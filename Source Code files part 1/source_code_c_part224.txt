type of network connectivity is
        present. The possible values are
            NETWORK_ALIVE_WAN
            NETWORK_ALIVE_LAN

    lpbAlive - Boolean indicating whether the network is alive or not.

    lpdwLastError - The out parameter that holds the error code returned
        from GetLastError() when there is no network connectivity.

Return Value:

    RPC_S_OK, normally.

    RPC Error, if there is an RPC-related problem.

--*/
{
    DWORD dwNow;
    DWORD fNetNature;
    BOOL bNetAlive;
    BOOL bLanAlive;
    BOOL bWanAlive;
    DWORD dwWanLastError;
    DWORD dwLanLastError;
    DWORD dwNetState;

    //
    // Some basic argument checks
    //
    if (NULL == lpdwLastError)
        {
        return RPC_S_INVALID_ARG;
        }

    if (   (NULL == lpdwFlags)
        || (NULL == lpbAlive))
        {
        *lpdwLastError = ERROR_INVALID_PARAMETER;
        return RPC_S_OK;
        }


    *lpdwFlags = 0x0;
    *lpbAlive = FALSE;
    *lpdwLastError = ERROR_SUCCESS;

    dwNow = GetTickCount();
    fNetNature = 0x0;
    dwNetState = 0;
    bLanAlive = FALSE;
    bWanAlive = FALSE;
    bNetAlive = FALSE;

    SensPrintA(SENS_INFO, ("--------------------------------------------------------------\n"));

    SensPrintA(SENS_INFO, ("RPC_IsNetworkAlive() - Current Statistics"
               "\n\tLAN State (%s), LAN (%d sec),"
               "\n\tWAN State (%s) WAN Time (%d sec)\n",
               gdwLANState ? "TRUE" : "FALSE",
               (dwNow - gdwLastLANTime)/1000,
               gdwWANState ? "TRUE" : "FALSE",
               (dwNow - gdwLastWANTime)/1000)
               );

#if defined(AOL_PLATFORM)
    SensPrintA(SENS_INFO, (""
               "\n\tAOL State (%s) AOL Time (%d sec)\n",
               gdwAOLState ? "TRUE" : "FALSE",
               (dwNow - gdwLastWANTime)/1000));
#endif // AOL_PLATFORM


    //
    // First, get information about the WAN
    //
    if ((dwNow - gdwLastWANTime) > MAX_WAN_INTERVAL)
        {
        SensPrintA(SENS_INFO, ("WAN State information expired. Trying again.\n"));

        // WAN state is stale, refresh it.
        bWanAlive = EvaluateWanConnectivity(&dwWanLastError);

        if (bWanAlive)
            {
            fNetNature |= NETWORK_ALIVE_WAN;
            bNetAlive = TRUE;
            }
        else
            {
            *lpdwLastError = MapLastError(dwWanLastError);
            }
        }
    else
        {
        // Return the WAN state.
        if (gdwWANState)
            {
            fNetNature |= NETWORK_ALIVE_WAN;
            bNetAlive = TRUE;
            bWanAlive = TRUE;
            }
        }

#if defined(AOL_PLATFORM)
    if (bWanAlive && gdwAOLState)
        {
        fNetNature |= NETWORK_ALIVE_AOL;
        }
#endif // AOL_PLATFORM

    //
    // If we can determine both types of connectivity at this stage, return.
    //
    if (   ((dwNow - gdwLastLANTime) <= MAX_LAN_INTERVAL)
        && (gdwLANState == TRUE))
        {
        fNetNature |= NETWORK_ALIVE_LAN;
        bNetAlive = TRUE;

        *lpdwFlags = fNetNature;
        *lpbAlive = bNetAlive;
        *lpdwLastError = ERROR_SUCCESS;

        SensPrintA(SENS_INFO, ("--------------------------------------------------------------\n"));

        return (RPC_S_OK);
        }

    //
    // One of the following is TRUE at this stage.
    //
    // a. Information about LAN is stale.
    // b. Information about LAN is current but there is no LAN connectivity.
    //    So, we go and check for it again.
    //

    if (gdwLANState == FALSE)
        {
        SensPrintA(SENS_INFO, ("LAN State either stale or there is no connectivity. Trying again.\n"));
        }
    else
        {
        SensPrintA(SENS_INFO, ("LAN State information expired. Trying again.\n"));
        }

    bLanAlive = EvaluateLanConnectivity(&dwLanLastError);
    if (bLanAlive)
        {
        fNetNature |= NETWORK_ALIVE_LAN;
        bNetAlive = TRUE;
        }
    else
        {
        *lpdwLastError = MapLastError(dwLanLastError);
        }

    *lpdwFlags = fNetNature;
    *lpbAlive = bNetAlive;

    if (bNetAlive)
        {
        *lpdwLastError = ERROR_SUCCESS;
        }

    SensPrintA(SENS_INFO, ("--------------------------------------------------------------\n"));

    return (RPC_S_OK);
}




error_status_t
RPC_IsDestinationReachableW(
    IN handle_t h,
    IN wchar_t * lpszDestination,
    IN OUT LPQOCINFO lpQOCInfo,
    OUT LPBOOL lpbReachable,
    OUT LPDWORD lpdwLastError
    )
/*++

Routine Description:

    Check to see if the given destination is reachable. If so, return Quality
    Of Connection (QOC) information, if necessary.

Arguments:

    hRpc - The RPC Binding handle.

    lpszDestination - The destination whose reachability is of interest.

    lpQOCInfo - Pointer to a buffer that will receive Quality of Connection
        (QOC) Information. Can be NULL if QOC is not desired.

    lpbReachable - Boolean indicating whether the destination is reachable
        or not.

    lpdwLastError - The out parameter that holds the error code returned
        from GetLastError() when the destination is not reachable.

Notes:

    This function does nothing on Win9x platforms. It should never be called on Win9x
    platforms.

Return Value:

    RPC_S_OK, normally.

    RPC Error, if there is an RPC-related problem.

--*/
{
    BOOL bPingStatus;
    BOOL bFound;
    DWORD dwStatus;
    DWORD dwIpAddress;
    DWORD dwReachGLE;
    ULONG ulRTT;
    size_t uiLength;

    //
    // Some basic argument checks
    //
    if (NULL == lpdwLastError)
        {
        return RPC_S_INVALID_ARG;
        }

    if (   (NULL == lpszDestination)
        || (NULL == lpbReachable))
        {
        // Not likely.
        *lpdwLastError = ERROR_INVALID_PARAMETER;
        return RPC_S_OK;
        }

    uiLength = wcslen(lpszDestination);
    if (   (uiLength > MAX_DESTINATION_LENGTH)
        || (uiLength == 0))
        {
        *lpbReachable = FALSE;
        *lpdwLastError = ERROR_INVALID_PARAMETER;
        return RPC_S_OK;
        }

    *lpdwLastError = ERROR_SUCCESS;
    *lpbReachable = FALSE;

    ulRTT = 0;
    dwStatus = 0;
    dwIpAddress = 0;
    dwReachGLE = ERROR_SUCCESS;
    bPingStatus = FALSE;
    bFound = FALSE;

    SensPrintA(SENS_INFO, ("--------------------------------------------------------------\n"));

    SensPrint(SENS_INFO, (SENS_STRING("RPC_IsDestinationReachableW(%s, 0x%x) called.\n"),
              lpszDestination, lpQOCInfo));

    dwStatus = ResolveName(lpszDestination, &dwIpAddress);

    if (dwStatus)
        {
        *lpdwLastError = MapLastError(dwStatus);
        *lpbReachable = FALSE;

        SensPrint(SENS_INFO, (SENS_STRING("The Destination %s cannot be resolved - %d\n"),
                  lpszDestination, dwStatus));
        SensPrintA(SENS_INFO, ("--------------------------------------------------------------\n"));

        return RPC_S_OK;
        }

    SensPrint(SENS_INFO, (SENS_STRING("Destination \"%s\" is resolved as 0x%x\n"),
              lpszDestination, dwIpAddress));

    bFound = CheckForReachability(
                dwIpAddress,
                lpQOCInfo,
                &dwReachGLE
                );

    SensPrintA(SENS_INFO, ("--------------------------------------------------------------\n"));

    *lpbReachable = bFound;
    *lpdwLastError = MapLastError(dwReachGLE);

    return RPC_S_OK;
}




error_status_t
RPC_IsDestinationReachableA(
    IN handle_t h,
    IN char * lpszDestination,
    IN OUT LPQOCINFO lpQOCInfo,
    OUT LPBOOL lpbReachable,
    OUT LPDWORD lpdwLastError
    )
/*++

Routine Description:

    Check to see if the given destination is reachable. If so, return Quality
    Of Connection (QOC) information, if necessary.

Arguments:

    hRpc - The RPC Binding handle.

    lpszDestination - The destination whose reachability is of interest.

    lpQOCInfo - Pointer to a buffer that will receive Quality of Connection
        (QOC) Information. Can be NULL if QOC is not desired.

    lpbReachable - Boolean indicating whether the destination is reachable
        or not.

    lpdwLastError - The out parameter that holds the error code returned
        from GetLastError() when the destination is not reachable.

Notes:

    This function does nothing on NT platforms. It should never be called on NT
    platforms.

Return Value:

    RPC_S_OK, normally.

    RPC Error, if there is an RPC-related problem.

--*/
{
    BOOL bPingStatus;
    BOOL bFound;
    DWORD dwStatus;
    DWORD dwIpAddress;
    DWORD dwReachGLE;
    ULONG ulRTT;
    size_t uiLength;

#if defined(SENS_CHICAGO)

    //
    // Some basic argument checks
    //
    if (NULL == lpdwLastError)
        {
        return RPC_S_INVALID_ARG;
        }

    if (   (NULL == lpszDestination)
        || (NULL == lpbReachable))
        {
        // Not likely.
        *lpdwLastError = ERROR_INVALID_PARAMETER;
        return RPC_S_OK;
        }

    uiLength = strlen(lpszDestination);
    if (   (uiLength > MAX_DESTINATION_LENGTH)
        || (uiLength == 0))
        {
        *lpbReachable = FALSE;
        *lpdwLastError = ERROR_INVALID_PARAMETER;
        return RPC_S_OK;
        }

    *lpdwLastError = ERROR_SUCCESS;
    *lpbReachable = FALSE;

    ulRTT = 0;
    dwStatus = 0;
    dwIpAddress = 0;
    dwReachGLE = ERROR_SUCCESS;
    bPingStatus = FALSE;
    bFound = FALSE;

    SensPrintA(SENS_INFO, ("--------------------------------------------------------------\n"));

    SensPrint(SENS_INFO, (SENS_STRING("RPC_IsDestinationReachableA(%s, 0x%x) called.\n"),
              lpszDestination, lpQOCInfo));

    dwStatus = ResolveName(lpszDestination, &dwIpAddress);

    if (dwStatus)
        {
        *lpdwLastError = MapLastError(dwStatus);
        *lpbReachable = FALSE;

        SensPrint(SENS_INFO, (SENS_STRING("The Destination %s cannot be resolved - %d\n"),
                  lpszDestination, dwStatus));
        SensPrintA(SENS_INFO, ("--------------------------------------------------------------\n"));

        return RPC_S_OK;
        }

    SensPrint(SENS_INFO, (SENS_STRING("Destination \"%s\" is resolved as 0x%x\n"),
              lpszDestination, dwIpAddress));

    bFound = CheckForReachability(
                dwIpAddress,
                lpQOCInfo,
                &dwReachGLE
                );

    SensPrintA(SENS_INFO, ("--------------------------------------------------------------\n"));

    *lpbReachable = bFound;
    *lpdwLastError = MapLastError(dwReachGLE);

#endif // SENS_CHICAGO

    return RPC_S_OK;
}




error_status_t
RPC_SensNotifyWinlogonEvent(
    handle_t h,
    PSENS_NOTIFY_WINLOGON pEvent
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    SENSEVENT_WINLOGON Data;
    RPC_STATUS status;

    switch (pEvent->eType)
        {
        case SENS_NOTIFY_WINLOGON_LOGON:
            Data.eType = SENS_EVENT_LOGON;
            break;

        case SENS_NOTIFY_WINLOGON_LOGOFF:
            Data.eType = SENS_EVENT_LOGOFF;
            break;

        case SENS_NOTIFY_WINLOGON_STARTSHELL:
            Data.eType = SENS_EVENT_STARTSHELL;
            break;

        case SENS_NOTIFY_WINLOGON_POSTSHELL:
            Data.eType = SENS_EVENT_POSTSHELL;
            break;

        case SENS_NOTIFY_WINLOGON_SESSION_DISCONNECT:
            Data.eType = SENS_EVENT_SESSION_DISCONNECT;
            break;

        case SENS_NOTIFY_WINLOGON_SESSION_RECONNECT:
            Data.eType = SENS_EVENT_SESSION_RECONNECT;
            break;

        case SENS_NOTIFY_WINLOGON_LOCK:

            // If already locked, there is nothing to do.
            if (TRUE == gdwLocked)
                {
                return RPC_S_OK;
                }

            // Update info in cache.
            gdwLocked = TRUE;
            UpdateSensCache(LOCK);

            Data.eType = SENS_EVENT_LOCK;
            break;

        case SENS_NOTIFY_WINLOGON_UNLOCK:

            // If already unlocked, there is nothing to do.
            if (FALSE == gdwLocked)
                {
                return RPC_S_OK;
                }

            // Update info in cache.
            gdwLocked = FALSE;
            UpdateSensCache(LOCK);


            Data.eType = SENS_EVENT_UNLOCK;
            break;

        case SENS_NOTIFY_WINLOGON_STARTSCREENSAVER:
            Data.eType = SENS_EVENT_STARTSCREENSAVER;
            break;

        case SENS_NOTIFY_WINLOGON_STOPSCREENSAVER:
            Data.eType = SENS_EVENT_STOPSCREENSAVER;
            break;

        default:
            SensPrintA(SENS_WARN, ("BOGUS WINLOGON EVENT\n"));
            ASSERT(0 && "BOGUS WINLOGON EVENT");
            return RPC_S_OK;
        }

    memcpy(&Data.Info, &pEvent->Info, sizeof(WINLOGON_INFO));

    //
    // PERFORMANCE NOTE:
    //
    //  o We want the Logoff event to be synchronous. That is, until all
    //    the subscribers to this event are done handling this event,
    //    System Logoff should not occur.
    //  o As of today, LCE fires events to the subscribers on the publishers
    //    thread. If we fire on a threadpool thread, it will release the
    //    publisher thread which will go and allow System Logoff to continue.
    //  o This has performance implications. We need to make sure that we
    //    don't impact System Logoff time when there are no subscriptions
    //    to this event.
    //

    if (SENS_EVENT_LOGOFF != Data.eType)
        {
        // Queue workitem to threadpool
        SensFireEvent(&Data);
        }
    else
        {
        PVOID pAllocatedData;

        pAllocatedData = AllocateEventData(&Data);
        if (NULL == pAllocatedData)
            {
            SensPrintA(SENS_ERR, ("RPC_NotifyWinlogonEvent(): Failed to allocate Event Data!\n"));
            return (RPC_S_OUT_OF_MEMORY);
            }

        // Synchronously call LCE and then free allocated Data.
        SensFireEventHelper(pAllocatedData);
        }

    return (RPC_S_OK);
}




error_status_t
RPC_SensNotifyRasEvent(
    handle_t h,
    PSENS_NOTIFY_RAS pEvent
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    DWORD dwIgnore;
    SENSEVENT_RAS Data;

    switch (pEvent->eType)
        {
        case SENS_NOTIFY_RAS_STARTED:
            Data.eType = SENS_EVENT_RAS_STARTED;
            break;

        case SENS_NOTIFY_RAS_STOPPED:
            Data.eType = SENS_EVENT_RAS_STOPPED;
            break;

        case SENS_NOTIFY_RAS_CONNECT:
            Data.eType = SENS_EVENT_RAS_CONNECT;
            break;

        case SENS_NOTIFY_RAS_DISCONNECT:
            Data.eType = SENS_EVENT_RAS_DISCONNECT;
            break;

        case SENS_NOTIFY_RAS_DISCONNECT_PENDING:
            Data.eType = SENS_EVENT_RAS_DISCONNECT_PENDING;
            break;

        default:
            SensPrintA(SENS_WARN, ("\t| BOGUS RAS EVENT - Type is %d\n", pEvent->eType));
            return RPC_S_OK;
        }

    Data.hConnection = pEvent->hConnection;

    SensFireEvent(&Data);

    EvaluateConnectivity(TYPE_WAN);

    return (RPC_S_OK);
}




error_status_t
RPC_SensNotifyNetconEvent(
    handle_t h,
    PSENS_NOTIFY_NETCON_P pEvent
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    SENSEVENT_LAN Data;

    switch (pEvent->eType)
        {
        case SENS_NOTIFY_LAN_CONNECT:
            Data.eType = SENS_EVENT_LAN_CONNECT;
            break;

        case SENS_NOTIFY_LAN_DISCONNECT:
            Data.eType = SENS_EVENT_LAN_DISCONNECT;
            break;

        default:
            SensPrintA(SENS_WARN, ("\t| BOGUS LAN EVENT - Type is %d\n", pEvent->eType));
            return RPC_S_OK;
        }

    Data.Name = pEvent->Name;
    Data.Status = pEvent->Status;
    Data.Type = pEvent->Type;

    // Force a recalculation of LAN Connectivity
    gdwLastLANTime -= (MAX_LAN_INTERVAL + 1);

    SensFireEvent(&Data);

    EvaluateConnectivity(TYPE_LAN);

    return (RPC_S_OK);
}




DWORD
MapLastError(
    DWORD dwInGLE
    )
/*++

Routine Description:

    This rountine maps the GLEs returned by the SENS Connecitivity engine to
    GLEs that describe the failure of the SENS APIs more accurately.

Arguments:

    dwInGLE - The GLE that needs to be mapped

Return Value:

    The mapped (and better) GLE.

--*/
{
    DWORD dwOutGLE;

    switch (dwInGLE)
        {
        //
        // When IP stack is not present, we typically get these errors.
        //
        case ERROR_INVALID_FUNCTION:
        case ERROR_NOT_SUPPORTED:
            dwOutGLE = ERROR_NO_NETWORK;
            break;

        //
        // No mapping by default.
        //
        default:
            dwOutGLE = dwInGLE;
            break;

        } // switch

    return dwOutGLE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\senssvc\cache.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    cache.cxx

Abstract:

    Code to create, destroy and manipulate SENS cache. Initially, it
    contains system connectivity state.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          2/8/1999         Start.

--*/


#include <precomp.hxx>


//
// Globals
//

HANDLE          ghSensFileMap;
PSENS_CACHE     gpSensCache;



BOOL
CreateCachePermissions(
    PSECURITY_ATTRIBUTES psa,
    PSECURITY_DESCRIPTOR psd,
    PACL *ppOutAcl
    )
/*++

Routine Description:

    Create security attributes for SENS Cache. It has following permissions:
        o Everyone    - READ
        o LocalSystem - READ & WRITE

Arguments:

    psa - Pointer to a security attributes structure.

    psd - Pointer to a security descriptor structure.

    pOutAcl - Pointer to an ACL. Needs to be cleaned when the return
        value is TRUE. Should be cleaned up on failure.

Notes:

    This code should work on NT4 also.

Return Value:

    TRUE, if successful.

    FALSE, otherwise

--*/
{
    BOOL bRetVal;
    int cbAcl;
    PACL pAcl;
    PSID pWorldSid;
    PSID pLocalSystemSid;
    SID_IDENTIFIER_AUTHORITY WorldAuthority = SECURITY_WORLD_SID_AUTHORITY;

    bRetVal = FALSE;
    *ppOutAcl = NULL;
    pAcl = NULL;
    pWorldSid = NULL;
    pLocalSystemSid = (PSID)&LocalSystem;

    //
    // Allocate WorldSid
    //
    bRetVal = AllocateAndInitializeSid(
                  &WorldAuthority,      // Pointer to identifier authority
                  1,                    // Count of subauthority
                  SECURITY_WORLD_RID,   // Subauthority 0
                  0,                    // Subauthority 1
                  0,                    // Subauthority 2
                  0,                    // Subauthority 3
                  0,                    // Subauthority 4
                  0,                    // Subauthority 5
                  0,                    // Subauthority 6
                  0,                    // Subauthority 7
                  &pWorldSid            // pointer to pointer to SID
                  );
    if (FALSE == bRetVal)
        {
        SensPrintA(SENS_ERR, ("CreateCachePermissions(): AllocateAndInitiali"
                  "zeSid(World) failed with %d.\n", GetLastError()));
        goto Cleanup;
        }

    ASSERT(RtlValidSid(pLocalSystemSid));

    //
    // Create the ACL with the desired ACEs
    //

    // Calculate the length of the required ACL buffer with 2 ACEs.
    cbAcl =   sizeof (ACL)
            + 2 * sizeof (ACCESS_ALLOWED_ACE)
            + GetLengthSid(pWorldSid)
            + GetLengthSid(pLocalSystemSid);

    // Allocate the ACL buffer.
    pAcl = (PACL) new char[cbAcl];
    if (NULL == pAcl)
        {
        SensPrintA(SENS_ERR, ("CreateCachePermissions(): Failed to allocate"
                  "an ACL.\n"));
        goto Cleanup;
        }

    // Initialize the ACL.
    bRetVal = InitializeAcl(
                  pAcl,             // Pointer to the ACL
                  cbAcl,            // Size of ACL
                  ACL_REVISION      // Revision level of ACL
                  );
    if (FALSE == bRetVal)
        {
        SensPrintA(SENS_ERR, ("CreateCachePermissions(): InitializeAcl() "
                  "failed with %d.\n", GetLastError()));
        goto Cleanup;
        }

    // Add ACE with FILE_MAP_READ for Everyone
    bRetVal = AddAccessAllowedAce(
                  pAcl,             // Pointer to the ACL
                  ACL_REVISION,     // ACL revision level
                  FILE_MAP_READ,    // Access Mask
                  pWorldSid         // Pointer to SID
                  );
    if (FALSE == bRetVal)
        {
        SensPrintA(SENS_ERR, ("CreateCachePermissions(): AddAccessAllowedAce()"
                  " failed with %d.\n", GetLastError()));
        goto Cleanup;
        }

    // Add ACE with FILE_MAP_WRITE for LocalSystem
    bRetVal = AddAccessAllowedAce(
                  pAcl,             // Pointer to the ACL
                  ACL_REVISION,     // ACL revision level
                  FILE_MAP_WRITE,   // Access Mask
                  pLocalSystemSid   // Pointer to SID
                  );
    if (FALSE == bRetVal)
        {
        SensPrintA(SENS_ERR, ("CreateCachePermissions(): AddAccessAllowedAce()"
                  " failed with %d.\n", GetLastError()));
        goto Cleanup;
        }

    // Initialize Security Descriptor.
    bRetVal = InitializeSecurityDescriptor(
                  psd,                          // Pointer to SD
                  SECURITY_DESCRIPTOR_REVISION  // SD revision
                  );
    if (FALSE == bRetVal)
        {
        SensPrintA(SENS_ERR, ("CreateCachePermissions(): "
                   "InitializeSecurityDescriptor() failed with a GLE of %d\n",
                   GetLastError()));
        goto Cleanup;
        }

    // Set the Dacl.
    bRetVal = SetSecurityDescriptorDacl(
                  psd,              // Security Descriptor
                  TRUE,             // Dacl present
                  pAcl,             // The Dacl
                  FALSE             // Not defaulted
                  );
    if (FALSE == bRetVal)
        {
        SensPrintA(SENS_ERR, ("CreateCachePermissions(): "
                   "SetSecurityDescriptorDacl() failed with a GLE of %d\n",
                   GetLastError()));
        goto Cleanup;
        }

    psa->nLength = sizeof(SECURITY_ATTRIBUTES);
    psa->lpSecurityDescriptor = psd;
    psa->bInheritHandle = FALSE;

    bRetVal = TRUE;

Cleanup:
    //
    // Cleanup
    //
    if (pWorldSid)
        {
        FreeSid(pWorldSid);
        }
    
    //
    // On failure, we clean the ACL up. On success, the caller cleans
    // it up after using it.
    //
    if (FALSE == bRetVal)
        {
        if (pAcl)
            {
            delete pAcl;
            }
        }
    else
        {
        *ppOutAcl = pAcl;
        }

    return bRetVal;
}


BOOL
CreateSensCache(
    void
    )
/*++

Routine Description:

    Create a cache for information maintained by SENS.

Arguments:

    None.

Return Value:

    TRUE, if successful.

    FALSE, otherwise.

--*/
{
    BOOL bRetVal;

    SECURITY_DESCRIPTOR sd;
    SECURITY_ATTRIBUTES sa, *psa;
    PACL pAcl;

    bRetVal = CreateCachePermissions(&sa, &sd, &pAcl);
    if (FALSE == bRetVal)
        {
        SensPrintA(SENS_ERR, ("CreateSensCache(): CreateCachePermissions() "
                   "failed with a GLE of %d\n", GetLastError()));
        goto Cleanup;
        }

    psa = &sa;

    //
    // First, create a file mapping object
    //
    ghSensFileMap = CreateFileMapping(
                        INVALID_HANDLE_VALUE, // Handle of file to map
                        psa,                  // Optional security attributes
                        PAGE_READWRITE,       // Protection for mapping object
                        0,                    // High-order 32 bits of size
                        SENS_CACHE_SIZE,      // Low-order 32 bits of size
                        SENS_CACHE_NAME       // Name of the file mapping object
                        );

    // Free Acl.
    delete pAcl;

    if (NULL == ghSensFileMap)
        {
        SensPrintA(SENS_ERR, ("CreateSensCache(): CreateFileMapping() failed "
                   "with a GLE of %d\n", GetLastError()));
        goto Cleanup;
        }
    else
    if (GetLastError() == ERROR_ALREADY_EXISTS)
        {
        SensPrintA(SENS_ERR, ("CreateSensCache(): File Mapping exists!\n"));
        }

    //
    // Now, map a view of the file into the address space
    //
    gpSensCache = (PSENS_CACHE) MapViewOfFile(
                      ghSensFileMap,    // Map file object
                      FILE_MAP_WRITE,   // Access mode
                      0,                // High-order 32 bits of file offset
                      0,                // Low-order 32 bits of file offset
                      0                 // Number of bytes to map
                      );
    if (NULL == gpSensCache)
        {
        SensPrintA(SENS_ERR, ("CreateSensCache(): MapViewOfFile() failed with "
                   "a GLE of %d\n", GetLastError()));
        goto Cleanup;
        }

    //
    // Initialize the cache.
    //
    memset(gpSensCache, 0x0, sizeof(SENS_CACHE));
    gpSensCache->dwCacheVer  = SENS_CACHE_VERSION;
    gpSensCache->dwCacheSize = sizeof(SENS_CACHE);
    gpSensCache->dwCacheInitTime = GetTickCount();

    bRetVal = TRUE;

    SensPrintA(SENS_INFO, ("[%d] CreateSensCache(): Cache initialized\n",
               GetTickCount(), gpSensCache->dwCacheInitTime));

    return bRetVal;

Cleanup:
    //
    // Cleanup
    //
    if (ghSensFileMap != NULL)
        {
        CloseHandle(ghSensFileMap);

        ghSensFileMap = NULL;
        gpSensCache = NULL;
        }

    return bRetVal;
}





void
DeleteSensCache(
    void
    )
/*++

Routine Description:

    Cleanup the previously create SENS cache.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if (gpSensCache != NULL)
        {
        BOOL bStatus = FALSE;

        ASSERT(ghSensFileMap != NULL);

        bStatus = UnmapViewOfFile((LPVOID) gpSensCache);
        SensPrintA(SENS_INFO, ("DeleteSensCache(): UnmapViewOfFile() returned"
                   " 0x%x with a GLE of %d\n.", bStatus, GetLastError()));
        ASSERT(bStatus != FALSE);

		gpSensCache = 0;
        }

    if (ghSensFileMap != NULL)
        {
        CloseHandle(ghSensFileMap);
		ghSensFileMap = 0;
        }

    SensPrintA(SENS_INFO, ("DeleteSensCache(): Successfully cleaned up SENS"
               " Cache.\n"));
    return;
}




void
UpdateSensCache(
    CACHE_TYPE Type
    )
/*++

Routine Description:

    Updates the requested part of the SENS cache.

Arguments:

    Type - That part of the cache that needs to be updated.

Return Value:

    None.

--*/
{
    //
    // Make sure Cache is initialized.
    //
    if (NULL == gpSensCache)
        {
        return;
        }

    switch (Type)
        {

        case LAN:
            gpSensCache->dwLANState = gdwLANState;
            gpSensCache->dwLastLANTime = gdwLastLANTime;
            UpdateSensNetworkCache();
            break;

        case WAN:
            gpSensCache->dwWANState = gdwWANState;
            gpSensCache->dwLastWANTime = gdwLastWANTime;
            UpdateSensNetworkCache();
            break;

#if defined(AOL_PLATFORM)

        case AOL:
            gpSensCache->dwAOLState = gdwAOLState;
            // We don't update the Network cache when AOL
            // connectivity is updated.
            break;

#endif // (AOL_PLATFORM)

        case LOCK:
            gpSensCache->dwLocked = gdwLocked;
            SensPrintA(SENS_INFO, ("CACHE: Updated Locked State to %d.\n", gpSensCache->dwLocked));
            break;

        case INVALID:
        default:
            SensPrintA(SENS_ERR, ("UpdateSensCache(): Received an invalid Type"
                       " (0x%x)\n", Type));
            ASSERT(0);
            break;

        } // switch

    SensPrintA(SENS_INFO, ("UpdateSensCache(): Succeeded.\n"));
}




inline void
UpdateSensNetworkCache(
    void
    )
/*++

    Convenient Macro to update the whole Network state.

--*/
{
    DWORD dwNetState;

    dwNetState = 0x0;

    RequestSensLock();

    if (gdwLANState)
        {
        dwNetState |= NETWORK_ALIVE_LAN;
        }

    if (gdwWANState)
        {
        dwNetState |= NETWORK_ALIVE_WAN;
        }

#if defined(AOL_PLATFORM)

    if (gdwAOLState)
        {
        dwNetState |= NETWORK_ALIVE_AOL;
        }

#endif // AOL_PLATFORM

    gpSensCache->dwLastUpdateState = dwNetState;

    gpSensCache->dwLastUpdateTime = GetTickCount();

    ReleaseSensLock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\senssvc\cfacchng.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    cfacchng.cxx

Abstract:

    Implements the Class Factory for the SENS IEventObjectChange Subscriber.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          11/17/1997         Start.

--*/

#include <precomp.hxx>


//
// Global counts for the number of objects in the server and the number of
// locks.
//

ULONG g_cCFObj    = 0L;
ULONG g_cCFLock   = 0L;


//
// Constructor and Destructor
//
CIEventObjectChangeCF::CIEventObjectChangeCF(
    void
    ) : m_cRef(1L)
{

}

CIEventObjectChangeCF::~CIEventObjectChangeCF(
    void
    )
{
    // Empty Destructor.
}



//
// QI
//
STDMETHODIMP
CIEventObjectChangeCF::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    HRESULT hr = S_OK;

    *ppv = NULL; // To handle failure cases

    // IUnknown or IClassFactory
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory))
        {
        *ppv = (LPUNKNOWN) this;
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    if (NULL != *ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        }

    return hr;
}



//
// AddRef
//
STDMETHODIMP_(ULONG)
CIEventObjectChangeCF::AddRef(
    void
    )
{
    return InterlockedIncrement((PLONG) &m_cRef);
}


//
// Release
//
STDMETHODIMP_(ULONG)
CIEventObjectChangeCF::Release(
    void
    )
{
    ULONG cRefT;

    cRefT = InterlockedDecrement((PLONG) &m_cRef);

    if (0 == m_cRef)
        {
        // Invoke the callback function.
        delete this;
        }

    return cRefT;
}



//
// CreateInstance
//
STDMETHODIMP
CIEventObjectChangeCF::CreateInstance(
    LPUNKNOWN pUnkOuter,
    REFIID riid,
    LPVOID *ppvObj
    )
{
    LPCIMPIEVENTOBJECTCHANGE pObjChange;
    HRESULT hr;

    DebugTraceGuid("CIEventObjectChangeCF:CreateInstance()", riid);

    hr = E_OUTOFMEMORY;
    *ppvObj = NULL;
    pObjChange = NULL;

    //
    // Return the appropriate interface pointer.
    //
    if (IsEqualIID(riid, IID_IEventObjectChange) ||
        IsEqualIID(riid, IID_IUnknown))
        {
        SensPrintA(SENS_INFO, ("\t| ClassFactory::CreateInstance(IEventObjectChange)\n"));
        pObjChange = new CImpIEventObjectChange();
        if (NULL != pObjChange)
            {
            hr = pObjChange->QueryInterface(riid, ppvObj);
            SensPrintA(SENS_INFO, ("\t| QI on CImpIEventObjectChange returned 0x%x\n", hr));
            pObjChange->Release();  // Unneeded now, ppvObj, if non-NULL, has a ref
            }
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    if (NULL != *ppvObj)
        {
        InterlockedIncrement((PLONG) &g_cCFObj);
        }

    SensPrintA(SENS_INFO, ("\t| Returning 0x%x from CF:CreateInstance\n", hr));

    return hr;
}



//
// LockServer
//
STDMETHODIMP
CIEventObjectChangeCF::LockServer(
    BOOL fLock
    )
{
    if (fLock)
        {
        InterlockedIncrement((PLONG) &g_cCFLock);
        }
    else
        {
        InterlockedDecrement((PLONG) &g_cCFLock);

        InterlockedIncrement((PLONG) &g_cCFObj);
        }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\senssvc\cpubfilt.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    cpubfilt.cxx

Abstract:

    This file contains the implementation of the PublisherFilter
    for the ISensNetwork interface exposed by SENS.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          1/26/1998         Start.

--*/



#include <precomp.hxx>


//
// Globals
//
LONG g_cFilterObj;      // Count of active components
LONG g_cFilterLock;     // Count of Server locks





//
// Constructors and Destructors
//
CImpISensNetworkFilter::CImpISensNetworkFilter(
    void
    ) : m_cRef(1L), // Add a reference.
        m_pConnectionMade_Enum(NULL),
        m_pConnectionMadeNoQOC_Enum(NULL),
        m_pConnectionLost_Enum(NULL),
        m_pDestinationReachable_Enum(NULL),
        m_pDestinationReachableNoQOC_Enum(NULL),
        m_pConnectionMade_FiringControl(NULL),
        m_pConnectionMadeNoQOC_FiringControl(NULL),
        m_pConnectionLost_FiringControl(NULL),
        m_pDestinationReachable_FiringControl(NULL),
        m_pDestinationReachableNoQOC_FiringControl(NULL)
{
    InterlockedIncrement(&g_cFilterObj);
}

CImpISensNetworkFilter::~CImpISensNetworkFilter(
    void
    )
{
    InterlockedDecrement(&g_cFilterObj);

    //
    // Release all references that we added to IEnumEventObject pointers,
    // if any.
    //
    if (m_pConnectionMade_Enum)
        {
        m_pConnectionMade_Enum->Release();
        }

    if (m_pConnectionMadeNoQOC_Enum)
        {
        m_pConnectionMadeNoQOC_Enum->Release();
        }

    if (m_pConnectionLost_Enum)
        {
        m_pConnectionLost_Enum->Release();
        }

    if (m_pDestinationReachable_Enum)
        {
        m_pDestinationReachable_Enum->Release();
        }

    if (m_pDestinationReachableNoQOC_Enum)
        {
        m_pDestinationReachableNoQOC_Enum->Release();
        }

    //
    // Release all references that we added to IFiringControl pointers,
    // if any (and there shouldn't be any).
    //
    if (m_pConnectionMade_FiringControl)
        {
        m_pConnectionMade_FiringControl->Release();
        }

    if (m_pConnectionMadeNoQOC_FiringControl)
        {
        m_pConnectionMadeNoQOC_FiringControl->Release();
        }

    if (m_pConnectionLost_FiringControl)
        {
        m_pConnectionLost_FiringControl->Release();
        }

    if (m_pDestinationReachable_FiringControl)
        {
        m_pDestinationReachable_FiringControl->Release();
        }

    if (m_pDestinationReachableNoQOC_FiringControl)
        {
        m_pDestinationReachableNoQOC_FiringControl->Release();
        }
}




//
// Standard QueryInterface
//
STDMETHODIMP
CImpISensNetworkFilter::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    HRESULT hr;

    DebugTraceGuid("CImpISensNetworkFilter:QueryInterface()", riid);

    hr = S_OK;
    *ppv = NULL;

    // IUnknown
    if (IsEqualIID(riid, IID_IUnknown))
        {
        *ppv = (ISensNetwork *) this;
        }
    else
    // ISensNetwork
    if (IsEqualIID(riid, IID_ISensNetwork))
        {
        *ppv = (ISensNetwork *) this;
        }
    else
    // IPublisherFilter
    if (IsEqualIID(riid, IID_IPublisherFilter))
        {
        *ppv = (IPublisherFilter *) this;
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    if (NULL != *ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        }

    return hr;
}




//
// IDispatch member function implementations. These are dummy implementations
// as EventSystem never calls them.
//

STDMETHODIMP
CImpISensNetworkFilter::GetTypeInfoCount(
    UINT *pCountITypeInfo
    )
{
    return E_NOTIMPL;

}

STDMETHODIMP
CImpISensNetworkFilter::GetTypeInfo(
    UINT iTypeInfo,
    LCID lcid,
    ITypeInfo **ppITypeInfo
    )
{
    return E_NOTIMPL;
}

STDMETHODIMP
CImpISensNetworkFilter::GetIDsOfNames(
    REFIID riid,
    LPOLESTR *arrNames,
    UINT cNames,
    LCID lcid,
    DISPID *arrDispIDs)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CImpISensNetworkFilter::Invoke(
    DISPID dispID,
    REFIID riid,
    LCID lcid,
    WORD wFlags,
    DISPPARAMS *pDispParams,
    VARIANT *pvarResult,
    EXCEPINFO *pExecpInfo,
    UINT *puArgErr
    )
{
    return E_NOTIMPL;
}




//
// Standard AddRef and Release
//
STDMETHODIMP_(ULONG)
CImpISensNetworkFilter::AddRef(
    void
    )
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CImpISensNetworkFilter::Release(
    void
    )
{
    LONG cRefT;

    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensNetworkFilter::Release(m_cRef = %d) called.\n"), m_cRef));

    cRefT = InterlockedDecrement((PLONG) &m_cRef);

    if (0 == m_cRef)
        {
        delete this;
        }

    return cRefT;
}



//
// ISensNetwork Implementation.
//

STDMETHODIMP
CImpISensNetworkFilter::ConnectionMade(
    BSTR bstrConnection,
    ULONG ulType,
    LPSENS_QOCINFO lpQOCInfo
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensNetworkFilter::ConnectionMade() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrConnection - %s\n"), bstrConnection));
    SensPrint(SENS_INFO, (SENS_STRING("            ulType - 0x%x\n"), ulType));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));

    HRESULT hr = S_OK;
    ConnectionFilter filter(PROPERTY_CONNECTION_MADE_TYPE, ulType, hr);
    if (SUCCEEDED(hr))
        {
        hr = FilterAndFire(
                 filter,
                 m_pConnectionMade_Enum,
                 m_pConnectionMade_FiringControl
                 );
        }

    // We're done with this IFiringControl object.
    m_pConnectionMade_FiringControl->Release();
    m_pConnectionMade_FiringControl = NULL;

    return hr;
}


STDMETHODIMP
CImpISensNetworkFilter::ConnectionMadeNoQOCInfo(
    BSTR bstrConnection,
    ULONG ulType
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensNetworkFilter::ConnectionMadeNoQOCInfo() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrConnection - %s\n"), bstrConnection));
    SensPrint(SENS_INFO, (SENS_STRING("            ulType - 0x%x\n"), ulType));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));

    HRESULT hr = S_OK;
    ConnectionFilter filter(PROPERTY_CONNECTION_MADE_NOQOC_TYPE, ulType, hr);
    if (SUCCEEDED(hr))
        {
        hr = FilterAndFire(
                 filter,
                 m_pConnectionMadeNoQOC_Enum,
                 m_pConnectionMadeNoQOC_FiringControl
                 );
        }

    // We're done with this IFiringControl object.
    m_pConnectionMadeNoQOC_FiringControl->Release();
    m_pConnectionMadeNoQOC_FiringControl = NULL;

    return hr;
}


STDMETHODIMP
CImpISensNetworkFilter::ConnectionLost(
    BSTR bstrConnection,
    ULONG ulType
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensNetworkFilter::ConnectionLost() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrConnection - %s\n"), bstrConnection));
    SensPrint(SENS_INFO, (SENS_STRING("            ulType - 0x%x\n"), ulType));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));

    HRESULT hr = S_OK;
    ConnectionFilter filter(PROPERTY_CONNECTION_LOST_TYPE, ulType, hr);
    if (SUCCEEDED(hr))
        {
        hr = FilterAndFire(
                 filter,
                 m_pConnectionLost_Enum,
                 m_pConnectionLost_FiringControl
                 );
        }

    // We're done with this IFiringControl object.
    m_pConnectionLost_FiringControl->Release();
    m_pConnectionLost_FiringControl = NULL;

    return hr;
}


STDMETHODIMP
CImpISensNetworkFilter::DestinationReachable(
    BSTR bstrDestination,
    BSTR bstrConnection,
    ULONG ulType,
    LPSENS_QOCINFO lpQOCInfo
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensNetworkFilter::DestinationReachable() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("   bstrDestination - %s\n"), bstrDestination));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrConnection - %s\n"), bstrConnection));
    SensPrint(SENS_INFO, (SENS_STRING("            ulType - 0x%x\n"), ulType));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));

    HRESULT hr = S_OK;
    ReachabilityFilter filter(PROPERTY_DESTINATION, PROPERTY_DESTINATION_TYPE, bstrDestination, ulType, hr);
    if (SUCCEEDED(hr))
        {
        hr = FilterAndFire(
                 filter,
                 m_pDestinationReachable_Enum,
                 m_pDestinationReachable_FiringControl
                 );
        }

    // We're done with this IFiringControl object.
    m_pDestinationReachable_FiringControl->Release();
    m_pDestinationReachable_FiringControl = NULL;

    return hr;
}


STDMETHODIMP
CImpISensNetworkFilter::DestinationReachableNoQOCInfo(
    BSTR bstrDestination,
    BSTR bstrConnection,
    ULONG ulType
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensNetworkFilter::DestinationReachableNoQOCInfo() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("   bstrDestination - %s\n"), bstrDestination));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrConnection - %s\n"), bstrConnection));
    SensPrint(SENS_INFO, (SENS_STRING("            ulType - 0x%x\n"), ulType));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));


    HRESULT hr = S_OK;
    ReachabilityFilter filter(PROPERTY_DESTINATION_NOQOC, PROPERTY_DESTINATION_NOQOC_TYPE, bstrDestination, ulType, hr);
    if (SUCCEEDED(hr))
        {
        hr = FilterAndFire(
                 filter,
                 m_pDestinationReachableNoQOC_Enum,
                 m_pDestinationReachableNoQOC_FiringControl
                 );
        }

    // We're done with this IFiringControl object.
    m_pDestinationReachableNoQOC_FiringControl->Release();
    m_pDestinationReachableNoQOC_FiringControl = NULL;

    return hr;
}




//
// IPublisherFilter Implementation.
//
STDMETHODIMP
CImpISensNetworkFilter::Initialize(
    BSTR bstrMethodName,
    IDispatch* dispUserDefined
    )
{
    HRESULT hr = E_INVALIDARG;

    IEnumEventObject** ppEnum = NULL;
    if (wcscmp(bstrMethodName, CONNECTION_MADE_METHOD) == 0)
        {
        ppEnum = &m_pConnectionMade_Enum;
        }
    else
    if (wcscmp(bstrMethodName, CONNECTION_MADE_NOQOC_METHOD) == 0)
        {
        ppEnum = &m_pConnectionMadeNoQOC_Enum;
        }
    else
    if (wcscmp(bstrMethodName, CONNECTION_LOST_METHOD) == 0)
        {
        ppEnum = &m_pConnectionLost_Enum;
        }
    else
    if (wcscmp(bstrMethodName, DESTINATION_REACHABLE_METHOD) == 0)
        {
        ppEnum = &m_pDestinationReachable_Enum;
        }
    else
    if (wcscmp(bstrMethodName, DESTINATION_REACHABLE_NOQOC_METHOD) == 0)
        {
        ppEnum = &m_pDestinationReachableNoQOC_Enum;
        }

    if (ppEnum != NULL)
        {
        IEventControl* control = NULL;
        hr = dispUserDefined->QueryInterface(IID_IEventControl, (void**)&control);
        if (FAILED(hr))
            {
            return hr;
            }

        IEventObjectCollection* collection = NULL;
        hr = control->GetSubscriptions(bstrMethodName, NULL, NULL, &collection);
        if (SUCCEEDED(hr))
            {
            hr = collection->get_NewEnum(ppEnum);

            // Don't need the collection any more... just keep the enum
            collection->Release();
            }

        control->Release();
        }

        return hr;
}


STDMETHODIMP
CImpISensNetworkFilter::PrepareToFire(
    BSTR bstrMethodName,
    IFiringControl* pIFiringControl
    )
{
    HRESULT hr = E_INVALIDARG;

    IFiringControl** ppFiringControl = NULL;
    if (wcscmp(bstrMethodName, CONNECTION_MADE_METHOD) == 0)
        {
        ppFiringControl = &m_pConnectionMade_FiringControl;
        }
    else
    if (wcscmp(bstrMethodName, CONNECTION_MADE_NOQOC_METHOD) == 0)
        {
        ppFiringControl = &m_pConnectionMadeNoQOC_FiringControl;
        }
    else
    if (wcscmp(bstrMethodName, CONNECTION_LOST_METHOD) == 0)
        {
        ppFiringControl = &m_pConnectionLost_FiringControl;
        }
    else
    if (wcscmp(bstrMethodName, DESTINATION_REACHABLE_METHOD) == 0)
        {
        ppFiringControl = &m_pDestinationReachable_FiringControl;
        }
    else
    if (wcscmp(bstrMethodName, DESTINATION_REACHABLE_NOQOC_METHOD) == 0)
        {
        ppFiringControl = &m_pDestinationReachableNoQOC_FiringControl;
        }

    if (ppFiringControl != NULL)
        {
        *ppFiringControl = pIFiringControl;
        pIFiringControl->AddRef();
        hr = S_OK;
        }

    return hr;
}




//
// Filter helper implementations.
//


//
// ConnectionFilter implementation.
//

ConnectionFilter::ConnectionFilter(
    const wchar_t* connectionTypeProperty,
    ULONG connectionType,
    HRESULT& hr
    ) : m_connectionTypeProperty(SysAllocString(connectionTypeProperty)),
        m_connectionType(connectionType)
{
    if (m_connectionTypeProperty == NULL)
        {
        hr = E_OUTOFMEMORY;
        }
    else
        {
        hr = S_OK;
        }
}


ConnectionFilter::~ConnectionFilter(
    void
    )
{
    SysFreeString(m_connectionTypeProperty);
}


HRESULT
ConnectionFilter::CheckMatch(
    IEventSubscription* pSubscription
    ) const
{
    VARIANT value;
    VariantInit(&value);
    HRESULT hr = pSubscription->GetPublisherProperty(m_connectionTypeProperty, &value);

    if (hr == S_FALSE)
        {
        // If the property isn't present, consider it a successful match.
        hr = S_OK;
        }
    else
    if (hr == S_OK)
        {
        // If the property is there, it must match the incoming parameter value.
        ASSERT(value.vt == VT_UI4);
        SensPrintW(SENS_INFO, (SENS_BSTR("\t| Property %s has value 0x%x\n"), m_connectionTypeProperty, value.ulVal));
        hr = (m_connectionType == value.ulVal) ? S_OK : S_FALSE;
        }

    VariantClear(&value);

    return hr;
}



//
// ReachabilityFilter implementation
//

ReachabilityFilter::ReachabilityFilter(
    const wchar_t* destinationProperty,
    const wchar_t* destinationTypeProperty,
    BSTR destination,
    ULONG destinationType,
    HRESULT& hr
    ) : m_destinationProperty(SysAllocString(destinationProperty)),
        m_destinationTypeProperty(SysAllocString(destinationTypeProperty)),
        m_destination(destination),
        m_destinationType(destinationType)
{
    if (m_destinationProperty == NULL || m_destinationTypeProperty == NULL)
        {
        hr = E_OUTOFMEMORY;
        }
    else
        {
        hr = S_OK;
        }
}


ReachabilityFilter::~ReachabilityFilter(
    void
    )
{
    SysFreeString(m_destinationProperty);
    SysFreeString(m_destinationTypeProperty);
}


HRESULT
ReachabilityFilter::CheckMatch(
    IEventSubscription* pSubscription
    ) const
{
    HRESULT hr;

    // Check the destination property
    VARIANT value;
    VariantInit(&value);
    hr = pSubscription->GetPublisherProperty(m_destinationProperty, &value);

    if (hr == S_FALSE)
        {
        // If the property isn't present, consider it a successful match.
        hr = S_OK;
        SensPrintW(SENS_INFO, (SENS_BSTR("\t\t\t| Subscription (0x%x) has no %s Dest Property\n"), pSubscription, m_destinationProperty));
        }
    else
    if (hr == S_OK)
        {
        // If the property is there, it must match the incoming parameter value.
        ASSERT(value.vt == VT_BSTR);
        SensPrintW(SENS_INFO, (SENS_BSTR("\t\t\t| Property %s has value %s\n"), m_destinationProperty, value.bstrVal));
        hr = (wcscmp(m_destination, value.bstrVal) == 0) ? S_OK : S_FALSE;
        }

    VariantClear(&value);

    if (hr == S_OK)
        {
        // If we have a match so far, check the destination type property
        VARIANT value;
        VariantInit(&value);
        hr = pSubscription->GetPublisherProperty(m_destinationTypeProperty, &value);

        if (hr == S_FALSE)
            {
            // If the property isn't present, consider it a successful match.
            hr = S_OK;
            SensPrintW(SENS_INFO, (SENS_BSTR("\t\t\t| Subscription (0x%x) has no %s Type Property\n"), pSubscription, m_destinationTypeProperty));
            }
        else
        if (hr == S_OK)
            {
            // If the property is there, it must match the incoming parameter value.
            ASSERT(value.vt == VT_UI4);
            SensPrintW(SENS_INFO, (SENS_BSTR("\t\t\t| Property %s has value 0x%x\n"), m_destinationTypeProperty, value.ulVal));
            hr = (m_destinationType == value.ulVal) ? S_OK : S_FALSE;
            }

        VariantClear(&value);
        }

    return hr;
}




//
// Generic filter and fire method.
//
HRESULT
FilterAndFire(
    const Filter& filter,
    IEnumEventObject* enumerator,
    IFiringControl* firingControl
    )
{
    HRESULT hr;
    IEventSubscription* pSubscription = NULL;
    int i = 0;

    //
    // Reset the enum back to the start
    //
    hr = enumerator->Reset();

    //
    // Loop through all the candidate subscriptions and fire the ones
    // that match the filter criteria.
    //
    for (;;)
        {
        ULONG cCount = 1;

        hr = enumerator->Next(cCount, (IUnknown**)&pSubscription, &cCount);
        if (hr != S_OK || cCount != 1)
            {
            break;
            }

        SensPrintA(SENS_INFO, ("\t\t\t| ****** Count for 0x%x is %d\n", enumerator, ++i));

        hr = filter.CheckMatch(pSubscription);
        if (hr == S_OK)
            {
            SensPrintA(SENS_INFO, ("\t\t\t| FilterAndFire(0x%x): CheckMatch() succeeded\n", enumerator));
            firingControl->FireSubscription(pSubscription);
            }

        pSubscription->Release();
        pSubscription = NULL;
        }

    //
    // Cleanup, including any left-over stuff in case of premature exit from the loop.
    //
    if (pSubscription != NULL)
        {
        pSubscription->Release();
        }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\senssvc\csubchng.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    csubchng.cxx

Abstract:

    This file contains the implementation of the IEventObjectChange
    interface. We need to subscribe to this interface for publishing
    the DestinationReachable events of SENS's ISensNetwork interface.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          1/26/1998         Start.

--*/



#include <precomp.hxx>


//
// Globals
//
LONG g_cSubChangeObj;      // Count of active components
LONG g_cSubChangeLock;     // Count of Server locks
extern LIST    *gpReachList;



//
// Constructors and Destructors
//
CImpIEventObjectChange::CImpIEventObjectChange(
    void
    ) : m_cRef(1L) // Add a reference.
{
    InterlockedIncrement(&g_cSubChangeObj);
}

CImpIEventObjectChange::~CImpIEventObjectChange(
    void
    )
{
    InterlockedDecrement(&g_cSubChangeObj);
}




//
// Standard QueryInterface
//
STDMETHODIMP
CImpIEventObjectChange::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    HRESULT hr;

    DebugTraceGuid("CImpIEventObjectChange:QueryInterface()", riid);

    hr = S_OK;
    *ppv = NULL;

    // IUnknown
    if (IsEqualIID(riid, IID_IUnknown))
        {
        *ppv = (ISensNetwork *) this;
        }
    else
    // IEventObjectChange
    if (IsEqualIID(riid, IID_IEventObjectChange))
        {
        *ppv = (ISensNetwork *) this;
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    if (NULL != *ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        }

    return hr;
}




//
// Standard AddRef and Release
//
STDMETHODIMP_(ULONG)
CImpIEventObjectChange::AddRef(
    void
    )
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CImpIEventObjectChange::Release(
    void
    )
{
    LONG cRefT;

    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpIEventObjectChange::Release(m_cRef = %d) called.\n"), m_cRef));

    cRefT = InterlockedDecrement((PLONG) &m_cRef);

    if (0 == m_cRef)
        {
        delete this;
        }

    return cRefT;
}




//
// IEventObjectChange Implementation.
//

STDMETHODIMP
CImpIEventObjectChange::ChangedSubscription(
    EOC_ChangeType changeType,
    BSTR bstrSubscriptionID
    )
{
    HRESULT hr;
    NODE *pNode;
    DWORD dwStatus;
    BOOL bSuccess;
    BSTR bstrDestinationName;

    hr = S_OK;
    pNode = NULL;
    dwStatus = ERROR_SUCCESS;
    bSuccess = FALSE;
    bstrDestinationName = NULL;

    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpIEventObjectChange::ChangedSubscription() called\n\n")));
    SensPrint(SENS_INFO, (SENS_STRING("            ChangeType - %d\n"), changeType));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrSubscriptionID - %s\n"), bstrSubscriptionID));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));

    hr = GetDestinationNameFromSubscription(
              bstrSubscriptionID,
              &bstrDestinationName
              );
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("GetDestinationNameFromSubscription() returned 0x%x\n"), hr));
        if (HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION) == hr)
            {
            hr = S_OK;  // Implies we got a non-DestinationReachability subscription.
            }
        goto Cleanup;
        }
    else
    if (bstrDestinationName == NULL)
        {
        SensPrintW(SENS_WARN, (SENS_BSTR("Destination is <NULL> !\n")));
        goto Cleanup;
        }
    else
        {
        SensPrintW(SENS_INFO, (SENS_BSTR("Destination is %s\n"), bstrDestinationName));
        }

    //
    // Deal with the changed subscription appropriately.
    //
    switch (changeType)
        {
        case EOC_NewObject:
            {
            if (wcslen(bstrDestinationName) > MAX_DESTINATION_LENGTH)
                {
                SensPrintW(SENS_ERR, (SENS_BSTR("Destination %s is too long.\n"), bstrDestinationName));
                break;
                }

            gpReachList->InsertByDest(bstrDestinationName);
            StartReachabilityEngine();
            break;
            }

        case EOC_DeletedObject:
            // Delete the node from the reachability list.
            bSuccess = gpReachList->DeleteByDest(bstrDestinationName);
            break;

        case EOC_ModifiedObject:
        default:
            // Nothing to do.
            break;;
        }

Cleanup:
    //
    // Cleanup
    //
    if (bstrDestinationName)
        {
        ::SysFreeString(bstrDestinationName);
        }

    return hr;
}

STDMETHODIMP
CImpIEventObjectChange::ChangedEventClass(
    EOC_ChangeType changeType,
    BSTR bstrSubscriptionID
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpIEventObjectChange::ChangedEventClass() called\n\n")));
    SensPrint(SENS_INFO, (SENS_STRING("            ChangeType - %d\n"), changeType));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrSubscriptionID - %s\n"), bstrSubscriptionID));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));

    return S_OK;
}

STDMETHODIMP
CImpIEventObjectChange::ChangedPublisher(
    EOC_ChangeType changeType,
    BSTR bstrSubscriptionID
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpIEventObjectChange::ChangedPublisher() called\n\n")));
    SensPrint(SENS_INFO, (SENS_STRING("            ChangeType - %d\n"), changeType));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrSubscriptionID - %s\n"), bstrSubscriptionID));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));

    return S_OK;
}



HRESULT
GetDestinationNameFromSubscription(
    BSTR bstrSubscriptionID,
    BSTR *pbstrDestinationName
    )
{
    HRESULT             hr;
    int                 errorIndex;
    BSTR                bstrPropertyName;
    BSTR                bstrMethodName;
    VARIANT             variantPropertyValue;
    WCHAR               wszQuery[MAX_QUERY_SIZE];
    LPOLESTR            strDestinationName;
    IEventSystem        *pIEventSystem;
    IEventSubscription  *pIEventSubscription;
    IUnknown            *pIUnkQueryResult;

    hr = S_OK;
    errorIndex = 0;
    strDestinationName = NULL;
    bstrPropertyName = NULL;
    bstrMethodName = NULL;
    *pbstrDestinationName = NULL;
    pIEventSystem = NULL;
    pIEventSubscription = NULL;
    pIUnkQueryResult = NULL;


    // Get a new IEventSystem object to play with.
    hr = CoCreateInstance(
             CLSID_CEventSystem,
             NULL,
             CLSCTX_SERVER,
             IID_IEventSystem,
             (LPVOID *) &pIEventSystem
             );
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("GetDestinationNameFromSubscription(): failed to create ")
                  SENS_STRING("IEventSystem - hr = <%x>\n"), hr));
        goto Cleanup;
        }

    // Form the query
    StringCchCopy(wszQuery, MAX_QUERY_SIZE, SENS_BSTR("SubscriptionID="));
    hr = StringCchCat(wszQuery, MAX_QUERY_SIZE, bstrSubscriptionID);

    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("Unable to build query, subid too long: %ws"), bstrSubscriptionID));
        goto Cleanup;
        }

    hr = pIEventSystem->Query(
                            PROGID_EventSubscription,
                            wszQuery,
                            &errorIndex,
                            &pIUnkQueryResult
                            );
    if (hr != S_OK)
        {
        SensPrint(SENS_ERR, (SENS_STRING("GetDestinationNameFromSubscription(): failed to Query() ")
                  SENS_STRING("- hr = <%x>\n"), hr));
        goto Cleanup;
        }

    hr = pIUnkQueryResult->QueryInterface(
                               IID_IEventSubscription,
                               (LPVOID *) &pIEventSubscription
                               );
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("GetDestinationNameFromSubscription(): QI for IEventSubscription")
                  SENS_STRING(" failed - hr = <%x>\n"), hr));
        goto Cleanup;
        }

    //
    // See if it is a subscription for Destination Reachability event. If not,
    // return success. If yes, try to get the value for Publisher property -
    // bstrDestination.
    //
    hr = pIEventSubscription->get_MethodName(
                                  &bstrMethodName
                                  );
    if (hr != S_OK)
        {
        SensPrint(SENS_ERR, (SENS_STRING("GetDestinationNameFromSubscription(): get_MethodName()")
                  SENS_STRING(" failed - hr = <%x>\n"), hr));
        goto Cleanup;
        }
    if (   (wcscmp(bstrMethodName, DESTINATION_REACHABLE_METHOD) != 0)
        && (wcscmp(bstrMethodName, DESTINATION_REACHABLE_NOQOC_METHOD) != 0))
        {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION);
        SensPrint(SENS_ERR, (SENS_STRING("GetDestinationNameFromSubscription(): Non-Reachability event")
                  SENS_STRING(" subscription (%s). Returning - hr = <%x>\n"), bstrMethodName, hr));
        goto Cleanup;
        }

    //
    // Try to get the value for Publisher property - bstrDestination
    //
    VariantInit(&variantPropertyValue);
    AllocateBstrFromString(bstrPropertyName, PROPERTY_DESTINATION);

    hr = pIEventSubscription->GetPublisherProperty(
                                  bstrPropertyName,
                                  &variantPropertyValue
                                  );
    if (hr == S_OK)
        {
        *pbstrDestinationName = variantPropertyValue.bstrVal;
        // Found the property!
        goto Cleanup;
        }

    //
    // Now, try to get the value for Publisher property - bstrDestinationNoQOC
    //
    FreeBstr(bstrPropertyName);
    VariantInit(&variantPropertyValue);
    AllocateBstrFromString(bstrPropertyName, PROPERTY_DESTINATION_NOQOC);

    hr = pIEventSubscription->GetPublisherProperty(
                                  bstrPropertyName,
                                  &variantPropertyValue
                                  );
    if (hr == S_OK)
        {
        // Found the property!
        *pbstrDestinationName = variantPropertyValue.bstrVal;
        goto Cleanup;
        }

    SensPrint(SENS_ERR, (SENS_STRING("GetDestinationNameFromSubscription(): failed to get ")
              SENS_STRING("PublisherProperty - hr = <%x>\n"), hr));

Cleanup:
    //
    // Cleanup
    //
    if (pIEventSystem)
        {
        pIEventSystem->Release();
        }
    if (pIEventSubscription)
        {
        pIEventSubscription->Release();
        }
    if (pIUnkQueryResult)
        {
        pIUnkQueryResult->Release();
        }

    FreeBstr(bstrPropertyName);
    FreeBstr(bstrMethodName);

    return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\senssvc\event.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    event.cxx

Abstract:

    SENS code related to firing Events using LCE mechanism.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          10/31/1997         Start.

--*/


#include <precomp.hxx>


//
// Some useful Macros
//


/*++

Macro Description:

    Helper Macro for firing Winlogon events.

Arguments:

    See signature.

--*/
#define FIRE_WINLOGON_EVENT(_EVENT_NAME_, _EVENT_TYPE_)                         \
{                                                                               \
    PSENSEVENT_WINLOGON pData = (PSENSEVENT_WINLOGON)EventData;                 \
    WCHAR buffer[CRED_MAX_USERNAME_LENGTH];                                     \
                                                                                \
    *buffer = 0;                                                                \
                                                                                \
    SensPrint(SENS_INFO, (SENS_STRING("\t|            WINLOGON Event\n")));                         \
    SensPrint(SENS_INFO, (SENS_STRING("\t|\n\t|                 Type  -  %s\n"), _EVENT_NAME_));    \
    SensPrint(SENS_INFO, (SENS_STRING("\t|                 Size  -  %d\n"), pData->Info.Size));     \
    SensPrint(SENS_INFO, (SENS_STRING("\t|                Flags  -  0x%x\n"), pData->Info.Flags));  \
    SensPrintW(SENS_INFO, (SENS_BSTR("\t|             UserName  -  %s\n"),                          \
              pData->Info.UserName ? pData->Info.UserName : SENS_BSTR("")));                        \
    SensPrintW(SENS_INFO, (SENS_BSTR("\t|               Domain  -  %s\n"),                          \
              pData->Info.Domain ? pData->Info.Domain : SENS_BSTR("")));                            \
    SensPrintW(SENS_INFO, (SENS_BSTR("\t|           WinStation  -  %s\n"),                          \
              pData->Info.WindowStation ? pData->Info.WindowStation : SENS_BSTR("")));              \
    SensPrint(SENS_INFO, (SENS_STRING("\t|               hToken  -  0x%x\n"), pData->Info.hToken)); \
    SensPrint(SENS_INFO, (SENS_STRING("\t|             hDesktop  -  0x%x\n"), pData->Info.hDesktop));    \
    SensPrint(SENS_INFO, (SENS_STRING("\t|          dwSessionId  -  0x%x\n"), pData->Info.dwSessionId)); \
                                                                                \
    if (pData->Info.Domain != NULL)                                             \
        {                                                                       \
        StringCchCopy(buffer, CRED_MAX_USERNAME_LENGTH, pData->Info.Domain);    \
        StringCchCat(buffer, CRED_MAX_USERNAME_LENGTH, SENS_BSTR("\\"));        \
        }                                                                       \
    if (pData->Info.UserName != NULL)                                           \
        {                                                                       \
        StringCchCat(buffer, CRED_MAX_USERNAME_LENGTH, pData->Info.UserName);   \
        }                                                                       \
    SensPrintW(SENS_INFO, (SENS_BSTR("\t|    UserName passed is -  %s\n"), buffer));   \
    hr = SensFireWinlogonEventHelper(buffer, pData->Info.dwSessionId, _EVENT_TYPE_);   \
                                                                                \
    break;                                                                      \
}


/*++

Macro Description:

    Helper Macro for firing PnP events.

Arguments:

    See signature.

Notes:

    a. This is not an actual event exposed by SENS.

--*/
#define FIRE_PNP_EVENT(_EVENT_NAME_)                                            \
{                                                                               \
    PSENSEVENT_PNP pData = (PSENSEVENT_PNP)EventData;                           \
                                                                                \
    SensPrint(SENS_INFO, (SENS_STRING("\t|            PNP Event\n")));          \
    SensPrint(SENS_INFO, (SENS_STRING("\t|\n\t|                 Type  -  DEVICE %s\n"), _EVENT_NAME_)); \
    SensPrint(SENS_INFO, (SENS_STRING("\t|                 Size  -  %d\n"), pData->Size));            \
    SensPrint(SENS_INFO, (SENS_STRING("\t|              DevType  -  %d\n"), pData->DevType));         \
    SensPrint(SENS_INFO, (SENS_STRING("\t|             Resource  -  0x%x\n"), pData->Resource));      \
    SensPrint(SENS_INFO, (SENS_STRING("\t|                Flags  -  0x%x\n"), pData->Flags));         \
                                                                                \
    break;                                                                      \
}


/*++

Macro Description:

    Helper Macro for firing Power events.

Arguments:

    See signature.

--*/
#define FIRE_POWER_EVENT(_EVENT_NAME_, _EVENT_TYPE_)                            \
{                                                                               \
    PSENSEVENT_POWER pData = (PSENSEVENT_POWER)EventData;                       \
                                                                                \
    SensPrint(SENS_INFO, (SENS_STRING("\t|            POWER MANAGEMENT Event\n"))); \
    SensPrint(SENS_INFO, (SENS_STRING("\t|\n\t|                  Type  -  %s\n"), _EVENT_NAME_));     \
    SensPrint(SENS_INFO, (SENS_STRING("\t|          ACLineStatus  -  %d\n"),        \
              pData->PowerStatus.ACLineStatus));                                    \
    SensPrint(SENS_INFO, (SENS_STRING("\t|           BatteryFlag  -  %d\n"),        \
              pData->PowerStatus.BatteryFlag));                                     \
    SensPrint(SENS_INFO, (SENS_STRING("\t|    BatteryLifePercent  -  %d\n"),        \
              pData->PowerStatus.BatteryLifePercent));                              \
    SensPrint(SENS_INFO, (SENS_STRING("\t|       BatteryLifeTime  -  0x%x secs\n"), \
              pData->PowerStatus.BatteryLifeTime));                                 \
    SensPrint(SENS_INFO, (SENS_STRING("\t|   BatteryFullLifeTime  -  0x%x secs\n"), \
              pData->PowerStatus.BatteryFullLifeTime));                         \
    hr = SensFirePowerEventHelper(pData->PowerStatus, _EVENT_TYPE_);            \
    break;                                                                      \
}


/*++

Macro Description:

    Helper Macro for firing RAS events.

Arguments:

    See signature.

Notes:

    a. This is not an actual event exposed by SENS. It may, however, generate
       a WAN Connectivity event.

--*/
#define FIRE_RAS_EVENT(_EVENT_NAME_)                                            \
{                                                                               \
                                                                                \
    PSENSEVENT_RAS pData = (PSENSEVENT_RAS)EventData;                           \
                                                                                \
    SensPrint(SENS_INFO, (SENS_STRING("\t|            RAS Event\n")));          \
    SensPrint(SENS_INFO, (SENS_STRING("\t|\n\t|                 Type  -  %s\n"), _EVENT_NAME_));     \
    SensPrint(SENS_INFO, (SENS_STRING("\t|    Connection Handle  -  0x%x\n"), pData->hConnection));  \
    break;                                                                      \
}


/*++

Macro Description:

    Helper Macro for firing LAN events.

Arguments:

    See signature.

Notes:

    a. This is not an actual event exposed by SENS. It may, however, generate
       a LAN Connectivity event.

--*/
#define FIRE_LAN_EVENT(_EVENT_NAME_)                                            \
                                                                                \
{                                                                               \
    PSENSEVENT_LAN pData = (PSENSEVENT_LAN)EventData;                           \
                                                                                \
    SensPrint(SENS_INFO, (SENS_STRING("\t|            LAN Event\n")));          \
    SensPrint(SENS_INFO, (SENS_STRING("\t|\n\t|                 Type  -  %s\n"), _EVENT_NAME_));    \
    SensPrint(SENS_INFO, (SENS_STRING("\t|\n\t|      Connection Name  -  %s\n"), pData->Name));     \
    SensPrint(SENS_INFO, (SENS_STRING("\t|\n\t|                Status -  0x%x\n"), pData->Status)); \
    SensPrint(SENS_INFO, (SENS_STRING("\t|\n\t|                  Type -  0x%x\n"), pData->Type));   \
    break;                                                                      \
}


/*++

Macro Description:

    This macro is called when we allocate the EventData so that it can be
    queued to a worker thread. ALLOCATE_END() should be called to signal the
    end of the allocation.

Arguments:

    See signature.

Notes:

    a. pData, pTempData and pReturnData are fixed names for the variable.
       They should not be changed without updating the code that uses
       this macro.

--*/
#define ALLOCATE_BEGIN(_EVENT_STRUCT_)                                          \
                                                                                \
    _EVENT_STRUCT_ *pData, *pTempData;                                          \
                                                                                \
    /* Allocate the Data structure */                                           \
    pTempData = (_EVENT_STRUCT_ *) EventData;                                   \
    pData = (_EVENT_STRUCT_ *) new char[sizeof(_EVENT_STRUCT_)];                \
    if (NULL == pData)                                                          \
        {                                                                       \
        goto Cleanup;                                                           \
        }                                                                       \
                                                                                \
    memcpy(pData, EventData, sizeof(_EVENT_STRUCT_));



/*++

Macro Description:

    This macro is called when we allocate the strings in the EventData before
    queueing to a worker thread. FREE_STRING_MEMBER() should be called to free
    the string before the EventData itself is freed.

Arguments:

    See signature.

Notes:

    a. pData, pTempData and pReturnData are fixed names for the variable.
       They should not be changed without updating the code that uses
       this macro.

--*/
#define ALLOCATE_STRING_MEMBER(_DEST_, _SOURCE_)                                \
                                                                                \
    if (NULL != _SOURCE_)                                                       \
        {                                                                       \
        SIZE_T size = wcslen(_SOURCE_)+1;                                       \
        /* Allocate the string */                                               \
        _DEST_ = new WCHAR[size];                                              \
        if (NULL == (_DEST_))                                                   \
            {                                                                   \
            delete pData;                                                       \
            goto Cleanup;                                                       \
            }                                                                   \
        StringCchCopy((_DEST_), size, (_SOURCE_));                              \
        }


/*++

Macro Description:

    This macro is called when we finish allocating the EventData so that
    it can be queued to a worker thread. It should be always called after
    ALLOCATE_BEGIN() macro.

Arguments:

    None.

Notes:

    a. pData, pTempData and pReturnData are fixed names for the variable.
       They should not be changed without updating the code that uses
       this macro.

--*/
#define ALLOCATE_END()                                                          \
                                                                                \
    SensPrint(SENS_INFO, (SENS_STRING("******** Allocated a DS (0x%x)\n"), pData));     \
    pReturnData = pData;                                                        \
    break;



/*++

Macro Description:

    This macro is called to begin the deallocation of the EventData. This
    should always match with a call to ALLOCATE_BEGIN() macro.

Arguments:

    None.

Notes:

    a. pData, pTempData and pReturnData are fixed names for the variable.
       They should not be changed without updating the code that uses
       this macro.

--*/
#define FREE_BEGIN(_EVENT_STRUCT_)                                              \
                                                                                \
    _EVENT_STRUCT_ *pData;                                                      \
                                                                                \
    pData = (_EVENT_STRUCT_ *) EventData;


/*++

Macro Description:

    This macro is called to free the string member of an EventData. This
    should always match with a call to ALLOCATE_STRING_MEMBER() macro.

Arguments:

    See signature.

Notes:

    a. pData, pTempData and pReturnData are fixed names for the variable.
       They should not be changed without updating the code that uses
       this macro.

--*/
#define FREE_STRING_MEMBER(_STRING_)                                            \
                                                                                \
    if (NULL != _STRING_)                                                       \
        {                                                                       \
        /* Free the string */                                                   \
        delete _STRING_;                                                        \
        }


/*++

Macro Description:

    This macro is called to end the deallocation of EventData. This
    should always match with a call to FREE_BEGIN() macro.

Arguments:

    See signature.

Notes:

    a. pData, pTempData and pReturnData are fixed names for the variable.
       They should not be changed without updating the code that uses
       this macro.

--*/
#define FREE_END()                                                              \
                                                                                \
    SensPrint(SENS_INFO, (SENS_STRING("********** Freed a DS (0x%x)\n"), pData));       \
    delete pData;                                                               \
    break;





void
EvaluateConnectivity(
    IN CONNECTIVITY_TYPE Type
    )
/*++

Routine Description:

    This code queues up a job (for evaluating Network connectivity) to
    a worker thread.

Arguments:

    Type - Indicates the type of connectivity to be evaluated.

Return Value:

    None.

--*/
{
    BOOL bRetVal;
    LPTHREAD_START_ROUTINE lpfnEvaluate;

    switch (Type)
        {
        case TYPE_WAN:
            lpfnEvaluate = (LPTHREAD_START_ROUTINE) EvaluateWanConnectivity;
            break;

        case TYPE_DELAY_LAN:
            lpfnEvaluate = (LPTHREAD_START_ROUTINE) EvaluateLanConnectivityDelayed;
            break;

        default:
        case TYPE_LAN:
            lpfnEvaluate = (LPTHREAD_START_ROUTINE) EvaluateLanConnectivity;
            break;
        }

    bRetVal = SensQueueUserWorkItem(
                  (LPTHREAD_START_ROUTINE) lpfnEvaluate,
                  NULL,
                  SENS_LONG_ITEM    // Flags
                  );
    if (FALSE == bRetVal)
        {
        SensPrintA(SENS_ERR, ("EvaluateConnectivity(): SensQueueUserWorkItem() failed with %d.\n",
                   GetLastError()));
        }
}




void
SensFireEvent(
    IN PVOID EventData
    )
/*++

Routine Description:

    This code queues up a job (for firing a SENS event) to a worker thread.

Arguments:

    EventData - Data relating to the event.

Return Value:

    None.

--*/
{
    BOOL bRetVal;
    PVOID pAllocatedData;

    pAllocatedData = AllocateEventData(EventData);
    if (NULL == pAllocatedData)
        {
        SensPrintA(SENS_ERR, ("SensFireEvent(): Failed to allocate Event Data!\n"));
        return;
        }

    bRetVal = SensQueueUserWorkItem(
                  (LPTHREAD_START_ROUTINE) SensFireEventHelper,
                  pAllocatedData,   // Event Data
                  SENS_LONG_ITEM    // Flags
                  );
    if (FALSE == bRetVal)
        {
        SensPrintA(SENS_ERR, ("SensFireEvent(): SensQueueUserWorkItem() failed with %d.\n",
                   GetLastError()));
        }
    else
        {
        SensPrintA(SENS_INFO, ("SensFireEvent(): SensQueueUserWorkItem() succeeded.\n"));
        }
}




DWORD WINAPI
SensFireEventHelper(
    IN PVOID EventData
    )
/*++

Routine Description:

    This code sets up the necessary stuff for firing a SENS event.

Arguments:

    EventData - Data relating to the event.

Return Value:

    S_OK, if successful

    hr, otherwise

--*/
{
    SENS_EVENT_TYPE eType;
    HRESULT hr;

    SensPrint(SENS_INFO, (SENS_STRING("\t|-------------------------------------------------------|\n")));
    SensPrint(SENS_INFO, (SENS_STRING("\t|               E V E N T   F I R E D                   |\n")));
    SensPrint(SENS_INFO, (SENS_STRING("\t|-------------------------------------------------------|\n")));

    hr = S_OK;
    eType = *(SENS_EVENT_TYPE *)EventData;

    switch (eType)
        {
        case SENS_EVENT_NETALIVE:
            {
            PSENSEVENT_NETALIVE pData = (PSENSEVENT_NETALIVE)EventData;

            SensPrint(SENS_INFO, (SENS_STRING("\t|   %s%sNetwork Connectivity is %sPRESENT.\n\t|\n"),
                      (pData->QocInfo.dwFlags & CONNECTION_WAN) ? SENS_STRING("WAN ") : SENS_STRING(""),
                      (pData->QocInfo.dwFlags & CONNECTION_LAN) ? SENS_STRING("LAN ") : SENS_STRING(""),
                      pData->bAlive ? SENS_STRING("") : SENS_STRING("NOT "))
                      );

            hr = SensFireNetEventHelper(pData);
            break;
            }

        case SENS_EVENT_REACH:
            {
            PSENSEVENT_REACH pData = (PSENSEVENT_REACH)EventData;

            SensPrint(SENS_INFO, (SENS_STRING("\t|   Destination is %sREACHABLE.\n"), pData->bReachable ? "" : "NOT "));
            SensPrint(SENS_INFO, (SENS_STRING("\t|\n\t|          Name   : %s\n"), pData->Destination));
            if (pData->bReachable == TRUE)
                {
                SensPrint(SENS_INFO, (SENS_STRING("\t|       dwFlags   : 0x%x \n"), pData->QocInfo.dwFlags));
                SensPrint(SENS_INFO, (SENS_STRING("\t|       InSpeed   : %d bits/sec.\n"), pData->QocInfo.dwInSpeed));
                SensPrint(SENS_INFO, (SENS_STRING("\t|      OutSpeed   : %d bits/sec.\n"), pData->QocInfo.dwOutSpeed));
                }

            hr = SensFireReachabilityEventHelper(pData);
            break;
            }

        case SENS_EVENT_PNP_DEVICE_ARRIVED:
            FIRE_PNP_EVENT(SENS_STRING("ARRIVED"));

        case SENS_EVENT_PNP_DEVICE_REMOVED:
            FIRE_PNP_EVENT(SENS_STRING("REMOVED"));

        case SENS_EVENT_POWER_ON_ACPOWER:
            FIRE_POWER_EVENT(SENS_STRING("ON AC POWER"), eType);

        case SENS_EVENT_POWER_ON_BATTERYPOWER:
            FIRE_POWER_EVENT(SENS_STRING("ON BATTERY POWER"), eType);

        case SENS_EVENT_POWER_BATTERY_LOW:
            FIRE_POWER_EVENT(SENS_STRING("BATTERY IS LOW"), eType);

        case SENS_EVENT_POWER_STATUS_CHANGE:
            FIRE_POWER_EVENT(SENS_STRING("POWER STATUS CHANGED"), eType);

        case SENS_EVENT_LOGON:
            FIRE_WINLOGON_EVENT(SENS_STRING("LOGON"), eType);

        case SENS_EVENT_LOGOFF:
            FIRE_WINLOGON_EVENT(SENS_STRING("LOGOFF"), eType);

        case SENS_EVENT_STARTSHELL:
            FIRE_WINLOGON_EVENT(SENS_STRING("STARTSHELL"), eType);

        case SENS_EVENT_POSTSHELL:
            FIRE_WINLOGON_EVENT(SENS_STRING("POSTSHELL"), eType);

        case SENS_EVENT_SESSION_DISCONNECT:
            FIRE_WINLOGON_EVENT(SENS_STRING("SESSION DISCONNECT"), eType);

        case SENS_EVENT_SESSION_RECONNECT:
            FIRE_WINLOGON_EVENT(SENS_STRING("SESSION RECONNECT"), eType);

        case SENS_EVENT_STARTSCREENSAVER:
            FIRE_WINLOGON_EVENT(SENS_STRING("STARTSCREENSAVER"), eType);

        case SENS_EVENT_STOPSCREENSAVER:
            FIRE_WINLOGON_EVENT(SENS_STRING("STOPSCREENSAVER"), eType);

        case SENS_EVENT_LOCK:
            FIRE_WINLOGON_EVENT(SENS_STRING("DISPLAY LOCK"), eType);

        case SENS_EVENT_UNLOCK:
            FIRE_WINLOGON_EVENT(SENS_STRING("DISPLAY UNLOCK"), eType);

        case SENS_EVENT_RAS_STARTED:
            FIRE_RAS_EVENT(SENS_STRING("RAS STARTED"));

        case SENS_EVENT_RAS_STOPPED:
            FIRE_RAS_EVENT(SENS_STRING("RAS STOPPED"));

        case SENS_EVENT_RAS_CONNECT:
            FIRE_RAS_EVENT(SENS_STRING("RAS CONNECT"));

        case SENS_EVENT_RAS_DISCONNECT:
            FIRE_RAS_EVENT(SENS_STRING("RAS DISCONNECT"));

        case SENS_EVENT_RAS_DISCONNECT_PENDING:
            FIRE_RAS_EVENT(SENS_STRING("RAS DISCONNECT PENDING"));

        case SENS_EVENT_LAN_CONNECT:
            FIRE_LAN_EVENT(SENS_STRING("LAN CONNECT"));

        case SENS_EVENT_LAN_DISCONNECT:
            FIRE_LAN_EVENT(SENS_STRING("LAN DISCONNECT"));

        default:
            SensPrint(SENS_ERR, (SENS_STRING("\t|   A bogus event - %d !\n"), eType));
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        }

    //
    // Free the allocated Event data structure.
    //
    FreeEventData(EventData);

    return ((DWORD) hr);
}




PVOID
AllocateEventData(
    PVOID EventData
    )
/*++

Routine Description:

    Allocated the EventData depending on the type of the event.

Arguments:

    EventData - Data relating to the event.

Return Value:

    None.

--*/
{
    SENS_EVENT_TYPE eType;
    PVOID pReturnData;

    pReturnData = NULL;
    if (NULL == EventData)
        {
        goto Cleanup;
        }

    eType = *(SENS_EVENT_TYPE *)EventData;

    switch (eType)
        {
        case SENS_EVENT_NETALIVE:
            {
            ALLOCATE_BEGIN(SENSEVENT_NETALIVE);

            ALLOCATE_STRING_MEMBER(pData->strConnection, pTempData->strConnection);

            ALLOCATE_END();
            }

        case SENS_EVENT_REACH:
            {
            ALLOCATE_BEGIN(SENSEVENT_REACH);

            ALLOCATE_STRING_MEMBER(pData->Destination, pTempData->Destination);
            ALLOCATE_STRING_MEMBER(pData->strConnection, pTempData->strConnection);

            ALLOCATE_END();
            }

        case SENS_EVENT_PNP_DEVICE_ARRIVED:
        case SENS_EVENT_PNP_DEVICE_REMOVED:
            {
            ALLOCATE_BEGIN(SENSEVENT_PNP);

            ALLOCATE_END();
            }


        case SENS_EVENT_POWER_ON_ACPOWER:
        case SENS_EVENT_POWER_ON_BATTERYPOWER:
        case SENS_EVENT_POWER_BATTERY_LOW:
        case SENS_EVENT_POWER_STATUS_CHANGE:
            {
            ALLOCATE_BEGIN(SENSEVENT_POWER);

            ALLOCATE_END();
            }

        case SENS_EVENT_LOGON:
        case SENS_EVENT_LOGOFF:
        case SENS_EVENT_STARTSHELL:
        case SENS_EVENT_POSTSHELL:
        case SENS_EVENT_SESSION_DISCONNECT:
        case SENS_EVENT_SESSION_RECONNECT:
        case SENS_EVENT_STARTSCREENSAVER:
        case SENS_EVENT_STOPSCREENSAVER:
        case SENS_EVENT_LOCK:
        case SENS_EVENT_UNLOCK:
            {
            ALLOCATE_BEGIN(SENSEVENT_WINLOGON);

            ALLOCATE_STRING_MEMBER(pData->Info.UserName, pTempData->Info.UserName);
            ALLOCATE_STRING_MEMBER(pData->Info.Domain, pTempData->Info.Domain);
            ALLOCATE_STRING_MEMBER(pData->Info.WindowStation, pTempData->Info.WindowStation);

            ALLOCATE_END();
            }

        case SENS_EVENT_RAS_STARTED:
        case SENS_EVENT_RAS_STOPPED:
        case SENS_EVENT_RAS_CONNECT:
        case SENS_EVENT_RAS_DISCONNECT:
        case SENS_EVENT_RAS_DISCONNECT_PENDING:
            {
            ALLOCATE_BEGIN(SENSEVENT_RAS);

            ALLOCATE_END();
            }

        case SENS_EVENT_LAN_CONNECT:
        case SENS_EVENT_LAN_DISCONNECT:
             {
            ALLOCATE_BEGIN(SENSEVENT_LAN);

            ALLOCATE_STRING_MEMBER(pData->Name, pTempData->Name);

            ALLOCATE_END();
            }

        default:
            SensPrint(SENS_ERR, (SENS_STRING("\t|   A bogus event - %d !\n"), eType));
            break;
        }

Cleanup:
    //
    // Cleanup
    //
    return pReturnData;
}




void
FreeEventData(
    PVOID EventData
    )
/*++

Routine Description:

    Frees the EventData depending on the type of the event.

Arguments:

    EventData - Data relating to the event.

Return Value:

    None.

--*/
{
    SENS_EVENT_TYPE eType;

    if (NULL == EventData)
        {
        goto Cleanup;
        }
    eType = *(SENS_EVENT_TYPE *)EventData;

    switch (eType)
        {
        case SENS_EVENT_NETALIVE:
            {
            FREE_BEGIN(SENSEVENT_NETALIVE);

            FREE_STRING_MEMBER(pData->strConnection);

            FREE_END();
            }

        case SENS_EVENT_REACH:
            {
            FREE_BEGIN(SENSEVENT_REACH);

            FREE_STRING_MEMBER(pData->Destination);
            FREE_STRING_MEMBER(pData->strConnection);

            FREE_END();
            }

        case SENS_EVENT_PNP_DEVICE_ARRIVED:
        case SENS_EVENT_PNP_DEVICE_REMOVED:
            {
            FREE_BEGIN(SENSEVENT_PNP);

            FREE_END();
            }


        case SENS_EVENT_POWER_ON_ACPOWER:
        case SENS_EVENT_POWER_ON_BATTERYPOWER:
        case SENS_EVENT_POWER_BATTERY_LOW:
        case SENS_EVENT_POWER_STATUS_CHANGE:
            {
            FREE_BEGIN(SENSEVENT_POWER);

            FREE_END();
            }

        case SENS_EVENT_LOGON:
        case SENS_EVENT_LOGOFF:
        case SENS_EVENT_STARTSHELL:
        case SENS_EVENT_POSTSHELL:
        case SENS_EVENT_SESSION_DISCONNECT:
        case SENS_EVENT_SESSION_RECONNECT:
        case SENS_EVENT_STARTSCREENSAVER:
        case SENS_EVENT_STOPSCREENSAVER:
        case SENS_EVENT_LOCK:
        case SENS_EVENT_UNLOCK:
            {
            FREE_BEGIN(SENSEVENT_WINLOGON);

            FREE_STRING_MEMBER(pData->Info.UserName);
            FREE_STRING_MEMBER(pData->Info.Domain);
            FREE_STRING_MEMBER(pData->Info.WindowStation);

            FREE_END();
            }

        case SENS_EVENT_RAS_STARTED:
        case SENS_EVENT_RAS_STOPPED:
        case SENS_EVENT_RAS_CONNECT:
        case SENS_EVENT_RAS_DISCONNECT:
        case SENS_EVENT_RAS_DISCONNECT_PENDING:
            {
            FREE_BEGIN(SENSEVENT_RAS);

            FREE_END();
            }

        case SENS_EVENT_LAN_CONNECT:
        case SENS_EVENT_LAN_DISCONNECT:
            {
            FREE_BEGIN(SENSEVENT_LAN);

            FREE_STRING_MEMBER(pData->Name);

            FREE_END();
            }

        default:
            SensPrint(SENS_ERR, (SENS_STRING("\t|   A bogus structure to free - %d !\n"), eType));
            break;
        }

Cleanup:
    //
    // Cleanup
    //
    return;
}




HRESULT
SensFireNetEventHelper(
    PSENSEVENT_NETALIVE pData
    )
/*++

Routine Description:

    Helps fire the SENS Network Alive event.

Arguments:

    pData - Net alive event data.

Return Value:

    S_OK, if successful.

    Failure hr, otherwise.

--*/
{
    HRESULT hr;
    BSTR bstrConnectionName;
    BSTR bstrMethodName;
    ISensNetwork    *pISensNetwork;
    IEventControl   *pIEventControl;
    SENS_QOCINFO    SensQocInfo;
    CImpISensNetworkFilter NetEventsFilter; // Already AddRef'ed

    hr = S_OK;
    bstrConnectionName = NULL;
    bstrMethodName = NULL;
    pISensNetwork = NULL;
    pIEventControl = NULL;

    hr = CoCreateInstance(
             SENSGUID_EVENTCLASS_NETWORK,
             NULL,
             CLSCTX_SERVER,
             IID_ISensNetwork,
             (LPVOID *) &pISensNetwork
             );
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't get ISensNetwork object - ")
                  SENS_STRING("hr = 0x%x\n"), hr));
        goto Cleanup;
        }
    SensPrint(SENS_INFO, (SENS_STRING("\t| Successfully created ISensNetwork Object\n")));

    //
    // Setup Publisher filtering
    //
    hr = pISensNetwork->QueryInterface(
                            IID_IEventControl,
                            (LPVOID *) &pIEventControl
                            );
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't get IEventControl object - ")
                  SENS_STRING("hr = 0x%x\n"), hr));
        goto Cleanup;
        }
    SensPrint(SENS_INFO, (SENS_STRING("\t| Successfully created IEventControl Object\n")));

    //
    // Disallow inproc activation (we're local system, and we
    // don't like foreign components in our security context,
    // potentially crashing us).
    //
    pIEventControl->put_AllowInprocActivation(FALSE);

    AllocateBstrFromString(bstrConnectionName, pData->strConnection);

    if (pData->bAlive)
        {
        // Connect events
        AllocateBstrFromString(bstrMethodName, CONNECTION_MADE_NOQOC_METHOD);
        hr = NetEventsFilter.Initialize(bstrMethodName, pIEventControl);
        if (FAILED(hr))
            {
            SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't initialize PublisherFilters for Net Connect Event - ")
                      SENS_STRING("hr = 0x%x\n"), hr));
            goto Cleanup;
            }
        hr = pIEventControl->SetPublisherFilter(
                                 bstrMethodName,
                                 &NetEventsFilter
                                 );
        if (FAILED(hr))
            {
            SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't set PublisherFilters for Net Connect Event - ")
                      SENS_STRING("hr = 0x%x\n"), hr));
            goto Cleanup;
            }

        //
        // Fire the necessary ISensNetwork events
        //

        //
        // ConnectionMadeNoQOCInfo event
        //
        hr = pISensNetwork->ConnectionMadeNoQOCInfo(
                                bstrConnectionName,
                                pData->QocInfo.dwFlags
                                );
        if (FAILED(hr))
            {
            SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't fire ConnectionMadeQOCInfo - ")
                      SENS_STRING("hr = 0x%x\n"), hr));
            goto Cleanup;
            }
        SensPrint(SENS_INFO, (SENS_STRING("\t| ConnectionMadeNoQOCInfo() returned 0x%x\n"), hr));

        //
        // ConnectionMade event
        //
        FreeBstr(bstrMethodName);
        AllocateBstrFromString(bstrMethodName, CONNECTION_MADE_METHOD);
        hr = NetEventsFilter.Initialize(bstrMethodName, pIEventControl);
        if (FAILED(hr))
            {
            SensPrint(SENS_ERR, (SENS_STRING("\t| initialize't set PublisherFilters for NetEvent - ")
                      SENS_STRING("hr = 0x%x\n"), hr));
            goto Cleanup;
            }
        hr = pIEventControl->SetPublisherFilter(
                                 bstrMethodName,
                                 &NetEventsFilter
                                 );
        if (FAILED(hr))
            {
            SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't set PublisherFilters for NetEvent - ")
                      SENS_STRING("hr = 0x%x\n"), hr));
            goto Cleanup;
            }

        memcpy(&SensQocInfo, &pData->QocInfo, sizeof(SENS_QOCINFO));
        hr = pISensNetwork->ConnectionMade(
                                bstrConnectionName,
                                pData->QocInfo.dwFlags,
                                &SensQocInfo
                                );
        if (FAILED(hr))
            {
            SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't fire ConnectionMade - ")
                      SENS_STRING("hr = 0x%x\n"), hr));
            goto Cleanup;
            }
        SensPrint(SENS_INFO, (SENS_STRING("\t| ConnectionMade() returned 0x%x\n"), hr));
        }
    else    // bAlive == FALSE
        {
        // Disconnect event
        AllocateBstrFromString(bstrMethodName, CONNECTION_LOST_METHOD);
        hr = NetEventsFilter.Initialize(bstrMethodName, pIEventControl);
        if (FAILED(hr))
            {
            SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't initialize PublisherFilters for Net Disconnect Event - ")
                      SENS_STRING("hr = 0x%x\n"), hr));
            goto Cleanup;
            }
        hr = pIEventControl->SetPublisherFilter(
                                 bstrMethodName,
                                 &NetEventsFilter
                                 );
        if (FAILED(hr))
            {
            SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't set PublisherFilters for Net Disconnect Event - ")
                      SENS_STRING("hr = 0x%x\n"), hr));
            goto Cleanup;
            }

        //
        // Fire the necessary ISensNetwork events
        //

        //
        // ConnectionMadeNoQOCInfo event
        //
        hr = pISensNetwork->ConnectionLost(
                                bstrConnectionName,
                                pData->QocInfo.dwFlags
                                );
        if (FAILED(hr))
            {
            SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't fire ConnectionLost - ")
                      SENS_STRING("hr = 0x%x\n"), hr));
            goto Cleanup;
            }
        SensPrint(SENS_INFO, (SENS_STRING("\t| ConnectionLost() returned 0x%x\n"), hr));
        }


Cleanup:
    //
    // Cleanup
    //
    if (pIEventControl)
        {
        pIEventControl->Release();
        }
    if (pISensNetwork)
        {
        pISensNetwork->Release();
        }

    FreeBstr(bstrMethodName);
    FreeBstr(bstrConnectionName);

    return hr;
}




HRESULT
SensFireReachabilityEventHelper(
    PSENSEVENT_REACH pData
    )
/*++

Routine Description:

    Helps fire the SENS Reachability event.

Arguments:

    pData - Reachability event Data.

Return Value:

    S_OK, if successful.

    Failure hr, otherwise.

--*/
{
    HRESULT hr;
    BSTR bstrConnectionName;
    BSTR bstrMethodName;
    BSTR bstrDestinationName;
    ISensNetwork    *pISensNetwork;
    IEventControl   *pIEventControl;
    SENS_QOCINFO    SensQocInfo;
    CImpISensNetworkFilter NetEventsFilter; // Already AddRef'ed

    hr = S_OK;
    bstrMethodName = NULL;
    bstrConnectionName = NULL;
    bstrDestinationName = NULL;
    pISensNetwork = NULL;
    pIEventControl = NULL;

    hr = CoCreateInstance(
             SENSGUID_EVENTCLASS_NETWORK,
             NULL,
             CLSCTX_SERVER,
             IID_ISensNetwork,
             (LPVOID *) &pISensNetwork
             );
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't get ISensNetwork object - ")
                  SENS_STRING("hr = 0x%x\n"), hr));
        goto Cleanup;
        }
    SensPrint(SENS_INFO, (SENS_STRING("\t| Successfully created ISensNetwork Object\n")));

    //
    // Setup Publisher filtering
    //
    hr = pISensNetwork->QueryInterface(
                            IID_IEventControl,
                            (LPVOID *) &pIEventControl
                            );
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't get IEventControl object - ")
                  SENS_STRING("hr = 0x%x\n"), hr));
        goto Cleanup;
        }
    SensPrint(SENS_INFO, (SENS_STRING("\t| Successfully created IEventControl Object\n")));

    //
    // Disallow inproc activation (we're local system, and we
    // don't like foreign components in our security context,
    // potentially crashing us).
    //
    pIEventControl->put_AllowInprocActivation(FALSE);

    AllocateBstrFromString(bstrMethodName, DESTINATION_REACHABLE_NOQOC_METHOD);
    hr = NetEventsFilter.Initialize(bstrMethodName, pIEventControl);
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("\t| initialize't set PublisherFilters for ReachabilityEvent - ")
                  SENS_STRING("hr = 0x%x\n"), hr));
        goto Cleanup;
        }
    hr = pIEventControl->SetPublisherFilter(
                             bstrMethodName,
                             &NetEventsFilter
                             );
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't set PublisherFilters for ReachabilityEvent - ")
                  SENS_STRING("hr = 0x%x\n"), hr));
        goto Cleanup;
        }

    //
    // Fire the Reachability events
    //
    AllocateBstrFromString(bstrConnectionName, pData->strConnection);
    AllocateBstrFromString(bstrDestinationName, pData->Destination);

    //
    // DestinationReachableNoQOCInfo event
    //
    hr = pISensNetwork->DestinationReachableNoQOCInfo(
                            bstrDestinationName,
                            bstrConnectionName,
                            pData->QocInfo.dwFlags
                            );
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't fire DestinationReachableNoQOCInfo - ")
                  SENS_STRING("hr = 0x%x\n"), hr));
        goto Cleanup;
        }
    SensPrint(SENS_INFO, (SENS_STRING("\t| DestinationReachableNoQOCInfo() returned 0x%x\n"), hr));

    //
    // DestinationReachable event
    //
    FreeBstr(bstrMethodName);
    AllocateBstrFromString(bstrMethodName, DESTINATION_REACHABLE_METHOD);
    hr = NetEventsFilter.Initialize(bstrMethodName, pIEventControl);
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("\t| initialize't set PublisherFilters for ReachabilityEvent - ")
                  SENS_STRING("hr = 0x%x\n"), hr));
        goto Cleanup;
        }
    hr = pIEventControl->SetPublisherFilter(
                             bstrMethodName,
                             &NetEventsFilter
                             );
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't set PublisherFilters for ReachabilityEvent - ")
                  SENS_STRING("hr = 0x%x\n"), hr));
        goto Cleanup;
        }

    memcpy(&SensQocInfo, &pData->QocInfo, sizeof(SENS_QOCINFO));
    hr = pISensNetwork->DestinationReachable(
                            bstrDestinationName,
                            bstrConnectionName,
                            pData->QocInfo.dwFlags,
                            &SensQocInfo
                            );
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't fire DestinationReachable - ")
                  SENS_STRING("hr = 0x%x\n"), hr));
        goto Cleanup;
        }
    SensPrint(SENS_INFO, (SENS_STRING("\t| DestinationReachable() returned 0x%x\n"), hr));



Cleanup:
    //
    // Cleanup
    //
    if (pIEventControl)
        {
        pIEventControl->Release();
        }
    if (pISensNetwork)
        {
        pISensNetwork->Release();
        }

    FreeBstr(bstrMethodName);
    FreeBstr(bstrConnectionName);
    FreeBstr(bstrDestinationName);

    return hr;
}




HRESULT
SensFireWinlogonEventHelper(
    LPWSTR strArg,
    DWORD dwSessionId,
    SENS_EVENT_TYPE eType
    )
/*++

Routine Description:

    Helps fire the SENS Winlogon event.

Arguments:

    strArg - DomainName\UserName

    dwSessionId - Session Id of the session on which this event was fired.

    eType - Type of Winlogon event.

Return Value:

    S_OK, if successful.

    Failure hr, otherwise.

--*/
{
    HRESULT hr;
    HRESULT hr2;
    BOOL bLogon2;
    BSTR bstrUserName;
    ISensLogon  *pISensLogon;
    ISensLogon2 *pISensLogon2;

    hr = S_OK;
    hr2 = S_OK;
    bstrUserName = NULL;
    pISensLogon = NULL;
    pISensLogon2 = NULL;

    //
    // Get the ISensLogon Object
    //
    hr = CoCreateInstance(
             SENSGUID_EVENTCLASS_LOGON,
             NULL,
             CLSCTX_SERVER,
             IID_ISensLogon,
             (LPVOID *) &pISensLogon
             );
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't get ISensLogon object - ")
                  SENS_STRING("hr = 0x%x\n"), hr));
        goto Cleanup;
        }
    SensPrint(SENS_INFO, (SENS_STRING("\t| Successfully created ISensLogon Object\n")));

    //
    // Get the ISensLogon2 Object
    //
    hr2 = CoCreateInstance(
             SENSGUID_EVENTCLASS_LOGON2,
             NULL,
             CLSCTX_SERVER,
             IID_ISensLogon2,
             (LPVOID *) &pISensLogon2
             );
    if (FAILED(hr2))
        {
        SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't get ISensLogon2 object - ")
                  SENS_STRING("hr = 0x%x\n"), hr2));
        goto Cleanup;
        }
    SensPrint(SENS_INFO, (SENS_STRING("\t| Successfully created ISensLogon2 Object\n")));

    AllocateBstrFromString(bstrUserName, strArg);

    switch (eType)
        {
        case SENS_EVENT_LOGON:
            hr = pISensLogon->Logon(bstrUserName);
            hr2 = pISensLogon2->Logon(bstrUserName, dwSessionId);
            break;

        case SENS_EVENT_LOGOFF:
            hr = pISensLogon->Logoff(bstrUserName);
            hr2 = pISensLogon2->Logoff(bstrUserName, dwSessionId);
            break;

        case SENS_EVENT_STARTSHELL:
            hr = pISensLogon->StartShell(bstrUserName);
            break;

        case SENS_EVENT_POSTSHELL:
            hr2 = pISensLogon2->PostShell(bstrUserName, dwSessionId);
            break;

        case SENS_EVENT_SESSION_DISCONNECT:
            hr2 = pISensLogon2->SessionDisconnect(bstrUserName, dwSessionId);
            break;

        case SENS_EVENT_SESSION_RECONNECT:
            hr2 = pISensLogon2->SessionReconnect(bstrUserName, dwSessionId);
            break;

        case SENS_EVENT_LOCK:
            hr = pISensLogon->DisplayLock(bstrUserName);
            break;

        case SENS_EVENT_UNLOCK:
            hr = pISensLogon->DisplayUnlock(bstrUserName);
            break;

        case SENS_EVENT_STARTSCREENSAVER:
            hr = pISensLogon->StartScreenSaver(bstrUserName);
            break;

        case SENS_EVENT_STOPSCREENSAVER:
            hr = pISensLogon->StopScreenSaver(bstrUserName);
            break;

        default:
            SensPrint(SENS_WARN, (SENS_STRING("\t| Bad Winlogon Event - %d\n"), eType));
            break;
        }

    //
    // Check for failures
    //

    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't fire ISensLogon->WinlogonEvent - ")
                  SENS_STRING("hr = 0x%x\n"), hr));
        }
    else
        {
        SensPrint(SENS_INFO, (SENS_STRING("\t| ISensLogon->WinlogonEvent() returned 0x%x\n"), hr));
        }

    if (FAILED(hr2))
        {
        SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't fire ISensLogon2->WinlogonEvent(%d) - ")
                  SENS_STRING("hr = 0x%x\n"), dwSessionId, hr2));
        }
    else
        {
        SensPrint(SENS_INFO, (SENS_STRING("\t| ISensLogon2->WinlogonEvent(%d) returned 0x%x\n"), dwSessionId, hr));
        }


Cleanup:
    //
    // Cleanup
    //
    if (pISensLogon)
        {
        pISensLogon->Release();
        }

    if (pISensLogon2)
        {
        pISensLogon2->Release();
        }

    FreeBstr(bstrUserName);

    return hr;
}




HRESULT
SensFirePowerEventHelper(
    SYSTEM_POWER_STATUS PowerStatus,
    SENS_EVENT_TYPE eType
    )
/*++

Routine Description:

    Helps fire the SENS Power event.

Arguments:

    PowerStatus - Power Status event structure

    eType - Type of the Power event.

Return Value:

    S_OK, if successful.

    Failure hr, otherwise.

--*/
{
    HRESULT hr;
    ISensOnNow  *pISensOnNow;

    hr = S_OK;
    pISensOnNow = NULL;

    //
    // Get the ISensOnNow Object
    //
    hr = CoCreateInstance(
             SENSGUID_EVENTCLASS_ONNOW,
             NULL,
             CLSCTX_SERVER,
             IID_ISensOnNow,
             (LPVOID *) &pISensOnNow
             );
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't get ISensOnNow object - ")
                  SENS_STRING("hr = 0x%x\n"), hr));
        goto Cleanup;
        }
    SensPrint(SENS_INFO, (SENS_STRING("\t| Successfully created ISensOnNow Object\n")));

    switch (eType)
        {
        case SENS_EVENT_POWER_ON_ACPOWER:
            hr = pISensOnNow->OnACPower();
            break;

        case SENS_EVENT_POWER_ON_BATTERYPOWER:
            hr = pISensOnNow->OnBatteryPower(PowerStatus.BatteryLifePercent);
            break;

        case SENS_EVENT_POWER_BATTERY_LOW:
            hr = pISensOnNow->BatteryLow(PowerStatus.BatteryLifePercent);
            break;

        default:
            SensPrint(SENS_WARN, (SENS_STRING("\t| Bad Power Event - %d\n"), eType));
            break;
        }

    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't fire ISensOnNow->PowerEvent - ")
                  SENS_STRING("hr = 0x%x\n"), hr));
        //SensPrintToDebugger(SENS_DEB, ("\t| Couldn't fire ISensOnNow->PowerEvent - "
        //                    "hr = 0x%x\n", hr));
        goto Cleanup;
        }
    SensPrint(SENS_INFO, (SENS_STRING("\t| ISensOnNow->PowerEvent() returned 0x%x\n"), hr));
    //SensPrintToDebugger(SENS_DEB, ("\t| ISensOnNow->PowerEvent() returned 0x%x\n", hr));

Cleanup:
    //
    // Cleanup
    //
    if (pISensOnNow)
        {
        pISensOnNow->Release();
        }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\senssvc\dest.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    dest.cxx

Abstract:

    Code to keep track of reachability of the list destinations specified
    in Event System's Reachability Event subscriptions.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          10/31/1997         Start.

--*/


#include <precomp.hxx>


//
// Constants
//

#define SENS_REACHABILITY_POLLING_INTERVAL    5*60*1000   // 5 minutes
#define SENS_REACHABILITY_FIRST_SCAN_TIME     5*60*1000   // 5 minutes




//
// Globals
//

LIST    *gpReachList;
HANDLE  ghReachTimer;





BOOL
StartReachabilityEngine(
    void
    )
/*++

Routine Description:

    Start the Destination reachability engine.

Arguments:

    None.

Return Value:

    TRUE, if successful.

    FALSE, otherwise.

--*/
{
    BOOL bRetVal;

    bRetVal = TRUE; // Note it is TRUE, by default.

    SensPrintA(SENS_INFO, ("StartReachabilityEngine(): Starting...\n"));

    RequestSensLock();

    if (ghReachTimer != NULL)
        {
        SensPrintA(SENS_INFO, ("StartReachabilityEngine(): Engine "
                   "already started!\n"));
        goto Cleanup;
        }

    //
    // Create a timer object to poll for destination reachability
    //
    SensSetTimerQueueTimer(
        bRetVal,                     // Bool return on NT5
        ghReachTimer,                // Handle return on IE5
        NULL,                        // Use default process timer queue
        ReachabilityPollingRoutine,  // Callback
        NULL,                        // Parameter
        SENS_REACHABILITY_FIRST_SCAN_TIME, // Time from now when timer should fire
        SENS_REACHABILITY_POLLING_INTERVAL,// Time inbetween firings of this timer
        0x0                          // No Flags.
        );
    if (SENS_TIMER_CREATE_FAILED(bRetVal, ghReachTimer))
        {
        SensPrintA(SENS_INFO, ("StartReachabilityEngine(): SensCancelTimerQueueTimer("
                   "Reachability) failed!\n"));
        bRetVal = FALSE;
        goto Cleanup;
        }


Cleanup:
    //
    // Cleanup
    //
    ReleaseSensLock();

    SensPrintA(SENS_INFO, ("StartReachabilityEngine(): Returning %s\n",
               bRetVal ? "TRUE" : "FALSE"));

    return bRetVal;
}




BOOL
StopReachabilityEngine(
    void
    )
/*++

Routine Description:

    Start the Destination reachability engine.

Arguments:

    None.

Return Value:

    TRUE, if successful.

    FALSE, otherwise.

--*/
{
    BOOL bStatus;

    bStatus = TRUE; // Note it is TRUE, by default.

    SensPrintA(SENS_INFO, ("StopReachabilityEngine(): Stopping...\n"));

    RequestSensLock();

    //
    // Remove Reachability polling timer
    //
    if (NULL != ghReachTimer)
        {
        bStatus = SensCancelTimerQueueTimer(NULL, ghReachTimer, NULL);
        
        ghReachTimer = NULL;

        SensPrintA(SENS_INFO, ("StopReachabilityEngine(): SensCancelTimerQueueTimer("
                   "Reachability) %s\n", bStatus ? "succeeded" : "failed!"));
        }

    ReleaseSensLock();

    SensPrintA(SENS_INFO, ("StopReachabilityEngine(): Returning %s\n",
               bStatus ? "TRUE" : "FALSE"));

    return bStatus;
}




BOOL
InitReachabilityEngine(
    void
    )
/*++

Routine Description:

    Initialize the Reachability polling mechanism.

Arguments:

    None.

Return Value:

    TRUE, if successful.

    FALSE, otherwise.

--*/
{
    BOOL bRetVal;

    bRetVal = FALSE;

    //
    // Initialize the list of destinations
    //
    gpReachList = new LIST();
    if (NULL == gpReachList)
        {
        goto Cleanup;
        }

    bRetVal = StartReachabilityEngine();

Cleanup:
    //
    // Cleanup
    //
    return bRetVal;
}




SENS_TIMER_CALLBACK_RETURN
ReachabilityPollingRoutine(
    PVOID pvIgnore,
    BOOLEAN bIgnore
    )
/*++

Routine Description:

    This routine is called periodically to walk through the reachability list
    to see if the destinations are reachable.

Arguments:

    pvIgnore - Ignored.

    bIgnore - Ignored.


Return Value:

    None.

--*/
{
    PNODE pTemp;
    DWORD OldState;
    QOCINFO DestQOCInfo;
    DWORD dwLastError;
    char *DestinationA;
    static BOOL bGotDestinations = FALSE;

    //
    // Get the list of destinations, if necessary.
    //
    if (FALSE == bGotDestinations)
        {
        HRESULT hr;

        hr = GetDestinationsFromSubscriptions();
        if (SUCCEEDED(hr))
            {
            bGotDestinations = TRUE;
            }
        else
            {
            SensPrintA(SENS_ERR, ("InitReachabilityPolling(): GetDestinations"
                       "FromSubscriptions() failed with 0x%x.\n", hr));
            }
        }

    SensPrintA(SENS_INFO, ("ReachabilityPollingRoutine(): Checking "
                           "Destinations for reachability.\n"));


    // PERF NOTE: Critsec held too long!
    gpReachList->RequestLock();

    if (gpReachList->IsEmpty() == TRUE)
        {
        StopReachabilityEngine();
        gpReachList->ReleaseLock();
        return;
        }

    //
    // Loop through all destinations checking for reachability.
    //

    pTemp = gpReachList->pHead;
    while (pTemp != NULL)
        {
        error_status_t status;

        // Save old reachability state.
        OldState = pTemp->State;

        //
        // Is it Reachable?
        //
        dwLastError = ERROR_SUCCESS;
        DestQOCInfo.dwSize = sizeof(QOCINFO);

        status = RPC_IsDestinationReachableW(
                           NULL,
                           pTemp->Destination,
                           &DestQOCInfo,
                           (LPBOOL) &pTemp->State,
                           &dwLastError
                           );

        ASSERT(status == RPC_S_OK);

        if (   (pTemp->State != OldState)
            && (dwLastError == ERROR_SUCCESS))
            {
            // Fire the Event!
            SENSEVENT_REACH Data;

            Data.eType = SENS_EVENT_REACH;
            Data.bReachable = pTemp->State;
            Data.Destination = pTemp->Destination;
            memcpy(&Data.QocInfo, &DestQOCInfo, DestQOCInfo.dwSize);
            // NOTE: Set the following field appropriately. This is the best we can do.
            Data.strConnection = DEFAULT_LAN_CONNECTION_NAME;

            SensFireEvent((PVOID)&Data);
            }

        if (dwLastError != ERROR_SUCCESS)
            {
            SensPrintW(SENS_INFO, (L"ReachabilityPollingRoutine(): %s is not reachable - %d\n",
                       pTemp->Destination, dwLastError));

            if (ERROR_INVALID_PARAMETER == dwLastError)
                {
                // Remove the destination from further reachability checks.
                gpReachList->DeleteByDest(pTemp->Destination);
                }
            }

        pTemp = pTemp->Next;
        } // while()

    gpReachList->ReleaseLock();

    //
    // Dump the list
    //
    gpReachList->Print();

}





HRESULT
GetDestinationsFromSubscriptions(
    void
    )
/*++

Routine Description:

    Retrieve the names of destinations from Reachability subscriptions and
    insert into the Reachability List.

Arguments:

    None.

Return Value:

    S_OK, on success.

    HRESULT, on failure.

--*/
{
    HRESULT                 hr;
    int                     errorIndex;
    LONG                    lCount;
    BSTR                    bstrPropertyName;
    BSTR                    bstrEventClassID;
    VARIANT                 variantPropertyValue;
    WCHAR                   wszQuery[MAX_QUERY_SIZE];
    LPOLESTR                strGuid;
    IEventSystem            *pIEventSystem;
    IEventSubscription      *pIEventSubscription;
    IEventObjectCollection  *pSubscriptionCollection;
    IEnumEventObject        *pIEnumEventObject;

    hr = S_OK;
    lCount = 0;
    errorIndex = 0;
    strGuid = NULL;
    bstrPropertyName = NULL;
    bstrEventClassID = NULL;
    pIEventSystem = NULL;
    pIEventSubscription = NULL;
    pSubscriptionCollection = NULL;
    pIEnumEventObject = NULL;


    // Get a new IEventSystem object to play with.
    hr = CoCreateInstance(
             CLSID_CEventSystem,
             NULL,
             CLSCTX_SERVER,
             IID_IEventSystem,
             (LPVOID *) &pIEventSystem
             );
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("GetDestinationsFromSubscriptions(): failed to create ")
                  SENS_STRING("IEventSystem - hr = <%x>\n"), hr));
        goto Cleanup;
        }

    //
    // Form the query.
    //
    // (EventClassID = NetEventClassID) AND
    // (   (MethodName = 'DestinationReachable')
    //  OR (MethodName = 'DestinationReachableNoQocInfo'))
    //

    AllocateBstrFromGuid(bstrEventClassID, SENSGUID_EVENTCLASS_NETWORK);
    StringCchCopy(wszQuery, MAX_QUERY_SIZE, SENS_BSTR("(EventClassID="));
    StringCchCat(wszQuery, MAX_QUERY_SIZE,  bstrEventClassID);
    StringCchCat(wszQuery, MAX_QUERY_SIZE,  SENS_BSTR(") AND ( (MethodName = \'"));
    StringCchCat(wszQuery, MAX_QUERY_SIZE,  DESTINATION_REACHABLE_METHOD);
    StringCchCat(wszQuery, MAX_QUERY_SIZE,  SENS_BSTR("\') OR (MethodName = \'"));
    StringCchCat(wszQuery, MAX_QUERY_SIZE,  DESTINATION_REACHABLE_NOQOC_METHOD);
    StringCchCat(wszQuery, MAX_QUERY_SIZE,  SENS_BSTR("\'))"));

    hr = pIEventSystem->Query(
                            PROGID_EventSubscriptionCollection,
                            wszQuery,
                            &errorIndex,
                            (LPUNKNOWN *) &pSubscriptionCollection
                            );
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("GetDestinationsFromSubscriptions(): failed to Query() ")
                  SENS_STRING("- hr = <%x>\n"), hr));
        SensPrint(SENS_ERR, (SENS_STRING("errorIndex = %d\n"), errorIndex));
        goto Cleanup;
        }
    SensPrint(SENS_ERR, (SENS_STRING("Query = %s, hr = 0x%x\n"), wszQuery, hr));

#if DBG
    hr = pSubscriptionCollection->get_Count(&lCount);
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("GetDestinationsFromSubscriptions(): ")
                  SENS_STRING("get_Count() returned hr = <%x>\n"), hr));
        goto Cleanup;
        }
    SensPrint(SENS_ERR, (SENS_STRING("GetDestinationsFromSubscriptions(): ")
              SENS_STRING("Found %d Reachability subscriptions.\n"), lCount));

    if (0 == lCount)
        {
        goto Cleanup;
        }
#endif // DBG

    // Get a new Enum object to play with.
    hr = pSubscriptionCollection->get_NewEnum(
                                      (IEnumEventObject **) &pIEnumEventObject
                                      );
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("GetDestinationsFromSubscriptions(): ")
                  SENS_STRING("get_NewEnum() returned hr = <%x>\n"), hr));
        goto Cleanup;
        }

    hr = S_OK;
    hr = pIEnumEventObject->Reset();

    //
    // Extract each destination name and insert into list.
    //
    while (S_OK == hr)
        {
        ULONG cElements = 1;

        hr = pIEnumEventObject->Next(
                                    cElements,
                                    (LPUNKNOWN *) &pIEventSubscription,
                                    &cElements
                                    );
        if (   (S_OK != hr)
            || (1 != cElements))
            {
            SensPrint(SENS_ERR, (SENS_STRING("GetDestinationsFromSubscriptions(): ")
                      SENS_STRING("Next() failed hr = <%x>, count = %d\n"), hr, cElements));
            goto Cleanup;
            }

        //
        // Try to get the value for Publisher property - bstrDestination
        //
        VariantInit(&variantPropertyValue);
        AllocateBstrFromString(bstrPropertyName, PROPERTY_DESTINATION);

        hr = pIEventSubscription->GetPublisherProperty(
                                      bstrPropertyName,
                                      &variantPropertyValue
                                      );
        if (hr == S_OK)
            {
            // Found the property!
            gpReachList->InsertByDest(variantPropertyValue.bstrVal);
            SensPrint(SENS_ERR, (SENS_STRING("GetDestinationsFromSubscriptions(): ")
                      SENS_STRING("Added to Reachability List: %s\n"),
                      variantPropertyValue.bstrVal));
            goto ProcessNextSubscription;
            }

        //
        // Now, try to get the value for Publisher property - bstrDestinationNoQOC
        //
        FreeBstr(bstrPropertyName);
        VariantInit(&variantPropertyValue);
        AllocateBstrFromString(bstrPropertyName, PROPERTY_DESTINATION_NOQOC);

        hr = pIEventSubscription->GetPublisherProperty(
                                      bstrPropertyName,
                                      &variantPropertyValue
                                      );
        if (hr == S_OK)
            {
            // Found the property!
            gpReachList->InsertByDest(variantPropertyValue.bstrVal);
            SensPrint(SENS_ERR, (SENS_STRING("GetDestinationsFromSubscriptions(): ")
                      SENS_STRING("Added to Reachability List: %s\n"),
                      variantPropertyValue.bstrVal));
            goto ProcessNextSubscription;
            }

        SensPrint(SENS_ERR, (SENS_STRING("GetDestinationsFromSubscriptions(): failed to get ")
                  SENS_STRING("PublisherProperty - hr = <%x>\n"), hr));


ProcessNextSubscription:

        VariantClear(&variantPropertyValue);
        FreeBstr(bstrPropertyName);

        pIEventSubscription->Release();
        pIEventSubscription = NULL;
        hr = S_OK;
        } // while()


Cleanup:
    //
    // Cleanup
    //
    if (pIEventSystem)
        {
        pIEventSystem->Release();
        }
    if (pIEventSubscription)
        {
        pIEventSubscription->Release();
        }
    if (pSubscriptionCollection)
        {
        pSubscriptionCollection->Release();
        }
    if (pIEnumEventObject)
        {
        pIEnumEventObject->Release();
        }

    FreeBstr(bstrEventClassID);
    FreeStr(strGuid);

    return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\senssvc\guids.c ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    guids.c

Abstract:

    Define the GUIDs used.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          12/10/1997         Start.

--*/



#pragma data_seg(".text")

#define INITGUID

#include <objbase.h>
#include <initguid.h>


// All guid header files
#include <coguid.h>
#include <ndisguid.h>
#include <ntddndis.h>
#include <wmium.h>
#include <sens.h>

#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\senssvc\linklist.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    linklist.cxx

Abstract:

    Implements a linked list for Destination Reachability.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          10/30/1997         Start.

--*/

#include <precomp.hxx>

#define WCHAR_Y     ((WCHAR) 'Y')
#define WCHAR_N     ((WCHAR) 'N')
#define WCHAR_X     ((WCHAR) '-')


NODE::NODE()
{
    Next = NULL;
    Prev = NULL;
    Destination = NULL;
    SubId = ~0;
    cRef = 1;
    State = UNTRIED;
}

NODE::NODE(DWORD Id, PWCHAR Dest, PDWORD pdwStatus)
{
    *pdwStatus = ERROR_SUCCESS;
    Next = NULL;
    Prev = NULL;

    // Make a copy of the Destination name
    size_t size = wcslen(Dest) + 1;
    Destination = (PWCHAR) new WCHAR[size];
    if (Destination != NULL)
        {
        StringCchCopyW(Destination, size, Dest);
        }
    else
        {
        *pdwStatus = ERROR_OUTOFMEMORY;
        }

    SubId = Id;
    cRef = 1;
    State = UNTRIED;
}

NODE::~NODE()
{
    if (Destination != NULL)
        {
        delete Destination;
        }
}

LIST::LIST()
{
    pHead = NULL;

    cElements = 0;

    InitializeCriticalSection(&ListLock);
}


LIST::~LIST()
{
    DeleteAll();

    DeleteCriticalSection(&ListLock);
}

DWORD
LIST::Insert(
    PNODE pNew
    )
{
    ASSERT(pNew != NULL);
    ASSERT(pNew->Destination != NULL);

    RequestLock();

    //
    // See if it is already present. Find() will add a reference to the
    // destination if it is already present in the list.
    //
    if (NULL != Find(pNew->Destination, TRUE))
        {
        ReleaseLock();
        Print();
        return ERROR_ALREADY_EXISTS;
        }

    pNew->Next = pHead;
    if (pHead != NULL)
        {
        pHead->Prev = pNew;
        }
    pHead = pNew;

    cElements++;

    ReleaseLock();

    Print();

    return ERROR_SUCCESS;
}

DWORD
LIST::InsertByDest(
    PWCHAR lpszDest
    )
{
    DWORD dwStatus = ERROR_SUCCESS;
    PNODE pNode = NULL;

    // Insert into the global list
    pNode = new NODE(99, lpszDest, &dwStatus);
    if (   (dwStatus != ERROR_SUCCESS)
        || (pNode == NULL))
        {
        if (pNode)
            {
            delete pNode;
            }
        return ERROR_OUTOFMEMORY;
        }

    dwStatus = Insert(pNode);

    if (ERROR_ALREADY_EXISTS == dwStatus)
        {
        delete pNode;
        }

    return dwStatus;
}

inline void
LIST::Delete(
    PNODE pDelete
    )
{
    // Should be always called with the ListLock held.

    if (0 != pDelete->Release())
        {
        Print();
        return;
        }

    if (pDelete->Next != NULL)
        {
        pDelete->Next->Prev = pDelete->Prev;
        }

    if (pDelete->Prev != NULL)
        {
        pDelete->Prev->Next = pDelete->Next;
        }

    if (pDelete == pHead)
        {
        pHead = pDelete->Next;
        }

    delete pDelete;

    cElements--;

    Print();
}

BOOL
LIST::DeleteByDest(
    PWCHAR lpszDest
    )
{
    PNODE pTemp = NULL;

    RequestLock();

    pTemp = pHead;
    while (pTemp != NULL)
        {
        if (wcscmp(pTemp->Destination, lpszDest) == 0)
            {
            Delete(pTemp);
            ReleaseLock();
            return TRUE;
            }

        pTemp = pTemp->Next;
        }

    ReleaseLock();

    return FALSE;
}

BOOL
LIST::DeleteById(
    DWORD Id
    )
{
    PNODE pTemp = NULL;

    RequestLock();

    pTemp = pHead;
    while (pTemp != NULL)
        {
        if (pTemp->SubId == Id)
            {
            Delete(pTemp);
            ReleaseLock();
            return TRUE;
            }

        pTemp = pTemp->Next;
        }

    ReleaseLock();

    return FALSE;
}

void
LIST::DeleteAll(
    void
    )
{
    PNODE pTemp, pDelete;

    RequestLock();

    pTemp = pHead;
    while (pTemp != NULL)
        {
        pDelete = pTemp;
        pTemp = pTemp->Next;
        delete pDelete;
        cElements--;
        }

    ASSERT(cElements == 0);

    ReleaseLock();
}

PNODE
LIST::Find(
    PWCHAR lpszDest,
    BOOL bAddReference
    )
{
    PNODE pTemp = NULL;

    RequestLock();

    pTemp = pHead;
    while (pTemp != NULL)
        {
        if (wcscmp(pTemp->Destination, lpszDest) == 0)
            {
            if (TRUE == bAddReference)
                {
                pTemp->AddRef();
                }
            ReleaseLock();
            return pTemp;
            }

        pTemp = pTemp->Next;
        }

    ReleaseLock();

    return NULL;
}

BOOL
LIST::IsEmpty(
    void
    )
{
    RequestLock();

    if (pHead == NULL)
        {
        ASSERT(cElements == 0);

        ReleaseLock();

        return TRUE;
        }

    ReleaseLock();

    return FALSE;
}

void
LIST::Print(
    void
    )
{
#ifdef DBG

    PNODE pTemp;


    SensPrintA(SENS_INFO, ("\n\t|----------------------------------------------------------|\n"));
    SensPrintA(SENS_INFO, ("\t|           R E A C H A B I L I T Y   L I S T              |\n"));
    SensPrintA(SENS_INFO, ("\t|----------------------------------------------------------|\n"));
    SensPrintA(SENS_INFO, ("\t|----------------------------------------------------------|\n"));
    SensPrintA(SENS_INFO, ("\t|  cRef | Reachable |          Destination                 |\n"));
    SensPrintA(SENS_INFO, ("\t|----------------------------------------------------------|\n"));

    RequestLock();

    pTemp = pHead;
    while (pTemp != NULL)
        {
        SensPrintW(SENS_INFO, (L"\t| %3d   |     %c     |     %s\n",
                   pTemp->cRef,
                   (pTemp->State == REACHABLE) ? WCHAR_Y : ((pTemp->State == UNTRIED) ? WCHAR_X : WCHAR_N),
                   pTemp->Destination ? pTemp->Destination : L"<NULL>")
                   );
        pTemp = pTemp->Next;
        }

    ReleaseLock();

    SensPrintA(SENS_INFO, ("\t|----------------------------------------------------------|\n\n"));

#else

    // Nothing

#endif // DBG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\senssvc\senssvc.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    senssvc.cxx

Abstract:

    This file implements the Init/Uninit functionality of System Event
    Notification service (SENS).

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          09-20-1997         Start.

--*/


#include <precomp.hxx>


#define MIN_CALL_THREADS            1
#define SENS_CLEANUP_TIMEOUT        15*1000     // Max wait
#define SENS_WAITFORINIT_TIMEOUT    30*1000     // 30 seconds max

//
// Globals
//

IEventSystem        *gpIEventSystem;
HANDLE              ghSensHeap;
HANDLE              ghSensStartedEvent;
CRITICAL_SECTION    gSensLock;
DWORD               gdwRegCO;
DWORD               gdwLocked;
LPCLASSFACTORY      gpChangeCF;

#ifdef DBG
DWORD           gdwDebugOutputLevel;
#endif // DBG

//
// External Globals
//

// Common
extern LONG     g_cFilterObj;
extern LONG     g_cFilterLock;
extern LONG     g_cSubChangeObj;
extern LONG     g_cSubChangeLock;
extern LIST     *gpReachList;
extern BOOL     gbIpInitSuccessful;
extern BOOL     gbIsRasInstalled;
extern long     gdwLastLANTime;
extern long     gdwLANState;
extern HANDLE   ghReachTimer;
extern HANDLE   ghMediaTimer;
extern long     gdwLastWANTime;
extern long     gdwWANState;
extern IF_STATE gIfState[MAX_IF_ENTRIES];
extern MIB_IPSTATS          gIpStats;
extern SYSTEM_POWER_STATUS  gSystemPowerState;


BOOL
SensInitialize(
    void
    )
/*++

Routine Description:

    Main entry into SENS.

Arguments:

    None.

Return Value:

    TRUE, if successful.

    FALSE, otherwise

--*/
{
    BOOL bRetValue;
	BOOL bComInitialized;

    bRetValue = FALSE;
	bComInitialized = FALSE;

#ifdef DBG
    DWORD dwNow = GetTickCount();
    EnableDebugOutputIfNecessary();

    SensPrintA(SENS_INFO, ("[%d] Initializing SENS...\n", dwNow));
#endif // DBG

    // This will Initialize COM on success.
    if (FALSE == Init())
        {
        SensPrintA(SENS_ERR, ("[%d] Init() failed.\n",
                   GetTickCount()));
        bRetValue = FALSE;
        goto Cleanup;
        }

	bComInitialized = TRUE;

    //
    // This will call CoRegisterClassObject and will help in service
    // startup. So, call this before ConfigureSensIfNecessary()
    //
    if (FALSE == DoEventSystemSetup())
        {
        SensPrintA(SENS_ERR, ("[%d] DoEventSystemSetup() failed.\n", GetTickCount()));
        }
    else
        {
        SensPrintA(SENS_INFO, ("[%d] DoEventSystemSetup() Succeeded.\n", GetTickCount()));
        }

    if (FALSE == ConfigureSensIfNecessary())
        {
        SensPrintA(SENS_ERR, ("[%d] ConfigureSensIfNecessary() failed.\n", GetTickCount()));
        }
    else
        {
        SensPrintA(SENS_INFO, ("[%d] ConfigureSensIfNecessary() Succeeded.\n", GetTickCount()));
        }

    if (FALSE == DoWanSetup())
        {
        SensPrintA(SENS_ERR, ("[%d] DoWanSetup() failed.\n", GetTickCount()));
        }
    else
        {
        SensPrintA(SENS_INFO, ("[%d] DoWanSetup() Succeeded.\n", GetTickCount()));
        }

    if (FALSE == DoLanSetup())
        {
        SensPrintA(SENS_ERR, ("[%d] DoLanSetup() failed.\n", GetTickCount()));
        bRetValue = FALSE;
        goto Cleanup;
        }
    SensPrintA(SENS_INFO, ("[%d] DoLanSetup() Succeeded.\n", GetTickCount()));

    if (FALSE == DoRpcSetup())
        {
        SensPrintA(SENS_ERR, ("[%d] DoRpcSetup() failed.\n", GetTickCount()));
        bRetValue = FALSE;
        goto Cleanup;
        }
    SensPrintA(SENS_INFO, ("[%d] DoRpcSetup() Succeeded.\n", GetTickCount()));

    bRetValue = TRUE;

    SensPrintA(SENS_DBG, ("[%d] Service start took %d msec.\n", GetTickCount(), (GetTickCount() - dwNow)));

Cleanup:
    //
    // Cleanup
    //

	if (bComInitialized)
		{
		//
		// This thread (service start) will exit shortly after we return.  Our event system
		// instance and other COM registrations are kept alive by the main svchost thread
		// which is initialized MTA.
		//
		CoUninitialize();
		}

    return bRetValue;
}


inline void
InitializeSensGlobals(
    void
    )
/*++

Routine Description:

    Initialize the global variables. This is needed if we are to run
    within svchost.exe.

Arguments:

    None.

Notes:

    Some of the SENS globals are initialized during SensInitialize()
    processing. Look at ServiceMain(), DoLanSetup(), DoWanSetup() etc.

Return Value:

    None.

--*/
{
    //
    // Common across platforms
    //

    // Pointers
    gpReachList         = NULL;
    gpIEventSystem      = NULL;
    gpSensCache         = NULL;
    gpChangeCF          = NULL;

    // Handles
    ghSensHeap          = NULL;
    ghReachTimer        = NULL;
    ghSensFileMap       = NULL;
    ghSensStartedEvent  = NULL;
    // BOOLs
    gbIpInitSuccessful      = FALSE;
    gbIsRasInstalled        = FALSE;
    gdwLocked               = FALSE;
    // DWORDs
    gdwLastLANTime      = 0x0;
    gdwLANState         = 0x0;
    gdwLastWANTime      = 0x0;
    gdwWANState         = 0x0;
    gdwRegCO            = 0x0;
    g_cFilterObj        = 0x0;
    g_cFilterLock       = 0x0;
    g_cSubChangeObj     = 0x0;
    g_cSubChangeLock    = 0x0;
    gdwMediaSenseState = SENSSVC_START;
    // Structures
    memset(gIfState, 0x0, (sizeof(IF_STATE) * MAX_IF_ENTRIES));
    memset(&gIpStats, 0x0, sizeof(MIB_IPSTATS));
    memset(&gSystemPowerState, 0x0, sizeof(SYSTEM_POWER_STATUS));
    memset(&gSensLock, 0x0, sizeof(CRITICAL_SECTION));
}


inline BOOL
Init(
    void
    )
/*++

Routine Description:

    Perform initialization at startup.

Arguments:

    None.

Notes:

    This should be called early in SensInitialize().

Return Value:

    TRUE, if successful.

    FALSE, otherwise

--*/
{
    HRESULT hr;
    BOOL bRetValue;
    BOOL bComInitialized;
    OSVERSIONINFO VersionInfo;

    hr = S_OK;
    bRetValue = FALSE;
    bComInitialized = FALSE;

    // Reset
    InitializeSensGlobals();

    //
    // Initialize COM
    //
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        {
        SensPrintA(SENS_ERR, ("[%d] CoInitializeEx() failed, HRESULT=%x\n", GetTickCount(), hr));
        bRetValue = FALSE;
        goto Cleanup;
        }
    bComInitialized = TRUE;

    // Use Default Process heap
    ghSensHeap = GetProcessHeap();
    if (ghSensHeap == NULL)
        {
        SensPrintToDebugger(SENS_DBG, ("[SENS] Failed to obtain ProcessHeap() - 0x%x!\n", GetLastError()));
        bRetValue = FALSE;
        goto Cleanup;
        }

    // Initialize Sens Global lock
    InitializeCriticalSection(&gSensLock);

    // Destination Reachability Event setup
    if (FALSE == InitReachabilityEngine())
        {
        SensPrintToDebugger(SENS_DBG, ("[SENS] Failed to initialize reachability engine!\n"));
        bRetValue = FALSE;
        goto Cleanup;
        }

    gpIEventSystem = NULL;

    if (FALSE == CreateSensCache())
        {
        SensPrintToDebugger(SENS_DBG, ("[SENS] Failed to create SENS Cache!\n"));
        }

    // Get a handle to the SensStartEvent.
    // The event may also be created in the wlnotify dll (winlogon).
    ghSensStartedEvent = CreateEvent(NULL,      // Specific Security Attributes
                                     TRUE,      // Event is ManualReset
                                     FALSE,     // Initial state is not Signalled
                                     SENS_STARTED_EVENT
                                     );
    if (ghSensStartedEvent == NULL)
        {
        SensPrintToDebugger(SENS_DBG, ("[SENS] Failed to Open SensStartedEvent - 0x%x!\n", GetLastError()));
        }
    else
        {
        SensPrint(SENS_INFO, (SENS_STRING("[%d] Successfully opened SensStartedEvent.\n"), GetTickCount()));
        }

    bRetValue = TRUE;

Cleanup:
    //
    // Cleanup stuff when we fail to Init properly.
    //
    if (FALSE == bRetValue)
        {
        // Release EventSystem
        if (gpIEventSystem != NULL)
            {
            gpIEventSystem->Release();
			gpIEventSystem = 0;
            }

        // Uninit COM because SensUninitialize() is not going to be called.
        if (TRUE == bComInitialized)
            {
            CoUninitialize();
            }
        }

    return bRetValue;
}


BOOL
CreateSids(
    PSID*	ppsidBuiltInAdministrators,
    PSID*	ppsidSystem,
    PSID*	ppsidWorld
)
/*++

Routine Description:

    Creates and return pointers to three SIDs one for each of World,
    Local Administrators, and System.
	
	
Note:

	IDENTICAL TO A FUNCTION IN OLE32\DCOMSS\WRAPPER\EPTS.C.		

Arguments:

    ppsidBuiltInAdministrators - Receives pointer to SID representing local
        administrators; 
    ppsidSystem - Receives pointer to SID representing System;
    ppsidWorld - Receives pointer to SID representing World.

Return Value:

    BOOL indicating success (TRUE) or failure (FALSE).

    Caller must free returned SIDs by calling FreeSid() for each returned
    SID when this function return TRUE; pointers should be assumed garbage
    when the function returns FALSE.

--*/
{
    //
    // An SID is built from an Identifier Authority and a set of Relative IDs
    // (RIDs).  The Authority of interest to us SECURITY_NT_AUTHORITY.
    //

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY WorldAuthority = SECURITY_WORLD_SID_AUTHORITY;

    //
    // Each RID represents a sub-unit of the authority.  Local
    // Administrators is in the "built in" domain.  The other SIDs, for
    // Authenticated users and system, is based directly off of the
    // authority. 
    //     
    // For examples of other useful SIDs consult the list in
    // \nt\public\sdk\inc\ntseapi.h.
    //

    if (!AllocateAndInitializeSid(&NtAuthority,
                                  2,            // 2 sub-authorities
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS,
                                  0,0,0,0,0,0,
                                  ppsidBuiltInAdministrators)) {

        // error

    } else if (!AllocateAndInitializeSid(&NtAuthority,
                                         1,            // 1 sub-authorities
                                         SECURITY_LOCAL_SYSTEM_RID,
                                         0,0,0,0,0,0,0,
                                         ppsidSystem)) {

        // error

        FreeSid(*ppsidBuiltInAdministrators);
        *ppsidBuiltInAdministrators = NULL;

    } else if (!AllocateAndInitializeSid(&WorldAuthority,
                                         1,            // 1 sub-authority
                                         SECURITY_WORLD_RID,
                                         0,0,0,0,0,0,0,
                                         ppsidWorld)) {

        // error

        FreeSid(*ppsidBuiltInAdministrators);
        *ppsidBuiltInAdministrators = NULL;

        FreeSid(*ppsidSystem);
        *ppsidSystem = NULL;

    } else {
        return TRUE;
    }

    return FALSE;
}


PSECURITY_DESCRIPTOR
CreateSd(
    VOID
)
/*++

Routine Description:

    Creates and return a SECURITY_DESCRIPTOR with a DACL granting
    (GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | SYNCHRONIZE) to World,
    and GENERIC_ALL to Local Administrators and System.
	
Notes: 

	SIMILAR TO A FUNCTION IN OLE32\DCOMSS\WRAPPER\EPTS.C.	

Arguments:

    None

Return Value:

    Pointer to the created SECURITY_DESCRIPTOR, or NULL if an error occurred.

    Caller must free returned SECURITY_DESCRIPTOR back to process heap by
    a call to HeapFree.

--*/
{
    PSID	psidWorld;
    PSID	psidBuiltInAdministrators;
    PSID	psidSystem;

    if (!CreateSids(&psidBuiltInAdministrators,
                    &psidSystem,
                    &psidWorld)) {

        // error

    } else {

        // 
        // Calculate the size of and allocate a buffer for the DACL, we need
        // this value independently of the total alloc size for ACL init.
        //

        PSECURITY_DESCRIPTOR    Sd = NULL;
        ULONG                   AclSize;

        //
        // "- sizeof (ULONG)" represents the SidStart field of the
        // ACCESS_ALLOWED_ACE.  Since we're adding the entire length of the
        // SID, this field is counted twice.
        //

        AclSize = sizeof (ACL) +
            (3 * (sizeof (ACCESS_ALLOWED_ACE) - sizeof (ULONG))) +
            GetLengthSid(psidWorld) +
            GetLengthSid(psidBuiltInAdministrators) +
            GetLengthSid(psidSystem);

        Sd = (PSID)new char[SECURITY_DESCRIPTOR_MIN_LENGTH + AclSize];

        if (!Sd) {

            // error

        } else {

            ACL                     *Acl;

            Acl = (ACL *)((BYTE *)Sd + SECURITY_DESCRIPTOR_MIN_LENGTH);

            if (!InitializeAcl(Acl,
                               AclSize,
                               ACL_REVISION)) {

                // error

            } else if (!AddAccessAllowedAce(Acl,
                                            ACL_REVISION,
                                            SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE,
                                            psidWorld)) {

                // Failed to build the ACE granting "WORLD"
                // (SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE) access.

            } else if (!AddAccessAllowedAce(Acl,
                                            ACL_REVISION,
                                            GENERIC_ALL,
                                            psidBuiltInAdministrators)) {

                // Failed to build the ACE granting "Built-in Administrators"
                // (GENERIC_ALL) access.

            } else if (!AddAccessAllowedAce(Acl,
                                            ACL_REVISION,
                                            GENERIC_ALL,
                                            psidSystem)) {

                // Failed to build the ACE granting "System"
                // GENERIC_ALL access.

            } else if (!InitializeSecurityDescriptor(Sd,
                                                     SECURITY_DESCRIPTOR_REVISION)) {

                // error

            } else if (!SetSecurityDescriptorDacl(Sd,
                                                  TRUE,
                                                  Acl,
                                                  FALSE)) {

                // error

            } else {
                FreeSid(psidWorld);
                FreeSid(psidBuiltInAdministrators);
                FreeSid(psidSystem);

                return Sd;
            }

			delete (char *)Sd;
        }

        FreeSid(psidWorld);
        FreeSid(psidBuiltInAdministrators);
        FreeSid(psidSystem);
    }

    return NULL;
}


RPC_STATUS
RPC_ENTRY
SENS_CheckLocalCallback(
    RPC_IF_HANDLE ifhandle,
    void *Context
    )
/*++

Routine Description:

    SENS runs in a shared service host which means it is possible for a
    caller on another machine to call SENS.  This is not expected and is
    blocked by this callback routine in order to reduce the potential 
    attack surface of RPC.

Arguments:

    ifhandle - interface this callback is registered with (ignored)
    context - context to discover information about the caller (ignored)

Return Value:

    RPC_S_OK - caller allowed to call methods in the interface
    other - caller is blocked

--*/
{
    unsigned fLocal = FALSE;

    if (   (RPC_S_OK == I_RpcBindingIsClientLocal(0, &fLocal))
        && (fLocal) )
        {
        return RPC_S_OK;
        }

    return RPC_S_ACCESS_DENIED;
}


BOOL
DoRpcSetup(
    void
    )
/*++

Routine Description:

    Perform RPC server initialization.

Arguments:

    None.

Return Value:

    TRUE, if successful.

    FALSE, otherwise

--*/
{
    RPC_STATUS status;
    BOOL fDontWait;
    BOOL bRetValue;
    PSECURITY_DESCRIPTOR psd;

    status = RPC_S_OK;
    fDontWait = TRUE;
    bRetValue = FALSE;

	// Make sure RPC allocates thread stacks of sufficient size.
	status = RpcMgmtSetServerStackSize(2*4096);
	ASSERT(status == RPC_S_OK);

	psd = CreateSd();
	if (!psd)
		{
		bRetValue = FALSE;
		goto Cleanup; 
		}

    status = RpcServerUseProtseqEp(
                 SENS_PROTSEQ,
                 RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                 SENS_ENDPOINT,
                 psd            // Security descriptor
                 );

	delete (char *)psd;

    if (RPC_S_DUPLICATE_ENDPOINT == status)
        {
        SensPrintA(SENS_ERR, ("[%d] DoRpcSetup(): Endpoint already created. Continuing!\n", GetTickCount()));
        status = RPC_S_OK;
        }

    if (RPC_S_OK != status)
        {
        SensPrintA(SENS_ERR, ("[%d] DoRpcSetup(): RpcServerUseProtseqEp() returned 0x%x\n", GetTickCount(), status));
        bRetValue = FALSE;
        goto Cleanup;
        }

    //
    // On NT platforms, use auto-listen interfaces. We don't need to call
    // RpcServerListen().
    //

    // SENS API interface
    status = RpcServerRegisterIfEx(
                 SensApi_ServerIfHandle,        // The interface
                 NULL,                          // MgrTypeUuid
                 NULL,                          // MgrEpv
                 RPC_IF_AUTOLISTEN,             // Flags
                 RPC_C_LISTEN_MAX_CALLS_DEFAULT,// Max calls value
                 SENS_CheckLocalCallback        // Security Callback function
                 );
    if (RPC_S_OK != status)
        {
        SensPrintA(SENS_ERR, ("[%d] DoRpcSetup(): RpcServerRegisterIfEx(1) returned 0x%x\n", GetTickCount(), status));
        bRetValue = FALSE;
        goto Cleanup;
        }

    // SensNotify interface
    status = RpcServerRegisterIfEx(
                 SENSNotify_ServerIfHandle,     // The interface
                 NULL,                          // MgrTypeUuid
                 NULL,                          // MgrEpv
                 RPC_IF_AUTOLISTEN,             // Flags
                 RPC_C_LISTEN_MAX_CALLS_DEFAULT,// Max calls value
                 SENS_CheckLocalCallback        // Security Callback function
                 );
    if (RPC_S_OK != status)
        {
        SensPrintA(SENS_ERR, ("[%d] DoRpcSetup(): RpcServerRegisterIfEx(2) returned 0x%x\n", GetTickCount(), status));
        bRetValue = FALSE;
        goto Cleanup;
        }

    // All's well.
    bRetValue = TRUE;

Cleanup:
    //
    // Cleanup
    //
    return bRetValue;
}




BOOL
SensUninitialize(
    void
    )
/*++

Routine Description:

    Perform any cleanup.

Arguments:

    None.

Return Value:

    TRUE, if successful.

    FALSE, otherwise

--*/
{
    int err;
    RPC_STATUS status;
    BOOL bRetValue;
    HRESULT hr;
    DWORD dwNow;

    bRetValue = TRUE;
    hr = S_OK;
    dwNow = GetTickCount();

    SensPrintA(SENS_ERR, ("[%d] Begin stopping of SENS Service...\n", dwNow));

    // Unregister media sense notifications.
    if (FALSE == MediaSenseUnregister())
        {
        SensPrintA(SENS_ERR, ("[%d] SensUninitialize(): MediaSenseUnregister() failed.\n", GetTickCount()));
        }
    else
        {
        SensPrintA(SENS_INFO, ("[%d] SensUninitialize(): MediaSenseUnregister() succeeded.\n", GetTickCount()));
        }

    // Unregister the RPC interface #1
    status = RpcServerUnregisterIf(
                 SensApi_ServerIfHandle,
                 NULL,   // MgrTypeUuid
                 FALSE   // WaitForCallsToComplete
                 );
	ASSERT(status == RPC_S_OK);
    if (RPC_S_OK != status)
        {
        SensPrintA(SENS_ERR, ("[%d] SensUninitialize(): RpcServerUnegisterIf(1) returned 0x%x\n", GetTickCount(), status));
        bRetValue = FALSE;
        goto Cleanup;
        }
    SensPrintA(SENS_INFO, ("[%d] SensUninitialize(): RpcServerUnregisterIf(1) succeeded.\n", GetTickCount()));

    // Unregister the RPC interface #2
    status = RpcServerUnregisterIf(
                 SENSNotify_ServerIfHandle,
                 NULL,   // MgrTypeUuid
                 FALSE   // WaitForCallsToComplete
                 );
	ASSERT(status == RPC_S_OK);
    if (RPC_S_OK != status)
        {
        SensPrintA(SENS_ERR, ("[%d] SensUninitialize(): RpcServerUnegisterIf(2) returned 0x%x\n", GetTickCount(), status));
        bRetValue = FALSE;
        goto Cleanup;
        }
    SensPrintA(SENS_INFO, ("[%d] SensUninitialize(): RpcServerUnregisterIf(2) succeeded.\n", GetTickCount()));
    
	//
    // Remove our classfactory from COM's cache.
    //
    if (0x0 != gdwRegCO)
        {
        hr = CoRevokeClassObject(gdwRegCO);
        }

    if (NULL != gpChangeCF)
        {
        gpChangeCF->Release();
        }

    //
    // EventSystem specific cleanup.
    //
    if (gpIEventSystem)
        {
        gpIEventSystem->Release();
        }

    //
    // Stop Reachability polling
    //
    StopReachabilityEngine();

    //
    // Empty the destination reachability list
    //
    if (NULL != gpReachList)
        {
        delete gpReachList;

        gpReachList = NULL;
        }

    //
    // Destroy SENS Cache
    //
    DeleteSensCache();

    // Cleanup started event handle
    ResetEvent(ghSensStartedEvent);
    CloseHandle(ghSensStartedEvent);
    ghSensStartedEvent = 0;

    // Delete Global SENS lock
    DeleteCriticalSection(&gSensLock);

    bRetValue = TRUE;

    SensPrintToDebugger(SENS_DBG, ("\n[SENS] [%d] Service Stopped.\n\n", GetTickCount()));

Cleanup:
    //
    // Cleanup
    //

    // Cleanup Winsock.
    err = WSACleanup();
    if (err != 0)
        {
        SensPrintA(SENS_ERR, ("[%d] SensUninitialize(): WSACleanup() returned GLE of %d\n", GetTickCount(),
                   WSAGetLastError()));
        }

    SensPrintA(SENS_INFO, ("[%d] Stopping SENS took %d msec.\n\n", GetTickCount(), (GetTickCount()-dwNow)));

    return bRetValue;
}



BOOL
DoEventSystemSetup(
    void
    )
/*++

Routine Description:

    Perform the EventSystem specific initialization here.

Arguments:

    None.

Return Value:

    TRUE, if successful.

    FALSE, otherwise

--*/
{
    HRESULT hr;
    BOOL bRetValue;

    hr = S_OK;
    bRetValue = FALSE;

    //
    // Instantiate the Event System
    //
    hr = CoCreateInstance(
             CLSID_CEventSystem,
             NULL,
             CLSCTX_SERVER,
             IID_IEventSystem,
             (LPVOID *) &gpIEventSystem
             );
    if (FAILED(hr))
        {
        SensPrintA(SENS_ERR, ("[%d] Failed to create CEventSystem, HRESULT=%x\n", GetTickCount(), hr));
        goto Cleanup;
        }

    //
    // Create the IEventObjectChange ClassFactory and register it with COM.
    //
    gpChangeCF = new CIEventObjectChangeCF;
    if (NULL == gpChangeCF)
        {
        SensPrintA(SENS_ERR, ("[%d] Failed to allocate IEventObjectChange ClassFactory object", GetTickCount()));
        goto Cleanup;
        }
    // Add our reference to it.
    gpChangeCF->AddRef();

    SensPrintA(SENS_INFO, ("[%d] ClassFactory created successfully.\n", GetTickCount()));

    // Register the CLSID
    hr = CoRegisterClassObject(
             SENSGUID_SUBSCRIBER_LCE,
             (LPUNKNOWN) gpChangeCF,
             CLSCTX_LOCAL_SERVER,
             REGCLS_MULTIPLEUSE,
             &gdwRegCO
             );
    if (FAILED(hr))
        {
        SensPrintA(SENS_ERR, ("[%d] CoRegisterClassObject(IEventObjectChange) returned 0x%x.\n", GetTickCount(), hr));
        goto Cleanup;
        }

    SensPrintA(SENS_ERR, ("[%d] Successfully registered the Class Factories.\n", GetTickCount()));
    bRetValue = TRUE;

Cleanup:
    //
    // Cleanup
    //
    if (FALSE == bRetValue)
        {
        if (0x0 != gdwRegCO)
            {
            hr = CoRevokeClassObject(gdwRegCO);
            gdwRegCO = 0x0;
            }

        if (gpChangeCF)
            {
            delete gpChangeCF;
            gpChangeCF = NULL;
            }
        }

    return bRetValue;
}




BOOL
ConfigureSensIfNecessary(
    void
    )
/*++

Routine Description:

    Perform the configuration necessary for SENS.

Arguments:

    None.

Return Value:

    TRUE, if successful.

    FALSE, otherwise

--*/
{
    HRESULT hr;
    HKEY hKeySens;
    LONG RegStatus;
    BOOL bStatus;
    DWORD dwType;
    DWORD cbData;
    DWORD dwConfigured;
    LPBYTE lpbData;
    HMODULE hSensCfgDll;
    FARPROC pRegisterFunc;

    hr = S_OK;
    hKeySens = NULL;
    RegStatus = ERROR_SUCCESS;
    bStatus = FALSE;
    dwType = 0x0;
    cbData = 0x0;
    dwConfigured = CONFIG_VERSION_NONE;
    lpbData = NULL;
    hSensCfgDll = NULL;
    pRegisterFunc = NULL;

    RegStatus = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE, // Handle of the key
                    SENS_REGISTRY_KEY,  // String which represents the sub-key to open
                    0,                  // Reserved (MBZ)
                    KEY_ALL_ACCESS,     // Security Access mask
                    &hKeySens           // Returned HKEY
                    );
    if (RegStatus != ERROR_SUCCESS)
        {
        SensPrintA(SENS_ERR, ("RegOpenKeyEx(Sens) returned %d.\n", RegStatus));
        goto Cleanup;
        }

    //
    // Query the Configured value
    //
    lpbData = (LPBYTE) &dwConfigured;
    cbData = sizeof(DWORD);

    RegStatus = RegQueryValueEx(
                    hKeySens,           // Handle of the sub-key
                    IS_SENS_CONFIGURED, // Name of the Value
                    NULL,               // Reserved (MBZ)
                    &dwType,            // Address of the type of the Value
                    lpbData,            // Address of the data of the Value
                    &cbData             // Address of size of data of the Value
                    );
    if (RegStatus != ERROR_SUCCESS)
        {
        SensPrintA(SENS_ERR, ("RegQueryValueEx(IS_SENS_CONFIGURED) failed with 0x%x\n", RegStatus));
        goto Cleanup;
        }
    ASSERT(dwType == REG_DWORD);

    if (dwConfigured >= CONFIG_VERSION_CURRENT)
        {
        SensPrintA(SENS_ERR, ("[%d] SENS is already configured!\n", GetTickCount()));
        bStatus = TRUE;
        goto Cleanup;
        }

    //
    // Sens is not yet configured to the latest version. So, do the necessary
    // work now.
    //

    // Try to Load the Configuration Dll
    hSensCfgDll = LoadLibrary(SENS_CONFIGURATION_DLL);
    if (hSensCfgDll == NULL)
        {
        SensPrintA(SENS_ERR, ("LoadLibrary(SensCfg) returned 0x%x.\n", GetLastError()));
        goto Cleanup;
        }

    // Get the required entry point.
    pRegisterFunc = GetProcAddress(hSensCfgDll, SENS_REGISTER_FUNCTION);
    if (pRegisterFunc == NULL)
        {
        SensPrintA(SENS_ERR, ("GetProcAddress(Register) returned 0x%x.\n", GetLastError()));
        goto Cleanup;
        }

    // Do the registration now.
    hr = (HRESULT)((*pRegisterFunc)());
    if (FAILED(hr))
        {
        SensPrintA(SENS_ERR, ("RegisterSens() returned with 0x%x\n", hr));
        goto Cleanup;
        }

    // Update registry to reflect that SENS is now configured.
    dwConfigured = CONFIG_VERSION_CURRENT;
    RegStatus = RegSetValueEx(
                  hKeySens,             // Key to set Value for.
                  IS_SENS_CONFIGURED,   // Value to set
                  0,                    // Reserved
                  REG_DWORD,            // Value Type
                  (BYTE*) &dwConfigured,// Address of Value data
                  sizeof(DWORD)         // Size of Value
                  );
    if (RegStatus != ERROR_SUCCESS)
        {
        SensPrintA(SENS_ERR, ("RegSetValueEx(IS_SENS_CONFIGURED) failed with 0x%x\n", RegStatus));
        goto Cleanup;
        }


    SensPrintA(SENS_INFO, ("[%d] SENS is now configured successfully. Registry updated.\n", GetTickCount()));
    bStatus = TRUE;

Cleanup:
    //
    // Cleanup
    //
    if (hKeySens)
        {
        RegCloseKey(hKeySens);
        }
    if (hSensCfgDll)
        {
        FreeLibrary(hSensCfgDll);
        }

    return bStatus;
}

extern "C" int APIENTRY
DllMain(
    IN HINSTANCE hInstance,
    IN DWORD dwReason,
    IN LPVOID lpvReserved
    )
/*++

Routine Description:

    This routine will get called either when a process attaches to this dll
    or when a process detaches from this dll.

Return Value:

    TRUE - Initialization successfully occurred.

    FALSE - Insufficient memory is available for the process to attach to
        this dll.

--*/
{
    BOOL bSuccess;

    switch (dwReason)
        {
        case DLL_PROCESS_ATTACH:
            // Disable Thread attach/detach calls
            bSuccess = DisableThreadLibraryCalls(hInstance);
            ASSERT(bSuccess == TRUE);

            // Use Default Process heap
            ghSensHeap = GetProcessHeap();
            ASSERT(ghSensHeap != NULL);
            break;

        case DLL_PROCESS_DETACH:
            break;

        }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\senssvc\sensutil.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    sensutil.cxx

Abstract:

    This file contains all the utility routines in SENS service.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          10/11/1997         Start.

--*/


#include <precomp.hxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\senssvc\ipname.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ipname.cxx

Abstract:

    Miscellaneous helper routines to resolve names to IP Addresses.

Author:

    Gopal Parupudi    <GopalP>

Notes:

    a. Class IP_ADDRESS_RESOLVER cloned from RPC Runtime Transport sources
       (rpc\runtime\trans\winnt\common\wstrans.cxx).

Revision History:

    GopalP          10/13/1997         Start.

--*/


#include <precomp.hxx>


#define BACKSLASH       ((SENS_CHAR) '\\')
#define HTTP_PREFIX1    (SENS_STRING("http://"))
#define HTTP_PREFIX2    (SENS_STRING("http:\\\\"))
#define HTTP_PREFIX_LEN 7




BOOL
GetNetBIOSName(
    IN TCHAR *ActualName,
    IN OUT TCHAR *SanitizedName,
    IN SIZE_T cchName
    )
/*++

Routine Description:

    Sanitize the name of the destination to make it more suitable for
    name resolution.

Arguments:

    ActualName - Original Name of the destination.

    SanitizedName - On return, this contains the sanitized version of the
        Actual Name. Memory is allocated by the caller.

Return Value:

    TRUE, if successful.

    FALSE, if the address if the address in invalid.

--*/
{
    TCHAR *pchTemp;

    //
    // Remove the leading \\ characters, if present.
    //
    pchTemp = ActualName;
    if (*pchTemp == BACKSLASH)
        {
        // Check for another slash
        if (*++pchTemp == BACKSLASH)
            {
            if (NULL != _tcschr(++pchTemp, BACKSLASH))
                {
                // Found yet another slash!
                return FALSE;
                }

            StringCchCopy(SanitizedName, cchName, pchTemp);

            return TRUE;
            }
        else
            {
            return FALSE;
            }
        }

    //
    // Remove the "http://" prefix, if present.
    //
    pchTemp = ActualName;
    if (   (_tcsnicmp(HTTP_PREFIX1, ActualName, HTTP_PREFIX_LEN) == 0)
        || (_tcsnicmp(HTTP_PREFIX2, ActualName, HTTP_PREFIX_LEN) == 0))
        {
        StringCchCopy(SanitizedName, cchName, (pchTemp + HTTP_PREFIX_LEN));

        return TRUE;
        }

    StringCchCopy(SanitizedName, cchName, pchTemp);

    return TRUE;
}




DWORD
ResolveName(
    IN TCHAR *lpszDestination,
    OUT LPDWORD lpdwIpAddr
    )
/*++

Routine Description:

    Resolve the destination name to its IP Address.

Arguments:

    lpszDestination - Name of the destination of interest.

    lpdwIpAddr - On success, this contains the IP Address of the destination.

Note:

    Since this function depends on Winsock2 being loaded, there are 2 different
    implementations - one for Win9x and one for NT.

Return Value:

    ERROR_SUCCESS, if successful

    Error code from GetLastError(), otherwise

--*/
{
    RPC_STATUS status;
    TCHAR *lpszSanitizedName;
    DWORD dwReturnCode;
    DWORD bufsize;
    PVOID buf;
    BOOL bSuccess;

    if (   (lpdwIpAddr == NULL)
        || (lpszDestination == NULL))
        {
        return ERROR_INVALID_PARAMETER;
        }

    *lpdwIpAddr = 0x0;
    lpszSanitizedName = NULL;
    dwReturnCode = ERROR_HOST_UNREACHABLE;
    bSuccess = FALSE;

    lpszSanitizedName = new TCHAR[_tcslen(lpszDestination)+1];
    if (!lpszSanitizedName)
        {
        return (ERROR_OUTOFMEMORY);
        }

    bSuccess = GetNetBIOSName(lpszDestination, lpszSanitizedName, _tcslen(lpszDestination)+1);
    if (bSuccess == FALSE)
        {
        SensPrint(SENS_INFO, (SENS_STRING("Bad format for destination name - %s\n"), lpszDestination));
        delete lpszSanitizedName;
        return (ERROR_INVALID_PARAMETER);
        }

    SensPrint(SENS_INFO, (SENS_STRING("Actual Name    - [%s]\n"), lpszDestination));
    SensPrint(SENS_INFO, (SENS_STRING("Sanitized Name - [%s]\n"), lpszSanitizedName));

    bufsize = sizeof(WSAQUERYSET) + IP_BUFFER_SIZE;
    buf = (PVOID) new char[bufsize];
    if (NULL == buf)
        {
        delete lpszSanitizedName;
        return (ERROR_OUTOFMEMORY);
        }

    IP_ADDRESS_RESOLVER resolver(lpszSanitizedName, bufsize, buf);

    status = resolver.NextAddress(lpdwIpAddr);

    switch (status)
        {
        case RPC_S_OK:
            dwReturnCode = ERROR_SUCCESS;
            break;

        case RPC_S_OUT_OF_MEMORY:
            dwReturnCode = ERROR_OUTOFMEMORY;
            break;

        case RPC_S_SERVER_UNAVAILABLE:
        default:
            //
            // Should we return HOST_NOT_FOUND in some cases depending
            // upon the WSAGetLastError() value? Maybe. But, the error
            // ERROR_HOST_UNREACHABLE is pretty close enough.
            //
            dwReturnCode = ERROR_HOST_UNREACHABLE;
            break;
        }


    //
    // Cleanup
    //
    if (NULL != lpszSanitizedName)
        {
        delete lpszSanitizedName;
        }
    if (NULL != buf)
        {
        delete buf;
        }

    return (dwReturnCode);
}



#if !defined(SENS_CHICAGO)


RPC_STATUS
IP_ADDRESS_RESOLVER::NextAddress(
    OUT LPDWORD lpdwIpAddr
    )
/*++

Routine Description:

    Returns the next IP address associated with the Name
    parameter to the constructor.

    During the first call if check for loopback and for dotted numeric IP
    address formats.  If these fail then it begins a complex lookup
    (WSALookupServiceBegin) and returns the first available address.

    During successive calls in which a complex lookup was started
    it returns sucessive addressed returned by WSALookupServiceNext().

Arguments:

    lpdwIpAddr - If successful, the member is set to an IP address.

Return Value:

    RPC_S_OK - lpdwIpAddr points to a new IP address

    RPC_S_SERVER_UNAVAILABLE - Unable to find any more addresses

    RPC_S_OUT_OF_MEMORY - otherwise

--*/
{
    int err;
    RPC_STATUS status;

    *lpdwIpAddr = 0x0;

    // If this is the first call, _Name will be non-NULL and
    // we need to start the lookup process.

    if (_Name)
        {
        TCHAR *Name = _Name;
        _Name = 0;

        // Check for loopback first.
        if (! *Name)
            {
            // Loopback - assign result of htonl(INADDR_LOOPBACK)
            // Little-endian dependence.
            *lpdwIpAddr = 0x0100007F;
            return(RPC_S_OK);
            }

        // Assume dot address since this is faster to check.
        int size = sizeof(SOCKADDR_IN);
        SOCKADDR_IN addr;
        err = WSAStringToAddress(Name,
                                 AF_INET,
                                 0,
                                 (PSOCKADDR)&addr,
                                 &size);

        if (err != SOCKET_ERROR)
            {
            *lpdwIpAddr = addr.sin_addr.s_addr;
            return(RPC_S_OK);
            }

        ASSERT(GetLastError() == WSAEINVAL);

        // Start a complex query operation

        const static AFPROTOCOLS aIpProtocols[2] =
            {
            {AF_INET, IPPROTO_UDP},
            {AF_INET, IPPROTO_TCP}
            };

        const static GUID guidHostAddressByName = SVCID_INET_HOSTADDRBYNAME;
        WSAQUERYSET wsqs;

        memset(&wsqs, 0, sizeof(wsqs));
        wsqs.dwSize = sizeof(WSAQUERYSET);
        // wsqs.dwNameSpace = NS_ALL;
        ASSERT(NS_ALL == 0);
        wsqs.lpszServiceInstanceName = Name;
        wsqs.lpServiceClassId = (GUID *)&guidHostAddressByName;
        wsqs.dwNumberOfProtocols = 2;
        wsqs.lpafpProtocols = (PAFPROTOCOLS)&aIpProtocols[0];

        err = WSALookupServiceBegin(&wsqs,
                                    LUP_RETURN_ADDR,
                                    &_hRnr);

        if (err == SOCKET_ERROR)
            {
            SensPrintA(SENS_INFO, ("WSALookupServiceBegin() failed: %d\n", GetLastError()));
            return(RPC_S_SERVER_UNAVAILABLE);
            }

        _index = 0;

        if (_pwsqs)
            {
            _pwsqs->dwNumberOfCsAddrs = 0;
            }
        }
    else
        {
        if (!_hRnr)
            {
            // First call finished but didn't start a complex query.  Abort now.
            return(RPC_S_SERVER_UNAVAILABLE);
            }
        }

    // A complex query has been started.

    ASSERT(_hRnr);

    // If the cached query structure is empty, call WSALookupNext to get
    // more addresses.

    if (!_pwsqs || (_index >= _pwsqs->dwNumberOfCsAddrs))
        {

        DWORD needed = _size;

        // Loop needed to realloc a larger _pwsqs buffer.

        for(;;)
            {
            err = WSALookupServiceNext(_hRnr,
                                       0, // flags
                                       &needed,
                                       _pwsqs);

            // Success, break out of the loop.
            if (err != SOCKET_ERROR)
                {
                ASSERT(_pwsqs->dwNumberOfCsAddrs > 0);
                ASSERT(_pwsqs->lpcsaBuffer);

                // Reset to start of new result set.
                _index = 0;
                break;
                }

            status = GetLastError();

            // WSAEFAULT means the buffer was too small.

            if (status != WSAEFAULT)
                {
                // WSA_E_NO_MORE means all matching address have
                // already been returned.

                VALIDATE(status)
                    {
                    WSA_E_NO_MORE,
                    WSANO_DATA,
                    WSASERVICE_NOT_FOUND,
                    WSAHOST_NOT_FOUND,
                    WSATRY_AGAIN,
                    WSANO_RECOVERY,
                    WSANO_DATA,
                    WSAEINVAL   // In response to out of resources scenarios.
                    } END_VALIDATE;

                SensPrintA(SENS_ERR, ("WSALookupServiceNext() failed: %d\n", status));

                return(RPC_S_SERVER_UNAVAILABLE);
                }

            // Allocate a larger buffer.

            if (needed <= _size)
                {
                ASSERT(needed > _size);
                return(RPC_S_SERVER_UNAVAILABLE);
                }

            if (_fFree)
                {
                delete _pwsqs;
                }

            _pwsqs = (PWSAQUERYSET) new char[needed];
            //_pwsqs = new WSAQUERYSETW[(needed - sizeof(WSAQUERYSETW))];
            //_pwsqs = (PWSAQUERYSETW) new char(needed - sizeof(WSAQUERYSETW));
            if (!_pwsqs)
                {
                return(RPC_S_OUT_OF_MEMORY);
                }

            _fFree = TRUE;
            _pwsqs->dwNumberOfCsAddrs = 0;
            _size = needed;

            #if DBG
            // On retail we start with enough space for two addresses during the
            // first call.  If this debug print gets hit too much we can increase the
            // starting size (IP_BUFFER_SIZE).
            if (_size > sizeof(WSAQUERYSET) + IP_RETAIL_BUFFER_SIZE)
                {
                SensPrintA(SENS_ERR, ("WSALookupServerNext(): sizeof(WSAQUERYSETW)  - %d\n"
                           "WSALookupServerNext(): IP_RETAIL_BUFFER_SIZE - %d\n",
                           sizeof(WSAQUERYSETW), IP_RETAIL_BUFFER_SIZE));
                SensPrintA(SENS_ERR, ("WSALookupServerNext() wants %d bytes.  Make this the "
                           "default?\n", _size));
                }
            #endif

            }
        }

    ASSERT(_pwsqs);
    ASSERT(_index < _pwsqs->dwNumberOfCsAddrs);

    LPCSADDR_INFO pInfo = &_pwsqs->lpcsaBuffer[_index];
    _index++;

    *lpdwIpAddr = ((SOCKADDR_IN *)pInfo->RemoteAddr.lpSockaddr)->sin_addr.s_addr;

    return(RPC_S_OK);
}



IP_ADDRESS_RESOLVER::~IP_ADDRESS_RESOLVER()
{
    if (_hRnr)
        {
        WSALookupServiceEnd(_hRnr);
        }

    if (_fFree)
        {
        delete _pwsqs;
        }
}

#endif // SENS_CHICAGO
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\senssvc\memory.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    memory.cxx

Abstract:

    This file contains common routines for memory allocation in SENS.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          10/30/1997         Start.

--*/

#include <precomp.hxx>


extern HANDLE ghSensHeap;



void * __cdecl
operator new(
    IN size_t size
    )
{
    return (HeapAlloc(ghSensHeap, 0, size));
}



void __cdecl
operator delete(
    IN void * lpvObj
    )
{
    HeapFree(ghSensHeap, 0, lpvObj);
}



extern "C" void __RPC_FAR * __RPC_API
MIDL_user_allocate(
    IN size_t len
    )
{
    return (new char[len]);
}



extern "C" void __RPC_API
MIDL_user_free(
    IN void __RPC_FAR * ptr
    )
{
    delete ptr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\senssvc\lan.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    lan.cxx

Abstract:

    This is the source file relating to the LAN-specific routines of the
    Connectivity APIs implementation.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          10/11/1997         Start.

--*/


#include <precomp.hxx>


//
// Constants
//

#define GETIFTABLE          GetIfTable
#define GETIPADDRTABLE      GetIpAddrTable
#define GETIPFORWARDTABLE   GetIpForwardTable
#define GETRTTANDHOPCOUNT   GetRTTAndHopCount
#define GETIPSTATISTICS     GetIpStatistics

#define MAX_IFTABLE_ROWS                4
#define MAX_IPADDRTABLE_ROWS            6
#define MAX_IPNETTABLE_ROWS             8
#define MAX_IPFORWARDTABLE_ROWS         8
#define MAX_HOPS_COUNT                  0xFFFF
#define BROADCAST_ACTIVITY_THRESHOLD    2                   // +2 thru -2
#define MEDIASENSE_INITIALIZATION_DELAY 3*25*1000           // 1:15 minutes
#define MEDIASENSE_EVALUATE_LAN_DELAY   4*1000              // 4 seconds

#define SENS_WINSOCK_VERSION        MAKEWORD( 2, 0 )

//
// Globals
//

BOOL        gbIpInitSuccessful;
long        gdwLastLANTime;
long        gdwLANState;
IF_STATE    gIfState[MAX_IF_ENTRIES];
MIB_IPSTATS gIpStats;
extern CRITICAL_SECTION gSensLock;

HANDLE ghMediaTimer;
DWORD  gdwMediaSenseState;

//
// Macros
//



/*++

Macro Description:

    A macro to help in allocating tables when calling IP Helper APIs.

Arguments:

    TABLE_TYPE - The type of the IP Table being queried.

    ROW_TYPE - The type of the Row corresponding to the TABLE_TYPE.

    FUNC_NAME - The IP API to be called to get the IP table.

    MAX_NUM_ROWS - The default number of rows for the table which is
        being retrieved. These rows are allocated on the stack.

Notes:

    o   lpdwLastError should be defined as an LPDWORD in the code
        fragment that uses this macro.

--*/
#define                                                             \
BEGIN_GETTABLE(                                                     \
    TABLE_TYPE,                                                     \
    ROW_TYPE,                                                       \
    FUNC_NAME,                                                      \
    MAX_NUM_ROWS                                                    \
    )                                                               \
    {                                                               \
    DWORD dwOldSize;                                                \
    DWORD dwSize;                                                   \
    DWORD dwStatus;                                                 \
                                                                    \
    BOOL bOrder;                                                    \
                                                                    \
    TABLE_TYPE *pTable;                                             \
                                                                    \
    bOrder = FALSE;                                                 \
                                                                    \
    dwSize = sizeof(DWORD) + MAX_NUM_ROWS * sizeof(ROW_TYPE);       \
	pTable = (TABLE_TYPE *) new char[dwSize];                       \
    if (pTable == NULL)                                             \
        {                                                           \
        SensPrintA(SENS_MEM, (#FUNC_NAME "(): failed to new %d bytes\n",        \
                  dwSize));                                         \
        *lpdwLastError = ERROR_OUTOFMEMORY;                         \
        return FALSE;                                               \
        }                                                           \
                                                                    \
    dwOldSize = dwSize;                                             \
                                                                    \
    dwStatus = FUNC_NAME(                                           \
                   pTable,                                          \
                   &dwSize,                                         \
                   bOrder                                           \
                   );                                               \
                                                                    \
    if (   (dwStatus == ERROR_INSUFFICIENT_BUFFER)                  \
        || (dwStatus == ERROR_MORE_DATA))                           \
        {                                                           \
		ASSERT(dwSize > dwOldSize);                                 \
        SensPrintA(SENS_WARN, (#FUNC_NAME "(%d): reallocing buffer to be %d bytes\n",   \
                   dwOldSize, dwSize));                             \
        delete (char *)pTable;                                      \
        pTable = (TABLE_TYPE *) new char[dwSize];                   \
        if (pTable != NULL)                                         \
            {                                                       \
            dwStatus = FUNC_NAME(                                   \
                           pTable,                                  \
                           &dwSize,                                 \
                           bOrder                                   \
                           );                                       \
            }                                                       \
        else                                                        \
            {                                                       \
            SensPrintA(SENS_MEM, (#FUNC_NAME "(): failed to new (%d) bytes\n",      \
                      dwSize));                                     \
            *lpdwLastError = ERROR_OUTOFMEMORY;                     \
            return FALSE;                                           \
            }                                                       \
        }                                                           \
                                                                    \
    if (dwStatus != 0)                                              \
        {                                                           \
        ASSERT(   (dwStatus != ERROR_INSUFFICIENT_BUFFER)           \
               && (dwStatus != ERROR_MORE_DATA));                   \
                                                                    \
        SensPrintA(SENS_ERR, (#FUNC_NAME "() returned %d\n", dwStatus));\
        *lpdwLastError = dwStatus;                                  \
        /* P3 BUG: Might need to fire ConnectionLost() here */      \
        gdwLANState = FALSE;                                        \
        UpdateSensCache(LAN);                                       \
		delete pTable;                                              \
        return FALSE;                                               \
        }


/*++

Macro Description:

    This macro ends the BEGIN_GETTABLE() macro.

Arguments:

    None.

Notes:

    a. If we have a return between BEGIN_XXX and END_XXX, we need to make
       sure that we free pTable.

--*/
#define                                                             \
END_GETTABLE()                                                      \
                                                                    \
    delete pTable;                                                  \
                                                                    \
    }




BOOL
DoLanSetup(
    void
    )
/*++

Routine Description:



Arguments:

    None.

Return Value:



--*/
{
    BOOL bRetValue;
    WORD wVersionRequested;
    WSADATA wsaData;
    int err;

    bRetValue = FALSE;

    //
    // NT5-specific stuff
    //
#if defined(SENS_NT5)

    ghMediaTimer = NULL;

    // Register for Media-sense notifications
    if (FALSE == MediaSenseRegister())
        {
        SensPrintA(SENS_ERR, ("%s MediaSenseRegister() failed.\n", SERVICE_NAME));
        }

#endif // SENS_NT5

    //
    // AOL-specific code
    //
#if defined(AOL_PLATFORM)
    gdwAOLState = FALSE;
#endif // AOL_PLATFORM

    //
    // Initialize Winsock.
    //
    wVersionRequested = SENS_WINSOCK_VERSION;
    err = WSAStartup(wVersionRequested, &wsaData);
    if (err != 0)
        {
        SensPrintA(SENS_ERR, ("WSAStartup() returned %d!\n", err));
        bRetValue = FALSE;
        goto Cleanup;
        }

    bRetValue = TRUE;

Cleanup:
    //
    // Cleanup
    //

    return bRetValue;
}



#ifdef DBG


inline void
PrintIfState(
    void
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    int i;

    SensPrintA(SENS_INFO, ("|---------------------------------------------------------------------------------------|\n"));
    SensPrintA(SENS_INFO, ("| Valid   Index  UcastIN  UcastOUT  NUcastIN  NUcastOUT  ErrIN  ErrOUT  DiscIN  DiscOUT |\n"));
    SensPrintA(SENS_INFO, ("|---------------------------------------------------------------------------------------|\n"));

    for (i = 0; i < MAX_IF_ENTRIES; i++)
        {
        SensPrintA(SENS_INFO, ("|   %c  %9d %7d %7d %9d %9d   %5d  %6d  %6d  %6d    |\n",
                   gIfState[i].fValid ? 'Y' : 'N',
                   gIfState[i].dwIndex,
                   gIfState[i].dwInUcastPkts,
                   gIfState[i].dwOutUcastPkts,
                   gIfState[i].dwInNUcastPkts,
                   gIfState[i].dwOutNUcastPkts,
                   gIfState[i].dwInErrors,
                   gIfState[i].dwOutErrors,
                   gIfState[i].dwInDiscards,
                   gIfState[i].dwOutDiscards)
                   );
        }

    SensPrintA(SENS_INFO, ("|---------------------------------------------------------------------------------------|\n"));
}

#else  // DBG

#define PrintIfState()      // Nothing

#endif // DBG



#ifdef DETAIL_DEBUG

void
PrintIfTable(
    MIB_IFTABLE *pTable
    )
{
    int i;

    SensPrintA(SENS_INFO, ("|------------------------------------------------------------------------------|\n"));
    SensPrintA(SENS_INFO, ("| Type   Index Spd/1K UcastIN UcastOUT ErrorIN OUT DiscIN OUT Opr Adm          |\n"));
    SensPrintA(SENS_INFO, ("|------------------------------------------------------------------------------|\n"));

    for (i = 0; i < pTable->dwNumEntries; i++)
        {
        SensPrintA(SENS_INFO, ("| %4d %7d %6d %7d %8d %7d %3d %6d %3d %3d %3d           |\n",
                   pTable->table[i].dwType,
                   pTable->table[i].dwIndex,
                   pTable->table[i].dwSpeed/1000,
                   pTable->table[i].dwInUcastPkts,
                   pTable->table[i].dwOutUcastPkts,
                   pTable->table[i].dwInErrors,
                   pTable->table[i].dwOutErrors,
                   pTable->table[i].dwInDiscards,
                   pTable->table[i].dwOutDiscards,
                   pTable->table[i].dwOperStatus,
                   pTable->table[i].dwAdminStatus
                               )
                   );
        }

    SensPrintA(SENS_INFO, ("|------------------------------------------------------------------------------|\n"));

}

void
PrintIpStats(
    void
    )
{

    SensPrintA(SENS_INFO, ("|------------------------------------|\n"));
    SensPrintA(SENS_INFO, ("| IP_STATS   InReceives OutRequests  |\n"));
    SensPrintA(SENS_INFO, ("|------------------------------------|\n"));

    SensPrintA(SENS_INFO, ("|          %10d   %10d   |\n",
               gIpStats.dwInReceives,
               gIpStats.dwOutRequests)
               );

    SensPrintA(SENS_INFO, ("|------------------------------------|\n"));

}

#else

#define PrintIfTable(_X_)   // Nothing

#define PrintIpStats()   // Nothing

#endif // DETAIL_DEBUG

BOOL WINAPI
EvaluateLanConnectivityDelayed(
    LPDWORD
    )
{
    for (int i = 0; i < 4; i++)
        {
        Sleep(MEDIASENSE_EVALUATE_LAN_DELAY*i);  // First time waits 0 ms, no delay

        if (EvaluateLanConnectivity(NULL))
            {
            SensPrintA(SENS_INFO, ("EvaluateLanConnectivity: Delayed eval successful (%d)\n", i));
            return TRUE;
            }
        }
    return FALSE;
}



BOOL WINAPI
EvaluateLanConnectivity(
    OUT LPDWORD lpdwLastError
    )
/*++

Routine Description:

    Evaluates LAN Connectivity.

Arguments:

    lpdwLastError - if return value is FALSE, GetLastError is returned
        in this OUT parameter.

Notes:

    a. This routine can be entered by multiple threads at the same time.
       Currently only very essential code is under a critical section.

    b. This routine can be executed as a threadpool work item.

Return Value:

    TRUE, if LAN connectivity is present.

    FALSE, otherwise

--*/
{
    DWORD dwNow;
    DWORD dwLocalLastError;
    DWORD dwActiveInterfaceSpeed;
    WCHAR wszActiveInterfaceName[MAX_INTERFACE_NAME_LEN];
    BOOL bLanAlive;
    BOOL bSomeInterfaceActive;
    BOOL bCheckCache;

    dwNow = GetTickCount();
    dwLocalLastError = ERROR_NO_NETWORK;
    dwActiveInterfaceSpeed = 0x0;
    bLanAlive = FALSE;
    bSomeInterfaceActive = FALSE;
    bCheckCache = FALSE;

    if (lpdwLastError)
        {
        *lpdwLastError = dwLocalLastError;
        }
    else
        {
        lpdwLastError = &dwLocalLastError;
        }

    //
    // Get infomation about IP statistics.
    //

    BEGIN_GETTABLE(MIB_IFTABLE, MIB_IFROW, GETIFTABLE, MAX_IFTABLE_ROWS)

    //
    // PurgeStaleInterfaces
    //
    PurgeStaleInterfaces(pTable, lpdwLastError);

    //
    // Algorithm:
    //
    // o Create a record.
    // o See if this record exists.
    // o Save the record, if not and return success.
    // o If it does exist, compare. If greater, then save record.
    // o If not greater, try other entries.
    // o All entries? return failure.
    //
    IF_STATE ifEntry;
    DWORD i;

    SensPrintA(SENS_INFO, ("GetIfTable(): Number of entries - %d.\n", pTable->dwNumEntries));

    PrintIfTable(pTable);

    i = 0;
    while (i < pTable->dwNumEntries)
        {
        //
        // Calculate only if it is a non-WAN and non-Loopback interface.
        //
        if (   (pTable->table[i].dwType != MIB_IF_TYPE_PPP)
            && (pTable->table[i].dwType != MIB_IF_TYPE_SLIP)
            && (pTable->table[i].dwType != MIB_IF_TYPE_LOOPBACK))
            {
            BOOL bForceInvalid = FALSE;

            //
            // BOOT UP WITH NO NETWORK:
            //
            // Check to see if both UnicastIN and UnicastOUT are zero. If so,
            // this interface is considered as not active and we skip it.
            //
            if (   (pTable->table[i].dwInUcastPkts == 0)
                && (pTable->table[i].dwOutUcastPkts == 0))
                {
                bForceInvalid = TRUE;
                }

            //
            // Check if networking says it is connected, if not, skip it.
            //
            if (pTable->table[i].dwOperStatus < MIB_IF_OPER_STATUS_CONNECTING)
                {
                SensPrintA(SENS_INFO, ("GetIfTable: Found interface %d in < connecting state (%d), ignored\n",
                           pTable->table[i].dwIndex, pTable->table[i].dwOperStatus) );
                bForceInvalid = TRUE;
                }

            //
            // At this stage, there is some Unicast activity on this interface.
            // So, we can skip the check for Unicast activity below.
            //

            // Fill the IF_STATE structure
            ifEntry.dwIndex = pTable->table[i].dwIndex;
            ifEntry.dwInUcastPkts = pTable->table[i].dwInUcastPkts;
            ifEntry.dwOutUcastPkts = pTable->table[i].dwOutUcastPkts;
            ifEntry.dwInNUcastPkts = pTable->table[i].dwInNUcastPkts;
            ifEntry.dwOutNUcastPkts = pTable->table[i].dwOutNUcastPkts;
            ifEntry.dwInErrors = pTable->table[i].dwInErrors;
            ifEntry.dwOutErrors = pTable->table[i].dwOutErrors;
            ifEntry.dwInDiscards = pTable->table[i].dwInDiscards;
            ifEntry.dwOutDiscards = pTable->table[i].dwOutDiscards;

            bSomeInterfaceActive = HasIfStateChanged(ifEntry, bForceInvalid);
            if (TRUE == bSomeInterfaceActive)
                {
                bLanAlive = TRUE;

                // Save info about interface for later use.
                dwActiveInterfaceSpeed = max(pTable->table[i].dwSpeed,dwActiveInterfaceSpeed);
                StringCchCopy(wszActiveInterfaceName, MAX_INTERFACE_NAME_LEN, pTable->table[i].wszName);
                }
            else
                {
                if (!bForceInvalid)
                    {
                    bCheckCache = TRUE; // Idle IF found but still valid (enable MAX_LAN_INTERNAL check below)
                    }
                }
            }

        i++;

        } // while ()

    PrintIfState();

    END_GETTABLE()


    //
    // RACE Condition Fix:
    //
    // If there are 2 threads that are in EvaluateLanConnectivity() and one
    // of them updates the interface's packet cache, then there is a distinct
    // possibility that the second thread will compare with the updated cache
    // and wrongly conclude that there is no activity. We ignore any loss of
    // connectivity that was evaluated before MAX_LAN_INTERVAL (ie., we should
    // keep giving cached information for MAX_LAN_INTERVAL seconds).
    //
    if (   (TRUE == bCheckCache)
        && (FALSE == bLanAlive) )
        {

        dwNow = GetTickCount();
        if (   ((dwNow - gdwLastLANTime) <= MAX_LAN_INTERVAL)
            && (gdwLastLANTime != 0) )
            {
            SensPrintA(SENS_DBG, ("EvaluateLanConnectivity(): Returning TRUE "
                       "(Now - %d sec, LastLANTime - %d sec)\n", dwNow/1000, gdwLastLANTime/1000));
            return TRUE;
            }
        }

    //
    // NOTE: If we are doing DWORD InterlockedExchange, then assignment
    // should suffice. Using InterlockedExchange is not a bug, though.
    //
    if (bLanAlive)
        {
        SensPrintA(SENS_DBG, ("**** EvaluateLanConnectivity(): Setting"
                   " gdwLastLANTime to %d secs\n", dwNow/1000));
        InterlockedExchange(&gdwLastLANTime, dwNow);
        }
    else
        {
        SensPrintA(SENS_DBG, ("**** EvaluateLanConnectivity(): Setting"
                   " gdwLastLANTime to 0 secs\n"));
        InterlockedExchange(&gdwLastLANTime, 0x0);
        }

    //
    // Adjust LAN state and fire an event, if necessary.
    //
    if (InterlockedExchange(&gdwLANState, bLanAlive) != bLanAlive)
        {
        //
        // LAN Connectivity state changed.
        //
        SENSEVENT_NETALIVE Data;

        Data.eType = SENS_EVENT_NETALIVE;
        Data.bAlive = bLanAlive;
        memset(&Data.QocInfo, 0x0, sizeof(QOCINFO));
        Data.QocInfo.dwSize = sizeof(QOCINFO);
        Data.QocInfo.dwFlags = NETWORK_ALIVE_LAN;
        Data.QocInfo.dwInSpeed = dwActiveInterfaceSpeed;
        Data.QocInfo.dwOutSpeed = dwActiveInterfaceSpeed;
        //
        // NOTE: When dwActiveInterfaceName gets the right value from
        // IPHLPAPIs we should use that name. Until then, we use a default.
        //
        Data.strConnection = DEFAULT_LAN_CONNECTION_NAME;

        UpdateSensCache(LAN);

        SensFireEvent((PVOID)&Data);
        }

    return bLanAlive;
}




BOOL
HasIfStateChanged(
    IF_STATE ifEntry,
    BOOL bForceInvalid
    )
/*++

Routine Description:

    Compares the current state of a remote network IF with the cached history
        to determine if it is active or not.

Arguments:

    ifEntry - An interface that appears to have changed state and is "valid" as a remote
        LAN if.  (ie, loopback, pptp, etc should be filtered out)
    bForceInvalid - If TRUE, don't bother to look at the stats; this interface is NOT valid.


Return Value:
    
    TRUE - ifEntry appears up and active
    FALSE - ifEntry inactive or down
    
--*/
{
    int i, j;
    static int iLastActiveIndex = -1;
    BOOL bActive;
    BOOL bSeenButInactive;
    DWORD dwInDiff;
    DWORD dwOutDiff;
    int iNUcastDiff;

    i = 0;
    bActive = FALSE;
    bSeenButInactive = FALSE;
    dwInDiff = 0;
    dwOutDiff = 0;
    iNUcastDiff = 0;

    RequestSensLock();

    //
    // Compare the current snapshot with the saved snapshot
    // for this interface.
    //
    while (i < MAX_IF_ENTRIES)
        {
        if (   (gIfState[i].fValid == TRUE)
            && (gIfState[i].dwIndex == ifEntry.dwIndex))
            {

            if (bForceInvalid)
                {
                gIfState[i].fValid = FALSE;
                break;
                }

            if (   (ifEntry.dwInUcastPkts > gIfState[i].dwInUcastPkts)
                || (ifEntry.dwOutUcastPkts > gIfState[i].dwOutUcastPkts)
                || (ifEntry.dwInNUcastPkts > gIfState[i].dwInNUcastPkts)
                || (ifEntry.dwOutNUcastPkts > gIfState[i].dwOutNUcastPkts)
                || (ifEntry.dwInErrors > gIfState[i].dwInErrors)
                || (ifEntry.dwOutErrors > gIfState[i].dwOutErrors)
                || (ifEntry.dwInDiscards > gIfState[i].dwInDiscards)
                || (ifEntry.dwOutDiscards > gIfState[i].dwOutDiscards))
                {
                //
                // HEURISTIC:
                //
                // a. When the net tap is pulled out, it has been observed that
                //    the difference in the incoming non-Unicast packet count
                //    is within +1 thru -1 of the difference in the outgoing
                //    non-Unicast packet count. Most of the times the diff of
                //    these differences is 0. We don't count this as LAN alive
                //
                // b. Also, there should be no change in the unicast IN packet
                //    count. Unicast OUT packet count may change. This could be
                //    problematic.
                //
                dwInDiff = ifEntry.dwInNUcastPkts - gIfState[i].dwInNUcastPkts;
                dwOutDiff = ifEntry.dwOutNUcastPkts - gIfState[i].dwOutNUcastPkts;
                iNUcastDiff = dwOutDiff - dwInDiff;
                SensPrintA(SENS_INFO, ("HasIfStateChanged(): dwInDiff = %d, "
                           "dwOutDiff = %d, dwNUcastDiff = %d, UcastINDiff = "
                           "%d, UcastOUTDiff = %d\n",
                           dwInDiff, dwOutDiff, iNUcastDiff,
                           ifEntry.dwInUcastPkts - gIfState[i].dwInUcastPkts,
                           ifEntry.dwOutUcastPkts - gIfState[i].dwOutUcastPkts));

                if (   (ifEntry.dwInUcastPkts == gIfState[i].dwInUcastPkts)
                    && (iNUcastDiff <= BROADCAST_ACTIVITY_THRESHOLD)
                    && (iNUcastDiff >= -BROADCAST_ACTIVITY_THRESHOLD))
                    {
                    SensPrintA(SENS_INFO, ("HasIfStateChanged(): Interface %d"
                               " has only Broadcast activity (Diff is %d)!\n",
                               gIfState[i].dwIndex, iNUcastDiff));
                    bSeenButInactive = TRUE;
                    }
                else
                    {
                    //
                    // Unicast IN packet counts have changed or Broadcast
                    // activity is greater than the threshold.
                    //
                    iLastActiveIndex = i;
                    bActive = TRUE;
                    SensPrintA(SENS_INFO, ("HasStateChanged(): Interface %d "
                               "has been active.\n", gIfState[i].dwIndex));

                    gdwLastLANTime = GetTickCount();
                    SensPrintA(SENS_DBG, ("**** HasIfStateChanged(): Setting "
                               "gdwLastLANTime to %d secs\n", gdwLastLANTime/1000));
                    }

                //
                // Save the new values.
                //
                memcpy(&gIfState[i], &ifEntry, sizeof(IF_STATE));
                gIfState[i].fValid = TRUE;
                }
            else
                {
                SensPrintA(SENS_INFO, ("HasStateChanged(): Interface %d has NO activity.\n",
                           gIfState[i].dwIndex));
                bSeenButInactive = TRUE;
                }

            // Found the interface, so stop searching
            break;
            }

        i++;

        } // while ()

    ReleaseSensLock();

    if (   (bSeenButInactive == TRUE)
        || (bForceInvalid) )
        {
        return FALSE;
        }

    if (bActive == TRUE)
        {
        return TRUE;
        }

    //
    // We are seeing this interface for the first time. Go ahead and save it
    // in the global interface state array.
    //
    i = MAX_IF_ENTRIES;
    j = iLastActiveIndex;

    RequestSensLock();

    while (i > 0)
        {
        // Try to find a free slot starting from the last active slot.
        j = (j+1) % MAX_IF_ENTRIES;

        if (gIfState[j].fValid == FALSE)
            {
            // Found one!
            break;
            }

        i--;
        }

    //
    // NOTE: If there are more than MAX_IF_ENTRIES, we will start
    // start reusing valid interface elements in gIfState array. This,
    // I guess, is OK since we will have enough interfaces to figure
    // out connectivity.
    //

    memcpy(&gIfState[j], &ifEntry, sizeof(IF_STATE));
    gIfState[j].fValid = TRUE;

    ReleaseSensLock();

    SensPrintA(SENS_ERR, ("******** HasIfStateChanged(): Adding a new "
               "interface with index %d\n", gIfState[j].dwIndex));

    return TRUE;
}



BOOL
MediaSenseRegister(
    void
    )
/*++

Routine Description:

    Schedule a workitem to register for Media-sense notifications from WMI.

Arguments:

    None.

Return Value:

    TRUE, if success.

    FALSE, otherwise.

--*/
{
    BOOL bRetVal;

    bRetVal = TRUE;

    ASSERT(gdwMediaSenseState == SENSSVC_START);

    //
    // Create a timer object to schedule (one-time only) Media-sense
    // registration.
    //
    SensSetTimerQueueTimer(
        bRetVal,                         // Bool return on NT5
        ghMediaTimer,                    // Handle return on IE5
        NULL,                            // Use default process timer queue
        MediaSenseRegisterHelper,        // Callback
        NULL,                            // Parameter
        MEDIASENSE_INITIALIZATION_DELAY, // Time from now when timer should fire
        0x0,                             // Time inbetween firings of this timer
        0x0                              // No Flags.
        );
    if (SENS_TIMER_CREATE_FAILED(bRetVal, ghMediaTimer))
        {
        SensPrintA(SENS_ERR, ("MediaSenseRegister(): SensSetTimerQueueTimer() failed with %d.\n",
                   GetLastError()));
        bRetVal = FALSE;
        }

    return bRetVal;
}




SENS_TIMER_CALLBACK_RETURN
MediaSenseRegisterHelper(
    PVOID pvIgnore,
    BOOLEAN bIgnore
    )
/*++

Routine Description:

    Helper routine that is scheduled to the WMI registration.

Arguments:

    pvIgnore - Ignored.

    bIgnore - Ignored.

Return Value:

    None (void).

--*/
{
    ULONG   Status;
    GUID    guid;

    RequestSensLock();
    
    if (   (SENSSVC_STOP == gdwMediaSenseState)
        || (UNREGISTERED == gdwMediaSenseState))
        {
        goto Cleanup;
        }

    //
    // Enable the media disconnect event.
    //
    guid = GUID_NDIS_STATUS_MEDIA_DISCONNECT;

    Status = WmiNotificationRegistrationW(
                 &guid,                         // Event of interest
                 TRUE,                          // Enable Notification?
                 EventCallbackRoutine,          // Callback function
                 0,                             // Callback context
                 NOTIFICATION_CALLBACK_DIRECT   // Notification flags
        );
    if (ERROR_SUCCESS != Status)
        {
        SensPrintA(SENS_ERR, ("Unable to enable media disconnect event: 0x%x!\n", Status));
        goto Cleanup;
        }

    //
    // Enable the media connect event
    //
    guid = GUID_NDIS_STATUS_MEDIA_CONNECT;

    Status = WmiNotificationRegistrationW(
                 &guid,                         // Event of interest
                 TRUE,                          // Enable Notification?
                 EventCallbackRoutine,          // Callback function
                 0,                             // Callback context
                 NOTIFICATION_CALLBACK_DIRECT   // Notification flags
                 );
    if (ERROR_SUCCESS != Status)
        {
        SensPrintA(SENS_ERR, ("Unable to enable media connect event: 0x%x!\n", Status));
        ASSERT(0);  // If we hit this then we need to unregister the first registration above.
        goto Cleanup;
        }

    SensPrintA(SENS_ERR, ("MediaSenseRegister(): Media-sense registration successful.\n"));

    gdwMediaSenseState = REGISTERED;

Cleanup:
    //
    // Cleanup
    //
    ReleaseSensLock();

    return;
}




BOOL
MediaSenseUnregister(
    void
    )
/*++

Routine Description:

    Unregister from Media-sense notifications from WMI.

Arguments:

    None.

Return Value:

    TRUE, if success.

    FALSE, otherwise.

--*/
{
    ULONG   Status;
    GUID    guid;
    BOOL    bRetVal;
    BOOL    bRegistered;

    bRetVal = TRUE;
    bRegistered = FALSE;

    RequestSensLock();

    ASSERT(gdwMediaSenseState == REGISTERED ||
           gdwMediaSenseState == SENSSVC_START);

    if (gdwMediaSenseState == REGISTERED)
        {
        bRegistered = TRUE;
        }

    gdwMediaSenseState = SENSSVC_STOP;

    if (NULL != ghMediaTimer)
        {
        bRetVal = SensCancelTimerQueueTimer(NULL, ghMediaTimer, NULL);
        ghMediaTimer = NULL;

        SensPrintA(SENS_INFO, ("[%d] MediaSensUnregister(): SensCancelTimer"
                  "QueueTimer(Media) %s\n", GetTickCount(),
                  bRetVal ? "succeeded" : "failed!"));
        }

    if (!bRegistered)
        {
        // Should not do unregistration.
        goto Cleanup;
        }

    //
    // Disable the media disconnect event.
    //
    guid = GUID_NDIS_STATUS_MEDIA_DISCONNECT;

    Status = WmiNotificationRegistrationW(
                 &guid,                         // Event of interest
                 FALSE,                         // Enable Notification?
                 EventCallbackRoutine,          // Callback function
                 0,                             // Callback context
                 NOTIFICATION_CALLBACK_DIRECT   // Notification flags
                 );
    if (ERROR_SUCCESS != Status)
        {
        SensPrintA(SENS_ERR, ("[%d] MediaSensUnregister(): Unable to disable "
                   "media disconnect event: 0x%x!\n", GetTickCount(), Status));
        ASSERT(0);  // If this fails analyze if we should still to the second unregister
        bRetVal = FALSE;
        }

    //
    // Disable the connect event
    //
    guid = GUID_NDIS_STATUS_MEDIA_CONNECT;

    Status = WmiNotificationRegistrationW(
                 &guid,                         // Event of interest
                 FALSE,                         // Enable Notification?
                 EventCallbackRoutine,          // Callback function
                 0,                             // Callback context
                 NOTIFICATION_CALLBACK_DIRECT   // Notification flags
                 );
    if (ERROR_SUCCESS != Status)
        {
        SensPrintA(SENS_ERR, ("[%d] MediaSensUnregister(): Unable to disable "
                   "media disconnect event: 0x%x!\n", GetTickCount(), Status));
        bRetVal = FALSE;
        }

Cleanup:
    //
    //
    //
    gdwMediaSenseState = UNREGISTERED;

    ReleaseSensLock();

    return bRetVal;
}




void
EventCallbackRoutine(
    IN PWNODE_HEADER WnodeHeader,
    IN ULONG Context
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    PULONG Data;
    PWNODE_SINGLE_INSTANCE Wnode = (PWNODE_SINGLE_INSTANCE)WnodeHeader;
    PWCHAR Name;
    DWORD dwIgnore;
    ULONG NameLen;
    int result;

    //
    // Get the information for the media disconnect.
    //
    result = memcmp(&WnodeHeader->Guid, &GUID_NDIS_STATUS_MEDIA_DISCONNECT, sizeof(GUID));
    if (0 == result)
        {
        SensPrintA(SENS_INFO, ("NDIS: received a media disconnect!\n"));
        EvaluateConnectivity(TYPE_LAN);
        }
    else
        {
        //
        // Get the information for the media connect.
        //
        result = memcmp(&WnodeHeader->Guid, &GUID_NDIS_STATUS_MEDIA_CONNECT, sizeof(GUID));
        if (0 == result)
            {
            SensPrintA(SENS_INFO, ("NDIS: received a media connect!\n"));
            EvaluateConnectivity(TYPE_DELAY_LAN);
            }
        else
            {
            SensPrintA(SENS_WARN, ("NDIS: Unknown event received!\n"));
            }
        }

    Name = (PWCHAR)RtlOffsetToPointer(Wnode, Wnode->OffsetInstanceName);

    SensPrintW(SENS_INFO, (L"NDIS: Instance: %ws\n", Name));
}



BOOL
GetIfEntryStats(
    IN DWORD dwIfIndex,
    IN LPQOCINFO lpQOCInfo,
    OUT LPDWORD lpdwLastError,
    OUT LPBOOL lpbIsWanIf
    )
/*++

Routine Description:

    Get the Statistics field of the Interface entry which has the given
    index.

Arguments:

    dwIfIndex - The interface of interest.

    lpQOCInfo - QOC Info structure whose fields are set when the interface
        entry is found in the interface table.

    lpdwLastError - The GLE, if any.

    lpbIsWanIf - Is the interface at this index a WAN interface or not.

Return Value:

    TRUE, if we find the index.

    FALSE, otherwise.

--*/
{
    DWORD i;
    BOOL bFound;

    *lpdwLastError = ERROR_SUCCESS;
    *lpbIsWanIf = FALSE;
    bFound = FALSE;

    BEGIN_GETTABLE(MIB_IFTABLE, MIB_IFROW, GETIFTABLE, MAX_IFTABLE_ROWS)

    // Search the Interface table for the entry with the given index.
    for (i = 0; i < pTable->dwNumEntries; i++)
        {
        if (pTable->table[i].dwIndex == dwIfIndex)
            {
            bFound = TRUE;

            SensPrintA(SENS_INFO, ("GetIfEntryStats(): Interface %d is of "
                       "type %d\n", dwIfIndex, pTable->table[i].dwType));

            if (   (pTable->table[i].dwType == MIB_IF_TYPE_PPP)
                || (pTable->table[i].dwType == MIB_IF_TYPE_SLIP))
                {
                *lpbIsWanIf = TRUE;
                }
            else
                {
                *lpbIsWanIf = FALSE;
                }

            if (lpQOCInfo != NULL)
                {
                lpQOCInfo->dwSize = sizeof(QOCINFO);
                lpQOCInfo->dwInSpeed = pTable->table[i].dwSpeed;
                lpQOCInfo->dwOutSpeed = pTable->table[i].dwSpeed;
                lpQOCInfo->dwFlags = (*lpbIsWanIf) ? CONNECTION_WAN : CONNECTION_LAN;
                }

            break;
            }
        }

    END_GETTABLE()

    return bFound;
}




BOOL
CheckForReachability(
    IN IPAddr DestIpAddr,
    IN OUT LPQOCINFO lpQOCInfo,
    OUT LPDWORD lpdwLastError
    )
/*++

Routine Description:

    This helper function does all the dirty work in checking for Reachability
    of a particular destination.

Arguments:

    DestIpAddr - The Destination of interest.

    lpQOCInfo - The QOC Info structure.

    lpdwLastError - Returns the GetLastError value when the destination is
        not reachable.

Return Value:

    TRUE, if the destination IP Address is reachable

    FALSE, otherwise. GLE returned in lpdwLastError.

--*/
{
    DWORD i;
    BOOL bSuccess;
    BOOL bSameNetId;
    BOOL bReachable;
    BOOL bIsWanIf;
    DWORD dwNetId;
    DWORD dwSubnetMask;
    DWORD ifNum;
    DWORD dwHopCount;
    DWORD dwRtt;

    ifNum = -1;
    dwRtt = 0;
    bSuccess = FALSE;
    bIsWanIf = FALSE;
    bReachable = FALSE;
    bSameNetId = FALSE;

    //
    // Search the IP Address table for an entry with the same NetId as the
    // Destination. If such an entry exists, the Destination is in the same
    // sub-net and hence reachable.
    //

    BEGIN_GETTABLE(MIB_IPADDRTABLE, MIB_IPADDRROW, GETIPADDRTABLE, MAX_IPADDRTABLE_ROWS)

    // Search for an entry with the same NetId
    for (i = 0; i < pTable->dwNumEntries; i++)
        {
        // Compare NetIds.
        dwSubnetMask = pTable->table[i].dwMask;
        dwNetId = pTable->table[i].dwAddr & dwSubnetMask;

        SensPrintA(SENS_INFO, ("IPADDRESS(%d) - Mask %8x, IP %8x, NETID %8x, COMP %8x\n", i,
                   pTable->table[i].dwMask,
                   pTable->table[i].dwAddr,
                   dwNetId,
                   (DestIpAddr & dwSubnetMask))
                   );

        if (   (pTable->table[i].dwAddr != 0x0)
            && ((DestIpAddr & dwSubnetMask) == dwNetId))
            {
            bSameNetId = TRUE;
            ifNum = pTable->table[i].dwIndex;
            SensPrintA(SENS_INFO, ("CheckForReachability(): Found entry in IPAddr Table with same NetId\n"));
            break;
            }
        }

    END_GETTABLE()

    if (bSameNetId)
        {
        // Destination is in the same Subnet. Get stats from the IfTable.
        bSuccess = GetIfEntryStats(ifNum, lpQOCInfo, lpdwLastError, &bIsWanIf);
        ASSERT(bSuccess == TRUE);
        if (bSuccess)
            {
            return TRUE;
            }
        }


    //
    // Entry is not in the IP AddrTable. We need to Ping. Search the Gateway
    // table for default gateway and get it's interface statistics.
    //
    BEGIN_GETTABLE(MIB_IPFORWARDTABLE, MIB_IPFORWARDROW, GETIPFORWARDTABLE, MAX_IPFORWARDTABLE_ROWS)

    for (i = 0; i < pTable->dwNumEntries; i++)
        {
        dwSubnetMask = pTable->table[i].dwForwardMask;
        dwNetId = pTable->table[i].dwForwardDest & dwSubnetMask;
        ifNum = pTable->table[i].dwForwardIfIndex;

        SensPrintA(SENS_INFO, ("IPFORWARD(%d) - Mask %8x, IP %8x, NETID %8x, COMP %8x\n", i,
                   pTable->table[i].dwForwardMask,
                   pTable->table[i].dwForwardDest,
                   dwNetId,
                   (DestIpAddr & dwSubnetMask))
                   );

        if (pTable->table[i].dwForwardDest == 0x0)
            {
            //
            // Skip the default gateway 0.0.0.0. But, get the statistics
            // anyways. The QOC of the default gateway is used if we have
            // to Ping the destination.
            //
            bSuccess = GetIfEntryStats(ifNum, lpQOCInfo, lpdwLastError, &bIsWanIf);
            SensPrintA(SENS_INFO, ("Default Gateway statistics (if = %d, "
                       "dwSpeed = %d, IsWanIf = %s)\n", ifNum, lpQOCInfo ?
                       lpQOCInfo->dwInSpeed : 0x0, bIsWanIf ? "TRUE" : "FALSE"));
            ASSERT(bSuccess == TRUE);
            break;
            }
        }

    END_GETTABLE()

    //
    // Resort to a Ping
    //

    bReachable = GETRTTANDHOPCOUNT(
                     DestIpAddr,
                     &dwHopCount,
                     MAX_HOPS_COUNT,
                     &dwRtt
                     );

    //
    // If we got around to doing a Ping, QOC information will have been
    // retrieved when we found the Default Gateway entry.
    //

    SensPrintA(SENS_INFO, ("CheckForReachability(): Ping returned %s with GLE of %d\n",
               bReachable ? "TRUE" : "FALSE", GetLastError()));

    if (bReachable == FALSE)
        {
        *lpdwLastError = ERROR_HOST_UNREACHABLE;
        }

    //
    // P3 BUG:
    //
    // a. We determine whether the interface on which the Ping went is a LAN
    //    or WAN by checking the interface type of the default gateway. This
    //    is not TRUE!
    //

    return bReachable;
}




BOOL
GetActiveWanInterfaceStatistics(
    OUT LPDWORD lpdwLastError,
    OUT LPDWORD lpdwWanSpeed
    )
/*++

Routine Description:

    Get the Statistics field of the Interface entry

Arguments:

    lpdwLastError - The GLE, if any.

    lpdwWanSpeed - Speed of the WAN interface

Notes:

    P3 BUG: Currently, this will return the speed of the first WAN interface
    it finds. This won't work properly if there are multiple "active" WAN
    interfaces.

Return Value:

    TRUE, if statistics were successfully retrieved

    FALSE, otherwise.

--*/
{
    DWORD i;
    BOOL bFound;

    *lpdwLastError = ERROR_SUCCESS;
    *lpdwWanSpeed = DEFAULT_WAN_BANDWIDTH;
    bFound = FALSE;

    BEGIN_GETTABLE(MIB_IFTABLE, MIB_IFROW, GETIFTABLE, MAX_IFTABLE_ROWS)

    // Search the Interface table for the first active WAN interface.
    for (i = 0; i < pTable->dwNumEntries; i++)
        {
        if (   (pTable->table[i].dwType == MIB_IF_TYPE_PPP)
            || (pTable->table[i].dwType == MIB_IF_TYPE_SLIP))
            {
            bFound = TRUE;

            if (   (pTable->table[i].dwInNUcastPkts != 0)
                || (pTable->table[i].dwOutNUcastPkts != 0)
                || (pTable->table[i].dwInErrors != 0)
                || (pTable->table[i].dwOutErrors != 0)
                || (pTable->table[i].dwInDiscards != 0)
                || (pTable->table[i].dwOutDiscards != 0))
                {
                *lpdwWanSpeed = pTable->table[i].dwSpeed;
                break;
                }
            }
        } // for

    END_GETTABLE()

    return bFound;
}




BOOL
PurgeStaleInterfaces(
    IN MIB_IFTABLE *pTable,
    OUT LPDWORD lpdwLastError
    )
/*++

Routine Description:

    Remove statistics from the interfaces that went away.

Arguments:

    pTable - The current If table.

    lpdwLastError - The GLE, if any.

Return Value:

    TRUE, always.

--*/
{
    DWORD i;
    DWORD j;
    BOOL bFound;


    *lpdwLastError = ERROR_SUCCESS;

    RequestSensLock();

    // Check if each valid interface in the cache still exists.
    for (j = 0; j < MAX_IF_ENTRIES; j++)
        {
        if (gIfState[j].fValid == FALSE)
            {
            continue;
            }

        bFound = FALSE;

        // Search if the interface in the cache is present in the IF_TABLE.
        for (i = 0; i < pTable->dwNumEntries; i++)
            {
            if (pTable->table[i].dwIndex == gIfState[j].dwIndex)
                {
                bFound = TRUE;
                }
            } // for (i)

        if (FALSE == bFound)
            {
            SensPrintA(SENS_ERR, ("******** PurgeStaleInterfaces(): Purging"
                       "interface with index %d\n", gIfState[j].dwIndex));

            // Interface went away. So remove from Cache.
            memset(&gIfState[j], 0x0, sizeof(IF_STATE));
            gIfState[j].fValid = FALSE;
            }

        } // for (j)

    ReleaseSensLock();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\senssvc\service.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    service.cxx

Abstract:

    This contains the Service related functionality of SENS.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    This is cloned from \nt\private\eventsystem\server\eventsystem.cpp

Revision History:

    GopalP          1/11/1998         Start.

--*/


#include <precomp.hxx>
#include <winuser.h>
#include <dbt.h>
#include "service.hxx"


//
// Constants
//
#define SENS_NAME       SENS_STRING("SENS")
#define SENS_DATA       0x19732304
#define SENS_WAIT_HINT  3*1000

enum ACTION
{
    ACTION_NONE,
    ACTION_APPLICATION,
    ACTION_SERVICE
};

//
// Globals
//

DWORD                   gdwError;
HANDLE                  ghStopEvent;
extern HANDLE           ghSensStartedEvent;
SYSTEM_POWER_STATUS     gSystemPowerState;


//
// Service related stuff
//
SERVICE_STATUS          gServiceStatus;       // current status of the service
SERVICE_STATUS_HANDLE   ghStatusHandle;
HDEVNOTIFY              ghDeviceNotify;

SERVICE_TABLE_ENTRY gaServiceEntryTable[] = {
    { SENS_NAME, (LPSERVICE_MAIN_FUNCTION) ServiceMain },
    { NULL, NULL }
    };

//
// Helper functions
//


void __stdcall
LogMessage(
    TCHAR* msg1,
    TCHAR* msg2
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    const TCHAR* strings[2] = {msg1, msg2};
    HANDLE hEventSource;

    hEventSource = RegisterEventSource(NULL, SENS_STRING("SENS"));

    if (hEventSource != NULL)
        {
        ReportEvent(
            hEventSource,           // event source handle
            EVENTLOG_ERROR_TYPE,    // event type
            0,                      // event category
            0,                      // event ID
            NULL,                   // current user's SID
            2,                      // strings in lpszStrings
            0,                      // no bytes of raw data
            strings,                // array of error strings
            NULL                    // no raw data
            );

        DeregisterEventSource(hEventSource);
        }
}


void
ServiceStart(
    void
    )
/*++

Routine Description:

    Start SENS as service.  Stay up until we receive the stop event.

Arguments:

    None.

Return Value:

    None.

--*/
{
    // Initialize SENS.
    if (FALSE == SensInitialize())
        {
        SensPrintToDebugger(SENS_DBG, ("[SENS] [%d] SensInitialize() failed.\n", GetTickCount()));
        return;
        }

    // Tell the SCM that we're running now.
    if (!ReportStatusToSCM(SERVICE_RUNNING, NO_ERROR, 0))
        {
        SensPrintToDebugger(SENS_DBG, ("[SENS] [%d] ReportStatusToSCM() failed.\n", GetTickCount()));

        return;
        }

    // Set the SensStartedEvent now.
    if (ghSensStartedEvent != NULL)
        {
        SetEvent(ghSensStartedEvent);
        SensPrintA(SENS_INFO, ("[%d] Successfully signalled starting of SENS.\n", GetTickCount()));
        }
    else
        {
        SensPrintToDebugger(SENS_DBG, ("[SENS] [%d] Couldn't set the SENS Started event!\n", GetTickCount()));
        }

    SensPrintToDebugger(SENS_DBG, ("\n[SENS] [%d] Started successfully.\n\n", GetTickCount()));

}



void
ServiceStop(
    void
    )
/*++

Routine Description:

    Stop SENS as a service.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Cleanup now.
    //
    SensUninitialize();
}




VOID WINAPI
ServiceMain(
    DWORD argc,
    TCHAR* argv[]
    )
/*++

Routine Description:

    Perform the actual service initialization.

Arguments:

    Usual stuff.

Return Value:

    Usual stuff.

--*/
{
    //
    // Initialize Globals.
    //
    gdwError = 0x0;
    ghStopEvent = NULL;
    ghStatusHandle = NULL;
    memset(&gServiceStatus, 0x0, sizeof(SERVICE_STATUS));
    ghDeviceNotify = NULL;

    // Service status parameters that don't change.
    gServiceStatus.dwServiceType                = SERVICE_WIN32_OWN_PROCESS;
    gServiceStatus.dwCurrentState               = SERVICE_START_PENDING;
    gServiceStatus.dwControlsAccepted           = 0;
    gServiceStatus.dwWin32ExitCode              = 0;
    gServiceStatus.dwServiceSpecificExitCode    = 0;
    gServiceStatus.dwCheckPoint                 = 0;
    gServiceStatus.dwWaitHint                   = SENS_WAIT_HINT;

    //
    // Register our service control handler
    //
    DEV_BROADCAST_DEVICEINTERFACE PnPFilter;

    ghStatusHandle = RegisterServiceCtrlHandlerEx(
                          SENS_NAME,
                          ServiceControl,
                          (PVOID) SENS_DATA
                          );
    if (ghStatusHandle == NULL)
        {
        return;
        }

#ifdef PNP_EVENTS
    // Before enabling PnP events be aware that the code to unregister for the PnP
    // is missing.  Since SENS does not use the PnPs the code was all removed.

    //
    // Register for the PnP Device Interface change notifications
    //
    PnPFilter.dbcc_size = sizeof(DEV_BROADCAST_DEVICEINTERFACE);
    PnPFilter.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
    PnPFilter.dbcc_reserved = 0x0;
    memcpy(
        &PnPFilter.dbcc_classguid,
        (LPGUID) &GUID_NDIS_LAN_CLASS,
        sizeof(GUID)
        );

    ghDeviceNotify = RegisterDeviceNotification(
                         (HANDLE) ghStatusHandle,
                         &PnPFilter,
                         DEVICE_NOTIFY_SERVICE_HANDLE
                         );
    if (NULL == ghDeviceNotify)
        {
        SensPrintToDebugger(SENS_DBG, ("[SENS] [%d] ServiceMain(): RegisterDeviceNotification() failed\n", GetTickCount()));
        }

#ifdef DETAIL_DEBUG
    SensPrintToDebugger(SENS_DBG, ("[SENS] [%d] ServiceMain(): RegisterDeviceNotification() succeeded\n", GetTickCount()));
#endif // DETAIL_DEBUG

#endif // PNP_EVENTS

    //
    // Save a snapshot of the System Power State.
    //
    BOOL bRet = GetSystemPowerStatus(&gSystemPowerState);
    if (bRet == FALSE)
        {
        SensPrintA(SENS_ERR, ("SensMessageLoopThread(): GetSystemPowerStatus() failed with "
               "GLE = %d\n", GetLastError()));
        }
    ASSERT(bRet);

    // Report the status, the exit code, and the wait hint to the SCM.
    if (!ReportStatusToSCM(SERVICE_START_PENDING, NO_ERROR, SENS_WAIT_HINT))
        {
        return;
        }

    // Start the service executing.
    ServiceStart();

    // Let the thread return.  We will use the stop thread to cleanup.

    return;
}




DWORD WINAPI
ServiceControl(
    DWORD dwCode,
    DWORD dwEventType,
    PVOID EventData,
    PVOID pData
    )
/*++

Routine Description:

    Handle Control Codes from SCM.

Arguments:

    dwCode - The control code.

    dwEventType - The type of the event.

    EventData - Data corresponding to the event.

    pData - Additional Data.

Notes:

    Refer to \\popcorn\razzle1\src\spec\umevent.doc for further details.

Return Value:

    None.

--*/
{

    PDEV_BROADCAST_DEVICEINTERFACE pDevice;
    NTSTATUS NtStatus;
    ANSI_STRING DeviceNameA;
    UNICODE_STRING UnicodeString;
    unsigned char *DeviceUuidA;
    DWORD  dwStatus = NO_ERROR;

    pDevice = (PDEV_BROADCAST_DEVICEINTERFACE) EventData;
    DeviceUuidA = NULL;

#ifdef DETAIL_DEBUG
    SensPrintToDebugger(SENS_DBG, ("[SENS] ServiceControl(): dwCode = 0x%x\n", dwCode));
#endif // DETAIL_DEBUG

    switch (dwCode)
        {
        case SERVICE_CONTROL_STOP:
            //
            // Stop the service.
            //
            // SERVICE_STOP_PENDING should be reported before setting the Stop
            // Event.  This avoids a race condition which may result in a 1053
            // - "The Service did not respond" error.
            //
            ReportStatusToSCM(SERVICE_STOP_PENDING, NO_ERROR, SENS_WAIT_HINT);

            ServiceStop();

            ReportStatusToSCM(SERVICE_STOPPED, NO_ERROR, 0);

            return dwStatus;

        case SERVICE_CONTROL_INTERROGATE:
            //
            // Update the service status.
            //

            ReportStatusToSCM(gServiceStatus.dwCurrentState, NO_ERROR, 0);
            break;

#ifdef PNP_EVENTS
        case SERVICE_CONTROL_DEVICEEVENT:
            //
            // PnP event.
            //
#ifdef DETAIL_DEBUG
            RtlInitUnicodeString(&UnicodeString, (PCWSTR) &pDevice->dbcc_name);
            NtStatus = RtlUnicodeStringToAnsiString(&DeviceNameA, &UnicodeString, TRUE);
            UuidToStringA(&pDevice->dbcc_classguid, &DeviceUuidA);

            SensPrintToDebugger(SENS_DBG, ("\n-------------------------------------------------------------\n"));
            SensPrintToDebugger(SENS_DBG, ("SENS received a PnP Event - "));
            SensPrintToDebugger(SENS_DBG, ((dwEventType == DBT_DEVICEREMOVECOMPLETE) ? "DEVICE REMOVED\n" : ""));
            SensPrintToDebugger(SENS_DBG, ((dwEventType == DBT_DEVICEARRIVAL) ? "DEVICE ARRIVED\n" : "\n"));
            SensPrintToDebugger(SENS_DBG, ("\tdwCode        - 0x%x\n", dwCode));
            SensPrintToDebugger(SENS_DBG, ("\tdwEventType   - 0x%x\n", dwEventType));
            SensPrintToDebugger(SENS_DBG, ("\tpData         - 0x%x\n", pData));
            SensPrintToDebugger(SENS_DBG, ("\tEventData     - 0x%x\n", pDevice));
            SensPrintToDebugger(SENS_DBG, ("\t  o dbcc_size         - 0x%x\n", pDevice->dbcc_size));
            SensPrintToDebugger(SENS_DBG, ("\t  o dbcc_devicetype   - 0x%x\n", pDevice->dbcc_devicetype));
            SensPrintToDebugger(SENS_DBG, ("\t  o dbcc_reserved     - 0x%x\n", pDevice->dbcc_reserved));
            SensPrintToDebugger(SENS_DBG, ("\t  o dbcc_classguid    - %s\n", DeviceUuidA));
            SensPrintToDebugger(SENS_DBG, ("\t  o dbcc_name         - %s\n", DeviceNameA.Buffer));
            SensPrintToDebugger(SENS_DBG, ("-------------------------------------------------------------\n\n"));

            if (NT_SUCCESS(NtStatus))
                {
                RtlFreeAnsiString(&DeviceNameA);
                }
            if (DeviceUuidA != NULL)
                {
                RpcStringFreeA(&DeviceUuidA);
                }
#endif // DETAIL_DEBUG
            break;
#endif // PNP_EVENTS

        case SERVICE_CONTROL_POWEREVENT:
            {
            // 
            // Power event
            //

            //
            // These are generated every 1% of power change, also by playing
            // with the power cpl or plugging in the machine.
            // 

            SYSTEM_POWER_STATUS CurSPstate;
            SENSEVENT_POWER Data;
            BOOL bRet;
            BOOL bFireEvent = FALSE;

            bRet = GetSystemPowerStatus(&CurSPstate);
            ASSERT(bRet);

            switch(dwEventType) 
                {
                case PBT_APMPOWERSTATUSCHANGE:
                    {
                    //
                    // OnACPower event is fired when
                    //    o previously the machine was not on AC
                    //    o now, it is on AC
                    //
                    if (   (CurSPstate.ACLineStatus == AC_LINE_ONLINE)
                        && (gSystemPowerState.ACLineStatus != AC_LINE_ONLINE))
                        {
                        Data.eType = SENS_EVENT_POWER_ON_ACPOWER;
                        bFireEvent = TRUE;
                        }
                    else
                        //
                        // OnBatteryPower event is fired when
                        //    o previously the machine was on AC
                        //    o now, it is not on AC
                        //    o the machine has a system battery
                        //
                    if (   (CurSPstate.ACLineStatus == AC_LINE_OFFLINE)
                        && (gSystemPowerState.ACLineStatus == AC_LINE_ONLINE)
                        && ((CurSPstate.BatteryFlag & BATTERY_FLAG_NO_BATTERY) == 0))
                        {
                        Data.eType = SENS_EVENT_POWER_ON_BATTERYPOWER;
                        bFireEvent = TRUE;

                        // Special case, if the machine goes off battery and has a low
                        // battery we want to generate both events.  Resetting the
                        // low battery flag here guarantees that next time power changes
                        // we will fire the low battery event.
                        CurSPstate.BatteryFlag = CurSPstate.BatteryFlag & ~BATTERY_FLAG_LOW;
                        }
                    else
                        // OnBatteryPowerLow event is fired when
                        // o the battery is not charging and
                        // o previously the battery was not low
                        // o and now the battery is low.
                        //
                    if (     (CurSPstate.BatteryFlag & BATTERY_FLAG_LOW)
                        && ( (CurSPstate.BatteryFlag & BATTERY_FLAG_CHARGING) == 0)
                        && ( (gSystemPowerState.BatteryFlag & BATTERY_FLAG_LOW) == 0) )
                        {
                        Data.eType = SENS_EVENT_POWER_BATTERY_LOW;
                        bFireEvent = TRUE;
                        }
                    else 
                        {
                        // Power event we don't about
                        ASSERT(bFireEvent == FALSE);
                        }

                    break;
                    }

                default:
                    {
                    // Other power event we can ignore
                    break;
                    }
                }

            if (bFireEvent)
                {
                // Save the new state. A critsec is not necessary as service control messages are serialized.
                memcpy(&gSystemPowerState, &CurSPstate, sizeof(SYSTEM_POWER_STATUS));

                // Fire the event.
                memcpy(&Data.PowerStatus, &CurSPstate, sizeof(SYSTEM_POWER_STATUS));
                SensFireEvent(&Data);
                }

            dwStatus = SUCCESS;
            break;
            }

        default:

            dwStatus = ERROR_CALL_NOT_IMPLEMENTED;

            // invalid control code
            break;
        }
    
    return dwStatus;
}




BOOL
ReportStatusToSCM(
    DWORD dwCurrentState,
    DWORD dwExitCode,
    DWORD dwWaitHint
    )
/*++

Routine Description:

    Report status to SCM.

Arguments:

    dwCurrentState - The current state of the service.

    dwExitCode - The Win32 Exit code.

    dwWaitHint - The amount of time in msec to wait for the SCM to acknowledge.

Return Value:

    TRUE, succeeded.

    FALSE, otherwise.

--*/
{
    DWORD dwCheckPoint = 0;
    BOOL bResult = TRUE;

    if (dwCurrentState == SERVICE_START_PENDING)
        {
        gServiceStatus.dwControlsAccepted = 0;
        }
    else
        {
        gServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_POWEREVENT;
        }

    gServiceStatus.dwCurrentState   = dwCurrentState;
    gServiceStatus.dwWin32ExitCode  = dwExitCode;
    gServiceStatus.dwWaitHint       = dwWaitHint;

    if (   (dwCurrentState == SERVICE_RUNNING)
        || (dwCurrentState == SERVICE_STOPPED))
        {
        gServiceStatus.dwCheckPoint = 0;
        }
    else
        {
        gServiceStatus.dwCheckPoint = ++dwCheckPoint;
        }

    //
    // Report the status of the service to the SCM.
    // Caller handles error reporting, so we can have some context....
    //
    return SetServiceStatus(ghStatusHandle, &gServiceStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\senssvc\stub_notify_s.c ===
#include <notify_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\senssvc\stub_api_s.c ===
#include <api_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\senssvc\wan.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    wan.cxx

Abstract:

    This is the source file relating to the WAN-specific routines of the
    Connectivity APIs implementation.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          10/11/1997         Start.

--*/


#include <precomp.hxx>

//
// Typedefs
//
typedef DWORD (APIENTRY *LPFN_RAS_ENUM)(LPRASCONN, LPDWORD, LPDWORD);
typedef BOOL  (APIENTRY *LPFN_DO_CONNECTOIDS_EXIST)(void);
typedef DWORD (APIENTRY *LPFN_RAS_CONNECTION_NOTIFICATION)(HRASCONN, HANDLE, DWORD);
typedef DWORD (APIENTRY *LPFN_RAS_GET_CONNECT_STATUS)(HRASCONN, LPRASCONNSTATUS);



//
// Constants
//
#define RAS_DLL         SENS_STRING("RasApi32.dll")
#define WININET_DLL     SENS_STRING("Wininet.dll")

#if !defined(SENS_CHICAGO)
#define RAS_ENUM                    "RasEnumConnectionsW"
#define RAS_CONNECTION_NOTIFICATION "RasConnectionNotificationW"
#else     // SENS_CHICAGO
#define RAS_ENUM                    "RasEnumConnectionsA"
#define RAS_CONNECTION_NOTIFICATION "RasConnectionNotificationA"
#define RAS_GET_CONNECT_STATUS      "RasGetConnectStatusA"
#define DO_CONNECTOIDS_EXIST        (LPCSTR) 101    // Ordinal 101
#endif    // SENS_CHICAGO

#if (WINVER < 0x401)
#define RASCN_Connection        0x00000001
#define RASCN_Disconnection     0x00000002
#endif // WINVER < 0x401



//
// Globals
//

// Common
long            gdwLastWANTime;
long            gdwWANState;
BOOL            gbIsRasInstalled;
LPFN_RAS_ENUM   glpfnRasEnumConnections;
LPFN_RAS_CONNECTION_NOTIFICATION glpfnRasConnectionNotification;

// IE5-specific
#if !defined(SENS_NT5)
HANDLE          ghRasEvents[2];
HANDLE          ghConnectWait;
HANDLE          ghDisconnectWait;
#endif // SENS_NT5

// Win9x-specific
#if defined(SENS_CHICAGO)
LPFN_RAS_GET_CONNECT_STATUS glpfnRasGetConnectStatus;
#endif // SENS_CHICAGO





inline void
LoadRasIfNecessary(
    void
    )
/*++

Routine Description:

    Load RAS DLL, if necessary.

Arguments:

    None.

Return Value:

    None.

--*/
{
    HMODULE hDLL;

    //
    // See if RAS DLL is already loaded.
    //
    if (NULL != glpfnRasEnumConnections)
        {
        return;
        }

    //
    // Do the necessary work.
    //
    hDLL = LoadLibrary(RAS_DLL);
    if (hDLL != NULL)
        {
        glpfnRasEnumConnections = (LPFN_RAS_ENUM) GetProcAddress(hDLL, RAS_ENUM);
        glpfnRasConnectionNotification = (LPFN_RAS_CONNECTION_NOTIFICATION)
                                         GetProcAddress(hDLL, RAS_CONNECTION_NOTIFICATION);
#if defined(SENS_CHICAGO)
        glpfnRasGetConnectStatus = (LPFN_RAS_GET_CONNECT_STATUS)
                                   GetProcAddress(hDLL, RAS_GET_CONNECT_STATUS);
#endif // SENS_CHICAGO

        if (
               (NULL == glpfnRasEnumConnections)
#if defined(SENS_CHICAGO)
            && (NULL == glpfnRasGetConnectStatus)
#endif // SENS_CHICAGO
           )
            {
            // Both entrypoints are NULL. Can't do much with RAS now.
            FreeLibrary(hDLL);
            }
        }

    SensPrintA(SENS_INFO, ("[SENS] LoadRasIfNecessary(): RAS DLL is %spresent.\n",
               (glpfnRasEnumConnections ? "" : "NOT ")));

}




BOOL
DoWanSetup(
    void
    )
/*++

Routine Description:

    Do minimal WAN Setup.

Arguments:

    None.

Return Value:

    TRUE, if successful.

    FALSE, otherwise.

--*/
{
    DWORD dwLastError;
    DWORD dwCurrentRasState;
    BOOL bStatus;

    dwLastError = 0;
    dwCurrentRasState = 0;
    bStatus = FALSE;
    glpfnRasEnumConnections = NULL;
    glpfnRasConnectionNotification = NULL;
    gbIsRasInstalled = FALSE;
    bStatus = TRUE;

Cleanup:
    //
    // Cleanup
    //
    return bStatus;
}


BOOL
IsRasInstalled(
    OUT LPDWORD lpdwState,
    OUT LPDWORD lpdwLastError
    )
/*++

Routine Description:

    Check to see if RAS is installed. If so, return it's current state.

Arguments:

    lpdwState - If Ras is installed, this parameter contains the current state
        of the RasMan service.

    lpdwLastError - If RAS is not active or installed, it retuns the GLE.

Return Value:

    TRUE, if Ras is installed.

    FALSE, otherwise.

--*/
{
    if (TRUE == gbIsRasInstalled)
        {
        *lpdwState = SERVICE_RUNNING;   // For NT
        *lpdwLastError = ERROR_SUCCESS;

        return TRUE;
        }

    static SC_HANDLE hSCM;      // Cache the handle.
    static SC_HANDLE hRasMan;   // Cache the handle.

    BOOL bRetValue;
    SERVICE_STATUS ServiceStatus;

    bRetValue = FALSE;
    *lpdwState = 0;
    *lpdwLastError = ERROR_SUCCESS;

    if (NULL == hSCM)
        {
        hSCM = OpenSCManager(
                   NULL,                   // Local machine
                   NULL,                   // Default database - SERVICES_ACTIVE_DATABASE
                   SC_MANAGER_ALL_ACCESS   // NOTE: Only for Administrators
                   );
        if (NULL == hSCM)
            {
            SensPrintA(SENS_ERR, ("OpenSCManager() returned %d\n", *lpdwLastError));
            goto Cleanup;
            }
        }

    if (hRasMan == NULL)
        {
        hRasMan = OpenService(
                      hSCM,                 // Handle to SCM database
                      RAS_MANAGER,          // Name of the service to start
                      SERVICE_QUERY_STATUS  // Type of access requested
                      );
        if (NULL == hRasMan)
            {
            SensPrintA(SENS_ERR, ("OpenService() returned %d\n", *lpdwLastError));
            goto Cleanup;
            }
        }

    memset(&ServiceStatus, 0, sizeof(SERVICE_STATUS));

    bRetValue = QueryServiceStatus(
                    hRasMan,
                    &ServiceStatus
                    );
    ASSERT(bRetValue == TRUE);

    if (FALSE == bRetValue)
        {
        goto Cleanup;
        }

    *lpdwState = ServiceStatus.dwCurrentState;

    gbIsRasInstalled = TRUE;

    SensPrintA(SENS_ERR, ("IsRasInstalled(): RASMAN state is %d\n",
               *lpdwState));

    return TRUE;

Cleanup:
    //
    // Cleanup
    //
    *lpdwLastError = GetLastError();

    if (hSCM)
        {
        CloseServiceHandle(hSCM);
        hSCM = NULL;
        }
    if (hRasMan)
        {
        CloseServiceHandle(hRasMan);
        hRasMan = NULL;
        }

    return FALSE;
}




BOOL WINAPI
EvaluateWanConnectivity(
    OUT LPDWORD lpdwLastError
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    BOOL bWanAlive;
    BOOL bRasInstalled;
    DWORD dwNow;
    DWORD dwCurrentRasState;
    SERVICE_STATUS ServiceStatus;
    PWCHAR szEntryName;
    DWORD dwLocalLastError;

    dwNow = GetTickCount();
    bWanAlive = FALSE;
    dwCurrentRasState = 0;
    dwLocalLastError = ERROR_NO_NETWORK;

	if (lpdwLastError)
        {
        *lpdwLastError = dwLocalLastError;
        }
    else
        {
        lpdwLastError = &dwLocalLastError;
        }

	szEntryName = new WCHAR[RAS_MaxEntryName + 1];
	if (!szEntryName )
		{
		*lpdwLastError = ERROR_OUTOFMEMORY;
		return FALSE;
		}

    StringCchCopy(szEntryName, RAS_MaxEntryName + 1, DEFAULT_WAN_CONNECTION_NAME);

    //
    // If RasManager is running, it implies that there "might" be one or more
    // active RAS connections.
    //
    bRasInstalled = IsRasInstalled(&dwCurrentRasState, lpdwLastError);

    if (TRUE == bRasInstalled)
        {
        LoadRasIfNecessary();
        }

    if (   (bRasInstalled) 
        && (dwCurrentRasState == SERVICE_RUNNING)
        && (glpfnRasEnumConnections != NULL))
        {
        DWORD dwRasStatus;
        DWORD cBytes;
        DWORD cBytesOld;
        DWORD cConnections;
        RASCONN *pRasConn;

        dwRasStatus = 0x0;
        cConnections = 0;

        //
        // Start with loop with a single structure.  Will loop and realloc if we need
		// a larger buffer.
        //
		cBytesOld = 0;
		cBytes = sizeof(RASCONN);
		pRasConn = NULL;
		dwRasStatus = ERROR_BUFFER_TOO_SMALL;

        //
        // Loop till RasEnumConnections() succeeds or returns with an error
        // other than ERROR_BUFFER_TOO_SMALL.
        //
        while (ERROR_BUFFER_TOO_SMALL == dwRasStatus)
            {
            ASSERT(cBytes > cBytesOld);
			ASSERT(pRasConn == NULL);

            // Allocate the buffer
            pRasConn = (RASCONN *) new char[cBytes];
            if (pRasConn == NULL)
                {
				delete szEntryName;
				*lpdwLastError = ERROR_OUTOFMEMORY;
                return FALSE;
                }

            pRasConn[0].dwSize = sizeof(RASCONN);
            cBytesOld = cBytes;

            dwRasStatus = (*glpfnRasEnumConnections)(
                              pRasConn,
                              &cBytes,
                              &cConnections
                              );

            // Free the too small buffer.
            if (ERROR_BUFFER_TOO_SMALL == dwRasStatus)
                {
                delete pRasConn;
				pRasConn = NULL;
				SensPrintA(SENS_WARN, ("RasEnumConnections(): reallocing buffer to be %d bytes\n", cBytes));
                }
            }

        if ((0 == dwRasStatus) &&
            (cConnections > 0))
            {
            bWanAlive = TRUE;
            SensPrintA(SENS_INFO, ("RasEnumConnections(%d) successful connections (%d)\n", cBytes, cConnections));

            // P3 BUG: we're only dealing with one RAS connection for now
            SensPrintA(SENS_INFO, ("\tConnection name: %s\n", pRasConn->szEntryName));

            StringCchCopy(szEntryName, RAS_MaxEntryName + 1, pRasConn->szEntryName);
            }
        else
            {
            if (dwRasStatus != 0)
                {
                *lpdwLastError = dwRasStatus;
                }
            SensPrintA(SENS_ERR, ("RasEnumConnections() returned %d - "
                       "connections (%d)\n", dwRasStatus, cConnections));
            }

        // Delete the RASCONN structure.
        delete pRasConn;

        } // if (bRasInstalled)


    SensPrintA(SENS_INFO, ("EvaluateWanConnectivity() returning %s, GLE of %d\n",
               bWanAlive ? "TRUE" : "FALSE", *lpdwLastError));


    if (InterlockedExchange(&gdwWANState, bWanAlive) != bWanAlive)
        {
        //
        // WAN Connectivity state changed.
        //
        BOOL bSuccess;
        DWORD dwActiveWanInterfaceSpeed;
        DWORD dwLastError;
        SENSEVENT_NETALIVE Data;

        dwLastError = ERROR_SUCCESS;
        dwActiveWanInterfaceSpeed = 0x0;

        if (bWanAlive)
            {
            bSuccess = GetActiveWanInterfaceStatistics(
                           &dwLastError,
                           &dwActiveWanInterfaceSpeed
                           );
#ifdef SENS_NT5
            // Will always fire on NT4/Win9x (due to bugs). Can fire on NT5.
            SensPrintA(SENS_WARN, ("GetActiveWanInterfaceStatistics() returned"
                       " FALSE, using defaults!\n"));
#endif // SENS_NT5
            }

        Data.eType = SENS_EVENT_NETALIVE;
        Data.bAlive = bWanAlive;
        memset(&Data.QocInfo, 0x0, sizeof(QOCINFO));
        Data.QocInfo.dwSize = sizeof(QOCINFO);
        Data.QocInfo.dwFlags = NETWORK_ALIVE_WAN;
        Data.QocInfo.dwInSpeed = dwActiveWanInterfaceSpeed;
        Data.QocInfo.dwOutSpeed = dwActiveWanInterfaceSpeed;
        Data.strConnection = szEntryName;

        UpdateSensCache(WAN);

        SensFireEvent((PVOID)&Data);
        }

    if (bWanAlive)
        {
        InterlockedExchange(&gdwLastWANTime, dwNow);
        }
    else
        {
        InterlockedExchange(&gdwLastWANTime, 0x0);
        }

    SensPrintA(SENS_INFO, ("RasEventNotifyRoutine(%d) - WAN Time is %d msec\n", dwNow, gdwLastWANTime));

	delete szEntryName;

    return bWanAlive;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\test\senssink\cfaclogn.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    cfaclogn.cxx

Abstract:

    Implements the Class Factory for the SENS ISensLogon Subscriber.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          11/17/1997         Start.

--*/


#include <common.hxx>
#include <ole2.h>
#include <sensevts.h>
#include "sinkcomn.hxx"
#include "cfaclogn.hxx"
#include "cimplogn.hxx"


//
// Global counts for the number of objects in the server and the number of
// locks.
//

extern ULONG g_cObj;
extern ULONG g_cLock;



//
// Constructor and Destructor
//
CISensLogonCF::CISensLogonCF(
    void
    ) : m_cRef(1L)
{

}

CISensLogonCF::~CISensLogonCF(
    void
    )
{
    // Empty Destructor.
}



//
// QI
//
STDMETHODIMP
CISensLogonCF::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    HRESULT hr = S_OK;

    *ppv = NULL; // To handle failure cases

    // IUnknown or IClassFactory
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory))
        {
        *ppv = (LPUNKNOWN) this;
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    if (NULL != *ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        }

    return hr;
}



//
// AddRef
//
STDMETHODIMP_(ULONG)
CISensLogonCF::AddRef(
    void
    )
{
    return InterlockedIncrement((PLONG) &m_cRef);
}


//
// Release
//
STDMETHODIMP_(ULONG)
CISensLogonCF::Release(
    void
    )
{
    ULONG cRefT;

    cRefT = InterlockedDecrement((PLONG) &m_cRef);

    if (0 == m_cRef)
        {
        // Invoke the callback function.
        ObjectDestroyed();
        delete this;
        }

    return cRefT;
}



//
// CreateInstance
//
STDMETHODIMP
CISensLogonCF::CreateInstance(
    LPUNKNOWN pUnkOuter,
    REFIID riid,
    LPVOID *ppvObj
    )
{
    LPCIMPISENSLOGON pObjLogn;
    HRESULT hr;

    DebugTraceGuid("CISensLogonCF::CreateInstance()", riid);

    hr = E_OUTOFMEMORY;
    *ppvObj = NULL;
    pObjLogn = NULL;

    //
    // Return the appropriate interface pointer.
    //
    if (IsEqualIID(riid, IID_ISensLogon) ||
        IsEqualIID(riid, IID_IUnknown))
        {
        SensPrintA(SENS_INFO, ("\t| ClassFactory::CreateInstance(ISensLogon)\n"));
        pObjLogn = new CImpISensLogon(ObjectDestroyed);
        if (NULL != pObjLogn)
            {
            hr = pObjLogn->QueryInterface(riid, ppvObj);
            SensPrintA(SENS_INFO, ("\t| QI on CImpISensLogon returned 0x%x\n", hr));
            }
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    if (NULL != *ppvObj)
        {
        InterlockedIncrement((PLONG) &g_cObj);
        }

    SensPrintA(SENS_INFO, ("\t| Returning 0x%x from CF:CreateInstance\n", hr));

    return hr;
}



//
// LockServer
//
STDMETHODIMP
CISensLogonCF::LockServer(
    BOOL fLock
    )
{
    if (fLock)
        {
        InterlockedIncrement((PLONG) &g_cLock);
        }
    else
        {
        InterlockedDecrement((PLONG) &g_cLock);

        InterlockedIncrement((PLONG) &g_cObj);
        ObjectDestroyed(); // this does a --g_cObj
        }

    return NOERROR;
}


//
// Class Factory for ISensLogon2 implementation
//



//
// Constructor and Destructor
//
CISensLogon2CF::CISensLogon2CF(
    void
    ) : m_cRef(1L)
{

}

CISensLogon2CF::~CISensLogon2CF(
    void
    )
{
    // Empty Destructor.
}



//
// QI
//
STDMETHODIMP
CISensLogon2CF::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    HRESULT hr = S_OK;

    *ppv = NULL; // To handle failure cases

    // IUnknown or IClassFactory
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory))
        {
        *ppv = (LPUNKNOWN) this;
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    if (NULL != *ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        }

    return hr;
}



//
// AddRef
//
STDMETHODIMP_(ULONG)
CISensLogon2CF::AddRef(
    void
    )
{
    return InterlockedIncrement((PLONG) &m_cRef);
}


//
// Release
//
STDMETHODIMP_(ULONG)
CISensLogon2CF::Release(
    void
    )
{
    ULONG cRefT;

    cRefT = InterlockedDecrement((PLONG) &m_cRef);

    if (0 == m_cRef)
        {
        // Invoke the callback function.
        ObjectDestroyed();
        delete this;
        }

    return cRefT;
}



//
// CreateInstance
//
STDMETHODIMP
CISensLogon2CF::CreateInstance(
    LPUNKNOWN pUnkOuter,
    REFIID riid,
    LPVOID *ppvObj
    )
{
    LPCIMPISENSLOGON2 pObjLogn2;
    HRESULT hr;

    DebugTraceGuid("CISensLogon2CF::CreateInstance()", riid);

    hr = E_OUTOFMEMORY;
    *ppvObj = NULL;
    pObjLogn2 = NULL;

    //
    // Return the appropriate interface pointer.
    //
    if (IsEqualIID(riid, IID_ISensLogon2) ||
        IsEqualIID(riid, IID_IUnknown))
        {
        SensPrintA(SENS_INFO, ("\t| ClassFactory::CreateInstance(ISensLogon2)\n"));
        pObjLogn2 = new CImpISensLogon2(ObjectDestroyed);
        if (NULL != pObjLogn2)
            {
            hr = pObjLogn2->QueryInterface(riid, ppvObj);
            SensPrintA(SENS_INFO, ("\t| QI on CImpISensLogon2 returned 0x%x\n", hr));
            }
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    if (NULL != *ppvObj)
        {
        InterlockedIncrement((PLONG) &g_cObj);
        }

    SensPrintA(SENS_INFO, ("\t| Returning 0x%x from CF:CreateInstance\n", hr));

    return hr;
}



//
// LockServer
//
STDMETHODIMP
CISensLogon2CF::LockServer(
    BOOL fLock
    )
{
    if (fLock)
        {
        InterlockedIncrement((PLONG) &g_cLock);
        }
    else
        {
        InterlockedDecrement((PLONG) &g_cLock);

        InterlockedIncrement((PLONG) &g_cObj);
        ObjectDestroyed(); // this does a --g_cObj
        }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\test\senssink\cfacpwr.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    cfacpwr.cxx

Abstract:

    Implements the Class Factory for the SENS ISensOnNow Subscriber.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          11/17/1997         Start.

--*/


#include <common.hxx>
#include <ole2.h>
#include <sensevts.h>
#include "sinkcomn.hxx"
#include "cfacpwr.hxx"
#include "cimppwr.hxx"


//
// Global counts for the number of objects in the server and the number of
// locks.
//

extern ULONG g_cObj;
extern ULONG g_cLock;



//
// Constructor and Destructor
//
CISensOnNowCF::CISensOnNowCF(
    void
    ) : m_cRef(1L)
{

}

CISensOnNowCF::~CISensOnNowCF(
    void
    )
{
    // Empty Destructor.
}



//
// QI
//
STDMETHODIMP
CISensOnNowCF::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    HRESULT hr = S_OK;

    *ppv = NULL; // To handle failure cases

    // IUnknown or IClassFactory
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory))
        {
        *ppv = (LPUNKNOWN) this;
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    if (NULL != *ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        }

    return hr;
}



//
// AddRef
//
STDMETHODIMP_(ULONG)
CISensOnNowCF::AddRef(
    void
    )
{
    return InterlockedIncrement((PLONG) &m_cRef);
}


//
// Release
//
STDMETHODIMP_(ULONG)
CISensOnNowCF::Release(
    void
    )
{
    ULONG cRefT;

    cRefT = InterlockedDecrement((PLONG) &m_cRef);

    if (0 == m_cRef)
        {
        // Invoke the callback function.
        ObjectDestroyed();
        delete this;
        }

    return cRefT;
}



//
// CreateInstance
//
STDMETHODIMP
CISensOnNowCF::CreateInstance(
    LPUNKNOWN pUnkOuter,
    REFIID riid,
    LPVOID *ppvObj
    )
{
    LPCIMPISENSONNOW pObjPower;
    HRESULT hr;

    DebugTraceGuid("CISensOnNowCF::CreateInstance()", riid);

    hr = E_OUTOFMEMORY;
    *ppvObj = NULL;
    pObjPower = NULL;

    //
    // Return the appropriate interface pointer.
    //
    if (IsEqualIID(riid, IID_ISensOnNow) ||
        IsEqualIID(riid, IID_IUnknown))
        {
        SensPrintA(SENS_INFO, ("\t| ClassFactory::CreateInstance(ISensNetwork)\n"));
        pObjPower = new CImpISensOnNow(ObjectDestroyed);
        if (NULL != pObjPower)
            {
            hr = pObjPower->QueryInterface(riid, ppvObj);
            SensPrintA(SENS_INFO, ("\t| QI on CImpISensOnNow returned 0x%x\n", hr));
            }
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    if (NULL != *ppvObj)
        {
        InterlockedIncrement((PLONG) &g_cObj);
        }

    SensPrintA(SENS_INFO, ("\t| Returning 0x%x from CF:CreateInstance\n", hr));

    return hr;
}



//
// LockServer
//
STDMETHODIMP
CISensOnNowCF::LockServer(
    BOOL fLock
    )
{
    if (fLock)
        {
        InterlockedIncrement((PLONG) &g_cLock);
        }
    else
        {
        InterlockedDecrement((PLONG) &g_cLock);

        InterlockedIncrement((PLONG) &g_cObj);
        ObjectDestroyed(); // this does a --g_cObj
        }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\senssvc\syncmgr.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    syncmgr.cxx

Abstract:

    This file contains code for Syncmgr to workaround the security
    restrictions placed on HKLM registry key. Normal users cannot
    write to HKLM now. So, SENS (running as LocalSystem) does the
    dirty work for Syncmgr.

Author:

    Gopal Parupudi    <GopalP>

Notes:

    This code is authored by RogerG.

Revision History:

    GopalP          3/10/1999         Start.
    
    RogerG          9/29/1999         Plug security holes.

--*/


#include <precomp.hxx>




typedef enum SYNCMGRCMDEXECID
{
    SYNCMGRCMDEXECID_UPDATERUNKEY = 1,
    SYNCMGRCMDEXECID_RESETREGSECURITY = 2,
} SYNCMGRCMDEXECID;


// functions local to file implementation is in.
HRESULT SyncMgrExecCmdUpdateRunKey(DWORD nCmdID, DWORD nCmdExecOpt);
HRESULT SyncMgrExecCmdResetRegSecurity(DWORD nCmdID, DWORD nCmdExecOpt);

BOOL SyncMgrGetSecurityDescriptor(SECURITY_ATTRIBUTES *psa,PSECURITY_DESCRIPTOR psd,
                                           PACL *ppOutAcl);
BOOL SyncMgrSetRegKeySecurityEveryone(HKEY hKeyParent,LPCTSTR lpSubKey,SECURITY_DESCRIPTOR *psd); // helper function
HRESULT SyncSetSubKeySecurityEveryone(HKEY hKeyParent,SECURITY_DESCRIPTOR *psd); // helper function
// end of local function delclaration

//--------------------------------------------------------------------------------
//
//  FUNCTION: RPC_SyncMgrExecCmd, public
//
//  PURPOSE: Executes specified SyncMgr cmd.
//
//
//  COMMENTS:
//
//
//--------------------------------------------------------------------------------

error_status_t RPC_SyncMgrExecCmd(handle_t hRpc, DWORD nCmdID, DWORD nCmdExecOpt)
{
HRESULT hr = E_UNEXPECTED;

    switch (nCmdID)
    {
    case SYNCMGRCMDEXECID_UPDATERUNKEY:
        hr =  SyncMgrExecCmdUpdateRunKey(nCmdID,nCmdExecOpt);
        break;
    case SYNCMGRCMDEXECID_RESETREGSECURITY:
        hr =  SyncMgrExecCmdResetRegSecurity(nCmdID,nCmdExecOpt);
        break;
    default:
        hr = S_FALSE;
        break;
    }

    return hr;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: SyncMgrExecCmdUpdateRunKey
//
//  PURPOSE: Updates the RunKey under HKLM to set if mobsync.exe
//            is run on shell startup.
//
//
//  COMMENTS:
//
//
//--------------------------------------------------------------------------------

const TCHAR szRunKey[]  = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Run");
const TCHAR szRunKeyCommandLine[]  = TEXT("%SystemRoot%\\system32\\mobsync.exe /logon");
const TCHAR szRunKeyValueName[] = TEXT("Synchronization Manager");

HRESULT SyncMgrExecCmdUpdateRunKey(DWORD nCmdID, DWORD nCmdExecOpt)
{
HRESULT hr;
HKEY hKeyRun;
BOOL fLogon = nCmdExecOpt ? TRUE : FALSE; // CmdExecOpt of zero means to remove, else write.

    if (ERROR_SUCCESS == (hr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,szRunKey,
                              NULL,KEY_READ | KEY_WRITE,&hKeyRun)))
    {
        if (fLogon)
        {
            hr = RegSetValueEx(hKeyRun, szRunKeyValueName, 0, REG_EXPAND_SZ,
                    (BYTE *) szRunKeyCommandLine,(lstrlen(szRunKeyCommandLine) + 1)*sizeof(TCHAR));
        }
        else
        {
            hr = RegDeleteValue(hKeyRun, szRunKeyValueName);
        }

        RegCloseKey(hKeyRun);
    }

    return hr;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: SyncMgrGetSecurityDescriptor
//
//  PURPOSE: Creates an appropriate secuirty descriptor to set on
//           the subkeys.
//
//
//  COMMENTS:
//
//
//--------------------------------------------------------------------------------

BOOL SyncMgrGetSecurityDescriptor(SECURITY_ATTRIBUTES *psa
                                          ,PSECURITY_DESCRIPTOR psd,
                                           PACL *ppOutAcl)
{
BOOL bRetVal;
int cbAcl;
PACL pAcl = NULL;
PSID pInteractiveUserSid = NULL;
PSID pLocalSystemSid = NULL;
PSID pAdminsSid = NULL;
SID_IDENTIFIER_AUTHORITY WorldAuthority = SECURITY_WORLD_SID_AUTHORITY;
SID_IDENTIFIER_AUTHORITY LocalSystemAuthority = SECURITY_NT_AUTHORITY;

    *ppOutAcl = NULL;

    bRetVal = FALSE;

    // in the structure.

    bRetVal = InitializeSecurityDescriptor(
              psd,                          // Pointer to SD
              SECURITY_DESCRIPTOR_REVISION  // SD revision
              );

    if (!bRetVal)
    {
        goto errRtn;
    }

    // setup acls.

    bRetVal = AllocateAndInitializeSid(
                  &LocalSystemAuthority,      // Pointer to identifier authority
                  1,                    // Count of subauthority
                  SECURITY_INTERACTIVE_RID,   // Subauthority 0
                  0,                    // Subauthority 1
                  0,                    // Subauthority 2
                  0,                    // Subauthority 3
                  0,                    // Subauthority 4
                  0,                    // Subauthority 5
                  0,                    // Subauthority 6
                  0,                    // Subauthority 7
                  &pInteractiveUserSid            // pointer to pointer to SID
                  );



    if (!bRetVal)
    {
        goto errRtn;
    }

    bRetVal = AllocateAndInitializeSid(
                  &LocalSystemAuthority,// Pointer to identifier authority
                  2,                    // Count of subauthority
                  SECURITY_BUILTIN_DOMAIN_RID,  // Subauthority 1
                  DOMAIN_ALIAS_RID_ADMINS,      // Subauthority 2
                  0,                    // Subauthority 2
                  0,                    // Subauthority 3
                  0,                    // Subauthority 4
                  0,                    // Subauthority 5
                  0,                    // Subauthority 6
                  0,                    // Subauthority 7
                  &pAdminsSid           // pointer to pointer to SID
                  );

    if (!bRetVal)
    {
        goto errRtn;
    }


    bRetVal = AllocateAndInitializeSid(
              &LocalSystemAuthority,// Pointer to identifier authority
              1,                    // Count of subauthority
              SECURITY_LOCAL_SYSTEM_RID,   // Subauthority 0
              0,                    // Subauthority 1
              0,                    // Subauthority 2
              0,                    // Subauthority 3
              0,                    // Subauthority 4
              0,                    // Subauthority 5
              0,                    // Subauthority 6
              0,                    // Subauthority 7
              &pLocalSystemSid      // pointer to pointer to SID
              );

    if (!bRetVal)
    {
        goto errRtn;
    }

    cbAcl =   sizeof (ACL)
        + 3 * sizeof (ACCESS_ALLOWED_ACE)
        + GetLengthSid(pInteractiveUserSid)
        + GetLengthSid(pLocalSystemSid)
        + GetLengthSid(pAdminsSid);

    pAcl = (PACL) new char[cbAcl];

    if (NULL == pAcl)
    {
        bRetVal = FALSE;
        goto errRtn;
    }

    bRetVal = InitializeAcl(
              pAcl,             // Pointer to the ACL
              cbAcl,            // Size of ACL
              ACL_REVISION      // Revision level of ACL
              );

    if (!bRetVal)
    {
        goto errRtn;
    }


    bRetVal = AddAccessAllowedAce(
              pAcl,             // Pointer to the ACL
              ACL_REVISION,     // ACL revision level
              SPECIFIC_RIGHTS_ALL | GENERIC_READ | DELETE ,    // Access Mask
              pInteractiveUserSid         // Pointer to SID
              );

    if (!bRetVal)
    {
        goto errRtn;
    }


    bRetVal = AddAccessAllowedAce(
              pAcl,             // Pointer to the ACL
              ACL_REVISION,     // ACL revision level
              GENERIC_ALL,      // Access Mask
              pAdminsSid        // Pointer to SID
          );

   if (!bRetVal)
    {
        goto errRtn;
    }

    bRetVal = AddAccessAllowedAce(
              pAcl,             // Pointer to the ACL
              ACL_REVISION,     // ACL revision level
              GENERIC_ALL,      // Access Mask
              pLocalSystemSid   // Pointer to SID
              );

    if (!bRetVal)
    {
        goto errRtn;
    }

    bRetVal =  SetSecurityDescriptorDacl(psd,TRUE,pAcl,FALSE);

    if (!bRetVal)
    {
        goto errRtn;
    }

    psa->nLength = sizeof(SECURITY_ATTRIBUTES);
    psa->lpSecurityDescriptor = psd;
    psa->bInheritHandle = FALSE;

errRtn:

    if (pInteractiveUserSid)
    {
        FreeSid(pInteractiveUserSid);
    }

    if (pLocalSystemSid)
    {
        FreeSid(pLocalSystemSid);
    }

    if (pAdminsSid)
    {
        FreeSid(pAdminsSid);
    }

    //
    // On failure, we clean the ACL up. On success, the caller cleans
    // it up after using it.
    //
    if (FALSE == bRetVal)
    {
        if (pAcl)
        {
            delete pAcl;
        }
    }
    else
    {
        *ppOutAcl = pAcl;
    }

    return bRetVal;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: SyncMgrExecCmdResetRegSecurity
//
//  PURPOSE: Makes sure HKLM..\SyncMgr key and all keys below
//              it can be accessed by all users.
//
//
//  COMMENTS:
//
//
//--------------------------------------------------------------------------------

const TCHAR szSyncMgrTopLevelKey[]  = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\SyncMgr");

HRESULT SyncMgrExecCmdResetRegSecurity(DWORD nCmdID, DWORD nCmdExecOpt)
{
HRESULT hr = E_UNEXPECTED;
SECURITY_ATTRIBUTES sa;
SECURITY_DESCRIPTOR sd;
PACL pAcl = NULL;

    if (!SyncMgrGetSecurityDescriptor(&sa,&sd,&pAcl))
    {
        SensPrintA(SENS_ERR, ("Unable to GetSecurity Attribs"));

        return E_FAIL;
    }


    // first try to set toplevel key
    if (SyncMgrSetRegKeySecurityEveryone(HKEY_LOCAL_MACHINE,szSyncMgrTopLevelKey,&sd))
    {
    HKEY hKeySyncMgr;

        // open the Key with REG_OPTION_OPEN_LINK so if someone places a symbolic
        // link under syncmgr we don't traverse it.
        if (ERROR_SUCCESS == (hr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,szSyncMgrTopLevelKey,
                              REG_OPTION_OPEN_LINK,KEY_READ | KEY_WRITE,&hKeySyncMgr)) )
        {
            SyncSetSubKeySecurityEveryone(hKeySyncMgr,&sd);
            RegCloseKey(hKeySyncMgr);
       }

    }

    if (pAcl)
    {
        delete pAcl;
    }

    return hr;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: SyncSetSubKeySecurity
//
//  PURPOSE: sets the security on all subkeys on the parent to everyone.
//
//
//  COMMENTS:
//
//
//--------------------------------------------------------------------------------

#define MAX_KEY_LENGTH  255

HRESULT SyncSetSubKeySecurityEveryone(HKEY hKeyParent,SECURITY_DESCRIPTOR *psd)
{
HRESULT hr;
HRESULT hrSubKey;
int iIndexCount;
DWORD  cbSubKey;
TCHAR  szSubKey[MAX_KEY_LENGTH];

    iIndexCount = 0;
    hr = ERROR_SUCCESS;
    hrSubKey = ERROR_SUCCESS;

    do
    {
    HKEY hKeySubKey;
    HRESULT hrCurSubKey;

        cbSubKey = MAX_KEY_LENGTH;
        hr = RegEnumKeyEx(hKeyParent,iIndexCount,szSubKey,&cbSubKey,NULL,NULL,NULL,NULL);

        if(hr != ERROR_SUCCESS)
        {
           hr = (ERROR_NO_MORE_ITEMS == hr) ? ERROR_SUCCESS : hr;
           break;
        }

        SyncMgrSetRegKeySecurityEveryone(hKeyParent,szSubKey,psd);

        // failure to open want to remember error but keep going through
        // remaining subkeys.
        if (ERROR_SUCCESS == (hrCurSubKey = RegOpenKeyEx (hKeyParent,szSubKey,REG_OPTION_OPEN_LINK ,KEY_READ | KEY_WRITE, &hKeySubKey)))
        {
            hrCurSubKey = SyncSetSubKeySecurityEveryone(hKeySubKey,psd);
            RegCloseKey(hKeySubKey);
        }

        if (ERROR_SUCCESS != hrCurSubKey)
        {
            hrSubKey = hrCurSubKey;
        }

        ++iIndexCount;

    } while (ERROR_SUCCESS == hr);


    return (ERROR_SUCCESS != hr) ? hr : hrSubKey;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: SyncMgrSetRegKeySecurityEveryone
//
//  PURPOSE: Gives Everyone all access to the specified RegKey.
//
//
//  COMMENTS:
//
//
//--------------------------------------------------------------------------------

BOOL SyncMgrSetRegKeySecurityEveryone(HKEY hKeyParent,LPCTSTR lpSubKey,SECURITY_DESCRIPTOR *psd)
{
BOOL fResult = FALSE;
HKEY hKey = NULL;

    // key must be openned with WRITE_DAC

    if (ERROR_SUCCESS != RegOpenKeyEx(hKeyParent,
        lpSubKey,
        REG_OPTION_OPEN_LINK, WRITE_DAC,&hKey) )
    {
        hKey = NULL;
    }

    if (hKey)
    {
        if (ERROR_SUCCESS == RegSetKeySecurity(hKey,
            (SECURITY_INFORMATION) DACL_SECURITY_INFORMATION,
            psd) )
        {
            fResult = TRUE;
        }

        RegCloseKey(hKey);
    }

    ASSERT(TRUE == fResult); // debugging lets find out when this fails.

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\test\senssink\cfacnet.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    cfacnet.cxx

Abstract:

    Implements the Class Factory for the SENS ISensNetwork Subscriber.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          11/17/1997         Start.

--*/


#include <common.hxx>
#include <ole2.h>
#include <sensevts.h>
#include "sinkcomn.hxx"
#include "cfacnet.hxx"
#include "cimpnet.hxx"
#include "cimplogn.hxx"


//
// Global counts for the number of objects in the server and the number of
// locks.
//

extern DWORD  gTid;
extern HANDLE ghEvent;

ULONG g_cObj    = 0L;
ULONG g_cLock   = 0L;


//
// Constructor and Destructor
//
CISensNetworkCF::CISensNetworkCF(
    void
    ) : m_cRef(1L)
{

}

CISensNetworkCF::~CISensNetworkCF(
    void
    )
{
    // Empty Destructor.
}



//
// QI
//
STDMETHODIMP
CISensNetworkCF::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    HRESULT hr = S_OK;

    *ppv = NULL; // To handle failure cases

    // IUnknown or IClassFactory
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory))
        {
        *ppv = (LPUNKNOWN) this;
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    if (NULL != *ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        }

    return hr;
}



//
// AddRef
//
STDMETHODIMP_(ULONG)
CISensNetworkCF::AddRef(
    void
    )
{
    return InterlockedIncrement((PLONG) &m_cRef);
}


//
// Release
//
STDMETHODIMP_(ULONG)
CISensNetworkCF::Release(
    void
    )
{
    ULONG cRefT;

    cRefT = InterlockedDecrement((PLONG) &m_cRef);

    if (0 == m_cRef)
        {
        // Invoke the callback function.
        ObjectDestroyed();
        delete this;
        }

    return cRefT;
}



//
// CreateInstance
//
STDMETHODIMP
CISensNetworkCF::CreateInstance(
    LPUNKNOWN pUnkOuter,
    REFIID riid,
    LPVOID *ppvObj
    )
{
    LPCIMPISENSNETWORK pObjNet;
    HRESULT hr;

    DebugTraceGuid("CISensNetworkCF::CreateInstance()", riid);

    hr = E_OUTOFMEMORY;
    *ppvObj = NULL;
    pObjNet = NULL;

    //
    // Return the appropriate interface pointer.
    //
    if (IsEqualIID(riid, IID_ISensNetwork) ||
        IsEqualIID(riid, IID_IUnknown))
        {
        SensPrintA(SENS_INFO, ("\t| ClassFactory::CreateInstance(ISensNetwork)\n"));
        pObjNet = new CImpISensNetwork(ObjectDestroyed);
        if (NULL != pObjNet)
            {
            hr = pObjNet->QueryInterface(riid, ppvObj);
            SensPrintA(SENS_INFO, ("\t| QI on CImpISensNetwork returned 0x%x\n", hr));
            }
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    if (NULL != *ppvObj)
        {
        InterlockedIncrement((PLONG) &g_cObj);
        }

    SensPrintA(SENS_INFO, ("\t| Returning 0x%x from CF:CreateInstance\n", hr));

    return hr;
}



//
// LockServer
//
STDMETHODIMP
CISensNetworkCF::LockServer(
    BOOL fLock
    )
{
    if (fLock)
        {
        InterlockedIncrement((PLONG) &g_cLock);
        }
    else
        {
        InterlockedDecrement((PLONG) &g_cLock);

        InterlockedIncrement((PLONG) &g_cObj);
        ObjectDestroyed(); // this does a --g_cObj
        }

    return NOERROR;
}



//
// ObjectDestroyed
//
void FAR PASCAL
ObjectDestroyed(
    void
    )
{
    BOOL bSuccess = FALSE;

    if ((0 == InterlockedDecrement((PLONG) &g_cObj)) &&
        (0 == g_cLock))
        {
        SensPrintA(SENS_INFO, ("\t| ObjectDestroyed: g_cObj = %d and g_cLock = %d\n", g_cObj, g_cLock));
        SensPrintA(SENS_INFO, ("\t| Shutting down the app. Calling SetEvent()\n"));

        Sleep(2000);
        SetEvent(ghEvent);

        /*
        SensPrintA(SENS_INFO, ("\t| Shutting down the app. Calling PostThreadMessage()\n"));

        bSuccess = PostThreadMessage(gTid, WM_QUIT, 0, 0);
        if (bSuccess == FALSE)
            {
            SensPrintA(SENS_ERR, ("\t| PostThreadMessage(Tid = %d) failed!\n"));
            }
        */
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\test\senssink\cimplogn.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    cimplogn.cxx

Abstract:

    The core implementation for the ISensLogon interface.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          11/17/1997         Start.

--*/


#include <common.hxx>
#include <ole2.h>
#include <oleauto.h>
#include <tchar.h>
#include "sinkcomn.hxx"
#include "cimplogn.hxx"
#include "sensevts.h"


extern ITypeInfo *gpITypeInfoLogon;
extern ITypeInfo *gpITypeInfoLogon2;




//
// Constructors and Destructors
//
CImpISensLogon::CImpISensLogon(
    void
    ) : m_cRef(0L), m_pfnDestroy(NULL)
{

}

CImpISensLogon::CImpISensLogon(
    LPFNDESTROYED pfnDestroy
    ) : m_cRef(0L), m_pfnDestroy(pfnDestroy)
{

}

CImpISensLogon::~CImpISensLogon(
    void
    )
{
    // Empty destructor
}



//
// Standard QueryInterface
//
STDMETHODIMP
CImpISensLogon::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    DebugTraceGuid("CImpISensLogon::QueryInterface()", riid);

    HRESULT hr = S_OK;

    *ppv = NULL; // To handle failure cases

    // IUnknown
    if (IsEqualIID(riid, IID_IUnknown))
        {
        *ppv = (LPUNKNOWN) this;
        }
    else
    // IDispatch
    if (IsEqualIID(riid, IID_IDispatch))
        {
        *ppv = (IDispatch *) this;
        }
    else
    // ISensLogon
    if (IsEqualIID(riid, IID_ISensLogon))
        {
        *ppv = (ISensLogon *) this;
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    if (NULL != *ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        }

    return hr;
}



//
// Standard AddRef and Release
//
STDMETHODIMP_(ULONG)
CImpISensLogon::AddRef(
    void
    )
{
    return InterlockedIncrement((PLONG) &m_cRef);
}

STDMETHODIMP_(ULONG)
CImpISensLogon::Release(
    void
    )
{
    ULONG cRefT;

    cRefT = InterlockedDecrement((PLONG) &m_cRef);

    if (0 == m_cRef)
        {
        // Invoke the callback function.
        if (NULL != m_pfnDestroy)
            {
            (*m_pfnDestroy)();
            }
        delete this;
        }

    return cRefT;
}



//
// IDispatch member function implementations.
//




STDMETHODIMP
CImpISensLogon::GetTypeInfoCount(
    UINT *pCountITypeInfo
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensLogon::GetTypeInfoCount() called.\n")));
    // We implement GetTypeInfo, so return 1.
    *pCountITypeInfo = 1;

    return NOERROR;

}


STDMETHODIMP
CImpISensLogon::GetTypeInfo(
    UINT iTypeInfo,
    LCID lcid,
    ITypeInfo **ppITypeInfo
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensLogon::GetTypeInfo() called.\n")));
    *ppITypeInfo = NULL;

    if (iTypeInfo != 0)
        {
        return DISP_E_BADINDEX;
        }

    // Call AddRef and return the pointer.
    gpITypeInfoLogon->AddRef();

    *ppITypeInfo = gpITypeInfoLogon;

    return S_OK;
}

STDMETHODIMP
CImpISensLogon::GetIDsOfNames(
    REFIID riid,
    LPOLESTR *arrNames,
    UINT cNames,
    LCID lcid,
    DISPID *arrDispIDs)
{
    HRESULT hr;

    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensLogon::GetIDsOfNames() called.\n")));

    if (riid != IID_NULL)
        {
        return DISP_E_UNKNOWNINTERFACE;
        }

    hr = gpITypeInfoLogon->GetIDsOfNames(
                               arrNames,
                               cNames,
                               arrDispIDs
                               );

    return hr;
}

STDMETHODIMP
CImpISensLogon::Invoke(
    DISPID dispID,
    REFIID riid,
    LCID lcid,
    WORD wFlags,
    DISPPARAMS *pDispParams,
    VARIANT *pvarResult,
    EXCEPINFO *pExecpInfo,
    UINT *puArgErr
    )
{
    HRESULT hr;

    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensLogon::Invoke() called.\n")));

    if (riid != IID_NULL)
        {
        return DISP_E_UNKNOWNINTERFACE;
        }

    hr = gpITypeInfoLogon->Invoke(
                               (IDispatch*) this,
                               dispID,
                               wFlags,
                               pDispParams,
                               pvarResult,
                               pExecpInfo,
                               puArgErr
                               );
    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensLogon::Invoke() returned 0x%x\n"), hr));

    return hr;
}


STDMETHODIMP
CImpISensLogon::Logon(
    BSTR bstrUserName
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensLogon::Logon() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrUserName - %s\n"), bstrUserName));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    return S_OK;
}


STDMETHODIMP
CImpISensLogon::Logoff(
    BSTR bstrUserName
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensLogon::Logoff() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrUserName - %s\n"), bstrUserName));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    return S_OK;
}

STDMETHODIMP
CImpISensLogon::StartShell(
    BSTR bstrUserName
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensLogon::StartShell() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrUserName - %s\n"), bstrUserName));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    return S_OK;
}

STDMETHODIMP
CImpISensLogon::DisplayLock(
    BSTR bstrUserName
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensLogon::DisplayLock() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrUserName - %s\n"), bstrUserName));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    return S_OK;
}

STDMETHODIMP
CImpISensLogon::DisplayUnlock(
    BSTR bstrUserName
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensLogon::DisplayUnlock() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrUserName - %s\n"), bstrUserName));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    return S_OK;
}

STDMETHODIMP
CImpISensLogon::StartScreenSaver(
    BSTR bstrUserName
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensLogon::StartScreenSaver() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrUserName - %s\n"), bstrUserName));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    return S_OK;
}

STDMETHODIMP
CImpISensLogon::StopScreenSaver(
    BSTR bstrUserName
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensLogon::StopScreenSaver() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrUserName - %s\n"), bstrUserName));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    return S_OK;
}



//
// ISensLogon2 Implementation
//



//
// Constructors and Destructors
//
CImpISensLogon2::CImpISensLogon2(
    void
    ) : m_cRef(0L), m_pfnDestroy(NULL)
{

}

CImpISensLogon2::CImpISensLogon2(
    LPFNDESTROYED pfnDestroy
    ) : m_cRef(0L), m_pfnDestroy(pfnDestroy)
{

}

CImpISensLogon2::~CImpISensLogon2(
    void
    )
{
    // Empty destructor
}



//
// Standard QueryInterface
//
STDMETHODIMP
CImpISensLogon2::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    DebugTraceGuid("CImpISensLogon2::QueryInterface()", riid);

    HRESULT hr = S_OK;

    *ppv = NULL; // To handle failure cases

    // IUnknown
    if (IsEqualIID(riid, IID_IUnknown))
        {
        *ppv = (LPUNKNOWN) this;
        }
    else
    // IDispatch
    if (IsEqualIID(riid, IID_IDispatch))
        {
        *ppv = (IDispatch *) this;
        }
    else
    // ISensLogon
    if (IsEqualIID(riid, IID_ISensLogon2))
        {
        *ppv = (ISensLogon2 *) this;
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    if (NULL != *ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        }

    return hr;
}



//
// Standard AddRef and Release
//
STDMETHODIMP_(ULONG)
CImpISensLogon2::AddRef(
    void
    )
{
    return InterlockedIncrement((PLONG) &m_cRef);
}

STDMETHODIMP_(ULONG)
CImpISensLogon2::Release(
    void
    )
{
    ULONG cRefT;

    cRefT = InterlockedDecrement((PLONG) &m_cRef);

    if (0 == m_cRef)
        {
        // Invoke the callback function.
        if (NULL != m_pfnDestroy)
            {
            (*m_pfnDestroy)();
            }
        delete this;
        }

    return cRefT;
}



//
// IDispatch member function implementations.
//




STDMETHODIMP
CImpISensLogon2::GetTypeInfoCount(
    UINT *pCountITypeInfo
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensLogon2::GetTypeInfoCount() called.\n")));
    // We implement GetTypeInfo, so return 1.
    *pCountITypeInfo = 1;

    return NOERROR;

}


STDMETHODIMP
CImpISensLogon2::GetTypeInfo(
    UINT iTypeInfo,
    LCID lcid,
    ITypeInfo **ppITypeInfo
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensLogon2::GetTypeInfo() called.\n")));
    *ppITypeInfo = NULL;

    if (iTypeInfo != 0)
        {
        return DISP_E_BADINDEX;
        }

    // Call AddRef and return the pointer.
    gpITypeInfoLogon2->AddRef();

    *ppITypeInfo = gpITypeInfoLogon2;

    return S_OK;
}

STDMETHODIMP
CImpISensLogon2::GetIDsOfNames(
    REFIID riid,
    LPOLESTR *arrNames,
    UINT cNames,
    LCID lcid,
    DISPID *arrDispIDs)
{
    HRESULT hr;

    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensLogon2::GetIDsOfNames() called.\n")));

    if (riid != IID_NULL)
        {
        return DISP_E_UNKNOWNINTERFACE;
        }

    hr = gpITypeInfoLogon2->GetIDsOfNames(
                               arrNames,
                               cNames,
                               arrDispIDs
                               );

    return hr;
}

STDMETHODIMP
CImpISensLogon2::Invoke(
    DISPID dispID,
    REFIID riid,
    LCID lcid,
    WORD wFlags,
    DISPPARAMS *pDispParams,
    VARIANT *pvarResult,
    EXCEPINFO *pExecpInfo,
    UINT *puArgErr
    )
{
    HRESULT hr;

    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensLogon2::Invoke() called.\n")));

    if (riid != IID_NULL)
        {
        return DISP_E_UNKNOWNINTERFACE;
        }

    hr = gpITypeInfoLogon2->Invoke(
                               (IDispatch*) this,
                               dispID,
                               wFlags,
                               pDispParams,
                               pvarResult,
                               pExecpInfo,
                               puArgErr
                               );
    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensLogon2::Invoke() returned 0x%x\n"), hr));

    return hr;
}


STDMETHODIMP
CImpISensLogon2::Logon(
    BSTR bstrUserName,
    DWORD dwSessionId
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensLogon2::Logon() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrUserName - %s\n"), bstrUserName));
    SensPrint(SENS_INFO, (SENS_STRING("    dwSessionId - %d\n"), dwSessionId));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    return S_OK;
}


STDMETHODIMP
CImpISensLogon2::Logoff(
    BSTR bstrUserName,
    DWORD dwSessionId
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensLogon2::Logoff() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrUserName - %s\n"), bstrUserName));
    SensPrint(SENS_INFO, (SENS_STRING("    dwSessionId - %d\n"), dwSessionId));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    return S_OK;
}

STDMETHODIMP
CImpISensLogon2::PostShell(
    BSTR bstrUserName,
    DWORD dwSessionId
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensLogon2::PostShell() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrUserName - %s\n"), bstrUserName));
    SensPrint(SENS_INFO, (SENS_STRING("    dwSessionId - %d\n"), dwSessionId));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    return S_OK;
}

STDMETHODIMP
CImpISensLogon2::SessionDisconnect(
    BSTR bstrUserName,
    DWORD dwSessionId
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensLogon2::SessionDisconnect() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrUserName - %s\n"), bstrUserName));
    SensPrint(SENS_INFO, (SENS_STRING("    dwSessionId - %d\n"), dwSessionId));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    return S_OK;
}

STDMETHODIMP
CImpISensLogon2::SessionReconnect(
    BSTR bstrUserName,
    DWORD dwSessionId
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensLogon2::SessionReconnect() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrUserName - %s\n"), bstrUserName));
    SensPrint(SENS_INFO, (SENS_STRING("    dwSessionId - %d\n"), dwSessionId));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\test\senssink\cimpnet.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    cimpnet.cxx

Abstract:

    The core implementation for the ISensNetwork interface.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          11/17/1997         Start.

--*/


#include <common.hxx>
#include <ole2.h>
#include <oleauto.h>
#include <tchar.h>
#include "sinkcomn.hxx"
#include "sensevts.h"
#include "cimpnet.hxx"


extern ITypeInfo *gpITypeInfoNetwork;




//
// Constructors and Destructors
//
CImpISensNetwork::CImpISensNetwork(
    void
    ) : m_cRef(0L), m_pfnDestroy(NULL)
{

}

CImpISensNetwork::CImpISensNetwork(
    LPFNDESTROYED pfnDestroy
    ) : m_cRef(0L), m_pfnDestroy(pfnDestroy)
{

}

CImpISensNetwork::~CImpISensNetwork(
    void
    )
{
    // Empty destructor
}



//
// Standard QueryInterface
//
STDMETHODIMP
CImpISensNetwork::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    DebugTraceGuid("CImpISensNetwork::QueryInterface()", riid);
    
    HRESULT hr = S_OK;

    *ppv = NULL; // To handle failure cases

    // IUnknown
    if (IsEqualIID(riid, IID_IUnknown))
        {
        *ppv = (LPUNKNOWN) this;
        }
    else
    // IDispatch
    if (IsEqualIID(riid, IID_IDispatch))
        {
        *ppv = (IDispatch *) this;
        }
    else
    // ISensNetwork
    if (IsEqualIID(riid, IID_ISensNetwork))
        {
        *ppv = (ISensNetwork *) this;
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    if (NULL != *ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        }

    return hr;
}



//
// Standard AddRef and Release
//
STDMETHODIMP_(ULONG)
CImpISensNetwork::AddRef(
    void
    )
{
    return InterlockedIncrement((PLONG) &m_cRef);
}

STDMETHODIMP_(ULONG)
CImpISensNetwork::Release(
    void
    )
{
    ULONG cRefT;

    cRefT = InterlockedDecrement((PLONG) &m_cRef);

    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensNetwork::Release(m_cRef = %d) called.\n"), m_cRef));

    if (0 == m_cRef)
        {
        // Invoke the callback function.
        if (NULL != m_pfnDestroy)
            {
            (*m_pfnDestroy)();
            }
        delete this;
        }

    return cRefT;
}



//
// IDispatch member function implementations.
//

STDMETHODIMP
CImpISensNetwork::GetTypeInfoCount(
    UINT *pCountITypeInfo
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensNetwork::GetTypeInfoCount() called.\n")));
    // We implement GetTypeInfo, so return 1.
    *pCountITypeInfo = 1;

    return NOERROR;

}


STDMETHODIMP
CImpISensNetwork::GetTypeInfo(
    UINT iTypeInfo,
    LCID lcid,
    ITypeInfo **ppITypeInfo
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensNetwork::GetTypeInfo() called.\n")));
    *ppITypeInfo = NULL;

    if (iTypeInfo != 0)
        {
        return DISP_E_BADINDEX;
        }

    // Call AddRef and return the pointer.
    gpITypeInfoNetwork->AddRef();

    *ppITypeInfo = gpITypeInfoNetwork;

    return S_OK;
}

STDMETHODIMP
CImpISensNetwork::GetIDsOfNames(
    REFIID riid,
    LPOLESTR *arrNames,
    UINT cNames,
    LCID lcid,
    DISPID *arrDispIDs)
{
    HRESULT hr;

    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensNetwork::GetIDsOfNames() called.\n")));

    if (riid != IID_NULL)
        {
        return DISP_E_UNKNOWNINTERFACE;
        }

    hr = gpITypeInfoNetwork->GetIDsOfNames(
                                 arrNames,
                                 cNames,
                                 arrDispIDs
                                 );

    return hr;
}

STDMETHODIMP
CImpISensNetwork::Invoke(
    DISPID dispID,
    REFIID riid,
    LCID lcid,
    WORD wFlags,
    DISPPARAMS *pDispParams,
    VARIANT *pvarResult,
    EXCEPINFO *pExecpInfo,
    UINT *puArgErr
    )
{
    HRESULT hr;

    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensNetwork::Invoke() called.\n")));

    if (riid != IID_NULL)
        {
        return DISP_E_UNKNOWNINTERFACE;
        }

    hr = gpITypeInfoNetwork->Invoke(
                                (IDispatch*) this,
                                dispID,
                                wFlags,
                                pDispParams,
                                pvarResult,
                                pExecpInfo,
                                puArgErr
                                );
    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensNetwork::Invoke() returned 0x%x\n"), hr));

    return hr;
}




//
// IDispatch member function implementations.
//

STDMETHODIMP
CImpISensNetwork::ConnectionMade(
    BSTR bstrConnection,
    ULONG ulType,
    LPSENS_QOCINFO lpQOCInfo
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensNetwork::ConnectionMade() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("   bstrConnection - %s\n"), bstrConnection));
    SensPrint(SENS_INFO, (SENS_STRING("            ulType - 0x%x\n"), ulType));
    SensPrint(SENS_INFO, (SENS_STRING("         lpQOCInfo - 0x%x\n"), lpQOCInfo));
    SensPrint(SENS_INFO, (SENS_STRING("             o dwSize     - 0x%x\n"), lpQOCInfo->dwSize));
    SensPrint(SENS_INFO, (SENS_STRING("             o dwFlags    - 0x%x\n"), lpQOCInfo->dwFlags));
    SensPrint(SENS_INFO, (SENS_STRING("             o dwInSpeed  - %d bits/sec.\n"), lpQOCInfo->dwInSpeed));
    SensPrint(SENS_INFO, (SENS_STRING("             o dwOutSpeed - %d bits/sec.\n"), lpQOCInfo->dwOutSpeed));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    return S_OK;
}

STDMETHODIMP
CImpISensNetwork::ConnectionMadeNoQOCInfo(
    BSTR bstrConnection,
    ULONG ulType
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensNetwork::ConnectionMadeNoQOCInfo() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("   bstrConnection - %s\n"), bstrConnection));
    SensPrint(SENS_INFO, (SENS_STRING("            ulType - 0x%x\n"), ulType));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    return S_OK;
}

STDMETHODIMP
CImpISensNetwork::ConnectionLost(
    BSTR bstrConnection,
    ULONG ulType
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensNetwork::ConnectionLost() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("   bstrConnection - %s\n"), bstrConnection));
    SensPrint(SENS_INFO, (SENS_STRING("            ulType - 0x%x\n"), ulType));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    return S_OK;
}

STDMETHODIMP
CImpISensNetwork::DestinationReachable(
    BSTR bstrDestination,
    BSTR bstrConnection,
    ULONG ulType,
    LPSENS_QOCINFO lpQOCInfo
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensNetwork::DestinationReachable() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("   bstrDestination - %s\n"), bstrDestination));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrConnection - %s\n"), bstrConnection));
    SensPrint(SENS_INFO, (SENS_STRING("            ulType - 0x%x\n"), ulType));
    SensPrint(SENS_INFO, (SENS_STRING("         lpQOCInfo - 0x%x\n"), lpQOCInfo));
    SensPrint(SENS_INFO, (SENS_STRING("             o dwSize     - 0x%x\n"), lpQOCInfo->dwSize));
    SensPrint(SENS_INFO, (SENS_STRING("             o dwFlags    - 0x%x\n"), lpQOCInfo->dwFlags));
    SensPrint(SENS_INFO, (SENS_STRING("             o dwInSpeed  - %d bits/sec.\n"), lpQOCInfo->dwInSpeed));
    SensPrint(SENS_INFO, (SENS_STRING("             o dwOutSpeed - %d bits/sec.\n"), lpQOCInfo->dwOutSpeed));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    return S_OK;
}

STDMETHODIMP
CImpISensNetwork::DestinationReachableNoQOCInfo(
    BSTR bstrDestination,
    BSTR bstrConnection,
    ULONG ulType
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensNetwork::DestinationReachableNoQOCInfo() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("   bstrDestination - %s\n"), bstrDestination));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrConnection - %s\n"), bstrConnection));
    SensPrint(SENS_INFO, (SENS_STRING("            ulType - 0x%x\n"), ulType));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\test\senssink\cimpsens.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    cimpsens.cxx

Abstract:

    The core implementation for the ISensNetwork interface.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          11/17/1997         Start.

--*/



#include <common.hxx>
#include <ole2.h>
#include <oleauto.h>
#include "sinkcomn.hxx"
#include "cimpsens.hxx"
#include "sensevts.h"


extern ITypeInfo *gpITypeInfo;




//
// Constructors and Destructors
//
CImpISensNetwork::CImpISensNetwork(
    void
    ) : m_cRef(0L), m_pfnDestroy(NULL)
{

}

CImpISensNetwork::CImpISensNetwork(
    LPFNDESTROYED pfnDestroy
    ) : m_cRef(0L), m_pfnDestroy(pfnDestroy)
{

}

CImpISensNetwork::~CImpISensNetwork(
    void
    )
{
    // Empty destructor
}



//
// Standard QueryInterface
//
STDMETHODIMP
CImpISensNetwork::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    DebugTraceGuid("CImpISensNetwork::QueryInterface()", riid);
    
    HRESULT hr = S_OK;

    *ppv = NULL; // To handle failure cases

    // IUnknown
    if (IsEqualIID(riid, IID_IUnknown))
        {
        *ppv = (LPUNKNOWN) this;
        }
    else
    // IDispatch
    if (IsEqualIID(riid, IID_IDispatch))
        {
        *ppv = (IDispatch *) this;
        }
    else
    // ISensNetwork
    if (IsEqualIID(riid, IID_ISensNetwork))
        {
        *ppv = (ISensNetwork *) this;
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    if (NULL != *ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        }

    return hr;
}



//
// Standard AddRef and Release
//
STDMETHODIMP_(ULONG)
CImpISensNetwork::AddRef(
    void
    )
{
    return InterlockedIncrement((PLONG) &m_cRef);
}

STDMETHODIMP_(ULONG)
CImpISensNetwork::Release(
    void
    )
{
    ULONG cRefT;

    cRefT = InterlockedDecrement((PLONG) &m_cRef);

    if (0 == m_cRef)
        {
        // Invoke the callback function.
        if (NULL != m_pfnDestroy)
            {
            (*m_pfnDestroy)();
            }
        delete this;
        }

    return cRefT;
}



//
// IDispatch member function implementations.
//




STDMETHODIMP
CImpISensNetwork::GetTypeInfoCount(
    UINT *pCountITypeInfo
    )
{
    SensPrintA(SENS_INFO, ("\t| CImpISensNetwork::GetTypeInfoCount() called.\n"));
    // We implement GetTypeInfo, so return 1.
    *pCountITypeInfo = 1;

    return NOERROR;

}


STDMETHODIMP
CImpISensNetwork::GetTypeInfo(
    UINT iTypeInfo,
    LCID lcid,
    ITypeInfo **ppITypeInfo
    )
{
    SensPrintA(SENS_INFO, ("\t| CImpISensNetwork::GetTypeInfo() called.\n"));
    *ppITypeInfo = NULL;

    if (iTypeInfo != 0)
        {
        return DISP_E_BADINDEX;
        }

    // Call AddRef and return the pointer.
    gpITypeInfo->AddRef();

    *ppITypeInfo = gpITypeInfo;

    return S_OK;
}

STDMETHODIMP
CImpISensNetwork::GetIDsOfNames(
    REFIID riid,
    LPOLESTR *arrNames,
    UINT cNames,
    LCID lcid,
    DISPID *arrDispIDs)
{
    HRESULT hr;

    SensPrintA(SENS_INFO, ("\t| CImpISensNetwork::GetIDsOfNames() called.\n"));

    if (riid != IID_NULL)
        {
        return DISP_E_UNKNOWNINTERFACE;
        }

    hr = gpITypeInfo->GetIDsOfNames(
                          arrNames,
                          cNames,
                          arrDispIDs
                          );

    return hr;
}

STDMETHODIMP
CImpISensNetwork::Invoke(
    DISPID dispID,
    REFIID riid,
    LCID lcid,
    WORD wFlags,
    DISPPARAMS *pDispParams,
    VARIANT *pvarResult,
    EXCEPINFO *pExecpInfo,
    UINT *puArgErr
    )
{
    HRESULT hr;

    SensPrintA(SENS_INFO, ("\t| CImpISensNetwork::Invoke() called.\n"));

    if (riid != IID_NULL)
        {
        return DISP_E_UNKNOWNINTERFACE;
        }

    hr = gpITypeInfo->Invoke(
                          (IDispatch*) this,
                          dispID,
                          wFlags,
                          pDispParams,
                          pvarResult,
                          pExecpInfo,
                          puArgErr
                          );

    return hr;
}

STDMETHODIMP_(void)
CImpISensNetwork::ConnectionMade(
    BSTR bstrConnection,
    ULONG ulType,
    SENS_QOCINFO QOCInfo
    )
{
    SensPrintA(SENS_INFO, ("---------------------------------------------------------\n"));
    SensPrintA(SENS_INFO, ("CImpISensNetwork::ConnectionMade() called\n\n"));
    SensPrintW(SENS_INFO, (L"    bstrConnection - %s\n", bstrConnection));
    SensPrintA(SENS_INFO, ("            ulType - 0x%x\n", ulType));
    SensPrintA(SENS_INFO, ("           QOCInfo - 0x%x\n", QOCInfo));
    SensPrintA(SENS_INFO, ("---------------------------------------------------------\n"));
}

STDMETHODIMP_(void)
CImpISensNetwork::ConnectionMadeNoQOCInfo(
    BSTR bstrConnection,
    ULONG ulType
    )
{
    SensPrintA(SENS_INFO, ("---------------------------------------------------------\n"));
    SensPrintA(SENS_INFO, ("CImpISensNetwork::ConnectionMadeNoQOCInfo() called\n\n"));
    SensPrintW(SENS_INFO, (L"    bstrConnection - %s\n", bstrConnection));
    SensPrintA(SENS_INFO, ("            ulType - 0x%x\n", ulType));
    SensPrintA(SENS_INFO, ("---------------------------------------------------------\n"));
}

STDMETHODIMP_(void)
CImpISensNetwork::ConnectionLost(
    BSTR bstrConnection,
    ULONG ulType
    )
{
    SensPrintA(SENS_INFO, ("---------------------------------------------------------\n"));
    SensPrintA(SENS_INFO, ("CImpISensNetwork::ConnectionLost() called\n\n"));
    SensPrintW(SENS_INFO, (L"    bstrConnection - %s\n", bstrConnection));
    SensPrintA(SENS_INFO, ("            ulType - 0x%x\n", ulType));
    SensPrintA(SENS_INFO, ("---------------------------------------------------------\n"));
}

STDMETHODIMP_(void)
CImpISensNetwork::BeforeDisconnect(
    BSTR bstrConnection,
    ULONG ulType
    )
{
    SensPrintA(SENS_INFO, ("---------------------------------------------------------\n"));
    SensPrintA(SENS_INFO, ("CImpISensNetwork::BeforeDisconnect() called\n\n"));
    SensPrintW(SENS_INFO, (L"    bstrConnection - %s\n", bstrConnection));
    SensPrintA(SENS_INFO, ("            ulType - 0x%x\n", ulType));
    SensPrintA(SENS_INFO, ("---------------------------------------------------------\n"));
}

STDMETHODIMP_(void)
CImpISensNetwork::DestinationReachable(
    BSTR bstrDestination,
    BSTR bstrConnection,
    ULONG ulType,
    SENS_QOCINFO QOCInfo
    )
{
    SensPrintA(SENS_INFO, ("---------------------------------------------------------\n"));
    SensPrintA(SENS_INFO, ("CImpISensNetwork::DestinationReachable() called\n\n"));
    SensPrintW(SENS_INFO, (L"   bstrDestination - %s\n", bstrDestination));
    SensPrintW(SENS_INFO, (L"    bstrConnection - %s\n", bstrConnection));
    SensPrintA(SENS_INFO, ("            ulType - 0x%x\n", ulType));
    SensPrintA(SENS_INFO, ("           QOCInfo - 0x%x\n", QOCInfo));
    SensPrintA(SENS_INFO, ("---------------------------------------------------------\n"));
}

STDMETHODIMP_(void)
CImpISensNetwork::DestinationReachableNoQOCInfo(
    BSTR bstrDestination,
    BSTR bstrConnection,
    ULONG ulType
    )
{
    SensPrintA(SENS_INFO, ("---------------------------------------------------------\n"));
    SensPrintA(SENS_INFO, ("CImpISensNetwork::DestinationReachableNoQOCInfo() called\n\n"));
    SensPrintW(SENS_INFO, (L"   bstrDestination - %s\n", bstrDestination));
    SensPrintW(SENS_INFO, (L"    bstrConnection - %s\n", bstrConnection));
    SensPrintA(SENS_INFO, ("            ulType - 0x%x\n", ulType));
    SensPrintA(SENS_INFO, ("---------------------------------------------------------\n"));
}

STDMETHODIMP_(void)
CImpISensNetwork::FooFunc(
    BSTR bstrConnection
    )
{
    SensPrintA(SENS_INFO, ("---------------------------------------------------------\n"));
    SensPrintA(SENS_INFO, ("CImpISensNetwork::FooFunc() called\n\n"));
    SensPrintW(SENS_INFO, (L"    bstrConnection - %s\n", bstrConnection));
    SensPrintA(SENS_INFO, ("---------------------------------------------------------\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\test\senssink\cimppwr.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    cimppwr.cxx

Abstract:

    The core implementation for the ISensOnNow interface.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          11/17/1997         Start.

--*/


#include <common.hxx>
#include <ole2.h>
#include <oleauto.h>
#include <tchar.h>
#include "sinkcomn.hxx"
#include "cimppwr.hxx"
#include "sensevts.h"


extern ITypeInfo *gpITypeInfoLogon;




//
// Constructors and Destructors
//
CImpISensOnNow::CImpISensOnNow(
    void
    ) : m_cRef(0L), m_pfnDestroy(NULL)
{

}

CImpISensOnNow::CImpISensOnNow(
    LPFNDESTROYED pfnDestroy
    ) : m_cRef(0L), m_pfnDestroy(pfnDestroy)
{

}

CImpISensOnNow::~CImpISensOnNow(
    void
    )
{
    // Empty destructor
}



//
// Standard QueryInterface
//
STDMETHODIMP
CImpISensOnNow::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    DebugTraceGuid("CImpISensOnNow::QueryInterface()", riid);
    
    HRESULT hr = S_OK;

    *ppv = NULL; // To handle failure cases

    // IUnknown
    if (IsEqualIID(riid, IID_IUnknown))
        {
        *ppv = (LPUNKNOWN) this;
        }
    else
    // IDispatch
    if (IsEqualIID(riid, IID_IDispatch))
        {
        *ppv = (IDispatch *) this;
        }
    else
    // ISensOnNow
    if (IsEqualIID(riid, IID_ISensOnNow))
        {
        *ppv = (ISensOnNow *) this;
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    if (NULL != *ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        }

    return hr;
}



//
// Standard AddRef and Release
//
STDMETHODIMP_(ULONG)
CImpISensOnNow::AddRef(
    void
    )
{
    return InterlockedIncrement((PLONG) &m_cRef);
}

STDMETHODIMP_(ULONG)
CImpISensOnNow::Release(
    void
    )
{
    ULONG cRefT;

    cRefT = InterlockedDecrement((PLONG) &m_cRef);

    if (0 == m_cRef)
        {
        // Invoke the callback function.
        if (NULL != m_pfnDestroy)
            {
            (*m_pfnDestroy)();
            }
        delete this;
        }

    return cRefT;
}



//
// IDispatch member function implementations.
//




STDMETHODIMP
CImpISensOnNow::GetTypeInfoCount(
    UINT *pCountITypeInfo
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensOnNow::GetTypeInfoCount() called.\n")));
    // We implement GetTypeInfo, so return 1.
    *pCountITypeInfo = 1;

    return NOERROR;

}


STDMETHODIMP
CImpISensOnNow::GetTypeInfo(
    UINT iTypeInfo,
    LCID lcid,
    ITypeInfo **ppITypeInfo
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensOnNow::GetTypeInfo() called.\n")));
    *ppITypeInfo = NULL;

    if (iTypeInfo != 0)
        {
        return DISP_E_BADINDEX;
        }

    // Call AddRef and return the pointer.
    gpITypeInfoLogon->AddRef();

    *ppITypeInfo = gpITypeInfoLogon;

    return S_OK;
}

STDMETHODIMP
CImpISensOnNow::GetIDsOfNames(
    REFIID riid,
    LPOLESTR *arrNames,
    UINT cNames,
    LCID lcid,
    DISPID *arrDispIDs)
{
    HRESULT hr;

    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensOnNow::GetIDsOfNames() called.\n")));

    if (riid != IID_NULL)
        {
        return DISP_E_UNKNOWNINTERFACE;
        }

    hr = gpITypeInfoLogon->GetIDsOfNames(
                               arrNames,
                               cNames,
                               arrDispIDs
                               );

    return hr;
}

STDMETHODIMP
CImpISensOnNow::Invoke(
    DISPID dispID,
    REFIID riid,
    LCID lcid,
    WORD wFlags,
    DISPPARAMS *pDispParams,
    VARIANT *pvarResult,
    EXCEPINFO *pExecpInfo,
    UINT *puArgErr
    )
{
    HRESULT hr;

    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensOnNow::Invoke() called.\n")));

    if (riid != IID_NULL)
        {
        return DISP_E_UNKNOWNINTERFACE;
        }

    hr = gpITypeInfoLogon->Invoke(
                               (IDispatch*) this,
                               dispID,
                               wFlags,
                               pDispParams,
                               pvarResult,
                               pExecpInfo,
                               puArgErr
                               );
    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensOnNow::Invoke() returned 0x%x\n"), hr));

    return hr;
}


STDMETHODIMP
CImpISensOnNow::OnACPower(
    void
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensOnNow::OnACPower() called\n")));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    return S_OK;
}


STDMETHODIMP
CImpISensOnNow::OnBatteryPower(
    DWORD dwBatteryLifePercent
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensOnNow::OnBatteryPower() called\n\n")));
    SensPrint(SENS_INFO, (SENS_STRING("    dwBatteryLifePercent - %d\n"), dwBatteryLifePercent));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    return S_OK;
}

STDMETHODIMP
CImpISensOnNow::BatteryLow(
    DWORD dwBatteryLifePercent
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensOnNow::BatteryLow() called\n\n")));
    SensPrint(SENS_INFO, (SENS_STRING("    dwBatteryLifePercent - %d\n"), dwBatteryLifePercent));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\test\senssink\senssink.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    senssink.cxx

Abstract:

    Main entry point for the Sample SENS Subscriber.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          11/17/1997         Start.

--*/



// Define this once and only once per exe.
#define INITGUIDS

#include <common.hxx>
#include <objbase.h>
#include <windows.h>
#include <ole2ver.h>
#include <initguid.h>
#include <eventsys.h>
#include <sensevts.h>
#include <sens.h>
#include "sinkcomn.hxx"
#include "sinkguid.hxx"
#include "senssink.hxx"
#include "cfacnet.hxx"
#include "cfaclogn.hxx"
#include "cfacpwr.hxx"

#define PER_USER 1
#if PER_USER
#define REG_ROOT HKEY_CLASSES_ROOT
#else
#define REG_ROOT HKEY_CLASSES_ROOT
#endif


#if defined(SENS_NT4)
#define SENS_TLB        SENS_BSTR("SENS.EXE")
#else  // SENS_NT4
#define SENS_TLB        SENS_BSTR("SENS.DLL")
#endif // SENS_NT4

#define SUBSCRIBER      SENS_STRING("SENS_SUBSCRIBER: ")
#define MAX_QUERY_SIZE  512
#define MAJOR_VER       1
#define MINOR_VER       0
#define DEFAULT_LCID    0x0


//
// Globals
//
IEventSystem    *gpIEventSystem;
ITypeInfo       *gpITypeInfoNetwork;
ITypeInfo       *gpITypeInfoLogon;
ITypeInfo       *gpITypeInfoLogon2;
ITypeInfo       *gpITypeInfoOnNow;
DWORD           gTid;
HANDLE          ghEvent;


#if defined(SENS_CHICAGO)

#ifdef DBG
DWORD           gdwDebugOutputLevel;
#endif // DBG

#endif // SENS_CHICAGO



int __cdecl
main(
    int argc,
    char ** argv
    )
{
    HRESULT hr;
    DWORD   dwVer;
    DWORD   dwRegCO;
    DWORD   dwWaitStatus;
    BOOL    fInitialized;
    BOOL    bUnregister;
    BOOL    bSetupPhase;
    MSG     msg;
    LPCLASSFACTORY pNetCF;
    LPCLASSFACTORY pLogonCF;
    LPCLASSFACTORY pLogon2CF;
    LPCLASSFACTORY pPowerCF;
    ITypeLib *pITypeLib;

    hr = S_OK;
    dwRegCO = 0x0;
    bUnregister = FALSE;
    bSetupPhase = FALSE;
    fInitialized = FALSE;
    pNetCF = NULL;
    pLogonCF = NULL;
    pLogon2CF = NULL;
    pPowerCF = NULL;
    gpIEventSystem = NULL;
    pITypeLib = NULL;
    gpITypeInfoNetwork = NULL;
    gpITypeInfoLogon = NULL;
    gpITypeInfoLogon2 = NULL;
    gpITypeInfoOnNow = NULL;

    dwVer = CoBuildVersion();
    if (rmm != HIWORD(dwVer))
        {
        SensPrint(SENS_ERR, (SUBSCRIBER SENS_STRING("CoBuildVersion() returned incompatible version.\n")));
        return -1;
        }

    if (FAILED(hr = CoInitializeEx(NULL, COINIT_MULTITHREADED)))
        {
        SensPrint(SENS_ERR, (SUBSCRIBER SENS_STRING("CoInitializeEx() returned 0x%x.\n"), hr));
        goto Cleanup;
        }
    fInitialized = TRUE;

    //
    // Check the command-line args
    //
    if (   ((argc == 2) && ((argv[1][0] != '-') && (argv[1][0] != '/')))
        || (argc > 2))
        {
        Usage();
        return (-1);
        }

    if (argc == 2)
        {
        switch (argv[1][1])
            {
            case 'i':
            case 'I':
                bSetupPhase = TRUE;
                bUnregister = FALSE;
                break;

            case 'u':
            case 'U':
                bSetupPhase = TRUE;
                bUnregister = TRUE;
                break;

            case 'e':
            case 'E':
                // SCM calls me with /Embedding flag
                break;

            default:
                Usage();
                return (-1);
            }
        }

    if (bSetupPhase == TRUE)
        {
        hr = RegisterWithES(bUnregister);
        if (FAILED(hr))
            {
            goto Cleanup;
            }

        // Network Subscriber
        hr = RegisterSubscriberCLSID(
                 CLSID_SensTestSubscriberNetwork,
                 TEST_SUBSCRIBER_NAME_NETWORK,
                 bUnregister
                 );
        if (FAILED(hr))
            {
            SensPrint(SENS_ERR, (SUBSCRIBER SENS_STRING("Failed to %sregister Test Subscriber Network CLSID")
                      SENS_STRING(" - hr = <%x>\n"), bUnregister ? SENS_STRING("un") : SENS_STRING(""), hr));
            }
        else
            {
            SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("%segistered Test Subscriber Network CLSID.\n"),
                      bUnregister ? SENS_STRING("Unr") : SENS_STRING("R")));
            }

        // Logon Subscriber
        hr = RegisterSubscriberCLSID(
                 CLSID_SensTestSubscriberLogon,
                 TEST_SUBSCRIBER_NAME_LOGON,
                 bUnregister
                 );
        if (FAILED(hr))
            {
            SensPrint(SENS_ERR, (SUBSCRIBER SENS_STRING("Failed to %sregister Test Subscriber Logon CLSID")
                      SENS_STRING(" - hr = <%x>\n"), bUnregister ? SENS_STRING("un") : SENS_STRING(""), hr));
            }
        else
            {
            SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("%segistered Test Subscriber Logon CLSID.\n"),
                      bUnregister ? SENS_STRING("Unr") : SENS_STRING("R")));
            }

        // Logon2 Subscriber
        hr = RegisterSubscriberCLSID(
                 CLSID_SensTestSubscriberLogon2,
                 TEST_SUBSCRIBER_NAME_LOGON2,
                 bUnregister
                 );
        if (FAILED(hr))
            {
            SensPrint(SENS_ERR, (SUBSCRIBER SENS_STRING("Failed to %sregister Test Subscriber Logon2 CLSID")
                      SENS_STRING(" - hr = <%x>\n"), bUnregister ? SENS_STRING("un") : SENS_STRING(""), hr));
            }
        else
            {
            SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("%segistered Test Subscriber Logon2 CLSID.\n"),
                      bUnregister ? SENS_STRING("Unr") : SENS_STRING("R")));
            }

        // Power Subscriber
        hr = RegisterSubscriberCLSID(
                 CLSID_SensTestSubscriberOnNow,
                 TEST_SUBSCRIBER_NAME_POWER,
                 bUnregister
                 );
        if (FAILED(hr))
            {
            SensPrint(SENS_ERR, (SUBSCRIBER SENS_STRING("Failed to %sregister Test Subscriber Power CLSID")
                      SENS_STRING(" - hr = <%x>\n"), bUnregister ? SENS_STRING("un") : SENS_STRING(""), hr));
            }
        else
            {
            SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("%segistered Test Subscriber Power CLSID.\n"),
                      bUnregister ? SENS_STRING("Unr") : SENS_STRING("R")));
            }
        goto Cleanup;
        }


    //
    // Get the ITypeInfo pointer.
    //
    hr = LoadRegTypeLib(
             LIBID_SensEvents,
             MAJOR_VER,
             MINOR_VER,
             DEFAULT_LCID,
             &pITypeLib
             );
    SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("LoadRegTypeLib() returned 0x%x\n"), hr));

    if (FAILED(hr))
        {
        hr = LoadTypeLib(
                 SENS_TLB,
                 &pITypeLib
                 );
        SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("LoadTypeLib() returned 0x%x\n"), hr));

        if (FAILED(hr))
            {
            SensPrint(SENS_ERR, (SUBSCRIBER SENS_STRING("Exiting...\n")));
            goto Cleanup;
            }
        }

    // Get type information for the ISensNetwork interface.
    hr = pITypeLib->GetTypeInfoOfGuid(
             IID_ISensNetwork,
             &gpITypeInfoNetwork
             );
    SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("ITypeLib::GetTypeInfoOfGuid(ISensNetwork) returned 0x%x\n"), hr));
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SUBSCRIBER SENS_STRING("Exiting...\n")));
        goto Cleanup;
        }

    // Get type information for the ISensLogon interface.
    hr = pITypeLib->GetTypeInfoOfGuid(
             IID_ISensLogon,
             &gpITypeInfoLogon
             );
    SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("ITypeLib::GetTypeInfoOfGuid(ISensLogon) returned 0x%x\n"), hr));
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SUBSCRIBER SENS_STRING("Exiting...\n")));
        goto Cleanup;
        }

    // Get type information for the ISensLogon2 interface.
    hr = pITypeLib->GetTypeInfoOfGuid(
             IID_ISensLogon2,
             &gpITypeInfoLogon2
             );
    SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("ITypeLib::GetTypeInfoOfGuid(ISensLogon2) returned 0x%x\n"), hr));
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SUBSCRIBER SENS_STRING("Exiting...\n")));
        goto Cleanup;
        }

    // Get type information for the ISensOnNow interface.
    hr = pITypeLib->GetTypeInfoOfGuid(
             IID_ISensOnNow,
             &gpITypeInfoOnNow
             );
    SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("ITypeLib::GetTypeInfoOfGuid(ISensOnNow) returned 0x%x\n"), hr));
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SUBSCRIBER SENS_STRING("Exiting...\n")));
        goto Cleanup;
        }

    //
    // Create the event
    //
    ghEvent = CreateEvent(
                  NULL,  // Security Attributes
                  FALSE, // bManualReset
                  FALSE, // Initial state
                  SENS_STRING("SENS Test Subscriber Quit Event")
                  );
    if (ghEvent == NULL)
        {
        SensPrint(SENS_ERR, (SUBSCRIBER  SENS_STRING("CreateEvent() failed.\n")));
        goto Cleanup;
        }

    //
    // Create the Network ClassFactory and register it with COM.
    //

    pNetCF = new CISensNetworkCF;
    if (NULL == pNetCF)
        {
        goto Cleanup;
        }
    pNetCF->AddRef(); // Because we hold on to it.
    SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("ClassFactory created successfully.\n")));

    // Register the CLSID
    hr = CoRegisterClassObject(
             CLSID_SensTestSubscriberNetwork,
             (LPUNKNOWN) pNetCF,
             CLSCTX_LOCAL_SERVER,
             REGCLS_MULTIPLEUSE,
             &dwRegCO
             );

    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SUBSCRIBER SENS_STRING("CoRegisterClassObject(Network) returned 0x%x.\n"), hr));
        }
    else
        {
        SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("Successfully registered the ISensNetwork Class Factory.\n")));
        }

    //
    // Create the Logon ClassFactory and register it with COM.
    //

    pLogonCF = new CISensLogonCF;
    if (NULL == pLogonCF)
        {
        goto Cleanup;
        }
    pLogonCF->AddRef(); // Because we hold on to it.
    SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("ClassFactory created successfully.\n")));

    hr = CoRegisterClassObject(
             CLSID_SensTestSubscriberLogon,
             (LPUNKNOWN) pLogonCF,
             CLSCTX_LOCAL_SERVER,
             REGCLS_MULTIPLEUSE,
             &dwRegCO
             );

    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SUBSCRIBER SENS_STRING("CoRegisterClassObject(Logon) returned 0x%x.\n"), hr));
        }
    else
        {
        SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("Successfully registered the ISensLogon Class Factory.\n")));
        }

    //
    // Create the Logon2 ClassFactory and register it with COM.
    //

    pLogon2CF = new CISensLogon2CF;
    if (NULL == pLogon2CF)
        {
        goto Cleanup;
        }
    pLogon2CF->AddRef(); // Because we hold on to it.
    SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("ClassFactory created successfully.\n")));

    hr = CoRegisterClassObject(
             CLSID_SensTestSubscriberLogon2,
             (LPUNKNOWN) pLogon2CF,
             CLSCTX_LOCAL_SERVER,
             REGCLS_MULTIPLEUSE,
             &dwRegCO
             );

    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SUBSCRIBER SENS_STRING("CoRegisterClassObject(Logon2) returned 0x%x.\n"), hr));
        }
    else
        {
        SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("Successfully registered the ISensLogon2 Class Factory.\n")));
        }

    //
    // Create the Power ClassFactory and register it with COM.
    //

    pPowerCF = new CISensOnNowCF;
    if (NULL == pPowerCF)
        {
        goto Cleanup;
        }
    pPowerCF->AddRef(); // Because we hold on to it.
    SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("ClassFactory created successfully.\n")));

    hr = CoRegisterClassObject(
             CLSID_SensTestSubscriberOnNow,
             (LPUNKNOWN) pPowerCF,
             CLSCTX_LOCAL_SERVER,
             REGCLS_MULTIPLEUSE,
             &dwRegCO
             );

    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SUBSCRIBER SENS_STRING("CoRegisterClassObject(Power) returned 0x%x.\n"), hr));
        }
    else
        {
        SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("Successfully registered the ISensOnNow Class Factory.\n")));
        }

    //
    // Wait to quit.
    //
    dwWaitStatus = WaitForSingleObject(ghEvent, INFINITE);
    SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("WaitForSingleObject returned %d\n"), dwWaitStatus));


//
// Cleanup
//
Cleanup:

    if (   (0L != dwRegCO)
        && (bSetupPhase == TRUE)
        && (bUnregister == TRUE))
        {
        CoRevokeClassObject(dwRegCO);
        SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("CoRevokeClassObject() returned 0x%x.\n"), hr));
        }

    if (bSetupPhase == TRUE)
        {
        SensPrint(SENS_INFO, (SENS_STRING("\n") SUBSCRIBER SENS_STRING("Sens Test Subscriber Configuration %s.\n"),
                  FAILED(hr) ? SENS_STRING("failed") : SENS_STRING("successful")));
        }

    if (NULL != pNetCF)
        {
        pNetCF->Release();
        }
    if (NULL != pLogonCF)
        {
        pLogonCF->Release();
        }
    if (NULL != pLogon2CF)
        {
        pLogon2CF->Release();
        }
    if (NULL != pPowerCF)
        {
        pPowerCF->Release();
        }
    if (NULL != pITypeLib)
        {
        pITypeLib->Release();
        }
    if (NULL != gpITypeInfoNetwork)
        {
        gpITypeInfoNetwork->Release();
        }
    if (NULL != gpITypeInfoLogon)
        {
        gpITypeInfoLogon->Release();
        }
    if (NULL != gpITypeInfoLogon2)
        {
        gpITypeInfoLogon2->Release();
        }
    if (NULL != gpITypeInfoOnNow)
        {
        gpITypeInfoOnNow->Release();
        }

    if (fInitialized)
        {
        CoUninitialize();
        }

    return 0;
}


HRESULT
RegisterWithES(
    BOOL bUnregister
    )
{
    HRESULT      hr;

    hr = S_OK;

    //
    // Instantiate the Event System
    //
    hr = CoCreateInstance(
             CLSID_CEventSystem,
             NULL,
             CLSCTX_SERVER,
             IID_IEventSystem,
             (LPVOID *) &gpIEventSystem
             );
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SUBSCRIBER SENS_STRING("Failed to create CEventSystem, HRESULT=%x\n"), hr));
        goto Cleanup;
        }
    SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("Successfully created CEventSystem\n")));

#if 0
    //
    // Test to see if we can get the MachineName
    //
    BSTR bstrMachineName;

    hr = gpIEventQuery->get_MachineName(&bstrMachineName);

    if (SUCCEEDED(hr))
        SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("Configuring Test Subscriber on %s...\n"), bstrMachineName));
    else
        SensPrint(SENS_ERR, (SUBSCRIBER SENS_STRING("get_MachineName failed, hr = %x\n"), hr));
#endif // 0

    //
    // Register my Subscriber's subscriptions with SENS.
    //
    hr = RegisterSubscriptions(bUnregister);
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SUBSCRIBER SENS_STRING("Failed to %sregister SensSink Subscriptions")
                  SENS_STRING(" - hr = <%x>\n"), bUnregister ? SENS_STRING("un") : SENS_STRING(""), hr));
        goto Cleanup;
        }
    SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("%segistered SensSink Subscriptions.\n"),
              bUnregister ? SENS_STRING("Unr") : SENS_STRING("R")));

Cleanup:
    //
    // Cleanup
    //
    if (gpIEventSystem)
        {
        gpIEventSystem->Release();
        }

    return hr;
}



HRESULT
RegisterSubscriptions(
    BOOL bUnregister
    )
{
    int                 i;
    int                 errorIndex;
    HRESULT             hr;
    LPOLESTR            strGuid;
    LPOLESTR            strSubscriptionID;
    WCHAR               szQuery[MAX_QUERY_SIZE];
    BSTR                bstrEventClassID;
    BSTR                bstrInterfaceID;
    BSTR                bstrSubscriberCLSID;
    BSTR                bstrPublisherID;
    BSTR                bstrSubscriptionID;
    BSTR                bstrSubscriptionName;
    BSTR                bstrMethodName;
    BSTR                bstrPropertyName;
    BSTR                bstrPropertyValue;
    ULONG               ulPropertyValue;
    VARIANT             variantPropertyValue;
    BSTR                bstrPROGID_EventSubscription;
    IEventSubscription  *pIEventSubscription;

    hr = S_OK;
    strGuid = NULL;
    errorIndex = 0;
    strSubscriptionID = NULL;
    bstrEventClassID = NULL;
    bstrInterfaceID = NULL;
    bstrSubscriberCLSID = NULL;
    bstrPublisherID = NULL;
    bstrSubscriptionID = NULL;
    bstrSubscriptionName = NULL;
    bstrMethodName = NULL;
    bstrPropertyName = NULL;
    bstrPropertyValue = NULL;
    ulPropertyValue = 0x0;
    bstrPROGID_EventSubscription = NULL;
    pIEventSubscription = NULL;

    //
    // Build a Subscriber
    //
    AllocateBstrFromGuid(bstrPublisherID, SENSGUID_PUBLISHER);
    AllocateBstrFromString(bstrPROGID_EventSubscription, PROGID_EventSubscription);

    for (i = 0; i < TEST_SUBSCRIPTIONS_COUNT; i++)
        {
        if (bUnregister)
            {
            // Form the query
            StringCbCopy(szQuery, sizeof(szQuery), SENS_BSTR("SubscriptionID="));
            AllocateStrFromGuid(strSubscriptionID, *(gTestSubscriptions[i].pSubscriptionID));
            StringCbCat(szQuery, sizeof(szQuery), strSubscriptionID);

            hr = gpIEventSystem->Remove(
                                     PROGID_EventSubscription,
                                     szQuery,
                                     &errorIndex
                                     );
            FreeStr(strSubscriptionID);

            if (FAILED(hr))
                {
                SensPrint(SENS_ERR, (SUBSCRIBER SENS_STRING("RegisterSubscriptions(%d) failed to unregister")
                          SENS_STRING(" - hr = <%x>\n"), i, hr));
                goto Cleanup;
                }

            continue;
            }

        // Get a new IEventSubscription object to play with.
        hr = CoCreateInstance(
                 CLSID_CEventSubscription,
                 NULL,
                 CLSCTX_SERVER,
                 IID_IEventSubscription,
                 (LPVOID *) &pIEventSubscription
                 );
        if (FAILED(hr))
            {
            SensPrint(SENS_ERR, (SUBSCRIBER SENS_STRING("RegisterSubscriptions(%d) failed to create ")
                      SENS_STRING("IEventSubscriptions - hr = <%x>\n"), i, hr));
            goto Cleanup;
            }

        AllocateBstrFromGuid(bstrSubscriptionID, *(gTestSubscriptions[i].pSubscriptionID));
        hr = pIEventSubscription->put_SubscriptionID(bstrSubscriptionID);
        ASSERT(SUCCEEDED(hr));

        AllocateBstrFromGuid(bstrSubscriberCLSID, *(gTestSubscriptions[i].pSubscriberCLSID));
        hr = pIEventSubscription->put_SubscriberCLSID(bstrSubscriberCLSID);
        ASSERT(SUCCEEDED(hr));

        hr = pIEventSubscription->put_PublisherID(bstrPublisherID);
        ASSERT(SUCCEEDED(hr));

        hr = pIEventSubscription->put_SubscriptionID(bstrSubscriptionID);
        ASSERT(SUCCEEDED(hr));

        AllocateBstrFromString(bstrSubscriptionName, gTestSubscriptions[i].strSubscriptionName);
        hr = pIEventSubscription->put_SubscriptionName(bstrSubscriptionName);
        ASSERT(SUCCEEDED(hr));

        AllocateBstrFromString(bstrMethodName, gTestSubscriptions[i].strMethodName);
        hr = pIEventSubscription->put_MethodName(bstrMethodName);
        ASSERT(SUCCEEDED(hr));

        AllocateBstrFromGuid(bstrEventClassID, *(gTestSubscriptions[i].pEventClassID));
        hr = pIEventSubscription->put_EventClassID(bstrEventClassID);
        ASSERT(SUCCEEDED(hr));

        AllocateBstrFromGuid(bstrInterfaceID, *(gTestSubscriptions[i].pInterfaceID));
        hr = pIEventSubscription->put_InterfaceID(bstrInterfaceID);
        ASSERT(SUCCEEDED(hr));

#if     1
        hr = pIEventSubscription->put_PerUser(TRUE);
        ASSERT(SUCCEEDED(hr));
#endif

        if (wcscmp(gTestSubscriptions[i].strMethodName, SENS_BSTR("ConnectionMadeNoQOCInfo")) == 0)
            {
            AllocateBstrFromString(bstrPropertyName, SENS_BSTR("ulConnectionMadeTypeNoQOC"));
            ulPropertyValue = CONNECTION_LAN;
            InitializeDwordVariant(&variantPropertyValue, ulPropertyValue);
            hr = pIEventSubscription->PutPublisherProperty(
                                          bstrPropertyName,
                                          &variantPropertyValue
                                          );
            ASSERT(SUCCEEDED(hr));
            SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("PutPublisherProperty(WAN/LAN) returned 0x%x\n"), hr));
            FreeBstr(bstrPropertyName);
            ulPropertyValue = 0x0;
            }
        else
        if (   (wcscmp(gTestSubscriptions[i].strMethodName, SENS_BSTR("DestinationReachable")) == 0)
            || (wcscmp(gTestSubscriptions[i].strMethodName, SENS_BSTR("DestinationReachableNoQOCInfo")) == 0))
            {
            // Set the DestinationName for which we want to be notified for.
            AllocateBstrFromString(bstrPropertyName, gTestSubscriptions[i].strPropertyMethodName);
            AllocateBstrFromString(bstrPropertyValue, gTestSubscriptions[i].strPropertyMethodNameValue);
            InitializeBstrVariant(&variantPropertyValue, bstrPropertyValue);
            hr = pIEventSubscription->PutPublisherProperty(
                                          bstrPropertyName,
                                          &variantPropertyValue
                                          );
            ASSERT(SUCCEEDED(hr));
            SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("PutPublisherProperty(DestinationName) returned 0x%x\n"), hr));
            FreeBstr(bstrPropertyName);
            FreeBstr(bstrPropertyValue);
            }

        FreeBstr(bstrSubscriptionID);
        FreeBstr(bstrSubscriberCLSID);
        FreeBstr(bstrEventClassID);
        FreeBstr(bstrInterfaceID);
        FreeBstr(bstrSubscriptionName);
        FreeBstr(bstrMethodName);

        hr = gpIEventSystem->Store(bstrPROGID_EventSubscription, pIEventSubscription);
        if (FAILED(hr))
            {
            SensPrint(SENS_ERR, (SUBSCRIBER SENS_STRING("RegisterSubscriptions(%d) failed to commit")
                      SENS_STRING(" - hr = <%x>\n"), i, hr));
            goto Cleanup;
            }

        pIEventSubscription->Release();

        pIEventSubscription = NULL;
        } // for loop

Cleanup:
    //
    // Cleanup
    //
    if (pIEventSubscription)
        {
        pIEventSubscription->Release();
        }

    FreeBstr(bstrPublisherID);
    FreeBstr(bstrSubscriberCLSID);
    FreeStr(strGuid);

    return (hr);
}




HRESULT
RegisterSubscriberCLSID(
    REFIID clsid,
    TCHAR* strSubscriberName,
    BOOL bUnregister
    )
/*++

Routine Description:

    Register/Unregister the CLSID of the Test subscriber.

Arguments:

    clsid - CLSID of the Subscriber.

    strSubscriberName - Name of the Subscriber.

    bUnregister - If TRUE, then unregister all subscriptions of SENS Test subscriber.

Return Value:

    S_OK, if successful

    hr, otherwise

--*/
{
    HRESULT hr;
    HMODULE hModule;
    HKEY appidKey = 0;
    HKEY clsidKey = 0;
    HKEY serverKey = 0;
    TCHAR szModule[MAX_PATH+1];
    WCHAR *szCLSID = 0;
    WCHAR *szLIBID = 0;
    TCHAR *szCLSID_t = 0;
    TCHAR *szLIBID_t = 0;
    TCHAR *szFriendlyName = strSubscriberName;

    hr = S_OK;

    // Convert the CLSID into a TCHAR.
    hr = StringFromCLSID(clsid, &szCLSID);
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    if (bUnregister == FALSE)
        {
        hr = StringFromCLSID(LIBID_SensEvents, &szLIBID);
        if (FAILED(hr))
            {
            goto Cleanup;
            }

        hModule = GetModuleHandle(0);

        // Get Subscriber location.
        const size_t moduleBufSize = sizeof szModule / sizeof szModule[0];
        DWORD dwResult = GetModuleFileName(hModule, szModule, moduleBufSize);
        if (dwResult == 0)
            {
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            goto Cleanup;
            }
        }

    //
    // Convert UNICODE strings into ANSI, if necessary
    //
#if !defined(SENS_CHICAGO)

    szCLSID_t = szCLSID;
    szLIBID_t = szLIBID;

#else // SENS_CHICAGO

    szCLSID_t = SensUnicodeStringToAnsi(szCLSID);
    szLIBID_t = SensUnicodeStringToAnsi(szLIBID);
    if (   (NULL == szCLSID_t)
        || (NULL == szLIBID_t))
        {
        goto Cleanup;
        }

#endif // SENS_CHICAGO


    // Build the key CLSID\\{clsid}
    TCHAR clsidKeyName[sizeof "CLSID\\{12345678-1234-1234-1234-123456789012}"];

    StringCbCopy(clsidKeyName, sizeof(clsidKeyName), SENS_STRING("CLSID\\"));
    StringCbCat(clsidKeyName, sizeof(clsidKeyName), szCLSID_t);

    // Build the key AppID\\{clsid}
    TCHAR appidKeyName[sizeof "AppID\\{12345678-1234-1234-1234-123456789012}"];
    StringCbCopy(appidKeyName, sizeof(appidKeyName), SENS_STRING("AppID\\"));
    StringCbCat(appidKeyName, sizeof(appidKeyName), szCLSID_t);

    if (bUnregister)
        {
        hr = RecursiveDeleteKey(HKEY_CLASSES_ROOT, clsidKeyName);
        if (FAILED(hr))
            {
            goto Cleanup;
            }

        hr = RecursiveDeleteKey(HKEY_CLASSES_ROOT, appidKeyName);

        goto Cleanup;
        }

    // Create the CLSID\\{clsid} key
    hr = CreateKey(
             HKEY_CLASSES_ROOT,
             clsidKeyName,
             szFriendlyName,
             &clsidKey
             );
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    //
    // Under the CLSID\\{clsid} key, create a named value
    //          AppID = {clsid}
    hr = CreateNamedValue(clsidKey, SENS_STRING("AppID"), szCLSID_t);
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    //
    // Create the appropriate server key beneath the clsid key.
    // For servers, this is CLSID\\{clsid}\\LocalServer32.
    // In both cases, the default value is the module path name.
    //
    hr = CreateKey(
             clsidKey,
             SENS_STRING("LocalServer32"),
             szModule,
             &serverKey
             );
    if (FAILED(hr))
        {
        goto Cleanup;
        }
    RegCloseKey(serverKey);

    //
    // Create CLSID\\{clsid}\\TypeLib subkey with a default value of
    // the LIBID of the TypeLib
    //
    hr = CreateKey(
             clsidKey,
             SENS_STRING("TypeLib"),
             szLIBID_t,
             &serverKey
             );
    if (FAILED(hr))
        {
        goto Cleanup;
        }
    RegCloseKey(serverKey);


    // We're finished with the CLSID\\{clsid} key
    RegCloseKey(clsidKey);

    // Register APPID.
    hr = CreateKey(
             HKEY_CLASSES_ROOT,
             appidKeyName,
             szFriendlyName,
             &appidKey
             );
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    // Under AppId\{clsid} key, create a named value [RunAs = "Interactive User"]
    hr = CreateNamedValue(appidKey, SENS_STRING("RunAs"), SENS_STRING("Interactive User"));
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    RegCloseKey(appidKey);


Cleanup:
    //
    // Cleanup
    //
    CoTaskMemFree(szCLSID);
    CoTaskMemFree(szLIBID);

#if defined(SENS_CHICAGO)

    if (szCLSID_t != NULL)
        {
        delete szCLSID_t;
        }
    if (szLIBID_t != NULL)
        {
        delete szLIBID_t;
        }

#endif // SENS_CHICAGO

    return hr;
}




HRESULT
CreateKey(
    HKEY hParentKey,
    const TCHAR* KeyName,
    const TCHAR* defaultValue,
    HKEY* hKey
    )
/*++

Routine Description:

    Create a key (with an optional default value).  The handle to the key is
    returned as an [out] parameter.  If NULL is passed as the key parameter,
    the key is created in the registry, then closed.

Arguments:

    hParentKey - Handle to the parent Key.

    KeyName - Name of the key to create.

    defaultValue - The default value for the key to create.

    hKey - OUT Handle to key that was created.

Return Value:

    S_OK, if successful

    hr, otherwise

--*/
{
    HKEY hTempKey;
    LONG lResult;

    hTempKey = NULL;

    lResult = RegCreateKeyEx(
                  hParentKey,               // Handle to open key
                  KeyName,                  // Subkey name
                  0,                        // Reserved
                  NULL,                     // Class string
                  REG_OPTION_NON_VOLATILE,  // Options Flag
                  KEY_ALL_ACCESS,           // Desired Security access
                  NULL,                     // Pointer to Security Attributes structure
                  &hTempKey,                // Handle of the opened/created key
                  NULL                      // Disposition value
                  );

    if (lResult != ERROR_SUCCESS)
        {
        return HRESULT_FROM_WIN32(lResult);
        }

    // Set the default value for the key
    if (defaultValue != NULL)
        {
        lResult = RegSetValueEx(
                      hTempKey,             // Key to set Value for.
                      NULL,                 // Value to set
                      0,                    // Reserved
                      REG_SZ,               // Value Type
                      (BYTE*) defaultValue, // Address of Value data
                      sizeof(TCHAR) * (_tcslen(defaultValue)+1) // Size of Value
                      );

        if (lResult != ERROR_SUCCESS)
            {
            RegCloseKey(hTempKey);
            return HRESULT_FROM_WIN32(lResult);
            }
        }

    if (hKey == NULL)
        {
        RegCloseKey(hTempKey);
        }
    else
        {
        *hKey = hTempKey;
        }

    return S_OK;
}




HRESULT
CreateNamedValue(
    HKEY hKey,
    const TCHAR* title,
    const TCHAR* value
    )
/*++

Routine Description:

    Create a named value under a key

Arguments:

    hKey - Handle to the parent Key.

    title - Name of the Value to create.

    value - The data for the Value under the Key.

Return Value:

    S_OK, if successful

    hr, otherwise

--*/
{
    HRESULT hr;
    LONG lResult;

    hr = S_OK;

    lResult = RegSetValueEx(
                  hKey,             // Key to set Value for.
                  title,            // Value to set
                  0,                // Reserved
                  REG_SZ,           // Value Type
                  (BYTE*) value,    // Address of Value data
                  sizeof(TCHAR) * (_tcslen(value)+1) // Size of Value
                  );

    if (lResult != ERROR_SUCCESS)
        {
        hr = HRESULT_FROM_WIN32(lResult);
        }

    return hr;
}




HRESULT
RecursiveDeleteKey(
    HKEY hKeyParent,
    const TCHAR* lpszKeyChild
    )
/*++

Routine Description:

    Delete a key and all of its descendents.

Arguments:

    hKeyParent - Handle to the parent Key.

    lpszKeyChild - The data for the Value under the Key.

Return Value:

    S_OK, if successful

    hr, otherwise

--*/
{
    HKEY hKeyChild;
    LONG lResult;

    //
    // Open the child.
    //
    lResult = RegOpenKeyEx(
                  hKeyParent,       // Handle to the Parent
                  lpszKeyChild,     // Name of the child key
                  0,                // Reserved
                  KEY_ALL_ACCESS,   // Security Access Mask
                  &hKeyChild        // Handle to the opened key
                  );

    if (lResult != ERROR_SUCCESS)
        {
        return HRESULT_FROM_WIN32(lResult);
        }

    //
    // Enumerate all of the decendents of this child.
    //
    FILETIME time;
    TCHAR szBuffer[MAX_PATH+1];
    const DWORD bufSize = sizeof szBuffer / sizeof szBuffer[0];
    DWORD dwSize = bufSize;

    while (TRUE)
        {
        lResult = RegEnumKeyEx(
                      hKeyChild,    // Handle of the key to enumerate
                      0,            // Index of the subkey to retrieve
                      szBuffer,     // OUT Name of the subkey
                      &dwSize,      // OUT Size of the buffer for name of subkey
                      NULL,         // Reserved
                      NULL,         // OUT Class of the enumerated subkey
                      NULL,         // OUT Size of the class of the subkey
                      &time         // OUT Last time the subkey was written to
                      );

        if (lResult != ERROR_SUCCESS)
            {
            break;
            }

        // Delete the decendents of this child.
        lResult = RecursiveDeleteKey(hKeyChild, szBuffer);
        if (lResult != ERROR_SUCCESS)
            {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild);
            return HRESULT_FROM_WIN32(lResult);
            }

        dwSize = bufSize;
        } // while

    // Close the child.
    RegCloseKey(hKeyChild);

    // Delete this child.
    lResult = RegDeleteKey(hKeyParent, lpszKeyChild);

    return HRESULT_FROM_WIN32(lResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\test\senssink\subcli\subcli.cxx ===
/*++

Copyright (C) 1997-998 Microsoft Corporation

Module Name:

    subcli.cxx

Abstract:

    Code to test the COM/OleAutomation aspect of the Test Subscriber for
    SENS.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          1/17/1998         Start.

--*/


#include <stdio.h>
#include <ole2.h>
#include <oleauto.h>
#include <initguid.h>
#include <sens.h>
#include <sensevts.h>
#include "sinkguid.hxx"


#define SENS_SERVICE    L"SENS.DLL"
#define MAJOR_VER       1
#define MINOR_VER       0
#define DEFAULT_LCID    0x0


int
main(
    int argc,
    char **argv
    )
{
    HRESULT hr = S_OK;
    IDispatch *pIDispatchNetwork = NULL;
    IDispatch *pIDispatchLogon = NULL;
    ISensNetwork *pISensNetwork = NULL;
    ISensNetwork *pISensLogon = NULL;
    ITypeLib *pITypeLib = NULL;
    ITypeInfo *pITypeInfo = NULL;
    IRecordInfo * pIRecordInfo = NULL;

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    printf("CoInitializeEx() returned 0x%x\n", hr);
    if (FAILED(hr))
        {
        goto Cleanup;
        }


    DISPID dispIDNetwork;
    DISPID dispIDLogon;
    OLECHAR *name;

    printf("--------------------------------------------------------------\n");
    hr = CoCreateInstance(
             CLSID_SensTestSubscriberNetwork,
             NULL,
             CLSCTX_LOCAL_SERVER,
             IID_IDispatch,
             (LPVOID *) &pIDispatchNetwork
             );

    printf("CoCreateInstance(IDispatchNetwork) returned 0x%x\n", hr);
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    hr = CoCreateInstance(
             CLSID_SensTestSubscriberNetwork,
             NULL,
             CLSCTX_LOCAL_SERVER,
             IID_ISensNetwork,
             (LPVOID *) &pISensNetwork
             );

    printf("CoCreateInstance(ISensNetwork) returned 0x%x\n", hr);
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    /*
    printf("Calling pISensNetwork->ConnectionMade()\n");
    pISensNetwork->ConnectionMade(
              SysAllocString(L"A dummy Connection Name"),
              0x1234,
              NULL
              );
    printf("Calling pISensNetwork->ConnectionMade() - DONE.\n");
    */

    name = L"FooFunc";
    hr = pIDispatchNetwork->GetIDsOfNames(
                                IID_NULL,
                                &name,
                                1,
                                GetUserDefaultLCID(),
                                &dispIDNetwork
                                );
    printf("GetIDsOfNames(FooFunc) returned 0x%x, dispID = %d\n",
           hr, dispIDNetwork);
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    //
    // Call Invoke on a function with 1 argument.
    //
    BSTR bstrTemp;
    VARIANTARG varg;

    bstrTemp = SysAllocString(L"A Dummy Connection Name");
    VariantInit(&varg);
    varg.vt = VT_BSTR;
    varg.bstrVal = bstrTemp;

    // Fill in the DISPPARAMS structure.
    DISPPARAMS param;
    param.cArgs = 1;
    param.rgvarg = &varg;
    param.cNamedArgs = 0;
    param.rgdispidNamedArgs = NULL;

    hr = pIDispatchNetwork->Invoke(
                                dispIDNetwork,
                                IID_NULL,
                                GetUserDefaultLCID(),
                                DISPATCH_METHOD,
                                &param,
                                NULL,
                                NULL,
                                NULL
                                );
    printf("Invoke(FooFunc) returned 0x%x\n", hr);
    SysFreeString(bstrTemp);
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    printf("--------------------------------------------------------------\n");
    name = L"ConnectionMadeNoQOCInfo";
    hr = pIDispatchNetwork->GetIDsOfNames(
                                IID_NULL,
                                &name,
                                1,
                                GetUserDefaultLCID(),
                                &dispIDNetwork
                                );
    printf("GetIDsOfNames(ConnectionMadeNoQOCInfo) returned 0x%x, dispID = %d\n",
           hr, dispIDNetwork);
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    //
    // Call Invoke on a function with 2 arguments (parameters in reverse order).
    //
    VARIANTARG vargarr[2];

    bstrTemp = SysAllocString(L"A Dummy Connection Name");
    VariantInit(&vargarr[1]);
    vargarr[1].vt = VT_BSTR;
    vargarr[1].bstrVal = bstrTemp;

    VariantInit(&vargarr[0]);
    vargarr[0].vt = VT_UI4;
    vargarr[0].ulVal = 0x00000001;

    // Fill in the DISPPARAMS structure.
    param.cArgs = 2;
    param.rgvarg = vargarr;
    param.cNamedArgs = 0;
    param.rgdispidNamedArgs = NULL;

    hr = pIDispatchNetwork->Invoke(
                                dispIDNetwork,
                                IID_NULL,
                                GetUserDefaultLCID(),
                                DISPATCH_METHOD,
                                &param,
                                NULL,
                                NULL,
                                NULL
                                );
    printf("Invoke(ConnectionMadeNoQOCInfo) returned 0x%x\n", hr);
    SysFreeString(bstrTemp);
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    printf("--------------------------------------------------------------\n");
    hr = CoCreateInstance(
             CLSID_SensTestSubscriberLogon,
             NULL,
             CLSCTX_LOCAL_SERVER,
             IID_IDispatch,
             (LPVOID *) &pIDispatchLogon
             );

    printf("CoCreateInstance(IDispatchLogon) returned 0x%x\n", hr);
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    hr = CoCreateInstance(
             CLSID_SensTestSubscriberLogon,
             NULL,
             CLSCTX_LOCAL_SERVER,
             IID_ISensLogon,
             (LPVOID *) &pISensLogon
             );

    printf("CoCreateInstance(ISensLogon) returned 0x%x\n", hr);
    if (FAILED(hr))
        {
        goto Cleanup;
        }


    name = L"Logon";
    hr = pIDispatchLogon->GetIDsOfNames(
                              IID_NULL,
                              &name,
                              1,
                              GetUserDefaultLCID(),
                              &dispIDLogon
                              );
    printf("GetIDsOfNames(Logon) returned 0x%x, dispID = %d\n",
           hr, dispIDLogon);
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    //
    // Call Invoke on a function with 1 argument.
    //
    bstrTemp = SysAllocString(L"REDMOND\\JohnDoe");
    VariantInit(&varg);
    varg.vt = VT_BSTR;
    varg.bstrVal = bstrTemp;

    // Fill in the DISPPARAMS structure.
    param.cArgs = 1;
    param.rgvarg = &varg;
    param.cNamedArgs = 0;
    param.rgdispidNamedArgs = NULL;

    hr = pIDispatchLogon->Invoke(
                             dispIDLogon,
                             IID_NULL,
                             GetUserDefaultLCID(),
                             DISPATCH_METHOD,
                             &param,
                             NULL,
                             NULL,
                             NULL
                             );
    printf("Invoke(Logon) returned 0x%x\n", hr);
    SysFreeString(bstrTemp);
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    printf("--------------------------------------------------------------\n");

    //
    // Call Invoke with multiple arguments and UDT
    //

    name = L"ConnectionMade";
    hr = pIDispatchNetwork->GetIDsOfNames(
                                IID_NULL,
                                &name,
                                1,
                                GetUserDefaultLCID(),
                                &dispIDNetwork
                                );
    printf("GetIDsOfNames(ConnectionMade) returned 0x%x, dispID = %d\n",
           hr, dispIDNetwork);
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    // Get the ITypeInfo pointer.
    hr = LoadRegTypeLib(
             LIBID_SensEvents,
             MAJOR_VER,
             MINOR_VER,
             DEFAULT_LCID,
             &pITypeLib
             );
    printf("LoadRegTypeLib returned 0x%x\n", hr);
    if (FAILED(hr))
        {
        hr = LoadTypeLib(
                 SENS_SERVICE,
                 &pITypeLib
                 );
        printf("LoadTypeLib() returned 0x%x\n", hr);
        if (FAILED(hr))
            {
            goto Cleanup;
            }
        }

    hr = pITypeLib->GetTypeInfo(0, &pITypeInfo);
    printf("GetTypeInfo returned 0x%x - (pITypeInfo = 0x%x)\n", hr, pITypeInfo);
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    hr = GetRecordInfoFromTypeInfo(pITypeInfo, &pIRecordInfo);
    printf("GetRecordInfoFromTypeInfo returned 0x%x\n", hr);
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    VARIANTARG arrvarg[3];
    SENS_QOCINFO QOCInfo;

    //
    // Parameters are filled in the reverse order.
    //
    VariantInit(&arrvarg[2]);
    arrvarg[2].vt = VT_BSTR;
    arrvarg[2].bstrVal = SysAllocString(L"A dummy connection name");

    VariantInit(&arrvarg[1]);
    arrvarg[1].vt = VT_UI4;
    arrvarg[1].ulVal = 0x1234abcd;

    // Setup QOCInfo.
    QOCInfo.ulSize = sizeof(SENS_QOCINFO);
    QOCInfo.ulFlags = 0x00000003;
    QOCInfo.ulInSpeed = 33600;
    QOCInfo.ulOutSpeed = 33600;

    VariantInit(&arrvarg[0]);
    arrvarg[0].vt = VT_RECORD | VT_BYREF;
    arrvarg[0].pRecInfo = pIRecordInfo;
    arrvarg[0].pvRecord = &QOCInfo;

    // Fill in the DISPPARAMS structure.
    param.cArgs = 3;
    param.rgvarg = arrvarg;
    param.cNamedArgs = 0;
    param.rgdispidNamedArgs = NULL;

    hr = pIDispatchNetwork->Invoke(
                                dispIDNetwork,
                                IID_NULL,
                                GetUserDefaultLCID(),
                                DISPATCH_METHOD,
                                &param,
                                NULL,
                                NULL,
                                NULL
                                );
    printf("Invoke(ConnectionMade) returned 0x%x\n", hr);
    if (FAILED(hr))
        {
        goto Cleanup;
        }


//
// Cleanup stuff
//
Cleanup:

    if (pIDispatchNetwork)
        {
        pIDispatchNetwork->Release();
        }

    if (pIDispatchLogon)
        {
        pIDispatchLogon->Release();
        }

    if (pISensNetwork)
        {
        pISensNetwork->Release();
        }

    if (pISensLogon)
        {
        pISensLogon->Release();
        }

    if (pITypeLib)
        {
        pITypeLib->Release();
        }

    if (pITypeInfo)
        {
        pITypeInfo->Release();
        }

    CoUninitialize();

    printf("--------------------------------------------------------------\n");

    return (SUCCEEDED(hr) ? 0 : -1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\test\senstest\senstest.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    senstest.cxx

Abstract:

    BVT for the SENS Connectivity APIs.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          10/13/1997         Start.

--*/


#include <common.hxx>
#include <stdio.h>
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <sensapi.h>
#include <conio.h>


//
// Globals
//
DWORD   gdwThreads;
DWORD   gdwInterval;

//
// Forwards
//

void
MultiThreadedTest(
    void
    );




inline void
Usage(
    void
    )
{
    printf("\nUsage:    senstest [Destination] \n");
    printf("          senstest [-m [Threads] [Interval]] \n\n");
    printf("Options:\n\n");
    printf("    Destination         Name of the destination whose\n"
           "                        reachability is of interest.\n");
    printf("    -m                  Perform Mulithreaded SensAPI test.\n");
    printf("    Threads             Number of threads  [Default = 5]\n");
    printf("    Interval            Wait between calls [Default = 10 sec]\n");
    printf("\n");
}


int __cdecl
main(
    int argc,
    const char * argv[]
    )
{
    DWORD dwFlags = 0;
    BOOL bAlive = FALSE;
    BOOL bReachable = FALSE;


    if (argc > 4)
        {
        Usage();
        return -1;
        }

    if (   (argc == 2)
        && (   (strcmp(argv[1], "-?") == 0)
            || (strcmp(argv[1], "/?") == 0)
            || (strcmp(argv[1], "-help") == 0)
            || (strcmp(argv[1], "/help") == 0)))
        {
        Usage();
        return -1;
        }

    //
    // Start the MultiThreadedTest, if required.
    //

    if (argc > 1)
        {
        if (strcmp(argv[1], "-m") == 0)
            {
            gdwThreads = 5;
            gdwInterval = 10;

            if (argc > 2)
                {
                gdwThreads = atoi(argv[2]);
                }
            if (argc > 3)
                {
                gdwInterval = atoi(argv[3]);
                }

            MultiThreadedTest();
            return 0;
            }
        }


    //
    // Call IsNetworkAlive()
    //

    printf("------------------------------------------------------------------"
            "----\n");

    bAlive = IsNetworkAlive(&dwFlags);

    printf("    IsNetworkAlive() returned %s\n", bAlive ? "TRUE" : "FALSE");
    if (bAlive)
        {
        printf("    Type of connection -%s%s%s\n",
               (dwFlags & NETWORK_ALIVE_WAN) ? " WAN" : "",
               (dwFlags & NETWORK_ALIVE_AOL) ? " AOL" : "",
               (dwFlags & NETWORK_ALIVE_LAN) ? " LAN" : "");
        }
    printf("    The GetLastError() was %d\n", GetLastError());

    printf("------------------------------------------------------------------"
            "----\n");

    if (argc == 1)
        {
        return 0;
        }


    //
    // Test the other API.
    //

    bReachable = IsDestinationReachableA((LPCSTR) argv[1], NULL);

    printf("    IsDestinationReachableA(%s, NULL) returned %s\n",
                argv[1], bReachable ? "TRUE" : "FALSE");

    if (bReachable)
        {
        printf("    QOC is NULL.\n");
        }
    printf("    The GetLastError() was %d\n", GetLastError());

    //
    // Now, call with QOC Info.
    //

    printf("------------------------------------------------------------------"
            "----\n");

    QOCINFO QOCInfo;
    NTSTATUS NtStatus;

    QOCInfo.dwSize = sizeof(QOCINFO);

#if !defined(SENS_CHICAGO)

    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    RtlInitAnsiString(&AnsiString, (PSZ)argv[1]);
    NtStatus = RtlAnsiStringToUnicodeString(
                   &UnicodeString,
                   &AnsiString,
                   TRUE
                   );
    if (!NT_SUCCESS(NtStatus))
        {
        printf("RtlAnsiStringToUnicodeString() returned 0x%x\n", NtStatus);
        return -1;
        }

    bReachable = IsDestinationReachableW(UnicodeString.Buffer, &QOCInfo);

    wprintf(L"    IsDestinationReachableW(%s, QOC) returned %s\n",
                UnicodeString.Buffer, bReachable ? L"TRUE" : L"FALSE");

    RtlFreeUnicodeString(&UnicodeString);

#else // !SENS_CHICAGO

    bReachable = IsDestinationReachableA(argv[1], &QOCInfo);

    printf("    IsDestinationReachableA(%s, QOC) returned %s\n",
                argv[1], bReachable ? "TRUE" : "FALSE");
#endif // SENS_CHICAGO

    if (bReachable)
        {
        printf("    QOCInfo\n");
        printf("        o dwSize     = 0x%x \n", QOCInfo.dwSize);
        printf("        o dwFlags    = 0x%x \n", QOCInfo.dwFlags);
        printf("        o dwInSpeed  = %d bits/sec.\n", QOCInfo.dwInSpeed);
        printf("        o dwOutSpeed = %d bits/sec.\n", QOCInfo.dwOutSpeed);
        }
    printf("    The GetLastError() was %d\n", GetLastError());

    printf("------------------------------------------------------------------"
            "----\n");

    return 0;
}


#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif

DWORD WINAPI
ThreadProc(
    LPVOID lpvThreadNum
    )
{
    DWORD dwFlags = 0;
    BOOL bAlive = FALSE;
    int iThreadNum;
    int iWait;

    iThreadNum = PtrToLong(lpvThreadNum);

    for (;;)
        {
        printf("[%2d]-----------------------------------------------------------"
            "----\n", iThreadNum);

        bAlive = IsNetworkAlive(&dwFlags);

        printf("[%2d] IsNetworkAlive() returned %s\n", iThreadNum,
               bAlive ? "TRUE" : "FALSE");
        if (bAlive)
            {
            printf("[%2d] Type of connection -%s%s%s\n",
                   iThreadNum,
                   (dwFlags & NETWORK_ALIVE_WAN) ? " WAN" : "",
                   (dwFlags & NETWORK_ALIVE_AOL) ? " AOL" : "",
                   (dwFlags & NETWORK_ALIVE_LAN) ? " LAN" : "");
            }
        printf("[%2d] The GetLastError() was %d\n", iThreadNum, GetLastError());

        iWait = rand() % gdwInterval;
        printf("[%2d] Sleeping for %d seconds\n", iThreadNum, iWait);
        printf("[%2d]-----------------------------------------------------------"
               "----\n\n", iThreadNum);

        Sleep(iWait * 1000);
        }

    return 0;
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif

void
MultiThreadedTest(
    void
    )
{
    DWORD i;
    DWORD dwThreadId;
    DWORD dwResult;
    HANDLE hThread;

    srand(GetTickCount());

    printf("\nSENSTEST: Starting Multithreaded IsNetworkAlive Test\n"
           "\tNumber of threads = %d\n"
           "\tMax Wait interval = %d seconds\n\n",
           gdwThreads, gdwInterval);

    for (i = 0; i < gdwThreads; i++)
        {
        hThread = CreateThread(
                      NULL,
                      0,
                      ThreadProc,
                      ULongToPtr(i),
                      0,
                      &dwThreadId
                      );
        if (NULL != hThread)
            {
            // Don't close the last handle.
            if ((i+1) != gdwThreads)
                {
                CloseHandle(hThread);
                }
            }
        else
            {
            printf("CreateThread(%d) failed with a GLE of %d\n", i,
                   GetLastError());
            }
        }

    dwResult = WaitForSingleObject(hThread, INFINITE);
    printf("WaitForSingleObject() returned %d, GLE = %d\n",
           dwResult, GetLastError());
    CloseHandle(hThread);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\test\senssink\classfac.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    classfac.cxx

Abstract:

    Implements the Class Factory for the SENS Subscriber.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          11/17/1997         Start.

--*/


#include <common.hxx>
#include <ole2.h>
#include <sensevts.h>
#include "sinkcomn.hxx"
#include "classfac.hxx"
#include "cimpnet.hxx"
#include "cimplogn.hxx"


//
// Global counts for the number of objects in the server and the number of
// locks.
//

ULONG g_cObj    = 0L;
ULONG g_cLock   = 0L;



//
// Constructor and Destructor
//
CSensSinkCF::CSensSinkCF(
    void
    ) : m_cRef(1L)
{

}

CSensSinkCF::~CSensSinkCF(
    void
    )
{
    // Empty Destructor.
}



//
// QI
//
STDMETHODIMP
CSensSinkCF::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    HRESULT hr = S_OK;

    *ppv = NULL; // To handle failure cases

    // IUnknown or IClassFactory
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory))
        {
        *ppv = (LPUNKNOWN) this;
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    if (NULL != *ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        }

    return hr;
}



//
// AddRef
//
STDMETHODIMP_(ULONG)
CSensSinkCF::AddRef(
    void
    )
{
    return InterlockedIncrement((PLONG) &m_cRef);
}


//
// Release
//
STDMETHODIMP_(ULONG)
CSensSinkCF::Release(
    void
    )
{
    ULONG cRefT;

    cRefT = InterlockedDecrement((PLONG) &m_cRef);

    if (0 == m_cRef)
        {
        // Invoke the callback function.
        ObjectDestroyed();
        delete this;
        }

    return cRefT;
}



//
// CreateInstance
//
STDMETHODIMP
CSensSinkCF::CreateInstance(
    LPUNKNOWN pUnkOuter,
    REFIID riid,
    LPVOID *ppvObj
    )
{
    LPCIMPISENSNETWORK pObjNet;
    LPCIMPISENSLOGON pObjLogn;
    HRESULT hr;

    DebugTraceGuid("CSensSinkCF::CreateInstance()", riid);

    hr = E_OUTOFMEMORY;
    *ppvObj = NULL;
    pObjNet = NULL;
    pObjLogn = NULL;

    //
    // Return the appropriate interface pointer.
    //
    if (IsEqualIID(riid, IID_ISensNetwork) ||
        IsEqualIID(riid, IID_IUnknown))
        {
        SensPrintA(SENS_INFO, ("\t| ClassFactory::CreateInstance(ISensNetwork)\n"));
        pObjNet = new CImpISensNetwork(ObjectDestroyed);
        if (NULL != pObjNet)
            {
            hr = pObjNet->QueryInterface(riid, ppvObj);
            SensPrintA(SENS_INFO, ("\t| QI on CImpISensNetwork returned 0x%x\n", hr));
            }
        }
    else
    if (IsEqualIID(riid, IID_ISensLogon))
        {
        SensPrintA(SENS_INFO, ("\t| ClassFactory::CreateInstance(ISensLogon)\n"));
        pObjLogn = new CImpISensLogon(ObjectDestroyed);
        if (NULL != pObjLogn)
            {
            hr = pObjLogn->QueryInterface(riid, ppvObj);
            SensPrintA(SENS_INFO, ("\t| QI on CImpISensLogon returned 0x%x\n", hr));
            }
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    if (NULL != *ppvObj)
        {
        InterlockedIncrement((PLONG) &g_cObj);
        }

    SensPrintA(SENS_INFO, ("\t| Returning 0x%x from CF:CreateInstance\n", hr));

    return hr;
}



//
// LockServer
//
STDMETHODIMP
CSensSinkCF::LockServer(
    BOOL fLock
    )
{
    if (fLock)
        {
        InterlockedIncrement((PLONG) &g_cLock);
        }
    else
        {
        InterlockedDecrement((PLONG) &g_cLock);

        InterlockedIncrement((PLONG) &g_cObj);
        ObjectDestroyed(); // this does a --g_cObj
        }

    return NOERROR;
}



//
// ObjectDestroyed
//
void FAR PASCAL
ObjectDestroyed(
    void
    )
{
    if ((0 == InterlockedDecrement((PLONG) &g_cObj)) &&
        (0 == g_cLock))
        {
        SensPrintA(SENS_INFO, ("\t| ObjectDestroyed: g_cObj = %d and g_cLock = %d\n", g_cObj, g_cLock));
        SensPrintA(SENS_INFO, ("\t| Shutting down the app. Calling PostQuitMessage(0)\n"));

        PostQuitMessage(0);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\dll\autosync.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       autosync.cpp
//
//  Contents:   Offline AutoSync class
//
//  Classes:    CAutoSyncPage
//
//  Notes:
//
//  History:    14-Nov-97   SusiA      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

extern LANGID g_LangIdSystem;      // LangId of system we are running on.
extern HINSTANCE g_hmodThisDll; // Handle to this DLL itself.

/*
Both the Logon and Idle pages in the settings dialog share this class
for performance reasons. i.e. don't have to enum handlers and setup
ras combo twice. If we ever need to sepcify the difference between settings
to handlers for logon/logoff and Idle then these would have to be separated
*/

// initializes the specified hwnd.
BOOL CAutoSyncPage::InitializeHwnd(HWND hwnd,SYNCTYPE syncType,DWORD dwDefaultConnection)
{
    HRESULT hr;
    HWND hwndRasCombo;
    HWND hwndList;
    HIMAGELIST      himage;
    LV_COLUMN       columnInfo;
    WORD wHandlerID;
    CListView **ppListView = NULL;
    UINT ImageListflags;
    
    
    Assert(hwnd == m_hwndAutoSync || hwnd == m_hwndIdle);
    
    // make sure main class is initialized.
    if (FALSE == Initialize(hwnd,dwDefaultConnection))
    {
        return FALSE;
    }
    
    // Setup the Ras combo
    // !!!Must be done before Initializing the Handler queue.
    smBoolChk(hwndRasCombo = GetDlgItem(hwnd,IDC_AUTOUPDATECOMBO));
    
    m_pRas->FillRasCombo(hwndRasCombo,FALSE,TRUE);
    
    // now initialize the handler which will create queue
    // if necessary and fill in the values for the specified syncType
    
    smBoolChk(InitializeHandler(hwnd,syncType));
    
    Assert(m_HndlrQueue);
    
    // If initialization was successfull, read in connection info
    // based on th type.
    if ( FAILED(m_HndlrQueue->InitSyncSettings(syncType,hwndRasCombo)))
    {
        return FALSE;
    }
    
    hr = m_HndlrQueue->FindFirstHandlerInState (HANDLERSTATE_PREPAREFORSYNC,&wHandlerID);
    
    while (hr == S_OK)
    {
        m_HndlrQueue->ReadSyncSettingsPerConnection(syncType,wHandlerID);
        hr = m_HndlrQueue->FindNextHandlerInState(wHandlerID,HANDLERSTATE_PREPAREFORSYNC,
            &wHandlerID);
    }
    
    
    
    //initialize the item list and style
    smBoolChk(hwndList = GetDlgItem(hwnd,IDC_AUTOUPDATELIST));
    
    ppListView = (syncType == SYNCTYPE_AUTOSYNC) ? &m_pItemListViewAutoSync : &m_pItemListViewIdle;
    if (hwndList)
    {
        *ppListView = new CListView(hwndList,hwnd,IDC_AUTOUPDATELIST,WM_NOTIFYLISTVIEWEX);
    }
    
    
    if (NULL == *ppListView)
    {
        return FALSE;
    }
    
    (*ppListView)->SetExtendedListViewStyle(LVS_EX_CHECKBOXES 
        |   LVS_EX_FULLROWSELECT |  LVS_EX_INFOTIP );
    
    
    ImageListflags = ILC_COLOR | ILC_MASK;
    if (IsHwndRightToLeft(hwnd))
    {
        ImageListflags |=  ILC_MIRROR;
    }
    
    // create an imagelist
    himage = ImageList_Create( GetSystemMetrics(SM_CXSMICON),
        GetSystemMetrics(SM_CYSMICON),ImageListflags,5,20);
    if (himage)
    {
        (*ppListView)->SetImageList(himage,LVSIL_SMALL);
    }
    
    // Insert the Proper columns
    columnInfo.mask = LVCF_FMT  | LVCF_WIDTH;
    columnInfo.fmt = LVCFMT_LEFT;
    columnInfo.cx = CalcListViewWidth(hwndList,260);
    
    (*ppListView)->InsertColumn(0,&columnInfo);
    
    smBoolChk(ShowItemsOnThisConnection(hwnd,syncType,dwDefaultConnection));
    
    ShowWindow(hwnd, SW_SHOWNORMAL );
    UpdateWindow(hwnd);
    
    return TRUE;
    
}



//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CAutoSyncPage::Initialize(DWORD dwDefaultConnection)
//
//  PURPOSE: initialization for the autosync page
//
//  RETURN VALUE: return TRUE if we process it ok.
//
//  HISTORY:  01-01-98       SusiA        Created.
//
//+-------------------------------------------------------------------------------

BOOL CAutoSyncPage::Initialize(HWND hwnd ,DWORD dwDefaultConnection )
{
    
    if (m_fInitialized)
        return TRUE;
    
    // Initialize Ras Combo box
    m_pRas= new CRasUI();
    
    if (NULL == m_pRas || FALSE == m_pRas->Initialize())
    {
        if (m_pRas)
        {
            delete m_pRas;
            m_pRas = NULL;
        }
        
        return FALSE;
    }
    
    
    m_fInitialized = TRUE;
    return TRUE;
}
//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CAutoSyncPage::InitializeHandler()
//
//  PURPOSE: initialization for the autosync page
//
//  RETURN VALUE: return TRUE if we process it ok.
//
//  HISTORY:  01-01-98       SusiA        Created.
//
//+-------------------------------------------------------------------------------

BOOL CAutoSyncPage::InitializeHandler(HWND hwnd,SYNCTYPE /* SyncType */)
{
    SCODE sc = S_OK;
    TCHAR lpName[MAX_PATH];
    HKEY hkSyncMgr;
    CLSID clsid;
    WORD wHandlerID;
    HWND hwndRasCombo;
    
    Assert(hwnd == m_hwndAutoSync || hwnd == m_hwndIdle);
    
    if (NULL == (hwndRasCombo = GetDlgItem(hwnd,IDC_AUTOUPDATECOMBO)) )
    {
        return FALSE;
    }
    
    
    if (NULL == m_HndlrQueue) // if queue is already initialized, just return.
    {
        m_HndlrQueue = new CHndlrQueue(QUEUETYPE_SETTINGS);
        if (NULL == m_HndlrQueue)
        {
            return FALSE;
        }
        if (FAILED(m_HndlrQueue->Init()))
        {
            m_HndlrQueue->Release();
            m_HndlrQueue = NULL;
            return FALSE;
        }  
        
        // loop through the reg getting the handlers and trying to
        // create them.
        if (hkSyncMgr = RegGetHandlerTopLevelKey(KEY_READ))
        {
            DWORD dwIndex = 0;
            
            while (ERROR_SUCCESS == RegEnumKey(hkSyncMgr,dwIndex,
                lpName,ARRAYSIZE(lpName)))
            {
                if (NOERROR == CLSIDFromString(lpName,&clsid) )
                {
                    if (NOERROR == m_HndlrQueue->AddHandler(clsid, &wHandlerID))
                    {
                        m_HndlrQueue->CreateServer(wHandlerID,&clsid);
                    }
                }
                
                dwIndex++;
            }
            
            RegCloseKey(hkSyncMgr);
        }
        
        // Initialize the items.
        sc = m_HndlrQueue->FindFirstHandlerInState(HANDLERSTATE_INITIALIZE,&wHandlerID);
        
        while (sc == S_OK)
        {
            m_HndlrQueue->Initialize(wHandlerID,0,SYNCMGRFLAG_SETTINGS,0,NULL);
            
            sc = m_HndlrQueue->FindNextHandlerInState(wHandlerID,
                HANDLERSTATE_INITIALIZE,
                &wHandlerID);             
        }
        
        // loop through adding items
        sc = m_HndlrQueue->FindFirstHandlerInState (HANDLERSTATE_ADDHANDLERTEMS,&wHandlerID);
        
        while (sc == S_OK)
        {
            m_HndlrQueue->AddHandlerItemsToQueue(wHandlerID);
            
            sc = m_HndlrQueue->FindNextHandlerInState(wHandlerID,HANDLERSTATE_ADDHANDLERTEMS,
                &wHandlerID);
        }
        
        
        
    }
    
    
    Assert(m_HndlrQueue);
    return TRUE;
    
}


void CAutoSyncPage::SetAutoSyncHwnd(HWND hwnd)
{
    m_hwndAutoSync = hwnd;
}

void CAutoSyncPage::SetIdleHwnd(HWND hwnd)
{
    m_hwndIdle = hwnd;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CAutoSyncPage::CommitChanges()
//
//  PURPOSE:  Write all the current AutoSync Settings to the registry
//
//      COMMENTS: Implemented on main thread.
//
//  HISTORY:  01-01-98       SusiA        Created.
//
//--------------------------------------------------------------------------------
HRESULT CAutoSyncPage::CommitAutoSyncChanges(void)
{
    HRESULT hr = S_FALSE;
    
    if (m_HndlrQueue)
    {
        hr =  m_HndlrQueue->CommitSyncChanges(SYNCTYPE_AUTOSYNC,m_pRas);
    }
    
    return hr;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CAutoSyncPage::CommitIdleChanges()
//
//  PURPOSE:  Write all the current Idle Settings to the registry
//
//
//
//  HISTORY:  02-23-98       rogerg        Created.
//
//--------------------------------------------------------------------------------

HRESULT CAutoSyncPage::CommitIdleChanges(void)
{
    HRESULT hr = S_FALSE;
    
    if (m_HndlrQueue)
    {
        hr = m_HndlrQueue->CommitSyncChanges(SYNCTYPE_IDLE,m_pRas);
    }
    
    return hr;
}


//+-------------------------------------------------------------------------------
//
//  FUNCTION: CAutoSyncPage::~CAutoSyncPage(HWND hwnd)
//
//  PURPOSE:  destructor
//
//      COMMENTS: destructor for AutoSync page
//
//--------------------------------------------------------------------------------
CAutoSyncPage::~CAutoSyncPage()
{
    if (m_pRas)
    {
        delete m_pRas;
        m_pRas = NULL;
    }
    
    
    if (m_HndlrQueue)
    {
        m_HndlrQueue->Release();
    }
    
    Assert(NULL == m_pItemListViewAutoSync);
    Assert(NULL == m_pItemListViewIdle);
    
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CAutoSyncPage::ShowProperties(int iItem)
//
//  PURPOSE:  Show the app specific properties  Dialog
//
//      COMMENTS: Implemented on main thread.
//
//  HISTORY:  01-01-98       SusiA        Created.
//
//--------------------------------------------------------------------------------
SCODE CAutoSyncPage::ShowProperties(HWND hwnd,int iItem)
{
    SCODE sc = E_UNEXPECTED;
    
    Assert(hwnd == m_hwndAutoSync || hwnd == m_hwndIdle);
    
    
    // review, what happens when a cancel comes in when properties are being shown??
    if (m_HndlrQueue)
    {
        sc = m_HndlrQueue->ShowProperties(hwnd,iItem);
    }
    
    return sc;
}

//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CAutoSyncPage::SetItemCheckState(int iItem, BOOL fChecked)
//
//  PURPOSE: set the selected check state
//
//  RETURN VALUE: return TRUE if we process it ok.
//
//  HISTORY:  01-01-98       SusiA        Created.
//
//+-------------------------------------------------------------------------------
BOOL CAutoSyncPage::SetItemCheckState(HWND hwnd,SYNCTYPE syncType,int iItem, BOOL fChecked,int iCheckCount)
{
    HWND hwndRasCombo;
    int iConnectionItem;
    
    Assert(hwnd == m_hwndAutoSync || hwnd == m_hwndIdle);
    
    hwndRasCombo = GetDlgItem(hwnd,IDC_AUTOUPDATECOMBO);
    
    if (NULL == hwndRasCombo || NULL == m_HndlrQueue)
    {
        Assert(hwndRasCombo);
        Assert(m_HndlrQueue);
        return FALSE;
    }
    
    
    iConnectionItem = ComboBox_GetCurSel(hwndRasCombo);
    
    //The check state is message is getting flagged by us programmatically setting it,
    // until after we are done initializing.
    if (m_fItemsOnConnection)
    {
        BOOL fAnyChecked;
        CListView *pItemListView = (syncType == SYNCTYPE_AUTOSYNC) ? m_pItemListViewAutoSync : m_pItemListViewIdle;
        
        fAnyChecked = iCheckCount ? TRUE : FALSE;
        
        if (ERROR_SUCCESS == m_HndlrQueue->SetSyncCheckStateFromListViewItem(
            syncType,iItem,fChecked, iConnectionItem))
        {
            return TRUE;
        }
        
        return FALSE;
    }
    
    return TRUE;
}

//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CAutoSyncPage::SetConnectionCheck(WORD wParam,DWORD dwCheckState)
//
//  PURPOSE: set the selected check state
//
//  RETURN VALUE: return TRUE if we process it ok.
//
//  HISTORY:  01-01-98       SusiA        Created.
//
//+-------------------------------------------------------------------------------
BOOL CAutoSyncPage::SetConnectionCheck(HWND hwnd,SYNCTYPE syncType,WORD wParam, DWORD dwCheckState)
{
    HWND hwndRasCombo ;
    int iConnectionItem;
    
    Assert(hwnd == m_hwndAutoSync || hwnd == m_hwndIdle);
    
    hwndRasCombo = GetDlgItem(hwnd,IDC_AUTOUPDATECOMBO);
    if (NULL == hwndRasCombo || NULL == m_HndlrQueue)
    {
        Assert(hwndRasCombo);
        Assert(m_HndlrQueue);
        return FALSE;
    }
    
    iConnectionItem = ComboBox_GetCurSel(hwndRasCombo);
    
    if (m_fItemsOnConnection)
    {
        CListView *pItemListView = (syncType == SYNCTYPE_AUTOSYNC) ? m_pItemListViewAutoSync : m_pItemListViewIdle;
        
        //Check changing for logon or logoff
        //So enable the prompt me first accordingly
        
        if (wParam != IDC_AUTOPROMPT_ME_FIRST)
        {
            HWND hwndLogon = GetDlgItem(hwnd,IDC_AUTOUPDATELIST);
            int iLogonCheck  = Button_GetCheck(GetDlgItem(hwnd,IDC_AUTOLOGON));
            int iLogoffCheck = Button_GetCheck(GetDlgItem(hwnd,IDC_AUTOLOGOFF));
        }
        if (ERROR_SUCCESS == m_HndlrQueue->SetConnectionCheck(wParam,dwCheckState,iConnectionItem))
        {
            return TRUE;
        }
        
        return FALSE;
    }
    return TRUE;
}
//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CAutoSyncPage::ShowItemsOnThisConnection(DWORD dwConnectionNum)
//
//  PURPOSE: initialization for the autosync page
//
//  RETURN VALUE: return TRUE if we process it ok.
//
//  HISTORY:  01-01-98       SusiA        Created.
//
//+-------------------------------------------------------------------------------

BOOL CAutoSyncPage::ShowItemsOnThisConnection(HWND hwnd,SYNCTYPE syncType,DWORD dwConnectionNum)
{
    TCHAR pszConnectionName[RAS_MaxEntryName+1];
    HWND hwndRasCombo;
    CListView *pItemListView = (syncType == SYNCTYPE_AUTOSYNC) ? m_pItemListViewAutoSync : m_pItemListViewIdle;
    BOOL *pListViewInitialize = (syncType == SYNCTYPE_AUTOSYNC) ? &m_pItemListViewAutoSyncInitialized : &m_fListViewIdleInitialized;
    
    Assert(hwnd == m_hwndAutoSync || hwnd == m_hwndIdle);
    
    hwndRasCombo = GetDlgItem(hwnd,IDC_AUTOUPDATECOMBO);
    if (NULL == hwndRasCombo || NULL == m_HndlrQueue || NULL == pItemListView)
    {
        Assert(m_HndlrQueue);
        Assert(hwndRasCombo);
        Assert(pItemListView);
        return FALSE;
    }
    
    *pListViewInitialize = FALSE; // reset initialized in case user switched connections.
    
    //first clear out the list view
    // Review - why not just recheck items based on new connection??? 
    m_fItemsOnConnection = FALSE;                       
    pItemListView->DeleteAllItems();
    
    HIMAGELIST himage;
    LVITEMEX lvItemInfo;
    WORD wHandlerID;
    
    
    //Note:  Use text to "uniquely" identify connection on RAS
    DWORD dwNumConnections = (DWORD) ComboBox_GetCount(hwndRasCombo);
    
    // make sure dwConnectionNum is valid,
    if (dwConnectionNum >= dwNumConnections)
    {
        return FALSE;
    }
    
    COMBOBOXEXITEM comboItem;
    comboItem.mask = CBEIF_TEXT;
    comboItem.cchTextMax = ARRAYSIZE(pszConnectionName);
    comboItem.pszText = pszConnectionName;
    comboItem.iItem = dwConnectionNum;
    
    // Review, handle failures.
    SendMessage(hwndRasCombo, CBEM_GETITEM, (WPARAM) 0, (LPARAM) &comboItem);
    
    // loop through proxies initializing and adding to the list
    SYNCMGRITEMID ItemID;
    CLSID clsidHandler;
    WORD wItemID;
    
    // add same images over and over again. Should either just use the same listView
    // resetting the CheckBoxes according or clear the ImageList each time.
    himage = pItemListView->GetImageList(LVSIL_SMALL );
    
    
    HRESULT hr = m_HndlrQueue->FindFirstItemOnConnection
        (pszConnectionName, &clsidHandler,
        &ItemID,&wHandlerID,&wItemID);
    
    if (NOERROR == hr)
    {
        DWORD dwCheckState;
        do
        {
            INT iListViewItem;
            CLSID clsidDataHandler;
            SYNCMGRITEM offlineItem;
            ITEMCHECKSTATE   ItemCheckState;
            
            // grab the offline item info.
            if (NOERROR == m_HndlrQueue->GetSyncItemDataOnConnection(
                dwConnectionNum,
                wHandlerID,wItemID,
                &clsidDataHandler,&offlineItem,
                &ItemCheckState,
                FALSE, FALSE))
            {
                LVHANDLERITEMBLOB lvHandlerItemBlob;
                int iParentItemId;
                BOOL fHandlerParent = TRUE; // always have a parent for now.
                
                // Check if item is already in the ListView and if so
                // go on
                
                lvHandlerItemBlob.cbSize = sizeof(LVHANDLERITEMBLOB);
                lvHandlerItemBlob.clsidServer = clsidDataHandler;
                lvHandlerItemBlob.ItemID = offlineItem.ItemID;
                
                if (-1 != pItemListView->FindItemFromBlob((LPLVBLOB) &lvHandlerItemBlob))
                {
                    // already in ListView, go on to the next item.
                    continue;
                }
                
                if (!fHandlerParent)
                {
                    iParentItemId = LVI_ROOT;
                }
                else
                {
                    // need to add to list so find parent and if one doesn't exist, create it.
                    lvHandlerItemBlob.cbSize = sizeof(LVHANDLERITEMBLOB);
                    lvHandlerItemBlob.clsidServer = clsidDataHandler;
                    lvHandlerItemBlob.ItemID = GUID_NULL;
                    
                    iParentItemId = pItemListView->FindItemFromBlob((LPLVBLOB) &lvHandlerItemBlob);
                    
                    if (-1 == iParentItemId)
                    {
                        LVITEMEX itemInfoParent;
                        SYNCMGRHANDLERINFO SyncMgrHandlerInfo;
                        
                        // if can't get the ParentInfo then don't add the Item
                        if (NOERROR != m_HndlrQueue->GetHandlerInfo(clsidDataHandler,&SyncMgrHandlerInfo))
                        {
                            continue;
                        }
                        
                        // Insert the Parent.
                        itemInfoParent.mask = LVIF_TEXT;
                        itemInfoParent.iItem = LVI_LAST;;
                        itemInfoParent.iSubItem = 0;
                        itemInfoParent.iImage = -1;
                        
                        itemInfoParent.pszText = SyncMgrHandlerInfo.wszHandlerName;
                        if (himage)
                        {
                            HICON hIcon = SyncMgrHandlerInfo.hIcon ? SyncMgrHandlerInfo.hIcon : offlineItem.hIcon;
                            
                            // if have toplevel handler info icon use this else use the
                            // items icon
                            
                            if (hIcon &&  (itemInfoParent.iImage = 
                                ImageList_AddIcon(himage,hIcon)) )
                            {
                                itemInfoParent.mask |= LVIF_IMAGE ; 
                            }
                        }
                        
                        // save the blob
                        itemInfoParent.maskEx = LVIFEX_BLOB;
                        itemInfoParent.pBlob = (LPLVBLOB) &lvHandlerItemBlob;
                        
                        iParentItemId = pItemListView->InsertItem(&itemInfoParent);
                        
                        // if parent insert failed go onto the next item
                        if (-1 == iParentItemId)
                        {
                            continue;
                        }
                    }
                }
                
                // now attemp to insert the item.
                lvItemInfo.mask = LVIF_TEXT; 
                lvItemInfo.maskEx = LVIFEX_PARENT | LVIFEX_BLOB; 
                
                lvItemInfo.iItem = LVI_LAST;
                lvItemInfo.iSubItem = 0; 
                lvItemInfo.iParent = iParentItemId;
                
                
                lvItemInfo.pszText = offlineItem.wszItemName; 
                lvItemInfo.iImage = -1; // set to -1 in case can't get image.
                
                
                // setup the blob
                lvHandlerItemBlob.ItemID = offlineItem.ItemID;
                lvItemInfo.pBlob = (LPLVBLOB) &lvHandlerItemBlob;
                
                if (himage && offlineItem.hIcon)
                {
                    lvItemInfo.iImage =
                        ImageList_AddIcon(himage,offlineItem.hIcon);
                }
                
                iListViewItem = pItemListView->InsertItem(&lvItemInfo);
                
                if (-1 == iListViewItem)
                {
                    continue;
                }
                
                //Set the check state of the item
                lvItemInfo.mask = LVIF_STATE;
                lvItemInfo.maskEx = 0; 
                lvItemInfo.iItem = iListViewItem; 
                lvItemInfo.iSubItem = 0;
                
                dwCheckState =  (syncType == SYNCTYPE_IDLE)
                    ? ItemCheckState.dwIdle : ItemCheckState.dwAutoSync;
                
                lvItemInfo.stateMask= LVIS_STATEIMAGEMASK;
                lvItemInfo.state = (dwCheckState == SYNCMGRITEMSTATE_UNCHECKED) ?
                                    LVIS_STATEIMAGEMASK_UNCHECK : LVIS_STATEIMAGEMASK_CHECK;
                
                pItemListView->SetItem(&lvItemInfo);
                
                m_HndlrQueue->SetItemListViewID(clsidDataHandler,offlineItem.ItemID,iListViewItem);
                
                }
                
                
            } while (NOERROR == m_HndlrQueue->FindNextItemOnConnection
                (pszConnectionName,wHandlerID,wItemID,
                &clsidHandler,&ItemID,&wHandlerID,&wItemID, TRUE,
                &dwCheckState) );
    }
    
    if (pItemListView->GetItemCount())
    {
        pItemListView->SetItemState(0,LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED );          
    }
    
    
    if (syncType == SYNCTYPE_AUTOSYNC)
    {
        int iLogonCheck  = m_HndlrQueue->GetCheck(IDC_AUTOLOGON, dwConnectionNum);
        int iLogoffCheck = m_HndlrQueue->GetCheck(IDC_AUTOLOGOFF, dwConnectionNum);
        
        Button_SetCheck(GetDlgItem(hwnd,IDC_AUTOLOGON),iLogonCheck);
        Button_SetCheck(GetDlgItem(hwnd,IDC_AUTOLOGOFF),iLogoffCheck);
        
        Button_SetCheck(GetDlgItem(hwnd,IDC_AUTOPROMPT_ME_FIRST),
            m_HndlrQueue->GetCheck(IDC_AUTOPROMPT_ME_FIRST, dwConnectionNum));
    }
    else if (syncType == SYNCTYPE_IDLE)
    {
        int iIdleCheck  = m_HndlrQueue->GetCheck(IDC_IDLECHECKBOX, dwConnectionNum);
        
        Button_SetCheck(GetDlgItem(hwnd,IDC_IDLECHECKBOX),iIdleCheck);
    }
    
    
    *pListViewInitialize = TRUE;
    m_fItemsOnConnection = TRUE;                        
    
    return TRUE;
}


//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CAutoSyncPage::GetNumConnections(SYNCTYPE syncType))
//
//  PURPOSE: returns the number of connections available to select for the
//          specified sync type
//
//  RETURN number of connections.
//
//  HISTORY:  03-10-98       rogerg        Created.
//
//+-------------------------------------------------------------------------------

DWORD CAutoSyncPage::GetNumConnections(HWND hwnd,SYNCTYPE syncType)
{
    HWND hwndRasCombo;
    
    Assert(syncType == SYNCTYPE_IDLE || syncType == SYNCTYPE_AUTOSYNC);
    Assert(NULL != hwnd);
    
    hwndRasCombo = GetDlgItem(hwnd,IDC_AUTOUPDATECOMBO);
    Assert(hwndRasCombo);
    
    if (hwndRasCombo)
    {
        return ComboBox_GetCount(hwndRasCombo);
    }
    
    return 0;
}


//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CAutoSyncPage::GetAdvancedIdleSettings(LPCONNECTIONSETTINGS *ppConnectionSettings)
//
//  PURPOSE: fills in the ConnectionSettings Structure with the Advanced
//              Idle default settings.
//
//  RETURN
//
//  HISTORY:  03-10-98       rogerg        Created.
//
//+-------------------------------------------------------------------------------

HRESULT CAutoSyncPage::GetAdvancedIdleSettings(LPCONNECTIONSETTINGS pConnectionSettings)
{
    Assert(pConnectionSettings);
    Assert(m_HndlrQueue);
    
    if (NULL == pConnectionSettings
        || NULL == m_HndlrQueue)
    {
        return S_FALSE;
    }
    
    return m_HndlrQueue->ReadAdvancedIdleSettings(pConnectionSettings);
}


//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CAutoSyncPage::SetAdvancedidleSettings(LPCONNECTIONSETTINGS pConnectionSettings)
//
//  PURPOSE: sets the advancedIdle Settings.
//
//  RETURN
//
//  HISTORY:  03-10-98       rogerg        Created.
//
//+-------------------------------------------------------------------------------

HRESULT CAutoSyncPage::SetAdvancedIdleSettings(LPCONNECTIONSETTINGS pConnectionSettings)
{
    Assert(pConnectionSettings);
    Assert(m_HndlrQueue);
    
    if (NULL == pConnectionSettings
        || NULL == m_HndlrQueue)
    {
        return S_FALSE;
    }
    
    return m_HndlrQueue->WriteAdvancedIdleSettings(pConnectionSettings);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\dll\cfact.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       Cfact.cpp
//
//  Contents:   Main Dll api and Class Factory interface
//
//  Classes:    CClassFactory
//
//  Notes:
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

STDAPI DllRegisterServer(void);
STDAPI DllPerUserRegister(void);
STDAPI DllPerUserUnregister(void);

EXTERN_C  int APIENTRY mobsyncDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved);
STDAPI mobsyncDllGetClassObject(REFCLSID clsid, REFIID iid, void **ppv);
STDAPI mobsyncDllRegisterServer(void);
STDAPI mobsyncDllUnregisterServer(void);
STDAPI mobsyncDllCanUnloadNow(void);

#define PrxDllMain mobsyncDllMain
#define PrxDllRegisterServer mobsyncDllRegisterServer
#define PrxDllUnregisterServer mobsyncDllUnregisterServer
#define PrxDllMain mobsyncDllMain
#define PrxDllGetClassObject mobsyncDllGetClassObject
#define PrxDllCanUnloadNow mobsyncDllCanUnloadNow

//
// Global variables
//
UINT      g_cRefThisDll = 0;            // Reference count of this DLL.
HINSTANCE g_hmodThisDll = NULL;         // Handle to this DLL itself.
CRITICAL_SECTION g_DllCriticalSection;  // Global Critical Section for this DLL
LANGID g_LangIdSystem;      // LangId of system we are running on.

// routines for catching WinLogon
EXTERN_C DWORD WINAPI
WinLogonEvent(
              LPVOID lpParam
              )
{
    
    return 0;
}



EXTERN_C DWORD WINAPI
WinLogoffEvent(
               LPVOID lpParam
               )
{
    
    return 0;
}

// Setup APIs. Should be moved to another file but wait until after ship.

// declarations for install variables and sections. Any changes
// to these declarations must also have a corresponding changes to .inf

// .inf sections names
#define INSTALLSECTION_MACHINEINSTALL       "Reg"
#define INSTALLSECTION_MACHINEUNINSTALL     "UnReg"

#define INSTALLSECTION_REGISTERSHORTCUT     "RegShortcut"
#define INSTALLSECTION_UNREGISTERSHORTCUT   "UnRegShortcut"

#define INSTALLSETCION_PERUSERINSTALL       "PerUserInstall"

#define INSTALLSECTION_SETUP_PERUSERINSTALL   "SetupPerUserInstall"
#define INSTALLSECTION_REMOVE_PERUSERINSTALL   "RemovePerUserInstall"


// Variable declarations
#define  MODULEPATH_MAXVALUESIZE                MAX_PATH
#define  SZ_MODULEPATH                          "MODULEPATH"

#define  ACCESSORIESGROUP_MAXVALUESIZE          MAX_PATH
#define  SZ_ACCESSORIESGROUP                    "ACESSORIES_GROUP"

// Synchronize LinkName
#define  SYNCHRONIZE_LINKNAME_MAXVALUESIZE      MAX_PATH
#define  SZ_SYNCHRONIZE_LINKNAME                "SYNCHRONIZE_LINKNAME"

// Synchronization PerUserInstall Dislay Name
#define  SYNCHRONIZE_PERUSERDISPLAYNAME_MAXVALUESIZE      MAX_PATH
#define  SZ_SYNCHRONIZE_PERUSERDISPLAYNAME                "SYNCHRONIZE_PERUSERDISPLAYNAME"


//+---------------------------------------------------------------------------
//
//  function:   RunDllRegister, public export
//
//  Synopsis:   processes cmdlines from Rundll32 cmd
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    08-Dec-97       rogerg      Created.
//              27-Oct-98       rogerg      Added perUser Flags.
//
//----------------------------------------------------------------------------

// export for how Rundll32 calls us
EXTERN_C void WINAPI  RunDllRegister(HWND hwnd,
                                     HINSTANCE hAppInstance,
                                     LPSTR pszCmdLine,
                                     int nCmdShow)
{
    char *pCmdLine = pszCmdLine;
    
    // if no cmdLine do a register.
    if (!pCmdLine || '\0' == *pCmdLine)
    {
        DllRegisterServer();
        return;
    }
    
    // only allow cmdlines inthe form of /
    if ('/' != *pCmdLine)
    {
        AssertSz(0,"Invalid CmdLine");
        return;
    }
    
    ++pCmdLine;
    
    // command lines we support for .inf installs are
    // /u - Uninstall
    // /p - perUser Install
    // /pu - perUser UnInstall
    
    switch(*pCmdLine)
    {
    case 'u':
    case 'U':
        DllUnregisterServer();
        break;
    case 'p':
    case 'P':
        
        ++pCmdLine;
        
        switch(*pCmdLine)
        {
        case '\0':
            DllPerUserRegister();
            break;
        case 'u':
        case 'U':
            DllPerUserUnregister();
            break;
        default:
            AssertSz(0,"Unknown PerUser Command");
            break;
        }
        break;
        default:
            AssertSz(0,"Unknown Cmd Line");
            break;
    }
    
}


//+---------------------------------------------------------------------------
//
//  function:   GetAccessoriesGroupName, private
//
//  Synopsis:   Gets the Name of the Accessories group
//              from the registry.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    ??-???-98       rogerg      Created.
//
//----------------------------------------------------------------------------

// if can get accessories group name register our shortcut.
// accessories name is located at
// key =  HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion Value = SM_AccessoriesName

// !! MUST ALWAYS RETURN ANSI
HRESULT GetAccessoriesGroupName(char *pszAccessories,DWORD cbSize)
{
    HKEY hkeyWindowsCurrentVersion;
    BOOL fHaveAccessoriesName = FALSE;
    DWORD dwDataSize = cbSize;
    
    if (ERROR_SUCCESS == RegOpenKeyExA(HKEY_LOCAL_MACHINE,"SOFTWARE\\Microsoft\\Windows\\CurrentVersion",0,KEY_READ,
        &hkeyWindowsCurrentVersion) )
    {
        
        if (ERROR_SUCCESS == SHRegGetValueA(hkeyWindowsCurrentVersion,NULL,"SM_AccessoriesName",SRRF_RT_REG_SZ | SRRF_NOEXPAND, NULL,
            (LPBYTE) pszAccessories, &dwDataSize) )
        {
            
            fHaveAccessoriesName = TRUE;
        }
        
        
        RegCloseKey(hkeyWindowsCurrentVersion);
    }
    
    //AssertSz(fHaveAccessoriesName,"Couldn't Get Accessories Group Name");
    
    return fHaveAccessoriesName ? NOERROR : E_UNEXPECTED;
}

//+---------------------------------------------------------------------------
//
//  function:   GetModulePath, private
//
//  Synopsis:   Gets the Path to us with our name stripped out.
//
//              Note - sets pszModulePath to NULL on error.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    27-Oct-98       rogerg      Created.
//
//----------------------------------------------------------------------------

HRESULT GetModulePath(char *pszModulePath,DWORD cbSize)
{
    DWORD dwModuleLen;
    
    Assert(pszModulePath && cbSize >= 1);
    
    if (!pszModulePath || cbSize < 1)
    {
        AssertSz(0,"Invalid ModulePath Ptr");
        return S_FALSE;
    }
    
    *pszModulePath = NULL;
    
    // setup the module path based on our dir.
    if(dwModuleLen = GetModuleFileNameA(
        g_hmodThisDll,
        pszModulePath,
        cbSize) )
    {
        char *pszCurChar = pszModulePath + dwModuleLen - 1;
        
        // NEED to strip off dll name from path, walk back until hit a \ or beginning of string.
        // call with CharPrev but really shouldn't have to since name is never localized.
        
        // on no match want an empty string, on a match want path + last backslash.
        
        while (pszCurChar)
        {
            char *pszPrevChar = CharPrevA(pszModulePath,pszCurChar);
            
            if(pszPrevChar <= pszModulePath)
            {
                *pszModulePath = '\0'; // if got all the way to the end then make an empty string.
                break;
            }
            
            if (*pszPrevChar == '\\')
            {
                *pszCurChar = '\0';
                break;
            }
            
            // check the next character
            pszCurChar = pszPrevChar;
        }
        
    }
    
    return *pszModulePath ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  function:   SetupInfVariables, private
//
//  Synopsis:   sets up the variables we pass to the .inf file
//              if fail to setup a variable it is set to NULL
//
//  Arguments:  cbNumEntries - number of entries in the arrays
//              pseReg - Array of STRENTRYs
//              pdwSizes - Array of String sizes for STRENTRY Values.
//
//  Returns:
//
//  Modifies:
//
//  History:    27-Oct-98       rogerg      Created.
//
//----------------------------------------------------------------------------

/*

  typedef struct _StrEntry {
  LPSTR   pszName;            // String to substitute
  LPSTR   pszValue;           // Replacement string or string resource
  } STRENTRY, *LPSTRENTRY;
  
*/

void SetupInfVariables(DWORD cbNumEntries,STRENTRY *pseReg,DWORD *pdwSizes)
{
    STRENTRY *pCurEntry;
    DWORD *pCurSize;
    
    Assert(pseReg);
    Assert(pdwSizes);
    
    pCurEntry = pseReg;
    pCurSize = pdwSizes;
    
    // loop through the entries getting the info.
    // Entry names are always in ANSI
    
    while (cbNumEntries--)
    {
        
        Assert(*pCurSize);
        
        if (0 < *pCurSize)
        {
            // null out entry in case of failure
            *(pCurEntry->pszValue) = '\0';
            
            // see if it matches a known variable.
            
            if (!lstrcmpA(pCurEntry->pszName,SZ_MODULEPATH))
            {
                // setup the module path based on our dir.
                // GetModulePath sets szModulePath to NULL on error.
                GetModulePath(pCurEntry->pszValue,*pCurSize);
            }
            else if (!lstrcmpA(pCurEntry->pszName,SZ_ACCESSORIESGROUP))
            {
                if (NOERROR != GetAccessoriesGroupName(pCurEntry->pszValue,*pCurSize))
                {
                    *(pCurEntry->pszValue) = '\0';
                }
                
            }
            else if (!lstrcmpA(pCurEntry->pszName,SZ_SYNCHRONIZE_LINKNAME))
            {
                // if size is too small the string will be truncated.
                LoadStringA(g_hmodThisDll,IDS_SHORTCUTNAME,pCurEntry->pszValue,*pCurSize);
            }
            else if (!lstrcmpA(pCurEntry->pszName,SZ_SYNCHRONIZE_PERUSERDISPLAYNAME))
            {
                // if size is too small the string will be truncated.
                LoadStringA(g_hmodThisDll,IDS_SYNCMGR_PERUSERDISPLAYNAME,pCurEntry->pszValue,*pCurSize);
            }
            else
            {
                AssertSz(0,"Uknown Setup Variable");
            }
        }
        
        pCurEntry++;
        pCurSize++;
        
    }
}


HRESULT CallRegInstall(LPSTR szSection,STRTABLE *stReg)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));
    
    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, achREGINSTALL);
        
        if (pfnri)
        {
            
            hr = pfnri(g_hmodThisDll, szSection,stReg);
        }
        
        FreeLibrary(hinstAdvPack);
    }
    
    return hr;
}

STDAPI DllRegisterServer(void)
{
    HRESULT  hr = NOERROR;
    char szModulePath[MODULEPATH_MAXVALUESIZE]; // !!! these must always be ANSI
    char szAccessoriesGroup[ACCESSORIESGROUP_MAXVALUESIZE];
    char szSynchronizeLinkName[SYNCHRONIZE_LINKNAME_MAXVALUESIZE];
    char szSynchronizePerUserDisplayName[SYNCHRONIZE_PERUSERDISPLAYNAME_MAXVALUESIZE];
    
    // register any proxies
    HRESULT hRes = PrxDllRegisterServer();
    
    // !!! STRENTRY and CallResInstall are always ANSI
    STRENTRY seReg[] = {
        {  SZ_MODULEPATH, szModulePath},
        {  SZ_ACCESSORIESGROUP, szAccessoriesGroup},
        {  SZ_SYNCHRONIZE_LINKNAME, szSynchronizeLinkName},
        {  SZ_SYNCHRONIZE_PERUSERDISPLAYNAME, szSynchronizePerUserDisplayName},
    };
    
    DWORD cbNumEntries = ARRAYSIZE(seReg);
    
    // fill in sizes for how big the string Values are.
    DWORD rgdwSizes[] = {
        ARRAYSIZE(szModulePath),
            ARRAYSIZE(szAccessoriesGroup),
            ARRAYSIZE(szSynchronizeLinkName),
            ARRAYSIZE(szSynchronizePerUserDisplayName),
    };
    
    Assert(ARRAYSIZE(seReg) == ARRAYSIZE(rgdwSizes));
    Assert(ARRAYSIZE(seReg) == cbNumEntries);
    Assert(4 == cbNumEntries); // to make sure ARRAYSIZE is working properly
    
    STRTABLE stReg = { cbNumEntries /* Num entries */, seReg };
    
    // initialize the variables.
    SetupInfVariables(cbNumEntries, seReg, rgdwSizes);
    
    // register the RegKeys pasing in the path to the module
    // call even if couldn't get shortcut.
    CallRegInstall(INSTALLSECTION_MACHINEINSTALL,&stReg); // reg the reg keys
    
    // if got the accessories and shortcut name, register the shortcut.
    if (*szSynchronizeLinkName && *szAccessoriesGroup)
    {
        CallRegInstall(INSTALLSECTION_REGISTERSHORTCUT,&stReg); // reg the reg keys
    }
    
    CallRegInstall(INSTALLSECTION_SETUP_PERUSERINSTALL,&stReg);
    
    //
    // Convert the "mobsync.exe /logon" reg value to use a fully-qualified path string.
    //
    RegFixRunKey();
    
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    char szAccessoriesGroup[ACCESSORIESGROUP_MAXVALUESIZE];
    char szSynchronizeLinkName[SYNCHRONIZE_LINKNAME_MAXVALUESIZE];
    char szSynchronizePerUserDisplayName[SYNCHRONIZE_PERUSERDISPLAYNAME_MAXVALUESIZE];
    
    // setup variables to pass to .inf
    STRENTRY seReg[] = {
        {  SZ_ACCESSORIESGROUP, szAccessoriesGroup},
        {  SZ_SYNCHRONIZE_LINKNAME, szSynchronizeLinkName},
        {  SZ_SYNCHRONIZE_PERUSERDISPLAYNAME, szSynchronizePerUserDisplayName},
    };
    
    DWORD cbNumEntries = ARRAYSIZE(seReg);
    
    // fill in sizes for how big the string Values are.
    DWORD rgdwSizes[] = {
        ARRAYSIZE(szAccessoriesGroup),
            ARRAYSIZE(szSynchronizeLinkName),
            ARRAYSIZE(szSynchronizePerUserDisplayName),
    };
    
    Assert(ARRAYSIZE(seReg) == ARRAYSIZE(rgdwSizes));
    Assert(ARRAYSIZE(seReg) == cbNumEntries);
    
    STRTABLE stReg = { cbNumEntries /* Num entries */, seReg };
    
    // initialize the variables.
    SetupInfVariables(cbNumEntries, seReg, rgdwSizes);
    
    // remove any schedules the user created
    RegUninstallSchedules();
    
    // remove or LCE/SENS registrations
    RegRegisterForEvents(TRUE /* fUninstall */);
    RegDeleteKeyNT(HKEY_LOCAL_MACHINE, AUTOSYNC_REGKEY); // remove AutoSync key
    
    
    // remove the proxies
    PrxDllUnregisterServer();
    
    CallRegInstall(INSTALLSECTION_REMOVE_PERUSERINSTALL,&stReg);
    
    // unreg our regkeys
    CallRegInstall(INSTALLSECTION_MACHINEUNINSTALL,&stReg);
    
    // if got shortcut and accessories group remove shorcut
    if (*szSynchronizeLinkName && *szAccessoriesGroup)
    {
        CallRegInstall(INSTALLSECTION_UNREGISTERSHORTCUT,&stReg); // reg the reg keys
    }
    
    // review, should be able to do this from .inf file
    RegDeleteKeyNT(HKEY_LOCAL_MACHINE, IDLESYNC_REGKEY); // remove Idle key
    RegDeleteKeyNT(HKEY_LOCAL_MACHINE, MANUALSYNC_REGKEY); // remove Manual key
    RegDeleteKeyNT(HKEY_LOCAL_MACHINE, PROGRESS_REGKEY); // remove ProgressState key
    
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  function:   DllPerUserRegister, private
//
//  Synopsis:   Handles PerUser Registration
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    27-Oct-98       rogerg      Created.
//
//----------------------------------------------------------------------------

STDAPI DllPerUserRegister(void)
{
    char szModulePath[MODULEPATH_MAXVALUESIZE]; // !!! these must always be ANSI
    char szAccessoriesGroup[ACCESSORIESGROUP_MAXVALUESIZE];
    char szSynchronizeLinkName[SYNCHRONIZE_LINKNAME_MAXVALUESIZE];
    char szSynchronizePerUserDisplayName[SYNCHRONIZE_PERUSERDISPLAYNAME_MAXVALUESIZE];
    
    // setup variables to pass to .inf
    STRENTRY seReg[] = {
        {  SZ_MODULEPATH, szModulePath},
        {  SZ_ACCESSORIESGROUP, szAccessoriesGroup},
        {  SZ_SYNCHRONIZE_LINKNAME, szSynchronizeLinkName},
        {  SZ_SYNCHRONIZE_PERUSERDISPLAYNAME, szSynchronizePerUserDisplayName},
    };
    
    DWORD cbNumEntries = ARRAYSIZE(seReg);
    
    // fill in sizes for how big the string Values are.
    DWORD rgdwSizes[] = {
        ARRAYSIZE(szModulePath),
            ARRAYSIZE(szAccessoriesGroup),
            ARRAYSIZE(szSynchronizeLinkName),
            ARRAYSIZE(szSynchronizePerUserDisplayName),
    };
    
    Assert(ARRAYSIZE(seReg) == ARRAYSIZE(rgdwSizes));
    Assert(ARRAYSIZE(seReg) == cbNumEntries);
    
    STRTABLE stReg = { cbNumEntries /* Num entries */, seReg };
    
    // initialize the variables.
    SetupInfVariables(cbNumEntries, seReg, rgdwSizes);
    
    // if got the accessories and shortcut name, register the shortcut.
    if (*szSynchronizeLinkName && *szAccessoriesGroup)
    {
        CallRegInstall(INSTALLSECTION_REGISTERSHORTCUT,&stReg); // reg the reg keys
    }
    
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  function:   DllPerUserUnregister, private
//
//  Synopsis:   Handles PerUser UnRegistration. Currently not
//              used since dll is removed on machine unregister
//              there is no dll to call next time user logs on.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    27-Oct-98       rogerg      Created.
//
//----------------------------------------------------------------------------

STDAPI DllPerUserUnregister(void)
{
    
    AssertSz(0,"DllPerUserUnregister Called");
    
    return S_OK;
}


// End of Setup APIs


extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    int iRet = 0;
    if (PrxDllMain(hInstance, dwReason, lpReserved))
    {
        
        if (dwReason == DLL_PROCESS_ATTACH)
        {
            
            if (InitializeCriticalSectionAndSpinCount(&g_DllCriticalSection, 0))
            {
                g_hmodThisDll = hInstance;
                
#ifdef _DEBUG
                InitDebugFlags();
#endif // _DEBUG
                
                InitCommonLib();
                
                g_LangIdSystem = GetSystemDefaultLangID(); // find out what lang we are on
                
                
                //initialize the common controls
                INITCOMMONCONTROLSEX controlsEx;
                controlsEx.dwSize = sizeof(INITCOMMONCONTROLSEX);
                controlsEx.dwICC = ICC_USEREX_CLASSES | ICC_WIN95_CLASSES | ICC_NATIVEFNTCTL_CLASS;
                InitCommonControlsEx(&controlsEx);
                iRet = 1;
            }
        }
        else if (dwReason == DLL_PROCESS_DETACH)
        {
            UnInitCommonLib();
            
            Assert(0 == g_cRefThisDll);
            DeleteCriticalSection(&g_DllCriticalSection);
            TRACE("In DLLMain, DLL_PROCESS_DETACH\r\n");
            iRet = 1;
        }
    }
    
    return iRet;
}

//---------------------------------------------------------------------------
// DllCanUnloadNow
//---------------------------------------------------------------------------

STDAPI DllCanUnloadNow(void)
{
    HRESULT hr;
    
    TRACE("In DLLCanUnloadNow\r\n");
    
    if (PrxDllCanUnloadNow() != S_OK)
    {
        return S_FALSE;
    }
    
    if (g_cRefThisDll)
    {
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }
    
    return hr;
}


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvOut)
{
    HRESULT hr = E_OUTOFMEMORY;
    
    TRACE("In DllGetClassObject\r\n");
    
    *ppvOut = NULL;
    
    if (IsEqualIID(rclsid, CLSID_SyncMgr))
    {
        CClassFactory *pcf = new CClassFactory;
        
        if (NULL != pcf)
        {
            hr =  pcf->QueryInterface(riid, ppvOut);
            pcf->Release();
        }
    }
    else
    {
        
        hr = PrxDllGetClassObject(rclsid,riid, ppvOut); 
    }
    
    return hr;
}

CClassFactory::CClassFactory()
{
    TRACE("CClassFactory::CClassFactory()\r\n");
    
    m_cRef = 1;
    InterlockedIncrement((LONG *)& g_cRefThisDll);
}

CClassFactory::~CClassFactory()             
{
    InterlockedDecrement((LONG *)& g_cRefThisDll);
}

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid,
                                           LPVOID FAR *ppv)
{
    TRACE("CClassFactory::QueryInterface()\r\n");
    
    *ppv = NULL;
    
    // Any interface on this object is the object pointer
    
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (LPCLASSFACTORY)this;
        
        AddRef();
        
        return NOERROR;
    }
    
    return E_NOINTERFACE;
}   

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    ULONG cRefs;
    
    // Increment ref count
    cRefs = InterlockedIncrement((LONG *)& m_cRef);
    
    return cRefs;
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    ULONG cRefs;
    
    cRefs = InterlockedDecrement( (LONG *) &m_cRef);
    
    if (0 == cRefs)
    {
        delete this;
    }
    
    return cRefs;
}

STDMETHODIMP CClassFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                           REFIID riid,
                                           LPVOID *ppvObj)
{
    HRESULT hr;
    
    TRACE("CClassFactory::CreateInstance()\r\n");
    
    *ppvObj = NULL;
    
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;
    
    
    LPSYNCMGRSYNCHRONIZEINVOKE pSyncMgrDllObject = (LPSYNCMGRSYNCHRONIZEINVOKE)
        new CSyncMgrSynchronize;
    
    if (NULL == pSyncMgrDllObject)
        return E_OUTOFMEMORY;
    
    hr =  pSyncMgrDllObject->QueryInterface(riid, ppvObj);
    pSyncMgrDllObject->Release();
    
    return hr;
}


STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    
    if (fLock)
    {
        InterlockedIncrement( (LONG *) &g_cRefThisDll);
    }
    else
    {
        InterlockedDecrement( (LONG *) &g_cRefThisDll);
    }
    
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\dll\cnetapi.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       cnetapi.h
//
//  Contents:   Network/SENS API wrappers
//
//  Classes:
//
//  Notes:
//
//  History:    08-Dec-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#ifndef _MOBSYNC_NETAPIIMPL
#define _MOBSYNC_NETAPIIMPL

// not defined until 401 but need to include header as 40 so rasconn
// structure is valid on 40

#ifndef RASADP_LoginSessionDisable
#define RASADP_LoginSessionDisable   1
#endif // RASADP_LoginSessionDisable



// Sens definitions
typedef BOOL (WINAPI *ISNETWORKALIVE)(LPDWORD);

// Ras definitions

typedef DWORD (APIENTRY *RASENUMCONNECTIONSW)( LPRASCONNW, LPDWORD, LPDWORD );
typedef DWORD (APIENTRY *RASENUMCONNECTIONSA)( LPRASCONNA, LPDWORD, LPDWORD );
typedef DWORD (APIENTRY *RASDIAL)(LPRASDIALEXTENSIONS, LPTSTR, LPRASDIALPARAMS, DWORD,
                                  LPVOID, LPHRASCONN );
typedef DWORD (APIENTRY *RASHANGUP)( HRASCONN );
typedef DWORD (APIENTRY *RASGETCONNECTSTATUSPROC)( HRASCONN, LPRASCONNSTATUS );
typedef DWORD (APIENTRY *RASGETERRORSTRINGPROCW)( UINT, LPWSTR, DWORD );
typedef DWORD (APIENTRY *RASGETERRORSTRINGPROCA)( UINT, LPSTR, DWORD );
typedef DWORD (APIENTRY *RASGETAUTODIALPARAM)(DWORD, LPVOID, LPDWORD );
typedef DWORD (APIENTRY *RASSETAUTODIALPARAM)(DWORD, LPVOID, DWORD );

typedef DWORD (APIENTRY *RASENUMENTRIESPROCA)( LPSTR, LPSTR, LPRASENTRYNAMEA, LPDWORD,
                                              LPDWORD );

typedef DWORD (APIENTRY *RASENUMENTRIESPROCW)( LPWSTR, LPWSTR, LPRASENTRYNAMEW, LPDWORD,
                                              LPDWORD );

typedef DWORD (APIENTRY *RASGETENTRYPROPERTIESPROC)(LPTSTR, LPTSTR, LPBYTE, LPDWORD, 
                                                    LPBYTE, LPDWORD );

#ifndef RASDEFINED
#define RASDEFINED
#endif //RASDEFINED


// wininet definitions
typedef DWORD (WINAPI *INTERNETDIAL)(HWND hwndParent,char* lpszConnectoid,DWORD dwFlags,
                                     LPDWORD lpdwConnection, DWORD dwReserved);
typedef DWORD (WINAPI *INTERNETDIALW)(HWND hwndParent,WCHAR* lpszConnectoid,DWORD dwFlags,
                                      LPDWORD lpdwConnection, DWORD dwReserved);
typedef DWORD (WINAPI *INTERNETHANGUP)(DWORD dwConnection,DWORD dwReserved);
typedef BOOL (WINAPI *INTERNETAUTODIAL)(DWORD dwFlags,DWORD dwReserved);
typedef BOOL (WINAPI *INTERNETAUTODIALHANGUP)(DWORD dwReserved);
typedef BOOL (WINAPI *INTERNETGETLASTRESPONSEINFO)(LPDWORD lpdwError,
                                                   LPSTR lpszBuffer,LPDWORD lpdwBufferLength);
typedef BOOL (WINAPI *INTERNETQUERYOPTION)( HINTERNET hInternet,
                                           DWORD dwOption,
                                           LPVOID lpBuffer,
                                           LPDWORD lpdwBufferLength );
typedef BOOL (WINAPI *INTERNETSETOPTION)( HINTERNET hInternet,
                                         DWORD dwOption,
                                         LPVOID lpBuffer,
                                         DWORD dwBufferLength );

// declaration of our internal class
class  CNetApi : public INetApi, public CLockHandler
{
public:
    CNetApi();
    
    STDMETHODIMP QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    STDMETHODIMP_(BOOL) IsSensInstalled(void);
    STDMETHODIMP_(BOOL) IsNetworkAlive(LPDWORD lpdwFlags);
    STDMETHODIMP GetWanConnections(DWORD *cbNumEntries,RASCONN **pWanConnections);
    STDMETHODIMP FreeWanConnections(RASCONN *pWanConnections);
    STDMETHODIMP GetConnectionStatus(LPCTSTR pszConnectionName,DWORD ConnectionType,BOOL *fConnected,BOOL *fCanEstablishConnection);
    STDMETHODIMP RasGetAutodial( BOOL& fEnabled );
    STDMETHODIMP RasSetAutodial( BOOL fEnabled );
    STDMETHODIMP_(DWORD) RasGetErrorStringProc( UINT uErrorValue, LPTSTR lpszErrorString,DWORD cBufSize);
    
    STDMETHODIMP_(DWORD) RasEnumEntries(LPWSTR reserved,LPWSTR lpszPhoneBook,
        LPRASENTRYNAME lprasEntryName,LPDWORD lpcb,LPDWORD lpcEntries);
    
    STDMETHODIMP_(DWORD) RasEnumConnections(LPRASCONNW lprasconn,LPDWORD lpcb,LPDWORD lpcConnections);
    
    // methods for calling wininet
    STDMETHODIMP_(DWORD) InternetDialA(HWND hwndParent,char* lpszConnectoid,DWORD dwFlags,
        LPDWORD lpdwConnection, DWORD dwReserved);
    STDMETHODIMP_(DWORD)InternetDialW(HWND hwndParent,WCHAR* lpszConnectoid,DWORD dwFlags,
        LPDWORD lpdwConnection, DWORD dwReserved);
    STDMETHODIMP_(DWORD)InternetHangUp(DWORD dwConnection,DWORD dwReserved);
    STDMETHODIMP_(BOOL) InternetAutodial(DWORD dwFlags,DWORD dwReserved);
    STDMETHODIMP_(BOOL) InternetAutodialHangup(DWORD dwReserved);
    STDMETHODIMP  InternetGetAutodial( DWORD *pdwMode );
    STDMETHODIMP  InternetSetAutodial( DWORD dwMode );
    STDMETHODIMP_(BOOL) IsGlobalOffline(void);
    STDMETHODIMP_(BOOL) SetOffline(BOOL fOffline);
    
private:
    ~CNetApi();
    
    HRESULT LoadRasApiDll();
    HRESULT LoadWinInetDll();
    STDMETHODIMP LoadSensDll();
    HRESULT _InternetGetAutodialFromWininet(DWORD *pdwMode);
    HRESULT _InternetGetAutodialFromRegistry(DWORD *pdwMode);
    HRESULT _InternetSetAutodialViaWininet(DWORD dwMode);
    HRESULT _InternetSetAutodialViaRegistry(DWORD dwMode);

    // Sens Dll imports
    BOOL m_fTriedToLoadSens;
    HINSTANCE m_hInstSensApiDll;
    ISNETWORKALIVE m_pIsNetworkAlive;
    
    // Ras Dll Imports
    BOOL m_fTriedToLoadRas;
    HINSTANCE m_hInstRasApiDll;
    RASENUMCONNECTIONSW m_pRasEnumConnectionsW;
    RASENUMCONNECTIONSA m_pRasEnumConnectionsA;
    RASENUMENTRIESPROCA         m_pRasEnumEntriesA;
    RASENUMENTRIESPROCW         m_pRasEnumEntriesW;
    RASGETENTRYPROPERTIESPROC   m_pRasGetEntryPropertiesW;
    RASGETERRORSTRINGPROCW m_pRasGetErrorStringW;
    RASGETERRORSTRINGPROCA m_pRasGetErrorStringA;
    
    // Ras dll imports of NT 4 or 5
    RASGETAUTODIALPARAM   m_pRasGetAutodialParam;
    RASSETAUTODIALPARAM   m_pRasSetAutodialParam;
    
    // wininet Dll Imports
    BOOL m_fTriedToLoadWinInet;
    HINSTANCE m_hInstWinInetDll;
    INTERNETDIAL m_pInternetDial;
    INTERNETDIALW m_pInternetDialW;
    INTERNETHANGUP m_pInternetHangUp;
    INTERNETAUTODIAL m_pInternetAutodial;
    INTERNETAUTODIALHANGUP m_pInternetAutodialHangup;
    INTERNETQUERYOPTION     m_pInternetQueryOption;
    INTERNETSETOPTION      m_pInternetSetOption;
    
    ULONG m_cRefs;          // Reference count for this global object
};




#endif // _MOBSYNC_NETAPIIMPL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\dll\color256.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       256color.cpp
//
//  Contents:   Onestop Schedule wizard 256color bitmap handling
//
//  History:    20-Nov-97   SusiA      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

extern HINSTANCE g_hmodThisDll; // Handle to this DLL itself.


static struct {
    HPALETTE        hPal;
    LPBITMAPINFO    lpbmi;
    HGLOBAL         hDIB;
    int             bitpix;
    int             srcOffset;
    int             srcWidth;
    int             srcHeight;
    RECT            dstRect;
} s_Bmp = { NULL, NULL, NULL, 0, 0, 0, 0, {0,0,0,0}};

//-------------------------------------------------------------------------
// Function: SetupPal(ncolor)
//
// Action: Create palette for 256 color DIB.
//
// Return: TRUE if succeeded, FALSE if not.
//-------------------------------------------------------------------------
BOOL SetupPal(WORD ncolor)
{
    UINT                i;
    struct {
       WORD             palVersion;
       WORD             palNumEntries;
       PALETTEENTRY     palPalEntry[256];
    } lgpl256;

    lgpl256.palVersion = 0x300;
    lgpl256.palNumEntries = ncolor;

    for (i = 0; i < lgpl256.palNumEntries; i++) {
        lgpl256.palPalEntry[i].peBlue  = s_Bmp.lpbmi->bmiColors[i].rgbBlue;
        lgpl256.palPalEntry[i].peGreen = s_Bmp.lpbmi->bmiColors[i].rgbGreen;
        lgpl256.palPalEntry[i].peRed   = s_Bmp.lpbmi->bmiColors[i].rgbRed;
        lgpl256.palPalEntry[i].peFlags = 0;
    }

    s_Bmp.hPal = CreatePalette((LPLOGPALETTE)&lgpl256);
    return(s_Bmp.hPal ? TRUE : FALSE);
}


//-------------------------------------------------------------------------
// Function: GetDIBData()
//
// Action: Get 256 color DIB (device independent bitmap) from resource.
//
// Return: TRUE if succeeded, FALSE if not.
//-------------------------------------------------------------------------
BOOL GetDIBData()
{
    HRSRC           hrsrc;
    WORD            ncolor;

    s_Bmp.hPal = NULL;
    hrsrc = FindResource(g_hmodThisDll, MAKEINTRESOURCE(IDB_SPLASH256), RT_BITMAP);
    if (!hrsrc)
        return FALSE;

    s_Bmp.hDIB = LoadResource(g_hmodThisDll, hrsrc);
    if (!s_Bmp.hDIB)
        return FALSE;

    s_Bmp.lpbmi = (LPBITMAPINFO)LockResource(s_Bmp.hDIB);
    if (s_Bmp.lpbmi == NULL)
        return FALSE;

    if (s_Bmp.lpbmi->bmiHeader.biClrUsed > 0)
        ncolor = (WORD)s_Bmp.lpbmi->bmiHeader.biClrUsed;
    else
        ncolor = 1 << s_Bmp.lpbmi->bmiHeader.biBitCount;

    if (ncolor > 256) {
        UnlockResource(s_Bmp.hDIB);
        return FALSE;   // cannot process here
    }

    if ( s_Bmp.lpbmi->bmiHeader.biSize != sizeof(BITMAPINFOHEADER) ) {
        UnlockResource(s_Bmp.hDIB);
        return FALSE;   // format not supported
    }

    if ( !SetupPal(ncolor) ) {
        UnlockResource(s_Bmp.hDIB);
        return FALSE;   // setup palette failed
    }

    s_Bmp.srcWidth = (int)s_Bmp.lpbmi->bmiHeader.biWidth;
    s_Bmp.srcHeight = (int)s_Bmp.lpbmi->bmiHeader.biHeight;
    s_Bmp.srcOffset = (int)s_Bmp.lpbmi->bmiHeader.biSize + (int)(ncolor * sizeof(RGBQUAD));
    UnlockResource(s_Bmp.hDIB);
    return TRUE;
}

//----------------------------------------------------------------------
// Function: Load256ColorBitmap()
//
// Action: Loads the 256color bitmap
//
//----------------------------------------------------------------------
BOOL Load256ColorBitmap()
{
HDC hDc = GetDC(NULL);
    
    if (hDc)
    {
        s_Bmp.bitpix = GetDeviceCaps(hDc, BITSPIXEL);

        ReleaseDC(NULL, hDc);

        if(s_Bmp.bitpix == 8)
        {
	    if(GetDIBData())
	    {
		s_Bmp.lpbmi = (LPBITMAPINFO)LockResource(s_Bmp.hDIB);
	    }
        }

        return TRUE;
    }

    return FALSE;
}

//----------------------------------------------------------------------
// Function: Unload256ColorBitmap()
//
// Action: Unloads the 256color bitmap
//
//----------------------------------------------------------------------
BOOL Unload256ColorBitmap()
{
	if(s_Bmp.hPal)
	{
		UnlockResource(s_Bmp.hDIB);
		DeleteObject(s_Bmp.hPal);
		s_Bmp.hPal = NULL;
	}
	return TRUE;
}
//----------------------------------------------------------------------
// Function: InitPage(hDlg,lParam)
//
// Action: Generic wizard page initialization.
//
//----------------------------------------------------------------------
BOOL InitPage(HWND   hDlg,   LPARAM lParam)
{
    if(s_Bmp.bitpix == 8)   // 256 color mode -> setup destination bmp rect
    {
        HWND hdst;
        RECT rect;
        POINT pt = {0, 0};

        hdst = GetDlgItem(hDlg, IDC_WIZBMP);
        if(hdst != NULL)
        {
            BOOL bSUNKEN;
            s_Bmp.dstRect.left = 0;
            s_Bmp.dstRect.top = 0;
            s_Bmp.dstRect.right = s_Bmp.srcWidth;
            s_Bmp.dstRect.bottom = s_Bmp.srcHeight;
            bSUNKEN = (BOOL)(GetWindowLongPtr(hdst, GWL_STYLE) & SS_SUNKEN);
            if(bSUNKEN)
            {
                s_Bmp.dstRect.right += 2;
                s_Bmp.dstRect.bottom += 2;
            }

            MapWindowPoints(hdst,NULL,&pt,1);
            OffsetRect(&s_Bmp.dstRect, pt.x, pt.y);

            pt.x = 0;
            pt.y = 0;
            GetClientRect(hDlg, &rect);
            MapWindowPoints(hDlg,NULL,&pt,1);

            OffsetRect(&rect, pt.x, pt.y);

            OffsetRect(&s_Bmp.dstRect, -rect.left, -rect.top);
            MoveWindow(hdst,
                s_Bmp.dstRect.left,
                s_Bmp.dstRect.top,
                s_Bmp.dstRect.right - s_Bmp.dstRect.left,
                s_Bmp.dstRect.bottom - s_Bmp.dstRect.top,
                TRUE);
            if(bSUNKEN)
                InflateRect(&s_Bmp.dstRect, -1, -1);
        }else
            SetRect(&s_Bmp.dstRect, 0, 0, 0, 0);
    }

    return TRUE;
}





//-------------------------------------------------------------------------
// Function: WmPaint(hDlg, uMsg, wParam, lParam)
//
// Action: Handle WM_PAINT message. Draw 256 color bmp on 256 color mode.
//
// Return: none
//-------------------------------------------------------------------------
 void WmPaint(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PAINTSTRUCT     ps;

    if(!s_Bmp.hPal){
        DefWindowProc(hDlg, uMsg, wParam, lParam);
        return;
    }

    BeginPaint(hDlg, &ps);
    SelectPalette(ps.hdc, s_Bmp.hPal, FALSE);
    RealizePalette(ps.hdc);

    SetDIBitsToDevice(ps.hdc,
        s_Bmp.dstRect.left,
        s_Bmp.dstRect.top,
        s_Bmp.dstRect.right - s_Bmp.dstRect.left,
        s_Bmp.dstRect.bottom - s_Bmp.dstRect.top,
        0,
        s_Bmp.srcHeight,
        s_Bmp.srcHeight,
        s_Bmp.srcHeight,
        (LPBYTE)s_Bmp.lpbmi + s_Bmp.srcOffset,
        s_Bmp.lpbmi,
        DIB_RGB_COLORS);

    EndPaint(hDlg, &ps);
}


//-------------------------------------------------------------------------
// Function: WmPaletteChanged(hDlg, wParam)
//
// Action: Handle WM_PALETTECHANGED message.
//
// Return: none
//-------------------------------------------------------------------------
 void WmPaletteChanged(HWND hDlg, WPARAM wParam)
{
    HDC         hdc;
    HPALETTE    hPalOld;
    UINT        rp;

    if(hDlg == (HWND)wParam || !s_Bmp.hPal)
        return;

    hdc = GetDC(hDlg);
    hPalOld = SelectPalette(hdc, s_Bmp.hPal, FALSE);
    rp = RealizePalette(hdc);
    if(rp)
        UpdateColors(hdc);

    if (hPalOld)
        SelectPalette(hdc, hPalOld, FALSE);
    ReleaseDC(hDlg, hdc);
}


//-------------------------------------------------------------------------
// Function: WmQueryNewPalette(hDlg)
//
// Action: Handle WM_QUERYNEWPALETTE message.
//
// Return: TRUE if processed, FALSE if not.
//-------------------------------------------------------------------------
 BOOL WmQueryNewPalette(HWND hDlg)
{
HDC     hdc;
HPALETTE    hPalOld;
UINT        rp = 0;

    if(!s_Bmp.hPal)
    {
        return FALSE;
    }

    hdc = GetDC(hDlg);

    if (hdc)
    {
        hPalOld = SelectPalette(hdc, s_Bmp.hPal, FALSE);
        rp = RealizePalette(hdc);
        if(hPalOld)
            SelectPalette(hdc, hPalOld, FALSE);

        ReleaseDC(hDlg, hdc);
    }

    if(rp)
    {
        InvalidateRect(hDlg, NULL, TRUE);
        return TRUE;
    }

    return FALSE;
}


//-------------------------------------------------------------------------
// Function: WmActivate(hDlg, wParam, lParam)
//
// Action: Handle WM_ACTIVATE message
//
// Return: zero if processed, non zero if not.
//-------------------------------------------------------------------------
 BOOL WmActivate(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    if(!s_Bmp.hPal)
        return 1;

    if(LOWORD(wParam) == WA_INACTIVE)   // Deactivated
        return 1;

    InvalidateRect(hDlg, NULL, FALSE);
    return 0;                       // processed
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\dll\color256.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       256color.h
//
//  Contents:   Onestop Schedule wizard 256color bitmap handling
//
//  History:    20-Nov-97   SusiA      Created.
//
//--------------------------------------------------------------------------
#ifndef _COLOR256_
#define _COLOR256_

BOOL Load256ColorBitmap();
BOOL Unload256ColorBitmap();
BOOL InitPage(HWND   hDlg,   LPARAM lParam);
BOOL SetupPal(WORD ncolor);
BOOL GetDIBData();
void WmPaint(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
void WmPaletteChanged(HWND hDlg, WPARAM wParam);
BOOL WmQueryNewPalette(HWND hDlg);
BOOL WmActivate(HWND hDlg, WPARAM wParam, LPARAM lParam);

#endif //_COLOR256_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\dll\clsobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       clsobj.cpp
//
//  Contents:   export for implimenting MobsyncGetClassObject.
//
//  Classes:
//
//  Notes:
//
//  History:    04-Aug-98   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

class CNetApi;

STDAPI MobsyncGetClassObject(ULONG mobsyncClassObjectId,void **pCObj)
{
    if (NULL == pCObj)
    {
        Assert(pCObj);
        return E_INVALIDARG;
    }

    switch(mobsyncClassObjectId)
    {
    case MOBSYNC_CLASSOBJECTID_NETAPI:
        *pCObj = new CNetApi();
        break;
    default:
        AssertSz(0,"Request made for unknown object");
        break;
    }

    return *pCObj ? NOERROR : CLASS_E_CLASSNOTAVAILABLE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\dll\confres.cpp ===
/*----------------------------------------------------------------------------
/ Title;
/  dll.cpp
/  Copyright (C) Microsoft Corporation, 1999.
/
/ Authors;
/   Jude Kavalam (judej)
/
/ Notes;
/   Entry point for File Conflict Resolution Dialog
/----------------------------------------------------------------------------*/

#include "precomp.h"

#define CX_BIGICON                      48
#define CY_BIGICON                      48

extern HINSTANCE g_hmodThisDll; // Handle to this DLL itself.

// Special flag to fix up the callback data when thunking
#define RFC_THUNK_DATA  0x80000000

/////////////////////////////////////////////////////////////////////////////
// Global UNICODE<>ANSI translation helpers
LPWSTR WINAPI AtlA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars)
{
    Assert(lpa != NULL);
    Assert(lpw != NULL);
    // verify that no illegal character present
    // since lpw was allocated based on the size of lpa
    // don't worry about the number of chars
    lpw[0] = L'\0';
    MultiByteToWideChar(CP_ACP, 0, lpa, -1, lpw, nChars);
    return lpw;
}

LPSTR WINAPI AtlW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars)
{
    Assert(lpw != NULL);
    Assert(lpa != NULL);
    // verify that no illegal character present
    // since lpa was allocated based on the size of lpw
    // don't worry about the number of chars
    lpa[0] = '\0';
    WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, nChars, NULL, NULL);
    return lpa;
}

INT_PTR CALLBACK RFCDlgProc(HWND, UINT, WPARAM, LPARAM);

// The caller needs to send an hwnd and fill in the RFCDLGPARAM. Only the icons
// are optional

int WINAPI SyncMgrResolveConflict(HWND hWndParent, RFCDLGPARAM *pdlgParam)
{
    int nRet = 0;
    HICON hIKeepBoth = NULL, hIKeepLocal = NULL, hIKeepNetwork = NULL;
    
    if (!hWndParent || !pdlgParam)
        return -1;
    
    // If we don't have any of the params fail..
    if (!pdlgParam->pszFilename || !pdlgParam->pszLocation || !pdlgParam->pszNewName)
        return -1;
    
    // If we do not have any of the icons, load the defaults
    if (!pdlgParam->hIKeepBoth)
        pdlgParam->hIKeepBoth = hIKeepBoth =
        (HICON)LoadImage(g_hmodThisDll, MAKEINTRESOURCE(IDI_KEEPBOTH),
        IMAGE_ICON, CX_BIGICON, CY_BIGICON,
        LR_LOADMAP3DCOLORS);
    if (!pdlgParam->hIKeepLocal)
        pdlgParam->hIKeepLocal = hIKeepLocal =
        (HICON)LoadImage(g_hmodThisDll, MAKEINTRESOURCE(IDI_KEEPLOCAL),
        IMAGE_ICON, CX_BIGICON, CY_BIGICON,
        LR_LOADMAP3DCOLORS);
    if (!pdlgParam->hIKeepNetwork)
        pdlgParam->hIKeepNetwork = hIKeepNetwork =
        (HICON)LoadImage(g_hmodThisDll, MAKEINTRESOURCE(IDI_KEEPNETWORK),
        IMAGE_ICON, CX_BIGICON, CY_BIGICON,
        LR_LOADMAP3DCOLORS);
    
    nRet = (int)DialogBoxParam(g_hmodThisDll, MAKEINTRESOURCE(IDD_RESFILECONFLICTS),
        hWndParent, RFCDlgProc, (LPARAM)pdlgParam);
    
    // Destroy the icons that were created
    if (hIKeepBoth)
        DestroyIcon(hIKeepBoth);
    if (hIKeepLocal)
        DestroyIcon(hIKeepLocal);
    if (hIKeepNetwork)
        DestroyIcon(hIKeepNetwork);
    
    return nRet;
}

INT_PTR CALLBACK RFCDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    RFCDLGPARAM * pParam = (RFCDLGPARAM*)GetWindowLongPtr(hDlg, DWLP_USER);
    
    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            SHFILEINFO sfi = {0};
            TCHAR szStr[INTERNET_MAX_URL_LENGTH + MAX_PATH];
            TCHAR szFmt[MAX_PATH];
            HICON hiExclaim;
            LPTSTR pszNetUser=NULL, pszNetDate=NULL, pszLocalUser=NULL, pszLocalDate=NULL;
            
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)lParam);
            pParam = (RFCDLGPARAM*)lParam;
            
            if (!pParam)
            {
                EndDialog(hDlg, -1);
                return TRUE;
            }
            
            hiExclaim = LoadIcon(NULL, IDI_EXCLAMATION);
            SendDlgItemMessage(hDlg, IDI_EXCLAIMICON, STM_SETICON, (WPARAM)hiExclaim, 0L);
            
            // Get the icon from Shell
            if (FAILED(StringCchPrintf(szStr, ARRAYSIZE(szStr), TEXT("%ws%ws"), pParam->pszLocation, pParam->pszFilename)))
            {
                EndDialog(hDlg, -1);
                return TRUE;
            }
            if (SHGetFileInfo(szStr, 0, &sfi, sizeof(sfi), SHGFI_ICON | SHGFI_LARGEICON))
                SendDlgItemMessage(hDlg, IDI_DOCICON, STM_SETICON, (WPARAM)sfi.hIcon, 0L);
            
            // Set initial selection
            CheckRadioButton(hDlg, IDC_KEEPBOTH, IDC_KEEPNETWORK, IDC_KEEPBOTH);
            if (pParam->hIKeepBoth)
                SendDlgItemMessage(hDlg, IDB_BIGICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM)pParam->hIKeepBoth);
            
            // Format and set the strings
            LoadString(g_hmodThisDll, IDS_NAMEANDLOCATION, szFmt, ARRAYSIZE(szFmt));
            if (FAILED(StringCchPrintf(szStr, ARRAYSIZE(szStr), szFmt, pParam->pszFilename, pParam->pszLocation)))
            {
                EndDialog(hDlg, -1);
                return TRUE;
            }
            SetDlgItemText(hDlg,IDC_FILEANDLOCATION,szStr);
            
            if (pParam->pszNewName)
            {
                SetDlgItemText(hDlg,IDC_NEWFILENAME,pParam->pszNewName);
            }
            
            if (pParam->pszNetworkModifiedBy && pParam->pszNetworkModifiedOn &&
                lstrlen(pParam->pszNetworkModifiedBy) && lstrlen(pParam->pszNetworkModifiedOn))
            {
                // we have by and on then use them both
                LoadString(g_hmodThisDll, IDS_NETWORKMODIFIED, szFmt, ARRAYSIZE(szFmt));
                if (FAILED(StringCchPrintf(szStr, ARRAYSIZE(szStr), szFmt, pParam->pszNetworkModifiedBy, pParam->pszNetworkModifiedOn)))
                {
                    EndDialog(hDlg, -1);
                    return TRUE;
                }
            }
            else if ((pParam->pszNetworkModifiedBy && lstrlen(pParam->pszNetworkModifiedBy)) &&
                (!pParam->pszNetworkModifiedOn || !lstrlen(pParam->pszNetworkModifiedOn)))
            {
                // We have the name but no date
                TCHAR szTemp[MAX_PATH];
                LoadString(g_hmodThisDll, IDS_UNKNOWNDATE, szTemp, ARRAYSIZE(szTemp));
                LoadString(g_hmodThisDll, IDS_NETWORKMODIFIED, szFmt, ARRAYSIZE(szFmt));
                if (FAILED(StringCchPrintf(szStr, ARRAYSIZE(szStr), szFmt, pParam->pszNetworkModifiedBy, szTemp)))
                {
                    EndDialog(hDlg, -1);
                    return TRUE;
                }
            }
            else if ((!pParam->pszNetworkModifiedBy || !lstrlen(pParam->pszNetworkModifiedBy)) &&
                (pParam->pszNetworkModifiedOn && lstrlen(pParam->pszNetworkModifiedOn)))
            {
                // We have the date but no name
                LoadString(g_hmodThisDll, IDS_NETWORKMODIFIED_DATEONLY, szFmt, ARRAYSIZE(szFmt));
                if (FAILED(StringCchPrintf(szStr, ARRAYSIZE(szStr), szFmt, pParam->pszNetworkModifiedOn)))
                {
                    EndDialog(hDlg, -1);
                    return TRUE;
                }
            }
            else
                // we do not have on or by, use the unknown
                LoadString(g_hmodThisDll, IDS_NONETINFO, szStr, ARRAYSIZE(szStr));
            
            SetDlgItemText(hDlg,IDC_NETWORKMODIFIED,szStr);
            
            if (pParam->pszLocalModifiedBy && pParam->pszLocalModifiedOn &&
                lstrlen(pParam->pszLocalModifiedBy) && lstrlen(pParam->pszLocalModifiedOn))
            {
                // we have by and on then use them both
                LoadString(g_hmodThisDll, IDS_LOCALMODIFIED, szFmt, ARRAYSIZE(szFmt));
                if (FAILED(StringCchPrintf(szStr, ARRAYSIZE(szStr), szFmt, pParam->pszLocalModifiedBy, pParam->pszLocalModifiedOn)))
                {
                    EndDialog(hDlg, -1);
                    return TRUE;
                }
            }
            else if ((pParam->pszLocalModifiedBy && lstrlen(pParam->pszLocalModifiedBy)) &&
                (!pParam->pszLocalModifiedOn || !lstrlen(pParam->pszLocalModifiedOn)))
            {
                // We have the name but no date
                TCHAR szTemp[MAX_PATH];
                LoadString(g_hmodThisDll, IDS_UNKNOWNDATE, szTemp, ARRAYSIZE(szTemp));
                LoadString(g_hmodThisDll, IDS_LOCALMODIFIED, szFmt, ARRAYSIZE(szFmt));
                if (FAILED(StringCchPrintf(szStr, ARRAYSIZE(szStr), szFmt, pParam->pszLocalModifiedBy, szTemp)))
                {
                    EndDialog(hDlg, -1);
                    return TRUE;
                }
            }
            else if ((!pParam->pszLocalModifiedBy || !lstrlen(pParam->pszLocalModifiedBy)) &&
                (pParam->pszLocalModifiedOn && lstrlen(pParam->pszLocalModifiedOn)))
            {
                // We have the date but no name
                LoadString(g_hmodThisDll, IDS_LOCALMODIFIED_DATEONLY, szFmt, ARRAYSIZE(szFmt));
                if (FAILED(StringCchPrintf(szStr, ARRAYSIZE(szStr), szFmt, pParam->pszLocalModifiedOn)))
                {
                    EndDialog(hDlg, -1);
                    return TRUE;
                }
            }
            else
                // we do not have on or by, use the unknown
                LoadString(g_hmodThisDll, IDS_NOLOCALINFO, szStr, ARRAYSIZE(szStr));
            
            SetDlgItemText(hDlg,IDC_LOCALMODIFIED,szStr);
            
            // If there is no call back function, don't show the view buttons.
            if (!pParam->pfnCallBack)
            {
                HWND hWndButton = GetDlgItem(hDlg, IDC_VIEWLOCAL);
                ShowWindow(hWndButton, SW_HIDE);
                EnableWindow(hWndButton, FALSE);
                hWndButton = GetDlgItem(hDlg, IDC_VIEWNETWORK);
                ShowWindow(hWndButton, SW_HIDE);
                EnableWindow(hWndButton, FALSE);
            }
            
            // Hide the "Apply to all" checkbox if caller doesn't want it.
            if (!(RFCF_APPLY_ALL & pParam->dwFlags))
            {
                HWND hWndButton = GetDlgItem(hDlg, IDC_APPLY_ALL);
                ShowWindow(hWndButton, SW_HIDE);
                EnableWindow(hWndButton, FALSE);
            }
            
            break;
        }
        
        case WM_COMMAND:
            {
                int id = LOWORD(wParam);
                
                switch (id)
                {
                case IDCANCEL:
                    EndDialog(hDlg, RFC_CANCEL);
                    break;
                    
                case IDOK:
                    {
                        int nRet = RFC_KEEPBOTH;
                        
                        if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_KEEPBOTH))
                            nRet = RFC_KEEPBOTH;
                        else if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_KEEPLOCAL))
                            nRet = RFC_KEEPLOCAL;
                        else if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_KEEPNETWORK))
                            nRet = RFC_KEEPNETWORK;
                        
                        if (pParam && (RFCF_APPLY_ALL & pParam->dwFlags) &&
                            BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_APPLY_ALL))
                        {
                            nRet |= RFC_APPLY_TO_ALL;
                        }
                        
                        EndDialog(hDlg, nRet);
                        break;
                    }
                    
                case IDC_KEEPBOTH:
                case IDC_KEEPLOCAL:
                case IDC_KEEPNETWORK:
                    {
                        HICON hITemp;
                        
                        if (!pParam)
                            break;
                        
                        if (IDC_KEEPBOTH == id)
                            hITemp = pParam->hIKeepBoth;
                        else if (IDC_KEEPLOCAL == id)
                            hITemp = pParam->hIKeepLocal;
                        else
                            hITemp = pParam->hIKeepNetwork;
                        
                        SendDlgItemMessage(hDlg, IDB_BIGICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM)hITemp);
                        break;
                    }
                    
                case IDC_VIEWLOCAL:
                    if (pParam)
                        pParam->pfnCallBack(hDlg, RFCCM_VIEWLOCAL, 0, (pParam->dwFlags & RFC_THUNK_DATA) ? pParam->lCallerData : (LPARAM)pParam);
                    break;
                    
                case IDC_VIEWNETWORK:
                    if (pParam)
                        pParam->pfnCallBack(hDlg, RFCCM_VIEWNETWORK, 0, (pParam->dwFlags & RFC_THUNK_DATA) ? pParam->lCallerData : (LPARAM)pParam);
                    break;
                    
                default:
                    return FALSE;
                }
                break;
            }
            
        default:
            return FALSE;
    }
    return TRUE;
}

int WINAPI SyncMgrResolveConflictA(HWND hWndParent, RFCDLGPARAMA *pdlgParam)
{
    USES_CONVERSION;
    RFCDLGPARAMW dlgPW={0};
    
    dlgPW.dwFlags = pdlgParam->dwFlags | RFC_THUNK_DATA;
    dlgPW.hIKeepBoth = pdlgParam->hIKeepBoth;
    dlgPW.hIKeepLocal = pdlgParam->hIKeepLocal;
    dlgPW.hIKeepNetwork = pdlgParam->hIKeepNetwork;
    dlgPW.pfnCallBack = pdlgParam->pfnCallBack;
    dlgPW.lCallerData = (LPARAM)pdlgParam;
    
    dlgPW.pszFilename = A2CW(pdlgParam->pszFilename);
    dlgPW.pszLocation = A2CW(pdlgParam->pszLocation);
    dlgPW.pszNewName = A2CW(pdlgParam->pszNewName);
    dlgPW.pszNetworkModifiedBy = A2CW(pdlgParam->pszNetworkModifiedBy);
    dlgPW.pszNetworkModifiedOn = A2CW(pdlgParam->pszNetworkModifiedOn);
    dlgPW.pszLocalModifiedBy = A2CW(pdlgParam->pszLocalModifiedBy);
    dlgPW.pszLocalModifiedOn = A2CW(pdlgParam->pszLocalModifiedOn);
    
    return SyncMgrResolveConflictW(hWndParent, &dlgPW);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\dll\confres.h ===
#ifndef _CONFRES_H_
#define _CONFRES_H_

// If we require any of the elements in the dialog box, we can call the
// caller back via the callback function and specify what we want
// (This has not yet been implemented)
#define RFCD_NAME                0x0001
#define RFCD_KEEPBOTHICON        0x0002
#define RFCD_KEEPLOCALICON       0x0004
#define RFCD_KEEPSERVERICON      0x0008
#define RFCD_NETWORKMODIFIEDBY   0x0010
#define RFCD_NETWORKMODIFIEDON   0x0020
#define RFCD_LOCALMODIFIEDBY     0x0040
#define RFCD_LOCALMODIFIEDON     0x0080
#define RFCD_NEWNAME             0x0100
#define RFCD_LOCATION            0x0200
#define RFCD_ALL                 0x03FF

// User clicks the view button. This is the message sent to the caller
// via the callback
#define RFCCM_VIEWLOCAL          0x0001   
#define RFCCM_VIEWNETWORK        0x0002
#define RFCCM_NEEDELEMENT        0x0003

// Return values
#define RFC_KEEPBOTH             0x01
#define RFC_KEEPLOCAL            0x02
#define RFC_KEEPNETWORK          0x03

typedef INT_PTR CALLBACK (*PFNRFCDCALLBACK)(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

typedef struct tagRFCDLGPARAMW {
    DWORD   dwFlags;                // currently unused.. 
    LPCWSTR  pszFilename;            // File name of the file conflicted
    LPCWSTR  pszLocation;            // Location of the file
    LPCWSTR  pszNewName;             // The  new name to give the file
    LPCWSTR  pszNetworkModifiedBy;   // Name of person who changed the net doc
    LPCWSTR  pszLocalModifiedBy;     // Name of person who changed the local doc
    LPCWSTR  pszNetworkModifiedOn;   // When the net doc was changed
    LPCWSTR  pszLocalModifiedOn;     // Whent the local doc was changed
    HICON    hIKeepBoth;             // Icon
    HICON    hIKeepLocal;            //
    HICON    hIKeepNetwork;          //
    PFNRFCDCALLBACK pfnCallBack;    // Callback
    LPARAM  lCallerData;            // Place where the caller can keep some context data
} RFCDLGPARAMW;

typedef struct tagRFCDLGPARAMA {
    DWORD   dwFlags;                // currently unused.. 
    LPCSTR  pszFilename;            // File name of the file conflicted
    LPCSTR  pszLocation;            // Location of the file
    LPCSTR  pszNewName;             // The  new name to give the file
    LPCSTR  pszNetworkModifiedBy;   // Name of person who changed the net doc
    LPCSTR  pszLocalModifiedBy;     // Name of person who changed the local doc
    LPCSTR  pszNetworkModifiedOn;   // When the net doc was changed
    LPCSTR  pszLocalModifiedOn;     // Whent the local doc was changed
    HICON   hIKeepBoth;             // Icon
    HICON   hIKeepLocal;            //
    HICON   hIKeepNetwork;          //
    PFNRFCDCALLBACK pfnCallBack;    // Callback
    LPARAM  lCallerData;            // Place where the caller can keep some context data
} RFCDLGPARAMA;

int WINAPI SyncMgrResolveConflictW(HWND hWndParent, RFCDLGPARAMW *pdlgParam);
int WINAPI SyncMgrResolveConflictA(HWND hWndParent, RFCDLGPARAMA *pdlgParam);

#define SyncMgrResolveConflict SyncMgrResolveConflictW
#define RFCDLGPARAM RFCDLGPARAMW

#endif  // _CONFRES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\dll\cnetapi.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       cnetapi.cpp
//
//  Contents:   Network/SENS API wrappers
//
//  Classes:
//
//  Notes:
//
//  History:    08-Dec-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

// SENS DLL and function strings
const WCHAR c_szSensApiDll[] = TEXT("SensApi.dll");
STRING_INTERFACE(szIsNetworkAlive,"IsNetworkAlive");

// RAS Dll and Function Strings
const WCHAR c_szRasDll[] = TEXT("RASAPI32.DLL");

// RAS function strings
STRING_INTERFACE(szRasEnumConnectionsW,"RasEnumConnectionsW");
STRING_INTERFACE(szRasEnumConnectionsA,"RasEnumConnectionsA");
STRING_INTERFACE(szRasEnumEntriesA,"RasEnumEntriesA");
STRING_INTERFACE(szRasEnumEntriesW,"RasEnumEntriesW");
STRING_INTERFACE(szRasGetEntryPropertiesW,"RasGetEntryPropertiesW");
STRING_INTERFACE(szRasGetErrorStringW,"RasGetErrorStringW");
STRING_INTERFACE(szRasGetErrorStringA,"RasGetErrorStringA");
STRING_INTERFACE(szRasGetAutodialParam, "RasGetAutodialParamA");
STRING_INTERFACE(szRasSetAutodialParam, "RasSetAutodialParamA");

// wininet declarations
// warning - IE 4.0 only exported InternetDial which was ANSI. IE5 has InternetDailA and
// internetDialW. we always use InternetDial for Ansi. So we prefere InternetDialW but
// must fall back to ANSI for IE 4.0
const WCHAR c_szWinInetDll[] = TEXT("WININET.DLL");

STRING_INTERFACE(szInternetDial,"InternetDial");
STRING_INTERFACE(szInternetDialW,"InternetDialW");
STRING_INTERFACE(szInternetHangup,"InternetHangUp");
STRING_INTERFACE(szInternetAutodial,"InternetAutodial");
STRING_INTERFACE(szInternetAutodialHangup,"InternetAutodialHangup");
STRING_INTERFACE(szInternetQueryOption,"InternetQueryOptionA"); // always use the A Version
STRING_INTERFACE(szInternetSetOption,"InternetSetOptionA"); // always use A Version

// SENS install key under HKLM
const WCHAR wszSensInstallKey[]  = TEXT("Software\\Microsoft\\Mobile\\Sens");

//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::CNetApi, public
//
//  Synopsis:   Constructor
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    08-Dec-97       rogerg        Created.
//
//----------------------------------------------------------------------------

CNetApi::CNetApi()
{
    m_fTriedToLoadSens = FALSE;
    m_hInstSensApiDll = NULL;
    m_pIsNetworkAlive = NULL;
    
    m_fTriedToLoadRas = FALSE;
    m_hInstRasApiDll = NULL;
    m_pRasEnumConnectionsW = NULL;
    m_pRasEnumConnectionsA = NULL;
    m_pRasEnumEntriesA = NULL;
    m_pRasEnumEntriesW = NULL;
    m_pRasGetEntryPropertiesW = NULL;
    
    m_pRasGetErrorStringW = NULL;
    m_pRasGetErrorStringA = NULL;
    m_pRasGetAutodialParam = NULL;
    m_pRasSetAutodialParam = NULL;
    
    m_fTriedToLoadWinInet = FALSE;
    m_hInstWinInetDll = NULL;
    m_pInternetDial = NULL;
    m_pInternetDialW = NULL;
    m_pInternetHangUp = NULL;
    m_pInternetAutodial = NULL;
    m_pInternetAutodialHangup = NULL;
    m_pInternetQueryOption = NULL;
    m_pInternetSetOption = NULL;
    
    m_cRefs = 1;
}


//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::~CNetApi, public
//
//  Synopsis:   Destructor
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    08-Dec-97       rogerg        Created.
//
//----------------------------------------------------------------------------

CNetApi::~CNetApi()
{
    Assert(0 == m_cRefs); 
    
    if (NULL != m_hInstSensApiDll)
    {
        FreeLibrary(m_hInstSensApiDll);
    }
    
    if (NULL != m_hInstWinInetDll)
    {
        FreeLibrary(m_hInstWinInetDll);
    }
    
    if (NULL != m_hInstRasApiDll)
    {
        FreeLibrary(m_hInstWinInetDll);
    }
    
}

//+-------------------------------------------------------------------------
//
//  Method:     CNetApi::QueryInterface
//
//  Synopsis:   Increments refcount
//
//  History:    31-Jul-1998      SitaramR       Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CNetApi::QueryInterface( REFIID, LPVOID* )
{
    AssertSz(0,"E_NOTIMPL");
    return E_NOINTERFACE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CNetApiXf
//
//  Synopsis:   Increments refcount
//
//  History:    31-Jul-1998      SitaramR       Created
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG)  CNetApi::AddRef()
{
    DWORD dwTmp = InterlockedIncrement( (long *) &m_cRefs );
    
    return dwTmp;
}

//+-------------------------------------------------------------------------
//
//  Method:     CNetApi::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    31-Jul-1998     SitaramR        Created
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG)  CNetApi::Release()
{
    Assert( m_cRefs > 0 );
    
    DWORD dwTmp = InterlockedDecrement( (long *) &m_cRefs );
    
    if ( 0 == dwTmp )
        delete this;
    
    return dwTmp;
}


//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::LoadSensDll
//
//  Synopsis:   Trys to Load Sens Library.
//
//  Arguments:
//
//  Returns:    NOERROR if successfull.
//
//  Modifies:
//
//  History:    08-Dec-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CNetApi::LoadSensDll()
{
    HRESULT hr = S_FALSE;
    
    if (m_fTriedToLoadSens)
    {
        return m_hInstSensApiDll ? NOERROR : S_FALSE;
    }
    
    CLock lock(this);
    lock.Enter();
    
    if (!m_fTriedToLoadSens)
    {
        Assert(NULL == m_hInstSensApiDll);
        m_hInstSensApiDll = LoadLibrary(c_szSensApiDll);
        
        if (m_hInstSensApiDll)
        {
            // for now, don't return an error is GetProc Fails but check in each function.
            m_pIsNetworkAlive = (ISNETWORKALIVE)
                GetProcAddress(m_hInstSensApiDll, szIsNetworkAlive);
        }
        
        if (NULL == m_hInstSensApiDll  
            || NULL == m_pIsNetworkAlive)
        {
            hr = S_FALSE;
            
            if (m_hInstSensApiDll)
            {
                FreeLibrary(m_hInstSensApiDll);
                m_hInstSensApiDll = NULL;
            }
        }
        else
        {
            hr = NOERROR;
        }
        
        m_fTriedToLoadSens = TRUE; // set after all initialization is done.
        
    }
    else
    {
        hr = m_hInstSensApiDll ? NOERROR : S_FALSE;
    }
    
    lock.Leave();
    
    return hr; 
}


//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::IsNetworkAlive, public
//
//  Synopsis:   Calls the Sens IsNetworkAlive API.
//
//  Arguments:
//
//  Returns:    IsNetworkAlive results or FALSE is failed to load
//              sens or import.
//
//  Modifies:
//
//  History:    08-Dec-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(BOOL) CNetApi::IsNetworkAlive(LPDWORD lpdwFlags)
{
    //
    // Sens load fail is not an error
    //
    LoadSensDll();
    
    BOOL fResult = FALSE;
    
    if (NULL == m_pIsNetworkAlive)
    {
        DWORD cbNumEntries;
        RASCONN *pWanConnections;
        
        // if couldn't load export see if there are any WAN Connections.
        if (NOERROR == GetWanConnections(&cbNumEntries,&pWanConnections))
        {
            if (cbNumEntries)
            {
                fResult  = TRUE;
                *lpdwFlags = NETWORK_ALIVE_WAN;
            }
            
            if (pWanConnections)
            {
                FreeWanConnections(pWanConnections);
            }
        }
        
        // for testing without sens
        //    fResult  = TRUE;
        //   *lpdwFlags |= NETWORK_ALIVE_LAN;
        // end of testing without sens
    }
    else
    {
        fResult = m_pIsNetworkAlive(lpdwFlags);
        
    }
    
    return fResult;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::IsSensInstalled, public
//
//  Synopsis:   Determines if SENS is installed on the System.
//
//  Arguments:
//
//  Returns:   TRUE if sens is installed
//
//  Modifies:
//
//  History:    12-Aug-98      Kyle        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(BOOL) CNetApi::IsSensInstalled(void)
{
    HKEY hkResult;
    BOOL fResult = FALSE;
    
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,wszSensInstallKey,0,
        KEY_READ,&hkResult))
    {
        fResult = TRUE;
        RegCloseKey(hkResult);
    }
    
    return fResult;
}


//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::GetWanConnections, public
//
//  Synopsis:   returns an array of Active Wan connections.
//              up to the caller to free RasEntries structure when done.
//
//  Arguments:  [out] [cbNumEntries] - Number of Connections found
//              [out] [pWanConnections] - Array of Connections found.
//
//  Returns:    IsNetworkAlive results or FALSE is failed to load
//              sens or import.
//
//  Modifies:
//
//  History:    08-Dec-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CNetApi::GetWanConnections(DWORD *cbNumEntries,RASCONN **pWanConnections)
{
    DWORD dwError = -1;
    DWORD dwSize;
    DWORD cConnections;
    
    *pWanConnections = NULL;
    *pWanConnections = 0;
    
    LPRASCONN lpRasConn;
    dwSize = sizeof(RASCONN);
    
    lpRasConn = (LPRASCONN) ALLOC(dwSize);
    
    if(lpRasConn)
    {
        lpRasConn->dwSize = sizeof(RASCONN);
        cConnections = 0;
        
        dwError = RasEnumConnections(lpRasConn, &dwSize, &cConnections);
        
        if (dwError == ERROR_BUFFER_TOO_SMALL)
        {
            dwSize = lpRasConn->dwSize; // get size needed
            
            FREE(lpRasConn);
            
            lpRasConn =  (LPRASCONN) ALLOC(dwSize);
            if(lpRasConn)
            {
                lpRasConn->dwSize = sizeof(RASCONN);
                cConnections = 0;
                dwError = RasEnumConnections(lpRasConn, &dwSize, &cConnections);
            }
        }
    }
    
    if (!dwError && lpRasConn)
    {
        *cbNumEntries = cConnections;
        *pWanConnections = lpRasConn;
        return NOERROR;
    }
    else
    {
        if (lpRasConn)
        {
            FREE(lpRasConn);
        }
    }
    
    return S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::FreeWanConnections, public
//
//  Synopsis:   Called by caller to free up memory 
//              allocated by GetWanConnections.
//
//  Arguments:  [in] [pWanConnections] - WanConnection Array to free
//
//  Returns:    
//
//  Modifies:
//
//  History:    08-Dec-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CNetApi::FreeWanConnections(RASCONN *pWanConnections)
{
    Assert(pWanConnections);
    
    if (pWanConnections)
    {
        FREE(pWanConnections);
    }
    
    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::RasEnumConnections, public
//
//  Synopsis:   Wraps RasEnumConnections.
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:
//
//  History:    02-Aug-98      rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(DWORD) CNetApi::RasEnumConnections(LPRASCONNW lprasconn,LPDWORD lpcb,LPDWORD lpcConnections)
{
    DWORD dwReturn = -1;
    
    
    if (NOERROR != LoadRasApiDll())
        return -1;
    
    if(m_pRasEnumConnectionsW)
    {
        dwReturn = (*m_pRasEnumConnectionsW)(lprasconn,lpcb,lpcConnections);
    }
    
    return dwReturn;
    
}


//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::GetConnectionStatus, private
//
//  Synopsis:   Given a Connection Name determines if the connection
//              has already been established.
//              Also set ths WanActive flag to indicate if there are any
//              existing RAS connections.
//
//  Arguments:  [pszConnectionName] - Name of the Connection
//              [out] [fConnected] - Indicates if specified connection is currently connected.
//              [out] [fCanEstablishConnection] - Flag indicates if the connection is not found can establish it.
//
//  Returns:    NOERROR if the dll was sucessfully loaded
//
//  Modifies:
//
//  History:    08-Dec-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CNetApi::GetConnectionStatus(LPCTSTR pszConnectionName,DWORD dwConnectionType,BOOL *fConnected,BOOL *fCanEstablishConnection)
{
    *fConnected = FALSE;
    *fCanEstablishConnection = FALSE;
    
    // if this is a lan connection then see if network is alive,
    // else go through the Ras apis.
    if (CNETAPI_CONNECTIONTYPELAN == dwConnectionType)
    {
        DWORD dwFlags;
        
        if (IsNetworkAlive(&dwFlags)
            && (dwFlags & NETWORK_ALIVE_LAN) )
        {
            *fConnected = TRUE;
        }
    }
    else
    {  // check for Ras Connections.
        RASCONN *pWanConnections;
        DWORD cbNumConnections;
        
        
        if (NOERROR == GetWanConnections(&cbNumConnections,&pWanConnections))
        {
            *fCanEstablishConnection = TRUE;
            if (cbNumConnections > 0)
            {
                *fCanEstablishConnection = FALSE;
                
                // loop through the entries to see if this connection is already
                // connected.
                while (cbNumConnections)
                {
                    cbNumConnections--;
                    
                    if (0 == lstrcmp(pWanConnections[cbNumConnections].szEntryName,pszConnectionName))
                    {
                        *fConnected = TRUE;
                        break;
                    }
                }
                
            }
            
            if (pWanConnections)
            {
                FreeWanConnections(pWanConnections);
            }
            
        }
        
    }
    
    
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::RasGetErrorStringProc, public
//
//  Synopsis:   Directly calls RasGetErrorString()
//
//  Arguments:
//
//  Returns:    Appropriate Error codes
//
//  Modifies:
//
//  History:    08-Dec-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(DWORD) CNetApi::RasGetErrorStringProc( UINT uErrorValue, LPTSTR lpszErrorString,DWORD cBufSize)
{
    DWORD   dwErr = -1;
    
    
    if (NOERROR != LoadRasApiDll())
        return -1;
    
    if (m_pRasGetErrorStringW)
    {
        dwErr = m_pRasGetErrorStringW(uErrorValue,lpszErrorString,cBufSize);
    }
    
    return dwErr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::RasEnumEntries, public
//
//  Synopsis:   wraps RasEnumEntries
//
//  Arguments: 
//
//  Returns:    
//
//  Modifies:
//
//  History:    08-Aug-98       rogerg        Created.
//
//----------------------------------------------------------------------------

DWORD CNetApi::RasEnumEntries(LPWSTR reserved,LPWSTR lpszPhoneBook,
                              LPRASENTRYNAME lprasEntryName,LPDWORD lpcb,LPDWORD lpcEntries)
{
    if (NOERROR != LoadRasApiDll())
        return -1;
    
    if(m_pRasEnumEntriesW)
    {
        return (m_pRasEnumEntriesW)(reserved,lpszPhoneBook,lprasEntryName,lpcb,lpcEntries);
    }
    
    return -1;
}


//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::RasGetAutodial
//
//  Synopsis:   Gets the autodial state
//
//  Arguments:  [fEnabled] - Whether Ras autodial is enabled or disabled returned here
//
//  History:    28-Jul-98       SitaramR        Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CNetApi::RasGetAutodial( BOOL& fEnabled )
{
    //
    // In case of failures the default is to assume that Ras autodial is enabled
    //
    fEnabled = TRUE;
    
    if (NOERROR != LoadRasApiDll())
        return NOERROR;
    
    if ( m_pRasGetAutodialParam == NULL )
        return NOERROR;
    
    DWORD dwValue;
    DWORD dwSize = sizeof(dwValue);
    DWORD dwRet = m_pRasGetAutodialParam( RASADP_LoginSessionDisable,
        &dwValue,
        &dwSize );
    if ( dwRet == ERROR_SUCCESS )
    {
        Assert( dwSize == sizeof(dwValue) );
        fEnabled = (dwValue == 0);
    }
    
    return NOERROR;
}



//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::RasSetAutodial
//
//  Synopsis:   Sets the autodial state
//
//  Arguments:  [fEnabled] - Whether Ras is to be enabled or disabled
//
//  History:    28-Jul-98       SitaramR        Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CNetApi::RasSetAutodial( BOOL fEnabled )
{
    //
    // Ignore failures
    //
    if (NOERROR != LoadRasApiDll())
        return NOERROR;
    
    if ( m_pRasGetAutodialParam == NULL )
        return NOERROR;
    
    DWORD dwValue = !fEnabled;
    DWORD dwRet = m_pRasSetAutodialParam( RASADP_LoginSessionDisable,
        &dwValue,
        sizeof(dwValue) );
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::LoadRasApiDll, private
//
//  Synopsis:   If not already loaded, loads the RasApi Dll.
//
//  Arguments:
//
//  Returns:    NOERROR if the dll was sucessfully loaded
//
//  Modifies:
//
//  History:    08-Dec-97       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT CNetApi::LoadRasApiDll()
{
    HRESULT hr = S_FALSE;;
    
    if (m_fTriedToLoadRas)
    {
        return m_hInstRasApiDll ? NOERROR : S_FALSE;
    }
    
    CLock lock(this);
    lock.Enter();
    
    if (!m_fTriedToLoadRas)
    {
        Assert(NULL == m_hInstRasApiDll);
        m_hInstRasApiDll = NULL;
        
        m_hInstRasApiDll = LoadLibrary(c_szRasDll);
        
        if (m_hInstRasApiDll)
        {
            m_pRasEnumConnectionsW = (RASENUMCONNECTIONSW)
                GetProcAddress(m_hInstRasApiDll, szRasEnumConnectionsW);
            m_pRasEnumConnectionsA = (RASENUMCONNECTIONSA)
                GetProcAddress(m_hInstRasApiDll, szRasEnumConnectionsA);
            
            m_pRasEnumEntriesA = (RASENUMENTRIESPROCA) 
                GetProcAddress(m_hInstRasApiDll, szRasEnumEntriesA);
            
            m_pRasEnumEntriesW = (RASENUMENTRIESPROCW) 
                GetProcAddress(m_hInstRasApiDll, szRasEnumEntriesW);
            
            m_pRasGetEntryPropertiesW = (RASGETENTRYPROPERTIESPROC)
                GetProcAddress(m_hInstRasApiDll, szRasGetEntryPropertiesW);
            
            m_pRasGetErrorStringW = (RASGETERRORSTRINGPROCW)
                GetProcAddress(m_hInstRasApiDll, szRasGetErrorStringW);
            m_pRasGetErrorStringA = (RASGETERRORSTRINGPROCA)
                GetProcAddress(m_hInstRasApiDll, szRasGetErrorStringA);
            
            m_pRasGetAutodialParam = (RASGETAUTODIALPARAM)
                GetProcAddress(m_hInstRasApiDll, szRasGetAutodialParam);
            
            m_pRasSetAutodialParam = (RASSETAUTODIALPARAM)
                GetProcAddress(m_hInstRasApiDll, szRasSetAutodialParam);
        }
        
        
        //
        // No check for Get/SetAutodialParam because they don't exist on Win 95
        //
        if (NULL == m_hInstRasApiDll
            || NULL == m_hInstRasApiDll
            || NULL == m_pRasEnumConnectionsA
            || NULL == m_pRasGetErrorStringA
            || NULL == m_pRasEnumEntriesA
            )
        {
            
            if (m_hInstRasApiDll)
            {
                FreeLibrary(m_hInstRasApiDll);
                m_hInstRasApiDll = NULL;
            }
            
            hr = S_FALSE;
        }
        else
        {
            hr = NOERROR;
        }
        
        m_fTriedToLoadRas = TRUE; // set after all init is done.
    }
    else
    {
        hr = m_hInstRasApiDll ? NOERROR : S_FALSE;
    }
    
    lock.Leave();
    
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::LoadWinInetDll, private
//
//  Synopsis:   If not already loaded, loads the WinInet Dll.
//
//  Arguments:
//
//  Returns:    NOERROR if the dll was sucessfully loaded
//
//  Modifies:
//
//  History:    26-May-98       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT CNetApi::LoadWinInetDll()
{
    
    if (m_fTriedToLoadWinInet)
    {
        return m_hInstWinInetDll ? NOERROR : S_FALSE;
    }
    
    CLock lock(this);
    lock.Enter();
    
    HRESULT hr = NOERROR;
    
    if (!m_fTriedToLoadWinInet)
    {
        Assert(NULL == m_hInstWinInetDll);
        
        m_hInstWinInetDll = LoadLibrary(c_szWinInetDll);
        
        if (m_hInstWinInetDll)
        {
            m_pInternetDial = (INTERNETDIAL) GetProcAddress(m_hInstWinInetDll, szInternetDial);
            m_pInternetDialW = (INTERNETDIALW) GetProcAddress(m_hInstWinInetDll, szInternetDialW);
            m_pInternetHangUp = (INTERNETHANGUP) GetProcAddress(m_hInstWinInetDll, szInternetHangup);
            m_pInternetAutodial = (INTERNETAUTODIAL)  GetProcAddress(m_hInstWinInetDll, szInternetAutodial);
            m_pInternetAutodialHangup = (INTERNETAUTODIALHANGUP) GetProcAddress(m_hInstWinInetDll, szInternetAutodialHangup);
            m_pInternetQueryOption = (INTERNETQUERYOPTION)  GetProcAddress(m_hInstWinInetDll, szInternetQueryOption);
            m_pInternetSetOption = (INTERNETSETOPTION)  GetProcAddress(m_hInstWinInetDll, szInternetSetOption);
            
            // note: not an error if can't get wide version of InternetDial
            Assert(m_pInternetDial);
            Assert(m_pInternetHangUp);
            Assert(m_pInternetAutodial);
            Assert(m_pInternetAutodialHangup);
            Assert(m_pInternetQueryOption);
            Assert(m_pInternetSetOption);
        }
        
        // note: don't bail if can't get wide version of InternetDial
        if (NULL == m_hInstWinInetDll
            || NULL == m_pInternetDial
            || NULL == m_pInternetHangUp
            || NULL == m_pInternetAutodial
            || NULL == m_pInternetAutodialHangup
            || NULL == m_pInternetQueryOption
            || NULL == m_pInternetSetOption
            )
        {
            if (m_hInstWinInetDll)
            {
                FreeLibrary(m_hInstWinInetDll);
                m_hInstWinInetDll = NULL;
            }
            
            hr = S_FALSE;
        }
        else
        {
            hr = NOERROR;
        }
        
        m_fTriedToLoadWinInet = TRUE; // set after all init is done.
    }
    else
    {
        // someone took the lock before us, return the new resul
        hr = m_hInstWinInetDll ? NOERROR : S_FALSE;
    }
    
    
    
    lock.Leave();
    
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::InternetDial, private
//
//  Synopsis:   Calls the WinInet InternetDial API.
//
//  Arguments:
//
//  Returns:    -1 can't load dll
//              whatever API returns.
//
//  Modifies:
//
//  History:    26-May-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(DWORD) CNetApi::InternetDialA(HWND hwndParent,char* lpszConnectoid,DWORD dwFlags,
                                            LPDWORD lpdwConnection, DWORD dwReserved)
{
    DWORD dwRet = -1;
    
    if (NOERROR == LoadWinInetDll())
    {
        dwRet = m_pInternetDial(hwndParent,lpszConnectoid,dwFlags,lpdwConnection,dwReserved);
    }
    
    return dwRet;
}


//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::InternetDial, private
//
//  Synopsis:   Calls the WinInet InternetDial API.
//
//  Arguments:
//
//  Returns:    -1 can't load dll
//              whatever API returns.
//
//  Modifies:
//
//  History:    26-May-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(DWORD) CNetApi::InternetDialW(HWND hwndParent,WCHAR* lpszConnectoid,DWORD dwFlags,
                                            LPDWORD lpdwConnection, DWORD dwReserved)
{
    DWORD dwRet = -1;
    
    if (NOERROR == LoadWinInetDll())
    {
        if (m_pInternetDialW)
        {
            dwRet = m_pInternetDialW(hwndParent,lpszConnectoid,dwFlags,lpdwConnection,dwReserved);
        }
    }
    
    return dwRet;
}



//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::InternetHangUp, private
//
//  Synopsis:   Calls the WinInet InternetHangUp API.
//
//  Arguments:
//
//  Returns:    -1 can't load dll
//              whatever API returns.
//
//  Modifies:
//
//  History:    26-May-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(DWORD) CNetApi::InternetHangUp(DWORD dwConnection,DWORD dwReserved)
{
    DWORD dwRet = -1;
    
    if (NOERROR == LoadWinInetDll())
    {
        dwRet = m_pInternetHangUp(dwConnection,dwReserved);
    }
    
    return dwRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::InternetAutodial, private
//
//  Synopsis:   Calls the WinInet InternetAutodial API.
//
//  Arguments:
//
//  Returns:    TRUE if connection was established.
//
//  Modifies:
//
//  History:    26-May-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(BOOL)  WINAPI CNetApi::InternetAutodial(DWORD dwFlags,DWORD dwReserved)
{
    BOOL fRet = FALSE;
    
    if (NOERROR == LoadWinInetDll())
    {
        fRet = m_pInternetAutodial(dwFlags,dwReserved);
    }
    
    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::InternetAutodialHangup, private
//
//  Synopsis:   Calls the WinInet InternetAutodialHangup API.
//
//  Arguments:
//
//  Returns:   TRUE if hangup was successful.
//
//  Modifies:
//
//  History:    26-May-98       rogerg        Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP_(BOOL)  WINAPI CNetApi::InternetAutodialHangup(DWORD dwReserved)
{
    BOOL fRet = FALSE;
    
    if (NOERROR == LoadWinInetDll())
    {
        fRet = m_pInternetAutodialHangup(dwReserved);
    }
    
    return fRet;
}


//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::InternetGetAutoDial
//
//  Synopsis:   Gets the wininet autodial state
//
//  Arguments:  [fDisabled] - Whether autodial is enabled or disabled
//
//  History:    28-Jul-98       SitaramR        Created
//              22-Mar-02       BrianAu         Use autodial mode.
//
//----------------------------------------------------------------------------

STDMETHODIMP CNetApi::InternetGetAutodial(DWORD *pdwMode)
{
    //
    // In case of failures use the same default as used in wininet.
    //
    *pdwMode = AUTODIAL_MODE_NO_NETWORK_PRESENT;

    HRESULT hr = _InternetGetAutodialFromWininet(pdwMode);
    if (FAILED(hr))
    {
        hr = _InternetGetAutodialFromRegistry(pdwMode);
    }
    //
    // Don't return a failure value.  The caller should always
    // receive a mode value.  If the caller wishes, they can check for 
    // S_OK vs. S_FALSE to know if they're getting a default or not.
    //
    return SUCCEEDED(hr) ? S_OK : S_FALSE;
}


//
// Obtains the current Internet Autodial mode from wininet.
// Returns:
//    S_OK    - Mode value obtained and returned.
//    E_FAIL  - Mode value not obtained.  Most likely, this particular option query 
//              is not supported on the installed version of wininet.
//
HRESULT CNetApi::_InternetGetAutodialFromWininet(DWORD *pdwMode)
{
    if (NOERROR == LoadWinInetDll())
    {
        DWORD dwMode;
        DWORD dwSize = sizeof(dwMode);
        if (m_pInternetQueryOption(NULL, INTERNET_OPTION_AUTODIAL_MODE, &dwMode, &dwSize))
        {
            //
            // InternetQueryOption( .. AUTODIAL .. ) is available on IE 5 only
            //
            *pdwMode = dwMode;
            return S_OK;
        }
    }
    return E_FAIL;
}


//
// Reads the Internet Autodial mode from the registry.
// This function effectively duplicates InternetQueryOption(INTERNET_OPTION_AUTODIAL_MODE).
//
// Returns:
//    S_OK    - Settings key was opened and a mode value has been returned.
//    Error   - No mode value returned.  One of the following happened:
//                 a. Settings key not opened.
//                 b. Key opened but no "EnableAutodial" or NoNetAutodial" values found.
//
HRESULT CNetApi::_InternetGetAutodialFromRegistry(DWORD *pdwMode)
{
    HRESULT hr = E_FAIL;
    HKEY hkey;
    LONG lr = RegOpenKeyEx(HKEY_CURRENT_USER,
                           REGSTR_PATH_INTERNET_SETTINGS,
                           NULL,
                           KEY_READ,
                           &hkey);
    if (ERROR_SUCCESS == lr)
    {
        DWORD dwType;
        DWORD dwValue;
        DWORD dwSize = sizeof(dwValue);
        lr = RegQueryValueEx(hkey,
                             REGSTR_VAL_ENABLEAUTODIAL,
                             NULL,
                             &dwType,
                             (BYTE *)&dwValue,
                             &dwSize);

        if ((ERROR_SUCCESS != lr) || (0 == dwValue))
        {
            *pdwMode = AUTODIAL_MODE_NEVER;
            hr = S_OK;
        }
        else
        {
            dwSize = sizeof(dwValue);
            lr = RegQueryValueEx(hkey,
                                 REGSTR_VAL_NONETAUTODIAL,
                                 NULL,
                                 &dwType,
                                 (BYTE *)&dwValue,
                                 &dwSize);
                                 
            if ((ERROR_SUCCESS != lr) || (0 == dwValue))
            {
                *pdwMode = AUTODIAL_MODE_ALWAYS;
                hr = S_OK;
            }
        }
        RegCloseKey(hkey);
    }
    if (S_OK != hr)
    {
        hr = HRESULT_FROM_WIN32(lr);
    }
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::InternetSetAutoDial
//
//  Synopsis:   Sets the wininet autodial state
//
//  Arguments:  [fEnabled] - Whether autodial is to be enabled or disabled
//
//  History:    28-Jul-98       SitaramR        Created
//              22-Mar-02       BrianAu         Use autodial mode.
//
//----------------------------------------------------------------------------

STDMETHODIMP CNetApi::InternetSetAutodial( DWORD dwMode )
{
    HRESULT hr = _InternetSetAutodialViaWininet(dwMode);
    if (FAILED(hr))
    {
        hr = _InternetSetAutodialViaRegistry(dwMode);
    }
    return hr;
}

//
// Sets the Internet Autodial mode value using Wininet.
// Returns:
//    S_OK    - Mode successfully written.
//    E_FAIL  - Mode not successfully written.  Likely because this particular
//              internet option is not available on loaded version of wininet.
//   
HRESULT CNetApi::_InternetSetAutodialViaWininet(DWORD dwMode)
{
    if (NOERROR == LoadWinInetDll())
    {
        if (m_pInternetSetOption(NULL, INTERNET_OPTION_AUTODIAL_MODE, &dwMode, sizeof(dwMode)))
        {
            //
            // InternetSetOption( .. AUTODIAL .. ) is available on IE 5 only
            //
            return S_OK;
        }
    }
    return E_FAIL;
}


//
// Sets the Internet Autodial mode value using the registry.
// Returns:
//     S_OK   - Mode value(s) set.
//     Error  - One or more mode value(s) not set.
//
// Note that we refer to "value(s)" plural.  This mode setting is represented
// by two registry values; "enabled" and "no net".  It is unlikely but possible
// that the function could set "enabled" but not "no net".  
//
HRESULT CNetApi::_InternetSetAutodialViaRegistry(DWORD dwMode)
{
    HKEY  hkey;
    LONG lr = RegOpenKeyEx(HKEY_CURRENT_USER,
                           REGSTR_PATH_INTERNET_SETTINGS,
                           NULL,
                           KEY_READ | KEY_WRITE,
                           &hkey);
   
    if (ERROR_SUCCESS == lr)
    {
        DWORD dwEnable = 0;
        DWORD dwNonet  = 0;

        switch(dwMode)
        {
            case AUTODIAL_MODE_NEVER:
                //
                // Use defaults of "no enable", "no net".
                //
                break;
                
            case AUTODIAL_MODE_NO_NETWORK_PRESENT:
                dwNonet = 1;
                //
                // Fall through...
                //
            case AUTODIAL_MODE_ALWAYS:
                dwEnable = 1;
                break;
                
            default:
                lr = ERROR_INVALID_PARAMETER;
                break;
        }
        if (ERROR_SUCCESS == lr)
        {
            lr = RegSetValueEx(hkey,
                               REGSTR_VAL_ENABLEAUTODIAL,
                               NULL,
                               REG_DWORD,
                               (BYTE *)&dwEnable,
                               sizeof(dwEnable));

            if (ERROR_SUCCESS == lr)
            {
                lr = RegSetValueEx(hkey,
                                   REGSTR_VAL_NONETAUTODIAL,
                                   NULL,
                                   REG_DWORD,
                                   (BYTE *)&dwNonet,
                                   sizeof(dwNonet));
            }                                   
        }   
        RegCloseKey(hkey);
    }
    return HRESULT_FROM_WIN32(lr);
}


//+-------------------------------------------------------------------
//
//  Function: IsGlobalOffline
//
//  Synopsis:  Determines if in WorkOffline State
//
//  Arguments: 
//
//  Notes: Code Provided by DarrenMi
//
//
//  History:  
//
//--------------------------------------------------------------------


STDMETHODIMP_(BOOL) CNetApi::IsGlobalOffline(void)
{
    DWORD   dwState = 0, dwSize = sizeof(dwState);
    BOOL    fRet = FALSE;
    
    LoadWinInetDll();
    
    if (NULL == m_pInternetQueryOption)
    {
        Assert(m_pInternetQueryOption)
            return FALSE; // USUAL NOT OFFLINE
    }
    
    if(m_pInternetQueryOption(NULL, INTERNET_OPTION_CONNECTED_STATE, &dwState,
        &dwSize))
    {
        if(dwState & INTERNET_STATE_DISCONNECTED_BY_USER)
            fRet = TRUE;
    }
    
    return fRet;
}

//+-------------------------------------------------------------------
//
//  Function:    SetOffline
//
//  Synopsis:  Sets the WorkOffline state to on or off.
//
//  Arguments: 
//
//  Notes: Code Provided by DarrenMi
//
//
//  History:  
//
//--------------------------------------------------------------------


STDMETHODIMP_(BOOL)  CNetApi::SetOffline(BOOL fOffline)
{    
    INTERNET_CONNECTED_INFO ci;
    BOOL fReturn = FALSE;
    
    LoadWinInetDll();
    
    if (NULL == m_pInternetSetOption)
    {
        Assert(m_pInternetSetOption);
        return FALSE;
    }
    
    ZeroMemory(&ci, sizeof(ci));
    
    if(fOffline) {
        ci.dwConnectedState = INTERNET_STATE_DISCONNECTED_BY_USER;
        ci.dwFlags = ISO_FORCE_DISCONNECTED;
    } else {
        ci.dwConnectedState = INTERNET_STATE_CONNECTED;
    }
    
    fReturn = m_pInternetSetOption(NULL, INTERNET_OPTION_CONNECTED_STATE, &ci, sizeof(ci));
    
    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\dll\dll.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       Dll.h
//
//  Contents:   Main Dll api and Class Factory interface
//
//  Classes:    CClassFactory
//
//  Notes:      
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------
                                  
#ifndef _ONESTOPDLL_H
#define _ONESTOPDLL_H


class CClassFactory : public IClassFactory
{
protected:
	ULONG	m_cRef;

public:
	CClassFactory();
	~CClassFactory();

	//IUnknown members
	STDMETHODIMP		QueryInterface(REFIID, LPVOID FAR *);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	//IClassFactory members
	STDMETHODIMP		CreateInstance(LPUNKNOWN, REFIID, LPVOID FAR *);
	STDMETHODIMP		LockServer(BOOL);

};
typedef CClassFactory *LPCClassFactory;

// todo: need helper functions for creating and releasing
// structure so each function doesn't have to call it.

#ifdef _UNUSED

class COneStopDllObject : public IServiceProvider
{
private:   
	ULONG m_cRef;
public:
	COneStopDllObject();
	~COneStopDllObject();

	//IUnknown members
	STDMETHODIMP		QueryInterface(REFIID, LPVOID FAR *);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// IServiceProvider Methods
	STDMETHODIMP QueryService(REFGUID guidService,REFIID riid,void** ppv);
};
typedef COneStopDllObject *LPCOneStopDllObject;

#endif // _UNUSED

#endif // _ONESTOPDLL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\dll\dllsz.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       dllsz.c
//
//  Contents:   SyncMgr dll string constants
//
//  History:    18-Feb-98   SusiA      Created.
//
//--------------------------------------------------------------------------

#include <windows.h>


const WCHAR SZ_REGISTRYMUTEXNAME[] =  TEXT("{6295DF2D-35EE-11d1-8707-00C04FD93327}RegistryMutex");
const WCHAR SZ_SCHEDULEMUTEXNAME[] =  TEXT("{6295DF2D-35EE-11d1-8707-00C04FD93327}ScheduleMutex");
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\dll\daily.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//  
//  File:       daily.cxx
//
//  Contents:   Task wizard Onestop daily selection property page implementation.
//
//  Classes:    CSelectDailyPage
//
//  History:    11-21-1997   SusiA   
//
//---------------------------------------------------------------------------

#include "precomp.h"

CSelectDailyPage *g_pDailyPage = NULL;
extern CSelectItemsPage *g_pSelectItemsPage;

//+-------------------------------------------------------------------------------
//  FUNCTION: SchedWizardDailyDlgProc(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE: Callback dialog procedure for the property page
//
//  PARAMETERS:
//    hDlg      - Dialog box window handle
//    uMessage  - current message
//    wParam    - depends on message
//    lParam    - depends on message
//
//  RETURN VALUE:
//
//    Depends on message.  In general, return TRUE if we process it.
//
//  COMMENTS:
//
//  HISTORY:    12-08-1997   SusiA      Created  
//
//--------------------------------------------------------------------------------
INT_PTR CALLBACK SchedWizardDailyDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    WORD wNotifyCode = HIWORD(wParam); // notification code
    
    switch (uMessage)
    {
    case WM_INITDIALOG:
        if (g_pDailyPage)
            g_pDailyPage->Initialize(hDlg);
        
        InitPage(hDlg,lParam);
        break;
        
    case WM_PAINT:
        WmPaint(hDlg, uMessage, wParam, lParam);
        break;
        
    case WM_PALETTECHANGED:
        WmPaletteChanged(hDlg, wParam);
        break;
        
    case WM_QUERYNEWPALETTE:
        return( WmQueryNewPalette(hDlg) );
        break;
        
    case WM_ACTIVATE:
        return( WmActivate(hDlg, wParam, lParam) );
        break;
        
    case WM_COMMAND:
        return g_pDailyPage->OnCommand(hDlg,
            LOWORD(wParam),  // item, control, or acce
            HIWORD(wParam)); // notification code
        break;
        
    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code) 
        {
            
        case PSN_KILLACTIVE:
            SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, FALSE);
            return 1;
            break;
            
        case PSN_RESET:
            // reset to the original values
            SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, FALSE);
            break;
            
        case PSN_SETACTIVE:
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
            break;
            
        case PSN_WIZNEXT:
            break;
            
        default:
            return FALSE;
            
        }
        break;
        
        default:
            return FALSE;
    }
    return TRUE;   
}
//+--------------------------------------------------------------------------
//
//  Member:     CSelectDailyPage::OnCommand
//
//  Synopsis:   Handle the WM_COMMAND for the daily page
//
//  History:    12-08-1997   SusiA   
//
//---------------------------------------------------------------------------

BOOL CSelectDailyPage::OnCommand(HWND hwnd, WORD wID, WORD wNotifyCode)
{
    switch (wNotifyCode)
    {
    case BN_CLICKED:
        
        switch (wID)
        {
        case daily_day_rb:
        case daily_weekday_rb:
        case daily_ndays_rb:
            m_idSelectedRadio = (USHORT) wID;
            EnableNDaysControls(wID == daily_ndays_rb);
            break;
            
        default:
            break;
        }
        break;
        
        case EN_UPDATE:
            {
                //
                // If the user just pasted non-numeric text or an illegal numeric
                // value, overwrite it and complain.
                //
                if (IsWindowEnabled(GetDlgItem(hwnd,daily_ndays_edit)))
                {
                    INT iNewPos = GetDlgItemInt(hwnd, daily_ndays_edit, NULL, FALSE);
                    
                    if (iNewPos < NDAYS_MIN || iNewPos > NDAYS_MAX)
                    {
                        HWND hUD = GetDlgItem(hwnd,daily_ndays_ud);
                        UpDown_SetPos(hUD, UpDown_GetPos(hUD));
                        MessageBeep(MB_ICONASTERISK);
                    }
                }
            }
            
        default:
            break;
            break;
    }
    return TRUE;
    
}
//+--------------------------------------------------------------------------
//
//  Member:     CSelectDailyPage::EnableNDaysControls
//
//  Synopsis:   Enable or disable the 'run every n days' controls
//
//  History:    12-05-1997   SusiA   Created
//
//---------------------------------------------------------------------------

VOID CSelectDailyPage::EnableNDaysControls(BOOL fEnable)
{
    EnableWindow(GetDlgItem(m_hwnd,daily_ndays_ud), fEnable);
    EnableWindow(GetDlgItem(m_hwnd,daily_ndays_edit), fEnable);
    EnableWindow(GetDlgItem(m_hwnd,daily_ndays_lable), fEnable);
}


//+--------------------------------------------------------------------------
//
//  Member:     CSelectDailyPage::CSelectDailyPage
//
//  Synopsis:   ctor
//
//              [phPSP]                - filled with prop page handle
//
//  History:    11-21-1997   SusiA   
//
//---------------------------------------------------------------------------

CSelectDailyPage::CSelectDailyPage(
                                   HINSTANCE hinst,
                                   ISyncSchedule *pISyncSched,
                                   HPROPSHEETPAGE *phPSP)
{
    ZeroMemory(&m_psp, sizeof(m_psp));
    
    m_psp.dwSize = sizeof (PROPSHEETPAGE);
    m_psp.hInstance = hinst;
    m_psp.dwFlags = PSP_DEFAULT;
    m_psp.pszTemplate = MAKEINTRESOURCE(IDD_SCHEDWIZ_DAILY);
    m_psp.pszIcon = NULL;
    m_psp.pfnDlgProc = SchedWizardDailyDlgProc;
    m_psp.lParam = 0;
    
    m_pISyncSched = pISyncSched;
    m_pISyncSched->AddRef();
    
    g_pDailyPage = this;
    
    m_idSelectedRadio = 0;
    *phPSP = CreatePropertySheetPage(&m_psp);
    
}

//+--------------------------------------------------------------------------
//
//  Member:     CSelectDailyPage::Initialize(HWND hwnd)
//
//  Synopsis:   initialize the welcome page and set the task name to a unique 
//              new onestop name
//
//  History:    11-21-1997   SusiA   
//
//---------------------------------------------------------------------------

BOOL CSelectDailyPage::Initialize(HWND hwnd)
{
    
    m_hwnd = hwnd;
    
    UpdateTimeFormat(m_tszTimeFormat, ARRAYSIZE(m_tszTimeFormat));
    DateTime_SetFormat(GetDlgItem(m_hwnd,starttime_dp), m_tszTimeFormat);
    
    m_idSelectedRadio = daily_day_rb;
    CheckDlgButton(m_hwnd, m_idSelectedRadio, BST_CHECKED);
    
    EnableNDaysControls(FALSE);
    UpDown_SetRange(GetDlgItem(m_hwnd,daily_ndays_ud), NDAYS_MIN, NDAYS_MAX);
    UpDown_SetPos(GetDlgItem(m_hwnd,daily_ndays_ud), 7);
    Edit_LimitText(GetDlgItem(m_hwnd,daily_ndays_edit), 3);
    return TRUE; 
    
}

//+--------------------------------------------------------------------------
//
//  Member:     CSelectDailyPage::FillInTrigger
//
//  Synopsis:   Fill in the fields of the trigger structure according to the
//              settings specified for this type of trigger
//
//  Arguments:  [pTrigger] - trigger struct to fill in
//
//  Modifies:   *[pTrigger]
//
//  History:    12-08-1997   SusiA  Stole from the TaskScheduler
//
//  Notes:      Precondition is that trigger's cbTriggerSize member is
//              initialized.
//
//---------------------------------------------------------------------------

BOOL CSelectDailyPage::SetITrigger()
{
    TASK_TRIGGER Trigger;
    ITaskTrigger *pITrigger;
    
    if (FAILED(m_pISyncSched->GetTrigger(&pITrigger)))
    {
        return FALSE;
    }
    
    ZeroMemory(&Trigger, sizeof(Trigger));
    Trigger.cbTriggerSize = sizeof(TASK_TRIGGER);
    
    switch (m_idSelectedRadio)
    {
    case daily_day_rb:
        Trigger.TriggerType = TASK_TIME_TRIGGER_DAILY;
        Trigger.Type.Daily.DaysInterval = 1;
        break;
        
    case daily_weekday_rb:
        Trigger.TriggerType = TASK_TIME_TRIGGER_WEEKLY;
        Trigger.Type.Weekly.WeeksInterval = 1;
        Trigger.Type.Weekly.rgfDaysOfTheWeek = TASK_WEEKDAYS;
        break;
        
    case daily_ndays_rb:
        Trigger.TriggerType = TASK_TIME_TRIGGER_DAILY;
        Trigger.Type.Daily.DaysInterval =
            UpDown_GetPos(GetDlgItem(m_hwnd, daily_ndays_ud));
        break;
        
    default:
        break;
    }
    FillInStartDateTime(GetDlgItem(m_hwnd,startdate_dp), 
        GetDlgItem(m_hwnd,starttime_dp), &Trigger);
    
    if (ERROR_SUCCESS == pITrigger->SetTrigger(&Trigger))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\dll\cred.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       wizsel.cxx
//
//  Contents:   Task schedule credentials selection property page implementation.
//
//  Classes:    CCredentialsPage
//
//  History:    05-22-1998   SusiA
//
//---------------------------------------------------------------------------

#include "precomp.h"

// temporariy define new mstask flag in case hasn't
// propogated to sdk\inc
//for CS help

#ifdef _CREDENTIALS

extern TCHAR szSyncMgrHelp[];
extern ULONG g_aContextHelpIds[];

CCredentialsPage *g_pCredentialsPage = NULL;

//+-------------------------------------------------------------------------------
//  FUNCTION: SchedWizardCredentialsDlgProc(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE: Callback dialog procedure for the property page
//
//  PARAMETERS:
//    hDlg      - Dialog box window handle
//    uMessage  - current message
//    wParam    - depends on message
//    lParam    - depends on message
//
//  RETURN VALUE:
//
//    Depends on message.  In general, return TRUE if we process it.
//
//  COMMENTS:
//
//--------------------------------------------------------------------------------
INT_PTR CALLBACK SchedWizardCredentialsDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    WORD wNotifyCode = HIWORD(wParam); // notification code
    
    switch (uMessage)
    {
    case WM_INITDIALOG:
        
        if (g_pCredentialsPage)
            g_pCredentialsPage->Initialize(hDlg);
        
        InitPage(hDlg,lParam);
        break;
        
    case WM_HELP:
        {
            LPHELPINFO lphi  = (LPHELPINFO)lParam;
            
            if (lphi->iContextType == HELPINFO_WINDOW)
            {
                WinHelp ( (HWND) lphi->hItemHandle,
                    szSyncMgrHelp,
                    HELP_WM_HELP,
                    (ULONG_PTR) g_aContextHelpIds);
            }
            return TRUE;
        }
    case WM_CONTEXTMENU:
        {
            WinHelp ((HWND)wParam,
                szSyncMgrHelp,
                HELP_CONTEXTMENU,
                (ULONG_PTR)g_aContextHelpIds);
            
            return TRUE;
        }
    case WM_PAINT:
        WmPaint(hDlg, uMessage, wParam, lParam);
        break;
        
    case WM_PALETTECHANGED:
        WmPaletteChanged(hDlg, wParam);
        break;
        
    case WM_QUERYNEWPALETTE:
        return( WmQueryNewPalette(hDlg) );
        break;
        
    case WM_ACTIVATE:
        return( WmActivate(hDlg, wParam, lParam) );
        break;
        
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_USERNAME:
        case IDC_PASSWORD:
        case IDC_CONFIRMPASSWORD:
            {
                if (wNotifyCode == EN_CHANGE)
                {
                    PropSheet_Changed(GetParent(hDlg), hDlg);
                    g_pCredentialsPage->SetDirty();
                }
            }
            break;
            
        case IDC_RUNLOGGEDON:
            {
                if (wNotifyCode == BN_CLICKED)
                {
                    PropSheet_Changed(GetParent(hDlg), hDlg);
                    g_pCredentialsPage->SetDirty();
                    g_pCredentialsPage->SetEnabled(FALSE);
                    
                }
            }
            break;
        case IDC_RUNALWAYS:
            {
                if (wNotifyCode == BN_CLICKED)
                {
                    PropSheet_Changed(GetParent(hDlg), hDlg);
                    g_pCredentialsPage->SetDirty();
                    g_pCredentialsPage->SetEnabled(TRUE);
                    
                }
            }
            break;
            
        default:
            break;
            
        }
        break;
        
        default:
            return FALSE;
    }
    return TRUE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CCredentialsPage::CCredentialsPage
//
//  Synopsis:   ctor
//
//              [phPSP]                - filled with prop page handle
//
//  History:    11-21-1997   SusiA
//
//---------------------------------------------------------------------------

CCredentialsPage::CCredentialsPage(
                                   HINSTANCE hinst,
                                   BOOL *pfSaved,
                                   ISyncSchedule *pISyncSched,
                                   HPROPSHEETPAGE *phPSP)
{
    ZeroMemory(&m_psp, sizeof(m_psp));
    
    m_psp.dwSize = sizeof (PROPSHEETPAGE);
    m_psp.dwFlags = PSP_DEFAULT;
    m_psp.hInstance = hinst;
    m_psp.pszTemplate = MAKEINTRESOURCE(IDD_SCHEDPAGE_CREDENTIALS);
    m_psp.pszIcon = NULL;
    m_psp.pfnDlgProc = SchedWizardCredentialsDlgProc;
    m_psp.lParam = 0;
    
    g_pCredentialsPage = this;
    m_pISyncSched = pISyncSched;
    m_pISyncSched->AddRef();
    
    m_pfSaved = pfSaved;
    *m_pfSaved = FALSE;
    
    m_fTaskAccountChange = FALSE;
    
    *phPSP = CreatePropertySheetPage(&m_psp);
    
    
}

//+--------------------------------------------------------------------------
//
//  Member:     CCredentialsPage::Initialize(HWND hwnd)
//
//  Synopsis:   initialize the credentials page
//
//  History:    05-22-1998   SusiA
//
//---------------------------------------------------------------------------

BOOL CCredentialsPage::Initialize(HWND hwnd)
{
    m_hwnd = hwnd;
    
    ShowUserName();
    
    //Set the default IDC_ONLY_WHEN_LOGGED_ON check state.
    ITask *pITask;
    m_pISyncSched->GetITask(&pITask);
    DWORD dwFlags;
    pITask->GetFlags(&dwFlags);
    
    BOOL fOnlyWhenLoggedOn = dwFlags & TASK_FLAG_RUN_ONLY_IF_LOGGED_ON;
    
    Button_SetCheck(GetDlgItem(m_hwnd,IDC_RUNLOGGEDON), fOnlyWhenLoggedOn);
    Button_SetCheck(GetDlgItem(m_hwnd,IDC_RUNALWAYS), !fOnlyWhenLoggedOn);
    Edit_LimitText(GetDlgItem(m_hwnd, IDC_PASSWORD), PWLEN);
    Edit_LimitText(GetDlgItem(m_hwnd, IDC_CONFIRMPASSWORD), PWLEN);
    Edit_LimitText(GetDlgItem(m_hwnd, IDC_USERNAME), MAX_DOMANDANDMACHINENAMESIZE -1);
    
    SetEnabled(!fOnlyWhenLoggedOn);
    pITask->Release();
    
    
    ShowWindow(m_hwnd, /* nCmdShow */ SW_SHOWNORMAL );
    UpdateWindow(m_hwnd);
    
    
    return TRUE;
    
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CCredentialsPage::SetDirty()
//
//  PURPOSE:  we have changed the account info
//
//      COMMENTS: Only called frm prop sheet; not wizard
//
//--------------------------------------------------------------------------------
void CCredentialsPage::SetDirty()
{
    m_fTaskAccountChange = TRUE;
    
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSelectItemsPage::ShowUserName()
//
//  PURPOSE:  change the task's user name
//
//      COMMENTS: Only called frm prop sheet; not wizard
//
//--------------------------------------------------------------------------------
BOOL CCredentialsPage::ShowUserName()
{
    
    Assert(m_pISyncSched);
    
    WCHAR wszUserName[MAX_PATH + 1];
    DWORD cchUserName = ARRAYSIZE(wszUserName);
    
    HWND hwndEdit = GetDlgItem(m_hwnd, IDC_USERNAME);
    
    HRESULT hr = m_pISyncSched->GetAccountInformation(&cchUserName, wszUserName);
    
    if (FAILED(hr))
    {
        *wszUserName = L'\0';
    }
    
    Edit_SetText(hwndEdit, wszUserName);
    
    //
    // Need to set m_fTaskAccountChange here since doing a Edit_SetText causes
    // a WM_COMMAND msg with EN_CHANGE to be called for edit boxes.
    //
    m_fTaskAccountChange = FALSE;
    
    return TRUE;
    
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSelectItemsPage::CommitChanges()
//
//  PURPOSE:  Write all the current Schedule Settings to the registry
//
//      COMMENTS: Implemented on main thread.
//
//--------------------------------------------------------------------------------
HRESULT CCredentialsPage::CommitChanges()
{
    HRESULT hr = S_OK;
    BOOL fAccountChanged = TRUE;
    
    if (m_fTaskAccountChange)
    {
        BOOL fRunAlways = Button_GetCheck(GetDlgItem(m_hwnd,IDC_RUNALWAYS));
        
        
        if (fRunAlways)
        {
            Assert(m_pISyncSched);
            WCHAR wcUserBuffMAX_DOMANDANDMACHINENAMESIZE];
            WCHAR wcPassword[PWLEN + 1];
            WCHAR wcConfirmPassword[PWLEN + 1];
            
            GetDlgItemText(m_hwnd,IDC_USERNAME,wcUserBuff,MAX_DOMANDANDMACHINENAMESIZE);
            GetDlgItemText(m_hwnd,IDC_PASSWORD,wcPassword, PWLEN);
            GetDlgItemText(m_hwnd,IDC_CONFIRMPASSWORD,wcConfirmPassword, PWLEN);
            
            
            if (wcscmp(wcPassword, wcConfirmPassword) != 0)
            {
                // we return this to signal the controlling page not to
                // dismiss the dialog.
                return(ERROR_INVALID_PASSWORD);
            }
            
            
            ITask *pITask;
            if (FAILED(hr = m_pISyncSched->GetITask(&pITask)))
            {
                return hr;
            }
            
            if (FAILED (hr = m_pISyncSched->SetAccountInformation(wcUserBuff,
                wcPassword)))
            {
                AssertSz(0,"ISyncSched->SetAccountInformation failed");
                return hr;
            }
            
            DWORD dwFlags;
            pITask->GetFlags(&dwFlags);
            
            if (FAILED(hr = pITask->SetFlags(dwFlags & (~TASK_FLAG_RUN_ONLY_IF_LOGGED_ON))))
            {
                AssertSz(0,"ITask->SetFlags failed");
                return hr;
            }
            pITask->Release();
            
        }
        else
        {
            ITask *pITask;
            if (FAILED(hr = m_pISyncSched->GetITask(&pITask)))
            {
                return hr;
            }
            
            WCHAR wszDomainAndUser[MAX_DOMANDANDMACHINENAMESIZE];
            
            GetDefaultDomainAndUserName(wszDomainAndUser,TEXT("\\"),ARRAYSIZE(wszDomainAndUser));
            
            if (FAILED(hr = m_pISyncSched->SetAccountInformation(wszDomainAndUser, NULL)))
            {
                AssertSz(0,"ISyncSched->SetAccountInformation failed");
                return hr;
            }
            
            DWORD dwFlags;
            pITask->GetFlags(&dwFlags);
            
            if (FAILED(hr = pITask->SetFlags(dwFlags | TASK_FLAG_RUN_ONLY_IF_LOGGED_ON)))
            {
                AssertSz(0,"ITask->SetFlags failed");
                return hr;
            }
            pITask->Release();
            
        }
        //Now save the schedule
        //NoteNote: optimize by moving the save from wizsel and cred to EditSyncSched
        hr = m_pISyncSched->Save();
        if (hr == S_OK)
        {
            *m_pfSaved = TRUE;
        }
    }
    return hr;
}


//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CSelectItemsPage::SetEnabled(BOOL fEnabled)
//
//  PURPOSE: set the fields enabled according to the RB choice
//
//  RETURN VALUE: return TRUE if we process it ok.
//
//+-------------------------------------------------------------------------------
BOOL CCredentialsPage::SetEnabled(BOOL fEnabled)
{
    EnableWindow(GetDlgItem(m_hwnd, IDC_USERNAME), fEnabled);
    EnableWindow(GetDlgItem(m_hwnd, IDC_PASSWORD), fEnabled);
    EnableWindow(GetDlgItem(m_hwnd, IDC_CONFIRMPASSWORD), fEnabled);
    EnableWindow(GetDlgItem(m_hwnd, IDC_RUNAS_TEXT), fEnabled);
    EnableWindow(GetDlgItem(m_hwnd, IDC_PASSWORD_TEXT), fEnabled);
    EnableWindow(GetDlgItem(m_hwnd, IDC_CONFIRMPASSWORD_TEXT), fEnabled);
    
    return TRUE;
    
}

#endif // #ifdef _CREDENTIALS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\dll\dllsz.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       dllsz.h
//
//  Contents:   SyncMgr dll string extern constants
//
//  History:    18-Feb-98   SusiA      Created.
//
//--------------------------------------------------------------------------

#ifndef _Dll_STRINGC_
#define  _Dll_STRINGC_

extern "C" { 

    // place dll specific strings here.

extern const WCHAR SZ_REGISTRYMUTEXNAME[];
extern const WCHAR SZ_SCHEDULEMUTEXNAME[];

};

#endif //  _Dll_STRINGC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\dll\dllreg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       Reg.h
//
//  Contents:   Registration routines
//
//  Classes:
//
//  Notes:
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#ifndef _CONESTOPREGISTER_
#define _CONESTOPREGISTER_

#include "rasui.h" // included so exe can inlude dll.reg.

#define GUID_SIZE 128
#define MAX_STRING_LENGTH 256

typedef
enum _tagSYNCTYPE
{
    SYNCTYPE_MANUAL    = 0x1,
        SYNCTYPE_AUTOSYNC  = 0x2,
        SYNCTYPE_IDLE      = 0x3,
        SYNCTYPE_SCHEDULED = 0x4,
        SYNCTYPE_PROGRESS  = 0x5
}   SYNCTYPE;


EXTERN_C void WINAPI  RunDllRegister(HWND hwnd,
                                     HINSTANCE hAppInstance,
                                     LPSTR pszCmdLine,
                                     int nCmdShow);


#define UL_DEFAULTIDLEWAITMINUTES  15
#define UL_DEFAULTIDLERETRYMINUTES 60
#define UL_DELAYIDLESHUTDOWNTIME   2*1000 // time in milliseconds
#define UL_DEFAULTWAITMINUTES 15
#define UL_DEFAULTREPEATSYNCHRONIZATION 1
#define UL_DEFAULTFRUNONBATTERIES 0

typedef struct _CONNECTIONSETTINGS {
    TCHAR pszConnectionName[RAS_MaxEntryName + 1];  //The connection
    DWORD dwConnType;
    //      DWORD dwSyncFlags;
    // For optimization:  these are currently all BOOL,
    //the first three are used exclusively for autosync,
    //and dwMakeConnection is used exclusively for sched sync.
    //Consider using bitfields and/or a union to consolidate space.
    
    // AutoSync settings
    DWORD  dwLogon;             //Autosync at logon
    DWORD  dwLogoff;            //Autosync at logoff
    DWORD  dwPromptMeFirst;     //Prompt the user first before autosyncing
    
    // Schedule settings.
    DWORD  dwMakeConnection;    //Automatically try to establish the connection
    
    // Idle Settings
    DWORD  dwIdleEnabled; // Idle is enabled on this connection
    
    // Idle Settings that are really not per connection but read in for
    // convenience. These are currently never written.
    ULONG ulIdleWaitMinutes; // number of minutes to wait after idle to start idle processing.
    ULONG ulIdleRetryMinutes; // number of minutes for Idle before retry.
    ULONG ulDelayIdleShutDownTime; // time to delay shutdown of idle in milliseconds
    DWORD dwRepeatSynchronization; // indicates synchronization should be repeated
    DWORD dwRunOnBatteries; // indicates whether to run on batteries or not.
    DWORD  dwHidden;            //Hide the schedule from the user because this is a publishers sched.
    DWORD  dwReadOnly;          //Schedule info is readonly
    
} CONNECTIONSETTINGS;

typedef CONNECTIONSETTINGS *LPCONNECTIONSETTINGS;


STDAPI_(BOOL) AddRegNamedValue(HKEY hkey,LPTSTR pszKey,LPTSTR pszSubkey,LPTSTR pszValueName,LPTSTR pszValue);
STDAPI_(BOOL) RegLookupSettings(HKEY hKeyUser,
                                CLSID clsidHandler,
                                SYNCMGRITEMID ItemID,
                                const TCHAR *pszConnectionName,
                                DWORD *pdwCheckState);

STDAPI_(BOOL) RegWriteOutSettings(HKEY hKeyUser,
                                  CLSID clsidHandler,
                                  SYNCMGRITEMID ItemID,
                                  const TCHAR *pszConnectionName,
                                  DWORD dwCheckState);

STDAPI_(BOOL) RegGetSyncItemSettings(DWORD dwSyncType,
                                     CLSID clsidHandler,
                                     SYNCMGRITEMID ItemId,
                                     const TCHAR *pszConnectionName,
                                     DWORD *pdwCheckState,
                                     DWORD dwDefaultCheckState,
                                     TCHAR *pszSchedName);

STDAPI_(BOOL) RegSetSyncItemSettings(DWORD dwSyncType,
                                     CLSID clsidHandler,
                                     SYNCMGRITEMID ItemId,
                                     const TCHAR *pszConnectionName,
                                     DWORD dwCheckState,
                                     TCHAR *pszSchedName);

STDAPI_(BOOL) RegSetSyncHandlerSettings(DWORD syncType,
                                        const TCHAR *pszConnectionName,
                                        CLSID clsidHandler,
                                        BOOL  fItemsChecked);

STDAPI_(BOOL) RegQueryLoadHandlerOnEvent(TCHAR *pszClsid,DWORD dwSyncFlags,
                                         TCHAR *pConnectionName);


//Progress dialog preference
STDAPI_(BOOL)  RegGetProgressDetailsState(REFCLSID clsidDlg,BOOL *pfPushPin, BOOL *pfExpanded);
STDAPI_(BOOL)  RegSetProgressDetailsState(REFCLSID clsidDlg,BOOL fPushPin, BOOL fExpanded);

//Autosync reg functions
STDAPI_(BOOL)  RegGetAutoSyncSettings(LPCONNECTIONSETTINGS lpConnectionSettings);
STDAPI_(BOOL)  RegSetAutoSyncSettings(LPCONNECTIONSETTINGS lpConnectionSettings,
                                      int iNumConnections,
                                      CRasUI *pRas,
                                      BOOL fCleanReg,
                                      BOOL fSetMachineState,
                                      BOOL fPerUser);

// Idle reg functions
STDAPI_(BOOL)  RegGetIdleSyncSettings(LPCONNECTIONSETTINGS lpConnectionSettings);
STDAPI_(BOOL)  RegSetIdleSyncSettings(LPCONNECTIONSETTINGS lpConnectionSettings, 
                                      int iNumConnections,
                                      CRasUI *pRas,
                                      BOOL fCleanReg,
                                      BOOL fPerUser);
STDAPI_(BOOL)  RegRegisterForIdleTrigger(BOOL fRegister,ULONG ulWaitMinutes,BOOL fRunOnBatteries);


// function for exporting settings for exe
STDAPI_(BOOL) RegGetSyncSettings(DWORD dwSyncType,LPCONNECTIONSETTINGS lpConnectionSettings);

//Scheduled Sync reg functions
STDAPI_(BOOL) RegSchedHandlerItemsChecked(TCHAR *pszHandlerName, 
                                          TCHAR *pszConnectionName,
                                          TCHAR *pszScheduleName);

STDAPI_(BOOL)  RegGetSchedSyncSettings( LPCONNECTIONSETTINGS lpConnectionSettings,TCHAR *pszSchedName);

STDAPI_(BOOL)  RegSetSchedSyncSettings( LPCONNECTIONSETTINGS lpConnectionSettings,TCHAR *pszSchedName);

STDAPI_(BOOL)  RegGetSchedFriendlyName(LPCTSTR ptszScheduleGUIDName,
                                       LPTSTR ptstrFriendlyName,
                                       UINT cchFriendlyName);

STDAPI_(BOOL)  RegSetSchedFriendlyName(LPCTSTR ptszScheduleGUIDName,
                                       LPCTSTR ptstrFriendlyName);

STDAPI_(BOOL)  RegGetSchedConnectionName(TCHAR *pszSchedName,
                                         TCHAR *pszConnectionName,
                                         DWORD cbConnectionName);

STDAPI_(BOOL) RegSetSIDForSchedule(TCHAR *pszSchedName);
STDAPI_(BOOL) RegGetSIDForSchedule(TCHAR *ptszTextualSidSched,
                                   DWORD cchTextualSidSched, 
                                   TCHAR *pszSchedName);


STDAPI_(BOOL) RegRemoveScheduledTask(TCHAR *pszTaskName);
STDAPI_(BOOL) RemoveScheduledJobFile(TCHAR *pszTaskName);

STDAPI_(BOOL) RegRegisterForScheduledTasks(BOOL fScheduled);
STDAPI_(BOOL) RegUninstallSchedules();
STDAPI_(BOOL) RegFixRunKey();

STDAPI_(DWORD) RegDeleteKeyNT(HKEY hStartKey , LPCWSTR pKeyName);

// Manual settings
STDAPI_(BOOL) RegRemoveManualSyncSettings(TCHAR *pszConnectionName);


// Handler Registration Functions.
STDAPI_(BOOL) RegRegisterHandler(REFCLSID rclsidHandler,
                                 WCHAR const *pwszDescription,
                                 DWORD dwSyncMgrRegisterFlags,
                                 BOOL *pfFirstRegistration);
STDAPI_(BOOL) RegRegRemoveHandler(REFCLSID rclsidHandler);
STDAPI_(BOOL) RegGetHandlerRegistrationInfo(REFCLSID rclsidHandler,LPDWORD pdwSyncMgrRegisterFlags);
STDAPI_(void) RegSetUserDefaults();
STDAPI_(void) RegSetAutoSyncDefaults(BOOL fLogon,BOOL fLogoff);
STDAPI_(void) RegSetIdleSyncDefaults(BOOL fIdle);

STDAPI RegSetUserAutoSyncDefaults(DWORD dwSyncMgrRegisterMask,
                                  DWORD dwSyncMgrRegisterFlags);
STDAPI RegSetUserIdleSyncDefaults(DWORD dwSyncMgrRegisterMask,
                                  DWORD dwSyncMgrRegisterFlags);
STDAPI RegGetUserRegisterFlags(LPDWORD pdwSyncMgrRegisterFlags);

STDAPI_(BOOL) RegWriteTimeStamp(HKEY hkey);
STDAPI_(BOOL) RegGetTimeStamp(HKEY hKey, FILETIME *pft);
STDAPI_(void) RegUpdateTopLevelKeys();

// common registry functions.


STDAPI_(HKEY) RegOpenUserKey(HKEY hkeyParent,REGSAM samDesired,BOOL fCreate,BOOL fCleanReg);
STDAPI_(HKEY) RegGetSyncTypeKey(DWORD dwSyncType,REGSAM samDesired,BOOL fCreate);
STDAPI_(HKEY) RegGetCurrentUserKey(DWORD dwSyncType,REGSAM samDesired,BOOL fCreate);

STDAPI_(HKEY) RegGetHandlerTopLevelKey(REGSAM samDesired);
STDAPI_(HKEY) RegGetHandlerKey(HKEY hkeyParent,LPCWSTR pszHandlerClsid,REGSAM samDesired,BOOL fCreate);

STDAPI  RegRegisterForEvents(BOOL fUninstall);

#endif // _CONESTOPREGISTER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\dll\guid.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       guid.c
//
//  Contents:   Defines GUIDS
//
//  Classes:    
//
//  Notes:      
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#pragma data_seg(".text")
#define INITGUID
#include <objbase.h>
#include <initguid.h>
#include <mstask.h>
#include "debug.h"
#include "mobsync.h"
#include "mobsyncp.h"

#include <sens.h>

#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\dll\errdlg.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       errdlg.cxx
//
//  Contents:   Error dialog function
//
//
//  History:    14-Jul-1998    SitaramR      Created from util.cxx
//
//---------------------------------------------------------------------------

#include "precomp.h"

extern TCHAR szSyncMgrHelp[];
extern ULONG g_aContextHelpIds[];

extern HINSTANCE g_hmodThisDll; // Handle to this DLL itself.

//+---------------------------------------------------------------------------
//
//      Security functions
//
//      only on NT
//
//----------------------------------------------------------------------------

void
SchedUIErrorDialog(
                   HWND    hwnd,
                   int     idsErrMsg)
{
    TCHAR szTitleBuf[MAX_PATH + 1];
    TCHAR szErrorBuf[MAX_PATH + 1];
    
    //
    // Load the error message string.
    //
    LoadString(g_hmodThisDll, IDS_SYNCHMGR_NAME, szTitleBuf, ARRAYSIZE(szTitleBuf));
    LoadString(g_hmodThisDll, idsErrMsg, szErrorBuf, ARRAYSIZE(szErrorBuf));
    
    MessageBox(hwnd, szErrorBuf, szTitleBuf,
        MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\dll\editschd.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//  
//  File:       editschd.cxx
//
//  Contents:   Task schedule page for hidden schedules
//
//  Classes:    CEditSchedPage
//
//  History:    15-Mar-1998   SusiA   
//
//---------------------------------------------------------------------------

#include "precomp.h"

extern LANGID g_LangIdSystem;      // LangId of system we are running on.

extern TCHAR szSyncMgrHelp[];
extern ULONG g_aContextHelpIds[];

CEditSchedPage *g_pEditSchedPage = NULL;
extern CSelectItemsPage *g_pSelectItemsPage;

#ifdef _CREDENTIALS
extern CCredentialsPage *g_pCredentialsPage;
#endif // _CREDENTIALS

extern HINSTANCE g_hmodThisDll; // Handle to this DLL itself.

//+-------------------------------------------------------------------------------
//  FUNCTION: SchedEditDlgProc(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE: Callback dialog procedure for the property page
//
//  PARAMETERS:
//    hDlg      - Dialog box window handle
//    uMessage  - current message
//    wParam    - depends on message
//    lParam    - depends on message
//
//  RETURN VALUE:
//
//    Depends on message.  In general, return TRUE if we process it.
//
//  COMMENTS:
//
//--------------------------------------------------------------------------------
INT_PTR CALLBACK SchedEditDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    WORD wNotifyCode = HIWORD(wParam); // notification code
    
    switch (uMessage)
    {
    case WM_INITDIALOG:
        
        if (g_pEditSchedPage)
            g_pEditSchedPage->Initialize(hDlg);
        
        InitPage(hDlg,lParam);
        return TRUE;
        break;
        
    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code)
        {
        case PSN_APPLY:
            
            if (!g_pEditSchedPage->SetSchedName())
            {
                SchedUIErrorDialog(hDlg, IERR_INVALIDSCHEDNAME);
                SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE );
                return TRUE;
            }
            
            if (g_pSelectItemsPage)
            {
                g_pSelectItemsPage->CommitChanges();
            }
            
#ifdef _CREDENTIALS
            
            SCODE sc;
            
            if (g_pCredentialsPage)
            {
                sc = g_pCredentialsPage->CommitChanges();
                
                if (sc == ERROR_INVALID_PASSWORD)
                {
                    // Passwords didn't match. Let the user know so he/she
                    // can correct it.
                    
                    SchedUIErrorDialog(hDlg, IERR_PASSWORD);
                    SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE );
                    return TRUE;
                    
                }
                else if (sc == SCHED_E_ACCOUNT_NAME_NOT_FOUND)
                {
                    // Passwords didn't match. Let the user know so he/she
                    // can correct it.
                    
                    SchedUIErrorDialog(hDlg, IERR_ACCOUNT_NOT_FOUND);
                    SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE );
                    return TRUE;
                    
                }
            }
#endif // _CREDENTIALS
            
            
            
            break;
            
        case PSN_SETACTIVE:
            if (g_pEditSchedPage)
                g_pEditSchedPage->Initialize(hDlg);
            break;
            
        default:
            break;
            
        }
        break;
        
        case WM_COMMAND:
            if ((wNotifyCode == EN_CHANGE) && (LOWORD(wParam) == IDC_SCHED_NAME_EDITBOX))
            {
                PropSheet_Changed(GetParent(hDlg), hDlg);
                g_pEditSchedPage->SetSchedNameDirty();
                return TRUE;
            }   
            break;
            
        case WM_HELP: 
            {
                LPHELPINFO lphi  = (LPHELPINFO)lParam;
                
                if (lphi->iContextType == HELPINFO_WINDOW)  
                {
                    WinHelp ( (HWND) lphi->hItemHandle,
                        szSyncMgrHelp, 
                        HELP_WM_HELP, 
                        (ULONG_PTR) g_aContextHelpIds);
                }           
                return TRUE;
            }
        case WM_CONTEXTMENU:
            {
                WinHelp ((HWND)wParam,
                    szSyncMgrHelp, 
                    HELP_CONTEXTMENU,
                    (ULONG_PTR)g_aContextHelpIds);
                
                return TRUE;
            }
            
        default:
            break;
    }
    return FALSE;   
}




//+--------------------------------------------------------------------------
//
//  Member:     CEditSchedPage::CEditSchedPage
//
//  Synopsis:   ctor
//
//              [phPSP]                - filled with prop page handle
//
//  History:    11-21-1997   SusiA   
//
//---------------------------------------------------------------------------

CEditSchedPage::CEditSchedPage(
                               HINSTANCE hinst,
                               ISyncSchedule *pISyncSched,
                               HPROPSHEETPAGE *phPSP)
{
    ZeroMemory(&m_psp, sizeof(m_psp));
    
    m_psp.dwSize = sizeof (PROPSHEETPAGE);
    m_psp.hInstance = hinst;
    m_psp.dwFlags = PSP_DEFAULT;
    m_psp.pszTemplate = MAKEINTRESOURCE(IDD_SCHEDPAGE_SCHEDULE);
    m_psp.pszIcon = NULL;
    m_psp.pfnDlgProc = SchedEditDlgProc;
    m_psp.lParam = 0;
    
    g_pEditSchedPage = this;
    m_pISyncSched = pISyncSched;
    m_pISyncSched->AddRef();
    
    *phPSP = CreatePropertySheetPage(&m_psp);
}

BOOL CEditSchedPage::_Initialize_ScheduleName(HWND hwnd)
{
    BOOL fRetVal = FALSE;
    TCHAR szStr[MAX_PATH];
    
    DWORD cch = ARRAYSIZE(szStr);
    
    //Schedule Name
    if (SUCCEEDED(m_pISyncSched->GetScheduleName(&cch, szStr)))
    {
        m_hwnd = hwnd;
        
        HWND hwndName = GetDlgItem(hwnd,IDC_SCHED_NAME);
        
        LONG_PTR dwStyle =  GetWindowLongPtr(hwndName, GWL_STYLE);
        
        SetWindowLongPtr(hwndName, GWL_STYLE, dwStyle | SS_ENDELLIPSIS);
        
        SetStaticString(hwndName, szStr);
        
        fRetVal = TRUE;
    }
    
    return fRetVal;
}

BOOL CEditSchedPage::_Initialize_TriggerString(HWND hwnd)
{
    BOOL fRetVal = FALSE;
    WCHAR szStr[MAX_PATH];
    WCHAR szFmt[MAX_PATH];
    WCHAR szParam[MAX_PATH];
    
    ITaskTrigger* pITrigger;
    
    if (SUCCEEDED(m_pISyncSched->GetTrigger(&pITrigger)))
    {
        TASK_TRIGGER TaskTrigger;
        if (SUCCEEDED(pITrigger->GetTrigger(&TaskTrigger)))
        {
            HRESULT hr;
            switch (TaskTrigger.TriggerType)
            {
            case TASK_EVENT_TRIGGER_ON_IDLE:
                LoadString(g_hmodThisDll, IDS_IDLE_TRIGGER_STRING, szParam, ARRAYSIZE(szParam));
                hr = S_OK;
                break;
            case TASK_EVENT_TRIGGER_AT_SYSTEMSTART:
                LoadString(g_hmodThisDll, IDS_SYSTEMSTART_TRIGGER_STRING, szParam, ARRAYSIZE(szParam));   
                hr = S_OK;
                break;
            case TASK_EVENT_TRIGGER_AT_LOGON:
                LoadString(g_hmodThisDll, IDS_LOGON_TRIGGER_STRING, szParam, ARRAYSIZE(szParam)); 
                hr = S_OK;
                break;
                
            default:
                {
                    LPWSTR pwszString;
                    hr = pITrigger->GetTriggerString(&pwszString);
                    if (SUCCEEDED(hr))
                    {
                        hr = StringCchCopy(szParam, ARRAYSIZE(szParam), pwszString);
                        CoTaskMemFree(pwszString);
                    }
                }
                break;
            }
            
            if (SUCCEEDED(hr))
            {   
                LoadString(g_hmodThisDll, IDS_SCHED_WHEN, szFmt, ARRAYSIZE(szFmt));
                if (SUCCEEDED(StringCchPrintf(szStr, ARRAYSIZE(szStr), szFmt, szParam)))
                {                    
                    fRetVal = TRUE;
                }
            }
        }
        pITrigger->Release();
    }
    
    if (fRetVal)
    {
        SetDlgItemText(hwnd,IDC_SCHED_STRING,szStr);
    }
    return fRetVal;
}

BOOL CEditSchedPage::_Initialize_LastRunString(HWND hwnd)
{
    BOOL fRetVal = FALSE;
    WCHAR szStr[MAX_PATH];
    WCHAR szFmt[MAX_PATH];
    WCHAR szParam[MAX_PATH];
    WCHAR szParam2[MAX_PATH];
    
    SYSTEMTIME st;
    HRESULT hr = m_pISyncSched->GetMostRecentRunTime(&st);
    
    if (S_OK == hr)
    {
        DWORD dwDateReadingFlags = GetDateFormatReadingFlags(hwnd);
        LoadString(g_hmodThisDll, IDS_SCHED_LASTRUN, szFmt, ARRAYSIZE(szFmt));
        if (GetDateFormat(LOCALE_USER_DEFAULT,dwDateReadingFlags, &st, NULL,szParam, ARRAYSIZE(szParam)) &&
            GetTimeFormat(LOCALE_USER_DEFAULT, 0, &st, NULL,szParam2, ARRAYSIZE(szParam2)) &&
            SUCCEEDED(StringCchPrintf(szStr, ARRAYSIZE(szStr), szFmt, szParam, szParam2)))
        {
            fRetVal = TRUE;
        }
    }
    else if (SUCCEEDED(hr) && S_OK != hr)
    {
        LoadString(g_hmodThisDll, IDS_SCHED_NEVERRUN, szStr, ARRAYSIZE(szStr));
        fRetVal = TRUE;
    }
    
    if (fRetVal)
    {
        SetDlgItemText(hwnd,IDC_LASTRUN,szStr);
    }
    return fRetVal;
}

BOOL CEditSchedPage::_Initialize_NextRunString(HWND hwnd)
{
    BOOL fRetVal = FALSE;
    WCHAR szStr[MAX_PATH];
    WCHAR szFmt[MAX_PATH];
    WCHAR szParam[MAX_PATH];
    WCHAR szParam2[MAX_PATH];
    
    SYSTEMTIME st;
    HRESULT hr = m_pISyncSched->GetNextRunTime(&st);
    if (SCHED_S_EVENT_TRIGGER == hr)
    {
        ITaskTrigger* pITrigger;
        if (SUCCEEDED(m_pISyncSched->GetTrigger(&pITrigger)))
        {
            TASK_TRIGGER TaskTrigger;
            if (SUCCEEDED(pITrigger->GetTrigger(&TaskTrigger)))
            {
                switch (TaskTrigger.TriggerType)
                {
                case TASK_EVENT_TRIGGER_ON_IDLE:
                    LoadString(g_hmodThisDll, IDS_IDLE_TRIGGER_STRING, szParam, ARRAYSIZE(szParam));  
                    break;
                case TASK_EVENT_TRIGGER_AT_SYSTEMSTART:
                    LoadString(g_hmodThisDll, IDS_SYSTEMSTART_TRIGGER_STRING, szParam, ARRAYSIZE(szParam));   
                    break;
                case TASK_EVENT_TRIGGER_AT_LOGON:
                    LoadString(g_hmodThisDll, IDS_LOGON_TRIGGER_STRING, szParam, ARRAYSIZE(szParam)); 
                    break;        
                default:
                    Assert(0);
                    break;
                }
                LoadString(g_hmodThisDll, IDS_NEXTRUN_EVENT, szFmt, ARRAYSIZE(szFmt));
                if (SUCCEEDED(StringCchPrintf(szStr, ARRAYSIZE(szStr), szFmt, szParam)))
                {
                    fRetVal = TRUE;
                }
            }
            pITrigger->Release();
        }
    }
    else if (S_OK == hr)
    {
        DWORD dwDateReadingFlags = GetDateFormatReadingFlags(hwnd);
        LoadString(g_hmodThisDll, IDS_SCHED_NEXTRUN, szFmt, ARRAYSIZE(szFmt));
        if (SUCCEEDED(GetDateFormat(LOCALE_USER_DEFAULT, dwDateReadingFlags, &st, 
                                    NULL,szParam, ARRAYSIZE(szParam))) &&
            SUCCEEDED(GetTimeFormat(LOCALE_USER_DEFAULT, 0, &st, 
                                    NULL,szParam2, ARRAYSIZE(szParam2))) &&
            SUCCEEDED(StringCchPrintf(szStr, ARRAYSIZE(szStr), szFmt, szParam, szParam2)))
        {
            fRetVal = TRUE;
        }
    }
    else if (SUCCEEDED(hr) && S_OK != hr)
    {
        LoadString(g_hmodThisDll, IDS_SCHED_NOTAGAIN, szStr, ARRAYSIZE(szStr));
        fRetVal = TRUE;
    }
    
    if (fRetVal)
    {
        SetDlgItemText(hwnd,IDC_NEXTRUN,szStr);
    }
    
    return fRetVal;
}
//+--------------------------------------------------------------------------
//
//  Member:     CEditSchedPage::Initialize(HWND hwnd)
//
//  Synopsis:   initialize the edit schedule page
//
//  History:    11-21-1997   SusiA   
//
//---------------------------------------------------------------------------
BOOL CEditSchedPage::Initialize(HWND hwnd)
{
    BOOL fRetVal = FALSE;
    
    if (_Initialize_ScheduleName(hwnd) &&
        _Initialize_TriggerString(hwnd) &&
        _Initialize_LastRunString(hwnd) &&
        _Initialize_NextRunString(hwnd))
    {
        // set the limit on the edit box for entering the name
        SendDlgItemMessage(hwnd,IDC_SCHED_NAME_EDITBOX,EM_SETLIMITTEXT,MAX_PATH,0);
        
        ShowSchedName();
        fRetVal = TRUE;
    }
    
    return fRetVal;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CEditSchedPage::SetSchedNameDirty()
//
//  PURPOSE:  set the sched name dirty
//
//  COMMENTS: Only called frm prop sheet; not wizard
//
//--------------------------------------------------------------------------------
void CEditSchedPage::SetSchedNameDirty()
{
    m_fSchedNameChanged = TRUE;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CEditSchedPage::ShowSchedName()
//
//  PURPOSE:  change the task's sched name
//
//  COMMENTS: Only called frm prop sheet; not wizard
//
//--------------------------------------------------------------------------------
BOOL CEditSchedPage::ShowSchedName()
{
    
    Assert(m_pISyncSched);
    WCHAR pwszSchedName[MAX_PATH + 1];
    DWORD cchSchedName = ARRAYSIZE(pwszSchedName);
    
    HWND hwndEdit = GetDlgItem(m_hwnd, IDC_SCHED_NAME_EDITBOX);
    
    if (FAILED(m_pISyncSched->GetScheduleName(&cchSchedName, pwszSchedName)))
    {
        return FALSE;
    }
    
    Edit_SetText(hwndEdit, pwszSchedName);
    
    m_fSchedNameChanged = FALSE;
    return TRUE;
    
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CEditSchedPage::SetSchedName()
//
//  PURPOSE:  change the task's sched name
//
//  COMMENTS: Only called frm prop sheet; not wizard
//
//--------------------------------------------------------------------------------
BOOL CEditSchedPage::SetSchedName()
{
    
    Assert(m_pISyncSched);
    
    TCHAR pszSchedName[MAX_PATH + 1];
    DWORD dwSize = MAX_PATH;
    
    if (m_fSchedNameChanged)
    {
        HWND hwndEdit = GetDlgItem(m_hwnd, IDC_SCHED_NAME_EDITBOX);
        Edit_GetText(hwndEdit, pszSchedName, MAX_PATH);
        
        if (S_OK != m_pISyncSched->SetScheduleName(pszSchedName))
        {
            return FALSE;
        }
        
        SetStaticString(GetDlgItem(m_hwnd,IDC_SCHED_NAME), pszSchedName);
        PropSheet_SetTitle(GetParent(m_hwnd),0, pszSchedName);      
    }       
    
    return TRUE;
    
}

//+--------------------------------------------------------------------------
//
//  Function:   SetStaticString (HWND hwnd, LPTSTR pszString)
//
//  Synopsis:   print out the schedule name in a static text string, with the ... 
//              if necessary
//
//  History:    12-Mar-1998   SusiA   
//
//---------------------------------------------------------------------------
BOOL SetStaticString (HWND hwnd, LPTSTR pszString)
{
    Assert(hwnd);
    
    Static_SetText(hwnd, pszString);
    
    return TRUE;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\dll\finish.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//  
//  File:       finish.cxx
//
//  Contents:   Task wizard Onestop finish property page implementation.
//
//  Classes:    CFinishPage
//
//  History:    11-21-1998   SusiA   
//
//---------------------------------------------------------------------------

#include "precomp.h"

CFinishPage *g_pFinishPage = NULL;

extern CSelectItemsPage *g_pSelectItemsPage;
//+-------------------------------------------------------------------------------
//  FUNCTION: SchedWizardFinishDlgProc(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE: Callback dialog procedure for the property page
//
//  PARAMETERS:
//    hDlg      - Dialog box window handle
//    uMessage  - current message
//    wParam    - depends on message
//    lParam    - depends on message
//
//  RETURN VALUE:
//
//    Depends on message.  In general, return TRUE if we process it.
//
//  COMMENTS:
//
//--------------------------------------------------------------------------------
INT_PTR CALLBACK SchedWizardFinishDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    WORD wNotifyCode = HIWORD(wParam); // notification code
    
    switch (uMessage)
    {
    case WM_INITDIALOG:
        if (g_pFinishPage)
            g_pFinishPage->Initialize(hDlg);
        
        InitPage(hDlg,lParam);
        break;
        
    case WM_PAINT:
        WmPaint(hDlg, uMessage, wParam, lParam);
        break;
        
    case WM_PALETTECHANGED:
        WmPaletteChanged(hDlg, wParam);
        break;
        
    case WM_QUERYNEWPALETTE:
        return( WmQueryNewPalette(hDlg) );
        break;
        
    case WM_ACTIVATE:
        return( WmActivate(hDlg, wParam, lParam) );
        break;
        
    case WM_COMMAND:
        break;
        
    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code) 
        {
            
        case PSN_KILLACTIVE:
            SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, FALSE);
            break;
            
        case PSN_RESET:
            // reset to the original values
            SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, FALSE);
            break;
            
        case PSN_SETACTIVE:
            g_pFinishPage->OnPSNSetActive(lParam);
            break;
            
        case PSN_WIZFINISH:
            {
                if (g_pSelectItemsPage)
                {
                    if (S_OK != g_pSelectItemsPage->CommitChanges())
                    {
                        SchedUIErrorDialog(hDlg, IERR_SCHEDULE_SAVE_FAIL);
                    }
                }               
            }
            break;
        default:
            return FALSE;
            
        }
        break;
        default:
            return FALSE;
    }
    return TRUE;   
}
//+--------------------------------------------------------------------------
//
//  Member:     CFinishPage::CFinishPage
//
//  Synopsis:   Initialize the finish page
//
//              [phPSP]                - filled with prop page handle
//
//  History:    11-21-1998   SusiA   
//
//---------------------------------------------------------------------------

CFinishPage::CFinishPage(
                         HINSTANCE hinst,
                         ISyncSchedule *pISyncSched,
                         HPROPSHEETPAGE *phPSP)
{
    ZeroMemory(&m_psp, sizeof(m_psp));
    
    m_psp.dwSize = sizeof (PROPSHEETPAGE);
    m_psp.hInstance = hinst;
    m_psp.dwFlags = PSP_DEFAULT;
    m_psp.pszTemplate = MAKEINTRESOURCE(IDD_SCHEDWIZ_FINISH);
    m_psp.pszIcon = NULL;
    m_psp.pfnDlgProc = SchedWizardFinishDlgProc;
    m_psp.lParam = 0;
    
    m_pISyncSched = pISyncSched;
    m_pISyncSched->AddRef();
    
    g_pFinishPage = this;
    
    *phPSP = CreatePropertySheetPage(&m_psp);
    
}

//+--------------------------------------------------------------------------
//
//  Member:     CFinishPage::Initialize(HWND hwnd)
//
//  Synopsis:   initialize the welcome page and set the task name to a unique 
//              new onestop name
//
//  History:    11-21-1998   SusiA   
//
//---------------------------------------------------------------------------
BOOL CFinishPage::Initialize(HWND hwnd)
{
    m_hwnd = hwnd;
    
    HWND hwndName = GetDlgItem(hwnd,IDC_SCHED_NAME);
    
    LONG_PTR dwStyle = GetWindowLongPtr(hwndName, GWL_STYLE);
    
    SetWindowLongPtr(hwndName, GWL_STYLE, dwStyle | SS_ENDELLIPSIS);
    
    return TRUE;
}

//+--------------------------------------------------------------------------
//
//  Member:     CFinishPage::OnPSNSetActive(LPARAM lParam)
//
//  Synopsis:   handle the set active notification
//
//  History:    12-08-1998   SusiA
//
//---------------------------------------------------------------------------

BOOL CFinishPage::OnPSNSetActive(LPARAM lParam)
{
    HRESULT hr;
    
    LPWSTR pwszTrigger = NULL;
    WCHAR pwszSchedName[MAX_PATH + 1];
    DWORD dwSize = MAX_PATH;
    
    PropSheet_SetWizButtons(GetParent(m_hwnd), PSWIZB_BACK | PSWIZB_FINISH);
    
    //Schedule Name
    if (FAILED(hr = m_pISyncSched->GetScheduleName(&dwSize, pwszSchedName)))
    {
        return FALSE;
    }
    
    SetStaticString(GetDlgItem(m_hwnd,IDC_SCHED_NAME), pwszSchedName);
    
    ITaskTrigger *pTrigger;
    
    if (FAILED(hr = m_pISyncSched->GetTrigger(&pTrigger)))
    {
        return FALSE;
    }
    
    if (FAILED(hr = pTrigger ->GetTriggerString(&pwszTrigger)))
    {
        return FALSE;
    }
    
    Static_SetText(GetDlgItem(m_hwnd,IDC_ScheduleTime), pwszTrigger);
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\dll\hndlrq.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       Hndlrq.cpp
//
//  Contents:   Implements class for keeping track of handlers
//      and the UI associated with them
//
//  Classes:    CHndlrQueue
//
//  History:    05-Nov-97   rogerg      Created.
//              17-Nov-97   susia       Moved to onestop dll for settings.
//
//--------------------------------------------------------------------------

#include "precomp.h"

//--------------------------------------------------------------------------------
//
//  FUNCTION: CHndlrQueue::CHndlrQueue(QUEUETYPE QueueType)
//
//  PURPOSE:  CHndlrQueue constructor
//
//  COMMENTS: Implemented on main thread.
//
//  History:  01-01-98       susia        Created.
//
//--------------------------------------------------------------------------------
CHndlrQueue::CHndlrQueue(QUEUETYPE QueueType)
{
    m_cRef = 1;
    m_pFirstHandler = NULL; 
    m_wHandlerCount = 0; 
    m_QueueType = QueueType;
    m_ConnectionList = NULL;
    m_ConnectionCount = 0;
    m_fItemsMissing = FALSE;
}

STDMETHODIMP CHndlrQueue::Init()
{
    return InitializeCriticalSectionAndSpinCount(&m_CriticalSection, 0) ? S_OK : E_FAIL;
}
//--------------------------------------------------------------------------------
//
//  FUNCTION: CHndlrQueue::AddRef()
//
//  PURPOSE:  AddRef
//
//  History:  30-Mar-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CHndlrQueue::AddRef()
{
    TRACE("CHndlrQueue::AddRef()\r\n");
    return ++m_cRef;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CHndlrQueue::Release()
//
//  PURPOSE:  Release
//
//  History:  30-Mar-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CHndlrQueue::Release()
{
    TRACE("CHndlrQueue::Release()\r\n");
    if (--m_cRef)
        return m_cRef;
    
    FreeAllHandlers();
    delete this;
    return 0L;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CHndlrQueue::~CHndlrQueue()
//
//  PURPOSE:  CHndlrQueue destructor
//
//  COMMENTS: Implemented on main thread.
//
//  History:  01-01-98       susia        Created.
//
//--------------------------------------------------------------------------------
CHndlrQueue::~CHndlrQueue()
{
    Assert(NULL == m_pFirstHandler); // all items should be freed at this point.
    DeleteCriticalSection(&m_CriticalSection);
}
//--------------------------------------------------------------------------------
//
//  FUNCTION: CHndlrQueue::AddHandler(REFCLSID clsidHandler, WORD *wHandlerId)
//
//  PURPOSE:  Add a handler to the queue  
//
//  COMMENTS: 
//
//  History:  01-01-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CHndlrQueue::AddHandler(REFCLSID clsidHandler, WORD *wHandlerId)
{
    HRESULT hr = E_OUTOFMEMORY;
    LPHANDLERINFO pnewHandlerInfo;
    LPHANDLERINFO pCurHandlerInfo = NULL;
    
    // first see if we already have this handler in the queue.
    // find first handler that matches the request CLSID
    pCurHandlerInfo = m_pFirstHandler;
    
    while (pCurHandlerInfo )
    {
        if (clsidHandler == pCurHandlerInfo->clsidHandler)
        {
            return S_FALSE;
        }
        pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }
    
    //didn't find the handler in the queue, add it now.
    pnewHandlerInfo = (LPHANDLERINFO) ALLOC(sizeof(*pnewHandlerInfo));
    
    if (pnewHandlerInfo)
    {
        // initialize
        ZeroMemory(pnewHandlerInfo, sizeof(*pnewHandlerInfo));
        pnewHandlerInfo->HandlerState = HANDLERSTATE_CREATE;
        pnewHandlerInfo->wHandlerId =   ++m_wHandlerCount;
        
        // add to end of list and set wHandlerId. End of list since in choice dialog want
        // first writer wins so don't have to continue searches when setting item state.
        if (NULL == m_pFirstHandler)
        {
            m_pFirstHandler = pnewHandlerInfo;
        }
        else
        {
            pCurHandlerInfo = m_pFirstHandler;
            
            while (pCurHandlerInfo->pNextHandler)
            {
                pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
            }
            pCurHandlerInfo->pNextHandler = pnewHandlerInfo;
        }
        
        *wHandlerId = pnewHandlerInfo->wHandlerId;
        
        hr = NOERROR;
    }
    
    return hr;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CHndlrQueue::RemoveHandler(WORD wHandlerId)
//
//  PURPOSE:  Release a handler from the queue  
//
//  COMMENTS: 
//
//  History:  09-23-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CHndlrQueue::RemoveHandler(WORD wHandlerId)
{
    HRESULT hr = NOERROR;
    LPHANDLERINFO pPrevHandlerInfo;
    LPHANDLERINFO pCurHandlerInfo;
    LPITEMLIST pCurItem = NULL;
    LPITEMLIST pNextItem = NULL;
    
    pCurHandlerInfo = pPrevHandlerInfo = m_pFirstHandler;
    
    while (pCurHandlerInfo && (pCurHandlerInfo->wHandlerId != wHandlerId))
    {
        pPrevHandlerInfo = pCurHandlerInfo;
        pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }   
    
    if (pCurHandlerInfo)
    {
        //Update the first node if necessary
        if (pCurHandlerInfo == m_pFirstHandler)
        {
            m_pFirstHandler = m_pFirstHandler->pNextHandler;
        }
        //Fix up linked list
        pPrevHandlerInfo->pNextHandler = pCurHandlerInfo->pNextHandler;
        
        
        //Free the handler items if there are any
        pCurItem = pCurHandlerInfo->pFirstItem;
        while (pCurItem)
        {   
            FREE(pCurItem->pItemCheckState);
            pNextItem = pCurItem->pnextItem;
            FREE(pCurItem);
            pCurItem = pNextItem;
        }
        
        //Release the handler
        if (pCurHandlerInfo->pSyncMgrHandler)
        {
            pCurHandlerInfo->pSyncMgrHandler->Release();
        }
        
        FREE(pCurHandlerInfo);
        
        
    }
    else
    {  
        return E_UNEXPECTED;
    }
    
    return hr;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CHndlrQueue::FreeAllHandlers(void)
//
//  PURPOSE:  loops through all the Handlers and frees them
//
//  COMMENTS: 
//
//  History:  01-01-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CHndlrQueue::FreeAllHandlers(void)
{
    HANDLERINFO HandlerInfoStart;
    LPHANDLERINFO pPrevHandlerInfo = &HandlerInfoStart;
    LPHANDLERINFO pCurHandlerInfo = NULL;
    LPITEMLIST pCurItem = NULL;
    LPITEMLIST pNextItem = NULL;
    
    if (m_ConnectionList)
    {
        FREE(m_ConnectionList);
        m_ConnectionList = NULL;
    }
    pPrevHandlerInfo->pNextHandler = m_pFirstHandler;
    
    while (pPrevHandlerInfo->pNextHandler)
    {
        pCurHandlerInfo = pPrevHandlerInfo->pNextHandler;
        
        pCurItem = pCurHandlerInfo->pFirstItem;
        while (pCurItem)
        {   
            FREE(pCurItem->pItemCheckState);
            pNextItem = pCurItem->pnextItem;
            FREE(pCurItem);
            pCurItem = pNextItem;
        }
        
        pPrevHandlerInfo->pNextHandler = pCurHandlerInfo->pNextHandler;
        if (pCurHandlerInfo->pSyncMgrHandler)
        {
            pCurHandlerInfo->pSyncMgrHandler->Release();
        }
        FREE(pCurHandlerInfo);
    }
    
    // update the pointer to the first handler item
    m_pFirstHandler = HandlerInfoStart.pNextHandler;
    Assert(NULL == m_pFirstHandler); // should always have released everything.
    
    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::GetHandlerInfo, public
//
//  Synopsis:   Gets Data associated with the HandlerID and ItemID
//
//  Arguments:  [wHandlerId] - Id Of Handler the Item belongs too
//
//  Returns:    Appropriate return codes
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::GetHandlerInfo(REFCLSID clsidHandler,
                                         LPSYNCMGRHANDLERINFO pSyncMgrHandlerInfo)
{
    HRESULT hr = S_FALSE;
    LPHANDLERINFO pCurHandlerInfo = NULL;
    // find first handler that matches the request CLSID
    pCurHandlerInfo = m_pFirstHandler;
    
    while (pCurHandlerInfo )
    {
        if (clsidHandler == pCurHandlerInfo->clsidHandler)
        {
            *pSyncMgrHandlerInfo = pCurHandlerInfo->SyncMgrHandlerInfo;
            hr = NOERROR;
            break;
        }
        
        pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }
    
    return hr;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION:CHndlrQueue::GetSyncItemDataOnConnection(int iConnectionIndex, 
//                          WORD wHandlerId,
//                          WORD wItemID,
//                          CLSID *pclsidHandler,
//                          SYNCMGRITEM* offlineItem,
//                          ITEMCHECKSTATE *pItemCheckState,    
//                          BOOL fSchedSync,
//                          BOOL fClear)
//
//  PURPOSE:  Get the item data per connection  
//
//  COMMENTS: Ras implementation is based on names.  Switch to GUIDs for Connection
//              objects
//
//  History:  01-01-98       susia        Created.
//
//--------------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::GetSyncItemDataOnConnection(
                                                      int iConnectionIndex, 
                                                      WORD wHandlerId, WORD wItemID,
                                                      CLSID *pclsidHandler,
                                                      SYNCMGRITEM* offlineItem,
                                                      ITEMCHECKSTATE   *pItemCheckState,
                                                      BOOL fSchedSync,
                                                      BOOL fClear)
{ 
    BOOL fFoundMatch = FALSE;
    LPHANDLERINFO pCurHandlerInfo = NULL;
    LPITEMLIST pCurItem = NULL;
    
    pCurHandlerInfo = m_pFirstHandler;
    
    while (pCurHandlerInfo && !fFoundMatch)
    {
        // only valid if Hanlder is in the PrepareForSync state.
        if (wHandlerId == pCurHandlerInfo->wHandlerId) // see if CLSID matches
        {
            // see if handler info has a matching item
            pCurItem = pCurHandlerInfo->pFirstItem;
            
            while (pCurItem)
            {
                if (wItemID == pCurItem->wItemId)
                {
                    fFoundMatch = TRUE;
                    break;
                }
                pCurItem = pCurItem->pnextItem;
            }
        }
        if (!fFoundMatch)
            pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }
    
    if (fFoundMatch)
    {
        if (pclsidHandler)
        {
            *pclsidHandler = pCurHandlerInfo->clsidHandler;
        }
        if (offlineItem)
        {
            *offlineItem = pCurItem->offlineItem;
        }
        
        if (pItemCheckState)
        {
            if (fSchedSync)
            {
                Assert(0 == iConnectionIndex);
                
                //if only holding on connection's settings at a time
                if (fClear)
                {
                    pCurItem->pItemCheckState[iConnectionIndex].dwSchedule = SYNCMGRITEMSTATE_UNCHECKED;
                }
            }
            else //AutoSync
            {
                Assert((iConnectionIndex>=0) && (iConnectionIndex < m_ConnectionCount))
            }
            
            *pItemCheckState = pCurItem->pItemCheckState[iConnectionIndex];
        }
    }
    
    return fFoundMatch ? NOERROR : S_FALSE;
}


//--------------------------------------------------------------------------------
//
//  STDMETHODIMP CHndlrQueue::GetItemIcon(WORD wHandlerId, WORD wItemID, HICON *phIcon)
//
//  PURPOSE:  Get the item icon 
//
//  History:  03-13-98       susia        Created.
//
//--------------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::GetItemIcon(WORD wHandlerId, 
                                      WORD wItemID,
                                      HICON *phIcon)
{ 
    BOOL fFoundMatch = FALSE;
    LPHANDLERINFO pCurHandlerInfo = NULL;
    LPITEMLIST pCurItem = NULL;
    
    pCurHandlerInfo = m_pFirstHandler;
    
    while (pCurHandlerInfo && !fFoundMatch)
    {
        if (wHandlerId == pCurHandlerInfo->wHandlerId) // see if CLSID matches
        {
            // see if handler info has a matching item
            pCurItem = pCurHandlerInfo->pFirstItem;
            
            while (pCurItem)
            {
                if (wItemID == pCurItem->wItemId)
                {
                    fFoundMatch = TRUE;
                    break;
                }
                pCurItem = pCurItem->pnextItem;
            }
        }
        if (!fFoundMatch)
            pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }
    
    if (fFoundMatch)
    {
        if (phIcon)
        {
            *phIcon = pCurItem->offlineItem.hIcon;
        }
    }
    
    return fFoundMatch ? NOERROR : S_FALSE;
}

//--------------------------------------------------------------------------------
//
//  STDMETHODIMP CHndlrQueue::GetItemName(WORD wHandlerId, WORD wItemID, WCHAR *pwszName, UINT cchName);
//
//  PURPOSE:  Get the item Name 
//
//  History:  03-13-98       susia        Created.
//
//--------------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::GetItemName(WORD wHandlerId, 
                                      WORD wItemID,
                                      WCHAR *pwszName, 
                                      UINT cchName)
{ 
    HRESULT hr = S_OK;
    BOOL fFoundMatch = FALSE;
    LPHANDLERINFO pCurHandlerInfo = NULL;
    LPITEMLIST pCurItem = NULL;
    
    pCurHandlerInfo = m_pFirstHandler;
    
    while (pCurHandlerInfo && !fFoundMatch)
    {
        if (wHandlerId == pCurHandlerInfo->wHandlerId) // see if CLSID matches
        {
            // see if handler info has a matching item
            pCurItem = pCurHandlerInfo->pFirstItem;
            
            while (pCurItem)
            {
                if (wItemID == pCurItem->wItemId)
                {
                    fFoundMatch = TRUE;
                    break;
                }
                pCurItem = pCurItem->pnextItem;
            }
        }
        if (!fFoundMatch)
            pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }
    
    if (fFoundMatch)
    {
        if (pwszName)
        {
            hr = StringCchCopy(pwszName, cchName, pCurItem->offlineItem.wszItemName);
        }
        else
        {
            hr = S_OK;
        }
    }
    else
    {
        hr = S_FALSE;
    }
    
    return hr;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CHndlrQueue::FindFirstHandlerInState(HANDLERSTATE hndlrState,WORD *wHandlerID)
//
//  PURPOSE: finds first handler it comes across in the state 
//
//  COMMENTS: 
//
//  HISTORY:  01-01-98       SusiA        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CHndlrQueue::FindFirstHandlerInState(HANDLERSTATE hndlrState,WORD *wHandlerID)
{
    return FindNextHandlerInState(0,hndlrState,wHandlerID);
}
//--------------------------------------------------------------------------------
//
//  FUNCTION: CHndlrQueue::FindNextHandlerInState(WORD wLastHandlerID,
//                                      HANDLERSTATE hndlrState,WORD *wHandlerID)
//
//  PURPOSE: finds next handler after LasthandlerID in the queue that matches 
//           the requested state.
//
//  COMMENTS: passing in 0 for the LasthandlerID is the same as calling 
//              FindFirstHandlerInState 
//
//  HISTORY:  01-01-98       SusiA        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CHndlrQueue::FindNextHandlerInState(WORD wLastHandlerID,HANDLERSTATE hndlrState,WORD *wHandlerID)
{
    HRESULT hr = S_FALSE; 
    LPHANDLERINFO pCurHandler;
    
    *wHandlerID = 0; 
    
    pCurHandler = m_pFirstHandler;
    
    if (0 != wLastHandlerID)
    {
        // loop foward until find the last handlerID we checked or hit the end
        while (pCurHandler)
        {
            if (wLastHandlerID == pCurHandler->wHandlerId)
            {
                break;
            }
            pCurHandler = pCurHandler->pNextHandler;
        }
        if (NULL == pCurHandler)
            return S_FALSE;
        
        pCurHandler = pCurHandler->pNextHandler; // increment to next handler.
    }
    
    while (pCurHandler)
    {
        if (hndlrState == pCurHandler->HandlerState)
        {
            *wHandlerID = pCurHandler->wHandlerId;
            hr = S_OK;
            break;
        }
        pCurHandler = pCurHandler->pNextHandler;
    }
    return hr;
}
//--------------------------------------------------------------------------------
//
//  FUNCTION: CHndlrQueue::FindFirstItemOnConnection
//                          (TCHAR *pszConnectionName, 
//                           CLSID *pclsidHandler,
//                           SYNCMGRITEMID* OfflineItemID,
//                           WORD *wHandlerId,
//                           WORD *wItemID)
//
//  PURPOSE: find first ListView Item that can sync over the specified 
//           connection and return its clsid and ItemID
//
//  COMMENTS: 
//
//  HISTORY:  01-01-98       SusiA        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CHndlrQueue::FindFirstItemOnConnection
(TCHAR *pszConnectionName, 
 CLSID *pclsidHandler,
 SYNCMGRITEMID* OfflineItemID,
 WORD *pwHandlerId,
 WORD *pwItemID)
{
    DWORD dwCheckState;
    
    
    return FindNextItemOnConnection
        (pszConnectionName,0,0,pclsidHandler,
        OfflineItemID, pwHandlerId, pwItemID, 
        TRUE, &dwCheckState);
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CHndlrQueue::FindNextItemOnConnection
//                          (TCHAR *pszConnectionName,
//                           WORD wLastHandlerId,
//                           WORD wLastItemID,
//                           CLSID *pclsidHandler,
//                           SYNCMGRITEMID* OfflineItemID,
//                           WORD *pwHandlerId,
//                           WORD *pwItemID,
//                           BOOL fAllHandlers,
//                           DWORD *pdwCheckState)
//
//
//
//  PURPOSE:  starts on the next item after the specified Handler and ItemID
//            setting the last HandlerID to 0 is the same as calling 
//            FindFirstItemOnConnection
//
//  COMMENTS:  For now, no Handler can specifiy that it can or cannot sync over a 
//             connection, so assume it can, and ignore the connection.
//
//  HISTORY:  01-01-98       SusiA        Created.
//
//--------------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::FindNextItemOnConnection
(TCHAR *pszConnectionName,
 WORD wLastHandlerId,
 WORD wLastItemID,
 CLSID *pclsidHandler,
 SYNCMGRITEMID* OfflineItemID,
 WORD *pwHandlerId,
 WORD *pwItemID,
 BOOL fAllHandlers,
 DWORD *pdwCheckState)
 
 
{
    BOOL fFoundMatch = FALSE;
    LPHANDLERINFO pCurHandlerInfo = NULL;
    LPITEMLIST pCurItem = NULL;
    
    pCurHandlerInfo = m_pFirstHandler;
    
    if (!pCurHandlerInfo)
    {
        return S_FALSE;
    }
    
    if (0 != wLastHandlerId)
    {
        // loop until find the specified handler or hit end of list.
        while(pCurHandlerInfo && wLastHandlerId != pCurHandlerInfo->wHandlerId)
            pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
        
        if (NULL == pCurHandlerInfo) // reached end of list without finding the Handler
        {
            Assert(0); // user must have passed an invalid start HandlerID.
            return S_FALSE;
        }
    }
    
    // loop until find item or end of item list
    pCurItem = pCurHandlerInfo->pFirstItem;
    
    if (0 != wLastItemID)
    {
        while (pCurItem && pCurItem->wItemId != wLastItemID)
        {
            pCurItem = pCurItem->pnextItem;
        }
        if (NULL == pCurItem) // reached end of item list without finding the specified item
        {
            Assert(0); // user must have passed an invalid start ItemID.
            return S_FALSE;
        }
        
        // now we found the Handler and item. loop through remaining items for this handler and
        // see if there is a match
        pCurItem = pCurItem->pnextItem;
    }
    //Found the item on this handler
    if (pCurItem)
    {
        fFoundMatch = TRUE;
    }
    
    //If we are to move beyond this handler, do so now, else we are done
    if (!fFoundMatch && fAllHandlers)
    {
        pCurHandlerInfo = pCurHandlerInfo->pNextHandler; // increment to next handler if no match
    }
    
    if ((FALSE == fFoundMatch) && fAllHandlers)
    {
        while (pCurHandlerInfo && !fFoundMatch)
        {
            // see if handler info has a matching item
            pCurItem = pCurHandlerInfo->pFirstItem;
            
            if (pCurItem)
                fFoundMatch = TRUE;
            
            if (!fFoundMatch)
                pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
        }
    }
    
    if (fFoundMatch)
    {
        *pclsidHandler = pCurHandlerInfo->clsidHandler;
        *OfflineItemID = pCurItem->offlineItem.ItemID;
        *pwHandlerId = pCurHandlerInfo->wHandlerId;
        *pwItemID = pCurItem->wItemId;
        *pdwCheckState = pCurItem->pItemCheckState[0].dwSchedule;
    }
    
    return fFoundMatch ? NOERROR : S_FALSE;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CHndlrQueue::GetHandlerIDFromClsid
//                          (REFCLSID clsidHandlerIn,
//                           WORD *pwHandlerId)
//
//  PURPOSE: get the HnadlerID from the CLSID
 //
 // COMMENTS: if the Handler is GUID_NULL enumerate all
 //
 //  HISTORY:  03-09-98       SusiA        Created.
 //
 //--------------------------------------------------------------------------------
 STDMETHODIMP CHndlrQueue::GetHandlerIDFromClsid
     (REFCLSID clsidHandlerIn,
     WORD *pwHandlerId)
 {
     LPHANDLERINFO pCurHandlerInfo = m_pFirstHandler;
     
     Assert(pwHandlerId);
     
     if (clsidHandlerIn == GUID_NULL) 
     {
         *pwHandlerId = 0;
         return S_OK;
         
     }
     while (pCurHandlerInfo && (clsidHandlerIn != pCurHandlerInfo->clsidHandler))
     {      
         pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
     }
     if (NULL == pCurHandlerInfo) // reached end of list without finding the Handler
     {
         *pwHandlerId = 0;
         Assert(0); // user must have passed an invalid start HandlerID.
         return S_FALSE;
     }
     
     *pwHandlerId = pCurHandlerInfo->wHandlerId;
     
     return S_OK;
     
     
 }
 
 //--------------------------------------------------------------------------------
 //
 //  FUNCTION: CHndlrQueue::SetItemListViewID(CLSID clsidHandler,
 //     SYNCMGRITEMID OfflineItemID,INT iItem)                                              
 //
 //  PURPOSE:   assigns all items that match the handler clsid and 
 //             ItemID this listView Value.
 //
 // COMMENTS: 
 //
 //  HISTORY:  01-01-98       SusiA        Created.
 //
 //--------------------------------------------------------------------------------
 STDMETHODIMP CHndlrQueue::SetItemListViewID(CLSID clsidHandler,
     SYNCMGRITEMID OfflineItemID,INT iItem) 
 { 
     LPHANDLERINFO pCurHandlerInfo = NULL;
     LPITEMLIST pCurItem = NULL;
     
     pCurHandlerInfo = m_pFirstHandler;
     
     while (pCurHandlerInfo )
     {
         if (clsidHandler == pCurHandlerInfo->clsidHandler)
         {
             
             pCurItem = pCurHandlerInfo->pFirstItem;
             
             while (pCurItem)
             {
                 if (OfflineItemID == pCurItem->offlineItem.ItemID)
                 {
                     // This can be called at anytime after prepareforSync if a duplicate
                     // is added later to the choice or progress bar.
                     // found a match
                     pCurItem->iItem = iItem;
                 }
                 
                 pCurItem = pCurItem->pnextItem;
             }
         }
         
         pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
     }
     
     return NOERROR;
     
 } 
 
 //--------------------------------------------------------------------------------
 //
 //  FUNCTION: DWORD  CHndlrQueue::GetCheck(WORD wParam, INT iItem)
 //
 //  PURPOSE:   Return the check state for the logon, logoff and 
 //            prompt me first check boxes on the connection number iItem    
 //
 // COMMENTS: 
 //
 //  HISTORY:  01-01-98       SusiA        Created.
 //
 //--------------------------------------------------------------------------------
 
 DWORD  CHndlrQueue::GetCheck(WORD wParam, INT iItem)
 {
     // if no connection list all items are unchecked
     if (!m_ConnectionList)
         return 0;
     
     switch (wParam)
     {
     case IDC_AUTOLOGON: 
         return m_ConnectionList[iItem].dwLogon;
         break;
     case IDC_AUTOLOGOFF:
         return m_ConnectionList[iItem].dwLogoff;
         break;
     case IDC_AUTOPROMPT_ME_FIRST:
         return m_ConnectionList[iItem].dwPromptMeFirst;
         break;
     case IDC_AUTOREADONLY:
         return m_ConnectionList->dwReadOnly;
         break;
     case IDC_AUTOHIDDEN:
         return m_ConnectionList->dwHidden;
         break;
     case IDC_AUTOCONNECT:
         return m_ConnectionList->dwMakeConnection;
         break;
     case IDC_IDLECHECKBOX:
         return m_ConnectionList[iItem].dwIdleEnabled; 
         
     default:
         AssertSz(0,"Unkown SetConnectionCheckBox");
         return 0;
     }
     
 }
 
 //--------------------------------------------------------------------------------
 //
 //  FUNCTION: DWORD  CHndlrQueue::SetConnectionCheck(WORD wParam, DWORD dwState, 
 //                                                 INT iConnectionItem)
 //
 //  PURPOSE:   Set the check state for the logon, logoff and 
 //            prompt me first check boxes on the connection number iConnectionItem  
 //
 // COMMENTS: 
 //
 //  HISTORY:  01-01-98       SusiA        Created.
 //
 //--------------------------------------------------------------------------------
 STDMETHODIMP CHndlrQueue::SetConnectionCheck(WORD wParam, DWORD dwState, INT iConnectionItem)
 {
     
     // if no connection list then just return
     if (!m_ConnectionList)
         return E_OUTOFMEMORY;
     
     switch (wParam)
     {
     case IDC_AUTOLOGON:    
         m_ConnectionList[iConnectionItem].dwLogon = dwState;
         break;
     case IDC_AUTOLOGOFF:
         m_ConnectionList[iConnectionItem].dwLogoff = dwState;
         break;
     case IDC_AUTOPROMPT_ME_FIRST:
         m_ConnectionList[iConnectionItem].dwPromptMeFirst = dwState;
         break;
     case IDC_IDLECHECKBOX:
         m_ConnectionList[iConnectionItem].dwIdleEnabled = dwState;
         break; 
         // these two sare for schedule
     case IDC_AUTOHIDDEN:
         m_ConnectionList->dwHidden = dwState;
         break;
     case IDC_AUTOREADONLY:
         m_ConnectionList->dwReadOnly = dwState;
         break;
     case IDC_AUTOCONNECT:
         m_ConnectionList->dwMakeConnection = dwState;
         break;
     default:
         AssertSz(0,"Unkown SetConnectionCheckBox");
         return E_UNEXPECTED;
     }
     
     return ERROR_SUCCESS;
 }
 //--------------------------------------------------------------------------------
 //
 //  FUNCTION: CHndlrQueue::SetSyncCheckStateFromListViewItem(
 //                                         DWORD dwSyncType,
 //                                         INT iItem,
 //                                         BOOL fChecked,
 //                                         INT iConnectionItem) 
 //
 //
 //  PURPOSE: finds item with this listview ID and sets it appropriately.  
 //
 // COMMENTS: 
 //
 //  HISTORY:  01-01-98       SusiA        Created.
 //
 //--------------------------------------------------------------------------------
 STDMETHODIMP CHndlrQueue::SetSyncCheckStateFromListViewItem(SYNCTYPE SyncType,
     INT iItem,
     BOOL fChecked,
     INT iConnectionItem) 
 { 
     LPHANDLERINFO pCurHandlerInfo = NULL;
     LPITEMLIST pCurItem = NULL;
     DWORD dwState;
     
     pCurHandlerInfo = m_pFirstHandler;
     
     dwState = fChecked ? SYNCMGRITEMSTATE_CHECKED : SYNCMGRITEMSTATE_UNCHECKED;
     
     while (pCurHandlerInfo )
     {
         pCurItem = pCurHandlerInfo->pFirstItem;
         
         while (pCurItem)
         {
             if (iItem == pCurItem->iItem)
             {
                 switch(SyncType)
                 {
                 case  SYNCTYPE_AUTOSYNC: 
                     pCurItem->pItemCheckState[iConnectionItem].dwAutoSync = dwState;
                     break;
                 case  SYNCTYPE_IDLE:
                     pCurItem->pItemCheckState[iConnectionItem].dwIdle = dwState;
                     break;
                 case SYNCTYPE_SCHEDULED:
                     pCurItem->pItemCheckState[iConnectionItem].dwSchedule = dwState;
                     break;
                 default:
                     AssertSz(0,"Unknown Setting type");
                     break;
                 }
                 
                 return NOERROR;
             }
             pCurItem = pCurItem->pnextItem;
         }
         pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
     }
     
     Assert(0); // review - better assert but warn us when try to set a listView item that isn't assigned.
     return S_FALSE; // item wasn't found
     
 } 
 
 //--------------------------------------------------------------------------------
 //
 //  FUNCTION: CHndlrQueue::ListViewItemHasProperties(INT iItem)
 //
 //  PURPOSE: determines if there are properties associated with this item.
 //
 // COMMENTS: 
 //
 //  HISTORY:  01-01-98       SusiA        Created.
 //
 //--------------------------------------------------------------------------------
 STDMETHODIMP CHndlrQueue::ListViewItemHasProperties(INT iItem) 
 { 
     LPHANDLERINFO pCurHandlerInfo = NULL;
     LPITEMLIST pCurItem = NULL;
     
     pCurHandlerInfo = m_pFirstHandler;
     
     while (pCurHandlerInfo )
     {
         pCurItem = pCurHandlerInfo->pFirstItem;
         
         while (pCurItem)
         {
             if (iItem == pCurItem->iItem)
             {
                 
                 Assert(HANDLERSTATE_PREPAREFORSYNC == pCurHandlerInfo->HandlerState); 
                 
                 return pCurItem->offlineItem.dwFlags & SYNCMGRITEM_HASPROPERTIES
                     ? NOERROR : S_FALSE;
             }
             
             pCurItem = pCurItem->pnextItem;
         }
         
         pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
     }
     
     //  Assert(-1 == iItem); // if don't find item, should be because user clicked in list box where there was none
     return S_FALSE; // item wasn't found
     
 }
 
 
 
 //--------------------------------------------------------------------------------
 //
 //  FUNCTION: CHndlrQueue::ShowProperties(HWND hwndParent,INT iItem)
 //
 //  PURPOSE:   find the first item in the queueu with the assigned iItem and 
 //            call there show properties method.
 //
 // COMMENTS: 
 //
 //  HISTORY:  01-01-98       SusiA        Created.
 //
 //--------------------------------------------------------------------------------
 STDMETHODIMP CHndlrQueue::ShowProperties(HWND hwndParent,INT iItem) 
 { 
     LPHANDLERINFO pCurHandlerInfo = NULL;
     LPITEMLIST pCurItem = NULL;
     
     AssertSz(0,"ShowProperties Called from Setttings");
     
     pCurHandlerInfo = m_pFirstHandler;
     
     while (pCurHandlerInfo )
     {
         pCurItem = pCurHandlerInfo->pFirstItem;
         
         while (pCurItem)
         {
             if (iItem == pCurItem->iItem)
             {
                 Assert(HANDLERSTATE_PREPAREFORSYNC == pCurHandlerInfo->HandlerState); 
                 
                 // UI shouldn't call this unless item actually has a properties flag
                 Assert(SYNCMGRITEM_HASPROPERTIES & pCurItem->offlineItem.dwFlags);
                 
                 // make sure properties flag isn't set.
                 if ( (SYNCMGRITEM_HASPROPERTIES & pCurItem->offlineItem.dwFlags))
                 {
                     return pCurHandlerInfo->pSyncMgrHandler->
                         ShowProperties(hwndParent,
                         (pCurItem->offlineItem.ItemID));
                 }
                 
                 return S_FALSE;
             }
             
             pCurItem = pCurItem->pnextItem;
         }
         
         pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
     }
     
     Assert(0); // review - better assert but wanr us when try to set a listView item that isn't assigned.
     return S_FALSE; // item wasn't found
 } 
 
 
 
 //--------------------------------------------------------------------------------
 //
 //  FUNCTION: CHndlrQueue::CreateServer(WORD wHandlerId, const CLSID *pCLSIDServer) 
 //
 //  PURPOSE:  Create the Handler server
 //
 // COMMENTS: 
 //
 //  HISTORY:  01-01-98       SusiA        Created.
 //
 //--------------------------------------------------------------------------------
 
 STDMETHODIMP CHndlrQueue::CreateServer(WORD wHandlerId, const CLSID *pCLSIDServer) 
 { 
     HRESULT hr = NO_ERROR; // review for Lookup failures
     LPHANDLERINFO pHandlerInfo = NULL;
     LPUNKNOWN pUnk;
     
     hr = LookupHandlerFromId(wHandlerId,&pHandlerInfo);
     if (hr == NOERROR)
     {
         if (HANDLERSTATE_CREATE != pHandlerInfo->HandlerState)
         {
             Assert(HANDLERSTATE_CREATE == pHandlerInfo->HandlerState);
             return E_UNEXPECTED;
         }
         
         pHandlerInfo->HandlerState = HANDLERSTATE_INCREATE;
         
         pHandlerInfo->clsidHandler = *pCLSIDServer;
         hr = CoCreateInstance(pHandlerInfo->clsidHandler, 
             NULL, CLSCTX_INPROC_SERVER,
             IID_IUnknown, (void**)&pUnk);
         
         if (NOERROR == hr)
         {
             hr = pUnk->QueryInterface(IID_ISyncMgrSynchronize,
                 (void **) &pHandlerInfo->pSyncMgrHandler);
             
             pUnk->Release();
         }
         
         
         if (NOERROR == hr)
         {
             pHandlerInfo->HandlerState = HANDLERSTATE_INITIALIZE;
         }
         else
         {
             pHandlerInfo->pSyncMgrHandler = NULL;
             pHandlerInfo->HandlerState = HANDLERSTATE_DEAD;
         }
         
     }
     return hr;
 }
 
 
 //--------------------------------------------------------------------------------
 //
 //  FUNCTION: CHndlrQueue::Initialize(WORD wHandlerId,DWORD dwReserved,DWORD dwSyncFlags,
 //                                 DWORD cbCookie,const BYTE *lpCookie) 
 //
 //  PURPOSE: Initialize the handler 
 //
 // COMMENTS: 
 //
 //  HISTORY:  01-01-98       SusiA        Created.
 //
 //--------------------------------------------------------------------------------
 
 STDMETHODIMP CHndlrQueue::Initialize(WORD wHandlerId,DWORD dwReserved,DWORD dwSyncFlags,
     DWORD cbCookie,const BYTE *lpCookie) 
 {
     HRESULT hr = E_UNEXPECTED; // review for Lookup failures
     LPHANDLERINFO pHandlerInfo = NULL;
     
     if (NOERROR == LookupHandlerFromId(wHandlerId,&pHandlerInfo))
     {
         if (HANDLERSTATE_INITIALIZE != pHandlerInfo->HandlerState)
         {
             Assert(HANDLERSTATE_INITIALIZE == pHandlerInfo->HandlerState);
             return E_UNEXPECTED; 
         }
         
         pHandlerInfo->HandlerState = HANDLERSTATE_ININITIALIZE;
         
         Assert(pHandlerInfo->pSyncMgrHandler);
         
         if (NULL != pHandlerInfo->pSyncMgrHandler)
         {
             hr = pHandlerInfo->pSyncMgrHandler->Initialize(dwReserved,dwSyncFlags,cbCookie,lpCookie);
         }
         
         if (NOERROR  == hr)
         {
             pHandlerInfo->HandlerState = HANDLERSTATE_ADDHANDLERTEMS;
             pHandlerInfo->dwSyncFlags = dwSyncFlags; 
         }
         else
         {
             // on an error, go ahead and release the proxy if server doesn't want to handle
             pHandlerInfo->HandlerState = HANDLERSTATE_DEAD;
         }
         
     }
     
     return hr; 
 }
 
 
 //--------------------------------------------------------------------------------
 //
 //  FUNCTION:  CHndlrQueue::AddHandlerItemsToQueue(WORD wHandlerId) 
 //
 //  PURPOSE:  Enumerate the handler items and add them to the queue
 //
 // COMMENTS: 
 //
 //  HISTORY:  01-01-98       SusiA        Created.
 //
 //--------------------------------------------------------------------------------
 
 STDMETHODIMP CHndlrQueue::AddHandlerItemsToQueue(WORD wHandlerId) 
 { 
     HRESULT hr = E_UNEXPECTED; // review for Lookup failures
     LPHANDLERINFO pHandlerInfo = NULL;
     LPSYNCMGRENUMITEMS pEnumOffline = NULL;
     
     if (NOERROR == LookupHandlerFromId(wHandlerId,&pHandlerInfo))
     {
         if (HANDLERSTATE_ADDHANDLERTEMS != pHandlerInfo->HandlerState)
         {
             Assert(HANDLERSTATE_ADDHANDLERTEMS == pHandlerInfo->HandlerState);
             return E_UNEXPECTED; 
         }
         
         pHandlerInfo->HandlerState = HANDLERSTATE_INADDHANDLERITEMS;
         
         Assert(pHandlerInfo->pSyncMgrHandler);
         
         if (pHandlerInfo->pSyncMgrHandler)
         {
             hr = pHandlerInfo->pSyncMgrHandler->EnumSyncMgrItems(&pEnumOffline);
             
             if ( ((S_OK == hr) || (S_SYNCMGR_MISSINGITEMS  == hr)) && pEnumOffline)
             {
                 SYNCMGRITEMNT5B2 offItem; // temporarily use NT5B2 structure since its bigger
                 ULONG pceltFetched;
                 
                 // add the handler info
                 SYNCMGRHANDLERINFO *pSyncMgrHandlerInfo = NULL;
                 
                 // update missing items info
                 if (S_SYNCMGR_MISSINGITEMS == hr)
                     m_fItemsMissing = TRUE;
                 
                 hr = pHandlerInfo->pSyncMgrHandler->GetHandlerInfo(&pSyncMgrHandlerInfo);
                 if (NOERROR == hr && pSyncMgrHandlerInfo)
                 {
                     if (IsValidSyncMgrHandlerInfo(pSyncMgrHandlerInfo))
                     {
                         SetHandlerInfo(wHandlerId,pSyncMgrHandlerInfo);
                     }
                     
                     CoTaskMemFree(pSyncMgrHandlerInfo);
                 }
                 
                 // Get this handlers registration flags
                 BOOL fReg;
                 
                 fReg = RegGetHandlerRegistrationInfo(pHandlerInfo->clsidHandler,
                     &(pHandlerInfo->dwRegistrationFlags));
                 
                 // rely on RegGetHandler to set flags to zero on error
                 // so assert that it does
                 Assert(fReg || (0 == pHandlerInfo->dwRegistrationFlags));
                 
                 
                 hr = NOERROR; // okay to add items even if Gethandler info fails
                 
                 Assert(sizeof(SYNCMGRITEMNT5B2) > sizeof(SYNCMGRITEM));
                 
                 // sit in loop getting data of objects to fill list box.
                 // should really set up list in memory for OneStop to fill in or
                 // main thread could pass in a callback interface.
                 
                 while(NOERROR == pEnumOffline->Next(1,(SYNCMGRITEM *) &offItem,&pceltFetched))
                 {
                     // don't add the item if temporary.
                     if (!(offItem.dwFlags & SYNCMGRITEM_TEMPORARY))
                     {
                         AddItemToHandler(wHandlerId,(SYNCMGRITEM *) &offItem); 
                     }
                 }
                 
                 pEnumOffline->Release();
             }
         }
         
         if (NOERROR  == hr)
         {
             pHandlerInfo->HandlerState = HANDLERSTATE_PREPAREFORSYNC;
         }
         else
         {
             pHandlerInfo->HandlerState = HANDLERSTATE_DEAD;
         }
     }
     
     return hr; 
 }
 
 //+---------------------------------------------------------------------------
 //
 //  Member:     CHndlrQueue::SetHandlerInfo, public
 //
 //  Synopsis:   Adds item to the specified handler.
 //              Called in context of the handlers thread.
 //
 //  Arguments:  [pHandlerId] - Id of handler.
 //              [pSyncMgrHandlerInfo] - Points to SyncMgrHandlerInfo to be filled in.
 //
 //  Returns:    Appropriate Error code
 //
 //  Modifies:
 //
 //  History:    28-Jul-98       rogerg        Created.
 //
 //----------------------------------------------------------------------------
 
 STDMETHODIMP CHndlrQueue::SetHandlerInfo(WORD wHandlerId,LPSYNCMGRHANDLERINFO pSyncMgrHandlerInfo)
 {
     HRESULT hr = E_UNEXPECTED;
     LPHANDLERINFO pHandlerInfo = NULL;
     
     if (!pSyncMgrHandlerInfo)
     {
         return E_INVALIDARG;
         Assert(pSyncMgrHandlerInfo);
     }
     
     
     if (NOERROR == LookupHandlerFromId(wHandlerId,&pHandlerInfo))
     {
         if (HANDLERSTATE_INADDHANDLERITEMS != pHandlerInfo->HandlerState)
         {
             Assert(HANDLERSTATE_INADDHANDLERITEMS == pHandlerInfo->HandlerState);
             hr =  E_UNEXPECTED;
         }
         else
         {
             
             // Review - After clients update turn
             // this check back on
             if (0 /* pSyncMgrHandlerInfo->cbSize != sizeof(SYNCMGRHANDLERINFO) */)
             {
                 hr = E_INVALIDARG;
             }
             else
             {
                 pHandlerInfo->SyncMgrHandlerInfo = *pSyncMgrHandlerInfo;
             }
         }
     }
     
     return hr;
     
 }
 
 
 //--------------------------------------------------------------------------------
 //
 //  FUNCTION: CHndlrQueue::AddItemToHandler(WORD wHandlerId,SYNCMGRITEM *pOffineItem)
 //
 //  PURPOSE:  Add the handler's items 
 //
 // COMMENTS: 
 //
 //  HISTORY:  01-01-98       SusiA        Created.
 //
 //--------------------------------------------------------------------------------
 
 STDMETHODIMP CHndlrQueue::AddItemToHandler(WORD wHandlerId,SYNCMGRITEM *pOffineItem)
 {
     HRESULT hr = E_UNEXPECTED; // review for Lookup failures
     LPHANDLERINFO pHandlerInfo = NULL;
     LPITEMLIST pNewItem = NULL;
     
     if (!IsValidSyncMgrItem(pOffineItem))
     {
         return E_UNEXPECTED;
     }
     
     if (NOERROR == LookupHandlerFromId(wHandlerId,&pHandlerInfo))
     {
         if (HANDLERSTATE_INADDHANDLERITEMS != pHandlerInfo->HandlerState)
         {
             Assert(HANDLERSTATE_INADDHANDLERITEMS == pHandlerInfo->HandlerState);
             return E_UNEXPECTED; 
         }
         
         // Allocate the item.
         pNewItem = (LPITEMLIST) ALLOC(sizeof(*pNewItem));
         
         if (NULL == pNewItem)
         {
             return E_OUTOFMEMORY;
         }
         
         ZeroMemory(pNewItem, sizeof(*pNewItem));
         pNewItem->wItemId =    ++pHandlerInfo->wItemCount;
         pNewItem->pHandlerInfo = pHandlerInfo;
         pNewItem->iItem = -1;
         
         pNewItem->offlineItem = *pOffineItem;
         
         // stick the item on the end of the list
         if (NULL == pHandlerInfo->pFirstItem)
         {
             pHandlerInfo->pFirstItem = pNewItem;
             Assert(1 == pHandlerInfo->wItemCount);
         }
         else
         {
             LPITEMLIST pCurItem;
             
             pCurItem = pHandlerInfo->pFirstItem;
             
             while (pCurItem->pnextItem)
                 pCurItem = pCurItem->pnextItem;
             
             pCurItem->pnextItem = pNewItem;
             
             Assert ((pCurItem->wItemId + 1) == pNewItem->wItemId);
         }
         
         hr = NOERROR;
     }
     
     return hr;
 }
 
 //--------------------------------------------------------------------------------
 //
 //  FUNCTION: CHndlrQueue::LookupHandlerFromId(WORD wHandlerId,
 //                                     LPHANDLERINFO *pHandlerInfo)
 //
 //  PURPOSE:  finds associated hander data from the handler ID
 //
 // COMMENTS: 
 //
 //  HISTORY:  01-01-98       SusiA        Created.
 //
 //--------------------------------------------------------------------------------
 
 STDMETHODIMP CHndlrQueue::LookupHandlerFromId(WORD wHandlerId,LPHANDLERINFO *pHandlerInfo)
 {
     HRESULT hr = E_UNEXPECTED; // review error code.
     LPHANDLERINFO pCurItem;
     
     *pHandlerInfo = NULL; 
     pCurItem = m_pFirstHandler;
     
     while (pCurItem)
     {
         if (wHandlerId == pCurItem->wHandlerId )
         {
             *pHandlerInfo = pCurItem;
             hr = NOERROR;
             break;
         }
         
         pCurItem = pCurItem->pNextHandler;
     }
     
     return hr;
 }
 
 //--------------------------------------------------------------------------------
 //
 //  FUNCTION: CHndlrQueue::InitAutoSyncSettings(HWND hwndRasCombo)
 //
 //  PURPOSE:  Initialize the autosync settings per the connections 
 //             listed in this RasCombo
 //
 // COMMENTS: Ras based (connection name as identifier) When connection object
 //           based, we will use the connection GUID to identify the connection 
 //           settings
 //
 //  HISTORY:  01-01-98       SusiA        Created.
 //
 //--------------------------------------------------------------------------------
 
 STDMETHODIMP CHndlrQueue::InitSyncSettings(SYNCTYPE syncType,HWND hwndRasCombo)
 {
     SCODE sc = S_OK;
     int i;
     
     // This function gets possibly gets called twice
     // once for AuotSync and once for Idle if already have
     // a connection list then use existing
     
     if (NULL == m_ConnectionList)
     {
         m_ConnectionCount = ComboBox_GetCount(hwndRasCombo);
         
         if (m_ConnectionCount > 0)
         {  
             smMem(m_ConnectionList = (LPCONNECTIONSETTINGS) 
                 ALLOC(m_ConnectionCount * sizeof(CONNECTIONSETTINGS)));
             
         }
     }
     
     // if now have a connection list set the appropriate settings
     if (m_ConnectionList)
     {
         COMBOBOXEXITEM comboItem;
         
         for (i=0; i<m_ConnectionCount; i++)
         {
             comboItem.mask = CBEIF_TEXT;
             comboItem.cchTextMax = RAS_MaxEntryName + 1;
             comboItem.pszText = m_ConnectionList[i].pszConnectionName;
             comboItem.iItem = i;
             
             // Review what happens on failure
             SendMessage(hwndRasCombo, CBEM_GETITEM, (WPARAM) 0, (LPARAM) &comboItem);
             
             switch (syncType)
             {
             case SYNCTYPE_AUTOSYNC:
                 RegGetAutoSyncSettings(&(m_ConnectionList[i]));
                 break;
             case SYNCTYPE_IDLE:
                 RegGetIdleSyncSettings(&(m_ConnectionList[i]));
                 break;
             default:
                 AssertSz(0,"Unknown SyncType");
                 break;
             }
         }
     }
     
EH_Err:
     return sc;  
 }
 
 //--------------------------------------------------------------------------------
 //
 //  FUNCTION: CHndlrQueue::InitSchedSyncSettings(LPCONNECTIONSETTINGS pConnectionSettings)
 //
 //  PURPOSE:  Initialize the scheduled Sync settings per the connections 
 //             listed in this RasCombo
 //
 // COMMENTS: Ras based (connection name as identifier) When connection object
 //           based, we will use the connection GUID to identify the connection 
 //           settings
 //
 //  HISTORY:  01-01-98       SusiA        Created.
 //
 //--------------------------------------------------------------------------------
 
 STDMETHODIMP CHndlrQueue::InitSchedSyncSettings(LPCONNECTIONSETTINGS pConnectionSettings)
 {
     m_ConnectionList = pConnectionSettings;
     
     return S_OK;  
 }
 
 //--------------------------------------------------------------------------------
 //
 //  FUNCTION: CHndlrQueue::ReadSchedSyncSettingsPerConnection(WORD wHandlerID, 
 //                                                            TCHAR * pszSchedName)
 //
 //  PURPOSE:  Read the scheduled Sync settings from the registry.  
 //           If there is no entry in the registry, the default is the 
 //           check state of the current offline item
 //
 // COMMENTS: Ras based (connection name as identifier) When connection object
 //           based, we will use the connection GUID to identify the connection 
 //           settings
 //
 //  HISTORY:  01-01-98       SusiA        Created.
 //
 //--------------------------------------------------------------------------------
 STDMETHODIMP CHndlrQueue::ReadSchedSyncSettingsOnConnection(WORD wHandlerID,TCHAR * pszSchedName)
 {
     HRESULT hr = E_UNEXPECTED; // review for Lookup failures
     LPHANDLERINFO pHandlerInfo = NULL;
     
     Assert(m_ConnectionList != NULL);
     
     if (!m_ConnectionList)
         return E_UNEXPECTED;
     
     //Set the Check set of this item per connection
     if (NOERROR == LookupHandlerFromId(wHandlerID,&pHandlerInfo))
     {
         LPITEMLIST pCurItem = pHandlerInfo->pFirstItem;
         
         while (pCurItem)
         {
             //Scheduled sync only works on one connection
             Assert(NULL == pCurItem->pItemCheckState );
             
             pCurItem->pItemCheckState = (ITEMCHECKSTATE*) ALLOC(sizeof(*(pCurItem->pItemCheckState)));
             
             if (!pCurItem->pItemCheckState)
             {
                 return E_OUTOFMEMORY;
             }
             
             // by default no items in the schedule are checked.
             pCurItem->pItemCheckState[0].dwSchedule = FALSE;
             
             
             // possible for schedule name to be null when schedule first created.
             if (pszSchedName)
             {
                 
                 RegGetSyncItemSettings(SYNCTYPE_SCHEDULED,
                     pHandlerInfo->clsidHandler,
                     pCurItem->offlineItem.ItemID,
                     m_ConnectionList->pszConnectionName,
                     &(pCurItem->pItemCheckState[0].dwSchedule),
                     pCurItem->offlineItem.dwItemState,
                     pszSchedName);
             }
             
             pCurItem = pCurItem->pnextItem;
         }
         
     }
     return hr;
     
 }
 
 //--------------------------------------------------------------------------------
 //
 //  FUNCTION: CHndlrQueue::InsertItem(LPHANDLERINFO pCurHandler, 
 //                              LPSYNC_HANDLER_ITEM_INFO pHandlerItemInfo)
 //
 //  PURPOSE:  App is programatically adding an item to the schedule 
 //     with a default check state
 //
 //  HISTORY:  11-25-98       SusiA        Created.
 //
 //--------------------------------------------------------------------------------
 STDMETHODIMP CHndlrQueue::InsertItem(LPHANDLERINFO pCurHandler, 
     LPSYNC_HANDLER_ITEM_INFO pHandlerItemInfo)
 {
     LPITEMLIST pCurItem = pCurHandler->pFirstItem;
     
     while (pCurItem)
     {
         if (pHandlerItemInfo->itemID == pCurItem->offlineItem.ItemID)
         {
             pCurItem->pItemCheckState[0].dwSchedule = pHandlerItemInfo->dwCheckState;
             pCurItem->offlineItem.hIcon = pHandlerItemInfo->hIcon;
             return StringCchCopy(pCurItem->offlineItem.wszItemName, 
                 ARRAYSIZE(pCurItem->offlineItem.wszItemName), 
                 pHandlerItemInfo->wszItemName);
         }
         pCurItem = pCurItem->pnextItem;
         
     }
     if (!pCurItem)
     {
         
         //Item was not found on the handler, add it now
         // Allocate the item.
         LPITEMLIST pNewItem = (LPITEMLIST) ALLOC(sizeof(*pNewItem));
         
         if (NULL == pNewItem)
         {
             return E_OUTOFMEMORY;
         }
         
         ZeroMemory(pNewItem,sizeof(*pNewItem));
         pNewItem->wItemId =     ++pCurHandler->wItemCount;
         pNewItem->pHandlerInfo = pCurHandler;
         pNewItem->iItem = -1;
         
         SYNCMGRITEM *pOfflineItem = (LPSYNCMGRITEM) ALLOC(sizeof(*pOfflineItem));
         
         if (NULL == pOfflineItem)
         {
             FREE(pNewItem);
             return E_OUTOFMEMORY;
         }
         
         ZeroMemory(pOfflineItem, sizeof(*pOfflineItem));
         pNewItem->offlineItem = *pOfflineItem;
         pNewItem->offlineItem.hIcon = pHandlerItemInfo->hIcon;
         pNewItem->offlineItem.ItemID = pHandlerItemInfo->itemID;
         HRESULT hrCopy = StringCchCopy(pNewItem->offlineItem.wszItemName,
             ARRAYSIZE(pNewItem->offlineItem.wszItemName),
             pHandlerItemInfo->wszItemName);
         if (FAILED(hrCopy))
         {
             FREE(pNewItem);
             FREE(pOfflineItem);
             return hrCopy;
         }
         
         //Scheduled sync only works on one connection
         Assert(NULL == pNewItem->pItemCheckState );
         
         pNewItem->pItemCheckState = (ITEMCHECKSTATE*) ALLOC(sizeof(*(pNewItem->pItemCheckState)));
         if (!pNewItem->pItemCheckState)
         {
             FREE(pNewItem);
             FREE(pOfflineItem);
             return E_OUTOFMEMORY;
         }        
         pNewItem->pItemCheckState[0].dwSchedule = pHandlerItemInfo->dwCheckState;
         
         // stick the item on the end of the list
         if (NULL == pCurHandler->pFirstItem)
         {
             pCurHandler->pFirstItem = pNewItem;
             Assert(1 == pCurHandler->wItemCount);
         }
         else
         {
             pCurItem = pCurHandler->pFirstItem;
             
             while (pCurItem->pnextItem)
                 pCurItem = pCurItem->pnextItem;
             
             pCurItem->pnextItem = pNewItem;
             
             Assert ((pCurItem->wItemId + 1) == pNewItem->wItemId);
         }
     }
     return S_OK;           
 }
 //--------------------------------------------------------------------------------
 //
 //  FUNCTION: CHndlrQueue::AddHandlerItem(LPSYNC_HANDLER_ITEM_INFO pHandlerItemInfo)
 //
 //  PURPOSE:  App is programatically adding an item to the schedule 
 //     with this default check state
 //
 //  HISTORY:  03-05-98       SusiA        Created.
 //
 //--------------------------------------------------------------------------------
 STDMETHODIMP CHndlrQueue::AddHandlerItem(LPSYNC_HANDLER_ITEM_INFO pHandlerItemInfo)
 { 
     LPHANDLERINFO pCurHandlerInfo = NULL;
     SCODE sc = S_OK;
     
     pCurHandlerInfo = m_pFirstHandler;
     
     while (pCurHandlerInfo )
     {
         if (pHandlerItemInfo->handlerID == pCurHandlerInfo->clsidHandler)
         {
             
             return InsertItem(pCurHandlerInfo, pHandlerItemInfo);
             
         }
         pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
     }
     //if the handler is not loaded, just cache the new item.
     return SYNCMGR_E_HANDLER_NOT_LOADED;
 } 
 
 //--------------------------------------------------------------------------------
 //
 //  FUNCTION: CHndlrQueue::SetItemCheck(REFCLSID pclsidHandler,
 //                     SYNCMGRITEMID *pOfflineItemID, DWORD dwCheckState)
 //
 //  PURPOSE:  App is programatically setting the check state of an item
 //
 //  HISTORY:  03-05-98       SusiA        Created.
 //
 //--------------------------------------------------------------------------------
 STDMETHODIMP CHndlrQueue::SetItemCheck(REFCLSID pclsidHandler,
     SYNCMGRITEMID *pOfflineItemID, DWORD dwCheckState)
 { 
     LPHANDLERINFO pCurHandlerInfo = NULL;
     LPITEMLIST pCurItem = NULL;
     
     pCurHandlerInfo = m_pFirstHandler;
     
     while (pCurHandlerInfo )
     {
         if (pclsidHandler == pCurHandlerInfo->clsidHandler)
         {
             pCurItem = pCurHandlerInfo->pFirstItem;
             
             while (pCurItem)
             {
                 if (*pOfflineItemID == pCurItem->offlineItem.ItemID)
                 {
                     pCurItem->pItemCheckState[0].dwSchedule = dwCheckState;
                     return S_OK;
                 }
                 pCurItem = pCurItem->pnextItem;
             }
             return SYNCMGR_E_ITEM_UNREGISTERED; 
         }
         pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
     }
     
     //if the handler is not loaded, just cache the new item
     return SYNCMGR_E_HANDLER_NOT_LOADED;
 } 
 
 
 //--------------------------------------------------------------------------------
 //
 //  FUNCTION: HndlrQueue::GetItemCheck(REFCLSID pclsidHandler,
 //                     SYNCMGRITEMID *pOfflineItemID, DWORD *pdwCheckState)
 //  PURPOSE:  App is programatically setting the check state of an item
 //
 //  HISTORY:  03-05-98       SusiA        Created.
 //
 //--------------------------------------------------------------------------------
 STDMETHODIMP CHndlrQueue::GetItemCheck(REFCLSID pclsidHandler,
     SYNCMGRITEMID *pOfflineItemID, DWORD *pdwCheckState)
 { 
     LPHANDLERINFO pCurHandlerInfo = NULL;
     LPITEMLIST pCurItem = NULL;
     
     pCurHandlerInfo = m_pFirstHandler;
     
     while (pCurHandlerInfo )
     {
         if (pclsidHandler == pCurHandlerInfo->clsidHandler)
         {
             pCurItem = pCurHandlerInfo->pFirstItem;
             
             while (pCurItem)
             {
                 if (*pOfflineItemID == pCurItem->offlineItem.ItemID)
                 {
                     *pdwCheckState = pCurItem->pItemCheckState[0].dwSchedule;
                     return S_OK;
                 }
                 pCurItem = pCurItem->pnextItem;
             }
             return SYNCMGR_E_ITEM_UNREGISTERED;
         }
         pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
     }
     
     //if the handler is not loaded, just cache the new item
     return SYNCMGR_E_HANDLER_NOT_LOADED;
     
 } 
 
 //--------------------------------------------------------------------------------
 //
 //  FUNCTION: CHndlrQueue::ReadSyncSettingsPerConnection(SYNCTYPE syncType, 
 //                                                          WORD wHandlerID)
 //
 //  PURPOSE:  Read the autosync settings from the registry.  
 //           If there is no entry in the registry, the default is the 
 //           check state of the current offline item
 //
 // COMMENTS: Ras based (connection name as identifier) When connection object
 //           based, we will use the connection GUID to identify the connection 
 //           settings
 //
 //--------------------------------------------------------------------------------
 STDMETHODIMP CHndlrQueue::ReadSyncSettingsPerConnection(SYNCTYPE syncType, 
     WORD wHandlerID)
 {
     HRESULT hr = E_UNEXPECTED; // review for Lookup failures
     LPHANDLERINFO pHandlerInfo = NULL;
     
     int i;
     
     if (0 == m_ConnectionCount)
         return S_FALSE;
     
     Assert(m_ConnectionList != NULL);
     Assert(m_ConnectionCount != 0);
     
     //Set the Check set of this item per connection
     if (NOERROR == LookupHandlerFromId(wHandlerID,&pHandlerInfo))
     {
         LPITEMLIST pCurItem = pHandlerInfo->pFirstItem;
         
         while (pCurItem)
         {
             
             // if don't alreayd have a checkStateAllocate one.
             if (!pCurItem->pItemCheckState)
             {
                 pCurItem->pItemCheckState = (ITEMCHECKSTATE*) ALLOC(m_ConnectionCount * sizeof(ITEMCHECKSTATE));
             }
             
             if (!pCurItem->pItemCheckState)
             {
                 return E_OUTOFMEMORY;
             }  
             
             for (i=0; i<m_ConnectionCount; i++)
             {
                 DWORD dwDefaultCheck;
                 
                 // if handler hasn't registered for the
                 // event then set its check state fo uncheck
                 // we do this in each case. to start off with
                 // assume the handler is registered
                 
                 // If change this logic need to also change logic in exe hndlrq.
                 
                 
                 dwDefaultCheck = pCurItem->offlineItem.dwItemState;
                 
                 switch (syncType)
                 {
                 case SYNCTYPE_AUTOSYNC:
                     
                     if (0 == (pHandlerInfo->dwRegistrationFlags 
                         & (SYNCMGRREGISTERFLAG_CONNECT | SYNCMGRREGISTERFLAG_PENDINGDISCONNECT)))
                     {
                         dwDefaultCheck = SYNCMGRITEMSTATE_UNCHECKED;
                     }
                     
                     RegGetSyncItemSettings(SYNCTYPE_AUTOSYNC,
                         pHandlerInfo->clsidHandler,
                         pCurItem->offlineItem.ItemID,
                         m_ConnectionList[i].pszConnectionName,
                         &(pCurItem->pItemCheckState[i].dwAutoSync),
                         dwDefaultCheck,
                         NULL);
                     
                     break;
                 case SYNCTYPE_IDLE:
                     
                     if (0 == (pHandlerInfo->dwRegistrationFlags & (SYNCMGRREGISTERFLAG_IDLE) ))
                     {
                         dwDefaultCheck = SYNCMGRITEMSTATE_UNCHECKED;
                     }
                     
                     RegGetSyncItemSettings(SYNCTYPE_IDLE,
                         pHandlerInfo->clsidHandler,
                         pCurItem->offlineItem.ItemID,
                         m_ConnectionList[i].pszConnectionName,
                         &(pCurItem->pItemCheckState[i].dwIdle),
                         dwDefaultCheck,
                         NULL);
                     break;
                 default:
                     AssertSz(0,"Unknown SyncType");
                     break;
                 }
                 
             }
             pCurItem = pCurItem->pnextItem;
         }
         
     }
     
     return hr;
 }
 
 //--------------------------------------------------------------------------------
 //
 //  FUNCTION: CHndlrQueue::ReadAdvancedIdleSettings
 //
 //  PURPOSE:  Reads in the advanced Idle Settings.
 //
     // COMMENTS: 
 //
 //  HISTORY:  01-01-98       SusiA        Created.
 //
 //--------------------------------------------------------------------------------
 
 STDMETHODIMP CHndlrQueue::ReadAdvancedIdleSettings(LPCONNECTIONSETTINGS pConnectionSettings)
 {
     
     // connection settings for global idle are really overloaded.
     // advanced idle settings are in each connection so just copy it from 
     // whatever the first connection is.
     
     if ( (m_ConnectionCount < 1) || (NULL == m_ConnectionList))
         return S_FALSE;
     
     
     *pConnectionSettings = m_ConnectionList[0];
     
     return NOERROR;
 }
 
 STDMETHODIMP CHndlrQueue::WriteAdvancedIdleSettings(LPCONNECTIONSETTINGS pConnectionSettings)
 {
     int iIndex;
     
     // connection settings for global idle are really overloaded.
     // advanced idle settings are in each connection so copy the members into each
     // loaded connection in the list
     
     for (iIndex = 0; iIndex < m_ConnectionCount; iIndex++)
     {
         m_ConnectionList[iIndex].ulIdleWaitMinutes = pConnectionSettings->ulIdleWaitMinutes;
         m_ConnectionList[iIndex].ulIdleRetryMinutes = pConnectionSettings->ulIdleRetryMinutes;
         m_ConnectionList[iIndex].dwRepeatSynchronization = pConnectionSettings->dwRepeatSynchronization;
         m_ConnectionList[iIndex].dwRunOnBatteries = pConnectionSettings->dwRunOnBatteries;
         m_ConnectionList[iIndex].ulIdleWaitMinutes = pConnectionSettings->ulIdleWaitMinutes;
         
         
     }
     
     return NOERROR;
 }
 
 
 
 //--------------------------------------------------------------------------------
 //
 //  FUNCTION: CHndlrQueue::CommitAutoSyncChanges(Ras *pRas)
 //
 //  PURPOSE:  Write the autosync settings to the registry.  This is done when
 //           the user selects OK or APPLY from the settings dialog.
 //
 // COMMENTS: 
 //
 //  HISTORY:  01-01-98       SusiA        Created.
 //
 //--------------------------------------------------------------------------------
 STDMETHODIMP CHndlrQueue::CommitSyncChanges(SYNCTYPE syncType,CRasUI *pRas)
 {
     LPHANDLERINFO pHandlerInfo;
     int i;
     
     if (!m_ConnectionList) // if no connection list, nothing to do
     {
         Assert(m_ConnectionList);
         return NOERROR;
     }
     
     switch (syncType)
     {
     case SYNCTYPE_AUTOSYNC:
         RegSetAutoSyncSettings(m_ConnectionList, m_ConnectionCount, pRas,
             !m_fItemsMissing /* fCleanReg */,
             TRUE /* fSetMachineState */,
             TRUE /* fPerUser */);
         
         break;
     case SYNCTYPE_IDLE:
         RegSetIdleSyncSettings(m_ConnectionList, m_ConnectionCount, pRas,
             !m_fItemsMissing /* fCleanReg */,
             TRUE /* fPerUser */);
         
         break;
     default:
         AssertSz(0,"Unknown SyncType");
         break;
     }
     
     for (i=0; i<m_ConnectionCount; i++)
     {
         
         pHandlerInfo = m_pFirstHandler;
         
         while (pHandlerInfo)
         {
             LPITEMLIST pCurItem = pHandlerInfo->pFirstItem;
             BOOL fAnyItemsChecked = FALSE;
             
             while (pCurItem)
             {
                 switch (syncType)
                 {
                 case SYNCTYPE_AUTOSYNC:
                     
                     fAnyItemsChecked |= pCurItem->pItemCheckState[i].dwAutoSync;
                     
                     RegSetSyncItemSettings(syncType,
                         pHandlerInfo->clsidHandler,
                         pCurItem->offlineItem.ItemID,
                         m_ConnectionList[i].pszConnectionName,
                         pCurItem->pItemCheckState[i].dwAutoSync,
                         NULL);
                     break;
                 case SYNCTYPE_IDLE:
                     
                     fAnyItemsChecked |= pCurItem->pItemCheckState[i].dwIdle;
                     
                     RegSetSyncItemSettings(syncType,
                         pHandlerInfo->clsidHandler,
                         pCurItem->offlineItem.ItemID,
                         m_ConnectionList[i].pszConnectionName,
                         pCurItem->pItemCheckState[i].dwIdle,
                         NULL);
                     break;
                 }
                 
                 pCurItem = pCurItem->pnextItem;
             }
             
             // write out the NoItems checked value on the handler for this connection
             RegSetSyncHandlerSettings(syncType,
                 m_ConnectionList[i].pszConnectionName,
                 pHandlerInfo->clsidHandler,
                 fAnyItemsChecked ? 1 : 0);
             
             
             pHandlerInfo = pHandlerInfo->pNextHandler;
         }
     }
     
     return ERROR_SUCCESS;
     
 }
 
 
 
 //--------------------------------------------------------------------------------
 //
 //  FUNCTION: CHndlrQueue::CommitSchedSyncChanges(TCHAR * pszSchedName,
 //                       TCHAR * pszFriendlyName,
 //                       TCHAR * pszConnectionName,
 //                       DWORD dwConnType,
 //                                           BOOL fCleanReg)
 //
 //
 //  PURPOSE:  Write the scheduled sync settings to the registry.  This is done when
 //            the user selects OK or FINISH from the settings dialog.
 //
 //  COMMENTS: 
 //
 //  HISTORY:  01-01-98       SusiA        Created.
 //
 //--------------------------------------------------------------------------------
 STDMETHODIMP CHndlrQueue::CommitSchedSyncChanges(TCHAR * pszSchedName,
     TCHAR * pszFriendlyName,
     TCHAR * pszConnectionName,
     DWORD dwConnType,
     BOOL fCleanReg)
 {
     HRESULT hr;
     LPHANDLERINFO pHandlerInfo;
     pHandlerInfo = m_pFirstHandler;
     
     if (!m_ConnectionList) // Review - What should we do here?
     {
         hr = E_FAIL;
     }
     else
     {
         if (fCleanReg && !m_fItemsMissing)
         {
             RegRemoveScheduledTask(pszSchedName); // Remove any previous settings
         }
         
         hr = StringCchCopy(m_ConnectionList->pszConnectionName, 
             ARRAYSIZE(m_ConnectionList->pszConnectionName), 
             pszConnectionName);
         if (SUCCEEDED(hr))
         {
             m_ConnectionList->dwConnType = dwConnType;
             
             //set the SID on this schedule
             if (!RegSetSIDForSchedule(pszSchedName) || 
                 !RegSetSchedFriendlyName(pszSchedName,pszFriendlyName))
             {
                 hr = E_FAIL;
             }
             else
             {
                 RegSetSchedSyncSettings(m_ConnectionList, pszSchedName);
                 
                 while (pHandlerInfo)
                 {
                     LPITEMLIST pCurItem = pHandlerInfo->pFirstItem;
                     
                     while (pCurItem)
                     {
                         RegSetSyncItemSettings(SYNCTYPE_SCHEDULED,
                             pHandlerInfo->clsidHandler,
                             pCurItem->offlineItem.ItemID,
                             m_ConnectionList->pszConnectionName,
                             pCurItem->pItemCheckState[0].dwSchedule,
                             pszSchedName);
                         
                         pCurItem = pCurItem->pnextItem;
                     }
                     
                     pHandlerInfo = pHandlerInfo->pNextHandler;
                 }
                 hr = S_OK;
             }
         }
     }
     return hr;
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\dll\invoke.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       Invoke.cpp
//
//  Contents:   IOfflineSynchronizeInvoke interface
//
//  Classes:    CSyncMgrSynchronize
//
//  Notes:
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

int CALLBACK SchedWizardPropSheetProc( HWND hwndDlg, UINT uMsg, LPARAM lParam);
DWORD StartScheduler();
BOOL IsFriendlyNameInUse(LPTSTR ptszScheduleGUIDName, UINT cchScheduleGUIDName, LPCTSTR ptstrFriendlyName);
IsScheduleNameInUse(LPTSTR ptszScheduleGUIDName);

extern HINSTANCE g_hmodThisDll;
extern UINT      g_cRefThisDll;

//+--------------------------------------------------------------
//
//  Class:     CSyncMgrSynchronize
//
//  FUNCTION: CSyncMgrSynchronize::CSyncMgrSynchronize()
//
//  PURPOSE: Constructor
//
//  History:  27-Feb-98       rogerg        Created.
//
//--------------------------------------------------------------------------------
CSyncMgrSynchronize::CSyncMgrSynchronize()
{
    TRACE("CSyncMgrSynchronize::CSyncMgrSynchronize()\r\n");
    
    m_cRef = 1;
    g_cRefThisDll++;
    m_pITaskScheduler = NULL;
    
}

//+--------------------------------------------------------------
//
//  Class:     CSyncMgrSynchronize
//
//  FUNCTION: CSyncMgrSynchronize::~CSyncMgrSynchronize()
//
//  PURPOSE: Destructor
//
//  History:  27-Feb-98       rogerg        Created.
//
//--------------------------------------------------------------------------------
CSyncMgrSynchronize::~CSyncMgrSynchronize()
{
    if (m_pITaskScheduler)
    {
        m_pITaskScheduler->Release();
    }
    g_cRefThisDll--;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncMgrSynchronize::QueryInterface(REFIID riid, LPVOID FAR *ppv)
//
//  PURPOSE:  QI for the CSyncMgrSynchronize
//
//  History:  27-Feb-98       rogerg        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncMgrSynchronize::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
    {
        TRACE("CSyncMgrDllObject::QueryInterface()==>IID_IUknown\r\n");
        
        *ppv = (LPSYNCMGRSYNCHRONIZEINVOKE) this;
    }
    else if (IsEqualIID(riid, IID_ISyncMgrSynchronizeInvoke))
    {
        TRACE("CSyncMgrDllObject::QueryInterface()==>IID_IOfflineSynchronizeInvoke\r\n");
        
        *ppv = (LPSYNCMGRSYNCHRONIZEINVOKE) this;
    }
    else if (IsEqualIID(riid, IID_ISyncMgrRegister))
    {
        TRACE("CSyncMgrDllObject::QueryInterface()==>IID_ISyncmgrSynchronizeRegister\r\n");
        
        *ppv = (LPSYNCMGRREGISTER) this;
    }
    else if (IsEqualIID(riid, IID_ISyncMgrRegisterCSC))
    {
        TRACE("CSyncMgrDllObject::QueryInterface()==>IID_ISyncmgrSynchronizeRegisterCSC\r\n");
        
        *ppv = (LPSYNCMGRREGISTERCSC) this;
    }
    else if (IsEqualIID(riid, IID_ISyncScheduleMgr))
    {
        TRACE("CSyncMgrDllObject::QueryInterface()==>IID_ISyncScheduleMgr\r\n");
        if (SUCCEEDED(InitializeScheduler()))
        {
            *ppv = (LPSYNCSCHEDULEMGR) this;
        }
    }
    
    if (*ppv)
    {
        AddRef();
        
        return NOERROR;
    }
    
    TRACE("CSyncMgrDllObject::QueryInterface()==>Unknown Interface!\r\n");
    
    return E_NOINTERFACE;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncMgrSynchronize::AddRef()
//
//  PURPOSE: Addref the CSyncMgrSynchronize
//
//  History:  27-Feb-98       rogerg        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSyncMgrSynchronize::AddRef()
{
    TRACE("CSyncMgrSynchronize::AddRef()\r\n");
    
    return ++m_cRef;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncMgrSynchronize::Release()
//
//  PURPOSE: Release the CSyncMgrSynchronize
//
//  History:  27-Feb-98       rogerg        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSyncMgrSynchronize::Release()
{
    TRACE("CSyncMgrSynchronize::Release()\r\n");
    
    if (--m_cRef)
        return m_cRef;
    
    delete this;
    
    return 0L;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncMgrSynchronize::UpdateItems(DWORD dwInvokeFlags,
//                              REFCLSID rclsid,DWORD cbCookie,const BYTE *lpCookie)
//
//  PURPOSE:
//
//  History:  27-Feb-98       rogerg        Created.
//
//--------------------------------------------------------------------------------

#define SYNCMGRINVOKEFLAGS_MASK (SYNCMGRINVOKE_STARTSYNC | SYNCMGRINVOKE_MINIMIZED)

STDMETHODIMP CSyncMgrSynchronize::UpdateItems(DWORD dwInvokeFlags,
                                              REFCLSID rclsid,DWORD cbCookie,const BYTE *lpCookie)
{
    HRESULT hr = E_UNEXPECTED;
    LPUNKNOWN lpUnk;
    
    // verify invoke flags are valid
    if (0 != (dwInvokeFlags & ~(SYNCMGRINVOKEFLAGS_MASK)) )
    {
        AssertSz(0,"Invalid InvokeFlags passed to UpdateItems");
        return E_INVALIDARG;
    }
    
    hr = CoCreateInstance(CLSID_SyncMgrp,NULL,CLSCTX_SERVER,IID_IUnknown,(void **) &lpUnk);
    
    if (NOERROR == hr)
    {
        LPPRIVSYNCMGRSYNCHRONIZEINVOKE pSynchInvoke = NULL;
        
        hr = lpUnk->QueryInterface(IID_IPrivSyncMgrSynchronizeInvoke,
            (void **) &pSynchInvoke);
        
        if (NOERROR == hr)
        {
            AllowSetForegroundWindow(ASFW_ANY); // let mobsync.exe come to front if necessary
            hr = pSynchInvoke->UpdateItems(dwInvokeFlags,rclsid,cbCookie,lpCookie);
            pSynchInvoke->Release();
        }
        
        
        lpUnk->Release();
    }
    
    return hr; // review error code
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncMgrSynchronize::UpdateAll()
//
//  PURPOSE:
//
//  History:  27-Feb-98       rogerg        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncMgrSynchronize::UpdateAll()
{
    HRESULT hr;
    LPUNKNOWN lpUnk;
    
    
    // programmatically pull up the choice dialog.
    
    hr = CoCreateInstance(CLSID_SyncMgrp,NULL,CLSCTX_SERVER,IID_IUnknown,(void **) &lpUnk);
    
    if (NOERROR == hr)
    {
        LPPRIVSYNCMGRSYNCHRONIZEINVOKE pSynchInvoke = NULL;
        
        hr = lpUnk->QueryInterface(IID_IPrivSyncMgrSynchronizeInvoke,
            (void **) &pSynchInvoke);
        
        if (NOERROR == hr)
        {
            
            AllowSetForegroundWindow(ASFW_ANY); // let mobsync.exe come to front if necessary
            
            pSynchInvoke->UpdateAll();
            pSynchInvoke->Release();
        }
        
        
        lpUnk->Release();
    }
    
    
    return NOERROR; // review error code
}

// Registration implementation

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncMgrSynchronize::RegisterSyncMgrHandler(REFCLSID rclsidHandler,DWORD dwReserved)
//
//  PURPOSE:  Programmatic way of registering handlers
//
//  History:  17-Mar-98       rogerg        Created.
//
//--------------------------------------------------------------------------------

STDMETHODIMP CSyncMgrSynchronize::RegisterSyncMgrHandler(REFCLSID rclsidHandler,
                                                         WCHAR const * pwszDescription,
                                                         DWORD dwSyncMgrRegisterFlags)
{
    if (0 != (dwSyncMgrRegisterFlags & ~(SYNCMGRREGISTERFLAGS_MASK)) )
    {
        AssertSz(0,"Invalid Registration Flags");
        return E_INVALIDARG;
    }
    
    BOOL fFirstRegistration = FALSE;
    HRESULT hr = E_FAIL;
    
    // Add the Handler to the the list
    if ( RegRegisterHandler(rclsidHandler, pwszDescription,dwSyncMgrRegisterFlags, &fFirstRegistration) )
    {
        hr = S_OK;
    }
    
    return hr;
}



//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncMgrSynchronize::RegisterSyncMgrHandler(REFCLSID rclsidHandler,DWORD dwReserved)
//
//  PURPOSE:  Programmatic way of registering handlers
//
//  History:  17-Mar-98       rogerg        Created.
//
//--------------------------------------------------------------------------------

// methods here to support the old IDL since it is no
// longer called it could be removed.
STDMETHODIMP CSyncMgrSynchronize::RegisterSyncMgrHandler(REFCLSID rclsidHandler,
                                                         DWORD dwReserved)
{
    HRESULT hr = RegisterSyncMgrHandler( rclsidHandler, 0, dwReserved );
    
    return hr;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncMgrSynchronize::UnregisterSyncMgrHandler(REFCLSID rclsidHandler)
//
//  PURPOSE:  Programmatic way of unregistering handlers
//
//  History:  17-Mar-98       rogerg        Created.
//
//--------------------------------------------------------------------------------

STDMETHODIMP CSyncMgrSynchronize::UnregisterSyncMgrHandler(REFCLSID rclsidHandler,DWORD dwReserved)
{
    if (dwReserved)
    {
        Assert(0 == dwReserved);
        return E_INVALIDARG;
    }
    
    HRESULT hr = E_FAIL;
    
    if (RegRegRemoveHandler(rclsidHandler))
    {
        hr = NOERROR;
    }
    
    return hr;
}


//--------------------------------------------------------------------------------
//
//  member: CSyncMgrSynchronize::GetHandlerRegistrationInfo(REFCLSID rclsidHandler)
//
//  PURPOSE:  Allows Handler to query its registration Status.
//
//  History:  17-Mar-98       rogerg        Created.
//
//--------------------------------------------------------------------------------

STDMETHODIMP CSyncMgrSynchronize::GetHandlerRegistrationInfo(REFCLSID rclsidHandler,LPDWORD pdwSyncMgrRegisterFlags)
{
    HRESULT hr = S_FALSE; // review what should be returned if handler not registered
    
    if (NULL == pdwSyncMgrRegisterFlags)
    {
        Assert(pdwSyncMgrRegisterFlags);
        return E_INVALIDARG;
    }
    
    *pdwSyncMgrRegisterFlags = 0;
    
    if (RegGetHandlerRegistrationInfo(rclsidHandler,pdwSyncMgrRegisterFlags))
    {
        hr = S_OK;
    }
    
    return hr;
}


//--------------------------------------------------------------------------------
//
//  member: CSyncMgrSynchronize::GetUserRegisterFlags
//
//  PURPOSE:  Returns current Registry Flags for the User.
//
//  History:  17-Mar-99      rogerg        Created.
//
//--------------------------------------------------------------------------------

STDMETHODIMP CSyncMgrSynchronize:: GetUserRegisterFlags(LPDWORD pdwSyncMgrRegisterFlags)
{
    
    if (NULL == pdwSyncMgrRegisterFlags)
    {
        Assert(pdwSyncMgrRegisterFlags);
        return E_INVALIDARG;
    }
    
    
    return RegGetUserRegisterFlags(pdwSyncMgrRegisterFlags);
}

//--------------------------------------------------------------------------------
//
//  member: CSyncMgrSynchronize::SetUserRegisterFlags
//
//  PURPOSE:  Sets registry flags for the User.
//
//  History:  17-Mar-99     rogerg        Created.
//
//--------------------------------------------------------------------------------

STDMETHODIMP CSyncMgrSynchronize:: SetUserRegisterFlags(DWORD dwSyncMgrRegisterMask,
                                                        DWORD dwSyncMgrRegisterFlags)
{
    
    if (0 != (dwSyncMgrRegisterMask & ~(SYNCMGRREGISTERFLAGS_MASK)) )
    {
        AssertSz(0,"Invalid Registration Mask");
        return E_INVALIDARG;
    }
    
    RegSetUserAutoSyncDefaults(dwSyncMgrRegisterMask,dwSyncMgrRegisterFlags);
    RegSetUserIdleSyncDefaults(dwSyncMgrRegisterMask,dwSyncMgrRegisterFlags);
    
    return NOERROR;
}



//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncMgrSynchronize::CreateSchedule(
//                                              LPCWSTR pwszScheduleName,
//                                              DWORD dwFlags,
//                                              SYNCSCHEDULECOOKIE *pSyncSchedCookie,
//                                              ISyncSchedule **ppSyncSchedule)
//
//  PURPOSE: Create a new Sync Schedule
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncMgrSynchronize::CreateSchedule(
                                                 LPCWSTR pwszScheduleName,
                                                 DWORD dwFlags,
                                                 SYNCSCHEDULECOOKIE *pSyncSchedCookie,
                                                 ISyncSchedule **ppSyncSchedule)
{
    SCODE sc;
    TCHAR ptszScheduleGUIDName[MAX_SCHEDULENAMESIZE + 4];
    TCHAR ptstrFriendlyName[MAX_PATH + 1];
    WCHAR pwszScheduleGUIDName[MAX_SCHEDULENAMESIZE + 4];
    
    ITask *pITask;
    
    Assert(m_pITaskScheduler);
    
    if ((!pSyncSchedCookie) || (!ppSyncSchedule) || (!pwszScheduleName))
    {
        sc = E_INVALIDARG;
    }
    else
    {        
        *ppSyncSchedule = NULL;
        
        if (*pSyncSchedCookie == GUID_NULL)
        {
            sc = CoCreateGuid(pSyncSchedCookie);
        }
        else
        {
            sc = S_OK;
        }
        
        if (SUCCEEDED(sc))
        {
            sc = MakeScheduleName(ptszScheduleGUIDName, ARRAYSIZE(ptszScheduleGUIDName), pSyncSchedCookie);
            if (SUCCEEDED(sc))
            {
                sc = StringCchCopy(pwszScheduleGUIDName, ARRAYSIZE(pwszScheduleGUIDName), ptszScheduleGUIDName);
                if (SUCCEEDED(sc))
                {                    
                    //if the schedule name is empty, generate a new unique one
                    if (!lstrcmp(pwszScheduleName,L""))
                    {
                        //this function is the energizer bunny, going and going until success....
                        GenerateUniqueName(ptszScheduleGUIDName, ptstrFriendlyName, ARRAYSIZE(ptstrFriendlyName));
                        sc = S_OK;
                    }
                    else
                    {
                        sc = StringCchCopy(ptstrFriendlyName, ARRAYSIZE(ptstrFriendlyName), pwszScheduleName);
                    }
                    
                    if (SUCCEEDED(sc))
                    {
                        HRESULT hrFriendlyNameInUse = NOERROR;
                        HRESULT hrActivate = NOERROR;
                        
                        //see if this friendly name is already in use by one of this user's schedules
                        //if it is, ptszScheduleGUIDName will be filled in with the offending Schedules GUID
                        if (IsFriendlyNameInUse(ptszScheduleGUIDName, ARRAYSIZE(ptszScheduleGUIDName), ptstrFriendlyName))
                        {
                            sc = StringCchCopy(pwszScheduleGUIDName, ARRAYSIZE(pwszScheduleGUIDName), ptszScheduleGUIDName);
                            if (SUCCEEDED(sc))
                            {
                                hrFriendlyNameInUse =  SYNCMGR_E_NAME_IN_USE;
                            }
                        }
                        if (SUCCEEDED(sc))
                        {
                            
                            // if we think it is in use try to activate to make sure.
                            if (SUCCEEDED(hrActivate = m_pITaskScheduler->Activate(pwszScheduleGUIDName,
                                IID_ITask,
                                (IUnknown **)&pITask)))
                            {                                
                                pITask->Release();
                                
                                //ok, we have the .job but not the reg entry.
                                //delete the turd job file.
                                
                                if (!IsScheduleNameInUse(ptszScheduleGUIDName))
                                {
                                    if (ERROR_SUCCESS != m_pITaskScheduler->Delete(pwszScheduleGUIDName))
                                    {
                                        //Try to force delete of the .job file
                                        if (SUCCEEDED(StringCchCat(ptszScheduleGUIDName, ARRAYSIZE(ptszScheduleGUIDName), L".job")))
                                        {
                                            RemoveScheduledJobFile(ptszScheduleGUIDName);
                                            //trunctate off the .job we just added
                                            pwszScheduleGUIDName[wcslen(ptszScheduleGUIDName) -4] = L'\0';
                                        }
                                    }
                                    hrActivate = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
                                }
                            }
                            
                            // if activate failed but we think there is a friendly name in use
                            // then update the regkey and return the appropriate info
                            // if already one or our schedules return SYNCMGR_E_NAME_IN_USE, if
                            // schedule name is being used by someone else return ERROR_ALREADY_EXISTS
                            
                            if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hrActivate)
                            {
                                
                                // file not found update regValues and continue to create
                                RegRemoveScheduledTask(pwszScheduleGUIDName);
                                sc = NOERROR;
                            }
                            else if (NOERROR  != hrFriendlyNameInUse)
                            {
                                // fill in the out param with the cookie of schedule
                                // that already exists.
                                
                                // !!!! warning, alters pwszScheduleGUIDName so
                                // if don't just return here would have to make a tempvar.
                                pwszScheduleGUIDName[GUIDSTR_MAX] = NULL;
                                GUIDFromString(pwszScheduleGUIDName, pSyncSchedCookie);
                                
                                sc = SYNCMGR_E_NAME_IN_USE;
                            }
                            else if (SUCCEEDED(hrActivate))
                            {
                                sc = HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
                            }
                            
                            if (SUCCEEDED(sc))
                            {
                                // Create an in-memory task object.
                                sc = m_pITaskScheduler->NewWorkItem(
                                    pwszScheduleGUIDName,
                                    CLSID_CTask,
                                    IID_ITask,
                                    (IUnknown **)&pITask);
                                if (SUCCEEDED(sc))
                                {           
                                    // Make sure the task scheduler service is started
                                    sc = StartScheduler();
                                    if (SUCCEEDED(sc))
                                    {
                                        *ppSyncSchedule =  new CSyncSchedule(pITask);
                                        
                                        if (!*ppSyncSchedule)
                                        {
                                            sc = E_OUTOFMEMORY;
                                        }
                                        else
                                        {                    
                                            sc = ((LPSYNCSCHEDULE)(*ppSyncSchedule))->Initialize(ptszScheduleGUIDName,ptstrFriendlyName);
                                            if (SUCCEEDED(sc))
                                            {
                                                sc = ((LPSYNCSCHEDULE)(*ppSyncSchedule))->SetDefaultCredentials();
                                                if (SUCCEEDED(sc))
                                                {
                                                    sc = (*ppSyncSchedule)->SetFlags(dwFlags & SYNCSCHEDINFO_FLAGS_MASK);
                                                }
                                            }
                                            
                                            if (FAILED(sc))
                                            {
                                                (*ppSyncSchedule)->Release();
                                                *ppSyncSchedule = NULL;
                                            }
                                        }
                                    }
                                    pITask->Release();
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    
    
    return sc;        
}

//+-------------------------------------------------------------------------------
//
//  FUNCTION: CALLBACK SchedWizardPropSheetProc( HWND hwndDlg, UINT uMsg, LPARAM lParam);
//
//  PURPOSE: Callback dialog init procedure the settings property dialog
//
//  PARAMETERS:
//    hwndDlg   - Dialog box window handle
//    uMsg              - current message
//    lParam    - depends on message
//
//--------------------------------------------------------------------------------

int CALLBACK SchedWizardPropSheetProc( HWND hwndDlg, UINT uMsg, LPARAM lParam)
{
    switch(uMsg)
    {
    case PSCB_INITIALIZED:
        {
            // Load the bitmap depends on color mode
            Load256ColorBitmap();
            
        }
        break;
    default:
        return FALSE;
        
    }
    return TRUE;
    
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncMgrSynchronize::LaunchScheduleWizard(
//                                              HWND hParent,
//                                              DWORD dwFlags,
//                                              SYNCSCHEDULECOOKIE *pSyncSchedCookie,
//                                              ISyncSchedule   ** ppSyncSchedule)
//
//  PURPOSE: Launch the SyncSchedule Creation wizard
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncMgrSynchronize::LaunchScheduleWizard(
                                                       HWND hParent,
                                                       DWORD dwFlags,
                                                       SYNCSCHEDULECOOKIE *pSyncSchedCookie,
                                                       ISyncSchedule   ** ppSyncSchedule)
{
    SCODE sc;
    BOOL fSaved;
    DWORD dwSize = MAX_PATH;
    ISyncSchedule *pNewSyncSchedule;
    DWORD cRefs;
    
    if (!ppSyncSchedule)
    {
        Assert(ppSyncSchedule);
        return E_INVALIDARG;
    }
    
    *ppSyncSchedule  = NULL;
    
    if (*pSyncSchedCookie == GUID_NULL)
    {
        if (FAILED(sc = CreateSchedule(L"", dwFlags, pSyncSchedCookie,
            &pNewSyncSchedule)))
        {
            return sc;
        }
        
    }
    else
    {
        //Open the schedule passed in
        if (FAILED(sc = OpenSchedule(pSyncSchedCookie,
            0,
            &pNewSyncSchedule)))
        {
            return sc;
        }
    }
    
    HPROPSHEETPAGE psp [NUM_TASK_WIZARD_PAGES];
    PROPSHEETHEADERA psh;
    
    ZeroMemory(psp,sizeof(*psp));
    
    m_apWizPages[0] = new CWelcomePage(g_hmodThisDll,pNewSyncSchedule, &psp[0]);
    m_apWizPages[1] = new CSelectItemsPage(g_hmodThisDll, &fSaved, pNewSyncSchedule, &psp[1],
        IDD_SCHEDWIZ_CONNECTION);
    m_apWizPages[2] = new CSelectDailyPage(g_hmodThisDll, pNewSyncSchedule, &psp[2]);
    m_apWizPages[3] = new CNameItPage(g_hmodThisDll, pNewSyncSchedule, &psp[3]);
    m_apWizPages[4] = new CFinishPage(g_hmodThisDll, pNewSyncSchedule, &psp[4]);
    
    
    
    // Check that all objects and pages could be created
    int i;
    for (i = 0; i < NUM_TASK_WIZARD_PAGES; i++)
    {
        if (!m_apWizPages[i] || !psp[i])
        {
            sc = E_OUTOFMEMORY;
        }
    }
    
    // Manually destroy the pages if one could not be created, then exit
    if (FAILED(sc))
    {
        for (i = 0; i < NUM_TASK_WIZARD_PAGES; i++)
        {
            if (psp[i])
            {
                DestroyPropertySheetPage(psp[i]);
            }
            else if (m_apWizPages[i])
            {
                delete m_apWizPages[i];
            }
            
        }
        
        pNewSyncSchedule->Release();
        return sc;
    }
    
    // All pages created, display the wizard
    ZeroMemory(&psh, sizeof(psh));
    
    psh.dwSize = sizeof (PROPSHEETHEADERA);
    psh.dwFlags = PSH_WIZARD;
    psh.hwndParent = hParent;
    psh.hInstance = g_hmodThisDll;
    psh.pszIcon = NULL;
    psh.phpage = psp;
    psh.nPages = NUM_TASK_WIZARD_PAGES;
    psh.pfnCallback = SchedWizardPropSheetProc;
    psh.nStartPage = 0;
    
    
    
    if (-1 == PropertySheetA(&psh))
    {
        sc = E_UNEXPECTED;
    }
    
    for (i = 0; i < NUM_TASK_WIZARD_PAGES; i++)
    {
        delete m_apWizPages[i];
    }
    
    if (SUCCEEDED(sc))
    {
        if (fSaved)
        {
            *ppSyncSchedule = pNewSyncSchedule;
            (*ppSyncSchedule)->AddRef();
            sc = NOERROR;
        }
        else
        {
            sc = S_FALSE;
        }
    }
    
    
    cRefs = pNewSyncSchedule->Release();
    
    Assert( (NOERROR == sc) || (0 == cRefs && NULL == *ppSyncSchedule));
    
    return sc;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncMgrSynchronize::OpenSchedule(
//                                              SYNCSCHEDULECOOKIE *pSyncSchedCookie,
//                                              DWORD dwFlags,
//                                              ISyncSchedule **ppSyncSchedule)
//
//  PURPOSE: Open an existing sync schedule
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncMgrSynchronize::OpenSchedule(
                                               SYNCSCHEDULECOOKIE *pSyncSchedCookie,
                                               DWORD dwFlags,
                                               ISyncSchedule **ppSyncSchedule)
{
    SCODE sc;
    
    TCHAR ptszScheduleGUIDName[MAX_SCHEDULENAMESIZE + 4];
    WCHAR *pwszScheduleGUIDName;
    TCHAR ptstrFriendlyName[MAX_PATH + 1];
    
    ITask *pITask;
    
    Assert(m_pITaskScheduler);
    
    if ((!pSyncSchedCookie) || (!ppSyncSchedule) )
    {
        sc = E_INVALIDARG;
    }
    else
    {
        *ppSyncSchedule = NULL;

        sc = MakeScheduleName(ptszScheduleGUIDName, ARRAYSIZE(ptszScheduleGUIDName), pSyncSchedCookie);
        if (SUCCEEDED(sc))
        {
            pwszScheduleGUIDName = ptszScheduleGUIDName;
            //See if we can find the friendly name in the registry
            if (!RegGetSchedFriendlyName(ptszScheduleGUIDName,ptstrFriendlyName,ARRAYSIZE(ptstrFriendlyName)))
            {
                //if we can't find the registry entry, 
                //try to remove any possible turd .job file.
                if (FAILED(m_pITaskScheduler->Delete(pwszScheduleGUIDName)))
                {
                    if (SUCCEEDED(StringCchCat(pwszScheduleGUIDName, ARRAYSIZE(ptszScheduleGUIDName), L".job")))
                    {
                        RemoveScheduledJobFile(pwszScheduleGUIDName);
                    }
                }
                
                sc = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);                    
            }
            else
            {
                //Try to activate the schedule
                sc = m_pITaskScheduler->Activate(pwszScheduleGUIDName,
                    IID_ITask,
                    (IUnknown **)&pITask);
                if (FAILED(sc))
                {
                    // if file not found then update reg info
                    if (sc == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
                    {
                        RegRemoveScheduledTask(pwszScheduleGUIDName);
                    }
                }
                else
                {
                    sc = StartScheduler();
                    if (SUCCEEDED(sc))
                    {
                        *ppSyncSchedule =  new CSyncSchedule(pITask);
                        if (!*ppSyncSchedule)
                        {
                            sc = E_OUTOFMEMORY;
                        }
                        else
                        {
                            sc = ((LPSYNCSCHEDULE)(*ppSyncSchedule))->Initialize(ptszScheduleGUIDName, ptstrFriendlyName);
                        }
                    }
                    pITask->Release();
                }
            }
        }
    }
    
    return sc;
    
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncMgrSynchronize::RemoveSchedule(
//                                              SYNCSCHEDULECOOKIE *pSyncSchedCookie)
//
//  PURPOSE: Remove a sync schedule
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncMgrSynchronize::RemoveSchedule(
                                                 SYNCSCHEDULECOOKIE *pSyncSchedCookie)
{
    SCODE sc = S_OK, 
        sc2 = S_OK;
    
    //add 4 to ensure we have room for the .job if necessary
    TCHAR ptszScheduleGUIDName[MAX_SCHEDULENAMESIZE + 4];
    WCHAR *pwszScheduleGUIDName = NULL;
    
    Assert(m_pITaskScheduler);
    
    if (!pSyncSchedCookie)
    {
        return E_INVALIDARG;
    }
    
    if (FAILED (sc = MakeScheduleName(ptszScheduleGUIDName, ARRAYSIZE(ptszScheduleGUIDName), pSyncSchedCookie)))
    {
        return sc;
    }
    pwszScheduleGUIDName = ptszScheduleGUIDName;
    
    //Try to remove the schedule
    if (ERROR_SUCCESS != (sc2 = m_pITaskScheduler->Delete(pwszScheduleGUIDName)))
    {
        //Try to force delete of the .job file
        if (FAILED(sc = StringCchCat(pwszScheduleGUIDName, ARRAYSIZE(ptszScheduleGUIDName), L".job")))
        {
            return sc;
        }
        
        RemoveScheduledJobFile(pwszScheduleGUIDName);
        //trunctate off the .job we just added
        pwszScheduleGUIDName[wcslen(pwszScheduleGUIDName) -4] = L'\0';
    }
    
    //Remove our Registry settings for this schedule
    //Garbage collection, don't propogate error here
    RegRemoveScheduledTask(ptszScheduleGUIDName);
    
    //If We just transitioned from one schedule to none, unregister now.
    HKEY    hkeySchedSync,
        hKeyUser;
    TCHAR   pszDomainAndUser[MAX_DOMANDANDMACHINENAMESIZE];
    DWORD   cchDomainAndUser = ARRAYSIZE(pszDomainAndUser);
    TCHAR   pszSchedName[MAX_PATH + 1];
    DWORD   cchSchedName = ARRAYSIZE(pszSchedName);
    
    hkeySchedSync = RegGetSyncTypeKey(SYNCTYPE_SCHEDULED,KEY_WRITE |  KEY_READ,FALSE);
    
    if (hkeySchedSync)
    {
        
        hKeyUser = RegOpenUserKey(hkeySchedSync,KEY_WRITE |  KEY_READ,FALSE,FALSE);
        
        if (hKeyUser)
        {
            BOOL fRemove = FALSE;
            
            //if there are no more scedules for this user, remove the user key.
            //Garbage collection, propogate ITaskScheduler->Delete error code in favor of this error.
            if (ERROR_NO_MORE_ITEMS == RegEnumKeyEx(hKeyUser,0,
                pszSchedName,&cchSchedName,NULL,NULL,NULL,NULL))
            {
                fRemove = TRUE;
            }
            
            RegCloseKey(hKeyUser);
            
            if (fRemove)
            {
                GetDefaultDomainAndUserName(pszDomainAndUser,TEXT("_"),ARRAYSIZE(pszDomainAndUser));
                
                RegDeleteKey(hkeySchedSync, pszDomainAndUser);
            }
        }
        
        //if there are no more user schedule keys, then no schedules, and unregister
        //Garbage collection, propogate ITaskScheduler->Delete error code in favor of this error.
        if ( ERROR_SUCCESS != (sc = RegEnumKeyEx(hkeySchedSync,0,
            pszDomainAndUser,&cchDomainAndUser,NULL,NULL,NULL,NULL)) )
        {
            RegRegisterForScheduledTasks(FALSE);
        }
        
        RegCloseKey(hkeySchedSync);
        
    }
    
    //propogate the error code from the 
    //task scheduler->Delete if no other errors occurred
    return sc2;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncMgrSynchronize::EnumSyncSchedules(
//                                              IEnumSyncSchedules **ppEnumSyncSchedules)
//
                                                 //  PURPOSE: Enumerate the sync schedules
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncMgrSynchronize::EnumSyncSchedules(
                                                    IEnumSyncSchedules **ppEnumSyncSchedules)
{
    
    SCODE sc;
    IEnumWorkItems *pEnumWorkItems;
    
    Assert(m_pITaskScheduler);
    if (!ppEnumSyncSchedules)
    {
        return E_INVALIDARG;
    }
    
    if (FAILED(sc = m_pITaskScheduler->Enum(&pEnumWorkItems)))
    {
        return sc;
    }
    
    *ppEnumSyncSchedules =  new CEnumSyncSchedules(pEnumWorkItems, m_pITaskScheduler);
    
    pEnumWorkItems->Release();
    
    if (*ppEnumSyncSchedules)
    {
        return sc;
    }
    return E_OUTOFMEMORY;
    
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CCSyncMgrSynchronize::InitializeScheduler()
//
//  PURPOSE:  Initialize the schedule service
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
SCODE CSyncMgrSynchronize::InitializeScheduler()
{
    
    SCODE sc;
    
    if (m_pITaskScheduler)
    {
        return S_OK;
    }
    
    // Obtain a task scheduler class instance.
    //
    sc = CoCreateInstance(
        CLSID_CTaskScheduler,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_ITaskScheduler,
        (VOID **)&m_pITaskScheduler);
    
    if(FAILED(sc))
    {
        m_pITaskScheduler = NULL;
    }
    return sc;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CCSyncMgrSynchronize::MakeScheduleName(LPTSTR ptstrName, UINT cchName, GUID *pCookie)
//
//  PURPOSE: Create the schedule name from the user, domain and GUID
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
SCODE CSyncMgrSynchronize::MakeScheduleName(LPTSTR ptstrName, UINT cchName, GUID *pCookie)
{
    SCODE sc = E_UNEXPECTED;
    WCHAR wszCookie[GUID_SIZE+1];
    
    if (*pCookie == GUID_NULL)
    {
        if (FAILED(sc = CoCreateGuid(pCookie)))
        {
            return sc;
        }
    }
    
    if (StringFromGUID2(*pCookie, wszCookie, ARRAYSIZE(wszCookie)))
    {
        sc = StringCchCopy(ptstrName, cchName, wszCookie);
        if (SUCCEEDED(sc))
        {
            sc = StringCchCat(ptstrName, cchName, TEXT("_"));
            if (SUCCEEDED(sc))
            {
                GetDefaultDomainAndUserName(ptstrName + GUIDSTR_MAX+1,TEXT("_"),cchName - (GUIDSTR_MAX+1));
            }
        }
    }
    
    return sc;
    
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: IsFriendlyNameInUse(LPCTSTR ptszScheduleGUIDName, UINT cchScheduleGUIDName, LPCTSTR ptstrFriendlyName)
//
//  PURPOSE: See if the friendly name is already in use by this user.
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
BOOL IsFriendlyNameInUse(LPTSTR ptszScheduleGUIDName,
                         UINT   cchScheduleGUIDName,
                         LPCTSTR ptstrFriendlyName)
{
    SCODE sc;
    HKEY hKeyUser;
    
    int i = 0;
    TCHAR ptstrName[MAX_PATH + 1];
    TCHAR ptstrNewName[MAX_PATH + 1];    
    
    hKeyUser = RegGetCurrentUserKey(SYNCTYPE_SCHEDULED,KEY_READ,FALSE);
    if (NULL == hKeyUser)
    {
        return FALSE;
    }
    
    while (S_OK == (sc = RegEnumKey( hKeyUser, i++, ptstrName,MAX_PATH)))
    {
        DWORD cbDataSize = sizeof(ptstrNewName);
        if (ERROR_SUCCESS == SHRegGetValue(hKeyUser, ptstrName, TEXT("FriendlyName"), SRRF_RT_REG_SZ | SRRF_NOEXPAND, NULL,
                                           (LPBYTE) ptstrNewName, &cbDataSize))
        {       
            if (0 == lstrcmp(ptstrNewName,ptstrFriendlyName))
            {
                RegCloseKey(hKeyUser);
                return SUCCEEDED(StringCchCopy(ptszScheduleGUIDName, cchScheduleGUIDName, ptstrName));
            }
        }
    }
    
    RegCloseKey(hKeyUser);
    
    return FALSE;
    
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: IsScheduleNameInUse(LPCTSTR ptszScheduleGUIDName)
//
//  PURPOSE: See if the schedule name is already in use by this user.
//
//  History:  12-Dec-98       susia        Created.
//
//--------------------------------------------------------------------------------
BOOL IsScheduleNameInUse(LPTSTR ptszScheduleGUIDName)
{
    HKEY hKeyUser;
    HKEY hkeySchedName;
    
    
    hKeyUser = RegGetCurrentUserKey(SYNCTYPE_SCHEDULED,KEY_READ,FALSE);
    
    if (NULL == hKeyUser)
    {
        return FALSE;
    }
    
    if (ERROR_SUCCESS == RegOpenKeyEx(hKeyUser,ptszScheduleGUIDName,0,KEY_READ,
        &hkeySchedName))
    {
        RegCloseKey(hKeyUser);
        RegCloseKey(hkeySchedName);
        return TRUE;
    }
    
    RegCloseKey(hKeyUser);
    return FALSE;
    
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CCSyncMgrSynchronize::GenerateUniqueName(LPCTSTR ptszScheduleGUIDName,
//                                                     LPTSTR ptszFriendlyName,
//                                                     UINT    cchFriendlyName)
//
//  PURPOSE: Generate a default schedule name.
//
//  History:  14-Mar-98       susia        Created.
//
//--------------------------------------------------------------------------------
#define MAX_APPEND_STRING_LEN              32

BOOL CSyncMgrSynchronize::GenerateUniqueName(LPTSTR ptszScheduleGUIDName,
                                             LPTSTR ptszFriendlyName,
                                             UINT   cchFriendlyName)
{
    TCHAR *ptszBuf;
    DWORD cchBuf;
    TCHAR ptszGUIDName[MAX_PATH + 1];
#define MAX_NAMEID 0xffff
    
    //copy this over because we don't want the check to overwrite the GUID name
    if (FAILED(StringCchCopy(ptszGUIDName, ARRAYSIZE(ptszGUIDName), ptszScheduleGUIDName)))
    {
        return FALSE;
    }
    
    LoadString(g_hmodThisDll,IDS_SYNCMGRSCHED_DEFAULTNAME,ptszFriendlyName,cchFriendlyName);
    ptszBuf = ptszFriendlyName + lstrlen(ptszFriendlyName);
    cchBuf = cchFriendlyName - (DWORD)(ptszBuf - ptszFriendlyName);
    
    BOOL fMatchFound = FALSE;
    
    int i=0;
    
    do
    {
        if (IsFriendlyNameInUse(ptszGUIDName, ARRAYSIZE(ptszGUIDName), ptszFriendlyName))
        {
            // if don't find match adjust buf and setup convert pointer
            if (FAILED(StringCchPrintf(ptszBuf, cchBuf, TEXT(" %d"), i)))
            {
                return FALSE;
            }
            
            fMatchFound = TRUE;
            ++i;
            
            
            Assert(i < 100);
        }
        else
        {
            fMatchFound = FALSE;
        }
    }while (fMatchFound && (i < MAX_NAMEID));
    
    if (MAX_NAMEID <= i)
    {
        AssertSz(0,"Ran out of NameIds");
        return FALSE;
    }
    
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\dll\hndlrq.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       Hndlrq.h
//
//  Contents:   Keeps tracks of Handlers and UI assignments
//
//  Classes:    CHndlrQueue
//
//  Notes:      
//
//  History:    05-Nov-97   rogerg      Created.
//              17-Nov-97   susia       Converted to an Autosync Queue
//
//--------------------------------------------------------------------------

#ifndef _HANDLERQUEUE_
#define _HANDLERQUEUE_

typedef enum _tagHANDLERSTATE   
{   
    HANDLERSTATE_CREATE             = 0x01, // state is initialized to this.
        HANDLERSTATE_INCREATE           = 0x02, // state is initialized to this.
        HANDLERSTATE_INITIALIZE         = 0x03, // set after a successfull creation.
        HANDLERSTATE_ININITIALIZE       = 0x04, // set during initialization call
        HANDLERSTATE_ADDHANDLERTEMS     = 0x05, // items need to be enumerated
        HANDLERSTATE_INADDHANDLERITEMS  = 0x06, // in the items enumerator
        HANDLERSTATE_PREPAREFORSYNC     = 0x07, // set during queue tranfers
        HANDLERSTATE_INPREPAREFORSYNC   = 0x08, // handler is currently in a prepfosync call.
        HANDLERSTATE_DEAD               = 0x0F, // handler has been released. Data Stays around.
}  HANDLERSTATE;

typedef enum _tagQUEUETYPE   
{   
    QUEUETYPE_SETTINGS          = 0x3, // set during queue tranfers
        QUEUETYPE_SCHEDULE          = 0x4, // set during queue tranfers
} QUEUETYPE;

// so can share the queue with AutoSync and Idle just define a checkstate struct
// to keep track of items.
typedef struct _tagITEMCHECKSTATE
{
    DWORD dwAutoSync;
    DWORD dwIdle;
    DWORD dwSchedule;
} ITEMCHECKSTATE;



typedef struct _ITEMLIST
{
    struct _ITEMLIST    *pnextItem;
    WORD            wItemId;        // Id that uniquely identifies Item within a handler.
    void            *pHandlerInfo;          // pointer to the handler that owns this item
    INT             iItem;          // Index of Item in the current ListView.!!!Initialize to -1
    SYNCMGRITEM     offlineItem;            // enumerator structure item returned
    ITEMCHECKSTATE      *pItemCheckState;   // list of check states per connection
} ITEMLIST;

typedef ITEMLIST* LPITEMLIST;



typedef struct _HANDLERINFO {
    struct _HANDLERINFO     *pNextHandler;  // next handler in queue
    WORD                wHandlerId;     // Id that uniquely identifies this instance of the Handler
    CLSID           clsidHandler;   // CLSID of the handler Handler 
    SYNCMGRHANDLERINFO          SyncMgrHandlerInfo; // copy of handler info GetHandlerInfo CallHANDLERSTATE     HandlerState;   // Current state of the handler
    HANDLERSTATE                HandlerState;
    DWORD                       dwRegistrationFlags; // flags as item is registered
    DWORD           dwSyncFlags;    // sync flags originally passed in Initialize.
    WORD            wItemCount;     // number of items on this handler    
    LPITEMLIST          pFirstItem;     // ptr to first Item of the handler in the list.
    LPSYNCMGRSYNCHRONIZE    pSyncMgrHandler;
} HANDLERINFO;

typedef HANDLERINFO* LPHANDLERINFO;


class CHndlrQueue {
    
private:
    
    LPHANDLERINFO       m_pFirstHandler;        // first handler in queue
    WORD            m_wHandlerCount;        // number of handlers in this queue
    QUEUETYPE       m_QueueType;            // type of queue this is.
    CRITICAL_SECTION    m_CriticalSection;      // critical section for the queue.
    LPCONNECTIONSETTINGS    m_ConnectionList;       // hold the settings per connection 
    int         m_ConnectionCount;      // number of connections
    BOOL                    m_fItemsMissing;         // set if any handlers have missing items.
    
public:
    
    CHndlrQueue(QUEUETYPE QueueType);
    ~CHndlrQueue();
    STDMETHODIMP Init();
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();
    
    
    // main queue routines
    STDMETHODIMP AddHandler(REFCLSID clsidHandler, WORD *wHandlerId);
    STDMETHODIMP RemoveHandler(WORD wHandlerId);
    
    STDMETHODIMP FreeAllHandlers(void); 
    
    // For updating hWnd and ListView Information.
    STDMETHODIMP GetHandlerInfo(REFCLSID clsidHandler,LPSYNCMGRHANDLERINFO pSyncMgrHandlerInfo);
    
    STDMETHODIMP FindFirstHandlerInState
        (HANDLERSTATE hndlrState,
        WORD *wHandlerID);
    
    STDMETHODIMP FindNextHandlerInState
        (WORD wLastHandlerID,
        HANDLERSTATE hndlrState,
        WORD *wHandlerID);
    
    STDMETHODIMP GetHandlerIDFromClsid
        (REFCLSID clsidHandlerIn,
        WORD *pwHandlerId);
    
    STDMETHODIMP FindFirstItemOnConnection
        (TCHAR *pszConnectionName, 
        CLSID *pclsidHandler,
        SYNCMGRITEMID* OfflineItemID,
        WORD *pwHandlerId,WORD *pwItemID);
    
    STDMETHODIMP FindNextItemOnConnection
        (TCHAR *pszConnectionName, 
        WORD wLastHandlerId,
        WORD wLastItemID,
        CLSID *pclsidHandler,
        SYNCMGRITEMID* OfflineItemID,
        WORD *pwHandlerId,
        WORD *pwItemID,
        BOOL fAllHandlers,
        DWORD *pdwCheckState);
    
    STDMETHODIMP GetSyncItemDataOnConnection
        (int iConnectionIndex, 
        WORD wHandlerId,
        WORD wItemID,
        CLSID *pclsidHandler,
        SYNCMGRITEM* offlineItem,
        ITEMCHECKSTATE   *pItemCheckState,
        BOOL fSchedSync,
        BOOL fClear);
    
    STDMETHODIMP SetSyncCheckStateFromListViewItem
        (SYNCTYPE SyncType,INT iItem,
        BOOL fChecked,
        INT iConnectionItem); 
    
    //AutoSync specific methods
    STDMETHODIMP ReadSyncSettingsPerConnection(SYNCTYPE syncType,WORD wHandlerID);
    STDMETHODIMP InitSyncSettings(SYNCTYPE syncType,HWND hwndRasCombo);
    STDMETHODIMP CommitSyncChanges(SYNCTYPE syncType,CRasUI *pRas);
    
    // Idle Specific methods.
    STDMETHODIMP ReadAdvancedIdleSettings(LPCONNECTIONSETTINGS pConnectionSettings);
    STDMETHODIMP WriteAdvancedIdleSettings(LPCONNECTIONSETTINGS pConnectionSettings);
    
    
    //SchedSync specific methods
    STDMETHODIMP ReadSchedSyncSettingsOnConnection(WORD wHandlerID, TCHAR *pszSchedName);
    STDMETHODIMP InitSchedSyncSettings(LPCONNECTIONSETTINGS pConnectionSettings);
    STDMETHODIMP CommitSchedSyncChanges(TCHAR * pszSchedName,
        TCHAR * pszFriendlyName,
        TCHAR * pszConnectionName,
        DWORD dwConnType,BOOL fCleanReg);
    
    STDMETHODIMP InsertItem(LPHANDLERINFO pCurHandler, 
        LPSYNC_HANDLER_ITEM_INFO pHandlerItemInfo);
    
    STDMETHODIMP AddHandlerItem(LPSYNC_HANDLER_ITEM_INFO pHandlerItemInfo);
    
    STDMETHODIMP SetItemCheck(REFCLSID pclsidHandler,
        SYNCMGRITEMID *OfflineItemID, DWORD dwCheckState);
    
    STDMETHODIMP GetItemCheck(REFCLSID pclsidHandler,
        SYNCMGRITEMID *OfflineItemID, DWORD *pdwCheckState);
    
    STDMETHODIMP SetItemListViewID(CLSID clsidHandler,SYNCMGRITEMID OfflineItemID,INT iItem); // assigns list view ID to an Item.
    DWORD  GetCheck(WORD wParam, INT iItem);
    STDMETHODIMP SetConnectionCheck(WORD wParam, DWORD dwState, INT iConnectionItem);
    
    
    STDMETHODIMP ListViewItemHasProperties(INT iItem);  // determines if there are properties associated with this item.
    STDMETHODIMP ShowProperties(HWND hwndParent,INT iItem);     // show properties for this listView Item.
    
    STDMETHODIMP CreateServer(WORD wHandlerId, const CLSID *pCLSIDServer); 
    STDMETHODIMP Initialize(WORD wHandlerId,DWORD dwReserved,DWORD dwSyncFlags,
        DWORD cbCookie,const BYTE *lpCookie);
    STDMETHODIMP SetHandlerInfo(WORD wHandlerId,LPSYNCMGRHANDLERINFO pSyncMgrHandlerInfo);
    STDMETHODIMP AddHandlerItemsToQueue(WORD wHandlerId);
    STDMETHODIMP AddItemToHandler(WORD wHandlerId,SYNCMGRITEM *pOffineItem);
    
    STDMETHODIMP GetItemName(WORD wHandlerId, WORD wItemID, WCHAR *pwszName, UINT cchName);
    STDMETHODIMP GetItemIcon(WORD wHandlerId, WORD wItemID, HICON *phIcon);
    
    
private:
    // private functions for finding proper handlers and items.
    STDMETHODIMP LookupHandlerFromId(WORD wHandlerId,LPHANDLERINFO *pHandlerInfo);
    ULONG  m_cRef;
    
};



#endif // _HANDLERQUEUE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\dll\makefile.inc ===
PRIVLIB= $(O)\mobsyncp.lib
$(O)\mobsync.lib : $(PRIVLIB)

$(PRIVLIB) $(PRIVLIB:.lib=.exp): $(O)\mobsyncp.def $(LIBRARY_OBJS)
   -lib -out:$(PRIVLIB) @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\mobsyncp.def
$(LIBRARY_OBJS)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\dll\nameit.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//  
//  File:       nameit.cxx
//
//  Contents:   Task wizard naming property page implementation.
//
//  Classes:    CNameItPage
//
//  History:    11-21-1997   SusiA 
//
//---------------------------------------------------------------------------

#include "precomp.h"

extern LANGID g_LangIdSystem;      // LangId of system we are running on.


CNameItPage *g_pNameItPage = NULL;

extern CSelectDailyPage *g_pDailyPage;

//+-------------------------------------------------------------------------------
//  FUNCTION: SchedWizardNameItDlgProc(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE: Callback dialog procedure for the property page
//
//  PARAMETERS:
//    hDlg      - Dialog box window handle
//    uMessage  - current message
//    wParam    - depends on message
//    lParam    - depends on message
//
//  RETURN VALUE:
//
//    Depends on message.  In general, return TRUE if we process it.
//
//  COMMENTS:
//
//+-------------------------------------------------------------------------------

INT_PTR CALLBACK SchedWizardNameItDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    
    switch (uMessage)
    {
        
    case WM_INITDIALOG:         
        {
            if (g_pNameItPage)
                g_pNameItPage->Initialize(hDlg);
            
            //This handles the 256 color processing init
            //for the .bmp
            InitPage(hDlg,lParam);
        }
        break;
        
    case WM_PAINT:
        WmPaint(hDlg, uMessage, wParam, lParam);
        break;
        
    case WM_PALETTECHANGED:
        WmPaletteChanged(hDlg, wParam);
        break;
        
    case WM_QUERYNEWPALETTE:
        return( WmQueryNewPalette(hDlg) );
        break;
        
    case WM_ACTIVATE:
        return( WmActivate(hDlg, wParam, lParam) );
        break;
        
    case WM_DESTROY:
        {
            Unload256ColorBitmap();
        }
        break;
        
    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code) 
        {
            
        case PSN_KILLACTIVE:
            SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, FALSE);
            return 1;
            break;
            
        case PSN_RESET:
            // reset to the original values
            SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, FALSE);
            break;
            
        case PSN_SETACTIVE:
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
            break;
            
        case PSN_WIZNEXT:
            
            if (g_pNameItPage)
            {
                if (!g_pNameItPage->SetScheduleName())
                {
                    SchedUIErrorDialog(hDlg, IERR_INVALIDSCHEDNAME);
                    // reset to the original values
                    SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, -1);
                    break;
                }
            }
            if (g_pDailyPage)
            {
                g_pDailyPage->SetITrigger();
            }
            break;
            
        default:
            return FALSE;
        }
        break;
        
        default:
            return FALSE;
    }
    return TRUE;   
    
}


//+--------------------------------------------------------------------------
//
//  Member:     CNameItPage::CNameItPage
//
//  Synopsis:   ctor
//
//              [phPSP]                - filled with prop page handle
//
//  History:    11-21-1997   SusiA   Stole from Task Scheduler wizard
//
//---------------------------------------------------------------------------

CNameItPage::CNameItPage(
                         HINSTANCE hinst,
                         ISyncSchedule *pISyncSched,
                         HPROPSHEETPAGE *phPSP)
{
    ZeroMemory(&m_psp, sizeof(m_psp));
    
    g_pNameItPage = this;
    
    m_psp.dwSize = sizeof (PROPSHEETPAGE);
    m_psp.hInstance = hinst;
    m_psp.dwFlags = PSP_DEFAULT;
    m_psp.pszTemplate = MAKEINTRESOURCE(IDD_SCHEDWIZ_NAMEIT);
    m_psp.pszIcon = NULL;
    m_psp.pfnDlgProc = SchedWizardNameItDlgProc;
    m_psp.lParam = 0;
    
    m_pISyncSched = pISyncSched;
    m_pISyncSched->AddRef();
    
    *phPSP = CreatePropertySheetPage(&m_psp);
    
    
}

//+--------------------------------------------------------------------------
//
//  Member:     CNameItPage::Initialize(HWND hwnd)
//
//  Synopsis:   initialize the name it page and set the task name to a unique 
//              new onestop name
//
//  History:    11-21-1997   SusiA   
//
//---------------------------------------------------------------------------

BOOL CNameItPage::Initialize(HWND hwnd)
{
    WCHAR pwszNewName[MAX_PATH+1];
    TCHAR *ptszNewName;
    DWORD dwSize = MAX_PATH;
    m_hwnd = hwnd;
    
    m_pISyncSched->GetScheduleName(&dwSize, pwszNewName);
    
    ptszNewName = pwszNewName;
    
    HWND hwndEdit = GetDlgItem(m_hwnd, IDC_NAMEIT);
    
    // set the limit on the edit box for entering the name
    SendMessage(hwndEdit,EM_SETLIMITTEXT,MAX_PATH,0);
    
    Edit_SetText(hwndEdit, ptszNewName);
    
    return TRUE;
}


//+--------------------------------------------------------------------------
//
//  Member:     BOOL CNameItPage::SetScheduleName()
//
//  Synopsis:   create a new schedule 
//
//  History:    11-21-1997   SusiA   
//
//---------------------------------------------------------------------------

BOOL CNameItPage::SetScheduleName()
{
    WCHAR pwszNewName[MAX_PATH + 1];
    HWND hwndEdit = GetDlgItem(m_hwnd, IDC_NAMEIT);
    
    Edit_GetText(hwndEdit, pwszNewName, ARRAYSIZE(pwszNewName));
    
    if (S_OK == m_pISyncSched->SetScheduleName(pwszNewName))
    {
        return TRUE;
    }
    return FALSE;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\dll\rasui.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       rasui.h
//
//  Contents:   helper functions for showing Ras UI
//
//  Classes:
//
//  Notes:
//
//  History:    08-Dec-97   rogerg      Created.
//
//--------------------------------------------------------------------------

// Windows Header Files:

#ifndef _RASUIIMPL_
#define _RASUIIMPL_

class CRasUI
{
public:
    CRasUI(void);
    ~CRasUI(void);
    BOOL Initialize(void);
    BOOL IsConnectionLan(int iConnectionNum);
    void FillRasCombo(HWND hwndCtl,BOOL fForceEnum,BOOL fShowRasEntries);


private:
    LPNETAPI m_pNetApi;

    DWORD m_cEntries;
    LPRASENTRYNAME m_lprasentry; // Cached enum

};


#endif // _RASUIIMPL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\dll\invoke.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       Invoke.h
//
//  Contents:   IOfflineSynchronizeInvoke interface
//
//  Classes:    CSyncMgrSynchronize
//
//  Notes:
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#ifndef _SYNCMGRINVOKE_
#define _SYNCMGRINVOKE_

#define NUM_TASK_WIZARD_PAGES 5


class CSyncMgrSynchronize : public ISyncMgrSynchronizeInvoke,
public ISyncScheduleMgr,
// public ISyncMgrRegister, // base class of ISyncMgrRegisterCSC
public IOldSyncMgrRegister, // can remove next ship since never went out except in beta
public ISyncMgrRegisterCSC
{
public:
    CSyncMgrSynchronize();
    ~CSyncMgrSynchronize();
    
    //IUnknown members
    STDMETHODIMP            QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();
    
    // IOfflineSynchronizeInvoke methods
    STDMETHODIMP UpdateItems(DWORD dwInvokeFlags,REFCLSID rclsid,DWORD cbCookie,const BYTE *lpCookie);
    STDMETHODIMP UpdateAll();
    
    // ISyncMgrRegister methods
    STDMETHODIMP RegisterSyncMgrHandler(REFCLSID rclsidHandler,
        WCHAR const *pwszDescription,
        DWORD dwSyncMgrRegisterFlags);
    
    STDMETHODIMP UnregisterSyncMgrHandler(REFCLSID rclsidHandler,DWORD dwReserved);
    
    STDMETHODIMP GetHandlerRegistrationInfo(REFCLSID rclsidHandler,LPDWORD pdwSyncMgrRegisterFlags);
    
    // ISyncMgrRegisterCSC private methods
    
    STDMETHODIMP GetUserRegisterFlags(LPDWORD pdwSyncMgrRegisterFlags);
    STDMETHODIMP SetUserRegisterFlags(DWORD dwSyncMgrRegisterMask,DWORD dwSyncMgrRegisterFlags);
    
    // old idl, remove when get a chance.
    // IOldSyncMgrRegister method
    STDMETHODIMP RegisterSyncMgrHandler(REFCLSID rclsidHandler,
        DWORD dwReserved);
    
    // ISyncScheduleMgr methods
    STDMETHODIMP CreateSchedule(
        LPCWSTR pwszScheduleName,
        DWORD dwFlags,
        SYNCSCHEDULECOOKIE *pSyncSchedCookie,
        ISyncSchedule **ppSyncSchedule);
    
    STDMETHODIMP LaunchScheduleWizard(
        HWND hParent,
        DWORD dwFlags,
        SYNCSCHEDULECOOKIE *pSyncSchedCookie,
        ISyncSchedule   ** ppSyncSchedule);
    
    STDMETHODIMP OpenSchedule(
        SYNCSCHEDULECOOKIE *pSyncSchedCookie,
        DWORD dwFlags,
        ISyncSchedule **ppSyncSchedule);
    
    STDMETHODIMP RemoveSchedule(
        SYNCSCHEDULECOOKIE *pSyncSchedCookie);
    
    STDMETHODIMP EnumSyncSchedules(
        IEnumSyncSchedules **ppEnumSyncSchedules);
    
private:
    SCODE   InitializeScheduler();
    SCODE   MakeScheduleName(LPTSTR ptstrName, UINT cchName, GUID *pCookie);
    
    BOOL    GetFriendlyName(LPCTSTR ptszScheduleGUIDName,
        LPTSTR ptstrFriendlyName);
    
    BOOL    GenerateUniqueName(LPTSTR ptszScheduleGUIDName,
        LPTSTR ptszFriendlyName,
        UINT    cchFriendlyName);
    ULONG m_cRef;
    ITaskScheduler     *m_pITaskScheduler;
    CWizPage           *m_apWizPages[NUM_TASK_WIZARD_PAGES];
    
};
typedef CSyncMgrSynchronize *LPCSyncMgrSynchronize;


#endif // _SYNCMGRINVOKE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\dll\rasproc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       RasProc.cpp
//
//  Contents:   Exports used by Ras for doing Pending Disconnect
//
//  Classes:    
//
//  Notes:      
//
//  History:    09-Jan-98   rogerg      Created.
//
//--------------------------------------------------------------------------

// Windows Header Files:

#include <windows.h>
#include <commctrl.h>
#include <objbase.h>
#include <strsafe.h>

#include "mobsync.h"
#include "mobsyncp.h"

#include "debug.h"
#include "alloc.h"
#include "critsect.h"
#include "netapi.h"
#include "syncmgrr.h"
#include "rasui.h"
#include "dllreg.h"
#include "cnetapi.h"
#include "rasproc.h"

#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x) / sizeof(x[0]))
#endif

//+-------------------------------------------------------------------
//
//  Function:   SyncMgrRasProc
//
//  Synopsis:   Main entry point for RAS to call to perform
//      a pending disconnect.
//
//  Arguments:  
//
//
//  Notes:
//
//--------------------------------------------------------------------

LRESULT CALLBACK  SyncMgrRasProc(UINT uMsg,WPARAM wParam, LPARAM lParam)
{
    
    switch(uMsg)
    {
    case SYNCMGRRASPROC_QUERYSHOWSYNCUI:
        return SyncMgrRasQueryShowSyncUI(wParam,lParam);
        break;
    case SYNCMGRRASPROC_SYNCDISCONNECT:
        return SyncMgrRasDisconnect(wParam,lParam);
        break;
    default:
        AssertSz(0,"Unknown RasProc Message");
        break;
    };
    
    return -1; 
}

//+-------------------------------------------------------------------
//
//  Function:   SyncMgrRasQueryShowSyncUI
//
//  Synopsis:   Called by RAS to determine if Ras Should show
//      the Disconnect checkbox and what state it should be.
//
//  Arguments:  
//      wParam = 0
//      lParam = Pointer to SYNCMGRQUERYSHOWSYNCUI structure
//
//  Notes:
//
//--------------------------------------------------------------------

LRESULT SyncMgrRasQueryShowSyncUI(WPARAM wParam,LPARAM lParam)
{
    CNetApi *pNetApi;
    SYNCMGRQUERYSHOWSYNCUI *pQueryStruct = (SYNCMGRQUERYSHOWSYNCUI *) lParam;
    LRESULT lResult = -1;
    
    if (pQueryStruct->cbSize != sizeof(SYNCMGRQUERYSHOWSYNCUI))
    {
        Assert(pQueryStruct->cbSize == sizeof(SYNCMGRQUERYSHOWSYNCUI));
        return -1;
    }
    
    pQueryStruct->fShowCheckBox = FALSE;
    pQueryStruct->nCheckState = BST_UNCHECKED;
    
    pNetApi = new CNetApi();
    
    if (!pNetApi)
    {
        AssertSz(0,"Failed to Load Ras");
        return -1;
    }
    
    RegSetUserDefaults(); // Make Sure the UserDefaults are up to date
    
    CONNECTIONSETTINGS  connectSettings;
    
    // Review, should just pass this to Function
    if (FAILED(StringCchCopy(connectSettings.pszConnectionName, 
        ARRAYSIZE(connectSettings.pszConnectionName), 
        pQueryStruct->pszConnectionName)))
    {
        return -1;
    }
    
    // look up preferences for this entry and see if disconnect has been chosen.
    lResult = 0; // return NOERROR even if no entry is found
    
    if (RegGetAutoSyncSettings(&connectSettings))
    {
        if (connectSettings.dwLogoff)
        {
            pQueryStruct->fShowCheckBox = TRUE;
            pQueryStruct->nCheckState = BST_CHECKED;
        }
    }
    
    pNetApi->Release();
    return lResult;
}


//+-------------------------------------------------------------------
//
//  Function:   SyncMgrRasDisconnect
//
//  Synopsis:   Main entry point for RAS to call to perform
//      a pending disconnect.
//
//  Arguments:  
//  wParam = 0
//  lParam = Pointer to SYNCMGRSYNCDISCONNECT structure
//
//  Notes:
//
//--------------------------------------------------------------------

LRESULT SyncMgrRasDisconnect(WPARAM wParam,LPARAM lParam)
{
    CNetApi *pNetApi;
    SYNCMGRSYNCDISCONNECT *pDisconnectStruct = (SYNCMGRSYNCDISCONNECT *) lParam;
    TCHAR szEntry[RAS_MaxEntryName + 1]; 
    
    if (pDisconnectStruct->cbSize != sizeof(SYNCMGRSYNCDISCONNECT))
    {
        Assert(pDisconnectStruct->cbSize == sizeof(SYNCMGRSYNCDISCONNECT));
        return -1;
    }
    
    pNetApi = new CNetApi();
    
    if (!pNetApi)
    {
        AssertSz(0,"Failed to Load Ras");
        return -1;
    }
    
    HRESULT hr;
    LPUNKNOWN lpUnk;
    
    // invoke SyncMgr.exe informing it is a Logoff and then wait in
    // a message loop until the event we pass in gets signalled.
    
    if (FAILED(StringCchCopy(szEntry, ARRAYSIZE(szEntry), pDisconnectStruct->pszConnectionName)))
    {
        return -1;
    }
    
    hr = CoInitialize(NULL);
    
    if (SUCCEEDED(hr))
    {
        
        hr = CoCreateInstance(CLSID_SyncMgrp,NULL,CLSCTX_SERVER,IID_IUnknown,(void **) &lpUnk);
        
        if (NOERROR == hr)
        {
            LPPRIVSYNCMGRSYNCHRONIZEINVOKE pSynchInvoke = NULL;
            
            hr = lpUnk->QueryInterface(IID_IPrivSyncMgrSynchronizeInvoke,
                (void **) &pSynchInvoke);
            
            if (NOERROR == hr)
            {
                
                // should have everything we need 
                hr = pSynchInvoke->RasPendingDisconnect(
                    (RAS_MaxEntryName + 1)*sizeof(TCHAR),
                    (BYTE *) szEntry);
                
                pSynchInvoke->Release();
                
            }
            
            lpUnk->Release();  
        }
        
        CoUninitialize();
    }
    
    pNetApi->Release();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\dll\rasproc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       RasProc.h
//
//  Contents:   implements Exports used by Ras for doing Pending Disconnect
//
//  Classes:    
//
//  Notes:      
//
//  History:    09-Jan-98   rogerg      Created.
//
//--------------------------------------------------------------------------

LRESULT SyncMgrRasQueryShowSyncUI(WPARAM wParam,LPARAM lParam);
LRESULT SyncMgrRasDisconnect(WPARAM wParam,LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\dll\precomp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       prcomp.h
//
//  Contents:   precompiled headers
//
//  Classes:
//
//  Notes:
//
//  History:    04-Aug-98   rogerg      Created.
//
//--------------------------------------------------------------------------

// standard includes for  MobSync lib
#include <objbase.h>
#include <windows.h>
#include <windowsx.h>
#include <shellapi.h>
#include <commctrl.h>
#include <atlbase.h>  // for confres
#include <inetreg.h>
#include <advpub.h>
#include <mstask.h>
#include <msterr.h>

#include <mobsync.h>
#include <mobsyncp.h>

#include <shlwapi.h>
#include <strsafe.h>

#include "debug.h"
#include "alloc.h"
#include "critsect.h"
#include "stringc.h"
#include "osdefine.h"

#include "validate.h"
#include "netapi.h"
#include "listview.h"
#include "util.hxx"
#include "clsobj.h"

// dll include files
#include "resource.h"
#include "resource.hm"
#include "dllsz.h"

#include "cnetapi.h"
#include "rasui.h"

#include "dllreg.h"

#include "hndlrq.h"

// wizard headers.
#include "color256.h"
#include "wizpage.hxx"
#include "editschd.hxx"
#include "daily.hxx"
#include "finish.hxx"
#include "invoke.h"
#include "nameit.hxx"
#include "cred.hxx"
#include "welcome.hxx"
#include "wizsel.hxx"

#include "dll.h"
#include "invoke.h"
#include "schedif.h"

#include "settings.h"


#ifndef LVS_EX_INFOTIP
#define LVS_EX_INFOTIP          0x00000400 // listview does InfoTips
#endif  // LVS_EX_INFOTIP

#ifndef LVM_GETSELECTIONMARK
#define LVM_GETSELECTIONMARK    (LVM_FIRST + 66)
#define ListView_GetSelectionMark(hwnd) \
    (int)SNDMSG((hwnd), LVM_GETSELECTIONMARK, 0, 0)
#endif //  LVM_GETSELECTIONMARK

#define LVIS_STATEIMAGEMASK_CHECK (0x2000)
#define LVIS_STATEIMAGEMASK_UNCHECK (0x1000)

// temporarily define TasManager Flag until in header.
#ifndef TASK_FLAG_RUN_ONLY_IF_LOGGED_ON
#define TASK_FLAG_RUN_ONLY_IF_LOGGED_ON        (0x2000)
#endif // TASK_FLAG_RUN_ONLY_IF_LOGGED_ON



#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\dll\rasui.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       rasui.cpp
//
//  Contents:   helper functions for showing Ras UI
//
//  Classes:
//
//  Notes:
//
//  History:    08-Dec-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

extern TCHAR szSyncMgrHelp[];
extern ULONG g_aContextHelpIds[];

extern HINSTANCE g_hmodThisDll;


//+---------------------------------------------------------------------------
//
//  Member:     CRasUI::CRasUI, public
//
//  Synopsis:   
//
//  Arguments: 
//
//  Returns:    
//
//  Modifies:
//
//  History:    08-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

CRasUI::CRasUI()
{
    m_pNetApi = NULL;
    
    m_cEntries = 0;
    m_lprasentry = 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRasUI::~CRasUI, public
//
//  Synopsis:   
//
//  Arguments: 
//
//  Returns:    
//
//  Modifies:
//
//  History:    08-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

CRasUI::~CRasUI()
{
    
    // clear out any cached enum
    m_cEntries = 0; // make sure on error our enum cash is reset.
    if (m_lprasentry)
    {
        FREE(m_lprasentry);
        m_lprasentry = NULL;
    }
    
    m_pNetApi->Release();
}


//+---------------------------------------------------------------------------
//
//  Member:     CRasUI::Initialize, public
//
//  Synopsis:   
//
//  Arguments: 
//
//  Returns:    
//
//  Modifies:
//
//  History:    08-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CRasUI::Initialize()
{
    
    if (NOERROR != MobsyncGetClassObject(MOBSYNC_CLASSOBJECTID_NETAPI,
        (void **) &m_pNetApi))
    {
        m_pNetApi = NULL;
    }
    
    return TRUE; // always return true, let other ras calls fail since need 
    // to handle LAN.
}


//+---------------------------------------------------------------------------
//
//  Member:     CRasUI::IsConnectionLan, public
//
//  Synopsis:   
//
//  Arguments: 
//
//  Returns:    
//
//  Modifies:
//
//  History:    08-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CRasUI::IsConnectionLan(int iConnectionNum)
{
    
    // ui always puts the LAN connection as the first item 
    // Need to add logic to get if truly lan if add support
    // for multiple LAN cards and/or not show if no LAN
    // card.
    
    if (iConnectionNum ==0)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
    
}


//+---------------------------------------------------------------------------
//
//  Member:     CRasUI::FillRasCombo, public
//
//  Synopsis:   
//
//  Arguments: hwndCtrl - Combo Ctrl to fill items with
//             fForceEnum - reenum rasphonebook instead of using cache
//             fShowRasEntries - true if should include ras entries
//                  in combo, if false, only LAN Connection is shown. 
//
//  Returns:    
//
//  Modifies:
//
//  History:    08-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

void CRasUI::FillRasCombo(HWND hwndCtl,BOOL fForceEnum,BOOL fShowRasEntries)
{
    DWORD dwSize;
    DWORD dwError;
    COMBOBOXEXITEM comboItem;
    DWORD cEntryIndex;
    INT_PTR iItem = 0;
    HIMAGELIST himage;
    HICON hIcon;
    TCHAR szBuf[MAX_PATH + 1];
    UINT ImageListflags;
    
    ImageListflags = ILC_COLOR | ILC_MASK;
    if (IsHwndRightToLeft(hwndCtl))
    {
        ImageListflags |=  ILC_MIRROR;
    }
    
    himage = ImageList_Create(16,16,ImageListflags ,5,20);
    if (himage)
    {
        SendMessage(hwndCtl,CBEM_SETIMAGELIST,0,(LPARAM) himage);
    }
    
    
    if (LoadString(g_hmodThisDll, IDS_LAN_CONNECTION, szBuf, MAX_PATH))
    {
        
        hIcon = LoadIcon(g_hmodThisDll,MAKEINTRESOURCE(IDI_LANCONNECTION));
        comboItem.iImage = ImageList_AddIcon(himage,hIcon);
        
        comboItem.mask = CBEIF_TEXT  | CBEIF_IMAGE  | CBEIF_LPARAM | CBEIF_INDENT
            | CBEIF_SELECTEDIMAGE;
        
        comboItem.iItem = iItem;
        comboItem.pszText = szBuf;
        comboItem.cchTextMax = lstrlen(szBuf) + 1;
        comboItem.iIndent = 0;
        comboItem.iSelectedImage = comboItem.iImage;
        comboItem.lParam  = SYNCSCHEDINFO_FLAGS_CONNECTION_LAN;
        
        iItem = SendMessage(hwndCtl, CBEM_INSERTITEM, (WPARAM) 0, (LPARAM) &comboItem);
        ++iItem;
    }
    
    dwError = 0; // if dont' show ras there are now errors
    
    if (fShowRasEntries)
    {
        // if we are forced to reenum the Rasconnections then free any existing cache
        
        if (fForceEnum)
        {
            m_cEntries = 0;
            if (m_lprasentry)
            {
                FREE(m_lprasentry);
                m_lprasentry = NULL;
            }
            
        }
        
        // if RAS couldn't be loaded, just have LAN connection.
        if (NULL == m_lprasentry) // if don't already have an enum cached then enum now.
        {
            
            dwSize = sizeof(*m_lprasentry);
            
            m_lprasentry = (LPRASENTRYNAME) ALLOC(dwSize);
            if(!m_lprasentry)
                goto error;
            
            m_lprasentry->dwSize = sizeof(*m_lprasentry);
            m_cEntries = 0;
            dwError = m_pNetApi->RasEnumEntries(NULL, NULL, 
                m_lprasentry, &dwSize, &m_cEntries);
            
            if (dwError == ERROR_BUFFER_TOO_SMALL)
            {
                FREE(m_lprasentry);
                m_lprasentry =  (LPRASENTRYNAME) ALLOC(dwSize);
                if(!m_lprasentry)
                    goto error;
                
                m_lprasentry->dwSize = sizeof(RASENTRYNAME);
                m_cEntries = 0;
                dwError = m_pNetApi->RasEnumEntries(NULL, NULL, 
                    m_lprasentry, &dwSize, &m_cEntries);
                
                Assert(0 == dwError);
            }
            
            if (dwError)
                goto error;
        }
        
        cEntryIndex = m_cEntries;
        
        comboItem.mask = CBEIF_DI_SETITEM | CBEIF_TEXT  | CBEIF_IMAGE  | CBEIF_LPARAM | CBEIF_INDENT
            | CBEIF_SELECTEDIMAGE ;
        
        hIcon = LoadIcon(g_hmodThisDll,MAKEINTRESOURCE(IDI_RASCONNECTION)); 
        comboItem.iImage = ImageList_AddIcon(himage,hIcon);
        comboItem.iItem = iItem;
        comboItem.iIndent = 0;
        comboItem.iSelectedImage = comboItem.iImage;
        comboItem.lParam  = SYNCSCHEDINFO_FLAGS_CONNECTION_WAN;
        
        while(cEntryIndex)
        {
            comboItem.pszText = m_lprasentry[cEntryIndex-1].szEntryName;
            
            iItem = SendMessage(hwndCtl, CBEM_INSERTITEM, (WPARAM) 0, (LPARAM) &comboItem);
            cEntryIndex--;
        }
    }
    
error:  
    SendMessage(hwndCtl, CB_SETCURSEL,0, 0);
    
    if (dwError)
    {
        m_cEntries = 0; // make sure on error our enum cash is reset.
        if (m_lprasentry)
        {
            FREE(m_lprasentry);
            m_lprasentry = NULL;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\dll\reg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       Reg.cpp
//
//  Contents:   Registration routines
//
//  Classes:
//
//  Notes:
//
//  History:    05-Nov-97   rogerg      Created.
//                              11-18-97        susia           Added Autosync and user reg key functions
//
//--------------------------------------------------------------------------

#include "precomp.h"

#ifdef _SENS
#include <eventsys.h> // include event system
#include <sens.h>
#include <sensevts.h>
#endif // _SENS

// temporariy define new mstask flag in case hasn't
// propogated to sdk\inc

#ifndef TASK_FLAG_RUN_ONLY_IF_LOGGED_ON
#define TASK_FLAG_RUN_ONLY_IF_LOGGED_ON        (0x2000)
#endif // TASK_FLAG_RUN_ONLY_IF_LOGGED_ON
extern HINSTANCE g_hmodThisDll; // Handle to this DLL itself.
extern CRITICAL_SECTION g_DllCriticalSection;   // Global Critical Section for this DLL

// only return success on NT 5.0

BOOL GetUserDefaultSecurityAttribs(SECURITY_ATTRIBUTES *psa
                                   ,PSECURITY_DESCRIPTOR psd,
                                   PACL *ppOutAcl)
{
    BOOL bRetVal;
    int cbAcl;
    PACL pAcl = NULL;
    PSID pInteractiveUserSid = NULL;
    PSID pLocalSystemSid = NULL;
    PSID pAdminsSid = NULL;
    SID_IDENTIFIER_AUTHORITY LocalSystemAuthority = SECURITY_NT_AUTHORITY;
    
    *ppOutAcl = NULL;
    
    bRetVal = FALSE;
    
    // in the structure.
    
    bRetVal = InitializeSecurityDescriptor(
        psd,                          // Pointer to SD
        SECURITY_DESCRIPTOR_REVISION  // SD revision
        );
    
    if (!bRetVal)
    {
        AssertSz(0,"Unable to Init SecurityDescriptor");
        goto errRtn;
    }
    
    // setup acls.
    
    bRetVal = AllocateAndInitializeSid(
        &LocalSystemAuthority,      // Pointer to identifier authority
        1,                    // Count of subauthority
        SECURITY_INTERACTIVE_RID,   // Subauthority 0
        0,                    // Subauthority 1
        0,                    // Subauthority 2
        0,                    // Subauthority 3
        0,                    // Subauthority 4
        0,                    // Subauthority 5
        0,                    // Subauthority 6
        0,                    // Subauthority 7
        &pInteractiveUserSid            // pointer to pointer to SID
        );
    
    
    if (!bRetVal)
    {
        AssertSz(0,"Alocate sid failed");
        goto errRtn;
    }
    
    bRetVal = AllocateAndInitializeSid(
        &LocalSystemAuthority,      // Pointer to identifier authority
        2,
        SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_ADMINS,  
        0,
        0,                    // Subauthority 3
        0,                    // Subauthority 4
        0,                    // Subauthority 5
        0,                    // Subauthority 6
        0,                    // Subauthority 7
        &pAdminsSid            // pointer to pointer to SID
        );
    
    if (!bRetVal)
    {
        AssertSz(0,"Alocate sid failed");
        goto errRtn;
    }
    
    
    bRetVal = AllocateAndInitializeSid(
        &LocalSystemAuthority,// Pointer to identifier authority
        1,                    // Count of subauthority
        SECURITY_LOCAL_SYSTEM_RID,   // Subauthority 0
        0,                    // Subauthority 1
        0,                    // Subauthority 2
        0,                    // Subauthority 3
        0,                    // Subauthority 4
        0,                    // Subauthority 5
        0,                    // Subauthority 6
        0,                    // Subauthority 7
        &pLocalSystemSid      // pointer to pointer to SID
        );
    
    if (!bRetVal)
    {
        AssertSz(0,"Alocate sid failed");
        goto errRtn;
    }
    
    cbAcl =   sizeof (ACL)
        + 3 * sizeof (ACCESS_ALLOWED_ACE)
        + GetLengthSid(pInteractiveUserSid)
        + GetLengthSid(pLocalSystemSid)
        + GetLengthSid(pAdminsSid);
    
    pAcl = (PACL) new char[cbAcl];
    
    if (NULL == pAcl)
    {
        bRetVal = FALSE;
        
        AssertSz(0,"unable to alloc ACL");
        goto errRtn;
    }
    
    bRetVal = InitializeAcl(
        pAcl,             // Pointer to the ACL
        cbAcl,            // Size of ACL
        ACL_REVISION      // Revision level of ACL
        );
    
    if (!bRetVal)
    {
        AssertSz(0,"InitAcl failed");
        goto errRtn;
    }
    
    
    bRetVal = AddAccessAllowedAce(
        pAcl,             // Pointer to the ACL
        ACL_REVISION,     // ACL revision level
        SPECIFIC_RIGHTS_ALL | GENERIC_READ | DELETE ,    // Access Mask
        pInteractiveUserSid         // Pointer to SID
        );
    
    if (!bRetVal)
    {
        AssertSz(0,"AddAccessAllowed Failed");
        goto errRtn;
    }
    
    
    bRetVal = AddAccessAllowedAce(
        pAcl,             // Pointer to the ACL
        ACL_REVISION,     // ACL revision level
        GENERIC_ALL,    // Access Mask
        pAdminsSid         // Pointer to SID
        );
    
    if (!bRetVal)
    {
        AssertSz(0,"AddAccessAllowed Failed");
        goto errRtn;
    }
    
    bRetVal = AddAccessAllowedAce(
        pAcl,             // Pointer to the ACL
        ACL_REVISION,     // ACL revision level
        GENERIC_ALL,    // Access Mask
        pLocalSystemSid         // Pointer to SID
        );
    
    if (!bRetVal)
    {
        AssertSz(0,"AddAccessAllowed Failed");
        goto errRtn;
    }
    
    bRetVal =  SetSecurityDescriptorDacl(psd,TRUE,pAcl,FALSE);
    
    if (!bRetVal)
    {
        AssertSz(0,"SetSecurityDescriptorDacl Failed");
        goto errRtn;
    }
    
    psa->nLength = sizeof(SECURITY_ATTRIBUTES);
    psa->lpSecurityDescriptor = psd;
    psa->bInheritHandle = FALSE;
    
errRtn:
    
    if (pInteractiveUserSid)
    {
        FreeSid(pInteractiveUserSid); 
    }
    
    if (pLocalSystemSid)
    {
        FreeSid(pLocalSystemSid);   
    }
    
    if (pAdminsSid)
    {
        FreeSid(pAdminsSid);
    }
    
    //
    // On failure, we clean the ACL up. On success, the caller cleans
    // it up after using it.
    //
    if (FALSE == bRetVal)
    {
        if (pAcl)
        {
            delete[] pAcl;
        }
    }
    else
    {
        Assert(pAcl);
        *ppOutAcl = pAcl;
    }
    
    return bRetVal;
}

const WCHAR SZ_USERSIDKEY[] = TEXT("SID");

// calls regOpen or create based on fCreate param


LONG RegGetKeyHelper(HKEY hkey,LPCWSTR pszKey,REGSAM samDesired,BOOL fCreate,
                     HKEY *phkResult,DWORD *pdwDisposition)
{
    LONG lRet = -1;
    
    Assert(pdwDisposition);
    
    *pdwDisposition = 0; 
    
    if (fCreate)
    {
        lRet = RegCreateKeyEx(hkey,pszKey,0,NULL,REG_OPTION_NON_VOLATILE,
            samDesired,NULL,phkResult,pdwDisposition);  
    }
    else
    {
        lRet = RegOpenKeyEx(hkey,pszKey,0,samDesired,phkResult);
        
        if (ERROR_SUCCESS == lRet)
        {
            *pdwDisposition = REG_OPENED_EXISTING_KEY; 
        }
        
    }
    
    return lRet;
}



// called to create a new UserKey or subkey
LONG RegCreateUserSubKey(
                         HKEY hKey,
                         LPCWSTR lpSubKey,
                         REGSAM samDesired,
                         PHKEY phkResult)
{
    LONG lRet;
    DWORD dwDisposition;
    
    lRet = RegCreateKeyEx(hKey,lpSubKey,0,NULL,REG_OPTION_NON_VOLATILE,
        samDesired,NULL,phkResult,&dwDisposition);    
    
    // !! if subkey contains \\ don't traverse back through the list
    
    if ( (ERROR_SUCCESS == lRet) && (REG_CREATED_NEW_KEY == dwDisposition))
    {
        HKEY hKeySecurity;
        SECURITY_ATTRIBUTES sa;
        SECURITY_DESCRIPTOR sd;
        PACL pOutAcl;
        
        if (ERROR_SUCCESS == RegOpenKeyEx(hKey,
            lpSubKey,
            REG_OPTION_OPEN_LINK, WRITE_DAC,&hKeySecurity) )
        {
            if (GetUserDefaultSecurityAttribs(&sa,&sd,&pOutAcl))
            {
                RegSetKeySecurity(hKeySecurity,
                    (SECURITY_INFORMATION) DACL_SECURITY_INFORMATION,
                    &sd);
                
                delete[] pOutAcl;
            }
            
            RegCloseKey(hKeySecurity);
        }
    }
    return lRet;
}


STDAPI_(HKEY) RegOpenUserKey(HKEY hkeyParent,REGSAM samDesired,BOOL fCreate,BOOL fCleanReg)
{
    TCHAR  pszDomainAndUser[MAX_DOMANDANDMACHINENAMESIZE];
    HKEY hKeyUser;
    BOOL fSetUserSid = FALSE;
    WCHAR szUserSID[MAX_PATH + 1];
    DWORD dwDisposition;
    LONG ret;
    
    
    GetDefaultDomainAndUserName(pszDomainAndUser,TEXT("_"),ARRAYSIZE(pszDomainAndUser));
    
    // If suppose to clean the settings for the user/ delete the key
    if (fCleanReg)
    {
        RegDeleteKeyNT(hkeyParent,pszDomainAndUser); 
    }
    
    
    if (ERROR_SUCCESS != (ret = RegGetKeyHelper(hkeyParent,pszDomainAndUser,samDesired,fCreate,
                                                &hKeyUser,&dwDisposition)))
    {
        hKeyUser = NULL;
    }
    
    if (hKeyUser)
    {
        WCHAR szRegSID[MAX_PATH + 1];
        DWORD cbRegSID = sizeof(szRegSID);
        
        if (ERROR_SUCCESS !=SHRegGetValue(hKeyUser,NULL,
                                          SZ_USERSIDKEY,SRRF_RT_REG_SZ | SRRF_NOEXPAND, NULL, 
                                          (LPBYTE) szRegSID, &cbRegSID))
        {
            fSetUserSid = TRUE; 
            
            // if have to set the sid need to make sure openned
            // with set Value and if didn't close key and 
            // let create re-open it with the desired access.
            
            if (!(samDesired & KEY_SET_VALUE))
            {
                RegCloseKey(hKeyUser);
                hKeyUser = NULL;
            }
            
        }
        else
        {
            if (GetUserTextualSid(szUserSID, ARRAYSIZE(szUserSID)))
            {
                if (lstrcmp(szRegSID, szUserSID))
                {
                    // if don't have access privledges
                    // to delete the User this will fail.
                    // may want a call into SENS to delete the
                    // User Key on Failure.
                    RegCloseKey(hKeyUser);
                    hKeyUser = NULL; // set to NULL so check below fails.
                    RegDeleteKeyNT(hkeyParent,pszDomainAndUser); 
                }
            }
        }
    }
    
    
    if (NULL == hKeyUser)
    {
        
        if (ERROR_SUCCESS != (ret = RegGetKeyHelper(hkeyParent,pszDomainAndUser,
            samDesired,fCreate,
            &hKeyUser,&dwDisposition)))
        {
            hKeyUser = NULL;
        }
        else
        {
            if (REG_CREATED_NEW_KEY == dwDisposition)
            {
                fSetUserSid = TRUE;
            }
        }
    }
    
    // on creation setup the security
    if ( (ERROR_SUCCESS == ret) && (REG_CREATED_NEW_KEY == dwDisposition))
    {
        
        HKEY hKeySecurity;
        SECURITY_ATTRIBUTES sa;
        SECURITY_DESCRIPTOR sd;
        PACL pOutAcl;
        
        // !! should have own call for  sync type key security
        if (ERROR_SUCCESS == RegOpenKeyEx(hkeyParent,pszDomainAndUser,
            REG_OPTION_OPEN_LINK, WRITE_DAC,&hKeySecurity) )
        {
            if (GetUserDefaultSecurityAttribs(&sa,&sd,&pOutAcl))
            {
                RegSetKeySecurity(hKeySecurity,
                    (SECURITY_INFORMATION) DACL_SECURITY_INFORMATION,
                    &sd);
                
                delete[] pOutAcl;
            }
            
            RegCloseKey(hKeySecurity);
        }
    }    
    
    // setup the User sid.
    // depends on key being openned with KEY_SET_VALUE
    if (hKeyUser && fSetUserSid && (samDesired & KEY_SET_VALUE))
    {
        if (GetUserTextualSid(szUserSID, ARRAYSIZE(szUserSID)))
        {
            DWORD dwType = REG_SZ;
            
            RegSetValueEx (hKeyUser,SZ_USERSIDKEY,NULL,
                dwType,
                (LPBYTE) szUserSID,
                (lstrlen(szUserSID) + 1)*sizeof(WCHAR));
        }
        
    }
    
    
    return hKeyUser;
    
}

STDAPI_(HKEY) RegGetSyncTypeKey(DWORD dwSyncType,REGSAM samDesired,BOOL fCreate)
{
    HKEY hKeySyncType;
    LPCWSTR pszKey;
    LONG ret;
    DWORD dwDisposition;
    
    // get appropriate key to open based on sync type
    
    switch(dwSyncType)
    {
    case SYNCTYPE_MANUAL:
        pszKey = MANUALSYNC_REGKEY;
        break;
    case SYNCTYPE_AUTOSYNC:
        pszKey = AUTOSYNC_REGKEY;
        break;
    case SYNCTYPE_IDLE:
        pszKey = IDLESYNC_REGKEY;
        break;
    case SYNCTYPE_SCHEDULED:
        pszKey = SCHEDSYNC_REGKEY;
        break;
    case SYNCTYPE_PROGRESS:
        pszKey = PROGRESS_REGKEY;
        break;
    default:
        AssertSz(0,"Unknown SyncType");
        pszKey = NULL;
        break;
    }
    
    if (NULL == pszKey)
    {
        return NULL;
    }
    
    // first try to open the existing key
    if (ERROR_SUCCESS != (ret = RegGetKeyHelper(HKEY_LOCAL_MACHINE,pszKey,samDesired,fCreate,
        &hKeySyncType,&dwDisposition)))
    {
        // if can't open key try to create 
        
        if (ERROR_ACCESS_DENIED == ret )
        {
            // if access denied, call sens to reset
            // the security on the topelevel keys.
            SyncMgrExecCmd_ResetRegSecurity();
            
            ret = RegGetKeyHelper(HKEY_LOCAL_MACHINE,pszKey,samDesired,fCreate,
                &hKeySyncType,&dwDisposition);        
        }
        
        if (ERROR_SUCCESS != ret)
        {
            hKeySyncType = NULL;
        }
    }
    if ( (ERROR_SUCCESS == ret) && (REG_CREATED_NEW_KEY == dwDisposition))
    {
        HKEY hKeySecurity;
        SECURITY_ATTRIBUTES sa;
        SECURITY_DESCRIPTOR sd;
        PACL pOutAcl;
        
        // !! should have own call for  sync type key security
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,pszKey,
            REG_OPTION_OPEN_LINK, WRITE_DAC,&hKeySecurity) )
        {
            if (GetUserDefaultSecurityAttribs(&sa,&sd,&pOutAcl))
            {
                RegSetKeySecurity(hKeySecurity,
                    (SECURITY_INFORMATION) DACL_SECURITY_INFORMATION,
                    &sd);
                
                delete[] pOutAcl;
            }
            
            RegCloseKey(hKeySecurity);
        }
    }
    
    return hKeySyncType;
}


STDAPI_(HKEY) RegGetCurrentUserKey(DWORD dwSyncType,REGSAM samDesired,BOOL fCreate)
{
    HKEY hKeySyncType;
    HKEY hKeyUser = NULL;
    
    hKeySyncType = RegGetSyncTypeKey(dwSyncType,samDesired ,fCreate);
    
    if (hKeySyncType)
    {
        hKeyUser =  RegOpenUserKey(hKeySyncType,samDesired,fCreate,FALSE /* fClean */);
        RegCloseKey(hKeySyncType);
    }
    
    return hKeyUser;
}


// tries to open and set security if necessary on the handler keys.

STDAPI_(HKEY) RegGetHandlerTopLevelKey(REGSAM samDesired)
{
    HKEY hKeyTopLevel;
    LONG ret;
    DWORD dwDisposition;
    
    // if open failed then try a create.
    if (ERROR_SUCCESS != (ret = RegCreateKeyEx (HKEY_LOCAL_MACHINE,HANDLERS_REGKEY,0, NULL,
        REG_OPTION_NON_VOLATILE,samDesired,NULL,
        &hKeyTopLevel,
        &dwDisposition)))
    {
        
        // if got an access denige on the handlers key 
        // call sens to reset.
        if (ERROR_ACCESS_DENIED == ret )
        {
            // if access denied, call sens to reset
            // the security on the topelevel keys.
            // and try again
            SyncMgrExecCmd_ResetRegSecurity();
            
            ret = RegCreateKeyEx (HKEY_LOCAL_MACHINE,HANDLERS_REGKEY,0, NULL,
                REG_OPTION_NON_VOLATILE,samDesired,NULL,
                &hKeyTopLevel,
                &dwDisposition);
        }
        
        if (ERROR_SUCCESS != ret)
        {
            hKeyTopLevel = NULL;
        }
    }
    
    if ( (ERROR_SUCCESS == ret) && (REG_CREATED_NEW_KEY == dwDisposition))
    {
        HKEY hKeySecurity;
        SECURITY_ATTRIBUTES sa;
        SECURITY_DESCRIPTOR sd;
        PACL pOutAcl;
        
        // !! should have own call for toplevel handler key security
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
            HANDLERS_REGKEY,
            REG_OPTION_OPEN_LINK, WRITE_DAC,&hKeySecurity) )
        {
            if (GetUserDefaultSecurityAttribs(&sa,&sd,&pOutAcl))
            {
                RegSetKeySecurity(hKeySecurity,
                    (SECURITY_INFORMATION) DACL_SECURITY_INFORMATION,
                    &sd);
                
                delete[] pOutAcl;
            }
            
            RegCloseKey(hKeySecurity);
        }
    }
    
    return hKeyTopLevel;
    
}

STDAPI_(HKEY) RegGetHandlerKey(HKEY hkeyParent,LPCWSTR pszHandlerClsid,REGSAM samDesired,
                               BOOL fCreate)
{
    HKEY hKeyHandler = NULL;
    LRESULT lRet;
    DWORD dwDisposition;
    
    
    if (ERROR_SUCCESS != (lRet = RegGetKeyHelper(hkeyParent,pszHandlerClsid,samDesired,
        fCreate,&hKeyHandler,&dwDisposition)))
    {
        hKeyHandler = NULL;
    }
    
    if (NULL == hKeyHandler)
    {
        
        // if got an access denied call sens to unlock
        if (ERROR_ACCESS_DENIED == lRet )
        {
            // if access denied, call sens to reset
            // the security on the topelevel keys.
            // and try again
            SyncMgrExecCmd_ResetRegSecurity();
            
            lRet = RegGetKeyHelper(hkeyParent,pszHandlerClsid,samDesired,
                fCreate,&hKeyHandler,&dwDisposition);
        }
        
        if (ERROR_SUCCESS != lRet)
        {
            hKeyHandler = NULL;
        }
        
    }
    
    if ( (ERROR_SUCCESS == lRet) && (REG_CREATED_NEW_KEY == dwDisposition))
    {
        HKEY hKeySecurity;
        SECURITY_ATTRIBUTES sa;
        SECURITY_DESCRIPTOR sd;
        PACL pOutAcl;
        
        // !! should have own call for  handler key security
        if (ERROR_SUCCESS == RegOpenKeyEx(hkeyParent,
            pszHandlerClsid,
            REG_OPTION_OPEN_LINK, WRITE_DAC,&hKeySecurity) )
        {
            if (GetUserDefaultSecurityAttribs(&sa,&sd,&pOutAcl))
            {
                
                RegSetKeySecurity(hKeySecurity,
                    (SECURITY_INFORMATION) DACL_SECURITY_INFORMATION,
                    &sd);
                
                delete[] pOutAcl;
            }
            
            RegCloseKey(hKeySecurity);
        }
    }
    
    return hKeyHandler;
}


/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: DWORD RegDeleteKeyNT(HKEY hStartKey , LPTSTR pKeyName )
  
    Summary:  Recursively delete a key on NT
    
      Returns:  Returns TRUE if successful, FALSE otherwise
      
------------------------------------------------------------------------F-F*/


STDAPI_(DWORD) RegDeleteKeyNT(HKEY hStartKey , LPCWSTR pKeyName )
{
    DWORD   dwRtn, dwSubKeyLength;
    LPTSTR  pSubKey = NULL;
    TCHAR   szSubKey[MAX_KEY_LENGTH]; // (256) this should be dynamic.
    HKEY    hkey;
    
    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGISTRYMUTEXNAME);
    CMutexRegistry.Enter();
    
    // do not allow NULL or empty key name
    if ( pKeyName &&  lstrlen(pKeyName))
    {
        if( (dwRtn=RegOpenKeyEx(hStartKey,pKeyName,
            0, KEY_ENUMERATE_SUB_KEYS | DELETE, &hkey )) == ERROR_SUCCESS)
        {
            while (dwRtn == ERROR_SUCCESS )
            {
                dwSubKeyLength = MAX_KEY_LENGTH;
                dwRtn=RegEnumKeyEx(
                    hkey,
                    0,       // always index zero
                    szSubKey,
                    &dwSubKeyLength,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );
                
                if(dwRtn == ERROR_NO_MORE_ITEMS)
                {
                    dwRtn = RegDeleteKey(hStartKey, pKeyName);
                    break;
                }
                else if(dwRtn == ERROR_SUCCESS)
                    dwRtn=RegDeleteKeyNT(hkey, szSubKey);
            }
            RegCloseKey(hkey);
            // Do not save return code because error
            // has already occurred
        }
    }
    else
        dwRtn = ERROR_BADKEY;
    
    CMutexRegistry.Leave();
    return dwRtn;
}


/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: RegGetProgressDetailsState()
  
    Summary:  Gets the expanded or collapsed user preference for the progress dialog
    and the pushpin preference
    
      Returns:  Returns TRUE if succeeded, FALSE otherwise
      
------------------------------------------------------------------------F-F*/
STDAPI_(BOOL) RegGetProgressDetailsState(REFCLSID clsidDlg,BOOL *pfPushPin, BOOL *pfExpanded)
{
    SCODE   sc = S_FALSE;
    HKEY    hkeyUserProgress,hkeyclsidDlg;    
    WCHAR   wszCLSID[GUID_SIZE + 1];
    
    if (0 == StringFromGUID2(clsidDlg, wszCLSID, ARRAYSIZE(wszCLSID)))
    {
        AssertSz(0,"Unable to make Guid a String");
        return FALSE;
    }
    
    //Prgress dialog defaults to collapsed, pushpin out
    *pfExpanded = FALSE;
    *pfPushPin = FALSE;
    
    hkeyUserProgress = RegGetCurrentUserKey(SYNCTYPE_PROGRESS,KEY_READ,FALSE);
    
    if (hkeyUserProgress)
    {
        
        if (ERROR_SUCCESS == RegOpenKeyEx(hkeyUserProgress,wszCLSID,0,KEY_READ,
            &hkeyclsidDlg))
        {
            DWORD   cbDataSize = sizeof(*pfExpanded);
            if (ERROR_SUCCESS == SHRegGetValue(hkeyclsidDlg,NULL,TEXT("Expanded"),SRRF_RT_REG_DWORD, NULL,
                (LPBYTE) pfExpanded, &cbDataSize))
            {
                cbDataSize = sizeof(*pfPushPin);
                
                if (ERROR_SUCCESS == SHRegGetValue(hkeyclsidDlg,NULL,TEXT("PushPin"),SRRF_RT_REG_DWORD, NULL,
                    (LPBYTE) pfPushPin, &cbDataSize))
                {
                    sc = S_OK;
                }
            }
            RegCloseKey(hkeyclsidDlg);
        }                
        RegCloseKey(hkeyUserProgress);
    }
    
    if (sc == S_OK)
        return TRUE;
    else 
        return FALSE;
    
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: RegSetProgressDetailsState(BOOL fExpanded)
  
    Summary:  Sets the expanded or collapsed user preference for the progress dialog
    
      Returns:  Returns TRUE if succeeded, FALSE otherwise
      
------------------------------------------------------------------------F-F*/
STDAPI_(BOOL)  RegSetProgressDetailsState(REFCLSID clsidDlg,BOOL fPushPin, BOOL fExpanded)
{
    BOOL fResult = FALSE;
    HKEY  hkeyUserProgress,hkeyclsidDlg;
    WCHAR  wszCLSID[GUID_SIZE + 1];
    
    
    if (0 == StringFromGUID2(clsidDlg, wszCLSID, ARRAYSIZE(wszCLSID)))
    {
        AssertSz(0,"Unable to make Guid a String");
        return FALSE;
    }
    
    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGISTRYMUTEXNAME);
    CMutexRegistry.Enter();
    
    hkeyUserProgress = RegGetCurrentUserKey(SYNCTYPE_PROGRESS,KEY_WRITE | KEY_READ,TRUE);
    
    if (hkeyUserProgress)
    {
        
        if (ERROR_SUCCESS == RegCreateUserSubKey(hkeyUserProgress,wszCLSID,
            KEY_WRITE | KEY_READ,
            &hkeyclsidDlg))
        {
            
            fResult = TRUE;
            
            if (ERROR_SUCCESS != RegSetValueEx(hkeyclsidDlg,TEXT("Expanded"),NULL, REG_DWORD,
                (LPBYTE) &(fExpanded),
                sizeof(fExpanded)))
            {
                fResult = FALSE;
            }
            
            
            if (ERROR_SUCCESS == RegSetValueEx(hkeyclsidDlg,TEXT("PushPin"),NULL, REG_DWORD,
                (LPBYTE) &(fPushPin),
                sizeof(fPushPin)))
            {
                fResult = FALSE;
            }
            
            RegCloseKey(hkeyclsidDlg);
        }
        
        RegCloseKey(hkeyUserProgress);
        
    }
    
    CMutexRegistry.Leave();
    return fResult;
    
}


/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: RegGetSyncItemSettings( DWORD dwSyncType,
  CLSID clsidHandler,
  SYNCMGRITEMID ItemId,
  const TCHAR *pszConnectionName,
  DWORD *pdwCheckState,
  DWORD dwDefaultCheckState,
  TCHAR *pszSchedName)
  
    Summary:  Gets the settings per handler, itemID, and connection name.
    If no selections on this connection, the default is ?
    
      Returns:  Returns TRUE if successful, FALSE otherwise
      
------------------------------------------------------------------------F-F*/
STDAPI_(BOOL) RegGetSyncItemSettings( DWORD dwSyncType,
                                     CLSID clsidHandler,
                                     SYNCMGRITEMID ItemId,
                                     const TCHAR *pszConnectionName,
                                     DWORD *pdwCheckState,
                                     DWORD dwDefaultCheckState,
                                     TCHAR *pszSchedName)
{
    HKEY hKeyUser;
    
    *pdwCheckState = dwDefaultCheckState;
    
    // special case schedule
    if (SYNCTYPE_SCHEDULED == dwSyncType)
    {
        // items are always turned off by default and if no schedule name
        // don't bother.
        *pdwCheckState = FALSE;
        if (!pszSchedName)
        {
            return FALSE;
        }
    }
    
    // open the user key for the type
    hKeyUser = RegGetCurrentUserKey(dwSyncType,KEY_READ,FALSE);
    
    if (NULL == hKeyUser)
    {
        return FALSE;
    }
    
    // for a schedule we need to go ahead and open up the schedule name
    // key
    
    HKEY hKeySchedule = NULL;
    
    // Review if want GetCurrentUserKey to Handle this.
    if (SYNCTYPE_SCHEDULED == dwSyncType)
    {
        if (ERROR_SUCCESS != RegOpenKeyEx((hKeyUser),
            pszSchedName,0,KEY_READ,
            &hKeySchedule))
        {
            hKeySchedule = NULL;
            RegCloseKey(hKeyUser);
            return FALSE;
        }
    }
    
    
    BOOL fResult;
    
    fResult =  RegLookupSettings(hKeySchedule ? hKeySchedule : hKeyUser,
        clsidHandler,
        ItemId,
        pszConnectionName,
        pdwCheckState);
    
    if (hKeySchedule)
    {
        RegCloseKey(hKeySchedule);
    }
    
    if (hKeyUser)
    {
        RegCloseKey(hKeyUser);
    }
    
    return fResult;
}



/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: RegSetSyncItemSettings( DWORD dwSyncType,
  CLSID clsidHandler,
  SYNCMGRITEMID ItemId,
  const TCHAR *pszConnectionName,
  DWORD dwCheckState,
  TCHAR *pszSchedName)
  
    Summary:  Sets the settings per handler, itemID, and connection name.
    
      Returns:  Returns TRUE if successful, FALSE otherwise
      
------------------------------------------------------------------------F-F*/

STDAPI_(BOOL) RegSetSyncItemSettings( DWORD dwSyncType,
                                     CLSID clsidHandler,
                                     SYNCMGRITEMID ItemId,
                                     const TCHAR *pszConnectionName,
                                     DWORD dwCheckState,
                                     TCHAR *pszSchedName)
{
    HKEY hKeyUser;
    
    
    if (SYNCTYPE_SCHEDULED == dwSyncType)
    {
        if (NULL == pszSchedName)
        {
            return FALSE;
        }
    }
    
    // open the user key for the type
    hKeyUser = RegGetCurrentUserKey(dwSyncType,KEY_WRITE | KEY_READ,TRUE);
    
    if (NULL == hKeyUser)
    {
        return FALSE;
    }
    
    // for a schedule we need to go ahead and open up the schedule name
    // key
    
    HKEY hKeySchedule = NULL;
    
    if (SYNCTYPE_SCHEDULED == dwSyncType)
    {
        if (ERROR_SUCCESS != RegCreateUserSubKey(hKeyUser,
            pszSchedName,KEY_WRITE |  KEY_READ,
            &hKeySchedule))
        {
            hKeySchedule = NULL;
            RegCloseKey(hKeyUser);
            return FALSE;
        }
    }
    
    BOOL fResult;
    
    fResult =  RegWriteOutSettings(hKeySchedule ? hKeySchedule : hKeyUser,
        clsidHandler,
        ItemId,
        pszConnectionName,
        dwCheckState);
    
    if (hKeySchedule)
    {
        RegCloseKey(hKeySchedule);
    }
    
    if (hKeyUser)
    {
        RegCloseKey(hKeyUser);
    }
    
    return fResult;
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: RegQueryLoadHandlerOnEvent( )
  
    Summary:  Determines if there is any reason to load this handler
    for the specified event and Connection
    
      Returns:  Returns TRUE if successful, FALSE otherwise
      
------------------------------------------------------------------------F-F*/

STDAPI_(BOOL) RegQueryLoadHandlerOnEvent(TCHAR *pszClsid,DWORD dwSyncFlags,
                                         TCHAR *pConnectionName)
{
    BOOL fLoadHandler = FALSE;
    DWORD dwSyncType;
    
    switch(dwSyncFlags & SYNCMGRFLAG_EVENTMASK)
    {
    case SYNCMGRFLAG_CONNECT:
    case SYNCMGRFLAG_PENDINGDISCONNECT:
        {
            dwSyncType = SYNCTYPE_AUTOSYNC;
        }
        break;
    case SYNCMGRFLAG_IDLE:
        {
            dwSyncType = SYNCTYPE_IDLE;
        }
        break;
    default:
        AssertSz(0,"Unknown SyncType");
        return FALSE;
        break;
    }
    
    // walk done the list openning keys.
    HKEY hkeySyncType;
    
    if (hkeySyncType = RegGetCurrentUserKey(dwSyncType,KEY_READ,FALSE))
    {
        HKEY hkeyConnectionName;
        
        if (ERROR_SUCCESS == RegOpenKeyEx(hkeySyncType,pConnectionName,0,KEY_READ,&hkeyConnectionName))
        {
            HKEY hkeyClsid;
            
            if (ERROR_SUCCESS == RegOpenKeyEx(hkeyConnectionName,pszClsid,0,KEY_READ,&hkeyClsid))
            {
                DWORD fQueryResult;
                DWORD cbDataSize = sizeof(fQueryResult);
                
                
                if (ERROR_SUCCESS == SHRegGetValue(hkeyClsid,NULL,TEXT("ItemsChecked"),SRRF_RT_REG_DWORD, 
                    NULL, (LPBYTE) &fQueryResult, &cbDataSize))
                {
                    fLoadHandler = fQueryResult;
                }
                
                RegCloseKey(hkeyClsid);
            }
            
            RegCloseKey(hkeyConnectionName);
        }
        
        RegCloseKey(hkeySyncType);
    }
    
    
    return fLoadHandler;
}


/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: RegSetSyncHandlerSettings( )
  
    Summary:  Sets the handler settings for syncType and Connection.
    
      Returns:  Returns TRUE if successful, FALSE otherwise
      
------------------------------------------------------------------------F-F*/

STDAPI_(BOOL) RegSetSyncHandlerSettings(DWORD dwSyncType,
                                        const TCHAR *pszConnectionName,
                                        CLSID clsidHandler,
                                        BOOL  fItemsChecked)
{
    HKEY hKeyUser;
    
    hKeyUser = RegGetCurrentUserKey(dwSyncType,KEY_WRITE |  KEY_READ,TRUE);
    
    if (NULL == hKeyUser)
    {
        return FALSE;
    }
    
    SCODE sc;
    HKEY hkeyConnection;
    HKEY hkeyCLSID;
    TCHAR    szCLSID[(GUID_SIZE + 1)];
    
    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGISTRYMUTEXNAME);
    CMutexRegistry.Enter();
    
    smChkTo(EH_Err2,RegCreateUserSubKey(hKeyUser,
        pszConnectionName,
        KEY_WRITE |  KEY_READ,
        &hkeyConnection));
    
    
    StringFromGUID2(clsidHandler, szCLSID, ARRAYSIZE(szCLSID));
    
    // Write entries under CLSID.
    smChkTo(EH_Err3,RegCreateUserSubKey(hkeyConnection,
        szCLSID,KEY_WRITE |  KEY_READ,
        &hkeyCLSID));
    
    RegSetValueEx(hkeyCLSID,TEXT("ItemsChecked"),NULL, REG_DWORD,
        (LPBYTE) &fItemsChecked,
        sizeof(fItemsChecked));
    
    RegCloseKey(hKeyUser);
    RegCloseKey(hkeyConnection);
    RegCloseKey(hkeyCLSID);
    CMutexRegistry.Leave();
    return TRUE;
    
EH_Err3:
    RegCloseKey(hkeyConnection);
EH_Err2:
    RegCloseKey(hKeyUser);
    
    CMutexRegistry.Leave();
    return FALSE;
}


/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: RegLookupSettings(const TCHAR *hkeyName,
  CLSID clsidHandler,
  SYNCMGRITEMID ItemID,
  const TCHAR *pszConnectionName,
  DWORD pdwCheckState)
  
    Summary:  Gets the settings per handler, itemID, and connection name.
    
      Returns:  Returns TRUE if there are settings for this item and
      connection, flase otherwise.
      
------------------------------------------------------------------------F-F*/

STDAPI_(BOOL) RegLookupSettings(HKEY hKeyUser,
                                CLSID clsidHandler,
                                SYNCMGRITEMID ItemID,
                                const TCHAR *pszConnectionName,
                                DWORD *pdwCheckState)
{
    SCODE sc;
    HKEY hkeyConnection;
    HKEY   hkeyItem;
    HKEY hKeyHandler;
    
    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGISTRYMUTEXNAME);
    CMutexRegistry.Enter();
    
    TCHAR    szID[GUID_SIZE+1];
    TCHAR    szCLSID[2*(GUID_SIZE+1)];
    
    
    smChkTo(EH_Err2,RegOpenKeyEx(hKeyUser,
        pszConnectionName,0,KEY_READ,
        &hkeyConnection));
    
    
    StringFromGUID2(clsidHandler, szCLSID, ARRAYSIZE(szCLSID));
    StringFromGUID2(ItemID, szID, ARRAYSIZE(szID));
    
    // Read entries under CLSID.
    smChkTo(EH_Err3,RegOpenKeyEx((hkeyConnection),
        szCLSID, 0, KEY_READ,
        &hKeyHandler));
    
    smChkTo(EH_Err4,RegOpenKeyEx((hKeyHandler),
        szID, 0, KEY_READ,
        &hkeyItem));
    
    DWORD cbDataSize = sizeof(*pdwCheckState);
    
    smChkTo(EH_Err4,SHRegGetValue(hkeyItem,NULL,TEXT("CheckState"),SRRF_RT_REG_DWORD, NULL, (LPBYTE)pdwCheckState, &cbDataSize));
    
    RegCloseKey(hkeyConnection);
    RegCloseKey(hkeyItem);
    RegCloseKey(hKeyHandler);
    
    CMutexRegistry.Leave();
    return TRUE;
    
EH_Err4:
    RegCloseKey(hKeyHandler);
EH_Err3:
    RegCloseKey(hkeyConnection);
EH_Err2:
    CMutexRegistry.Leave();
    return FALSE;
}


/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: RegWriteOutSettings(HKEY hKeyUser,
  CLSID clsidHandler,
  SYNCMGRITEMID ItemID,
  const TCHAR *pszConnectionName,
  DWORD dwCheckState)
  
    Summary:  Sets the settings per handler, itemID, and connection name.
    
      Returns:  Returns TRUE if we can set them, FALSE if there is an error
      
------------------------------------------------------------------------F-F*/

STDAPI_(BOOL) RegWriteOutSettings(HKEY hKeyUser,
                                  CLSID clsidHandler,
                                  SYNCMGRITEMID ItemID,
                                  const TCHAR *pszConnectionName,
                                  DWORD dwCheckState)
{
    SCODE sc;
    HKEY    hkeyConnection;
    HKEY   hKeyHandler;
    HKEY     hkeyItem;
    
    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGISTRYMUTEXNAME);
    CMutexRegistry.Enter();
    
    TCHAR    szID[GUID_SIZE+1];
    TCHAR    szCLSID[2*(GUID_SIZE+1)];
    
    smChkTo(EH_Err2,RegCreateUserSubKey(hKeyUser,
        pszConnectionName,KEY_WRITE |  KEY_READ,
        &hkeyConnection));
    
    
    StringFromGUID2(clsidHandler, szCLSID, ARRAYSIZE(szCLSID));
    StringFromGUID2(ItemID, szID, ARRAYSIZE(szID));
    
    
    smChkTo(EH_Err3,RegCreateUserSubKey(hkeyConnection,
        szCLSID,KEY_WRITE |  KEY_READ,
        &hKeyHandler));
    
    
    // Write entries under CLSID.
    smChkTo(EH_Err4,RegCreateUserSubKey(hKeyHandler,
        szID,KEY_WRITE |  KEY_READ,
        &hkeyItem));
    
    
    smChkTo(EH_Err4,RegSetValueEx(hkeyItem,TEXT("CheckState"),NULL, REG_DWORD,
        (LPBYTE) &dwCheckState,
        sizeof(dwCheckState)));
    
    RegCloseKey(hkeyConnection);
    RegCloseKey(hkeyItem);
    RegCloseKey(hKeyHandler);
    
    CMutexRegistry.Leave();
    return TRUE;
    
EH_Err4:
    RegCloseKey(hKeyHandler);
EH_Err3:
    RegCloseKey(hkeyConnection);
EH_Err2:
    CMutexRegistry.Leave();
    return FALSE;
}



/****************************************************************************

  AutoSync Registry Functions
  
***************************************************************************F-F*/

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: RegGetAutoSyncSettings(     LPCONNECTIONSETTINGS lpConnectionSettings)
  
    Summary:  Gets the logon, logoff and prompt me first user selections.
    If no selections on this connection, the default is ?
    
      Returns:  Returns TRUE if successful, FALSE otherwise
      
------------------------------------------------------------------------F-F*/
STDAPI_(BOOL)  RegGetAutoSyncSettings(LPCONNECTIONSETTINGS lpConnectionSettings)
{
    SCODE sc;
    HKEY hkeyConnection;
    
    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGISTRYMUTEXNAME);
    CMutexRegistry.Enter();
    
    
    // Set these first to default values, in case there are no current
    // user preferences in the registry
    lpConnectionSettings->dwLogon = FALSE;
    lpConnectionSettings->dwLogoff = FALSE;
    lpConnectionSettings->dwPromptMeFirst = FALSE;
    
    HKEY hKeyUser;
    
    hKeyUser = RegGetCurrentUserKey(SYNCTYPE_AUTOSYNC,KEY_READ,FALSE);
    
    if (NULL == hKeyUser)
    {
        goto EH_Err;
    }
    
    DWORD cbDataSize = sizeof(lpConnectionSettings->dwLogon);
    
    smChkTo(EH_Err3,RegOpenKeyEx(hKeyUser, lpConnectionSettings->pszConnectionName,0,KEY_READ,
        &hkeyConnection));
    
    smChkTo(EH_Err4,SHRegGetValue(hkeyConnection,NULL,TEXT("Logon"),SRRF_RT_REG_DWORD, NULL,
        (LPBYTE) &(lpConnectionSettings->dwLogon),
        &cbDataSize));
    
    cbDataSize = sizeof(lpConnectionSettings->dwLogoff);
    
    smChkTo(EH_Err4,SHRegGetValue(hkeyConnection,NULL,TEXT("Logoff"),SRRF_RT_REG_DWORD, NULL,
        (LPBYTE) &(lpConnectionSettings->dwLogoff),
        &cbDataSize));
    
    cbDataSize = sizeof(lpConnectionSettings->dwPromptMeFirst);
    
    smChkTo(EH_Err4,SHRegGetValue(hkeyConnection,NULL,TEXT("PromptMeFirst"),SRRF_RT_REG_DWORD, NULL,
        (LPBYTE) &(lpConnectionSettings->dwPromptMeFirst),
        &cbDataSize));
    
    RegCloseKey(hkeyConnection);
    RegCloseKey(hKeyUser);
    
    CMutexRegistry.Leave();
    
    return TRUE;
    
EH_Err4:
    RegCloseKey(hkeyConnection);
EH_Err3:
    RegCloseKey(hKeyUser);
EH_Err:
    CMutexRegistry.Leave();
    
    return FALSE;
    
}


/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: RegUpdateUserAutosyncKey
  
    Summary:  given an Autosync User Key makes sure it is in the latest
    format and if not updates it.
    
      Returns: 
      
------------------------------------------------------------------------F-F*/

void RegUpdateUserAutosyncKey(HKEY hkeyUser,BOOL fForce)
{
    DWORD   dwUserLogonLogoff;
    DWORD   cbDataSize = sizeof(dwUserLogonLogoff);
    DWORD dwIndex = 0;
    TCHAR lpName[MAX_PATH];
    DWORD cbName = MAX_PATH;
    
    DWORD dwLogon = 0;
    DWORD dwLogoff = 0;
    
    if (!fForce && (ERROR_SUCCESS == SHRegGetValue(hkeyUser,NULL,TEXT("Logon"),SRRF_RT_REG_DWORD, NULL,
        (LPBYTE) &dwUserLogonLogoff,
        &cbDataSize)) )
    {
        // if can open Logon Key this is up to date.
        return;
    }
    
    // need to enum connection names and update the toplevel information.
    while ( ERROR_SUCCESS == RegEnumKey(hkeyUser,dwIndex,
        lpName,cbName) )
    {
        LONG lRet;
        HKEY hKeyConnection;
        
        lRet = RegOpenKeyEx( hkeyUser,
            lpName,
            NULL,
            KEY_READ,
            &hKeyConnection );
        
        if (ERROR_SUCCESS == lRet)
        {
            
            cbDataSize = sizeof(dwUserLogonLogoff);
            
            if (ERROR_SUCCESS == SHRegGetValue(hKeyConnection,NULL,TEXT("Logon"),SRRF_RT_REG_DWORD, NULL,
                (LPBYTE) &dwUserLogonLogoff,
                &cbDataSize) )
            {
                dwLogon |= dwUserLogonLogoff;
            }
            
            cbDataSize = sizeof(dwUserLogonLogoff);
            
            if (ERROR_SUCCESS == SHRegGetValue(hKeyConnection,NULL,TEXT("Logoff"),SRRF_RT_REG_DWORD, NULL,
                (LPBYTE) &dwUserLogonLogoff,
                &cbDataSize) )
            {
                dwLogoff |= dwUserLogonLogoff;
            }
            
            RegCloseKey(hKeyConnection);
        }
        
        dwIndex++;
    }
    
    // write out new flags even if errors occured. work thing that happens is
    // we don't set up someones autosync automatically.
    RegSetValueEx(hkeyUser,TEXT("Logon"),NULL, REG_DWORD,
        (LPBYTE) &(dwLogon), sizeof(dwLogon));
    RegSetValueEx(hkeyUser,TEXT("Logoff"),NULL, REG_DWORD,
        (LPBYTE) &(dwLogoff), sizeof(dwLogoff));
    
    RegWriteTimeStamp(hkeyUser);
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: RegUpdateAutoSyncKeyValueSettings
  
    Summary:  walks through the UserList Updating the AutoSync
    
      Returns: 
      
------------------------------------------------------------------------F-F*/
void RegUpdateAutoSyncKeyValue(HKEY hkeyAutoSync,DWORD dwLogonDefault,DWORD dwLogoffDefault)
{
    DWORD dwIndex = 0;
    WCHAR lpName[MAX_PATH];
    DWORD cbName = MAX_PATH; 
    LONG lRet;
    DWORD dwLogon = 0;
    DWORD dwLogoff = 0;
    BOOL fSetLogon,fSetLogoff;
    
    // need to walk the autosync user key and set the top level information
    // based on whther someone logon/logoff
    
    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGISTRYMUTEXNAME);
    CMutexRegistry.Enter();
    
    while ( ERROR_SUCCESS == (lRet = RegEnumKey(hkeyAutoSync,dwIndex,
        lpName,cbName) ))
    {
        DWORD   dwUserLogonLogoff;
        DWORD   cbDataSize = sizeof(dwUserLogonLogoff);
        HKEY hKeyDomainUser;
        
        lRet = RegOpenKeyEx( hkeyAutoSync,
            lpName,
            NULL,
            KEY_READ, 
            &hKeyDomainUser );
        
        if (ERROR_SUCCESS == lRet)
        {
            
            // If Query fails don't want to count this as a failed to enum
            // error so don't set lRet
            if (ERROR_SUCCESS == (SHRegGetValue(hKeyDomainUser,NULL,TEXT("Logon"),SRRF_RT_REG_DWORD, NULL,
                (LPBYTE) &dwUserLogonLogoff,
                &cbDataSize) ))
            {
                dwLogon |= dwUserLogonLogoff;
            }
            
            cbDataSize = sizeof(dwUserLogonLogoff);
            
            if (ERROR_SUCCESS == lRet)
            {
                if (ERROR_SUCCESS == (SHRegGetValue(hKeyDomainUser,NULL,TEXT("Logoff"),SRRF_RT_REG_DWORD, NULL,
                    (LPBYTE) &dwUserLogonLogoff,
                    &cbDataSize) ) )
                {
                    dwLogoff |= dwUserLogonLogoff;
                }
            }
            
            RegCloseKey(hKeyDomainUser);
        }
        
        if (ERROR_SUCCESS != lRet)
        {
            break;
        }
        
        dwIndex++;
    }
    
    fSetLogon = FALSE;
    fSetLogoff = FALSE;
    
    // if an error occured, then use the passed in defaults,
    // if set to 1, else don't set.
    if ( (ERROR_SUCCESS != lRet) && (ERROR_NO_MORE_ITEMS != lRet))
    {
        if ( (-1 != dwLogonDefault) && (0 != dwLogonDefault))
        {
            fSetLogon = TRUE;
            dwLogon = dwLogonDefault;
        }
        
        if ( (-1 != dwLogoffDefault) && (0 != dwLogoffDefault))
        {
            fSetLogoff = TRUE;
            dwLogoff = dwLogoffDefault;
        }
        
    }
    else
    {
        fSetLogon = TRUE;
        fSetLogoff = TRUE;
    }
    
    // write out new flags even if errors occured. work thing that happens is
    // we don't set up someones autosync automatically.
    
    if (fSetLogon)
    {
        RegSetValueEx(hkeyAutoSync,TEXT("Logon"),NULL, REG_DWORD,
            (LPBYTE) &(dwLogon), sizeof(dwLogon));
    }
    
    if (fSetLogoff)
    {
        RegSetValueEx(hkeyAutoSync,TEXT("Logoff"),NULL, REG_DWORD,
            (LPBYTE) &(dwLogoff), sizeof(dwLogoff));
    }
    
    RegWriteTimeStamp(hkeyAutoSync);
    
    CMutexRegistry.Leave();
}



/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: RegUpdateUserIdleKey
  
    Summary:  given an Idle User Key makes sure it is in the latest
    format and if not updates it.
    
      Returns: 
      
------------------------------------------------------------------------F-F*/

void RegUpdateUserIdleKey(HKEY hkeyUser,BOOL fForce)
{
    DWORD dwUserIdleEnabled;
    DWORD cbDataSize = sizeof(dwUserIdleEnabled);
    DWORD dwIndex = 0;
    TCHAR lpName[MAX_PATH];
    DWORD cbName = MAX_PATH;
    
    DWORD dwIdleEnabled = 0;
    
    if (!fForce && (ERROR_SUCCESS == SHRegGetValue(hkeyUser,NULL,TEXT("IdleEnabled"),SRRF_RT_REG_DWORD, NULL,
        (LPBYTE) &dwUserIdleEnabled,
        &cbDataSize)) )
    {
        // if can open Logon Key this is up to date.
        return;
    }
    
    // need to enum connection names and update the toplevel information.
    while ( ERROR_SUCCESS == RegEnumKey(hkeyUser,dwIndex,
        lpName,cbName) )
    {
        LONG lRet;
        HKEY hKeyConnection;
        
        lRet = RegOpenKeyEx( hkeyUser,
            lpName,
            NULL,
            KEY_READ,
            &hKeyConnection );
        
        if (ERROR_SUCCESS == lRet)
        {
            
            cbDataSize = sizeof(dwUserIdleEnabled);
            
            if (ERROR_SUCCESS == SHRegGetValue(hKeyConnection,NULL,TEXT("IdleEnabled"),SRRF_RT_REG_DWORD, NULL,
                (LPBYTE) &dwUserIdleEnabled,
                &cbDataSize) )
            {
                dwIdleEnabled |= dwUserIdleEnabled;
            }
            
            RegCloseKey(hKeyConnection);
        }
        
        dwIndex++;
    }
    
    // write out new flags even if errors occured. work thing that happens is
    // we don't set up someones autosync automatically.
    RegSetValueEx(hkeyUser,TEXT("IdleEnabled"),NULL, REG_DWORD,
        (LPBYTE) &(dwIdleEnabled), sizeof(dwIdleEnabled));
    RegWriteTimeStamp(hkeyUser);
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: RegUpdateIdleKeyValue
  
    Summary:  walks through the UserList Updating the Idle RegKey
    
      Returns: 
      
------------------------------------------------------------------------F-F*/
void RegUpdateIdleKeyValue(HKEY hkeyIdle,DWORD dwDefault)
{
    DWORD dwIndex = 0;
    WCHAR lpName[MAX_PATH];
    DWORD dwIdleEnabled = 0;
    LONG  lRet = -1;
    BOOL fSetDefault;
    
    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGISTRYMUTEXNAME);
    CMutexRegistry.Enter();
    
    // need to walk the idle user key and set the top level information
    // based on whther someone logon/logoff
    
    fSetDefault = FALSE;
    
    
    while ( ERROR_SUCCESS == (lRet =  RegEnumKey(hkeyIdle,dwIndex,
        lpName,ARRAYSIZE(lpName))) )
    {
        DWORD   dwUserIdleEnabled;
        DWORD   cbDataSize = sizeof(dwUserIdleEnabled);
        HKEY hKeyDomainUser;
        
        lRet = RegOpenKeyEx( hkeyIdle,
            lpName,
            NULL,
            KEY_READ, 
            &hKeyDomainUser );
        
        if (ERROR_SUCCESS == lRet)
        {
            
            // if query fails don't consider this an error as far as
            // setDefault goes.
            if (ERROR_SUCCESS == (SHRegGetValue(hKeyDomainUser,NULL,TEXT("IdleEnabled"),SRRF_RT_REG_DWORD, NULL,
                (LPBYTE) &dwUserIdleEnabled,
                &cbDataSize) ))
            {
                dwIdleEnabled |= dwUserIdleEnabled;
            }
            
            RegCloseKey(hKeyDomainUser);
        }
        
        if (ERROR_SUCCESS != lRet)
        {
            break;
        }
        
        dwIndex++;
    }
    
    // if an error occured, then use the passed in defaults,
    // if set to 1, else don't set.
    if ( (ERROR_SUCCESS != lRet) && (ERROR_NO_MORE_ITEMS != lRet))
    {
        if ( (-1 != dwDefault) && (0 != dwDefault))
        {
            fSetDefault = TRUE;
            dwIdleEnabled = dwDefault;
        }
        
    }
    else
    {
        fSetDefault = TRUE;
    }
    
    
    // write out new flags even if errors occured. work thing that happens is
    // we don't set up someones autosync automatically.
    
    if (fSetDefault)
    {
        RegSetValueEx(hkeyIdle,TEXT("IdleEnabled"),NULL, REG_DWORD,
            (LPBYTE) &(dwIdleEnabled), sizeof(dwIdleEnabled));
    }
    
    RegWriteTimeStamp(hkeyIdle);
    CMutexRegistry.Leave();
}


/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: RegSetAutoSyncSettings(     LPCONNECTIONSETTINGS lpConnectionSettings,
  int iNumConnections)
  
    Summary:  Sets the logon, logoff and prompt me first user selections.
    
      Returns:  Returns TRUE if successful, FALSE otherwise
      
------------------------------------------------------------------------F-F*/
STDAPI_(BOOL)  RegSetAutoSyncSettings(LPCONNECTIONSETTINGS lpConnectionSettings,
                                      int iNumConnections,
                                      CRasUI *pRas,
                                      BOOL fCleanReg,
                                      BOOL fSetMachineState,
                                      BOOL fPerUser)
{
    SCODE sc = S_OK;
    HKEY hAutoSync;
    HKEY hKeyUser;
    HKEY hkeyConnection;
    DWORD dwUserConfigured = 1;
    DWORD dwLogonDefault = -1;
    DWORD dwLogoffDefault = -1;
    int i;
    
    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGISTRYMUTEXNAME);
    CMutexRegistry.Enter();
    
    // make sure keys are converted to newest format
    RegUpdateTopLevelKeys();
    
    Assert(-1 != TRUE); // we rely on TRUE boolean being something other than -1
    
    hAutoSync =  RegGetSyncTypeKey(SYNCTYPE_AUTOSYNC,KEY_WRITE| KEY_READ,TRUE);
    
    if (NULL == hAutoSync)
    {
        goto EH_Err;
    }
    
    hKeyUser =  RegOpenUserKey(hAutoSync,KEY_WRITE| KEY_READ,TRUE,fCleanReg);
    
    if (NULL == hKeyUser)
    {
        goto EH_Err2;
    }
    
    if (fPerUser)
    {
        
        smChkTo(EH_Err3,RegSetValueEx(hKeyUser,TEXT("UserConfigured"),NULL, REG_DWORD,
            (LPBYTE) &dwUserConfigured,
            sizeof(dwUserConfigured)));
    }
    else
    {
        DWORD cbDataSize = sizeof(dwUserConfigured);
        
        //If this value isn't added yet, 
        if (ERROR_SUCCESS == SHRegGetValue(hKeyUser,NULL,TEXT("UserConfigured"),SRRF_RT_REG_DWORD, NULL,
            (LPBYTE) &dwUserConfigured,
            &cbDataSize))
        {
            //if the user setup their configuration, we won't override on a
            //subsequent handler registration.
            if (dwUserConfigured)
            {
                RegCloseKey(hKeyUser);   
                RegCloseKey(hAutoSync);   
                CMutexRegistry.Leave();
                return TRUE; 
            }
        }
    }
    
    for (i=0; i<iNumConnections; i++)
    {
        
        smChkTo(EH_Err3,RegCreateUserSubKey (hKeyUser,
            lpConnectionSettings[i].pszConnectionName,
            KEY_WRITE |  KEY_READ,
            &hkeyConnection));
        
        
        if (-1 != lpConnectionSettings[i].dwLogon)
        {
            
            if (0 != lpConnectionSettings[i].dwLogon)
            {
                dwLogonDefault = lpConnectionSettings[i].dwLogon;
            }
            
            smChkTo(EH_Err4,RegSetValueEx(hkeyConnection,TEXT("Logon"),NULL, REG_DWORD,
                (LPBYTE) &(lpConnectionSettings[i].dwLogon),
                sizeof(lpConnectionSettings[i].dwLogon)));
        }
        
        if (-1 != lpConnectionSettings[i].dwLogoff)
        {
            
            if (0 != lpConnectionSettings[i].dwLogoff)
            {
                dwLogoffDefault = lpConnectionSettings[i].dwLogoff;
            }
            
            smChkTo(EH_Err4,RegSetValueEx(hkeyConnection,TEXT("Logoff"),NULL, REG_DWORD,
                (LPBYTE) &(lpConnectionSettings[i].dwLogoff),
                sizeof(lpConnectionSettings[i].dwLogoff)));
        }
        
        
        if (-1 != lpConnectionSettings[i].dwPromptMeFirst)
        {
            smChkTo(EH_Err4,RegSetValueEx(hkeyConnection,TEXT("PromptMeFirst"),NULL, REG_DWORD,
                (LPBYTE) &(lpConnectionSettings[i].dwPromptMeFirst),
                sizeof(lpConnectionSettings[i].dwPromptMeFirst)));
        }
        
        RegCloseKey(hkeyConnection);
        
    }
    
    // update the toplevel User information
    RegUpdateUserAutosyncKey(hKeyUser,TRUE /* fForce */);
    
    // update the top-level key
    RegUpdateAutoSyncKeyValue(hAutoSync,dwLogonDefault,dwLogoffDefault);
    
    RegCloseKey(hKeyUser);
    RegCloseKey(hAutoSync);
    
    // update our global sens state based on Autosync and Registration
    
    if (fSetMachineState)
    {
        RegRegisterForEvents(FALSE /* fUninstall */);
    }
    
    CMutexRegistry.Leave();
    return TRUE;
    
EH_Err4:
    RegCloseKey(hkeyConnection);
EH_Err3:
    RegCloseKey(hKeyUser);
EH_Err2:
    RegCloseKey(hAutoSync);
EH_Err:
    
    CMutexRegistry.Leave();
    return FALSE;
    
}

/****************************************************************************

  Scheduled Sync Registry Functions
  
***************************************************************************F-F*/
//--------------------------------------------------------------------------------
//
//  FUNCTION: RegGetSchedFriendlyName(LPCTSTR ptszScheduleGUIDName,
//                                    LPTSTR ptstrFriendlyName,
//                                    UINT cchFriendlyName)
//
//  PURPOSE: Get the friendly name of this Schedule.
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDAPI_(BOOL) RegGetSchedFriendlyName(LPCTSTR ptszScheduleGUIDName,
    LPTSTR ptstrFriendlyName,
    UINT cchFriendlyName)
{
    BOOL fResult = FALSE;    
    HKEY hKeyUser;
    
    hKeyUser = RegGetCurrentUserKey(SYNCTYPE_SCHEDULED,KEY_READ,FALSE);    
    if (NULL != hKeyUser)
    {
        HKEY hkeySchedName;
        if (NOERROR == RegOpenKeyEx (hKeyUser, ptszScheduleGUIDName, 0,KEY_READ, 
            &hkeySchedName))
        {
            
            DWORD cbFriendlyName =  cchFriendlyName * sizeof(TCHAR);
            
            if (ERROR_SUCCESS == SHRegGetValue(hkeySchedName,NULL,TEXT("FriendlyName"),SRRF_RT_REG_SZ | SRRF_NOEXPAND, NULL,
                (LPBYTE) ptstrFriendlyName, &cbFriendlyName))
            {
                fResult = TRUE;
            }
            
            RegCloseKey(hkeySchedName);
        }
    }
    
    
    RegCloseKey(hKeyUser);
    return fResult;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: RegSetSchedFriendlyName(LPCTSTR ptszScheduleGUIDName,
//                                                                        LPCTSTR ptstrFriendlyName)
//
//  PURPOSE: Set the friendly name of this Schedule.
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDAPI_(BOOL) RegSetSchedFriendlyName(LPCTSTR ptszScheduleGUIDName,
    LPCTSTR ptstrFriendlyName)
    
{
    SCODE   sc;
    HKEY  hkeySchedName;
    HKEY hKeyUser;
    
    
    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGISTRYMUTEXNAME);
    CMutexRegistry.Enter();
    
    hKeyUser = RegGetCurrentUserKey(SYNCTYPE_SCHEDULED,KEY_WRITE |  KEY_READ,TRUE);
    
    if (NULL == hKeyUser)
    {
        goto EH_Err;
    }
    
    smChkTo(EH_Err3,RegCreateUserSubKey (hKeyUser, ptszScheduleGUIDName,
        KEY_WRITE |  KEY_READ,
        &hkeySchedName));
    
    
    smChkTo(EH_Err4,RegSetValueEx (hkeySchedName,TEXT("FriendlyName"),NULL,
        REG_SZ,
        (LPBYTE) ptstrFriendlyName,
        (lstrlen(ptstrFriendlyName) + 1)*sizeof(TCHAR)));
    
    RegCloseKey(hkeySchedName);
    RegCloseKey(hKeyUser);
    CMutexRegistry.Leave();
    return TRUE;
    
EH_Err4:
    RegCloseKey(hkeySchedName);
EH_Err3:
    RegCloseKey(hKeyUser);
EH_Err:
    
    CMutexRegistry.Leave();
    return FALSE;
    
    
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    
      Function: RegGetSchedSyncSettings(    LPCONNECTIONSETTINGS lpConnectionSettings,
      TCHAR *pszSchedName)
      
        Summary:  Gets the MakeAutoConnection user selections.
        If no selections on this connection, the default is FALSE
        
          Returns:  Returns TRUE if successful, FALSE otherwise
          
------------------------------------------------------------------------F-F*/
STDAPI_(BOOL)  RegGetSchedSyncSettings(LPCONNECTIONSETTINGS lpConnectionSettings,
                                       TCHAR *pszSchedName)
{
    SCODE   sc;
    HKEY  hkeySchedName,
        hkeyConnection;
    DWORD   cbDataSize = sizeof(lpConnectionSettings->dwHidden);
    HKEY hKeyUser;
    
    // Set these first to default values, in case there are no current
    // user preferences in the registry
    lpConnectionSettings->dwConnType = SYNCSCHEDINFO_FLAGS_CONNECTION_LAN;
    lpConnectionSettings->dwMakeConnection = FALSE;
    lpConnectionSettings->dwHidden = FALSE;
    lpConnectionSettings->dwReadOnly = FALSE;
    
    hKeyUser = RegGetCurrentUserKey(SYNCTYPE_SCHEDULED,KEY_READ,FALSE);
    if (NULL == hKeyUser)
    {
        goto EH_Err2;
    }
    
    
    smChkTo(EH_Err3,RegOpenKeyEx (hKeyUser,
        pszSchedName,0,KEY_READ,
        &hkeySchedName));
    
    smChkTo(EH_Err4,SHRegGetValue(hkeySchedName,NULL,TEXT("ScheduleHidden"),SRRF_RT_REG_DWORD, NULL,
        (LPBYTE) &(lpConnectionSettings->dwHidden),
        &cbDataSize));
    
    cbDataSize = sizeof(lpConnectionSettings->dwReadOnly);
    
    smChkTo(EH_Err4,SHRegGetValue(hkeySchedName,NULL,TEXT("ScheduleReadOnly"),SRRF_RT_REG_DWORD, NULL,
        (LPBYTE) &(lpConnectionSettings->dwReadOnly),
        &cbDataSize));
    
    smChkTo(EH_Err4,RegOpenKeyEx (hkeySchedName,
        lpConnectionSettings->pszConnectionName,
        0,KEY_READ,
        &hkeyConnection));
    
    cbDataSize = sizeof(lpConnectionSettings->dwMakeConnection);
    
    smChkTo(EH_Err5,SHRegGetValue(hkeyConnection,NULL,TEXT("MakeAutoConnection"),SRRF_RT_REG_DWORD, NULL,
        (LPBYTE) &(lpConnectionSettings->dwMakeConnection),
        &cbDataSize));
    
    cbDataSize = sizeof(lpConnectionSettings->dwConnType);
    
    smChkTo(EH_Err5,SHRegGetValue(hkeyConnection,NULL,TEXT("Connection Type"),SRRF_RT_REG_DWORD, NULL,
        (LPBYTE) &(lpConnectionSettings->dwConnType),
        &cbDataSize));
    
    RegCloseKey(hkeyConnection);
    RegCloseKey(hkeySchedName);
    RegCloseKey(hKeyUser);
    return TRUE;
    
EH_Err5:
    RegCloseKey(hkeyConnection);
EH_Err4:
    RegCloseKey(hkeySchedName);
EH_Err3:
    RegCloseKey(hKeyUser);
EH_Err2:
    return FALSE;
    
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: RegSetSchedSyncSettings(    LPCONNECTIONSETTINGS lpConnectionSettings,
  TCHAR *pszSchedName)
  
    Summary:  Sets the hidden and readonly schedule flags.
    
      Returns:  Returns TRUE if successful, FALSE otherwise
      
------------------------------------------------------------------------F-F*/
STDAPI_(BOOL)  RegSetSchedSyncSettings(LPCONNECTIONSETTINGS lpConnectionSettings,
    TCHAR *pszSchedName)
{
    BOOL    fRetVal = FALSE;
    HKEY    hKeyUser,
        hkeySchedName,
        hkeyConnection;
    
    
    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGISTRYMUTEXNAME);
    CMutexRegistry.Enter();
    
    hKeyUser = RegGetCurrentUserKey(SYNCTYPE_SCHEDULED,KEY_READ | KEY_WRITE,TRUE);
    
    if (hKeyUser)
    {      
        if (ERROR_SUCCESS == RegCreateUserSubKey (hKeyUser, 
            pszSchedName,
            KEY_WRITE |  KEY_READ, 
            &hkeySchedName))
        {
            if (ERROR_SUCCESS == RegSetValueEx(hkeySchedName,TEXT("ScheduleHidden"),NULL, REG_DWORD,
                (LPBYTE) &(lpConnectionSettings->dwHidden),
                sizeof(lpConnectionSettings->dwHidden)))
            {
                if (ERROR_SUCCESS == RegSetValueEx(hkeySchedName,TEXT("ScheduleReadOnly"),NULL, REG_DWORD,
                    (LPBYTE) &(lpConnectionSettings->dwReadOnly),
                    sizeof(lpConnectionSettings->dwReadOnly)))
                {
                    if (ERROR_SUCCESS == RegCreateUserSubKey (hkeySchedName, lpConnectionSettings->pszConnectionName,
                        KEY_WRITE |  KEY_READ, &hkeyConnection))
                    {
                        if (ERROR_SUCCESS == RegSetValueEx(hkeyConnection,TEXT("MakeAutoConnection"),NULL, REG_DWORD,
                            (LPBYTE) &(lpConnectionSettings->dwMakeConnection),
                            sizeof(lpConnectionSettings->dwMakeConnection)))
                        {
                            if (ERROR_SUCCESS == RegSetValueEx(hkeyConnection,TEXT("Connection Type"),NULL, REG_DWORD,
                                (LPBYTE) &(lpConnectionSettings->dwConnType),
                                sizeof(lpConnectionSettings->dwConnType)))
                            {
                                fRetVal = TRUE;
                            }
                        }
                        
                        RegCloseKey(hkeyConnection);
                    }
                }
            }
            RegCloseKey(hkeySchedName);
        }
        
        RegCloseKey(hKeyUser);
    }
    CMutexRegistry.Leave();
    
    return fRetVal;
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Function: RegGetSchedConnectionName(TCHAR *pszSchedName,
TCHAR *pszConnectionName,
DWORD cbConnectionName)

  
    Summary:  returns the Connection Name for the Scheduled Item.
    
      Returns:  Returns TRUE if successful, FALSE otherwise
      
------------------------------------------------------------------------F-F*/

STDAPI_(BOOL)  RegGetSchedConnectionName(TCHAR *pszSchedName,TCHAR *pszConnectionName,
    DWORD cbConnectionName)
{
    SCODE   sc;
    BOOL    fResult = FALSE;
    HKEY    hKeyUser,hkeySchedName;
    DWORD   dwIndex = 0;
    DWORD   cb = cbConnectionName;
    
    //First Set the connectionName to a default.
    // for now we always assume a LAN card is present.
    // if add support for connection manager should 
    // update this.
    
    LoadString(g_hmodThisDll, IDS_LAN_CONNECTION, pszConnectionName, cbConnectionName);
    
    hKeyUser = RegGetCurrentUserKey(SYNCTYPE_SCHEDULED,KEY_READ,FALSE);
    
    if (NULL == hKeyUser)
    {
        goto EH_Err;
    }
    
    smChkTo(EH_Err3, RegOpenKeyEx (hKeyUser,pszSchedName, 
        0,KEY_READ, &hkeySchedName));
    
    // next enumeration of keys is the names of the Schedules connection
    // currently just have one so only get the first.
    if ( ERROR_SUCCESS == RegEnumKeyEx(hkeySchedName,dwIndex,
        pszConnectionName,&cb,NULL,NULL,NULL,NULL))
    {
        fResult = TRUE;
    }
    
    RegCloseKey(hkeySchedName);
    RegCloseKey(hKeyUser);
    
    return fResult;
    
    
EH_Err3:
    RegCloseKey(hKeyUser);
EH_Err:
    return FALSE;
    
    
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: BOOL RegSetSIDForSchedule( TCHAR *pszSchedName)
  
    Summary:  sets the SID for this schedule
    
      Returns:  Returns TRUE if successful, FALSE otherwise
      
------------------------------------------------------------------------F-F*/
STDAPI_(BOOL) RegSetSIDForSchedule(TCHAR *pszSchedName)
    
{
SCODE   sc;
HKEY    hkeySchedName;
TCHAR   szSID[MAX_PATH];
DWORD   dwType = REG_SZ;


    if (!GetUserTextualSid(szSID, ARRAYSIZE(szSID)))
    {
        return FALSE;
    }
    
    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGISTRYMUTEXNAME);
    CMutexRegistry.Enter();
    
    HKEY hKeyUser = RegGetCurrentUserKey(SYNCTYPE_SCHEDULED,KEY_READ | KEY_WRITE,TRUE);
    
    if (NULL == hKeyUser)
    {
        goto EH_Err2;
    }
    
    smChkTo(EH_Err3,RegCreateUserSubKey (hKeyUser, pszSchedName,
        KEY_WRITE |  KEY_READ,
        &hkeySchedName));
    
    
    smChkTo(EH_Err4,RegSetValueEx  (hkeySchedName,TEXT("SID"),NULL,
                                    dwType,
                                    (LPBYTE) szSID,
                                    (lstrlen(szSID) + 1)*sizeof(TCHAR)));
    
    RegCloseKey(hkeySchedName);
    RegCloseKey(hKeyUser);
    CMutexRegistry.Leave();
    return TRUE;
    
EH_Err4:
    RegCloseKey(hkeySchedName);
EH_Err3:
    RegCloseKey(hKeyUser);
EH_Err2:
    CMutexRegistry.Leave();
    return FALSE;
    
    
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: BOOL RegGetSIDForSchedule(  TCHAR *ptszTextualSidSched, 
  DWORD *pcbSizeSid, TCHAR *pszSchedName)
  
    Summary:  returns the SID for this schedule
    
      Returns:  Returns TRUE if successful, FALSE otherwise
      
------------------------------------------------------------------------F-F*/
STDAPI_(BOOL) RegGetSIDForSchedule(TCHAR *ptszTextualSidSched, DWORD cchTextualSidSched, TCHAR *pszSchedName)
{
    SCODE   sc;
    HKEY    hkeySchedName;
    DWORD   cbValue;
    
    ptszTextualSidSched[0] = TEXT('\0');
    HKEY hKeyUser = RegGetCurrentUserKey(SYNCTYPE_SCHEDULED,KEY_READ,FALSE);
    
    if (NULL == hKeyUser)
    {
        goto EH_Err2;
    }
    
    smChkTo(EH_Err3, RegOpenKeyEx (hKeyUser,pszSchedName,
                                   0,KEY_READ, &hkeySchedName));


    cbValue = cchTextualSidSched * sizeof(*ptszTextualSidSched);
    if (ERROR_SUCCESS != (sc = SHRegGetValue(hkeySchedName,NULL,TEXT("SID"),SRRF_RT_REG_SZ | SRRF_NOEXPAND, NULL,
        (LPBYTE) ptszTextualSidSched, &cbValue)))
    {
        //handle migration from schedules without SIDs 
        // like from Beta to current builds
        RegSetSIDForSchedule(pszSchedName);

        cbValue = cchTextualSidSched * sizeof(*ptszTextualSidSched);
        SHRegGetValue(hkeySchedName,NULL,TEXT("SID"),SRRF_RT_REG_SZ | SRRF_NOEXPAND, NULL,
            (LPBYTE) ptszTextualSidSched, &cbValue);
    }
    RegCloseKey(hkeySchedName);
    RegCloseKey(hKeyUser);
    return TRUE;
    
    
EH_Err3:
    RegCloseKey(hKeyUser);
EH_Err2:
    return FALSE;
    
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  BOOL      RemoveScheduledJobFile(TCHAR *pszTaskName)
  
    Summary:  Remove the TaskScheduler .job file 
    
      Note:     Try to use ITask->Delete first
      Call only when TaskScheduler isn't present or if ITask->Delete failed
      
        Returns:  Returns TRUE always
        
------------------------------------------------------------------------F-F*/

STDAPI_(BOOL) RemoveScheduledJobFile(TCHAR *pszTaskName)
{
    SCODE   sc;
    TCHAR   pszFullFileName[MAX_PATH+1];
    TCHAR   pszTaskFolderPath[MAX_PATH+1];
    HKEY    hkeyTaskSchedulerPath;
    DWORD   cbDataSize = sizeof(pszTaskFolderPath); 
    
    
    if (ERROR_SUCCESS == (sc = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
        TEXT("SOFTWARE\\Microsoft\\SchedulingAgent"),
        NULL,KEY_READ,&hkeyTaskSchedulerPath)))
    {
        sc = SHRegGetValue(hkeyTaskSchedulerPath,NULL,TEXT("TasksFolder"),
            SRRF_RT_REG_SZ | SRRF_NOEXPAND, NULL,
            (LPBYTE) pszTaskFolderPath, &cbDataSize);
        RegCloseKey(hkeyTaskSchedulerPath);
    }
    
    //If this get doesn't exist then bail.
    if (ERROR_SUCCESS != sc)
    {
        return FALSE;
    }
    ExpandEnvironmentStrings(pszTaskFolderPath,pszFullFileName,MAX_PATH);
    if (!PathAppend(pszFullFileName, pszTaskName))
    {
        return FALSE;
    }
    
    //if we fail this, ignore the error.  We tried, there isn't much else we can do.
    //So we have a turd file.
    DeleteFile(pszFullFileName);
    return TRUE;
}


/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  BOOL RegRemoveScheduledTask(TCHAR *pszTaskName)
  
    Summary:  Remove the Scheduled task info from the registry.
    
      Returns:  Returns TRUE if successful, FALSE otherwise
      
------------------------------------------------------------------------F-F*/

STDAPI_(BOOL) RegRemoveScheduledTask(TCHAR *pszTaskName)
{
    HKEY hKeyUser;
    
    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGISTRYMUTEXNAME);
    CMutexRegistry.Enter();
    
    hKeyUser = RegGetCurrentUserKey(SYNCTYPE_SCHEDULED,KEY_READ | KEY_WRITE,FALSE);
    
    if (hKeyUser)
    {
        RegDeleteKeyNT(hKeyUser, pszTaskName);
        RegCloseKey(hKeyUser);
    }
    
    
    CMutexRegistry.Leave();
    return TRUE;
}


/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  BOOL RegUninstallSchedules()
  
    Summary:  Uninstall the scheduled tasks.
    
      Returns:  Returns TRUE if successful, FALSE otherwise
      
------------------------------------------------------------------------F-F*/
STDAPI_(BOOL) RegUninstallSchedules()
{
    SCODE sc;
    ITaskScheduler   *pITaskScheduler = NULL;
    HKEY    hkeySchedSync;
    
    // Obtain a task scheduler class instance.
    sc = CoCreateInstance(
        CLSID_CTaskScheduler,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_ITaskScheduler,
        (VOID **)&pITaskScheduler);
    
    if (NOERROR != sc)
    {
        pITaskScheduler = NULL;
    }
    
    //now go through and delete the schedules
    
    hkeySchedSync =  RegGetSyncTypeKey(SYNCTYPE_SCHEDULED,KEY_READ,FALSE);
    
    if (hkeySchedSync)
    {
        int iUserCount = 0;
        
        while (sc == ERROR_SUCCESS )
        {
            HKEY hkeyDomainUser;
            TCHAR   szDomainUser[MAX_KEY_LENGTH];
            SCODE sc2;
            DWORD  cchDomainUser = ARRAYSIZE(szDomainUser);
            
            sc = RegEnumKeyEx(hkeySchedSync,iUserCount,szDomainUser,&cchDomainUser,NULL,NULL,NULL,NULL);
            iUserCount++;
            
            if(sc == ERROR_NO_MORE_ITEMS)
            {
                break;
            }
            
            sc2 = RegOpenKeyEx (hkeySchedSync,szDomainUser,0,KEY_READ, &hkeyDomainUser);
            
            if (ERROR_SUCCESS == sc2)
            {
                int iScheduleCount = 0;
                
                while (sc2 == ERROR_SUCCESS )
                {
                    TCHAR   ptszScheduleGUIDName[MAX_KEY_LENGTH];
                    //Add 4 to ensure that we can hold the .job extension if necessary
                    WCHAR pwszScheduleGUIDName[MAX_SCHEDULENAMESIZE + 4];                              
                    DWORD cchScheduleGUIDName = ARRAYSIZE(ptszScheduleGUIDName);
                    
                    sc2 = RegEnumKeyEx(hkeyDomainUser,iScheduleCount,ptszScheduleGUIDName,&cchScheduleGUIDName,NULL,NULL,NULL,NULL);
                    
                    iScheduleCount++;
                    
                    if(sc2 == ERROR_NO_MORE_ITEMS)
                    {
                        continue;
                    }
                    else
                    {
                        Assert(ARRAYSIZE(pwszScheduleGUIDName) >= ARRAYSIZE(ptszScheduleGUIDName));
                        StringCchCopy(pwszScheduleGUIDName, ARRAYSIZE(pwszScheduleGUIDName), ptszScheduleGUIDName);
                        
                        if ((!pITaskScheduler) || 
                            FAILED(pITaskScheduler->Delete(pwszScheduleGUIDName)))
                        {
                            if (SUCCEEDED(StringCchCat(pwszScheduleGUIDName, ARRAYSIZE(pwszScheduleGUIDName), L".job")))
                            {                            
                                RemoveScheduledJobFile(pwszScheduleGUIDName);
                            }
                        }
                        
                    }
                }
                
                RegCloseKey(hkeyDomainUser);
            }
            
        }
        
        RegCloseKey(hkeySchedSync);
    }
    
    if (pITaskScheduler)
    {
        pITaskScheduler->Release();
    }
    
    RegDeleteKeyNT(HKEY_LOCAL_MACHINE, SCHEDSYNC_REGKEY);
    
    return TRUE;
}
    
/****************************************************************************
    
    Idle Registry Functions
      
***************************************************************************F-F*/
        
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: RegGetIdleSyncSettings(     LPCONNECTIONSETTINGS lpConnectionSettings)
  
    Summary:  Gets the Idle Specific settings.
    
      Returns:  Returns TRUE if successful, FALSE otherwise
      
------------------------------------------------------------------------F-F*/

STDAPI_(BOOL)  RegGetIdleSyncSettings(LPCONNECTIONSETTINGS lpConnectionSettings)
{
    SCODE sc;
    HKEY hkeyConnection;
    DWORD cbDataSize;
    
    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGISTRYMUTEXNAME);
    CMutexRegistry.Enter();
    
    // set up defaults
    
    lpConnectionSettings->dwIdleEnabled = 0;
    
    // following are really per user not per connection
    lpConnectionSettings->ulIdleWaitMinutes = UL_DEFAULTIDLEWAITMINUTES;
    lpConnectionSettings->ulIdleRetryMinutes = UL_DEFAULTIDLERETRYMINUTES;
    lpConnectionSettings->ulDelayIdleShutDownTime = UL_DELAYIDLESHUTDOWNTIME;
    lpConnectionSettings->dwRepeatSynchronization = UL_DEFAULTREPEATSYNCHRONIZATION;
    lpConnectionSettings->dwRunOnBatteries = UL_DEFAULTFRUNONBATTERIES;
    
    HKEY hKeyUser = RegGetCurrentUserKey(SYNCTYPE_IDLE,KEY_READ,FALSE);
    
    if (NULL == hKeyUser)
    {
        goto EH_Err2;
    }
    
    
    cbDataSize = sizeof(lpConnectionSettings->ulIdleWaitMinutes);
    
    // if got the Idle key open then fill in global settings
    
    SHRegGetValue(hKeyUser,NULL,SZ_IDLEWAITAFTERIDLEMINUTESKEY,SRRF_RT_REG_DWORD, NULL,
        (LPBYTE) &(lpConnectionSettings->ulIdleWaitMinutes),
        &cbDataSize);
    
    cbDataSize = sizeof(lpConnectionSettings->dwRepeatSynchronization);
    SHRegGetValue(hKeyUser,NULL,SZ_IDLEREPEATESYNCHRONIZATIONKEY,SRRF_RT_REG_DWORD, NULL,
        (LPBYTE) &(lpConnectionSettings->dwRepeatSynchronization),
        &cbDataSize);
    
    cbDataSize = sizeof(lpConnectionSettings->ulIdleRetryMinutes);
    SHRegGetValue(hKeyUser,NULL,SZ_IDLERETRYMINUTESKEY,SRRF_RT_REG_DWORD, NULL,
        (LPBYTE) &(lpConnectionSettings->ulIdleRetryMinutes),
        &cbDataSize);
    
    cbDataSize = sizeof(lpConnectionSettings->ulDelayIdleShutDownTime);
    SHRegGetValue(hKeyUser,NULL,SZ_IDLEDELAYSHUTDOWNTIMEKEY,SRRF_RT_REG_DWORD, NULL,
        (LPBYTE) &(lpConnectionSettings->ulDelayIdleShutDownTime),
        &cbDataSize);
    
    cbDataSize = sizeof(lpConnectionSettings->dwRunOnBatteries);
    SHRegGetValue(hKeyUser,NULL,SZ_IDLERUNONBATTERIESKEY,SRRF_RT_REG_DWORD, NULL,
        (LPBYTE) &(lpConnectionSettings->dwRunOnBatteries),
        &cbDataSize);
    
    smChkTo(EH_Err3,RegOpenKeyEx(hKeyUser, lpConnectionSettings->pszConnectionName,0,KEY_READ,
        &hkeyConnection));
    
    cbDataSize = sizeof(lpConnectionSettings->dwIdleEnabled);
    SHRegGetValue(hkeyConnection,NULL,TEXT("IdleEnabled"),SRRF_RT_REG_DWORD, NULL,
        (LPBYTE) &(lpConnectionSettings->dwIdleEnabled),
        &cbDataSize);
    
    RegCloseKey(hkeyConnection);
    RegCloseKey(hKeyUser);
    
    CMutexRegistry.Leave();
    return TRUE;
    
EH_Err3:
    RegCloseKey(hKeyUser);
EH_Err2:
    CMutexRegistry.Leave();
    return FALSE;
    
}
                
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: RegSetIdleSyncSettings(LPCONNECTIONSETTINGS lpConnectionSettings,
  int iNumConnections,
  CRasUI *pRas,
  BOOL fCleanReg,
  BOOL fPerUser)
  
    Summary:  Sets the Idle Information user selections.
    
      Returns:  Returns TRUE if successful, FALSE otherwise
      
------------------------------------------------------------------------F-F*/
STDAPI_(BOOL)  RegSetIdleSyncSettings(LPCONNECTIONSETTINGS lpConnectionSettings,
                                      int iNumConnections,
                                      CRasUI *pRas,
                                      BOOL fCleanReg,
                                      BOOL fPerUser)
{
    HKEY hkeyIdleSync = NULL;
    HKEY hKeyUser;;
    HKEY hkeyConnection;
    HRESULT hr;
    ULONG ulWaitMinutes = UL_DEFAULTWAITMINUTES;
    DWORD dwIdleEnabled;
    BOOL fRunOnBatteries = UL_DEFAULTFRUNONBATTERIES;
    int i;
    DWORD cbDataSize;
    DWORD dwUserConfigured;
    DWORD dwTopLevelDefaultValue = -1;
    
    RegUpdateTopLevelKeys(); // make sure top-level keys are latest version
    
    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGISTRYMUTEXNAME);
    CMutexRegistry.Enter();
    
    Assert(-1 != TRUE); // we rely on TRUE boolean being something other than -1
    
    hkeyIdleSync =  RegGetSyncTypeKey(SYNCTYPE_IDLE,KEY_WRITE| KEY_READ,TRUE);
    
    if (NULL == hkeyIdleSync)
    {
        goto EH_Err;
    }
    
    hKeyUser =  RegOpenUserKey(hkeyIdleSync,KEY_WRITE| KEY_READ,TRUE,fCleanReg);
    
    if (NULL == hKeyUser)
    {
        goto EH_Err2;
    }
    
    
    if (fPerUser)
    {
        
        dwUserConfigured = 1;
        
        if (ERROR_SUCCESS != RegSetValueEx(hKeyUser,TEXT("UserConfigured"),NULL, REG_DWORD,
            (LPBYTE) &dwUserConfigured,
            sizeof(dwUserConfigured)))
        {
            goto EH_Err3;
        }
        
    }
    else
    {
        cbDataSize = sizeof(dwUserConfigured);
        
        //If this value isn't added yet, 
        if (ERROR_SUCCESS == SHRegGetValue(hKeyUser,NULL,TEXT("UserConfigured"),SRRF_RT_REG_DWORD, NULL,
            (LPBYTE) &dwUserConfigured,
            &cbDataSize))
        {
            //if the user setup their configuration, we won't override on a
            //subsequent handler registration.
            if (dwUserConfigured)
            {
                RegCloseKey(hkeyIdleSync);
                RegCloseKey(hKeyUser);
                CMutexRegistry.Leave();
                return TRUE;
            }
        }
    }
    
    for (i=0; i<iNumConnections; i++)
    {
        
        if (ERROR_SUCCESS != RegCreateUserSubKey (hKeyUser,
            lpConnectionSettings[i].pszConnectionName,
            KEY_WRITE |  KEY_READ,
            &hkeyConnection))
        {
            goto EH_Err3;        
        }
        
        
        hr = RegSetValueEx(hkeyConnection,TEXT("IdleEnabled"),NULL, REG_DWORD,
            (LPBYTE) &(lpConnectionSettings[i].dwIdleEnabled),
            sizeof(lpConnectionSettings[i].dwIdleEnabled));
        
        if (lpConnectionSettings[i].dwIdleEnabled)
        {
            dwTopLevelDefaultValue = lpConnectionSettings[i].dwIdleEnabled;
        }
        
        RegCloseKey(hkeyConnection);
        
    }
    // write out the global idle information for Retry minutes and DelayIdleShutDown.
    // then call function to reg/unregister with TS.
    
    
    Assert(hkeyIdleSync); // should have already returned if this failed.
    
    if (iNumConnections) // make sure at least one connection
    {
        
        // ONLY UPDATE SETTINGS IF NOT -1;
        
        if (-1 != lpConnectionSettings[0].ulIdleRetryMinutes)
        {
            hr = RegSetValueEx(hKeyUser,SZ_IDLERETRYMINUTESKEY,NULL, REG_DWORD,
                (LPBYTE) &(lpConnectionSettings[0].ulIdleRetryMinutes),
                sizeof(lpConnectionSettings[0].ulIdleRetryMinutes));
        }
        
        if (-1 != lpConnectionSettings[0].ulDelayIdleShutDownTime)
        {
            hr = RegSetValueEx(hKeyUser,SZ_IDLEDELAYSHUTDOWNTIMEKEY,NULL, REG_DWORD,
                (LPBYTE) &(lpConnectionSettings[0].ulDelayIdleShutDownTime),
                sizeof(lpConnectionSettings[0].ulDelayIdleShutDownTime));
        }
        
        if (-1 != lpConnectionSettings[0].dwRepeatSynchronization)
        {
            hr = RegSetValueEx(hKeyUser,SZ_IDLEREPEATESYNCHRONIZATIONKEY,NULL, REG_DWORD,
                (LPBYTE) &(lpConnectionSettings[0].dwRepeatSynchronization),
                sizeof(lpConnectionSettings[0].dwRepeatSynchronization));
        }
        
        
        
        if (-1 != lpConnectionSettings[0].ulIdleWaitMinutes)
        {
            hr = RegSetValueEx(hKeyUser,SZ_IDLEWAITAFTERIDLEMINUTESKEY,NULL, REG_DWORD,
                (LPBYTE) &(lpConnectionSettings[0].ulIdleWaitMinutes),
                sizeof(lpConnectionSettings[0].ulIdleWaitMinutes));
        }
        
        
        if (-1 != lpConnectionSettings[0].dwRunOnBatteries)
        {
            hr = RegSetValueEx(hKeyUser,SZ_IDLERUNONBATTERIESKEY,NULL, REG_DWORD,
                (LPBYTE) &(lpConnectionSettings[0].dwRunOnBatteries),
                sizeof(lpConnectionSettings[0].dwRunOnBatteries));
        }
        
        ulWaitMinutes = lpConnectionSettings[0].ulIdleWaitMinutes;
        fRunOnBatteries = lpConnectionSettings[0].dwRunOnBatteries;
        
        // if -1 is passed in for ulWait or fRun on Batteries we need to 
        // get these and set them up so they can be passed onto Task Schedule
        if (-1 == ulWaitMinutes)
        {
            cbDataSize = sizeof(ulWaitMinutes);
            
            if (!(ERROR_SUCCESS == SHRegGetValue(hKeyUser,NULL,SZ_IDLEWAITAFTERIDLEMINUTESKEY,SRRF_RT_REG_DWORD, NULL,
                (LPBYTE) &ulWaitMinutes,
                &cbDataSize)) )
            {
                ulWaitMinutes = UL_DEFAULTIDLEWAITMINUTES;
            }
        }
        
        if (-1 == fRunOnBatteries)
        {
            cbDataSize = sizeof(fRunOnBatteries);
            
            if (!(ERROR_SUCCESS == SHRegGetValue(hKeyUser,NULL,SZ_IDLERUNONBATTERIESKEY,SRRF_RT_REG_DWORD, NULL,
                (LPBYTE) &fRunOnBatteries,
                &cbDataSize)) )
            {
                fRunOnBatteries = UL_DEFAULTFRUNONBATTERIES;
            }
        }
        
    }
    
    RegUpdateUserIdleKey(hKeyUser,TRUE /* fForce */); // set userlevel IdleFlags
    
    // read in dwIdleEnabled key now that the UserKey is Updated.
    cbDataSize = sizeof(dwIdleEnabled);
    
    if (!(ERROR_SUCCESS == SHRegGetValue(hKeyUser,NULL,TEXT("IdleEnabled"),SRRF_RT_REG_DWORD, NULL,
        (LPBYTE) &dwIdleEnabled,
        &cbDataSize)) )
    {
        AssertSz(0,"Unable to query User IdleEnabledKey");
        dwIdleEnabled = FALSE;
    }
    
    RegCloseKey(hKeyUser);
    
    // update the toplevel IdleSyncInfo
    RegUpdateIdleKeyValue(hkeyIdleSync,dwTopLevelDefaultValue);
    
    RegCloseKey(hkeyIdleSync);
    
    CMutexRegistry.Leave();
    
    RegRegisterForIdleTrigger(dwIdleEnabled,ulWaitMinutes,fRunOnBatteries);
    
    return TRUE;
    
EH_Err3:
    RegCloseKey(hKeyUser);
EH_Err2:
    RegCloseKey(hkeyIdleSync);
EH_Err:
    CMutexRegistry.Leave();
    
    return FALSE;
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: RegRegisterForIdleTrigger()
  
    Summary:  Sets or removes the Idle trigger.
    
      Returns:  Returns TRUE if successful, FALSE otherwise
      
------------------------------------------------------------------------F-F*/
        
STDAPI_(BOOL)  RegRegisterForIdleTrigger(BOOL fRegister,ULONG ulWaitMinutes,BOOL fRunOnBatteries)
{
    HRESULT hr;
    CSyncMgrSynchronize *pSyncMgrSynchronize;
    LPSYNCSCHEDULEMGR pScheduleMgr;
    
    // Review - Currently the mobsync dll is registered as apartment
    //    and this function can be called from Logon/Logoff which is FreeThreaded
    //    Correct fix is to change DLL to be registered as BOTH but until then
    //    just create the class directly.
    
    pSyncMgrSynchronize = new CSyncMgrSynchronize;
    hr = E_OUTOFMEMORY;
    
    if (pSyncMgrSynchronize)
    {
        hr = pSyncMgrSynchronize->QueryInterface(IID_ISyncScheduleMgr,(void **) &pScheduleMgr);
        pSyncMgrSynchronize->Release();
    }
    
    
    if (NOERROR != hr)
    {
        return FALSE;
    }
    
    if (fRegister)
    {
        ISyncSchedule *pSyncSchedule = NULL;
        SYNCSCHEDULECOOKIE SyncScheduleCookie;
        BOOL fNewlyCreated = FALSE;
       
        SyncScheduleCookie =  GUID_IDLESCHEDULE;
        
        // if there isn't an existing schedule create one, else update
        // the existing.
        
        if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == (hr = pScheduleMgr->OpenSchedule(&SyncScheduleCookie,0,&pSyncSchedule)))
        {
            SyncScheduleCookie =  GUID_IDLESCHEDULE;
            // see if it is an exiting schedule.
            
            hr = pScheduleMgr->CreateSchedule(L"Idle",0,&SyncScheduleCookie,&pSyncSchedule);
            fNewlyCreated = TRUE;
        }
        
        // If created or found a schedule update the trigger settings.
        if (NOERROR == hr)
        {
            ITaskTrigger *pTrigger;
            
            pSyncSchedule->SetFlags(SYNCSCHEDINFO_FLAGS_READONLY | SYNCSCHEDINFO_FLAGS_HIDDEN);
            
            if (NOERROR == pSyncSchedule->GetTrigger(&pTrigger))
            {
                TASK_TRIGGER trigger;
                ITask *pTask;
                
                trigger.cbTriggerSize = sizeof(trigger);
                
                if (SUCCEEDED(pTrigger->GetTrigger(&trigger)))
                {
                    DWORD dwFlags;
                    
                    // need to set Idle, ULONG ulWaitMinutes,BOOL fRunOnBatteries
                    trigger.cbTriggerSize = sizeof(trigger);
                    trigger.TriggerType  = TASK_EVENT_TRIGGER_ON_IDLE;
                    trigger.rgFlags = 0;
                    pTrigger->SetTrigger(&trigger);
                    
                    if (SUCCEEDED(pSyncSchedule->GetITask(&pTask)))
                    {
                        // set up if run on battery.
                        if (SUCCEEDED(pTask->GetFlags(&dwFlags)))
                        {
                            dwFlags &= ~TASK_FLAG_DONT_START_IF_ON_BATTERIES;
                            dwFlags |=  !fRunOnBatteries ? TASK_FLAG_DONT_START_IF_ON_BATTERIES : 0;
                            
                            dwFlags |= TASK_FLAG_RUN_ONLY_IF_LOGGED_ON; // don't require password.
                            
                            pTask->SetFlags(dwFlags);
                        }
                        
                        // if this schedule was just created, get the current user name and reset
                        // account information password to NULL, If existing schedule don't change
                        // since user may have added a password for schedule to run while not logged on.
                        if (fNewlyCreated)
                        {
                            TCHAR szAccountName[MAX_DOMANDANDMACHINENAMESIZE];
                            WCHAR *pszAccountName = NULL;
                            
                            // Review, this never returns an errorl
                            *szAccountName = WCHAR('\0');
                            GetDefaultDomainAndUserName(szAccountName,TEXT("\\"),ARRAYSIZE(szAccountName));
                            
                            pszAccountName = szAccountName;
                            
                            Assert(pszAccountName);
                            
                            if (pszAccountName)
                            {
                                pTask->SetAccountInformation(pszAccountName,NULL);
                            }
                            
                        }
                        
                        
                        // set up the IdleWaitTime.
                        pTask->SetIdleWait((WORD) ulWaitMinutes,1);
                        
                        // turn off the option to kill task after xxx minutes.
                        pTask->SetMaxRunTime(INFINITE);
                        
                        pTask->Release();
                    }
                    
                    pTrigger->Release();
                    
                }
                
                pSyncSchedule->Save();
            }
            
            
            
            pSyncSchedule->Release();
        }
        
    }
    else
    {
        SYNCSCHEDULECOOKIE SyncScheduleCookie = GUID_IDLESCHEDULE;
        
        // see if there is an existing schedule and if so remove it.
        pScheduleMgr->RemoveSchedule(&SyncScheduleCookie);
        
    }
    
    pScheduleMgr->Release();
    
    // set the temporary sens flags according so it can start on an idle trigger.
    // not an error to not be able to get and set key since sens will
    // be running anyways eventually.
    HKEY    hkeyAutoSync;
    DWORD   dwFlags = 0;
    DWORD   cbDataSize = sizeof(dwFlags);
    
    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGISTRYMUTEXNAME);
    CMutexRegistry.Enter();
    
    hkeyAutoSync = RegGetSyncTypeKey(SYNCTYPE_AUTOSYNC,KEY_WRITE |  KEY_READ,TRUE);
    if (NULL == hkeyAutoSync)
    {
        CMutexRegistry.Leave(); 
        return FALSE;
    }
    
    if (ERROR_SUCCESS == SHRegGetValue(hkeyAutoSync,NULL,TEXT("Flags"),SRRF_RT_REG_DWORD, NULL,
        (LPBYTE) &(dwFlags),&cbDataSize))
    {
        // Here we are setting Idle only so retail the other settings.
        dwFlags &= ~AUTOSYNC_IDLE;
        dwFlags |= (fRegister? AUTOSYNC_IDLE : 0);
        
        RegSetValueEx(hkeyAutoSync,TEXT("Flags"),NULL, REG_DWORD,
            (LPBYTE) &(dwFlags), sizeof(dwFlags));
    }
    RegCloseKey(hkeyAutoSync);
    CMutexRegistry.Leave();
    return TRUE;
    
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  BOOL  RegGetSyncSettings(DWORD dwSyncType,LPCONNECTIONSETTINGS lpConnectionSettings)
  
    Summary:  Get ConnectionSettings appropriate to the synctype..
    
      Returns:  Returns TRUE if successful, FALSE otherwise
      
------------------------------------------------------------------------F-F*/
        
STDAPI_(BOOL) RegGetSyncSettings(DWORD dwSyncType,LPCONNECTIONSETTINGS lpConnectionSettings)
{
    
    switch(dwSyncType)
    {
    case SYNCTYPE_AUTOSYNC:
        return RegGetAutoSyncSettings(lpConnectionSettings);
        break;
    case SYNCTYPE_IDLE:
        return RegGetIdleSyncSettings(lpConnectionSettings);
        break;
    default:
        AssertSz(0,"Unknown SyncType in RegGetSyncSettings");
        break;
    }
    
    return FALSE;
}
        
        
/****************************************************************************
        
    Manual Sync Registry Functions
          
***************************************************************************F-F*/
        
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        
  BOOL RegRemoveManualSyncSettings(TCHAR *pszTaskName)
  
    Summary:  Remove the manual settings info from the registry.
    
      Returns:  Returns TRUE if successful, FALSE otherwise
      
------------------------------------------------------------------------F-F*/
        
STDAPI_(BOOL) RegRemoveManualSyncSettings(TCHAR *pszConnectionName)
{
    HKEY hkeyUser;
    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGISTRYMUTEXNAME);
    CMutexRegistry.Enter();
    
    hkeyUser = RegGetCurrentUserKey(SYNCTYPE_MANUAL,KEY_WRITE |  KEY_READ,FALSE);
    
    if (hkeyUser)
    {
        RegDeleteKeyNT(hkeyUser, pszConnectionName);
        RegCloseKey(hkeyUser);
    }
    
    CMutexRegistry.Leave();
    return TRUE;
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  BOOL RegWriteEvents(BOOL fWanLogon,BOOL fWanLogoff,BOOL fLanLogon,BOOL fLanLogoff)
  
    Summary:  Write out the Wan/Lan Logon/Logoff preferences fo SENS knows whether to invoke us.
    
      Returns:  Returns TRUE if successful, FALSE otherwise
      
------------------------------------------------------------------------F-F*/

// Run key under HKLM
const WCHAR wszRunKey[]  = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Run");
const WCHAR wszRunKeyCommandLine[]  = TEXT("%SystemRoot%\\system32\\mobsync.exe /logon");


STDAPI_(BOOL) RegWriteEvents(BOOL Logon,BOOL Logoff)
{
    HRESULT hr;
    HKEY    hkeyAutoSync;
    DWORD   dwFlags = 0;
    DWORD   dwType = REG_DWORD;
    DWORD   cbDataSize = sizeof(DWORD);
    
    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGISTRYMUTEXNAME);
    CMutexRegistry.Enter();
    
    hkeyAutoSync =  RegGetSyncTypeKey(SYNCTYPE_AUTOSYNC,KEY_WRITE |  KEY_READ,TRUE);
    if (NULL == hkeyAutoSync)
    {
        
        CMutexRegistry.Leave();
        return FALSE;
    }
    
    RegQueryValueEx(hkeyAutoSync,TEXT("Flags"),NULL, &dwType,
        (LPBYTE) &(dwFlags),
        &cbDataSize);
    
    
    // Review, Shouldn't need to worry about schedule/idle once IsNetworkAlive
    // is setup properly. Leave for now first time anyone sets idle or schedule
    // stuck
    
    
    // Here we are setting autosync only,
    // so retain the registry settings for scheduled and idle.
    
    dwFlags &= ~(AUTOSYNC_WAN_LOGON  | AUTOSYNC_LAN_LOGON | AUTOSYNC_LOGONWITHRUNKEY
        | AUTOSYNC_WAN_LOGOFF | AUTOSYNC_LAN_LOGOFF);
    
    dwFlags |= (Logoff ? AUTOSYNC_WAN_LOGOFF : 0);
    dwFlags |= (Logoff ? AUTOSYNC_LAN_LOGOFF : 0);
    
    // Since now use Run key instead of SENS always set both Logon Flags 
    // that SENS looks for to do a CreateProcess on us to FALSE.
    // Then set the AUTOSYNC_LOGONWITHRUNKEY key to true so sens still gets loaded.
    
    dwFlags |= (Logon ? AUTOSYNC_LOGONWITHRUNKEY : 0);
    
    hr = RegSetValueEx(hkeyAutoSync,TEXT("Flags"),NULL, REG_DWORD,
        (LPBYTE) &(dwFlags), sizeof(DWORD));
    
    RegCloseKey(hkeyAutoSync);
    
    // now add /delete the run key appropriately.
    
    
    HKEY hKeyRun;
    
    // call private RegOpen since don't want to set security on RunKey
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, wszRunKey, NULL, KEY_READ | KEY_WRITE, &hKeyRun))
    {
        if (Logon)
        {
            RegSetValueEx(hKeyRun, SZ_SYNCMGRNAME, 0, REG_EXPAND_SZ, 
                (BYTE *) wszRunKeyCommandLine,(lstrlen(wszRunKeyCommandLine) + 1)*sizeof(TCHAR));
        }
        else
        {
            RegDeleteValue(hKeyRun, SZ_SYNCMGRNAME);
        }
        
        
        RegCloseKey(hKeyRun);
    }
    else
    {
        // if can't open run key try calling SENS if that fails give up.
        SyncMgrExecCmd_UpdateRunKey(Logon);
    }
    
    CMutexRegistry.Leave();
    return TRUE;
}

        
        
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  BOOL RegFixRunKey(BOOL fScheduled)
  
    Summary:  The original version of SyncMgr for WinMe/Win2000 wrote the
    "run" value as "mobsync.exe /logon".  Since this is not a fully-
    qualified path to the mobsync.exe image, the system's search 
    path is utilized to locate the image.  This can create an 
    opportunity for someone to build a 'trojan' mobsync.exe, place
    it in the search path ahead of the real mobsync.exe and have 
    the 'trojan' code run whenever a synchronization is invoked.
    To fix this, the path must be stored in the registry using
    fully-qualified syntax.  
    
      i.e. "%SystemRoot%\System32\mobsync.exe /logon"
      
        This function is called from DllRegisterServer to correct this 
        registry entry during setup.
        
      Returns:  Always returns TRUE.

------------------------------------------------------------------------F-F*/
                    
STDAPI_(BOOL) RegFixRunKey(void)
{
    HKEY hKeyRun;
    
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
        wszRunKey,
        NULL,
        KEY_READ | KEY_WRITE,
        &hKeyRun))
    {
        TCHAR szRunValue[MAX_PATH];
        DWORD cbValue = sizeof(szRunValue);
        if (ERROR_SUCCESS == SHRegGetValue(hKeyRun,NULL,SZ_SYNCMGRNAME, SRRF_RT_REG_SZ | SRRF_NOEXPAND, NULL,
            (LPBYTE)szRunValue, &cbValue))
        {
            if (0 == lstrcmp(szRunValue, TEXT("mobsync.exe /logon")))
            {
                //
                // Upgrade only if it's our original value.
                //
                RegSetValueEx(hKeyRun, 
                    SZ_SYNCMGRNAME, 
                    0, 
                    REG_EXPAND_SZ, 
                    (BYTE *)wszRunKeyCommandLine,
                    (lstrlen(wszRunKeyCommandLine) + 1) * sizeof(TCHAR));
            }           
        }
        RegCloseKey(hKeyRun);
    }
    return TRUE;
}


/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  BOOL RegRegisterForScheduledTasks(BOOL fScheduled)
  
    Summary:  Register/unregister for scheduled tasks
    so SENS knows whether to invoke us.
    
      Returns:  Returns TRUE if successful, FALSE otherwise
      
------------------------------------------------------------------------F-F*/

STDAPI_(BOOL) RegRegisterForScheduledTasks(BOOL fScheduled)
{
    HKEY    hkeyAutoSync;
    DWORD   dwFlags = 0;
    DWORD   cbDataSize = sizeof(dwFlags);
    
    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGISTRYMUTEXNAME);
    CMutexRegistry.Enter();
    
    hkeyAutoSync =  RegGetSyncTypeKey(SYNCTYPE_AUTOSYNC,KEY_WRITE |  KEY_READ,TRUE);
    
    if (NULL == hkeyAutoSync)
    {
        CMutexRegistry.Leave();
        return FALSE;
    }
    
    SHRegGetValue(hkeyAutoSync,NULL,TEXT("Flags"),SRRF_RT_REG_DWORD, NULL,
        (LPBYTE) &(dwFlags), &cbDataSize);
    
    
    // Here we are setting schedsync only,
    // so retain the registry settings for autosync and idle.
    
    dwFlags &=  AUTOSYNC_WAN_LOGON  |
        AUTOSYNC_WAN_LOGOFF     |
        AUTOSYNC_LAN_LOGON  |
        AUTOSYNC_LAN_LOGOFF |
        AUTOSYNC_IDLE;
    
    dwFlags |= (fScheduled? AUTOSYNC_SCHEDULED : 0);
    
    RegSetValueEx(hkeyAutoSync,TEXT("Flags"),NULL, REG_DWORD,
        (LPBYTE) &(dwFlags), sizeof(dwFlags));
    
    RegCloseKey(hkeyAutoSync);
    
    CMutexRegistry.Leave();
    
    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     RegGetCombinedUserRegFlags, private
//
//  Synopsis:   Gets an or'ing together of user settings for setting up globals.
//
//  Arguments:  [dwSyncMgrRegisterFlags] - On Success gets set to flags
//               on failure they are set to zero
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    24-Aug-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL RegGetCombinedUserRegFlags(DWORD *pdwSyncMgrRegisterFlags)
{
    HKEY hkey;
    BOOL fResult = TRUE;
    DWORD dw;
    DWORD cb = sizeof(dw);
    
    
    *pdwSyncMgrRegisterFlags = 0;
    
    // update the AutoSync Key
    hkey =  RegGetSyncTypeKey(SYNCTYPE_AUTOSYNC,KEY_READ,FALSE);
    
    if (hkey)
    {
        
        
        if (ERROR_SUCCESS == SHRegGetValue(hkey,NULL,TEXT("Logon"),SRRF_RT_REG_DWORD, NULL,
            (LPBYTE) &dw, &cb) )
        {
            *pdwSyncMgrRegisterFlags |= dw ? SYNCMGRREGISTERFLAG_CONNECT : 0;
        }
        
        cb = sizeof(dw);
        
        if (ERROR_SUCCESS == SHRegGetValue(hkey,NULL,TEXT("Logoff"),SRRF_RT_REG_DWORD, NULL,
            (LPBYTE) &dw, &cb) )
        {
            *pdwSyncMgrRegisterFlags |= dw ? SYNCMGRREGISTERFLAG_PENDINGDISCONNECT : 0;
        }
        
        RegCloseKey(hkey);
    }
    
    
    // update the Idle Key
    hkey =  RegGetSyncTypeKey(SYNCTYPE_IDLE,KEY_READ,FALSE);
    
    if (hkey)
    {
        cb = sizeof(dw);
        
        if (ERROR_SUCCESS == SHRegGetValue(hkey,NULL,TEXT("IdleEnabled"),SRRF_RT_REG_DWORD, NULL,
            (LPBYTE) &dw, &cb) )
        {
            *pdwSyncMgrRegisterFlags |= dw ? SYNCMGRREGISTERFLAG_IDLE : 0;
        }
        
        RegCloseKey(hkey);
    }
    
    return TRUE; // always return true but don't set flags on error.
    
}

                    
//+---------------------------------------------------------------------------
//
//  Member:     RegGetCombinedHandlerRegFlags, private
//
//  Synopsis:   Gets an or'ing together of handler registration Keys
//
//  Arguments:  [dwSyncMgrRegisterFlags] - On Success gets set to flags
//               on failure they are set to zero
//              [ft] - On Success filed with timestamp
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    24-Aug-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL RegGetCombinedHandlerRegFlags(DWORD *pdwSyncMgrRegisterFlags,FILETIME *pft)
{
    HKEY hkey;
    
    *pdwSyncMgrRegisterFlags = 0;
    
    hkey = RegGetHandlerTopLevelKey(KEY_READ);
    if (hkey)
    {
        DWORD dwRegistrationFlags;
        DWORD cbDataSize = sizeof(dwRegistrationFlags);
        
        if (ERROR_SUCCESS == SHRegGetValue(hkey,NULL,SZ_REGISTRATIONFLAGSKEY,SRRF_RT_REG_DWORD, NULL,
            (LPBYTE) &dwRegistrationFlags,&cbDataSize) )
        {
            *pdwSyncMgrRegisterFlags = dwRegistrationFlags;
        }
        
        RegGetTimeStamp(hkey,pft);
        
        RegCloseKey(hkey);
    }
    
    return TRUE; // always return true but don't set flags on error.
    
}


//+---------------------------------------------------------------------------
//
//  Member:     RegGetChangedHandlerFlags, private
//
//  Synopsis:   Gets an or'ing together of handler registration Keys
//              that have changed since the given FILETIME
//
//  Arguments:  [pft] - Pointer to FileTime for Compare
//              [pdwChangedFlags] - On Success filed with flags that channged
//
//  Returns:    TRUE if could gather flags.
//
//  Modifies:
//
//  History:    24-Aug-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL RegGetChangedHandlerFlags(FILETIME *pft,DWORD *pdwHandlerChandedFlags)
{
    HKEY hkeyHandler;
    
    *pdwHandlerChandedFlags = 0;
    
    hkeyHandler = RegGetHandlerTopLevelKey(KEY_READ);
    
    if (hkeyHandler)
    {
        TCHAR lpName[MAX_PATH + 1];
        DWORD dwRegistrationFlags = 0;
        FILETIME ftHandlerReg;
        DWORD dwIndex = 0;
        LONG lRet;
        HKEY hKeyClsid;
        
        // enumerate the keys 
        while ( ERROR_SUCCESS == RegEnumKey(hkeyHandler,dwIndex,lpName,ARRAYSIZE(lpName)) )
        {
            lRet = RegOpenKeyEx( hkeyHandler,
                                 lpName,
                                 NULL,
                                 KEY_READ,
                                 &hKeyClsid );
            
            
            if (ERROR_SUCCESS == lRet)
            {
                
                RegGetTimeStamp(hKeyClsid,&ftHandlerReg);
                
                // handler reg is new time than our gvien time add it to the flags.
                if (CompareFileTime(pft,&ftHandlerReg) < 0)
                {
                    DWORD   dwHandlerRegFlags;
                    DWORD   cbDataSize = sizeof(dwHandlerRegFlags);
                    if (ERROR_SUCCESS == SHRegGetValue(hKeyClsid,NULL,SZ_REGISTRATIONFLAGSKEY,SRRF_RT_REG_DWORD, NULL,
                                                       (LPBYTE) &dwHandlerRegFlags,&cbDataSize) )
                    {
                        dwRegistrationFlags |= dwHandlerRegFlags;
                    }
                }
                
                RegCloseKey(hKeyClsid);
            }
            
            dwIndex++;
        }
        
        
        *pdwHandlerChandedFlags = dwRegistrationFlags;
        
        RegCloseKey(hkeyHandler);
    }
    
    
    return TRUE;
}

                    
//+---------------------------------------------------------------------------
//
//  Member:     RegRegisterForEvents, private
//
//  Synopsis:   Registers/UnRegisters for appropriate SENS and WinLogon Events.
//              and any other per machine registration we need to do
//
//  Arguments:  [fUninstall] - set to true by uninstall to force us to unregister
//                  regardless of current machine state.
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

// !!!Warning - Assumes toplevel key information is up to date.

STDAPI  RegRegisterForEvents(BOOL fUninstall)
{
    HRESULT hr = NOERROR;
    BOOL fLogon = FALSE;
    BOOL fLogoff = FALSE;
    BOOL fIdle = FALSE;
#ifdef _SENS
    IEventSystem *pEventSystem;
#endif // _SENS
    CCriticalSection cCritSect(&g_DllCriticalSection,GetCurrentThreadId());
    
    cCritSect.Enter();
    
    if (!fUninstall)
    {
        FILETIME ftHandlerReg;
        DWORD dwSyncMgrUsersRegisterFlags; // or'ing of all Users settings
        DWORD dwSyncMgrHandlerRegisterFlags; // or'ing of all handler settings.
        DWORD dwCombinedFlags; // or together user and handler.
        
        // if not an uninstall determine the true machine state 
        // if Logon set for handler or user set or if handler
        //   wants an idle set.
        // If Logoff set we register for Logoff.
        
        RegGetCombinedUserRegFlags(&dwSyncMgrUsersRegisterFlags);
        RegGetCombinedHandlerRegFlags(&dwSyncMgrHandlerRegisterFlags,&ftHandlerReg);
        
        dwCombinedFlags = dwSyncMgrUsersRegisterFlags | dwSyncMgrHandlerRegisterFlags;
        
        if ( (dwCombinedFlags & SYNCMGRREGISTERFLAG_CONNECT)
            ||  (dwSyncMgrHandlerRegisterFlags & SYNCMGRREGISTERFLAG_IDLE) )
        {
            fLogon = TRUE;
        }
        
        if ( (dwCombinedFlags & SYNCMGRREGISTERFLAG_PENDINGDISCONNECT) )
        {
            fLogoff = TRUE;
        }
        
    }
    
    // update Registry entries for SENS to lookup
    RegWriteEvents(fLogon,fLogoff);
    
#ifdef _SENS
    
    
    // we were able to load ole automation so reg/unreg with the event system.
    hr = CoCreateInstance(CLSID_CEventSystem,NULL,CLSCTX_SERVER,IID_IEventSystem,
        (LPVOID *) &pEventSystem);
    
    if (SUCCEEDED(hr))
    {
        IEventSubscription  *pIEventSubscription;
        WCHAR               szGuid[GUID_SIZE+1];
        BSTR                bstrSubscriberID = NULL;
        BSTR                bstrPROGID_EventSubscription = NULL;
        
        
        bstrPROGID_EventSubscription = SysAllocString(PROGID_EventSubscription);
        
        StringFromGUID2(GUID_SENSSUBSCRIBER_SYNCMGRP,szGuid, ARRAYSIZE(szGuid));
        bstrSubscriberID = SysAllocString(szGuid);
        
        if (bstrSubscriberID && bstrPROGID_EventSubscription)
        {
            // register for RasConnect
            hr = CoCreateInstance(
                CLSID_CEventSubscription,
                NULL,
                CLSCTX_SERVER,
                IID_IEventSubscription,
                (LPVOID *) &pIEventSubscription
                );
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
        
        if (SUCCEEDED(hr))
        {
            BSTR bstrPublisherID = NULL;
            BSTR bstrSubscriptionID = NULL;
            BSTR bstrSubscriptionName = NULL;
            BSTR bstrSubscriberCLSID = NULL;
            BSTR bstrEventID = NULL;
            BSTR bstrEventClassID = NULL;
            BSTR bstrIID = NULL;
            
            // if there are any events, register with ens for messages.
            if (fLogon)
            {
                
                StringFromGUID2(GUID_SENSLOGONSUBSCRIPTION_SYNCMGRP,szGuid, ARRAYSIZE(szGuid));
                bstrSubscriptionID = SysAllocString(szGuid);
                
                if (bstrSubscriptionID && SUCCEEDED(hr))
                {
                    hr = pIEventSubscription->put_SubscriptionID(bstrSubscriptionID);
                }
                
                StringFromGUID2(CLSID_SyncMgrp,szGuid, ARRAYSIZE(szGuid));
                bstrSubscriberCLSID = SysAllocString(szGuid);
                
                if (bstrSubscriberCLSID && SUCCEEDED(hr))
                {
                    hr = pIEventSubscription->put_SubscriberCLSID(bstrSubscriberCLSID);
                }
                
                StringFromGUID2(SENSGUID_PUBLISHER,szGuid, ARRAYSIZE(szGuid));
                bstrPublisherID = SysAllocString(szGuid);
                if (bstrPublisherID && SUCCEEDED(hr))
                {
                    hr = pIEventSubscription->put_PublisherID(bstrPublisherID);
                }
                
                
                bstrSubscriptionName = SysAllocString(SZ_SYNCMGRNAME);
                if (bstrSubscriptionName && SUCCEEDED(hr))
                {
                    hr = pIEventSubscription->put_SubscriptionName(bstrSubscriptionName);
                }
                
                bstrEventID = SysAllocString(L"ConnectionMade");
                if (bstrEventID && SUCCEEDED(hr))
                {
                    hr = pIEventSubscription->put_MethodName(bstrEventID);
                }
                
                StringFromGUID2(SENSGUID_EVENTCLASS_NETWORK,szGuid,ARRAYSIZE(szGuid));
                bstrEventClassID = SysAllocString(szGuid);
                if (bstrEventClassID && SUCCEEDED(hr))
                {
                    hr = pIEventSubscription->put_EventClassID(bstrEventClassID);
                }
                
                // set this up for roaming
                if (SUCCEEDED(hr))
                {
                    // hr = pIEventSubscription->put_PerUser(TRUE); // don't register PerUser for Nw
                }
                
                StringFromGUID2(IID_ISensNetwork,szGuid,ARRAYSIZE(szGuid));
                bstrIID = SysAllocString(szGuid);
                if (bstrIID && SUCCEEDED(hr))
                {
                    hr = pIEventSubscription->put_InterfaceID(bstrIID);
                }
                
                
                if (SUCCEEDED(hr))
                {
                    hr = pEventSystem->Store(bstrPROGID_EventSubscription,pIEventSubscription);
                }
                
                if (bstrIID)
                {
                    SysFreeString(bstrIID);
                }
                
                if (bstrPublisherID)
                    SysFreeString(bstrPublisherID);
                
                if (bstrSubscriberCLSID)
                    SysFreeString(bstrSubscriberCLSID);
                
                if (bstrEventClassID)
                    SysFreeString(bstrEventClassID);
                
                if (bstrEventID)
                    SysFreeString(bstrEventID);
                
                if (bstrSubscriptionID)
                    SysFreeString(bstrSubscriptionID);
                
                if (bstrSubscriptionName)
                    SysFreeString(bstrSubscriptionName);
            }
            else // don't need to be registered, remove.
            {
                
                if (NOERROR == hr)
                {
                    int   errorIndex;
                    
                    bstrSubscriptionID = SysAllocString(L"SubscriptionID={6295df30-35ee-11d1-8707-00C04FD93327}");
                    
                    if (bstrSubscriptionID)
                    {
                        hr = pEventSystem->Remove(bstrPROGID_EventSubscription,bstrSubscriptionID /* QUERY */,&errorIndex);
                        SysFreeString(bstrSubscriptionID);
                    }
                }
                
            }
            
            
            pIEventSubscription->Release();
            
        }
        
        if (bstrSubscriberID)
        {
            SysFreeString(bstrSubscriberID);
        }
        
        if (bstrPROGID_EventSubscription)
        {
            SysFreeString(bstrPROGID_EventSubscription);
        }
        
        pEventSystem->Release();
        
    }
    
#endif // _SENS
    
    cCritSect.Leave();
    
    return hr;
}

// helper functions for handler registration
STDAPI_(BOOL) RegGetTimeStamp(HKEY hKey, FILETIME *pft)
{
    FILETIME ft;
    LONG lr;
    DWORD cbSize = sizeof(ft);
    
    Assert(pft);
    
    lr = SHRegGetValue( hKey,NULL,
        SZ_REGISTRATIONTIMESTAMPKEY,
        SRRF_RT_REG_BINARY,
        NULL,
        (BYTE *)&ft,
        &cbSize );
    
    
    if ( lr == ERROR_SUCCESS )
    {
        Assert(cbSize == sizeof(FILETIME));
        *pft = ft;
    }
    else
    {
        // set the filetime to way back when to
        // any compares will just say older instead
        // of having to check success code
        (*pft).dwLowDateTime = 0;
        (*pft).dwHighDateTime = 0;
    }
    
    return TRUE;
}


STDAPI_(BOOL) RegWriteTimeStamp(HKEY hkey)
{
    SYSTEMTIME sysTime;
    FILETIME ft;
    LONG lr = -1;
    
    GetSystemTime(&sysTime); // void can't check for errors
    
    if (SystemTimeToFileTime(&sysTime,&ft) )
    {
        CMutex  CMutexRegistry(NULL, FALSE,SZ_REGISTRYMUTEXNAME);
        CMutexRegistry.Enter();
        
        
        // write out the UpdateTime
        lr = RegSetValueEx( hkey,
            SZ_REGISTRATIONTIMESTAMPKEY,
            NULL,
            REG_BINARY,
            (BYTE *)&ft,
            sizeof(ft) );
        
        CMutexRegistry.Leave();
        
    }
    return (ERROR_SUCCESS == lr) ? TRUE : FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   UpdateHandlerKeyInformation
//
//  Synopsis:  Updates the top-level handler key information
//
//  Arguments:
//
//  Returns:    void
//
//  Modifies:   enumerates the handlers underneath the given key
//              updating the registrationFlags which is an || or
//              all registered handler flags and then updates the 
//              timestamp on this key
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

void UpdateHandlerKeyInformation(HKEY hKeyHandler)
{
    DWORD dwSyncMgrTopLevelRegisterFlags = 0;
    DWORD dwIndex = 0;
    TCHAR lpName[MAX_PATH];
    
    while ( ERROR_SUCCESS == RegEnumKey(hKeyHandler,dwIndex,
        lpName,ARRAYSIZE(lpName)) )
    {
        DWORD   dwHandlerRegFlags;
        DWORD   cbDataSize = sizeof(dwHandlerRegFlags);
        LONG lRet;
        HKEY hKeyClsid;
        
        lRet = RegOpenKeyEx( hKeyHandler,
            lpName,
            NULL,
            KEY_READ,
            &hKeyClsid );
        
        if (ERROR_SUCCESS == lRet)
        {
            
            if (ERROR_SUCCESS == SHRegGetValue(hKeyClsid,NULL,SZ_REGISTRATIONFLAGSKEY,SRRF_RT_REG_DWORD, NULL,
                (LPBYTE) &dwHandlerRegFlags,
                &cbDataSize) )
            {
                dwSyncMgrTopLevelRegisterFlags |= dwHandlerRegFlags;
            }
            
            RegCloseKey(hKeyClsid);
        }
        
        dwIndex++;
    }
    
    
    // not much we can do if RegFlags are messed up other than assert and mask out
    Assert(dwSyncMgrTopLevelRegisterFlags <= SYNCMGRREGISTERFLAGS_MASK);
    dwSyncMgrTopLevelRegisterFlags &= SYNCMGRREGISTERFLAGS_MASK;
    
    // write out new flags even if errors occured. work thing that happens is
    // we don't set up someones autosync automatically.
    RegSetValueEx(hKeyHandler,SZ_REGISTRATIONFLAGSKEY,NULL, REG_DWORD,
        (LPBYTE) &(dwSyncMgrTopLevelRegisterFlags), sizeof(dwSyncMgrTopLevelRegisterFlags));
    
    RegWriteTimeStamp(hKeyHandler);
}


//+---------------------------------------------------------------------------
//
//  Function:   RegUpdateTopLevelKeys
//
//  Synopsis:   Looks at toplevel AutoSync,Idle, etc. keys and determines
//              if they need to be updated and if so goes for it.
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  Modifies:   set pfFirstRegistration out param to true if this is
//              the first handler that has registered so we can setup defaults.
//
//  History:    24-Aug-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI_(void) RegUpdateTopLevelKeys()
{
    HKEY hkey;
    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGISTRYMUTEXNAME);
    
    CMutexRegistry.Enter();
    
    
    // update the AutoSync Key
    hkey =  RegGetSyncTypeKey(SYNCTYPE_AUTOSYNC,KEY_READ | KEY_WRITE,TRUE);
    
    
    if (hkey)
    {
        DWORD   dwUserLogonLogoff;
        DWORD   cbDataSize = sizeof(dwUserLogonLogoff);
        
        // see if has a logon value and if it is either newly created or
        // old format. Call Update to setthings up
        if (ERROR_SUCCESS != SHRegGetValue(hkey,NULL,TEXT("Logon"),SRRF_RT_REG_DWORD, NULL,
            (LPBYTE) &dwUserLogonLogoff,
            &cbDataSize) )
        {
            RegUpdateAutoSyncKeyValue(hkey,-1,-1); 
        }
        
        RegCloseKey(hkey);
    }
    
    
    // update the Idle Key
    hkey =  RegGetSyncTypeKey(SYNCTYPE_IDLE,KEY_READ | KEY_WRITE,TRUE);
    
    if (hkey)
    {
        DWORD   dwIdleEnabled;
        DWORD   cbDataSize = sizeof(dwIdleEnabled);
        
        // see if has a Idle value and if it is either newly created or
        // old format. Call Update to setthings up
        if (ERROR_SUCCESS != SHRegGetValue(hkey,NULL,TEXT("IdleEnabled"),SRRF_RT_REG_DWORD, NULL,
            (LPBYTE) &dwIdleEnabled, &cbDataSize) )
        {
            RegUpdateIdleKeyValue(hkey,-1); 
        }
        
        RegCloseKey(hkey);
    }
    
    CMutexRegistry.Leave();
    
}

//+---------------------------------------------------------------------------
//
//  Function:   RegRegisterHandler
//
//  Synopsis:   Registers Handlers with SyncMgr.
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  Modifies:   set pfFirstRegistration out param to true if this is
//              the first handler that has registered so we can setup defaults.
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI_(BOOL) RegRegisterHandler(REFCLSID rclsidHandler,
                                 WCHAR const* pwszDescription,
                                 DWORD dwSyncMgrRegisterFlags,
                                 BOOL *pfFirstRegistration)
{
    LONG lRet;
    
    RegUpdateTopLevelKeys(); // make sure other top-level keys are up to date.
    
    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGISTRYMUTEXNAME);
    CMutexRegistry.Enter();
    
    *pfFirstRegistration = FALSE;
    HKEY hKeyHandler;
    
    hKeyHandler = RegGetHandlerTopLevelKey(KEY_READ | KEY_WRITE);
    
    if (NULL == hKeyHandler)
    {
        CMutexRegistry.Leave();
        return FALSE;
    }
    
    //
    // Check if this is the first handler being registerd
    //
    TCHAR szGuid[GUID_SIZE+1];
    DWORD cchGuid = ARRAYSIZE(szGuid);
    
    lRet = RegEnumKeyEx( hKeyHandler,
        0,
        szGuid,
        &cchGuid,
        NULL,
        NULL,
        NULL,
        NULL );
    
    if ( lRet != ERROR_SUCCESS )
        *pfFirstRegistration = TRUE;
    
    //
    // Convert guid and description to TCHAR
    //
    TCHAR *pszDesc;
    BOOL fOk = FALSE;
    
    StringFromGUID2( rclsidHandler, szGuid, ARRAYSIZE(szGuid));
    pszDesc = (TCHAR *)pwszDescription;
    
    
    // write out the registration flags. If fail go ahead
    // and succed registration anyways.
    if (hKeyHandler)
    {
        HKEY hKeyClsid;
        
        hKeyClsid = RegGetHandlerKey(hKeyHandler,szGuid,KEY_WRITE | KEY_READ,TRUE);
        
        if (hKeyClsid)
        {
            
            fOk = TRUE; // if make handle key say registered okay
            
            if (pszDesc)
            {
                RegSetValueEx(hKeyClsid,NULL,NULL, REG_SZ,
                    (LPBYTE) pszDesc,
                    (lstrlen(pszDesc) +1)*sizeof(TCHAR));
            }
            
            RegSetValueEx(hKeyClsid,SZ_REGISTRATIONFLAGSKEY,NULL, REG_DWORD,
                (LPBYTE) &(dwSyncMgrRegisterFlags), sizeof(dwSyncMgrRegisterFlags));
            
            // update the TimeStamp on the handler clsid
            
            RegWriteTimeStamp(hKeyClsid);
            RegCloseKey( hKeyClsid );
            
            // update the toplevel key
            UpdateHandlerKeyInformation(hKeyHandler);
        }
    }
    
    // update the user information.
    RegSetUserDefaults();
    RegRegisterForEvents(FALSE /* fUninstall */);
    
    CMutexRegistry.Leave();
    RegCloseKey(hKeyHandler);
    
    return fOk;
}


//+---------------------------------------------------------------------------
//
//  Function:   RegRegRemoveHandler
//
//  Synopsis:   UnRegisters Handlers with SyncMgr.
//
                                 //  Arguments:
                                 //
                                 //  Returns:    Appropriate status code
//
//  Modifies:   set pfAllHandlerUnRegistered out param to true if this is
//              the last handler that needs to be unregistered before
//              turning off our defaults..
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI_(BOOL) RegRegRemoveHandler(REFCLSID rclsidHandler)
{
    HKEY hKeyHandler;
    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGISTRYMUTEXNAME);
    
    CMutexRegistry.Enter();
    
    
    hKeyHandler = RegGetHandlerTopLevelKey(KEY_WRITE | KEY_READ);
    
    if (NULL == hKeyHandler)
    {
        //
        // Non-existent key, so nothing to remove
        //
        CMutexRegistry.Leave();
        return TRUE;
    }
    
    TCHAR szGuid[GUID_SIZE+1];
    
    StringFromGUID2( rclsidHandler, szGuid, ARRAYSIZE(szGuid) );
    
    HKEY hKeyClsid;
    
    hKeyClsid = RegGetHandlerKey(hKeyHandler,szGuid,KEY_WRITE | KEY_READ,FALSE);
    
    if (hKeyClsid)
    {
        RegCloseKey( hKeyClsid );
        RegDeleteKey( hKeyHandler, szGuid );
        
        // update the toplevel key
        UpdateHandlerKeyInformation(hKeyHandler);
        
    }
    else
    {
        //
        // Non-existent key, so nothing to remove
        //
    }
    
    
    RegRegisterForEvents(FALSE /* fUninstall */); // UPDATE EVENT REGISTRATION.
    
    CMutexRegistry.Leave();
    RegCloseKey(hKeyHandler);
    
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   RegGetHandlerRegistrationInfo
//
//  Synopsis:   Gets Information of the specified handler.
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  Modifies:   pdwSyncMgrRegisterFlags
//
//  History:    20-Aug-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI_(BOOL) RegGetHandlerRegistrationInfo(REFCLSID rclsidHandler,LPDWORD pdwSyncMgrRegisterFlags)
{
    HKEY hKeyHandler;
    
    *pdwSyncMgrRegisterFlags = 0;
    
    
    hKeyHandler = RegGetHandlerTopLevelKey(KEY_READ);
    
    if (NULL == hKeyHandler)
    {
        //
        // Non-existent key
        //
        return FALSE;
    }
    TCHAR szGuid[GUID_SIZE+1];
    
    StringFromGUID2( rclsidHandler, szGuid, ARRAYSIZE(szGuid));
    
    HKEY hKeyClsid;
    BOOL fResult = FALSE;
    
    hKeyClsid = RegGetHandlerKey(hKeyHandler,szGuid,KEY_READ,FALSE);
    
    if (hKeyClsid)
    {
        DWORD   cbDataSize = sizeof(*pdwSyncMgrRegisterFlags);
        LONG lRet;
        
        lRet = SHRegGetValue(hKeyClsid,NULL,SZ_REGISTRATIONFLAGSKEY,SRRF_RT_REG_DWORD, NULL,
            (LPBYTE) pdwSyncMgrRegisterFlags,
            &cbDataSize);
        RegCloseKey( hKeyClsid );
        
        fResult = (ERROR_SUCCESS == lRet) ? TRUE : FALSE;
    }
    else
    {
        //
        // Non-existent key, so nothing to remove
        //
        
    }
    
    RegCloseKey(hKeyHandler);
    
    return fResult;
}


//+---------------------------------------------------------------------------
//
//  Function:   RegSetUserDefaults
//
//  Synopsis:   Registers default values for auto and idle sync
//
//              Setup based on Handler and UserPreferences
//
//  History:    20-May-98       SitaramR       Created
//
//----------------------------------------------------------------------------

STDAPI_(void) RegSetUserDefaults()
{
    HKEY hKeyUser = NULL;
    FILETIME ftHandlerReg;
    DWORD dwHandlerRegistrationFlags;
    
    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGISTRYMUTEXNAME);
    CMutexRegistry.Enter();
    
    // get the combined handler registration toplevel flags and timeStamp
    // to see if should bother enumerating the rest.
    if (!RegGetCombinedHandlerRegFlags(&dwHandlerRegistrationFlags,&ftHandlerReg))
    {
        CMutexRegistry.Leave();
        return;
    }
    
    if (0 != (dwHandlerRegistrationFlags & 
        (SYNCMGRREGISTERFLAG_CONNECT | SYNCMGRREGISTERFLAG_PENDINGDISCONNECT) ) )
    {
        
        // See if AutoSync key needs to be updated
        hKeyUser =  RegGetCurrentUserKey(SYNCTYPE_AUTOSYNC,KEY_WRITE |  KEY_READ,TRUE);
        
        if (hKeyUser)
        {
            FILETIME ftUserAutoSync;
            
            // if got the User get the timestamp and see if it is older than the handlers
            // If this is a new user filetime will be 0
            
            RegGetTimeStamp(hKeyUser,&ftUserAutoSync);
            
            if (CompareFileTime(&ftUserAutoSync,&ftHandlerReg) < 0)
            {
                DWORD dwHandlerChangedFlags;
                
                // need to walk through handlers and update what we need to set based
                // on each handlers timestamp since we don't want a handler that registered
                // for idle to cause us to turn AutoSync back on and vis-a-versa
                
                if (RegGetChangedHandlerFlags(&ftUserAutoSync,&dwHandlerChangedFlags))
                {
                    BOOL fLogon = (dwHandlerChangedFlags & SYNCMGRREGISTERFLAG_CONNECT) ? TRUE : FALSE;
                    BOOL fLogoff = (dwHandlerChangedFlags & SYNCMGRREGISTERFLAG_PENDINGDISCONNECT) ? TRUE : FALSE;
                    
                    RegSetAutoSyncDefaults(fLogon,fLogoff);
                }
                
            }
            
            RegCloseKey(hKeyUser);
            hKeyUser = NULL;
        }
    }
    
    if (0 != (dwHandlerRegistrationFlags & SYNCMGRREGISTERFLAG_IDLE ) )
    {
        
        // now check for Idle same logic as above could probably combine
        // into a function
        // See if AutoSync key needs to be updated
        hKeyUser =  RegGetCurrentUserKey(SYNCTYPE_IDLE, KEY_WRITE |  KEY_READ,TRUE);
        
        
        if (hKeyUser)
        {
            FILETIME ftUserIdleSync;
            
            // if got the User get the timestamp and see if it is older than the handlers
            // If this is a new user filetime will be 0
            
            RegGetTimeStamp(hKeyUser,&ftUserIdleSync);
            
            if (CompareFileTime(&ftUserIdleSync,&ftHandlerReg) < 0)
            {
                DWORD dwHandlerChangedFlags;
                
                // need to walk through handlers and update what we need to set based
                // on each handlers timestamp since we don't want a handler that registered
                // for AutoSync to cause us to turn Idle back on and vis-a-versa
                
                if (RegGetChangedHandlerFlags(&ftUserIdleSync,&dwHandlerChangedFlags))
                {
                    if (dwHandlerChangedFlags & SYNCMGRREGISTERFLAG_IDLE)
                    {
                        RegSetIdleSyncDefaults(TRUE);
                    }
                    
                }
                
            }
            
            RegCloseKey(hKeyUser);
            hKeyUser = NULL;
        }
    }
    
    
    CMutexRegistry.Leave();
}



//+---------------------------------------------------------------------------
//
//  Function:   RegSetAutoSyncDefaults
//
//  Synopsis:   Registers default values for auto sync
//
//  History:    20-May-98       SitaramR       Created
//
//----------------------------------------------------------------------------

STDAPI_(void) RegSetAutoSyncDefaults(BOOL fLogon,BOOL fLogoff)
{
    CONNECTIONSETTINGS *pConnection = (LPCONNECTIONSETTINGS)
        ALLOC(sizeof(*pConnection));
    if ( pConnection == 0 )
        return;
    INT iRet = LoadString(g_hmodThisDll,
        IDS_LAN_CONNECTION,
        pConnection->pszConnectionName,
        ARRAYSIZE(pConnection->pszConnectionName) );
    Assert( iRet != 0 );
    
    // -1 values are ignored by RegSetAutoSyncSettings.
    // if not turning on leave the User Preferences alone,
    pConnection->dwConnType = 0;
    pConnection->dwLogon = fLogon ? TRUE : -1;
    pConnection->dwLogoff = fLogoff ? TRUE : -1;
    pConnection->dwPromptMeFirst = -1;
    pConnection->dwMakeConnection = -1;
    pConnection->dwIdleEnabled = -1;
    
    // since this bases settings on what is already set no need to
    // do a cleanreg or update the machine state
    RegSetAutoSyncSettings(pConnection, 1, 0,
        FALSE /* fCleanReg */,
        FALSE /* fSetMachineState */,
        FALSE /* fPerUser */);
    
    FREE(pConnection);
}

//+---------------------------------------------------------------------------
//
//  Function:   RegSetUserAutoSyncDefaults
//
//  Synopsis:   Registers user default values for auto sync
//
//  History:    39-March-99       rogerg       Created
//
//----------------------------------------------------------------------------

STDAPI RegSetUserAutoSyncDefaults(DWORD dwSyncMgrRegisterMask,
                                  DWORD dwSyncMgrRegisterFlags)
{
    
    // if not changing either logon or logoff just return
    if (!(dwSyncMgrRegisterMask & SYNCMGRREGISTERFLAG_CONNECT)
        && !(dwSyncMgrRegisterMask & SYNCMGRREGISTERFLAG_PENDINGDISCONNECT) )
    {
        return NOERROR;
    }
    
    
    CONNECTIONSETTINGS *pConnection = (LPCONNECTIONSETTINGS)
        ALLOC(sizeof(*pConnection));
    if ( pConnection == 0 )
        return E_OUTOFMEMORY;
    INT iRet = LoadString(g_hmodThisDll,
        IDS_LAN_CONNECTION,
        pConnection->pszConnectionName,
        ARRAYSIZE(pConnection->pszConnectionName) );
    Assert( iRet != 0 );
    
    // -1 values are ignored by RegSetAutoSyncSettings.
    // if not turning on leave the User Preferences alone,
    pConnection->dwConnType = 0;
    pConnection->dwLogon = -1;
    pConnection->dwLogoff = -1;
    pConnection->dwPromptMeFirst = -1;
    pConnection->dwMakeConnection = -1;
    pConnection->dwIdleEnabled = -1;
    
    if (dwSyncMgrRegisterMask & SYNCMGRREGISTERFLAG_CONNECT)
    {
        pConnection->dwLogon = (dwSyncMgrRegisterFlags & SYNCMGRREGISTERFLAG_CONNECT)
            ? TRUE : FALSE;
    }
    
    if (dwSyncMgrRegisterMask & SYNCMGRREGISTERFLAG_PENDINGDISCONNECT)
    {
        pConnection->dwLogoff = (dwSyncMgrRegisterFlags & SYNCMGRREGISTERFLAG_PENDINGDISCONNECT)
            ? TRUE : FALSE;
    }
    
    // since this bases settings on what is already set no need to
    // do a cleanreg or update the machine state
    RegSetAutoSyncSettings(pConnection, 1, 0,
        FALSE /* fCleanReg */,
        TRUE /* fSetMachineState */,
        TRUE /* fPerUser */);
    
    FREE(pConnection);
    
    return NOERROR;
}



//+---------------------------------------------------------------------------
//
//  Function:   RegSetIdleSyncDefaults
//
//  Synopsis:   Registers default values for idle sync
//
//  History:    20-May-98       SitaramR       Created
//
//----------------------------------------------------------------------------

STDAPI_(void) RegSetIdleSyncDefaults(BOOL fIdle)
{
    
    Assert(fIdle); // for now this should only be called when true;
    
    if (!fIdle)
    {
        return;
    }
    
    CONNECTIONSETTINGS *pConnection = (LPCONNECTIONSETTINGS)
        ALLOC(sizeof(*pConnection));
    if ( pConnection == 0 )
        return;
    INT iRet = LoadString(g_hmodThisDll,
        IDS_LAN_CONNECTION,
        pConnection->pszConnectionName,
        ARRAYSIZE(pConnection->pszConnectionName) );
    Assert( iRet != 0 );
    
    pConnection->dwConnType = 0;
    pConnection->dwLogon = -1;
    pConnection->dwLogoff = -1;
    pConnection->dwPromptMeFirst = -1;
    pConnection->dwMakeConnection = -1;
    pConnection->dwIdleEnabled = TRUE;
    
    // set all userLevel items to -1 so user gets the defaults if new
    // but keep their settings if have already tweaked them.
    pConnection->ulIdleRetryMinutes = -1;
    pConnection->ulDelayIdleShutDownTime = -1;
    pConnection->dwRepeatSynchronization = -1;
    pConnection->ulIdleWaitMinutes = -1;
    pConnection->dwRunOnBatteries = -1;
    
    RegSetIdleSyncSettings(pConnection, 1, 0,
        FALSE /* fCleanReg */,
        FALSE /* fPerUser  */);
    
    FREE(pConnection);
}


//+---------------------------------------------------------------------------
//
//  Function:   RegSetIdleSyncDefaults
//
//  Synopsis:   Registers default values for idle sync
//
//  History:    30-March-99       ROGERG       Created
//
//----------------------------------------------------------------------------

STDAPI RegSetUserIdleSyncDefaults(DWORD dwSyncMgrRegisterMask,
                                  DWORD dwSyncMgrRegisterFlags)
{
    
    // RegSetIdleSyncSettings doesn't handle idle enabled of -1 so only
    // call if Idle actually is set in the flags, if not just return
    
    if (!(dwSyncMgrRegisterMask & SYNCMGRREGISTERFLAG_IDLE))
    {
        return NOERROR;
    }
    
    CONNECTIONSETTINGS *pConnection = (LPCONNECTIONSETTINGS)
        ALLOC(sizeof(*pConnection));
    if ( pConnection == 0 )
        return E_OUTOFMEMORY;
    INT iRet = LoadString(g_hmodThisDll,
        IDS_LAN_CONNECTION,
        pConnection->pszConnectionName,
        ARRAYSIZE(pConnection->pszConnectionName) );
    Assert( iRet != 0 );
    
    pConnection->dwConnType = 0;
    pConnection->dwLogon = -1;
    pConnection->dwLogoff = -1;
    pConnection->dwPromptMeFirst = -1;
    pConnection->dwMakeConnection = -1;
    
    pConnection->dwIdleEnabled = (SYNCMGRREGISTERFLAG_IDLE  & dwSyncMgrRegisterFlags) 
        ? TRUE : FALSE;
    
    // set all userLevel items to -1 so user gets the defaults if new
    // but keep their settings if have already tweaked them.
    pConnection->ulIdleRetryMinutes = -1;
    pConnection->ulDelayIdleShutDownTime = -1;
    pConnection->dwRepeatSynchronization = -1;
    pConnection->ulIdleWaitMinutes = -1;
    pConnection->dwRunOnBatteries = -1;
    
    RegSetIdleSyncSettings(pConnection, 1, 0,
        FALSE /* fCleanReg */,
        TRUE /* fPerUser  */);
    
    
    FREE(pConnection);
    
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Function:   RegGetUserRegisterFlags
//
//  Synopsis:   returns current registration flags for the User.
//
//  History:    30-March-99       ROGERG       Created
//
//----------------------------------------------------------------------------

STDAPI RegGetUserRegisterFlags(LPDWORD pdwSyncMgrRegisterFlags)
{
    CONNECTIONSETTINGS connectSettings;
    
    *pdwSyncMgrRegisterFlags = 0;
    
    INT iRet = LoadString(g_hmodThisDll,
        IDS_LAN_CONNECTION,
        connectSettings.pszConnectionName,
        ARRAYSIZE(connectSettings.pszConnectionName) );
    if (0 == iRet)
    {
        Assert( iRet != 0 );
        return E_UNEXPECTED;
    }
    
    RegGetSyncSettings(SYNCTYPE_AUTOSYNC,&connectSettings);
    
    if (connectSettings.dwLogon)
    {
        *pdwSyncMgrRegisterFlags |= (SYNCMGRREGISTERFLAG_CONNECT);
    }
    
    if (connectSettings.dwLogoff)
    {
        *pdwSyncMgrRegisterFlags |= (SYNCMGRREGISTERFLAG_PENDINGDISCONNECT);
    }
    
    
    RegGetSyncSettings(SYNCTYPE_IDLE,&connectSettings);
    
    if (connectSettings.dwIdleEnabled)
    {
        *pdwSyncMgrRegisterFlags |= (SYNCMGRREGISTERFLAG_IDLE);
    }
    
    
    
    return NOERROR;
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: BOOL RegSchedHandlerItemsChecked(TCHAR *pszHandlerName, 
  TCHAR *pszConnectionName,
  TCHAR *pszScheduleName)
  
    Summary:  Determine if any items are checked on this handler for this schedule
    
      Returns:  Returns TRUE if one or more are checked, FALSE otherwise
      
------------------------------------------------------------------------F-F*/
BOOL  RegSchedHandlerItemsChecked(TCHAR *pszHandlerName, 
                                  TCHAR *pszConnectionName,
                                  TCHAR *pszScheduleName)
{
    SCODE sc;
    HKEY     hKeyUser,
        hkeySchedName,
        hkeyConnection,
        hkeyHandler,
        hkeyItem;
    DWORD   cbName = MAX_PATH,
        dwIndex = 0,
        dwCheckState = 0;        
    
    BOOL    fItemsChecked = FALSE;
    TCHAR   lpName[MAX_PATH + 1];
    
    hKeyUser =  RegGetCurrentUserKey(SYNCTYPE_SCHEDULED,KEY_READ,FALSE);
    
    if (NULL == hKeyUser)
    {
        return FALSE;
    }
    
    smChkTo(EH_Err3,RegOpenKeyEx (hKeyUser,
        pszScheduleName,0,KEY_READ,
        &hkeySchedName));
    
    smChkTo(EH_Err4,RegOpenKeyEx (hkeySchedName,
        pszConnectionName,
        0,KEY_READ,
        &hkeyConnection));
    
    smChkTo(EH_Err5,RegOpenKeyEx (hkeyConnection,
        pszHandlerName,
        0,KEY_READ,
        &hkeyHandler));
    // need to enum handler items.
    while ( ERROR_SUCCESS == RegEnumKey(hkeyHandler,dwIndex,
        lpName,cbName) )
    {
        LONG lRet;
        
        lRet = RegOpenKeyEx( hkeyHandler,
            lpName,
            NULL,
            KEY_READ,
            &hkeyItem);
        
        if (ERROR_SUCCESS == lRet)
        {
            DWORD cbDataSize = sizeof(dwCheckState);
            SHRegGetValue(hkeyItem,NULL,TEXT("CheckState"), SRRF_RT_REG_DWORD, NULL, 
                (LPBYTE) &dwCheckState, &cbDataSize);
            
            RegCloseKey(hkeyItem);
            
        }
        else
        {
            goto EH_Err5;
        }
        
        if (dwCheckState)
        {
            fItemsChecked = TRUE;
            break;
        }
        dwIndex++;
    }
    
    RegCloseKey(hkeyHandler);
    RegCloseKey(hkeyConnection);
    RegCloseKey(hkeySchedName);
    RegCloseKey(hKeyUser);
    return fItemsChecked;
    
EH_Err5:
    RegCloseKey(hkeyConnection);
EH_Err4:
    RegCloseKey(hkeySchedName);
EH_Err3:
    RegCloseKey(hKeyUser);
    
    return fItemsChecked;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\dll\resource.h ===
//{{NO_DEPENDENCIES}}
// Copyright (C) Microsoft Corporation, 1999.
// Microsoft Developer Studio generated include file.
// Used by settings.rc
//
#define IDC_RUNAS_TEXT                  1070
#define IDC_SCHED_NAME_EDIT             1071
#define IDC_SCHED_NAME_EDITBOX          1072
#define IDC_PASSWORD_TEXT               1073
#define IDC_CONFIRMPASSWORD_TEXT        1074
#define IDC_EDIT2                       1075
#define IDC_STATIC1                     1076
#define IDC_RUNLOGGEDON                 1078
#define IDC_RUNALWAYS                   1079
#define IDC_STATIC2                     1081
#define DLL_STARTRESOURCEID             3000
#define IDD_RASCONNECTION               3001
#define IDS_DESCRIPTION                 3002
#define IDS_LARGEFONTNAME               3003
#define IDS_DESCRIPTION4                3004
#define IDS_DESCRIPTION2                3005
#define IDS_LARGEFONTSIZE               3006
#define IDS_DESCRIPTION3                3007
#define IDC_PHONEICON                   3009
#define IDS_SYNCHMGR_NAME               3011
#define IDC_DESCRIPTION                 3012
#define IDS_CONNECTDESCRIPTION          3013
#define IERR_PASSWORD                   3014
#define IDC_SETDEFAULT                  3015
#define IERR_INTERNAL_ERROR             3016
#define IDC_CONNECTIONCOMBO             3017
#define IERR_OUT_OF_MEMORY              3018
#define IERR_NOITEMS                    3019
#define IDS_SCHEDULE_COLUMN_TITLE       3020
#define IDS_LOGONLOGOFF_TAB             3021
#define IDS_ONIDLE_TAB                  3022
#define IDS_SCHEDULED_TAB               3023
#define IDS_SCHEDULED_TITLE             3024
#define IDS_LAN_CONNECTION              3025
#define IDS_NAMEANDLOCATION             3026
#define IDS_NETWORKMODIFIED             3027
#define IDS_LOCALMODIFIED               3028
#define IERR_GETSVCSTATE                3029
#define IERR_STOPSVC                    3030
#define IERR_PAUSESVC                   3031
#define IERR_CONTINUESVC                3032
#define IDS_SCHEDULER_NAME              3033
#define IERR_SCHEDSVC                   3034
#define IDS_START_SERVICE               3035
#define IDS_CONTINUE_SERVICE            3036
#define IDS_START_PENDING               3037
#define IERR_SERVICE_NOT_STARTED        3038
#define IERR_SERVICE_NOT_STARTED_EDIT   3039
#define IERR_INVALIDSCHEDNAME           3040
#define IDS_SCHED_WHEN                  3041
#define IDS_SCHED_LASTRUN               3042
#define IDS_SCHED_NEXTRUN               3043
#define IDS_SCHED_NEVERRUN              3044
#define IDS_SCHED_NOTSCHED              3045
#define IDS_UPDATESELECTEDITEM          3046
#define IDS_SYNCMGR_EXE_NAME            3046
#define IDI_RASCONNECTION               3047
#define IERR_NAMEINUSE                  3047
#define IDI_LANCONNECTION               3048
#define IERR_SCHEDULE_SAVE_FAIL         3049
#define IDS_SCHED_NOTAGAIN              3050
#define IDS_IDLE_TRIGGER_STRING		3051
#define IDS_SYSTEMSTART_TRIGGER_STRING	3052
#define IDS_LOGON_TRIGGER_STRING	3053
#define IDS_NEXTRUN_EVENT		3054

#define IDI_PHONE                       3101
#define IDD_PROPPAGE_LARGE              3102
#define IDD_SCHEDWIZ_WHAT               3103
#define IDD_SCHEDWIZ_CONNECTION         3104
#define IDD_AUTOSYNC                    3105
#define IDD_SCHEDSYNC                   3106
#define IDD_SCHEDWIZ_WHENWHO            3107
#define IDD_SCHEDWIZ_NAMEIT             3108
#define IDD_SCHEDPAGE_ITEMS             3109
#define IDD_PROPPAGE_MEDIUM             3110
#define IDD_SCHEDPAGE_CREDENTIALS       3110
#define IDD_SCHEDWIZ_FINISH             3111
#define IDB_SPLASH256                   3112
#define IDD_SCHEDWIZ_DAILY              3113
#define IDB_BITMAP1                     3114
#define IDD_SCHEDWIZ_ITEMS              3115
#define IDD_SCHEDWIZ_INTRO              3116
#define IDI_TASKSCHED                   3118
#define IDI_SYNCMGR                     3129
#define set_passwd_dlg                  3131
#define IDD_RESFILECONFLICTS            3132
#define IDI_KEEPBOTH                    3135
#define IDI_KEEPLOCAL                   3136
#define IDI_KEEPNETWORK                 3137
#define IDD_IDLESETTINGS                3143
#define IDD_ADVANCEDIDLESETTINGS        3144
#define IDI_SETTINGS                    3147
#define IDC_ADVANCEDIDLEOVERVIEWTEXT    3148
#define IDC_ADVANCEDIDLEWAITTEXT        3149
#define IDC_ADVANCEDIDLEMINUTESTEXT1    3150
#define IDC_ADVANCEDIDLEMINUTESTEXT2    3151
#define IDS_LOGON_TAB                   3152
#define IDS_LOGON_TEXT                  3153
#define IDC_AUTOUPDATECOMBO             4001
#define IDC_AUTOUPDATELIST              4002
#define IDC_AUTOLOGON                   4003
#define IDC_AUTOLOGOFF                  4004
#define IDC_SP_SEPARATOR                4005
#define IDC_AUTOPROMPT_ME_FIRST         4006
#define IDC_SCHEDLIST                   4007
#define IDC_SCHEDADD                    4008
#define IDC_SCHEDEDIT                   4009
#define IDC_SCHEDREMOVE                 4010
#define IDC_WIZBMP                      4013
#define IDC_NAMEIT                      4014
#define IDC_SCHEDUPDATECOMBO            4015
#define IDC_SCHEDUPDATELIST             4016
#define IDC_USERNAME                    4027
#define IDC_USERPASSWORD                4028
#define IDC_USERPASSWORDCONFIRM         4029
#define IDC_CONFIRMPASSWORD             4030
#define IDC_STARTDATE                   4033
#define startdate_dp                    4034
#define IDC_EVERYDAY                    4035
#define daily_day_rb                    4036
#define IDC_WEEKDAYS                    4037
#define daily_weekday_rb                4038
#define IDC_EVERY                       4039
#define daily_ndays_rb                  4040
#define IDC_LIST2                       4041
#define IDC_DAILYTIME                   4042
#define starttime_dp                    4043
#define daily_ndays_ud                  4044
#define daily_ndays_edit                4045
#define daily_ndays_lable               4046
#define IDC_ScheduleName                4047
#define IDC_ScheduleTime                4048
#define IDC_ConnectionName              4049
#define IDC_AUTOCONNECT                 4050
#define IDC_AUTOHIDDEN                  4051
#define IDC_AUTOCONNECT2                4051
#define IDC_ONLY_WHEN_LOGGED_ON         4051
#define IDC_AUTOREADONLY                4052
#define IDC_ConnectionText              4053
#define IDC_INTROTITLE                  4054
#define IDC_PASSWORD                    4055
#define IDC_PASSWORDBUTTON              4055
#define edt_sp_cfrmpasswd               4056
#define edt_sp_passwd                   4057
#define lbl_sp_passwd                   4058
#define lbl_sp_cfrmpasswd               4059
#define btn_sp_ok                       4060
#define btn_sp_cancel                   4061
#define IDC_IDLECHECKBOX                4062
#define IDC_ADVANCEDIDLE                4063
#define IDC_SPINIDLEWAITMINUTES         4065
#define IDC_CHECK1                      4066
#define IDC_CHECKREPEATESYNC            4067
#define IDC_SPIN3                       4068
#define IDC_SPINIDLEREPEATMINUTES       4070
#define IDC_CHECK2                      4071
#define IDC_CHECKRUNONBATTERIES         4072
#define IDC_EDITIWAITMINUTES            4073
#define IDC_EDITIDLEREPEATMINUTES       4075
#define IDD_SCHEDPAGE_SCHEDULE          4076
#define IDC_SCHED_STRING                4080
#define IDC_LASTRUN                     4081
#define IDC_NEXTRUN                     4082
#define IDC_SCHED_NAME                  4083
#define IDC_FILEANDLOCATION             4501
#define IDC_KEEPBOTH                    4502
#define IDC_KEEPLOCAL                   4503
#define IDC_KEEPNETWORK                 4504
#define IDC_NEWFILENAME                 4505
#define IDC_NETWORKMODIFIED             4506
#define IDC_LOCALMODIFIED               4507
#define IDC_VIEWNETWORK                 4508
#define IDC_VIEWLOCAL                   4509
#define IDI_DOCICON                     4510
#define IDI_EXCLAIMICON                 4511
#define IDB_BIGICON                     4512
#define IDC_STATIC3                     4513
#define IDC_STATIC4                     4514
#define IERR_ACCOUNT_NOT_FOUND          4515
#define IDS_NOLOCALINFO                 4516
#define IDS_NONETINFO                   4517
#define IDS_UNKNOWNDATE                 4519
#define IDC_APPLY_ALL                   4520
#define IDS_NETWORKMODIFIED_DATEONLY    4521
#define IDS_LOCALMODIFIED_DATEONLY      4522
#define IDS_CONFIRMSCHEDDELETE_TITLE    4600
#define IDS_CONFIRMSCHEDDELETE_TEXT     4601
#define IDS_SYNCMGRSCHED_DEFAULTNAME    4602
#define IDS_SHORTCUTNAME                4700
#define IDS_SYNCMGR_PERUSERDISPLAYNAME  4701
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        150
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1082
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\dll\schdsync.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       schdsync.cpp
//
//  Contents:   SyncMgr AutoSync class
//
//  Classes:    CSchedSyncPage
//
//  Notes:      
//
//  History:    14-Nov-97   SusiA      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

DWORD StartScheduler();

extern HINSTANCE g_hmodThisDll; // Handle to this DLL itself.
extern LANGID g_LangIdSystem;      // LangId of system we are running on.


#define UNLIMITED_SCHEDULE_COUNT    50 //Review:  What is a reasonable amount of shcedules to grab at a time
#define MAX_APPEND_STRING_LEN       32


//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CSchedSyncPage::Initialize()
//
//  PURPOSE: initialization for the autosync page
//
//  RETURN VALUE: return TRUE if we process it ok.
//
//+-------------------------------------------------------------------------------

BOOL CSchedSyncPage::Initialize()
{
    //initialize the item list
    HWND hwndList = GetDlgItem(m_hwnd,IDC_SCHEDLIST);
    TCHAR pszColumnTitle[MAX_PATH + 1];
    LV_COLUMN columnInfo;
    HIMAGELIST himage;
    INT iItem = -1;
    UINT ImageListflags;
    
    
    LoadString(m_hinst, IDS_SCHEDULE_COLUMN_TITLE, pszColumnTitle, ARRAYSIZE(pszColumnTitle));
    
    ListView_SetExtendedListViewStyle(hwndList, LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP );
    
    
    ImageListflags = ILC_COLOR | ILC_MASK;
    if (IsHwndRightToLeft(m_hwnd))
    {
        ImageListflags |=  ILC_MIRROR;
    }
    
    // create an imagelist
    himage = ImageList_Create( GetSystemMetrics(SM_CXSMICON),
        GetSystemMetrics(SM_CYSMICON),ImageListflags,5,20);
    if (himage)
    {
        ListView_SetImageList(hwndList,himage,LVSIL_SMALL);
    }
    
    HICON hIcon = LoadIcon(m_hinst,MAKEINTRESOURCE(IDI_TASKSCHED));
    if (hIcon)
    {
        m_iDefaultIconImageIndex = ImageList_AddIcon(himage,hIcon);
    }
    else
    {
        m_iDefaultIconImageIndex = -1;
    }
    
    // Insert the Proper columns
    columnInfo.mask = LVCF_FMT  | LVCF_TEXT  | LVCF_WIDTH  | LVCF_SUBITEM;
    columnInfo.fmt = LVCFMT_LEFT;
    columnInfo.cx = 328;
    columnInfo.pszText = pszColumnTitle;
    columnInfo.cchTextMax = lstrlen(pszColumnTitle) + 1;
    columnInfo.iSubItem = 0;
    ListView_InsertColumn(hwndList,0,&columnInfo);
    
    if (FAILED(InitializeScheduleAgent()))
    {
        return FALSE;
    }
    ShowAllSchedules();
    
    ShowWindow(m_hwnd, /* nCmdShow */ SW_SHOWNORMAL ); 
    UpdateWindow(m_hwnd);
    
    
    return TRUE;
    
}

//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CSchedSyncPage::InitializeScheduleAgent()
//
//  PURPOSE: initialization for the ISyncSCheduleMgr
//
//  RETURN VALUE: return the appropriate HRESULT.
//
//+-------------------------------------------------------------------------------
HRESULT CSchedSyncPage::InitializeScheduleAgent()
{
    HRESULT hr;
    LPUNKNOWN lpUnk;
    m_pISyncSchedMgr = NULL;
    
    hr = CoCreateInstance(CLSID_SyncMgr,NULL,CLSCTX_INPROC_SERVER,
        IID_ISyncScheduleMgr,(void **) &lpUnk);
    
    if (NOERROR == hr)
    {
        hr = lpUnk->QueryInterface(IID_ISyncScheduleMgr,
            (void **) &m_pISyncSchedMgr);
        
        lpUnk->Release();
    }
    
    return hr;
    
}

//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CSchedSyncPage::ShowAllSchedules()
//
//  PURPOSE: initialization for the schedsync page
//
//  RETURN VALUE: return TRUE if we process it ok.
//
//+-------------------------------------------------------------------------------

BOOL CSchedSyncPage::ShowAllSchedules()
{
    HRESULT hr;
    BOOL fResult = FALSE;
    IEnumSyncSchedules *pEnum = NULL;
    int iItem = -1;
    DWORD dwFetched;
    HWND hwndListView = GetDlgItem(m_hwnd,IDC_SCHEDLIST);
    SYNCSCHEDULECOOKIE SyncScheduleCookie;
    
    
    if (!m_pISyncSchedMgr || !hwndListView)
    {
        goto errRtn;
    }
    
    //First clear out the list
    FreeAllSchedules();
    ListView_DeleteAllItems(hwndListView);
    
    if (FAILED(hr = m_pISyncSchedMgr->EnumSyncSchedules(&pEnum)))
    {
        goto errRtn;
    }
    
    while(S_OK == pEnum->Next(1,&SyncScheduleCookie, &dwFetched))
    {
        ISyncSchedule *pISyncSched; 
        WCHAR pwszName[MAX_PATH + 1];
        DWORD cchName = ARRAYSIZE(pwszName);
        LV_ITEM lvItem;
        
        //get the ISyncSched for this schedule
        if (FAILED(hr = m_pISyncSchedMgr->OpenSchedule(&SyncScheduleCookie, 
            0,&pISyncSched)))
        {
            //can't find this one in the registry - move on.
            continue;
        }
        //Get and convert the schedules friendly name
        if (FAILED(hr = pISyncSched->GetScheduleName(&cchName,pwszName)))
        {
            goto errRtn;
        }
        
        ++iItem;
        ZeroMemory(&lvItem, sizeof(lvItem));
        
        lvItem.mask = LVIF_TEXT | LVIF_PARAM;
        lvItem.pszText = pwszName;
        
        if (m_iDefaultIconImageIndex >= 0)
        {
            lvItem.mask |= LVIF_IMAGE;
            lvItem.iImage = m_iDefaultIconImageIndex;
        }
        
        //Save the ISyncSched pointer in the list view data
        lvItem.lParam = (LPARAM)pISyncSched;
        
        //add the item to the list
        ListView_InsertItem(hwndListView, &lvItem);
    }
    
    if (iItem != -1)
    {
        ListView_SetItemState(hwndListView, 0, 
            LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED );      
    }
    
    fResult = TRUE;
    
errRtn:
    
    if (pEnum)
    {
        pEnum->Release();
    }
    
    return fResult;
    
}
//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CSchedSyncPage::FreeAllSchedules()
//
//  PURPOSE: free the schedules for the schedsync page
//
//  RETURN VALUE: return TRUE if we process it ok.
//
//+-------------------------------------------------------------------------------

BOOL CSchedSyncPage::FreeAllSchedules()
{
    int iItem;
    int iItemCount;
    
    HWND hwndListView = GetDlgItem(m_hwnd,IDC_SCHEDLIST);
    
    iItemCount = ListView_GetItemCount(hwndListView);       
    
    for(iItem = 0; iItem < iItemCount; iItem++)
    {
        ISyncSchedule *pISyncSched; 
        LV_ITEM lvItem;
        
        ZeroMemory(&lvItem, sizeof(lvItem));
        lvItem.mask = LVIF_PARAM;
        lvItem.iItem = iItem;
        
        ListView_GetItem(hwndListView, &lvItem);                
        
        pISyncSched = (ISyncSchedule *) lvItem.lParam;
        
        if (pISyncSched)
        {
            DWORD cRefs;
            
            cRefs = pISyncSched->Release();
            Assert(0 == cRefs);
        }
    }
    return TRUE;
}


//-----------------------------------------------------------------------------
//
//  FUNCTION:   CSchedSyncPage::OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr)
//
//  PURPOSE:    Handle the various notification messages dispatched from schedule
//              page
//
//-----------------------------------------------------------------------------
BOOL CSchedSyncPage::OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr)
{
    if (IDC_SCHEDLIST == idFrom)
    {
        switch (pnmhdr->code)
        {
        case LVN_ITEMCHANGED:
            {
                NM_LISTVIEW *pnmv = (NM_LISTVIEW FAR *) pnmhdr; 
                
                if (  (pnmv->uChanged == LVIF_STATE)  &&
                    ((pnmv->uNewState ^ pnmv->uOldState) & LVIS_SELECTED))
                {
                    BOOL fEnable = FALSE;
                    
                    if (pnmv->uNewState & LVIS_SELECTED)
                    {
                        fEnable = TRUE;
                    }
                    
                    SetButtonState(IDC_SCHEDREMOVE,fEnable);
                    SetButtonState(IDC_SCHEDEDIT,fEnable);
                    return TRUE;
                }                       
            }
            break;
        case NM_DBLCLK:
            {
                LPNMLISTVIEW lpnmlv = (LPNMLISTVIEW) pnmhdr;
                EditTask(lpnmlv->iItem);
            }
            break;
        case NM_RETURN:
            {
                LPNMLISTVIEW lpnmlv = (LPNMLISTVIEW) pnmhdr;
                EditTask(lpnmlv->iItem);
            }
            
            break;
        default:
            break;
        }
    }
    return FALSE;
}

BOOL CSchedSyncPage::SetButtonState(int nIDDlgItem,BOOL fEnabled)
{
    BOOL fResult = FALSE;
    HWND hwndCtrl = GetDlgItem(m_hwnd,nIDDlgItem);
    HWND hwndFocus = NULL;
    
    if (hwndCtrl)
    {
        if (!fEnabled) // don't bother getting focus if not disabling.
        {
            hwndFocus = GetFocus();
        }
        
        fResult = EnableWindow(GetDlgItem(m_hwnd,nIDDlgItem),fEnabled);
        
        // if control had the focus. and now it doesn't then tab to the 
        // next control
        if (hwndFocus == hwndCtrl
            && !fEnabled)
        {
            SetFocus(GetDlgItem(m_hwnd,IDC_SCHEDADD));  // if need to change focus set to add.
        }
        
    }
    
    return fResult;
}


BOOL  CSchedSyncPage::OnCommand(HWND hDlg, WORD wNotifyCode, WORD wID, HWND hwndCtl)
{
    BOOL bResult = FALSE;
    
    if (BN_CLICKED == wNotifyCode) // allrespond to clicked 
    {
        
        switch (wID)
        {
        case  IDC_SCHEDADD:
            {
                StartScheduleWizard();
                
                HWND hwndList = GetDlgItem(hDlg, IDC_SCHEDLIST);
                
                BOOL fEnable = ListView_GetSelectedCount(hwndList)? TRUE: FALSE;
                
                SetButtonState(IDC_SCHEDEDIT,fEnable);
                SetButtonState(IDC_SCHEDREMOVE,fEnable);
                
            }
            break;
        case  IDC_SCHEDREMOVE:
            {
                HWND hwndList = GetDlgItem(hDlg, IDC_SCHEDLIST);
                int iItem = ListView_GetSelectionMark(hwndList);
                RemoveTask(iItem);
                
                BOOL fEnable = ListView_GetSelectedCount(hwndList)? TRUE: FALSE;
                
                SetButtonState(IDC_SCHEDEDIT,fEnable);
                SetButtonState(IDC_SCHEDREMOVE,fEnable);
                
            }
            break;
        case  IDC_SCHEDEDIT:
            {
                HWND hwndList = GetDlgItem(hDlg, IDC_SCHEDLIST);
                int iItem = ListView_GetSelectionMark(hwndList);
                EditTask(iItem);    
                
                BOOL fEnable = ListView_GetSelectedCount(hwndList)? TRUE: FALSE;
                
                SetButtonState(IDC_SCHEDEDIT,fEnable);
                SetButtonState(IDC_SCHEDREMOVE,fEnable);
                
            }
            break;
        default:
            break;
        }
    }
    
    return bResult;
    
}


//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CSchedSyncPage::EditTask(int iItem)
//
//  PURPOSE: edits the selected task
//
//  RETURN VALUE: return TRUE if we process it ok.
//
//+-------------------------------------------------------------------------------
BOOL CSchedSyncPage::EditTask(int iItem)
{
    LV_ITEM lvItem;
    WCHAR pwszScheduleName[MAX_PATH + 1];
    DWORD cchScheduleName = ARRAYSIZE(pwszScheduleName);
    
    ZeroMemory(&lvItem, sizeof(lvItem));
    
    lvItem.mask = LVIF_PARAM;
    lvItem.iItem = iItem;
    
    ListView_GetItem(GetDlgItem(m_hwnd, IDC_SCHEDLIST), &lvItem);
    
    if (lvItem.iItem != -1)
    {   
        ISyncSchedule *pISyncSched = (ISyncSchedule *) lvItem.lParam;
        //Start on the scheduled items page
        pISyncSched->EditSyncSchedule(m_hwnd, 0);
        
        pISyncSched->GetScheduleName(&cchScheduleName, pwszScheduleName);
        
        ListView_SetItemText( GetDlgItem(m_hwnd,IDC_SCHEDLIST), iItem, 0,pwszScheduleName);
    }
    
    return TRUE;
}

//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CSchedSyncPage::RemoveTask(int iItem)
//
//  PURPOSE: removes the selected task
//
//  RETURN VALUE: return TRUE if we process it ok.
//
//+-------------------------------------------------------------------------------

// Review - Why can't we just alloc what we need instead of eating up the stack.
BOOL CSchedSyncPage::RemoveTask(int iItem)
{
    TCHAR ptszScheduleName[MAX_PATH + 1];
    WCHAR pwszScheduleName[MAX_PATH + 1];
    TCHAR szFmt[MAX_PATH];
    TCHAR szTitle[MAX_PATH];
    TCHAR szStr[MAX_PATH];
    SYNCSCHEDULECOOKIE SyncSchedCookie;
    DWORD cchScheduleName = ARRAYSIZE(pwszScheduleName);
    
    if  (!m_pISyncSchedMgr)
    {
        return FALSE;
    }
    
    LV_ITEM lvItem;
    ZeroMemory(&lvItem, sizeof(lvItem));
    
    lvItem.mask = LVIF_PARAM;
    lvItem.iItem = iItem;
    
    ListView_GetItem(GetDlgItem(m_hwnd, IDC_SCHEDLIST), &lvItem);
    
    if (lvItem.iItem == -1)
    {
        return FALSE;
    }
    
    
    ISyncSchedule *pISyncSched = (ISyncSchedule *) lvItem.lParam;
    
    if (NULL == pISyncSched)
    {
        return FALSE;
    }
    
    
    if (NOERROR != pISyncSched->GetScheduleName(&cchScheduleName,pwszScheduleName))
    {
        *ptszScheduleName = TEXT('\0');
    }
    else
    {
        if (FAILED(StringCchCopy(ptszScheduleName, ARRAYSIZE(ptszScheduleName), pwszScheduleName)))
        {
            return FALSE;
        }
    }
    
    // make sure user really wants to delete this schedule
    LoadString(g_hmodThisDll, IDS_CONFIRMSCHEDDELETE_TITLE, szTitle, ARRAYLEN(szTitle));
    LoadString(g_hmodThisDll, IDS_CONFIRMSCHEDDELETE_TEXT, szFmt, ARRAYLEN(szFmt));

    StringCchPrintf(szStr, ARRAYSIZE(szStr), szFmt, ptszScheduleName); // truncation fine, this is for display
    
    if (IDNO == MessageBox(m_hwnd,szStr,szTitle,MB_YESNO | MB_ICONQUESTION))
    {
        return FALSE;
    }
            
    cchScheduleName = ARRAYSIZE(ptszScheduleName);
    
    //Get the Cookie from the schedule
    if (FAILED(((LPSYNCSCHEDULE)pISyncSched)->GetScheduleGUIDName
                    (&cchScheduleName,ptszScheduleName)))
    {
        return FALSE;
    }
    
    ptszScheduleName[GUIDSTR_MAX] = NULL;
    if (FAILED(StringCchCopy(pwszScheduleName,ARRAYSIZE(pwszScheduleName), ptszScheduleName)))
    {
        return FALSE;
    }
    GUIDFromString(pwszScheduleName, &SyncSchedCookie);
    
    
    //release this pISyncSched
    pISyncSched->Release();
    
    m_pISyncSchedMgr->RemoveSchedule(&SyncSchedCookie);
    
    HWND hwndList = GetDlgItem(m_hwnd, IDC_SCHEDLIST);
    
    ListView_DeleteItem(hwndList, iItem);
    UpdateWindow(hwndList);
    
    
    return TRUE;
}


//+-------------------------------------------------------------------------------
//
//  FUNCTION: StartScheduleWizard(HINSTANCE hinst)
//
//  PURPOSE:  Display the Onestop schedsync wizard
//
//
//--------------------------------------------------------------------------------
BOOL CSchedSyncPage::StartScheduleWizard()
{
    BOOL fRet = FALSE;
    ISyncSchedule *pISyncSched = NULL;
    SYNCSCHEDULECOOKIE SyncSchedCookie = GUID_NULL;
    
    if (m_pISyncSchedMgr &&
        S_OK == m_pISyncSchedMgr->LaunchScheduleWizard(
                                                       m_hwnd, 
                                                       0,
                                                       &SyncSchedCookie,       
                                                       &pISyncSched))
    {
        TCHAR ptszBuf[MAX_PATH + 1];
        WCHAR pwszName[MAX_PATH + 1];
        DWORD cchName = ARRAYSIZE(pwszName);
        LV_ITEM lvItem;
        
        if (SUCCEEDED(pISyncSched->GetScheduleName(&cchName, pwszName)) &&
            SUCCEEDED(StringCchCopy(ptszBuf, ARRAYSIZE(ptszBuf), pwszName)))
        {
            ZeroMemory(&lvItem, sizeof(lvItem));
            
            lvItem.mask = LVIF_TEXT | LVIF_PARAM;
            lvItem.pszText = ptszBuf;
            
            if (m_iDefaultIconImageIndex >= 0)
            {
                lvItem.mask |= LVIF_IMAGE;
                lvItem.iImage = m_iDefaultIconImageIndex;
            }
            
            //Save the ISyncSched pointer in the list view data
            lvItem.lParam = (LPARAM)pISyncSched;
            
            //add the item to the list
            ListView_InsertItem(GetDlgItem(m_hwnd,IDC_SCHEDLIST), &lvItem);
            
            fRet = TRUE;
        }
        else
        {
            pISyncSched->Release();
        }
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\dll\schedif.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       schedif.cpp
//
//  Contents:   interfaces for synchronization scheduling
//
//  Interfaces: IEnumSyncSchedules
//              ISyncSchedule
//              IEnumSyncItems
//  
//  Classes:    CEnumSyncSchedules
//              CSyncSchedule
//              CEnumSyncItems
//
//  Notes:      
//
//  History:    27-Feb-98   Susia      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"
#include <assert.h>

extern UINT      g_cRefThisDll; 


extern HINSTANCE g_hmodThisDll; // Handle to this DLL itself.
DWORD StartScheduler();
BOOL IsFriendlyNameInUse(LPTSTR ptszScheduleGUIDName, UINT cchScheduleGUIDName, LPCTSTR ptstrFriendlyName);

//+--------------------------------------------------------------
//
//  Class:     CEnumSyncSchedules
//
//  FUNCTION: CEnumSyncSchedules::CEnumSyncSchedules()
//
//  PURPOSE: Constructor
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
CEnumSyncSchedules::CEnumSyncSchedules(IEnumWorkItems *pIEnumWorkItems, 
                                       ITaskScheduler *pITaskScheduler)
{
    TRACE("CEnumSyncSchedules::CEnumSyncSchedules()\r\n");
    m_cRef = 1;
    ++g_cRefThisDll;

    m_pIEnumWorkItems = pIEnumWorkItems;
    m_pITaskScheduler = pITaskScheduler;
    
    m_pITaskScheduler->AddRef();
    m_pIEnumWorkItems->AddRef();

}

//+--------------------------------------------------------------
//
//  Class:     CEnumSyncSchedules
//
//  FUNCTION: CEnumSyncSchedules::~CEnumSyncSchedules()
//
//  PURPOSE: Destructor
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
CEnumSyncSchedules::~CEnumSyncSchedules()
{
    TRACE("CEnumSyncSchedules::~CEnumSyncSchedules()\r\n");
 
    m_pITaskScheduler->Release();
    m_pIEnumWorkItems->Release();

    --g_cRefThisDll;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CEnumSyncSchedules::QueryInterface(REFIID riid, LPVOID FAR *ppv)
//
//  PURPOSE: QI for the enumerator
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CEnumSyncSchedules::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
    {
        TRACE("CEnumSyncSchedules::QueryInterface()==>IID_IUknown\r\n");
        *ppv = (LPUNKNOWN)this;
    }
    else if (IsEqualIID(riid, IID_IEnumSyncSchedules))
    {
        TRACE("CSyncScheduleMgr::QueryInterface()==>IID_IEnumSyncSchedules\r\n");
        *ppv = (LPENUMSYNCSCHEDULES) this;
    }
    if (*ppv)
    {
        AddRef();
        return NOERROR;
    }

    TRACE("CEnumSyncSchedules::QueryInterface()==>Unknown Interface!\r\n");
    return E_NOINTERFACE;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CEnumSyncSchedules::AddRef()
//
//  PURPOSE: Addref for the enumerator
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CEnumSyncSchedules::AddRef()
{
    TRACE("CEnumSyncSchedules::AddRef()\r\n");
    return ++m_cRef;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CEnumSyncSchedules::Release()
//
//  PURPOSE: Release for the enumerator
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CEnumSyncSchedules::Release()
{
    TRACE("CEnumSyncSchedules::Release()\r\n");
    if (--m_cRef)
        return m_cRef;

    delete this;
    return 0L;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION:  CEnumSyncSchedules::Next(ULONG celt, 
//                  SYNCSCHEDULECOOKIE *pSyncSchedCookie,
//                  ULONG *pceltFetched)
//
//  PURPOSE:  Next sync Schedule 
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CEnumSyncSchedules::Next(ULONG celt, 
                    SYNCSCHEDULECOOKIE *pSyncSchedCookie,
                    ULONG *pceltFetched)
{
    SCODE sc;
    LPWSTR *pwszSchedNames;

    ULONG ulSyncCount = 0, ulTaskCount = 0;
    ULONG ulFetched;

    Assert(m_pIEnumWorkItems);

    if ((0 == celt) || 
        ((celt > 1) && (NULL == pceltFetched)) ||
        (NULL == pSyncSchedCookie))
    {
        return E_INVALIDARG;
    }

    //We may have to call Next multiple times, as we must filter out non-sync schedules.
    do 
    {
        ulTaskCount = 0;
        
        if (FAILED (sc = m_pIEnumWorkItems->Next(celt - ulSyncCount, 
                      &pwszSchedNames, &ulFetched)))
    {
        return sc;
    }
    if (ulFetched == 0)
    {
        break;
    }
    while (ulTaskCount < ulFetched)
    {
        //IsSyncMgrSched will blow away turds
            if (  IsSyncMgrSched(pwszSchedNames[ulTaskCount]) )
            {   
                if  (!IsSyncMgrSchedHidden(pwszSchedNames[ulTaskCount]) )
                {   
                    pwszSchedNames[ulTaskCount][GUIDSTR_MAX] = NULL;
                    GUIDFromString(pwszSchedNames[ulTaskCount], &(pSyncSchedCookie[ulSyncCount]));
                    ulSyncCount++;
                }
            }
            //Free this TaskName, we are done with it.
        CoTaskMemFree(pwszSchedNames[ulTaskCount]);
        ulTaskCount++;
    }
        
    CoTaskMemFree(pwszSchedNames);
    
    } while (ulFetched && (ulSyncCount < celt));
    
    if (pceltFetched)
    {
        *pceltFetched = ulSyncCount;
    }
    if (ulSyncCount == celt)
    {
        return S_OK;
    }
    return S_FALSE; 
}   


//--------------------------------------------------------------------------------
//
//  FUNCTION: CEnumSyncSchedules::Skip(ULONG celt)
//
//  PURPOSE:  skip celt sync schedules
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CEnumSyncSchedules::Skip(ULONG celt)
{
    SCODE sc;
    LPWSTR *pwszSchedNames;

    ULONG ulSyncCount = 0, ulTaskCount = 0;
    ULONG ulFetched;

    Assert(m_pIEnumWorkItems);
    
    //We have to call Next, rather than wrap Skip, because we need the schedule name to 
    //determine if it is ours or not.
    //We may have to call Next multiple times, as we must filter out non-sync schedules.
    do 
    {
    ulTaskCount = 0;
    if (S_OK != (sc = m_pIEnumWorkItems->Next(celt - ulSyncCount, 
                                      &pwszSchedNames, &ulFetched)))
    {
        return sc;
    }
    while (ulTaskCount < ulFetched)
    {
            //IsSyncMgrSched will blow away turds
            if (  IsSyncMgrSched(pwszSchedNames[ulTaskCount]) )
            {
                if (!IsSyncMgrSchedHidden(pwszSchedNames[ulTaskCount]) )
            {   
            ulSyncCount++;
            }
            }
            //Free this TaskName, we are done with it.
        FREE(pwszSchedNames[ulTaskCount]);
        ulTaskCount++;
    }
        
    FREE(pwszSchedNames);
    
    } while (ulFetched && (ulSyncCount < celt));    
    
    return S_OK;    
}   

//--------------------------------------------------------------------------------
//
//  FUNCTION: CEnumSyncSchedules::Reset(void)
//
//  PURPOSE: reset the enumerator
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CEnumSyncSchedules::Reset(void)
{
    Assert(m_pIEnumWorkItems);
    
    return m_pIEnumWorkItems->Reset();
    
}   

//--------------------------------------------------------------------------------
//
//  FUNCTION: CEnumSyncSchedules::Clone(IEnumSyncSchedules **ppEnumSyncSchedules)
//
//  PURPOSE: Clone the enumerator
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CEnumSyncSchedules::Clone(IEnumSyncSchedules **ppEnumSyncSchedules)
{
    SCODE sc;
    IEnumWorkItems *pIEnumWorkItems;
    
    if (!ppEnumSyncSchedules)
    {
        return E_INVALIDARG;
    }
    Assert(m_pIEnumWorkItems);


    if (FAILED(sc = m_pIEnumWorkItems->Clone(&pIEnumWorkItems)))
    {
        return sc;
    }

    *ppEnumSyncSchedules =  new CEnumSyncSchedules(pIEnumWorkItems, m_pITaskScheduler);

    if (!ppEnumSyncSchedules)
    {
        return E_OUTOFMEMORY;   
    }

    //Constructor AddRefed it, we release it here.
    pIEnumWorkItems->Release();
    return S_OK;
}   

//--------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CEnumSyncSchedules::VerifyScheduleSID(LPCWSTR pwstrTaskName)
//
//  PURPOSE: determine if this schedule SID matches the current user SID
//          !!!Warning - This functions deletes the .job file so make sure
//                  if you call this function you validated the Task .job file
//                  was created by SyncMgr. Should change this so caller needs to
//                  delete
//
//  History:  15-Oct-98       susia        Created.
//
//--------------------------------------------------------------------------------
BOOL CEnumSyncSchedules::VerifyScheduleSID(LPCWSTR pwstrTaskName)
{
    TCHAR ptszTaskName[MAX_PATH + 1],
          ptszTextualSidUser[MAX_PATH + 1],
          ptszTextualSidSched[MAX_PATH + 1];
    
    if (!GetUserTextualSid(ptszTextualSidUser, ARRAYSIZE(ptszTextualSidUser)) ||
        FAILED(StringCchCopy(ptszTaskName, ARRAYSIZE(ptszTaskName), pwstrTaskName)))
    {
        return FALSE;
    }
        
    //Truncate off the .job extension of the schedule name
    int iTaskNameLen = lstrlen(ptszTaskName);

    if (iTaskNameLen < 4)
    {
        return FALSE;
    }
    ptszTaskName[iTaskNameLen -4] = TEXT('\0');

    //Get the SID for this schedule from the registry
    //If this fails the key didn't exist 
    if (!RegGetSIDForSchedule(ptszTextualSidSched, ARRAYSIZE(ptszTextualSidSched), ptszTaskName) ||
        //If this fails the key exists but has the wrong SID    
        lstrcmp(ptszTextualSidSched, ptszTextualSidUser))
    {
    
        //Try to remove the schedule
        if (FAILED(m_pITaskScheduler->Delete(pwstrTaskName)))
        {
            //pwstrTaskName should have the .job extension for this function
            RemoveScheduledJobFile((TCHAR *)pwstrTaskName);
        }
        
        //Remove our Registry settings for this schedule
        //Note this should not have the .job extension
        RegRemoveScheduledTask(ptszTaskName);

        return FALSE;
    }

    return TRUE;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CEnumSyncSchedules::CheckForTaskNameKey(LPCWSTR pwstrTaskName)
//
//  PURPOSE: check for a corresponging key for the .job
//          !!!Warning - This functions deletes the .job file so make sure
//                  if you call this function you validated the Task .job file
//                  was created by SyncMgr. Should change this so caller needs to
//                  delete

//
//  History:  21-Dec-98       susia        Created.
//
//--------------------------------------------------------------------------------
BOOL CEnumSyncSchedules::CheckForTaskNameKey(LPCWSTR pwstrTaskName)
{
    HKEY hkeySchedSync,hkeyDomainUser,hkeySchedName;
    LONG lRegResult;
    TCHAR ptszTaskName[MAX_SCHEDULENAMESIZE + 5];

    hkeySchedSync = hkeyDomainUser = hkeySchedName = NULL;

    if (!pwstrTaskName)
    {
        Assert(pwstrTaskName);
        return FALSE;
    }
    
    if (FAILED(StringCchCopy(ptszTaskName, ARRAYSIZE(ptszTaskName), pwstrTaskName)))
    {
        return FALSE;
    }

    int iTaskNameLen = lstrlen(ptszTaskName);

    if (iTaskNameLen < 4)
    {
    AssertSz (0, "Schedule name is too short");
        return FALSE;
    }

    ptszTaskName[iTaskNameLen -4] = TEXT('\0');


    // validate this is a valid schedule and if no registry data for 
    // it then delete the .job file. 
    // Get the UserName key from the TaskName itself since on NT schedules
    // can fire if User provided as Password as a different user thant the 
    // current user.

    //Idle GUID is the same UNICODE lenght as all GUID strings.
    int OffsetToUserName = wcslen(WSZGUID_IDLESCHEDULE)
                    + 1; // +1 for _ char between guid and user name.

    TCHAR *pszDomainAndUser = (TCHAR *) ptszTaskName + OffsetToUserName;
    
    // can't call standard function for getting since DomainName is from
    // the task, if fails its okay
    lRegResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,SCHEDSYNC_REGKEY,0,KEY_READ, &hkeySchedSync);

    if (ERROR_SUCCESS == lRegResult)
    {
        lRegResult = RegOpenKeyEx (hkeySchedSync,pszDomainAndUser,0,KEY_READ, &hkeyDomainUser);
    }

    if (ERROR_SUCCESS == lRegResult)
    {
        lRegResult = RegOpenKeyEx (hkeyDomainUser,ptszTaskName,0,KEY_READ, &hkeySchedName);
    }

    // close up the keys
    if (hkeySchedName) RegCloseKey(hkeySchedName);
    if (hkeyDomainUser) RegCloseKey(hkeyDomainUser);
    if (hkeySchedSync) RegCloseKey(hkeySchedSync);

    // if any of the keys are bad then nix the TS file and return;
    if ( ERROR_FILE_NOT_FOUND  == lRegResult)
    {
       //Try to remove the schedule
        if (FAILED(m_pITaskScheduler->Delete(pwstrTaskName)))
        {
            //pwstrTaskName should have the .job extension for this function
            RemoveScheduledJobFile((TCHAR *)pwstrTaskName);
        }
        
        return FALSE;
    }
    else 
    {    
        return TRUE;
    }
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CEnumSyncSchedules::IsSyncMgrSched(LPCWSTR pwstrTaskName)
//
//  PURPOSE: determine if this schedule is a SyncSched
//
//  History:  03-Mar-98       susia        Created.
//
//--------------------------------------------------------------------------------
BOOL CEnumSyncSchedules::IsSyncMgrSched(LPCWSTR pwstrTaskName)
{
    TCHAR pszDomainAndUser[MAX_DOMANDANDMACHINENAMESIZE];
    WCHAR pwszDomainAndUser[MAX_DOMANDANDMACHINENAMESIZE];
    
    Assert(m_pITaskScheduler);

    // First let's make sure our address arithmetic 
    // doesn't push us off the string
    if (lstrlen(pwstrTaskName) <= GUIDSTR_MAX)
    {
        return FALSE;
    }

        //Now make sure this was created by CREATOR_SYNCMGR_TASK.
    ITask *pITask;
    LPWSTR pwszCreator;

    if (FAILED(m_pITaskScheduler->Activate(pwstrTaskName,
                               IID_ITask,
                           (IUnknown **)&pITask)))
    {
        return FALSE;
    }
    if (FAILED(pITask->GetCreator(&pwszCreator)))
    {
        pITask->Release();
        return FALSE;
    }
    
    if (0 != lstrcmp(pwszCreator, CREATOR_SYNCMGR_TASK))
    {
        CoTaskMemFree(pwszCreator);
        pITask->Release();
        return FALSE;
    }

    CoTaskMemFree(pwszCreator);
    pITask->Release();  

    //Blow away the .job if there is no reg entry for it.
    // so remember to make sure this schedule was created by us before
    // calling
    if (!CheckForTaskNameKey(pwstrTaskName))
    {
        return FALSE;
    }
    GetDefaultDomainAndUserName(pszDomainAndUser,TEXT("_"), ARRAYSIZE(pszDomainAndUser));
    if (FAILED(StringCchCopy(pwszDomainAndUser, ARRAYSIZE(pwszDomainAndUser), pszDomainAndUser)))
    {
        return FALSE;
    }

    //Get the Domain and User name
    if (0 != wcsncmp(&(pwstrTaskName[GUIDSTR_MAX +1]),pwszDomainAndUser,lstrlen(pwszDomainAndUser)))
    {
        return FALSE;
    }
    
    //Ok the name looks right for this user.
    //Let's make sure the SID matches as well.
    //on Win9X the SID should be the empty string
    // !! this removes the .job file and regKeys if the sid doesn't match
    if (!VerifyScheduleSID(pwstrTaskName))
    {
        return FALSE;
    }
                
   
    
    return TRUE;

}   


//--------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CEnumSyncSchedules::IsSyncMgrSchedHidden(LPCWSTR pwstrTaskName)
//
//  PURPOSE: determine if this schedule is a hidden
//
//  History:  16-Mar-98       susia        Created.
//
//--------------------------------------------------------------------------------
BOOL CEnumSyncSchedules::IsSyncMgrSchedHidden(LPCWSTR pwstrTaskName)
{
    SCODE   sc;
    HKEY    hKeyUser;
    DWORD   dwHidden = FALSE;
    DWORD   cbDataSize = sizeof(dwHidden);
    int     iTaskNameLen;
    int     i = 0;
    TCHAR   ptstrRegName[MAX_PATH + 1];
    TCHAR   ptstrNewName[MAX_PATH + 1];


    if (FAILED(StringCchCopy(ptstrNewName, ARRAYSIZE(ptstrNewName), pwstrTaskName)))
    {
        return FALSE;
    }

    //Truncate off the .job extension of the schedule name
    iTaskNameLen = lstrlen(ptstrNewName);

    if (iTaskNameLen < 4)
    {
        return FALSE;
    }
    ptstrNewName[iTaskNameLen -4] = TEXT('\0');

    hKeyUser = RegGetCurrentUserKey(SYNCTYPE_SCHEDULED,KEY_READ,FALSE);

    if (NULL == hKeyUser)
    {
        return FALSE;
    }

    do 
    {   
    sc = RegEnumKey( hKeyUser, i++, ptstrRegName, MAX_PATH);
    
        //This is the schedule
    if (0 == lstrcmp(ptstrRegName,ptstrNewName))
        {
                break;
        }       
    } while (sc == S_OK);

    //we couldn't find the schedule
    if (sc != S_OK)
    {    
        RegCloseKey(hKeyUser);
        return FALSE; 
    }

    //schedule found, get the hidden flag
    if (ERROR_SUCCESS != SHRegGetValue(hKeyUser, ptstrRegName,TEXT("ScheduleHidden"), SRRF_RT_REG_DWORD, NULL, 
                                       (LPBYTE) &dwHidden, &cbDataSize))
    {
        dwHidden = 0;
    }

    RegCloseKey(hKeyUser);

    if (dwHidden)
    {
        return TRUE;
    }

    return FALSE;
}

//+------------------------------------------------------------------------------
//
//  Class:     CSyncSchedule
//
//
//  FUNCTION: CSyncSchedule::CSyncSchedule()
//
//  PURPOSE:  CSyncSchedule constructor
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
CSyncSchedule::CSyncSchedule(ITask *pITask)
{
    TRACE("CSyncSchedule::CSyncSchedule()\r\n");
    ++g_cRefThisDll;

    m_cRef = 1;
    m_HndlrQueue = NULL;
    m_fCleanReg = FALSE;

    m_pITask = pITask;
    m_pITask->AddRef();

    m_iTrigger = 0;
    m_pITrigger = NULL;
    m_fNewSchedule = FALSE;
    m_pFirstCacheEntry = NULL;
}

//+------------------------------------------------------------------------------
//
//  Class:     CSyncSchedule
//
//
//  FUNCTION: CSyncSchedule::~CSyncSchedule()
//
//  PURPOSE:  CSyncSchedule destructor
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
CSyncSchedule::~CSyncSchedule()
{
    TRACE("CSyncSchedule::~CSyncSchedule()\r\n");

    if (m_pITask)
    {
    m_pITask->Release();
    }
    if (m_pITrigger)
    {
        m_pITrigger->Release();
    }

     --g_cRefThisDll;
}

//+------------------------------------------------------------------------------
//
//  Class:     CSyncSchedule
//
//
//  FUNCTION: CSyncSchedule::SetDefaultCredentials()
//
//  PURPOSE:  CSyncSchedule credential intialization
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
SCODE CSyncSchedule::SetDefaultCredentials()
{

    SCODE sc = S_OK;
    
    //Set the default credentials   
    WCHAR pwszDomainAndUserName[MAX_DOMANDANDMACHINENAMESIZE];

    GetDefaultDomainAndUserName(pwszDomainAndUserName, TEXT("\\"), ARRAYSIZE(pwszDomainAndUserName));
        
    
    if (FAILED(sc = m_pITask->SetFlags(TASK_FLAG_RUN_ONLY_IF_LOGGED_ON)))
    {
        return sc;
    }
    if (FAILED(sc = m_pITask->SetAccountInformation(pwszDomainAndUserName,NULL)))
    {
        return sc;
    }
    return sc;
}

//+------------------------------------------------------------------------------
//
//  Class:     CSyncSchedule
//
//
//  FUNCTION: CSyncSchedule::Initialize(LPTSTR ptstrGUIDName, LPTSTR ptstrFriendlyName)
//
//  PURPOSE:  CSyncSchedule intialization
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
SCODE CSyncSchedule::Initialize(LPTSTR ptstrGUIDName, LPTSTR ptstrFriendlyName)
{
    SCODE sc;
    
    sc = StringCchCopy(m_ptstrGUIDName, ARRAYSIZE(m_ptstrGUIDName), ptstrGUIDName);
    if (SUCCEEDED(sc))
    {
        sc = StringCchCopy(m_pwszFriendlyName, ARRAYSIZE(m_pwszFriendlyName), ptstrFriendlyName);
        if (SUCCEEDED(sc))
        {
            TRACE("CSyncSchedule::Initialize()\r\n");
    
            Assert(m_pITask);

            // Form the application name/path and command line params.
            //initialize the syncmgr application name
            TCHAR ptszFileName[MAX_PATH + 1];
            WCHAR pwszAppName[MAX_PATH + 1];
            WCHAR pwszSchedName[MAX_PATH + 1];

            LoadString(g_hmodThisDll, IDS_SYNCMGR_EXE_NAME, ptszFileName, ARRAYSIZE(ptszFileName));
            sc = StringCchCopy(pwszAppName, ARRAYSIZE(pwszAppName), ptszFileName);
            if (SUCCEEDED(sc))
            {
                sc = StringCchCopy(pwszSchedName, ARRAYSIZE(pwszSchedName), m_ptstrGUIDName);
                if (SUCCEEDED(sc))
                {

                    m_pITask->SetApplicationName(pwszAppName);

                    sc = StringCchPrintf(pwszAppName, ARRAYSIZE(pwszAppName), 
                                         TEXT("%s\"%s\""), // put quotes to handle friendly names
                                         SCHED_COMMAND_LINE_ARG, pwszSchedName);
                    if (SUCCEEDED(sc))
                    {
                        sc = m_pITask->SetParameters(pwszAppName);
                        if (SUCCEEDED(sc))
                        {
                            // Specify the creator name.  SyncMGr uses this to identify syncmgr tasks
                            sc = m_pITask->SetCreator(CREATOR_SYNCMGR_TASK);
                            if (SUCCEEDED(sc))
                            {

                                //Set up the Trigger
                                WORD wTriggerCount;
                                sc = m_pITask->GetTriggerCount(&wTriggerCount);
                                if (SUCCEEDED(sc))
                                {
                                    if (wTriggerCount == 0)
                                    {
                                        sc = m_pITask->CreateTrigger(&m_iTrigger, &m_pITrigger);
                                    }
                                    else
                                    {
                                        sc = m_pITask->GetTrigger(m_iTrigger, &m_pITrigger);
                                    }

                                    if (SUCCEEDED(sc))
                                    {
                                        //Create a new connectionSettings for this schedule and hand off to the handler queue
                                        // who will free it
                                        m_pConnectionSettings = (LPCONNECTIONSETTINGS) 
                                                        ALLOC(sizeof(*m_pConnectionSettings));

                                        if (!m_pConnectionSettings)
                                        { 
                                            sc = E_OUTOFMEMORY;
                                        }
                                        else
                                        {    
                                            // If the connection name isn't in the registry, we know this is a new schedule.
                                            // We set the name to the default connection name and return FALSE if it wasn't there,
                                            // True if it was located in the registry
                                            if (!RegGetSchedConnectionName(m_ptstrGUIDName, 
                                                                           m_pConnectionSettings->pszConnectionName, 
                                                                           MAX_PATH))
                                            {
                                                m_fNewSchedule = TRUE;
                                            }

                                            //this set defaults before quering registry, so if it can't read the reg,
                                            //we will just get defaults.
                                            RegGetSchedSyncSettings(m_pConnectionSettings, m_ptstrGUIDName);

                                            //Save the Connection name and type on this obj
                                            sc = StringCchCopy(m_pwszConnectionName, 
                                                               ARRAYSIZE(m_pwszConnectionName), 
                                                               m_pConnectionSettings->pszConnectionName);
                                            if (SUCCEEDED(sc))
                                            {
                                                m_dwConnType = m_pConnectionSettings->dwConnType;

                                                if (!m_HndlrQueue)
                                                {
                                                    m_HndlrQueue = new CHndlrQueue(QUEUETYPE_SETTINGS); 
                                                    if (!m_HndlrQueue) 
                                                    {
                                                        sc = E_OUTOFMEMORY;
                                                    }
                                                    else
                                                    {
                                                        sc = m_HndlrQueue->Init();
                                                        if (FAILED(sc))
                                                        {
                                                            m_HndlrQueue->Release();
                                                            m_HndlrQueue = NULL;
                                                        }
                                                        else
                                                        {                    
                                                            sc = m_HndlrQueue->InitSchedSyncSettings(m_pConnectionSettings);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    return sc;  
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::LoadOneHandler(REFCLSID pHandlerID)
//
//  PURPOSE:  Initialize and load this handler
//
//  History:  9-Oct-98       susia        Created.
//
//--------------------------------------------------------------------------------
SCODE CSyncSchedule::LoadOneHandler(REFCLSID pHandlerID)
{
    SCODE sc = NOERROR;
    WORD wHandlerID;

    Assert(m_HndlrQueue);
         
    if (NOERROR == (sc = m_HndlrQueue->AddHandler(pHandlerID, &wHandlerID)))
    {
        if (FAILED(sc = m_HndlrQueue->CreateServer(wHandlerID,&pHandlerID)))
        {
            return sc;
        }
        // Initialize the handlers. 
    // If the Handler doesn't want to play on this schedule, remove him.
    if (S_FALSE == m_HndlrQueue->Initialize(wHandlerID,0,SYNCMGRFLAG_SETTINGS,0,NULL))
    {
        m_HndlrQueue->RemoveHandler(wHandlerID);
        return SYNCMGR_E_HANDLER_NOT_LOADED;

        }
        
        if (FAILED(sc = m_HndlrQueue->AddHandlerItemsToQueue(wHandlerID)))
        {
            return sc;
        }
        //this set defaults before quering registry, so if it can't read the reg,
        //we will just get defaults.
        m_HndlrQueue->ReadSchedSyncSettingsOnConnection(wHandlerID, m_ptstrGUIDName);

        //Apply all the cached changed to the newly loaded handler
        ApplyCachedItemsCheckState(pHandlerID);

        //Clear out the list of changes to this handler's items
        PurgeCachedItemsCheckState(pHandlerID);

    }
    if (sc == S_FALSE)
    {
        return S_OK;
    }   
    return sc;  

}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::LoadAllHandlers()
//
//  PURPOSE:  Initialize and load all the handlers
//
//  History:  6-Oct-98       susia        Created.
//
//--------------------------------------------------------------------------------
SCODE CSyncSchedule::LoadAllHandlers()
{
    SCODE sc = NOERROR;
    TCHAR lpName[MAX_PATH];
    HKEY hkSyncMgr;
    CLSID clsid;
    WORD wHandlerID;

    Assert(m_HndlrQueue);
    
    // loop through the reg getting the handlers and trying to 
    // create them.

    hkSyncMgr = RegGetHandlerTopLevelKey(KEY_READ);

    if (hkSyncMgr)
    {
        DWORD dwIndex = 0;

        // if loading all handlers and got handler key open then can clean
        // up old reg entries for this schedule
        m_fCleanReg = TRUE; 

        while ( ERROR_SUCCESS == RegEnumKey(hkSyncMgr,dwIndex,
                                            lpName,ARRAYSIZE(lpName)) )
        {
            if (NOERROR == CLSIDFromString(lpName,&clsid) )
            {
                if (NOERROR == m_HndlrQueue->AddHandler(clsid, &wHandlerID))
                {
                        HRESULT hrInit;

                            // Initialize the handlers. 
                            // If the Handler fails to create or 
                            // doesn't want to play on this schedule, remove him.
                           hrInit =  m_HndlrQueue->CreateServer(wHandlerID,&clsid);

                           if (NOERROR == hrInit)
                           {
                               hrInit = m_HndlrQueue->Initialize(wHandlerID,0
                                                        ,SYNCMGRFLAG_SETTINGS,0,NULL);
                           }

                   if (NOERROR != hrInit)
                           {
                    m_HndlrQueue->RemoveHandler(wHandlerID);
                   }
                }
            }
            dwIndex++;
        }
        RegCloseKey(hkSyncMgr);
    }

    // loop through adding items
    sc = m_HndlrQueue->FindFirstHandlerInState (HANDLERSTATE_ADDHANDLERTEMS,&wHandlerID);
    
    while (sc == S_OK)
    {
        //ignore failures here and move on.  Could be the handler just fails to addItems,
        //and we don't want to fail the whole load over that
        m_HndlrQueue->AddHandlerItemsToQueue(wHandlerID);
        
        //this set defaults before quering registry, so if it can't read the reg,
        //we will just get defaults.
        m_HndlrQueue->ReadSchedSyncSettingsOnConnection(wHandlerID, m_ptstrGUIDName);

        sc = m_HndlrQueue->FindNextHandlerInState(wHandlerID, 
                                                  HANDLERSTATE_ADDHANDLERTEMS, 
                                                  &wHandlerID);
    }
    //Apply all the chached changed to all the newly loaded handlers
    ApplyCachedItemsCheckState(GUID_NULL);
    //Clear out the list of changes to all handler items that occurred before loading
    PurgeCachedItemsCheckState(GUID_NULL);
    

    if (sc == S_FALSE)
    {
        return S_OK;
    }
    
    return sc;  

}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::CacheItemCheckState(REFCLSID phandlerID,
//                                               SYNCMGRITEMID itemID,
//                                               DWORD dwCheckState)
//
//  PURPOSE:  Cache the check state of an item for a handler that is not yet loaded
//
//  History:  12-02-98       susia        Created.
//
//--------------------------------------------------------------------------------
SCODE CSyncSchedule::CacheItemCheckState(REFCLSID phandlerID,
                                         SYNCMGRITEMID itemID,
                                         DWORD dwCheckState)
{
    CACHELIST *pCurCacheEntry = m_pFirstCacheEntry;

    while (pCurCacheEntry)
    {
        if ( (phandlerID == pCurCacheEntry->phandlerID) &&
             (itemID == pCurCacheEntry->itemID)            )
        {
            pCurCacheEntry->dwCheckState = dwCheckState;
            return S_OK;
        }
        pCurCacheEntry = pCurCacheEntry->pNext;
    }
    //Not found in the list, insert it now
    pCurCacheEntry = (CACHELIST *) ALLOC(sizeof(*pCurCacheEntry));
    
    if (NULL == pCurCacheEntry)
    {
        return E_OUTOFMEMORY;
    }
    
    ZeroMemory(pCurCacheEntry,sizeof(*pCurCacheEntry));
    
    pCurCacheEntry->phandlerID = phandlerID;
    pCurCacheEntry->itemID = itemID;
    pCurCacheEntry->dwCheckState = dwCheckState;

    pCurCacheEntry->pNext = m_pFirstCacheEntry;

    m_pFirstCacheEntry = pCurCacheEntry;

    return S_OK;

}
//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::RetreiveCachedItemCheckState(REFCLSID phandlerID,
//                                               SYNCMGRITEMID itemID,
//                                               DWORD *pdwCheckState)
//
//  PURPOSE:  Retreive the cached the check state (if any) of an item for 
//            a handler that is not yet loaded
//
//  History:  12-02-98       susia        Created.
//
//--------------------------------------------------------------------------------
SCODE CSyncSchedule::RetreiveCachedItemCheckState(REFCLSID phandlerID,
                                         SYNCMGRITEMID itemID,
                                         DWORD *pdwCheckState)
{
    CACHELIST *pCurCacheEntry = m_pFirstCacheEntry;

    while (pCurCacheEntry)
    {
        if ( (phandlerID == pCurCacheEntry->phandlerID) &&
             (itemID == pCurCacheEntry->itemID)            )
        {
            *pdwCheckState = pCurCacheEntry->dwCheckState;
            return S_OK;
        }
        pCurCacheEntry = pCurCacheEntry->pNext;
    }
    // no problem if we didn't find it, it has already been 
    // set to either what was in the registry, or if it wasn't in the registry,
    // to the default check state
    return S_OK;

}
//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::ApplyCachedItemsCheckState(REFCLSID pHandlerID)
//
//  PURPOSE:  Apply any check state changes that occurred before the handler was loaded
//
//  History:  12-02-98       susia        Created.
//
//--------------------------------------------------------------------------------
SCODE CSyncSchedule::ApplyCachedItemsCheckState(REFCLSID phandlerID)
{

    CACHELIST *pCurCacheEntry = m_pFirstCacheEntry;

    while (pCurCacheEntry)
    {
        if ( (phandlerID == pCurCacheEntry->phandlerID) ||
             (phandlerID == GUID_NULL)                     )
        {
            SetItemCheck( pCurCacheEntry->phandlerID,
              &pCurCacheEntry->itemID, 
                          pCurCacheEntry->dwCheckState);

        }
        pCurCacheEntry = pCurCacheEntry->pNext;
    }
    // no problem if we didn't find it, it has already been 
    // set to either what was in the registry, or if it wasn't in the registry,
    // to the default check state
    return S_OK;
    

}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::WriteOutAndPurgeCache()
//
//  PURPOSE:  If we never loaded the handlers before save, write the settings to the registry
//
//  History:  12-02-98       susia        Created.
//
//--------------------------------------------------------------------------------
SCODE CSyncSchedule::WriteOutAndPurgeCache(void)
{

    CACHELIST *pCurCacheEntry = m_pFirstCacheEntry;
    CACHELIST *pTemp;    

    while (pCurCacheEntry)
    {        
       RegSetSyncItemSettings(SYNCTYPE_SCHEDULED,
                               pCurCacheEntry->phandlerID,
                               pCurCacheEntry->itemID,
                               m_pwszConnectionName,
                               pCurCacheEntry->dwCheckState,
                               m_ptstrGUIDName);

        pTemp = pCurCacheEntry;
        pCurCacheEntry= pCurCacheEntry->pNext;
        FREE(pTemp);
        pTemp = NULL;
    }
    m_pFirstCacheEntry = NULL;

    return S_OK;
    

}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::PurgeCachedItemsCheckState(REFCLSID pHandlerID)
//
//  PURPOSE:  Free from the list any check state changes that occurred before the handler was loaded
//
//  History:  12-02-98       susia        Created.
//
//--------------------------------------------------------------------------------
SCODE CSyncSchedule::PurgeCachedItemsCheckState(REFCLSID phandlerID)
{
    CACHELIST StartNode;
    CACHELIST *pCur = NULL,
              *pPrev = &StartNode;

    pPrev->pNext = m_pFirstCacheEntry;

    while (pPrev->pNext)
    {
        pCur = pPrev->pNext;
    
        if ( (phandlerID == pCur->phandlerID) ||
             (phandlerID == GUID_NULL)                     )
        {
            pPrev->pNext = pCur->pNext;   
            FREE(pCur);
        }
        else
        {
            pPrev = pCur;
        }
    }
    m_pFirstCacheEntry = StartNode.pNext;

    return S_OK;

    

}
//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::QueryInterface(REFIID riid, LPVOID FAR *ppv)
//
//  PURPOSE:  QI
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncSchedule::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
    {
        TRACE("CSyncSchedule::QueryInterface()==>IID_IUknown\r\n");
        *ppv = (LPUNKNOWN)this;
    }
    else if (IsEqualIID(riid, IID_ISyncSchedule))
    {
        TRACE("CSyncSchedule::QueryInterface()==>IID_ISyncSchedule\r\n");
        *ppv = (LPSYNCSCHEDULE) this;
    }
    else if (IsEqualIID(riid, IID_ISyncSchedulep))
    {
        TRACE("CSyncSchedule::QueryInterface()==>IID_ISyncSchedulep\r\n");
        *ppv = (LPSYNCSCHEDULEP) this;
    }
    if (*ppv)
    {
        AddRef();
        return NOERROR;
    }

    TRACE("CSyncSchedule::QueryInterface()==>Unknown Interface!\r\n");
    return E_NOINTERFACE;
}
//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::AddRef()
//
//  PURPOSE:  AddRef
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSyncSchedule::AddRef()
{
    TRACE("CSyncSchedule::AddRef()\r\n");
    if (m_HndlrQueue)
    m_HndlrQueue->AddRef();

    return ++m_cRef;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::Release()
//
//  PURPOSE:  Release
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSyncSchedule::Release()
{
    TRACE("CSyncSchedule::Release()\r\n");

    if (m_HndlrQueue)
    m_HndlrQueue->Release();

    if (--m_cRef)
        return m_cRef;

    delete this;
    return 0L;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::GetFlags(DWORD *pdwFlags)
//
//  PURPOSE:  Get the flags for this schedule
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncSchedule::GetFlags(DWORD *pdwFlags)
{
    if (!pdwFlags)
    {
        return E_INVALIDARG;
    }
    *pdwFlags = 0;

    Assert(m_HndlrQueue);
    
    if (m_HndlrQueue->GetCheck(IDC_AUTOHIDDEN, 0))
    {
    *pdwFlags |= SYNCSCHEDINFO_FLAGS_HIDDEN;
    }
    if (m_HndlrQueue->GetCheck(IDC_AUTOREADONLY, 0))
    {
        *pdwFlags |= SYNCSCHEDINFO_FLAGS_READONLY;
    }
    if (m_HndlrQueue->GetCheck(IDC_AUTOCONNECT, 0))
    {
    *pdwFlags |= SYNCSCHEDINFO_FLAGS_AUTOCONNECT;
    }

    return S_OK;    
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::SetFlags(DWORD dwFlags)
//
//  PURPOSE: Set the flags for this schedule  
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncSchedule::SetFlags(DWORD dwFlags)
{
    SCODE sc;

    Assert(m_HndlrQueue);
    
    if (FAILED(sc = m_HndlrQueue->SetConnectionCheck(IDC_AUTOREADONLY,
                    (dwFlags & SYNCSCHEDINFO_FLAGS_READONLY) ? TRUE : FALSE, 0)))
    {       
    return sc;
    }

    if (FAILED (sc = m_HndlrQueue->SetConnectionCheck(IDC_AUTOHIDDEN,
                    (dwFlags & SYNCSCHEDINFO_FLAGS_HIDDEN) ? TRUE : FALSE, 0)))
    {       
    return sc;
    }

    sc = m_HndlrQueue->SetConnectionCheck(IDC_AUTOCONNECT,
                        (dwFlags & SYNCSCHEDINFO_FLAGS_AUTOCONNECT) ? TRUE : FALSE,0);
    
    return sc;

}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::GetConnection(DWORD *pcchConnectionName,
//                                         LPWSTR pwszConnectionName,
//                                         DWORD *pdwConnType)
//
//  PURPOSE:  Get the connection name for this schedule
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncSchedule::GetConnection(DWORD *pcchConnectionName,
                                          LPWSTR pwszConnectionName,
                                          DWORD *pdwConnType)
{
    HRESULT hr;
    if (!pcchConnectionName || !pwszConnectionName || !pdwConnType)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = StringCchCopy(pwszConnectionName, *pcchConnectionName, m_pwszConnectionName);
        if (FAILED(hr))
        {
            *pcchConnectionName = lstrlen(m_pwszConnectionName) + 1;
        }
    }

    if (SUCCEEDED(hr))
    {
        *pdwConnType = m_dwConnType;
    }

    return hr;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION:  CSyncSchedule::SetConnection(LPCWSTR pwszConnectionName, DWORD dwConnType)
//
//  PURPOSE:  Set the connection for this schedule
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncSchedule::SetConnection(LPCWSTR pwszConnectionName, DWORD dwConnType)
{
    SCODE sc;

    if (((dwConnType == SYNCSCHEDINFO_FLAGS_CONNECTION_WAN) && (!pwszConnectionName)) ||
         ((dwConnType != SYNCSCHEDINFO_FLAGS_CONNECTION_WAN) &&
      (dwConnType != SYNCSCHEDINFO_FLAGS_CONNECTION_LAN)   )  )
    {
        sc = E_INVALIDARG;
    } 
    else 
    {
        if (!m_fNewSchedule)
        {
            if (FAILED(sc = LoadAllHandlers()))
                return sc;
        }

        if (pwszConnectionName && (lstrlen(pwszConnectionName) > MAX_PATH))
        {
            return E_INVALIDARG;
        }

        m_dwConnType = dwConnType;
    
        if (!pwszConnectionName)
        {
           LoadString(g_hmodThisDll, IDS_LAN_CONNECTION, m_pwszConnectionName,ARRAYSIZE(m_pwszConnectionName));

           sc = S_OK;
        }
        else
        {   
            sc = StringCchCopy(m_pwszConnectionName, ARRAYSIZE(m_pwszConnectionName), pwszConnectionName);
        }
    }
    
    return sc;  
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::GetScheduleName(DWORD *pcchScheduleName,
//                                           LPWSTR pwszScheduleName)
//
//  PURPOSE:  Get the friendly name for this schedule
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncSchedule::GetScheduleName(DWORD *pcchScheduleName,
                                            LPWSTR pwszScheduleName)
{
    HRESULT hr;
    if (!pcchScheduleName || !pwszScheduleName)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = StringCchCopy(pwszScheduleName, *pcchScheduleName, m_pwszFriendlyName);
        if (FAILED(hr))
        {
            *pcchScheduleName = lstrlen(m_pwszFriendlyName) + 1;
        }
    }

    return hr;  
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::SetScheduleName(LPCWSTR pwszScheduleName)
//
//  PURPOSE:  Set the friendly name for this schedule
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncSchedule::SetScheduleName(LPCWSTR pwszScheduleName)
{
    HRESULT hr;
    TCHAR ptszFriendlyName[MAX_PATH+1];
    TCHAR ptszScheduleName[MAX_PATH+1];
    TCHAR *ptszWorker = NULL;
    WCHAR *pwszWorker = NULL;
    int iName;
    DWORD dwSize = MAX_PATH;



    if (!pwszScheduleName || lstrlen(pwszScheduleName) > MAX_PATH)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = StringCchCopy(ptszFriendlyName, ARRAYSIZE(ptszFriendlyName), pwszScheduleName);
        if (SUCCEEDED(hr))
        {
    
            //strip trailing white space off name
            iName = lstrlen(ptszFriendlyName);

            if (iName)
            {
                ptszWorker = iName + ptszFriendlyName -1;
            }

            while (iName && (*ptszWorker == TEXT(' ')))
            {
                *ptszWorker = TEXT('\0');
                    --ptszWorker;
                iName--;
            }
            //don't allow empty string schedule names
            if (iName == 0)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
            }
            else
            {
                hr = StringCchCopy(ptszScheduleName, ARRAYSIZE(ptszScheduleName), m_ptstrGUIDName);
                if (SUCCEEDED(hr))
                {
    
                    if (IsFriendlyNameInUse(ptszScheduleName, ARRAYSIZE(ptszScheduleName), ptszFriendlyName) &&
                        0 != lstrcmp(ptszScheduleName, m_ptstrGUIDName)) //make sure it is in use by this schedule
                    {
                        hr = SYNCMGR_E_NAME_IN_USE;
                    }
                    else
                    {
                        // only copy up to first leading space
                        hr = StringCchCopy(m_pwszFriendlyName, 
                                           __min(iName + 1, ARRAYSIZE(m_pwszFriendlyName)), 
                                           pwszScheduleName);
                        pwszWorker = m_pwszFriendlyName + iName;
                        *pwszWorker = TEXT('\0');
                        hr = S_OK;
                    }
                }
            }
        }
    }
    return hr;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::GetScheduleCookie(SYNCSCHEDULECOOKIE *pSyncSchedCookie)
//
//  PURPOSE:  Set the schedule cookie
//
//  History:  14-Mar-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncSchedule::GetScheduleCookie(SYNCSCHEDULECOOKIE *pSyncSchedCookie)
{
    HRESULT hr;
    WCHAR pwszSchedName[MAX_PATH +1];

    if (!pSyncSchedCookie)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = StringCchCopy(pwszSchedName, ARRAYSIZE(pwszSchedName), m_ptstrGUIDName);
        if (SUCCEEDED(hr))
        {
            pwszSchedName[GUIDSTR_MAX] = NULL;
            GUIDFromString(pwszSchedName, pSyncSchedCookie);
            hr = S_OK;
        }
    }
    
    return hr;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::SetAccountInformation(LPCWSTR pwszAccountName,
//                      LPCWSTR pwszPassword)
//
//  PURPOSE: Set the credentials for this schedule 
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncSchedule::SetAccountInformation(LPCWSTR pwszAccountName,
                        LPCWSTR pwszPassword)
{
    Assert(m_pITask);
    return m_pITask->SetAccountInformation(pwszAccountName, pwszPassword);
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::GetAccountInformation(DWORD *pcchAccountName,
//                                                 LPWSTR pwszAccountName)
//
//  PURPOSE:  Get the credentials for this schedule
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncSchedule::GetAccountInformation(DWORD *pcchAccountName,
                                                  LPWSTR pwszAccountName)
{
    Assert(m_pITask);
    SCODE sc;

    WCHAR *pwszAccount;

    if (!pcchAccountName || !pwszAccountName)
    {
        sc = E_INVALIDARG;
    }
    else
    {
        sc = m_pITask->GetAccountInformation(&pwszAccount);
        if (SUCCEEDED(sc))
        {            
            sc = StringCchCopy(pwszAccountName, *pcchAccountName, pwszAccount);
            if (FAILED(sc))
            {
                *pcchAccountName = lstrlen(pwszAccount) + 1;
            }
            
            CoTaskMemFree(pwszAccount);
        }
    }

    return sc;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::GetTrigger(ITaskTrigger ** ppTrigger)
//
//  PURPOSE: Return the ITaskTrigger interface for this schedule
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncSchedule::GetTrigger(ITaskTrigger ** ppTrigger)
{
    SCODE sc = S_OK;

    Assert(m_pITask);
    Assert (m_pITrigger);

    if (!ppTrigger)
    {
    return E_INVALIDARG;
    }

    *ppTrigger = m_pITrigger;
    m_pITrigger->AddRef();

    return sc;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION:  CSyncSchedule::GetNextRunTime(SYSTEMTIME * pstNextRun)
//
//  PURPOSE:  return the next time this schedule will run
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncSchedule::GetNextRunTime(SYSTEMTIME * pstNextRun)
{
    Assert(m_pITask);
    return m_pITask->GetNextRunTime(pstNextRun);
}

//--------------------------------------------------------------------------------
//
//  FUNCTION:  CSyncSchedule::GetMostRecentRunTime(SYSTEMTIME * pstRecentRun)
//
//  PURPOSE:  return the last time this schedule ran 
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncSchedule::GetMostRecentRunTime(SYSTEMTIME * pstRecentRun)
{
    Assert(m_pITask);
    return m_pITask->GetMostRecentRunTime(pstRecentRun);

}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::EditSyncSchedule(HWND  hParent,
//                      DWORD dwReserved)
//
//  PURPOSE:  Launch the propery sheets for this schedule
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncSchedule::EditSyncSchedule(HWND  hParent,
                         DWORD dwReserved)
{
    SCODE sc;
    IProvideTaskPage * pIProvideTaskPage;
    PROPSHEETHEADER    PropSheetHdr;
    HPROPSHEETPAGE    *psp;
    int iCurPage = 0;
    int iNumPages = 2;
    INT_PTR iRet;
    BOOL fReadOnlySchedule;
    BOOL fSavedItems = FALSE;
    BOOL fSavedCredentials = FALSE;
    
    WCHAR pwszScheduleName[MAX_PATH + 1];
    TCHAR ptszScheduleName[MAX_PATH + 1];
    DWORD dwSize = MAX_PATH;

    CSelectItemsPage *pItemsPage = NULL;
#ifdef _CREDENTIALS
    CCredentialsPage *pCredentialsPage = NULL;
#endif // _CREDENTIALS

    CWizPage *pSchedPage = NULL;

    Assert (m_HndlrQueue);

    if (FAILED(sc = StartScheduler()))
    {
    return sc;
    }

    fReadOnlySchedule = m_HndlrQueue->GetCheck(IDC_AUTOREADONLY, 0);
    
    if (!fReadOnlySchedule)
    {   
    //AutoAdd new items if the schedule is not ReadOnly
    iNumPages = 4;
    }

#ifdef _CREDENTIALS
    iNumPages++;
#endif // #ifdef _CREDENTIALS

    psp = (HPROPSHEETPAGE *) ALLOC(iNumPages*sizeof(*psp));

    if (!psp)
    {
        return E_OUTOFMEMORY;
    }

    ZeroMemory(psp,iNumPages*sizeof(*psp));
    ZeroMemory(&PropSheetHdr,sizeof(PropSheetHdr));

    smMemTo(EH_Err1, pSchedPage = new CEditSchedPage(g_hmodThisDll, 
                                this, 
                            &psp[iCurPage]));
        
    smMemTo(EH_Err2, pItemsPage = new CSelectItemsPage(g_hmodThisDll, 
                            &fSavedItems,
                            this, 
                            &psp[++iCurPage], 
                            IDD_SCHEDPAGE_ITEMS));
            
    if (!fReadOnlySchedule)
    {   
        // Obtain the IProvideTaskPage interface from the task object.
        smChkTo(EH_Err3, m_pITask->QueryInterface( IID_IProvideTaskPage,
                            (VOID **)&pIProvideTaskPage));
        
        smChkTo(EH_Err4, pIProvideTaskPage->GetPage(TASKPAGE_SCHEDULE, TRUE, 
                                                        &psp[++iCurPage]));
    
        smChkTo(EH_Err4, pIProvideTaskPage->GetPage(TASKPAGE_SETTINGS, TRUE, 
                                                        &psp[++iCurPage]));
    }
    
#ifdef _CREDENTIALS
    smMemTo(EH_Err4, pCredentialsPage = new CCredentialsPage(g_hmodThisDll,
                            &fSavedCredentials, 
                                    this, 
                            &psp[++iCurPage]));

#endif // #ifdef _CREDENTIALS
                
    
    GetScheduleName(&dwSize, pwszScheduleName);
    smChkTo(EH_Err5, StringCchCopy(ptszScheduleName,ARRAYSIZE(ptszScheduleName), pwszScheduleName));
    
    PropSheetHdr.dwSize     = sizeof(PROPSHEETHEADER);
    PropSheetHdr.dwFlags    = PSH_DEFAULT;
    PropSheetHdr.hwndParent = hParent;
    PropSheetHdr.hInstance  = NULL;
    PropSheetHdr.pszCaption = ptszScheduleName;
    PropSheetHdr.phpage     = psp;
    PropSheetHdr.nPages     = iNumPages;
    PropSheetHdr.nStartPage = 0;

    iRet = PropertySheet(&PropSheetHdr);
    
    if ((iRet > 0) && (fSavedItems || fSavedCredentials))
    {
        //  Changes were made
        sc = S_OK;
    }
    else if (iRet >= 0)
    {
        //  The user hit OK or Cancel but
        //  nothing was changed
    sc = S_FALSE;
    }
    else
    {
        //  play taps...
        sc = E_FAIL;
    }

EH_Err5:
#ifdef _CREDENTIALS
    if  (pCredentialsPage)
    {
        delete pCredentialsPage;
    }
#endif // #ifdef _CREDENTIALS

EH_Err4:
    if (!fReadOnlySchedule)
    {   
    pIProvideTaskPage->Release();   
    }
EH_Err3:
    delete pItemsPage;
EH_Err2:
    delete pSchedPage;  
EH_Err1:
    FREE(psp);
    return sc;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::AddItem(LPSYNC_HANDLER_ITEM_INFO pHandlerItemInfo);
//
//  PURPOSE:  Add a handler item to the schedule  
//
//  History:  27-Feb-98        susia        Created.
//             9-Oct-98        susia        Added delay loading of handler
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncSchedule::AddItem(LPSYNC_HANDLER_ITEM_INFO pHandlerItemInfo)
{
    SCODE sc = NOERROR;

    if (!pHandlerItemInfo)
    {
    return E_INVALIDARG;
    }
    sc = m_HndlrQueue->AddHandlerItem(pHandlerItemInfo);
    
    //if the handler is not yet loaded, just write through to the registry
    if (sc == SYNCMGR_E_HANDLER_NOT_LOADED)
    {
       sc = CacheItemCheckState(pHandlerItemInfo->handlerID,
                           pHandlerItemInfo->itemID,
                           pHandlerItemInfo->dwCheckState);
    }
    
    return sc;

}

STDMETHODIMP CSyncSchedule::RegisterItems( REFCLSID pHandlerID,
                                    SYNCMGRITEMID *pItemID)
{
    //eliminated because unused and overly complicated
    return E_NOTIMPL;
}

STDMETHODIMP CSyncSchedule::UnregisterItems( REFCLSID pHandlerID,
                                      SYNCMGRITEMID *pItemID)
{
    //eliminated because unused and overly complicated
    return E_NOTIMPL;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::SetItemCheck(REFGUID pHandlerID,
//                      SYNCMGRITEMID *pItemID, DWORD dwCheckState)
//
//  PURPOSE:  Set the Item CheckState
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncSchedule::SetItemCheck(REFCLSID pHandlerID,
                     SYNCMGRITEMID *pItemID, DWORD dwCheckState)
{
    SCODE sc = NOERROR;

    if ((!pItemID) || (pHandlerID == GUID_NULL))
    {
    return E_INVALIDARG;
    }   
    sc = m_HndlrQueue->SetItemCheck(pHandlerID,pItemID, dwCheckState);

    if (sc == SYNCMGR_E_HANDLER_NOT_LOADED)
    {
       sc = CacheItemCheckState(pHandlerID,
                           *pItemID,
                           dwCheckState);

    }
    
    return sc;

}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::GetItemCheck(REFCLSID pHandlerID,
//                  SYNCMGRITEMID *pItemID, DWORD *pdwCheckState);
//
//  PURPOSE:  Set the Item CheckState
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncSchedule::GetItemCheck(REFCLSID pHandlerID,
                    SYNCMGRITEMID *pItemID, DWORD *pdwCheckState)
{
    SCODE sc = NOERROR;

    if ((!pItemID) || (pHandlerID == GUID_NULL) || (!pdwCheckState))
    {
        return E_INVALIDARG;
    }
    sc = m_HndlrQueue->GetItemCheck(pHandlerID, pItemID, pdwCheckState);
    
    if (sc == SYNCMGR_E_HANDLER_NOT_LOADED)
    {
       TCHAR pszConnectionName[RAS_MaxEntryName + 1];
       
       sc = StringCchCopy(pszConnectionName, ARRAYSIZE(pszConnectionName), m_pwszConnectionName);
       if (SUCCEEDED(sc))
       {      
           //if we fail setting this in the registry, ignore it and move on.
           // we will lose this item settings.
           RegGetSyncItemSettings(SYNCTYPE_SCHEDULED,
                                   pHandlerID,
                                   *pItemID,
                                   pszConnectionName,
                                   pdwCheckState,
                                   FALSE,
                                   m_ptstrGUIDName);
       
           //Now check if there have been any changes to the check state
           sc = RetreiveCachedItemCheckState(pHandlerID,
                                        *pItemID,
                                        pdwCheckState);
       }
    }

    return sc;
}


//+------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::Save()
//
//  PURPOSE:  CSyncSchedule save, commits the sync schedule.
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncSchedule::Save()
{
    HRESULT hr;
    TRACE("CSyncSchedule::Save()\r\n");

    TCHAR ptszConnectionName[RAS_MaxEntryName + 1];
    TCHAR ptszScheduleName[MAX_PATH + 1];
    TCHAR ptszFriendlyName[MAX_PATH + 1];
    WCHAR *pwszScheduleName;

    Assert(m_pITask);

    //protect the Save path in a mutex
    CMutex  CMutexSchedule(NULL, FALSE,SZ_SCHEDULEMUTEXNAME);
    CMutexSchedule.Enter();

    hr = StringCchCopy(ptszFriendlyName, ARRAYSIZE(ptszFriendlyName), m_pwszFriendlyName);
    if (SUCCEEDED(hr))
    {
        hr = StringCchCopy(ptszScheduleName, ARRAYSIZE(ptszScheduleName), m_ptstrGUIDName);
        if (SUCCEEDED(hr))
        {
            if (IsFriendlyNameInUse(ptszScheduleName, ARRAYSIZE(ptszScheduleName), ptszFriendlyName) &&
                0 != lstrcmp(ptszScheduleName, m_ptstrGUIDName)) //make sure it is in use by this schedule
            {
                hr = SYNCMGR_E_NAME_IN_USE;
            }
            else
            {
                //Save the schedule to a file
                IPersistFile *pIPersistFile;
                
                hr = m_pITask->QueryInterface(IID_IPersistFile, (VOID **)&pIPersistFile);            
                if (SUCCEEDED(hr))
                {
                    //Save the settings for this schedule in the registry
                    // todo: ADD code to back out the reg writing if for
                    // some reason TS fails.

                    hr = StringCchCopy(ptszConnectionName, ARRAYSIZE(ptszConnectionName), m_pwszConnectionName);
                    if (SUCCEEDED(hr))
                    {
                        if (m_HndlrQueue)
                        {
                            hr = m_HndlrQueue->CommitSchedSyncChanges(m_ptstrGUIDName,
                                                                      ptszFriendlyName,
                                                                      ptszConnectionName,
                                                                      m_dwConnType,
                                                                      m_fCleanReg);
                        }
                        
                        //if we never loaded the handler, then save the cached info to the reg.
                        WriteOutAndPurgeCache();

                        RegRegisterForScheduledTasks(TRUE);

                        if (FAILED(hr) || (FAILED(hr = pIPersistFile->Save(NULL, FALSE))))
                        {
                            // if failed save clear out the registry. 
                            RegRemoveScheduledTask(m_ptstrGUIDName);
                        }
                        else
                        {
                            //Now set the file attributes to hidden so we won't show up in the normal TS UI.
                            hr = pIPersistFile->GetCurFile(&pwszScheduleName);
                            if (SUCCEEDED(hr))
                            {
                                if (!SetFileAttributes(pwszScheduleName, FILE_ATTRIBUTE_HIDDEN))
                                {
                                    DWORD dwErr = GetLastError();                                    
                                    hr = HRESULT_FROM_WIN32(dwErr);
                                }
                                else
                                {
                                    hr = S_OK;
                                }
                                CoTaskMemFree(pwszScheduleName);
                            }
                        }
                    }
                    pIPersistFile->Release();                
                }
            }
        }
    }
    CMutexSchedule.Leave();

    return hr;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::EnumItems(REFGUID pHandlerID,
//                      IEnumSyncItems  **ppEnumItems)
//
//  PURPOSE: Enumerate the handler items on this sync schedule   
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncSchedule::EnumItems(REFGUID pHandlerID,
                      IEnumSyncItems  **ppEnumItems)
{
    SCODE sc = S_OK;

    if (!ppEnumItems)
    {
    return E_INVALIDARG;
    }
    
    if (pHandlerID != GUID_NULL)
    {
        if (FAILED(sc = LoadOneHandler(pHandlerID)))
        {
            return sc;
        }
    }
    else if (FAILED(sc = LoadAllHandlers()))
    {
        return sc;
    }
        
    *ppEnumItems =  new CEnumSyncItems(pHandlerID, m_HndlrQueue);
    
    if (*ppEnumItems)
    {
    return S_OK;
    }
    return E_OUTOFMEMORY;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::GetITask(ITask ** ppITask)
//
//  PURPOSE: Return the ITask interface for this schedule
//
//  Notes: We really should have this private.
//
//  History:  15-Mar-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncSchedule::GetITask(ITask ** ppITask)
{
    Assert(m_pITask);

    *ppITask = m_pITask;
    m_pITask->AddRef();

    return S_OK;
}

//--------------------------------------------------------------------------------
//
//  member: CSyncSchedule::GetHandlerInfo, private
//
//  PURPOSE: returns handler infor for the item. Used so can display UI,
//
//
//  History:  11-Aug-98       rogerg        Created.
//
//-------------------------------------------------------------------------------

STDMETHODIMP CSyncSchedule::GetHandlerInfo(REFCLSID pHandlerID,LPSYNCMGRHANDLERINFO *ppSyncMgrHandlerInfo)
{
HRESULT hr = E_UNEXPECTED;
LPSYNCMGRHANDLERINFO pHandlerInfo = NULL;

    if (!ppSyncMgrHandlerInfo)
    {
        Assert(ppSyncMgrHandlerInfo);
        return E_INVALIDARG;
    }

    if (FAILED(hr = LoadOneHandler(pHandlerID)))
    {
        return hr;
    }

    if (pHandlerInfo = (LPSYNCMGRHANDLERINFO) CoTaskMemAlloc(sizeof(*pHandlerInfo)))
    {
        hr = m_HndlrQueue->GetHandlerInfo(pHandlerID,pHandlerInfo);
    }
   
    *ppSyncMgrHandlerInfo = (NOERROR == hr) ? pHandlerInfo : NULL;

    return hr;
}



//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::GetScheduleGUIDName(DWORD *pcchScheduleName,
//                                               LPTSTR ptszScheduleName)
//
//  PURPOSE:  Get the GUID name for this schedule
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
HRESULT  CSyncSchedule::GetScheduleGUIDName(DWORD *pcchScheduleName,
                                            LPTSTR ptszScheduleName)
{
    HRESULT hr;

    if (!pcchScheduleName || !ptszScheduleName)
    {
        hr = E_INVALIDARG;
    }
    else 
    {
        hr = StringCchCopy(ptszScheduleName, *pcchScheduleName, m_ptstrGUIDName);
        if (FAILED(hr))
        {
            *pcchScheduleName = lstrlen(m_ptstrGUIDName) + 1;
        }
    }

    return hr;
}

//+------------------------------------------------------------------------------
//
//  Class:     CEnumSyncItems
//
//  FUNCTION: CEnumSyncItems::CEnumSyncItems()
//
//  PURPOSE: Constructor
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
CEnumSyncItems::CEnumSyncItems(REFCLSID pHandlerId, CHndlrQueue *pHndlrQueue)
{
    TRACE("CEnumSyncItems::CEnumSyncItems()\r\n");
    
    ++g_cRefThisDll;

    Assert(pHndlrQueue);

    m_HndlrQueue = pHndlrQueue;
    m_HndlrQueue->AddRef();
    
    if (pHandlerId == GUID_NULL)
    {
        m_fAllHandlers = TRUE;
    }
    else
    {
        m_fAllHandlers = FALSE;
    }

    m_HndlrQueue->GetHandlerIDFromClsid(pHandlerId, &m_wHandlerId);

    m_HandlerId = pHandlerId;
    m_wItemId = 0;
    m_cRef = 1;
    
}

//+------------------------------------------------------------------------------
//
//  Class:     CEnumSyncItems
//
//  FUNCTION: CEnumSyncItems::~CEnumSyncItems()
//
//  PURPOSE: Destructor
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
CEnumSyncItems::~CEnumSyncItems()
{
    --g_cRefThisDll;

    Assert(0 == m_cRef);

    TRACE("CEnumSyncItems::CEnumSyncItems()\r\n");
}
//--------------------------------------------------------------------------------
//
//  FUNCTION: CEnumSyncItems::QueryInterface(REFIID riid, LPVOID FAR *ppv)
//
//  PURPOSE: QI for the enumerator
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------

STDMETHODIMP CEnumSyncItems::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
    {
        TRACE("CEnumSyncItems::QueryInterface()==>IID_IUknown\r\n");
        *ppv = (LPUNKNOWN)this;
    }
    else if (IsEqualIID(riid, IID_IEnumSyncItems))
    {
        TRACE("CSyncScheduleMgr::QueryInterface()==>IID_IEnumSyncItems\r\n");
        *ppv = (LPENUMSYNCITEMS) this;
    }
    if (*ppv)
    {
        AddRef();
        return NOERROR;
    }

    TRACE("CEnumSyncItems::QueryInterface()==>Unknown Interface!\r\n");
    return E_NOINTERFACE;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CEnumSyncItems::AddRef()
//
//  PURPOSE: Addref the enumerator
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CEnumSyncItems::AddRef()
{
    TRACE("CEnumSyncItems::AddRef()\r\n");
    m_HndlrQueue->AddRef();
    return ++m_cRef;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CEnumSyncItems::Release()
//
//  PURPOSE: Release the enumerator
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CEnumSyncItems::Release()
{
    TRACE("CEnumSyncItems::Release()\r\n");
    m_HndlrQueue->Release();
    if (--m_cRef)
        return m_cRef;

    delete this;
    return 0L;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CEnumSyncItems::Next(ULONG celt,
//                  LPSYNC_HANDLER_ITEM_INFO rgelt,
//                  ULONG * pceltFetched)
//
//  PURPOSE: Next handler item on this schedule
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CEnumSyncItems::Next(ULONG celt,
                    LPSYNC_HANDLER_ITEM_INFO rgelt,
                    ULONG * pceltFetched)
{
    
    SCODE sc;
    UINT i;
    GUID handlerID;
    SYNCMGRITEMID itemID;
    DWORD dwCheckState;
    Assert(m_HndlrQueue);

    if ((0 == celt) ||  
        ((celt > 1) && (NULL == pceltFetched)) ||
        (NULL == rgelt))
    {
        return E_INVALIDARG;
    }
    if (pceltFetched)
    {
        *pceltFetched = 0;
    }
    
    i = 0;

    while (i < celt)    
    {
        sc = m_HndlrQueue->FindNextItemOnConnection
                    (NULL,m_wHandlerId,m_wItemId,
                     &handlerID,&itemID,&m_wHandlerId,&m_wItemId, m_fAllHandlers, 
                 &dwCheckState);

        if (sc != S_OK)
        {
            break;
        }
            
        rgelt[i].handlerID = handlerID;
        rgelt[i].itemID = itemID;
        rgelt[i].dwCheckState = dwCheckState;
        m_HndlrQueue->GetItemIcon(m_wHandlerId, m_wItemId, &(rgelt[i].hIcon));
        sc = m_HndlrQueue->GetItemName(m_wHandlerId, m_wItemId, rgelt[i].wszItemName, ARRAYSIZE(rgelt[i].wszItemName));
        if (FAILED(sc))
        {
            break;
        }
                
        i++;        
    }
    
    if (SUCCEEDED(sc))
    {
        if (pceltFetched)
        {
            *pceltFetched = i;
        }
        if (i == celt)
        {
            return S_OK;
        }
        else
        {
            return S_FALSE;
        }
    }
    else
    {
        return sc;
    }
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CEnumSyncItems::Skip(ULONG celt)
//
//  PURPOSE: Skip celt items on this schedule
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CEnumSyncItems::Skip(ULONG celt)
{
    SCODE sc = S_OK;  // (celt == 0) results in Success.
    UINT i;
    GUID handlerID;
    SYNCMGRITEMID itemID;
    DWORD dwCheckState;

    Assert(m_HndlrQueue);

    i = 0;
    while (i< celt) 
    {
    sc = m_HndlrQueue->FindNextItemOnConnection
                        (NULL,m_wHandlerId,m_wItemId,
                     &handlerID,&itemID,&m_wHandlerId,&m_wItemId, m_fAllHandlers, 
                     &dwCheckState);
        if (sc != S_OK)
    {
        break;
    }
    i++;
    
    }
    if (SUCCEEDED(sc))
    {
    return S_OK;
    }
    else
    {
    return sc;
    }
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CEnumSyncItems::Reset(void)
//
//  PURPOSE: Reset the enumerator
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CEnumSyncItems::Reset(void)
{
    TRACE("CEnumSyncItems::Reset()\r\n");
    
    m_wItemId = 0;
    return m_HndlrQueue->GetHandlerIDFromClsid(m_HandlerId, &m_wHandlerId);
}


//--------------------------------------------------------------------------------
//
//  FUNCTION:  CEnumSyncItems::Clone(IEnumSyncItems ** ppEnumSyncItems)
//
//  PURPOSE: Clone the enumerator
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CEnumSyncItems::Clone(IEnumSyncItems ** ppEnumSyncItems)
{
    if (!ppEnumSyncItems)
    {
    return E_INVALIDARG;
    }
    
    *ppEnumSyncItems =  new CEnumSyncItems(m_HandlerId, m_HndlrQueue);
    
    if (!(*ppEnumSyncItems))
    {
    return E_OUTOFMEMORY;
    }
    
    return ((LPENUMSYNCITEMS) (*ppEnumSyncItems))->SetHandlerAndItem
                                                    (m_wHandlerId, m_wItemId);
}


//--------------------------------------------------------------------------------
//
//  FUNCTION:  CEnumSyncItems::SetHandlerAndItem(WORD wHandlerID, WORD wItemID)
//
//  PURPOSE: Used when Cloning the enumerator
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
SCODE CEnumSyncItems::SetHandlerAndItem(WORD wHandlerID, WORD wItemID)
{
    m_wHandlerId = wHandlerID;
    m_wItemId = wItemID;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\dll\settings.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       Settings.h
//
//  Contents:   Onestop Settings PropertyPage Dialog box classes
//
//  Classes:    CAutoSyncPage
//				CSchedSyncPage
//
//  Notes:
//
//  History:    14-Nov-97   SusiA      Created.
//
//--------------------------------------------------------------------------


#ifndef _SETTINGSDLG_
#define _SETTINGSDLG_

// definitions for Advnanced Idle Setting Spin Control
#define SPINDIALWAITMINUTES_MIN 1
#define SPINDIALWAITMINUTES_MAX 999

#define SPINDIALREPEATMINUTES_MIN 1
#define SPINDIALREPEATMINUTES_MAX 999

#define WM_NOTIFYLISTVIEWEX (WM_USER + 1)

//+-------------------------------------------------------------------------------
//
//  CLASS: CAutoSyncPage
//
//  PURPOSE:  Handle the AutoSync Psge
//
//--------------------------------------------------------------------------------


class CAutoSyncPage
{
public:
    inline CAutoSyncPage(HINSTANCE hinst);
    ~CAutoSyncPage();

    void SetAutoSyncHwnd(HWND hwnd);
    void SetIdleHwnd(HWND hwnd);
    BOOL InitializeHwnd(HWND hwnd,SYNCTYPE syncType,DWORD dwDefaultConnection);
    DWORD GetNumConnections(HWND hwnd,SYNCTYPE syncType);
    BOOL ShowItemsOnThisConnection(HWND hwnd,SYNCTYPE syncType,DWORD dwConnectionNum);
    BOOL SetItemCheckState(HWND hwnd,SYNCTYPE syncType,int iItem, BOOL fChecked,int iCheckCount);
    BOOL SetConnectionCheck(HWND hwnd,SYNCTYPE syncType,WORD wParam,DWORD dwCheckState);

    HRESULT GetAdvancedIdleSettings(LPCONNECTIONSETTINGS pConnectionSettings);
    HRESULT SetAdvancedIdleSettings(LPCONNECTIONSETTINGS pConnectionSettings);

    HRESULT ShowProperties(HWND hwnd,int iItem);


    SCODE CommitAutoSyncChanges();
    SCODE CommitIdleChanges();

private:
    BOOL InitializeHandler(HWND hwnd,SYNCTYPE SyncType);
    BOOL Initialize(HWND hwnd,DWORD dwDefaultConnection); // called to initialize the AutoSync page

    CHndlrQueue *m_HndlrQueue;
    HWND m_hwndAutoSync;
    HWND m_hwndIdle;
    CListView  *m_pItemListViewAutoSync;
    CListView  *m_pItemListViewIdle;
    BOOL m_pItemListViewAutoSyncInitialized;
    BOOL m_fListViewIdleInitialized;
    HINSTANCE m_hinst;
    CRasUI *m_pRas;
    BOOL m_fInitialized;
    BOOL m_fItemsOnConnection;

    friend INT_PTR CALLBACK AutoSyncDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
    friend INT_PTR CALLBACK IdleSyncDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
};

//+-------------------------------------------------------------------------------
//
//  CLASS: CSchedSyncPage
//
//  PURPOSE:  Handle the SchedSync Psge
//
//--------------------------------------------------------------------------------

class CSchedSyncPage
{
public:

	CSchedSyncPage(HINSTANCE hinst, HWND hwnd);
	~CSchedSyncPage();

        BOOL	Initialize();
	BOOL	ShowAllSchedules();
	BOOL	FreeAllSchedules();
	HRESULT InitializeScheduleAgent();
	BOOL	StartScheduleWizard();
	BOOL	EditTask(int iItem);
	BOOL	RemoveTask(int iItem);

        BOOL    OnCommand(HWND hDlg, WORD wNotifyCode, WORD wID, HWND hwndCtl);
	BOOL	OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr);
        BOOL SetButtonState(int nIDDlgItem,BOOL fEnabled);


private:
	HWND m_hwnd;
	HINSTANCE m_hinst;

	LPSYNCSCHEDULEMGR   m_pISyncSchedMgr;
        int m_iDefaultIconImageIndex;

	
};

//+-------------------------------------------------------------------------------
//
//  FUNCTION: CAutoSyncPage::CAutoSyncPage(HWND hwnd)
//
//  PURPOSE:  Constructor
//
//	COMMENTS: Constructor for AutoSync page
//
//--------------------------------------------------------------------------------
inline CAutoSyncPage::CAutoSyncPage(HINSTANCE hinst)
{
    m_hinst = hinst;
    m_HndlrQueue = NULL;
    m_fInitialized = FALSE;
    m_fItemsOnConnection = FALSE;

    m_hwndIdle = NULL;
    m_hwndAutoSync = NULL;

    m_pItemListViewAutoSync = NULL;
    m_pItemListViewIdle = NULL;
    m_pItemListViewAutoSyncInitialized = FALSE;
    m_fListViewIdleInitialized = FALSE;

}


//+-------------------------------------------------------------------------------
//
//  FUNCTION: CSchedSyncPage::CSchedSyncPage(HWND hwnd)
//
//  PURPOSE:  Constructor
//
//	COMMENTS: Constructor for SchedSync page
//
//--------------------------------------------------------------------------------
inline CSchedSyncPage::CSchedSyncPage(HINSTANCE hinst, HWND hwnd)
{
    m_hwnd = hwnd;
	m_hinst = hinst;
	m_pISyncSchedMgr = NULL;

}
//+-------------------------------------------------------------------------------
//
//  FUNCTION: CSchedSyncPage::~CSchedSyncPage(HWND hwnd)
//
//  PURPOSE:  Constructor
//
//	COMMENTS: Constructor for SchedSync page
//
//--------------------------------------------------------------------------------
inline CSchedSyncPage::~CSchedSyncPage()
{
	if (m_pISyncSchedMgr)
	{
		m_pISyncSchedMgr->Release();
	}
}


#endif // _SETTINGSDLG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\dll\schedif.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       schedif.h
//
//  Contents:   interfaces for synchronization scheduling
//
//  Interfaces: IEnumSyncSchedules
//              ISyncSchedule
//              IEnumSyncItems
//  
//  Classes:    CEnumSyncSchedules
//              CSyncSchedule
//              CEnumSyncItems
//
//  Notes:      
//
//  History:    27-Feb-98   Susia      Created.
//
//--------------------------------------------------------------------------
#ifndef _SYNCSCHED_IF_
#define _SYNCSCHED_IF_

#define MAX_SCHEDULENAMESIZE (GUID_SIZE + 1 + MAX_DOMANDANDMACHINENAMESIZE + 1)

//+--------------------------------------------------------------
//
//  Class:     CEnumSyncSchedules
//
//  History:    27-Feb-98       SusiA   Created
//
//---------------------------------------------------------------
class CEnumSyncSchedules : public IEnumSyncSchedules
{
public:
    CEnumSyncSchedules(IEnumWorkItems *pIEnumWorkItems, 
        ITaskScheduler *pITaskScheduler);
    ~CEnumSyncSchedules();
    
    //  IUnknown members
    STDMETHODIMP            QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();
    
    // IEnumSyncSchedules methods
    STDMETHODIMP Next(ULONG celt, 
        SYNCSCHEDULECOOKIE *pSyncSchedCookie,
        ULONG *pceltFetched);
    
    STDMETHODIMP Skip(ULONG celt);
    
    STDMETHODIMP Reset(void);
    
    STDMETHODIMP Clone(IEnumSyncSchedules **ppEnumSyncSchedules);
    
private:   
    ULONG m_cRef;
    IEnumWorkItems *m_pIEnumWorkItems;
    ITaskScheduler *m_pITaskScheduler;
    BOOL IsSyncMgrSched(LPCWSTR pwstrTaskName);
    BOOL IsSyncMgrSchedHidden(LPCWSTR pwstrTaskName);
    BOOL VerifyScheduleSID(LPCWSTR pwstrTaskName);
    BOOL CheckForTaskNameKey(LPCWSTR pwstrTaskName);
};
typedef CEnumSyncSchedules *LPENUMSYNCSCHEDULES;


typedef struct tagCACHELIST {
    struct tagCACHELIST *pNext;
    CLSID phandlerID;
    SYNCMGRITEMID itemID;
    DWORD dwCheckState;
} CACHELIST;


//+--------------------------------------------------------------
//
//  Class:     CSyncSchedule
//
//  History:    27-Feb-98       SusiA   Created
//
//---------------------------------------------------------------
class CSyncSchedule : public ISyncSchedulep
{
    
public:
    CSyncSchedule(ITask *pITask);        
    ~CSyncSchedule();
    
    
    //  IUnknown members
    STDMETHODIMP            QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();
    
    // ISyncSchedule methods
    STDMETHODIMP GetFlags(DWORD *pdwFlags);
    
    STDMETHODIMP SetFlags(DWORD dwFlags);
    
    STDMETHODIMP GetConnection(DWORD *pcchConnectionName,
        LPWSTR pwszConnectionName,
        DWORD *pdwConnType);
    
    STDMETHODIMP SetConnection(LPCWSTR pwszConnectionName,
        DWORD dwConnType);
    
    STDMETHODIMP GetScheduleName(DWORD *pcbSize,
        LPWSTR pwszScheduleName);
    
    STDMETHODIMP SetScheduleName(LPCWSTR pwszScheduleName);
    
    STDMETHODIMP GetScheduleCookie(SYNCSCHEDULECOOKIE *pSyncSchedCookie);
    
    STDMETHODIMP SetAccountInformation(LPCWSTR pwszAccountName,
        LPCWSTR pwszPassword);
    
    STDMETHODIMP GetAccountInformation(DWORD *pcbSize,
        LPWSTR pwszAccountName);
    
    STDMETHODIMP GetTrigger(ITaskTrigger ** ppTrigger);
    
    STDMETHODIMP GetNextRunTime(SYSTEMTIME * pstNextRun);
    
    STDMETHODIMP GetMostRecentRunTime(SYSTEMTIME * pstRecentRun);
    
    STDMETHODIMP EditSyncSchedule(HWND  hParent,
        DWORD dwReserved);
    
    STDMETHODIMP AddItem(LPSYNC_HANDLER_ITEM_INFO pHandlerItemInfo);
    
    STDMETHODIMP RegisterItems( REFCLSID pHandlerID,
        SYNCMGRITEMID *pItemID);
    
    STDMETHODIMP UnregisterItems( REFCLSID pHandlerID,
        SYNCMGRITEMID *pItemID);
    
    STDMETHODIMP SetItemCheck(REFCLSID pHandlerID,
        SYNCMGRITEMID *pItemID, DWORD dwCheckState);
    
    STDMETHODIMP GetItemCheck(REFCLSID pHandlerID,
        SYNCMGRITEMID *pItemID, DWORD *pdwCheckState);
    
    STDMETHODIMP EnumItems(REFCLSID pHandlerID,
        IEnumSyncItems  **ppEnumItems);
    
    STDMETHODIMP Save();
    
    STDMETHODIMP GetITask(ITask **ppITask);
    
    // ISyncSchedulp methods
    STDMETHODIMP GetHandlerInfo(REFCLSID pHandlerID,LPSYNCMGRHANDLERINFO *ppSyncMgrHandlerInfo);
    
    
private:   
    SCODE Initialize(LPTSTR ptstrGUIDName, LPTSTR ptstrFriendlyName);
    SCODE LoadAllHandlers();
    SCODE LoadOneHandler(REFCLSID pHandlerID);
    SCODE SetDefaultCredentials();
    SCODE GetScheduleGUIDName(DWORD *pcbSize,
        LPTSTR ptszScheduleName);
    SCODE CacheItemCheckState(REFCLSID phandlerID,
        SYNCMGRITEMID itemID,
        DWORD dwCheckState);
    
    SCODE RetreiveCachedItemCheckState(REFCLSID phandlerID,
        SYNCMGRITEMID itemID,
        DWORD *pdwCheckState);
    
    SCODE ApplyCachedItemsCheckState(REFCLSID phandlerID);
    SCODE PurgeCachedItemsCheckState(REFCLSID phandlerID);
    SCODE WriteOutAndPurgeCache(void);
    
    CACHELIST *m_pFirstCacheEntry;
    
    ULONG  m_cRef;
    ITask *m_pITask;
    // 
    // Since we don't expose functions to get and set 
    // the GUID name, this one is a TCHAR for ease of writing the registry                                  
    TCHAR  m_ptstrGUIDName[MAX_PATH + 1];  
    
    WCHAR  m_pwszFriendlyName[MAX_PATH + 1];
    WCHAR  m_pwszConnectionName[RAS_MaxEntryName + 1];
    DWORD  m_dwConnType;
    BOOL   m_fCleanReg;
    
    LPCONNECTIONSETTINGS m_pConnectionSettings;
    CHndlrQueue *m_HndlrQueue;
    WORD   m_iTrigger;
    ITaskTrigger *m_pITrigger;
    BOOL m_fNewSchedule;
    
    friend class CSyncMgrSynchronize; 
    friend class CSchedSyncPage;
    
};
typedef CSyncSchedule *LPSYNCSCHEDULE;

//+--------------------------------------------------------------
//
//  Class:     CEnumSyncItems
//
//  History:    27-Feb-98       SusiA   Created
//
//---------------------------------------------------------------
class CEnumSyncItems : public IEnumSyncItems
{
    friend class CEnumSyncItems;
    
public:
    CEnumSyncItems(REFGUID pHandlerId, CHndlrQueue *pHndlrQueue);
    ~CEnumSyncItems();
    
    //  IUnknown members
    STDMETHODIMP            QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();
    
    // IEnumSyncItems methods
    STDMETHODIMP Next(ULONG celt,
        LPSYNC_HANDLER_ITEM_INFO rgelt,
        ULONG * pceltFetched);
    
    STDMETHODIMP Skip(ULONG celt);
    
    STDMETHODIMP Reset(void);
    
    STDMETHODIMP Clone(IEnumSyncItems ** ppEnumSyncItems);
    
private:   
    SCODE SetHandlerAndItem(WORD wHandlerID, WORD wItemID);
    
    ULONG m_cRef;
    GUID m_HandlerId;
    WORD m_wItemId;
    WORD m_wHandlerId;
    CHndlrQueue *m_HndlrQueue;
    BOOL m_fAllHandlers;
};
typedef CEnumSyncItems *LPENUMSYNCITEMS;

#endif // _SYNCSCHED_IF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\dll\schdsrvc.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       schdsrvc.cxx
//
//  Contents:
//
//  Notes:  Hack around the service not being started when creating tasks
//
//  Functions:	StartScheduler
//
//  History:    2/19/1997   SusiA   Cut from MSDN
//
//  Notes:      This function works for either Win9x or Windows NT.
//              If the service is running but paused, does nothing.//
//____________________________________________________________________________

#include "precomp.h"

#undef TRACE
#define TRACE(x)                //OutputDebugString(x)

#define MAX_SERVICE_WAIT_TIME   90000   //  a minute and a half

#define SCHED_CLASS             TEXT("SAGEWINDOWCLASS")
#define SCHED_TITLE             TEXT("SYSTEM AGENT COM WINDOW")
#define SCHED_SERVICE_APP_NAME  TEXT("mstask.exe")
#define SCHED_SERVICE_NAME      TEXT("Schedule")

DWORD StartScheduler()
{
    DWORD dwTimeOut;
    DWORD dwError;

    SC_HANDLE   hSC = NULL;        
	SC_HANDLE   hSchSvc = NULL;
    hSC = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (hSC == NULL)        
	{            
		return GetLastError();
    }
    hSchSvc = OpenService(hSC,
                            SCHED_SERVICE_NAME,
                            SERVICE_START | SERVICE_QUERY_STATUS);

    CloseServiceHandle(hSC);
    if (hSchSvc == NULL)        
	{
        return GetLastError();        
	}        
	SERVICE_STATUS SvcStatus;
    
	if (QueryServiceStatus(hSchSvc, &SvcStatus) == FALSE)        
	{
        CloseServiceHandle(hSchSvc);            
		return GetLastError();
    }        
	if (SvcStatus.dwCurrentState == SERVICE_RUNNING)        
	{
        // The service is already running.
        CloseServiceHandle(hSchSvc);
        return ERROR_SUCCESS;
    }
    if (StartService(hSchSvc, 0, NULL) == FALSE)
    {
        CloseServiceHandle(hSchSvc);
        return GetLastError();
    }

    dwTimeOut = GetTickCount() + MAX_SERVICE_WAIT_TIME;

    BOOL bContinue = TRUE;

    dwError = ERROR_SERVICE_NEVER_STARTED;

    while (bContinue)
    {
        if (QueryServiceStatus(hSchSvc, &SvcStatus) == FALSE)
        {
            dwError = GetLastError();
            break;
        }

        switch (SvcStatus.dwCurrentState)
        {
            //  This is good!
            case SERVICE_RUNNING:
                dwError = ERROR_SUCCESS;

                //  Fall through

            //  These are bad
            case SERVICE_STOPPED:
            case SERVICE_STOP_PENDING:
            case SERVICE_PAUSE_PENDING:
            case SERVICE_PAUSED:
                bContinue = FALSE;
                break;

            default:
                if (GetTickCount() < dwTimeOut)
                {                        
                    //  How long to sleep?  According to the SDK use a tenth of the wait hint
                    //  and floor/ceil it between 1 and 10 seconds.

                    DWORD dwSleep = SvcStatus.dwWaitHint / 10;

                    if (dwSleep < 1000)
                    {
                        dwSleep = 1000;
                    }
                    else if (dwSleep > 10000)
                    {
                        dwSleep = 10000;
                    }
                    
                    TRACE("########## Waiting for Task Scheduler service to be started...\n");

                    Sleep(dwSleep);
                }
                else
                {
                    TRACE("########## Starting Task Scheduler service timed out...\n");
                    bContinue = FALSE;
                }
                break;
        }
    }

    CloseServiceHandle(hSchSvc);

    TRACE("########## Stop waiting for Task Scheduler service to start...\n");

	return dwError;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\dll\settings.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       Settings.cpp
//
//  Contents:   Onestop settings routines
//
//  Classes:
//
//  Notes:
//
//  History:    10-Nov-97   SusiA      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

extern HINSTANCE g_hmodThisDll; // Handle to this DLL itself.
extern UINT      g_cRefThisDll;
extern CRITICAL_SECTION g_DllCriticalSection; // Global Critical Section for this DLL

// items for context sensitive help
// Review -Should be string in resource.
TCHAR szSyncMgrHelp[]  = TEXT("mobsync.hlp");

ULONG g_aContextHelpIds[] =
{
    IDC_STATIC1,                ((DWORD)  -1),
    IDC_STATIC2,                ((DWORD)  -1),
    IDC_STATIC3,                ((DWORD)  -1),
    IDC_STATIC4,                ((DWORD)  -1),
    IDC_ADVANCEDIDLEOVERVIEWTEXT,           ((DWORD)  -1),
    IDC_ADVANCEDIDLEWAITTEXT,       ((DWORD)  -1),
    IDC_ADVANCEDIDLEMINUTESTEXT1,           ((DWORD)  -1),
    IDC_ADVANCEDIDLEMINUTESTEXT2,           ((DWORD)  -1),
    IDC_SP_SEPARATOR,           ((DWORD)  -1),
    IDS_CONNECTDESCRIPTION,         ((DWORD)  -1),
    IDC_SCHED_NAME,             ((DWORD)  -1),
    IDC_SCHED_STRING,           ((DWORD)  -1),
    IDC_LASTRUN,                ((DWORD)  -1),
    IDC_NEXTRUN,                ((DWORD)  -1),
        IDC_ConnectionText,                     ((DWORD)  -1),
    IDC_RUNLOGGEDON,            HIDC_RUNLOGGEDON,
    IDC_RUNALWAYS,              HIDC_RUNALWAYS,
    IDC_RUNAS_TEXT,             HIDC_RUNAS_TEXT,
    IDC_USERNAME,               HIDC_USERNAME,
    IDC_PASSWORD_TEXT,          HIDC_PASSWORD_TEXT,
    IDC_PASSWORD,               HIDC_PASSWORD,
    IDC_CONFIRMPASSWORD_TEXT,       HIDC_CONFIRMPASSWORD_TEXT,
    IDC_CONFIRMPASSWORD,            HIDC_CONFIRMPASSWORD,
    IDC_ADVANCEDIDLE,           HIDC_ADVANCEDIDLE,
    IDC_AUTOCONNECT,            HIDC_AUTOCONNECT,
    IDC_AUTOLOGOFF,             HIDC_AUTOLOGOFF,
    IDC_AUTOLOGON,              HIDC_AUTOLOGON,
    IDC_AUTOPROMPT_ME_FIRST,        HIDC_AUTOPROMPT_ME_FIRST,
    IDC_AUTOUPDATECOMBO,            HIDC_AUTOUPDATECOMBO,
    IDC_AUTOUPDATELIST,         HIDC_AUTOUPDATELIST,
    IDC_CHECKREPEATESYNC,           HIDC_CHECKREPEATESYNC,
    IDC_CHECKRUNONBATTERIES,        HIDC_CHECKRUNONBATTERIES,   
    IDC_EDITIDLEREPEATMINUTES,      HIDC_EDITIDLEREPEATMINUTES,
    IDC_EDITIWAITMINUTES,                   HIDC_EDITIWAITMINUTES,
        IDC_SPINIDLEREPEATMINUTES,              HIDC_EDITIDLEREPEATMINUTES,
    IDC_SPINIDLEWAITMINUTES,                HIDC_EDITIWAITMINUTES,
        IDC_IDLECHECKBOX,           HIDC_IDLECHECKBOX,
    IDC_SCHEDADD,               HIDC_SCHEDADD,
    IDC_SCHEDEDIT,              HIDC_SCHEDEDIT,
    IDC_SCHEDLIST,              HIDC_SCHEDLIST,
    IDC_SCHEDREMOVE,            HIDC_SCHEDREMOVE,
    IDC_SCHEDUPDATECOMBO,           HIDC_SCHEDUPDATECOMBO,  
    IDC_SCHEDUPDATELIST,            HIDC_SCHEDUPDATELIST,   
    IDC_SCHED_NAME_EDITBOX,         HIDC_SCHED_NAME_EDITBOX,
    0,0
};


INT_PTR CALLBACK AutoSyncDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK SchedSyncDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK IdleSyncDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK IdleAdvancedSettingsDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);

int CALLBACK PropSheetProc( HWND hwndDlg, UINT uMsg, LPARAM lParam);

DWORD WINAPI  SettingsThread( LPVOID lpArg );

DWORD g_SettingsThreadID = NULL;
HWND g_hwndPropSheet = NULL;
CAutoSyncPage *g_pAutoSyncPage = NULL; // shared by AutoSync and IdleSyncDlg Procs
CSchedSyncPage *g_pSchedSyncPage = NULL;
BOOL g_fInSettingsDialog = FALSE;

//+-------------------------------------------------------------------------------
//
//  FUNCTION: IsSchedulingInstalled()
//
//  PURPOSE:  Determines is there is a task scheduler on the current workstation
//
//
//--------------------------------------------------------------------------------
BOOL IsSchedulingInstalled()
{
    BOOL fInstalled = FALSE;
    ISchedulingAgent *pSchedAgent = NULL;

    // Review if there is a better way to test this.
    if (NOERROR == CoCreateInstance(CLSID_CSchedulingAgent,
                                    NULL,
                                    CLSCTX_INPROC_SERVER,
                                    IID_ISchedulingAgent,
                                    (LPVOID*)&pSchedAgent))
    {
    fInstalled = TRUE;
    pSchedAgent->Release();
    }

    return fInstalled;
}

//+-------------------------------------------------------------------------------
//
//  FUNCTION: IsIdleAvailable()
//
//  PURPOSE:  Determines is this machine supports can Idle
//
//
//--------------------------------------------------------------------------------

BOOL IsIdleAvailable()
{
BOOL fInstalled = FALSE;
ISchedulingAgent *pSchedAgent = NULL;

    // Review if there is a better way to test this.
    if (NOERROR == CoCreateInstance(CLSID_CSchedulingAgent,
                                    NULL,
                                    CLSCTX_INPROC_SERVER,
                                    IID_ISchedulingAgent,
                                    (LPVOID*)&pSchedAgent) )
    {
    fInstalled = TRUE;
    pSchedAgent->Release();
    }

    return fInstalled;
}

//+-------------------------------------------------------------------------------
//
//  FUNCTION: IsAutoSyncAvailable()
//
//  PURPOSE:  Determines is this machine supports AutoSync
//
//
//--------------------------------------------------------------------------------

BOOL IsAutoSyncAvailable()
{
    return TRUE;
}

//+-------------------------------------------------------------------------------
//
//  FUNCTION: DisplayOptions()
//
//  PURPOSE:  Display the Onestop autosync options
//
//
//--------------------------------------------------------------------------------
STDAPI DisplayOptions(HWND hwndOwner)
{
#define MAXNUMPROPSHEETS 3
    
    int hr = E_FAIL;
    DWORD dwError;
    // always use ANSI versions since doesn't matter
    PROPSHEETPAGE psp [MAXNUMPROPSHEETS];
    HPROPSHEETPAGE hpsp [MAXNUMPROPSHEETS];
    PROPSHEETHEADER psh;
    int nPages = 0;
    BOOL fIdleAvailable;
    CCriticalSection cCritSect(&g_DllCriticalSection,GetCurrentThreadId());
    
    cCritSect.Enter();
    
    if (g_fInSettingsDialog) // IF ALREADY DISPLAYING A DIALOG BOX, THEN JUST RETURN
    {
        HWND hwndSettings = g_hwndPropSheet;
        
        cCritSect.Leave();
        
        if (hwndSettings)
        {
            SetForegroundWindow(hwndSettings);
        }
        
        return NOERROR;
    }
    
    
    g_fInSettingsDialog = TRUE;
    cCritSect.Leave();
    
    hr = CoInitialize(NULL);
    
    if (SUCCEEDED(hr))
    {
        
        RegSetUserDefaults(); // Make Sure the UserDefaults are up to date
        
        ZeroMemory(psp,sizeof(*psp));
        ZeroMemory(&psh, sizeof(psh));
        
        
        if (IsAutoSyncAvailable())
        {
            psp[nPages].dwSize = sizeof (psp[0]);
            psp[nPages].dwFlags = PSP_DEFAULT | PSP_USETITLE;
            psp[nPages].hInstance = g_hmodThisDll;
            psp[nPages].pszTemplate = MAKEINTRESOURCE(IDD_AUTOSYNC);
            psp[nPages].pszIcon = NULL;
            psp[nPages].pfnDlgProc = AutoSyncDlgProc;
            psp[nPages].pszTitle = MAKEINTRESOURCE(IDS_LOGONLOGOFF_TAB);
            psp[nPages].lParam = 0;
            
            hpsp[nPages] = CreatePropertySheetPage(&(psp[nPages]));
            ++nPages;
        }
        
        if (fIdleAvailable = IsIdleAvailable())
        {
            
            psp[nPages].dwSize = sizeof (psp[0]);
            psp[nPages].dwFlags = PSP_DEFAULT | PSP_USETITLE;
            
            psp[nPages].hInstance = g_hmodThisDll;
            psp[nPages].pszTemplate = MAKEINTRESOURCE(IDD_IDLESETTINGS);
            psp[nPages].pszIcon = NULL;
            psp[nPages].pfnDlgProc = IdleSyncDlgProc;
            psp[nPages].pszTitle = MAKEINTRESOURCE(IDS_ONIDLE_TAB);
            psp[nPages].lParam = 0;
            
            hpsp[nPages] = CreatePropertySheetPage(&(psp[nPages]));
            
            ++nPages;
        }
        
        
        // Review - if have idle have schedule, why not collapse
        // all these IsxxxAvailable into one call.
        if (fIdleAvailable /* IsSchedulingInstalled() */)
        {
            psp[nPages].dwSize = sizeof (psp[0]);
            psp[nPages].dwFlags = PSP_DEFAULT | PSP_USETITLE;
            psp[nPages].hInstance = g_hmodThisDll;
            psp[nPages].pszTemplate = MAKEINTRESOURCE(IDD_SCHEDSYNC);
            psp[nPages].pszIcon = NULL;
            psp[nPages].pfnDlgProc = SchedSyncDlgProc;
            psp[nPages].pszTitle = MAKEINTRESOURCE(IDS_SCHEDULED_TAB);
            psp[nPages].lParam = 0;
            
            hpsp[nPages] = CreatePropertySheetPage(&(psp[nPages]));
            
            ++nPages;
        }
        
        
        Assert(nPages <= MAXNUMPROPSHEETS);
        
        psh.dwSize = sizeof (psh);
        psh.dwFlags = PSH_DEFAULT | PSH_USECALLBACK | PSH_USEHICON;
        psh.hwndParent = hwndOwner;
        psh.hInstance = g_hmodThisDll;
        psh.pszIcon = NULL;
        psh.hIcon =  LoadIcon(g_hmodThisDll, MAKEINTRESOURCE(IDI_SYNCMGR));
        psh.pszCaption = MAKEINTRESOURCE(IDS_SCHEDULED_TITLE);
        psh.nPages = nPages;
        psh.phpage = hpsp;
        psh.pfnCallback = PropSheetProc;
        psh.nStartPage = 0;
        
        hr = (int)PropertySheet(&psh);
        
        // remove global classes
        
        if (g_pAutoSyncPage)
        {
            delete g_pAutoSyncPage;
            g_pAutoSyncPage = NULL;
        }
        
        g_SettingsThreadID = NULL;
        
        if (g_pSchedSyncPage)
        {
            delete g_pSchedSyncPage;
            g_pSchedSyncPage = NULL;
        }
        
        g_hwndPropSheet = NULL;
        
        CoFreeUnusedLibraries();
        CoUninitialize();
    }
    
    if (hr == -1)
    {
        dwError = GetLastError();
    }
    
    cCritSect.Enter();
    g_fInSettingsDialog = FALSE; // allow another settings to be created.
    cCritSect.Leave();
    
    return hr;
}


//+-------------------------------------------------------------------------------
//  FUNCTION: AutoSyncDlgProc(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE: Callback dialog procedure for the property page
//
//  PARAMETERS:
//    hDlg      - Dialog box window handle
//    uMessage  - current message
//    wParam    - depends on message
//    lParam    - depends on message
//
//  RETURN VALUE:
//
//    Depends on message.  In general, return TRUE if we process it.
//
//  COMMENTS:
//
//+-------------------------------------------------------------------------------

INT_PTR CALLBACK AutoSyncDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    WORD wNotifyCode = HIWORD(wParam); // notification code
    
    switch (uMessage)
    {
    case WM_INITDIALOG:
        {
            if (NULL == g_pAutoSyncPage)
            {
                g_pAutoSyncPage = new CAutoSyncPage(g_hmodThisDll);
            }
            
            if (g_pAutoSyncPage)
            {
                g_pAutoSyncPage->SetAutoSyncHwnd(hDlg);
                g_pAutoSyncPage->InitializeHwnd(hDlg,SYNCTYPE_AUTOSYNC,0);
                return TRUE;
            }   
            else
            {
                return FALSE;
            }
        }
        break;
        
    case WM_DESTROY:
        {
            
            if (g_pAutoSyncPage && g_pAutoSyncPage->m_pItemListViewAutoSync)
            {
                delete  g_pAutoSyncPage->m_pItemListViewAutoSync;
                g_pAutoSyncPage->m_pItemListViewAutoSync = NULL;
            }
            
        }
        break;
        
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_AUTOUPDATECOMBO:
            {
                if (wNotifyCode == CBN_SELCHANGE)
                {
                    HWND hwndCombo = (HWND) lParam;
                    if (g_pAutoSyncPage)
                    {
                        g_pAutoSyncPage->ShowItemsOnThisConnection
                            (hDlg,SYNCTYPE_AUTOSYNC,ComboBox_GetCurSel(hwndCombo));
                    }
                }
            }
            break;
            
        case IDC_AUTOLOGON: 
        case IDC_AUTOLOGOFF:
        case IDC_AUTOPROMPT_ME_FIRST:
            {
                if (wNotifyCode == BN_CLICKED)
                {
                    PropSheet_Changed(g_hwndPropSheet, hDlg);
                    
                    HWND hwndCtrl = (HWND) lParam;
                    g_pAutoSyncPage->SetConnectionCheck(hDlg,SYNCTYPE_AUTOSYNC,LOWORD(wParam),
                        Button_GetCheck(hwndCtrl));
                    
                }
            }
            break;
            
        default:
            break;
            
        }
        break;
        case WM_HELP:
            {
                LPHELPINFO lphi  = (LPHELPINFO)lParam;
                
                if (lphi->iContextType == HELPINFO_WINDOW)
                {
                    WinHelp ( (HWND) lphi->hItemHandle,
                        szSyncMgrHelp,
                        HELP_WM_HELP,
                        (ULONG_PTR) g_aContextHelpIds);
                }
                return TRUE;
            }
        case WM_CONTEXTMENU:
            {
                
                WinHelp ((HWND)wParam,
                    szSyncMgrHelp,
                    HELP_CONTEXTMENU,
                    (ULONG_PTR)g_aContextHelpIds);
                
                return TRUE;
            }
            
        case WM_NOTIFYLISTVIEWEX:
            
            if (g_pAutoSyncPage)
            {
                int idCtrl = (int) wParam;
                LPNMHDR pnmhdr = (LPNMHDR) lParam;
                
                if ( (IDC_AUTOUPDATELIST != idCtrl) || (NULL == g_pAutoSyncPage->m_pItemListViewAutoSync))
                {
                    Assert(IDC_AUTOUPDATELIST == idCtrl);
                    Assert(g_pAutoSyncPage->m_pItemListViewAutoSync);
                    break;
                }
                
                switch (pnmhdr->code)
                {
                case LVNEX_ITEMCHECKCOUNT:
                    {
                        LPNMLISTVIEWEXITEMCHECKCOUNT pnmvCheckCount = (LPNMLISTVIEWEXITEMCHECKCOUNT) lParam;
                        
                        // pass along notification only if listView is done being initialized
                        // since no need to set the CheckState or mark PSheet as Dirty
                        if (g_pAutoSyncPage->m_pItemListViewAutoSyncInitialized)
                        {
                            
                            g_pAutoSyncPage->SetItemCheckState(hDlg,SYNCTYPE_AUTOSYNC,
                                pnmvCheckCount->iItemId,pnmvCheckCount->dwItemState
                                ,pnmvCheckCount->iCheckCount);
                            
                            PropSheet_Changed(g_hwndPropSheet, hDlg);
                        }
                        
                        break;
                    }
                default:
                    break;
                }
            }
            break;
            
        case WM_NOTIFY:
            if (g_pAutoSyncPage)
            {
                int idCtrl = (int) wParam;
                LPNMHDR pnmhdr = (LPNMHDR) lParam;
                
                
                // if notification for UpdateListPass it on.
                if ((IDC_AUTOUPDATELIST == idCtrl) && g_pAutoSyncPage->m_pItemListViewAutoSync)
                {
                    g_pAutoSyncPage->m_pItemListViewAutoSync->OnNotify(pnmhdr);
                    break;
                }
                
            }
            
            switch (((NMHDR FAR *)lParam)->code)
            {
            case PSN_SETACTIVE:
                break;
                
            case PSN_APPLY:
                //User has clicked the OK or Apply button so we'll
                //Save the current selections
                
                g_pAutoSyncPage->CommitAutoSyncChanges();
                break;
            default:
                break;
            }
            break;
            
            default:
                return FALSE;
    }
    
    return FALSE;
}


//+-------------------------------------------------------------------------------
//  FUNCTION: IdleSyncDlgProc(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE: Callback dialog procedure for the iDLE property page
//
//  PARAMETERS:
//    hDlg      - Dialog box window handle
//    uMessage  - current message
//    wParam    - depends on message
//    lParam    - depends on message
//
//  RETURN VALUE:
//
//    Depends on message.  In general, return TRUE if we process it.
//
//  COMMENTS:
//
//+-------------------------------------------------------------------------------

INT_PTR CALLBACK IdleSyncDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    WORD wNotifyCode = HIWORD(wParam); // notification code
    
    switch (uMessage)
    {
    case WM_INITDIALOG:
        {
        /*
        RECT rc;
        HRESULT hr;
        
          
            hr = GetWindowRect(hDlg, &rc);
            
              hr = SetWindowPos(hDlg,
              NULL,
              ((GetSystemMetrics(SM_CXSCREEN) - (rc.right - rc.left)) / 2),
              ((GetSystemMetrics(SM_CYSCREEN) - (rc.bottom - rc.top)) / 2),
              0,
              0,
            SWP_NOSIZE | SWP_NOACTIVATE); */
            
            
            if (NULL == g_pAutoSyncPage)
            {
                g_pAutoSyncPage = new CAutoSyncPage(g_hmodThisDll);
            }
            
            
            if (g_pAutoSyncPage)
            {
                BOOL fConnectionsAvailable;
                
                g_pAutoSyncPage->SetIdleHwnd(hDlg);
                g_pAutoSyncPage->InitializeHwnd(hDlg,SYNCTYPE_IDLE,0);
                
                // there must be at least one connection or we disable
                // the advanced button.
                
                fConnectionsAvailable  =
                    g_pAutoSyncPage->GetNumConnections(hDlg,SYNCTYPE_IDLE)
                    ? TRUE : FALSE;
                
                EnableWindow(GetDlgItem(hDlg,IDC_ADVANCEDIDLE),fConnectionsAvailable);
                
                return TRUE;
            }   
            else
            {
                return FALSE;
            }
            
        }
        break;
    case WM_DESTROY:
        {
            
            if (g_pAutoSyncPage && g_pAutoSyncPage->m_pItemListViewIdle)
            {
                delete g_pAutoSyncPage->m_pItemListViewIdle;
                g_pAutoSyncPage->m_pItemListViewIdle = NULL;
            }
            
            //  PostQuitMessage(0); 
            
            // PostQuitMessage(0);  
        }
        break;
    case WM_HELP:
        {
            LPHELPINFO lphi  = (LPHELPINFO)lParam;
            
            if (lphi->iContextType == HELPINFO_WINDOW)
            {
                WinHelp ( (HWND) lphi->hItemHandle,
                    szSyncMgrHelp,
                    HELP_WM_HELP,
                    (ULONG_PTR) g_aContextHelpIds);
            }
            return TRUE;
        }
    case WM_CONTEXTMENU:
        {
            
            WinHelp ((HWND)wParam,
                szSyncMgrHelp,
                HELP_CONTEXTMENU,
                (ULONG_PTR)g_aContextHelpIds);
            
            return TRUE;
        }
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_AUTOUPDATECOMBO:
            {
                if (wNotifyCode == CBN_SELCHANGE)
                {
                    HWND hwndCombo = (HWND) lParam;
                    if (g_pAutoSyncPage)
                    {
                        g_pAutoSyncPage->ShowItemsOnThisConnection
                            (hDlg,SYNCTYPE_IDLE,ComboBox_GetCurSel(hwndCombo));
                    }
                }
            }
            break;
        case IDC_IDLECHECKBOX:
            {
                if (wNotifyCode == BN_CLICKED)
                {
                    PropSheet_Changed(g_hwndPropSheet, hDlg);
                    
                    HWND hwndCtrl = (HWND) lParam;
                    g_pAutoSyncPage->SetConnectionCheck(hDlg,SYNCTYPE_IDLE,LOWORD(wParam),
                        Button_GetCheck(hwndCtrl));
                    
                }
            }
            break;
        case IDC_ADVANCEDIDLE:
            {
                if (wNotifyCode == BN_CLICKED)
                {
                    // bring up the advanced idle dialog passing in the autoSyncPage class
                    // as the owning class.
                    DialogBoxParam(g_hmodThisDll,
                        MAKEINTRESOURCE(IDD_ADVANCEDIDLESETTINGS),hDlg, IdleAdvancedSettingsDlgProc,
                        (LPARAM) g_pAutoSyncPage);
                    
                }
            }
            break;
        default:
            break;
            
        }
        break;
        case WM_NOTIFYLISTVIEWEX:
            if (g_pAutoSyncPage)
            {
                int idCtrl = (int) wParam;
                LPNMHDR pnmhdr = (LPNMHDR) lParam;
                
                if ( (IDC_AUTOUPDATELIST != idCtrl) || (NULL == g_pAutoSyncPage->m_pItemListViewIdle))
                {
                    Assert(IDC_AUTOUPDATELIST == idCtrl);
                    Assert(g_pAutoSyncPage->m_pItemListViewIdle);
                    break;
                }
                
                switch (pnmhdr->code)
                {
                case LVNEX_ITEMCHECKCOUNT:
                    {
                        LPNMLISTVIEWEXITEMCHECKCOUNT pnmvCheckCount = (LPNMLISTVIEWEXITEMCHECKCOUNT) lParam;
                        
                        // pass along notification only if listView is done being initialized
                        // since no need to set the CheckState or mark PSheet as Dirty
                        if (g_pAutoSyncPage->m_fListViewIdleInitialized)
                        {
                            g_pAutoSyncPage->SetItemCheckState(hDlg,SYNCTYPE_IDLE,
                                pnmvCheckCount->iItemId,pnmvCheckCount->dwItemState
                                ,pnmvCheckCount->iCheckCount);
                            
                            PropSheet_Changed(g_hwndPropSheet, hDlg);
                        }
                        
                        break;
                    }
                default:
                    break;
                }
            }
            break;
        case WM_NOTIFY:
            
            if (g_pAutoSyncPage)
            {
                int idCtrl = (int) wParam;
                LPNMHDR pnmhdr = (LPNMHDR) lParam;
                
                // if notification for UpdateListPass it on.
                if ((IDC_AUTOUPDATELIST == idCtrl) && g_pAutoSyncPage->m_pItemListViewIdle)
                {
                    g_pAutoSyncPage->m_pItemListViewIdle->OnNotify(pnmhdr);
                    break;
                }
                
                switch (((NMHDR FAR *)lParam)->code)
                {
                case PSN_SETACTIVE:
                    break;
                case PSN_APPLY:
                    //User has clicked the OK or Apply button so we'll
                    //Save the current selections
                    g_pAutoSyncPage->CommitIdleChanges();
                    break;
                default:
                    break;
                }
            }
            break;
            
        default:
            return FALSE;
    }
    
    return FALSE;
}

//+-------------------------------------------------------------------------------
//  FUNCTION: IdleAdvancedSettingsDlgProc(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE: Callback dialog procedure for the Advanced Idle Settings.
//
//  PARAMETERS:
//    hDlg      - Dialog box window handle
//    uMessage  - current message
//    wParam    - depends on message
//    lParam    - depends on message
//
//  RETURN VALUE:
//
//    Depends on message.  In general, return TRUE if we process it.
//
//  COMMENTS:
//
//+-------------------------------------------------------------------------------


INT_PTR CALLBACK IdleAdvancedSettingsDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    
    switch(uMessage)
    {
    case WM_INITDIALOG:
        {
            CONNECTIONSETTINGS ConnectionSettings;
            
            Assert(g_pAutoSyncPage);
            
            if (NULL == g_pAutoSyncPage)
                return FALSE;
            
            UpDown_SetRange(GetDlgItem(hDlg,IDC_SPINIDLEWAITMINUTES), SPINDIALWAITMINUTES_MIN, SPINDIALWAITMINUTES_MAX);
            Edit_LimitText(GetDlgItem(hDlg,IDC_EDITIWAITMINUTES), 3);
            
            UpDown_SetRange(GetDlgItem(hDlg,IDC_SPINIDLEREPEATMINUTES), SPINDIALREPEATMINUTES_MIN, SPINDIALREPEATMINUTES_MAX);
            Edit_LimitText(GetDlgItem(hDlg,IDC_EDITIDLEREPEATMINUTES), 3);
            
            // initialize user specific preferences
            // if can't get shouldn't show dialog
            
            // EditText cannot accept DBCS characters on Win9x so disalbe IME for 
            // Edit Boxes.
            
            ImmAssociateContext(GetDlgItem(hDlg,IDC_EDITIWAITMINUTES), NULL);
            ImmAssociateContext(GetDlgItem(hDlg,IDC_EDITIDLEREPEATMINUTES), NULL);
            
            if (NOERROR == g_pAutoSyncPage->GetAdvancedIdleSettings(&ConnectionSettings))
            {
                UpDown_SetPos(GetDlgItem(hDlg,IDC_SPINIDLEWAITMINUTES), ConnectionSettings.ulIdleWaitMinutes);
                UpDown_SetPos(GetDlgItem(hDlg,IDC_SPINIDLEREPEATMINUTES),ConnectionSettings.ulIdleRetryMinutes);
                
                Button_SetCheck(GetDlgItem(hDlg,IDC_CHECKREPEATESYNC),ConnectionSettings.dwRepeatSynchronization);
                Button_SetCheck(GetDlgItem(hDlg,IDC_CHECKRUNONBATTERIES),!(ConnectionSettings.dwRunOnBatteries));
                
                // if the repeat check state is selected then enable the edit box associated with it
                EnableWindow(GetDlgItem(hDlg,IDC_SPINIDLEREPEATMINUTES),ConnectionSettings.dwRepeatSynchronization);
                EnableWindow(GetDlgItem(hDlg,IDC_EDITIDLEREPEATMINUTES),ConnectionSettings.dwRepeatSynchronization);
                EnableWindow(GetDlgItem(hDlg,IDC_ADVANCEDIDLEMINUTESTEXT2),ConnectionSettings.dwRepeatSynchronization);
                
            }
            
            ShowWindow(hDlg,SW_SHOW);
            return TRUE;
            break;
        }
    case WM_HELP:
        {
            LPHELPINFO lphi  = (LPHELPINFO)lParam;
            
            if (lphi->iContextType == HELPINFO_WINDOW)
            {
                WinHelp ( (HWND) lphi->hItemHandle,
                    szSyncMgrHelp,
                    HELP_WM_HELP,
                    (ULONG_PTR) g_aContextHelpIds);
            }
            return TRUE;
        }
    case WM_CONTEXTMENU:
        {
            
            WinHelp ((HWND)wParam,
                szSyncMgrHelp,
                HELP_CONTEXTMENU,
                (ULONG_PTR)g_aContextHelpIds);
            
            return TRUE;
        }
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDCANCEL:
            EndDialog(hDlg,FALSE);
            break;
        case IDOK:
            if (g_pAutoSyncPage)
            {
                CONNECTIONSETTINGS ConnectionSettings;
                
                if (g_pAutoSyncPage)
                {
                    
                    ConnectionSettings.ulIdleWaitMinutes = GetDlgItemInt(hDlg, IDC_EDITIWAITMINUTES, NULL, FALSE);
                    ConnectionSettings.ulIdleRetryMinutes = GetDlgItemInt(hDlg, IDC_EDITIDLEREPEATMINUTES, NULL, FALSE);
                    
                    ConnectionSettings.dwRepeatSynchronization = Button_GetCheck(GetDlgItem(hDlg,IDC_CHECKREPEATESYNC));
                    ConnectionSettings.dwRunOnBatteries = (!Button_GetCheck(GetDlgItem(hDlg,IDC_CHECKRUNONBATTERIES)));
                    
                    g_pAutoSyncPage->SetAdvancedIdleSettings(&ConnectionSettings);
                }
            }
            EndDialog(hDlg,FALSE);
            break;
        case IDC_EDITIWAITMINUTES:
            {
                WORD wNotifyCode = HIWORD(wParam);
                INT iNewPos;
                
                //
                // If the user just pasted non-numeric text or an illegal numeric
                // value, overwrite it and complain.
                //
                if (EN_KILLFOCUS == wNotifyCode)
                {
                    iNewPos = GetDlgItemInt(hDlg, IDC_EDITIWAITMINUTES, NULL, FALSE);
                    if (iNewPos < SPINDIALWAITMINUTES_MIN || iNewPos > SPINDIALWAITMINUTES_MAX)
                    {
                        HWND hUD = GetDlgItem(hDlg,IDC_SPINIDLEWAITMINUTES);
                        
                        if (iNewPos < SPINDIALWAITMINUTES_MIN)
                        {
                            UpDown_SetPos(hUD, SPINDIALWAITMINUTES_MIN);
                        }
                        else
                        {
                            UpDown_SetPos(hUD,SPINDIALWAITMINUTES_MAX);
                        }
                        
                    }
                    
                }
                break;
            }
        case IDC_EDITIDLEREPEATMINUTES:
            {
                WORD wNotifyCode = HIWORD(wParam);
                INT iNewPos;
                
                //
                // If the user just pasted non-numeric text or an illegal numeric
                // value, overwrite it and complain.
                //
                
                // Review, redundant code with other spin control.
                if (EN_KILLFOCUS  == wNotifyCode)
                {
                    iNewPos = GetDlgItemInt(hDlg, IDC_EDITIDLEREPEATMINUTES, NULL, FALSE);
                    if (iNewPos < SPINDIALREPEATMINUTES_MIN || iNewPos > SPINDIALREPEATMINUTES_MAX)
                    {
                        HWND hUD = GetDlgItem(hDlg,IDC_SPINIDLEREPEATMINUTES);
                        
                        if (iNewPos < SPINDIALREPEATMINUTES_MIN)
                        {
                            UpDown_SetPos(hUD, SPINDIALREPEATMINUTES_MIN);
                        }
                        else
                        {
                            UpDown_SetPos(hUD,SPINDIALREPEATMINUTES_MAX);
                        }
                        
                    }
                    
                }
                
                break;
            }
        case IDC_CHECKREPEATESYNC:
            {
                WORD wNotifyCode = HIWORD(wParam);
                
                // if use clicked the repeat check box set set state of the other
                // items associated with it.
                
                if (BN_CLICKED == wNotifyCode)
                {
                    BOOL fEnableState = Button_GetCheck(GetDlgItem(hDlg,IDC_CHECKREPEATESYNC));
                    
                    // if the repeat check state is selected then enable the edit box associated with it
                    EnableWindow(GetDlgItem(hDlg,IDC_SPINIDLEREPEATMINUTES),fEnableState);
                    EnableWindow(GetDlgItem(hDlg,IDC_EDITIDLEREPEATMINUTES),fEnableState);
                    EnableWindow(GetDlgItem(hDlg,IDC_ADVANCEDIDLEMINUTESTEXT2),fEnableState);
                }
                
                
                break;
            }
        default:
            break;
        }
    default:
        break;
    }
    
    return FALSE;
}


//+-------------------------------------------------------------------------------
//  FUNCTION: SchedSyncDlgProc(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE: Callback dialog procedure for the property page
//
//  PARAMETERS:
//    hDlg      - Dialog box window handle
//    uMessage  - current message
//    wParam    - depends on message
//    lParam    - depends on message
//
//  RETURN VALUE:
//
//    Depends on message.  In general, return TRUE if we process it.
//
//  COMMENTS:
//
//--------------------------------------------------------------------------------


INT_PTR CALLBACK SchedSyncDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    WORD wNotifyCode = HIWORD(wParam); // notification code
    BOOL bResult = FALSE;
    
    switch (uMessage)
    {
    case WM_INITDIALOG:
        {
            
            g_pSchedSyncPage = new CSchedSyncPage(g_hmodThisDll, hDlg);
            
            if (g_pSchedSyncPage)
            {
                bResult =  g_pSchedSyncPage->Initialize();
            }   
            
        }
        break;
    case WM_DESTROY:
        {
            g_pSchedSyncPage->FreeAllSchedules();
        }
        break;
    case WM_HELP:
        {
            LPHELPINFO lphi  = (LPHELPINFO)lParam;
            
            if (lphi->iContextType == HELPINFO_WINDOW)
            {
                WinHelp ( (HWND) lphi->hItemHandle,
                    szSyncMgrHelp,
                    HELP_WM_HELP,
                    (ULONG_PTR) g_aContextHelpIds);
            }
            
            bResult = TRUE;
        }
        break;
    case WM_CONTEXTMENU:
        {
            WinHelp ((HWND)wParam,
                szSyncMgrHelp,
                HELP_CONTEXTMENU,
                (ULONG_PTR)g_aContextHelpIds);
            
            bResult =  TRUE;
        }
        break;
    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:
            break;
            
        case PSN_APPLY:
            //User has clicked the OK or Apply button so we'll
            //update the icon information in the .GAK file
            break;
            
        default:
            bResult =  g_pSchedSyncPage->OnNotify(hDlg,(int)wParam,(LPNMHDR)lParam);
            break;
        }
        break;
        case WM_COMMAND:
            bResult = g_pSchedSyncPage->OnCommand(hDlg, HIWORD(wParam), LOWORD(wParam),
                (HWND)lParam);
            break;  
        default:
            break;
    }
    
    return bResult;
}
//+-------------------------------------------------------------------------------
//
//  FUNCTION: CALLBACK PropSheetProc( HWND hwndDlg, UINT uMsg, LPARAM lParam);
//
//  PURPOSE: Callback dialog init procedure the settings property dialog
//
//  PARAMETERS:
//    hwndDlg   - Dialog box window handle
//    uMsg      - current message
//    lParam    - depends on message
//
//--------------------------------------------------------------------------------

int CALLBACK PropSheetProc( HWND hwndDlg, UINT uMsg, LPARAM lParam)
{
    switch(uMsg)
    {
    case PSCB_INITIALIZED:
        g_hwndPropSheet = hwndDlg;
        return TRUE;
        break;
    default:
        return TRUE;
    }
    return TRUE;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\dll\wizpage.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       wizpage.cxx
//
//  Contents:   Implementation of wizard page class
//
//  History:    4-30-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "precomp.h"

//+--------------------------------------------------------------------------
//
//  Member:     CWizPage::~CWizPage
//
//  History:    31-Mar-1998   SusiA   
//
//---------------------------------------------------------------------------

CWizPage::~CWizPage()
{
	if (m_pISyncSched)
		m_pISyncSched->Release();
}


//+--------------------------------------------------------------------------
//
//  Member:     CWizPage::_OnNotify
//
//  Synopsis:   Aggregate the CPropPage WM_NOTIFY handler to provide
//              wizard-specific dispatching.
//
//  Arguments:  standard windows
//
//  Returns:    standard windows
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CWizPage::_OnNotify(
    UINT    uMessage,
    UINT    uParam,
    LPARAM  lParam)
{
    // TRACE_METHOD(CWizPage, _OnNotify);

    LPNMHDR pnmhdr = (LPNMHDR) lParam;

    switch (pnmhdr->code)
    {
    //
    // Delegate to base class for notification processing it provides
    // which we don't need to override.
    //

    //
    // Support notifications unique to wizard pages
    //

    case PSN_WIZBACK:
        return _OnWizBack();

    case PSN_WIZNEXT:
        return _OnWizNext();

    }

    return TRUE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CWizPage::_OnWizBack
//
//  Synopsis:   Default handling of PSN_WIZBACK
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CWizPage::_OnWizBack()
{

    SetWindowLongPtr(m_hwnd, DWLP_MSGRESULT, 0);
    return 0;
}




//+--------------------------------------------------------------------------
//
//  Member:     CWizPage::_OnWizNext
//
//  Synopsis:   Default handling of PSN_WIZNEXT
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CWizPage::_OnWizNext()
{

    SetWindowLongPtr(m_hwnd, DWLP_MSGRESULT, 0);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\dll\syncmgrr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       syncmgrr.h
//
//  Contents:   Exports used by Ras for doing Pending Disconnect
//
//  Classes:    
//
//  Notes:      
//
//  History:    09-Jan-98   rogerg      Created.
//
//--------------------------------------------------------------------------

LRESULT CALLBACK  SyncMgrRasProc(UINT uMsg,WPARAM wParam, LPARAM lParam);  

// structures used in messages

typedef struct _tagSYNCMGRQUERYSHOWSYNCUI
{
    /* [in]  */ DWORD cbSize;
    /* [in]  */ GUID GuidConnection;
    /* [in]  */ LPCWSTR pszConnectionName;
    /* [out] */ BOOL fShowCheckBox;
    /* [out] */ UINT nCheckState;  // values taken from the BST_ #defines
} SYNCMGRQUERYSHOWSYNCUI;

typedef struct _tagSYNCMGRSYNCDISCONNECT
{
    /* [in] */ DWORD cbSize;
    /* [in] */ GUID  GuidConnection;
    /* [in] */ LPCWSTR pszConnectionName;
 } SYNCMGRSYNCDISCONNECT;

// Messages to SyncMgrRasProc
#define SYNCMGRRASPROC_QUERYSHOWSYNCUI 	WM_USER + 1

// wParam = 0
// lParam = Pointer to SYNCMGRQUERYSHOWSYNCUI

#define SYNCMGRRASPROC_SYNCDISCONNECT        	WM_USER + 2

// wParam = 0
// lParam = Pointer to SYNCMGRSYNCDISCONNECT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\dll\welcome.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//  
//  File:       welcome.cxx
//
//  Contents:   Task wizard welcome (initial) property page implementation.
//
//  Classes:    CWelcomePage
//
//  History:    11-21-1997   SusiA 
//
//---------------------------------------------------------------------------

#include "precomp.h"

CWelcomePage *g_pWelcomePage = NULL;

//+-------------------------------------------------------------------------------
//  FUNCTION: SchedWizardWelcomeDlgProc(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE: Callback dialog procedure for the property page
//
//  PARAMETERS:
//    hDlg      - Dialog box window handle
//    uMessage  - current message
//    wParam    - depends on message
//    lParam    - depends on message
//
//  RETURN VALUE:
//
//    Depends on message.  In general, return TRUE if we process it.
//
//  COMMENTS:
//
//+-------------------------------------------------------------------------------

INT_PTR CALLBACK SchedWizardWelcomeDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{

    switch (uMessage)
    {
        
    case WM_INITDIALOG:         
        {
        //This handles the 256 color processing init
        //for the .bmp
        InitPage(hDlg,lParam);
        }
            break;
        case WM_PAINT:
            WmPaint(hDlg, uMessage, wParam, lParam);
            break;

        case WM_PALETTECHANGED:
            WmPaletteChanged(hDlg, wParam);
            break;

        case WM_QUERYNEWPALETTE:
            return( WmQueryNewPalette(hDlg) );
            break;

        case WM_ACTIVATE:
            return( WmActivate(hDlg, wParam, lParam) );
            break;

        case WM_DESTROY:
        {
            Unload256ColorBitmap();
        }
        break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code) 
            {

                case PSN_KILLACTIVE:
                    SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, FALSE);
                    return 1;
                    break;

                case PSN_RESET:
                    // reset to the original values
                    SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, FALSE);
                    break;

                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
                break;

                case PSN_WIZNEXT:
                    break;

                default:
                    return FALSE;
        }
        break;
        
        default:
            return FALSE;
    }
    return TRUE;   

}

    
    
//+--------------------------------------------------------------------------
//
//  Member:     CWelcomePage::CWelcomePage
//
//  Synopsis:   ctor
//
//              [phPSP]                - filled with prop page handle
//
//  History:    11-21-1997   SusiA   Stole from Task Scheduler wizard
//
//---------------------------------------------------------------------------

CWelcomePage::CWelcomePage(
    HINSTANCE hinst,
    ISyncSchedule *pISyncSched,
    HPROPSHEETPAGE *phPSP)
{
    ZeroMemory(&m_psp, sizeof(m_psp));

    g_pWelcomePage = this;

    m_psp.dwSize = sizeof (PROPSHEETPAGE);
        m_psp.dwFlags = PSH_DEFAULT;
    m_psp.hInstance = hinst;
    m_psp.pszTemplate = MAKEINTRESOURCE(IDD_SCHEDWIZ_INTRO);
    m_psp.pszIcon = NULL;
    m_psp.pfnDlgProc = SchedWizardWelcomeDlgProc;
    m_psp.lParam = 0;

    m_pISyncSched = pISyncSched;
    m_pISyncSched->AddRef();

   *phPSP = CreatePropertySheetPage(&m_psp);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\dll\wizsel.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//  
//  File:       wizsel.cxx
//
//  Contents:   Task wizard Onestop selection property page implementation.
//
//  Classes:    CSelectItemsPage
//
//  History:    11-21-1997   SusiA   
//
//---------------------------------------------------------------------------


#include "precomp.h"

// temporariy define new mstask flag in case hasn't
// propogated to sdk\inc
//for CS help

extern TCHAR szSyncMgrHelp[];
extern ULONG g_aContextHelpIds[];

extern LANGID g_LangIdSystem;      // LangId of system we are running on.

CSelectItemsPage *g_pSelectItemsPage = NULL;

//+-------------------------------------------------------------------------------
//  FUNCTION: SchedWizardConnectionDlgProc(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE: Callback dialog procedure for the property page
//
//  PARAMETERS:
//    hDlg      - Dialog box window handle
//    uMessage  - current message
//    wParam    - depends on message
//    lParam    - depends on message
//
//  RETURN VALUE:
//
//    Depends on message.  In general, return TRUE if we process it.
//
//  COMMENTS:
//
//--------------------------------------------------------------------------------
INT_PTR CALLBACK SchedWizardConnectionDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    WORD wNotifyCode = HIWORD(wParam); // notification code
 
    switch (uMessage)
    {
        case WM_INITDIALOG:
            
            if (g_pSelectItemsPage)
                g_pSelectItemsPage->Initialize(hDlg);

            InitPage(hDlg,lParam);
            break;

        case WM_DESTROY:
            if (g_pSelectItemsPage)
            {
                g_pSelectItemsPage->FreeItemsFromListView();
                g_pSelectItemsPage->FreeRas();
                                
                                if (g_pSelectItemsPage->m_pListView)
                                {
                                    delete g_pSelectItemsPage->m_pListView;
                                }

            }
            break;

        case WM_HELP: 
        {
            LPHELPINFO lphi  = (LPHELPINFO)lParam;

            if (lphi->iContextType == HELPINFO_WINDOW)  
            {
                WinHelp ( (HWND) lphi->hItemHandle,
                    szSyncMgrHelp, 
                    HELP_WM_HELP, 
                    (ULONG_PTR) g_aContextHelpIds);
            }           
            return TRUE;
        }
        case WM_CONTEXTMENU:
        {
            WinHelp ((HWND)wParam,
                            szSyncMgrHelp, 
                            HELP_CONTEXTMENU,
                           (ULONG_PTR)g_aContextHelpIds);
            
            return TRUE;
        }
        case WM_PAINT:
            WmPaint(hDlg, uMessage, wParam, lParam);
            break;

        case WM_PALETTECHANGED:
            WmPaletteChanged(hDlg, wParam);
            break;

        case WM_QUERYNEWPALETTE:
            return( WmQueryNewPalette(hDlg) );
            break;

        case WM_ACTIVATE:
            return( WmActivate(hDlg, wParam, lParam) );
            break;

        case WM_NOTIFYLISTVIEWEX:

            if (g_pSelectItemsPage)
            {
            int idCtrl = (int) wParam; 
            LPNMHDR pnmhdr = (LPNMHDR) lParam;

                if ( (IDC_SCHEDUPDATELIST != idCtrl) || (NULL == g_pSelectItemsPage->m_pListView))
                {
                    Assert(IDC_SCHEDUPDATELIST == idCtrl);
                    Assert(g_pSelectItemsPage->m_pListView);
                    break;
                }

                switch (pnmhdr->code)
                {
                    case LVNEX_ITEMCHECKCOUNT:
                    {
            LPNMLISTVIEWEXITEMCHECKCOUNT pnmvCheckCount = (LPNMLISTVIEWEXITEMCHECKCOUNT) lParam; 
                    
                        g_pSelectItemsPage->SetItemCheckState(pnmvCheckCount->iCheckCount);

                        break;
                    }
                    default:
                        break;
                }
            }
            break;

        case WM_NOTIFY:
            if (g_pSelectItemsPage)
            {
            int idCtrl = (int) wParam; 
            LPNMHDR pnmhdr = (LPNMHDR) lParam;


                // if notification for UpdateListPass it on.
                if ((IDC_SCHEDUPDATELIST == idCtrl) && g_pSelectItemsPage->m_pListView)
                {
                    g_pSelectItemsPage->m_pListView->OnNotify(pnmhdr);
                    break;
                }
                
            }

        switch (((NMHDR FAR *)lParam)->code)
            {
        case PSN_KILLACTIVE:
            break;
        case PSN_RESET:
            break;
        case PSN_SETACTIVE:
            if (g_pSelectItemsPage->m_pListView
                                && (0 == g_pSelectItemsPage->m_pListView->GetCheckedItemsCount()) )
            {
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK ) ; 
            }
            else
            { 
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
            }
            
                SetWindowLongPtr(hDlg,  DWLP_MSGRESULT, 0);
            break;
        case PSN_WIZNEXT:
            //shouldn't save this until finish
            //this guy is only called if the dialog is a wizard
                   break;                       
                default:
                    break;
            }
            break;
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
            case IDC_SCHEDUPDATECOMBO:
            {               
                if (wNotifyCode == CBN_SELCHANGE)
                {
                HWND hwndCombo = (HWND) lParam;
                if (g_pSelectItemsPage)
                {
                    g_pSelectItemsPage->SetConnectionDirty();
                                        
                                        
                    g_pSelectItemsPage->ShowItemsOnThisConnection
                                (ComboBox_GetCurSel(hwndCombo), FALSE);
                                        
                }
                }
            }
            break;

            case IDC_AUTOCONNECT:
                {
                if (wNotifyCode == BN_CLICKED) 
                {
                    PropSheet_Changed(GetParent(hDlg), hDlg);
        
                    HWND hwndCtrl = (HWND) lParam;
                    g_pSelectItemsPage->SetCheck(LOWORD(wParam),
                                        Button_GetCheck(hwndCtrl));
            
                }
                }
            break;
            
            default:
                        break;

            }
            break;

        default:
            return FALSE;
    }
    return TRUE;   
}


    
    
//+--------------------------------------------------------------------------
//
//  Member:     CSelectItemsPage::CSelectItemsPage
//
//  Synopsis:   ctor
//
//              [phPSP]                - filled with prop page handle
//
//  History:    11-21-1997   SusiA   
//
//---------------------------------------------------------------------------

CSelectItemsPage::CSelectItemsPage(
    HINSTANCE hinst,
    BOOL *pfSaved,
    ISyncSchedule *pISyncSched,
        HPROPSHEETPAGE *phPSP,
    int iDialogResource)
{
    ZeroMemory(&m_psp, sizeof(m_psp));

        Assert(pISyncSched);

    m_psp.dwSize = sizeof (PROPSHEETPAGE);
    m_psp.dwFlags = PSH_DEFAULT;
    m_psp.hInstance = hinst;
    m_psp.pszTemplate = MAKEINTRESOURCE(iDialogResource);
    m_psp.pszIcon = NULL;
    m_psp.pfnDlgProc = SchedWizardConnectionDlgProc;
    m_psp.lParam = 0;

    m_iCreationKind = iDialogResource;
    g_pSelectItemsPage = this;
    m_pISyncSched = pISyncSched;
    m_pISyncSched->AddRef();
    m_pfSaved = pfSaved;
    *m_pfSaved = FALSE;


    m_pListView = NULL;

    m_fItemsChanged = FALSE;
    m_fConnectionFlagChanged = FALSE;
    m_fConnectionChanged = FALSE;

        // attempt to get our private interface
        if (NOERROR != pISyncSched->QueryInterface(IID_ISyncSchedulep,(void **) &m_pISyncSchedp))
        {
            m_pISyncSchedp = NULL;
        }

    
   *phPSP = CreatePropertySheetPage(&m_psp);


}


CSelectItemsPage::~CSelectItemsPage()
{

    if (m_pISyncSchedp)
    {
        m_pISyncSchedp->Release();
    }
}


//+--------------------------------------------------------------------------
//
//  Member:     CSelectItemsPage::FreeRas()
//
//  History:    12-Mar-1998   SusiA   
//
//---------------------------------------------------------------------------
void CSelectItemsPage::FreeRas()
{
    if (m_pRas)
        delete m_pRas;

}

//+--------------------------------------------------------------------------
//
//  Member:     CSelectItemsPage::Initialize(HWND hwnd)
//
//  Synopsis:   initialize the item selection page and set the task name to a unique 
//              new onestop name
//
//  History:    11-21-1997   SusiA   
//
//---------------------------------------------------------------------------

BOOL CSelectItemsPage::Initialize(HWND hwnd)
{
    m_hwnd = hwnd;
    // Initialize Ras Combo box
    m_pRas= new CRasUI();
    
    if (NULL == m_pRas || FALSE == m_pRas->Initialize())
    {
        if (m_pRas)
            delete m_pRas;
        return FALSE;
    }
    m_hwndRasCombo = GetDlgItem(m_hwnd,IDC_SCHEDUPDATECOMBO);
    
    m_pRas->FillRasCombo(m_hwndRasCombo,FALSE,TRUE);

    InitializeItems();
    
    //initialize the item list
    HWND hwndList = GetDlgItem(m_hwnd,IDC_SCHEDUPDATELIST);
    LV_COLUMN columnInfo;
    HIMAGELIST himage;
    INT iItem = -1;
    UINT ImageListflags;

    
    m_pListView = new CListView(hwndList,m_hwnd,IDC_SCHEDUPDATELIST,WM_NOTIFYLISTVIEWEX);
    if (NULL == m_pListView)
    {
        return FALSE;
    }

    m_pListView->SetExtendedListViewStyle(LVS_EX_CHECKBOXES |  LVS_EX_FULLROWSELECT |  LVS_EX_INFOTIP );

    ImageListflags = ILC_COLOR | ILC_MASK;
    if (IsHwndRightToLeft(hwnd))
    {
        ImageListflags |=  ILC_MIRROR;
    }

    // create an imagelist
    himage = ImageList_Create( GetSystemMetrics(SM_CXSMICON),
                     GetSystemMetrics(SM_CYSMICON),ImageListflags,5,20);
    if (himage)
    {
       m_pListView->SetImageList(himage,LVSIL_SMALL);
    }
  
    // Insert the Proper columns

    columnInfo.mask = LVCF_FMT  | LVCF_TEXT  | LVCF_WIDTH  | LVCF_SUBITEM;
    columnInfo.fmt = LVCFMT_LEFT;
    columnInfo.cx = CalcListViewWidth(hwndList,295);
    columnInfo .pszText = TEXT("");
    columnInfo.cchTextMax = 1;
    columnInfo.iSubItem = 0;
    m_pListView->InsertColumn(0,&columnInfo);
    
    ShowItemsOnThisConnection(ComboBox_GetCurSel(m_hwndRasCombo), FALSE);

    //Wizard creation
    if (m_iCreationKind != IDD_SCHEDPAGE_ITEMS)
    {
        SetConnectionDirty();
    }
    ShowWindow(m_hwnd, /* nCmdShow */ SW_SHOWNORMAL ); 
    UpdateWindow(m_hwnd);

    return TRUE;

}

//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CSelectItemsPage::InitializeItems()
//
//  PURPOSE: initialize the handler for the schedule wizard page
//
//  RETURN VALUE: return TRUE if we process it ok.
//
//+-------------------------------------------------------------------------------

BOOL CSelectItemsPage::InitializeItems()
{
    int i,
        iConnectionCount;
    TCHAR ptszComboConnName[RAS_MaxEntryName + 1];

    TCHAR ptszConnectionName[RAS_MaxEntryName + 1];
    WCHAR pwszConnectionName[RAS_MaxEntryName + 1];
    
    DWORD cchConnectionName = ARRAYSIZE(pwszConnectionName);
    DWORD dwConnType;

    m_fItemsChanged = FALSE;
    m_fConnectionFlagChanged = FALSE;
    m_fConnectionChanged = FALSE;

    if (FAILED(m_pISyncSched->GetConnection(&cchConnectionName,pwszConnectionName, &dwConnType)) ||
        FAILED(StringCchCopy(ptszConnectionName, ARRAYSIZE(ptszConnectionName), pwszConnectionName)))
    {
        return FALSE;
    }

    iConnectionCount= ComboBox_GetCount(m_hwndRasCombo);        
    
    //Initialize the Schedule connection settings
    COMBOBOXEXITEM comboItem;
      
    for (i=0; i< iConnectionCount; i++)
    {
        comboItem.mask = CBEIF_TEXT;
        comboItem.cchTextMax = ARRAYSIZE(ptszComboConnName);
        comboItem.pszText = ptszComboConnName;
        comboItem.iItem = i;

        // Review, handle failures.
        SendMessage(m_hwndRasCombo, CBEM_GETITEM, (WPARAM) 0, (LPARAM) &comboItem);

        m_SchedConnectionNum = 0;
        
        if (lstrcmp(ptszComboConnName, ptszConnectionName) == 0)
        {
            //Current connection to sync over for the schedule.
            m_SchedConnectionNum = i;
            ComboBox_SetCurSel(m_hwndRasCombo, i);
            break;
        }
    }
    //Set the default autoconnect check state  
    m_pISyncSched->GetFlags(&m_dwFlags);
            
    Button_SetCheck(GetDlgItem(m_hwnd,IDC_AUTOCONNECT),
                    m_dwFlags & SYNCSCHEDINFO_FLAGS_AUTOCONNECT);

    return TRUE;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSelectItemsPage::SetConnectionDirty()
//
//  PURPOSE:  we have changed the connection info
//
//  COMMENTS: Only called frm prop sheet; not wizard
//
//--------------------------------------------------------------------------------
void CSelectItemsPage::SetConnectionDirty()
{
    m_fConnectionChanged = TRUE;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CSelectItemsPage::CommitChanges()
//
//  PURPOSE:  Write all the current Schedule Settings to the registry
//
//  COMMENTS: Implemented on main thread.
//
//--------------------------------------------------------------------------------
HRESULT CSelectItemsPage::CommitChanges()
{
    HRESULT hr = S_OK;
    
    if (m_fConnectionFlagChanged)
    {
        m_pISyncSched->SetFlags(m_dwFlags);
    }

    if (m_fConnectionChanged)
    {
        m_pISyncSched->SetConnection(m_pwszConnectionName, m_dwConnType);
    }
    if (m_fItemsChanged) 
    {
        int iTotalItems = m_pListView->GetItemCount();

        //Now set the check state with ISyncSched
        BOOL fChecked;
        int iItem;

                for (iItem=0;iItem < iTotalItems;iItem++)
        {

                        fChecked = (LVITEMEXSTATE_CHECKED == m_pListView->GetCheckState(iItem)) ? TRUE : FALSE;
            
            LVITEMEX lvItem;
            ZeroMemory(&lvItem, sizeof(lvItem));

            lvItem.mask = LVIF_PARAM;
                        lvItem.maskEx = 0;
            lvItem.iItem = iItem;
            lvItem.lParam = 0;

            if (m_pListView->GetItem(&lvItem) && lvItem.lParam) // lparam is zero for toplevel items
            {   
                LPSYNC_HANDLER_ITEM_INFO pHandlerItem = (LPSYNC_HANDLER_ITEM_INFO) lvItem.lParam;
                if (fChecked)
                {
                    m_pISyncSched->SetItemCheck(pHandlerItem->handlerID,
                                                &(pHandlerItem->itemID),
                                                SYNCMGRITEMSTATE_CHECKED);
                }
                else
                {
                    m_pISyncSched->SetItemCheck(pHandlerItem->handlerID,
                                                &(pHandlerItem->itemID),
                                                SYNCMGRITEMSTATE_UNCHECKED);
                }
            }
        }
    }

    hr = m_pISyncSched->Save();

    if (hr == S_OK)
    {
        *m_pfSaved = TRUE; 
    }

    return hr;

}

//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CSelectItemsPage::SetItemCheckState()
//
//  PURPOSE: set the selected check state
//
//  RETURN VALUE: return TRUE if we process it ok.
//
//+-------------------------------------------------------------------------------
BOOL CSelectItemsPage::SetItemCheckState(int iCheckCount)
{
int iConnectionItem = ComboBox_GetCurSel(m_hwndRasCombo);
    
    //The check state is message is getting flagged by us programmatically setting it,
    // until after we are done initializing.
    if (m_Initialized)
    {
    BOOL fAnyChecked = iCheckCount ? TRUE : FALSE;
        
    //Enable the prompt me first according to what items selected
    //EnableWindow(GetDlgItem(m_hwnd,IDC_AUTOPROMPT_ME_FIRST), m_fAnyChecked);
    
    PropSheet_Changed(GetParent(m_hwnd), m_hwnd);

    //Enable the next button according to what items are selected
    // should only be disabled iff ALL connection items are
    // unselected, not just the current connections selection's
    if (fAnyChecked) 
        PropSheet_SetWizButtons(GetParent(m_hwnd), PSWIZB_BACK | PSWIZB_NEXT);
    else
        PropSheet_SetWizButtons(GetParent(m_hwnd), PSWIZB_BACK);

    m_fItemsChanged = TRUE;
    }
    return TRUE;
}
//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CSelectItemsPage::SetCheck(WORD wParam,DWORD dwCheckState)
//
//  PURPOSE: set the selected check state
//
//  RETURN VALUE: return TRUE if we process it ok.
//
//+-------------------------------------------------------------------------------
BOOL CSelectItemsPage::SetCheck(WORD wParam,DWORD dwCheckState)
{
    if (wParam == IDC_AUTOCONNECT)
    {
        int iConnectionItem = ComboBox_GetCurSel(m_hwndRasCombo);

        //preserve Readonly state
        m_dwFlags &= SYNCSCHEDINFO_FLAGS_READONLY;

        //set new autoconnect state
        if (dwCheckState)
        {
            m_dwFlags |= SYNCSCHEDINFO_FLAGS_AUTOCONNECT;
        }
        
        if (m_Initialized)
        {
            m_fConnectionFlagChanged = TRUE;
        }

    }
    return TRUE;

}
//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CSelectItemsPage::FreeItemsFromListView()
//
//  PURPOSE:  free the items on this Schedule 
//
//  RETURN VALUE: return TRUE if we process it ok.
//
//+-------------------------------------------------------------------------------
BOOL CSelectItemsPage::FreeItemsFromListView()
{
    int iItem;
    int iItemCount;

    HWND hwndListView = GetDlgItem(m_hwnd,IDC_SCHEDUPDATELIST);
    
    iItemCount = m_pListView->GetItemCount();       
    
    for(iItem = 0; iItem < iItemCount; iItem++)
    {
        LPSYNC_HANDLER_ITEM_INFO pHandlerItem; 
        LVITEMEX lvItem;

        ZeroMemory(&lvItem, sizeof(lvItem));
        lvItem.mask = LVIF_PARAM;
        lvItem.maskEx = 0;
        lvItem.iItem = iItem;

        if (m_pListView->GetItem(&lvItem) && lvItem.lParam)
        {
            pHandlerItem = (LPSYNC_HANDLER_ITEM_INFO) lvItem.lParam;
            FREE(pHandlerItem);
        }
    }
    return TRUE;
}
//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CSelectItemsPage::ShowItemsOnThisConnection()
//
//  PURPOSE: List the items on this connection for the Schedule page
//
//  RETURN VALUE: return TRUE if we process it ok.
//
//+-------------------------------------------------------------------------------
BOOL CSelectItemsPage::ShowItemsOnThisConnection(int iItem, BOOL fClear)
{
    TCHAR ptszConnectionName[RAS_MaxEntryName + 1];
    
    // set up the list view
    if (!m_pListView || !m_pISyncSchedp)
    {
        return FALSE;
    }
    
    HIMAGELIST himage;
    LVITEMEX itemInfo;
    
    m_Initialized = FALSE;          
    
    //Note:  Use text to "uniquely" identify connection on RAS
    //change to using GUID on connection objects
    int iNumConnections = ComboBox_GetCount(m_hwndRasCombo);
    
    m_SchedConnectionNum = iItem;
    
    COMBOBOXEXITEM comboItem;
    comboItem.mask = CBEIF_TEXT | CBEIF_LPARAM;
    comboItem.cchTextMax = ARRAYSIZE(ptszConnectionName);
    comboItem.pszText = ptszConnectionName;
    comboItem.iItem = iItem;
    
    // Review, handle failures.
    SendMessage(m_hwndRasCombo, CBEM_GETITEM, 0, (LPARAM) &comboItem);
    
    //SetConnectionName
    if (FAILED(StringCchCopy(m_pwszConnectionName, ARRAYSIZE(m_pwszConnectionName), ptszConnectionName)))
    {
        return FALSE;
    }
    m_dwConnType = (DWORD) comboItem.lParam;
    
    // if don't need to clear and listview contains items then we are done
    if (!fClear && m_pListView->GetItemCount())
    {
        m_Initialized = TRUE;
        return TRUE;
    }
    
    //first clear out the list view
    FreeItemsFromListView();
    m_pListView->DeleteAllItems();
    
    
    // Review, dont' clear ImageList so just keeps getting bigger as change connections.
    himage = m_pListView->GetImageList(LVSIL_SMALL );
    
    //Enumerate the Items
    IEnumSyncItems *pIEnum;
    LPSYNC_HANDLER_ITEM_INFO pHandlerItem = (LPSYNC_HANDLER_ITEM_INFO) 
        ALLOC(sizeof(SYNC_HANDLER_ITEM_INFO));
    
    ULONG ulFetched;
    
    if (FAILED(m_pISyncSchedp->EnumItems(GUID_NULL, &pIEnum)))
    {
        return FALSE;
    }
    
    
    while (pHandlerItem && S_OK == pIEnum->Next(1,pHandlerItem, &ulFetched))
    {
        LVHANDLERITEMBLOB lvHandlerItemBlob;
        int iParentItemId;
        BOOL fHandlerParent = TRUE; // always have a parent for now.
        
        // Check if item is already in the ListView and if so
        // go on
        
        lvHandlerItemBlob.cbSize = sizeof(LVHANDLERITEMBLOB);
        lvHandlerItemBlob.clsidServer = pHandlerItem->handlerID;
        lvHandlerItemBlob.ItemID = pHandlerItem->itemID;
        
        if (-1 != m_pListView->FindItemFromBlob((LPLVBLOB) &lvHandlerItemBlob))
        {
            // already in ListView, go on to the next item.
            continue;
        }
        
        if (!fHandlerParent)
        {
            iParentItemId = LVI_ROOT;
        }
        else
        {
            // need to add to list so find parent and if one doesn't exist, create it.
            lvHandlerItemBlob.cbSize = sizeof(LVHANDLERITEMBLOB);
            lvHandlerItemBlob.clsidServer = pHandlerItem->handlerID;
            lvHandlerItemBlob.ItemID = GUID_NULL;
            
            iParentItemId = m_pListView->FindItemFromBlob((LPLVBLOB) &lvHandlerItemBlob);
            
            if (-1 == iParentItemId)
            {
                LVITEMEX itemInfoParent;
                SYNCMGRHANDLERINFO *pSyncMgrHandlerInfo;
                
                // if can't get the ParentInfo then don't add the Item
                if (NOERROR != m_pISyncSchedp->GetHandlerInfo(pHandlerItem->handlerID,&pSyncMgrHandlerInfo) )
                {
                    continue;
                }
                
                // Insert the Parent.
                itemInfoParent.mask = LVIF_TEXT | LVIF_PARAM;
                itemInfoParent.iItem = LVI_LAST;
                itemInfoParent.iSubItem = 0;
                itemInfoParent.lParam = 0;
                itemInfoParent.iImage = -1;
                
                itemInfoParent.pszText = pSyncMgrHandlerInfo->wszHandlerName;
                if (himage)
                {
                    HICON hIcon = pSyncMgrHandlerInfo->hIcon ? pSyncMgrHandlerInfo->hIcon : pHandlerItem->hIcon;
                    
                    // if have toplevel handler info icon use this else use the
                    // items icon
                    
                    if (hIcon &&  (itemInfoParent.iImage = 
                        ImageList_AddIcon(himage,hIcon)) )
                    {
                        itemInfoParent.mask |= LVIF_IMAGE ; 
                    }
                }
                
                // save the blob
                itemInfoParent.maskEx = LVIFEX_BLOB;
                itemInfoParent.pBlob = (LPLVBLOB) &lvHandlerItemBlob;
                
                iParentItemId = m_pListView->InsertItem(&itemInfoParent);
                
                CoTaskMemFree(pSyncMgrHandlerInfo);
                
                // if parent insert failed go onto the next item
                if (-1 == iParentItemId)
                {
                    continue;
                }
            }
        }
        
        
        itemInfo.mask = LVIF_TEXT | LVIF_PARAM; 
        itemInfo.maskEx = LVIFEX_PARENT | LVIFEX_BLOB;
        itemInfo.iItem = LVI_LAST; 
        itemInfo.iSubItem = 0; 
        
        itemInfo.lParam = (LPARAM)pHandlerItem;
        itemInfo.pszText = pHandlerItem->wszItemName; 
        itemInfo.iImage = -1;       // index of the list view item?s icon 
        if (himage && pHandlerItem->hIcon)
        {
            itemInfo.iImage = 
                ImageList_AddIcon(himage,pHandlerItem->hIcon);
            
            itemInfo.mask |= LVIF_IMAGE; 
            
        }
        
        itemInfo.iParent = iParentItemId;
        
        // setup the blob
        lvHandlerItemBlob.ItemID = pHandlerItem->itemID;
        itemInfo.pBlob = (LPLVBLOB) &lvHandlerItemBlob;
        
        itemInfo.iItem = m_pListView->InsertItem(&itemInfo);
        
        if (-1 == itemInfo.iItem)
        {
            continue;
        }
        
        //Set the check state of the item
        itemInfo.mask = LVIF_STATE; 
        itemInfo.stateMask= LVIS_STATEIMAGEMASK; 
        
        if (fClear)
        {
            itemInfo.state = LVIS_STATEIMAGEMASK_UNCHECK;
            m_fItemsChanged = TRUE;
        }
        else
        {
            itemInfo.state = pHandlerItem->dwCheckState == SYNCMGRITEMSTATE_UNCHECKED ?
LVIS_STATEIMAGEMASK_UNCHECK : LVIS_STATEIMAGEMASK_CHECK ;
        }
        
        
        m_pListView->SetItem(&itemInfo);
        
        pHandlerItem = (LPSYNC_HANDLER_ITEM_INFO) ALLOC(sizeof(SYNC_HANDLER_ITEM_INFO));
        
    }
    
    
    if (m_pListView->GetItemCount())
    {
        m_pListView->SetItemState(0,
            LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED );
    }
    
    //free the last one we created, we didn't use it.
    if (pHandlerItem)
    {
        FREE(pHandlerItem);
    }
    
    pIEnum->Release();
    
    m_Initialized = TRUE;           
    
    if (m_pListView->GetCheckedItemsCount()) 
    {
        PropSheet_SetWizButtons(GetParent(m_hwnd), PSWIZB_BACK | PSWIZB_NEXT);
    }
    else  
    {
        PropSheet_SetWizButtons(GetParent(m_hwnd), PSWIZB_BACK); 
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\exe\callback.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Callback.h
//
//  Contents:   Callback implementation
//
//  Classes:    COfflineSychronizeCallback
//
//  Notes:
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#ifndef _SYNCCALLBACK_
#define _SYNCCALLBACK_

class CHndlrMsg;
class CThreadMsgProxy;


class COfflineSynchronizeCallback: public ISyncMgrSynchronizeCallback ,
                                   public IOldSyncMgrSynchronizeCallback, // OLD IDL
                                   CLockHandler
{
public:
    COfflineSynchronizeCallback(CHndlrMsg *pHndlrMsg,
                            CLSID CLSIDServer,DWORD dwSyncFlags,BOOL fAllowModeless);
    ~COfflineSynchronizeCallback();

    //IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // Callback methods.
    STDMETHODIMP Progress(REFSYNCMGRITEMID ItemID,LPSYNCMGRPROGRESSITEM lpSyncProgressItem);
    STDMETHODIMP PrepareForSyncCompleted(HRESULT hr);
    STDMETHODIMP SynchronizeCompleted(HRESULT hr);

    STDMETHODIMP EnableModeless(BOOL fEnable);
    STDMETHODIMP LogError(DWORD dwErrorLevel,const WCHAR *lpcErrorText,LPSYNCMGRLOGERRORINFO lpSyncLogError);
    STDMETHODIMP DeleteLogError(REFSYNCMGRERRORID ErrorID,DWORD dwReserved);
    STDMETHODIMP EstablishConnection( WCHAR const * lpwszConnection, DWORD dwReserved);

    // new callback methods
    STDMETHODIMP ShowPropertiesCompleted(HRESULT hr);
    STDMETHODIMP ShowErrorCompleted(HRESULT hr,ULONG cbNumItems,SYNCMGRITEMID *pItemIDs);


    // called by hndlrMsg
    void SetHndlrMsg(CHndlrMsg *pHndlrMsg,BOOL fForceKilled);
    void SetEnableModeless(BOOL fAllowModeless);

private:
    void CallCompletionRoutine(DWORD dwThreadMsg,HRESULT hCallResult,ULONG cbNumItems,SYNCMGRITEMID *pItemIDs);

    CHndlrMsg *m_pHndlrMsg;
    ULONG m_cRef;
    BOOL m_fSynchronizeCompleted;
    DWORD m_dwSyncFlags;
    BOOL m_fAllowModeless;
    BOOL m_fForceKilled;
    CLSID m_CLSIDServer;

};



#endif // _SYNCCALLBACK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\exe\callback.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Callback.cpp
//
//  Contents:   Calback implementation
//
//  Classes:    COfflineSynchronizeCallback
//
//  Notes:
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

//+---------------------------------------------------------------------------
//
//  Member:     COfflineSynchronizeCallback::COfflineSynchronizeCallback, public
//
//  Synopsis:   Constructor
//
//  Arguments:  [pHndlrMsg] - pointer to CHndlrMsg class this callback belongs too.
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

COfflineSynchronizeCallback::COfflineSynchronizeCallback(CHndlrMsg *pHndlrMsg
                                                         ,CLSID CLSIDServer
                                                         ,DWORD dwSyncFlags
                                                         ,BOOL fAllowModeless)
{
    Assert(pHndlrMsg);

    m_pHndlrMsg = pHndlrMsg;
    m_CLSIDServer = CLSIDServer;
    m_dwSyncFlags = dwSyncFlags;
    m_cRef = 1;
    m_fSynchronizeCompleted = FALSE;
    m_fAllowModeless = fAllowModeless;
    m_fForceKilled = FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     COfflineSynchronizeCallback::~COfflineSynchronizeCallback, public
//
//  Synopsis:   Destructor
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

COfflineSynchronizeCallback::~COfflineSynchronizeCallback()
{
    Assert(FALSE == m_fForceKilled); // should never get cleaned up of force killed.
    Assert(NULL == m_pHndlrMsg);
    Assert(0 == m_cRef);
}

//+---------------------------------------------------------------------------
//
//  Member:     COfflineSynchronizeCallback::QueryInterface, public
//
//  Synopsis:   Standard QueryInterface
//
//  Arguments:  [iid] - Interface ID
//              [ppvObj] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP  COfflineSynchronizeCallback::QueryInterface (REFIID riid, LPVOID * ppvObj)
{
    *ppvObj = NULL;

    if( IsEqualIID( riid, IID_IUnknown ) )
        *ppvObj = (LPVOID) this;
    else if ( IsEqualIID( riid, IID_ISyncMgrSynchronizeCallback ) )
        *ppvObj = (LPVOID)(LPSYNCMGRSYNCHRONIZECALLBACK) this;
    else if ( IsEqualIID( riid, IID_IOldSyncMgrSynchronizeCallback ) )
    {
        // This is for the Old IDL This is the old IE 5.0 Beta1 interface
        // no one shipped using it so it can safely be removed.
        *ppvObj = (LPVOID)(LPOLDSYNCMGRSYNCHRONIZECALLBACK) this;
    }
    else
        return E_NOINTERFACE;

    AddRef();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     COfflineSynchronizeCallback::AddRef, public
//
//  Synopsis:   Add reference
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

DWORD COfflineSynchronizeCallback::AddRef()
{
ULONG cRefs;

    cRefs = InterlockedIncrement((LONG *)& m_cRef);
    return cRefs;
}

//+---------------------------------------------------------------------------
//
//  Member:     COfflineSynchronizeCallback::Release, public
//
//  Synopsis:   Release reference
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

DWORD COfflineSynchronizeCallback::Release()
{
ULONG cRefs;

    cRefs = InterlockedDecrement( (LONG *) &m_cRef);

    if (0 == cRefs)
    {
        delete this;
    }

    return cRefs;
}


//+---------------------------------------------------------------------------
//
//  Member:     COfflineSynchronizeCallback::EnableModeless, public
//
//  Synopsis:   EnableModeless method - Currently always returns S_OK
//
//  Arguments:  [fEnable] - Boolean (TRUE == request to bring up dialog,
//                              FALSE == the dialog has been dismissed.
//
//  Returns:    S_OK if handler can perform the request
//              S_FALSE if dialog shouldn't be displayed.
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP COfflineSynchronizeCallback::EnableModeless(BOOL fEnable)
{
HRESULT hr = S_OK;

    if (m_fForceKilled)
    {
        return S_FALSE;
    }

    if (!m_fAllowModeless && fEnable)
    {
        hr = S_FALSE;
    }

    if (m_pHndlrMsg)
    {
    BOOL fAttach = FALSE;

        if (fEnable && (S_OK == hr)) // Attach Thread input if want dialog and it was granted.
        {
            fAttach = TRUE;
        }

        m_pHndlrMsg->AttachThreadInput(fAttach);
    }


    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     COfflineSynchronizeCallback::Progress, public
//
//  Synopsis:   Called by Handlers to update progress information.
//
//  Arguments:  [ItemID] - Identifies Item Progress information pertains to
//              [lpSyncProgressItem] - Pointer to ProgressItem Structure.
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP COfflineSynchronizeCallback::Progress(REFSYNCMGRITEMID ItemID,
                                        LPSYNCMGRPROGRESSITEM lpSyncProgressItem)
{
HRESULT hr = E_UNEXPECTED;
CHndlrQueue *pHndlrQueue = NULL;
HANDLERINFO *pHandlerID = 0;
DWORD dwProxyThreadId;
CLock clockCallback(this);

    if (m_fForceKilled)
    {
        return S_SYNCMGR_CANCELALL;
    }

    clockCallback.Enter();

    Assert(m_pHndlrMsg);

    if (m_pHndlrMsg)
    {
        m_pHndlrMsg->GetHndlrQueue(&pHndlrQueue,&pHandlerID,&dwProxyThreadId);
    }

    clockCallback.Leave();

    if (pHndlrQueue)
    {
        hr = pHndlrQueue->Progress(pHandlerID,
                                            ItemID,lpSyncProgressItem);

        pHndlrQueue->Release(); // release our reference put on by GetHndlrQueue
    }

    return hr;
}


STDMETHODIMP COfflineSynchronizeCallback::PrepareForSyncCompleted(HRESULT hCallResult)
{
    CallCompletionRoutine(ThreadMsg_PrepareForSync,hCallResult,0,NULL);
    return S_OK;
}


STDMETHODIMP COfflineSynchronizeCallback::SynchronizeCompleted(HRESULT hCallResult)
{
    CallCompletionRoutine(ThreadMsg_Synchronize,hCallResult,0,NULL);
    return S_OK;
}

STDMETHODIMP  COfflineSynchronizeCallback::ShowPropertiesCompleted(HRESULT hCallResult)
{
   CallCompletionRoutine(ThreadMsg_ShowProperties,hCallResult,0,NULL);
   return S_OK;
}

STDMETHODIMP  COfflineSynchronizeCallback::ShowErrorCompleted(HRESULT hCallResult,ULONG cbNumItems,SYNCMGRITEMID *pItemIDs)
{

    CallCompletionRoutine(ThreadMsg_ShowError,hCallResult,cbNumItems,pItemIDs);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     COfflineSynchronizeCallback::LogError, public
//
//  Synopsis:   Called by Handlers to log and Error.
//
//  Arguments:  [dwErrorLevel] - ErrorLevel of the Log
//              [lpcErrorText] - Text Associated with the error.
//              [lpSyncLogError] - Additional Error information.
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP COfflineSynchronizeCallback::LogError(DWORD dwErrorLevel,
                        const WCHAR *lpcErrorText,LPSYNCMGRLOGERRORINFO lpSyncLogError)
{
HRESULT hr = E_UNEXPECTED;
CHndlrQueue *pHndlrQueue = NULL;
HANDLERINFO *pHandlerID = 0;
DWORD dwProxyThreadId;
CLock clockCallback(this);

    if (m_fForceKilled)
    {
        return S_OK;
    }

    clockCallback.Enter();

    Assert(m_pHndlrMsg);

    if (m_pHndlrMsg)
    {
        m_pHndlrMsg->GetHndlrQueue(&pHndlrQueue,&pHandlerID,&dwProxyThreadId);
    }

    clockCallback.Leave();

    if (pHndlrQueue)
    {
        hr = pHndlrQueue->LogError(pHandlerID,
                dwErrorLevel, lpcErrorText,lpSyncLogError);

        pHndlrQueue->Release(); // release our reference put on by GetHndlrQueue

    }

    return hr;

}


//+---------------------------------------------------------------------------
//
//  Member:     COfflineSynchronizeCallback::LogError, public
//
//  Synopsis:   Called by Handlers to delete an error that
//              was previously logged.
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    13-Mar-98      rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP COfflineSynchronizeCallback::DeleteLogError(REFSYNCMGRERRORID ErrorID,DWORD dwReserved)
{
HRESULT hr = E_UNEXPECTED;
CHndlrQueue *pHndlrQueue = NULL;
HANDLERINFO *pHandlerID = 0;
DWORD dwProxyThreadId;
CLock clockCallback(this);

    if (m_fForceKilled)
    {
        return S_OK;
    }

    if (dwReserved)
    { 
        AssertSz(0,"DeleteLogError Reserved must be zero");
        return E_INVALIDARG;
    }

    clockCallback.Enter();

    Assert(m_pHndlrMsg);

    if (m_pHndlrMsg)
    {
        m_pHndlrMsg->GetHndlrQueue(&pHndlrQueue,&pHandlerID,&dwProxyThreadId);
    }

    clockCallback.Leave();

    if (pHndlrQueue)
    {
        hr = pHndlrQueue->DeleteLogError(pHandlerID,ErrorID,dwReserved);
        pHndlrQueue->Release(); // release our reference put on by GetHndlrQueue

    }

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Member:     COfflineSynchronizeCallback::EstablishConnection
//
//  Synopsis:   Called by Handlers to establish a net connection
//
//  Arguments:  [lpwszConnection] -- Connection string
//              [dwReserved]      -- Must be zero for now
//
//  History:    28-Jul-98      SitaramR        Created
//
//----------------------------------------------------------------------------

STDMETHODIMP COfflineSynchronizeCallback::EstablishConnection( WCHAR const * lpwszConnection,
                                                               DWORD dwReserved)
{

    if (m_fForceKilled)
    {
        return S_FALSE;
    }

    if ( dwReserved )
    {
        Assert( dwReserved == 0 );
        return E_INVALIDARG;
    }

    HRESULT hr = E_UNEXPECTED;

    CHndlrQueue *pHndlrQueue = NULL;
    HANDLERINFO *pHandlerID = 0;
    DWORD dwProxyThreadId;

    CLock clockCallback(this);

    clockCallback.Enter();

    Assert(m_pHndlrMsg);

    if (m_pHndlrMsg)
    {
        m_pHndlrMsg->GetHndlrQueue(&pHndlrQueue,&pHandlerID,&dwProxyThreadId);
    }

    clockCallback.Leave();

    if (pHndlrQueue)
    {
        hr = pHndlrQueue->EstablishConnection( pHandlerID,
                                               lpwszConnection,
                                               dwReserved);
        pHndlrQueue->Release(); // release our reference put on by GetHndlrQueue
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     COfflineSynchronizeCallback::SetHndlrMsg, public
//
//  Synopsis:   Called by CHndlrMsg to update the CHndlrMsg that owns the
//              callback. This currently should only be called with a paramater
//              of NULL for when the HndlrMsg is being destroyed.
//
//  Arguments:  [pHndlrMsg] - New CHndlrMsg the Callback belongs too.
//		[fForceKilled] - Set to True if HndlrMsg is removed because of a forcekill
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

void COfflineSynchronizeCallback::SetHndlrMsg(CHndlrMsg *pHndlrMsg,BOOL fForceKilled)
{
CLock clockCallback(this);

    Assert(NULL == pHndlrMsg); 
    Assert(FALSE == m_fForceKilled); // shouldn't get force killed twice

    clockCallback.Enter();
    m_pHndlrMsg = pHndlrMsg;
    m_fForceKilled = fForceKilled;
    clockCallback.Leave();
}


//+---------------------------------------------------------------------------
//
//  Member:     COfflineSynchronizeCallback::SetEnableModeless, private
//
//  Synopsis:   Called by CHndlrMsg to update inform the callback if
//              it is allowed to enablemodelsss.
//
//  Arguments:  
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

void COfflineSynchronizeCallback::SetEnableModeless(BOOL fAllowModeless)
{
CLock clockCallback(this);

    clockCallback.Enter();
    m_fAllowModeless = fAllowModeless;
    clockCallback.Leave();
}


//+---------------------------------------------------------------------------
//
//  Member:     COfflineSynchronizeCallback::CallCompletionRoutine, private
//
//  Synopsis:   Private helper method for calling completion routine.
//
//  Arguments:
//              DWORD dwThreadMsg - Identifies message belongs too.
//              HRESULT hCallResult - result of call
//              ULONG *pcbNumItems - only applies to ShowError
//              SYNCMGRITEMID **pItemIDs - only applies to ShowError
//
//  Returns:
//
//  Modifies:
//
//  History:    02-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void COfflineSynchronizeCallback::CallCompletionRoutine(DWORD dwThreadMsg,HRESULT hCallResult,ULONG cbNumItems,SYNCMGRITEMID *pItemIDs)
{
CHndlrQueue *pHndlrQueue = NULL;
HANDLERINFO *pHandlerID = 0;
DWORD dwProxyThreadId;
SYNCMGRITEMID itemIDShowProperties;
CLock clockCallback(this);

    if (m_fForceKilled)
    {
        return;
    }

    clockCallback.Enter();

    Assert(m_pHndlrMsg);

    if (m_pHndlrMsg)
    {
        // if this is a ShowProperties, fix up the item
        if (ThreadMsg_ShowProperties == dwThreadMsg)
        {
            cbNumItems = 1;
            itemIDShowProperties = m_pHndlrMsg->m_itemIDShowProperties;
            pItemIDs = &itemIDShowProperties;

            m_pHndlrMsg->m_itemIDShowProperties = GUID_NULL;
        }

        m_pHndlrMsg->GetHndlrQueue(&pHndlrQueue,&pHandlerID,&dwProxyThreadId);
        m_pHndlrMsg->AttachThreadInput(FALSE); // release any thread input that was set.
    }

    clockCallback.Leave();

    if (pHndlrQueue)
    {
        pHndlrQueue->CallCompletionRoutine(pHandlerID,dwThreadMsg,hCallResult,cbNumItems,pItemIDs);
        pHndlrQueue->Release(); // release our reference put on by GetHndlrQueue

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\exe\clsfact.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       ClsFact.h
//
//  Contents:   OneStop ClassFactory
//
//  Classes:    CClassFactory
//
//  Notes:      
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------


#ifndef _CLSFACT_
#define _CLSFACT_


//This class factory for OneStop EXE

class CClassFactory : public IClassFactory
{
protected:
	ULONG	m_cRef;

public:
	CClassFactory();
	~CClassFactory();

	//IUnknown members
	STDMETHODIMP		 QueryInterface( REFIID, LPVOID* );
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	//IClassFactory members
	STDMETHODIMP		CreateInstance( LPUNKNOWN, REFIID, LPVOID* );
	STDMETHODIMP		LockServer( BOOL );
};







#endif // _CLSFACT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\exe\choice.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Choice.cpp
//
//  Contents:   Implements the choice dialog
//
//  Classes:    CChoiceDlg
//
//  Notes:
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

const DlgResizeList g_ChoiceResizeList[] = {
    IDC_CHOICERESIZESCROLLBAR,DLGRESIZEFLAG_PINRIGHT | DLGRESIZEFLAG_PINBOTTOM,
    IDC_START,DLGRESIZEFLAG_PINRIGHT | DLGRESIZEFLAG_PINBOTTOM | DLGRESIZEFLAG_NOCOPYBITS,
    IDC_OPTIONS,DLGRESIZEFLAG_PINRIGHT | DLGRESIZEFLAG_PINBOTTOM | DLGRESIZEFLAG_NOCOPYBITS,
    IDC_CLOSE,DLGRESIZEFLAG_PINRIGHT | DLGRESIZEFLAG_PINBOTTOM | DLGRESIZEFLAG_NOCOPYBITS,
    IDC_CHOICELISTVIEW,DLGRESIZEFLAG_PINRIGHT | DLGRESIZEFLAG_PINBOTTOM | DLGRESIZEFLAG_PINTOP | DLGRESIZEFLAG_PINLEFT,
    IDC_PROPERTY,DLGRESIZEFLAG_PINRIGHT | DLGRESIZEFLAG_PINBOTTOM | DLGRESIZEFLAG_NOCOPYBITS,
};

TCHAR g_szSyncMgrHelp[]  = TEXT("mobsync.hlp");
ULONG g_aContextHelpIds[] =
{
    IDC_STATIC1,		        ((DWORD)  -1),
    IDC_STATIC2,		        ((DWORD)  -1),
    IDC_STATIC3,		        ((DWORD)  -1),
    IDC_STATIC4,		        ((DWORD)  -1),
    IDC_STATIC5,			((DWORD)  -1),
    IDC_UPDATEAVI,                      ((DWORD)  -1),
    IDC_RESULTTEXT,		        ((DWORD)  -1),	
    IDC_STATIC_SKIP_TEXT,	        ((DWORD)  -1),
    IDC_CHOICELISTVIEW,		        HIDC_CHOICELISTVIEW,
    IDC_CLOSE,			        HIDC_CLOSE,
    IDC_DETAILS,		        HIDC_DETAILS,
    IDC_LISTBOXERROR,		        HIDC_LISTBOXERROR,
    IDC_OPTIONS,		        HIDC_OPTIONS,
    IDC_PROGRESSBAR,	                HIDC_PROGRESSBAR,
    IDC_PROGRESS_OPTIONS_BUTTON_MAIN,	HIDC_PROGRESS_OPTIONS_BUTTON_MAIN,
    IDC_PROPERTY,		        HIDC_PROPERTY,	
    IDC_SKIP_BUTTON_MAIN,	        HIDC_SKIP_BUTTON_MAIN,
    IDC_START,			        HIDC_START,
    IDC_UPDATE_LIST,		        HIDC_UPDATE_LIST,
    IDC_PROGRESS_TABS,		        HIDC_PROGRESS_TABS,
    IDC_TOOLBAR,		        HIDC_PUSHPIN,
    IDSTOP,			        HIDSTOP,
    0, 0
};

extern HINSTANCE g_hInst;      // current instance
extern LANGID g_LangIdSystem; // langID of system we are running on.

//--------------------------------------------------------------------------------
//
//  FUNCTION: CChoiceDlg::CChoiceDlg()
//
//  PURPOSE:  Constructor
//
//	COMMENTS: Constructor for choice dialog
//
//
//--------------------------------------------------------------------------------

CChoiceDlg::CChoiceDlg(REFCLSID rclsid)
{
    m_fDead = FALSE;
    m_hwnd = NULL;
    m_nCmdShow = SW_SHOWNORMAL;
    m_pHndlrQueue = NULL;
    m_clsid = rclsid;
    m_dwThreadID = 0;
    m_fInternalAddref = FALSE;
    m_dwShowPropertiesCount = 0;
    m_fForceClose = FALSE;
    m_pItemListView = NULL;
    m_ulNumDlgResizeItem = 0;
    m_ptMinimizeDlgSize.x = 0;
    m_ptMinimizeDlgSize.y = 0;

    m_fHwndRightToLeft = FALSE;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CChoiceDlg::Initialize
//
//  PURPOSE:  Must be called before any other methods.
//
//
//--------------------------------------------------------------------------------

BOOL CChoiceDlg::Initialize(DWORD dwThreadID,int nCmdShow)
{

    m_nCmdShow = nCmdShow;

    Assert(NULL == m_hwnd);

    if (NULL == m_hwnd)
    {
	m_dwThreadID = dwThreadID;

        m_hwnd =  CreateDialogParam(g_hInst,(LPWSTR) MAKEINTRESOURCE(IDD_CHOICE), NULL, CChoiceDlgProc,
			(LPARAM) this);
    }

    Assert(m_hwnd);
    return m_hwnd ? TRUE : FALSE;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CChoiceDlg::SetQueueData()
//
//  PURPOSE:  Sets the Choice dialog queue
//
//  COMMENTS: Does a SendMessage to get on the same thread as the dialog
//
//
//--------------------------------------------------------------------------------

BOOL CChoiceDlg::SetQueueData(REFCLSID rclsid,CHndlrQueue * pHndlrQueue)
{
SetQueueDataInfo dataInfo;
BOOL fSet = FALSE;

    dataInfo.rclsid = &rclsid;
    dataInfo.pHndlrQueue = pHndlrQueue;

    SendMessage(m_hwnd,WM_CHOICE_SETQUEUEDATA,
	   (WPARAM) &fSet,(LPARAM) &dataInfo);

    return fSet;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CChoiceDlg::PrivSetQueueData()
//
//  PURPOSE:  Sets the QueueData
//
//  COMMENTS: Can be called multiple times if the dialg is invoked twice.
//
//
//--------------------------------------------------------------------------------

BOOL CChoiceDlg::PrivSetQueueData(REFCLSID rclsid,CHndlrQueue * pHndlrQueue)
{
    if (NULL == pHndlrQueue)
	    return FALSE;

    // if already have a queue then transfer the given queue items, else just
    // set the items.

    // reivew, special case UpdateAll dialog to just bring it to front
    //	    instead of adding all the items again.

    // if a request comes in to add after we have removed our addref or
    // haven't set it yet then stick an addref on the dialog

    if (FALSE == m_fInternalAddref)
    {
        m_fInternalAddref = TRUE;
	SetChoiceReleaseDlgCmdId(rclsid,this,RELEASEDLGCMDID_CANCEL);
	AddRefChoiceDialog(rclsid,this); // first time addref to keep alive.
    }

    if (NULL == m_pHndlrQueue)
    {
        m_pHndlrQueue = pHndlrQueue;
	m_pHndlrQueue->SetQueueHwnd(this);
	m_clsid = rclsid;

    }
    else
    {
	Assert(m_clsid == rclsid); // better have found the same choice dialog.
	Assert(m_pHndlrQueue);


	// !! warninng if you return an error it is up to the caller to free the queue.
	if (m_pHndlrQueue)
	{
	
	    m_pHndlrQueue->TransferQueueData(pHndlrQueue); // review, what should do on error.

	    // ALL QUEUE DATA SHOULD BE TRANSFERED.
	    pHndlrQueue->FreeAllHandlers();
	    pHndlrQueue->Release();
	}

    }


    AddNewItemsToListView(); // add the items to the ListView.

    // go ahead and show the choice dialog now that there are
    // items to display
    ShowChoiceDialog();

   return TRUE;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CChoiceDlg::SetButtonState
//
//  PURPOSE:
//
//
//
//
//--------------------------------------------------------------------------------

BOOL CChoiceDlg::SetButtonState(int nIDDlgItem,BOOL fEnabled)
{
BOOL fResult = FALSE;
HWND hwndCtrl = GetDlgItem(m_hwnd,nIDDlgItem);
HWND hwndFocus = NULL;

    if (hwndCtrl)
    {
        // if state is current state then don't do anything
        // !! in case IsWindowEnable bool doesn't == our bool
        if ( (!!IsWindowEnabled(hwndCtrl)) == (!!fEnabled) )
        {
            return fEnabled;
        }

        if (!fEnabled) // don't bother getting focus if not disabling.
        {
            hwndFocus = GetFocus();
        }

        fResult = EnableWindow(GetDlgItem(m_hwnd,nIDDlgItem),fEnabled);

        // if control had the focus. and now it doesn't then tab to the
        // next control
        if (hwndFocus == hwndCtrl
                && !fEnabled)
        {
            SetFocus(GetDlgItem(m_hwnd,IDC_CLOSE));  // close is always enabled.
        }

    }

    return fResult;
}


//+---------------------------------------------------------------------------
//
//  Member:     CChoiceDlg::AddQueueItemsToListView, private
//
//  Synopsis:   Adds the items in the Queue to the ListView.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    30-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CChoiceDlg::AddNewItemsToListView()
{
    DWORD dwExtStyle = LVS_EX_CHECKBOXES | LVS_EX_FULLROWSELECT |  LVS_EX_INFOTIP;
    LVHANDLERITEMBLOB lvEmptyItemBlob;

    // set up the list view
    if (!m_pItemListView)
    {
        Assert(m_pItemListView);
        return FALSE;
    }

    // if emptyItem is in list View delete it.
    lvEmptyItemBlob.cbSize = sizeof(LVHANDLERITEMBLOB);
    lvEmptyItemBlob.clsidServer = GUID_NULL;
    lvEmptyItemBlob.ItemID = GUID_NULL;

    if (-1 != m_pItemListView->FindItemFromBlob((LPLVBLOB) &lvEmptyItemBlob))
    {
        int ListViewWidth = CalcListViewWidth(GetDlgItem(m_hwnd,IDC_CHOICELISTVIEW));

        m_pItemListView->DeleteAllItems();

        // adjust the column widths back
        m_pItemListView->SetColumnWidth(0,(ListViewWidth * 2)/3);
        m_pItemListView->SetColumnWidth(1,ListViewWidth/3);
    }

    AddItemsFromQueueToListView(m_pItemListView,m_pHndlrQueue,dwExtStyle,0,
                      CHOICELIST_LASTUPDATECOLUMN,/* iDateColumn */ -1 /*status column */,TRUE /* fUseHandlerAsParent */
                    ,FALSE /* fAddOnlyCheckedItems */);


    // Set StartButton State in case don't have any checks would
    // m_iCheckCount set by listview notification.
    SetButtonState(IDC_START,m_pItemListView->GetCheckedItemsCount());


    // if no items are in the ListView then done, put in the NoItems to Sync Info.
    if (0 == m_pItemListView->GetItemCount())
    {
        TCHAR szBuf[MAX_STRING_RES];
        RECT rcClientRect;
        HIMAGELIST himageSmallIcon = m_pItemListView->GetImageList(LVSIL_SMALL );

        //disable the check box list view style
        m_pItemListView->SetExtendedListViewStyle(LVS_EX_FULLROWSELECT |  LVS_EX_INFOTIP );

        // adjust the column widths
        if (GetClientRect(GetDlgItem(m_hwnd,IDC_CHOICELISTVIEW),&rcClientRect))
        {
             m_pItemListView->SetColumnWidth(1,0);
             m_pItemListView->SetColumnWidth(0,rcClientRect.right -2);
        }


        LoadString(g_hInst,IDS_NOITEMS, szBuf, ARRAYSIZE(szBuf));
	
        LVITEMEX lvitem;
	
        lvitem.mask = LVIF_TEXT | LVIF_IMAGE ;
        lvitem.iItem = 0;
        lvitem.iSubItem = 0;
        lvitem.pszText = szBuf;
        lvitem.iImage = -1;

        if (himageSmallIcon)
        {
            lvitem.iImage = ImageList_AddIcon(himageSmallIcon,LoadIcon(NULL, IDI_INFORMATION));
        }

        lvitem.maskEx = LVIFEX_BLOB;
        lvitem.pBlob = (LPLVBLOB) &lvEmptyItemBlob;

        m_pItemListView->InsertItem(&lvitem);

        m_pItemListView->SetItemState(0,
               LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED );

        // Reset the current default push button to a regular button.
        SendDlgItemMessage(m_hwnd, IDC_START, BM_SETSTYLE, BS_PUSHBUTTON, (LPARAM)TRUE);

        // Update the default push button's control ID.
        SendMessage(m_hwnd, DM_SETDEFID, IDC_CLOSE, 0L);

        // Set the new style.
        SendDlgItemMessage(m_hwnd, IDC_CLOSE,BM_SETSTYLE, BS_DEFPUSHBUTTON, (LPARAM)TRUE);
    }

    m_pItemListView->SetItemState(0,
             LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED );

    return TRUE;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CChoiceDlg::ShowChoiceDialog()
//
//  PURPOSE:  Initialize and display the Choice Dialog
//
//  COMMENTS: Implemented on main thread.
//
//
//--------------------------------------------------------------------------------
BOOL CChoiceDlg::ShowChoiceDialog()
{

    // Review, this needs to get cleanedup
    if (!m_hwnd)
    {
        Assert(m_hwnd);
        return FALSE;
    }

    return TRUE;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CChoiceDlg::ShowProperties(int iItem)
//
//  PURPOSE:  Show the app specific properties  Dialog
//
//	COMMENTS: Implemented on main thread.
//
//--------------------------------------------------------------------------------
HRESULT CChoiceDlg::ShowProperties(int iItem)
{
HRESULT hr = E_UNEXPECTED;

    Assert(iItem >= 0);

    // only call showProperties if still have our own addref.
    // and not already in a ShowProperties out call.
    if ( (iItem >= 0) &&
        m_pItemListView &&
        m_pHndlrQueue &&
        m_fInternalAddref && (0 == m_dwShowPropertiesCount) )
    {
    LVHANDLERITEMBLOB lvHandlerItemBlob;

        lvHandlerItemBlob.cbSize = sizeof(LVHANDLERITEMBLOB);

        if (m_pItemListView->GetItemBlob(iItem,(LPLVBLOB) &lvHandlerItemBlob,lvHandlerItemBlob.cbSize))
        {

            if (S_OK == m_pHndlrQueue->ItemHasProperties(lvHandlerItemBlob.clsidServer,
                                                        lvHandlerItemBlob.ItemID))
	    {

                // Put two refs on the Properties one
                // for completion routine to reset and one for this
                // call so cancel can't happen until both return from
                // call and completion is called.

                m_dwShowPropertiesCount += 2;

                ObjMgr_AddRefHandlerPropertiesLockCount(2);

                hr = m_pHndlrQueue->ShowProperties(lvHandlerItemBlob.clsidServer,lvHandlerItemBlob.ItemID,m_hwnd);

                 --m_dwShowPropertiesCount;  // out of call
                ObjMgr_ReleaseHandlerPropertiesLockCount(1);

                Assert( ((LONG) m_dwShowPropertiesCount) >= 0);

                if ( ((LONG) m_dwShowPropertiesCount) <0)
                    m_dwShowPropertiesCount = 0;

                // if hr wasn't a success code then up to us to call the callback
                if (FAILED(hr))
                {
                    PostMessage(m_hwnd,WM_BASEDLG_COMPLETIONROUTINE,
                                            ThreadMsg_ShowProperties,0);
                }

            }
        }

    }

    return hr;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CChoiceDlg::ReleaseDlg
//
//  PURPOSE:  Called by objmgr when we need to release
//              post message to the dialog thread.
//
//  COMMENTS:
//
//--------------------------------------------------------------------------------

void CChoiceDlg::ReleaseDlg(WORD wCommandID)
{
    PostMessage(m_hwnd,WM_CHOICE_RELEASEDLGCMD,wCommandID,0);
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CChoiceDlg::PrivReleaseDlg
//
//  PURPOSE:  frees the dialog
//
//  COMMENTS:
//
//--------------------------------------------------------------------------------

void CChoiceDlg::PrivReleaseDlg(WORD wCommandID)
{
BOOL fCloseConnections = TRUE;

    Assert(m_dwThreadID == GetCurrentThreadId());
    Assert(m_fInternalAddref == FALSE);

    if (m_hwnd)
    {
	// ShowWindow(m_hwnd,SW_HIDE);
    }

    // if don't have a listView then change command to a cancel
    if (NULL == m_pItemListView)
    {
        wCommandID = RELEASEDLGCMDID_CANCEL;
    }

    switch(wCommandID)
    {
    case RELEASEDLGCMDID_CANCEL:
       // done with our queue

	Assert(m_pHndlrQueue);
    case RELEASEDLGCMDID_DESTROY:
	// this CommandID is sent if dialog was created but it couldn't be added
	// to the object mgr list.

	if (m_pHndlrQueue)
	{
	    m_pHndlrQueue->FreeAllHandlers(); // done with our queue.
	    m_pHndlrQueue->Release();
	    m_pHndlrQueue = NULL;
	}

	break;
    case RELEASEDLGCMDID_OK:
	{
	     Assert(m_pHndlrQueue);
             Assert(m_pItemListView);

	     if (m_pHndlrQueue && m_pItemListView)
	     {
	    CProgressDlg *pProgressDlg;
	    short i = 0;
	    int sCheckState;
            LVHANDLERITEMBLOB lvHandlerItemBlob;

                    lvHandlerItemBlob.cbSize = sizeof(LVHANDLERITEMBLOB);

		 // loop through getting and setting the selected items.

		 // 1 checked, 0 unchecked, -1 last item
		 while (-1 != (sCheckState = m_pItemListView->GetCheckState(i)))
		 {

		    if (m_pItemListView->GetItemBlob(i,(LPLVBLOB) &lvHandlerItemBlob,lvHandlerItemBlob.cbSize))
                    {

                        if (GUID_NULL != lvHandlerItemBlob.ItemID)
                        {
                            m_pHndlrQueue->SetItemState(lvHandlerItemBlob.clsidServer,
                                        lvHandlerItemBlob.ItemID,
                                        sCheckState == LVITEMEXSTATE_CHECKED ?
                                                SYNCMGRITEMSTATE_CHECKED : SYNCMGRITEMSTATE_UNCHECKED);
                        }

                    }

		     i++;

		 } while (-1 != sCheckState);

		 m_pHndlrQueue->PersistChoices();

		 // on a manual create the progress dialog as displayed.
		 if (S_OK == FindProgressDialog(GUID_NULL,TRUE,SW_SHOWNORMAL,&pProgressDlg))
		 {
		     if (S_OK == pProgressDlg->TransferQueueData(m_pHndlrQueue))
                     {
                        fCloseConnections = FALSE;
                     }
		     ReleaseProgressDialog(GUID_NULL,pProgressDlg,FALSE);
		 }

		   m_pHndlrQueue->FreeAllHandlers(); // done with our queue.
		   m_pHndlrQueue->Release();
		   m_pHndlrQueue = NULL;
	     }
	}
	break;
    case RELEASEDLGCMDID_DEFAULT:
	
	if (m_pHndlrQueue)
	{
	    m_pHndlrQueue->FreeAllHandlers(); // done with our queue.
	    m_pHndlrQueue->Release();
	    m_pHndlrQueue = NULL;
	}

	break;
    default:
	Assert(0); // unknown command or we never set one.
	break;
    }


    // see if there is a progress queue when we get done and we havne't
    // created one ourselves. If there isn't then
    // call CloseConnection to make sure any Events or open Connections
    // get hungUp.

    CProgressDlg *pProgressDlg = NULL;


    if (fCloseConnections)
    {
        if  (S_OK == FindProgressDialog(GUID_NULL,FALSE,SW_MINIMIZE,&pProgressDlg))
        {
            ReleaseProgressDialog(GUID_NULL,pProgressDlg,FALSE);
        }
        else
        {
            ConnectObj_CloseConnections();
        }
    }

    m_fDead = TRUE;

    if (m_pItemListView)
    {
        delete m_pItemListView;
        m_pItemListView = NULL;
    }


    if (m_hwnd)
    {
	DestroyWindow(m_hwnd);
        m_hwnd = NULL;
    }


    delete this;

    return;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CChoiceDlg::UpdateWndPosition
//
//  PURPOSE:   updates window Z-Order and min/max state.
//
//  COMMENTS:
//
//--------------------------------------------------------------------------------

void CChoiceDlg::UpdateWndPosition(int nCmdShow,BOOL fForce)
{
    // always just pull choice to the front since can't minimize;
   ShowWindow(m_hwnd,nCmdShow);
   SetForegroundWindow(m_hwnd);
   UpdateWindow(m_hwnd);
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CChoiceDlg::HandleLogError(int iItem)
//
//  PURPOSE:  handles virtual function for base class.
//
//
//--------------------------------------------------------------------------------

void CChoiceDlg::HandleLogError(HWND hwnd, HANDLERINFO *pHandlerID,MSGLogErrors *lpmsgLogErrors)
{
    AssertSz(0,"Choice dialogs HandleLogError Called");

}

//+---------------------------------------------------------------------------
//
//  Member:     CChoiceDlg::CallCompletionRoutine, private
//
//  Synopsis:   method called when a call has been completed.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    02-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CChoiceDlg::CallCompletionRoutine(DWORD dwThreadMsg,LPCALLCOMPLETIONMSGLPARAM lpCallCompletelParam)
{

    // only completion routine choice
    // dialog should get is for show properties
    switch(dwThreadMsg)
    {
    case ThreadMsg_ShowProperties:

        ObjMgr_ReleaseHandlerPropertiesLockCount(1);

        // If have a success code we need to handle do it
        // before releasing our lock.
        if (lpCallCompletelParam)
        {
            switch(lpCallCompletelParam->hCallResult)
            {
            case S_SYNCMGR_ITEMDELETED:

                // if item is deleted just set the itemState to unchecked and remove from the
                // ui

                if (m_pHndlrQueue && m_pItemListView)
                {
                LVHANDLERITEMBLOB lvItemBlob;
                int lvItemID;

                    m_pHndlrQueue->SetItemState(lpCallCompletelParam->clsidHandler,
                                    lpCallCompletelParam->itemID,SYNCMGRITEMSTATE_UNCHECKED);

                    lvItemBlob.cbSize = sizeof(LVHANDLERITEMBLOB);
                    lvItemBlob.clsidServer = lpCallCompletelParam->clsidHandler;
                    lvItemBlob.ItemID = lpCallCompletelParam->itemID;

                    if (-1 != (lvItemID = m_pItemListView->FindItemFromBlob((LPLVBLOB) &lvItemBlob)))
                    {
                        // if toplevel item, first delete the children
                        if (GUID_NULL == lpCallCompletelParam->itemID)
                        {
                            m_pItemListView->DeleteChildren(lvItemID);
                        }

                        m_pItemListView->DeleteItem(lvItemID);
                    }

                    Assert(-1 != lvItemID);
                }

                break;
            case S_SYNCMGR_ENUMITEMS:

                if (m_pHndlrQueue && m_pItemListView)
                {
                LVHANDLERITEMBLOB lvItemBlob;
                int lvItemID;

                    // delete all items from the ListView.
                    lvItemBlob.cbSize = sizeof(LVHANDLERITEMBLOB);
                    lvItemBlob.clsidServer = lpCallCompletelParam->clsidHandler;
                    lvItemBlob.ItemID = GUID_NULL;

                    if (-1 != (lvItemID = m_pItemListView->FindItemFromBlob((LPLVBLOB) &lvItemBlob)))
                    {
                        if (m_pItemListView->DeleteChildren(lvItemID))
                        {

                            m_pHndlrQueue->ReEnumHandlerItems(lpCallCompletelParam->clsidHandler,
                                                    lpCallCompletelParam->itemID);

                            AddNewItemsToListView();
                        }
                    }

                    Assert(-1 != lvItemID);
                }
                break;
            default:
                break;
            }
        }

        --m_dwShowPropertiesCount;
        Assert( ((LONG) m_dwShowPropertiesCount) >= 0);

        // fix up the count if gone negative.
        if ( ((LONG) m_dwShowPropertiesCount) < 0)
            m_dwShowPropertiesCount = 0;

        break;
    default:
        AssertSz(0,"Uknown Completion Routine");
        break;
    }


    // if have an lparam free it now
    if (lpCallCompletelParam)
    {
        FREE(lpCallCompletelParam);
    }

}

//+---------------------------------------------------------------------------
//
//  Member:     CChoiceDlg::QueryCanSystemShutdown, private
//
//  Synopsis:   called by object manager to determine if can shutdown.
//
//          !!!Warning - can be called on any thread. make sure this is
//              readonly.
//
//          !!!Warning - Do not yield in the function;
//
//
//  Arguments:
//
//  Returns:   S_OK - if can shutdown
//             S_FALSE - system should not shutdown, must fill in out params.
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT CChoiceDlg::QueryCanSystemShutdown(/* [out] */ HWND *phwnd, /* [out] */ UINT *puMessageId,
                                             /* [out] */ BOOL *pfLetUserDecide)
{
HRESULT hr = S_OK;

    // dialog locked open if in ShowProperties
    if (m_dwShowPropertiesCount > 0)
    {
        *puMessageId = IDS_HANDLERPROPERTIESQUERYENDSESSION;
        *phwnd = NULL; // since properties can overvlay us don't give parent
        *pfLetUserDecide = FALSE; // user doesn't get a choice.
        hr = S_FALSE;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CChoiceDlg::CalcListViewWidth, private
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    12-Aug-98       rogerg        Created.
//
//----------------------------------------------------------------------------

int CChoiceDlg::CalcListViewWidth(HWND hwndList)
{
NONCLIENTMETRICSA metrics;
RECT rcClientRect;


    metrics.cbSize = sizeof(metrics);

    // explicitly ask for ANSI version of SystemParametersInfo since we just
    // care about the ScrollWidth and don't want to conver the LOGFONT info.
    if (GetClientRect(hwndList,&rcClientRect)
        && SystemParametersInfoA(SPI_GETNONCLIENTMETRICS,sizeof(metrics),(PVOID) &metrics,0))
    {
        // subtract off scroll bar distance + 1/2 another to give a little space to
        // read right justified text.
        rcClientRect.right -= (metrics.iScrollWidth * 3)/2;
    }
    else
    {
        rcClientRect.right = 320;  // if fail, just makeup a number
    }


    return rcClientRect.right;
}


//+---------------------------------------------------------------------------
//
//  Member:     CChoiceDlg::OnInitialize, private
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CChoiceDlg::OnInitialize(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    HIMAGELIST himage;
    WCHAR wszColumnName[MAX_PATH];
    INT iItem = -1;
    HWND hwndList = GetDlgItem(hwnd,IDC_CHOICELISTVIEW);
    LPNETAPI pNetApi;

    // if sens is not installed hide the settings button.
    // and move the synchronize over.
    if (pNetApi = gSingleNetApiObj.GetNetApiObj())
    {
        if (!(pNetApi->IsSensInstalled()))
        {
            RECT rect;
            HWND hwndSettings = GetDlgItem(hwnd,IDC_OPTIONS);

            if (hwndSettings)
            {
                BOOL fGetWindowRect;
                HWND hwndStart;
                RECT rectStart;

                ShowWindow(hwndSettings,SW_HIDE);
                EnableWindow(hwndSettings,FALSE); // disable for alt

                fGetWindowRect = GetWindowRect(hwndSettings,&rect);
                hwndStart = GetDlgItem(hwnd,IDC_START);

                if (fGetWindowRect && hwndStart
                    && GetClientRect(hwndStart,&rectStart)
                    && MapWindowPoints(NULL,hwnd,(LPPOINT) &rect,2)
                    )
                {
                    SetWindowPos(hwndStart, 0,
                        rect.right - WIDTH(rectStart),rect.top,0,0,SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOSIZE );
                }
            }
        }

        pNetApi->Release();
    }

    m_hwnd = hwnd; // setup the hwnd.

    m_fHwndRightToLeft = IsHwndRightToLeft(m_hwnd);

    // IF THE HWND IS RIGHT TO LEFT HIDE
    // SIZE CONTROL UNTIL RESIZE WORKS.

    if (m_fHwndRightToLeft)
    {
        ShowWindow(GetDlgItem(m_hwnd,IDC_CHOICERESIZESCROLLBAR),SW_HIDE);
    }
    
    if (hwndList)
    {
        // setup the list view
        m_pItemListView = new CListView(hwndList,hwnd,IDC_CHOICELISTVIEW,WM_BASEDLG_NOTIFYLISTVIEWEX);

        if (m_pItemListView)
        {
            int iClientRect = CalcListViewWidth(hwndList);
            UINT ImageListflags;

            m_pItemListView->SetExtendedListViewStyle(LVS_EX_CHECKBOXES | LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP );

            // create an imagelist, if fail continue, list view just won't have an
            // imaglist

            ImageListflags = ILC_COLOR | ILC_MASK;
            if (IsHwndRightToLeft(m_hwnd))
            {
                ImageListflags |=  ILC_MIRROR;
            }

            himage = ImageList_Create( GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON),ImageListflags,5,20);
            if (himage)
            {
                m_pItemListView->SetImageList(himage,LVSIL_SMALL);
            }

            // Calc cx 2/3 for name 1/3 for

            if (!LoadString(g_hInst,IDS_CHOICEHANDLERCOLUMN, wszColumnName, ARRAYSIZE(wszColumnName)))
            {
                *wszColumnName = NULL;
            }

            InsertListViewColumn(m_pItemListView,CHOICELIST_NAMECOLUMN,wszColumnName,LVCFMT_LEFT,(iClientRect*2)/3);

            if (!LoadString(g_hInst,IDS_CHOICELASTUPDATECOLUMN, wszColumnName, ARRAYSIZE(wszColumnName)))
            {
                *wszColumnName = NULL;
            }

            InsertListViewColumn(m_pItemListView,CHOICELIST_LASTUPDATECOLUMN,wszColumnName,LVCFMT_RIGHT,(iClientRect)/3);
       }
    }

    RECT rectParent;

    m_ulNumDlgResizeItem = 0; // if fail then we don't resize anything.

    if (GetClientRect(hwnd,&rectParent))
    {
        ULONG itemCount;
        DlgResizeList *pResizeList;

        // loop through resize list
        Assert(NUM_DLGRESIZEINFOCHOICE == (sizeof(g_ChoiceResizeList)/sizeof(DlgResizeList)) );

        pResizeList = (DlgResizeList *) &g_ChoiceResizeList;

        for (itemCount = 0; itemCount < NUM_DLGRESIZEINFOCHOICE; ++itemCount)
        {
            if(InitResizeItem(pResizeList->iCtrlId,
                pResizeList->dwDlgResizeFlags,hwnd,&rectParent,&(m_dlgResizeInfo[m_ulNumDlgResizeItem])))
            {
                ++m_ulNumDlgResizeItem;
            }

            ++pResizeList;
        }
    }

    // store the current width and height as the
    // the min
    if (GetWindowRect(hwnd,&rectParent))
    {
        m_ptMinimizeDlgSize.x = rectParent.right - rectParent.left;
        m_ptMinimizeDlgSize.y = rectParent.bottom - rectParent.top;
    }

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CChoiceDlg::OnClose, private
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CChoiceDlg::OnClose(UINT uMsg,WPARAM wParam,LPARAM lParam)
{

    if ( (0 == m_dwShowPropertiesCount) && (m_fInternalAddref) )
    {
        m_fInternalAddref = FALSE; // set released member so know we have removed addref on ourself.
        SetChoiceReleaseDlgCmdId(m_clsid,this,RELEASEDLGCMDID_CANCEL);
        ReleaseChoiceDialog(m_clsid,this);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CChoiceDlg::OnSetQueueData, private
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CChoiceDlg::OnSetQueueData(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
SetQueueDataInfo *pdataInfo;
BOOL fSet;
BOOL *pfSet = (BOOL *) wParam;

    pdataInfo = (SetQueueDataInfo *) lParam;
    fSet = PrivSetQueueData(*pdataInfo->rclsid, pdataInfo->pHndlrQueue );

    if (pfSet)
    {
        *pfSet = fSet;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CChoiceDlg::OnContextMenu, private
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CChoiceDlg::OnContextMenu(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    WinHelp ((HWND)wParam,g_szSyncMgrHelp,HELP_CONTEXTMENU,
               (ULONG_PTR) g_aContextHelpIds);
}

//+---------------------------------------------------------------------------
//
//  Member:     CChoiceDlg::OnHelp, private
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CChoiceDlg::OnHelp(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
LPHELPINFO lphi  = (LPHELPINFO)lParam;

    if (lphi->iContextType == HELPINFO_WINDOW)
    {
	WinHelp ( (HWND) lphi->hItemHandle,
		g_szSyncMgrHelp,HELP_WM_HELP,
		(ULONG_PTR)  g_aContextHelpIds);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CChoiceDlg::OnStartCommand, private
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CChoiceDlg::OnStartCommand(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    if ((0 == m_dwShowPropertiesCount) && (m_fInternalAddref))
    {
       m_fInternalAddref = FALSE;
       SetChoiceReleaseDlgCmdId(m_clsid,this,RELEASEDLGCMDID_OK);
       ReleaseChoiceDialog(m_clsid,this);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CChoiceDlg::OnPropertyCommand, private
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CChoiceDlg::OnPropertyCommand(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    // only bring up properties if still have addref on self.
    if (m_fInternalAddref && m_pItemListView)
    {
    int i =  m_pItemListView->GetSelectionMark();

        if (i >= 0)
        {
            ShowProperties(i);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CChoiceDlg::OnCommand, private
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CChoiceDlg::OnCommand(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
WORD wID = LOWORD(wParam);
WORD wNotifyCode = HIWORD(wParam);

    switch (wID)
    {
    case  IDC_START:
        if (BN_CLICKED == wNotifyCode)
        {
            OnStartCommand(uMsg,wParam,lParam);
        }
        break;
    case IDCANCEL:
    case IDC_CLOSE:
        OnClose(uMsg,wParam,lParam);
        break;
    case IDC_PROPERTY:
        OnPropertyCommand(uMsg,wParam,lParam);
	break;
    case IDC_OPTIONS:
        ShowOptionsDialog(m_hwnd);
        break;
    default:
        break;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CChoiceDlg::OnGetMinMaxInfo, private
//
//  Synopsis:  Called by WM_GETMINMAXINFO
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CChoiceDlg::OnGetMinMaxInfo(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
MINMAXINFO   *pMinMax = (MINMAXINFO *) lParam ;

     pMinMax->ptMinTrackSize.x = m_ptMinimizeDlgSize.x;
     pMinMax->ptMinTrackSize.y = m_ptMinimizeDlgSize.y ;

}

//+---------------------------------------------------------------------------
//
//  Member:     CChoiceDlg::OnSize, private
//
//  Synopsis:  Called by WM_SIZE
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------


void CChoiceDlg::OnSize(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    ResizeItems(m_ulNumDlgResizeItem,m_dlgResizeInfo);
}

//+---------------------------------------------------------------------------
//
//  Member:     CChoiceDlg::OnNotify, private
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

LRESULT CChoiceDlg::OnNotify(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
int idCtrl = (int) wParam;
LPNMHDR pnmh = (LPNMHDR) lParam;

    if ((IDC_CHOICELISTVIEW == idCtrl) && m_pItemListView)
    {
        return m_pItemListView->OnNotify(pnmh);
    }


    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CChoiceDlg::OnNotifyListViewEx, private
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

LRESULT CChoiceDlg::OnNotifyListViewEx(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
int idCtrl = (int) wParam;
LPNMHDR pnmh = (LPNMHDR) lParam;
LVHANDLERITEMBLOB lvHandlerItemBlob;

    if ( (IDC_CHOICELISTVIEW != idCtrl) || (NULL == m_pItemListView))
    {
        Assert(IDC_CHOICELISTVIEW == idCtrl);
        Assert(m_pItemListView);
        return 0;
    }

    lvHandlerItemBlob.cbSize = sizeof(LVHANDLERITEMBLOB);

    switch (pnmh->code)
    {
    case LVNEX_ITEMCHECKCOUNT:
    {
    LPNMLISTVIEWEXITEMCHECKCOUNT  plviCheckCount = (LPNMLISTVIEWEXITEMCHECKCOUNT) lParam;

        // update start button based on how many items are selected.
        SetButtonState(IDC_START,plviCheckCount->iCheckCount);
        break;
    }
    case LVNEX_ITEMCHANGED:
    {
    LPNMLISTVIEWEX pnmvEx = (LPNMLISTVIEWEX) lParam;
    LPNMLISTVIEW pnmv= &(pnmvEx->nmListView);

        if (pnmv->uChanged == LVIF_STATE)
        {	
        int iItem = pnmv->iItem;
        BOOL fItemHasProperties = FALSE;;
	
            if (pnmv->uNewState & LVIS_SELECTED)
            {
                Assert(iItem >= 0);

		if ((iItem >= 0) &&
                       m_pItemListView->GetItemBlob(iItem,(LPLVBLOB) &lvHandlerItemBlob,lvHandlerItemBlob.cbSize))
                {

                    if (S_OK == m_pHndlrQueue->ItemHasProperties(lvHandlerItemBlob.clsidServer,
                                                                lvHandlerItemBlob.ItemID))
		    {
                        fItemHasProperties = TRUE;
		    }
                }
            }

            SetButtonState(IDC_PROPERTY,fItemHasProperties);
	}
        break;
    }
    case LVNEX_DBLCLK:
    {
    LPNMLISTVIEW lpnmlv = (LPNMLISTVIEW) lParam;

        ShowProperties(lpnmlv->iItem);
        break;
    }
    default:
        break;
    }

    return 0;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CChoiceDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
//
//  PURPOSE:  Callback for Choice Dialog
//
//	COMMENTS: Implemented on main thread.
//
//
//------------------------------------------------------------------------------
INT_PTR CALLBACK CChoiceDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                          LPARAM lParam)
{
CChoiceDlg *pThis = (CChoiceDlg *) GetWindowLongPtr(hwnd, DWLP_USER);

    // spcial case destroy and init.
    switch (uMsg)
    {
    case WM_DESTROY:
        PostQuitMessage(0); // done with this thread.
	break;
    case WM_INITDIALOG:
        {
	// Stash the this pointer so we can use it later
	SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)lParam);
	pThis = (CChoiceDlg *) lParam;

        if (pThis)
        {
            return pThis->OnInitialize(hwnd,uMsg,wParam,lParam);
        }

        return FALSE;
	break;
        }
    default:
        {
            if (pThis)
            {
                switch (uMsg)
                {
                case WM_CLOSE:
                    pThis->OnClose(uMsg,wParam,lParam);
                    break;
                case WM_BASEDLG_HANDLESYSSHUTDOWN:
                    PostMessage(hwnd,WM_CLOSE,0,0); // post a close message to get on our thread.
                    break;
                case WM_GETMINMAXINFO:
                    pThis->OnGetMinMaxInfo(uMsg,wParam,lParam);
                    break;
                case WM_SIZE:
                    pThis->OnSize(uMsg,wParam,lParam);
                    break;
                case WM_COMMAND:
                    pThis->OnCommand(uMsg,wParam,lParam);
                    break;
                case WM_NOTIFY:
                    {
                    LRESULT lretOnNotify;

                        lretOnNotify =  pThis->OnNotify(uMsg,wParam,lParam);

                        SetWindowLongPtr(hwnd,DWLP_MSGRESULT,lretOnNotify);
                        return TRUE;
                    }
	            break;
                case WM_HELP:
                    pThis->OnHelp(uMsg,wParam,lParam);
                    return TRUE;
	            break;
	        case WM_CONTEXTMENU:
                    pThis->OnContextMenu(uMsg,wParam,lParam);
	            break;
                case WM_BASEDLG_SHOWWINDOW:
                    pThis->UpdateWndPosition((int)wParam /*nCmd */,FALSE /* force */);
                    break;
                case WM_BASEDLG_COMPLETIONROUTINE:
                    pThis->CallCompletionRoutine((DWORD)wParam /* dwThreadMsg*/,(LPCALLCOMPLETIONMSGLPARAM) lParam);
                    break;
                case WM_BASEDLG_NOTIFYLISTVIEWEX:
                    pThis->OnNotifyListViewEx(uMsg,wParam,lParam);
                    break;
	        case WM_CHOICE_SETQUEUEDATA:
                    pThis->OnSetQueueData(uMsg,wParam,lParam);
                    return TRUE;
	            break;
                case WM_CHOICE_RELEASEDLGCMD:
                    pThis->PrivReleaseDlg((WORD)wParam /* wCommandID */);
                    break;
	        default:
	            break;
                }
            }
        }
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\exe\cmdline.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       cmdline.cpp
//
//  Contents:   commandline helper routines.
//
//  Classes:    
//
//  Notes:      
//
//  History:    17-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"


//+---------------------------------------------------------------------------
//
//  Member:     CCmdLine::CCmdLine, public
//
//  Synopsis:  Constructor.
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

CCmdLine::CCmdLine()
{
    m_cmdLineFlags = 0;
    m_pszJobFile = NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CCmdLine::~CCmdLine, public
//
//  Synopsis:  destructor.
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    07-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

CCmdLine::~CCmdLine()
{
    if (m_pszJobFile)
    {
        FREE(m_pszJobFile);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CCmdLine::ParseCommandLine, public
//
//  Synopsis:   Parses the command line passed to the Application
//		and Sets the member variables accordingly.
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

void CCmdLine::ParseCommandLine()
{
    char *lpszRemaining;

    m_cmdLineFlags = 0;

    // start at 1 -- the first is the exe
    for (int i=1; i< __argc; i++)
    {
 	    if (MatchOption(__argv[i], "Embedding"))
    	{
 	        m_cmdLineFlags |= CMDLINE_COMMAND_EMBEDDING;
    	}
 	    else if (MatchOption(__argv[i],"Register"))
    	{
 	        m_cmdLineFlags |= CMDLINE_COMMAND_REGISTER;
    	}
 	    else if (MatchOption(__argv[i], "logon") )
	    {
 	        m_cmdLineFlags |= CMDLINE_COMMAND_LOGON;
	    }
 	    else if (MatchOption(__argv[i],"logoff") )
	    {
 	        m_cmdLineFlags |= CMDLINE_COMMAND_LOGOFF;
	    }
 	    else if (MatchOption(__argv[i],"DllRegisterServer") )
	    {
 	        m_cmdLineFlags |= CMDLINE_COMMAND_REGISTER;
	    }
 	    else if (MatchOption(__argv[i],"Idle") )
	    {
            // pretend idle is the idle schedule firing for this 
            // user so same code path is exceriside if command
            // line invoked or TS launched us.
            
            m_cmdLineFlags |= CMDLINE_COMMAND_SCHEDULE;

            // m_pszJobFile will be scheduleguid_UserName

            TCHAR szDomainUserName[MAX_DOMANDANDMACHINENAMESIZE];
            GetDefaultDomainAndUserName(szDomainUserName,TEXT("_"), MAX_DOMANDANDMACHINENAMESIZE);

            DWORD dwJobFileLen = ( lstrlen(WSZGUID_IDLESCHEDULE)            /* guid of schedule */
                                        + 1                                /* space for separator */
                                        + lstrlen(szDomainUserName)          /* space for domainUserNmae */
                                        + 1                                /* space for NULL */
                                 );

            m_pszJobFile = (WCHAR *) ALLOC(dwJobFileLen * sizeof(WCHAR));

            if (m_pszJobFile)
            {
                StringCchCopy(m_pszJobFile, dwJobFileLen, WSZGUID_IDLESCHEDULE);
                StringCchCat(m_pszJobFile, dwJobFileLen, TEXT("_"));
                StringCchCat(m_pszJobFile, dwJobFileLen, szDomainUserName);            
            }
        }
 	    else if (MatchOption(__argv[i], "Schedule=", FALSE, &lpszRemaining))
	    {
            m_cmdLineFlags |= CMDLINE_COMMAND_SCHEDULE;
           
            // command lines are always in ANSI so convert jobname to WCHAR
            
            ULONG ulJobFileSize = lstrlenA(lpszRemaining) + 1;
            m_pszJobFile = (WCHAR *) ALLOC(ulJobFileSize*sizeof(WCHAR));

            // UP to Schedule method on invoke to handle if jobfile is null.
            if (m_pszJobFile)
            {
                MultiByteToWideChar(CP_ACP, 0, lpszRemaining, -1, m_pszJobFile, ulJobFileSize);
            }
	    }
	    else
	    {
	        AssertSz( i== 0, "Unknown Command Line"); // unknown command line
	    }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CCmdLine::MatchOption, private
//
//  Synopsis:   given a command line and an option determines if the command
//		line matches the option up until the end of the option text
//		if there is additional text after the option text a pointer
//		to it will be returned in lpRemaining, else lpRemaining wil
//		be set to NULL.
//
//		!!!CmdLine options always come in in ANSI
//
//  Arguments:  [lpsz] - command line value to match
//		[lpszOption] - Option string to match command line too.
//		[fExactMatch] - when true, the command line must contain the same
//				number of characters as the Option (i.e.) There shouldn't
//				be any remaining characters
//		[lpszRemaining] - Points to any remaining part of the command after the match
//
//  Returns:    
//
//  Modifies:   
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CCmdLine::MatchOption(LPSTR lpsz, LPSTR lpszOption,BOOL fExactMatch,LPSTR *lpszRemaining)
{
    if (lpszRemaining)
	    *lpszRemaining = '\0';

    if ( lpsz && (lpsz[0] == TEXT('-') || lpsz[0] == TEXT('/')) )
    {
        int nRet = 0;

        lpsz++;

        while (! (nRet = toupper(*lpsz) - toupper(*lpszOption)) && *lpsz)
        {
	        lpsz++;
	        lpszOption++;
        }

        if (*lpszOption || (*lpsz && fExactMatch) )
	        return FALSE;

        if (lpszRemaining)
	        *lpszRemaining = lpsz;

        return(TRUE);
    }

    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CCmdLine::MatchOption, private
//
//  Synopsis:   given a command line and an option determines if the command
//		line matches exactly matches the option 
//
//  Arguments:  [lpsz] - command line value to match
//		[lpszOption] - Option string to match command line too.
//
//  Returns:    
//
//  Modifies:   
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CCmdLine::MatchOption(LPSTR lpsz, LPSTR lpszOption)
{
    return MatchOption(lpsz, lpszOption, TRUE /* fExactmatch */, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\exe\clsfact.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Clsfact.cpp
//
//  Contents:   Class Factory
//
//  Classes:    CClassFactory
//
//  Notes:      
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

//+---------------------------------------------------------------------------
//
//  Member:     CClassFactory::CClassFactory, public
//
//  Synopsis:   Constructor
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

CClassFactory::CClassFactory()
{
	m_cRef = 1;
	return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CClassFactory::~CClassFactory, public
//
//  Synopsis:   Destructor
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

CClassFactory::~CClassFactory( void )
{
    
    Assert(0 == m_cRef);
    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CClassFactory::QueryInterface, public
//
//  Synopsis:   Standard QueryInterface
//
//  Arguments:  [iid] - Interface ID
//              [ppvObj] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassFactory::QueryInterface( REFIID riid, LPVOID* ppv )
{
    *ppv = NULL;

    if( IsEqualIID( riid, IID_IUnknown ) || IsEqualIID( riid, IID_IClassFactory ) )
    {
	*ppv = (LPVOID)this;
	AddRef();
	return S_OK;
    }

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------------------
//
//  Member:	CClassFactory::AddRef, public
//
//  Synopsis:	Add reference
//
//  History:	05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
ULONG cRefs;

    cRefs = InterlockedIncrement((LONG *)& m_cRef);
    return cRefs;
}

//+---------------------------------------------------------------------------
//
//  Member:	CClasFactory::Release, public
//
//  Synopsis:	Release reference
//
//  History:	05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
ULONG cRefs;

    cRefs = InterlockedDecrement( (LONG *) &m_cRef);

    if (0 == cRefs)
    {
	delete this;
    }

    return cRefs;
}

//+---------------------------------------------------------------------------
//
//  Member:     CClassFactory::CreateInstance, public
//
//  Synopsis:   Creates and instance of the requested object 
//
//  Arguments:  [pUnkOuter] - Controlling unknown
//		[riid] - Requested interface
//		[ppvObj] - object pointer
//
//  Returns:    Appropriate status code
//
//  Modifies:   
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CClassFactory::CreateInstance( LPUNKNOWN pUnkOuter, REFIID riid, LPVOID FAR *ppvObj )
{
HRESULT		hr = E_OUTOFMEMORY;
CSynchronizeInvoke *pNewSynchronizeInstance;

    *ppvObj = NULL;

    // We don't support aggregation at all.
    if( pUnkOuter )
    {
	return CLASS_E_NOAGGREGATION;
    }

    //Create the object, passing function to notify on destruction
    pNewSynchronizeInstance = new CSynchronizeInvoke(); // initialized RefCount to 1.

    if( NULL == pNewSynchronizeInstance )
    {
	return hr;
    }

    hr = pNewSynchronizeInstance->QueryInterface( riid, ppvObj );
    pNewSynchronizeInstance->Release(); // release our copy of the object

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CClassFactory::LockServer, public
//
//  Synopsis:   Locks the Server
//
//  Arguments:  [fLock] - To Lock or Unlock
//
//  Returns:    Appropriate status code
//
//  Modifies:   
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassFactory::LockServer( BOOL fLock )
{
    if( fLock )
    {
	AddRefOneStopLifetime(TRUE /*External*/);
    }
    else
    {
	ReleaseOneStopLifetime(TRUE /*External*/);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\exe\cmdline.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       cmdline.h
//
//  Contents:   Helper class for parsing the Command Line.
//
//  Classes:    
//
//  Notes:      
//
//  History:    17-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------


#ifndef _CMDLINEHELPER_
#define _CMDLINEHELPER_

typedef enum _tagCMDLINE_COMMAND   
{	
    CMDLINE_COMMAND_EMBEDDING			= 0x01, // embedding flag was passed in
    CMDLINE_COMMAND_REGISTER			= 0x02, // register flag was passed in
    CMDLINE_COMMAND_LOGON			= 0x04, // logon flag was passed in
    CMDLINE_COMMAND_LOGOFF			= 0x08, // logon flag was passed in
    CMDLINE_COMMAND_SCHEDULE			= 0x10, // schedule flag was passed in
    CMDLINE_COMMAND_IDLE			= 0x20, // Idle flag was passed in
} CMDLINE_COMMAND;


class CCmdLine {

public:
    CCmdLine();
    ~CCmdLine();
    void ParseCommandLine();
    inline DWORD GetCmdLineFlags() { return m_cmdLineFlags; };
    WCHAR* GetJobFile() { return m_pszJobFile; };

private:
    BOOL MatchOption(LPSTR lpsz, LPSTR lpszOption);
    BOOL MatchOption(LPSTR lpsz, LPSTR lpszOption,BOOL fExactMatch,LPSTR *lpszRemaining);

    DWORD m_cmdLineFlags;
    WCHAR *m_pszJobFile;
	
};





#endif // _CMDLINEHELPER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\exe\connobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:      connobj.cpp
//
//  Contents:   ConnectionObject Implementation
//
//  Classes:    CCConnectObj
//
//  Notes:      Purpose is to globally keep track of Connections
//              for a SyncMgr instance. and Open and Close Connections
//              abstracted from LAN or RAS.
//
//  History:    10-Feb-98   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"


extern HINSTANCE g_hInst;      // current instance

CConnectionObj *g_pConnectionObj = NULL; // global pointer to ConnectionObject.

//+---------------------------------------------------------------------------
//
//  Member:     InitConnectionObjects, public
//
//  Synopsis:   Must be called to initialize the ConnectionObjects
//              before any other functions are called.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT InitConnectionObjects()
{
    g_pConnectionObj = new CConnectionObj;

    return g_pConnectionObj ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     ReleaseConnectionObjects, public
//
//  Synopsis:   Called to Release the Connection Objects
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT ReleaseConnectionObjects()
{
    if (g_pConnectionObj)
    {
        delete g_pConnectionObj;
        g_pConnectionObj = NULL;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionObj::CConnectionObj, public
//
//  Synopsis:   Constructor
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

CConnectionObj::CConnectionObj()
   :  m_pFirstConnectionObj(NULL),
      m_fAutoDialConn(FALSE),
      m_fForcedOnline(FALSE)
{
}


//+---------------------------------------------------------------------------
//
//  Function:   CConnectionObj::FindConnectionObj, public
//
//  Synopsis:   Sees if there is an existing Connection object for this
//              Item and if there is incremements the refcount. If one
//              isn't found and fCreate is true a new one is allocated
//              and added to the list.
//
//  Arguments:  [pszConnectionName] - Name of the Connection.
//              [fCreate] - Create a New Connection if one doesn't already exist
///             [pConnectionOb] - OutParam pointer to newly created connectionObj
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT CConnectionObj::FindConnectionObj(LPCWSTR pszConnectionName,
                           BOOL fCreate,CONNECTIONOBJ **pConnectionObj)
{
    HRESULT hr = S_FALSE;
    CONNECTIONOBJ *pCurConnectionObj;
    BOOL fFoundMatch = FALSE;
    CLock clockqueue(this);
    TCHAR szBuf[MAX_PATH + 1];

    *pConnectionObj = NULL;

    Assert(pszConnectionName);

    clockqueue.Enter();

    // look for an existing match
    pCurConnectionObj = m_pFirstConnectionObj;

    while (pCurConnectionObj)
    {
        if (0 == lstrcmp(pszConnectionName,pCurConnectionObj->pwszConnectionName))
        {
            fFoundMatch = TRUE;
            break;
        }

        pCurConnectionObj = pCurConnectionObj->pNextConnectionObj;
    }

    if (fFoundMatch)
    {
        ++(pCurConnectionObj->cRefs);
        *pConnectionObj = pCurConnectionObj;
        hr = S_OK;
    }
    else if (fCreate)
    {
        CONNECTIONOBJ *pNewConnectionObj;

        // if we need to create a new connectionObj then
        pNewConnectionObj = (CONNECTIONOBJ *) ALLOC(sizeof(CONNECTIONOBJ));
        if (pNewConnectionObj)
        {
            memset(pNewConnectionObj, 0, sizeof(CONNECTIONOBJ));
            pNewConnectionObj->cRefs = 1;

            Assert(pszConnectionName);

            // setup the Connectoin Name
            if (pszConnectionName)
            {
                DWORD cch = lstrlen(pszConnectionName);
                DWORD cbAlloc = (cch + 1)*ARRAY_ELEMENT_SIZE(pNewConnectionObj->pwszConnectionName);

                pNewConnectionObj->pwszConnectionName = (LPWSTR) ALLOC(cbAlloc);

                if (pNewConnectionObj->pwszConnectionName)
                {
                    StringCchCopy(pNewConnectionObj->pwszConnectionName, cch+1, pszConnectionName);
                }
            }

            // for now if the name of the connection is our
            // LAN connection name then set the ConnectionType to LAN,
            // else set it to WAN. if convert to using hte connection
            // manager should get from that.

            LoadString(g_hInst, IDS_LAN_CONNECTION, szBuf, MAX_PATH);

            if (NULL == pszConnectionName || 0 == lstrcmp(szBuf,pszConnectionName))
            {
                pNewConnectionObj->dwConnectionType = CNETAPI_CONNECTIONTYPELAN;
            }
            else
            {
                pNewConnectionObj->dwConnectionType = CNETAPI_CONNECTIONTYPEWAN;
            }
        }

        // if everything went okay, add it to the list.
        // must have a new connection obj and either not connection name
        // was passed in or we successfully added a connection name.
        if ( pNewConnectionObj && ( (NULL == pszConnectionName) || pNewConnectionObj->pwszConnectionName) )
        {
            // put at beginning of list
            pNewConnectionObj->pNextConnectionObj = m_pFirstConnectionObj;
            m_pFirstConnectionObj = pNewConnectionObj;

            *pConnectionObj = pNewConnectionObj;
            hr = S_OK;
        }
        else
        {
            if (pNewConnectionObj)
            {
                FreeConnectionObj(pNewConnectionObj);
            }
        }

    }

    clockqueue.Leave();

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CConnectionObj::RemoveConnectionObj, public
//
//  Synopsis:   Removes the specified connections from the list.
//
//  Arguments:  [pszConnectionName] - Name of the Connection.
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

void CConnectionObj::RemoveConnectionObj(CONNECTIONOBJ *pConnectionObj)
{
    CONNECTIONOBJ *pCurConnection = m_pFirstConnectionObj;

    ASSERT_LOCKHELD(this);

    // remove from the list
    if (m_pFirstConnectionObj == pConnectionObj)
    {
        m_pFirstConnectionObj = pConnectionObj->pNextConnectionObj;
    }
    else
    {
        while (pCurConnection)
        {
            if (pCurConnection->pNextConnectionObj == pConnectionObj)
            {
                pCurConnection->pNextConnectionObj = pConnectionObj->pNextConnectionObj;
                break;
            }

            pCurConnection = pCurConnection->pNextConnectionObj;
        }
    }

    FreeConnectionObj(pConnectionObj);
}

//+---------------------------------------------------------------------------
//
//  Function:   CConnectionObj::FreeConnectionObj, privte
//
//  Synopsis:   frees the memory associate with a conneciton Object.
//
//  Arguments:  
//
//  Returns:    nada
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

void CConnectionObj::FreeConnectionObj(CONNECTIONOBJ *pConnectionObj)
{
    Assert(pConnectionObj);

    if (pConnectionObj)
    {
        if (pConnectionObj->pwszConnectionName)
        {
            FREE(pConnectionObj->pwszConnectionName);
        }

        FREE(pConnectionObj);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionObj::IsConnectionAvailable, public
//
//  Synopsis:   Given a connection name sees if the connection is open
//
//  Arguments:
//
//  Returns:    S_OK - Connection Open
//              S_FALSE - Connection not Open
//
//  Modifies:
//
//  History:    05-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT CConnectionObj::IsConnectionAvailable(LPCWSTR pszConnectionName)
{
    TCHAR szBuf[MAX_PATH + 1];
    DWORD dwConnectionType;
    LPNETAPI pNetApi = gSingleNetApiObj.GetNetApiObj();
    HRESULT hr = S_FALSE;

    if (pNetApi )
    {
        BOOL fConnected,fCanEstablishConnection;

        // for now if the name of the connection is our
        // LAN connection name then set the ConnectionType to LAN,
        // else set it to WAN. if convert to Connection Manager
        // should get type from those interfaces.
        LoadString(g_hInst, IDS_LAN_CONNECTION, szBuf, MAX_PATH);

        if (NULL == pszConnectionName || 0 == lstrcmp(szBuf,pszConnectionName))
        {
            dwConnectionType = CNETAPI_CONNECTIONTYPELAN;
        }
        else
        {
            dwConnectionType = CNETAPI_CONNECTIONTYPEWAN;
        }


        pNetApi->GetConnectionStatus(pszConnectionName,dwConnectionType,
                                       &fConnected,&fCanEstablishConnection);
        pNetApi->Release();

        hr = (fConnected) ? S_OK: S_FALSE;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionObj::RestoreWorkOffline, private
//
//  Synopsis:   If have force an online because of a dial then
//              set system state back to Work Offline.
//
//  Arguments:
//
//  Returns:   
//
//  Modifies:
//
//  History:    05-Apr-99      rogerg        Created.
//
//----------------------------------------------------------------------------

void CConnectionObj::RestoreWorkOffline(LPNETAPI pNetApi)
{
    if (!pNetApi)
    {
        Assert(pNetApi);
        return;
    }

    if (m_fForcedOnline)
    {
        pNetApi->SetOffline(TRUE);
        m_fForcedOnline = FALSE;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionObj::TurnOffWorkOffline, private
//
//  Synopsis:   If System is in WorkOffline state will force
//              back to online.
//
//  Arguments:
//
//  Returns:   
//
//  Modifies:
//
//  History:    05-Apr-99      rogerg        Created.
//
//----------------------------------------------------------------------------

void CConnectionObj::TurnOffWorkOffline(LPNETAPI pNetApi)
{
    if (!pNetApi)
    {
        Assert(pNetApi);
        return;
    }

    if (pNetApi->IsGlobalOffline())
    {
        // if in offline state go ahead and switch to online
        if (pNetApi->SetOffline(FALSE))
        {
            m_fForcedOnline = TRUE;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionObj::OpenConnection, public
//
//  Synopsis:   Given a connection sees if the connection is open
//              and if it not and the fMakeConnection is true
//              will then attempt to open the connection.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------
HRESULT CConnectionObj::OpenConnection(CONNECTIONOBJ *pConnectionObj, BOOL fMakeConnection, CBaseDlg *pDlg)
{
#ifndef _RASDIAL
    DWORD dwConnectionId;
#else
    HRASCONN hRasConn;
#endif // _RASDIAL

    LPNETAPI pNetApi = gSingleNetApiObj.GetNetApiObj();
    BOOL fConnected = FALSE;
    BOOL fCanEstablishConnection = FALSE;

    if (pNetApi)
    {
        // See if the specified connection is active and if there is any
        // Wan Activity.

        Assert(pConnectionObj->dwConnectionType); // should have a connection type setup by now.
        if ( S_OK == pNetApi->GetConnectionStatus( pConnectionObj->pwszConnectionName,
                                                        pConnectionObj->dwConnectionType,
                                                        &fConnected,
                                                        &fCanEstablishConnection) )
        {
            // if there is no Wan Activity and there is not a connection
            // then we can go ahead try to dial
            if (!fConnected && fCanEstablishConnection
                    && fMakeConnection && (pConnectionObj->pwszConnectionName))
            {
                DWORD dwErr;
            
                TurnOffWorkOffline(pNetApi);

                dwErr = pNetApi->InternetDialW( (pDlg ? pDlg->GetHwnd() : NULL),
                                                    pConnectionObj->pwszConnectionName,
                                                    INTERNET_AUTODIAL_FORCE_ONLINE | INTERNET_AUTODIAL_FORCE_UNATTENDED,
                                                    &dwConnectionId,
                                                    0 );
                if (0  == dwErr)
                {
                    fConnected = TRUE;
                    pConnectionObj->dwConnectionId = dwConnectionId;
                }
                else 
                {
                    dwConnectionId = 0;

                    if (pDlg)
                    {
                        LogError(pNetApi,dwErr,pDlg);
                    }
                }
            }
        }
    }

    if (pNetApi)
        pNetApi->Release();

    // review, don't handle all failure cases for Scheduling such as LAN connection
    // not available or not allowed to make connection on RAS.
    pConnectionObj->fConnectionOpen = fConnected;

    return pConnectionObj->fConnectionOpen ? S_OK : S_FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CConnectionObj::AutoDial
//
//  Synopsis:   Dials the default auto dial connection
//
//  History:    28-Jul-98       SitaramR        Created
//
//----------------------------------------------------------------------------
HRESULT CConnectionObj::AutoDial(DWORD dwFlags, CBaseDlg *pDlg)
{
    HRESULT hr = S_OK;
    DWORD dwErr = -1;
    LPNETAPI pNetApi = gSingleNetApiObj.GetNetApiObj();

    // only allow one autodial at a time.
    if (m_fAutoDialConn)
    {
        return hr;
    }

    if ( NULL == pNetApi )
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        TurnOffWorkOffline(pNetApi);

        // if flags are force unattended then call InternetAutoDial
        // if should prompt user call InternetDial without
        // a connectoid to bringup choice
        if (dwFlags & INTERNET_AUTODIAL_FORCE_UNATTENDED)
        {
            BOOL fOk = pNetApi->InternetAutodial(dwFlags,0);
            if ( fOk )
            {
                m_fAutoDialConn = TRUE;
                m_dwAutoConnID = 0;
                dwErr = 0;
            }
            else
            {
                dwErr = GetLastError();
            }
        }
        else
        {
            DWORD dwConnectionId;

            dwErr = pNetApi->InternetDialW( (pDlg ? pDlg->GetHwnd() : NULL),
                                            NULL,
                                            INTERNET_AUTODIAL_FORCE_ONLINE,
                                            &dwConnectionId,
                                            0 );

            if (0 == dwErr)
            {
                m_fAutoDialConn = TRUE;
                m_dwAutoConnID = dwConnectionId;
            }
        }

        // if an error occured then log it.
        if (dwErr)
        {
            if (pDlg)
            {
                LogError(pNetApi,dwErr,pDlg);
            }
        }

        hr = m_fAutoDialConn ? S_OK : E_UNEXPECTED;
    }

    if ( pNetApi )
    {
        pNetApi->Release();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionObj::AutoDial
//
//  Synopsis:   turns on or off work offline
//
//  History:    14-April-99       rogerg        Created
//
//----------------------------------------------------------------------------

HRESULT CConnectionObj::SetWorkOffline(BOOL fWorkOffline)
{
    LPNETAPI pNetApi = gSingleNetApiObj.GetNetApiObj();

    if (NULL == pNetApi)
    {
        return E_OUTOFMEMORY;
    }

    if (fWorkOffline)
    {
        RestoreWorkOffline(pNetApi); // Note: only sets back to workOffline if we turned it off.
    }
    else
    {
        TurnOffWorkOffline(pNetApi);
    }

    pNetApi->Release(); 

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CConnectionObj::LogError, private
//
//  Synopsis: Logs the dwErr to the dialog
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    08-Mar-99 rogerg        Created.
//
//----------------------------------------------------------------------------

void CConnectionObj::LogError(LPNETAPI pNetApi,DWORD dwErr,CBaseDlg *pDlg)
{
    BOOL fErrorString= FALSE;
    WCHAR wszErrorString[RASERROR_MAXSTRING];
    MSGLogErrors msgLogError;

    // don't log if success or no dialog
    if (NULL == pDlg || 0 == dwErr)
    {
        Assert(dwErr);
        Assert(pDlg);
        return;
    }

    // print out an error message if it falls within the range of RAS then
    // get the raserror, else if a Win32 message get that, if -1 means the dll
    // failed to load so use the unknown error.

    if (dwErr >= RASBASE && dwErr <=  RASBASEEND)
    {
        if (S_OK == pNetApi->RasGetErrorStringProc(dwErr, wszErrorString, ARRAYSIZE(wszErrorString)) )
        {
            fErrorString = TRUE;
        }
    }
    else if (-1 != dwErr) // try formatMessage
    {
         if (FormatMessageW(
                      FORMAT_MESSAGE_FROM_SYSTEM,
                      NULL,
                      dwErr,
                      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), //The user default language
                      wszErrorString,
                      ARRAYSIZE(wszErrorString),
                      NULL))
         {
             fErrorString = TRUE;
         }
    }


    if (FALSE == fErrorString)
    {
        // just use the generic error.
        if (LoadString(g_hInst, IDS_UNDEFINED_ERROR, wszErrorString, ARRAYSIZE(wszErrorString)))
        {
            fErrorString = TRUE;
        }
    }

    if (fErrorString)
    {
        msgLogError.mask = 0;
        msgLogError.dwErrorLevel = SYNCMGRLOGLEVEL_ERROR;
        msgLogError.lpcErrorText = wszErrorString;
        msgLogError.ErrorID = GUID_NULL;
        msgLogError.fHasErrorJumps = FALSE;

        pDlg->HandleLogError(NULL,0,&msgLogError);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CConnectionObj::CloseConnection, public
//
//  Synopsis:   closes the specified connection.
//          Not an error if can't find Connection obj since under error
//          conditions we still want to call this to clean up, object
//          may or may not exist.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT CConnectionObj::CloseConnection(CONNECTIONOBJ *pConnectionObj)
{
    CLock clockqueue(this);
    CONNECTIONOBJ FirstConnectObj;
    CONNECTIONOBJ *pCurConnection = &FirstConnectObj;

    clockqueue.Enter();

    LPNETAPI pNetApi = gSingleNetApiObj.GetNetApiObj();

    pCurConnection->pNextConnectionObj = m_pFirstConnectionObj;

    while (pCurConnection->pNextConnectionObj)
    {
        CONNECTIONOBJ *pConnection = pCurConnection->pNextConnectionObj;

        // if the connection is equal to what was passed in, then
        // close it out.

        if (pConnection == pConnectionObj)
        {
            // If have a Completion Event to Set then
            if (pConnection->hCompletionEvent)
            {
                SetEvent(pConnection->hCompletionEvent);
                CloseHandle(pConnection->hCompletionEvent);
                pConnection->hCompletionEvent = NULL;
            }

            // if have an open ras connection, hang it up.
            // only time this should get connected is in the progress
            // TODO: make this a class that keeps the netapi loaded
            // until all connections have been closed.
#ifndef _RASDIAL
            if (pConnection->dwConnectionId)
            {
                if ( pNetApi )
                {
                    pNetApi->InternetHangUp(pConnection->dwConnectionId,0);
                    pConnection->dwConnectionId = 0; // even if hangup fails set to null.
                }
            }
#else
            if (pConnection->hRasConn)
            {
                if ( pNetApi )
                {
                    pNetApi->RasHangup(pConnection->hRasConn);
                    pConnection->hRasConn = NULL; // even if hangup fails set to null.
                }
            }
#endif // _RASDIAL

            // if no one is holding onto this connection anymore get rid of it.
            if (0 == pConnection->cRefs)
            {
                pCurConnection->pNextConnectionObj = pConnection->pNextConnectionObj;

                FreeConnectionObj(pConnection);
            }
            else
            {
                pCurConnection = pCurConnection->pNextConnectionObj;
            }
            break;
        }
        else
        {
            pCurConnection = pCurConnection->pNextConnectionObj;
        }
    }

    m_pFirstConnectionObj = FirstConnectObj.pNextConnectionObj;

    if ( pNetApi )
        pNetApi->Release();

    clockqueue.Leave();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionObj::CloseConnections, public
//
//  Synopsis:   Closes any open connections that have a refcount of zero.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT CConnectionObj::CloseConnections()
{
    CLock clockqueue(this);
    CONNECTIONOBJ FirstConnectObj;
    CONNECTIONOBJ *pCurConnection = &FirstConnectObj;

    clockqueue.Enter();

    pCurConnection->pNextConnectionObj = m_pFirstConnectionObj;

    LPNETAPI pNetApi = gSingleNetApiObj.GetNetApiObj();

    while (pCurConnection->pNextConnectionObj)
    {
        CONNECTIONOBJ *pConnection = pCurConnection->pNextConnectionObj;

        // If have a Completion Event to Set then
        if (pConnection->hCompletionEvent)
        {
            SetEvent(pConnection->hCompletionEvent);
            CloseHandle(pConnection->hCompletionEvent);
            pConnection->hCompletionEvent = NULL;
        }

        // if have an open ras connection, hang it up.
        // only time this should get connected is in the progress
        // TODO: make this a class that keeps the netapi loaded
        // until all connections have been closed.
        if (pConnection->dwConnectionId)
        {
            if ( pNetApi )
            {
                pNetApi->InternetHangUp(pConnection->dwConnectionId,0);
                pConnection->dwConnectionId = 0; // even if hangup fails set to null.
            }
        }

        // if no one is holding onto this connection anymore get rid of it.
        if (0 == pConnection->cRefs)
        {
            pCurConnection->pNextConnectionObj = pConnection->pNextConnectionObj;
            FreeConnectionObj(pConnection);
        }
        else
        {
            pCurConnection = pCurConnection->pNextConnectionObj;
        }
    }

    m_pFirstConnectionObj = FirstConnectObj.pNextConnectionObj;

    //
    // Check if auto dial connection needs to be turned off, ignore failure
    //
    if ( m_fAutoDialConn )
    {
        if ( pNetApi )
        {
            if (m_dwAutoConnID)
            {
                pNetApi->InternetHangUp(m_dwAutoConnID,0);
            }
            else
            {
                pNetApi->InternetAutodialHangup( 0 );
            }
        }

        m_dwAutoConnID = FALSE;
        m_fAutoDialConn = FALSE;
    }

    // if we turned off offline then turn it back on
    RestoreWorkOffline(pNetApi);

    if ( pNetApi )
        pNetApi->Release();

    clockqueue.Leave();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   CConnectionObj::ReleaseConnectionObj, public
//
//  Synopsis:   Decrements the specified connectionObj
//              If ther reference count goes to zero and there
//              is not an open connection we go ahead and
//              cleanup immediately.
//
//              If there is a dialed connection we wait until
//              CloseConnection is explicitly called.
//
//  Arguments:  [pConnectionObj] - Pointer to the Connection Obj to Release.
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

DWORD CConnectionObj::ReleaseConnectionObj(CONNECTIONOBJ *pConnectionObj)
{
    DWORD cRefs;
    BOOL fConnectionOpen = FALSE;
    CLock clockqueue(this);

    clockqueue.Enter();
    --pConnectionObj->cRefs;
    cRefs = pConnectionObj->cRefs;

    Assert( ((LONG) cRefs) >= 0);

#ifndef _RASDIAL
    fConnectionOpen = pConnectionObj->dwConnectionId;
#else
    fConnectionOpen = pConnectionObj->hRasConn;
#endif // _RASDIAL

    if ( (0 == cRefs) && !fConnectionOpen && (NULL == pConnectionObj->hCompletionEvent) )
    {
        RemoveConnectionObj(pConnectionObj);
    }

    clockqueue.Leave();
    return cRefs;
}

//+---------------------------------------------------------------------------
//
//  Function:   CConnectionObj::AddRefConnectionObj, public
//
//  Synopsis:   Puts an AddRef on the specified connection obj
//
//  Arguments:  [pConnectionObj] - Pointer to the Connection Obj to Release.
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

DWORD CConnectionObj::AddRefConnectionObj(CONNECTIONOBJ *pConnectionObj)
{
    DWORD cRefs = InterlockedIncrement( (LONG *) &(pConnectionObj->cRefs));

    return cRefs;
}


//+---------------------------------------------------------------------------
//
//  Member:     CConnectionObj::GetConnectionObjCompletionEvent, public
//
//  Synopsis:  caller has made a request for a completion event to be set up.
// !!! warning, on success the event won't be signalled until CloseConnections is Called.
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT CConnectionObj::GetConnectionObjCompletionEvent(CONNECTIONOBJ *pConnectionObj,HANDLE *phRasPendingEvent)
{
    HRESULT hr = E_UNEXPECTED;
    BOOL fFirstCreate = FALSE;
    CLock clockqueue(this);

    clockqueue.Enter();

    if (NULL == pConnectionObj->hCompletionEvent)
    {
        pConnectionObj->hCompletionEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        fFirstCreate = TRUE;
    }

    if (pConnectionObj->hCompletionEvent)
    {
        HANDLE hCurThread;
        HANDLE hProcess;

        // if have a handle, duplicate it hand it out.
        hProcess = GetCurrentProcess();
        hCurThread = GetCurrentThread();

        if ( DuplicateHandle( hProcess,
                                pConnectionObj->hCompletionEvent,
                                hProcess,
                                phRasPendingEvent,
                                0,
                                FALSE,
                                DUPLICATE_SAME_ACCESS) )
        {
            hr = S_OK;
        }
        else
        {
            *phRasPendingEvent = NULL;

            // if event was just created, then also close this one
            if (fFirstCreate)
            {
                CloseHandle(pConnectionObj->hCompletionEvent);
                pConnectionObj->hCompletionEvent = NULL;
            }
        }
    }

    clockqueue.Leave();

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:     ConnectObj_OpenConnection, public
//
//  Synopsis:   wrapper function
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT ConnectObj_OpenConnection(CONNECTIONOBJ *pConnectionObj,BOOL fMakeConnection,CBaseDlg *pDlg)
{
    Assert(g_pConnectionObj);

    if (NULL == g_pConnectionObj)
        return E_UNEXPECTED;

    return g_pConnectionObj->OpenConnection(pConnectionObj,fMakeConnection,pDlg);
}

//+---------------------------------------------------------------------------
//
//  Function:     ConnectObj_CloseConnections, public
//
//  Synopsis:   wrapper function
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT ConnectObj_CloseConnections()
{
    Assert(g_pConnectionObj);

    if (NULL == g_pConnectionObj)
        return E_UNEXPECTED;

    return g_pConnectionObj->CloseConnections();
}

//+---------------------------------------------------------------------------
//
//  Function:     ConnectObj_CloseConnection, public
//
//  Synopsis:   wrapper function
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT ConnectObj_CloseConnection(CONNECTIONOBJ *pConnectionObj)
{
    Assert(g_pConnectionObj);

    if (NULL == g_pConnectionObj)
        return E_UNEXPECTED;

    return g_pConnectionObj->CloseConnection(pConnectionObj);
}

//+---------------------------------------------------------------------------
//
//  Function:     ConnectObj_FindConnectionObj, public
//
//  Synopsis:   wrapper function
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT ConnectObj_FindConnectionObj(LPCWSTR pszConnectionName,BOOL fCreate,CONNECTIONOBJ **pConnectionObj)
{
    Assert(g_pConnectionObj);

    if (NULL == g_pConnectionObj)
        return E_UNEXPECTED;

    return g_pConnectionObj->FindConnectionObj(pszConnectionName, fCreate, pConnectionObj);
}


//+---------------------------------------------------------------------------
//
//  Function:   ConnectObj_AutoDial
//
//  Synopsis:   Wrapper function for auto dial
//
//  History:    28-Jul-98      SitaramR        Created
//
//----------------------------------------------------------------------------

HRESULT ConnectObj_AutoDial(DWORD dwFlags,CBaseDlg *pDlg)
{
    Assert(g_pConnectionObj);

    if (NULL == g_pConnectionObj)
        return E_UNEXPECTED;

    return g_pConnectionObj->AutoDial(dwFlags,pDlg);
}

//+---------------------------------------------------------------------------
//
//  Function:     ConnectObj_ReleaseConnectionObj, public
//
//  Synopsis:   wrapper function
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

DWORD ConnectObj_ReleaseConnectionObj(CONNECTIONOBJ *pConnectionObj)
{
    Assert(g_pConnectionObj);

    if (NULL == g_pConnectionObj)
        return 0;

    return g_pConnectionObj->ReleaseConnectionObj(pConnectionObj);

}

//+---------------------------------------------------------------------------
//
//  Function:     ConnectObj_AddRefConnectionObj, public
//
//  Synopsis:   wrapper function
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

DWORD ConnectObj_AddRefConnectionObj(CONNECTIONOBJ *pConnectionObj)
{
    Assert(g_pConnectionObj);

    if (NULL == g_pConnectionObj)
        return 0;

    return g_pConnectionObj->AddRefConnectionObj(pConnectionObj);
}

//+---------------------------------------------------------------------------
//
//  Function:     ConnectObj_GetConnectionObjCompletionEvent, public
//
//  Synopsis:   wrapper function
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT ConnectObj_GetConnectionObjCompletionEvent(CONNECTIONOBJ *pConnectionObj,HANDLE *phRasPendingEvent)
{
    Assert(g_pConnectionObj);

    if (NULL == g_pConnectionObj)
        return E_UNEXPECTED;

    return g_pConnectionObj->GetConnectionObjCompletionEvent(pConnectionObj,phRasPendingEvent);
}

//+---------------------------------------------------------------------------
//
//  Function:   ConnectObj_IsConnectionAvailable, public
//
//  Synopsis:   wrapper function
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    30-Mar-99       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT ConnectObj_IsConnectionAvailable(LPCWSTR pszConnectionName)
{
    Assert(g_pConnectionObj);

    if (NULL == g_pConnectionObj)
        return E_UNEXPECTED;

    return g_pConnectionObj->IsConnectionAvailable(pszConnectionName);
}

//+---------------------------------------------------------------------------
//
//  Function:   ConnectObj_SetWorkOffline, public
//
//  Synopsis:   wrapper function
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    14-Apr-99       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT ConnectObj_SetWorkOffline(BOOL fWorkOffline)
{
    Assert(g_pConnectionObj);

    if (NULL == g_pConnectionObj)
        return E_UNEXPECTED;

    return g_pConnectionObj->SetWorkOffline(fWorkOffline);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\exe\guid.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       guid.c
//
//  Contents:   Defines GUIDS
//
//  Classes:    
//
//  Notes:      
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#pragma data_seg(".text")
#define INITGUID
#include <objbase.h>
#include <initguid.h>


#include "mobsync.h"
#include "mobsyncp.h"
#include "osdefine.h"
#include "debug.h"

#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\exe\connobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       ConnObj.h
//
//  Contents:   ConnectionObject Implementation
//
//  Classes:    CCConnectObj
//
//  Notes:
//
//  History:    10-Feb-98   rogerg      Created.
//
//--------------------------------------------------------------------------

#ifndef _SYNCMGRCONNECTIONOBJ_
#define SYNCMGRCONNECTIONOBJ_

class CBaseDlg;

typedef struct _CONNECTIONOBJ {
    struct _CONNECTIONOBJ *pNextConnectionObj;
    DWORD cRefs;
    LPWSTR  pwszConnectionName; // pointer to the connection name.
    DWORD dwConnectionType; // connection type as defined by CNetApi class
    BOOL fConnectionOpen; // flag set when connection has been established.
    DWORD dwConnectionId; // Connection Id returned from InternetDial.
    HANDLE   hCompletionEvent;  // set by clients who want to be informed when connection
                                // has been closed.
} CONNECTIONOBJ;


class CConnectionObj : CLockHandler
{
public:
    CConnectionObj();

    HRESULT OpenConnection(CONNECTIONOBJ *pConnectionObj,BOOL fMakeConnection,CBaseDlg *pDlg);
    HRESULT AutoDial(DWORD dwFlags,CBaseDlg *pDlg); // same flags as InternetAutoDial takes
    HRESULT SetWorkOffline(BOOL fWorkOffline); 
    HRESULT CloseConnections();
    HRESULT CloseConnection(CONNECTIONOBJ *pConnectionObj);
    HRESULT FindConnectionObj(LPCWSTR pszConnectionName,BOOL fCreate,CONNECTIONOBJ **pConnectionObj);
    DWORD ReleaseConnectionObj(CONNECTIONOBJ *pConnectionObj);
    DWORD AddRefConnectionObj(CONNECTIONOBJ *pConnectionObj);
    HRESULT GetConnectionObjCompletionEvent(CONNECTIONOBJ *pConnectionObj,HANDLE *phRasPendingEvent);
    HRESULT IsConnectionAvailable(LPCWSTR pszConnectionName);

private:
    void LogError(LPNETAPI pNetApi,DWORD dwErr,CBaseDlg *pDlg);
    void RemoveConnectionObj(CONNECTIONOBJ *pConnectionObj);
    void FreeConnectionObj(CONNECTIONOBJ *pConnectionObj);
    void TurnOffWorkOffline(LPNETAPI pNetApi);
    void RestoreWorkOffline(LPNETAPI pNetApi);


    CONNECTIONOBJ *m_pFirstConnectionObj; // pointer to first connection object in list.
    BOOL           m_fAutoDialConn;       // Was an auto dial connection set up ?
    DWORD          m_dwAutoConnID;    
    BOOL           m_fForcedOnline; // set to true if had to transition from WorkOffline to dial
};


HRESULT InitConnectionObjects();
HRESULT ReleaseConnectionObjects();

// wrapper functions for class
HRESULT ConnectObj_OpenConnection(CONNECTIONOBJ *pConnectionObj,BOOL fMakeConnection,CBaseDlg *pDlg);
HRESULT ConnectObj_CloseConnection(CONNECTIONOBJ *pConnectionObj);
HRESULT ConnectObj_CloseConnections();
HRESULT ConnectObj_FindConnectionObj(LPCWSTR pszConnectionName,BOOL fCreate,CONNECTIONOBJ **pConnectionObj);
DWORD ConnectObj_ReleaseConnectionObj(CONNECTIONOBJ *pConnectionObj);
DWORD ConnectObj_AddRefConnectionObj(CONNECTIONOBJ *pConnectionObj);
HRESULT ConnectObj_GetConnectionObjCompletionEvent(CONNECTIONOBJ *pConnectionObj,HANDLE *phRasPendingEvent);
HRESULT ConnectObj_AutoDial(DWORD dwFlags,CBaseDlg *pDlg);
HRESULT ConnectObj_IsConnectionAvailable(LPCWSTR pszConnectionName);
HRESULT ConnectObj_SetWorkOffline(BOOL fWorkOffline);

#endif // SYNCMGRCONNECTIONOBJ_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\exe\dlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Dlg.h
//
//  Contents:   Dialog box classes
//
//  Classes:    CBaseDlg
//              CChoiceDlg
//              CProgressDlg
//
//  Notes:
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------


#ifndef _ONESTOPDLG_
#define _ONESTOPDLG_


//Used for item data on Progress Results UI
// !!!!Warning - Automated test look at this structure directly
//   If you change it you need to notify Testing so they can also
//   Update their tests

typedef struct tagLBDATA
{
BOOL    fTextRectValid; // flag to indicate if rcText has been calculated.
RECT    rcTextHitTestRect; // rectangle for hitTesting.
RECT    rcText;     // total bounding box of text to use for draw
INT     IconIndex;
BOOL    fIsJump;
BOOL    fHasBeenClicked;
BOOL    fAddLineSpacingAtEnd; // set if should leave space after item
HANDLERINFO *   pHandlerID;
SYNCMGRERRORID ErrorID;
DWORD   dwErrorLevel;    // Error level of this item
TCHAR   pszText[1];      // errorText, dynamic array.
} LBDATA;



// cmdIds passed ot the ReleaseDlg method
#define RELEASEDLGCMDID_DESTROY    0 // cmdid send when dialog was destroyed before added to list
#define RELEASEDLGCMDID_DEFAULT    1 // cmdid sent if cmd hasn't been explicitly set.
#define RELEASEDLGCMDID_OK                 2 // treated as if user Pressed Okay
#define RELEASEDLGCMDID_CANCEL     3 // treated as if user pressed Cancel


// helper utilities
BOOL AddItemsFromQueueToListView(CListView  *pItemListView,CHndlrQueue *pHndlrQueue
                            ,DWORD dwExtStyle,LPARAM lparam,int iDateColumn,int iStatusColumn,BOOL fHandlerParent
                            ,BOOL fAddOnlyCheckedItems);



typedef struct _tagDlgResizeList
{
    int iCtrlId;
    DWORD dwDlgResizeFlags;
} DlgResizeList;

// structure passed as lParam to call completion routine.
// must free after processin the message
// CallCompletion message declarations.
// DWORD dwThreadMsg; // passed as wParam.

typedef struct _tagCALLCOMPLETIONMSGLPARAM 
{
    HRESULT hCallResult;
    CLSID  clsidHandler;
    SYNCMGRITEMID itemID;
} CALLCOMPLETIONMSGLPARAM , *LPCALLCOMPLETIONMSGLPARAM;

// base class both dialogs derive from
#define CHOICELIST_NAMECOLUMN 0
#define CHOICELIST_LASTUPDATECOLUMN 1
#define PROGRESSLIST_NAMECOLUMN 0
#define PROGRESSLIST_STATUSCOLUMN 1
#define PROGRESSLIST_INFOCOLUMN 2

#define PROGRESS_TAB_UPDATE	0
#define PROGRESS_TAB_ERRORS 1

class CBaseDlg
{
public:
    HWND m_hwnd;
    DWORD m_dwThreadID;
    BOOL m_fForceClose; // passed in generic release.
    BOOL m_fHwndRightToLeft;


    inline HWND GetHwnd() { return m_hwnd; };

    virtual BOOL Initialize(DWORD dwThreadID,int nCmdShow) = 0;
    virtual void ReleaseDlg(WORD wCommandID) = 0;
    virtual void UpdateWndPosition(int nCmdShow,BOOL fForce)= 0;

    // make HandleLogError as a base dialog class so can call it from queue and
    // other locations without worrying about the dialog type.
    virtual void HandleLogError(HWND hwnd,HANDLERINFO *pHandlerID,MSGLogErrors *lpmsgLogErrors) = 0;
    virtual void PrivReleaseDlg(WORD wCommandID) = 0;
    virtual void CallCompletionRoutine(DWORD dwThreadMsg,LPCALLCOMPLETIONMSGLPARAM lpCallCompletelParam) = 0;
    virtual HRESULT QueryCanSystemShutdown(/* [out] */ HWND *phwnd, /* [out] */ UINT *puMessageId,
                                             /* [out] */ BOOL *pfLetUserDecide) = 0;
};

// Messages Shared between both dialogs

#define WM_BASEDLG_SHOWWINDOW           (WM_USER + 3)
#define WM_BASEDLG_COMPLETIONROUTINE    (WM_USER + 4)
#define WM_BASEDLG_HANDLESYSSHUTDOWN    (WM_USER + 5)
#define WM_BASEDLG_NOTIFYLISTVIEWEX     (WM_USER + 6)
#define WM_BASEDLG_LAST                 WM_BASEDLG_NOTIFYLISTVIEWEX

// choice dialog messages
#define WM_CHOICE_FIRST  (WM_BASEDLG_LAST + 1)
#define WM_CHOICE_SETQUEUEDATA          (WM_CHOICE_FIRST + 1)
#define WM_CHOICE_RELEASEDLGCMD         (WM_CHOICE_FIRST + 2)
#define WM_CHOICE_LAST                  WM_CHOICE_RELEASEDLGCMD               


// progress dialog messages
#define WM_PROGRESS_FIRST   (WM_CHOICE_LAST + 1)
#define WM_PROGRESS_UPDATE                  (WM_PROGRESS_FIRST + 1)
#define WM_PROGRESS_LOGERROR                (WM_PROGRESS_FIRST + 2)
#define WM_PROGRESS_DELETELOGERROR          (WM_PROGRESS_FIRST + 3)
#define WM_PROGRESS_STARTPROGRESS           (WM_PROGRESS_FIRST + 4)
#define WM_PROGRESS_RELEASEDLGCMD           (WM_PROGRESS_FIRST + 5)
#define WM_PROGRESS_TRANSFERQUEUEDATA       (WM_PROGRESS_FIRST + 6)
#define WM_PROGRESS_SHELLTRAYNOTIFICATION   (WM_PROGRESS_FIRST + 7)
#define WM_PROGRESS_SHUTDOWN                (WM_PROGRESS_FIRST + 8)
#define WM_PROGRESS_RESETKILLHANDLERSTIMER  (WM_PROGRESS_FIRST + 9)

// helper macros for sending window messages
#define BASEDLG_SHOWWINDOW(hwnd,nCmdShow) SendMessage(hwnd,WM_BASEDLG_SHOWWINDOW,nCmdShow,0);

INT_PTR CALLBACK CChoiceDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                              LPARAM lParam);

typedef struct _tagSetQueueDataInfo
{
const CLSID *rclsid;
CHndlrQueue * pHndlrQueue;
} SetQueueDataInfo;

#define NUM_DLGRESIZEINFOCHOICE 6 // make sure update if change numitems

class CChoiceDlg : public CBaseDlg
{
public:
    CChoiceDlg(REFCLSID rclsid);
    BOOL Initialize(DWORD dwThreadID,int nCmdShow); // called to initialize the choice dialog
    BOOL SetQueueData(REFCLSID rclsid,CHndlrQueue * pHndlrQueue);
    void ReleaseDlg(WORD wCommandID);
    void UpdateWndPosition(int nCmdShow,BOOL fForce);
    HRESULT QueryCanSystemShutdown(/* [out] */ HWND *phwnd, /* [out] */ UINT *puMessageId,
                                             /* [out] */ BOOL *pfLetUserDecide);

    void HandleLogError(HWND hwnd,HANDLERINFO *pHandlerID,MSGLogErrors *lpmsgLogErrors);
    void PrivReleaseDlg(WORD wCommandID);
    void CallCompletionRoutine(DWORD dwThreadMsg,LPCALLCOMPLETIONMSGLPARAM lpCallCompletelParam);


private:
    BOOL PrivSetQueueData(REFCLSID rclsid,CHndlrQueue * pHndlrQueue);
    BOOL SetButtonState(int nIDDlgItem,BOOL fEnabled);
    int CalcListViewWidth(HWND hwndList);

    BOOL OnInitialize(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
    void OnClose(UINT uMsg,WPARAM wParam,LPARAM lParam);
    void OnCommand(UINT uMsg,WPARAM wParam,LPARAM lParam);
    void OnGetMinMaxInfo(UINT uMsg,WPARAM wParam,LPARAM lParam);
    void OnSize(UINT uMsg,WPARAM wParam,LPARAM lParam);
    LRESULT OnNotifyListViewEx(UINT uMsg,WPARAM wParam,LPARAM lParam);
    LRESULT OnNotify(UINT uMsg,WPARAM wParam,LPARAM lParam);
    void OnHelp(UINT uMsg,WPARAM wParam,LPARAM lParam);
    void OnContextMenu(UINT uMsg,WPARAM wParam,LPARAM lParam);
    void OnSetQueueData(UINT uMsg,WPARAM wParam,LPARAM lParam);
    void OnStartCommand(UINT uMsg,WPARAM wParam,LPARAM lParam);
    void OnPropertyCommand(UINT uMsg,WPARAM wParam,LPARAM lParam);

    // Set QueueData has to be in sync with
    BOOL ShowChoiceDialog();
    BOOL AddNewItemsToListView();
    HRESULT ShowProperties(int iItem);

    CHndlrQueue *m_pHndlrQueue;
    BOOL m_fDead;
    int m_nCmdShow; // How to show dialog, same flags pased to ShowWindow.
    BOOL m_fInternalAddref; // bool to indicate if dialog has placed an addref on self.
    DWORD m_dwShowPropertiesCount; // keeps track of number of show properties open.
    CLSID m_clsid;              // clsid associated with this dialog.
    ULONG m_ulNumDlgResizeItem;
    DLGRESIZEINFO m_dlgResizeInfo[NUM_DLGRESIZEINFOCHOICE];
    POINT m_ptMinimizeDlgSize;
    CListView  *m_pItemListView;


friend INT_PTR CALLBACK CChoiceDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                          LPARAM lParam);

};




// structures for dialog messages

// wparam of the progress update message,
// lparam of the Update is teh SYNCPROGRESSITEM.
typedef struct _tagPROGRESSUPDATEDATA
{
HANDLERINFO *pHandlerID;
WORD  wItemId;
CLSID clsidHandler;
SYNCMGRITEMID ItemID;
} PROGRESSUPDATEDATA;


// flags for keeping track of progress dlg state.
// make sure all flags are unique bits.
typedef enum _tagPROGRESSFLAG
{
    // general state of the dialog
    PROGRESSFLAG_NEWDIALOG                  = 0x01,  // dialog is new and no items have been added yet.
    PROGRESSFLAG_TRANSFERADDREF             = 0x02, // an addref has been placed on dialog by queue items getting trasferred.
    PROGRESSFLAG_SYNCINGITEMS               = 0x04, // process of synchronizing items in queue has started but not finished.
    PROGRESSFLAG_INCANCELCALL               = 0x08, // cancel call is in progress.
    PROGRESSFLAG_CANCELWHILESHUTTINGDOWN    = 0x10, // cancel was pressed while in shutdownloop
    PROGRESSFLAG_DEAD                       = 0x20, // done with dialog no methods should be called.
    PROGRESSFLAG_CALLBACKPOSTED             = 0x40, // at leasted on callback message is in the queue.
    PROGRESSFLAG_STARTPROGRESSPOSTED        = 0x80, // anyone who posts a start process check this before posting

    // flags used by main sync loop to figure out what to do next.
    PROGRESSFLAG_NEWITEMSINQUEUE        = 0x0100, // new items have been placed in the queue.
    PROGRESSFLAG_IDLENETWORKTIMER       = 0x0200,  // idle timer has been setup for network idles.
    PROGRESSFLAG_PROGRESSANIMATION      = 0x0400, // progress animatiion has been turned on.
    PROGRESSFLAG_SHUTTINGDOWNLOOP       = 0x0800,  // set when no more items in queue and starting shutdown process
    PROGRESSFLAG_INHANDLEROUTCALL       = 0x1000,  // set when in main loop and making an out call.
    PROGRESSFLAG_COMPLETIONROUTINEWHILEINOUTCALL       = 0x2000,  // set in callback when handler is already in an out calll.
    PROGRESSFLAG_INSHOWERRORSCALL          = 0x4000, // set when in showerrors call
    PROGRESSFLAG_SHOWERRORSCALLBACKCALLED = 0x8000, // set when showerrors callback comes in while still in original cal.

    // flags used to keep track of Idle state (if any)
    PROGRESSFLAG_REGISTEREDFOROFFIDLE   = 0x010000, // off idle callback has been registered.
    PROGRESSFLAG_RECEIVEDOFFIDLE        = 0x020000, // queue has receive the offIdle event
    PROGRESSFLAG_IDLERETRYENABLED       = 0x040000, // retry on idle has been set.
    PROGRESSFLAG_INOFFIDLE              = 0x080000, // set when handling an offidle
    PROGRESSFLAG_CANCELPRESSED          = 0x100000, // set when cancel has been pressed and never reset.
    
    //flag used to terminate unresponsive hanlders
    PROGRESSFLAG_INTERMINATE            = 0x200000 //We are terminating unresponsive handlers.

} PROGRESSFLAG;


INT_PTR CALLBACK ProgressWndProc(HWND hwnd, UINT uMsg,WPARAM wParam,LPARAM lParam);

#define NUM_DLGRESIZEINFO_PROGRESS 15
#define NUM_DLGRESIZEINFO_PROGRESS_COLLAPSED 7

#define NUM_PROGRESS_ERRORIMAGES 3

/////////////////////////////////////////////////////////////////////////////
// Images
//
typedef enum _tagErrorImageIndex
{
    ErrorImage_Information = 0,
    ErrorImage_Warning      = 1,
    ErrorImage_Error        = 2,
} ErrorImageIndex;

enum {
    IMAGE_TACK_IN = 0,
    IMAGE_TACK_OUT
};

class CProgressDlg : public CBaseDlg
{
public:

    CProgressDlg(REFCLSID rclsid);
    BOOL Initialize(DWORD dwThreadID,int nCmdShow);

    // transfer queue has to be synced with person doing the transfer.
    STDMETHODIMP TransferQueueData(CHndlrQueue *HndlrQueue);
    void ReleaseDlg(WORD wCommandID);
    void UpdateWndPosition(int nCmdShow,BOOL fForce);
    void HandleLogError(HWND hwnd,HANDLERINFO *pHandlerID,MSGLogErrors *lpmsgLogErrors);
    void HandleDeleteLogError(HWND hwnd,MSGDeleteLogErrors *pDeleteLogError);
    void CallCompletionRoutine(DWORD dwThreadMsg,LPCALLCOMPLETIONMSGLPARAM lpCallCompletelParam);
    HRESULT QueryCanSystemShutdown(/* [out] */ HWND *phwnd, /* [out] */ UINT *puMessageId,
                                             /* [out] */ BOOL *pfLetUserDecide);

    void PrivReleaseDlg(WORD wCommandID);
    void OffIdle();
    void OnIdle();
    void SetIdleParams( ULONG m_ulIdleRetryMinutes,ULONG m_ulDelayIdleShutDownTime,BOOL fRetryEnabled);


private:
    STDMETHODIMP_(ULONG) AddRefProgressDialog();
    STDMETHODIMP_(ULONG) ReleaseProgressDialog(BOOL fForce);

    // methods called from the wndProc
    BOOL InitializeHwnd(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
    BOOL OnCommand(HWND hwnd, WORD wID, WORD wNotifyCode);
    BOOL OnSysCommand(UINT uMsg,WPARAM wParam,LPARAM lParam);
    void OnTimer(UINT uMsg,WPARAM wParam,LPARAM lParam);
    void OnTaskBarCreated(UINT uMsg,WPARAM wParam,LPARAM lParam);
    void OnPaint(UINT uMsg,WPARAM wParam,LPARAM lParam);
    void OnShellTrayNotification(UINT uMsg,WPARAM wParam,LPARAM lParam);
    void OnClose(UINT uMsg,WPARAM wParam,LPARAM lParam);
    void OnSize(UINT uMsg,WPARAM wParam,LPARAM lParam);
    void OnGetMinMaxInfo(UINT uMsg,WPARAM wParam,LPARAM lParam);
    void OnMoving(UINT uMsg,WPARAM wParam,LPARAM lParam);
    void OnCommand(UINT uMsg,WPARAM wParam,LPARAM lParam);
    LRESULT OnNotify(UINT uMsg,WPARAM wParam,LPARAM lParam);
    BOOL OnContextMenu(UINT uMsg,WPARAM wParam,LPARAM lParam);
    BOOL OnPowerBroadcast(UINT uMsg,WPARAM wParam,LPARAM lParam);
    LRESULT OnNotifyListViewEx(UINT uMsg,WPARAM wParam,LPARAM lParam);
    void OnResetKillHandlersTimers(void);


    STDMETHODIMP PrivTransferQueueData(CHndlrQueue *HndlrQueue);
    BOOL KeepProgressAlive();
    void OnCancel(BOOL fOffIdle);
    STDMETHODIMP CreateListViewItem(HWND hwnd,HANDLERINFO *pHandlerID,REFCLSID clsidHandler,SYNCMGRITEM *pofflineItem, INT *piListViewItem, INT iItem);
    STDMETHODIMP OnShowError(HANDLERINFO *pHandlerId,HWND hWndParent,REFSYNCMGRERRORID ErrorID);
    BOOL RedrawIcon();
    void ShowProgressTab(int iTab);
    void UpdateProgressValues();
    STDMETHODIMP PrepareNewItemsForSync(void);
    void DoSyncTask(HWND hwnd);
    void HandleProgressUpdate(HWND hwnd, WPARAM wParam,LPARAM lParam);
    void ExpandCollapse(BOOL fExpand, BOOL fForce);
    BOOL InitializeTabs(HWND hwnd);
    BOOL InitializeToolbar(HWND hwnd);
    BOOL InitializeUpdateList(HWND hwnd);
    BOOL InitializeResultsList(HWND hwnd);
    BOOL ShowCompletedProgress(BOOL fComplete,BOOL fDialogIsLocked);
    BOOL AnimateTray(BOOL fTayAdded);
    BOOL RegisterShellTrayIcon(BOOL fRegister);
    BOOL UpdateTrayIcon();
    BOOL SetButtonState(int nIDDlgItem,BOOL fEnabled);
    BOOL IsItemWorking(int iListViewItem);

    void UpdateDetailsInfo(DWORD dwStatusType,int iItem, TCHAR *pszItemInfo);
    void AddListData(LBDATA *pData, int iNumChars, HWND hwndList);


private:
    LONG m_cInternalcRefs;
    LONG m_lTimerSet;

    HWND m_hwndTabs;
    WNDPROC m_fnResultsListBox;  // function for ListBoxSubClass.
    BOOL m_fSensInstalled;

    // variables for resizing.
    DLGRESIZEINFO m_dlgResizeInfo[NUM_DLGRESIZEINFO_PROGRESS];
    ULONG m_cbNumDlgResizeItemsCollapsed;
    ULONG m_cbNumDlgResizeItemsExpanded;
    POINT m_ptMinimumDlgExpandedSize; // minimum size dialog can be in expanded mode.
    DWORD   m_cyCollapsed;      // min Height of the collapsed dialog
    BOOL    m_fExpanded;    // TRUE if the details part of the dialog is visible
    BOOL    m_fPushpin;     //Pushpin state
    BOOL    m_fMaximized;   // set to true when the window has been maximized.
    RECT    m_rcDlg;        // Size of the fully expanded dialog

    HIMAGELIST m_errorimage;
    int m_iIconMetricX;
    int m_iIconMetricY;
    INT  m_ErrorImages[NUM_PROGRESS_ERRORIMAGES];
    INT  m_iProgressSelectedItem;
    INT  m_iResultCount;
    INT  m_iInfoCount;
    INT  m_iWarningCount;
    INT  m_iErrorCount;
    LBDATA *m_CurrentListEntry;

    int m_iLastItem; 
    DWORD m_dwLastStatusType;
    INT    m_iTab;                 // The index of the current tab

    CHndlrQueue *m_HndlrQueue;

    // Idle specific members
    CSyncMgrIdle *m_pSyncMgrIdle;
    ULONG m_ulIdleRetryMinutes;
    ULONG m_ulDelayIdleShutDownTime;

    DWORD m_dwProgressFlags;
    DWORD m_dwShowErrorRefCount; // number of RefCounts showError calls have on the dialog.
    DWORD m_dwSetItemStateRefCount; // number of RefCounts SetItemState OutCall has on the dialog.
    DWORD m_dwHandleThreadNestcount; // make sure main handler thread isn't re-entrant
    DWORD m_dwPrepareForSyncOutCallCount; // number of prepareForSyncs in progress.
    DWORD m_dwSynchronizeOutCallCount; // number of prepareForSyncs in progress.
    DWORD m_dwHandlerOutCallCount; // total number of outcalls in progress.
    CLSID m_clsidHandlerInSync;         // clsid associated with handler that is currently synchronizing.
    
    DWORD m_dwQueueTransferCount; // number of queue transfers in progress.
    BOOL m_fHasShellTrayIcon;
    BOOL m_fAddedIconToTray;
    int  m_iTrayAniFrame;
    CLSID m_clsid;              // clsid associated with this dialog.
    INT m_iItem;                // index to any new item to the list box.
    int m_nCmdShow;             // How to show dialog, same flags pased to ShowWindow.
    CListView  *m_pItemListView;
    UINT m_nKillHandlerTimeoutValue; // TimeoutValue for ForceKill
    

    TCHAR m_pszStatusText[8][MAX_STRING_RES + 1];

    friend INT_PTR CALLBACK ProgressWndProc(HWND hwnd, UINT uMsg,WPARAM wParam,LPARAM lParam);
    friend BOOL OnProgressUpdateNotify(HWND hwnd,CProgressDlg *pProgress, int idFrom, LPNMHDR pnmhdr);
    friend BOOL OnProgressResultsDrawItem(HWND hwnd,CProgressDlg *pProgress,UINT idCtl, const DRAWITEMSTRUCT* lpDrawItem);
    friend BOOL OnProgressResultsNotify(HWND hwnd,CProgressDlg *pProgress, int idFrom, LPNMHDR pnmhdr);
    friend INT_PTR CALLBACK ResultsListBoxWndProc(HWND hwnd, UINT uMsg,WPARAM wParam,LPARAM lParam);
    friend INT_PTR CALLBACK ResultsProgressWndProc(HWND hwnd, UINT uMsg,WPARAM wParam,LPARAM lParam);
    friend BOOL OnProgressResultsMeasureItem(HWND hwnd,CProgressDlg *pProgress, UINT *horizExtent, UINT idCtl, MEASUREITEMSTRUCT *pMeasureItem);


};


#endif // _ONESTOPDLG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\exe\dlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Dlg.cpp
//
//  Contents:   common dialog routines.
//
//  Classes:    
//
//  Notes:      
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

extern HINSTANCE g_hInst;      // current instance

//+---------------------------------------------------------------------------
//
//  function:     AddItemsFromQueueToListView, private
//
//  Synopsis:   Adds the items in the Queue to the ListView.
//
//  Arguments:  
//              int iDateColumn,int iStatusColumn - if these are >= zero
//              means the Column is Valid and the proper data is initialized.
//
//  Returns:    
//
//  Modifies:   
//
//  History:    30-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------


BOOL AddItemsFromQueueToListView(CListView  *pItemListView,CHndlrQueue *pHndlrQueue
                            ,DWORD dwExtStyle,LPARAM lparam,int iDateColumn,int iStatusColumn,BOOL fHandlerParent
                            ,BOOL fAddOnlyCheckedItems)
{
    WORD wItemID;
    HIMAGELIST himageSmallIcon;
    HANDLERINFO *pHandlerId;
    WCHAR wszStatusText[MAX_STRING_RES];
    DWORD dwDateReadingFlags;

    dwDateReadingFlags = GetDateFormatReadingFlags(pItemListView->GetHwnd());

    *wszStatusText = NULL;

    if (!pItemListView)
    {
        Assert(pItemListView);
        return FALSE;
    }

    if (!pHndlrQueue)
    {
        Assert(pHndlrQueue);
        return FALSE;
    }

    pItemListView->SetExtendedListViewStyle(dwExtStyle);

    // not an error to not get the small Icon, just won't have icons.
    himageSmallIcon = pItemListView->GetImageList(LVSIL_SMALL );

    pHandlerId = 0;;
    wItemID = 0;

    // loop through queue finding any 
    while (S_OK ==  pHndlrQueue->FindNextItemInState(HANDLERSTATE_PREPAREFORSYNC,
                            pHandlerId,wItemID,&pHandlerId,&wItemID))
    {
        INT iListViewItem;
        CLSID clsidDataHandler;
        SYNCMGRITEM offlineItem;
        BOOL fHiddenItem;
        LVITEMEX lvItemInfo; // structure to pass into ListView Calls


	    // grab the offline item info. 
        if (S_OK == pHndlrQueue->GetItemDataAtIndex(pHandlerId,wItemID,&clsidDataHandler,&offlineItem,&fHiddenItem))
	    {
            LVHANDLERITEMBLOB lvHandlerItemBlob;
            int iParentItemId;

            // if the item is hidden don't show it in the UI
            if (fHiddenItem)
            {
                continue;
            }

            // if only add checked items and this one isn't continue on
            if (fAddOnlyCheckedItems && (SYNCMGRITEMSTATE_CHECKED != offlineItem.dwItemState))
            {
                continue;
            }

            // Check if item is already in the ListView and if so
            // go on

            lvHandlerItemBlob.cbSize = sizeof(LVHANDLERITEMBLOB);
            lvHandlerItemBlob.clsidServer = clsidDataHandler;
            lvHandlerItemBlob.ItemID = offlineItem.ItemID;
            
            if (-1 != pItemListView->FindItemFromBlob((LPLVBLOB) &lvHandlerItemBlob))
            {
                // already in ListView, go on to the next item.
                continue;
            }

            if (!fHandlerParent)
            {
                iParentItemId = LVI_ROOT;
            }
            else
            {
                // need to add to list so find parent and if one doesn't exist, create it.
                lvHandlerItemBlob.cbSize = sizeof(LVHANDLERITEMBLOB);
                lvHandlerItemBlob.clsidServer = clsidDataHandler;
                lvHandlerItemBlob.ItemID = GUID_NULL;

                iParentItemId = pItemListView->FindItemFromBlob((LPLVBLOB) &lvHandlerItemBlob);

                if (-1 == iParentItemId)
                {
                    LVITEMEX itemInfoParent;
                    SYNCMGRHANDLERINFO SyncMgrHandlerInfo;

                    // if can't get the ParentInfo then don't add the Item
                    if (S_OK != pHndlrQueue->GetHandlerInfo(clsidDataHandler,&SyncMgrHandlerInfo))
                    {
                        continue;
                    }

                    // Insert the Parent.
                    itemInfoParent.mask = LVIF_TEXT;
                    itemInfoParent.iItem = LVI_LAST;;
                    itemInfoParent.iSubItem = 0;
                    itemInfoParent.iImage = -1;
    
                    itemInfoParent.pszText = SyncMgrHandlerInfo.wszHandlerName;
		            if (himageSmallIcon)
		            {
                        HICON hIcon = SyncMgrHandlerInfo.hIcon ? SyncMgrHandlerInfo.hIcon : offlineItem.hIcon;

                        // if have toplevel handler info icon use this else use the items icon

                        if (hIcon)
                        {
                            itemInfoParent.iImage = ImageList_AddIcon(himageSmallIcon,hIcon);
                            if (itemInfoParent.iImage != -1)
                            {
                                itemInfoParent.mask |= LVIF_IMAGE ; 
                            }
                        }
		            }

                    // save the blob
                    itemInfoParent.maskEx = LVIFEX_BLOB;
                    itemInfoParent.pBlob = (LPLVBLOB) &lvHandlerItemBlob;
            
                    iParentItemId = pItemListView->InsertItem(&itemInfoParent);

                    // if parent insert failed go onto the next item
                    if (-1 == iParentItemId)
                    {
                        continue;
                    }
                }
            }

            // now attempt to insert the item.
            lvItemInfo.mask = LVIF_TEXT | LVIF_PARAM; 
            lvItemInfo.maskEx = LVIFEX_PARENT | LVIFEX_BLOB; 
            lvItemInfo.iItem = LVI_LAST;
            lvItemInfo.iSubItem = 0; 
            lvItemInfo.iParent = iParentItemId;
            lvItemInfo.pszText = offlineItem.wszItemName; 
            lvItemInfo.iImage = -1; // set to -1 in case can't get image.
            lvItemInfo.lParam = lparam;

	        if (himageSmallIcon && offlineItem.hIcon)
	        {
		        lvItemInfo.iImage =  ImageList_AddIcon(himageSmallIcon,offlineItem.hIcon);
                lvItemInfo.mask |= LVIF_IMAGE ; 
	        }

            // setup the blob
            lvHandlerItemBlob.ItemID = offlineItem.ItemID;
            lvItemInfo.pBlob = (LPLVBLOB) &lvHandlerItemBlob;

	        iListViewItem = lvItemInfo.iItem = pItemListView->InsertItem(&lvItemInfo);

            if (-1 == iListViewItem)
            {
                continue;
            }

            // if the item has a date column insert it and the item
            // has a last update time.
            if (iDateColumn  >= 0 && (offlineItem.dwFlags & SYNCMGRITEM_LASTUPDATETIME))
            {
                SYSTEMTIME sysTime;
                FILETIME filetime;
                WCHAR DateTime[256];  
                LPWSTR pDateTime = DateTime;
                int cchWritten;

                lvItemInfo.mask = LVIF_TEXT;
                lvItemInfo.iSubItem = iDateColumn;
                lvItemInfo.maskEx = 0; 

                FileTimeToLocalFileTime(&(offlineItem.ftLastUpdate),&filetime);
                FileTimeToSystemTime(&filetime,&sysTime);

                // insert date in form of date<space>hour
                *DateTime = NULL; 

                // want to insert the date
                if (cchWritten = GetDateFormat(NULL,DATE_SHORTDATE | dwDateReadingFlags,&sysTime,NULL,pDateTime,ARRAYSIZE(DateTime)))
                {
                    pDateTime += (cchWritten -1); // move number of characters written. (cchWritten includes the NULL)
                    *pDateTime = TEXT(' '); // pDateTime is now ponting at the NULL character.
                    ++pDateTime;
                
                    // if left to right add the LRM
                    if (DATE_LTRREADING & dwDateReadingFlags)
                    {
                        *pDateTime = LRM;
                        ++pDateTime;
                    }

                    // no try to get the hours if fails we make sure that the last char is NULL;
                    if (!GetTimeFormat(NULL,TIME_NOSECONDS,&sysTime,NULL,pDateTime,ARRAYSIZE(DateTime) - cchWritten))
                    {
                        *pDateTime = NULL;
                    }
                }

                lvItemInfo.pszText = DateTime;

		        pItemListView->SetItem(&lvItemInfo); // if fail, then just don't have any date.
            }

            if (iStatusColumn >= 0)
            {
                lvItemInfo.iSubItem = iStatusColumn;
                lvItemInfo.maskEx = 0; 

                lvItemInfo.mask = LVIF_TEXT;

                if (NULL == *wszStatusText)
                {
                    LoadString(g_hInst, IDS_PENDING,wszStatusText, MAX_STRING_RES);
                }

                lvItemInfo.pszText = wszStatusText;

                pItemListView->SetItem(&lvItemInfo); // if fail, then just don't have any date.
            }

            // if the listbox has checkBoxes then set the CheckState accordingly
            if (LVS_EX_CHECKBOXES & dwExtStyle)
            {
                if (SYNCMGRITEMSTATE_CHECKED == offlineItem.dwItemState)
                {
			        lvItemInfo.state = LVIS_STATEIMAGEMASK_CHECK;
		        }
		        else
		        {
			        lvItemInfo.state = LVIS_STATEIMAGEMASK_UNCHECK;
		        }

                // if LVS_EX_CHECKBOXES set then setup the CheckBox State setitem State, must do after insert
                pItemListView->SetItemState(iListViewItem,lvItemInfo.state,LVIS_STATEIMAGEMASK);
            }
        }
    }

    // now loop through to see if any handlers that want to always show but don't
    // yet have any items have been added

    if (fHandlerParent)
    {
        LVHANDLERITEMBLOB lvHandlerItemBlob;
        int iParentItemId;
        HANDLERINFO *pHandlerID = 0;
        CLSID clsidDataHandler;

        while (S_OK == pHndlrQueue->FindNextHandlerInState(pHandlerID,
                            GUID_NULL,HANDLERSTATE_PREPAREFORSYNC,&pHandlerID
                            ,&clsidDataHandler))
        {
            SYNCMGRHANDLERINFO SyncMgrHandlerInfo;

            // if can't get the ParentInfo then don't add.
            if (S_OK != pHndlrQueue->GetHandlerInfo(clsidDataHandler,&SyncMgrHandlerInfo))
            {
                continue;
            }

            // only add if handler says too
            if (!(SYNCMGRHANDLER_ALWAYSLISTHANDLER & SyncMgrHandlerInfo.SyncMgrHandlerFlags))
            {
                continue;
            }

            // need to add to list so find parent and if one doesn't exist, create it.
            lvHandlerItemBlob.cbSize = sizeof(LVHANDLERITEMBLOB);
            lvHandlerItemBlob.clsidServer = clsidDataHandler;
            lvHandlerItemBlob.ItemID = GUID_NULL;

            iParentItemId = pItemListView->FindItemFromBlob((LPLVBLOB) &lvHandlerItemBlob);

            if (-1 == iParentItemId)
            {
                LVITEMEX itemInfoParent;

                // Insert the Parent.
                itemInfoParent.mask = LVIF_TEXT;
                itemInfoParent.iItem = LVI_LAST;;
                itemInfoParent.iSubItem = 0;
                itemInfoParent.iImage = -1;

                itemInfoParent.pszText = SyncMgrHandlerInfo.wszHandlerName;
	            if (himageSmallIcon)
	            {
	                HICON hIcon = SyncMgrHandlerInfo.hIcon;

                    // if have toplevel handler info icon use this else use the items icon

		            if (hIcon)
		            {
		                itemInfoParent.iImage = ImageList_AddIcon(himageSmallIcon, hIcon);
		                if (itemInfoParent.iImage != -1)
		                {
                            itemInfoParent.mask |= LVIF_IMAGE ; 
		                }
                    }
	            }

                // save the blob
                itemInfoParent.maskEx = LVIFEX_BLOB;
                itemInfoParent.pBlob = (LPLVBLOB) &lvHandlerItemBlob;
    
                iParentItemId = pItemListView->InsertItem(&itemInfoParent);
            }
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\exe\hndlrmsg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Hndlrmsg.h
//
//  Contents:   Handles messages on the Handlers thread
//
//  Classes:    CHndlrMsg
//
//  Notes:
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#ifndef _HNDLRMSG_
#define _HNDLRMSG_

class CThreadMsgProxy;
class COfflineSynchronizeCallback;
class CHndlrQueue;

typedef struct _tagShowPropertiesThreadArgs {
LPSYNCMGRSYNCHRONIZE lpOneStopHandler;
CLSID ItemId;
HWND hwnd;
} ShowPropertiesThreadArgs;


class CHndlrMsg  : public CLockHandler
{

public:
    CHndlrMsg(void);
    ~CHndlrMsg(void);

    //IUnknown members
    STDMETHODIMP            QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // ISYNCMGRSynchronize Methods
    STDMETHODIMP Initialize(DWORD dwReserved,DWORD dwSyncFlags,
                        DWORD cbCookie,const BYTE *lpCooke);

    STDMETHODIMP GetHandlerInfo(LPSYNCMGRHANDLERINFO *ppSyncMgrHandlerInfo);
    STDMETHODIMP EnumSyncMgrItems(ISyncMgrEnumItems **ppenumOffineItems);
    STDMETHODIMP GetItemObject(REFSYNCMGRITEMID ItemID,REFIID riid,void** ppv);
    STDMETHODIMP ShowProperties(HWND hwnd,REFSYNCMGRITEMID ItemID);
    STDMETHODIMP SetProgressCallback(ISyncMgrSynchronizeCallback *lpCallBack);
    STDMETHODIMP PrepareForSync(ULONG cbNumItems,SYNCMGRITEMID *pItemIDs,
                        HWND hwnd,DWORD dwReserved);
    STDMETHODIMP Synchronize(HWND hwnd);
    STDMETHODIMP SetItemStatus(REFSYNCMGRITEMID ItemID,DWORD dwSyncMgrStatus);
    STDMETHODIMP ShowError(HWND hWndParent,REFSYNCMGRERRORID ErrorID);

    // Private proxy messages
    STDMETHODIMP  CreateServer(const CLSID *pCLSIDServer,
                            CHndlrQueue *pHndlrQueue,HANDLERINFO *pHandlerId,DWORD dwProxyThreadId);
    STDMETHODIMP  SetHndlrQueue(CHndlrQueue *pHndlrQueue,HANDLERINFO *pHandlerId,DWORD m_dwProxyThreadId);
    STDMETHODIMP  AddHandlerItems(HWND hwndList,DWORD *pcbNumItems);
    STDMETHODIMP  SetupCallback(BOOL fSet);

    // Private methods
 //   STDMETHODIMP  privSetCallBack(void);
    STDMETHODIMP AddToItemList(LPSYNCMGRITEM poffItem);
    STDMETHODIMP SetHandlerInfo();

    // private messages called on different thread.
    STDMETHODIMP ForceKillHandler();

private:
    void  GetHndlrQueue(CHndlrQueue **ppHndlrQueue,HANDLERINFO **ppHandlerId,DWORD *pdwProxyThreadId);
    void  AttachThreadInput(BOOL fAttach); // attach input queue with proxy.
    BOOL m_fThreadInputAttached;
    DWORD m_cRef;
    LPSYNCMGRSYNCHRONIZE m_pOneStopHandler;
    LPOLDSYNCMGRSYNCHRONIZE m_pOldOneStopHandler; // old idl, remove if time.
    DWORD m_dwSyncFlags;
    COfflineSynchronizeCallback *m_pCallBack;
    SYNCMGRITEMID m_itemIDShowProperties; // ItemId that was passed to ShowProperties.
    CLSID m_CLSIDServer;
    CHndlrQueue *m_pHndlrQueue;
    HANDLERINFO *m_pHandlerId;
    DWORD m_dwProxyThreadId; // threadId of caller.
    DWORD m_dwThreadId;
    DWORD m_dwNestCount; // keep track of re-entry.
    BOOL m_fDead; // object has been released;
    BOOL m_fForceKilled; // object was force killed.

    friend COfflineSynchronizeCallback;
};




#endif // _HNDLRMSG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\exe\hndlrmsg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Hndlrmsg.cpp
//
//  Contents:   Takes care of handler specific messages
//
//  Classes:    CHndlrMsg
//
//  Notes:
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::CHndlrMsg, public
//
//  Synopsis:   Constructor
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

CHndlrMsg::CHndlrMsg()
{
    m_pOneStopHandler = NULL;
    m_pOldOneStopHandler = NULL;
    m_dwSyncFlags = 0;
    m_pCallBack = NULL;
    m_cRef = 1;
    m_fDead = FALSE;
    m_fForceKilled = FALSE;
    m_dwNestCount = 0;
    m_fThreadInputAttached = FALSE;
    m_itemIDShowProperties = GUID_NULL;

    m_dwProxyThreadId = -1;
    m_dwThreadId = GetCurrentThreadId();
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::~CHndlrMsg, public
//
//  Synopsis:   Destructor
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

CHndlrMsg::~CHndlrMsg()
{
    Assert(m_dwThreadId == GetCurrentThreadId() || m_fForceKilled);
    Assert(0 == m_dwNestCount || m_fForceKilled);
    Assert(0 == m_cRef || m_fForceKilled);
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::QueryInterface, public
//
//  Synopsis:   Standard QueryInterface
//
//  Arguments:  [iid] - Interface ID
//              [ppvObj] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrMsg::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    Assert(m_dwThreadId == GetCurrentThreadId());

    Assert(0 == m_dwNestCount);

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::AddRef, public
//
//  Synopsis:   Add reference
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CHndlrMsg::AddRef()
{
    ULONG cRefs;

    Assert(FALSE == m_fForceKilled && FALSE == m_fDead);

    Assert(m_dwThreadId == GetCurrentThreadId());
    Assert(0 == m_dwNestCount);

    m_dwNestCount++;

    cRefs = InterlockedIncrement((LONG *)& m_cRef);

    m_dwNestCount--;
    return cRefs;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::Release, public
//
//  Synopsis:   Release reference
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CHndlrMsg::Release()
{
    ULONG cRefs;

    Assert(FALSE == m_fForceKilled && FALSE == m_fDead);

    Assert(m_dwThreadId == GetCurrentThreadId());
    Assert(0 == m_dwNestCount);

    m_dwNestCount++;

    cRefs = InterlockedDecrement( (LONG *) &m_cRef);

    if (0 == cRefs)
    {
        if (m_pCallBack)
        {
            SetupCallback(FALSE);
        }

        Assert( !(m_pOneStopHandler && m_pOldOneStopHandler) );
        if (m_pOneStopHandler)
        {
            LPSYNCMGRSYNCHRONIZE OneStopHandler = m_pOneStopHandler;

            m_pOneStopHandler = NULL;
            // if have a callback then revoke it
            // CODE REVIEW : NOTENOTE :
            //  This is a valid use of try/except, but this would mask real refcounting errors in the handler callbacks,
            //  or elsewhere in our code where m_pOneStopHandler was overwritten..
            __try
            {
                OneStopHandler->Release();
            }
            __except(QueryHandleException())
            {
                AssertSz(0,"Exception in Handler's release method.");
            }
        }

        if (m_pOldOneStopHandler)
        {
            LPOLDSYNCMGRSYNCHRONIZE pOldOneStopHandler = m_pOldOneStopHandler;

            m_pOldOneStopHandler = NULL;
            // if have a callback then revoke it
            __try
            {
                pOldOneStopHandler->Release();
            }
            __except(QueryHandleException())
            {
                AssertSz(0,"Exception in Handler's release method.");
            }
        }

        if (m_pHndlrQueue)
        {
            m_pHndlrQueue->Release();
            m_pHndlrQueue = NULL;
        }

        m_fDead = TRUE;
        m_dwNestCount--;
        delete this;
    }
    else
    {
        m_dwNestCount--;
    }

    return cRefs;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::Initialize, public
//
//  Synopsis:   Calls Initialize method of the Handler
//
//  Arguments:  [dwReserved] - Reserved for now is NULL
//              [dwSyncFlags] - SyncFlags
//              [cbCookie] - Size of Cookie data if any
//              [lpCookie] - Pointer to Cookie data
//
//  Returns:    Whatever the handler tells us too.
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrMsg::Initialize(DWORD dwReserved,
                                    DWORD dwSyncFlags,
                                    DWORD cbCookie,
                                    BYTE const* lpCookie)
{
    HRESULT hr = E_UNEXPECTED;

    Assert(FALSE == m_fForceKilled && FALSE == m_fDead);

    Assert(m_dwThreadId == GetCurrentThreadId());
    Assert(0 == m_dwNestCount);

    m_dwNestCount++;

    m_dwSyncFlags = dwSyncFlags;
    Assert(m_pOneStopHandler || m_pOldOneStopHandler);
    Assert( !(m_pOneStopHandler && m_pOldOneStopHandler) );

    if (m_pOneStopHandler)
    {
        // CODE REVIEW : NOTENOTE: 
        //  QueryHandleException() catches all exceptions - do we want to limit out exception handling code ?
        __try
        {
            hr = m_pOneStopHandler->Initialize(dwReserved,dwSyncFlags,cbCookie,lpCookie);
        }
        __except(QueryHandleException())
        {
            hr = HRESULT_FROM_WIN32(GetExceptionCode());
            AssertSz(0,"Exception in Handler's Initialize method.");
        }
    }

    if (m_pOldOneStopHandler)
    {
         // old handlers can't handle cookie data unless it is their own
        if (SYNCMGRFLAG_INVOKE != (dwSyncFlags & SYNCMGRFLAG_EVENTMASK))
        {
            cbCookie = 0;
            lpCookie = NULL;
        }

        __try
        {
            hr = m_pOldOneStopHandler->Initialize(dwReserved,dwSyncFlags,cbCookie,lpCookie);
        }
        __except(QueryHandleException())
        {
            hr = HRESULT_FROM_WIN32(GetExceptionCode());
            AssertSz(0,"Exception in Handler's Initialize method.");
        }
    }

   m_dwNestCount--;
   return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::GetHandlerInfo, public
//
//  Synopsis:   Calls GetHandlerInfo method of the Handler
//
//  Arguments:  [ppSyncMgrHandlerInfo] -
//
//  Returns:    Whatever the handler tells us too.
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrMsg::GetHandlerInfo(LPSYNCMGRHANDLERINFO *ppSyncMgrHandlerInfo)
{
    HRESULT hr = E_UNEXPECTED;

    Assert(m_dwThreadId == GetCurrentThreadId());

    Assert(FALSE == m_fForceKilled && FALSE == m_fDead);

    Assert(m_pOneStopHandler || m_pOldOneStopHandler);
    Assert( !(m_pOneStopHandler && m_pOldOneStopHandler) );

    if (m_pOneStopHandler)
    {
        __try
        {
            hr = m_pOneStopHandler->GetHandlerInfo(ppSyncMgrHandlerInfo);
        }
        __except(QueryHandleException())
        {
            hr = HRESULT_FROM_WIN32(GetExceptionCode());
            AssertSz(0,"Exception in Handler's GetHandlerInfo method.");
        }
    }

    if (m_pOldOneStopHandler)
    {
        __try
        {
            hr = m_pOldOneStopHandler->GetHandlerInfo(ppSyncMgrHandlerInfo);
        }
        __except(QueryHandleException())
        {
            hr = HRESULT_FROM_WIN32(GetExceptionCode());
            AssertSz(0,"Exception in Handler's GetHandlerInfo method.");
        }
    }

   return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::EnumOfflineItems, public
//
//  Synopsis:   PlaceHolder for IOfflineSynchronize Enum method.
//              This shouldn't be called. AddHandlerItems should be
//              called instead
//
//  Arguments:  [ppenumOfflineItems] - returned enumerator
//
//  Returns:    Whatever the handler tells us too.
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrMsg::EnumSyncMgrItems(ISyncMgrEnumItems** ppenumOffineItems)
{
    Assert(m_dwThreadId == GetCurrentThreadId());
    Assert(0 == m_dwNestCount);
    m_dwNestCount++;

    AssertSz(0,"Shouldn't call this Method");
    *ppenumOffineItems = NULL;

    m_dwNestCount--;
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::GetItemObject, public
//
//  Synopsis:   Calls Handler's GetItemObject method
//
//  Arguments:  [ItemID] - Id of the item
//              [riid] - requested interface
//              [ppv] - out pointer for object
//
//  Returns:    Whatever the handler tells us too.
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrMsg::GetItemObject(REFSYNCMGRITEMID ItemID, REFIID riid, void** ppv)
{
    HRESULT hr = E_UNEXPECTED;

    Assert(m_dwThreadId == GetCurrentThreadId());
    Assert(FALSE == m_fForceKilled && FALSE == m_fDead);
    Assert(0 == m_dwNestCount);

    m_dwNestCount++;

    Assert(m_pOneStopHandler || m_pOldOneStopHandler);
    Assert( !(m_pOneStopHandler && m_pOldOneStopHandler) );

    // CODE REVIEW: NOTENOTE
    //  MSDN documents that this GetItemObject method is for future use, and that no client
    //  should be implementing it. Notice the ASSERT below
    if (m_pOneStopHandler)
    {
        __try
        {
            hr = m_pOneStopHandler->GetItemObject(ItemID,riid,ppv);
        }
        __except(QueryHandleException())
        {
            hr = HRESULT_FROM_WIN32(GetExceptionCode());
            AssertSz(0,"Exception in Handler's GetItemObject method.");
        }
        Assert(E_NOTIMPL == hr); // currently no one should be implementing this.
    }

    if (m_pOldOneStopHandler)
    {
        __try
        {
            hr = m_pOldOneStopHandler->GetItemObject(ItemID,riid,ppv);
        }
        __except(QueryHandleException())
        {
            hr = HRESULT_FROM_WIN32(GetExceptionCode());
            AssertSz(0,"Exception in Handler's GetItemObject method.");
        }
        Assert(E_NOTIMPL == hr); // currently noone should be implementing this.
    }

    m_dwNestCount--;
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::ShowProperties, public
//
//  Synopsis:   Calls Handler's ShowProperties method
//
//  Arguments:  [hwnd] - hwnd to use as parent to dialog
//              [itemID] - Identifies the Item
//
//  Returns:    Whatever the handler tells us.
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrMsg::ShowProperties(HWND hwnd,REFSYNCMGRITEMID ItemID)
{
    HRESULT hr = E_UNEXPECTED;

    Assert(m_pOneStopHandler || m_pOldOneStopHandler);
    Assert( !(m_pOneStopHandler && m_pOldOneStopHandler) );
    Assert(FALSE == m_fForceKilled && FALSE == m_fDead);

    // need to setup calback if showProperties is called
    // if can't setup callback then fail the ShowProperties call.

    // Review, ShowPropertiesCompleted doesn't give us the ItemID back so we
    // have to store it. This is fine but limits us to one ShowPropertiesCall
    // at a time on the handler. if update main interfaces change
    // ShowPropertiesCompleted to return the ItemID 

    Assert(GUID_NULL == m_itemIDShowProperties);

    m_itemIDShowProperties = ItemID;

    hr = SetupCallback(TRUE); // set up the callback.
    if (S_OK != hr)
        return hr;

    Assert(0 == m_dwNestCount);
    m_dwNestCount++;

    Assert(m_pOneStopHandler || m_pOldOneStopHandler);
    Assert( !(m_pOneStopHandler && m_pOldOneStopHandler) );

    AttachThreadInput(TRUE);

    if (m_pOneStopHandler)
    {
        __try
        {
            hr = m_pOneStopHandler->ShowProperties(hwnd,ItemID);
        }
        __except(QueryHandleException())
        {
            hr = HRESULT_FROM_WIN32(GetExceptionCode());
            AssertSz(0,"Exception in Handler's ShowProperties method.");
        }
    }

    if (m_pOldOneStopHandler)
    {
        __try
        {
            hr = m_pOldOneStopHandler->ShowProperties(hwnd,ItemID);
        }
        __except(QueryHandleException())
        {
            hr = HRESULT_FROM_WIN32(GetExceptionCode());
            AssertSz(0,"Exception in Handler's ShowProperties method.");
        }
    }

    m_dwNestCount--;

    // if old interface need to make the callback ourselves
    if ( m_pOldOneStopHandler )
    {
        Assert(m_pCallBack);
        if (m_pCallBack && (S_OK == hr))
        {
            m_pCallBack->ShowPropertiesCompleted(S_OK);
        }
    }

    // if an error is returned set the showProperties guid back
    if (S_OK != hr)
    {
        m_itemIDShowProperties = GUID_NULL;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::SetProgressCallback, public
//
//  Synopsis:   PlaceHolder for SetProgressCallback. This member is currently
//              not used. Instead the SetupCallback method is called
//
//  Arguments:  [lpCallBack] - Pointer to Callback object
//
//  Returns:    Whatever the handler tells us.
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrMsg::SetProgressCallback(ISyncMgrSynchronizeCallback *lpCallBack)
{
    Assert(m_dwThreadId == GetCurrentThreadId());
    Assert(0 == m_dwNestCount);
    Assert(FALSE == m_fForceKilled && FALSE == m_fDead);
    m_dwNestCount++;

    AssertSz(0,"Shouldn't call this method");

    m_dwNestCount--;
    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::PrepareForSync, public
//
//  Synopsis:   Calls Handler's ShowProperties method
//
//  Arguments:  [cbNumItems] - number of items so sync
//              [pItemIDs] - Array of Items
//              [hwnd] - Hwnd to use as the Parent of any dialogs
//              [dwReserved] - Just a reserved parameter
//
//  Returns:    Whatever the handler tells us.
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrMsg::PrepareForSync(ULONG cbNumItems,SYNCMGRITEMID *pItemIDs,
                                HWND hwnd,DWORD dwReserved)
{
    HRESULT hr = E_UNEXPECTED;

    Assert(m_dwThreadId == GetCurrentThreadId());
    Assert(FALSE == m_fForceKilled && FALSE == m_fDead);
    // Assert(0 == m_dwNestCount);// may not be zero if handler has yielded

    hr = SetupCallback(TRUE); // set up the callback.
    if (S_OK != hr)
        return hr;

    m_dwNestCount++;

    Assert(m_pOneStopHandler || m_pOldOneStopHandler);
    Assert( !(m_pOneStopHandler && m_pOldOneStopHandler) );

    if (m_pOneStopHandler)
    {
        __try
        {
            hr = m_pOneStopHandler->PrepareForSync(cbNumItems,pItemIDs,hwnd,dwReserved);
        }
        __except(QueryHandleException())
        {
            hr = HRESULT_FROM_WIN32(GetExceptionCode());
            AssertSz(0,"Exception in Handler's PrepareForSync method.");
        }
    }

    if (m_pOldOneStopHandler)
    {
        __try
        {
            hr = m_pOldOneStopHandler->PrepareForSync(cbNumItems,pItemIDs,hwnd,dwReserved);
        }
        __except(QueryHandleException())
        {
            hr = HRESULT_FROM_WIN32(GetExceptionCode());
            AssertSz(0,"Exception in Handler's PrepareForSync method.");
        }
    }

    m_dwNestCount--;

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::Sychronize, public
//
//  Synopsis:   Calls Handler's Synchronize method
//
//  Arguments:  [hwnd] - hwnd to use as parent to dialog
//
//  Returns:    Whatever the handler tells us.
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrMsg::Synchronize(HWND hwnd)
{
    HRESULT hr = E_UNEXPECTED;

    Assert(m_dwThreadId == GetCurrentThreadId());
    Assert(FALSE == m_fForceKilled && FALSE == m_fDead);

    Assert(m_pOneStopHandler || m_pOldOneStopHandler);
    Assert( !(m_pOneStopHandler && m_pOldOneStopHandler) );
    // Assert(0 == m_dwNestCount);
    m_dwNestCount++;

    if (m_pOneStopHandler)
    {
        __try
        {
            hr = m_pOneStopHandler->Synchronize(hwnd);
        }
        __except(QueryHandleException())
        {
            hr = HRESULT_FROM_WIN32(GetExceptionCode());
            AssertSz(0,"Exception in Handler's Synchronize method.");
        }
    }

    if (m_pOldOneStopHandler)
    {
        __try
        {
            hr = m_pOldOneStopHandler->Synchronize(hwnd);
        }
        __except(QueryHandleException())
        {
            hr = HRESULT_FROM_WIN32(GetExceptionCode());
            AssertSz(0,"Exception in Handler's Synchronize method.");
        }
    }

    m_dwNestCount--;

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::SetItemStatus, public
//
//  Synopsis:   Calls Handler's SetItemStatus method
//
//  Arguments:
//
//  Returns:    Whatever the handler tells us.
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrMsg::SetItemStatus(REFSYNCMGRITEMID ItemID,DWORD dwSyncMgrStatus)
{
    HRESULT hr = S_OK;

    Assert(m_dwThreadId == GetCurrentThreadId());
    Assert(FALSE == m_fForceKilled && FALSE == m_fDead);
    Assert(m_pOneStopHandler || m_pOldOneStopHandler);
    Assert( !(m_pOneStopHandler && m_pOldOneStopHandler) );

    m_dwNestCount++; // valid for this to come in when in sync call.

    if (m_pOneStopHandler)
    {
        __try
        {
            hr = m_pOneStopHandler->SetItemStatus(ItemID,dwSyncMgrStatus);
        }
        __except(QueryHandleException())
        {
            hr = HRESULT_FROM_WIN32(GetExceptionCode());
            AssertSz(0,"Exception in Handler's SetItemStatus method.");
        }
    }

    if (m_pOldOneStopHandler)
    {
        __try
        {
            hr = m_pOldOneStopHandler->SetItemStatus(ItemID,dwSyncMgrStatus);
        }
        __except(QueryHandleException())
        {
            hr = HRESULT_FROM_WIN32(GetExceptionCode());
            AssertSz(0,"Exception in Handler's SetItemStatus method.");
        }
    }

    m_dwNestCount--;
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::ShowError, public
//
//  Synopsis:   Calls Handler's ShowError method
//
//  Arguments:  [hwnd] - hwnd to use as parent to dialog
//              [dwErrorID] - ErrorID passed in LogError
//
//  Returns:    Whatever the handler tells us.
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrMsg::ShowError(HWND hWndParent,REFSYNCMGRERRORID ErrorID)
{
    HRESULT hr = E_UNEXPECTED;
    ULONG cbNumItems;
    SYNCMGRITEMID *pItemIDs;

    Assert(m_dwThreadId == GetCurrentThreadId());
    Assert(FALSE == m_fForceKilled && FALSE == m_fDead);
    Assert(m_pOneStopHandler || m_pOldOneStopHandler);
    Assert( !(m_pOneStopHandler && m_pOldOneStopHandler) );

    m_dwNestCount++;

    // on a ShowError enablemodeless in the callback can 
    // return true since user has shown an interest

    if (m_pCallBack)
    {
        m_pCallBack->SetEnableModeless(TRUE);
    }

    AttachThreadInput(TRUE);

    if (m_pOneStopHandler)
    {
        __try
        {
            hr = m_pOneStopHandler->ShowError(hWndParent,ErrorID);
        }
        __except(QueryHandleException())
        {
            hr = HRESULT_FROM_WIN32(GetExceptionCode());
            AssertSz(0,"Exception in Handler's ShowError method.");
        }
    }

    if (m_pOldOneStopHandler)
    {
        __try
        {
            hr = m_pOldOneStopHandler->ShowError(hWndParent,ErrorID,&cbNumItems,&pItemIDs);
        }
        __except(QueryHandleException())
        {
            hr = HRESULT_FROM_WIN32(GetExceptionCode());
            AssertSz(0,"Exception in Handler's ShowError method.");
        }    
    }

    m_dwNestCount--;

    // if old interface need to make the callback ourselves
    if ( m_pOldOneStopHandler )
    {
        Assert(m_pCallBack);
        if (m_pCallBack && SUCCEEDED(hr))
        {
            m_pCallBack->ShowErrorCompleted(hr,cbNumItems,pItemIDs);
            if ( (S_SYNCMGR_RETRYSYNC == hr) && pItemIDs) // after completion routine free the pItems since [in] param.
            {
                CoTaskMemFree(pItemIDs);
            }
        }

        return SUCCEEDED(hr) ? S_OK : hr;
    }

    // New interface won't have the numItems and Items Enum
    // on new interface ShowError should only return S_OK so if retry or
    // other success is returned then return S_OK;

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::SetupCallback, private
//
//  Synopsis:   Sets up the callback for the handler
//
//  Arguments:  [fSet] - TRUE sets the Callbac, FALSE removes it
//
//  Returns:    S_OK on Success
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP  CHndlrMsg::SetupCallback(BOOL fSet)
{
    HRESULT hr = E_UNEXPECTED;

    Assert(m_dwThreadId == GetCurrentThreadId());
    Assert(FALSE == m_fForceKilled && FALSE == m_fDead);
    Assert(m_dwNestCount <= 1); // 1 since valid to be called from Release method.
    m_dwNestCount++;

    // possible to get called with fSet twice of true in the case
    // a retrysync occurs. If we already have a callback set
    // when a new request to set one comes in the just return.

    if ( m_pCallBack && (TRUE == fSet))
    {
        hr = S_OK;
    }
    else
    {
        Assert( ( (m_pCallBack) && (FALSE == fSet) )
            || (TRUE == fSet)); // catch case OneStop calls this twice when already set

        if (m_pCallBack)
        {
            // set the callbacks CHndlrMsg pointer to NULL in case
            // object tries to call through after the release.
            m_pCallBack->SetHndlrMsg(NULL,FALSE);
            m_pCallBack->Release();
            m_pCallBack = NULL;
        }

        if (TRUE == fSet)
        {
             // if allocation fails, progress just gets set to NULL
            m_pCallBack = new COfflineSynchronizeCallback( this,
                                                        m_CLSIDServer,m_dwSyncFlags,
                                                        (SYNCMGRFLAG_MAYBOTHERUSER & m_dwSyncFlags) /* fAllowModeless */ );
        }

        Assert( !(m_pOneStopHandler && m_pOldOneStopHandler) );
        if (m_pOneStopHandler)
        {
            __try
            {
                hr = m_pOneStopHandler->SetProgressCallback( (LPSYNCMGRSYNCHRONIZECALLBACK) m_pCallBack );
            }
            __except(QueryHandleException())
            {
                hr = HRESULT_FROM_WIN32(GetExceptionCode());
                AssertSz(0,"Exception in Handler's SetProgressCallback method.");
            }
        }

        if (m_pOldOneStopHandler)
        {
            __try
            {
                hr = m_pOldOneStopHandler->SetProgressCallback( (LPOLDSYNCMGRSYNCHRONIZECALLBACK) m_pCallBack );
            }
            __except(QueryHandleException())
            {
                hr = HRESULT_FROM_WIN32(GetExceptionCode());
                AssertSz(0,"Exception in Handler's SetProgressCallback method.");
            }
        }

        if ( (S_OK != hr) && (m_pCallBack)  )
        {
            m_pCallBack->SetHndlrMsg(NULL,FALSE);
            m_pCallBack->Release(); // on an error go ahead and release our copy too.
            m_pCallBack = NULL;
        }
    }

    m_dwNestCount--;
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::SetHandlerInfo, private
//
//  Synopsis:   sets up the Handler info
//
//  Arguments:  
//
//  Returns:    S_OK on Success
//
//  Modifies:
//
//  History:    28-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrMsg::SetHandlerInfo()
{
    LPSYNCMGRHANDLERINFO pSyncMgrHandlerInfo = NULL;
    HRESULT hr = E_UNEXPECTED; 

    Assert(FALSE == m_fForceKilled && FALSE == m_fDead);

    hr = GetHandlerInfo(&pSyncMgrHandlerInfo);
    if (S_OK != hr || (NULL == pSyncMgrHandlerInfo))
    {
        return hr;
    }
    
    if (!IsValidSyncMgrHandlerInfo(pSyncMgrHandlerInfo))
    {
        CoTaskMemFree(pSyncMgrHandlerInfo);
        return E_INVALIDARG;
    }

    Assert(m_pHndlrQueue);

    if (m_pHndlrQueue)
    {
        hr = m_pHndlrQueue->SetHandlerInfo(m_pHandlerId,pSyncMgrHandlerInfo);
    }

    if (pSyncMgrHandlerInfo)
    {
        CoTaskMemFree(pSyncMgrHandlerInfo);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::AddtoItemList, private
//
//  Synopsis:   Adds a single Items to the queue
//
//  Arguments:  [poffItem] - Pointer to Item to add
//
//  Returns:    S_OK on Success
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT CHndlrMsg::AddToItemList(LPSYNCMGRITEM poffItem)
{
    HRESULT hr = E_UNEXPECTED;

    Assert(m_dwThreadId == GetCurrentThreadId());
    Assert(FALSE == m_fForceKilled && FALSE == m_fDead);

    Assert(m_pHndlrQueue);

    if (!IsValidSyncMgrItem(poffItem))
    {
        return E_INVALIDARG;
    }

    if (m_pHndlrQueue)
    {
        hr  = m_pHndlrQueue->AddItemToHandler(m_pHandlerId,poffItem);
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::AddHandlerItems, private
//
//  Synopsis:   Calls the handlers enumerator and adds each returned item
//              to the queue
//
//  Arguments:  [hwndList] - hwnd of ListView to add items too. (Not Used)
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP  CHndlrMsg::AddHandlerItems(HWND hwndList, DWORD *pcbNumItems)
{
    HRESULT hr = E_UNEXPECTED;
    LPSYNCMGRENUMITEMS pEnumOffline = NULL;

    Assert(m_dwThreadId == GetCurrentThreadId());
    Assert(FALSE == m_fForceKilled && FALSE == m_fDead);
    Assert(pcbNumItems);

    *pcbNumItems = 0;

    Assert(0 == m_dwNestCount);
    m_dwNestCount++;

    SetHandlerInfo(); // setup the toplevel handler info

    Assert(m_pOneStopHandler || m_pOldOneStopHandler);
    Assert( !(m_pOneStopHandler && m_pOldOneStopHandler) );

    if (m_pOneStopHandler || m_pOldOneStopHandler)
    {
        if ( m_pOneStopHandler )
        {
            __try
            {
                hr = m_pOneStopHandler->EnumSyncMgrItems(&pEnumOffline);
            }
            __except(QueryHandleException())
            {
                hr = HRESULT_FROM_WIN32(GetExceptionCode());
                AssertSz(0,"Exception in Handler's EnumSyncMgrItems method.");
            }
        }
        if ( m_pOldOneStopHandler )
        {
            __try
            {
                hr = m_pOldOneStopHandler->EnumSyncMgrItems(&pEnumOffline);
            }
            __except(QueryHandleException())
            {
                hr = HRESULT_FROM_WIN32(GetExceptionCode());
                AssertSz(0,"Exception in Handler's EnumSyncMgrItems method.");
            }
        }

        // Review - Make sure preferences aren't deleted
        //  in missing items case.
        if ( (S_OK == hr || S_SYNCMGR_MISSINGITEMS  == hr) && pEnumOffline)
        {
            SYNCMGRITEMNT5B2 offItem; // temporarily use NT5B2 structure since its bigger
            ULONG pceltFetched;

            Assert(sizeof(SYNCMGRITEMNT5B2) > sizeof(SYNCMGRITEM));

            // sit in loop getting data of objects to fill list box.
            // should really set up list in memory for OneStop to fill in or
            // main thread could pass in a callback interface.
            
            if (pEnumOffline)
            {
                __try
                {
                    while(S_OK == pEnumOffline->Next(1,(LPSYNCMGRITEM) &offItem,&pceltFetched))
                    {
                        if (S_OK == AddToItemList((LPSYNCMGRITEM) &offItem))
                        {
                            ++(*pcbNumItems);
                        }
                    }

                    pEnumOffline->Release();
                }
                __except(QueryHandleException())
                {
                    hr = HRESULT_FROM_WIN32(GetExceptionCode());
                    AssertSz(0,"Exception in Handler's EnumOffline::Next method.");
                }
            }
            else
            {
                hr = E_UNEXPECTED;
            }
        }
    }

    m_dwNestCount--;
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::CreateServer, private
//
//  Synopsis:   Creates and Instance of the handle
//
//  Arguments:  [pCLSIDServer] - CLSID of Handler
//              [pHndlrQueue] - pointer to queue handler should be added too
//              [wHandlerID] - ID of Handler in the queue
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP  CHndlrMsg::CreateServer(const CLSID *pCLSIDServer,CHndlrQueue *pHndlrQueue,
                                  HANDLERINFO *pHandlerId,DWORD dwProxyThreadId)
{
    HRESULT hr = S_OK;
    LPUNKNOWN pUnk;
    LPSYNCMGRENUMITEMS pEnumOffline = NULL;

    Assert(m_dwThreadId == GetCurrentThreadId());
    Assert(FALSE == m_fForceKilled && FALSE == m_fDead);
    Assert(0 == m_dwNestCount);
    m_dwNestCount++;

    m_CLSIDServer = *pCLSIDServer;
    m_pHndlrQueue = pHndlrQueue;
    m_dwProxyThreadId = dwProxyThreadId;

    if (m_pHndlrQueue)
    {
        m_pHndlrQueue->AddRef();
    }

    m_pHandlerId = pHandlerId;

    hr = CoCreateInstance(m_CLSIDServer, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (void **) &pUnk);

    if (S_OK == hr)
    {
        __try
        {
            hr = pUnk->QueryInterface(IID_ISyncMgrSynchronize,(void **) &m_pOneStopHandler);
        }
        __except(QueryHandleException())
        {
            hr = HRESULT_FROM_WIN32(GetExceptionCode());
            AssertSz(0,"Exception in Handler's IUnknown::QI method.");
        }
        __try
        {
            pUnk->Release();
        }
        __except(QueryHandleException())
        {
            hr = HRESULT_FROM_WIN32(GetExceptionCode());
            AssertSz(0,"Exception in Handler's IUnknown::Release method.");
        }
    }

    if (S_OK != hr)
    {
        m_pOneStopHandler = NULL;
        m_pOldOneStopHandler = NULL;
    }

    m_dwNestCount--;
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::SetHndlrQueue, private
//
//  Synopsis:   Assigns a new HndlrQueue.
//
//  Arguments:  [pHndlrQueue] - Pointer to the Queue
//              [wHandlerId] - Id assigned to handler in the new queue
//
//              !!!Warning - this is on the callers thread
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP  CHndlrMsg::SetHndlrQueue(CHndlrQueue *pHndlrQueue,HANDLERINFO *pHandlerId,DWORD dwProxyThreadId)
{
    CLock clockCallback(this);

    Assert(FALSE == m_fForceKilled && FALSE == m_fDead);

    clockCallback.Enter();

    Assert(0 == m_dwNestCount);
    m_dwNestCount++;

    if (pHndlrQueue != m_pHndlrQueue)
    {
        if (m_pHndlrQueue)
        {
            m_pHndlrQueue->Release();
        }

        m_pHndlrQueue = pHndlrQueue;

        if (m_pHndlrQueue)
        {
            m_pHndlrQueue->AddRef();
        }
    }

    AttachThreadInput(FALSE); // make sure thread input isn't set

    // update handlr id and proxy which can change even if queue is same
    // which can happen first queue that gets set in choice.
    m_pHandlerId = pHandlerId;
    m_dwProxyThreadId = dwProxyThreadId;

    m_dwNestCount--;

    clockCallback.Leave();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::GetHndlrQueue, private
//
//  Synopsis:   Gets current Queue,
//              Can be called on any thread so progress callback
//              gets this information.
//
//  Arguments:  [ppHndlrQueue] - Out param filled with Pointer to the Queue
//                              [pwHandlerId] - out param filled with Id assigned to handler
//                              in the new queue
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

void CHndlrMsg::GetHndlrQueue(CHndlrQueue **ppHndlrQueue,HANDLERINFO **ppHandlerId,DWORD *pdwProxyThreadId)
{
    CLock clockCallback(this);

    Assert(FALSE == m_fForceKilled && FALSE == m_fDead);

    clockCallback.Enter();

    *ppHndlrQueue = m_pHndlrQueue;
    *ppHandlerId = m_pHandlerId;
    *pdwProxyThreadId = m_dwProxyThreadId;

    if (m_pHndlrQueue)
    {
        m_pHndlrQueue->AddRef();
    }

    clockCallback.Leave();
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::AttachThreadInput, private
//
//  Synopsis:   Attaches the thread input of this thread
//              with the calling proxy so UI works correctly.
//
//  Arguments:  [fAttach] - Bool to indicate if should attach or not.
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

void  CHndlrMsg::AttachThreadInput(BOOL fAttach)
{
    Assert(FALSE == m_fForceKilled && FALSE == m_fDead);

    // if request is same as current state don't do anything.
    if (m_fThreadInputAttached != fAttach )
    {
        m_fThreadInputAttached = fAttach;
        ::AttachThreadInput(m_dwProxyThreadId,m_dwThreadId,fAttach);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::ForceKillHandler, private
//
//  Synopsis:   called directly by proxy when a thread is not
//              responding. Does any necessary cleanup of classes in the handler
//              thread before the proxy kills the thred
//
//  Arguments: 
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    17-Nov-98      rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrMsg::ForceKillHandler()
{
    Assert(FALSE == m_fForceKilled && FALSE == m_fDead);

    m_fForceKilled = TRUE;

    // if have a callback tell it we terminated but don't
    // release it in case the handler calls the callback later.

    if (m_pCallBack)
    {
        COfflineSynchronizeCallback* pCallback = m_pCallBack;
    
        m_pCallBack = NULL;
        pCallback->SetHndlrMsg(NULL,TRUE);
    }

    // delete our instance since should never be called again.
    delete this;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\exe\hndlrq.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Hndlrq.cpp
//
//  Contents:   Implements class for keeping track of handlers
//              and the UI associated with them
//
//  Classes:    CHndlrQueue
//
//  Notes:
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

#define HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE 10

// called to set up the JobInfo on a choice queue.

STDMETHODIMP CHndlrQueue::AddQueueJobInfo(DWORD dwSyncFlags,DWORD cbNumConnectionNames,
                                TCHAR **ppConnectionNames,
                                 TCHAR *pszScheduleName,BOOL fCanMakeConnection
                                 ,JOBINFO **pJobInfo)

{
    HRESULT hr = E_UNEXPECTED;
    TCHAR *pszConnectionName;
    TCHAR **pszConnectionNameArray;
    CLock clockqueue(this);

    *pJobInfo = NULL;

    Assert(m_QueueType == QUEUETYPE_CHOICE);

    if (m_QueueType != QUEUETYPE_CHOICE)
    {
        return E_UNEXPECTED;
    }

    clockqueue.Enter();

    Assert(NULL == m_pFirstJobInfo);

    // fix up connections so have at least one connection/job.
    // this currently happens on an UpdateItems.
    if (NULL == ppConnectionNames || 0 == cbNumConnectionNames )
    {
        cbNumConnectionNames = 1;
        pszConnectionName = TEXT("");
        pszConnectionNameArray = &pszConnectionName;
    }
    else
    {
        pszConnectionName = *ppConnectionNames;
        pszConnectionNameArray = ppConnectionNames;
    }

    // create a job requesting size for the number of connections passed in.
    hr = CreateJobInfo(&m_pFirstJobInfo,cbNumConnectionNames);

    if (S_OK == hr)
    {
        DWORD dwConnectionIndex;

        Assert(cbNumConnectionNames >= 1); // Review assert for debugging to test when have multiple connections for first time.
        m_pFirstJobInfo->cbNumConnectionObjs = 0;

        // add a connectionObject for each connection
        for (dwConnectionIndex = 0; dwConnectionIndex < cbNumConnectionNames; ++dwConnectionIndex)
        {
            hr = ConnectObj_FindConnectionObj(pszConnectionNameArray[dwConnectionIndex],
                                        TRUE,&(m_pFirstJobInfo->pConnectionObj[dwConnectionIndex]));

            if (S_OK != hr)
            {
                break;
            }
            else
            {
                ++m_pFirstJobInfo->cbNumConnectionObjs;
            }
        }

        if (S_OK == hr)
        {
            m_pFirstJobInfo->dwSyncFlags = dwSyncFlags;

            if ((SYNCMGRFLAG_SCHEDULED == (dwSyncFlags & SYNCMGRFLAG_EVENTMASK)))
            {
                StringCchCopy(m_pFirstJobInfo->szScheduleName, ARRAYSIZE(m_pFirstJobInfo->szScheduleName), pszScheduleName);
                m_pFirstJobInfo->fCanMakeConnection = fCanMakeConnection;
                m_pFirstJobInfo->fTriedConnection = FALSE;
            }
        }
        else
        {
            // couldn't create the connectionObj so release our jobID
            m_pFirstJobInfo = NULL;
        }
   }

   *pJobInfo = m_pFirstJobInfo;
   clockqueue.Leave();

   return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::CHndlrQueue, public
//
//  Synopsis:   Constructor used to create a progress queue
//
//  Arguments:  [QueueType] - Type of Queue that should be created.
//              [hwndDlg] - Hwnd who owns this queue.
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

CHndlrQueue::CHndlrQueue(QUEUETYPE QueueType,CBaseDlg *pDlg)
{
    Assert( (QueueType == QUEUETYPE_PROGRESS) || (QueueType == QUEUETYPE_CHOICE) );

    m_pFirstHandler = NULL;
    m_wHandlerCount = 0;
    m_dwShowErrororOutCallCount = 0;
    m_cRefs = 1;
    m_QueueType = QueueType;
    m_fItemsMissing = FALSE;
    m_dwQueueThreadId = GetCurrentThreadId();
    m_iNormalizedMax = 0;
    m_fNumItemsCompleteNeedsARecalc = TRUE;

    m_pDlg = pDlg;
    if (m_pDlg)
    {
        m_hwndDlg = m_pDlg->GetHwnd();
        Assert(m_hwndDlg);
    }

    m_fInCancelCall = FALSE;
    m_pFirstJobInfo = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::~CHndlrQueue, public
//
//  Synopsis:   Destructor
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

CHndlrQueue::~CHndlrQueue()
{
    CLock clockqueue(this);

    // for a progress queue all the jobInfos should be released
    // for the choice queue there should be one JobInfo that has to
    // be released that was addref'd in the constructor.

    Assert(0 == m_cRefs);
    Assert(NULL == m_pFirstJobInfo); // review - this should never fire anymore.

    Assert(NULL == m_pFirstJobInfo
            || m_QueueType == QUEUETYPE_CHOICE); // there shouldn't be any unreleased JobInfo

    Assert(m_pFirstHandler == NULL); // All Handlers should have been released by now.
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::AddRef, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    01-June-98       rogerg        Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CHndlrQueue::AddRef()
{
    DWORD cRefs;

    Assert(m_cRefs >= 1); // should never zero bounce.
    cRefs = InterlockedIncrement((LONG *)& m_cRefs);
    return cRefs;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::Release, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    01-June-98       rogerg        Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CHndlrQueue::Release()
{
    DWORD cRefs;

    cRefs = InterlockedDecrement( (LONG *) &m_cRefs);

    Assert( ((LONG) cRefs) >= 0); // should never go negative.
    if (0 == cRefs)
    {
        delete this;
    }

    return cRefs;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::AddHandler, public
//
//  Synopsis:   Adds a new empty handler to the queue and returns it ID
//
//  Arguments:  [pwHandlerID] - on success contains the assigned Handler ID
//              [pJobInfo] - Job this item is associated with
//              [dwRegistrationFlags] - Flags the Handler has registered for.
//
//  Returns:    Appropriate return codes
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::AddHandler(HANDLERINFO **ppHandlerId,JOBINFO *pJobInfo,DWORD dwRegistrationFlags)
{
    HRESULT hr = E_OUTOFMEMORY;
    LPHANDLERINFO pnewHandlerInfo;
    CLock clockqueue(this);

    *ppHandlerId = 0;

    pnewHandlerInfo = (LPHANDLERINFO) ALLOC(sizeof(HANDLERINFO));

    if (pnewHandlerInfo)
    {
        clockqueue.Enter();

        m_fNumItemsCompleteNeedsARecalc = TRUE; // need to recalc next GetProgress.

        // initialize the new Handler Entry
        memset(pnewHandlerInfo, 0, sizeof(HANDLERINFO));
        pnewHandlerInfo->HandlerState = HANDLERSTATE_CREATE;
        pnewHandlerInfo->pHandlerId =   pnewHandlerInfo;
        pnewHandlerInfo->dwRegistrationFlags = dwRegistrationFlags;

        // queue should be a choice queue and
        // there should already be a jobinfo.
        Assert(m_QueueType == QUEUETYPE_CHOICE);
        Assert(m_pFirstJobInfo);
        Assert(pJobInfo == m_pFirstJobInfo); // for now job info should always be the first one.

        if (m_QueueType == QUEUETYPE_CHOICE && pJobInfo)
        {
            AddRefJobInfo(pJobInfo);
            pnewHandlerInfo->pJobInfo = pJobInfo;
        }

        // add to end of list and set pHandlerId. End of list since in choice dialog want
        // first writer wins so don't have to continue searches when setting item state.

        if (NULL == m_pFirstHandler)
        {
            m_pFirstHandler = pnewHandlerInfo;
        }
        else
        {
            LPHANDLERINFO pCurHandlerInfo;

            pCurHandlerInfo = m_pFirstHandler;

            while (pCurHandlerInfo->pNextHandler)
            {
                pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
            }

            pCurHandlerInfo->pNextHandler = pnewHandlerInfo;
        }

        *ppHandlerId = pnewHandlerInfo->pHandlerId;

        clockqueue.Leave();

        hr = S_OK;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::ForceKillHandlers, public
//
//  Synopsis:   Kills unresponsive handlers after timeout
//
//  Returns:    Appropriate return codes
//
//  History:    20-Nov-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::ForceCompleteOutCalls(LPHANDLERINFO pCurHandler)
{
    // need to have lock for argument to be valid.

    ASSERT_LOCKHELD(this); 

    //prepare for sync out call
    if (pCurHandler->dwOutCallMessages & ThreadMsg_PrepareForSync)
    {
        CallCompletionRoutine(pCurHandler,ThreadMsg_PrepareForSync,
                              HRESULT_FROM_WIN32(ERROR_CANCELLED),0,NULL);
    }

    //Synchronize out call
    if (pCurHandler->dwOutCallMessages & ThreadMsg_Synchronize)
    {
        CallCompletionRoutine(pCurHandler,ThreadMsg_Synchronize,
                              HRESULT_FROM_WIN32(ERROR_CANCELLED),0,NULL);
    }
    //ShowProperties out call
    if (pCurHandler->dwOutCallMessages & ThreadMsg_ShowProperties)
    {
        CallCompletionRoutine(pCurHandler,ThreadMsg_ShowProperties,
                              HRESULT_FROM_WIN32(ERROR_CANCELLED),0,NULL);
    }
    //Show Errors out call
    if (pCurHandler->dwOutCallMessages & ThreadMsg_ShowError)
    {
        CallCompletionRoutine(pCurHandler,ThreadMsg_ShowError,
                              HRESULT_FROM_WIN32(ERROR_CANCELLED),0,NULL);
    }

    // force handler state to release.
    pCurHandler->HandlerState = HANDLERSTATE_RELEASE;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::ForceKillHandlers, public
//
//  Synopsis:   Kills unresponsive handlers after timeout
//
//  Returns:    Appropriate return codes
//
//  History:    30-Oct-98       susia        Created.
//              19-Nov-98       rogerg       Change to only kill first unresponsive handler
//
//----------------------------------------------------------------------------

#define BAD_HANDLERSTATE(pHandlerId) \
    (  (HANDLERSTATE_INSYNCHRONIZE >= pHandlerId->HandlerState)   \
    || (pHandlerId->dwOutCallMessages & ThreadMsg_SetItemStatus)  \
    )

STDMETHODIMP CHndlrQueue::ForceKillHandlers(BOOL *pfItemToKill)
{
    HRESULT hr = S_OK;
    LPHANDLERINFO pCurHandler;
    CLock clockqueue(this);

    *pfItemToKill = TRUE; // if something strange happens make sure timer gets reset.

    clockqueue.Enter();

    pCurHandler = m_pFirstHandler;

    while (pCurHandler)
    {
        // if handler is cancelled but still in a noncancelled state or
        // is cancelled but stuck in the outcall then terminate.

        // need to check both because some handlers may call the callback
        // to set the state done but still be stuck in an out call.

        if ( pCurHandler->fCancelled &&  BAD_HANDLERSTATE(pCurHandler) )
        {
            TCHAR pszHandlerName[MAX_SYNCMGRHANDLERNAME + 1];

            ConvertString(pszHandlerName,
                          (pCurHandler->SyncMgrHandlerInfo).wszHandlerName,
                          MAX_SYNCMGRHANDLERNAME);

            // yield because of message box in Terminate Handler call.

            Assert(!pCurHandler->fInTerminateCall);
            pCurHandler->fInTerminateCall = TRUE;
            clockqueue.Leave();

            hr = pCurHandler->pThreadProxy->TerminateHandlerThread(pszHandlerName,TRUE);

            clockqueue.Enter();

            pCurHandler->fInTerminateCall = FALSE;

            if (hr == S_OK)
            {
                LPHANDLERINFO pKilledHandler = pCurHandler;

                ForceCompleteOutCalls(pCurHandler);

                // now need to loop through remaining instances handlers off the same clsid
                // we just killed

                // CODE REVIEW: NOTENOTE:
                // pCurHandler is being assigned, not compared - its a '=', not a '=='
                while(pCurHandler = pCurHandler->pNextHandler)
                {
                    if (pCurHandler->clsidHandler == pKilledHandler->clsidHandler)
                    {
                        // must meet original kil criteria
                        if ( pCurHandler->fCancelled && BAD_HANDLERSTATE(pCurHandler) )
                        {
                            HRESULT hrProxyTerminate;

                            pCurHandler->fInTerminateCall = TRUE;

                            clockqueue.Leave();
                            hrProxyTerminate = pCurHandler->pThreadProxy->TerminateHandlerThread(pszHandlerName,FALSE);
                            clockqueue.Enter();

                            Assert(S_OK == hrProxyTerminate);// this should never fail.

                            ForceCompleteOutCalls(pCurHandler);

                            pCurHandler->fInTerminateCall = FALSE;
                        }
                    }
                }
            }

            // if handled one , break out and reqiure to be called again.
            break; 
        }

        pCurHandler = pCurHandler->pNextHandler;
    }

    // finally loop through the queue and see if there are any more items to kill

    *pfItemToKill = FALSE; 

    pCurHandler = m_pFirstHandler;

    while (pCurHandler)
    {
        // if handler is cancelled but still in a noncancelled state or
        // is cancelled but stuck in the outcall then terminate.

        // need to check both because some handlers may call the callback
        // to set the state done but still be stuck in an out call.
        if ( pCurHandler->fCancelled && BAD_HANDLERSTATE(pCurHandler) )
        {
             *pfItemToKill = TRUE;
             break;
        }

        pCurHandler = pCurHandler->pNextHandler;
    }

    clockqueue.Leave();

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::Cancel, public
//
//  Synopsis:   Set the current Handler Items in the queue
//              into cancel mode.
//
//          The Different States Are.
//              If the item is waiting for <= PrepareForSync place in Release
//              If InPrepareForSync Skip Items and then Synchrnoize
//                  will check the complete value before calling through
//                  and if set will just release the Handler.
//              If Waiting to Synchronize Skip Items then let Synchronize
//                  Check for complete value and just set release
//              If Item is currently In the Synchronize Skip all items
//                  and then just let synchronize return
//
//  Algorithm. If <= PrepareForSync then place in Release, Else if <= InSynchronize
//              then SkipTheItems
//
//         Note: Relies on Synchronize setting handler state before calling
//              through to Handlers Synchronize Method. PrepareForSync should
//              also check this in case new PrepareforSync request comes
//              in during an out call in this routine.
//
//  Arguments:
//
//  Returns:    Appropriate return codes
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::Cancel(void)
{
    HRESULT hr = E_UNEXPECTED;
    LPHANDLERINFO pCurHandler;
    CLock clockqueue(this);

    clockqueue.Enter();

    // don't do anything is still processing the last cancel request

    if (!m_fInCancelCall)
    {
        m_fInCancelCall = TRUE;

        // first thing set cancel to true on all handler items
        // so if sync,PrepareForSyncRequest comes in during SetItemStatus
        // out call it will be cancelled immediately.

        pCurHandler = m_pFirstHandler;

        while (pCurHandler)
        {
            pCurHandler->fCancelled = TRUE;
            pCurHandler = pCurHandler->pNextHandler;
        }

        // now loop through looking for any items that need to have
        // their item status set.

        // !!!remember new requests can come in so only make out call
        // if fCancelled is set.
        // !!! items can be removed from queue in between our cancel call
        //  and when we return.

        pCurHandler = m_pFirstHandler;

        while (pCurHandler)
        {
            CThreadMsgProxy *pThreadProxy = pCurHandler->pThreadProxy;

            if (pCurHandler->fCancelled && pThreadProxy
                && (pCurHandler->HandlerState >= HANDLERSTATE_INPREPAREFORSYNC)
                && (pCurHandler->HandlerState <= HANDLERSTATE_INSYNCHRONIZE) )
            {
                // could be in a setitemstatus call, if so then don't do another.
                // review - dup of SkipCode. should have a general purpose function
                // to call after setting what items should be cancelled.
                if (!(pCurHandler->dwOutCallMessages & ThreadMsg_SetItemStatus))
                {
                    pCurHandler->dwOutCallMessages |= ThreadMsg_SetItemStatus;            
                    clockqueue.Leave();

                    // send a reset to the hwnd we belong to if there is one

                    if (m_hwndDlg)
                    {
                        SendMessage(m_hwndDlg,WM_PROGRESS_RESETKILLHANDLERSTIMER,0,0);
                    }

                    hr = pThreadProxy->SetItemStatus(GUID_NULL, SYNCMGRSTATUS_STOPPED);

                    clockqueue.Enter();
                    pCurHandler->dwOutCallMessages &= ~ThreadMsg_SetItemStatus;
                }
            }
            else if (pCurHandler->HandlerState  <  HANDLERSTATE_INPREPAREFORSYNC)
            {
                LPITEMLIST pCurItem;

                pCurHandler->HandlerState = HANDLERSTATE_RELEASE;

                // need to setup HwndCallback so progres gets updated. 
                // review, after ship why can't setup HwndCallback on transferqueueu
                pCurHandler->hWndCallback = m_hwndDlg;

                // if handler hansn't been kicked off yet, just reset the items ourselves
                pCurItem = pCurHandler->pFirstItem;

                while (pCurItem)
                {
                    if (pCurItem->fIncludeInProgressBar)
                    {
                        SYNCMGRPROGRESSITEM SyncProgressItem;

                        SyncProgressItem.cbSize = sizeof(SYNCMGRPROGRESSITEM);
                        SyncProgressItem.mask = SYNCMGRPROGRESSITEM_PROGVALUE | SYNCMGRPROGRESSITEM_MAXVALUE | SYNCMGRPROGRESSITEM_STATUSTYPE;
                        SyncProgressItem.iProgValue = HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE;
                        SyncProgressItem.iMaxValue = HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE;
                        SyncProgressItem.dwStatusType = SYNCMGRSTATUS_STOPPED;

                        // set progress faking we are in an out call so any releasecompleted
                        // handler that comes through doesn't release us.
                        // if already in outCall then progress just won't get updated
                        // until next time.
                        if (!(pCurHandler->dwOutCallMessages & ThreadMsg_SetItemStatus))
                        {
                            pCurHandler->dwOutCallMessages |= ThreadMsg_SetItemStatus;  
                            
                            clockqueue.Leave();

                            Progress(pCurHandler->pHandlerId, pCurItem->offlineItem.ItemID,&SyncProgressItem);

                            clockqueue.Enter();
                            pCurHandler->dwOutCallMessages &= ~ThreadMsg_SetItemStatus;
                        }
                    }

                    pCurItem = pCurItem->pnextItem;
                }

            }

            pCurHandler = pCurHandler->pNextHandler;
        }

        m_fInCancelCall = FALSE;
    }

    clockqueue.Leave();

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::MoveHandler, public
//
//  Synopsis:   Moves the Handler from a queue into this queue.
//
//  Arguments:  [pQueueMoveFrom] - Queue the handler is being moved from.
//              [pHandlerInfoMoveFrom] - Handler that is being moved
//              [ppHandlerId] - On Success contains the new HandlerID
//
//  Returns:    Appropriate return codes
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::MoveHandler(CHndlrQueue *pQueueMoveFrom,
                                      LPHANDLERINFO pHandlerInfoMoveFrom,
                                      HANDLERINFO **ppHandlerId,
                                      CLock *pclockQueue)
{
    LPITEMLIST pCurItem = NULL;
    JOBINFO *pJobInfo = NULL;
    BOOL fHasItemsToSync = FALSE;

    ASSERT_LOCKHELD(this); // items should already be locked when this function is called.
    ASSERT_LOCKHELD(pQueueMoveFrom);

    if ( (QUEUETYPE_PROGRESS != m_QueueType) &&  (QUEUETYPE_CHOICE != m_QueueType) )
    {
        Assert(QUEUETYPE_CHOICE == m_QueueType);
        Assert(QUEUETYPE_PROGRESS == m_QueueType);
        return E_UNEXPECTED; // review error code.
    }

    *ppHandlerId = 0;
    ++m_wHandlerCount;

    //  pHandlerInfoMoveFrom->pHandlerId = m_wHandlerCount;
    pHandlerInfoMoveFrom->pNextHandler = NULL;

     *ppHandlerId = pHandlerInfoMoveFrom->pHandlerId;

    // now fix up the items duplicate flag information.
    pCurItem = pHandlerInfoMoveFrom->pFirstItem;

    while (pCurItem)
    {
        LPHANDLERINFO pHandlerMatched;
        LPITEMLIST pItemListMatch;

        // setup the information for the UI depending on if this item is check and
        // the state it is in.

        // if item is now within a valid range then uncheck it.
        if (SYNCMGRITEMSTATE_CHECKED == pCurItem->offlineItem.dwItemState
            && ( (pHandlerInfoMoveFrom->HandlerState < HANDLERSTATE_PREPAREFORSYNC)
                    || (pHandlerInfoMoveFrom->HandlerState >= HANDLERSTATE_RELEASE) )  )
       {
            Assert(pHandlerInfoMoveFrom->HandlerState >= HANDLERSTATE_PREPAREFORSYNC); // this should never happen.
            
            pCurItem->offlineItem.dwItemState = SYNCMGRITEMSTATE_UNCHECKED;
       }

       // setup the UI information based on if the item is checked.
       // or if its a hidden item.
        if ( (SYNCMGRITEMSTATE_UNCHECKED == pCurItem->offlineItem.dwItemState) || pCurItem->fHiddenItem)
        {
            SetItemProgressValues(pCurItem,HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE,HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE);
            pCurItem->fIncludeInProgressBar = FALSE;
        }
        else
        {
            fHasItemsToSync = TRUE;
            SetItemProgressValues(pCurItem,0,HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE);
            pCurItem->fIncludeInProgressBar = TRUE;
        }

        if (IsItemAlreadyInList(pHandlerInfoMoveFrom->clsidHandler,
                                (pCurItem->offlineItem.ItemID),
                                pHandlerInfoMoveFrom->pHandlerId,
                                &pHandlerMatched,&pItemListMatch) )
        {
            pCurItem->fDuplicateItem = TRUE;
        }
        else
        {
            Assert(FALSE == pCurItem->fDuplicateItem); // catch case of duplicate getting lost
            pCurItem->fDuplicateItem = FALSE;
        }

        pCurItem = pCurItem->pnextItem;
    }

    // if the item we are moving has a Proxy then update the proxy to the new queue.
    // We update this when the item is not attached to either queue.
    if (pHandlerInfoMoveFrom->pThreadProxy)
    {
        HANDLERINFO *pHandlerInfoArg = pHandlerInfoMoveFrom->pHandlerId;

        // set the proxy to point to the new information
        pHandlerInfoMoveFrom->pThreadProxy->SetProxyParams(m_hwndDlg
                                                            ,m_dwQueueThreadId
                                                            ,this
                                                            ,pHandlerInfoArg);
    }

    // Add the handler to this list.
    if (NULL == m_pFirstHandler)
    {
        m_pFirstHandler = pHandlerInfoMoveFrom;
//      Assert(1 == m_wHandlerCount); // Review = HandlerCount doesn't have to be 1 if ReleaseCompltedHandlers has been called.
    }
    else
    {
        LPHANDLERINFO pCurHandlerInfo;

        pCurHandlerInfo = m_pFirstHandler;

        while (pCurHandlerInfo->pNextHandler)
        {
            pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
        }

        pCurHandlerInfo->pNextHandler = pHandlerInfoMoveFrom;
    }

    // if this is a progress queue and there are not items to sync for the
    // handler or the HandlerState isn't in PrepareForSync then set
    // the state to TransferRelease since it can be freed.

    if ((QUEUETYPE_PROGRESS == m_QueueType && !fHasItemsToSync )
        ||  (pHandlerInfoMoveFrom->HandlerState != HANDLERSTATE_PREPAREFORSYNC)) 
    {
        pHandlerInfoMoveFrom->HandlerState = HANDLERSTATE_TRANSFERRELEASE;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::TransferQueueData, public
//
//  Synopsis:   Moves the Items from one queue to another. Currently we only
//              support transferrring items from a choice queueu to a choice or
//              progress queue. Only handlers in the PREPAREFORSYNC state are moved
//              when transferring to a Progress queue. When transferring to a choice
//              queue only items in the ADDHANDLERITEMS state are moved.
//
//              !!Warning - Cannot release lock during this process
//
//  Arguments:  [pQueueMoveFrom] - Queue to move items from.
//              [dwSyncFlags] - flags that started the sync
//              [pszConnectionName] - Connection the sync should be performed on, can be NULL
//              [szSchedulName] - Name of Schedule that started this Job. Can be NULL.
//              [hRasPendingEvent] - Event to signal when job is complete. Can be NULL.
//
//  Returns:    Appropriate return codes
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::TransferQueueData(CHndlrQueue *pQueueMoveFrom
            /* ,DWORD dwSyncFlags,TCHAR *pzConnectionName,TCHAR *szScheduleName */)
{
    HRESULT hr = E_UNEXPECTED;
    HANDLERINFO HandlerInfoMoveFrom;
    LPHANDLERINFO pHandlerInfoMoveFrom = &HandlerInfoMoveFrom;
    CLock clockqueue(this);
    CLock clockqueueMoveFrom(pQueueMoveFrom);

    clockqueue.Enter();
    clockqueueMoveFrom.Enter();

    m_fNumItemsCompleteNeedsARecalc = TRUE; // need to recalc NumItems next time

    if ((QUEUETYPE_PROGRESS != m_QueueType
            && QUEUETYPE_CHOICE != m_QueueType) || QUEUETYPE_CHOICE != pQueueMoveFrom->m_QueueType)
    {
        Assert(QUEUETYPE_PROGRESS == m_QueueType || QUEUETYPE_CHOICE == m_QueueType);
        Assert(QUEUETYPE_CHOICE == pQueueMoveFrom->m_QueueType);
    }
    else if (NULL == pQueueMoveFrom->m_pFirstHandler) 
    {
        // if no job info then there aren't any items to move.
    }
    else
    {
        JOBINFO *pMoveFromJobInfo = NULL;

        // transfer everything over and then release after done call freecompletedhandlers
        // to clean anything up.

        // transfer over all jobs

        Assert(pQueueMoveFrom->m_pFirstJobInfo);
        Assert(pQueueMoveFrom->m_pFirstJobInfo->pConnectionObj);

        pMoveFromJobInfo = pQueueMoveFrom->m_pFirstJobInfo;
        pQueueMoveFrom->m_pFirstJobInfo = NULL;

        if (NULL == m_pFirstJobInfo)
        {
            m_pFirstJobInfo = pMoveFromJobInfo;
        }
        else
        {
            JOBINFO *pCurLastJob = NULL;

            pCurLastJob = m_pFirstJobInfo;
            while (pCurLastJob->pNextJobInfo)
            {
                pCurLastJob = pCurLastJob->pNextJobInfo;
            }

            pCurLastJob->pNextJobInfo = pMoveFromJobInfo;
        }

        // loop through moving items, have to reassign the Handler ID and
        // !!Warning - This function does nothing with ListViewData it is up to the
        //     caller to make sure this is set up properly

        // review  - should just loop through fixing up necessary items and then
        // add entire list onto end. inneficient to do one at a time.

        pHandlerInfoMoveFrom->pNextHandler = pQueueMoveFrom->m_pFirstHandler;
        while (pHandlerInfoMoveFrom->pNextHandler)
        {
            LPHANDLERINFO pHandlerToMove;
            HANDLERINFO *pNewHandlerId;

            // Asserts for making sure the UI has been cleared from the queue
            Assert(FALSE == pHandlerInfoMoveFrom->pNextHandler->fHasErrorJumps);
            Assert(pHandlerInfoMoveFrom->pNextHandler->pJobInfo);

            // !!! Warning get next handler before transfer or next ptr will be invalid.

            pHandlerToMove = pHandlerInfoMoveFrom->pNextHandler;
            pHandlerInfoMoveFrom->pNextHandler = pHandlerToMove->pNextHandler;
            MoveHandler(pQueueMoveFrom,pHandlerToMove,&pNewHandlerId,&clockqueue);

            // now set the original queues head
            pQueueMoveFrom->m_pFirstHandler = HandlerInfoMoveFrom.pNextHandler;

            hr = S_OK;
        }
    }

    clockqueue.Leave();
    clockqueueMoveFrom.Leave();

    // now free any handlers that came into the queue that we
    // don't want to do anything with .

    ReleaseHandlers(HANDLERSTATE_TRANSFERRELEASE);

    return hr;
 }

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::SetQueueHwnd, public
//
//  Synopsis:   informs the queue os the new dialog owner if any
//              queue must also loop through existing proxies
//              and reset their hwnd.
//
//  Arguments:
//
//  Returns:    Appropriate return codes
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::SetQueueHwnd(CBaseDlg *pDlg)
{
    LPHANDLERINFO pCurHandlerInfo;
    CLock clockqueue(this);

    clockqueue.Enter();

    m_pDlg = pDlg;
    if (m_pDlg)
    {
        m_hwndDlg = m_pDlg->GetHwnd();
    }
    else
    {
        m_hwndDlg = NULL;
    }

    m_dwQueueThreadId = GetCurrentThreadId(); // make sure queu threadId is updated.

    pCurHandlerInfo = m_pFirstHandler;

    while (pCurHandlerInfo)
    {
        if (pCurHandlerInfo->pThreadProxy)
        {
            pCurHandlerInfo->pThreadProxy->SetProxyParams(m_hwndDlg
                                                            ,m_dwQueueThreadId
                                                            ,this
                                                            ,pCurHandlerInfo->pHandlerId);

        }

        pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }

    clockqueue.Leave();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::ReleaseCompletedHandlers, public
//
//  Synopsis:   Releases any Handlers that are in the Release or free
//              dead state from the queue.
//
//  Arguments:
//
//  Returns:    Appropriate return codes
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::ReleaseCompletedHandlers()
{
    return ReleaseHandlers(HANDLERSTATE_RELEASE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::FreeAllHandlers, public
//
//  Synopsis:   Releases all handlers from the queue.
//
//  Arguments:
//
//  Returns:    Appropriate return codes
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::FreeAllHandlers(void)
{
    return ReleaseHandlers(HANDLERSTATE_NEW); // release handlers in all states.
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::ReleaseHandlers, public
//
//  Synopsis:   Releases any Handlers are in a state >= the requested state
//
//  Arguments:  HandlerState - Frees all handlers that have a state >= the requested state.
//
//      !!Warning: This should be the only place the proxy if freed and
//          the handler is removed from the list.
//
//  Returns:    Appropriate return codes
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::ReleaseHandlers(HANDLERSTATE HandlerState)
{
    HANDLERINFO HandlerInfoStart;
    LPHANDLERINFO pPrevHandlerInfo = &HandlerInfoStart;
    LPHANDLERINFO pCurHandlerInfo = NULL;
    LPHANDLERINFO pHandlerFreeList = NULL;
    LPITEMLIST pCurItem = NULL;
    LPITEMLIST pNextItem = NULL;
    CLock clockqueue(this);

    ASSERT_LOCKNOTHELD(this); // shouldn't be any out calls in progress when this is called.

    clockqueue.Enter();

    m_fNumItemsCompleteNeedsARecalc = TRUE; // need to recalc next GetProgress.

    // loop through the handlers finding the one that match the criteria
    // removing them from list and adding them to the free list
    // we do this so don't have to worry about someone else accessing
    // handlers we are freeing during an out call.

    if (HANDLERSTATE_NEW == HandlerState)
    {
        // Release should only be called on this state if caller is sure no out
        // calls are in progress or else handler may not exist when
        // they come back
        pHandlerFreeList = m_pFirstHandler;
        m_pFirstHandler = NULL;
    }
    else
    {
        Assert(HandlerState >= HANDLERSTATE_RELEASE); // if in release no out calls are in progress.

        pPrevHandlerInfo->pNextHandler = m_pFirstHandler;

        while (pPrevHandlerInfo->pNextHandler)
        {
            pCurHandlerInfo = pPrevHandlerInfo->pNextHandler;

            // if meet handler state criteria and not in any out calls then can
            // remove from list.

            // if request for HANDLERSTATE_NEW then assert than there shouldn't be
            // any out calls in progress or terminating.
            Assert(!(HandlerState == HANDLERSTATE_NEW) || 
                    (0 == pCurHandlerInfo->dwOutCallMessages && !pCurHandlerInfo->fInTerminateCall));

            if ( (HandlerState <= pCurHandlerInfo->HandlerState)
                && (0 == pCurHandlerInfo->dwOutCallMessages) 
                && !(pCurHandlerInfo->fInTerminateCall))
            {
                Assert (HANDLERSTATE_RELEASE == pCurHandlerInfo->HandlerState  ||
                        HANDLERSTATE_TRANSFERRELEASE == pCurHandlerInfo->HandlerState ||
                        HANDLERSTATE_HASERRORJUMPS == pCurHandlerInfo->HandlerState ||
                        HANDLERSTATE_DEAD == pCurHandlerInfo->HandlerState);

                // remove from queue list and add to free.
                pPrevHandlerInfo->pNextHandler = pCurHandlerInfo->pNextHandler;

                pCurHandlerInfo->pNextHandler = pHandlerFreeList;
                pHandlerFreeList = pCurHandlerInfo;
            }
            else
            {
                // if no match then just continue.
                pPrevHandlerInfo = pCurHandlerInfo;
            }

        }

        // update the queue head.
        m_pFirstHandler = HandlerInfoStart.pNextHandler;
    }

    // now loop through the free list freeing the items.

    while (pHandlerFreeList)
    {
        pCurHandlerInfo = pHandlerFreeList;
        pHandlerFreeList = pHandlerFreeList->pNextHandler;


        // if the item has a job info release the reference on it.
        if (pCurHandlerInfo->pJobInfo)
        {
            ReleaseJobInfo(pCurHandlerInfo->pJobInfo);
            pCurHandlerInfo->pJobInfo = NULL;
        }


        if (pCurHandlerInfo->pThreadProxy)
        {
            CThreadMsgProxy *pThreadProxy = pCurHandlerInfo->pThreadProxy;
            HWND hwndCallback;

            Assert(HANDLERSTATE_DEAD != pCurHandlerInfo->HandlerState);

            pCurHandlerInfo->HandlerState = HANDLERSTATE_DEAD;
            pThreadProxy = pCurHandlerInfo->pThreadProxy;
            pCurHandlerInfo->pThreadProxy = NULL;

            hwndCallback = pCurHandlerInfo->hWndCallback;
            pCurHandlerInfo->hWndCallback = NULL;

            clockqueue.Leave(); // release lock when making the OutCall.
            pThreadProxy->Release(); // review, don't release proxy to try to catch race condition.

            clockqueue.Enter();
        }

        pCurItem = pCurHandlerInfo->pFirstItem;

        while (pCurItem)
        {
            pNextItem = pCurItem->pnextItem;
            FREE(pCurItem);
            pCurItem = pNextItem;
        }

        FREE(pCurHandlerInfo);
    }

    clockqueue.Leave();

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::GetHandlerInfo, public
//
//  Synopsis:   Gets Data associated with the HandlerID and ItemID
//
//  Arguments:  [clsidHandler] - ClsiId Of Handler the Item belongs too
//
//  Returns:    Appropriate return codes
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::GetHandlerInfo(REFCLSID clsidHandler, LPSYNCMGRHANDLERINFO pSyncMgrHandlerInfo)
{
    HRESULT hr = S_FALSE;
    LPHANDLERINFO pCurHandlerInfo = NULL;
    CLock clockqueue(this);

    clockqueue.Enter();

    // find first handler that matches the request CLSID
    pCurHandlerInfo = m_pFirstHandler;

    while (pCurHandlerInfo )
    {
        if (clsidHandler == pCurHandlerInfo->clsidHandler)
        {
            *pSyncMgrHandlerInfo = pCurHandlerInfo->SyncMgrHandlerInfo;
            hr = S_OK;
            break;
        }

        pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }

    clockqueue.Leave();

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::GetHandlerInfo, public
//
//  Synopsis:   Gets Data associated with the HandlerID and ItemID
//
//  Arguments:  [wHandlerId] - Id Of Handler the Item belongs too
//
//  Returns:    Appropriate return codes
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::GetHandlerInfo(HANDLERINFO *pHandlerId, LPSYNCMGRHANDLERINFO pSyncMgrHandlerInfo)
{
    HRESULT hr = S_FALSE;
    LPHANDLERINFO pHandlerInfo = NULL;
    CLock clockqueue(this);

    clockqueue.Enter();

    if (S_OK == LookupHandlerFromId(pHandlerId,&pHandlerInfo))
    {
        *pSyncMgrHandlerInfo = pHandlerInfo->SyncMgrHandlerInfo;
        hr = S_OK;
    }

    clockqueue.Leave();

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::GetItemDataAtIndex, public
//
//  Synopsis:   Gets Data associated with the HandlerID and ItemID
//
//  Arguments:  [wHandlerId] - Id Of Handler the Item belongs too
//              [wItemID] - Identifies the Item in the Handler
//              [pclsidHandler] - on return contains a pointer to the clsid of the Handler
//              [offlineItem] - on returns contains a pointer to the OfflineItem for the item.
//              [pfHiddenItem] - On return is a bool indicating if this item is hidden.
//
//  Returns:    Appropriate return codes
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::GetItemDataAtIndex(HANDLERINFO *pHandlerId,WORD wItemID,
                                CLSID *pclsidHandler,SYNCMGRITEM *offlineItem,BOOL *pfHiddenItem)

{
    BOOL fFoundMatch = FALSE;
    LPHANDLERINFO pCurHandlerInfo = NULL;
    LPITEMLIST pCurItem = NULL;
    CLock clockqueue(this);

    clockqueue.Enter();

    pCurHandlerInfo = m_pFirstHandler;

    while (pCurHandlerInfo && !fFoundMatch)
    {
        // only valid if Hanlder is in the PrepareForSync state.
        if (pHandlerId == pCurHandlerInfo->pHandlerId) // see if CLSID matches
        {
            // see if handler info has a matching item
            pCurItem = pCurHandlerInfo->pFirstItem;

            while (pCurItem)
            {
                if (wItemID == pCurItem->wItemId)
                {
                    fFoundMatch = TRUE;
                    break;
                }

                pCurItem = pCurItem->pnextItem;
            }
        }

        if (!fFoundMatch)
            pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }

    if (fFoundMatch)
    {
        if (pclsidHandler)
        {
            *pclsidHandler = pCurHandlerInfo->clsidHandler;
        }
        if (offlineItem)
        {
            *offlineItem = pCurItem->offlineItem;
        }
        if (pfHiddenItem)
        {
            *pfHiddenItem = pCurItem->fHiddenItem;
        }

    }

    clockqueue.Leave();

    return fFoundMatch ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::GetItemDataAtIndex, public
//
//  Synopsis:   Gets Data associated with the HandlerID and OfflineItemID
//
//  Arguments:  [wHandlerId] - Id Of Handler the Item belongs too
//              [ItemID] - identifies the Item by its OfflineItemID
//              [pclsidHandler] - on return contains a pointer to the clsid of the Handler
//              [offlineItem] - on returns contains a pointer to the OfflineItem for the item.
//              [pfHiddenItem] - On return is a bool indicating if this item is a hidden item.
//
//  Returns:    Appropriate return codes
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::GetItemDataAtIndex(HANDLERINFO *pHandlerId,REFSYNCMGRITEMID ItemID,CLSID *pclsidHandler,
                                            SYNCMGRITEM *offlineItem,BOOL *pfHiddenItem)
{
    BOOL fFoundMatch = FALSE;
    LPHANDLERINFO pCurHandlerInfo = NULL;
    LPITEMLIST pCurItem = NULL;
    CLock clockqueue(this);

    clockqueue.Enter();

    pCurHandlerInfo = m_pFirstHandler;

    while (pCurHandlerInfo && !fFoundMatch)
    {
        // only valid if handler is in the PrepareForSync state.
        if (pHandlerId == pCurHandlerInfo->pHandlerId) // see if CLSID matches
        {
            // see if handler info has a matching item
            pCurItem = pCurHandlerInfo->pFirstItem;

            while (pCurItem)
            {
                if (ItemID == pCurItem->offlineItem.ItemID)
                {
                    fFoundMatch = TRUE;
                    break;
                }

                pCurItem = pCurItem->pnextItem;
            }
        }

        if (!fFoundMatch)
            pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }

    if (fFoundMatch)
    {
        *pclsidHandler = pCurHandlerInfo->clsidHandler;
        *offlineItem = pCurItem->offlineItem;
        *pfHiddenItem = pCurItem->fHiddenItem;

    }

    clockqueue.Leave();

    return fFoundMatch ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::FindFirstItemInState, public
//
//  Synopsis:   Finds the first Item in the queue that matches the given state.
//
//  Arguments:  
//              [hndlrState]  - specifies matching state we are looking for.
//              [pwHandlerId] - on return contains the HandlerID of the Item
//              [pwItemID] - on returns contains the ItemID of the item in the queue.
//
//  Returns:    S_OK if an Item was found with an unassigned ListView.
//              S_FALSE - if no Item was found.
//              Appropriate error return codes
//
//  Modifies:
//
//  History:    30-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::FindFirstItemInState(HANDLERSTATE hndlrState,
				   HANDLERINFO **ppHandlerId,WORD *pwItemID)
{
    return FindNextItemInState(hndlrState,0,0,ppHandlerId,pwItemID);
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::FindNextItemInState, public
//
//  Synopsis:   Finds the first Item in the queue that matches the given state.
//              after the specified item.
//
//  Arguments:  
//              [hndlrState]  - specifies matching state we are looking for.
//              [pOfflineItemID] - on returns contains a pointer to the OfflineItem for the item.
//              [pwHandlerId] - on return contains the HandlerID of the Item
//              [pwItemID] - on returns contains the ItemID of the item in the queue.
//
//  Returns:    S_OK if an Item was found with an unassigned ListView.
//              S_FALSE - if no Item was found.
//              Appropriate error return codes
//
//  Modifies:
//
//  History:    30-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::FindNextItemInState(HANDLERSTATE hndlrState,
                                 HANDLERINFO *pLastHandlerId,WORD wLastItemID,
				 HANDLERINFO **ppHandlerId,WORD *pwItemID)
{
    BOOL fFoundMatch = FALSE;
    LPHANDLERINFO pCurHandlerInfo = NULL;
    LPITEMLIST pCurItem = NULL;
    CLock clockqueue(this);

    clockqueue.Enter();
    pCurHandlerInfo = m_pFirstHandler;

    if (pLastHandlerId)
    {
        // loop until find the specified handler or hit end of list.
        while(pCurHandlerInfo && pLastHandlerId != pCurHandlerInfo->pHandlerId)
        {
            pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
        }

        if (NULL == pCurHandlerInfo) // reached end of list without finding the Handler
        {
            Assert(0); // user must have passed an invalid start HandlerID.
            clockqueue.Leave();
            return S_FALSE;
        }

        // loop until find item or end of item list
        pCurItem = pCurHandlerInfo->pFirstItem;
        while (pCurItem && pCurItem->wItemId != wLastItemID)
        {
            pCurItem = pCurItem->pnextItem;
        }

        if (NULL == pCurItem) // reached end of item list without finding the specified item
        {
            Assert(0); // user must have passed an invalid start ItemID.
            clockqueue.Leave();
            return S_FALSE;
        }

        // now we found the Handler and item. loop through remaining items for this handler 
        // if it still has another item then just return that.
        pCurItem = pCurItem->pnextItem;
        
        if (pCurItem)
        {
            Assert(hndlrState == pCurHandlerInfo->HandlerState); // should only be called in PrepareForSyncState
            fFoundMatch = TRUE;
        }

        if (!fFoundMatch)
            pCurHandlerInfo = pCurHandlerInfo->pNextHandler; // increment to next handler if no match
    }

    if (!fFoundMatch)
    {
        // in didn't find a match in the 
        while (pCurHandlerInfo)
        {
            if ((hndlrState == pCurHandlerInfo->HandlerState) && (pCurHandlerInfo->pFirstItem) )
            {
                pCurItem = pCurHandlerInfo->pFirstItem;
                fFoundMatch = TRUE;
                break;
            }

            pCurHandlerInfo = pCurHandlerInfo->pNextHandler;        
        }
    }

    if (fFoundMatch)
    {
        *ppHandlerId = pCurHandlerInfo->pHandlerId;
        *pwItemID = pCurItem->wItemId;
    }

    clockqueue.Leave();

    return fFoundMatch ? S_OK : S_FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::SetItemState, public
//
//  Synopsis:  Set the Item state for the first item finds that it 
//              matches in the Queue. Sets all other matches to unchecked.
//
//  Arguments:  
//
//  Returns:   Appropriate error return codes
//
//  Modifies:
//
//  History:    30-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::SetItemState(REFCLSID clsidHandler,REFSYNCMGRITEMID ItemID,DWORD dwState)
{
    LPHANDLERINFO pCurHandlerInfo = NULL;
    LPITEMLIST pCurItem = NULL;
    BOOL fFoundMatch = FALSE;
    CLock clockqueue(this);

    if (QUEUETYPE_CHOICE != m_QueueType)
    {
        Assert(QUEUETYPE_CHOICE == m_QueueType);
        return E_UNEXPECTED;
    }

    clockqueue.Enter();

    pCurHandlerInfo = m_pFirstHandler;

    while (pCurHandlerInfo)
    {
        if (clsidHandler == pCurHandlerInfo->clsidHandler)
        {
            pCurItem = pCurHandlerInfo->pFirstItem;

            while (pCurItem)
            {
                if (ItemID == pCurItem->offlineItem.ItemID)
                {
                    // if the handlerstate is not prepareforsync or not first match then uncheck
                    if ((HANDLERSTATE_PREPAREFORSYNC != pCurHandlerInfo->HandlerState) || fFoundMatch)
                    {
                        pCurItem->offlineItem.dwItemState = SYNCMGRITEMSTATE_UNCHECKED;
                    }
                    else
                    {
                        pCurItem->offlineItem.dwItemState = dwState;
                        fFoundMatch = TRUE;
                    }
                }

                pCurItem = pCurItem->pnextItem;
            }
        }

        pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }

    clockqueue.Leave();

    Assert(fFoundMatch); // we should have found at least one match.

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::SkipItem, public
//
//  Synopsis:   loop through handler and mark the items appropriately that match..
//
//  Arguments:  [iItem] - List View Item to skip.
//
//  Returns:   Appropriate return codes.
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::SkipItem(REFCLSID clsidHandler,REFSYNCMGRITEMID ItemID)
{
    LPHANDLERINFO pCurHandlerInfo = NULL;
    LPITEMLIST pCurItem = NULL;
    CLock clockqueue(this);
    HRESULT hr = S_OK;

    if (QUEUETYPE_PROGRESS != m_QueueType)
    {
        Assert(QUEUETYPE_PROGRESS == m_QueueType);
        return E_UNEXPECTED;
    }

    clockqueue.Enter();

    pCurHandlerInfo = m_pFirstHandler;

    while (pCurHandlerInfo )
    {
        if (clsidHandler == pCurHandlerInfo->clsidHandler)
        {       
            pCurItem = pCurHandlerInfo->pFirstItem;

            while (pCurItem)
            {
                // if item is cancelled then also treat as a match to
                // handle case cancel came in while in an out call.
                if ( ItemID == pCurItem->offlineItem.ItemID)
                {
                    // found an item, now if it hasn't started the sync or
                    // is not already complete set the value.

                    if ((pCurHandlerInfo->HandlerState < HANDLERSTATE_RELEASE) )
                    {
                        pCurItem->fItemCancelled = TRUE;

                        // If haven't called PrepareforSync yet then
                        // set uncheck the item so it isn't passed to PrepareForSync
                        // If PrepareForSync has already been called, call the items
                        // SkipMethod. if already in a setItemstatus call for this handler don't
                        // do anything.

                        // if not in another setitemstatus call loop through freeing all
                        // the items that have the cancel set.

                        // essentially a dup of cance and also handle case cancel
                        // comes win while this handler is in an out call.

                        if (!(pCurHandlerInfo->dwOutCallMessages & ThreadMsg_SetItemStatus))
                        {
                            pCurHandlerInfo->dwOutCallMessages |= ThreadMsg_SetItemStatus;

                            if (pCurHandlerInfo->HandlerState >= HANDLERSTATE_INPREPAREFORSYNC
                                        && pCurItem->fSynchronizingItem )
                            {
                                CThreadMsgProxy *pThreadProxy;
                                SYNCMGRITEMID ItemId;

                                pThreadProxy = pCurHandlerInfo->pThreadProxy;
                                ItemId = pCurItem->offlineItem.ItemID;
                                clockqueue.Leave();

                                if (pThreadProxy)
                                {
                                    hr = pThreadProxy->SetItemStatus(ItemId, SYNCMGRSTATUS_SKIPPED);
                                }

                                clockqueue.Enter();
                            }
                            else 
                            {
                                // once done skipping handler if state is <= preparefor sync we set the state accordingly.
                                // if were syncing up to handler.
                                if ( (pCurHandlerInfo->HandlerState <= HANDLERSTATE_PREPAREFORSYNC)
                                        && (pCurItem->fIncludeInProgressBar) )
                                {
                                    SYNCMGRPROGRESSITEM SyncProgressItem;

                                    // unheck the state so PrepareForsync doesn't include
                                    // this item.
                                    pCurItem->offlineItem.dwItemState = SYNCMGRITEMSTATE_UNCHECKED;

                                    SyncProgressItem.cbSize = sizeof(SYNCMGRPROGRESSITEM);
                                    SyncProgressItem.mask = SYNCMGRPROGRESSITEM_PROGVALUE | SYNCMGRPROGRESSITEM_MAXVALUE | SYNCMGRPROGRESSITEM_STATUSTYPE;
                                    SyncProgressItem.iProgValue = HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE;
                                    SyncProgressItem.iMaxValue = HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE;
                                    SyncProgressItem.dwStatusType = SYNCMGRSTATUS_SKIPPED;

                                    // need to setup HwndCallback so progres gets updated. 
                                    // review, after ship why can't setup HwndCallback on transferqueueu
                                    pCurHandlerInfo->hWndCallback = m_hwndDlg;

                                    clockqueue.Leave();

                                    Progress(pCurHandlerInfo->pHandlerId, pCurItem->offlineItem.ItemID,&SyncProgressItem);

                                    clockqueue.Enter();
                                }
                            }

                            pCurHandlerInfo->dwOutCallMessages &= ~ThreadMsg_SetItemStatus;
                        }
                    }
                }

                pCurItem = pCurItem->pnextItem;
            }
        }

        pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }

    clockqueue.Leave();

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::ItemHasProperties, public
//
//  Synopsis:  determines if the item in the queue has properties.
//              Uses the first item match it finds.
//
//  Arguments:  
//
//  Returns:   Appropriate error return codes
//
//  Modifies:
//
//  History:    30-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::ItemHasProperties(REFCLSID clsidHandler,REFSYNCMGRITEMID ItemID)
{
    LPHANDLERINFO pHandlerInfo;
    LPITEMLIST pItem;
    HRESULT hr = S_FALSE;
    CLock clockqueue(this);

    Assert(QUEUETYPE_CHOICE == m_QueueType);
    ASSERT_LOCKNOTHELD(this);

    clockqueue.Enter();

    // item is guidNULL this is toplevel so use the getHandlerInfo, else see
    // if the item supports showProperties.

    if (S_OK == FindItemData(clsidHandler,ItemID,
            HANDLERSTATE_PREPAREFORSYNC,HANDLERSTATE_PREPAREFORSYNC,&pHandlerInfo,&pItem))
    {
        if (GUID_NULL == ItemID)
        {
             Assert(NULL == pItem);

             hr = ((pHandlerInfo->SyncMgrHandlerInfo).SyncMgrHandlerFlags  & SYNCMGRHANDLER_HASPROPERTIES) ? S_OK : S_FALSE;
        }
        else
        {
            Assert(pItem);
            
            if (pItem)
            {
                hr = (pItem->offlineItem).dwFlags & SYNCMGRITEM_HASPROPERTIES ? S_OK : S_FALSE;
            }
            else
            {
                hr = S_FALSE;
            }
        }
    }

    clockqueue.Leave();

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::ShowProperties, public
//
//  Synopsis:  Calls the ShowProperties Method on the first items it finds.
//              Uses the first item match it finds.
//
//  Arguments:  
//
//  Returns:   Appropriate error return codes
//
//  Modifies:
//
//  History:    30-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::ShowProperties(REFCLSID clsidHandler,REFSYNCMGRITEMID ItemID,HWND hwndParent)
{
    LPHANDLERINFO pHandlerInfo;
    LPHANDLERINFO  pHandlerId = NULL;
    LPITEMLIST pItem;
    HRESULT hr = E_UNEXPECTED;
    BOOL fHandlerCalled = FALSE;
    BOOL fHasProperties = FALSE;
    CThreadMsgProxy *pThreadProxy;
    CLock clockqueue(this);

    Assert(QUEUETYPE_CHOICE == m_QueueType);
    ASSERT_LOCKNOTHELD(this);

    clockqueue.Enter();

    if (S_OK == FindItemData(clsidHandler,ItemID,
            HANDLERSTATE_PREPAREFORSYNC,HANDLERSTATE_PREPAREFORSYNC,&pHandlerInfo,&pItem))
    {
        Assert(HANDLERSTATE_PREPAREFORSYNC == pHandlerInfo->HandlerState);

        pThreadProxy = pHandlerInfo->pThreadProxy;
        pHandlerId = pHandlerInfo->pHandlerId;

        Assert(!(ThreadMsg_ShowProperties & pHandlerInfo->dwOutCallMessages));
        pHandlerInfo->dwOutCallMessages |= ThreadMsg_ShowProperties;

        if (GUID_NULL == ItemID && pHandlerInfo)
        {
            Assert(NULL == pItem);

            fHasProperties = (pHandlerInfo->SyncMgrHandlerInfo).SyncMgrHandlerFlags 
                    & SYNCMGRHANDLER_HASPROPERTIES ? TRUE : FALSE;
        }
        else if (pItem)
        {
            Assert(SYNCMGRITEM_HASPROPERTIES & pItem->offlineItem.dwFlags);
            fHasProperties = (pItem->offlineItem).dwFlags 
                        & SYNCMGRITEM_HASPROPERTIES ? TRUE : FALSE;
        }
        else
        {
            fHasProperties = FALSE;
        }
        
        clockqueue.Leave();

        // make sure properties flag isn't set.
        if (fHasProperties && pThreadProxy )
        {
            fHandlerCalled = TRUE;
            hr =  pThreadProxy->ShowProperties(hwndParent,ItemID);
        }
        else
        {
            AssertSz(0,"ShowProperties called on an Item without properties");
            hr = S_FALSE;
        }

        Assert(pHandlerId);

        if ( (fHandlerCalled && (FAILED(hr))) || (!fHandlerCalled) )
        {
            GUID guidCompletion = ItemID;
            
            CallCompletionRoutine(pHandlerId,ThreadMsg_ShowProperties,hr,1,&guidCompletion);

            // since called completion routine map anything but S_OK to S_FALSE;
            // so caller doesn't wait for the callback.

            if (S_OK != hr)
            {
                hr = S_FALSE;
            }
       }
    }
    else
    {
        Assert(FAILED(hr)); // should return some failure so caller knows callback isn't coming.
        clockqueue.Leave();
    }

   return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::ReEnumHandlerItems, public
//
//  Synopsis:  Deletes any Items associated with any handlers that
//              match the clsid of the handler and then
//              call the first handlers in the list enumeration method
//              again.
//
//  Arguments:  
//
//  Returns:   Appropriate error return codes
//
//  Modifies:
//
//  History:    30-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::ReEnumHandlerItems(REFCLSID clsidHandler,REFSYNCMGRITEMID ItemID)
{
    LPHANDLERINFO pCurHandlerInfo = NULL;
    HANDLERINFO *pHandlerId = NULL;
    LPITEMLIST pCurItem = NULL;
    CLock clockqueue(this);

    if (QUEUETYPE_CHOICE != m_QueueType)
    {
        Assert(QUEUETYPE_CHOICE == m_QueueType);
        return E_UNEXPECTED;
    }

    clockqueue.Enter();

    pCurHandlerInfo = m_pFirstHandler;

    while (pCurHandlerInfo)
    {
        if (clsidHandler == pCurHandlerInfo->clsidHandler)
        {
            LPITEMLIST pNextItem;

            // if first handler we found update the handlerID
            if (pHandlerId)
            {
                pHandlerId = pCurHandlerInfo->pHandlerId;
                pCurHandlerInfo->HandlerState = HANDLERSTATE_ADDHANDLERTEMS; // put back to addhandlerItems statest
            }

            pCurHandlerInfo->wItemCount = 0;

            pCurItem = pCurHandlerInfo->pFirstItem;

            while (pCurItem)
            {
                pNextItem = pCurItem->pnextItem;
                FREE(pCurItem);
                pCurItem = pNextItem;
            }

             pCurHandlerInfo->pFirstItem = NULL;
        }

        pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }

    clockqueue.Leave();

    // if have a handler id add them back to the queue
    if (pHandlerId)
    {
        DWORD cbNumItemsAdded;

        AddHandlerItemsToQueue(pHandlerId,&cbNumItemsAdded);
    }

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::IsItemCompleted, private
//
//  Synopsis:   Given an handler item determines if its
//              synchronization is completed
//
//              !!!This is not efficient. n! solution. If get
//              a lot of items may need to have to rewrite
//              and cache some information concerning dup
//              items.
//
//  Arguments:  [wHandlerId] - Handler the item belongs too.
//              [wItemID] - Identifies the Item
//
//  Returns:    
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CHndlrQueue::IsItemCompleted(LPHANDLERINFO pHandler,LPITEMLIST pItem)
{
    CLSID clsidHandler;
    SYNCMGRITEMID ItemId;
    int iItemNotComplete = 0;

    Assert(pHandler);
    Assert(pItem);

    ASSERT_LOCKHELD(this); // caller of this function should have already locked the queue.

    clsidHandler = pHandler->clsidHandler;
    ItemId = pItem->offlineItem.ItemID;

    // back up to beginning of handler to simplify logic
    // items must be pCurItem->fIncludeInProgressBar && !pCurItem->fProgressBarHandled
    // to count toward not being a completion;

    while (pHandler)
    {
        if (pHandler->clsidHandler == clsidHandler)
        {
            // see if handler info has a matching item
            pItem = pHandler->pFirstItem;

            while (pItem)
            {
                if (pItem->offlineItem.ItemID == ItemId)
                {
                    if (pItem->fIncludeInProgressBar && !pItem->fProgressBarHandled)
                    {
                        if (pItem->iProgValue < pItem->iProgMaxValue)
                        {
                            ++iItemNotComplete;
                        }

                        pItem->fProgressBarHandled = TRUE;
                    }
                }

                pItem = pItem->pnextItem;
            }
        }

        pHandler = pHandler->pNextHandler;
    }

    return iItemNotComplete ? FALSE : TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::SetItemProgressInfo, public
//
//  Synopsis:   Updates the stored progress information for the
//              Associated Items
//
//  Arguments:  [wHandlerId] - Handler the item belongs too.
//              [wItemID] - Identifies the Item
//              [pSyncProgressItem] - Pointer to Progress Information.
//              [pfProgressChanged] - returns true if any progress values were changed
//                      for the item
//
//  Returns:    S_OK - at least one item with the iItem assigned was found
//              S_FALSE - Item does not have properties.
//              Appropriate error return codes
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::SetItemProgressInfo(HANDLERINFO *pHandlerId,WORD wItemID,
                                                LPSYNCMGRPROGRESSITEM pSyncProgressItem,
                                                 BOOL *pfProgressChanged)
{
    HRESULT hr = E_UNEXPECTED;
    LPHANDLERINFO pHandlerInfo = NULL;
    BOOL fFoundMatch = FALSE;
    LPITEMLIST pCurItem = NULL;
    CLock clockqueue(this);

    Assert(pfProgressChanged);

    *pfProgressChanged = FALSE;

    if (QUEUETYPE_PROGRESS != m_QueueType)
    {
        Assert(QUEUETYPE_PROGRESS == m_QueueType);
        return E_UNEXPECTED; // review error code.
    }

    clockqueue.Enter();

    if (S_OK == LookupHandlerFromId(pHandlerId,&pHandlerInfo))
    {
        // try to find the matching item.
        pCurItem = pHandlerInfo->pFirstItem;

        while (pCurItem)
        {
            if (wItemID == pCurItem->wItemId)
            {
                fFoundMatch = TRUE;
                break;
            }

            pCurItem = pCurItem->pnextItem;
        }
    }

    if (fFoundMatch)
    {
        SetItemProgressInfo(pCurItem,pSyncProgressItem,pfProgressChanged);
    }

    clockqueue.Leave();

    return fFoundMatch ? S_OK : S_FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::SetItemProgressInfo, private
//
//  Synopsis:   Updates the stored progress information for the
//              Associated iTEM
//
//  Arguments:  [pItem] - Identifies the Item
//              [pSyncProgressItem] - Pointer to Progress Information.
//              [pfProgressChanged] - returns true if any progress values were changed
//                      for the item
//
//  Returns:    S_OK - at least one item with the iItem assigned was found
//              Appropriate error return codes
//
//              !!Caller must have already taken a lock.
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::SetItemProgressInfo(LPITEMLIST pItem,LPSYNCMGRPROGRESSITEM pSyncProgressItem,
                                        BOOL *pfProgressChanged)
{
    BOOL fProgressAlreadyCompleted;

    ASSERT_LOCKHELD(this); // caller of this function should have already locked the queue.

    // progress is considered complete if Values is >= Maxa
    fProgressAlreadyCompleted = (pItem->iProgMaxValue <= pItem->iProgValue);

    if (SYNCMGRPROGRESSITEM_MAXVALUE & pSyncProgressItem->mask)
    {
        // if Progress Max Value is negative then don't set.
        if (pSyncProgressItem->iMaxValue >= 0)
        {
            if (pItem->iProgMaxValue != pSyncProgressItem->iMaxValue)
            {
                *pfProgressChanged = TRUE;
                pItem->fProgValueDirty = TRUE;
                pItem->iProgMaxValue = pSyncProgressItem->iMaxValue;
            }
        }
    }

    if (SYNCMGRPROGRESSITEM_PROGVALUE & pSyncProgressItem->mask)
    {
        // if progress value is negative, don't change it
        if (pSyncProgressItem->iProgValue > 0)
        {
            if (pItem->iProgValue != pSyncProgressItem->iProgValue)
            {
                *pfProgressChanged = TRUE;
                pItem->fProgValueDirty = TRUE;
                pItem->iProgValue = pSyncProgressItem->iProgValue;
            }
        }
    }

    if (SYNCMGRPROGRESSITEM_STATUSTYPE & pSyncProgressItem->mask)
    {
        if (pItem->dwStatusType != pSyncProgressItem->dwStatusType)
        {
            *pfProgressChanged = TRUE;
            pItem->dwStatusType = pSyncProgressItem->dwStatusType;

            // if status is complete set the progvalue == to the max
            // on behalf of the handler so the Items completed and progress bar
            // gets updated.
            if (pItem->dwStatusType == SYNCMGRSTATUS_SKIPPED
                || pItem->dwStatusType == SYNCMGRSTATUS_SUCCEEDED
                || pItem->dwStatusType == SYNCMGRSTATUS_FAILED )
            {
                pItem->fProgValueDirty = TRUE;
                pItem->iProgValue = pItem->iProgMaxValue;
            }
        }
    }

    // if progressValue is > max then set it to max

    if (pItem->iProgValue > pItem->iProgMaxValue)
    {
        // AssertSz(0,"Progress Value is > Max");
        pItem->iProgValue = pItem->iProgMaxValue;
    }

    // see if need to recalc numItems completed next time
    // GetProgressInfo is Called.
    BOOL fProgressCompletedNow = (pItem->iProgMaxValue <= pItem->iProgValue);

    if (fProgressAlreadyCompleted != fProgressCompletedNow)
    {
        m_fNumItemsCompleteNeedsARecalc = TRUE;
    }

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::SetItemProgressValues, private
//
//  Synopsis:   Private helper function for updating/initializing
//              an items progress bar values. 
//
//  Arguments:  [pItem] - Identifies the Item
//              [pSyncProgressItem] - Pointer to Progress Information.
//              [pfProgressChanged] - returns true if any progress values were changed
//                      for the item
//
//  Returns:    S_OK - at least one item with the iItem assigned was found
//              Appropriate error return codes
//
//              !!Caller must have already taken a lock.
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::SetItemProgressValues(LPITEMLIST pItem,INT iProgValue,INT iProgMaxValue)
{
    SYNCMGRPROGRESSITEM SyncProgressItem;
    BOOL fProgressChanged;

    ASSERT_LOCKHELD(this); // caller of this function should have already locked the queue.

    SyncProgressItem.cbSize = sizeof(SYNCMGRPROGRESSITEM);
    SyncProgressItem.mask = SYNCMGRPROGRESSITEM_PROGVALUE | SYNCMGRPROGRESSITEM_MAXVALUE;
    SyncProgressItem.iProgValue = iProgValue;
    SyncProgressItem.iMaxValue = iProgMaxValue;

    return SetItemProgressInfo(pItem,&SyncProgressItem,&fProgressChanged);
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::GetProgressInfo, public
//
//  Synopsis:    calculates current progress bar values and number of items complete.
//
//  Arguments:  [piProgValue] - on return contains the new Progress Bar Value.
//              [piMaxValue] - on return contains the Progress Bar Max Value
//              [piNumItemsComplete] - on returns contains number of items complete.
//              [iNumItemsTotal] - on returns contains number of total items.
//
//  Returns:    Appropriate error codes
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::GetProgressInfo(INT *piProgValue,INT *piMaxValue,INT *piNumItemsComplete,
                                            INT *piNumItemsTotal)
{
    LPHANDLERINFO pCurHandlerInfo = NULL;
    LPITEMLIST pCurItem = NULL;
    INT iCurValue;
    BOOL fNormalizedValueChanged = FALSE;
    CLock clockqueue(this);

    if (QUEUETYPE_PROGRESS != m_QueueType)
    {
        Assert(QUEUETYPE_PROGRESS == m_QueueType);
        return E_UNEXPECTED; // review error code.
    }

    clockqueue.Enter();

     // if m_fNumItemsCompleteNeedsARecalc is set need 
    // to recalc normalized and numItems Comlete and Total Items.

    if (m_fNumItemsCompleteNeedsARecalc)
    {
        INT iNormalizedMax;

        m_ulProgressItemCount = 0;

        // get the number of selected items in the queue.
        pCurHandlerInfo = m_pFirstHandler;

        while (pCurHandlerInfo)
        {
            // see if handler info has a matching item
            pCurItem = pCurHandlerInfo->pFirstItem;

            while (pCurItem)
            {
                if (pCurItem->fIncludeInProgressBar)
                {
                     //if this item should be included in the progress, increment the progress bar count.
                      ++m_ulProgressItemCount;

                      pCurItem->fProgressBarHandled = FALSE; // reset handled 
                }

                pCurItem = pCurItem->pnextItem;
            }

            pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
        }

        if (0 == m_ulProgressItemCount)
        {
            iNormalizedMax = 0;
        }
        else
        {
            iNormalizedMax = MAXPROGRESSVALUE/m_ulProgressItemCount;

            if (0 == iNormalizedMax)
            {
                iNormalizedMax = 1;
            }
        }

        if (m_iNormalizedMax != iNormalizedMax)
        {
            fNormalizedValueChanged = TRUE;
            m_iNormalizedMax = iNormalizedMax;
        }
    }

    // now loop thruogh again getting total CurValue and finished items
    // we say an item is finished if it is out of the synchronize method or the min==max.

    pCurHandlerInfo = m_pFirstHandler;
    iCurValue = 0;

    // if numitemcount needs updated reset the member vars
    if (m_fNumItemsCompleteNeedsARecalc)
    {
        m_iCompletedItems = 0;
        m_iItemCount = 0;
    }
        
    while (pCurHandlerInfo)
    {
        // see if handler info has a matching item
        pCurItem = pCurHandlerInfo->pFirstItem;

        while (pCurItem)
        {
            if (pCurItem->fIncludeInProgressBar)
            {
                // if Progress is dirty or normalized value changed
                // need to recalc this items progress value

                if (pCurItem->fProgValueDirty || fNormalizedValueChanged)
                {
                    int iProgValue = pCurItem->iProgValue;
                    int iProgMaxValue = pCurItem->iProgMaxValue;
                
                    if (iProgValue && iProgMaxValue)
                    {
                        pCurItem->iProgValueNormalized =  (int) ((1.0*iProgValue*m_iNormalizedMax)/iProgMaxValue);
                    }
                    else
                    {
                        pCurItem->iProgValueNormalized = 0;
                    }

                    pCurItem->fProgValueDirty = FALSE;
                }

                iCurValue += pCurItem->iProgValueNormalized;

                // Handle NumItems needing to be recalc'd
                if (m_fNumItemsCompleteNeedsARecalc && !pCurItem->fProgressBarHandled)
                {
                    ++m_iItemCount;
            
                    // now loop through this item and  remaining items and if any match
                    // mark as handled and if complete then incrment the compleated count;
                    if (IsItemCompleted(pCurHandlerInfo,pCurItem))
                    {
                        ++m_iCompletedItems;
                    }
                }
            }

            pCurItem = pCurItem->pnextItem;
        }

        pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }

    m_fNumItemsCompleteNeedsARecalc = FALSE; 

    *piProgValue = iCurValue;
    *piMaxValue = m_iNormalizedMax*m_ulProgressItemCount;
    
    *piNumItemsComplete = m_iCompletedItems;
    *piNumItemsTotal = m_iItemCount;

    Assert(*piProgValue <= *piMaxValue);

    clockqueue.Leave();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::RemoveFinishedProgressItems, public
//
//  Synopsis:   Loops through handler setting any finished items
//              fIncludeInProgressBar value to false
//
//  Arguments:
//
//  Returns:   Appropriate return codes.
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::RemoveFinishedProgressItems()
{
    LPHANDLERINFO pCurHandlerInfo = NULL;
    LPITEMLIST pCurItem = NULL;
    CLock clockqueue(this);

    clockqueue.Enter();

    m_fNumItemsCompleteNeedsARecalc = TRUE;

    pCurHandlerInfo = m_pFirstHandler;

    while (pCurHandlerInfo)
    {
        // mark any items that have completed their synchronization.
        if (HANDLERSTATE_INSYNCHRONIZE < pCurHandlerInfo->HandlerState)
        {
            // see if handler info has a matching item
            pCurItem = pCurHandlerInfo->pFirstItem;

            while (pCurItem)
            {
                pCurItem->fIncludeInProgressBar = FALSE;
                pCurItem = pCurItem->pnextItem;
            }

        }

        pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }

    clockqueue.Leave();

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::AreAnyItemsSelectedInQueue, public
//
//  Synopsis:   Determines if there are any items selected in the queue.
//              can be called by choice dialog for example before creating
//              progress and doing a transfer since there is no need to
//              if nothing to sync anyways.
//
//  Arguments:
//
//  Returns:   TRUE - At least one item is selected inthe queue
//             FALSE - No Items are slected in the queue.
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CHndlrQueue::AreAnyItemsSelectedInQueue()
{
    LPHANDLERINFO pCurHandlerInfo = NULL;
    LPITEMLIST pCurItem = NULL;
    BOOL fFoundSelectedItem = FALSE;
    CLock clockqueue(this);

    clockqueue.Enter();

    // invalidate UI that applies to entire queue
    pCurHandlerInfo = m_pFirstHandler;

    while (pCurHandlerInfo && !fFoundSelectedItem)
    {
        // if handler state is less than a completion go ahead and
        // check the items.
        if (HANDLERSTATE_HASERRORJUMPS > pCurHandlerInfo->HandlerState)
        {
            pCurItem = pCurHandlerInfo->pFirstItem;

            while (pCurItem)
            {
                // clear Item UI information
                if (pCurItem->offlineItem.dwItemState == SYNCMGRITEMSTATE_CHECKED)
                {
                    fFoundSelectedItem = TRUE;
                    break;
                }

                pCurItem = pCurItem->pnextItem;
            }
        }

        pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }

    clockqueue.Leave();

    return fFoundSelectedItem;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::PersistChoices, public
//
//  Synopsis:   Saves Selected Users choices for the next time
//              the choice dialog is brought up. Only should
//              be called from a choice queue.
//
//  Arguments:
//
//  Returns:   Appropriate return codes.
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::PersistChoices(void)
{
    LPHANDLERINFO pCurHandlerInfo = NULL;
    LPITEMLIST pCurItem = NULL;
    CLock clockqueue(this);

    if (QUEUETYPE_CHOICE != m_QueueType)
    {
        Assert(QUEUETYPE_CHOICE == m_QueueType);
        return S_FALSE;
    }

    ASSERT_LOCKNOTHELD(this);
    clockqueue.Enter();

    // currently only persist on a manual invoke since user
    // has to go to settings to change other invoke types and
    // that is persisted

    // since this is the choice queue we know all handlers have the
    // same JobID. if this ever changes, have to set on a case by
    // case basis.

    if (m_pFirstJobInfo && m_pFirstJobInfo->pConnectionObj &&
            (SYNCMGRFLAG_MANUAL == (m_pFirstJobInfo->dwSyncFlags & SYNCMGRFLAG_EVENTMASK)) )
    {
        TCHAR *pszConnectionName = m_pFirstJobInfo->pConnectionObj[0]->pwszConnectionName;
        DWORD dwSyncFlags = m_pFirstJobInfo->dwSyncFlags;

        Assert(1 == m_pFirstJobInfo->cbNumConnectionObjs); // assert manual only ever has one connectionObj

        // delete all previously stored preferences.
        // this is valid because only called from choice queue that all ConnectionNames are the same.
        
        if (!m_fItemsMissing)
        {
            RegRemoveManualSyncSettings(pszConnectionName);
        }

        pCurHandlerInfo = m_pFirstHandler;

        while (pCurHandlerInfo)
        {
            // only save if Handler is in the PrepareForSync state.
            // bug, need to make sure return code from enum wasn't missing items
            if (HANDLERSTATE_PREPAREFORSYNC == pCurHandlerInfo->HandlerState )
            {
                // save out these items.
                pCurItem = pCurHandlerInfo->pFirstItem;

                while (pCurItem)
                {
                    if (!pCurItem->fDuplicateItem)
                    {
                        switch(dwSyncFlags & SYNCMGRFLAG_EVENTMASK)
                        {
                        case SYNCMGRFLAG_MANUAL:
                            RegSetSyncItemSettings(SYNCTYPE_MANUAL,
                                                pCurHandlerInfo->clsidHandler,
                                                pCurItem->offlineItem.ItemID,
                                                pszConnectionName,
                                                pCurItem->offlineItem.dwItemState,
                                                NULL);
                            break;
                        default:
                            AssertSz(0,"UnknownSyncFlag Event");
                            break;
                        };
                    }

                    pCurItem = pCurItem->pnextItem;
                }
            }

            pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
        }
    }

    clockqueue.Leave();

    return S_OK;
}



//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::FindFirstHandlerInState, public
//
//  Synopsis:   Finds the first Handler that matches the specified
//              state in the queue.
//
//  Arguments:  [hndlrState] - Requested handler state.
//              [pwHandlerID] - on success filled with HandlerID that was found
//
//  Returns:    Appropriate return codes.
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::FindFirstHandlerInState(HANDLERSTATE hndlrState, REFCLSID clsidHandler,
                                                    HANDLERINFO **ppHandlerId,CLSID *pMatchHandlerClsid)
{
    return FindNextHandlerInState(0, clsidHandler,hndlrState, ppHandlerId, pMatchHandlerClsid);
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::FindNextHandlerInState, public
//
//  Synopsis:   Finds next handler after LastHandlerID in the queue that matches
//              the requested state. Passing in 0 for the LastHandlerID is the same
//              as calling FindFirstHandlerInState
//
//              if GUID_NULL is passed in for the clsidHandler the first handler that
//              matches the specified state is returned.
//
//  Arguments:  [wLastHandlerID] - Id of last handler found.
//              [clsidHandler] - specific handler classid is requested, only find matches with this clsid
//              [hndlrState] - Requested handler state.
//              [pwHandlerID] - on success filled with HandlerID that was found
//              [pMatchHandlerClsid] - on sucdess clsid of handler found.
//
//  Returns:    Appropriate return codes.
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::FindNextHandlerInState(HANDLERINFO *pLastHandlerID,REFCLSID clsidHandler,
                                        HANDLERSTATE hndlrState,HANDLERINFO **ppHandlerID,CLSID *pMatchHandlerClsid)
{
    HRESULT hr = S_FALSE;
    LPHANDLERINFO pCurHandler;
    CLock clockqueue(this);

    *ppHandlerID = 0;

    clockqueue.Enter();

    pCurHandler = m_pFirstHandler;

    if (pLastHandlerID)
    {
        // loop foward until find the last handlerID we checked or hit the end
        while (pCurHandler)
        {
            if (pLastHandlerID == pCurHandler->pHandlerId)
            {
                break;
            }

            pCurHandler = pCurHandler->pNextHandler;
        }

        if (pCurHandler)
        {
            pCurHandler = pCurHandler->pNextHandler; // increment to next handler.
        }
    }

    while (pCurHandler)
    {
        if ( (hndlrState == pCurHandler->HandlerState)
               && ((GUID_NULL == clsidHandler) || (clsidHandler ==  pCurHandler->clsidHandler)) )
        {
            *ppHandlerID = pCurHandler->pHandlerId;
            *pMatchHandlerClsid = pCurHandler->clsidHandler;
            hr = S_OK;
            break;
        }

        pCurHandler = pCurHandler->pNextHandler;
    }

    clockqueue.Leave();
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::CreateServer, public
//
//  Synopsis:   Creates a new proxy then calls proxy to create and instance of the
//              specified handler.
//
//  Arguments:  [wHandlerId] - Id of handler to call.
//              [pCLSIDServer] - CLSID of Handler to Create.
//
//  Returns:    Appropriate return codes.
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::CreateServer(HANDLERINFO *pHandlerId, const CLSID *pCLSIDServer)
{
    HRESULT hr = E_UNEXPECTED;
    LPHANDLERINFO pHandlerInfo = NULL;
    CLock clockqueue(this);

    ASSERT_LOCKNOTHELD(this);
    clockqueue.Enter();

    if (S_OK == LookupHandlerFromId(pHandlerId,&pHandlerInfo))
    {
        Assert(HANDLERSTATE_CREATE == pHandlerInfo->HandlerState);

        Assert(0 == pHandlerInfo->dwCallNestCount);
        pHandlerInfo->dwCallNestCount++;

        if (HANDLERSTATE_CREATE == pHandlerInfo->HandlerState)
        {
            pHandlerInfo->HandlerState = HANDLERSTATE_INCREATE;
            Assert(NULL == pHandlerInfo->pThreadProxy);

            // see if there is already a thread for this handler's
            // CLSID.

            hr =  CreateHandlerThread(&(pHandlerInfo->pThreadProxy), m_hwndDlg, *pCLSIDServer);

            if (S_OK == hr)
            {
                HANDLERINFO *pHandlerIdArg;
                CThreadMsgProxy *pThreadProxy;

                pHandlerIdArg = pHandlerInfo->pHandlerId;
                pThreadProxy = pHandlerInfo->pThreadProxy;

                clockqueue.Leave();

                hr = pThreadProxy->CreateServer(pCLSIDServer,this,pHandlerIdArg);

                clockqueue.Enter();

                pHandlerInfo->pThreadProxy = pThreadProxy;
            }

            if (S_OK == hr)
            {
                pHandlerInfo->clsidHandler = *pCLSIDServer;
                pHandlerInfo->HandlerState = HANDLERSTATE_INITIALIZE;
            }
            else
            {
                pHandlerInfo->HandlerState = HANDLERSTATE_RELEASE;
            }
        }

        pHandlerInfo->dwCallNestCount--;
    }

    clockqueue.Leave();
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::Initialize, public
//
//  Synopsis:   Calls Hanlder's Initialize method
//
//  Arguments:  [wHandlerId] - Id of handler to call.
//              [dwReserved] - Initialize reserved parameter
//              [dwSyncFlags] - Sync flags
//              [cbCookie] - size of cookie data
//              [lpCookie] - ptr to cookie data
//
//  Returns:    Appropriate return codes.
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::Initialize(HANDLERINFO *pHandlerId,DWORD dwReserved,DWORD dwSyncFlags,
                    DWORD cbCookie,const BYTE *lpCooke)
{
    HRESULT hr = E_UNEXPECTED;
    LPHANDLERINFO pHandlerInfo = NULL;
    CLock clockqueue(this);

    ASSERT_LOCKNOTHELD(this);
    clockqueue.Enter();

    if (S_OK == LookupHandlerFromId(pHandlerId, &pHandlerInfo))
    {
        Assert(HANDLERSTATE_INITIALIZE == pHandlerInfo->HandlerState);
        Assert(pHandlerInfo->pThreadProxy);

        Assert(0 == pHandlerInfo->dwCallNestCount);
        pHandlerInfo->dwCallNestCount++;

        if ( (HANDLERSTATE_INITIALIZE == pHandlerInfo->HandlerState) && (pHandlerInfo->pThreadProxy) )
        {
            CThreadMsgProxy *pThreadProxy;

            Assert(dwSyncFlags & SYNCMGRFLAG_EVENTMASK); // an event should be set
            pHandlerInfo->HandlerState = HANDLERSTATE_ININITIALIZE;

            pThreadProxy = pHandlerInfo->pThreadProxy;

            clockqueue.Leave();

            hr =  pThreadProxy->Initialize(dwReserved,dwSyncFlags,cbCookie,lpCooke);

            clockqueue.Enter();

            if (S_OK == hr)
            {
                pHandlerInfo->HandlerState = HANDLERSTATE_ADDHANDLERTEMS;
            }
            else
            {
                pHandlerInfo->HandlerState = HANDLERSTATE_RELEASE;
            }
        }

        pHandlerInfo->dwCallNestCount--;
    }

    clockqueue.Leave();
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::AddHandlerItemsToQueue, public
//
//  Synopsis:   Calls through to proxy to add items to the queue
//
//  Arguments:  [wHandlerId] - Id of handler to call.
//
//  Returns:    Appropriate return codes.
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::AddHandlerItemsToQueue(HANDLERINFO *pHandlerId,DWORD *pcbNumItems)
{
    HRESULT hr = E_UNEXPECTED;
    LPHANDLERINFO pHandlerInfo = NULL;
    CLock clockqueue(this);

    ASSERT_LOCKNOTHELD(this);
    clockqueue.Enter();

    Assert(pcbNumItems);
    Assert(QUEUETYPE_CHOICE == m_QueueType); // items should only be added in a choice queue.

    *pcbNumItems = 0;

    if (S_OK == LookupHandlerFromId(pHandlerId,&pHandlerInfo))
    {
        Assert(0 == pHandlerInfo->dwCallNestCount);
        pHandlerInfo->dwCallNestCount++;

        Assert(HANDLERSTATE_ADDHANDLERTEMS == pHandlerInfo->HandlerState);
        Assert(pHandlerInfo->pThreadProxy);

        if ( (HANDLERSTATE_ADDHANDLERTEMS == pHandlerInfo->HandlerState) && (pHandlerInfo->pThreadProxy) )
        {
            CThreadMsgProxy *pThreadProxy;

            pHandlerInfo->HandlerState = HANDLERSTATE_INADDHANDLERITEMS;
            pThreadProxy = pHandlerInfo->pThreadProxy;

            clockqueue.Leave();

            // on return all items should be filled in.
            hr =  pThreadProxy->AddHandlerItems(NULL /* HWND */,pcbNumItems);

            clockqueue.Enter();

            if ( (S_OK == hr) || (S_SYNCMGR_MISSINGITEMS == hr) )
            {
                if (S_SYNCMGR_MISSINGITEMS == hr)
                    m_fItemsMissing = TRUE;

                hr = S_OK; // review, need to handler missing items in registry.
                pHandlerInfo->HandlerState = HANDLERSTATE_PREPAREFORSYNC;
            }
            else
            {
                // on an error, go ahead and release the proxy if server can't enum
                pHandlerInfo->HandlerState = HANDLERSTATE_RELEASE;
                *pcbNumItems = 0;
            }
        }

        pHandlerInfo->dwCallNestCount--;
    }

    clockqueue.Leave();
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::GetItemObject, public
//
//  Synopsis:   Calls through to proxy to get an items object pointer
//
//  Arguments:  [wHandlerId] - Id of handler to call.
//              [wItemID] - ID of item to get the object of.
//              [riid] - interface requested of the object
//              [ppv] - on success is a pointer to the newly created object
//
//  Returns:    Currently all handlers should return E_NOTIMPL.
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::GetItemObject(HANDLERINFO *pHandlerId,WORD wItemID,REFIID riid,void** ppv)
{
    HRESULT hr = E_UNEXPECTED;
    LPHANDLERINFO pHandlerInfo = NULL;
    CLock clockqueue(this);

    Assert(QUEUETYPE_PROGRESS == m_QueueType);

    ASSERT_LOCKNOTHELD(this);
    clockqueue.Enter();

    if (S_OK == LookupHandlerFromId(pHandlerId,&pHandlerInfo))
    {
        LPITEMLIST pCurItem;

        Assert(HANDLERSTATE_PREPAREFORSYNC == pHandlerInfo->HandlerState);
        Assert(pHandlerInfo->pThreadProxy);

        Assert(0 == pHandlerInfo->dwCallNestCount);
        pHandlerInfo->dwCallNestCount++;

        if ( (HANDLERSTATE_PREPAREFORSYNC == pHandlerInfo->HandlerState) && (pHandlerInfo->pThreadProxy))
        {
            // now try to find the item.
            pCurItem = pHandlerInfo->pFirstItem;

            while (pCurItem)
            {
                if (wItemID == pCurItem->wItemId)
                {
                    CThreadMsgProxy *pThreadProxy;
                    SYNCMGRITEMID ItemID;

                    pThreadProxy = pHandlerInfo->pThreadProxy;
                    ItemID = pCurItem->offlineItem.ItemID;
                    clockqueue.Leave();

                    hr = pThreadProxy->GetItemObject(ItemID,riid,ppv);

                    return hr;
                }

                pCurItem = pCurItem->pnextItem;
            }
        }

        pHandlerInfo->dwCallNestCount--;
    }

    clockqueue.Leave();

    AssertSz(0, "Specified object wasn't found");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::SetUpProgressCallback, public
//
//  Synopsis:   Calls through to proxy to set up the progress callback
//
//  Arguments:  [wHandlerId] - Id of handler to call.
//              [fSet] - TRUE == create, FALSE == destroy.
//              [hwnd] - Callback info should be sent to specified window.
//
//  Returns:    Appropriate Error code
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::SetUpProgressCallback(HANDLERINFO *pHandlerId,BOOL fSet,HWND hwnd)
{
    HRESULT hr = E_UNEXPECTED;
    LPHANDLERINFO pHandlerInfo = NULL;
    CLock clockqueue(this);

    AssertSz(0,"this function no longer used");

    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::PrepareForSync, public
//
//  Synopsis:   Calls through to Handlers PrepareForSync method.
//
//  Arguments:  [wHandlerId] - Id of handler to call.
//              [hWndParent] - Hwnd to use for any displayed dialogs.
//
//  Returns:    Appropriate Error code
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::PrepareForSync(HANDLERINFO *pHandlerId,HWND hWndParent)
{
    HRESULT hr = E_UNEXPECTED;
    LPHANDLERINFO pHandlerInfo = NULL;
    ULONG cbNumItems;
    SYNCMGRITEMID *pItemIDs;
    BOOL fHandlerCalled = FALSE;
    CLock clockqueue(this);

    Assert(QUEUETYPE_PROGRESS == m_QueueType);

    ASSERT_LOCKNOTHELD(this);
    clockqueue.Enter();

    if (S_OK == LookupHandlerFromId(pHandlerId,&pHandlerInfo))
    {
        Assert(HANDLERSTATE_PREPAREFORSYNC == pHandlerInfo->HandlerState);
        Assert(pHandlerInfo->pThreadProxy);

        Assert(0 == pHandlerInfo->dwCallNestCount);
        pHandlerInfo->dwCallNestCount++;

        Assert(!(ThreadMsg_PrepareForSync & pHandlerInfo->dwOutCallMessages));
        pHandlerInfo->dwOutCallMessages |= ThreadMsg_PrepareForSync;

        if (HANDLERSTATE_PREPAREFORSYNC == pHandlerInfo->HandlerState)
        {
            // if item doesn't have a ThreadProxy or it has been cancelled,
            // put in the Release State

            if ( (NULL == pHandlerInfo->pThreadProxy) || (pHandlerInfo->fCancelled) )
            {
                pHandlerInfo->HandlerState = HANDLERSTATE_RELEASE;
            }
            else
            {
                // create a list of the selected items and pass to PrepareForSync
                cbNumItems = GetSelectedItemsInHandler(pHandlerInfo,0,NULL);
                if (0 == cbNumItems)
                {
                    // if no items selected don't call prepareforsync
                    // and set the HandlerState so it can be released
                    pHandlerInfo->HandlerState = HANDLERSTATE_RELEASE;
                    hr = S_FALSE;
                }
                else
                {
                    pItemIDs = (SYNCMGRITEMID *) ALLOC(sizeof(SYNCMGRITEMID)*cbNumItems);

                    if (pItemIDs)
                    {
                        // loop through items filling in the proper data
                        GetSelectedItemsInHandler(pHandlerInfo,&cbNumItems,pItemIDs);

                        if (0 == cbNumItems)
                        {
                            hr = S_FALSE; // There are no selected items.
                        }
                        else
                        {
                            CThreadMsgProxy *pThreadProxy;
                            JOBINFO *pJobInfo = NULL;

                            pHandlerInfo->HandlerState = HANDLERSTATE_INPREPAREFORSYNC;

                            pThreadProxy = pHandlerInfo->pThreadProxy;
                            pHandlerInfo->hWndCallback = hWndParent;
                            pJobInfo = pHandlerInfo->pJobInfo;

                            // if we need to dial to make the connection do
                            // so now.

                            clockqueue.Leave();

                            DWORD dwSyncFlags = pJobInfo->dwSyncFlags & SYNCMGRFLAG_EVENTMASK;
                            BOOL fAutoDialDisable = TRUE;
                            if ( dwSyncFlags == SYNCMGRFLAG_MANUAL || dwSyncFlags == SYNCMGRFLAG_INVOKE )
                                fAutoDialDisable = FALSE;

                            //
                            // Ignore failure return from ApplySyncItemDialState
                            //
                            ApplySyncItemDialState( fAutoDialDisable );

                            hr = OpenConnection(pJobInfo);

                            if (S_OK == hr)
                            {
                                // if this is on an idle write out the last
                                // handler id

                                // review - if don't wait to call PrepareForSync
                                // on idle the setlastIdlehandler should be called on sync.
                                if (pJobInfo && (SYNCMGRFLAG_IDLE == (pJobInfo->dwSyncFlags  & SYNCMGRFLAG_EVENTMASK)) )
                                {
                                    SetLastIdleHandler(pHandlerInfo->clsidHandler);
                                }

                                fHandlerCalled = TRUE;
                                hr =  pThreadProxy->PrepareForSync(cbNumItems, pItemIDs,
                                                        hWndParent, 0 /* dwReserved */ );

                            }
                            else
                            {
                                clockqueue.Enter();
                                pHandlerInfo->hWndCallback = NULL;
                                clockqueue.Leave();
                            }
                        }

                        // on return from PrepareFroSync or error need to free items
                        clockqueue.Enter();
                        FREE(pItemIDs);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
        }
    }

    clockqueue.Leave();

    // if the handler returns an errorfrom PrepareForSync we need
    // to call the completion routine ourselves and/or we never got to the point
    // of making the outcall.

   if ( (fHandlerCalled && (S_OK != hr)) || (!fHandlerCalled))
   {
        CallCompletionRoutine(pHandlerId,ThreadMsg_PrepareForSync,hr,0,NULL);
   }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::PrepareForSyncCompleted, public
//
//  Synopsis:   Called by completion routine on a PrepareForSyncCompleted
//
//              Warning: Assume queue is locked and pHandlerInfo has
//                  already been verified.
//
//  Returns:    Appropriate Error code
//
//  Modifies:
//
//  History:    02-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::PrepareForSyncCompleted(LPHANDLERINFO pHandlerInfo,HRESULT hCallResult)
{
    ASSERT_LOCKHELD(this); // caller of this function should have already locked the queue.

    if (S_OK == hCallResult)
    {
         pHandlerInfo->HandlerState = HANDLERSTATE_SYNCHRONIZE;
    }
    else
    {
        pHandlerInfo->HandlerState = HANDLERSTATE_RELEASE;
    }

    if ( (pHandlerInfo->HandlerState != HANDLERSTATE_SYNCHRONIZE))
    {
        // if handler didn't make it to the synchronize state then fix up the items
        LPITEMLIST pCurItem = NULL;

        // prepare for sync either doesn't want to handle the
        // items or an error occured,
        // need to go ahead and mark the items as completed.
        // same routine that is after synchronize.

        pCurItem = pHandlerInfo->pFirstItem;

        while (pCurItem)
        {
            SetItemProgressValues(pCurItem,
                    HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE,
                    HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE);

            pCurItem->fSynchronizingItem = FALSE;

            pCurItem = pCurItem->pnextItem;
         }
    }

    pHandlerInfo->dwCallNestCount--; // decrement nestcount put on by PrepareForSync call.

    // if the handler state has been released but it has some jumptext, which it can if
    // the PrepareForsync was caused by a retry then set the results to HANDLERSTATE_HASERRORJUMPS
    if ((HANDLERSTATE_RELEASE == pHandlerInfo->HandlerState) && (pHandlerInfo->fHasErrorJumps))
    {
        pHandlerInfo->HandlerState = HANDLERSTATE_HASERRORJUMPS;
    }

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::Synchronize, public
//
//  Synopsis:   Calls through to Handlers Synchronize method.
//
//  Arguments:  [wHandlerId] - Id of handler to call.
//              [hWndParent] - Hwnd to use for any displayed dialogs.
//
//  Returns:    Appropriate Error code
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::Synchronize(HANDLERINFO *pHandlerId,HWND hWndParent)
{
    HRESULT hr = E_UNEXPECTED;
    LPHANDLERINFO pHandlerInfo = NULL;
    BOOL fHandlerCalled = FALSE;
    CLock clockqueue(this);

    Assert(QUEUETYPE_PROGRESS == m_QueueType);

    ASSERT_LOCKNOTHELD(this);
    clockqueue.Enter();

    if (S_OK == LookupHandlerFromId(pHandlerId,&pHandlerInfo))
    {
        Assert(HANDLERSTATE_SYNCHRONIZE == pHandlerInfo->HandlerState);
        Assert(pHandlerInfo->pThreadProxy);

        Assert(0 == pHandlerInfo->dwCallNestCount);
        pHandlerInfo->dwCallNestCount++;

        Assert(!(ThreadMsg_Synchronize & pHandlerInfo->dwOutCallMessages));
        pHandlerInfo->dwOutCallMessages |= ThreadMsg_Synchronize;

        if ( (HANDLERSTATE_SYNCHRONIZE == pHandlerInfo->HandlerState) && (pHandlerInfo->pThreadProxy) )
        {
            // make sure the handler has a proxy and the item
            // wasn't cancelled.
            if ( (NULL == pHandlerInfo->pThreadProxy) || (pHandlerInfo->fCancelled))
            {
                pHandlerInfo->HandlerState = HANDLERSTATE_RELEASE;
            }
            else
            {
                CThreadMsgProxy *pThreadProxy;

                pHandlerInfo->HandlerState = HANDLERSTATE_INSYNCHRONIZE;
                pThreadProxy= pHandlerInfo->pThreadProxy;

                clockqueue.Leave();
                fHandlerCalled = TRUE;
                hr =  pThreadProxy->Synchronize(hWndParent);
                clockqueue.Enter();
            }
        }
    }

    clockqueue.Leave();

    // if the handler returns an error from Synchronize we need
    // to call the completion routine ourselves and/or we never got to the point
    // of making the outcall.

   if ( (fHandlerCalled && (S_OK != hr)) || (!fHandlerCalled) )
   {
        CallCompletionRoutine(pHandlerId,ThreadMsg_Synchronize,hr,0,NULL);
   }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::SynchronizeCompleted, public
//
//  Synopsis:   Called by completion routine on a SynchronizeCompleted
//
//              Warning: Assume queue is locked and pHandlerInfo has
//                  already been verified.
//
//  Returns:    Appropriate Error code
//
//  Modifies:
//
//  History:    02-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::SynchronizeCompleted(LPHANDLERINFO pHandlerInfo,HRESULT hCallResult)
{
    LPITEMLIST pCurItem = NULL;
    BOOL fRetrySync = FALSE;

    ASSERT_LOCKHELD(this); // caller of this function should have already locked the queue.

    if (pHandlerInfo->fRetrySync)
    {
        // if a retry request came in during the sync, retry it.
        pHandlerInfo->HandlerState = HANDLERSTATE_PREPAREFORSYNC;
        pHandlerInfo->fRetrySync = FALSE; // reset the retry sync flag.
        fRetrySync = TRUE;
    }
    else if (pHandlerInfo->fHasErrorJumps)
    {
        pHandlerInfo->HandlerState = HANDLERSTATE_HASERRORJUMPS;
    }
    else
    {
        pHandlerInfo->HandlerState = HANDLERSTATE_RELEASE;
    }

     // when come out of synchronize we set the items values for them.
    // in case they were negligent.
    pCurItem = pHandlerInfo->pFirstItem;

    while (pCurItem)
    {
        SetItemProgressValues(pCurItem,
                    HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE,
                    HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE);

        pCurItem->fSynchronizingItem = FALSE;

        pCurItem = pCurItem->pnextItem;

    }

    pHandlerInfo->dwCallNestCount--; // remove nest count

     // if the handler state has been released but it has some jumptext, which it can if
    // the sycnrhonize was caused by a retry then set the results to HANDLERSTATE_HASERRORJUMPS

    if ((HANDLERSTATE_RELEASE == pHandlerInfo->HandlerState) && (pHandlerInfo->fHasErrorJumps))
    {
        pHandlerInfo->HandlerState = HANDLERSTATE_HASERRORJUMPS;
    }

    return S_OK;

}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::ShowError, public
//
//  Synopsis:   Calls through to Handlers ShowError method.
//
//  Arguments:  [wHandlerId] - Id of handler to call.
//              [hWndParent] - Hwnd to use for any displayed dialogs.
//              [dwErrorID] - Identifies the error to show
//
//  Returns:    Appropriate Error code
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::ShowError(HANDLERINFO *pHandlerId,HWND hWndParent,REFSYNCMGRERRORID ErrorID)
{
    HRESULT hr = E_UNEXPECTED;
    LPHANDLERINFO pHandlerInfo = NULL;
    BOOL fHandlerCalled = FALSE;
    BOOL fAlreadyInShowErrors = TRUE;
    CLock clockqueue(this);

    Assert(QUEUETYPE_PROGRESS == m_QueueType);

    clockqueue.Enter();

    if (S_OK == LookupHandlerFromId(pHandlerId,&pHandlerInfo))
    {
        Assert(pHandlerInfo->fHasErrorJumps);
        Assert(pHandlerInfo->pThreadProxy);

         // if we are already handling a ShowError for this handler then don't
        // start another one

        if (!(pHandlerInfo->fInShowErrorCall))
        {
            fAlreadyInShowErrors = FALSE;
            m_dwShowErrororOutCallCount++; // increment handlers ShowError OutCall Count.

            Assert(!(ThreadMsg_ShowError & pHandlerInfo->dwOutCallMessages));
            pHandlerInfo->dwOutCallMessages |= ThreadMsg_ShowError;

            if (pHandlerInfo->pThreadProxy )
            {
                CThreadMsgProxy *pThreadProxy;
                ULONG cbNumItems = 0; // review, these are not longer necessary.
                SYNCMGRITEMID *pItemIDs = NULL;

                pThreadProxy = pHandlerInfo->pThreadProxy;
                fHandlerCalled = TRUE;
                pHandlerInfo->fInShowErrorCall = TRUE;

                clockqueue.Leave();
                hr =  pThreadProxy->ShowError(hWndParent,ErrorID,&cbNumItems,&pItemIDs);
                clockqueue.Enter();
            }
        }
    }

    clockqueue.Leave();

    // if the handler returns an error from ShowError we need
    // to call the completion routine ourselves and/or we never got to the point
    // of making the outcall and there wasn't already an outcall in progress.
   if ( (fHandlerCalled && (S_OK != hr)) || (!fHandlerCalled && !fAlreadyInShowErrors) )
   {
        CallCompletionRoutine(pHandlerId,ThreadMsg_ShowError,hr,0,NULL);
   }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::ShowErrorCompleted, public
//
//  Synopsis:   Called by completion routine on a ShowErrorCompleted
//
//              Warning: Assume queue is locked and pHandlerInfo has
//                  already been verified.
//
//  Returns:
//
//  Modifies:
//
//  History:    02-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::ShowErrorCompleted(LPHANDLERINFO pHandlerInfo,HRESULT hCallResult,
                                     ULONG cbNumItems,SYNCMGRITEMID *pItemIDs)
{
    ASSERT_LOCKHELD(this); // caller of this function should have already locked the queue.

    if (S_SYNCMGR_RETRYSYNC == hCallResult)
    {

        // validate we got something back for cbNumItems and pItemIDs or
        // don't do anything
        if ( (0 == cbNumItems) || (NULL == pItemIDs))
        {
            Assert(cbNumItems); // assert in debug so can catch handlers.
            Assert(pItemIDs);
        }
        else
        {
            SYNCMGRITEMID *pCurItemItemId;
            ULONG cbNumItemsIndex;

            // if the handler is in the release state then change to prepareForSync
            // if it is still in a synchronize just set the fRetrySync flag in the
            // handler for it to check when done.

            // Cases
            //   Handlers PrepareForSync Method hasn't been called. Just add items to request
            //   Handlers is between  InPrepareForSync and InSynchronize. Set RetrySyncFlag
            //   Handler has is done with it synchronize. reset state to PrepareForSync

            // when prepareforsync is called on an item it state gets set back to unchecked
            // so just need to worry about setting appropriate items to checked.

            pCurItemItemId = pItemIDs;
            for (cbNumItemsIndex = 0 ; cbNumItemsIndex < cbNumItems; cbNumItemsIndex++)
            {
                BOOL fFoundMatch = FALSE;
                LPITEMLIST pHandlerItem;

                pHandlerItem = pHandlerInfo->pFirstItem;
                while (pHandlerItem)
                {
                    if (*pCurItemItemId == pHandlerItem->offlineItem.ItemID)
                    {
                        pHandlerItem->offlineItem.dwItemState = SYNCMGRITEMSTATE_CHECKED;

                        SetItemProgressValues(pHandlerItem,0,
                              HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE);

                        pHandlerItem->fIncludeInProgressBar = TRUE;
                        fFoundMatch = TRUE;
                        break;
                    }

                    pHandlerItem = pHandlerItem->pnextItem;
                }

                if (!fFoundMatch)
                {
                    LPITEMLIST pNewItem;
                    SYNCMGRITEM syncItem;

                    // if didn't find a match this must be a new item, add it to the list
                    // and set up the appropriate states.
                    // Note: items added like this should not be included in the progress bar.
                    // first time progress is called on an item it will get included
                    // in the progress bar.

                    syncItem.cbSize = sizeof(SYNCMGRITEM);
                    syncItem.dwFlags = SYNCMGRITEM_TEMPORARY;
                    syncItem.ItemID = *pCurItemItemId;
                    syncItem.dwItemState = SYNCMGRITEMSTATE_CHECKED;
                    syncItem.hIcon = NULL;
                    *syncItem.wszItemName = L'\0';

                    pNewItem =  AllocNewHandlerItem(pHandlerInfo,&syncItem);

                    if (pNewItem)
                    {
                        pNewItem->offlineItem.dwItemState = SYNCMGRITEMSTATE_CHECKED;

                        SetItemProgressValues(pNewItem,
                               HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE,
                              HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE);

                        pNewItem->fHiddenItem = TRUE; // set to indicate not part of UI.
                        pNewItem->fIncludeInProgressBar = FALSE;
                    }
                }

                ++pCurItemItemId;
            }

            if (pHandlerInfo->HandlerState < HANDLERSTATE_INPREPAREFORSYNC)
            {
                // don't reset anything. just make sure requested items are added
                // to the request.
            }
            else if (pHandlerInfo->HandlerState > HANDLERSTATE_INSYNCHRONIZE)
            {
                // if synchronize is complete reset the state to PrepareForSync.
                pHandlerInfo->HandlerState = HANDLERSTATE_PREPAREFORSYNC;
            }
            else
            {
                // retry request came in between the PrepareForSync call and Synchronize
                // being complete.
                Assert(pHandlerInfo->HandlerState >= HANDLERSTATE_INPREPAREFORSYNC);
                Assert(pHandlerInfo->HandlerState < HANDLERSTATE_DEAD);
                pHandlerInfo->fRetrySync = TRUE;
            }

            //
            // If the handler has been canceled, uncancel it to enable the retry
            //
            pHandlerInfo->fCancelled = FALSE;
        }
    }

    --m_dwShowErrororOutCallCount; // decrement handlers ShowError OutCall Count.

    // should never happen but in case out call goes negative fixup to zero.
    Assert( ((LONG) m_dwShowErrororOutCallCount) >= 0);
    if ( ((LONG) m_dwShowErrororOutCallCount) < 0)
    {
        m_dwShowErrororOutCallCount = 0;
    }

    pHandlerInfo->fInShowErrorCall = FALSE; // handler is no longer in a ShowError Call

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::FindItemData, private
//
//  Synopsis:   finds associated handler and item info. caller must be
//              holding the lock and access the returned info before
//              releasing the lock 
//
//              !! Only matches items that have a state between or equal
//              to the handler state ranges.
//
//              !!! If ItemID of GUID_NULL is passed it it returns a match
//                  of the first handler found and sets pItem out param to NULL
//
//  Arguments: 
//
//  Returns:    Appropriate return codes
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::FindItemData(CLSID clsidHandler,REFSYNCMGRITEMID OfflineItemID,
                                         HANDLERSTATE hndlrStateFirst,HANDLERSTATE hndlrStateLast,
                                         LPHANDLERINFO *ppHandlerInfo,LPITEMLIST *ppItem)
{
    LPHANDLERINFO pCurHandlerInfo = NULL;
    LPITEMLIST pCurItem = NULL;
    BOOL fNoMatchFound = TRUE;
    HRESULT hr = S_FALSE;

    ASSERT_LOCKHELD(this);

    Assert(ppHandlerInfo);
    Assert(ppItem);

    *ppHandlerInfo = NULL;
    *ppItem = NULL;

    pCurHandlerInfo = m_pFirstHandler;

    while (pCurHandlerInfo && fNoMatchFound)
    {
        if ( (clsidHandler == pCurHandlerInfo->clsidHandler)
            && (hndlrStateLast >= pCurHandlerInfo->HandlerState)
            && (hndlrStateFirst <= pCurHandlerInfo->HandlerState) )
        {
            *ppHandlerInfo = pCurHandlerInfo;

            // if top level item tem ppItem to NULL and return okay
            if (GUID_NULL == OfflineItemID)
            {
                *ppItem = NULL;
                hr = S_OK;
                fNoMatchFound = FALSE;
            }
            else
            {
                pCurItem = pCurHandlerInfo->pFirstItem;

                while (pCurItem)
                {
                    if (OfflineItemID == pCurItem->offlineItem.ItemID)
                    {
                        *ppItem = pCurItem;
                        hr = S_OK;
                        fNoMatchFound = FALSE;
                        break;
                    }
                    pCurItem = pCurItem->pnextItem;
                }
            }
        }

        pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::LookupHandlerFromId, private
//
//  Synopsis:   Finds associate handler info from the given Id
//
//  Arguments:  [wHandlerId] - Id of handler to call.
//              [pHandlerInfo] - on S_OK pointer to handler info
//
//  Returns:    Appropriate Error code
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::LookupHandlerFromId(HANDLERINFO *pHandlerId,LPHANDLERINFO *pHandlerInfo)
{
    HRESULT hr = E_UNEXPECTED;
    LPHANDLERINFO pCurItem;

    ASSERT_LOCKHELD(this); // caller of this function should have already locked the queue.

    *pHandlerInfo = NULL;
    pCurItem = m_pFirstHandler;

    while (pCurItem)
    {
        if (pHandlerId == pCurItem->pHandlerId )
        {
            *pHandlerInfo = pCurItem;
            Assert(pCurItem == pHandlerId);
            hr = S_OK;
            break;
        }

        pCurItem = pCurItem->pNextHandler;
    }

    Assert(S_OK == hr); // test assert to see if ever fires.

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::AllocNewHandlerItem, public
//
//  Synopsis:   Adds new item to the specified handler.
//
//  Arguments:  [wHandlerId] - Id of handler.
//              [pOfflineItem] - Points to Items information to add.
//
//  Returns:    Appropriate Error code
//
//  Modifies:
//
//  History:    13-May-98      rogerg        Created.
//
//----------------------------------------------------------------------------

LPITEMLIST CHndlrQueue::AllocNewHandlerItem(LPHANDLERINFO pHandlerInfo,SYNCMGRITEM *pOfflineItem)
{
    LPITEMLIST pNewItem = NULL;

    ASSERT_LOCKHELD(this); // caller of this function should have already locked the queue.

    Assert(pHandlerInfo);
    Assert(pOfflineItem);

    // Allocate the item.
    pNewItem = (LPITEMLIST) ALLOC(sizeof(ITEMLIST));

    if (pNewItem)
    {
        // set up defaults.
        memset(pNewItem, 0, sizeof(ITEMLIST));
        pNewItem->wItemId =     ++pHandlerInfo->wItemCount;
        pNewItem->pHandlerInfo = pHandlerInfo;
        pNewItem->fDuplicateItem = FALSE;
        pNewItem->fIncludeInProgressBar = FALSE;
        SetItemProgressValues(pNewItem, 0, HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE);
        pNewItem->dwStatusType = SYNCMGRSTATUS_PENDING;
        pNewItem->fHiddenItem = FALSE;
        pNewItem->fSynchronizingItem = FALSE;

        pNewItem->offlineItem = *pOfflineItem;

        // stick the item on the end of the list
        if (NULL == pHandlerInfo->pFirstItem)
        {
            pHandlerInfo->pFirstItem = pNewItem;
            Assert(1 == pHandlerInfo->wItemCount);
        }
        else
        {
            LPITEMLIST pCurItem;

            pCurItem = pHandlerInfo->pFirstItem;

            while (pCurItem->pnextItem)
                pCurItem = pCurItem->pnextItem;

            pCurItem->pnextItem = pNewItem;

            Assert ((pCurItem->wItemId + 1) == pNewItem->wItemId);
        }
    }

    return pNewItem;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::SetHandlerInfo, public
//
//  Synopsis:   Adds item to the specified handler.
//              Called in context of the handlers thread.
//
//  Arguments:  [pHandlerId] - Id of handler.
//              [pSyncMgrHandlerInfo] - Points to SyncMgrHandlerInfo to be filled in.
//
//  Returns:    Appropriate Error code
//
//  Modifies:
//
//  History:    28-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::SetHandlerInfo(HANDLERINFO *pHandlerId,LPSYNCMGRHANDLERINFO pSyncMgrHandlerInfo)
{
    HRESULT hr = E_UNEXPECTED;
    LPHANDLERINFO pHandlerInfo = NULL;
    CLock clockqueue(this);

    if (!pSyncMgrHandlerInfo)
    {
        Assert(pSyncMgrHandlerInfo);
        return E_INVALIDARG;
    }

    clockqueue.Enter();

    Assert(m_QueueType == QUEUETYPE_CHOICE);

    if (S_OK == LookupHandlerFromId(pHandlerId,&pHandlerInfo))
    {
        if (HANDLERSTATE_INADDHANDLERITEMS != pHandlerInfo->HandlerState)
        {
            Assert(HANDLERSTATE_INADDHANDLERITEMS == pHandlerInfo->HandlerState);
            hr =  E_UNEXPECTED;
        }
        else
        {
            // Quick Check of Size here. other paramters should already
            // be validated by hndlrmsg
            if (pSyncMgrHandlerInfo->cbSize != sizeof(SYNCMGRHANDLERINFO) )
            {
                Assert(pSyncMgrHandlerInfo->cbSize == sizeof(SYNCMGRHANDLERINFO));
                hr = E_INVALIDARG;
            }
            else
            {
                pHandlerInfo->SyncMgrHandlerInfo = *pSyncMgrHandlerInfo;
	            hr = S_OK;
            }
        }
    }

    clockqueue.Leave();

    return hr;

}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::IsAllHandlerInstancesCancelCompleted, private
//
//  Synopsis:   Asks queue if all interintances of a Handler CLSID
//              are completed, Called in proxy terminate to see
//              if after requesting user input there are still items to 
//              kill.
//
//              Note: Only checks instances for this queue.
//
//  Arguments:  
//
//  Returns:    S_OK; if all handler instances are done.
//              S_FALSE - if still items going that should be killed.
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::IsAllHandlerInstancesCancelCompleted(REFCLSID clsidHandler)
{
    HRESULT hr = S_OK;
    LPHANDLERINFO pCurHandlerInfo;
    CLock clockqueue(this);

    // just loop through handlers matching clsid and if any are <= SynchronizeCompleted
    // and the cancelled flag set then an instance of the Handler is still
    // stuck in a Cancel.

    Assert(m_QueueType == QUEUETYPE_PROGRESS);

    clockqueue.Enter();

    pCurHandlerInfo = m_pFirstHandler;

    while (pCurHandlerInfo)
    {
        if ( (clsidHandler == pCurHandlerInfo->clsidHandler) && (BAD_HANDLERSTATE(pCurHandlerInfo) )
                && (pCurHandlerInfo->fCancelled) )
        {
            hr = S_FALSE;
            break;
        }

        pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }

    clockqueue.Leave();

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::AddItemToHandler, public
//
//  Synopsis:   Adds item to the specified handler.
//              Called in context of the handlers thread.
//
//  Arguments:  [wHandlerId] - Id of handler.
//              [pOfflineItem] - Points to Items information to add.
//
//  Returns:    Appropriate Error code
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::AddItemToHandler(HANDLERINFO *pHandlerId,SYNCMGRITEM *pOfflineItem)
{
    HRESULT hr = E_UNEXPECTED; // review for Lookup failures
    LPHANDLERINFO pHandlerInfo = NULL;
    LPITEMLIST pNewItem = NULL;
    LPHANDLERINFO pHandlerMatched;
    LPITEMLIST pItemListMatch;
    CLock clockqueue(this);

    clockqueue.Enter();

    Assert(m_QueueType == QUEUETYPE_CHOICE);

    if (S_OK == LookupHandlerFromId(pHandlerId,&pHandlerInfo))
    {
        if (HANDLERSTATE_INADDHANDLERITEMS != pHandlerInfo->HandlerState)
        {
            Assert(HANDLERSTATE_INADDHANDLERITEMS == pHandlerInfo->HandlerState);
            hr =  E_UNEXPECTED;
        }
        else
        {
            // make sure the handler has a jobID and ConnectionObj
            // associated with it.

            Assert(pHandlerInfo->pJobInfo);
            Assert(pHandlerInfo->pJobInfo->pConnectionObj);

            if (pHandlerInfo->pJobInfo && pHandlerInfo->pJobInfo->pConnectionObj)
            {
                DWORD dwSyncFlags = pHandlerInfo->pJobInfo->dwSyncFlags;

                // Allocate the item.
                pNewItem = AllocNewHandlerItem(pHandlerInfo,pOfflineItem);

                if (NULL == pNewItem)
                {
                    hr =  E_OUTOFMEMORY;
                }
                else
                {
                    DWORD dwCheckState;
                    DWORD dwDefaultCheck; // what default for the item should be.
                    DWORD ConnectionIndex;
                    DWORD dwSyncEvent = dwSyncFlags & SYNCMGRFLAG_EVENTMASK;

                    // if SyncType is SYNCMGRFLAG_CONNECT, SYNCMGRFLAG_PENDINGDISCONNECT
                    //  or Idle, set the defaults based on registration flags

                    // If change this logic need to also change logic in dll hndlrq.
                    
                    dwDefaultCheck = pOfflineItem->dwItemState;
                    if ( 
                           ( (dwSyncEvent == SYNCMGRFLAG_IDLE) && !(pHandlerInfo->dwRegistrationFlags & SYNCMGRREGISTERFLAG_IDLE) )
                        || ( (dwSyncEvent == SYNCMGRFLAG_CONNECT) && !(pHandlerInfo->dwRegistrationFlags & SYNCMGRREGISTERFLAG_CONNECT) )
                        || ( (dwSyncEvent == SYNCMGRFLAG_PENDINGDISCONNECT) && !(pHandlerInfo->dwRegistrationFlags & SYNCMGRREGISTERFLAG_PENDINGDISCONNECT) )
                       )
                    {
                        dwDefaultCheck = SYNCMGRITEMSTATE_UNCHECKED;
                    }

                    // get appropriate stored setting based on the sync flags
                    // invoke we just use whatever the handler tells us it should be.
                    if (SYNCMGRFLAG_INVOKE != dwSyncEvent)
                    {
                        for (ConnectionIndex = 0; ConnectionIndex <
                                        pHandlerInfo->pJobInfo->cbNumConnectionObjs;
                                                                        ++ConnectionIndex)
                        {
                            TCHAR *pszConnectionName =
                                  pHandlerInfo->pJobInfo->pConnectionObj[ConnectionIndex]->pwszConnectionName;

                            switch(dwSyncEvent)
                            {
                            case SYNCMGRFLAG_MANUAL:
                                // only support one connection for manual
                                 Assert(pHandlerInfo->pJobInfo->cbNumConnectionObjs == 1);

                                if (RegGetSyncItemSettings(SYNCTYPE_MANUAL,
                                                pHandlerInfo->clsidHandler,
                                                pOfflineItem->ItemID,
                                                pszConnectionName,&dwCheckState,
                                                dwDefaultCheck,
                                                NULL))
                                {
                                    pNewItem->offlineItem.dwItemState = dwCheckState;
                                }
                                break;

                            case SYNCMGRFLAG_CONNECT:
                            case SYNCMGRFLAG_PENDINGDISCONNECT:
                                if (RegGetSyncItemSettings(SYNCTYPE_AUTOSYNC,
                                                pHandlerInfo->clsidHandler,
                                                pOfflineItem->ItemID,
                                                pszConnectionName,&dwCheckState,
                                                dwDefaultCheck,
                                                NULL))
                                {
                                    // for logon/logoff a checkstate of set wins and
                                    // as soon as it is set break out of the loop

                                    if ( (0 == ConnectionIndex) ||
                                            (SYNCMGRITEMSTATE_CHECKED == dwCheckState) )
                                    {
                                        pNewItem->offlineItem.dwItemState = dwCheckState;
                                    }

                                    if (SYNCMGRITEMSTATE_CHECKED == pNewItem->offlineItem.dwItemState)
                                    {
                                        break;
                                    }
                                }
                                break;

                            case SYNCMGRFLAG_IDLE:
                                if (RegGetSyncItemSettings(SYNCTYPE_IDLE,
                                                pHandlerInfo->clsidHandler,
                                                pOfflineItem->ItemID,
                                                pszConnectionName,&dwCheckState,
                                                dwDefaultCheck,
                                                NULL))
                                {
                                    // for Idle a checkstate of set wins and
                                    // as soon as it is set break out of the loop

                                    if ( (0 == ConnectionIndex) ||
                                            (SYNCMGRITEMSTATE_CHECKED == dwCheckState))
                                    {
                                        pNewItem->offlineItem.dwItemState = dwCheckState;
                                    }

                                    if (SYNCMGRITEMSTATE_CHECKED ==pNewItem->offlineItem.dwItemState)
                                    {
                                        break;
                                    }
                                }
                                break;

                            case SYNCMGRFLAG_SCHEDULED: // if caused by an invoke, use whatever handler tells us.
                                  // only support one connection for schedule
                                 Assert(pHandlerInfo->pJobInfo->cbNumConnectionObjs == 1);

                                if (pHandlerInfo->pJobInfo)
                                {
                                    if (RegGetSyncItemSettings(SYNCTYPE_SCHEDULED,
                                                        pHandlerInfo->clsidHandler,
                                                        pOfflineItem->ItemID,
                                                        pszConnectionName,
                                                        &dwCheckState,
                                                        SYNCMGRITEMSTATE_UNCHECKED, // if don't find item, don't check
                                                        pHandlerInfo->pJobInfo->szScheduleName))
                                   {
                                        pNewItem->offlineItem.dwItemState = dwCheckState;
                                   }
                                   else
                                   {
                                       // If don't find then default is to be unchecked.
                                       pNewItem->offlineItem.dwItemState = SYNCMGRITEMSTATE_UNCHECKED;
                                   }
                                }
                               break;

                            case SYNCMGRFLAG_INVOKE: // if caused by an invoke, use whatever handler tells us.
                                break;

                            default:
                                AssertSz(0, "UnknownSyncFlag Event");
                                break;
                            };
                        }
                    }

                    //  Search and mark duplicate entries.
                    if (IsItemAlreadyInList(pHandlerInfo->clsidHandler,
                        (pOfflineItem->ItemID),pHandlerInfo->pHandlerId,
                          &pHandlerMatched,&pItemListMatch) )
                    {
                        Assert(QUEUETYPE_CHOICE == m_QueueType || QUEUETYPE_PROGRESS == m_QueueType);

                        pNewItem->fDuplicateItem = TRUE;

                        // duplicate handling
                        // if a manual sync then first writer to the queue wins,
                        if (QUEUETYPE_CHOICE == m_QueueType)
                        {
                            pNewItem->offlineItem.dwItemState = SYNCMGRITEMSTATE_UNCHECKED;
                        }

                    }

                    hr = S_OK;
                }
            }
        }
    }

    clockqueue.Leave();
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::Progress, public
//
//  Synopsis:   Updates items progress information
//              Called in the context of the Handlers thread
//
//  Arguments:  [wHandlerId] - Id of handler.
//              [ItemID] - OfflineItemID of the specified item.
//              [lpSyncProgressItem] - Pointer to SyncProgressItem.
//
//  Returns:    Appropriate Error code
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::Progress(HANDLERINFO *pHandlerId,REFSYNCMGRITEMID ItemID,
                                                LPSYNCMGRPROGRESSITEM lpSyncProgressItem)
{
    HRESULT hr = E_UNEXPECTED;
    LPHANDLERINFO pHandlerInfo = NULL;
    LPITEMLIST pCurItem = NULL;
    BOOL fFoundMatch = FALSE;
    PROGRESSUPDATEDATA progressData;
    HWND hwndCallback;
    CLock clockqueue(this);

    progressData.pHandlerID = pHandlerId;
    progressData.ItemID = ItemID;

    Assert(QUEUETYPE_PROGRESS == m_QueueType);

    clockqueue.Enter();

    if (S_OK == LookupHandlerFromId(pHandlerId,&pHandlerInfo))
    {
        pCurItem = pHandlerInfo->pFirstItem;

        while (pCurItem)
        {
            if (ItemID == pCurItem->offlineItem.ItemID)
            {
                fFoundMatch = TRUE;
                break;
            }

            pCurItem = pCurItem->pnextItem;
        }

        if (pHandlerInfo->fCancelled)
            hr = S_SYNCMGR_CANCELALL;
        else if (!fFoundMatch || pCurItem->fItemCancelled)
        {
            Assert(fFoundMatch);
            hr = S_SYNCMGR_CANCELITEM;
        }
        else
            hr = S_OK;

    }

    if (fFoundMatch) // store everyting in local vars.
    {
        // if found match but shouldn't include in progress bar
        // fix it up.

        if ( (pCurItem->fHiddenItem) || (FALSE == pCurItem->fIncludeInProgressBar))
        {
            // if found a match it should be included in the progress bar
           // Assert(TRUE == pCurItem->fIncludeInProgressBar); // Review if test app hits this.
            Assert(FALSE == pCurItem->fHiddenItem); // shouldn't get progress on hidden items.

            fFoundMatch = FALSE;

            if (S_OK == hr) 
            {
                hr = S_SYNCMGR_CANCELITEM; // return cancel item just as if item wasn't cancelled.
            }
        }
        else
        {
            progressData.clsidHandler = pHandlerInfo->clsidHandler;
            progressData.wItemId = pCurItem->wItemId;
            hwndCallback = pHandlerInfo->hWndCallback;
        }
    }

    clockqueue.Leave();

    if (fFoundMatch)
    {
        // send off data to the callback window.
        // it is responsible for updating the items progress values.
        if (hwndCallback)
        {
            // validate the ProgressItem structure before passing it on.

            if (IsValidSyncProgressItem(lpSyncProgressItem))
            {
                SendMessage(hwndCallback,WM_PROGRESS_UPDATE,
                                (WPARAM) &progressData,(LPARAM) lpSyncProgressItem);
            }
            else
            {
                if (S_OK == hr) // CANCEL RESULTS OVERRIDE ARG PROBLEMS
                {
                    hr = E_INVALIDARG;
                }
            }
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::LogError, public
//
//  Synopsis:   Logs and error for the specified item
//              Called in the context of the Handlers thread
//
//  Arguments:  [wHandlerId] - Id of handler.
//              [dwErrorLevel] - ErrorLevel of the Error
//              [lpcErrorText] - Text of the Error.
//              [lpSyncLogError] - Pointer to SyncLogError structure
//
//  Returns:    Appropriate Error code
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::LogError(HANDLERINFO *pHandlerId,DWORD dwErrorLevel,
                                            const WCHAR *lpcErrorText, LPSYNCMGRLOGERRORINFO lpSyncLogError)
{
    HRESULT hr = E_UNEXPECTED;
    LPHANDLERINFO pHandlerInfo = NULL;
    LPITEMLIST pCurItem = NULL;
    BOOL fFoundMatch = FALSE;
    MSGLogErrors msgLogErrors;
    HWND hWndCallback = NULL;
    CLock clockqueue(this);

    msgLogErrors.dwErrorLevel = dwErrorLevel;
    msgLogErrors.lpcErrorText = lpcErrorText;
    msgLogErrors.ErrorID = GUID_NULL;
    msgLogErrors.fHasErrorJumps = FALSE;
    msgLogErrors.mask = 0;

    Assert(QUEUETYPE_PROGRESS == m_QueueType);

    clockqueue.Enter();

    if (S_OK == LookupHandlerFromId(pHandlerId,&pHandlerInfo))
    {
        hWndCallback = pHandlerInfo->hWndCallback;

        // validate the paramaters.
        if (NULL == hWndCallback)
        {
            hr = E_UNEXPECTED;
        }
        else if (!IsValidSyncLogErrorInfo(dwErrorLevel,lpcErrorText,lpSyncLogError))
        {
            hr = E_INVALIDARG;
        }
        else
        {
            if (lpSyncLogError && (lpSyncLogError->mask & SYNCMGRLOGERROR_ERRORID))
            {
                pHandlerInfo->fHasErrorJumps = TRUE;
                msgLogErrors.mask |= SYNCMGRLOGERROR_ERRORID;
                msgLogErrors.ErrorID = lpSyncLogError->ErrorID;
            }

            if (lpSyncLogError && (lpSyncLogError->mask & SYNCMGRLOGERROR_ERRORFLAGS))
            {
                if (SYNCMGRERRORFLAG_ENABLEJUMPTEXT & lpSyncLogError->dwSyncMgrErrorFlags)
                {
                    pHandlerInfo->fHasErrorJumps = TRUE;
                    msgLogErrors.fHasErrorJumps = TRUE;
                }
            }

            if (lpSyncLogError && (lpSyncLogError->mask & SYNCMGRLOGERROR_ITEMID))
            {
                msgLogErrors.mask |= SYNCMGRLOGERROR_ITEMID;
                msgLogErrors.ItemID = lpSyncLogError->ItemID;
            }

            hr = S_OK;
        }
    }

    clockqueue.Leave();

    if (S_OK == hr)
    {
        Assert(sizeof(WPARAM) >= sizeof(HANDLERINFO *));

        SendMessage(hWndCallback, WM_PROGRESS_LOGERROR, (WPARAM) pHandlerId, (LPARAM) &msgLogErrors);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::DeleteLogError, public
//
//  Synopsis:   Deletes an Error from the Results pane that was previously logged.
//
//  Arguments:
//
//  Returns:    Appropriate Error code
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::DeleteLogError(HANDLERINFO *pHandlerId,REFSYNCMGRERRORID ErrorID,DWORD dwReserved)

{
    MSGDeleteLogErrors msgDeleteLogError;
    HWND hWndCallback = NULL;
    HANDLERINFO *pHandlerInfo;
    CLock clockqueue(this);

    clockqueue.Enter();
    msgDeleteLogError.pHandlerId = pHandlerId;
    msgDeleteLogError.ErrorID = ErrorID;

    if (S_OK == LookupHandlerFromId(pHandlerId,&pHandlerInfo))
    {
        hWndCallback = pHandlerInfo->hWndCallback;
    }

    // review, if handler doesn't have any more error jumps after the deletelogError we can now
    // release it (pHandlerInfo->fHasErrorJumps)

    clockqueue.Leave();

    if (hWndCallback)
    {
        SendMessage(hWndCallback, WM_PROGRESS_DELETELOGERROR, (WPARAM) 0, (LPARAM) &msgDeleteLogError);
    }

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::CallCompletionRoutine, public
//
//  Synopsis:   Called by callback on handler thread
//              to indicate a call with a completion callback
//              has completed.
//
//  Returns:    Appropriate Error code
//
//  Modifies:
//
//  History:    02-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CHndlrQueue::CallCompletionRoutine(HANDLERINFO *pHandlerId,DWORD dwThreadMsg,HRESULT hCallResult,
                                           ULONG cbNumItems,SYNCMGRITEMID *pItemIDs)
{
    HWND hWndDlg = NULL;
    HRESULT hrHandlerCall = S_OK;
    BOOL fCallbackAlreadyCalled = FALSE;
    HANDLERINFO *pHandlerInfo;
    CLock clockqueue(this);

    if (!pHandlerId)
    {
        Assert(pHandlerId);
        return;
    }
    // Note: cbNumItems and pItemIDs is only valid for ShowErrors

    // make sure the handlid is valid and then if there
    // is a pdlg call its completion routine via the postmessage
    // method.

    clockqueue.Enter();

    hWndDlg = m_hwndDlg;
    Assert(hWndDlg);

    if ( pHandlerId && (S_OK == LookupHandlerFromId(pHandlerId,&pHandlerInfo)) )
    {
        // if flag isn't set for the message
        // then it was already handled i.e. handler called
        // us even though it returned an error.

        if (dwThreadMsg & pHandlerInfo->dwOutCallMessages)
        {
            pHandlerInfo->dwOutCallMessages &= ~dwThreadMsg;
        }
        else
        {
            AssertSz(0,"Callback called twice"); // test apps currently do this.
            fCallbackAlreadyCalled = TRUE;
        }

        // if already handled don't call these again.
        if (!fCallbackAlreadyCalled)
        {
            // fix up internal states before informing caller
            // the call is complete.
            switch(dwThreadMsg)
            {
            case ThreadMsg_ShowProperties: // don't need to do anything on show properties.
                break;
            case ThreadMsg_PrepareForSync:
                hrHandlerCall = PrepareForSyncCompleted(pHandlerInfo,hCallResult);
                break;
            case ThreadMsg_Synchronize:
                hrHandlerCall = SynchronizeCompleted(pHandlerInfo,hCallResult);
                break;
            case ThreadMsg_ShowError:
                hrHandlerCall = ShowErrorCompleted(pHandlerInfo,hCallResult,cbNumItems,pItemIDs);
                break;
            default:
                AssertSz(0,"Unknown Queue Completion Callback");
                break;
            }
        }

        // possible completion routine comes in before handler has actually
        // returned from the original call. Wait until proxy is no longer in an
        // out call.
        // If switch to COM for messaging need to find a better way of doing this.

        if (pHandlerInfo->pThreadProxy &&
                pHandlerInfo->pThreadProxy->IsProxyInOutCall()
                && hWndDlg)
        {
            // tell proxy to post the message whenver it gets done.

            // CODE REVIEW:
            // NOTENOTE:
            //  Remove this code..
            /*
            if ( 0 /* S_OK ==
                pHandlerInfo->pThreadProxy->SetProxyCompletion(hWndDlg,WM_BASEDLG_COMPLETIONROUTINE,dwThreadMsg,hCallResult)*)
            {
                hWndDlg = NULL;
            }
            */
        }
    }
    else
    {
        // on handler lookup assert but still post the message to the hwnd
        // so it won't get stuck waiting for the completion routine

        // this is only valid for setproperties in the
        // case the user clicked on a non-existant item but
        // this shouldn't really happen either
        AssertSz(dwThreadMsg == ThreadMsg_ShowProperties,"LookupHandler failed in CompletionRoutine");
    }

    LPCALLCOMPLETIONMSGLPARAM lpCallCompletelParam =  (LPCALLCOMPLETIONMSGLPARAM) ALLOC(sizeof(CALLCOMPLETIONMSGLPARAM));

    if (lpCallCompletelParam)
    {
        lpCallCompletelParam->hCallResult = hCallResult;
        lpCallCompletelParam->clsidHandler = pHandlerId->clsidHandler;

        // itemID is GUID_NULL unless its a ShowProperties completed.
        if ((ThreadMsg_ShowProperties == dwThreadMsg) && (1 == cbNumItems))
        {
            lpCallCompletelParam->itemID = *pItemIDs;
        }
        else
        {
            lpCallCompletelParam->itemID = GUID_NULL;
        }
    }

    clockqueue.Leave();

    if (hWndDlg && !fCallbackAlreadyCalled) // if already out of out call  or proxy failed post the messge ourselves.
    {
        // if alloc of completion lparam fails send message anyways so callback count
        // remains accurate.
        PostMessage(hWndDlg,WM_BASEDLG_COMPLETIONROUTINE,dwThreadMsg,(LPARAM) lpCallCompletelParam);
    }
    else
    {
        // if don't post message up to us to free the lpCallCopmlete.
        if (lpCallCompletelParam)
        {
            FREE(lpCallCompletelParam);
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::IsItemAlreadyInList, private
//
//  Synopsis:   Given a clsid and ItemID determines if a matchin
//              item is already in the list
//              Called in the context of the Handlers thread
//
//  Arguments:  [clsidHandler] - clsid of the handler
//              [ItemID] - ItemID of the item
//              [wHandlerId] - HandlerID of the item.
//              [ppHandlerMatched] - on out the handler that matched
//              [ppItemIdMatch] - on out Item that matched.
//
//  Returns:    Appropriate Error code
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CHndlrQueue::IsItemAlreadyInList(CLSID clsidHandler,REFSYNCMGRITEMID ItemID,
                                      HANDLERINFO *pHandlerId,
                                      LPHANDLERINFO *ppHandlerMatched,
                                      LPITEMLIST *ppItemListMatch)
{
    BOOL fFoundMatch = FALSE;
    LPHANDLERINFO pCurHandlerInfo = NULL;
    LPITEMLIST pCurItem = NULL;

    ASSERT_LOCKHELD(this); // caller of this function should have already locked the queue.

    pCurHandlerInfo = m_pFirstHandler;

    while (pCurHandlerInfo && !fFoundMatch)
    {
        if (pHandlerId == pCurHandlerInfo->pHandlerId) // when find hander know didn't find any before.
            break;

        if (clsidHandler == pCurHandlerInfo->clsidHandler) // see if CLSID matches
        {
            // see if handler info has a matching item
            pCurItem = pCurHandlerInfo->pFirstItem;

            while (pCurItem)
            {
                if (ItemID == pCurItem->offlineItem.ItemID)
                {

                    *ppHandlerMatched = pCurHandlerInfo;
                    *ppItemListMatch = pCurItem;

                    fFoundMatch = TRUE;
                    break;
                }

                pCurItem = pCurItem->pnextItem;
            }
        }
        pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }

    return fFoundMatch;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::GetSelectedItemsInHandler, private
//
//  Synopsis:   Gets the number of selected items for this handler
//
//              for our implementation if a cbCount is passed and it doesn't match
//              the number of actually selected then assert since we call this routine
//              internally.
//
//
//  Arguments:  [pHandlerInfo] - Pointer to the HandlerInfo to look at.
//              [cbcount] - [in] cbCount == number of pItems allocated,
//                          [out] cbCpimt == number of items actually written.
//                                  if the buffer is too small items written will be zero.
//              [pItems] - Pointer to array of SYNCMGRITEMs to be filled in.
//
//  Returns:    Returns the number of selectd items.
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

DWORD CHndlrQueue::GetSelectedItemsInHandler(LPHANDLERINFO pHandlerInfo,ULONG *cbCount,
                                        SYNCMGRITEMID* pItems)
{
    LPITEMLIST pCurItem;
    DWORD dwSelectCount = 0;
    DWORD dwArraySizeIndex;
    DWORD dwArraySize;

    ASSERT_LOCKHELD(this); // caller of this function should have already locked the queue.

    if (cbCount)
    {
        dwArraySizeIndex = *cbCount;
        dwArraySize = *cbCount;
        *cbCount = 0; // initialize to zero.
    }
    else
    {
        dwArraySizeIndex = 0;
        dwArraySize = 0;
    }

    if ( dwArraySize && NULL == pItems)
    {
        Assert(0 == dwArraySize || pItems);
        return 0;
    }

    if (NULL == pHandlerInfo)
    {
        Assert(pHandlerInfo);
        return 0;
    }

    pCurItem = pHandlerInfo->pFirstItem;

    while (pCurItem)
    {
        // dwItemState
        if (SYNCMGRITEMSTATE_CHECKED == pCurItem->offlineItem.dwItemState)
        {
            ++dwSelectCount;

            if (dwArraySizeIndex)
            {
                *pItems = pCurItem->offlineItem.ItemID;
                *cbCount += 1;
                ++pItems;
                --dwArraySizeIndex;

                if (!pCurItem->fHiddenItem) // if not a hidden item
                {
                    Assert(TRUE == pCurItem->fIncludeInProgressBar);
                    Assert(HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE == pCurItem->iProgMaxValue); 

                    // reset iProgValue back to zero since may not be zero if retry came in while still synchronizing.
                    SetItemProgressValues(pCurItem,0,HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE);
                }
                else
                {
                    // if item is hidden,a assert it doesn't have UI
                    Assert(FALSE == pCurItem->fIncludeInProgressBar);
                    Assert(HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE == pCurItem->iProgValue);
                    Assert(HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE == pCurItem->iProgMaxValue); 
                }
                
                pCurItem->fSynchronizingItem = TRUE;  // item is now synchronizing
        
                // once added to the array uncheck the item so on a retry we can just
                // always reset items to checked
                pCurItem->offlineItem.dwItemState = SYNCMGRITEMSTATE_UNCHECKED;
            }
        }
        else
        {
            Assert(FALSE == pCurItem->fSynchronizingItem);
            //  Assert(FALSE == pCurItem->fIncludeInProgressBar); Can be included in progress bar if retry comes in before RemoveFinished is called.
            Assert(HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE == pCurItem->iProgValue);
            Assert(HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE == pCurItem->iProgMaxValue); 
        }

        pCurItem = pCurItem->pnextItem;
    }

    // internal call should always request a proper array size.
    Assert(dwSelectCount == dwArraySize || 0 == dwArraySize);

    return dwSelectCount;
}

// job info methods

STDMETHODIMP CHndlrQueue::CreateJobInfo(JOBINFO **ppJobInfo,DWORD cbNumConnectionNames)
{
    HRESULT hr = S_FALSE;
    JOBINFO *pNewJobInfo = NULL;

    ASSERT_LOCKHELD(this);

    // create a new job and add it to the the JobInfo list.
    // allocate space for JobInfo + number of connection objects that
    // will be associated with this job.

    Assert(cbNumConnectionNames);

    if (cbNumConnectionNames < 1)
        return S_FALSE;

    pNewJobInfo = (JOBINFO *) ALLOC(sizeof(JOBINFO) +
            sizeof(CONNECTIONOBJ)*(cbNumConnectionNames - 1));

    if (pNewJobInfo)
    {
        memset(pNewJobInfo, 0, sizeof(JOBINFO));

        pNewJobInfo->cRefs = 1;
        pNewJobInfo->pNextJobInfo = m_pFirstJobInfo;
        m_pFirstJobInfo = pNewJobInfo;

        *ppJobInfo = pNewJobInfo;

        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

DWORD CHndlrQueue::ReleaseJobInfoExt(JOBINFO *pJobInfo)
{
    DWORD dwRet;
    CLock clockqueue(this);

    clockqueue.Enter();
    dwRet = ReleaseJobInfo(pJobInfo);
    clockqueue.Leave();

    return dwRet;
}

DWORD CHndlrQueue::ReleaseJobInfo(JOBINFO *pJobInfo)
{
    DWORD cRefs;

    ASSERT_LOCKHELD(this);

    --(pJobInfo->cRefs);
    cRefs = pJobInfo->cRefs;

    Assert( ((LONG) cRefs) >= 0);

    if (0 == cRefs)
    {
        JOBINFO *pCurJobInfo = NULL;
        DWORD dwConnObjIndex;

        // loop through release all connection objs on this job
        for (dwConnObjIndex = 0 ; dwConnObjIndex < pJobInfo->cbNumConnectionObjs;
            dwConnObjIndex++)
        {
            Assert(pJobInfo->pConnectionObj[dwConnObjIndex]);
            if (pJobInfo->pConnectionObj[dwConnObjIndex])
            {
                ConnectObj_ReleaseConnectionObj(pJobInfo->pConnectionObj[dwConnObjIndex]);
                pJobInfo->pConnectionObj[dwConnObjIndex] = NULL;
            }
        }

        // remove this JobInfo from the list.
        if (pJobInfo == m_pFirstJobInfo)
        {
            m_pFirstJobInfo = pJobInfo->pNextJobInfo;
        }
        else
        {
            pCurJobInfo = m_pFirstJobInfo;

            while (pCurJobInfo->pNextJobInfo)
            {
                if (pJobInfo == pCurJobInfo->pNextJobInfo)
                {
                   pCurJobInfo->pNextJobInfo =  pJobInfo->pNextJobInfo;
                   break;
                }

                pCurJobInfo = pCurJobInfo->pNextJobInfo;
            }
        }

        FREE(pJobInfo);
    }

    return cRefs;
}

DWORD CHndlrQueue::AddRefJobInfo(JOBINFO *pJobInfo)
{
    DWORD cRefs;

    ASSERT_LOCKHELD(this);

    ++(pJobInfo->cRefs);
    cRefs = pJobInfo->cRefs;

    return cRefs;
}

// determines ifthe specified JobInfo's connection can be openned.
// review should really call into connection Object help api.
STDMETHODIMP CHndlrQueue::OpenConnection(JOBINFO *pJobInfo)
{
    CONNECTIONOBJ *pConnectionObj;
    HRESULT hr;

    Assert(pJobInfo);

    if (NULL == pJobInfo) // if no job info go ahead and say the connection is open.
        return S_OK;

    // turn off workOffline during the sync CloseConnection will turn
    // it back on if the user had it off.
    ConnectObj_SetWorkOffline(FALSE);

    // if this is anything but a schedule go ahead and say S_OK;
    if (!(SYNCMGRFLAG_SCHEDULED == (pJobInfo->dwSyncFlags & SYNCMGRFLAG_EVENTMASK)) )
    {
        return S_OK;
    }

    // for schedule sink we only support one connection Object.
    if (1 != pJobInfo->cbNumConnectionObjs)
    {
        Assert(1 == pJobInfo->cbNumConnectionObjs);
        return E_UNEXPECTED;
    }

    pConnectionObj = pJobInfo->pConnectionObj[0];
    if (NULL == pConnectionObj)
        return S_OK;

    // if we aren't suppose to make a connection of there is already
    // a hRasConn as part of the connection object then just
    // return S_OK;

    // if connection is already open and we are on a job that
    // has already tried to open it then return S_OK;
    if (pJobInfo->pConnectionObj[0]->fConnectionOpen && pJobInfo->fTriedConnection)
        return S_OK;

    // if we haven't already tried to make the connection
    // on this job then call OpenConnection to make sure the
    // connection is still really open.
    if (!pJobInfo->fTriedConnection)
    {
        pJobInfo->fTriedConnection = TRUE;

        hr = ConnectObj_OpenConnection(pConnectionObj, pJobInfo->fCanMakeConnection, m_pDlg);
    }
    else
    {
        hr = S_FALSE;
    }

    // if get down to the bottom and still no hRasConn then return S_FALSE
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::ScrambleIdleHandlers, private
//
//  Synopsis:   Called on an Idle Choice queue just before transfer
//              so the lastHandler is placed at the back of the list.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::ScrambleIdleHandlers(REFCLSID clsidLastHandler)
{
    LPHANDLERINFO pMatchHandler;
    LPHANDLERINFO pLastHandler;
    CLock clockqueue(this);

    Assert(m_QueueType == QUEUETYPE_CHOICE);

    clockqueue.Enter();

    // find the first occurance of specified handler and then place that handler
    // at the end of the list and everything after at the beginning of the list

    // no an error to not find the Handler since may have been deleted or
    // no longer has items.

     pMatchHandler = m_pFirstHandler;

     while (pMatchHandler)
     {
         if (pMatchHandler->clsidHandler == clsidLastHandler)
         {
            // if there are no items after the match then just break;
            if (NULL == pMatchHandler->pNextHandler)
            {
                break;
            }

            // loop until find the last handler.
            pLastHandler = pMatchHandler->pNextHandler;
            while (pLastHandler->pNextHandler)
            {
                pLastHandler = pLastHandler->pNextHandler;
            }

            // now set the handler after the matchHandler to be the
            // head and set the next pointer of the LastHandler in
            // the list to point to the MatchHandler.

            pLastHandler->pNextHandler = m_pFirstHandler;
            m_pFirstHandler = pMatchHandler->pNextHandler;
            pMatchHandler->pNextHandler = NULL;
            break;
         }

        pMatchHandler = pMatchHandler->pNextHandler;
     }

    clockqueue.Leave();

    return S_OK;
}



//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::BeginSyncSession
//
//  Synopsis:   Called to signal the beginning of the core synchronization session
//              to setup up dial support.
//
//  History:    28-Jul-98       SitaramR        Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::BeginSyncSession()
{
    HRESULT hr = ::BeginSyncSession();
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::EndSyncSession
//
//  Synopsis:   Called to signal the end of the core synchronization session
//              to teardown dial support.
//
//  History:    28-Jul-98       SitaramR        Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::EndSyncSession()
{
    HRESULT hr = ::EndSyncSession();
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::SortHandlersByConnection
//
//  Synopsis:   Moves hanlders that won't establish connection to the end,
//              ie after handlers that can establish connectoin.
//
//  History:    28-Jul-98       SitaramR        Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::SortHandlersByConnection()
{
    CLock clockqueue(this);
    clockqueue.Enter();

    Assert(m_QueueType == QUEUETYPE_CHOICE);

    LPHANDLERINFO pFirstCannotDialHandler = NULL;
    LPHANDLERINFO pLastCannotDialHandler = NULL;

    LPHANDLERINFO pPrevHandler = NULL;
    LPHANDLERINFO pCurHandler = m_pFirstHandler;

    while ( pCurHandler )
    {
        if ( pCurHandler->SyncMgrHandlerInfo.SyncMgrHandlerFlags & SYNCMGRHANDLER_MAYESTABLISHCONNECTION )
        {
            //
            // Move to next handler
            //
            pPrevHandler = pCurHandler;
            pCurHandler = pCurHandler->pNextHandler;
        }
        else
        {
            //
            // Move handler to cannot dial list
            //
            if ( pPrevHandler == NULL )
            {
                //
                // This is the first handler in list
                //
                m_pFirstHandler = pCurHandler->pNextHandler;
                pCurHandler->pNextHandler = NULL;

                if ( pLastCannotDialHandler == NULL )
                {
                    Assert( pFirstCannotDialHandler == NULL );
                    pFirstCannotDialHandler = pLastCannotDialHandler = pCurHandler;
                }
                else
                {
                    pLastCannotDialHandler->pNextHandler = pCurHandler;
                    pLastCannotDialHandler = pCurHandler;
                }

                pCurHandler = m_pFirstHandler;
            }
            else
            {
                pPrevHandler->pNextHandler = pCurHandler->pNextHandler;
                pCurHandler->pNextHandler = NULL;

                if ( pLastCannotDialHandler == NULL )
                {
                    Assert( pFirstCannotDialHandler == NULL );
                    pFirstCannotDialHandler = pLastCannotDialHandler = pCurHandler;
                }
                else
                {
                    pLastCannotDialHandler->pNextHandler = pCurHandler;
                    pLastCannotDialHandler = pCurHandler;
                }

                pCurHandler = pPrevHandler->pNextHandler;
            }
        }
    }

    //
    // Attach cannot dial list at end of m_pFirstHandler list
    //
    if ( pPrevHandler )
    {
        Assert( pPrevHandler->pNextHandler == NULL );
        pPrevHandler->pNextHandler = pFirstCannotDialHandler;
    }
    else
    {
        //
        // Case where the original list became empty
        //
        Assert( m_pFirstHandler == NULL );
        m_pFirstHandler = pFirstCannotDialHandler;
    }

    clockqueue.Leave();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::EstablishConnection
//
//  Synopsis:   Called by handler to establish a connection.
//
//  Arguments:  [pHandlerID]      -- Ptr to handler
//              [lpwszConnection] -- Connection to establish
//              [dwReserved]      -- Must be zero for now
//
//  History:    28-Jul-98       SitaramR        Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::EstablishConnection( LPHANDLERINFO pHandlerID,
                                               WCHAR const * lpwszConnection,
                                               DWORD dwReserved )
{
    HRESULT hr = S_OK;

    CLock clockqueue(this);

    clockqueue.Enter();

    CONNECTIONOBJ *pConnObj = NULL;
    BOOL fAutoDial = FALSE;

    LPHANDLERINFO pHandlerInfo = NULL;
    hr = LookupHandlerFromId( pHandlerID, &pHandlerInfo );

    if ( S_OK == hr )
    {
        JOBINFO *pJobInfo = pHandlerInfo->pJobInfo;
        DWORD dwSyncFlags = pJobInfo->dwSyncFlags & SYNCMGRFLAG_EVENTMASK;
        if ( ( dwSyncFlags == SYNCMGRFLAG_MANUAL || dwSyncFlags == SYNCMGRFLAG_INVOKE )
             && pHandlerInfo->SyncMgrHandlerInfo.SyncMgrHandlerFlags & SYNCMGRHANDLER_MAYESTABLISHCONNECTION )
        {
            if ( lpwszConnection == NULL )
            {
                //
                // Null connection means use the default autodial connection
                //
                fAutoDial = TRUE;
            }
            else
            {
                hr = ConnectObj_FindConnectionObj(lpwszConnection,TRUE,&pConnObj);
            }
        }
        else
        {
            //
            // Either the handler invoke type does not permit establishing connection,
            // or GetHandlerInfo flags did not specify the EstablishConnection flag.
            //
            hr = E_UNEXPECTED;
        }
    }

    clockqueue.Leave();

    if (S_OK == hr)
    {
        if (fAutoDial)
        {
            hr = ConnectObj_AutoDial(INTERNET_AUTODIAL_FORCE_ONLINE,m_pDlg);
        }
        else
        {
            Assert( pConnObj );
            if ( !pConnObj->fConnectionOpen )
            {
                hr = ConnectObj_OpenConnection(pConnObj, TRUE, m_pDlg );
                ConnectObj_ReleaseConnectionObj(pConnObj);
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\exe\hndlrq.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Hndlrq.h
//
//  Contents:   Keeps tracks of Handlers and UI assignments
//
//  Classes:    CHndlrQueue
//
//  Notes:
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#ifndef _HANDLERQUEUE_
#define _HANDLERQUEUE_

//  For Choice dialog If same item is added again first one their wins.
//  This handles the case if user previously chose properties. duplicate items
//  will be set to not synchronize even if the preference is set. this is
//  the defined behavior for AddHandlerItemsToQueue.
//
//  Progress dialog all items get synchronized as they were added. To move
//  items to the Progress queue always use the TransferQueueData method. If Item
//  was previously skipped what should we do?


// Also need routines for registering Choice and Progress dialogs.
class CBaseDlg;
class CChoiceDlg;
class CLock;
class CThreadMsgProxy;
class CHndlrMsg;

// state the handler should go to next
// note: any items with a HandlerState other than choice in a TransferQueueData
//          will be released asserting the HANDLERSTATE_RELEASE or HANDLERSTATE_DEAD
//          state is set.

typedef enum _tagHANDLERSTATE
{
    HANDLERSTATE_NEW                    = 0x00, // state is initialized to this.
    HANDLERSTATE_CREATE                 = 0x01, // state is initialized to this.
    HANDLERSTATE_INCREATE               = 0x02, // state is initialized to this.
    HANDLERSTATE_INITIALIZE             = 0x03, // set after a successfull creation.
    HANDLERSTATE_ININITIALIZE           = 0x04, // set during initialization call
    HANDLERSTATE_ADDHANDLERTEMS         = 0x05,  // items need to be enumerated
    HANDLERSTATE_INADDHANDLERITEMS      = 0x06, // in the items enumerator
    HANDLERSTATE_PREPAREFORSYNC         = 0x07, // set during queue tranfers
    HANDLERSTATE_INPREPAREFORSYNC       = 0x08, // handler is currently in a prepfosync call.
    HANDLERSTATE_INSETCALLBACK          = 0x09, // within a setcallback call.
    HANDLERSTATE_SYNCHRONIZE            = 0x0A, // Prepare for Sync set this if successfull
    HANDLERSTATE_INSYNCHRONIZE          = 0x0B, // item is currently in a synchronize call
    HANDLERSTATE_HASERRORJUMPS          = 0x0C, // if synchronize returned but error has jumps
    HANDLERSTATE_INHASERRORJUMPS        = 0x0D, // this handleris in a has jumps call
    HANDLERSTATE_RELEASE                = 0x0E, // Handler can be released, set on error or after success
    HANDLERSTATE_TRANSFERRELEASE        = 0x0F, // Handler can be released, was transferred into the queue but nothing to do.
    HANDLERSTATE_DEAD                   = 0x10, // handler has been released. Data Stays around.
}  HANDLERSTATE;

typedef enum _tagQUEUETYPE
{
    QUEUETYPE_CHOICE                    = 0x1, //
    QUEUETYPE_PROGRESS                  = 0x2, //
    QUEUETYPE_SETTINGS                  = 0x3, //
} QUEUETYPE;

// Job info list is assigned to each new item added to the hndlrqueu
// keeps track of number of handlers attached to JobInfo, Initialize
// flags, schedule name
// Progress queue keeps a linked list.

typedef struct _JOBINFO  {
    struct _JOBINFO *pNextJobInfo;
    struct _JOBINFO *pTransferJobInfo; // used in queue transfer.
    DWORD cRefs;
    DWORD dwSyncFlags; // standard sync flags
    TCHAR szScheduleName[MAX_PATH + 1]; 
    BOOL fCanMakeConnection; // Job is allowed to dial the connection.
    BOOL fTriedConnection; // Job already tried to dial the connection.
    DWORD cbNumConnectionObjs;
    CONNECTIONOBJ *pConnectionObj[1]; // array of cbNumConnecObjs associated with this job.
} JOBINFO;



typedef struct _ITEMLIST
{
    struct _ITEMLIST* pnextItem;
    WORD  wItemId;              // Id that uniquely identifies Item within a handler.
    void *pHandlerInfo;         // pointer to the handler that owns this item
    SYNCMGRITEM offlineItem;    // enumerator structure item returned
    BOOL fItemCancelled;        // when set poper code should be returned to progress.
    BOOL fDuplicateItem;        // when set to true indicates there was already an existing item of this handler and item.
    BOOL fIncludeInProgressBar; // if set to true items ProgValues are added to the progress bar.
    BOOL fProgressBarHandled;   // Used internally by GetProgressInfo for calculating num items of num items completed
    INT iProgValue;             // current progress value.
    INT iProgMaxValue;          // current progress max value.
    BOOL fProgValueDirty;       // set to true if Normalized Progress Value needs to be recalced.
    INT iProgValueNormalized;      // current progress  value normalized
    DWORD dwStatusType;         // status type from last callback.
    BOOL fHiddenItem;       // flag set it Item was added by ShowErrors returning nonItem.
    BOOL fSynchronizingItem;      // flag set while item has been selected for prepareForSync/synchronize.
} ITEMLIST;
typedef ITEMLIST* LPITEMLIST;

typedef struct _HANDLERINFO {
    struct _HANDLERINFO *pNextHandler;
    DWORD dwCallNestCount;
    struct _HANDLERINFO *pHandlerId;        // Id that uniquely identifies this instance of the Handler
    CLSID clsidHandler;             // CLSID of the handler Handler
    DWORD    dwRegistrationFlags; // flags as item is registered
    SYNCMGRHANDLERINFO SyncMgrHandlerInfo; // copy of handler info GetHandlerInfo Call
    HANDLERSTATE HandlerState;
    HWND hWndCallback; //  hWnd to send callback information to.
    BOOL fHasErrorJumps; // BOOL if can call ShowErrors then don't release on completion of sync.
    BOOL fInShowErrorCall; // bool to indicate if handler is currently handling a ShowError Call.
    BOOL fInTerminateCall; // bool to indicate if handler is currently handling a ShowError Call.
    CThreadMsgProxy *pThreadProxy;
    DWORD dwOutCallMessages; // out call messages we are currenlty handling.
    WORD wItemCount;
    BOOL fCancelled; // This Handler was Cancelled by the User.
    BOOL fRetrySync; // retrySync was requested while before this items synchronization was done.
    LPITEMLIST pFirstItem;          // ptr to first Item of the handler in the list.
    JOBINFO *pJobInfo;
} HANDLERINFO;
typedef HANDLERINFO* LPHANDLERINFO;


#define MAXPROGRESSVALUE 3000 // maximum absolute progress bar value

class CHndlrQueue : CLockHandler {

    private:
        // review when eat up all the available IDs
        LPHANDLERINFO m_pFirstHandler;
        JOBINFO     *m_pFirstJobInfo; // pointer to first job.
        HWND m_hwndDlg; // hwnd to dialog that owns the queue.
        CBaseDlg *m_pDlg; // pointer to dialog that owns the queue.
        WORD m_wHandlerCount; // number of handlers in this queue
        QUEUETYPE m_QueueType; // type of queue this is.
        DWORD m_dwQueueThreadId; // Thread that queue was created on.
        DWORD m_dwShowErrororOutCallCount; // number of handlers currently stuck in a ShowError Call.
        BOOL m_fInCancelCall; // Don't allow Cancel to be re-entrant
        DWORD m_cRefs;
        BOOL  m_fItemsMissing;         // set if any handlers have missing items.
        INT   m_iNormalizedMax; // last calculated Max Value in GetProgressInfo
        BOOL  m_fNumItemsCompleteNeedsARecalc; // Need to recalulate the number of items complete.
        BOOL  m_iItemCount; // Total Number of  Items as shown in progress.
        BOOL  m_iCompletedItems; // Number of Completed Items..
        ULONG m_ulProgressItemCount; //  total count of Items in cache included with progress.

    public:
        CHndlrQueue(QUEUETYPE QueueType,CBaseDlg *pDlg);
        ~CHndlrQueue();

        STDMETHODIMP_(ULONG)    AddRef();
        STDMETHODIMP_(ULONG)    Release();

        // main queue routines
        STDMETHODIMP AddHandler(HANDLERINFO **ppHandlerId,JOBINFO *pJobInfo,DWORD dwRegistrationFlags);
        STDMETHODIMP Cancel(void);
        STDMETHODIMP ForceKillHandlers(BOOL *pfItemToKill);
        STDMETHODIMP TransferQueueData(CHndlrQueue *pQueueMoveFrom);
        STDMETHODIMP SetQueueHwnd(CBaseDlg *pDlg);
        STDMETHODIMP ReleaseCompletedHandlers(void);
        BOOL AreAnyItemsSelectedInQueue(); // walks through seeing if any items are selected for sync.
        STDMETHODIMP FreeAllHandlers(void); // frees all handlers associated with the queue.

        STDMETHODIMP GetHandlerInfo(REFCLSID clsidHandler,LPSYNCMGRHANDLERINFO pSyncMgrHandlerInfo);
        STDMETHODIMP GetHandlerInfo(HANDLERINFO *pHandlerId,LPSYNCMGRHANDLERINFO pSyncMgrHandlerInfo);
        STDMETHODIMP GetItemDataAtIndex(HANDLERINFO *pHandlerId,WORD wItemID,CLSID *pclsidHandler,
                                            SYNCMGRITEM* offlineItem,BOOL *pfHiddenItem);
        STDMETHODIMP GetItemDataAtIndex(HANDLERINFO *pHandlerId,REFSYNCMGRITEMID ItemID,CLSID *pclsidHandler,
                                            SYNCMGRITEM* offlineItem,BOOL *pfHiddenItem);

        // new methods for walking through ListView relying on clsid and itemID
	STDMETHODIMP FindFirstItemInState(HANDLERSTATE hndlrState,HANDLERINFO **ppHandlerId,WORD *wItemID);
	STDMETHODIMP FindNextItemInState(HANDLERSTATE hndlrState,HANDLERINFO *pLastHandlerId,WORD wLastItemID,
						     HANDLERINFO **ppHandlerId,WORD *wItemID);

        STDMETHODIMP SetItemState(REFCLSID clsidHandler,REFSYNCMGRITEMID ItemID,DWORD dwState); 
	STDMETHODIMP ItemHasProperties(REFCLSID clsidHandler,REFSYNCMGRITEMID ItemID);  // determines if there are properties associated with this item.
	STDMETHODIMP ShowProperties(REFCLSID clsidHandler,REFSYNCMGRITEMID ItemID,HWND hwndParent);	    // show properties for this listView Item.
        STDMETHODIMP ReEnumHandlerItems(REFCLSID clsidHandler,REFSYNCMGRITEMID ItemID);
	STDMETHODIMP SkipItem(REFCLSID clsidHandler,REFSYNCMGRITEMID ItemID); // skip this item

        // methods for handling the progress and Items complete
        STDMETHODIMP GetProgressInfo(INT *iProgValue,INT *iMaxValue,INT *iNumItemsComplete,
                                            INT *iNumItemsTotal);
        STDMETHODIMP SetItemProgressInfo(HANDLERINFO *pHandlerId,WORD wItemID,
                                                LPSYNCMGRPROGRESSITEM pSyncProgressItem,
                                                BOOL *pfProgressChanged);
        STDMETHODIMP RemoveFinishedProgressItems(); // walks through list marking any
                                                     // finished items as fIncludeInProgressBar==FALSE;

        STDMETHODIMP PersistChoices(void); // persists choices for next time.

        // For finding Handlers that meet specific state requirements
        STDMETHODIMP FindFirstHandlerInState(HANDLERSTATE hndlrState,
                        REFCLSID clsidHandler,HANDLERINFO **ppHandlerId,CLSID *pMatchHandlerClsid);
        STDMETHODIMP FindNextHandlerInState(HANDLERINFO *pLastHandlerID,
                            REFCLSID clsidHandler,HANDLERSTATE hndlrState,HANDLERINFO **ppHandlerId
                            ,CLSID *pMatchHandlerClsid);

        // functions for calling through the items proxy.
        STDMETHODIMP CreateServer(HANDLERINFO *pHandlerId, const CLSID *pCLSIDServer);
        STDMETHODIMP Initialize(HANDLERINFO *pHandlerId,DWORD dwReserved,DWORD dwSyncFlags,
                            DWORD cbCookie,const BYTE *lpCooke);
        STDMETHODIMP AddHandlerItemsToQueue(HANDLERINFO *pHandlerId,DWORD *pcbNumItems);
        STDMETHODIMP GetItemObject(HANDLERINFO *pHandlerId,WORD wItemID,REFIID riid,void** ppv);
        STDMETHODIMP SetUpProgressCallback(HANDLERINFO *pHandlerId,BOOL fSet,HWND hwnd); // TRUE == create, FALSE == destroy. Callback info should be sent to specified hwnd.
        STDMETHODIMP PrepareForSync(HANDLERINFO *pHandlerId,HWND hWndParent);
        STDMETHODIMP Synchronize(HANDLERINFO *pHandlerId,HWND hWndParent);
        STDMETHODIMP ShowError(HANDLERINFO *pHandlerId,HWND hWndParent,REFSYNCMGRERRORID ErrorID);

        // callback proxy functions
        STDMETHODIMP IsAllHandlerInstancesCancelCompleted(REFCLSID clsidHandler);

        // functions called from Handler Thread
        STDMETHODIMP SetHandlerInfo(HANDLERINFO *pHandlerId,LPSYNCMGRHANDLERINFO pSyncMgrHandlerInfo);
        STDMETHODIMP AddItemToHandler(HANDLERINFO *pHandlerId,LPSYNCMGRITEM pOffineItem);
        STDMETHODIMP Progress(HANDLERINFO *pHandlerId,REFSYNCMGRITEMID ItemID,LPSYNCMGRPROGRESSITEM lpSyncProgressItem);
        STDMETHODIMP LogError(HANDLERINFO *pHandlerId,DWORD dwErrorLevel,const WCHAR *lpcErrorText,LPSYNCMGRLOGERRORINFO lpSyncLogError);
        STDMETHODIMP DeleteLogError(HANDLERINFO *pHandlerId,REFSYNCMGRERRORID ErrorID,DWORD dwReserved);
        void CallCompletionRoutine(HANDLERINFO *pHandlerId,DWORD dwThreadMsg,HRESULT hr,
                                ULONG cbNumItems,SYNCMGRITEMID *pItemIDs);

        // internal queue handler of method calls with completion
        // routines. can be called on either handler or dlg owner thread
        // on error from calls completion routine is still invoked for
        // the convenience of the caller to never have to worry about it.
        STDMETHODIMP PrepareForSyncCompleted(LPHANDLERINFO pHandlerInfo,HRESULT hCallResult);
        STDMETHODIMP SynchronizeCompleted(LPHANDLERINFO pHandlerInfo,HRESULT hCallResult);
        STDMETHODIMP ShowErrorCompleted(LPHANDLERINFO pHandlerInfo,HRESULT hCallResult,ULONG cbNumItems,SYNCMGRITEMID *pItemIDs);

        STDMETHODIMP AddQueueJobInfo(DWORD dwSyncFlags, DWORD cbNumConnectionNames,
                                    TCHAR **ppConnectionNames,TCHAR *pszScheduleName,BOOL fCanMakeConnection
                                     ,JOBINFO **ppJobInfo);

        DWORD ReleaseJobInfoExt(JOBINFO *pJobInfo);


        // state transition functions
        STDMETHODIMP CancelQueue(void); // put queue into cancel mode.
        STDMETHODIMP ScrambleIdleHandlers(REFCLSID clsidLastHandler);

        // Handler dial support functinos
        STDMETHODIMP BeginSyncSession();
        STDMETHODIMP EndSyncSession();
        STDMETHODIMP SortHandlersByConnection();
        STDMETHODIMP EstablishConnection( LPHANDLERINFO pHandlerID,
                                          WCHAR const * lpwszConnection,
                                          DWORD dwReserved );

    private:
        // private functions for finding proper handlers and items.
        LPITEMLIST AllocNewHandlerItem(LPHANDLERINFO pHandlerInfo,SYNCMGRITEM *pOfflineItem);
	STDMETHODIMP LookupHandlerFromId(HANDLERINFO *pHandlerId,LPHANDLERINFO *pHandlerInfo);
        STDMETHODIMP FindItemData(CLSID clsidHandler,REFSYNCMGRITEMID OfflineItemID,
                                         HANDLERSTATE hndlrStateFirst,HANDLERSTATE hndlrStateLast,
                                         LPHANDLERINFO *ppHandlerInfo,LPITEMLIST *ppItem);

	BOOL IsItemAlreadyInList(CLSID clsidHandler,REFSYNCMGRITEMID ItemID,
                                                    HANDLERINFO *pHandlerId,
                                                    LPHANDLERINFO *ppHandlerMatched,
                                                    LPITEMLIST *ppItemListMatch);
        STDMETHODIMP MoveHandler(CHndlrQueue *pQueueMoveFrom,
                        LPHANDLERINFO pHandlerInfoMoveFrom,HANDLERINFO **pHandlerId,
                        CLock *pclockQueue);
        DWORD GetSelectedItemsInHandler(LPHANDLERINFO pHandlerInfo,ULONG *cbCount,
                                        SYNCMGRITEMID* pItems);
        BOOL IsItemCompleted(LPHANDLERINFO pHandler,LPITEMLIST pItem);
        STDMETHODIMP ReleaseHandlers(HANDLERSTATE HandlerState); // Releases handlers that are no longer neededfs

        // items to handle maintain JobInfo items.
        STDMETHODIMP CreateJobInfo(JOBINFO **ppJobInfo,DWORD cbNumConnectionNames);
        DWORD AddRefJobInfo(JOBINFO *pJobInfo);
        DWORD ReleaseJobInfo(JOBINFO *pJobInfo);

        STDMETHODIMP ForceCompleteOutCalls(LPHANDLERINFO pCurHandler);

        // connection help routines
        STDMETHODIMP OpenConnection(JOBINFO *pJobInfo);

        // helper function for setting item ProgressInfo
        STDMETHODIMP SetItemProgressInfo(LPITEMLIST pItem,
                                        LPSYNCMGRPROGRESSITEM pSyncProgressItem,
                                        BOOL *pfProgressChanged);
        STDMETHODIMP SetItemProgressValues(LPITEMLIST pItem,INT iProgValue,INT iProgMaxValue);


    friend CHndlrMsg;
};

// helper functions
BOOL IsValidSyncProgressItem(LPSYNCMGRPROGRESSITEM lpProgItem);
BOOL IsValidSyncLogErrorInfo(DWORD dwErrorLevel,const WCHAR *lpcErrorText,LPSYNCMGRLOGERRORINFO lpSyncLogError);


#endif // _HANDLERQUEUE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\exe\invoke.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Invoke.cpp
//
//  Contents:   Handles invocation cases, ENS, Schedule, etc.
//
//  Classes:    CSynchronizeInvoke
//
//  Notes:
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

// Review - Need to figure out logon logic. This just prevents ConnectionMade
// events from being handled while we are in logon. If IsNetworkAlive becomse async
// or someone calls IsNetworkAlive before us we will sync the same items twice.
BOOL g_InAutoSync = FALSE;
extern HINSTANCE g_hInst;      // current instance

//+---------------------------------------------------------------------------
//
//  Member:     CSynchronizeInvoke::CSynchronizeInvoke, public
//
//  Synopsis:   Constructor
//              Increments the applications lifetime
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

CSynchronizeInvoke::CSynchronizeInvoke()
{
    m_cRef = 1;
    m_pUnkOuter = &m_Unknown; // only support our unknown for know.
    m_pITypeInfoLogon = NULL;
    m_pITypeInfoNetwork = NULL;

    m_Unknown.SetParent(this);

#ifdef _SENS
    m_PrivSensNetwork.SetParent(this);
    m_PrivSensLogon.SetParent(this);
#endif // _SENS

    AddRefOneStopLifetime(TRUE /*External*/);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSynchronizeInvoke::~CSynchronizeInvoke, public
//
//  Synopsis:   Destructor
//              Decrements the applications lifetime
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

CSynchronizeInvoke::~CSynchronizeInvoke()
{
    if (m_pITypeInfoLogon)
    {
        m_pITypeInfoLogon->Release();
        m_pITypeInfoLogon = NULL;
    }

    if (m_pITypeInfoNetwork)
    {
        m_pITypeInfoNetwork->Release();
        m_pITypeInfoNetwork = NULL;
    }

    ReleaseOneStopLifetime(TRUE /*External*/);
}


//+---------------------------------------------------------------------------
//
//  Member:     CSynchronizeInvoke::QueryInterface, public
//
//  Synopsis:   Standard QueryInterface
//
//  Arguments:  [iid] - Interface ID
//              [ppvObj] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CSynchronizeInvoke::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    return m_pUnkOuter->QueryInterface(riid,ppv);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSynchronizeInvoke::AddRef, public
//
//  Synopsis:   Add reference
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CSynchronizeInvoke::AddRef()
{
    return m_pUnkOuter->AddRef();
}


//+---------------------------------------------------------------------------
//
//  Member:     CSychrononizeInvoke::Release, public
//
//  Synopsis:   Release reference
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CSynchronizeInvoke::Release()
{
    return m_pUnkOuter->Release();
}

//+---------------------------------------------------------------------------
//
//  Member:     CSynchronizeInvoke::UpdateItems, public
//
//  Synopsis:   Handles a programmatic UpdateItems call.
//
//              !!Warning - Liveness relies on a dialog being created
//                      before return or we could go away when the
//                      caler releases our interface.
//
//  Arguments:  [dwInvokeFlags] - InvokeFlags
//              [rclsid] - clsid of handler to load
//              [cbCookie] - Size of cookie data
//              [lpCookie] - Ptr to cookie data.
//
//  Returns:    Appropriate error codes
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CSynchronizeInvoke::UpdateItems(DWORD dwInvokeFlags,REFCLSID rclsid,
                                                        DWORD cbCookie,const BYTE*lpCookie)
{
    HRESULT hr = E_OUTOFMEMORY;
    CHndlrQueue * pHndlrQueue = NULL;
    HANDLERINFO *pHandlerID;
    JOBINFO *pJobInfo = NULL;
    BOOL fReg;
    DWORD dwRegistrationFlags;
    int nCmdShow = (dwInvokeFlags & SYNCMGRINVOKE_MINIMIZED) ? SW_SHOWMINIMIZED : SW_SHOWNORMAL;

    // when a new UpdateItems come through do the following
    //  1 - If should display choices see if existing choice dialog or create a new one
    //          and then add the new items to the choice queue

    //  2 - If shouldn't display choices see if existing progress or create a new one
    //          and then add the items to the progress queue.

    // behavior - If already an Update All choice dialog just pull it to the Front
    //            If Already an UpdateAll progress bar bring it to the front
    //            If Progress Bar but doesn't already contain an updateAll create the choice dialog.


    // we don't use stored preferences on invoke so doesn't matter what pass in as the connection
    pHndlrQueue = new CHndlrQueue(QUEUETYPE_CHOICE,NULL);  

    if (NULL == pHndlrQueue)
    {
        hr =  E_OUTOFMEMORY;
        return hr;
    }

    // attempt to initialize the queue
    hr = pHndlrQueue->AddQueueJobInfo(
                SYNCMGRFLAG_INVOKE | SYNCMGRFLAG_MAYBOTHERUSER,
                0,NULL,NULL,FALSE,&pJobInfo);

    fReg = RegGetHandlerRegistrationInfo(rclsid,&dwRegistrationFlags);
    Assert(fReg || (0 == dwRegistrationFlags));

    if ( (S_OK == hr) && (S_OK == pHndlrQueue->AddHandler(&pHandlerID,pJobInfo,dwRegistrationFlags)) )
    {
        hr = pHndlrQueue->CreateServer(pHandlerID,&rclsid);

        if (S_OK == hr)
        {
            hr = pHndlrQueue->Initialize(pHandlerID,0,SYNCMGRFLAG_INVOKE | SYNCMGRFLAG_MAYBOTHERUSER,
                                    cbCookie,lpCookie);
        }
    }

    // can release our reference on the job info
    if (pJobInfo)
    {
        pHndlrQueue->ReleaseJobInfoExt(pJobInfo);
        pJobInfo = NULL;
    }

    if (S_OK == hr)
    {
        DWORD cbNumItemsAdded;

        hr = pHndlrQueue->AddHandlerItemsToQueue(pHandlerID,&cbNumItemsAdded);

        if (SYNCMGRINVOKE_STARTSYNC & dwInvokeFlags)
        {
            // if start invoke need to add the handlers items to the queue before
            // transferring

            if ( (S_OK == hr) && (pHndlrQueue->AreAnyItemsSelectedInQueue()) )
            {
                CProgressDlg *pProgressDlg;

                hr = FindProgressDialog(GUID_NULL,TRUE,nCmdShow,&pProgressDlg);

                if (S_OK == hr)
                {
                    hr = pProgressDlg->TransferQueueData(pHndlrQueue);
                    ReleaseProgressDialog(GUID_NULL,pProgressDlg,FALSE);
                }
            }

            pHndlrQueue->FreeAllHandlers(); // done with our queue.

            pHndlrQueue->Release();
            pHndlrQueue = NULL;
        }
        else
        {
            CChoiceDlg *pChoiceDlg;

           // Bring up the Choice dialog, Let choice dialog actually addes the hanlder items
           // if there are any so in the future we can async fill in the choices

           hr = FindChoiceDialog(rclsid,TRUE,nCmdShow,&pChoiceDlg);

           if (S_OK == hr)
           {
                if (FALSE == pChoiceDlg->SetQueueData(rclsid,pHndlrQueue) ) 
                {
                    pHndlrQueue->FreeAllHandlers();

                    pHndlrQueue->Release();

                    pHndlrQueue = NULL;
                    hr =  E_UNEXPECTED;
                }

                ReleaseChoiceDialog(rclsid,pChoiceDlg);
           }
        }
    }
    else
    {
        // if initialize failed and have a queue release it now.

        if (pHndlrQueue)
        {
            pHndlrQueue->FreeAllHandlers();
            pHndlrQueue->Release();
            pHndlrQueue = NULL;
        }
    }

   // if we successfully added a jobinfo to the queue release our reference.

   return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSynchronizeInvoke::UpdateAll, public
//
//  Synopsis:   Handles a programmatic UpdateAll call.
//
//  Arguments:
//
//  Returns:    Appropriate error codes
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CSynchronizeInvoke::UpdateAll(void)
{
    HRESULT hr = S_OK;
    TCHAR pConnectName[RAS_MaxEntryName + 1];
    TCHAR *pConnectionNameArray;

    if (!LoadString(g_hInst, IDS_LAN_CONNECTION, pConnectName, ARRAYSIZE(pConnectName)))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        return hr;
    }

    pConnectionNameArray = pConnectName;

    // Review - Do we Need proper connection or do we always just
    //  use the last items selected in a manual sync regardless
    //  of the current connection

    return PrivUpdateAll(0, SYNCMGRFLAG_MANUAL | SYNCMGRFLAG_MAYBOTHERUSER, 0, NULL,
                        1, &pConnectionNameArray, NULL, FALSE, NULL, 0, 0, FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CSynchronizeInvoke::Logon, public
//
//  Synopsis:   Handles a Logon notification
//
//  Arguments:
//
//  Returns:    Appropriate error codes
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CSynchronizeInvoke::Logon()
{
    HRESULT hr = E_UNEXPECTED;

    RegSetUserDefaults(); // Make Sure the UserDefaults are up to date

    // if on Win9x just call IsNetworkAlive and rely on ConnectionMade
    // events coming through. Can't just do this yet on NT 5.0 because 
    // not guaranteed to get connectionMades on each logon.

    hr = PrivHandleAutoSync(SYNCMGRFLAG_CONNECT | SYNCMGRFLAG_MAYBOTHERUSER);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSynchronizeInvoke::Logoff, public
//
//  Synopsis:   Handles a Logoff notification
//
//  Arguments:
//
//  Returns:    Appropriate error codes
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CSynchronizeInvoke::Logoff()
{
    HRESULT hr = E_UNEXPECTED;

    RegSetUserDefaults(); // Make Sure the UserDefaults are up to date

    hr = PrivHandleAutoSync(SYNCMGRFLAG_PENDINGDISCONNECT | SYNCMGRFLAG_MAYBOTHERUSER);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSynchronizeInvoke::Schedule, public
//
//  Synopsis:   Handles a shceduled notification
//
//  Arguments:
//
//  Returns:    Appropriate error codes
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

const TCHAR c_szTrayWindow[]            = TEXT("Shell_TrayWnd");

STDMETHODIMP CSynchronizeInvoke::Schedule(WCHAR *pszTaskName)
{
    HRESULT hr = E_UNEXPECTED;
    TCHAR szConnectionName[RAS_MaxEntryName + 1];
    TCHAR *pszConnectionName = szConnectionName;
    CONNECTIONSETTINGS ConnectionSettings;

    if (!pszTaskName)
    {
        Assert(pszTaskName);
        return E_INVALIDARG;
    }

    // validate this is a valid schedule and if no registry data for 
    // it then delete the .job file. 
    // Get the UserName key from the TaskName itself since on NT schedules
    // can fire if User provided as Password as a different user thant the 
    // current user.

    int OffsetToUserName = lstrlen(WSZGUID_IDLESCHEDULE)
                                    + 1; // +1 for _ char between guid and user name.

    WCHAR *pszDomainAndUser = pszTaskName + OffsetToUserName;
    HKEY hkeySchedSync,hkeyDomainUser,hkeySchedName;
    LONG lRegResult;

    hkeySchedSync = hkeyDomainUser = hkeySchedName = NULL;

     // open up keys ourselves so 
    lRegResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE,SCHEDSYNC_REGKEY,0,KEY_READ, &hkeySchedSync);

    if (ERROR_SUCCESS == lRegResult)
    {
        lRegResult = RegOpenKeyEx (hkeySchedSync,pszDomainAndUser,0,KEY_READ, &hkeyDomainUser);
    }

    if (ERROR_SUCCESS == lRegResult)
    {
        lRegResult = RegOpenKeyEx (hkeyDomainUser,pszTaskName,0,KEY_READ, &hkeySchedName);
    }

    // close up the keys
    if (hkeySchedName) RegCloseKey(hkeySchedName);
    if (hkeyDomainUser) RegCloseKey(hkeyDomainUser);
    if (hkeySchedSync) RegCloseKey(hkeySchedSync);

    // if any of the keys are bad then nix the TS file and return;
    if ( ERROR_FILE_NOT_FOUND  == lRegResult)
    {
        // TODO: Call function to delete this .job file when
        // it is implemented for now just let it fire each time.

        return E_UNEXPECTED;
    }

    // assert is just so it fires if a new Error code occurs
    // so we make sure we handle it properly

    Assert(ERROR_SUCCESS == lRegResult);

    // check to see if this is really and idle and if so foward on to Idle
    // method

    WCHAR *pszSchedCookieIdle = WSZGUID_IDLESCHEDULE;
    int comparelength = (sizeof(WSZGUID_IDLESCHEDULE)/sizeof(WCHAR)) -1; // don't compare null

    // set the Idle flag instead
    if (0 == StrCmpNI(pszSchedCookieIdle, pszTaskName, comparelength))
    {
        return Idle();
    }

    // finally made it past verification if you can get a Connection
    // you can run the schedule.

    if (RegGetSchedConnectionName(pszTaskName,pszConnectionName,ARRAYSIZE(szConnectionName)))
    {
        BOOL fCanMakeConnection = FALSE;

        DWORD cbCookie = (lstrlen(pszTaskName) + 1)*(sizeof(WCHAR)/sizeof(BYTE));

        // if this is a valid schedule then go ahead and read in the settings
        // by default don't let the connection be made.

        StringCchCopy(ConnectionSettings.pszConnectionName, ARRAYSIZE(ConnectionSettings.pszConnectionName), pszConnectionName);
        if (RegGetSchedSyncSettings(&ConnectionSettings,pszTaskName))
        {
            fCanMakeConnection = ConnectionSettings.dwMakeConnection;
        }

        // if this schedule can't make the connectione then
        // check to see if the conneciton is available and if
        // it isn't bail here.

        BOOL fConnectionAvailable = FALSE;

        if (!fCanMakeConnection)
        {
            if (S_OK == ConnectObj_IsConnectionAvailable(pszConnectionName))
            {
                fConnectionAvailable = TRUE;
            }
        }

        // add to the queue and let the main progress determine if
        // can handle the schedule.
    
        if (fCanMakeConnection || fConnectionAvailable)
        {
            // on a schedule we pass in the schedule name for the cookie data.
             hr = PrivUpdateAll(SYNCMGRINVOKE_STARTSYNC | SYNCMGRINVOKE_MINIMIZED,SYNCMGRFLAG_SCHEDULED,
                  cbCookie,(BYTE *) pszTaskName,1,&pszConnectionName,pszTaskName,fCanMakeConnection,NULL,0,0,FALSE);
        }
        else
        {
            hr = S_FALSE;
        }
    }
    else
    {
       AssertSz(0,"Schedule has no Connection");
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSynchronizeInvoke::Idle, public
//
//  Synopsis:   Handles an Idle Notifications
//
//  Arguments:
//
//  Returns:    Appropriate error codes
//
//  Modifies:
//
//  History:    20-Feb-98      rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CSynchronizeInvoke::Idle()
{
    HRESULT hr = E_UNEXPECTED;

    // request the idle Lock, If someone already has it then just return.
    if (S_OK == (hr = RequestIdleLock()))
    {
        hr = RunIdle();

        // if an error occured setting things up or nothing to do
        // then release our idle lock.
         if (S_OK != hr)
         {
            ReleaseIdleLock();
         }
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSynchronizeInvoke::RunIdle, public
//
//  Synopsis:   Runs an Idle.
//
//  Arguments:
//
//  Returns:    Appropriate error codes
//
//  Modifies:
//
//  History:    20-Feb-98      rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CSynchronizeInvoke::RunIdle()
{
    // for not just run the Idle as a Connect
    return PrivHandleAutoSync(SYNCMGRFLAG_IDLE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CSynchronizeInvoke::RasPendingDisconnect, private
//
//  Synopsis:   Handles a programmatic Ras Pending Disconnect calls.
//
//
//  Arguments:
//
//  Returns:    Appropriate error codes
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CSynchronizeInvoke::RasPendingDisconnect(DWORD cbConnectionName,
                    const BYTE *lpConnectionName)
{
    HRESULT hr = E_OUTOFMEMORY;
    CONNECTIONOBJ *pConnectionObj;

    // Thread with class factory is FreeThreaded so can block the return
    // until update is complete.

    // find connection object for this item so know its liveness.
    hr = ConnectObj_FindConnectionObj( (TCHAR*) lpConnectionName,TRUE,&pConnectionObj);

    if (S_OK == hr)
    {
        HANDLE hRasPendingEvent;

        hr = ConnectObj_GetConnectionObjCompletionEvent(pConnectionObj,&hRasPendingEvent);
        if (S_OK == hr)
        {
            hr = PrivAutoSyncOnConnection(SYNCMGRFLAG_PENDINGDISCONNECT | SYNCMGRFLAG_MAYBOTHERUSER,
                1,(TCHAR **) &lpConnectionName,hRasPendingEvent);

            // if successfully invoked the connection then wait for the event
            // object to get set,

            if ( (S_OK == hr) && hRasPendingEvent)
            {
                WaitForSingleObject(hRasPendingEvent,INFINITE);  // review if can determine a timeout
            }
            else
            {
                // !!!!on failure call close the Connection to make sure
                // the object gets cleaned up in case the progress queue didn't get kicked off.
                // If someone is currently using a connection they will be closed which is
                // the same as if autosync wasn't selected and the User chose to
                // close while a sync was in progress.

                ConnectObj_CloseConnection(pConnectionObj);
            }

            // Release our hold on the Connection.
            ConnectObj_ReleaseConnectionObj(pConnectionObj);

            if (hRasPendingEvent)
            {
                CloseHandle(hRasPendingEvent);
            }
        }

    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     QueryLoadHandlerOnEvent, private
//
//  Synopsis:   Determines if Handle needs to be loaded for the specified
//              Event and Connection.
//
//
//  Arguments:  [pszClsid] - clsid of handler
//              [dwSyncFlags] - SyncFlags to pass onto initialize
//              [cbNumConnectionNames] - Number of ConnectionNames in array
//              [ppConnectionNames] - array of connection names.
//
//  Returns:    TRUE - handler needs to be loaded
//              FALSE - handler doesn't need to be loaded.
//
//  Modifies:
//
//  History:    24-Aug-98      rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL QueryLoadHandlerOnEvent(TCHAR *pszClsid,DWORD dwSyncFlags,DWORD dwRegistrationFlags,
                                             DWORD cbNumConnectionNames,TCHAR **ppConnectionNames)
{
    BOOL fLoadHandler = TRUE;
    DWORD dwSyncEvent = dwSyncFlags & SYNCMGRFLAG_EVENTMASK;

    // see if handler is registered for the event
    // if it is then we always load it. If its not the User had to have checked an item
    if (
           ( (dwSyncEvent == SYNCMGRFLAG_IDLE) && !(dwRegistrationFlags & SYNCMGRREGISTERFLAG_IDLE) )
        || ( (dwSyncEvent == SYNCMGRFLAG_CONNECT) && !(dwRegistrationFlags & SYNCMGRREGISTERFLAG_CONNECT) )
        || ( (dwSyncEvent == SYNCMGRFLAG_PENDINGDISCONNECT) && !(dwRegistrationFlags & SYNCMGRREGISTERFLAG_PENDINGDISCONNECT) )
       )
    {
        DWORD cbCurConnectionName;

        fLoadHandler = FALSE;

        for (cbCurConnectionName = 0 ; cbCurConnectionName < cbNumConnectionNames;cbCurConnectionName++)
        {
            fLoadHandler |= RegQueryLoadHandlerOnEvent(pszClsid,dwSyncFlags,ppConnectionNames[cbCurConnectionName]);
        }
    }

    return fLoadHandler;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSynchronizeInvoke::PrivUpdateAll, private
//
//  Synopsis:   Handles a programmatic UpdateAll call.
//
//              !!Warning - Liveness relies on a dialog being created
//                      before return or we could go away when the
//                      caler releases our interface.
//
//  Arguments:  [dwInvokeFlags] - InvokeFlags
//              [dwSyncFlags] - SyncFlags to pass onto initialize
//              [pszConnectionName] - array of connection names.
//              [pszScheduleName] - Name of schedule that was fired if a scheduled event.
//
//  Returns:    S_OK - If handled result
//              S_FALSE - if nothing to do (such as no items selected on Idle).
//              error codes - if errors occured
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CSynchronizeInvoke::PrivUpdateAll(DWORD dwInvokeFlags,DWORD dwSyncFlags,
                                DWORD cbCookie,const BYTE *lpCooke,
                                DWORD cbNumConnectionNames,TCHAR **ppConnectionNames,
                                TCHAR *pszScheduleName,BOOL fCanMakeConnection,HANDLE hRasPendingDisconnect,
                                ULONG ulIdleRetryMinutes,ULONG ulDelayIdleShutDownTime,BOOL fRetryEnabled)
{
    HRESULT hr = E_OUTOFMEMORY;
    CHndlrQueue * pHndlrQueue = NULL;
    CLSID clsidChoice = GUID_NULL;
    JOBINFO *pJobInfo = NULL;
    int nCmdShow = (dwInvokeFlags & SYNCMGRINVOKE_MINIMIZED) ? SW_SHOWMINIMIZED : SW_SHOWNORMAL;
    DWORD dwSyncEvent = (dwSyncFlags & SYNCMGRFLAG_EVENTMASK);

    // On an UpdateAll
    //   1 - see if there is an existing UpdateAll choice, If so bring to foreground
    //   2 - Bring up update All choice dialog.

    // behavior - If already an Update All choice dialog just pull it to the Front
    //            If Already an UpdateAll progress bar bring it to the front
    //            If Progress Bar but doesn't already contain an updateAll create the choice dialog.


    Assert(ppConnectionNames && (cbNumConnectionNames >= 1));
    Assert( (NULL == pszScheduleName) || (SYNCMGRFLAG_SCHEDULED == dwSyncEvent)
            || (SYNCMGRFLAG_IDLE == dwSyncEvent)  ); // review, temporary for idle.

    pHndlrQueue = new CHndlrQueue(QUEUETYPE_CHOICE,NULL);

    if (NULL == pHndlrQueue)
        return E_OUTOFMEMORY;

    hr = pHndlrQueue->AddQueueJobInfo(dwSyncFlags,cbNumConnectionNames,
                                        ppConnectionNames,pszScheduleName,fCanMakeConnection
                                        ,&pJobInfo);

    // loop through the reg getting the handlers and trying to
    // create them.

    if (S_OK == hr)
    {
        TCHAR lpName[256];
        DWORD cbName = 256;
        HKEY hkOneStop;
        CLSID clsid;
        HANDLERINFO *pHandlerID;
        BOOL fItemsInQueue = FALSE;

        hkOneStop = RegGetHandlerTopLevelKey(KEY_READ);

        if (hkOneStop)
        {
            DWORD dwIndex = 0;

            while ( ERROR_SUCCESS == RegEnumKey(hkOneStop,dwIndex, lpName,cbName) )
            {
                if (S_OK == CLSIDFromString(lpName,&clsid) )
                {
                    BOOL fReg;
                    DWORD dwRegistrationFlags;
                    BOOL fLoadHandler = TRUE;

                    fReg = RegGetHandlerRegistrationInfo(clsid,&dwRegistrationFlags);
                    Assert(fReg || (0 == dwRegistrationFlags));
                    
                    //For scheduled, see if there are any items on this handler,

                    if ((SYNCMGRINVOKE_STARTSYNC & dwInvokeFlags) &&
                        (SYNCMGRFLAG_SCHEDULED == dwSyncEvent))
                    {
                        fLoadHandler = RegSchedHandlerItemsChecked(lpName, ppConnectionNames[0],pszScheduleName);
                    }
                    else if (SYNCMGRINVOKE_STARTSYNC & dwInvokeFlags)
                    {
                        fLoadHandler =  QueryLoadHandlerOnEvent(lpName,dwSyncFlags,dwRegistrationFlags,
                                                 cbNumConnectionNames,ppConnectionNames);
                    }

                    if (fLoadHandler)
                    {
                        if (S_OK == pHndlrQueue->AddHandler(&pHandlerID,pJobInfo,dwRegistrationFlags))
                        {
                            pHndlrQueue->CreateServer(pHandlerID,&clsid);
                        }
                    }
                }

                dwIndex++;
            }

            RegCloseKey(hkOneStop);
        }

        // Initialize the items.

        CLSID pHandlerClsid;

        while (S_OK == pHndlrQueue->FindFirstHandlerInState(HANDLERSTATE_INITIALIZE,GUID_NULL,&pHandlerID,&pHandlerClsid))
        {
            pHndlrQueue->Initialize(pHandlerID,0,dwSyncFlags,
                cbCookie,lpCooke);
        }

        // can release jobinfo since handlers need to hold their own addref.
         if (pJobInfo)
        {
            pHndlrQueue->ReleaseJobInfoExt(pJobInfo);
            pJobInfo = NULL;
        }

        // if start invoke need to add the handlers items to the queue before
        // transferring

        while (S_OK == pHndlrQueue->FindFirstHandlerInState(HANDLERSTATE_ADDHANDLERTEMS,GUID_NULL,&pHandlerID,&pHandlerClsid))
        {
            DWORD cbNumItemsAdded;

            // CODE REVIEW:
            // NOTENOTE:
            //  What if one of these additems fails ?
            hr = pHndlrQueue->AddHandlerItemsToQueue(pHandlerID,&cbNumItemsAdded);

            // if an item was added, then there are items in the queue
            if (cbNumItemsAdded)
            {
                fItemsInQueue = TRUE;
            }
        }

        //
        // Move handlers that won't establish connections to end
        // of handler list.
        //
        pHndlrQueue->SortHandlersByConnection();

        if (SYNCMGRINVOKE_STARTSYNC & dwInvokeFlags)
        {
            CProgressDlg *pProgressDlg;
            CLSID clsid_Progress = GUID_NULL;

            // For Idle we want to use the idle progress dialog
            // currently progress dialog relies on some globals so
            // need to change that first before checking this in
            if (SYNCMGRFLAG_IDLE == dwSyncEvent)
            {
                clsid_Progress = GUID_PROGRESSDLGIDLE;
            }

            // if not items are selected, just free the queue.
            // Review - it would be better to always call Progress and progress
            // itself not show until there are items to synchronize
            if (pHndlrQueue->AreAnyItemsSelectedInQueue())
            {
                hr = FindProgressDialog(clsid_Progress,TRUE,nCmdShow,&pProgressDlg);

                if (S_OK == hr)
                {
                    // for an Idle we now request the defaults for retryIdle
                    // and delay shutdown, and change the queue order
                    // based on the last item
                    if (SYNCMGRFLAG_IDLE == dwSyncEvent)
                    {
                        CLSID clsidLastHandler;

                        pProgressDlg->SetIdleParams(ulIdleRetryMinutes, ulDelayIdleShutDownTime, fRetryEnabled);

                        if (S_OK == GetLastIdleHandler(&clsidLastHandler))
                        {
                            pHndlrQueue->ScrambleIdleHandlers(clsidLastHandler);
                        }
                    }

                     hr = pProgressDlg->TransferQueueData(pHndlrQueue);
                     ReleaseProgressDialog(clsid_Progress,pProgressDlg,FALSE);
                }
            }
            else
            {
                hr = S_FALSE; // return S_FALSE IF NOTHING TO DO.
            }

            pHndlrQueue->FreeAllHandlers(); // done with our queue.

            pHndlrQueue->Release();
            pHndlrQueue = NULL;
        }
        else
        {
            BOOL fDontShowIfNoItems = (
                (SYNCMGRFLAG_CONNECT == dwSyncEvent)
                || (SYNCMGRFLAG_PENDINGDISCONNECT == dwSyncEvent ) );
                                
            // if the choice has been requested by a logon/logoff event and 
            // there aren't any items in the queue for the User to choose then
            // if you want to turn on the code to now display anything
            // turn on this If statement. For now we always show the choice.

            // CODE REVIEW:
            // NOTENOTE: 
            //  This is ALWAYS executed..

            if (1 /* !fDontShowIfNoItems || fItemsInQueue */)
            {
               // Bring up the Choice dialog, Let choice dialog actually addes the hanlder items
               // if there are any so in the future we can async fill in the choices

               CChoiceDlg *pChoiceDlg;
               hr = FindChoiceDialog(clsidChoice,TRUE,nCmdShow,&pChoiceDlg);

               if (S_OK == hr)
               {
                    if (FALSE == pChoiceDlg->SetQueueData(clsidChoice,pHndlrQueue) ) 
                    {
                        hr =  E_UNEXPECTED;
                    }
                    else
                    {
                        pHndlrQueue = NULL; // set queue to NULL since Choice dialog owns it now.
                    }

                    ReleaseChoiceDialog(clsidChoice,pChoiceDlg);
               }
            }

            // release our queue if still have it otherwise choice owns it.
            if (pHndlrQueue)
            {
                pHndlrQueue->FreeAllHandlers();
                pHndlrQueue->Release();
            }
        }
    }

   return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSynchronizeInvoke::PrivHandleAutoSync, private
//
//  Synopsis:   Handles an AutoSync Update. Figures out what connections
//              if any are active and invoke an AutoSync on each one.
//
//  Arguments:  [dwSyncFlags] - SyncFlags to pass onto initialize
//
//  Returns:    S_OK - sync was started
//              S_FALSE - nothing to do
//              appropriate error codes.
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CSynchronizeInvoke::PrivHandleAutoSync(DWORD dwSyncFlags)
{
    HRESULT hr = E_UNEXPECTED;
    DWORD dwFlags = 0;
    LPNETAPI pNetApi = NULL;
    DWORD cbNumWanConnections = 0;
    LPRASCONN pRasConn = NULL;

    pNetApi = gSingleNetApiObj.GetNetApiObj();

    if (NULL == pNetApi)
        return S_FALSE;

    g_InAutoSync = TRUE;

    if (pNetApi->IsNetworkAlive(&dwFlags))
    {
        TCHAR **pConnections; // array of connection names. End with NULL;
        ULONG ulConnectionCount = 0;

        if (NETWORK_ALIVE_LAN & dwFlags)
        {
            // We curently don't care about these error results.
            // PrivAutoSyncOnConnection(dwSyncFlags,LANCONNECTIONNAME,NULL);
            // Review what we want this to do.
            ulConnectionCount += 1;
        }

        // loop through Ras Connections.
        if ( NETWORK_ALIVE_WAN & dwFlags)
        {
            if (S_OK == pNetApi->GetWanConnections(&cbNumWanConnections,&pRasConn)
                    && (pRasConn) )
            {
                ulConnectionCount += cbNumWanConnections;
            }
            else
            {
                cbNumWanConnections = 0;
                pRasConn = NULL;
            }
        }

        // allocate array buffer for connections + 1 more for NULL
        if (ulConnectionCount
                && (pConnections = (TCHAR **) ALLOC(sizeof(TCHAR *)*(ulConnectionCount + 1))))
        {
            TCHAR **pCurConnection = pConnections;
            TCHAR *pLanConnection = NULL;

            // initialize the array.
            if (NETWORK_ALIVE_LAN & dwFlags)
            {
                pLanConnection = (TCHAR *) ALLOC(sizeof(TCHAR )*(MAX_PATH + 1));
                
                if (pLanConnection)
                {
                    if (LoadString(g_hInst, IDS_LAN_CONNECTION, pLanConnection, MAX_PATH))
                    {
                        *pCurConnection = pLanConnection;
                        ++pCurConnection;
                    }
                }
            }

            while (cbNumWanConnections)
            {
                cbNumWanConnections--;
                *pCurConnection = pRasConn[cbNumWanConnections].szEntryName;
                ++pCurConnection;
            }

            *pCurConnection = NULL; // set the last connection to NULL;

            // now autosync these puppies
            hr = PrivAutoSyncOnConnection(dwSyncFlags,ulConnectionCount,pConnections,NULL);

            if (pLanConnection)
            {
                FREE(pLanConnection);
            }

            if (pRasConn)
            {
                pNetApi->FreeWanConnections(pRasConn);
            }

            if (pConnections)
            {
                FREE(pConnections);
            }
        }
    }

    g_InAutoSync = FALSE;

    if ( pNetApi )
        pNetApi->Release();

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSynchronizeInvoke::PrivAutoSyncOnConnection, private
//
//  Synopsis:   Handles an AutoSync Update. Given the SyncFlags and Connection
//              determines if anything should be done on this connection
//              and if so invokes it.
//
//  Arguments:  [dwSyncFlags] - SyncFlags to pass onto initialize
//              [ppConnectionNames] - array of connectnames that apply to this request
//
//  Returns:    Appropriate error codes
//
//  Modifies:
//
//  History:    08-Dec-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CSynchronizeInvoke::PrivAutoSyncOnConnection(DWORD dwSyncFlags,DWORD cbNumConnectionNames,
                                 TCHAR **ppConnectionNames,HANDLE hRasPendingEvent)
{
    CONNECTIONSETTINGS ConnectSettings;
    DWORD dwSyncEvent;
    TCHAR **ppWorkerConnectionNames = NULL;
    DWORD cbNumWorkerConnections = 0;
    DWORD cbIndexCheck;
    DWORD dwPromptMeFirst = 0;
    ULONG ulIdleRetryMinutes;
    ULONG ulDelayIdleShutDownTime;
    BOOL fRetryEnabled = FALSE;
    HRESULT hr = S_FALSE;

    // assert there is at least one connection in the request
    Assert(ppConnectionNames && cbNumConnectionNames >= 1);

    if (NULL == ppConnectionNames || 0 == cbNumConnectionNames )
        return S_FALSE;

    ppWorkerConnectionNames = (TCHAR **) ALLOC(sizeof(TCHAR**) * cbNumConnectionNames);
    if (NULL == ppWorkerConnectionNames)
    {
        return E_OUTOFMEMORY;
    }

    dwSyncEvent = (dwSyncFlags & SYNCMGRFLAG_EVENTMASK);

    // loop through all the connections and move any of the ones that
    // are valid into our ppWorkerConnections name array.

    TCHAR **ppCurWorkerConnectionNamesIndex = ppWorkerConnectionNames;
    TCHAR **ppConnectionsNameIndex = ppConnectionNames;

    for (cbIndexCheck = 0; cbIndexCheck < cbNumConnectionNames; cbIndexCheck++)
    {
        StringCchCopy(ConnectSettings.pszConnectionName, ARRAYSIZE(ConnectSettings.pszConnectionName), *ppConnectionsNameIndex);

        // See if should do anything on this connection.
        if (RegGetSyncSettings(SYNCMGRFLAG_IDLE == dwSyncEvent
                    ? SYNCTYPE_IDLE : SYNCTYPE_AUTOSYNC,&ConnectSettings))
        {
            if ( (((SYNCMGRFLAG_CONNECT == dwSyncEvent) && ConnectSettings.dwLogon))
               ||(((SYNCMGRFLAG_PENDINGDISCONNECT == dwSyncEvent) && ConnectSettings.dwLogoff))
               ||(((SYNCMGRFLAG_IDLE == dwSyncEvent) && ConnectSettings.dwIdleEnabled))
                )
            {
                *ppCurWorkerConnectionNamesIndex = *ppConnectionsNameIndex;
                ++ppCurWorkerConnectionNamesIndex;
                ++cbNumWorkerConnections;

                // update the variables for connection, for autosync if dwPromptMeFirst
                // is set on any match connection
                switch (dwSyncEvent)
                {
                case SYNCMGRFLAG_IDLE:

                    // minimum retry idle values win.
                    if ( (1 == cbNumWorkerConnections) || (ConnectSettings.ulIdleRetryMinutes < ulIdleRetryMinutes) )
                    {
                        ulIdleRetryMinutes = ConnectSettings.ulIdleRetryMinutes;
                    }

                    // maximum wait for shutdown wins.
                     if ( (1 == cbNumWorkerConnections) || (ConnectSettings.ulDelayIdleShutDownTime > ulDelayIdleShutDownTime) )
                    {
                        ulDelayIdleShutDownTime = ConnectSettings.ulDelayIdleShutDownTime;
                    }

                    // if any connection has retry after xxx minutes set to bool then retry
                     if (ConnectSettings.dwRepeatSynchronization)
                    {
                        fRetryEnabled = TRUE;
                    }
                    break;

                case SYNCMGRFLAG_PENDINGDISCONNECT:
                case SYNCMGRFLAG_CONNECT:
                    // if any connection is set to prompt then prompt.
                    if (ConnectSettings.dwPromptMeFirst)
                    {
                        dwPromptMeFirst = ConnectSettings.dwPromptMeFirst;
                    }
                    break;
                }
            }
        }

        ++ppConnectionsNameIndex;
    }


    // if we found any connections to actually do work on start the sync off.
    if (cbNumWorkerConnections > 0)
    {
        DWORD dwInvokeFlag = 0;

        switch (dwSyncEvent)
        {
        case SYNCMGRFLAG_IDLE:
            dwInvokeFlag |=  SYNCMGRINVOKE_MINIMIZED | SYNCMGRINVOKE_STARTSYNC;
            break;

        case SYNCMGRFLAG_PENDINGDISCONNECT:
        case SYNCMGRFLAG_CONNECT:
            if (!dwPromptMeFirst)
            {
                dwInvokeFlag |= SYNCMGRINVOKE_STARTSYNC;
            }
            break;

        default:
            AssertSz(0,"Unknown SyncEvent");
            break;
        }

        // perform the Update
        hr = PrivUpdateAll(dwInvokeFlag,dwSyncFlags,0,NULL,
                        cbNumWorkerConnections,
                        ppWorkerConnectionNames,NULL,FALSE,hRasPendingEvent,
                        ulIdleRetryMinutes,
                        ulDelayIdleShutDownTime,fRetryEnabled);
    }

    if (ppWorkerConnectionNames)
    {
        FREE(ppWorkerConnectionNames);
    }

    return hr;
}

// default Unknown implementation


//+---------------------------------------------------------------------------
//
//  Member:     CSynchronizeInvoke::CPrivUnknown::QueryInterface, public
//
//  Synopsis:   Standard QueryInterface
//
//  Arguments:  [iid] - Interface ID
//              [ppvObj] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CSynchronizeInvoke::CPrivUnknown::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = this;
    }
    else if (IsEqualIID(riid, IID_IPrivSyncMgrSynchronizeInvoke))
    {
        *ppv = (IPrivSyncMgrSynchronizeInvoke *) m_pSynchInvoke;
    }
    
#ifdef _SENS
    else if (IsEqualIID(riid, IID_ISensNetwork))
    {
        *ppv = (ISensNetwork *) &(m_pSynchInvoke->m_PrivSensNetwork);
    }

    else if (IsEqualIID(riid, IID_ISensLogon))
    {
        *ppv = (ISensLogon *) &(m_pSynchInvoke->m_PrivSensLogon);
    }

    // in final this shouldn't return anything until LCE change, change
    // depending on which interface we want to test.

    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppv = &(m_pSynchInvoke->m_PrivSensLogon);
    }
#endif // _SENS

    if (*ppv)
    {
        m_pSynchInvoke->m_pUnkOuter->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSynchronizeInvoke::CPrivUnknown::AddRef, public
//
//  Synopsis:   Add reference
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CSynchronizeInvoke::CPrivUnknown::AddRef()
{
    ULONG cRefs;

    cRefs = InterlockedIncrement((LONG *)& m_pSynchInvoke->m_cRef);
    return cRefs;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSychrononizeInvoke::CPrivUnknown::Release, public
//
//  Synopsis:   Release reference
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CSynchronizeInvoke::CPrivUnknown::Release()
{
    ULONG cRefs;

    cRefs = InterlockedDecrement( (LONG *) &m_pSynchInvoke->m_cRef);

    if (0 == cRefs)
    {
        delete m_pSynchInvoke;
    }

    return cRefs;
}


#ifdef _SENS

// SENS Network connect Interfaces

STDMETHODIMP CSynchronizeInvoke::CPrivSensNetwork::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    return m_pSynchInvoke->m_pUnkOuter->QueryInterface(riid,ppv);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSynchronizeInvoke::AddRef, public
//
//  Synopsis:   Add reference
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CSynchronizeInvoke::CPrivSensNetwork::AddRef()
{
    return m_pSynchInvoke->m_pUnkOuter->AddRef();
}


//+---------------------------------------------------------------------------
//
//  Member:     CSychrononizeInvoke::Release, public
//
//  Synopsis:   Release reference
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CSynchronizeInvoke::CPrivSensNetwork::Release()
{
    return m_pSynchInvoke->m_pUnkOuter->Release();

}

STDMETHODIMP
CSynchronizeInvoke::CPrivSensNetwork::GetTypeInfoCount(
    UINT *pCountITypeInfo
    )
{
    *pCountITypeInfo = 1;
    return S_OK;
}


STDMETHODIMP
CSynchronizeInvoke::CPrivSensNetwork::GetTypeInfo(
    UINT iTypeInfo,
    LCID lcid,
    ITypeInfo **ppITypeInfo
    )
{
    HRESULT hr;

    if (iTypeInfo)
    {
        return DISP_E_BADINDEX;
    }

    if (S_OK == (hr = m_pSynchInvoke->GetNetworkTypeInfo()))
    {
        // if got a typelib addref it and hand it out.
        m_pSynchInvoke->m_pITypeInfoNetwork->AddRef();
        *ppITypeInfo = m_pSynchInvoke->m_pITypeInfoNetwork;
    }

    return hr;
}

STDMETHODIMP
CSynchronizeInvoke::CPrivSensNetwork::GetIDsOfNames(
    REFIID riid,
    LPOLESTR *arrNames,
    UINT cNames,
    LCID lcid,
    DISPID *arrDispIDs)
{
    HRESULT hr;

    if (S_OK == (hr = m_pSynchInvoke->GetNetworkTypeInfo()))
    {
         hr = m_pSynchInvoke->m_pITypeInfoNetwork->GetIDsOfNames(
                               arrNames,
                               cNames,
                               arrDispIDs
                               );
    }

    return hr;
}

STDMETHODIMP
CSynchronizeInvoke::CPrivSensNetwork::Invoke(
    DISPID dispID,
    REFIID riid,
    LCID lcid,
    WORD wFlags,
    DISPPARAMS *pDispParams,
    VARIANT *pvarResult,
    EXCEPINFO *pExecpInfo,
    UINT *puArgErr
    )
{
    HRESULT hr;

    if (S_OK == (hr = m_pSynchInvoke->GetNetworkTypeInfo()))
    {
         hr = m_pSynchInvoke->m_pITypeInfoNetwork->Invoke(
                                            (IDispatch*) this,
                                           dispID,
                                           wFlags,
                                           pDispParams,
                                           pvarResult,
                                           pExecpInfo,
                                           puArgErr);
    }


  return hr;
}


STDMETHODIMP
CSynchronizeInvoke::CPrivSensNetwork::ConnectionMade(
    BSTR bstrConnection,
    ULONG ulType,
    LPSENS_QOCINFO pQOCInfo
    )
{
    HRESULT hr = E_UNEXPECTED;
    TCHAR pszConnectionName[RAS_MaxEntryName + 1];
    TCHAR *pConnectionNameArray;

    if (g_InAutoSync) // Review logic, for now if in logon just return.
    {
        return S_OK;
    }

    RegSetUserDefaults(); // Make Sure the UserDefaults are up to date

    // if Lan connection use our hardcoded value, else use the
     // connection name given to use.

    if (ulType & NETWORK_ALIVE_LAN)
    {
        LoadString(g_hInst, IDS_LAN_CONNECTION, pszConnectionName,ARRAYSIZE(pszConnectionName));
    }
    else
    {
        StringCchCopy(pszConnectionName, ARRAYSIZE(pszConnectionName), bstrConnection);
    }

    pConnectionNameArray = pszConnectionName;

    if (pszConnectionName)
    {
        hr = m_pSynchInvoke->PrivAutoSyncOnConnection(SYNCMGRFLAG_CONNECT | SYNCMGRFLAG_MAYBOTHERUSER,1,
                &pConnectionNameArray,
                NULL);
    }

    return hr;
}

//
// CODE REVIEW:
// NOTENOTE:
//  Can we remove this function ?
STDMETHODIMP
CSynchronizeInvoke::CPrivSensNetwork::ConnectionMadeNoQOCInfo(
    BSTR bstrConnection,
    ULONG ulType
    )
{
    /*
    AssertSz(0,"ConnectionMadeNoQOCInfo called");

    TCHAR *pszConnectionName = bstrConnection;

    //  m_pSynchInvoke->PrivAutoSyncOnConnection(SYNCMGRFLAG_CONNECT,pszConnectionName,
        //              NULL);
    */

   return S_OK;
}

STDMETHODIMP
CSynchronizeInvoke::CPrivSensNetwork::ConnectionLost(
    BSTR bstrConnection,
    ULONG ulType
    )
{
    return S_OK;
}

STDMETHODIMP
CSynchronizeInvoke::CPrivSensNetwork::BeforeDisconnect(
    BSTR bstrConnection,
    ULONG ulType
    )
{
    return S_OK;
}

STDMETHODIMP
CSynchronizeInvoke::CPrivSensNetwork::DestinationReachable(
    BSTR bstrDestination,
    BSTR bstrConnection,
    ULONG ulType,
    LPSENS_QOCINFO pQOCInfo
    )
{
    return S_OK;
}

STDMETHODIMP
CSynchronizeInvoke::CPrivSensNetwork::DestinationReachableNoQOCInfo(
    BSTR bstrDestination,
    BSTR bstrConnection,
    ULONG ulType
    )
{
   return S_OK;
}


// ISensLogon/Logoff Events


STDMETHODIMP CSynchronizeInvoke::CPrivSensLogon::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    return m_pSynchInvoke->m_pUnkOuter->QueryInterface(riid,ppv);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSynchronizeInvoke::AddRef, public
//
//  Synopsis:   Add reference
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CSynchronizeInvoke::CPrivSensLogon::AddRef()
{
    return m_pSynchInvoke->m_pUnkOuter->AddRef();
}


//+---------------------------------------------------------------------------
//
//  Member:     CSychrononizeInvoke::Release, public
//
//  Synopsis:   Release reference
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CSynchronizeInvoke::CPrivSensLogon::Release()
{
    return m_pSynchInvoke->m_pUnkOuter->Release();

}

STDMETHODIMP
CSynchronizeInvoke::CPrivSensLogon::GetTypeInfoCount(
    UINT *pCountITypeInfo
    )
{
    *pCountITypeInfo = 1;
    return S_OK;
}


STDMETHODIMP
CSynchronizeInvoke::CPrivSensLogon::GetTypeInfo(
    UINT iTypeInfo,
    LCID lcid,
    ITypeInfo **ppITypeInfo
    )
{
    HRESULT hr;

    if (iTypeInfo)
    {
        return DISP_E_BADINDEX;
    }

    if (S_OK == (hr = m_pSynchInvoke->GetLogonTypeInfo()))
    {
        // if got a typelib addref it and hand it out.
        m_pSynchInvoke->m_pITypeInfoLogon->AddRef();
        *ppITypeInfo = m_pSynchInvoke->m_pITypeInfoLogon;
    }

    return hr;
}

STDMETHODIMP
CSynchronizeInvoke::CPrivSensLogon::GetIDsOfNames(
    REFIID riid,
    LPOLESTR *arrNames,
    UINT cNames,
    LCID lcid,
    DISPID *arrDispIDs)
{
    HRESULT hr;

    if (S_OK == (hr = m_pSynchInvoke->GetLogonTypeInfo()))
    {
         hr = m_pSynchInvoke->m_pITypeInfoLogon->GetIDsOfNames(
                               arrNames,
                               cNames,
                               arrDispIDs
                               );
    }

    return hr;
}

STDMETHODIMP
CSynchronizeInvoke::CPrivSensLogon::Invoke(
    DISPID dispID,
    REFIID riid,
    LCID lcid,
    WORD wFlags,
    DISPPARAMS *pDispParams,
    VARIANT *pvarResult,
    EXCEPINFO *pExecpInfo,
    UINT *puArgErr
    )
{
    HRESULT hr;

    if (S_OK == (hr = m_pSynchInvoke->GetLogonTypeInfo()))
    {
         hr = m_pSynchInvoke->m_pITypeInfoLogon->Invoke(
                                            (IDispatch*) this,
                                           dispID,
                                           wFlags,
                                           pDispParams,
                                           pvarResult,
                                           pExecpInfo,
                                           puArgErr);
    }

    return hr;
}

STDMETHODIMP CSynchronizeInvoke::CPrivSensLogon::Logon(BSTR bstrUserName)
{
    m_pSynchInvoke->Logon();
    return S_OK;
}

STDMETHODIMP  CSynchronizeInvoke::CPrivSensLogon::Logoff(BSTR bstrUserName)
{
    m_pSynchInvoke->Logoff();
    return S_OK;
}

STDMETHODIMP  CSynchronizeInvoke::CPrivSensLogon::Startup(BSTR bstrUserName)
{
    return S_OK;
}

STDMETHODIMP  CSynchronizeInvoke::CPrivSensLogon::StartShell(BSTR bstrUserName)
{
    return S_OK;
}

STDMETHODIMP  CSynchronizeInvoke::CPrivSensLogon::Shutdown(BSTR bstrUserName)
{
    return S_OK;
}

STDMETHODIMP  CSynchronizeInvoke::CPrivSensLogon::DisplayLock(BSTR bstrUserName)
{
    return S_OK;
}

STDMETHODIMP  CSynchronizeInvoke::CPrivSensLogon::DisplayUnlock(BSTR bstrUserName)
{
    return S_OK;
}

STDMETHODIMP  CSynchronizeInvoke::CPrivSensLogon::StartScreenSaver(BSTR bstrUserName)
{
    return S_OK;
}


STDMETHODIMP  CSynchronizeInvoke::CPrivSensLogon::StopScreenSaver(BSTR bstrUserName)
{
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSynchronizeInvoke::GetLogonTypeInfo, private
//
//  Synopsis:   Loads the TypeInfo object for the Sens
//              Logon Information.
//
//  Arguments:
//
//  Returns:   S_OK if successfully loaded the TypeInfo.
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//+---------------------------------------------------------------------------

STDMETHODIMP CSynchronizeInvoke::GetLogonTypeInfo()
{
    HRESULT hr;
    ITypeLib *pITypeLib;

    if (m_pITypeInfoLogon)
        return S_OK;

    hr = LoadRegTypeLib(
                 LIBID_SensEvents,
                 1 /* MAJOR_VER */ ,
                 0 /* MINOR_VER */ ,
                 0 /* DEFAULT_LCID */,
                 &pITypeLib
                 );

    if (S_OK == hr)
    {
        hr = pITypeLib->GetTypeInfoOfGuid(
                     IID_ISensLogon,
                     &m_pITypeInfoLogon
                     );

        pITypeLib->Release();
    }

    if (S_OK != hr)
    {
        m_pITypeInfoLogon = NULL; // don't rely on call not to leave this alone.
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSynchronizeInvoke::GetNetworkTypeInfo, private
//
//  Synopsis:   Loads the TypeInfo object for the Sens
//              Network Information.
//
//  Arguments:
//
//  Returns:   S_OK if successfully loaded the TypeInfo.
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//+---------------------------------------------------------------------------

STDMETHODIMP CSynchronizeInvoke::GetNetworkTypeInfo()
{
    HRESULT hr;
    ITypeLib *pITypeLib;

    if (m_pITypeInfoNetwork)
        return S_OK;

    hr = LoadRegTypeLib(
                 LIBID_SensEvents,
                 1 /* MAJOR_VER */ ,
                 0 /* MINOR_VER */ ,
                 0 /* DEFAULT_LCID */,
                 &pITypeLib
                 );

    if (S_OK == hr)
    {
        hr = pITypeLib->GetTypeInfoOfGuid(
                     IID_ISensNetwork,
                     &m_pITypeInfoNetwork
                     );

        pITypeLib->Release();
    }

    if (S_OK != hr)
    {
        m_pITypeInfoNetwork = NULL; // don't rely on call not to leave this alone.
    }

    return hr;
}


#endif // _SENS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\exe\invoke.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Invoke.h
//
//  Contents:   Private Invoke interface for kicking off Synchronizations
//
//  Classes:    CSynchronizeInvoke
//
//  Notes:      
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------


#ifndef _SYNCINVOKE_
#define _SYNCINVOKE_

#ifdef _SENS
#include <sensevts.h> // Review - must be real path 
#endif // _SENS

class CSynchronizeInvoke : public IPrivSyncMgrSynchronizeInvoke 
{

public:
    CSynchronizeInvoke(void);
    ~CSynchronizeInvoke();

    // default controlling unknown.
    class CPrivUnknown : public IUnknown
    {
    public:
        STDMETHOD(QueryInterface) ( REFIID riid, LPVOID FAR* ppvObj);
        STDMETHOD_(ULONG,AddRef) (void);
        STDMETHOD_(ULONG,Release) (void);

	inline void SetParent(CSynchronizeInvoke *pSynchInvoke) { m_pSynchInvoke = pSynchInvoke; };

    private:
	CSynchronizeInvoke *m_pSynchInvoke;
    };

    friend class CPrivUnknown;
    CPrivUnknown m_Unknown;

    //IUnknown members
    STDMETHODIMP	    QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // IOfflineSynchronizeInvoke Methods
    STDMETHODIMP UpdateItems(DWORD dwInvokeFlags,REFCLSID rclsid,DWORD cbCookie,const BYTE*lpCookie);
    STDMETHODIMP UpdateAll(void);

    // private methods
    STDMETHODIMP Logon();
    STDMETHODIMP Logoff();
    STDMETHODIMP Schedule(WCHAR *pszTaskName);
    STDMETHODIMP Idle();
    STDMETHODIMP RasPendingDisconnect(DWORD cbConnectionName,const BYTE *lpConnectionName);

#ifdef _SENS

    class CPrivSensNetwork : public ISensNetwork
    {
    public:
        STDMETHOD(QueryInterface) ( REFIID riid, LPVOID FAR* ppvObj);
        STDMETHOD_(ULONG,AddRef) (void);
        STDMETHOD_(ULONG,Release) (void);

	// Dispatch Methods
	STDMETHOD (GetTypeInfoCount)    (UINT *);
	STDMETHOD (GetTypeInfo)         (UINT, LCID, ITypeInfo **);
	STDMETHOD (GetIDsOfNames)       (REFIID, LPOLESTR *, UINT, LCID, DISPID *);
	STDMETHOD (Invoke)              (DISPID, REFIID, LCID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *);

	// ISensNetwork
	STDMETHOD (ConnectionMade)                (BSTR, ULONG, LPSENS_QOCINFO);
	STDMETHOD (ConnectionMadeNoQOCInfo)       (BSTR, ULONG);
	STDMETHOD (ConnectionLost)                (BSTR, ULONG);
	STDMETHOD (BeforeDisconnect)              (BSTR, ULONG);
	STDMETHOD (DestinationReachable)          (BSTR, BSTR, ULONG, LPSENS_QOCINFO);
	STDMETHOD (DestinationReachableNoQOCInfo) (BSTR, BSTR, ULONG);

	inline void SetParent(CSynchronizeInvoke *pSynchInvoke) { m_pSynchInvoke = pSynchInvoke; };

	private:
	    CSynchronizeInvoke *m_pSynchInvoke;
     };

    friend class CPrivSensNetwork;
    CPrivSensNetwork m_PrivSensNetwork;

    class CPrivSensLogon : public ISensLogon
    {
    public:
        STDMETHOD(QueryInterface) ( REFIID riid, LPVOID FAR* ppvObj);
        STDMETHOD_(ULONG,AddRef) (void);
        STDMETHOD_(ULONG,Release) (void);

	// Dispatch Methods
	STDMETHOD (GetTypeInfoCount)    (UINT *);
	STDMETHOD (GetTypeInfo)         (UINT, LCID, ITypeInfo **);
	STDMETHOD (GetIDsOfNames)       (REFIID, LPOLESTR *, UINT, LCID, DISPID *);
	STDMETHOD (Invoke)              (DISPID, REFIID, LCID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *);

	// ISensLogon
	STDMETHOD (Logon)(BSTR bstrUserName);
	STDMETHOD (Logoff)(BSTR bstrUserName);
	STDMETHOD (Startup)(BSTR bstrUserName);
	STDMETHOD (StartShell)(BSTR bstrUserName);
	STDMETHOD (Shutdown)(BSTR bstrUserName);
	STDMETHOD (DisplayLock)(BSTR bstrUserName);
	STDMETHOD (DisplayUnlock)(BSTR bstrUserName);
	STDMETHOD (StartScreenSaver)(BSTR bstrUserName);
	STDMETHOD (StopScreenSaver)(BSTR bstrUserName);

        inline void SetParent(CSynchronizeInvoke *pSynchInvoke) { m_pSynchInvoke = pSynchInvoke; };

	private:
	    CSynchronizeInvoke *m_pSynchInvoke;

    };

    friend class CPrivSensLogon;
    CPrivSensLogon m_PrivSensLogon;

#endif // _SENS

public:
    STDMETHODIMP RunIdle();

private:
   STDMETHODIMP PrivUpdateAll(DWORD dwInvokeFlags,DWORD dwSyncFlags,DWORD cbCookie,const BYTE *lpCooke,
	  	DWORD cbNumConnectionNames,TCHAR **ppConnectionNames,
                TCHAR *pszScheduleName,BOOL fCanMakeConnection,HANDLE hRasPendingDisconnect,
                ULONG ulIdleRetryMinutes,ULONG ulDelayIdleShutDownTime,BOOL fRetryEnabled);
   
   STDMETHODIMP PrivHandleAutoSync(DWORD dwSyncFlags);
   STDMETHODIMP PrivAutoSyncOnConnection(DWORD dwSyncFlags,DWORD cbNumConnectionNames,
                        TCHAR **ppConnectionName,
			HANDLE hRasPendingEvent);

   STDMETHODIMP GetLogonTypeInfo();
   STDMETHODIMP GetNetworkTypeInfo();


   DWORD m_cRef;
   IUnknown *m_pUnkOuter; // pointer to outer unknown.
    
   ITypeInfo *m_pITypeInfoLogon; // TypeInfo for Sens Logon Event.
   ITypeInfo *m_pITypeInfoNetwork; // TypeInfo for Sens Network Event.
};


#endif // _SYNCINVOKE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\exe\idle.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       idle.cpp
//
//  Contents:   Idle notification routines.
//
//  Classes:
//
//  Notes:
//
//  History:    23-Feb-98   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

// msidle  DLL and function strings
STRING_FILENAME(szMsIdleDll, "MsIdle.dll");

#define BEGINIDLEDETECTIONORD 3
#define ENDIDLEDETECTIONORD   4
#define SETIDLETIMEOUTORD     5
#define SETIDLENOTIFYORD      6
#define SETBUSYNOTIFYORD      7
#define GETIDLEMINUTESORD     8

CSyncMgrIdle *g_SyncMgrIdle = NULL; // idle that has a current callback.

//+---------------------------------------------------------------------------
//
//  Member:     IdleCallback, private
//
//  Synopsis:   callback function for Idle, Only one idle registration
//		is allowed per SyncMgrInstance.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    23-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void WINAPI IdleCallback(DWORD dwState)
{
    if (STATE_USER_IDLE_END == dwState)
    {
	    if (g_SyncMgrIdle)
	    {
	        g_SyncMgrIdle->m_fReceivedOffIdle = TRUE;

	        // if we have a registered timer for reset Idle remove it.
	        if (g_SyncMgrIdle->m_dwRegisteredTimer)
	        {
		        KillTimer(0,g_SyncMgrIdle->m_dwRegisteredTimer);
	        }

	        g_SyncMgrIdle->m_pSetBusyNotify(FALSE,0); // only allow one busy to come through
	        g_SyncMgrIdle->m_pSetIdleNotify(FALSE,0); // don't allow an Idle through after get a busy.
	        g_SyncMgrIdle->OffIdle();
	    }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     TimerCallback, private
//
//  Synopsis:   callback function for Timer when minutes have passed
//		for when to restart the Idle.
//		
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    23-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

VOID CALLBACK IdleOnTimerProc(HWND hwnd,UINT uMsg,UINT idEvent,DWORD dwTime)
{
    if (g_SyncMgrIdle && !g_SyncMgrIdle->m_fReceivedOffIdle)
    {
        DWORD_PTR dwRegTimer = g_SyncMgrIdle->m_dwRegisteredTimer;

	    g_SyncMgrIdle->m_dwRegisteredTimer = 0;
	    KillTimer(0,dwRegTimer);
	    g_SyncMgrIdle->OnIdle();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrIdle::CSyncMgrIdle, public
//
//  Synopsis:   Constructor
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    23-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

CSyncMgrIdle::CSyncMgrIdle()
{
    m_hInstMsIdleDll = NULL;
    m_pBeginIdleDetection = NULL;
    m_pEndIdleDetection = NULL;
    m_pGetIdleMinutes = NULL;
    m_pSetBusyNotify = NULL;
    m_pSetIdleNotify = NULL;
    m_pSetIdleTimeout = NULL;
    m_pProgressDlg = NULL;
    m_dwRegisteredTimer = NULL;
    m_fInBeginIdleDetection = FALSE;
    m_fReceivedOffIdle = FALSE;

    Assert(NULL == g_SyncMgrIdle); // make sure another idle doesn't exist
}


//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrIdle::~CSyncMgrIdle, public
//
//  Synopsis:   destructor
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    23-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

CSyncMgrIdle::~CSyncMgrIdle()
{
    if (m_dwRegisteredTimer) // remove our timer.
    {
	    KillTimer(0,m_dwRegisteredTimer);
    }

    // if we are in an idle detection then first remove it.
    if (m_fInBeginIdleDetection)
    {
        m_pEndIdleDetection(0);
	    m_pProgressDlg = NULL;
	    g_SyncMgrIdle = NULL;
    }
    else
    {
	    Assert(NULL == m_pProgressDlg);
	    Assert(NULL == g_SyncMgrIdle);
    }

    // if have the dll then free it.

    if (m_hInstMsIdleDll)
    {
	    FreeLibrary(m_hInstMsIdleDll);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrIdle::Initialize, public
//
//  Synopsis:   Initializes class, must be called before any other member.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    23-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CSyncMgrIdle::Initialize()
{
    return LoadMsIdle();
}


//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrIdle::BeginIdleDetection, public
//
//  Synopsis:   Registers the callback with msidle.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    23-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

DWORD CSyncMgrIdle::BeginIdleDetection(CProgressDlg *pProgressDlg,DWORD dwIdleMin, DWORD dwReserved)
{
    DWORD dwResult = 0;

    Assert(m_hInstMsIdleDll);

    if (!m_hInstMsIdleDll)
    {
	    return -1;
    }

    // if there is already an idle registered
    // assert it is the same as what is trying to get registered
    // now and return

    Assert(FALSE == m_fInBeginIdleDetection);

    if (m_fInBeginIdleDetection)
    {
	    Assert(g_SyncMgrIdle == this);
	    Assert(m_pProgressDlg == pProgressDlg);
	    return 0;
    }

    Assert(NULL == g_SyncMgrIdle); // should not still be another Idle.

    g_SyncMgrIdle = this;
    m_pProgressDlg = pProgressDlg;

    dwResult =  m_pBeginIdleDetection(IdleCallback,30,0);

    if (dwResult)
    {
	    g_SyncMgrIdle = NULL;
	    m_pProgressDlg = NULL;
    }
    else
    {
	    m_pSetBusyNotify(TRUE,0);
	    m_pSetIdleNotify(FALSE,0);

	    m_fInBeginIdleDetection = TRUE;
    }

    return dwResult;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrIdle::ReRegisterIdleDetection, public
//
//  Synopsis:   ReRegisters an existing callback with MSIdle. Currently MSIdle
//              only allows one idle registration per process. If a handler comes
//              along and also wants Idle they will remove our calback. Therefore
//              until MSIdle allows multiple registrations per process we
//              reregister for Idle after each handler is called.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    01-April-98       rogerg        Created.
//
//----------------------------------------------------------------------------

DWORD CSyncMgrIdle::ReRegisterIdleDetection(CProgressDlg *pProgressDlg)
{
    DWORD dwResult = 0;

    Assert(m_hInstMsIdleDll);

    // this funciton should only be called after we have already begun an existing Idle detection.
    // If IdleDetection if already off for any reason don't reregister.
    if (!m_hInstMsIdleDll || !m_fInBeginIdleDetection)
    {
	    return -1;
    }

    Assert(g_SyncMgrIdle == this);
    Assert(m_pProgressDlg == pProgressDlg);

    g_SyncMgrIdle = this;
    m_pProgressDlg = pProgressDlg;

    m_pEndIdleDetection(0); // Review - Need to call EndIdleDetection or MSIdle.dll will leak WindowsHooks on NT 4.0.
    dwResult =  m_pBeginIdleDetection(IdleCallback,30,0);

    if (dwResult)
    {
	    g_SyncMgrIdle = NULL;
	    m_pProgressDlg = NULL;
    }
    else
    {
    	m_pSetBusyNotify(TRUE,0);
	    m_pSetIdleNotify(FALSE,0);
    }

    return dwResult;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrIdle::ResetIdle, public
//
//  Synopsis:   Resets the idle Counter.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    23-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

DWORD CSyncMgrIdle::ResetIdle(ULONG ulIdleRetryMinutes)
{
    Assert(ulIdleRetryMinutes);

    // assert we have a callback.
    Assert(g_SyncMgrIdle);
    Assert(m_pProgressDlg );

    Assert(0 == m_dwRegisteredTimer); // don't allow nested

    // if zero is passed in then set to an hour
    if (!ulIdleRetryMinutes)
        ulIdleRetryMinutes = 60;

    m_dwRegisteredTimer = SetTimer(NULL, 0, 1000*60*ulIdleRetryMinutes, (TIMERPROC) IdleOnTimerProc);

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrIdle::OffIdle, public
//
//  Synopsis:   Gets Called when an OnIdle Occurs,.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    23-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void  CSyncMgrIdle::OffIdle()
{
    // when get an offIdle first thing revoke our Idle handlers

    if (g_SyncMgrIdle->m_dwRegisteredTimer)
    {
    	KillTimer(0, g_SyncMgrIdle->m_dwRegisteredTimer);
        g_SyncMgrIdle->m_dwRegisteredTimer = 0;
    }

    Assert(m_fInBeginIdleDetection);

    if (m_fInBeginIdleDetection)
    {
        m_pEndIdleDetection(0);
        m_fInBeginIdleDetection = FALSE;
	    g_SyncMgrIdle = NULL;
    }

    if (m_pProgressDlg)
	    m_pProgressDlg->OffIdle();

    m_pProgressDlg = NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrIdle::OnIdle, public
//
//  Synopsis:   Gets Called when an OffIdle Occurs,.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    23-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void  CSyncMgrIdle::OnIdle()
{
    if (m_pProgressDlg)
	    m_pProgressDlg->OnIdle();
}


//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrIdle::CheckForIdle, public
//
//  Synopsis:   Gets Called by progress once in a while to make sure
//		an offIdle happened but our notification missed it.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    23-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CSyncMgrIdle::CheckForIdle()
{

    // currently don't do anything for this case. If we miss the off-Idle we
    // just continue. This function is a placeholder in case
    // we need to add this support.

}


//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrIdle::LoadMsIdle, private
//
//  Synopsis:   attempts to load the necessary msIdle exports.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    23-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CSyncMgrIdle::LoadMsIdle()
{
    TCHAR szFullPath[MAX_PATH+1];

    *szFullPath = 0;
    if (GetSystemDirectory(szFullPath, ARRAYSIZE(szFullPath)))
    {
        if (!PathAppend(szFullPath, szMsIdleDll))
        {
            *szFullPath = 0;
        }
        szFullPath[MAX_PATH] = 0;           // Ensure NULL termination
    }

    if (!*szFullPath)
    {
        StringCchCopy(szFullPath, ARRAYSIZE(szFullPath), szMsIdleDll);
    }

    m_hInstMsIdleDll = LoadLibrary(szFullPath);

    if (m_hInstMsIdleDll)
    {
        // for now, don't return an error is GetProc Fails but check in each function.
        m_pBeginIdleDetection = (_BEGINIDLEDETECTION) GetProcAddress(m_hInstMsIdleDll, (LPCSTR) BEGINIDLEDETECTIONORD);

        m_pEndIdleDetection = (_ENDIDLEDETECTION) GetProcAddress(m_hInstMsIdleDll, (LPCSTR) ENDIDLEDETECTIONORD);

        m_pGetIdleMinutes = (_GETIDLEMINUTES) GetProcAddress(m_hInstMsIdleDll, (LPCSTR) GETIDLEMINUTESORD);

        m_pSetBusyNotify = (_SETBUSYNOTIFY) GetProcAddress(m_hInstMsIdleDll, (LPCSTR) SETBUSYNOTIFYORD);

        m_pSetIdleNotify = (_SETIDLENOTIFY) GetProcAddress(m_hInstMsIdleDll, (LPCSTR) SETIDLENOTIFYORD);

        m_pSetIdleTimeout = (_SETIDLETIMEOUT) GetProcAddress(m_hInstMsIdleDll, (LPCSTR) SETIDLETIMEOUTORD);
    }

    if (m_hInstMsIdleDll &&
	    m_pBeginIdleDetection &&
	    m_pEndIdleDetection   &&
	    m_pGetIdleMinutes &&
	    m_pSetBusyNotify  &&
	    m_pSetIdleNotify &&
	    m_pSetIdleTimeout
	 )
    {
    	return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\exe\msg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Msg.h
//
//  Contents:   Handles inter-thread communications
//
//  Classes:    CThreadMsgProxy
//
//  Notes:      
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#ifndef _THREADMSG_
#define _THREADMSG_

// stublist for global stublist structure.
typedef struct tagSTUBLIST {
    struct tagSTUBLIST *pNextStub;	// pointer to next proxy.
    ULONG cRefs;			// number of proxies using Stub
    CLSID clsidStub;			// clsid for stub.
    HANDLE hThreadStub;			// Handle of the Stubs Thread
    DWORD ThreadIdStub;			// ThreadID to send Message to.
    HWND hwndStub;			// HWND OF STUB.
    BOOL fStubTerminated;	        // set if this stub was force terminated.
} STUBLIST;


// WMs for Thread communication

#define WM_THREADMESSAGE		(WM_USER + 1)
#define WM_CFACTTHREAD_REVOKE		(WM_USER + 2)
#define WM_MAINTHREAD_QUIT		(WM_USER + 3)
#define WM_THREADSTUBMESSAGE		(WM_USER + 4)


#define WM_USER_MAX 0x7FFF // maximum user message that can be defined.


// alll msgs are unique bits so hndlrq and others
// can keep track of out calls.

typedef enum _tagThreadMsg
{
    ThreadMsg_Initialize	    = 0x0001,
    ThreadMsg_GetHandlerInfo	    = 0x0002,
    ThreadMsg_EnumOfflineItems	    = 0x0004,
    ThreadMsg_GetItemObject	    = 0x0008,
    ThreadMsg_ShowProperties	    = 0x0010,
    ThreadMsg_SetProgressCallback   = 0x0020,

    ThreadMsg_PrepareForSync	    = 0x0040,
    ThreadMsg_Synchronize	    = 0x0080,
    ThreadMsg_SetItemStatus	    = 0x0100,
    ThreadMsg_ShowError		    = 0x0200,

    ThreadMsg_Release		    = 0x0400,
    // Private Messages
    ThreadMsg_AddHandlerItems	    = 0x1000,
    ThreadMsg_CreateServer	    = 0X2000,
    ThreadMsg_SetHndlrQueue	    = 0x4000,
    ThreadMsg_SetupCallback	    = 0x8000,

} ThreadMsg;

// messages sent to toplevel stub object.
typedef enum _tagStubMsg
{
    StubMsg_CreateNewStub	    = 0x0001,
    StubMsg_Release		    = 0x0002,
} StubMsg;

class CThreadMsgProxy;
class CThreadMsgStub;
class CHndlrMsg;
class CHndlrQueue;


typedef struct _tagHandlerThreadArgs {
HANDLE hEvent; // used to know when the message loop has been created.
HRESULT hr; // inidicates if creation was successfull
HWND hwndStub; // hwnd of stub window. This is the window messages should be posted to.
} HandlerThreadArgs;

// helper functions called by client and Server
HRESULT CreateHandlerThread(CThreadMsgProxy **pThreadProxy,HWND hwndDlg
			,REFCLSID refClsid);
STDAPI InitMessageService();



// WPARAM is messaging specific data

typedef struct _tagMessagingInfo
{
HANDLE hMsgEvent; // Handle to Message Event for synchronization.
DWORD  dwSenderThreadID; // ThreadID of the Caller.
CHndlrMsg *pCHndlrMsg; //handler message instance for this proxy.
}  MessagingInfo;



// LPARAM is information specific to the message being sent.


typedef struct _tagGenericMsg
{
HRESULT hr; // return value from the message.
UINT ThreadMsg;   // message to send.
}   GenericMsg;


// request to stubObject to create a new stub for a proxy
typedef struct _tagMSGSTUBCreateStub
{
    GenericMsg MsgGen;
    CHndlrMsg *pCHndlrMsg; // on success returns a pointer to a new hndlrMsg struct.
} MSGSTUBCreateStub;



// Message specific structures
typedef struct _tagMSGCreateServer
{
GenericMsg MsgGen;
const CLSID *pCLSIDServer;
CHndlrQueue *pHndlrQueue;
HANDLERINFO *pHandlerId;
DWORD dwProxyThreadId;
} MSGCreateServer;

// Message specific structures
typedef struct _tagSetHndlrQueue
{
GenericMsg MsgGen;
CHndlrQueue *pHndlrQueue;
HANDLERINFO *pHandlerId;
DWORD dwProxyThreadId;
} MSGSetHndlrQueue;

typedef struct _tagMSGInitialize
{
GenericMsg MsgGen;
DWORD dwReserved;
DWORD dwSyncFlags;
DWORD cbCookie;
const BYTE  *lpCookie;
} MSGInitialize;

typedef struct _tagMSGGetHandlerInfo
{
GenericMsg MsgGen;
LPSYNCMGRHANDLERINFO *ppSyncMgrHandlerInfo;
} MSGGetHandlerInfo;

typedef struct _tagMSGEnumOfflineItems
{
GenericMsg MsgGen;
ISyncMgrEnumItems** ppenumOfflineItems;
} MSGEnumOfflineItems;


typedef struct _tagMSGGetItemObject
{
GenericMsg MsgGen;
SYNCMGRITEMID ItemID;
GUID riid;
void** ppv;
} MSGGetItemObject;



typedef struct _tagMSGShowProperties
{
GenericMsg MsgGen;
HWND hWndParent;
SYNCMGRITEMID ItemID;
} MSGShowProperties;


typedef struct _tagMSGSetProgressCallback
{
GenericMsg MsgGen;
ISyncMgrSynchronizeCallback *lpCallBack;
} MSGSetProgressCallback;



typedef struct _tagMSGPrepareForSync
{
GenericMsg MsgGen;

// SetHndlrQueue Items
CHndlrQueue *pHndlrQueue;
HANDLERINFO *pHandlerId;

// PrepareForSyncItems 
ULONG cbNumItems;
SYNCMGRITEMID *pItemIDs;
HWND hWndParent;
DWORD dwReserved;
} MSGPrepareForSync;


typedef struct _tagMSGSynchronize
{
GenericMsg MsgGen;
HWND hWndParent;
} MSGSynchronize;

typedef struct _tagMSGSetItemStatus
{
GenericMsg MsgGen;
SYNCMGRITEMID ItemID;
DWORD dwSyncMgrStatus;
} MSGSetItemStatus;



typedef struct _tagMSGShowErrors
{
GenericMsg MsgGen;
HWND hWndParent;
SYNCMGRERRORID ErrorID;
ULONG *pcbNumItems;
SYNCMGRITEMID **ppItemIDs;
} MSGShowConflicts;

typedef struct _tagMSGLogErrors
{
DWORD mask;
SYNCMGRERRORID ErrorID;
BOOL fHasErrorJumps;
SYNCMGRITEMID ItemID;
DWORD dwErrorLevel;
const WCHAR *lpcErrorText;
} MSGLogErrors;


typedef struct _tagMSGDeleteLogErrors
{
HANDLERINFO *pHandlerId;
SYNCMGRERRORID ErrorID;
} MSGDeleteLogErrors;


typedef struct _tagMSGAddItemHandler
{
GenericMsg MsgGen;
HWND hwndList; // review, unused.
DWORD *pcbNumItems;
} MSGAddItemHandler;

typedef struct _tagMSGSetupCallback
{
GenericMsg MsgGen;
BOOL fSet;
} MSGSetupCallback;


// inherit from IOfflineSynchronize to catch any interface changes.

class CThreadMsgProxy 
{
public:
    CThreadMsgProxy();
    ~CThreadMsgProxy();

    STDMETHODIMP InitProxy(HWND hwndStub, DWORD ThreadId,HANDLE hThread,HWND hwndDlg,
			REFCLSID refClsid,STUBLIST *pStubId);					
    STDMETHODIMP DispatchMsg(GenericMsg *genMsg,BOOL fAllowIncomingCalls,BOOL fAsync);
    STDMETHODIMP DispatchsStubMsg(GenericMsg *pgenMsg,BOOL fAllowIncomingCalls);

    //IUnknown members
    STDMETHODIMP	    QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // IOfflineSynchronize Methods
    STDMETHODIMP Initialize(DWORD dwReserved,DWORD dwSyncFlags,
				DWORD cbCookie,const BYTE *lpCooke);

    STDMETHODIMP GetHandlerInfo(LPSYNCMGRHANDLERINFO *ppSyncMgrHandlerInfo);
        
    STDMETHODIMP EnumSyncMgrItems(ISyncMgrEnumItems **ppenumOfflineItems);
    STDMETHODIMP GetItemObject(REFSYNCMGRITEMID ItemID,REFIID riid,void** ppv);
    STDMETHODIMP ShowProperties(HWND hWndParent,REFSYNCMGRITEMID ItemID);
    STDMETHODIMP SetProgressCallback(ISyncMgrSynchronizeCallback *lpCallBack);
    STDMETHODIMP PrepareForSync(ULONG cbNumItems,SYNCMGRITEMID *pItemIDs,
			    HWND hWndParent,DWORD dwReserved);
    STDMETHODIMP Synchronize(HWND hWndParent);
    STDMETHODIMP SetItemStatus(REFSYNCMGRITEMID ItemID,DWORD dwSyncMgrStatus);
    STDMETHODIMP ShowError(HWND hWndParent,REFSYNCMGRERRORID ErrorID,ULONG *pcbNumItems,SYNCMGRITEMID **ppItemIDs);

    // Private messages
    STDMETHODIMP  CreateServer(const CLSID *pCLSIDServer,CHndlrQueue *pHndlrQueue,HANDLERINFO *pHandlerId);
    STDMETHODIMP  SetHndlrQueue(CHndlrQueue *pHndlrQueue,
			HANDLERINFO *pHandlerId,
			DWORD dwThreadIdProxy);
    STDMETHODIMP  AddHandlerItems(HWND hwndList,DWORD *pcbNumItems);
    STDMETHODIMP  SetupCallback(BOOL fSet);
    STDMETHODIMP  SetProxyParams(HWND hwndDlg, DWORD ThreadIdProxy,
			    CHndlrQueue *pHndlrQueue,HANDLERINFO *pHandlerId );

    inline STDMETHODIMP  SetProxyHwndDlg(HWND hwndDlg) { 
			m_hwndDlg = hwndDlg; 
			return S_OK; 
			}

    inline BOOL IsProxyInOutCall() { return m_dwNestCount; }
    STDMETHODIMP SetProxyCompletion(HWND hWnd,UINT Msg,WPARAM wParam,LPARAM lParam);

    // messages sent to the toplevel stub object.

    STDMETHODIMP CreateNewHndlrMsg();
    STDMETHODIMP ReleaseStub();
    STDMETHODIMP TerminateHandlerThread(TCHAR *pszHandlerName,BOOL fPromptUser);

private:
    HANDLE m_hThreadStub; // Handle of the Stubs Thread
    DWORD m_ThreadIdStub; // ThreadID to send Message to.
    HWND m_hwndStub; // HWND OF STUB.
    CHndlrMsg *m_pCHndlrMsg; // HndlrMsg associated with this proxy.
    BOOL  m_fTerminatedHandler; // set to true if handler has been terminated.
    STUBLIST *m_pStubId; // Id of stub this proxy belongs to.
    HWND  m_hwndDlg; // hwnd of any dialog on this thread.
    CLSID m_Clsid; // clsid of this handler.
    DWORD m_ThreadIdProxy;

    
    // Proxy Side Information
    CHndlrQueue *m_pHndlrQueue;
    HANDLERINFO * m_pHandlerId;
    BOOL m_fNewHndlrQueue; // set to indicate if Stub side information is out of date.
    DWORD m_dwNestCount; // keeps track of number of nestcount on item so can determine if in out call.
    MSG m_msgCompletion;
    BOOL m_fHaveCompletionCall;

    DWORD m_cRef;
};

#define MSGSERVICE_HWNDCLASSNAME  "SyncMgr_HwndMsgService"
#define DWL_THREADWNDPROCCLASS 0 // window long offset to MsgService Hwnd this ptr.


LRESULT CALLBACK  MsgThreadWndProc(HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);

typedef enum _tagMSGHWNDTYPE   
{	
    MSGHWNDTYPE_UNDEFINED			= 0x0, // Message Service has not been initialized
    MSGHWNDTYPE_HANDLERTHREAD			= 0x1, // Message Service if for a Handler Thread.
    MSGHWNDTYPE_MAINTHREAD			= 0x2, // Message Service if for the Main Thread
} MSGHWNDTYPE;

typedef struct _tagMSGSERVICEQUEUE
{
  struct _tagMSGSERVICEQUEUE *pNextMsg;
  DWORD dwNestCount; // nestcount completion should be called.
  MSG msg;
} MSGSERVICEQUEUE;

class CMsgServiceHwnd 
{
public:
    HWND m_hwnd;
    DWORD m_dwThreadID;
    CHndlrMsg *m_pHndlrMsg;
    MSGHWNDTYPE m_MsgHwndType;
    MSGSERVICEQUEUE *m_pMsgServiceQueue; // queue to hold any message to process when current
					// cal completes.
    BOOL m_fInOutCall;

    CMsgServiceHwnd();
    ~CMsgServiceHwnd();
    inline HWND GetHwnd() { return m_hwnd; };
    BOOL Initialize(DWORD dwThreadID,MSGHWNDTYPE MsgHwndType);
    HRESULT HandleThreadMessage(MessagingInfo *pmsgInfo,GenericMsg *pgenMsg);
    void Destroy();
};

// internal functions
HRESULT SendThreadMessage(DWORD idThread,UINT uMsg,WPARAM wParam,LPARAM lParam);
DWORD WINAPI HandlerThread( LPVOID );
HRESULT DoModalLoop(HANDLE hEvent,HANDLE hThread,HWND hwndDlg,BOOL fAllowIncomingCalls,DWORD dwTimeout);


#endif // _THREADMSG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\exe\idle.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       idle.h
//
//  Contents:   Idle notification routines.
//
//  Classes:
//
//  Notes:
//
//  History:    23-Feb-98   rogerg      Created.
//
//--------------------------------------------------------------------------

#ifndef _SYNCMGRIDLE_
#define _SYNCMGRIDLE_

// this is a copy of msidle.h routines we need since msidle.h is not defined in public

typedef void (WINAPI* _IDLECALLBACK) (DWORD dwState);

#define STATE_USER_IDLE_BEGIN       1
#define STATE_USER_IDLE_END         2

//
// BeginIdleDetection - start monitoring idleness
//
// pfnCallback - function to call back when idle state changes
// dwIdleMin - minutes of inactivity before idle callback
// dwReserved - must be 0
//
// Returns: 0 on success, error code on failure
//
// Note: Exported as ordinal 3
//
DWORD BeginIdleDetection(_IDLECALLBACK pfnCallback, DWORD dwIdleMin, DWORD dwReserved);

typedef DWORD (WINAPI* _BEGINIDLEDETECTION) (_IDLECALLBACK, DWORD, DWORD);

//
// EndIdleDetection - stop monitoring idleness
//
// Returns: TRUE on success, FALSE on failure
//
// Note: Exported as ordinal 4
//
BOOL EndIdleDetection(DWORD dwReserved);

typedef BOOL (WINAPI* _ENDIDLEDETECTION) (DWORD);

//
// SetIdleTimeout - Set minutes for idle timeout and reset idle state
//
// dwMinutes - new minutes threshold for idleness
// fResetState - flag to return to non-idle state to retrigger idle callback
// dwReserved - must be 0
//
// Note: Exported as ordinal 5
//
BOOL SetIdleTimeout(DWORD dwMinutes, DWORD dwReserved);

typedef BOOL (WINAPI* _SETIDLETIMEOUT) (DWORD, DWORD);

//
// SetIdleNotify - Turns on or off notification when idle
//
// fNotify - flag whether to notify or not
// dwReserved - must be 0
//
// Note: Exported as ordinal 6
//
void SetIdleNotify(BOOL fNotify, DWORD dwReserved);

typedef void (WINAPI* _SETIDLENOTIFY) (BOOL, DWORD);

//
// SetBusyNotify - Turns on or off notification when busy
//
// fNotify - flag whether to notify or not
// dwReserved - must be 0
//
// Note: Exported as ordinal 7
//
void SetBusyNotify(BOOL fNotify, DWORD dwReserved);

typedef void (WINAPI* _SETBUSYNOTIFY) (BOOL, DWORD);

//
// GetIdleMinutes
//
// dwReserved - must be 0
//
// Returns number of minutes since user's last activity
//
// Note: Exported as ordinal 8
//
DWORD GetIdleMinutes(DWORD dwReserved);

typedef DWORD (WINAPI* _GETIDLEMINUTES) (DWORD);


// end of msidle.h copy

class CProgressDlg;

void WINAPI IdleCallback(DWORD dwState); // callback for registering with Idle.

class CSyncMgrIdle
{
public:
    CSyncMgrIdle();
    ~CSyncMgrIdle();

    BOOL Initialize();

    DWORD BeginIdleDetection(CProgressDlg *pProgressDlg,DWORD dwIdleMin, DWORD dwReserved);
    DWORD ReRegisterIdleDetection(CProgressDlg *pProgressDlg);
    DWORD ResetIdle(ULONG ulIdleRetryMinutes);
    void OffIdle();
    void OnIdle();
    void CheckForIdle();

private:
    BOOL LoadMsIdle();

    HINSTANCE m_hInstMsIdleDll;
    _BEGINIDLEDETECTION m_pBeginIdleDetection;
    _ENDIDLEDETECTION m_pEndIdleDetection;
    _GETIDLEMINUTES m_pGetIdleMinutes;
    _SETBUSYNOTIFY m_pSetBusyNotify;
    _SETIDLENOTIFY m_pSetIdleNotify;
    _SETIDLETIMEOUT m_pSetIdleTimeout;

    BOOL m_fInBeginIdleDetection;
    DWORD_PTR m_dwRegisteredTimer;
    BOOL m_fReceivedOffIdle;
    CProgressDlg *m_pProgressDlg;

    friend void WINAPI IdleCallback(DWORD dwState);
    friend VOID CALLBACK IdleOnTimerProc(HWND hwnd,UINT uMsg,UINT idEvent,DWORD dwTime);
};




#endif // _SYNCMGRIDLE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\exe\objmgr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Objmgr.cpp
//
//  Contents:   Keeps track of dialog objects and
//              application lifetime
//
//  Classes:
//
//  Notes:
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

STDAPI DisplayOptions(HWND hwndOwner); // OneStop.dll Export

CSingletonNetApi gSingleNetApiObj;         // Global singleton NetApi object

CRITICAL_SECTION g_LockCountCriticalSection; // Critical Section fo Object Mgr
OBJECTMGRDATA g_ObjectMgrData; // Global Object Mgr Data

#ifdef _DEBUG
DWORD g_ThreadCount = 0;
#endif // _DEBUG

//+---------------------------------------------------------------------------
//
//  Function:   CreateDlgThread, public
//
//  Synopsis:   Called to Create a new Dlg Thread
//
//  Arguments:  [dlgType] - Type of Dialog to create
//              [nCmdShow] - How to display the Dialog.
//              [ppDlg] - on success returns a pointer to the new dialog
//              [pdwThreadID] - on Success Id of thread that was created.
//              [phThread] - Handle to newly created thread.
//
//  Returns:    Appropriate return codes
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT CreateDlgThread(DLGTYPE dlgType,REFCLSID rclsid,int nCmdShow,CBaseDlg **ppDlg,
                            DWORD *pdwThreadID,HANDLE *phThread)
{
    HRESULT hr = E_FAIL;
    HANDLE hNewThread = NULL;
    DlgThreadArgs ThreadArgs;

    *phThread = NULL;
    *ppDlg = NULL;

    ThreadArgs.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (ThreadArgs.hEvent)
    {
        ThreadArgs.dlgType = dlgType;
        ThreadArgs.clsid = rclsid;
        ThreadArgs.pDlg = NULL;
        ThreadArgs.nCmdShow = nCmdShow;
        ThreadArgs.hr = E_UNEXPECTED;

        hNewThread = CreateThread(NULL,0,DialogThread,&ThreadArgs,0,pdwThreadID);

        if (hNewThread)
        {
            WaitForSingleObject(ThreadArgs.hEvent,INFINITE);
            if (S_OK == ThreadArgs.hr)
            {
                *phThread = hNewThread;
                *ppDlg = ThreadArgs.pDlg;
                hr = S_OK;
            }
            else
            {
                CloseHandle(hNewThread);
                hr = ThreadArgs.hr;
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }

        CloseHandle(ThreadArgs.hEvent);
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   DialogThread, public
//
//  Synopsis:   ThreadProc for a new Dlg Thread
//              !!!Warning - Must always ensure event in ThreadArg gets set.
//
//  Arguments:  [lpArg] - Pointer to DialogThreadArgs
//
//  Returns:    Appropriate return codes. Sets hr value in
//              ThreadArgs before setting event object
//
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

DWORD WINAPI DialogThread( LPVOID lpArg )
{
    MSG msg;
    HRESULT hr;
    HRESULT hrCoInitialize;
    DWORD cRefs;
    HWND hwndDlg;
    DlgThreadArgs *pThreadArgs = (DlgThreadArgs *) lpArg;

    pThreadArgs->hr = S_OK;

    hrCoInitialize = CoInitialize(NULL);

    switch (pThreadArgs->dlgType)
    {
    case DLGTYPE_CHOICE:
        pThreadArgs->pDlg = new CChoiceDlg(pThreadArgs->clsid);
        break;

    case DLGTYPE_PROGRESS:
        pThreadArgs->pDlg = new CProgressDlg(pThreadArgs->clsid);
        break;

    default:
       pThreadArgs->pDlg = NULL;
       AssertSz(0,"Unknown Dialog Type");
       break;
    }

    // need to do a PeekMessage and then set an event to make sure
    // a message loop is created before the first PostMessage is sent.

    PeekMessage(&msg, NULL, WM_USER, WM_USER, PM_NOREMOVE);

    // initialize the dialog box before returning to main thread.
    if ( (NULL == pThreadArgs->pDlg)
            || (FALSE == pThreadArgs->pDlg->Initialize(GetCurrentThreadId(),pThreadArgs->nCmdShow))
            || (FAILED(hrCoInitialize)) )
    {
        if (pThreadArgs->pDlg)
            pThreadArgs->pDlg->PrivReleaseDlg(RELEASEDLGCMDID_DESTROY);

        pThreadArgs->hr = E_OUTOFMEMORY;
    }
    else
    {
        hwndDlg = pThreadArgs->pDlg->GetHwnd();
    }

    hr = pThreadArgs->hr;
#ifdef _DEBUG
    ++g_ThreadCount;
#endif // _DEBUG

    cRefs = AddRefOneStopLifetime(FALSE /* !External */); // make sure we stay alive for lifetime of thread.
    Assert(cRefs > 1); // someone else should also have a lock during dialog creation.

    // let the caller know the thread is done initializing.
    if (pThreadArgs->hEvent)
        SetEvent(pThreadArgs->hEvent);

    if (S_OK == hr)
    {
        // sit in loop receiving messages.
        while (GetMessage(&msg, NULL, 0, 0))
        {
            if (!IsDialogMessage(hwndDlg,&msg))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }

    if (SUCCEEDED(hrCoInitialize))
        CoUninitialize();

#ifdef _DEBUG
    --g_ThreadCount;
#endif // _DEBUG

    ReleaseOneStopLifetime(FALSE /* !External */);

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   FindDialog, private
//
//  Synopsis:   Looks to see if there is an existing  dialog
//              matching the type and  clsid. If not and fCreate is true a
//              new  dialog will be made. If fCreate is false
//              and no dialog is found S_FALSE will be returned.
//
//  Arguments:  [rclcisd] - clsid of choice dialog
//              [fCreate] - If true and no choice dialog found a new one will
//                          be created.
//              [nCmdShow] - How to Create the dialog
//              [pChoiceDlg] - On Success is a pointer to the new Choice Dialog.
//
//  Returns:    Appropriate return codes.
//
//
//  Modifies:
//
//  History:    17-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI FindDialog(DLGTYPE dlgType,REFCLSID rclsid,BOOL fCreate,int nCmdShow,CBaseDlg **pDlg)
{
    DLGLISTITEM *pDlgListItem;
    HWND hwnd = NULL;
    CCriticalSection cCritSect(&g_LockCountCriticalSection,GetCurrentThreadId());

   *pDlg = NULL;

    cCritSect.Enter();

    pDlgListItem = g_ObjectMgrData.DlgList;

    // look for existing.
    while (pDlgListItem)
    {
        if ( (rclsid == pDlgListItem->clsid) && (dlgType == pDlgListItem->dlgType) )
        {
            break;
        }

        pDlgListItem = pDlgListItem->pDlgNextListItem;
    }

    if (pDlgListItem)
    {
        Assert((pDlgListItem->cRefs > 0) || (pDlgListItem->cLocks > 0) );

        ++pDlgListItem->cRefs;
        *pDlg = pDlgListItem->pDlg;
    }

    // didn't find a match if fCreate is set then try to create one.
    if (fCreate && NULL == *pDlg)
    {
        CBaseDlg *pNewDlg;
        DLGLISTITEM *pNewDlgListItem;
        DWORD dwThreadID;
        pNewDlgListItem = (DLGLISTITEM *) ALLOC(sizeof(DLGLISTITEM));

        if (pNewDlgListItem)
        {
            HRESULT hr;
            HANDLE hThread;

            cCritSect.Leave();
            hr = CreateDlgThread(dlgType,rclsid,nCmdShow,&pNewDlg,&dwThreadID,&hThread);
            cCritSect.Enter();

            if (S_OK == hr )
            {
                // its possible that while we had the lock count released a request
                // for the same  dialog came through so rescan to make sure we
                // don't have a match

                pDlgListItem = g_ObjectMgrData.DlgList;

                // look for existing.
                while (pDlgListItem)
                {
                    if ( (rclsid == pDlgListItem->clsid) &&  (dlgType == pDlgListItem->dlgType) )
                    {
                        break;
                    }

                    pDlgListItem = pDlgListItem->pDlgNextListItem;
                }

                // if found a match then incrmement its cRef,
                // delete the new one we just created,
                // and return a pointer to the one in the list
                // else add new dialog to the list.
                if (pDlgListItem)
                {
                    // delete our newly create dialog and structure.
                    CloseHandle(hThread);
                    FREE(pNewDlgListItem);
                    pNewDlg->ReleaseDlg(RELEASEDLGCMDID_DESTROY);

                    // increment found dialog and set the out param
                    Assert(pDlgListItem->cRefs > 0);
                    ++pDlgListItem->cRefs;
                    *pDlg = pDlgListItem->pDlg;
                }
                else
                {
                    // iniitalize the structure.
                    pNewDlgListItem->dlgType = dlgType;
                    pNewDlgListItem->cRefs = 1;
                    pNewDlgListItem->cLocks = 0;
                    pNewDlgListItem->clsid = rclsid;
                    pNewDlgListItem->pDlg = pNewDlg;
                    pNewDlgListItem->dwThreadID = dwThreadID;
                    pNewDlgListItem->hThread = hThread;
                    pNewDlgListItem->fHasReleaseDlgCmdId = FALSE;
                    pNewDlgListItem->wCommandID = RELEASEDLGCMDID_DEFAULT;

                    *pDlg = pNewDlg;

                    // now add to the beginning of the list.
                    pNewDlgListItem->pDlgNextListItem = g_ObjectMgrData.DlgList;
                    g_ObjectMgrData.DlgList = pNewDlgListItem;

                    ++g_ObjectMgrData.LockCountInternal; // increment the LockCount
                }
            }
            else
            {
                FREE(pNewDlgListItem);
            }
        }
    }

    // if found an existing dialog, update the z-Order
    if (*pDlg)
    {
        hwnd = (*pDlg)->GetHwnd();
    }

    cCritSect.Leave();

    if (hwnd)
    {
        BASEDLG_SHOWWINDOW(hwnd,nCmdShow);
    }

    return *pDlg ? S_OK : S_FALSE;
}


//+---------------------------------------------------------------------------
//
//  Function:   AddRefDialog, private
//
//  Synopsis:   Looks to see if there is an existing  dialog
//              matching the type and  clsid and puts an addref on it.
//
//  Arguments:
//
//  Returns:    Appropriate return codes.
//
//
//  Modifies:
//
//  History:    17-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) AddRefDialog(DLGTYPE dlgType,REFCLSID rclsid,CBaseDlg *pDlg)
{
    DLGLISTITEM dlgListDummy;
    DLGLISTITEM *pDlgListItem = &dlgListDummy;
    ULONG cRefs = 1;
    CCriticalSection cCritSect(&g_LockCountCriticalSection,GetCurrentThreadId());

    cCritSect.Enter();

    pDlgListItem = g_ObjectMgrData.DlgList;

    // look for existing.
    while (pDlgListItem)
    {
        if ( (rclsid == pDlgListItem->clsid) &&  (dlgType == pDlgListItem->dlgType) )
        {
            break;
        }

        pDlgListItem = pDlgListItem->pDlgNextListItem;
    }

    if (pDlgListItem)
    {
         // since only allow one choice at a time Dlg should always match.
        Assert(pDlgListItem->pDlg == pDlg);
        cRefs = ++pDlgListItem->cRefs;
    }
    else
    {
        cCritSect.Leave();
        AssertSz(0,"Addref Called on invalid DLG");
        cCritSect.Enter();
    }

    cCritSect.Leave();
    return cRefs;
}


//+---------------------------------------------------------------------------
//
//  Function:   ReleaseDialog, private
//
//  Synopsis:   Looks to see if there is an existing  dialog
//              matching the type and  clsid and calls release on it..
//
//  Arguments:
//
//  Returns:    Appropriate return codes.
//
//
//  Modifies:
//
//  History:    17-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) ReleaseDialog(DLGTYPE dlgType,REFCLSID rclsid,CBaseDlg *pDlg,BOOL fForce)
{
    DLGLISTITEM dlgListDummy;
    DLGLISTITEM *pDlgListItem = &dlgListDummy;
    CCriticalSection cCritSect(&g_LockCountCriticalSection,GetCurrentThreadId());

    cCritSect.Enter();

    pDlgListItem->pDlgNextListItem = g_ObjectMgrData.DlgList;

    // look for existing.
    while (pDlgListItem->pDlgNextListItem)
    {
        if ( (dlgType == pDlgListItem->pDlgNextListItem->dlgType)
            && (rclsid == pDlgListItem->pDlgNextListItem->clsid) )
        {
            DLGLISTITEM *pDlgListMatch;
            DWORD cRefs;

            pDlgListMatch = pDlgListItem->pDlgNextListItem;

            Assert(pDlgListMatch->pDlg == pDlg);

            cRefs = --pDlgListMatch->cRefs;
            Assert(0 <= ((LONG) cRefs));

            // 2/23/98 rogerg changed cLocks to go to zero if
            // flocks is set in case the cancel (which is the only button to set force)
            // release comes in before a an object that just needs to keep the dialog alive.

            if (fForce)
                pDlgListMatch->cLocks = 0;

            if (0 >= cRefs && (0 == pDlgListMatch->cLocks || fForce) )
            {
                HANDLE hThread;

                // remove the item from the list.
                pDlgListItem->pDlgNextListItem = pDlgListMatch->pDlgNextListItem;
                g_ObjectMgrData.DlgList = dlgListDummy.pDlgNextListItem;

                cCritSect.Leave();

                // we should have always set the callback
                Assert(TRUE == pDlgListMatch->fHasReleaseDlgCmdId);

                pDlgListMatch->pDlg->ReleaseDlg(pDlgListMatch->wCommandID);
                pDlgListMatch->fHasReleaseDlgCmdId = FALSE;
                hThread = pDlgListMatch->hThread;

                FREE(pDlgListMatch);
                ReleaseOneStopLifetime(FALSE /* !External */); // release the ServerCount

                CloseHandle(hThread);
            }
            else
            {
                cCritSect.Leave();
            }

            return cRefs;
        }

        pDlgListItem = pDlgListItem->pDlgNextListItem;
    }

    // if got here and didn't find let us know
    Assert(0);
    cCritSect.Leave();

    return 0; // we return zero if can't find the item.
}

//+---------------------------------------------------------------------------
//
//  Function:   SetReleaseDlgCmdId, private
//
//  Synopsis:   Sets the releaseCmdId for the specified dialog.
//
//  Arguments:
//
//  Returns:    Appropriate return codes.
//
//
//  Modifies:
//
//  History:    17-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI SetReleaseDlgCmdId(DLGTYPE dlgType,REFCLSID rclsid,CBaseDlg *pDlg,WORD wCommandId)
{
    HRESULT hr;
    DLGLISTITEM *pDlgListItem;
    CCriticalSection cCritSect(&g_LockCountCriticalSection,GetCurrentThreadId());

    cCritSect.Enter();

    pDlgListItem = g_ObjectMgrData.DlgList;

    // look for existing.
    while (pDlgListItem)
    {
        if ( (rclsid == pDlgListItem->clsid) &&  (dlgType == pDlgListItem->dlgType) )
        {

           // should only ever be one choice dialog in the list
           Assert(pDlg == pDlgListItem->pDlg);

           // if there is already a cmdId associated don't replace it
            pDlgListItem->fHasReleaseDlgCmdId = TRUE;
            pDlgListItem->wCommandID = wCommandId;
            hr =  S_OK;

            cCritSect.Leave();
            return hr;
        }

        pDlgListItem = pDlgListItem->pDlgNextListItem;
    }

    cCritSect.Leave();
    Assert(0); // object wasn't found for some reason.

    return E_UNEXPECTED;
}


//+---------------------------------------------------------------------------
//
//  Function:   FindChoiceDialog, public
//
//  Synopsis:   Looks to see if there is an existing choice dialog
//              matching the clsid. If not and fCreate is true a
//              new choice dialog will be made. If fCreate is false
//              and no dialog is found S_FALSE will be returned.
//
//  Arguments:  [rclcisd] - clsid of choice dialog
//              [fCreate] - If true and no choice dialog found a new one will
//                          be created.
//              [nCmdShow] - How to Create the dialog
//              [pChoiceDlg] - On Success is a pointer to the new Choice Dialog.
//
//  Returns:    Appropriate return codes.
//
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI FindChoiceDialog(REFCLSID rclsid,BOOL fCreate,int nCmdShow,CChoiceDlg **pChoiceDlg)
{
    return FindDialog(DLGTYPE_CHOICE,rclsid,fCreate,nCmdShow,(CBaseDlg**) pChoiceDlg);
}


//+---------------------------------------------------------------------------
//
//  Function:   ReleaseChoiceDialog, public
//
//  Synopsis:   Releases the ChoiceDialog matching the clsid
//              and Dialog Ptr. If it finds a match, and the
//              refcount decrements to zero the dialog if first
//              removed from the list and then its ReleaseDlg
//              method is called.
//
//  Arguments:  [rclcisd] - clsid of choice dialog
//              [pChoiceDlg] - Ptr to the Choice dialog
//
//  Returns:    Appropriate return codes.
//
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) ReleaseChoiceDialog(REFCLSID rclsid,CChoiceDlg *pChoiceDlg)
{
    return ReleaseDialog(DLGTYPE_CHOICE,rclsid,pChoiceDlg,FALSE);
}

//+---------------------------------------------------------------------------
//
//  Function:   AddRefChoiceDialog, public
//
//  Synopsis:   puts an Addref of the choice dialog
//
//  Arguments:  [rclsid] - Identifies the choice dialog
//              [pChoiceDlg] - Ptr to the choice dialog
//
//  Returns:    New Reference count
//
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) AddRefChoiceDialog(REFCLSID rclsid,CChoiceDlg *pChoiceDlg)
{
    return AddRefDialog(DLGTYPE_CHOICE,rclsid,pChoiceDlg);
}


//+---------------------------------------------------------------------------
//
//  Function:   SetChoiceReleaseDlgCmdId, public
//
//  Synopsis:   Sets the CommandId to be used inthe
//              ReleaseDlg is call when the dialog is destroyed.
//
//  Arguments:  [rclcisd] - clsid of choice dialog
//              [pChoiceDlg] - Ptr to the Choice dialog
//              [wCommandId] - CommandId to pass to ReleaseDlg
//
//  Returns:    Appropriate return codes.
//
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI SetChoiceReleaseDlgCmdId(REFCLSID rclsid,CChoiceDlg *pChoiceDlg,WORD wCommandId)
{
    return SetReleaseDlgCmdId(DLGTYPE_CHOICE,rclsid,pChoiceDlg,wCommandId);
}


//+---------------------------------------------------------------------------
//
//  Function:   FindProgressDialog, public
//
//  Synopsis:   Looks to see if there is an existing progress dialog.
//              If not and fCreate is true a new progress dialog will be made.
//              If fCreate is false and no dialog is found S_FALSE will be returned.
//
//  Arguments:  [fCreate] - If true and no choice dialog found a new one will
//                          be created.
//              [nCmdShow] - How to display the dialog
//              [pProgressDlg] - On Success is a pointer to the new Progress Dialog.
//
//  Returns:    Appropriate return codes.
//
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI FindProgressDialog(REFCLSID rclsid,BOOL fCreate,int nCmdShow,CProgressDlg **pProgressDlg)
{
    return FindDialog(DLGTYPE_PROGRESS,rclsid,fCreate,nCmdShow,(CBaseDlg **) pProgressDlg);
}


//+---------------------------------------------------------------------------
//
//  Function:   ReleaseProgressDialog, public
//
//  Synopsis:   Releases the Progress dialog matching the Dialog Ptr.
//              If it finds a match, and the
//              refcount decrements to zero the dialog if first
//              removed from the list and then its ReleaseDlg
//              method is called.
//
//  Arguments:  [fForce] - if refs gos to zero releases the dialog
//                         even if there is a lock on it.
//              [pProgressDlg] - Ptr to the Progress dialog
//
//  Returns:    New Reference count.
//
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) ReleaseProgressDialog(REFCLSID rclsid,CProgressDlg *pProgressDlg,BOOL fForce)
{
    return ReleaseDialog(DLGTYPE_PROGRESS,rclsid,pProgressDlg,fForce);
}

//+---------------------------------------------------------------------------
//
//  Function:   AddRefProgressDialog, public
//
//  Synopsis:   puts an Addref of the progress dialog
//
//  Arguments:  [fForce] - if refs gos to zero releases the dialog
//                         even if there is a lock on it.
//              [pProgressDlg] - Ptr to the Progress dialog
//
//  Returns:    New Reference count
//
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) AddRefProgressDialog(REFCLSID clsid,CProgressDlg *pProgressDlg)
{
    return AddRefDialog(DLGTYPE_PROGRESS,clsid,pProgressDlg);
}

//+---------------------------------------------------------------------------
//
//  Function:   SetProgressReleaseDlgCmdId, public
//
//  Synopsis:   Sets the Callback for the Progress dialog that
//              is called when the Progress dialog has been removed
//              from the list.
//
//  Arguments:  [pProgressDlg] - Ptr to the Progress dialog
//              [wCommandId] - CommandId to pass to ReleaseDlg
//
//  Returns:    Appropriate Error codes
//
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI SetProgressReleaseDlgCmdId(REFCLSID clsid,CProgressDlg *pProgressDlg,WORD wCommandId)
{
    return SetReleaseDlgCmdId(DLGTYPE_PROGRESS,clsid,pProgressDlg,wCommandId);
}


//+---------------------------------------------------------------------------
//
//  Function:   LockProgressDialog, public
//
//  Synopsis:   Add/Removes Lock on the Progress Dialog.
//              When there is a lock on the Progress Dialog
//              it won't go away when the reference count
//              goes to zero.
//
//              !!Dialog will not go away if lock count
//              goes to zero even if cRefs are currently zero
//
//
//  Arguments:  [pProgressDlg] - Ptr to the Progress dialog
//              [fLock] - BOOL whether to lock/unlocK
//
//  Returns:    Appropriate Error codes
//
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg      Created.
//  History     09-Dec-98       rogerg      Change so lock was a bool instead of refcount
//                                          to have same behavior as release with force flag
//
//----------------------------------------------------------------------------

STDAPI LockProgressDialog(REFCLSID clsid,CProgressDlg *pProgressDlg,BOOL fLock)
{
    HRESULT hr = S_FALSE;
    DLGLISTITEM *pDlgListItem;
    CCriticalSection cCritSect(&g_LockCountCriticalSection,GetCurrentThreadId());

    cCritSect.Enter();

    pDlgListItem = g_ObjectMgrData.DlgList;

    // look for existing.
    while (pDlgListItem)
    {
        if ( (DLGTYPE_PROGRESS == pDlgListItem->dlgType) && (clsid == pDlgListItem->clsid) )
        {
            break;
        }

        pDlgListItem = pDlgListItem->pDlgNextListItem;
    }

    if (pDlgListItem)
    {
        if (fLock)
        {
            pDlgListItem->cLocks = 1;
        }
        else
        {
            pDlgListItem->cLocks = 0;
        }

        hr = S_OK;
    }
    else
    {
        AssertSz(0,"Dialog Not found in Lock");
    }

    cCritSect.Leave();

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   ShowOptionsDialog, public
//
//  Synopsis:   Displays the options dialog. If one is already displayed
//              it just brings it to the foreground.
//
//  Arguments:  [hwndParent] - Use as parent if dialog doesn't already exist
//
//  Returns:    Appropriate Error codes
//
//
//  Modifies:
//
//  History:    24-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI ShowOptionsDialog(HWND hwndParent)
{
    DlgSettingsArgs ThreadArgs;
    HRESULT hr = E_FAIL;
    HANDLE hNewThread = NULL;
    DWORD dwThreadId;

    ThreadArgs.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (ThreadArgs.hEvent)
    {
        ThreadArgs.hwndParent = hwndParent;
        ThreadArgs.dwParentThreadId = GetCurrentThreadId();

        hr = S_OK;

        hNewThread = CreateThread(NULL,0,SettingsThread,&ThreadArgs,0,&dwThreadId);

        if (hNewThread)
        {
            WaitForSingleObject(ThreadArgs.hEvent,INFINITE);
            CloseHandle(hNewThread); // we'll let the thread take care of itself
        }

        CloseHandle(ThreadArgs.hEvent);
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   SettingsThread, private
//
//  Synopsis:   Worker thread for displaying the settings dialog.
//
//  Arguments:
//
//  Returns:
//
//
//  Modifies:
//
//  History:    24-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

DWORD WINAPI  SettingsThread( LPVOID lpArg )
{
    DlgSettingsArgs *pThreadArgs = (DlgSettingsArgs *) lpArg;
    HWND hwndParent;
    CCriticalSection cCritSect(&g_LockCountCriticalSection,GetCurrentThreadId());

    hwndParent = pThreadArgs->hwndParent;

    // see if we are already in a DisplayOptions Dialog
    // and if so just return,

    AddRefOneStopLifetime(FALSE /* !External */);

    // Increment settings ref count
    cCritSect.Enter();
    ++g_ObjectMgrData.dwSettingsLockCount;
    cCritSect.Leave();

    // attach the thread input with the creating thread so focus works correctly.
    AttachThreadInput(GetCurrentThreadId(),pThreadArgs->dwParentThreadId,TRUE);

    // let the caller know the thread is done initializing.
    if (pThreadArgs->hEvent)
        SetEvent(pThreadArgs->hEvent);

    DisplayOptions(hwndParent);  // exported in the OneStop Dll.

    // decrement the settings lock count
    cCritSect.Enter();
    --g_ObjectMgrData.dwSettingsLockCount;
    cCritSect.Leave();

    ReleaseOneStopLifetime(FALSE /* !External */);

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   RegisterOneStopCLSIDs, private
//
//  Synopsis:   Registers the Clsids associated with the OneStop app
//
//  Arguments:
//
//  Returns:    Appropriate Error codes
//
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI RegisterOneStopCLSIDs()
{
    LPCLASSFACTORY pClassFact;
    HRESULT hr = E_OUTOFMEMORY;

    pClassFact = (LPCLASSFACTORY) new CClassFactory();

    if (pClassFact)
    {
        hr = CoRegisterClassObject( CLSID_SyncMgrp, 
                                    pClassFact, 
                                    CLSCTX_LOCAL_SERVER,
                                    REGCLS_MULTIPLEUSE,
                                    &g_ObjectMgrData.dwRegClassFactCookie);

        if (S_OK != hr)
        {
            // on longon the rpc server may not yet be available and on
            // logoff we get the wrong server identity. Don't assert on these
            // since we know about the cases.
            if (HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE) != hr
                &&  CO_E_WRONG_SERVER_IDENTITY != hr)
            {
                AssertSz(0,"Class Factory Registration failed");
            }

            g_ObjectMgrData.dwRegClassFactCookie = 0;
        }
        else
        {
            g_ObjectMgrData.fRegClassFactCookieValid = TRUE;
        }

        pClassFact->Release(); // Release our reference on the ClassFactory.
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   MakeWinstaDesktopName, public
//
//  Synopsis:   Stole main code from Ole32 remote.cxx to generate
//              a unique eventName based on session and desktop..

//  Arguments:  
//
//  Returns:    Appropriate Error codes
//
//  Modifies:
//
//  History:    18-Dec-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI MakeWinstaDesktopName(LPCWSTR pszPreceding, LPWSTR *ppszResultString)
{
    HWINSTA hWinsta;
    HDESK   hDesk;
    WCHAR   wszWinsta[32];
    WCHAR   wszDesktop[32];
    LPWSTR  pwszWinsta;
    LPWSTR  pwszDesktop;
    LPWSTR _pwszWinstaDesktop; // out param
    ULONG  cchWinstaDesktop;
    DWORD   Length;
    BOOL    Status;
    HRESULT hr;
    DWORD dwResult;

    if (!ppszResultString)
    {
        Assert(ppszResultString);
        return E_INVALIDARG;
    }

    *ppszResultString = NULL;;

    hWinsta = GetProcessWindowStation();

    if ( ! hWinsta )
        return HRESULT_FROM_WIN32(GetLastError());

    hDesk = GetThreadDesktop(GetCurrentThreadId());

    if ( ! hDesk )
        return HRESULT_FROM_WIN32(GetLastError());

    pwszWinsta = wszWinsta;
    pwszDesktop = wszDesktop;

    Length = sizeof(wszWinsta);

    Status = GetUserObjectInformation(
                hWinsta,
                UOI_NAME,
                pwszWinsta,
                Length,
                &Length );

    if ( ! Status )
    {
        dwResult = GetLastError();
        if ( ERROR_INSUFFICIENT_BUFFER != dwResult)
        {
            hr  = HRESULT_FROM_WIN32(dwResult);
            goto WinstaDesktopExit;
        }

        pwszWinsta = (LPWSTR) ALLOC( Length );
        if ( ! pwszWinsta )
        {
            hr = E_OUTOFMEMORY;
            goto WinstaDesktopExit;
        }

        Status = GetUserObjectInformation(
                    hWinsta,
                    UOI_NAME,
                    pwszWinsta,
                    Length,
                    &Length );

        if ( ! Status )
        {
            hr  = HRESULT_FROM_WIN32(GetLastError());
            goto WinstaDesktopExit;
        }
    }

    Length = sizeof(wszDesktop);

    Status = GetUserObjectInformation(
                hDesk,
                UOI_NAME,
                pwszDesktop,
                Length,
                &Length );

    if ( ! Status )
    {
        dwResult = GetLastError();
        if ( dwResult != ERROR_INSUFFICIENT_BUFFER )
        {
            hr = HRESULT_FROM_WIN32(dwResult);
            goto WinstaDesktopExit;
        }

        pwszDesktop = (LPWSTR) ALLOC( Length );
        if ( ! pwszDesktop )
        {
            hr = E_OUTOFMEMORY;
            goto WinstaDesktopExit;
        }

        Status = GetUserObjectInformation(
                    hDesk,
                    UOI_NAME,
                    pwszDesktop,
                    Length,
                    &Length );

        if ( ! Status )
        {
            hr =  HRESULT_FROM_WIN32(GetLastError());
            goto WinstaDesktopExit;
        }
    }

    cchWinstaDesktop = (pszPreceding ? lstrlen(pszPreceding) + 1 : 0) 
                                + lstrlen(pwszWinsta) + 1 
                                + lstrlen(pwszDesktop) + 1;

    _pwszWinstaDesktop = (WCHAR *) ALLOC(cchWinstaDesktop * sizeof(WCHAR));

    if ( _pwszWinstaDesktop )
    {
        *_pwszWinstaDesktop = NULL;

        if (pszPreceding)
        {
            StringCchCopy(_pwszWinstaDesktop, cchWinstaDesktop, pszPreceding);
            StringCchCat(_pwszWinstaDesktop, cchWinstaDesktop, L"_");
        }

        StringCchCat(_pwszWinstaDesktop, cchWinstaDesktop, pwszWinsta );
        StringCchCat(_pwszWinstaDesktop, cchWinstaDesktop, L"_" );
        StringCchCat(_pwszWinstaDesktop, cchWinstaDesktop, pwszDesktop );

        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

WinstaDesktopExit:

    if ( pwszWinsta != wszWinsta )
    {
        FREE( pwszWinsta );
    }

    if ( pwszDesktop != wszDesktop )
    {
        FREE( pwszDesktop );
    }

    if (S_OK == hr)
    {
        *ppszResultString = _pwszWinstaDesktop;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   RegisterOneStopClassFactory, public
//
//  Synopsis:   Handles the ClassFactory registration
//              along with the associated race conditions.
//
//              if class factory isn't already registered, then go ahead and register now.
//              there is the case the between the time we see if there is a class factory
//              and the CoCreateInstance is called it could go away.  If this happens, another
//              instance of Onestop.exe is launched and everything will work properly.

//  Arguments:  [fForce] - When true the ClassFactory is registered even if there
//                          is an existing event object.
//
//  Returns:    Appropriate Error codes
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------



const WCHAR SZ_CFACTORYEVENTNAME[] =  TEXT("{6295DF2D-35EE-11d1-8707-00C04FD93327}CFactEvent");

STDAPI RegisterOneStopClassFactory(BOOL fForce)
{
    HRESULT hr = S_OK; // only report error is actual call to register CFact Failed.
    LPWSTR pEventName;
    BOOL fExistingInstance = FALSE;

    if (S_OK != MakeWinstaDesktopName(SZ_CFACTORYEVENTNAME,&pEventName))
    {
        pEventName = (LPWSTR) SZ_CFACTORYEVENTNAME;
    }

    // this should only ever be called on MainThread so don't
    // need to lock
    Assert(g_ObjectMgrData.dwMainThreadID == GetCurrentThreadId());
    Assert(NULL == g_ObjectMgrData.hClassRegisteredEvent);

    g_ObjectMgrData.hClassRegisteredEvent =  CreateEvent(NULL, TRUE, FALSE, pEventName);
    Assert(g_ObjectMgrData.hClassRegisteredEvent);

    // if got the event and not a force see if there is an existing instance.
    if (g_ObjectMgrData.hClassRegisteredEvent && !fForce)
    {
        if (ERROR_ALREADY_EXISTS == GetLastError())
        {
            // object already existed and the force flag isn't set
            // it means we can use the existing registered object.
            CloseHandle(g_ObjectMgrData.hClassRegisteredEvent);
            g_ObjectMgrData.hClassRegisteredEvent = NULL;
            hr = S_OK;
            fExistingInstance = TRUE;
        }
    }

    // If fForce is set or these isn't an existing class, go ahead and register.
    if (fForce || (!fExistingInstance && g_ObjectMgrData.hClassRegisteredEvent)) 
    {
        // force on an event already existing is  a state that
        // should only occur if EXE was launched twice with the embedding flag.
        // This shouldn't happen under normal conditions so assert.
        // so we can catch any cases that we didn't get the event
        // and the force flag is set.

        Assert(g_ObjectMgrData.hClassRegisteredEvent);

        hr = RegisterOneStopCLSIDs();

        if (S_OK != hr)
        {
            if (g_ObjectMgrData.hClassRegisteredEvent)
            {
                CloseHandle(g_ObjectMgrData.hClassRegisteredEvent);
                g_ObjectMgrData.hClassRegisteredEvent = NULL;
            }
        }
   }

   if (pEventName && (SZ_CFACTORYEVENTNAME != pEventName))
   {
       FREE(pEventName);
   }

   return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   AddRefOneStopLifetime, public
//
//  Synopsis:   Adds a Reference to the applications

//  Arguments:
//
//  Returns:    New total Reference count including both
//              internal and external locks.
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) AddRefOneStopLifetime(BOOL fExternal)
{
    DWORD cRefs;
    CCriticalSection cCritSect(&g_LockCountCriticalSection,GetCurrentThreadId());

    // Increment ref count
    cCritSect.Enter();

    if (fExternal)
    {
        ++g_ObjectMgrData.LockCountExternal;
    }
    else
    {
        ++g_ObjectMgrData.LockCountInternal;
    }

    cRefs = g_ObjectMgrData.LockCountExternal + g_ObjectMgrData.LockCountInternal;

    cCritSect.Leave();

    Assert(0 < cRefs);

    return cRefs;
}

//+---------------------------------------------------------------------------
//
//  Function:   ReleaseOneStopLifetime, public
//
//  Synopsis:   Releases a Reference to the applications
//              If the refcount goes to zero the classfactory
//              is revoked an a quit message is posted to the
//              main thread
//
//  Arguments:
//
//  Returns:    New Reference count including internal and
//              external locks.
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) ReleaseOneStopLifetime(BOOL fExternal)
{
    DWORD cRefsExternal;
    DWORD cRefsInternal;
    BOOL fForceClose;
    DLGLISTITEM *pDlgListItem;
    CCriticalSection cCritSect(&g_LockCountCriticalSection,GetCurrentThreadId());

    cCritSect.Enter();

    if (fExternal)
    {
        --g_ObjectMgrData.LockCountExternal;
    }
    else
    {
        --g_ObjectMgrData.LockCountInternal;
    }

    cRefsInternal = g_ObjectMgrData.LockCountInternal;
    cRefsExternal = g_ObjectMgrData.LockCountExternal;
    fForceClose = g_ObjectMgrData.fCloseAll;

    pDlgListItem = g_ObjectMgrData.DlgList;

    Assert(0 <= ((LONG) cRefsInternal));
    Assert(0 <= ((LONG) cRefsExternal));

    if( (0 >= cRefsInternal)
        && (0 >= cRefsExternal || fForceClose)
        && (FALSE == g_ObjectMgrData.fDead) )
    {
        HANDLE hRegisteredEvent;
        HWND hwndMainThreadMsg;
        DWORD dwRegClassFactCookie;
        BOOL  fRegClassFactCookieValid;

        Assert(0 == pDlgListItem); // all dialogs should have been released.
        Assert(0 == g_ObjectMgrData.dwSettingsLockCount); // settings dialogs should be gone.

        g_ObjectMgrData.fDead = TRUE;

        hRegisteredEvent = g_ObjectMgrData.hClassRegisteredEvent;
        g_ObjectMgrData.hClassRegisteredEvent = NULL;

        hwndMainThreadMsg = g_ObjectMgrData.hWndMainThreadMsg;
        g_ObjectMgrData.hWndMainThreadMsg = NULL;

        dwRegClassFactCookie = g_ObjectMgrData.dwRegClassFactCookie;
        g_ObjectMgrData.dwRegClassFactCookie = 0;

        fRegClassFactCookieValid = g_ObjectMgrData.fRegClassFactCookieValid;
        g_ObjectMgrData.fRegClassFactCookieValid = FALSE;

        cCritSect.Leave();

        if (hRegisteredEvent)
        {
            CloseHandle(hRegisteredEvent); // release our registration event.
        }

        // we need to revoke the classfactory on the thread that registered it.
        // Send a message back to the thread that registered the event.

        if (fRegClassFactCookieValid)
        {
            SendMessage(hwndMainThreadMsg,WM_CFACTTHREAD_REVOKE,dwRegClassFactCookie,0);
        }

        // if lockcount is still zero then post the quitmessage
        // else someone came in during our revoke and we
        // need to wait for the refcount to hit zero again.

        cCritSect.Enter();

        cRefsInternal = g_ObjectMgrData.LockCountInternal;
        cRefsExternal = g_ObjectMgrData.LockCountExternal;

        if ( (0 >= cRefsInternal) 
                && (0 >= cRefsExternal || fForceClose) )
        {
            DWORD dwMainThreadID;
            HANDLE hThread = NULL;

            dwMainThreadID = g_ObjectMgrData.dwMainThreadID;

            // its possible the quite is occuring on a thread other than
            // the main thread. If this is the case send the handle of the thread
            // along with the quit message to the main thread can wait for this
            // thread to exit.

// #ifdef _THREADSHUTDOWN
//            if (dwMainThreadID != GetCurrentThreadId())
//            {
//            HANDLE hCurThread;
//            HANDLE hProcess;
//
//               hCurThread = GetCurrentThread();
//                hProcess = GetCurrentProcess();
//
//                if (!DuplicateHandle(hProcess,hCurThread,hProcess,&hThread,
//                            0,FALSE,DUPLICATE_SAME_ACCESS) )
//                {
//                    hThread = NULL; // don't rely on DupHandle to set this to null on error.
//                }
//
//            }
// #endif // _THREADSHUTDOWN

            // shut down the main thread
            cCritSect.Leave();
            PostMessage(hwndMainThreadMsg,WM_MAINTHREAD_QUIT,0,(LPARAM) /* hThread */ 0);
            cCritSect.Enter();
        }
        else
        {
            g_ObjectMgrData.fDead = FALSE;
        }
    }

    cCritSect.Leave();

    return (cRefsExternal + cRefsInternal);
}


//+---------------------------------------------------------------------------
//
//  Function:   InitObjectManager, public
//
//  Synopsis:   Must be called from Main thread before any
//              new threads, dialogs are created or the class factory
//              is registered.
//
//  Arguments:
//
//  Returns:    Appropriate Error Codes.
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI InitObjectManager(CMsgServiceHwnd *pMsgService)
{
    // initialize critical section for our lock count.
    if (InitializeCriticalSectionAndSpinCount(&g_LockCountCriticalSection, 0))
    {
        g_ObjectMgrData.dwMainThreadID = GetCurrentThreadId();
        g_ObjectMgrData.hWndMainThreadMsg = pMsgService->GetHwnd();

        g_ObjectMgrData.DlgList = NULL;
        g_ObjectMgrData.hClassRegisteredEvent = NULL;
        g_ObjectMgrData.dwRegClassFactCookie = 0;
        g_ObjectMgrData.fRegClassFactCookieValid = FALSE;
        g_ObjectMgrData.LockCountInternal = 0;
        g_ObjectMgrData.LockCountExternal = 0;
        g_ObjectMgrData.fCloseAll = FALSE;
        g_ObjectMgrData.dwSettingsLockCount = 0;
        g_ObjectMgrData.dwHandlerPropertiesLockCount = 0;
        g_ObjectMgrData.fDead = FALSE;

        // Initialize autodial support
        g_ObjectMgrData.eAutoDialState = eQuiescedOff;
        g_ObjectMgrData.fRasAutoDial = FALSE;
        g_ObjectMgrData.dwWininetAutoDialMode = AUTODIAL_MODE_NEVER;
        g_ObjectMgrData.fFirstSyncItem = FALSE;
        g_ObjectMgrData.cNestedStartCalls = 0;

        Assert(g_ObjectMgrData.hWndMainThreadMsg);

        return S_OK;
    }

    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Function:   RequestIdleLock, public
//
//  Synopsis:   request to see if an new Idle can be started.
//
//  Arguments:
//
//  Returns:    S_OK - if Idle should be continued
//              S_FALSE - if another Idle is already in progreaa.
//
//  Modifies:
//
//  History:    23-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI RequestIdleLock()
{
    HRESULT hr;
    CCriticalSection cCritSect(&g_LockCountCriticalSection,GetCurrentThreadId());

    cCritSect.Enter();

    if (g_ObjectMgrData.fIdleHandlerRunning)
    {
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
        g_ObjectMgrData.fIdleHandlerRunning = TRUE;
    }

    cCritSect.Leave();

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   ReleaseIdleLock, public
//
//  Synopsis:   Informs ObjectMgr that the Idle is done processing.
//
//  Arguments:
//
//  Returns:    Appropriate error codes.
//
//  Modifies:
//
//  History:    23-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI ReleaseIdleLock()
{
    HRESULT hr = S_OK;
    CCriticalSection cCritSect(&g_LockCountCriticalSection,GetCurrentThreadId());

    cCritSect.Enter();

    // note okay for this to already be FALSE in case progress receives
    // an offidle before release. Call this when idle progress is 
    // released as safety in case offidle isn't working properly.

    g_ObjectMgrData.fIdleHandlerRunning = FALSE;

    cCritSect.Leave();

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   ObjMgr_HandleQueryEndSession, public
//
//  Synopsis:   Called by main thread so knows how to respond to WN_QUERYENDSESSION.
//
//  Arguments:
//
//  Returns:    S_OK - if system can shutdown
//              S_FALSE - if hould fail the query. On an S_FALSE the out params
//                  are filled, hwnd with parent hwnd of any message box and MessageID
//                  with the appropriate messageID to display.
//
//  Modifies:
//
//  History:    21-May-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI ObjMgr_HandleQueryEndSession(HWND *phwnd,UINT *puMessageId,BOOL *pfLetUserDecide)
{
    HRESULT hr = S_OK;
    BOOL fProgressDialog = FALSE;
    CCriticalSection cCritSect(&g_LockCountCriticalSection,GetCurrentThreadId());

    cCritSect.Enter();

    *phwnd = NULL;
    *pfLetUserDecide = FALSE;

    // if there are any settings dialogs then we can't quit
    if (g_ObjectMgrData.dwSettingsLockCount > 0)
    {
        *phwnd = NULL;
        *puMessageId = IDS_SETTINGSQUERYENDSESSION;
        hr = S_FALSE;
    }
    else
    {
        DLGLISTITEM *pDlgListItem;
        BOOL fDontShutdown = FALSE; // set when find match
        HWND hwnd;
        UINT uMessageId;
        BOOL fLetUserDecide;

        // loop through dialogs asking if they can shutdown.
        // first dialog find that doesn't give choice return
        // if the dialog says to let user decide continue looping
        // until hit end or find a dialog that doesn't give choice since
        // not giving choice takes precedence.

        // see if there is a progress dialog other than idle and if so stop the logoff.
        pDlgListItem = g_ObjectMgrData.DlgList;

        // loop through the choice dialogs to see if
        while (pDlgListItem)
        {
            if ( (pDlgListItem->pDlg)
                && (S_FALSE == pDlgListItem->pDlg->QueryCanSystemShutdown(&hwnd,&uMessageId,&fLetUserDecide) ) )
            {
                // if first dialog find we can't shutdown or fLetUserDecide isn't set
                // then upate the out params

                if (!fDontShutdown || !fLetUserDecide)
                {
                    *phwnd = hwnd;
                    *puMessageId = uMessageId;
                    *pfLetUserDecide = fLetUserDecide;

                    fProgressDialog = (pDlgListItem->dlgType == DLGTYPE_PROGRESS) ? TRUE : FALSE;
                }

                fDontShutdown = TRUE;

                // if this dialog doesn't allow the use choice then break
                if (!fLetUserDecide)
                {
                    break;
                }
            }

            pDlgListItem = pDlgListItem->pDlgNextListItem;
        }

        if (fDontShutdown)
        {
            hr = S_FALSE;
        }
    }

    cCritSect.Leave();

    // if can't shutdown and it is a progress dialog then make sure
    // the dialog is not minimized;
    if (fProgressDialog && (*phwnd) )
    {
        BASEDLG_SHOWWINDOW(*phwnd,SW_SHOWNORMAL);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjMgr_AddRefHandlerPropertiesLockCount, public
//
//  Synopsis:   Called by choice dialog to change the global lock count
//              of open handler properties dialogs
//
//  Arguments:  dwNumRefs - number of references to increment
//
//  Returns:    Appropriate error codes
//
//  Modifies:
//
//  History:    21-May-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) ObjMgr_AddRefHandlerPropertiesLockCount(DWORD dwNumRefs)
{
    ULONG cRefs;
    CCriticalSection cCritSect(&g_LockCountCriticalSection,GetCurrentThreadId());

    Assert(dwNumRefs); // catch people passing on 0 since doesn't make sense.

    cCritSect.Enter();

    g_ObjectMgrData.dwHandlerPropertiesLockCount += dwNumRefs;
    cRefs = g_ObjectMgrData.dwHandlerPropertiesLockCount;

    cCritSect.Leave();

    return cRefs;
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjMgr_ReleaseHandlerPropertiesLockCount, public
//
//  Synopsis:   Called by choice dialog to change the global lock count
//              of open handler properties dialogs
//
//  Arguments:  dwNumRefs - number of references to decrement
//
//  Returns:    Appropriate error codes
//
//  Modifies:
//
//  History:    21-May-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) ObjMgr_ReleaseHandlerPropertiesLockCount(DWORD dwNumRefs)
{
    DWORD cRefs;
    CCriticalSection cCritSect(&g_LockCountCriticalSection,GetCurrentThreadId());

    Assert(dwNumRefs); // catch people passing on 0 since doesn't make sense.

    cCritSect.Enter();

    g_ObjectMgrData.dwHandlerPropertiesLockCount -= dwNumRefs;
    cRefs = g_ObjectMgrData.dwHandlerPropertiesLockCount;

    cCritSect.Leave();

    Assert( ((LONG) cRefs) >= 0);

    if ( ((LONG) cRefs) < 0)
    {
        cRefs = 0;
    }

    return cRefs;
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjMgr_CloseAll, public
//
//  Synopsis:   Called by main thread when an END_SESSION occurs. Loops throug
//              dialogs posting a close to them
//
//  Arguments:
//
//  Returns:    Appropriate error codes
//
//  Modifies:
//
//  History:    21-May-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI ObjMgr_CloseAll()
{
    HRESULT hr = S_OK;
    HWND hwndDlg;
    DLGLISTITEM *pDlgListItem;
    CCriticalSection cCritSect(&g_LockCountCriticalSection,GetCurrentThreadId());

    // Put on Addref to hold alive until done with loop. and also
    // toggle lifetime in case launched with /embedding and
    // no references on self.

    AddRefOneStopLifetime(FALSE /* !External */);

    cCritSect.Enter();
    // see if there is a progress dialog other than idle and if so stop the logoff.
    pDlgListItem = g_ObjectMgrData.DlgList;

    // look for existing.
    while (pDlgListItem)
    {
        Assert(pDlgListItem->pDlg);

        if (pDlgListItem->pDlg)
        {
            hwndDlg = pDlgListItem->pDlg->GetHwnd();

            Assert(hwndDlg);

            if (hwndDlg)
            {
                PostMessage(hwndDlg,WM_BASEDLG_HANDLESYSSHUTDOWN,0,0);
            }
        }

        pDlgListItem = pDlgListItem->pDlgNextListItem;
    }

    // set the CloseAll flag so Release knows to ignore any
    // external refCounts
    g_ObjectMgrData.fCloseAll  = TRUE;

    cCritSect.Leave();

    ReleaseOneStopLifetime(FALSE /* !External */);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   GetAutoDialState
//
//  Synopsis:   Reads the current auto dial state of the machine/process
//
//  History:    18-Jul-98       SitaramR        Created
//
//----------------------------------------------------------------------------

STDAPI GetAutoDialState()
{
    LPNETAPI pNetApi = gSingleNetApiObj.GetNetApiObj();

    if ( pNetApi )
    {
        BOOL fEnabled;
        DWORD dwMode;

        pNetApi->RasGetAutodial( fEnabled );
        g_ObjectMgrData.fRasAutoDial = fEnabled;

        pNetApi->InternetGetAutodial( &dwMode );
        g_ObjectMgrData.dwWininetAutoDialMode = dwMode;
    }

    if ( pNetApi )
        pNetApi->Release();

    if ( g_ObjectMgrData.fRasAutoDial || (AUTODIAL_MODE_NEVER != g_ObjectMgrData.dwWininetAutoDialMode ))
        g_ObjectMgrData.eAutoDialState = eQuiescedOn;

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   LokEnableAutoDial
//
//  Synopsis:   Enables Ras and Wininet autodialing
//
//  History:    18-Jul-98       SitaramR        Created
//              22-Mar-02       BrianAu         Use inet autodial mode
//
//----------------------------------------------------------------------------

STDAPI LokEnableAutoDial()
{
    LPNETAPI pNetApi = gSingleNetApiObj.GetNetApiObj();

    if ( pNetApi )
    {
        if ( g_ObjectMgrData.fRasAutoDial )
            pNetApi->RasSetAutodial( TRUE );

        pNetApi->InternetSetAutodial( g_ObjectMgrData.dwWininetAutoDialMode );
    }

   if ( pNetApi )
        pNetApi->Release();

   return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   LokDisableAutoDial
//
//  Synopsis:   Disables Ras and Wininet autodialing
//
//  History:    18-Jul-98       SitaramR        Created
//              22-Mar-02       BrianAu         Use inet autodial mode
//
//----------------------------------------------------------------------------

STDAPI LokDisableAutoDial()
{
    LPNETAPI pNetApi = gSingleNetApiObj.GetNetApiObj();

    if ( pNetApi )
    {
        if ( g_ObjectMgrData.fRasAutoDial )
            pNetApi->RasSetAutodial( FALSE );

        pNetApi->InternetSetAutodial( AUTODIAL_MODE_NEVER );
        pNetApi->Release();
    }
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   BeginSyncSession
//
//  Synopsis:   Called at the beginning of actual synchronization to setup
//              autodial support.
//
//  History:    18-Jul-98       SitaramR        Created
//
//----------------------------------------------------------------------------

STDAPI BeginSyncSession()
{
    CCriticalSection cCritSect(&g_LockCountCriticalSection,GetCurrentThreadId());
    cCritSect.Enter();

    if ( g_ObjectMgrData.cNestedStartCalls == 0 )
    {
        Assert( g_ObjectMgrData.eAutoDialState == eQuiescedOn
                || g_ObjectMgrData.eAutoDialState == eQuiescedOff );

        g_ObjectMgrData.fFirstSyncItem = TRUE;
    }

    g_ObjectMgrData.cNestedStartCalls++;

    cCritSect.Leave();

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   EndSyncSession
//
//  Synopsis:   Called at the end of actual synchronization to cleanup
//              autodial support.
//
//  History:    28-Jul-98       SitaramR        Created
//
//----------------------------------------------------------------------------

STDAPI EndSyncSession()
{
    HRESULT hr = E_UNEXPECTED;

    CCriticalSection cCritSect(&g_LockCountCriticalSection,GetCurrentThreadId());
    cCritSect.Enter();

    Assert( g_ObjectMgrData.cNestedStartCalls > 0 );
    Assert( g_ObjectMgrData.eAutoDialState != eQuiescedOn );

    g_ObjectMgrData.cNestedStartCalls--;

    if ( g_ObjectMgrData.cNestedStartCalls == 0 )
    {
        if ( g_ObjectMgrData.eAutoDialState == eAutoDialOn )
            g_ObjectMgrData.eAutoDialState = eQuiescedOn;
        else if ( g_ObjectMgrData.eAutoDialState == eAutoDialOff )
        {
            //
            // Reset autodial state to enabled now that all synch has completed.
            // What to do if hr is set to error code ?
            //
            hr = LokEnableAutoDial();

            g_ObjectMgrData.eAutoDialState = eQuiescedOn;
        }
        //
        // If the state is eQuiescedOff then do nothing
        //
    }

    cCritSect.Leave();

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   ApplySyncItemDialState
//
//  Synopsis:   Set the auto dial requirements of each handler as it is being
//              prepared for syncing.
//
//  Arguments:  [fAutoDialDisable] -- Should autodial be disabled for this
//                                    handler ?
//
//  History:    28-Jul-98       SitaramR        Created
//
//----------------------------------------------------------------------------

STDAPI ApplySyncItemDialState( BOOL fAutoDialDisable )
{
    HRESULT hr = S_OK;

    CCriticalSection cCritSect(&g_LockCountCriticalSection,GetCurrentThreadId());
    cCritSect.Enter();

    if ( g_ObjectMgrData.fFirstSyncItem )
    {
        //
        // Read whether autodial state is on or off, before we modify it
        //
        GetAutoDialState();

        Assert( g_ObjectMgrData.eAutoDialState == eQuiescedOn
                || g_ObjectMgrData.eAutoDialState == eQuiescedOff );

        if ( g_ObjectMgrData.eAutoDialState == eQuiescedOn )
        {
            if ( fAutoDialDisable )
            {
                hr = LokDisableAutoDial();
                g_ObjectMgrData.eAutoDialState = eAutoDialOff;
            }
            else
                g_ObjectMgrData.eAutoDialState = eAutoDialOn;
        }

        g_ObjectMgrData.fFirstSyncItem = FALSE;
    }
    else
    {
        if ( !fAutoDialDisable && (g_ObjectMgrData.eAutoDialState == eAutoDialOff) )
        {
            hr = LokEnableAutoDial();
            g_ObjectMgrData.eAutoDialState = eAutoDialOn;
        }
    }

    cCritSect.Leave();

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     CSingletonNetApi::~CSingletonNetApi
//
//  Synopsis:   Destructor
//
//  History:    31-Jul-1998     SitaramR        Created
//
//--------------------------------------------------------------------------

CSingletonNetApi::~CSingletonNetApi()
{
    CLock lock(this);
    lock.Enter();

    Assert(NULL == m_pNetApi);

    if ( m_pNetApi )
    {
        m_pNetApi->Release();
        m_pNetApi = 0;
    }

    lock.Leave();
}


//+-------------------------------------------------------------------------
//
//  Method:     CSingletonNetApi::GetNetApiObj
//
//  Synopsis:   Returns a pointer to NetApi object
//
//  History:    31-Jul-1998     SitaramR        Created
//
//--------------------------------------------------------------------------

LPNETAPI CSingletonNetApi::GetNetApiObj()
{
    CLock lock(this);
    lock.Enter();

    if ( m_pNetApi == 0 )
    {
        if (S_OK != MobsyncGetClassObject(MOBSYNC_CLASSOBJECTID_NETAPI,(void **) &m_pNetApi))
        {
            m_pNetApi = NULL;
        }
    }

    if ( m_pNetApi )
        m_pNetApi->AddRef();

    lock.Leave();

    return m_pNetApi;
}


void CSingletonNetApi::DeleteNetApiObj()
{
    CLock lock(this);
    lock.Enter();

    if ( m_pNetApi )
    {
        DWORD cRefs;

        cRefs = m_pNetApi->Release();
        Assert(0 == cRefs);

        m_pNetApi = NULL;
    }   

    lock.Leave();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\exe\msg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Msg.cpp
//
//  Contents:   Handles messages between threads
//
//  Classes:    CThreadMsgProxy
//
//  Notes:
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

extern HINSTANCE g_hInst;
extern void UnitApplication();

// globals for handling QueryEndSession
HANDLE g_hEndSessionEvent = NULL; // created when an end session has occured.
BOOL   g_fShuttingDown = FALSE; // set when application begins to shutdown.(WM_QUIT)

// global for keeping track of handler's threads. We create on Thread for each handler
// CLSID

STUBLIST *g_FirstStub = NULL; // pointer to first proxy in our list.
CRITICAL_SECTION g_StubListCriticalSection; // Critical Section to use for adding proxy

//+---------------------------------------------------------------------------
//
//  Function:   TerminateStub, public
//
//  Synopsis:   Called by proxy to terminate a Stub of the given Id.
//
//  Arguments:  [pStubID] - Identifies the stub.
//
//  Returns:    S_OK - Stub was terminated
//              S_FALSE or Error - Stub either was already terminated
//                  or couldn't be found.
//
//  Modifies:
//
//  History:    17-Nov-98       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT  TerminateStub(STUBLIST *pStubID)
{
    HRESULT hr = E_UNEXPECTED;
    STUBLIST *pStubList;
    CCriticalSection cCritSect(&g_StubListCriticalSection,GetCurrentThreadId());

    cCritSect.Enter();

    pStubList = g_FirstStub;
    while (pStubList)
    {
	    if (pStubID == pStubList)
	    {
            hr = pStubList->fStubTerminated ? S_FALSE : S_OK;
	        pStubList->fStubTerminated = TRUE;
	        break;
	    }

	    pStubList = pStubList->pNextStub;
    }

    cCritSect.Leave();

    AssertSz(SUCCEEDED(hr),"Didn't find StubID on Terminate");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   DoesStubExist, public
//
//  Synopsis:   Called by proxy see if Stub Exists
//              or has been terminated
//
//  Arguments:  [pStubID] - Identifies the stub.
//
//  Returns:    S_OK - Stubs exists
//              S_FALSE - Stub hasn't been terminated.
//
//  Modifies:
//
//  History:    17-Nov-98       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT DoesStubExist(STUBLIST *pStubID)
{
    HRESULT hr = S_FALSE;
    STUBLIST *pStubList;
    CCriticalSection cCritSect(&g_StubListCriticalSection,GetCurrentThreadId());

    cCritSect.Enter();

    pStubList = g_FirstStub;
    while (pStubList)
    {
	    if (pStubID == pStubList)
	    {
            // if stub has already been terminated return S_FALSE
            hr = pStubList->fStubTerminated ? S_FALSE : S_OK;
	        break;
	    }

	    pStubList = pStubList->pNextStub;
    }

    cCritSect.Leave();
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   CreateHandlerThread, public
//
//  Synopsis:   Called by client to create a new handler thread
//
//  Arguments:  [pThreadProxy] - on success returns a pointer to Proxy
//		[hwndDlg] = hwnd of Window to associate with this proxy
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT CreateHandlerThread(CThreadMsgProxy **pThreadProxy, HWND hwndDlg, REFCLSID refClsid)
{
    HRESULT hr = E_FAIL;
    HANDLE hThread = NULL;
    DWORD dwThreadId;
    HandlerThreadArgs ThreadArgs;
    STUBLIST *pStubList;
    BOOL fExistingStub = FALSE;
    CCriticalSection cCritSect(&g_StubListCriticalSection,GetCurrentThreadId());

    *pThreadProxy = new CThreadMsgProxy();

    if (NULL == *pThreadProxy)
	    return E_OUTOFMEMORY;

    // lock the critical section and don't release it until the proxy
    // has been setup.

    cCritSect.Enter();

    // Look to see if there is already a thread for this handler's
    // clsid and if there is, reuse it, else create a new one.

    pStubList = g_FirstStub;
    while (pStubList)
    {
	    if ((pStubList->clsidStub == refClsid) && (FALSE == pStubList->fStubTerminated))
	    {
	        fExistingStub = TRUE;
	        break;
	    }

	    pStubList = pStubList->pNextStub;
    }

    // if found existing proxy then addref the cRefs and init the proxy
    // with the variables, else create a new one.

    if (fExistingStub)
    {
    	++(pStubList->cRefs); // bump up the cRefs
	    hr = (*pThreadProxy)->InitProxy(pStubList->hwndStub,
		                    		    pStubList->ThreadIdStub,
				                        pStubList->hThreadStub,
				                        hwndDlg,
				                        pStubList->clsidStub,
                                        pStubList);
    }
    else
    {
	    ThreadArgs.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

	    if (ThreadArgs.hEvent)
	    {
	        hThread = CreateThread(NULL, 0, HandlerThread, &ThreadArgs, 0, &dwThreadId);
	        if (hThread)
	        {
	            WaitForSingleObject(ThreadArgs.hEvent,INFINITE);
                hr = ThreadArgs.hr;

	            if (S_OK == hr)
	            {
		            STUBLIST *pNewStub;

        		    pNewStub = (STUBLIST*) ALLOC(sizeof(STUBLIST));
		
		            if (pNewStub)
                    {
            			pNewStub->pNextStub = NULL;
			            pNewStub->cRefs = 1;
            			pNewStub->hwndStub = ThreadArgs.hwndStub;
			            pNewStub->ThreadIdStub = dwThreadId;
            			pNewStub->hThreadStub = hThread;
			            pNewStub->clsidStub = refClsid;
                        pNewStub->fStubTerminated = FALSE;

			            if (NULL == g_FirstStub)
			            {
			                g_FirstStub = pNewStub;
			            }
			            else
			            {
			                pStubList = g_FirstStub;
			                while (pStubList->pNextStub)
			                {
				                pStubList = pStubList->pNextStub;
			                }

			                pStubList->pNextStub = pNewStub;
			            }
	
			            (*pThreadProxy)->InitProxy(ThreadArgs.hwndStub,dwThreadId,hThread,hwndDlg,refClsid,pNewStub);
		            }
		            else
		            {
			            hr = E_OUTOFMEMORY;
		            }
	            }

	            // if failed to create thread, initproxy or add it to global list, then bail
	            if (S_OK != hr)
	            {
		            CloseHandle(hThread);
	            }
	        }
	        else
	        {
		        hr = HRESULT_FROM_WIN32(GetLastError());
	        }

	        CloseHandle(ThreadArgs.hEvent);
	    }
    }

    cCritSect.Leave();

    // if got this far either found our created a handler thread, now need
    // to initialize the the stub side to create a hndlrMsg for this
    // instance of the handler. will return a hdnlrmsg that must be passed
    // along with everycall.

    if ( (S_OK == hr) && (*pThreadProxy))
    {
	    hr = (*pThreadProxy)->CreateNewHndlrMsg();

	    // Review - if fail to create hndlr message, then
	    // free proxy and return an error.
    }

    if (S_OK != hr)
    {
	    if ((*pThreadProxy))
	    {
	        (*pThreadProxy)->Release();
	        *pThreadProxy = NULL;
	    }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HandlerThread, public
//
//  Synopsis:   main proc for Handler thread
//
//  Arguments:  [lpArg] - Ptr to HandlerThreadArgs
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

DWORD WINAPI HandlerThread( LPVOID lpArg )
{
    MSG msg;
    HRESULT hr;
    CThreadMsgStub *pThreadMsgStub = NULL;
    CMsgServiceHwnd *pMsgDlg;
    HRESULT hrOleInitialize;
    BOOL fMsgDlgInitialized = FALSE;
    HandlerThreadArgs *pThreadArgs = (HandlerThreadArgs *) lpArg;
    DWORD dwThreadID = GetCurrentThreadId();

    __try
    {				
        pThreadArgs->hr = E_UNEXPECTED;

        // need to do a PeekMessage and then set an event to make sure
        // a message loop is created before the first PostMessage is sent.
        PeekMessage(&msg, NULL, WM_USER, WM_USER, PM_NOREMOVE);

        hrOleInitialize = CoInitialize(NULL);

        // create our message hwnd
        pMsgDlg = new CMsgServiceHwnd;

        if (pMsgDlg)
        {
            if (pMsgDlg->Initialize(dwThreadID,MSGHWNDTYPE_HANDLERTHREAD))
            {
                pThreadArgs->hwndStub = pMsgDlg->GetHwnd();
                fMsgDlgInitialized = TRUE;
            }
        }

        // set the approriate error
        if (fMsgDlgInitialized && SUCCEEDED(hrOleInitialize))
            hr = S_OK;
        else
            hr = E_UNEXPECTED;

        pThreadArgs->hr = hr;

        // let the caller know the thread is done initializing.
        if (pThreadArgs->hEvent)
            SetEvent(pThreadArgs->hEvent);

        if (S_OK == hr)
        {
            // sit in loop receiving messages.
            while (GetMessage(&msg, NULL, 0, 0)) 
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }

        if (SUCCEEDED(hrOleInitialize))
        {
            CoFreeUnusedLibraries();
            CoUninitialize();
        }
    }
    __except(QueryHandleException())
    {
        AssertSz(0,"Exception in Handler Thread.");
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:   CMsgServiceHwnd::HandleThreadMessage, public
//
//  Synopsis:   Responsible for determining the thread message that
//		was received and calling the proper handler routine
//
//  Arguments:  [pmsgInfo] - Ptr to MessagingInfo structure
//		[pgenMsg] - Ptr to Generic Message structure.
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT CMsgServiceHwnd::HandleThreadMessage(MessagingInfo *pmsgInfo,GenericMsg *pgenMsg)
{
    CHndlrMsg *pHndlrMsg;

    pgenMsg->hr = E_UNEXPECTED; // initialize the return result.

    // review, look up in linked list to validate.

    pHndlrMsg = pmsgInfo->pCHndlrMsg;

    m_fInOutCall = TRUE;

    switch (pgenMsg->ThreadMsg)
    {
    case ThreadMsg_Release:
    {
        MSGInitialize *pmsg = (MSGInitialize *) pgenMsg;
        ULONG cRefs;

	    cRefs = pHndlrMsg->Release();
	    Assert(0 == cRefs);

	    m_pHndlrMsg = NULL; // review, change when done.
	    pgenMsg->hr = S_OK;

	    m_fInOutCall = FALSE;
	}
	break;

    case ThreadMsg_Initialize:
	{
	    MSGInitialize *pmsg = (MSGInitialize *) pgenMsg;

	    pgenMsg->hr = pHndlrMsg->Initialize(pmsg->dwReserved,pmsg->dwSyncFlags,
			pmsg->cbCookie,pmsg->lpCookie);
	}
	break;

    case ThreadMsg_GetHandlerInfo:
	{
        MSGGetHandlerInfo *pmsg = (MSGGetHandlerInfo *) pgenMsg;
	    pgenMsg->hr = pHndlrMsg->GetHandlerInfo(pmsg->ppSyncMgrHandlerInfo);
	}
	break;

    case ThreadMsg_GetItemObject:
	{
	    MSGGetItemObject *pmsg = (MSGGetItemObject *) pgenMsg;

	    pgenMsg->hr = pHndlrMsg->GetItemObject(pmsg->ItemID,pmsg->riid, pmsg->ppv);
	}
	break;

    case ThreadMsg_ShowProperties:
	{
	    MSGShowProperties *pmsg = (MSGShowProperties *) pgenMsg;
        pgenMsg->hr = pHndlrMsg->ShowProperties(pmsg->hWndParent,pmsg->ItemID);
	}
	break;

    case ThreadMsg_PrepareForSync:
	{
	    MSGPrepareForSync *pmsg = (MSGPrepareForSync *) pgenMsg;
	    HANDLE hEvent = pmsgInfo->hMsgEvent;

	    pgenMsg->hr = pHndlrMsg->PrepareForSync(pmsg->cbNumItems,pmsg->pItemIDs,
				    pmsg->hWndParent,pmsg->dwReserved);
	}
	break;

    case ThreadMsg_Synchronize:
	{
	    MSGSynchronize *pmsg = (MSGSynchronize *) pgenMsg;
	    HANDLE hEvent = pmsgInfo->hMsgEvent;

	    pgenMsg->hr = pHndlrMsg->Synchronize(pmsg->hWndParent);
	}
	break;

    case ThreadMsg_SetItemStatus:
	{
	    MSGSetItemStatus *pmsg = (MSGSetItemStatus *) pgenMsg;
	    pgenMsg->hr = pHndlrMsg->SetItemStatus(pmsg->ItemID,pmsg->dwSyncMgrStatus);
	}
	break;

    case ThreadMsg_ShowError:
	{
	    MSGShowConflicts *pmsg = (MSGShowConflicts *) pgenMsg;
	    pgenMsg->hr = pHndlrMsg->ShowError(pmsg->hWndParent,pmsg->ErrorID);
	}
	break;

    case ThreadMsg_AddHandlerItems:
	{
	    MSGAddItemHandler *pmsg = (MSGAddItemHandler *) pgenMsg;
	    pgenMsg->hr = pHndlrMsg->AddHandlerItems(pmsg->hwndList,pmsg->pcbNumItems);
	}
	break;

    case ThreadMsg_CreateServer:
	{
        MSGCreateServer *pmsg = (MSGCreateServer *) pgenMsg;
	    pgenMsg->hr = pHndlrMsg->CreateServer(pmsg->pCLSIDServer,pmsg->pHndlrQueue,pmsg->pHandlerId,pmsg->dwProxyThreadId);
	}
	break;

    case ThreadMsg_SetHndlrQueue:
	{
    	MSGSetHndlrQueue *pmsg = (MSGSetHndlrQueue *) pgenMsg;
	    pgenMsg->hr = pHndlrMsg->SetHndlrQueue(pmsg->pHndlrQueue,pmsg->pHandlerId,pmsg->dwProxyThreadId);
	}
	break;

    case ThreadMsg_SetupCallback:
	{
    	MSGSetupCallback *pmsg = (MSGSetupCallback *) pgenMsg;
	    pgenMsg->hr = pHndlrMsg->SetupCallback(pmsg->fSet);
	}
	break;

    default:
	    AssertSz(0,"Unknown Thread Message");
	    break;
    }

    m_fInOutCall = FALSE;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   DopModalLoop, public
//
//  Synopsis:   Sit in message loop until the specified object
//		becomes or thread becomes signalled.
//
//  Arguments:  [hEvent] - Event to wait on
//		[hThread] - Thread that if it becomes signalled indicates thread
//			    that is being called has died.
//		[hwndDlg] - hwnd of Dialog on thread we should check message for, can be null.
//		[fAllowIncomingCalls] - incoming Messages can be dispatched during out call.
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT DoModalLoopoLD(HANDLE hEvent,HANDLE hThread,HWND hwndDlg,BOOL fAllowIncomingCalls,
                    DWORD dwTimeout)
{
    HRESULT hr = S_OK;
    DWORD dwWakeup;
    DWORD dwHandleCount;
    DWORD dwStartTime = GetTickCount();
    DWORD dwTimeoutValue;
    HANDLE handles[2];

    handles[0] = hEvent;
    handles[1] = hThread;

    dwHandleCount = (NULL == hThread) ? 1 : 2;

    dwTimeoutValue = dwTimeout; // initial call to wait is just the passed in vaulue

    // just sit in a loop until the message has been processed or the thread
    // we are calling dies

    // if no event to wait on just fall through
    if (NULL == hEvent)
    {
        do
        {
    	    if (fAllowIncomingCalls)
	        {
	            dwWakeup = MsgWaitForMultipleObjects(dwHandleCount,&handles[0],FALSE,dwTimeoutValue,QS_ALLINPUT);
    	    }
	        else
	        {
	            dwWakeup = WaitForMultipleObjects(dwHandleCount,&handles[0],FALSE,dwTimeoutValue);
	        }

    	    if (WAIT_OBJECT_0 == dwWakeup) // call was completed.    	    
	        {  
    	        hr = S_OK;
	            break;
	        }
	        else if ((WAIT_OBJECT_0 +1 == dwWakeup) &&  (2== dwHandleCount) )
	        {
	            // thread died within call.
	            AssertSz(0,"Server Thread Terminated");
	            hr = E_UNEXPECTED;
	            break;
	        }
	        else if (WAIT_ABANDONED_0  == dwWakeup)
	        {
	            AssertSz(0,"Abandoned"); // this shouldn't ever happen
	            hr = E_UNEXPECTED;
	            break;
	        }
	        else if (WAIT_TIMEOUT == dwWakeup)
	        {
	            hr = HRESULT_FROM_WIN32(ERROR_TIMEOUT);
	            break;
	        }
	        else
	        {
	            MSG msg;

                // see if events are signalled themselves since can get into this
                // loop is items are in the queue even if events we are
                // waiting on are already set.

                if (WAIT_OBJECT_0 == WaitForSingleObject(hEvent,0))
                {
                    hr = S_OK;
                    break;
                }
                else if (hThread && (WAIT_OBJECT_0 == WaitForSingleObject(hThread,0)) )
                {
	                AssertSz(0,"Server Thread Terminated");
	                hr = E_UNEXPECTED;
	                break;
                }

                // only grab out one peek message since dispatch could
                // cause another message to get placed in the queue.
                if (PeekMessage(&msg, NULL, 0, 0, PM_NOYIELD | PM_REMOVE))
                {	
		            if ( (NULL == hwndDlg) || !IsDialogMessage(hwndDlg,&msg))
		            {
		                TranslateMessage((LPMSG) &msg);
		                DispatchMessage((LPMSG) &msg);
		            }
	            }
	        }

            // adjust the timeout value
            if (INFINITE == dwTimeout)
            {
                dwTimeoutValue = INFINITE;
            }
            else
            {
                DWORD dwCurTime = GetTickCount();

                // handle roll-over of GetTickCount. If this happens use has to wait
                // for the StartTime again. so user may have to wait twice as long
                // as originally anticipated.
                if (dwCurTime < dwStartTime)
                {
                    dwStartTime = dwCurTime;
                }

                // if the elapsed time is greater than the timeout set the
                // timeout value to zero, else use the different/
                if (dwTimeout <=  (dwCurTime - dwStartTime))
                {
                    dwTimeoutValue = 0;
                }
                else
                {
                    dwTimeoutValue = dwTimeout -  (dwCurTime - dwStartTime);
                }
            }

        }  while (1);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   DopModalLoop, public
//
//  Synopsis:   Sit in message loop until the specified object
//		becomes or thread becomes signalled.
//
//  Arguments:  [hEvent] - Event to wait on
//		[hThread] - Thread that if it becomes signalled indicates thread
//			    that is being called has died.
//		[hwndDlg] - hwnd of Dialog on thread we should check message for, can be null.
//		[fAllowIncomingCalls] - incoming Messages can be dispatched during out call.
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT DoModalLoop(HANDLE hEvent,HANDLE hThread,HWND hwndDlg,BOOL fAllowIncomingCalls,
                    DWORD dwTimeout)
{
    HRESULT hr = S_OK;
    DWORD dwWakeup;
    DWORD dwHandleCount;
    DWORD dwStartTime = GetTickCount();
    DWORD dwTimeoutValue;
    HANDLE handles[2];

    handles[0] = hEvent;
    handles[1] = hThread;

    Assert(hEvent);

    dwHandleCount = (NULL == hThread) ? 1 : 2;

    dwTimeoutValue = dwTimeout; // initial call to wait is just the passed in vaulue

    // just sit in a loop until the message has been processed or the thread
    // we are calling dies
    do
    {
        DWORD dwWaitValue;
        MSG msg;

        // check if hEvents are signalled yet
        if (WAIT_OBJECT_0 == (dwWaitValue = WaitForSingleObject(hEvent,0)) )
        {
            hr = S_OK;
            break;
        }
        else if ( (dwWaitValue != WAIT_ABANDONED)
                    && hThread && (WAIT_OBJECT_0 == (dwWaitValue = WaitForSingleObject(hThread,0))) )
        {
            // possible on Release message event was set between the 
            // time we checked for it and our thread event check.
            if (WAIT_OBJECT_0 == (dwWaitValue = WaitForSingleObject(hEvent,0)) )
            {
                hr = S_OK;
            }
            else
            {
	            AssertSz(0,"Server Thread Terminated");
	            hr = E_UNEXPECTED;
            }
            break;
        }

        // if come out af any of these calls with abandoned then assert and break;
        if (WAIT_ABANDONED  == dwWaitValue)
	    {
	        AssertSz(0,"Abandoned"); // this shouldn't ever happen
	        hr = E_UNEXPECTED;
	        break;
	    }

        // if not then either grab next PeekMessage or wait for objects depending
        if (fAllowIncomingCalls)
	    {
            // Leave any completion posts in the queue until the call has returned.
            if (PeekMessage(&msg, NULL, 0, 0, PM_NOYIELD | PM_REMOVE) )
            {
                dwWakeup = WAIT_OBJECT_0 + dwHandleCount; // set it to wait MsgWait would.

                Assert (msg.message != WM_QUIT);

                if ( (NULL == hwndDlg) || !IsDialogMessage(hwndDlg,&msg))
	            {
		            TranslateMessage((LPMSG) &msg);
                    DispatchMessage((LPMSG) &msg);
                }
            }
            else
            {
                dwWakeup = MsgWaitForMultipleObjects(dwHandleCount,&handles[0],FALSE,dwTimeoutValue,QS_ALLINPUT);
            }
        }
	    else
	    {
	        dwWakeup = WaitForMultipleObjects(dwHandleCount,&handles[0],FALSE,dwTimeoutValue);
	    }

        if (WAIT_TIMEOUT == dwWakeup)
        {
	        hr = HRESULT_FROM_WIN32(ERROR_TIMEOUT);
	        break;
	    }

        // update the timeout value
        if (INFINITE == dwTimeout)
        {
            dwTimeoutValue = INFINITE;
        }
        else
        {
            DWORD dwCurTime = GetTickCount();

            // handle roll-over of GetTickCount. If this happens use has to wait
            // for the StartTime again. so user may have to wait twice as long
            // as originally anticipated.
            if (dwCurTime < dwStartTime)
            {
                dwStartTime = dwCurTime;
            }

            // if the elapsed time is greater than the timeout set the
            // timeout value to zero, else use the different/
            if (dwTimeout <=  (dwCurTime - dwStartTime))
            {
                dwTimeoutValue = 0;
            }
            else
            {
                dwTimeoutValue = dwTimeout -  (dwCurTime - dwStartTime);
            }
        }

    } while (1);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::CThreadMsgProxy, public
//
//  Synopsis:   Constructor

//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

CThreadMsgProxy::CThreadMsgProxy()
{
    m_Clsid = GUID_NULL;
    m_cRef = 1;
    m_hwndDlg = NULL;
    m_pCHndlrMsg = NULL;
    m_fTerminatedHandler = FALSE;

    m_hThreadStub = NULL;
    m_ThreadIdStub = 0;
    m_hwndStub = NULL;
    m_hwndDlg = NULL;
    m_ThreadIdProxy = 0;

    m_fNewHndlrQueue = FALSE;
    m_pHandlerId = 0;
    m_pHndlrQueue = NULL;
    m_dwNestCount = 0;
    m_fHaveCompletionCall = FALSE;

}

//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::~CThreadMsgProxy, public
//
//  Synopsis:   destructor

//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    03-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

CThreadMsgProxy::~CThreadMsgProxy()
{
    Assert(0 == m_dwNestCount);
    Assert(NULL == m_pStubId);
}

//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::InitProxy, public
//
//  Synopsis:   Initializes member vars of Thread Proxy

//  Arguments:  [hwndStub] - hwnd of the Stub to send messages too.
//		[ThreadId] - ThreadId of the Stub
//		[hThread] - Handle of the Stub Thread.
//
//  Returns:    !!!!This function should be written so it never fails.
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CThreadMsgProxy::InitProxy(HWND hwndStub, DWORD ThreadId,HANDLE hThread,
					HWND hwndDlg,REFCLSID refClsid,
                                        STUBLIST *pStubId)
{
    m_hwndStub = hwndStub;
    m_ThreadIdStub =  ThreadId;
    m_hThreadStub = hThread;
    m_pStubId = pStubId;

    m_hwndDlg = hwndDlg;
    m_Clsid = refClsid;
    m_ThreadIdProxy = GetCurrentThreadId();

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::DispatchMsg, public
//
//  Synopsis:   Dispatches the specified messge

//  Arguments:  [pgenMsg] - Ptr to Generic Message structure.
//		[fAllowIncomingCalls] - incoming Messages can be dispatched during out call.
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CThreadMsgProxy::DispatchMsg(GenericMsg *pgenMsg,BOOL fAllowIncomingCalls,BOOL fAsync)
{
    HRESULT hr = E_UNEXPECTED;
    MessagingInfo msgInfo;

    // if the hndlrmsg information needs to be updated update
    // it before sending requested message

    AssertSz(!m_fTerminatedHandler,"Dispatching Message on Terminated Thread");

    if (m_fTerminatedHandler)
    {
        return E_UNEXPECTED;
    }

    ++m_dwNestCount;

    msgInfo.hMsgEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (NULL == msgInfo.hMsgEvent)
    {
        --m_dwNestCount;
	    return HRESULT_FROM_WIN32(GetLastError());
    }

    msgInfo.dwSenderThreadID = m_ThreadIdProxy;
    msgInfo.pCHndlrMsg = m_pCHndlrMsg;

    // Post the message to the handler thread.
    Assert(m_hwndStub); 
    Assert(m_pCHndlrMsg);
    Assert(m_hThreadStub);
    Assert(m_pStubId);

    if (m_hwndStub && m_pCHndlrMsg && m_hThreadStub && m_pStubId)
    {
        BOOL fPostMessage;

        fPostMessage = PostMessage(m_hwndStub,WM_THREADMESSAGE,(WPARAM) &msgInfo, (LPARAM) pgenMsg);
        
        Assert(fPostMessage || m_pStubId->fStubTerminated);

        if (fPostMessage)
        {
            hr = DoModalLoop(msgInfo.hMsgEvent,m_hThreadStub,m_hwndDlg,fAllowIncomingCalls,INFINITE);
        }
    }

    CloseHandle(msgInfo.hMsgEvent);

    --m_dwNestCount;

    // if have a callback message then post. Note don't have this code for stub messages
    // since it doesn;t have any callbacks

    if (m_fHaveCompletionCall)
    {
        PostMessage(m_msgCompletion.hwnd,m_msgCompletion.message,m_msgCompletion.wParam,m_msgCompletion.lParam);
        m_fHaveCompletionCall = FALSE;
    }

    return (S_OK != hr) ? hr : pgenMsg->hr;
}


//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::DispatchsStubMsg, public
//
//  Synopsis:   Dispatches the specified Stub messge

//  Arguments:  [pgenMsg] - Ptr to Generic Message structure.
//		[fAllowIncomingCalls] - incoming Messages can be dispatched during out call.
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CThreadMsgProxy::DispatchsStubMsg(GenericMsg *pgenMsg,BOOL fAllowIncomingCalls)
{
    HRESULT hr = E_UNEXPECTED;
    MessagingInfo msgInfo;
    BOOL fPostMessage;

    AssertSz(!m_fTerminatedHandler,"Dispatching  Stub Message on Terminated Thread");

    if (m_fTerminatedHandler)
        return E_UNEXPECTED;

    msgInfo.hMsgEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (NULL == msgInfo.hMsgEvent)
	    return HRESULT_FROM_WIN32(GetLastError());

    m_dwNestCount++;

    msgInfo.dwSenderThreadID = m_ThreadIdProxy;

    // Post the message to the handler thread.
    Assert(m_hwndStub);
    Assert(m_hThreadStub);
    Assert(m_pStubId);

    if (m_hwndStub && m_hThreadStub && m_pStubId)
    {
        fPostMessage = PostMessage(m_hwndStub,WM_THREADSTUBMESSAGE,(WPARAM) &msgInfo, (LPARAM) pgenMsg);
        Assert(fPostMessage || (m_pStubId->fStubTerminated));

        if (fPostMessage)
        {
            hr = DoModalLoop(msgInfo.hMsgEvent,m_hThreadStub,m_hwndDlg,fAllowIncomingCalls,INFINITE);
        }
    }
        
    CloseHandle(msgInfo.hMsgEvent);

    m_dwNestCount--;

    Assert(FALSE == m_fHaveCompletionCall); // catch any stub calls that occur at same time as dispatch
    return (S_OK != hr) ? hr : pgenMsg->hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   TerminateHandlerThread, public
//
//  Synopsis:   terminate the non-responsive handler thread
//
//  Returns:    Appropriate status code
//
//  Modifies:   m_hThreadStub;
//
//  History:    02-Nov-98       susia        Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP  CThreadMsgProxy::TerminateHandlerThread(TCHAR *pszHandlerName,BOOL fPromptUser)
{
    int         iEndSession;
    TCHAR       pszFormatString[MAX_PATH + 1],
            pszMessageText[MAX_PATH + 1],
            pszTitleString[MAX_STRING_RES + 1];

    AssertSz(!m_fTerminatedHandler,"Terminate Handler called twice on same Proxy"); 

    if (S_OK == DoesStubExist(m_pStubId))
    {
        BOOL bResult;

        // let use know of cases don't want to prompt user but haven't killed stub yet.
        Assert(fPromptUser); 

        if (fPromptUser)
        {
            if (!pszHandlerName)
            {
                LoadString(g_hInst,IDS_NULL_HANDLERNOTRESPONDING,pszMessageText, MAX_PATH); 
            }
            else
            {
                LoadString(g_hInst,IDS_HANDLERNOTRESPONDING,pszFormatString, MAX_PATH); 
                StringCchPrintf(pszMessageText, ARRAYSIZE(pszMessageText), pszFormatString, pszHandlerName);
            }
    
            LoadString(g_hInst,IDS_SYNCMGR_ERROR,pszTitleString, MAX_STRING_RES);

            iEndSession = MessageBox(m_hwndDlg,pszMessageText,pszTitleString,
                                     MB_YESNO | MB_ICONERROR );

            if (IDYES != iEndSession)
            {
                return S_FALSE;  //Yes will terminate the thread
            }
        }

        // make sure handler is still not responding.
        HRESULT fAllHandlerInstancesComplete = S_FALSE;
        if (m_pHndlrQueue)
        {
            fAllHandlerInstancesComplete = m_pHndlrQueue->IsAllHandlerInstancesCancelCompleted(m_Clsid);
        }
        
        // if no longer any instancesof this handler that aren't responding just ignore
        // the terminate.
        if (S_OK == fAllHandlerInstancesComplete)
        {
            return S_FALSE;
        }

        // mark the stubId as terminated
        TerminateStub(m_pStubId);

        // now terminate the thread.
        // CODE REVIEW:
        // NOTENOTE:
        //  Danger Will Robinson - Danger Will Robinson - Danger Will Robinson
        //  Maybe we can use something other than TerminateThread here ???
        bResult = TerminateThread (m_hThreadStub, 0);
        AssertSz(bResult,"Error Terminating Thread");
    }

    m_pStubId = NULL;

    // if get here means we should are terminating this thread
    m_fTerminatedHandler = TRUE;
    m_hThreadStub = 0; // set threadId of stub to zero.

    // set the proxy stubhwnd to NULL
    m_hwndStub = NULL;

    // if have a hndlrmsg tell it we are terminated and clear
    // out our member variable.
    if (m_pCHndlrMsg)
    {
        CHndlrMsg *pCHndlrMsg = m_pCHndlrMsg;

        m_pCHndlrMsg = NULL;
        pCHndlrMsg->ForceKillHandler();
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::CreateNewHndlrMsg, public
//
//  Synopsis:   Make a request to the stub to create a new
//		Handler Message object
//
//  Arguments:
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CThreadMsgProxy::CreateNewHndlrMsg()
{
    HRESULT hr = S_OK;
    MSGSTUBCreateStub msg;

    msg.MsgGen.ThreadMsg = StubMsg_CreateNewStub;

    hr = DispatchsStubMsg( (GenericMsg *) &msg,TRUE);

    m_pCHndlrMsg = msg.pCHndlrMsg;

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::ReleaseStub, public
//
//  Synopsis:   Informst the Stub thread that it is no longer needed.

//  Arguments:
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CThreadMsgProxy::ReleaseStub()
{
    HRESULT hr = S_OK;
    GenericMsg msg;

    msg.ThreadMsg = StubMsg_Release;

    hr = DispatchsStubMsg( (GenericMsg *) &msg,TRUE);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CThreadMsgProxy::QueryInterface, public
//
//  Synopsis:   Standard QueryInterface
//
//  Arguments:  [iid] - Interface ID
//              [ppvObj] - Object return
//
//  Returns:    Always returns E_NOTIMPL;
//
//  Modifies:   [ppvObj]
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CThreadMsgProxy::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    AssertSz(0,"QI called on MsgProxy");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:	CThreadMsgProxy::AddRef, public
//
//  Synopsis:	Add reference
//
//  History:	05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CThreadMsgProxy::AddRef()
{
    ULONG cRefs;

    cRefs = InterlockedIncrement((LONG *)& m_cRef);
    return cRefs;
}

//+---------------------------------------------------------------------------
//
//  Member:	CThreadMsgProxy::Release, public
//
//  Synopsis:	Release reference
//		Must properly handle the case Release is
//		called before the initialize method in case
//		createing the handler thread fails.
//
//  History:	05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CThreadMsgProxy::Release()
{
    HRESULT hr = S_OK;
    GenericMsg msg;
    ULONG cRefs;

    cRefs = InterlockedDecrement( (LONG *) &m_cRef);

    if (cRefs)
        return cRefs;

    if (m_hThreadStub && !m_fTerminatedHandler)
    {
        CCriticalSection cCritSect(&g_StubListCriticalSection,GetCurrentThreadId());
        BOOL fLastRelease = FALSE;
        BOOL fExistingStub = FALSE;
        STUBLIST *pStubList;

	    // release the handler Thread.
	    msg.ThreadMsg = ThreadMsg_Release;
	    hr = DispatchMsg( (GenericMsg *) &msg,TRUE,FALSE);
	    m_pCHndlrMsg = NULL;

	    // If the cRefs in our proxy list is zero
	    // then sit in loop until the ThreadStub Dies.
	    cCritSect.Enter();

	    pStubList = g_FirstStub;
	    while (pStubList)
	    {
	        if (pStubList->clsidStub == m_Clsid)
	        {
		        fExistingStub = TRUE;
		        break;
	        }

	        pStubList= pStubList->pNextStub;
	    }

	    Assert(fExistingStub); // their should always be an existing proxy

	    if (fExistingStub)
	    {
	        Assert(pStubList->cRefs > 0);

	        (pStubList->cRefs)--;

	        if (0 == pStubList->cRefs)
    	    {
	            STUBLIST CurStub;
        	    STUBLIST *pCurStub = &CurStub;

		        CurStub.pNextStub = g_FirstStub;

		        while (pCurStub->pNextStub)
		        {
		            if (pCurStub->pNextStub == pStubList)
		            {
			            pCurStub->pNextStub = pStubList->pNextStub;
			            g_FirstStub = CurStub.pNextStub;
			            FREE(pStubList);
			            break;
		            }

		            pCurStub = pCurStub->pNextStub;
		        }

		        fLastRelease = TRUE;
	        }
    	}

	    cCritSect.Leave();

	    if (fLastRelease)
	    {
	        // send the quit command to the stub,
	        if (S_OK == ReleaseStub())
	        {
		        // Review, what if stubthread never dies.
                m_dwNestCount++;
		        DoModalLoop(m_hThreadStub,NULL,NULL,TRUE,INFINITE); // sit in loop until the stub thread dies
		        CloseHandle(m_hThreadStub);
                m_dwNestCount--;
	        }
	    }

        m_pStubId = NULL; // clear StubId
    }

    delete this;
    return cRefs;
}


//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::Initialize, public
//
//  Synopsis:   Sends Initialize command to the Handler thread

//  Arguments:  [dwReserved] - reserved.
//		[dwSyncFlags] - syncflags
//		[cbCookie] - size of cookie data
//		[lpCookie] - ptr to any cookie data
//
//  Returns:    Appropriate error code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CThreadMsgProxy::Initialize(DWORD dwReserved,
			    DWORD dwSyncFlags,
			    DWORD cbCookie,
			    const BYTE  *lpCookie)
{
    HRESULT hr = S_OK;
    MSGInitialize msg;

    msg.MsgGen.ThreadMsg = ThreadMsg_Initialize;

    // package up the parameters
    msg.dwReserved = dwReserved;
    msg.dwSyncFlags = dwSyncFlags;
    msg.cbCookie = cbCookie;
    msg.lpCookie = lpCookie;

    hr = DispatchMsg( (GenericMsg *) &msg,TRUE,FALSE);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::GetHandlerInfo, public
//
//  Synopsis:   Sends GetHandler command to the Handler thread

//  Arguments:  [ppSyncMgrHandlerInfo] - pointer to SyncMgrHandlerInfo pointer
//
//  Returns:    Appropriate error code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CThreadMsgProxy::GetHandlerInfo(LPSYNCMGRHANDLERINFO *ppSyncMgrHandlerInfo)
{
    HRESULT hr = S_OK;
    MSGGetHandlerInfo msg;

    msg.MsgGen.ThreadMsg = ThreadMsg_Initialize;

    // package up the parameters
    msg.ppSyncMgrHandlerInfo = ppSyncMgrHandlerInfo;

    hr = DispatchMsg( (GenericMsg *) &msg,TRUE,FALSE);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::EnumOfflineItems, public
//
//  Synopsis:   Sends Enum command to the Handler thread
//		Should not be called. AddItems method
//		should be called instead
//
//  Arguments:  [ppenumOfflineItems] - reserved.
//
//  Returns:    E_NOTIMPL;
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CThreadMsgProxy::EnumSyncMgrItems(ISyncMgrEnumItems **ppenumOfflineItems)
{
    AssertSz(0,"EnumMethod Called on Proxy");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::GetItemObject, public
//
//  Synopsis:   Sends GetItemObject command to the Handler thread

//  Arguments:  [ItemID] - identifies the item.
//		[riid] - requested interface
//		[ppv] - On success, pointer to object
//
//  Returns:    Appropriate error code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CThreadMsgProxy::GetItemObject(REFSYNCMGRITEMID ItemID,REFIID riid,void** ppv)
{
    HRESULT hr = S_OK;
    MSGGetItemObject msg;

    msg.MsgGen.ThreadMsg = ThreadMsg_GetItemObject;

    // package up the parameters
    msg.ItemID  = ItemID;
    msg.riid = riid;
    msg.ppv = ppv;

    hr = DispatchMsg( (GenericMsg *) &msg,TRUE,FALSE);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::ShowProperties, public
//
//  Synopsis:   Sends ShowProperties command to the Handler thread

//  Arguments:  [hWndParent] - hwnd to use as parent of any dialogs
//		[ItemID] - Identifies the Item
//
//  Returns:    Appropriate error code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CThreadMsgProxy::ShowProperties(HWND hWndParent,REFSYNCMGRITEMID ItemID)
{
    HRESULT hr = S_OK;
    MSGShowProperties msg;

    msg.MsgGen.ThreadMsg = ThreadMsg_ShowProperties;

    // package up the parameters
    msg.hWndParent = hWndParent;
    msg.ItemID = ItemID;

    hr = DispatchMsg( (GenericMsg *) &msg,TRUE,TRUE);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::SetProgressCallback, public
//
//  Synopsis:   Sends SetProgressCallback command to the Handler thread
//		This method should not be called, SetupCallback method
//		should be called instead
//
//  Arguments:  [lpCallBack] - Ptr to callback.
//
//  Returns:    Appropriate error code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CThreadMsgProxy::SetProgressCallback(ISyncMgrSynchronizeCallback *lpCallBack)
{
    AssertSz(0,"SetProgressCallback called on Proxy");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::PrepareForSync, public
//
//  Synopsis:   Sends PrepareForSync command to the Handler thread
//
//  Arguments:  [cbNumItems] - Number of items in the pItemIDs array.
//		[pItemIDs] - array of item ids
//		[hWndParent] - hwnd to use as the parent for any dialogs
//		[dwReserved] - Reserved parameter.
//
//  Returns:    Appropriate error code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CThreadMsgProxy::PrepareForSync(ULONG cbNumItems,SYNCMGRITEMID *pItemIDs,
				    HWND hWndParent,DWORD dwReserved)
{
    HRESULT hr = S_OK;
    MSGPrepareForSync msg;

    msg.MsgGen.ThreadMsg = ThreadMsg_PrepareForSync;

    // package up the parameters
    msg.cbNumItems = cbNumItems;
    msg.pItemIDs   = pItemIDs;
    msg.hWndParent = hWndParent;
    msg.dwReserved = dwReserved;

    hr = DispatchMsg( (GenericMsg *) &msg,TRUE,TRUE);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::Synchronize, public
//
//  Synopsis:   Sends Synchronize command to the Handler thread
//
//  Arguments:	[hWndParent] - hwnd to use as the parent for any dialogs
//
//  Returns:    Appropriate error code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CThreadMsgProxy::Synchronize(HWND hWndParent)
{
    HRESULT hr = S_OK;
    MSGSynchronize msg;

    msg.MsgGen.ThreadMsg = ThreadMsg_Synchronize;

    // package up the parameters
    msg.hWndParent = hWndParent;

    hr = DispatchMsg( (GenericMsg *) &msg,TRUE,TRUE);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::SetItemStatus, public
//
//  Synopsis:   Sends SetItemStatus command to the Handler thread
//
//  Arguments:	[ItemID] - Identifies the item
//		[dwSyncMgrStatus] - Status to set the item too.
//
//  Returns:    Appropriate error code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CThreadMsgProxy::SetItemStatus(REFSYNCMGRITEMID ItemID,DWORD dwSyncMgrStatus)
{
    HRESULT hr = S_OK;
    MSGSetItemStatus msg;

    msg.MsgGen.ThreadMsg = ThreadMsg_SetItemStatus;

    // package up the parameters
    msg.ItemID = ItemID;
    msg.dwSyncMgrStatus = dwSyncMgrStatus;

    hr = DispatchMsg( (GenericMsg *) &msg,TRUE,FALSE);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::ShowError, public
//
//  Synopsis:   Sends ShowError command to the Handler thread
//
//  Arguments:	[hWndParent] - hwnd to use as the parent for any dialogs
//		[dwErrorID] - Identifies the Error.
//
//  Returns:    Appropriate error code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CThreadMsgProxy::ShowError(HWND hWndParent,REFSYNCMGRERRORID ErrorID,ULONG *pcbNumItems,SYNCMGRITEMID **ppItemIDs)
{
    HRESULT hr = S_OK;
    MSGShowConflicts msg;

    msg.MsgGen.ThreadMsg = ThreadMsg_ShowError;

    // package up the parameters
    msg.hWndParent = hWndParent;
    msg.ErrorID = ErrorID;
    msg.pcbNumItems = pcbNumItems;
    msg.ppItemIDs = ppItemIDs;

    hr = DispatchMsg( (GenericMsg *) &msg,TRUE,TRUE);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::CreateServer, public
//
//  Synopsis:   Sends CreateServer command to the Handler thread
//
//  Arguments:	[pCLSIDServer] - clsid of handler to create
//		[pHndlrQueue] - Queue the handler belongs too.
//		[wHandlerId] - ID assigned to this instance of the Handler
//
//  Returns:    Appropriate error code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CThreadMsgProxy::CreateServer(const CLSID *pCLSIDServer,CHndlrQueue *pHndlrQueue,
						HANDLERINFO *pHandlerId)
{
    HRESULT hr = S_OK;
    MSGCreateServer msg;

    m_pHndlrQueue = pHndlrQueue;
    m_pHandlerId = pHandlerId;

    msg.MsgGen.ThreadMsg = ThreadMsg_CreateServer;

    // package up the parameters
    msg.pCLSIDServer = pCLSIDServer;
    msg.pHndlrQueue  = pHndlrQueue;
    msg.pHandlerId   = pHandlerId;
    msg.dwProxyThreadId = m_ThreadIdProxy;

    hr = DispatchMsg( (GenericMsg *) &msg,TRUE,FALSE);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::SetHndlrQueue, public
//
//  Synopsis:   Assigns a new queue to the Handler
//
//  Arguments:	[pHndlrQueue] - Queue the handler now belongs too.
//		[wHandlerId] - ID assigned to this instance of the Handler
//		[dwThreadIdProxy] - ThreadID the queue is in.
//
//  Returns:    Appropriate error code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CThreadMsgProxy::SetHndlrQueue(CHndlrQueue *pHndlrQueue,
					    HANDLERINFO *pHandlerId,
					    DWORD dwThreadIdProxy)
{
    HRESULT hr = S_OK;
    MSGSetHndlrQueue msg;

    AssertSz(0,"this shouldn't be called");

    m_ThreadIdProxy = dwThreadIdProxy; // update the threadId the Proxy is on.

    msg.MsgGen.ThreadMsg = ThreadMsg_SetHndlrQueue;

    // package up the parameters
    msg.pHndlrQueue  = pHndlrQueue;
    msg.pHandlerId   = pHandlerId;
    msg.dwProxyThreadId = dwThreadIdProxy;

    hr = DispatchMsg( (GenericMsg *) &msg,TRUE,FALSE);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::AddHandlerItems, public
//
//  Synopsis:   Request Handler adds its items to the queue.
//
//  Arguments:	[hwndList] - Currently not used..
//
//  Returns:    Appropriate error code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP  CThreadMsgProxy::AddHandlerItems(HWND hwndList,DWORD *pcbNumItems)
{
    HRESULT hr = S_OK;
    MSGAddItemHandler msg;

    msg.MsgGen.ThreadMsg = ThreadMsg_AddHandlerItems;

    // package up the parameters
    msg.hwndList = hwndList;
    msg.pcbNumItems = pcbNumItems;

    hr = DispatchMsg( (GenericMsg *) &msg,TRUE,FALSE);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::SetupCallback, public
//
//  Synopsis:   Request stub sets up the Callback.
//
//  Arguments:	[fSet] - TRUE == set the callback, FALSE == revoke it.
//
//  Returns:    Appropriate error code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP  CThreadMsgProxy::SetupCallback(BOOL fSet)
{
    HRESULT hr = S_OK;
    MSGSetupCallback msg;

    AssertSz(0,"Shouldn't be called");

    msg.MsgGen.ThreadMsg = ThreadMsg_SetupCallback;

    // package up the parameters
    msg.fSet = fSet;
    hr = DispatchMsg( (GenericMsg *) &msg,TRUE,FALSE);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::SetProxyParams, public
//
//  Synopsis:   informs server thread that the queue has been chagned
//              on it..
//
//  Arguments:	
//
//  Returns:    Appropriate error code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP  CThreadMsgProxy::SetProxyParams(HWND hwndDlg, DWORD ThreadIdProxy,
			    CHndlrQueue *pHndlrQueue,HANDLERINFO *pHandlerId )
{
    m_hwndDlg = hwndDlg;
    m_ThreadIdProxy = ThreadIdProxy;
    m_pHndlrQueue = pHndlrQueue;
    m_pHandlerId = pHandlerId;

    Assert(m_pCHndlrMsg);
    if (m_pCHndlrMsg)
    {
        m_pCHndlrMsg->SetHndlrQueue(pHndlrQueue,pHandlerId,m_ThreadIdProxy);
    }

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::SetProxyCompletion, public
//
//  Synopsis:   sets values for any completion notification to
//              post when returning from an out call
//
//  Arguments:	
//
//  Returns:    Appropriate error code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP  CThreadMsgProxy::SetProxyCompletion(HWND hWnd,UINT Msg,WPARAM wParam,LPARAM lParam)
{
    Assert(FALSE == m_fHaveCompletionCall); // should only ever have one.

    if (m_fHaveCompletionCall) // if already have a completion fail.
           return S_FALSE;

    m_fHaveCompletionCall = TRUE;

    m_msgCompletion.hwnd = hWnd;
    m_msgCompletion.message = Msg;
    m_msgCompletion.wParam = wParam;
    m_msgCompletion.lParam = lParam;

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:   CMsgServiceHwnd::CMsgServiceHwnd, public
//
//  Synopsis:	Constructor
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

CMsgServiceHwnd::CMsgServiceHwnd()
{
    m_hwnd = NULL;
    m_dwThreadID = -1;
    m_pHndlrMsg = NULL;
    m_fInOutCall = FALSE;
    m_pMsgServiceQueue = NULL;
    m_MsgHwndType = MSGHWNDTYPE_UNDEFINED;
}

//+---------------------------------------------------------------------------
//
//  Member:   CMsgServiceHwnd::~CMsgServiceHwnd, public
//
//  Synopsis:	Destructor
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

CMsgServiceHwnd::~CMsgServiceHwnd()
{
}

//+---------------------------------------------------------------------------
//
//  Member:   CMsgServiceHwnd::Initialize, public
//
//  Synopsis:	Initializes the service HWND
//
//  Arguments:  [dwThreadID] - id of thread hwnd belongs too.
//		[MsgHwndType] - type of MsgHwnd this is.
//
//  Returns: TRUE on success, FALSE on failure
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CMsgServiceHwnd::Initialize(DWORD dwThreadID,MSGHWNDTYPE MsgHwndType)
{
    BOOL fInitialized = FALSE;
    TCHAR szWinTitle[MAX_STRING_RES];

    m_MsgHwndType = MsgHwndType;

   LoadString(g_hInst, IDS_SYNCMGRNAME, szWinTitle, ARRAYSIZE(szWinTitle));

    m_hwnd = CreateWindowEx(0,
			      TEXT(MSGSERVICE_HWNDCLASSNAME),
			      szWinTitle,
			      // must use WS_POPUP so the window does not get
			      // assigned a hot key by user.
			      WS_DISABLED |   WS_POPUP,
			      CW_USEDEFAULT,
			      CW_USEDEFAULT,
			      CW_USEDEFAULT,
			      CW_USEDEFAULT,
			      NULL, // REVIEW, can we give it a parent to not show up.
			      NULL,
			      g_hInst,
			      this);

    Assert(m_hwnd);

    if (m_hwnd)
    {
	    m_dwThreadID = dwThreadID;
		fInitialized = TRUE;
    }

    if (!fInitialized)
    {
	    Assert(NULL == m_pHndlrMsg);
    }

    // caller still needs to call Destroy if initialize returns false.
    return fInitialized;
 }

//+---------------------------------------------------------------------------
//
//  Member:   CMsgServiceHwnd::Destroy, public
//
//  Synopsis:	Destroys the ServiceHwnd
//
//  Arguments:

//  Returns:
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

void CMsgServiceHwnd::Destroy()
{
    BOOL fDestroy;

    // HANDLER m_pHndlrMsg will be destroyed by the Release HandleThreadMessage call
    // only case that it shouldn't is if for some reason CreateThreadHndlr failed
    Assert(NULL == m_pHndlrMsg);

    if (m_pHndlrMsg)
    {
    	m_pHndlrMsg->Release();
	    m_pHndlrMsg = NULL;
    }

    if (m_hwnd)
    {
    	fDestroy =  DestroyWindow(m_hwnd);
        Assert(fDestroy);
    }

    delete this;
}

//+---------------------------------------------------------------------------
//
//  Member:   CMsgServiceHwnd::MsgThreadWndProc, public
//
//  Synopsis:	Servicer Side message handling window.
//
//  Arguments:

//  Returns:
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

LRESULT CALLBACK  MsgThreadWndProc(HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{
    CMsgServiceHwnd *pThis = (CMsgServiceHwnd *) GetWindowLongPtr(hWnd, DWL_THREADWNDPROCCLASS);

    if (pThis || (msg == WM_CREATE))
    {
        switch (msg)
        {
	    case WM_CREATE :
            {
	            CREATESTRUCT *pCreateStruct = (CREATESTRUCT *) lParam;
                SetWindowLongPtr(hWnd, DWL_THREADWNDPROCCLASS,(LONG_PTR) pCreateStruct->lpCreateParams );
	            pThis = (CMsgServiceHwnd *) pCreateStruct->lpCreateParams ;
	        }
	        break;

	    case WM_DESTROY:
            SetWindowLongPtr(hWnd, DWL_THREADWNDPROCCLASS,(LONG_PTR) NULL);
            PostQuitMessage(0); // no longer need this thread
	        break;

	    case WM_THREADSTUBMESSAGE: // message send only to stub.
	        {
                MessagingInfo *pmsgInfo = (MessagingInfo *) wParam;
	            GenericMsg *pgenMsg = (GenericMsg *) lParam;

		        Assert(MSGHWNDTYPE_HANDLERTHREAD == pThis->m_MsgHwndType);
		
		        pgenMsg->hr = E_UNEXPECTED;

		        switch(pgenMsg->ThreadMsg)
		        {
		        case StubMsg_Release:
		            // proxy is telling us there is no need to stick around
		            // any longer so post a quit message.
		            Assert(NULL == pThis->m_pHndlrMsg);

		            pThis->Destroy();  // no longer need this
		            pgenMsg->hr = S_OK;
		            break;

		        case StubMsg_CreateNewStub:
		            // proxy is telling us there is no need to stick around
		            // any longer so post a quit message.

                    pThis->m_pHndlrMsg = new CHndlrMsg;
                    ((MSGSTUBCreateStub *) pgenMsg)->pCHndlrMsg = pThis->m_pHndlrMsg;

		            pThis->m_pHndlrMsg = NULL;
		            pgenMsg->hr = S_OK;
		            break;

		        default:
		            AssertSz(0,"Unknown StubMessage");
		            break;
		        };

                if (pmsgInfo->hMsgEvent)
		        {
		            SetEvent(pmsgInfo->hMsgEvent);
                }
	        }
            break;

	    case WM_THREADMESSAGE:
            {
                MessagingInfo *pmsgInfo = (MessagingInfo *) wParam;
                GenericMsg *pgenMsg = (GenericMsg *) lParam;

                Assert(MSGHWNDTYPE_HANDLERTHREAD == pThis->m_MsgHwndType);

                pThis->HandleThreadMessage(pmsgInfo,pgenMsg);

                // won't be an hEvent on an async call
	            if (pmsgInfo->hMsgEvent)
	            {
	               SetEvent(pmsgInfo->hMsgEvent);
	            }

                // on an async call we free
            }
            break;

        case WM_CFACTTHREAD_REVOKE:
            {
                Assert(MSGHWNDTYPE_MAINTHREAD == pThis->m_MsgHwndType);
		        HRESULT hr = CoRevokeClassObject((DWORD)wParam);
		        Assert(S_OK == hr);
	        }
            break;

	    case WM_MAINTHREAD_QUIT: // handles shutdown of main thread.
	        {
	            HANDLE hThread = (HANDLE) lParam;

	            Assert(MSGHWNDTYPE_MAINTHREAD == pThis->m_MsgHwndType);

                // set ShuttingDown Flag for race conditions with QueryEnd,
                // before yielding.
                g_fShuttingDown = TRUE; 

                // if there is an hThread that was passed wait until it goes away
                Assert(0 == hThread); // we currently don't support this.

		        if (hThread)
		        {
		            WaitForSingleObject(hThread,INFINITE);
		            CloseHandle(hThread);
		        }

                // if have a queryEndSession object state its okay to return now
                // no need to cleanup window.
                if (g_hEndSessionEvent)
                {
                    HANDLE hEvent = g_hEndSessionEvent;
                    // g_hEndSessionEvent = NULL; // leave EndSession NON-Null since only need to handle one.
                    SetEvent(hEvent);
                }
                else
                {
                    pThis->Destroy(); // Clean up this window.
                }
	        }
            break;

        case WM_QUERYENDSESSION:
            {
                HWND hwndQueryParent;
                UINT uiMessageID;
                BOOL fLetUserDecide;
                BOOL fReturn = TRUE;

                // only handle this message if it is the main thread window
                if (MSGHWNDTYPE_MAINTHREAD != pThis->m_MsgHwndType)
                {
                    break;
                }

                if (!g_fShuttingDown 
                       && (S_FALSE == ObjMgr_HandleQueryEndSession(&hwndQueryParent,&uiMessageID,&fLetUserDecide)))
                {
                    TCHAR pszTitle[MAX_PATH];
                    TCHAR pszMessageText[MAX_PATH];
                    UINT uType; // style of messagebox.
                    int iEndSession;

                    LoadString(g_hInst,IDS_SYNCMGRNAME,pszTitle,sizeof(pszTitle)/sizeof(TCHAR));
                    LoadString(g_hInst,uiMessageID,pszMessageText,sizeof(pszMessageText)/sizeof(TCHAR));

                    if (fLetUserDecide)
                    {
                        uType = MB_YESNO | MB_ICONEXCLAMATION | MB_SETFOREGROUND;
                    }
                    else
                    {
                        uType = MB_OK | MB_ICONSTOP | MB_SETFOREGROUND;
                    }

                    iEndSession = MessageBox(hwndQueryParent, pszMessageText, pszTitle, uType);

                    if (!fLetUserDecide || IDYES != iEndSession)
                    {
                        fReturn = FALSE;  // FALSE causes system to stop the shutdown.
                    }
                }


                // if we are going to allow shutdown cleanup our threads
                // before returning since on Win9x its too late afterwards.
		        if (fReturn)
                {
                    HANDLE hEndSessionEvent = NULL;

                    // its possible that another QUERYENDSESSION comes
                    // in while we are still shutting down. If already
                    // handling an end sessios or in WM_MAINTHREAD_QUIT just fall through

			        if (NULL == g_hEndSessionEvent && !g_fShuttingDown)
                    {
                        g_hEndSessionEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
                        hEndSessionEvent = g_hEndSessionEvent;
                            
                        ObjMgr_CloseAll(); // start the process of closing down the dialogs.

                        Assert(hEndSessionEvent);
		
                        // wait until other threads have cleaned up so we know its safe to terminate.
                        if (hEndSessionEvent)
                        {
                            DoModalLoop(hEndSessionEvent ,NULL,NULL,TRUE,INFINITE);
                           CloseHandle(hEndSessionEvent);
                        }
                    }
                }

                return fReturn;
		    }
	    	break;

	    default:
	        break;
        }
    }

    return DefWindowProc(hWnd, msg, wParam, lParam);
}

//+---------------------------------------------------------------------------
//
//  Function:   InitMessageService, public
//
//  Synopsis:	Initializes our internal thread messaging service.
//		Must be called before any Messagin is done.
//
//  Arguments:

//  Returns: S_OK if Service was successfully initialized.
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI InitMessageService()
{
    ATOM aWndClass = 0;
    WNDCLASS        xClass;
    DWORD dwErr;

    // initialize the proxy critical section
    if (InitializeCriticalSectionAndSpinCount(&g_StubListCriticalSection, 0))
    {
        // Register windows class.we need for handling thread communication
        xClass.style         = 0;
        xClass.lpfnWndProc   = MsgThreadWndProc;
        xClass.cbClsExtra    = 0;

        xClass.cbWndExtra    = sizeof(PVOID); // room for class this ptr
        xClass.hInstance     = g_hInst;
        xClass.hIcon         = NULL;
        xClass.hCursor       = NULL;
        xClass.hbrBackground = (HBRUSH) (COLOR_BACKGROUND + 1);
        xClass.lpszMenuName  = NULL;
        xClass.lpszClassName = TEXT(MSGSERVICE_HWNDCLASSNAME);

        aWndClass = RegisterClass( &xClass );

        dwErr = GetLastError();

        Assert(aWndClass);
    }

    return (0 == aWndClass) ? S_FALSE : S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\exe\objmgr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       ObjMgr.h
//
//  Contents:   Keeps track of our applications dialog objects
//              and lifetime
//
//  Classes:
//
//  Notes:
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#ifndef _OBJMGR_
#define _OBJMGR_

class CBaseDlg;
class CChoiceDlg;
class CProgressDlg;

typedef enum _tagDLGTYPE   // type of dialog.
{
    DLGTYPE_CHOICE                      = 0x1,
    DLGTYPE_PROGRESS                    = 0x2,
} DLGTYPE;

enum EAutoDialState
{
    eQuiescedOn,        // Quiesced state and auto dial is on
    eQuiescedOff,       // Quiesced state and auto dial is off
    eAutoDialOn,        // During a sync session and auto dial is on
    eAutoDialOff        // During a sync session and auto dial is off
};


typedef struct _tagDLGLISTITEM {
    _tagDLGLISTITEM *pDlgNextListItem;  // pointer to the next dialog in the list.
    DLGTYPE dlgType;            // type of dialog this is.
    ULONG cRefs;                // number of references on this object
    ULONG cLocks;               // number of locks on this object
    CLSID clsid;                // clsid of this dialog, only applicable to choice.
    CBaseDlg *pDlg;
    DWORD dwThreadID;           // Thread the dialog is on.
    HANDLE hThread;             // Handle to the thread the dialog belongs too
    BOOL fHasReleaseDlgCmdId;   // boolean to indicate if there is a callback
    WORD wCommandID;            // CommandID to pass to the callback.
} DLGLISTITEM;


typedef struct _tagOBJECTMGRDATA {
    DLGLISTITEM *DlgList; // Ptr to Dialog list
    HANDLE hClassRegisteredEvent; // Event created by process that has registered the classFactory.
    DWORD dwRegClassFactCookie; // registered OLE Class Factory Cooke
    BOOL fRegClassFactCookieValid; // registered OLE Class Factory Cooke
    DWORD LockCountInternal;    // Internal lock count on Application
    DWORD LockCountExternal;    // External lock count on Application
    BOOL  fCloseAll;   // Set if told to CloseAll, used in ReleaseOneStopLifetime
    DWORD dwSettingsLockCount;  // number of lock counts on the settings dialog,.
    DWORD dwHandlerPropertiesLockCount; // number of lock counts on any handler properties dialogs open
    BOOL fDead; // set in release call to avoid multiple releases.
    DWORD dwMainThreadID; // Id of Main Thrad
    HWND hWndMainThreadMsg; //hwnd of Main Thread Message Hwnd.
    BOOL fIdleHandlerRunning; // SyncMgr is currently processing Idle.
    EAutoDialState   eAutoDialState;     // State machine for supporting autodial
    BOOL             fRasAutoDial;       // Is Ras auto dial on ?
    DWORD            dwWininetAutoDialMode; // State of Wininet auto dial
    BOOL             fFirstSyncItem;     // Is the first PrepareForSyncItem being processed
    ULONG            cNestedStartCalls;  // Count of nested start calls
} OBJECTMGRDATA;


typedef struct _tagDlgThreadArgs {
HANDLE hEvent; // used to know when the message loop has been created.
HRESULT hr; // inidicates if creation was successfull
DLGTYPE dlgType; // requested dialog type to create.
CLSID clsid; // clsid identifies the dialog.
int nCmdShow; // how to display the dialog
CBaseDlg *pDlg; // pointer to the created dialog.
} DlgThreadArgs;

DWORD WINAPI DialogThread( LPVOID lpArg );

// onetime initialization routiens
STDAPI InitObjectManager(CMsgServiceHwnd *pMsgService);

// determines main threads response to WM_QUERYENDSESSION
STDAPI ObjMgr_HandleQueryEndSession(HWND *hwnd,UINT *uMessageId,BOOL *fLetUserDecide);
STDAPI_(ULONG) ObjMgr_AddRefHandlerPropertiesLockCount(DWORD dwNumRefs);
STDAPI_(ULONG) ObjMgr_ReleaseHandlerPropertiesLockCount(DWORD dwNumRefs);
STDAPI ObjMgr_CloseAll();

// idle managmenent
STDAPI RequestIdleLock();
STDAPI ReleaseIdleLock();

// routines for handling dialog lifetime
STDAPI FindChoiceDialog(REFCLSID rclsid,BOOL fCreate,int nCmdShow,CChoiceDlg **pChoiceDlg);
STDAPI_(ULONG) AddRefChoiceDialog(REFCLSID rclsid,CChoiceDlg *pChoiceDlg);
STDAPI_(ULONG) ReleaseChoiceDialog(REFCLSID rclsid,CChoiceDlg *pChoiceDlg);
STDAPI SetChoiceReleaseDlgCmdId(REFCLSID rclsid,CChoiceDlg *pChoiceDlg,WORD wCommandId);

STDAPI FindProgressDialog(REFCLSID rclsid,BOOL fCreate,int nCmdShow,CProgressDlg **pProgressDlg);
STDAPI_(ULONG) AddRefProgressDialog(REFCLSID rclsid,CProgressDlg *pProgressDlg);
STDAPI_(ULONG) ReleaseProgressDialog(REFCLSID rclsid,CProgressDlg *pProgressDlg,BOOL fForce);
STDAPI SetProgressReleaseDlgCmdId(REFCLSID rclsid,CProgressDlg *pProgressDlg,WORD wCommandId);
STDAPI LockProgressDialog(REFCLSID rclsid,CProgressDlg *pProgressDlg,BOOL fLock);

// helper routines called by dialog lifetime.
STDAPI FindDialog(DLGTYPE dlgType,REFCLSID rclsid,BOOL fCreate,int nCmdShow,CBaseDlg **pDlg);
STDAPI_(ULONG) AddRefDialog(DLGTYPE dlgType,REFCLSID rclsid,CBaseDlg *pDlg);
STDAPI_(ULONG) ReleaseDialog(DLGTYPE dlgType,REFCLSID rclsid,CBaseDlg *pDlg,BOOL fForce);
STDAPI SetReleaseDlgCmdId(DLGTYPE dlgType,REFCLSID rclsid,CBaseDlg *pDlg,WORD wCommandId);

// Routines called for dial support
STDAPI BeginSyncSession();
STDAPI EndSyncSession();
STDAPI ApplySyncItemDialState( BOOL fAutoDialDisable );
STDAPI GetAutoDialState();
STDAPI LokDisableAutoDial();
STDAPI LokEnableAutoDial();

typedef struct _tagDlgSettingsArgs {
HANDLE hEvent; // used to know when thread has been initialized.
HWND hwndParent; // hwnd to use the parent as.
DWORD dwParentThreadId;
} DlgSettingsArgs;

DWORD WINAPI  SettingsThread( LPVOID lpArg );
STDAPI ShowOptionsDialog(HWND hwndParent);

// helper routine for OLE classes.
STDAPI RegisterOneStopClassFactory(BOOL fForce);

// routines for managing lifetime of application
STDAPI_(ULONG) AddRefOneStopLifetime(BOOL fExternal);
STDAPI_(ULONG) ReleaseOneStopLifetime(BOOL fExternal);

// routines for routing messages
BOOL IsOneStopDlgMessage(MSG *msg);

// declarations for CSingletonNetapi class.

//+-------------------------------------------------------------------------
//
//  Class:      CSingletonNetApi
//
//  Purpose:    Singleton net api object
//
//  History:    31-Jul-98     SitaramR      Created
//
//--------------------------------------------------------------------------

class CSingletonNetApi : CLockHandler
{
public:

    CSingletonNetApi()
       : m_pNetApi(0)
    {
    }

    ~CSingletonNetApi();

    LPNETAPI GetNetApiObj();
    void DeleteNetApiObj();

private:
    LPNETAPI  m_pNetApi;                  // Actual net api object
};

extern CSingletonNetApi gSingleNetApiObj;  // Global singleton NetApi object


#endif // _OBJMGR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\exe\precomp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       prcomp.h
//
//  Contents:   precompiled headers
//
//  Classes:
//
//  Notes:
//
//  History:    04-Aug-98   rogerg      Created.
//
//--------------------------------------------------------------------------

// standard includes for  MobSync lib
#include <objbase.h>
#include <windows.h>
#include <windowsx.h>
#include <shellapi.h>
#include <commctrl.h>
#include <inetreg.h>
#include <advpub.h>
#include <mstask.h>
#include <msterr.h>

#include <mobsync.h>
#include <mobsyncp.h>

#include "debug.h"
#include "alloc.h"
#include "critsect.h"
#include "stringc.h"
#include "osdefine.h"

#include "validate.h"
#include "netapi.h"
#include "listview.h"
#include "util.hxx"
#include "clsobj.h"
#include "userenv.h"
#include "shlwapi.h"

// dll include files
#include "..\dll\dllreg.h"

#include "resource.h"
#include "resource.hm"

#include "reg.h"

#include "cmdline.h"
#include "idle.h"
#include "connobj.h"

#include "hndlrq.h"
#include "msg.h"
#include "callback.h"
#include "hndlrmsg.h"

#include "dlg.h"

#include "invoke.h"
#include "clsfact.h"

#include "objmgr.h"

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#ifndef LVS_EX_INFOTIP
#define LVS_EX_INFOTIP          0x00000400 // listview does InfoTips
#endif  // LVS_EX_INFOTIP

#ifndef LVM_GETSELECTIONMARK
#define LVM_GETSELECTIONMARK    (LVM_FIRST + 66)
#define ListView_GetSelectionMark(hwnd) \
    (int)SNDMSG((hwnd), LVM_GETSELECTIONMARK, 0, 0)
#endif //  LVM_GETSELECTIONMARK

#define LVIS_STATEIMAGEMASK_CHECK (0x2000)
#define LVIS_STATEIMAGEMASK_UNCHECK (0x1000)

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\exe\reg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Reg.h
//
//  Contents:   Registration routines
//
//  Classes:    
//
//  Notes:      
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#ifndef _ONESTOPREG_
#define _ONESTOPREG_


#define GUID_SIZE 128
#define MAX_STRING_LENGTH 256


// public functions
STDMETHODIMP GetLastIdleHandler(CLSID *clsidHandler);
STDMETHODIMP SetLastIdleHandler(REFCLSID clsidHandler);
BOOL  RegSchedHandlerItemsChecked(TCHAR *pszHandlerName, 
                                 TCHAR *pszConnectionName,
                                 TCHAR *pszScheduleName);


#endif // _ONESTOPREG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\exe\progress.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Progress.cpp
//
//  Contents:   Progress Dialog
//
//  Classes:
//
//  Notes:
//
//  History:    05-Nov-97   Susia      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

#define TIMERID_TRAYANIMATION 3
#define TRAYANIMATION_SPEED 500 // speed in milliseconds

#define TIMERID_NOIDLEHANGUP 4  // inform wininet that connection isn't idle.
#define NOIDLEHANGUP_REFRESHRATE (1000*30) // inform of idle every 30 seconds.

#define TIMERID_KILLHANDLERS 5
#define TIMERID_KILLHANDLERSMINTIME (1000*15) // minimum timeout for kill handlers that are hung after cancel.
#define TIMERID_KILLHANDLERSWIN9XTIME (1000*60) // Timeout for for kill handlers other than NT 5.0

const TCHAR c_szTrayWindow[]            = TEXT("Shell_TrayWnd");
const TCHAR c_szTrayNotifyWindow[]      = TEXT("TrayNotifyWnd");

#ifndef IDANI_CAPTION
#define IDANI_CAPTION   3
#endif // IDANI_CAPTION

// list collapsed items first so only have to loop
// though first item to cbNumDlgResizeItemsCollapsed when
// not expanded.
const DlgResizeList g_ProgressResizeList[] = {
    IDSTOP,DLGRESIZEFLAG_PINRIGHT,
    IDC_DETAILS,DLGRESIZEFLAG_PINRIGHT,
    IDC_RESULTTEXT,DLGRESIZEFLAG_PINRIGHT | DLGRESIZEFLAG_PINLEFT,
    IDC_STATIC_WHATS_UPDATING,DLGRESIZEFLAG_PINRIGHT | DLGRESIZEFLAG_PINLEFT,
    IDC_STATIC_WHATS_UPDATING_INFO,DLGRESIZEFLAG_PINRIGHT | DLGRESIZEFLAG_PINLEFT,
    IDC_STATIC_HOW_MANY_COMPLETE,DLGRESIZEFLAG_PINRIGHT | DLGRESIZEFLAG_PINLEFT,
    IDC_SP_SEPARATOR,DLGRESIZEFLAG_PINRIGHT | DLGRESIZEFLAG_PINLEFT,
    // expanded items
    IDC_TOOLBAR, DLGRESIZEFLAG_PINRIGHT,
    IDC_PROGRESS_TABS,DLGRESIZEFLAG_PINRIGHT | DLGRESIZEFLAG_PINLEFT | DLGRESIZEFLAG_PINBOTTOM | DLGRESIZEFLAG_PINTOP,
    IDC_UPDATE_LIST,DLGRESIZEFLAG_PINRIGHT | DLGRESIZEFLAG_PINLEFT | DLGRESIZEFLAG_PINBOTTOM | DLGRESIZEFLAG_PINTOP,
    IDC_SKIP_BUTTON_MAIN,DLGRESIZEFLAG_PINBOTTOM | DLGRESIZEFLAG_PINLEFT,
    IDC_STATIC_SKIP_TEXT,DLGRESIZEFLAG_PINBOTTOM | DLGRESIZEFLAG_PINLEFT,
    IDC_PROGRESS_OPTIONS_BUTTON_MAIN,DLGRESIZEFLAG_PINRIGHT | DLGRESIZEFLAG_PINBOTTOM,
    IDC_LISTBOXERROR,DLGRESIZEFLAG_PINRIGHT | DLGRESIZEFLAG_PINLEFT | DLGRESIZEFLAG_PINBOTTOM | DLGRESIZEFLAG_PINTOP,
    IDC_PROGRESSRESIZESCROLLBAR,DLGRESIZEFLAG_PINRIGHT | DLGRESIZEFLAG_PINBOTTOM,
};

extern HINSTANCE g_hInst;      // current instance
extern TCHAR g_szSyncMgrHelp[];
extern ULONG g_aContextHelpIds[];

extern LANGID g_LangIdSystem; // langID of system we are running on.
extern DWORD g_WMTaskbarCreated; // TaskBar Created WindowMessage;

INT_PTR CALLBACK ProgressWndProc(HWND hwnd, UINT uMsg,WPARAM wParam,LPARAM lParam);

//defined in progtab.cpp
extern INT_PTR CALLBACK UpdateProgressWndProc(HWND hwnd, UINT uMsg,WPARAM wParam,LPARAM lParam);
extern INT_PTR CALLBACK ResultsProgressWndProc(HWND hwnd, UINT uMsg,WPARAM wParam,LPARAM lParam);
extern BOOL OnProgressResultsMeasureItem(HWND hwnd,CProgressDlg *pProgress, UINT *horizExtent, UINT idCtl, MEASUREITEMSTRUCT *pMeasureItem);
extern BOOL OnProgressResultsDeleteItem(HWND hwnd, UINT idCtl, const DELETEITEMSTRUCT * lpDeleteItem);
extern void OnProgressResultsSize(HWND hwnd,CProgressDlg *pProgress,UINT uMsg,WPARAM wParam,LPARAM lParam);

//--------------------------------------------------------------------------------
//
//  FUNCTION: CProgressDlg::CProgressDlg()
//
//  PURPOSE:  Constructor
//
//      COMMENTS: Constructor for progress dialog
//
//
//--------------------------------------------------------------------------------
CProgressDlg::CProgressDlg(REFCLSID rclsid)
{
    m_clsid = rclsid;
    m_cInternalcRefs = 0;
    m_hwnd = NULL;
    m_hwndTabs = NULL;
    m_errorimage = NULL;
    m_HndlrQueue = NULL;
    m_iProgressSelectedItem = -1;
    m_iItem = -1;           // index to any new item to the list box.
    m_iResultCount = -1;    // Number of logged results
    m_iErrorCount = 0;      // Number of logged errors
    m_iWarningCount = 0;    // Number of logged warnings
    m_iInfoCount = 0;       // Number of logged info
    m_dwThreadID = -1;
    m_nCmdShow = SW_SHOWNORMAL;
//    m_hRasConn = NULL;
    m_pSyncMgrIdle = NULL;
    m_fHasShellTrayIcon = FALSE;
    m_fAddedIconToTray = FALSE;
    m_fnResultsListBox = NULL;

    m_ulIdleRetryMinutes = 0;
    m_ulDelayIdleShutDownTime = 0;

    m_fHwndRightToLeft = FALSE;

    m_iLastItem = -1;
    m_dwLastStatusType = -1;

    m_dwHandleThreadNestcount = 0;
    m_dwShowErrorRefCount = 0;
    m_dwSetItemStateRefCount = 0;
    m_dwHandlerOutCallCount = 0;
    m_dwPrepareForSyncOutCallCount = 0;
    m_dwSynchronizeOutCallCount = 0;
    m_dwQueueTransferCount = 0;
    m_clsidHandlerInSync = GUID_NULL;
    m_fForceClose = FALSE;
      
    m_nKillHandlerTimeoutValue = TIMERID_KILLHANDLERSMINTIME;

    m_dwProgressFlags = PROGRESSFLAG_NEWDIALOG;
    m_pItemListView =  NULL;
    m_iTrayAniFrame = IDI_SYSTRAYANI6; // initialize to end.

    LoadString(g_hInst, IDS_STOPPED,            m_pszStatusText[0], MAX_STRING_RES);
    LoadString(g_hInst, IDS_SKIPPED,            m_pszStatusText[1], MAX_STRING_RES);
    LoadString(g_hInst, IDS_PENDING,            m_pszStatusText[2], MAX_STRING_RES);
    LoadString(g_hInst, IDS_SYNCHRONIZING,      m_pszStatusText[3], MAX_STRING_RES);
    LoadString(g_hInst, IDS_SUCCEEDED,          m_pszStatusText[4], MAX_STRING_RES);
    LoadString(g_hInst, IDS_FAILED,                     m_pszStatusText[5], MAX_STRING_RES);
    LoadString(g_hInst, IDS_PAUSED,                     m_pszStatusText[6], MAX_STRING_RES);
    LoadString(g_hInst, IDS_RESUMING,           m_pszStatusText[7], MAX_STRING_RES);

    // Determine if SENS is installed
    LPNETAPI pNetApi;

    m_fSensInstalled = FALSE;
    if (pNetApi = gSingleNetApiObj.GetNetApiObj())
    {
        m_fSensInstalled = pNetApi->IsSensInstalled();
        pNetApi->Release();
    }

    m_CurrentListEntry = NULL;   
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgressDlg::AddRefProgressDialog, private
//
//  Synopsis:   Called to Addref ourselves
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    26-Aug-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CProgressDlg::AddRefProgressDialog()
{
    ULONG cRefs;

    cRefs = ::AddRefProgressDialog(m_clsid,this); // addref GlobalRef

    Assert(0 <= m_cInternalcRefs);
    ++m_cInternalcRefs;

    return cRefs;
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressDlg::ReleaseProgressDialog, private
//
//  Synopsis:   Called to Release ourselves
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    26-Aug-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CProgressDlg::ReleaseProgressDialog(BOOL fForce)
{
    ULONG cRefs;

    Assert(0 < m_cInternalcRefs);
    --m_cInternalcRefs;

    cRefs = ::ReleaseProgressDialog(m_clsid,this,fForce); // release global ref.

    return cRefs;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CProgressDlg::Initialize()
//
//  PURPOSE:  Initialize the Progress Dialog
//
//      COMMENTS: Implemented on main thread.
//
//
//--------------------------------------------------------------------------------
BOOL CProgressDlg::Initialize(DWORD dwThreadID,int nCmdShow)
{
    BOOL fCreated = FALSE;
    Assert(NULL == m_hwnd);

    m_nCmdShow = nCmdShow;

    if (NULL == m_hwnd)
    {
        m_dwThreadID = dwThreadID;

        m_hwnd =  CreateDialogParam(g_hInst,MAKEINTRESOURCE(IDD_PROGRESS),NULL,  ProgressWndProc,
                        (LPARAM) this);

        if (!m_hwnd)
            return FALSE;

        // expand/collapse dialog base on use settings.
        RegGetProgressDetailsState(m_clsid,&m_fPushpin, &m_fExpanded);
        ExpandCollapse(m_fExpanded, TRUE);

        // Set the state of the thumbtack
        if (m_fPushpin)
        {
            SendDlgItemMessage(m_hwnd, IDC_TOOLBAR, TB_SETSTATE, IDC_PUSHPIN,
                               MAKELONG(TBSTATE_CHECKED | TBSTATE_ENABLED, 0));
            SendMessage(m_hwnd, WM_COMMAND, IDC_PUSHPIN, 0);
        }

        m_HndlrQueue = new CHndlrQueue(QUEUETYPE_PROGRESS,this); // reivew, queueu should be created and passed in initialize??


        // if this is the idle progress then need to load up msidle and
        // set up the callback

        if (m_clsid == GUID_PROGRESSDLGIDLE)
        {
            BOOL fIdleSupport = FALSE;

            m_pSyncMgrIdle = new CSyncMgrIdle();

            if (m_pSyncMgrIdle)
            {
                fIdleSupport = m_pSyncMgrIdle->Initialize();

                if (FALSE == fIdleSupport)
                {
                    delete m_pSyncMgrIdle;
                    m_pSyncMgrIdle = NULL;
                }
            }

            // if couldn't load idle, then return a failure
            if (FALSE == fIdleSupport)
            {
                return FALSE;
            }
        }

        fCreated = TRUE;

        // When Window is first created show with specified nCmdShow.
        // Review if want to wait to show window until transfer comes in.
        UpdateWndPosition(nCmdShow,TRUE /* fForce */);
    }

   Assert(m_hwnd);

   UpdateWindow(m_hwnd);
   return TRUE;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CProgressDlg::OnSize(UINT uMsg,WPARAM wParam,LPARAM lParam)
//
//  PURPOSE:  moves and resizes dialog items based on current window size.
//
//--------------------------------------------------------------------------------

void CProgressDlg::OnSize(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    ULONG cbNumResizeItems;
    HWND hwndSizeGrip;

    cbNumResizeItems  =  m_fExpanded ? m_cbNumDlgResizeItemsExpanded : m_cbNumDlgResizeItemsCollapsed;

    ResizeItems(cbNumResizeItems,m_dlgResizeInfo);

    // if expanded and not maximized show the resize, else hide it.
    hwndSizeGrip = GetDlgItem(m_hwnd,IDC_PROGRESSRESIZESCROLLBAR);
    if (hwndSizeGrip)
    {
        int nCmdShow = (m_fMaximized || !m_fExpanded) ? SW_HIDE : SW_NORMAL;

	    // temporarily always hide if right to left
	    if (m_fHwndRightToLeft)
	    {
	        nCmdShow = SW_HIDE;
        }

        ShowWindow(hwndSizeGrip,nCmdShow);
    }

    // tell the error listbox it needs to recalc its items heights
    OnProgressResultsSize(m_hwnd,this,WM_SIZE,0,0);
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CProgressDlg::OffIdle()
//
//  PURPOSE:  Informs progress dialog that the machine is no longer Idle.
//
// Scenarios
//
//      dialog is maximized, just keep processing.
//      dialog is minimized or in tray - Set our wait timer for a specified time
//          if dialog is still minimized, go away
//          if dialog is now maximized just keep processing.
//
//--------------------------------------------------------------------------------

void CProgressDlg::OffIdle()
{
    Assert(!(PROGRESSFLAG_DEAD & m_dwProgressFlags)); // make sure not notified after dialog gone.

     m_dwProgressFlags |=  PROGRESSFLAG_INOFFIDLE;

    // set flag that we received the OffIdle
    m_dwProgressFlags |= PROGRESSFLAG_RECEIVEDOFFIDLE;

    // reset Flag so know that no longer registered for Idle.
    m_dwProgressFlags &=  ~PROGRESSFLAG_REGISTEREDFOROFFIDLE;

     // make sure in all cases we release the idle reference.

    // if in shutdownmode or cancel has already been pressed
    // by the user or if window is visible but not in the Tray.
    // then don't bother with the wait.

    if ( !IsWindowVisible(m_hwnd) && m_fHasShellTrayIcon
        && !(m_dwProgressFlags & PROGRESSFLAG_SHUTTINGDOWNLOOP)
        && !(m_dwProgressFlags & PROGRESSFLAG_CANCELPRESSED) 
        && (m_dwProgressFlags & PROGRESSFLAG_SYNCINGITEMS) )
    {
        HANDLE hTimer =  CreateEvent(NULL, TRUE, FALSE, NULL);

        // should use Create/SetWaitable timer to accomplish this but these
        // functions aren't available on Win9x yet.

        if (hTimer)
        {
            UINT uTimeOutValue = m_ulDelayIdleShutDownTime;

            Assert(sizeof(UINT) >= sizeof(HANDLE));

            DoModalLoop(hTimer,NULL,m_hwnd,TRUE,uTimeOutValue);

            CloseHandle(hTimer);
        }
    }


    // now after our wait, check the window placement again
    // if window is not visible or is in the tray
    // then do a cancel on behalf of the User,

    if ( (!IsWindowVisible(m_hwnd) || m_fHasShellTrayIcon)
        && !(m_dwProgressFlags & PROGRESSFLAG_SHUTTINGDOWNLOOP)
        && !(m_dwProgressFlags & PROGRESSFLAG_CANCELPRESSED) )
    {
        OnCancel(TRUE);
    }


    // now if we aren't syncing any items and no items
    // waiting in the queue release our idle lock
    // !!! warning. don't release until after wait above to
    // don't have to worry about next idle firing before
    // this method is complete.

    if (!(m_dwProgressFlags & PROGRESSFLAG_SYNCINGITEMS)
        || !(m_dwQueueTransferCount) )
    {
        ReleaseIdleLock();
    }

    m_dwProgressFlags &=  ~PROGRESSFLAG_INOFFIDLE;

    ReleaseProgressDialog(m_fForceClose); // release our addref.
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CProgressDlg::OnIdle()
//
//  PURPOSE:  Informs progress dialog that the machine is still
//          Idle after a set amount of time.
//
//
//--------------------------------------------------------------------------------

void CProgressDlg::OnIdle()
{
    CSynchronizeInvoke *pSyncMgrInvoke;

    Assert(!(m_dwProgressFlags & PROGRESSFLAG_DEAD)); // make sure not notified after dialog gone.

    // if received and offIdle then ignore this idle until next ::transfer
    if (!(m_dwProgressFlags & PROGRESSFLAG_RECEIVEDOFFIDLE)
        && !(m_dwProgressFlags & PROGRESSFLAG_INOFFIDLE) )
    {
        AddRefProgressDialog(); // hold alive until next items are queued.

        pSyncMgrInvoke = new CSynchronizeInvoke;

        if (pSyncMgrInvoke)
        {
            pSyncMgrInvoke->RunIdle();
            pSyncMgrInvoke->Release();
        }

        ReleaseProgressDialog(m_fForceClose);
    }
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CProgressDlg::SetIdleParams()
//
//  PURPOSE:  Sets the IdleInformation, last writer wins.
//
//
//--------------------------------------------------------------------------------

void CProgressDlg::SetIdleParams( ULONG ulIdleRetryMinutes,ULONG ulDelayIdleShutDownTime
                                 ,BOOL fRetryEnabled)
{
    Assert(m_clsid == GUID_PROGRESSDLGIDLE);

    m_ulIdleRetryMinutes = ulIdleRetryMinutes;
    m_ulDelayIdleShutDownTime = ulDelayIdleShutDownTime;

    if (fRetryEnabled)
    {
        m_dwProgressFlags |=  PROGRESSFLAG_IDLERETRYENABLED;
    }
}

//--------------------------------------------------------------------------------
//
//  FUNCTION:   BOOL CProgressDlg::InitializeToolbar(HWND hwnd)
//
//  PURPOSE:    What dialog would be complete without a toolbar, eh?
//
//  RETURN VALUE:
//      TRUE if everything succeeded, FALSE otherwise.
//
//--------------------------------------------------------------------------------
BOOL CProgressDlg::InitializeToolbar(HWND hwnd)
{
    HWND hwndTool;
    HIMAGELIST himlImages = ImageList_LoadBitmap(g_hInst,
                                        MAKEINTRESOURCE(IDB_PUSHPIN), 16, 0,
                                        RGB(255, 0, 255));

    hwndTool  = GetDlgItem(hwnd,IDC_TOOLBAR);

    //If we can't create the pushpin window
    //the user just won't get a pushpin.

    if (hwndTool)
    {
        TBBUTTON tb = { IMAGE_TACK_OUT, IDC_PUSHPIN, TBSTATE_ENABLED, TBSTYLE_CHECK, 0, 0 };
        SendMessage(hwndTool, TB_SETIMAGELIST, 0, (LPARAM) himlImages);
        SendMessage(hwndTool, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);
        SendMessage(hwndTool, TB_SETBUTTONSIZE, 0, MAKELONG(14, 14));
        SendMessage(hwndTool, TB_SETBITMAPSIZE, 0, MAKELONG(14, 14));
        SendMessage(hwndTool, TB_ADDBUTTONS, 1, (LPARAM) &tb);
    }

    return (0);
}

//--------------------------------------------------------------------------------
//
//  FUNCTION:   CProgressDlg::InitializeTabs(HWND hwnd)
//
//  PURPOSE:    Initializes the tab control on the dialog.
//
//  RETURN VALUE:
//      TRUE if everything succeeded, FALSE otherwise.
//
//--------------------------------------------------------------------------------

BOOL CProgressDlg::InitializeTabs(HWND hwnd)
{
    m_hwndTabs = GetDlgItem(hwnd, IDC_PROGRESS_TABS);
    TC_ITEM tci;
    TCHAR szRes[MAX_STRING_RES];

    if (!m_hwndTabs )
        return FALSE;

    // "Updates"
    tci.mask = TCIF_TEXT;
    LoadString(g_hInst, IDS_UPDATETAB, szRes, ARRAYSIZE(szRes));
    tci.pszText = szRes;
    TabCtrl_InsertItem(m_hwndTabs,PROGRESS_TAB_UPDATE, &tci);

    // "Results"
    LoadString(g_hInst, IDS_ERRORSTAB, szRes, ARRAYSIZE(szRes));
    tci.pszText = szRes;
        TabCtrl_InsertItem(m_hwndTabs, PROGRESS_TAB_ERRORS, &tci);

    //Set the tab to the Update page to begin with
    m_iTab = PROGRESS_TAB_UPDATE;

    if (-1 != TabCtrl_SetCurSel(m_hwndTabs, PROGRESS_TAB_UPDATE))
    {
        m_iTab = PROGRESS_TAB_UPDATE;
        ShowWindow(GetDlgItem(hwnd, IDC_LISTBOXERROR), SW_HIDE);
    }
    else //ToDo:  What do we do if the set tab fails?
    {
        m_iTab = -1;
        return FALSE;
    }

    return (TRUE);
}

//--------------------------------------------------------------------------------
//
//  FUNCTION:   CProgressDlg::InitializeUpdateList(HWND hwnd)
//
//  PURPOSE:    Initializes the update list view control on the progress dialog.
//
//  RETURN VALUE:
//      TRUE if everything succeeded, FALSE otherwise.
//
//--------------------------------------------------------------------------------

BOOL CProgressDlg::InitializeUpdateList(HWND hwnd)
{
    HWND hwndList = GetDlgItem(hwnd,IDC_UPDATE_LIST);
    HIMAGELIST hImageList;
    TCHAR pszProgressColumn[MAX_STRING_RES + 1];
    int iListViewWidth;

    if (hwndList)
    {
        m_pItemListView = new CListView(hwndList,hwnd,IDC_UPDATE_LIST,WM_BASEDLG_NOTIFYLISTVIEWEX);
    }

    if (!m_pItemListView)
    {
        return FALSE;
    }

    if (m_pItemListView)
    {
        UINT ImageListflags;

        ImageListflags = ILC_COLOR | ILC_MASK;
        if (IsHwndRightToLeft(hwnd))
        {
            ImageListflags |=  ILC_MIRROR;
        }

        // create an imagelist
        hImageList = ImageList_Create( GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), ImageListflags, 5, 20);
        if (hImageList)
        {
            m_pItemListView->SetImageList(hImageList, LVSIL_SMALL);
        }

        // for column widths go 35%, 20%, 45%
        iListViewWidth = CalcListViewWidth(hwndList,410);

        //set up the columns
        LoadString(g_hInst, IDS_PROGRESS_DLG_COLUMN_NAME, pszProgressColumn, MAX_STRING_RES);
        InsertListViewColumn(m_pItemListView,PROGRESSLIST_NAMECOLUMN,pszProgressColumn,
                                   LVCFMT_LEFT,(iListViewWidth*7)/20 /* cx */);


        LoadString(g_hInst, IDS_PROGRESS_DLG_COLUMN_STATUS, pszProgressColumn, MAX_STRING_RES);
        InsertListViewColumn(m_pItemListView,PROGRESSLIST_STATUSCOLUMN,pszProgressColumn,
                           LVCFMT_LEFT,(iListViewWidth/5) /* cx */);


        LoadString(g_hInst, IDS_PROGRESS_DLG_COLUMN_INFO, pszProgressColumn, MAX_STRING_RES);
        InsertListViewColumn(m_pItemListView,PROGRESSLIST_INFOCOLUMN,pszProgressColumn,
                           LVCFMT_LEFT,(iListViewWidth*9)/20 /* cx */);
    }

    return (TRUE);
}

//--------------------------------------------------------------------------------
//
//  FUNCTION:   CProgressDlg::InitializeResultsList(HWND hwnd)
//
//  PURPOSE:    Initializes the results list view control on the progress dialog.
//
//  RETURN VALUE:
//      TRUE if everything succeeded, FALSE otherwise.
//
//--------------------------------------------------------------------------------

BOOL CProgressDlg::InitializeResultsList(HWND hwnd)
{
    HWND hwndList = GetDlgItem(hwnd,IDC_LISTBOXERROR);
    LBDATA  *pData = NULL;
    ULONG cbData = 0;      // Allocated length of pData
    ULONG cchDataText = 0;  // Allocated length of pData->pszText
    TCHAR pszError[MAX_STRING_RES];
    UINT ImageListflags;

    LoadString(g_hInst, IDS_NOERRORSREPORTED, pszError, ARRAYSIZE(pszError));

    if (!hwndList)
        return FALSE;

    // Allocate a struct for the item data
    cchDataText = ARRAYSIZE(pszError);
    cbData = sizeof(LBDATA) + cchDataText * sizeof(TCHAR);

    pData = (LBDATA *) ALLOC(cbData);
    if (!pData)
    {
        return FALSE;
    }

    pData->fIsJump = FALSE;
    pData->fTextRectValid = FALSE;
    pData->fHasBeenClicked = FALSE;
    pData->fAddLineSpacingAtEnd = FALSE;
    pData->ErrorID = GUID_NULL;
    pData->dwErrorLevel = SYNCMGRLOGLEVEL_INFORMATION;
    pData->pHandlerID = 0;
    StringCchCopy(pData->pszText, cchDataText, pszError);

    // create the error image list based on the current System
    // metrics
    m_iIconMetricX =   GetSystemMetrics(SM_CXSMICON);
    m_iIconMetricY =   GetSystemMetrics(SM_CYSMICON);

    ImageListflags = ILC_COLOR | ILC_MASK;
    if (IsHwndRightToLeft(hwnd))
    {
         ImageListflags |=  ILC_MIRROR;
    }

    m_errorimage = ImageList_Create(m_iIconMetricX,m_iIconMetricY,ImageListflags, 0, MAX_ERR0R_ICONS);

    // load up the Error Images, if fail then just won't be an image next to the text
    if (m_errorimage)
    {
        m_ErrorImages[ErrorImage_Information] = ImageList_AddIcon(m_errorimage,LoadIcon(NULL,IDI_INFORMATION));
        m_ErrorImages[ErrorImage_Warning] = ImageList_AddIcon(m_errorimage,LoadIcon(NULL,IDI_WARNING));
        m_ErrorImages[ErrorImage_Error] = ImageList_AddIcon(m_errorimage,LoadIcon(NULL,IDI_ERROR));
    }
    else
    {
        m_ErrorImages[ErrorImage_Information] = m_ErrorImages[ErrorImage_Warning] =
             m_ErrorImages[ErrorImage_Error] = -1;
    }

    //Add a default Icon
    pData->IconIndex = m_ErrorImages[ErrorImage_Information];

    // Add the item data
    AddListData(pData, sizeof(pszError), hwndList);
    return TRUE;
}

void CProgressDlg::ReleaseDlg(WORD wCommandID)
{
    // put into dead state so know not
    // addref/release
    PostMessage(m_hwnd,WM_PROGRESS_RELEASEDLGCMD,wCommandID,0);
}

// notifies choice dialog when it is actually released.
void CProgressDlg::PrivReleaseDlg(WORD wCommandID)
{
    m_dwProgressFlags |=  PROGRESSFLAG_DEAD; // put us in the dead state.

    Assert(0 == m_dwQueueTransferCount); // shouldn't be going away if transfer is in progress!!

    RegSetProgressDetailsState(m_clsid,m_fPushpin, m_fExpanded);
    ShowWindow(m_hwnd,SW_HIDE);

    // if the tray is around hide it now.
    if (m_fHasShellTrayIcon)
    {
        RegisterShellTrayIcon(FALSE);
        m_fHasShellTrayIcon = FALSE;
    }

    switch (wCommandID)
    {
    case RELEASEDLGCMDID_OK: // on an okay sleep a little, then fall through to cancel.
    case RELEASEDLGCMDID_CANCEL:
        Assert(m_HndlrQueue);
        //
        // Fall through..
        //
    case RELEASEDLGCMDID_DESTROY: // called in Thread creation or initialize failed
    case RELEASEDLGCMDID_DEFAULT:
        if (m_HndlrQueue)
        {
            m_HndlrQueue->FreeAllHandlers();
            m_HndlrQueue->Release();
            m_HndlrQueue = NULL;
        }
        break;

    default:
        AssertSz(0,"Unknown Command");
        break;
    }

    Assert(m_hwnd);

    if (m_fHasShellTrayIcon)
    {
        RegisterShellTrayIcon(FALSE);
    }

    if (m_pSyncMgrIdle)
    {
        delete m_pSyncMgrIdle;
    }

    // if this is an idle progress then release our lock on the idle
    if (m_clsid == GUID_PROGRESSDLGIDLE)
    {
        ReleaseIdleLock();
    }

    if (m_pItemListView)
    {
        delete m_pItemListView;
        m_pItemListView = NULL;
    }

    if (m_hwnd)
        DestroyWindow(m_hwnd);

    delete this;

    return;
}

// updates window Z-Order and min/max state.
void CProgressDlg::UpdateWndPosition(int nCmdShow,BOOL fForce)
{
    BOOL fRemoveTrayIcon = FALSE;
    BOOL fWindowVisible = IsWindowVisible(m_hwnd);
    BOOL fTrayRequest = ((nCmdShow == SW_MINIMIZE)|| (nCmdShow == SW_SHOWMINIMIZED) || (nCmdShow == SW_HIDE));
    BOOL fHandledUpdate = FALSE;

    // only time we go to the tray is if the request is a minimize and
    // either the window is invisible or it is a force. note Hide for
    // now is treated as going to the tray.
    //
    // other cases or on tray failure we can just do a setforeground and show window.

    if (fTrayRequest && (fForce || !fWindowVisible))
    {
        if (m_fHasShellTrayIcon || RegisterShellTrayIcon(TRUE))
        {
            // if window was visible hide it and animiate
            if (fWindowVisible)
            {
                AnimateTray(TRUE);
                ShowWindow(m_hwnd,SW_HIDE);
            }

            fHandledUpdate = TRUE;
        }
    }

    if (!fHandledUpdate)
    {    
        // if haven't handled then make sure window is shown and bring to
        // front

        if (m_fHasShellTrayIcon)
        {
            AnimateTray(FALSE);
        }

        ShowWindow(m_hwnd,SW_SHOW);
        SetForegroundWindow(m_hwnd);

        // if currently have a tray then lets animate
        // fAnimate =  m_fHasShellTrayIcon ? TRUE : FALSE;

        // if the tray is around but we didn't register it this time through then it should
        // be removed

        if (m_fHasShellTrayIcon)
        {
            RegisterShellTrayIcon(FALSE);
        }
    }
}

//--------------------------------------------------------------------------------
//
//  Member: CProgressDlg::AnimateTray
//
//  PURPOSE:  does animation to the tray
//
//  COMMENTS: true means we are animating to the tray, false means back to the hwnd.
//
//
//--------------------------------------------------------------------------------

BOOL CProgressDlg::AnimateTray(BOOL fTrayAdded)
{
    BOOL fAnimate;
    HWND hwndTray,hWndST;
    RECT rcDlg;
    RECT rcST;

    fAnimate = FALSE;

    // get rectangles for animation
    if (hwndTray = FindWindow(c_szTrayWindow, NULL))
    {
        if (hWndST = FindWindowEx(hwndTray, NULL, c_szTrayNotifyWindow, NULL))
        {
            GetWindowRect(m_hwnd, &rcDlg);
            GetWindowRect(hWndST, &rcST);

            fAnimate = TRUE;
        }
    }

    if (fAnimate)
    {
        if (fTrayAdded)
        {
            DrawAnimatedRects(m_hwnd, IDANI_CAPTION,&rcDlg,&rcST);
        }
        else
        {
            DrawAnimatedRects(m_hwnd, IDANI_CAPTION,&rcST,&rcDlg);
        }
    }

    return fAnimate;
}

//--------------------------------------------------------------------------------
//
//  Member: CProgressDlg::RegisterShellTrayIcon
//
//  PURPOSE:  Registers/Unregisters the dialog in the Tray.
//
//      COMMENTS:  Up to Caller to do the proper thing with the main hwnd.
//
//
//--------------------------------------------------------------------------------

BOOL CProgressDlg::RegisterShellTrayIcon(BOOL fRegister)
{
    NOTIFYICONDATA icondata;

    if (fRegister)
    {
        BOOL fResult;

        m_fHasShellTrayIcon = TRUE;

        fResult = UpdateTrayIcon();

        if (!fResult) // if couldn't ad then say its not added.
        {
            m_fHasShellTrayIcon = FALSE;
        }

        return fResult;
   }
   else // remove ouselves from the tray.
   {
        Assert(TRUE == m_fHasShellTrayIcon);
        icondata.cbSize = sizeof(NOTIFYICONDATA);
        icondata.hWnd = m_hwnd;
        icondata.uID = 1;

        m_fHasShellTrayIcon = FALSE;
        m_fAddedIconToTray = FALSE;

        // ShellNotifyIcon Yields
        Shell_NotifyIcon(NIM_DELETE,&icondata);
   }

   return TRUE;
}

// called to Update the TrayIcon, Keeps track of highest warning state
// and sets the appropriate Icon in the tray. If the item is not already
// in the tray UpdateTrayIcon will not do a thing.

BOOL CProgressDlg::UpdateTrayIcon()
{
    NOTIFYICONDATA icondata;
    DWORD dwReturn = 0;

    if (m_fHasShellTrayIcon)
    {
        icondata.cbSize = sizeof(NOTIFYICONDATA);
        icondata.hWnd = m_hwnd;
        icondata.uID = 1;
        icondata.uFlags = NIF_ICON  | NIF_MESSAGE;
        icondata.uCallbackMessage = WM_PROGRESS_SHELLTRAYNOTIFICATION;

        // if progress animation is turned on then also animate
        // the tray.
        if (m_dwProgressFlags & PROGRESSFLAG_PROGRESSANIMATION)
        {
            // update the frame

            m_iTrayAniFrame++;

            if (m_iTrayAniFrame > IDI_SYSTRAYANI6)
                m_iTrayAniFrame = IDI_SYSTRAYANI1;

            icondata.hIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(m_iTrayAniFrame));
        }
        else
        {
            // update the Icon and tip text based on the current state .
            // Review - Currently don't have different Icons.

            if (m_iErrorCount > 0)
            {
                icondata.hIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_SYSTRAYERROR));
            }
            else if (m_iWarningCount > 0)
            {
                icondata.hIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_SYSTRAYWARNING));
            }
            else
            {
                icondata.hIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_SYSTRAYANI1));
            }
        }

        Assert(icondata.hIcon);

        TCHAR szBuf[MAX_STRING_RES];

        icondata.uFlags |= NIF_TIP;

        LoadString(g_hInst, IDS_SYNCMGRNAME, szBuf, ARRAYSIZE(szBuf));
        StringCchCopy(icondata.szTip, ARRAYSIZE(icondata.szTip), szBuf);

        dwReturn = Shell_NotifyIcon(m_fAddedIconToTray ? NIM_MODIFY : NIM_ADD ,&icondata);

        if (dwReturn)
        {
            // possible for Shell_NotifyIcon(NIM_DELETE) to come in while still
            // in shell notify call so only set m_fAddedIconTray to true
            // if still have a shell tray icon after the call.

            if (m_fHasShellTrayIcon)
            {
                m_fAddedIconToTray = TRUE;
            }

            return TRUE;
        }
        else
        {
            // possible this failed becuase a Shell_DeleteIcon was in progress
            // which yields check if really have a Shell Tray and if not
            // reset the AddedIcon Flag
            
            if (!m_fHasShellTrayIcon)
            {
                m_fAddedIconToTray = FALSE;
            }

            return FALSE;
        }
    }

    return FALSE;
}

// given an ID sets the appropriate state.
BOOL CProgressDlg::SetButtonState(int nIDDlgItem,BOOL fEnabled)
{
    BOOL fResult = FALSE;
    HWND hwndCtrl = GetDlgItem(m_hwnd,nIDDlgItem);
    HWND hwndFocus = NULL;

    if (hwndCtrl)
    {
        if (!fEnabled) // don't bother getting focus if not disabling.
        {
            hwndFocus = GetFocus();
        }

        fResult = EnableWindow(GetDlgItem(m_hwnd,nIDDlgItem),fEnabled);

        // if control had the focus. and now it doesn't then tab to the
        // next control
        if ( (hwndFocus == hwndCtrl) && !fEnabled)
        {
            SetFocus(GetDlgItem(m_hwnd,IDC_DETAILS));
        }

    }

    return fResult;
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgressDlg::InitializeHwnd, private
//
//  Synopsis:   Called by WM_INIT.
//              m_hwnd member is not setup yet so refer to hwnd.
//
//              Sets up items specific to the UI
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    30-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CProgressDlg::InitializeHwnd(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    HWND hwndList = GetDlgItem(hwnd,IDC_LISTBOXERROR);

    m_hwnd = hwnd; // setup the hwnd.

    m_fHwndRightToLeft = IsHwndRightToLeft(m_hwnd);

    // IF THE HWND IS RIGHT TO LEFT HIDE
    // SIZE CONTROL UNTIL RESIZE WORKS.

    if (m_fHwndRightToLeft)
    {
        ShowWindow(GetDlgItem(m_hwnd,IDC_PROGRESSRESIZESCROLLBAR),SW_HIDE);
    }
 
    InterlockedExchange(&m_lTimerSet, 0);

    if (m_fnResultsListBox =  (WNDPROC) GetWindowLongPtr(hwndList,GWLP_WNDPROC))
    {
        SetWindowLongPtr(hwndList, GWLP_WNDPROC, (LONG_PTR) ResultsListBoxWndProc);
    }

    m_cbNumDlgResizeItemsCollapsed = 0; // if fail then we don't resize anything.
    m_cbNumDlgResizeItemsExpanded = 0;

    // init resize items, be default nothing will move.
    m_ptMinimumDlgExpandedSize.x = 0;
    m_ptMinimumDlgExpandedSize.y = 0;
    m_cyCollapsed = 0;
    m_fExpanded = FALSE;

    m_fMaximized = FALSE;

    RECT rectParent;

    //Setup the toolbar pushpin
    InitializeToolbar(hwnd);

    if (GetClientRect(hwnd,&rectParent))
    {
        ULONG itemCount;
        DlgResizeList *pResizeList;

        // loop through resize list
        Assert(NUM_DLGRESIZEINFO_PROGRESS == (sizeof(g_ProgressResizeList)/sizeof(DlgResizeList)) );

        pResizeList = (DlgResizeList *) &g_ProgressResizeList;

        // loop through collapsed items
        for (itemCount = 0; itemCount < NUM_DLGRESIZEINFO_PROGRESS_COLLAPSED; ++itemCount)
        {
            if(InitResizeItem(pResizeList->iCtrlId,
                pResizeList->dwDlgResizeFlags,hwnd,&rectParent,&(m_dlgResizeInfo[m_cbNumDlgResizeItemsCollapsed])))
            {
                ++m_cbNumDlgResizeItemsCollapsed; // if fail then we don't resize anything.
                ++m_cbNumDlgResizeItemsExpanded;
            }

            ++pResizeList;
        }

        // loop through expanded items
        for (itemCount = NUM_DLGRESIZEINFO_PROGRESS_COLLAPSED;
                        itemCount < NUM_DLGRESIZEINFO_PROGRESS; ++itemCount)
        {
            if(InitResizeItem(pResizeList->iCtrlId,
                pResizeList->dwDlgResizeFlags,hwnd,&rectParent,&(m_dlgResizeInfo[m_cbNumDlgResizeItemsExpanded])))
            {
                ++m_cbNumDlgResizeItemsExpanded;
            }

            ++pResizeList;
        }
    }

    // store the current width and height as the
    // the min for expanded and as the current expanded height
    // if GetWindowRect fails not much we can do.
    if (GetWindowRect(hwnd,&m_rcDlg))
    {
        RECT rcSep;

        m_ptMinimumDlgExpandedSize.x = m_rcDlg.right - m_rcDlg.left;
        m_ptMinimumDlgExpandedSize.y = m_rcDlg.bottom - m_rcDlg.top;

        // use the separator position as the max height when collapsed
        if (GetWindowRect(GetDlgItem(hwnd, IDC_SP_SEPARATOR), &rcSep))
        {
            m_cyCollapsed = rcSep.top - m_rcDlg.top;
        }
    }

    if (InitializeTabs(hwnd)) // If these fail user just won't see probress..
    {
       InitializeUpdateList(hwnd);
       InitializeResultsList(hwnd);
    }

    Animate_Open(GetDlgItem(hwnd,IDC_UPDATEAVI),MAKEINTRESOURCE(IDA_UPDATE));

    return TRUE; // return true if want to use default focus.
}


//--------------------------------------------------------------------------------
//
//  FUNCTION:   CProgressDlg::OnPaint()
//
//  PURPOSE:    Handle the WM_PAINT message dispatched from the dialog
//
//--------------------------------------------------------------------------------
void CProgressDlg::OnPaint(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    // if not currently animating and
    // have already added things to the dialog then draw the icons
    if (!(m_dwProgressFlags & PROGRESSFLAG_PROGRESSANIMATION)
        && !(m_dwProgressFlags & PROGRESSFLAG_NEWDIALOG) )
    {
        PAINTSTRUCT     ps;
        HDC hDC = BeginPaint(m_hwnd, &ps);

        if (hDC)
        {
            HICON hIcon;

            if (m_iErrorCount > 0)
            {
                hIcon = LoadIcon(NULL,IDI_ERROR);
            }
            else if (m_iWarningCount > 0)
            {
                hIcon = LoadIcon(NULL,IDI_WARNING);
            }
            else
            {
                hIcon = LoadIcon(NULL,IDI_INFORMATION);
            }

            if (hIcon)
            {
                DrawIcon(hDC, 7, 10,hIcon);
            }

            EndPaint(m_hwnd, &ps);
        }
    }
}

//--------------------------------------------------------------------------------
//
//  FUNCTION:   CProgressDlg::RedrawIcon()
//
//  PURPOSE:    Clear/Draw the completed icon
//
//--------------------------------------------------------------------------------
BOOL CProgressDlg::RedrawIcon()
{
    RECT rc = {0, 0, 37, 40};

    InvalidateRect(m_hwnd, &rc, TRUE);

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressDlg::OnShowError, private
//
//  Synopsis:   Calls appropriate handlers ShowError method.
//
//  Arguments:  [wHandlerId] - Id of handler to call.
//              [hwndParent]- hwnd to use as the parent.
//              [ErrorId] - Identifies the Error.
//
//  Returns:    S_OK - If ShowError was called
//              S_FALSE - if already in ShowErrorCall
//              appropriate error codes.
//
//  Modifies:
//
//  History:    04-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CProgressDlg::OnShowError(HANDLERINFO *pHandlerId,HWND hwndParent,REFSYNCMGRERRORID ErrorID)
{
    HRESULT hr = S_FALSE; // if don't call ShowError should return S_FALSE

    // only allow one ShowError Call at a time.
    if (!(m_dwProgressFlags & PROGRESSFLAG_INSHOWERRORSCALL) && !(m_dwProgressFlags &  PROGRESSFLAG_DEAD))
    {
        Assert(!(m_dwProgressFlags &  PROGRESSFLAG_SHOWERRORSCALLBACKCALLED));
        m_dwProgressFlags |= PROGRESSFLAG_INSHOWERRORSCALL;

        // hold alive - stick two references so we can always just release
        // at end of ShowError and ShowErrorCompleted methods.

        m_dwShowErrorRefCount += 2;
        AddRefProgressDialog();
        AddRefProgressDialog();

        hr = m_HndlrQueue->ShowError(pHandlerId,hwndParent,ErrorID);

        m_dwProgressFlags &= ~PROGRESSFLAG_INSHOWERRORSCALL;

        // if callback with an hresult or retry came in while we were
        // in our out call then post the transfer

        if (m_dwProgressFlags & PROGRESSFLAG_SHOWERRORSCALLBACKCALLED)
        {
            m_dwProgressFlags &= ~PROGRESSFLAG_SHOWERRORSCALLBACKCALLED;
            // need to sendmessage so queued up before release.
            SendMessage(m_hwnd,WM_PROGRESS_TRANSFERQUEUEDATA,(WPARAM) 0, (LPARAM) NULL);
        }

        --m_dwShowErrorRefCount;

        // count can go negative if handler calls completion routine on an error. if
        // this is the case just set it to zero
        if ( ((LONG) m_dwShowErrorRefCount) < 0)
        {
            AssertSz(0,"Negative ErrorCount");
            m_dwShowErrorRefCount = 0;
        }
        else
        {
            ReleaseProgressDialog(m_fForceClose);
        }
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressDlg::OnResetKillHandlersTimers, private
//
//  Synopsis:   Called to reset the Kill Handlers
//              Timer. Called as a SendMessage From the handlrqueue
//              Cancel Call.
//              
//              !!!This funciton won't create the Timer if it doesn't
//              already exist by design since queue could be in a cancel
//              in a state we don't want to force kill as in the case
//              of an offIdle
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:
//
//  History:    19-Nov-1998       rogerg        Created.
//
//----------------------------------------------------------------------------

void CProgressDlg::OnResetKillHandlersTimers(void)
{
    if (m_lTimerSet && !(m_dwProgressFlags & PROGRESSFLAG_INTERMINATE))
    {
        // SetTimer with the same hwnd and Id will replace the existing.
        Assert(m_nKillHandlerTimeoutValue >= TIMERID_KILLHANDLERSMINTIME);

        SetTimer(m_hwnd,TIMERID_KILLHANDLERS,m_nKillHandlerTimeoutValue,NULL);
    }
}

//--------------------------------------------------------------------------------
//
//  FUNCTION:   CProgressDlg::OnCancel()
//
//  PURPOSE:  handles cancelling of the dialog
//
//--------------------------------------------------------------------------------

void CProgressDlg::OnCancel(BOOL fOffIdle)
{
    // if dialog isn't dead and not in a showerrorcall then
    // already in a cancel
    // addref/release. if no more refs we will go away.

    if (!fOffIdle)
    {
        // set cancelpressed flag if the user invoked the cancel.
        m_dwProgressFlags |= PROGRESSFLAG_CANCELPRESSED;

        if (!m_lTimerSet)
        {
            InterlockedExchange(&m_lTimerSet, 1);
            Assert(m_nKillHandlerTimeoutValue >= TIMERID_KILLHANDLERSMINTIME);

            SetTimer(m_hwnd,TIMERID_KILLHANDLERS,m_nKillHandlerTimeoutValue,NULL);
        }

        if ( (m_dwProgressFlags & PROGRESSFLAG_REGISTEREDFOROFFIDLE)
                && !(m_dwProgressFlags & PROGRESSFLAG_RECEIVEDOFFIDLE) )
        {
            IdleCallback(STATE_USER_IDLE_END); // make sure offidle gets set if user presses cancel
        }
    }

    if (!(m_dwProgressFlags & PROGRESSFLAG_DEAD) && !m_dwShowErrorRefCount
        && !(m_dwProgressFlags & PROGRESSFLAG_INCANCELCALL)
        && !(m_dwProgressFlags & PROGRESSFLAG_INTERMINATE))
    {
        // just cancel the queue, when items
        // come though cancel

        // it is possible that the dialog has already been removed from the
        // object list and the User hit stop again.

        SetProgressReleaseDlgCmdId(m_clsid,this,RELEASEDLGCMDID_CANCEL); // set so cleanup knows it was stopped by user..

        // if handlethread is in shutdown then just fall through

        if (!(m_dwProgressFlags & PROGRESSFLAG_SHUTTINGDOWNLOOP))
        {    
            AddRefProgressDialog(); // hold dialog alive until cancel is complete
            
            // Get the state of the stop button before the call
            // because it could transition to close during the Canel
            BOOL fForceShutdown = !(m_dwProgressFlags & PROGRESSFLAG_SYNCINGITEMS);
                        
            m_dwProgressFlags |= PROGRESSFLAG_INCANCELCALL;
            if (m_dwProgressFlags & PROGRESSFLAG_SYNCINGITEMS)
            {
                //
                // Replace the STOP button text with "Stopping" and 
                // disable the button.  This gives the user positive feedback
                // that the operation is being stopped.  We'll re-enable
                // the button whenever it's text is changed.
                //
                const HWND hwndStop = GetDlgItem(m_hwnd, IDSTOP);
                TCHAR szText[80];
                if (0 < LoadString(g_hInst, IDS_STOPPING, szText, ARRAYSIZE(szText)))
                {
                    SetWindowText(hwndStop, szText);
                }
                EnableWindow(hwndStop, FALSE);
            }
            m_HndlrQueue->Cancel();
            m_dwProgressFlags &= ~PROGRESSFLAG_INCANCELCALL;

            // addref/release lifetime in case locked open.

            // OffIdle case: then do a soft release so dialog doesn't
            // go away.
            
            // Non Idle case:  Set the fForceClose After the call 
            // incase the pushpin change or errors came in during the Cancel
            
            ReleaseProgressDialog(fOffIdle ? m_fForceClose : fForceShutdown );            
        }
        else
        {
            // set flag so shutdown knows a cancel was pressed
            m_dwProgressFlags |=  PROGRESSFLAG_CANCELWHILESHUTTINGDOWN;
        }
    }
}

//--------------------------------------------------------------------------------
//
//  FUNCTION:   CProgressDlg::OnCommand()
//
//  PURPOSE:    Handle the various command messages dispatched from the dialog
//
//--------------------------------------------------------------------------------
void CProgressDlg::OnCommand(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    WORD wID = LOWORD(wParam);  // item, control, or accelerator identifier
    WORD wNotifyCode HIWORD(wParam);

    switch (wID)
    {
    case IDC_SKIP_BUTTON_MAIN:
        {
            if (m_pItemListView)
            {
                if (m_iProgressSelectedItem != -1)
                {
                    //Skip this item:
                    if (!(m_dwProgressFlags &  PROGRESSFLAG_DEAD))
                    {
                        LVHANDLERITEMBLOB lvHandlerItemBlob;

                        lvHandlerItemBlob.cbSize = sizeof(LVHANDLERITEMBLOB);

                        if (m_pItemListView->GetItemBlob(m_iProgressSelectedItem,
                                        (LPLVBLOB) &lvHandlerItemBlob,lvHandlerItemBlob.cbSize))
                        {
                            ++m_dwSetItemStateRefCount;
                            AddRefProgressDialog();

                            m_HndlrQueue->SkipItem(lvHandlerItemBlob.clsidServer, lvHandlerItemBlob.ItemID);

                            --m_dwSetItemStateRefCount;
                            ReleaseProgressDialog(m_fForceClose);
                        }
                    }

                    //Disable the Skip button for this item
                    SetButtonState(IDC_SKIP_BUTTON_MAIN,FALSE);
                }
            }
        }
        break;

    case IDC_PROGRESS_OPTIONS_BUTTON_MAIN:
        {
            // !!! if skip has the focus set it to settings since while the
            // settings dialog is open the skip could go disabled.
            if (GetFocus() ==  GetDlgItem(m_hwnd,IDC_SKIP_BUTTON_MAIN))
            {
                SetFocus(GetDlgItem(m_hwnd,IDC_PROGRESS_OPTIONS_BUTTON_MAIN));
            }

            ShowOptionsDialog(m_hwnd);
        }
        break;

    case IDCANCEL:
        wNotifyCode = BN_CLICKED; // make sure notify code is clicked and fall through
        //
        // Fall through..
        //
    case IDSTOP:
        {
            if (BN_CLICKED == wNotifyCode)
            {
                OnCancel(FALSE);
            }
        }
        break;

    case IDC_PUSHPIN:
        {
            UINT state = (UINT)SendDlgItemMessage(m_hwnd, IDC_TOOLBAR, TB_GETSTATE, IDC_PUSHPIN, 0);

            m_fPushpin = state & TBSTATE_CHECKED;

            SendDlgItemMessage(m_hwnd, IDC_TOOLBAR, TB_CHANGEBITMAP,
                               IDC_PUSHPIN,
                               MAKELPARAM(m_fPushpin ? IMAGE_TACK_IN : IMAGE_TACK_OUT, 0));
        }
        break;

    case IDC_DETAILS:
        ExpandCollapse(!m_fExpanded, FALSE);
        break;

    default:
        break;
    }
}



//--------------------------------------------------------------------------------
//
//  FUNCTION:   CProgressDlg::ShowProgressTab(int iTab)
//
//  PURPOSE:
//
//--------------------------------------------------------------------------------

void CProgressDlg::ShowProgressTab(int iTab)
{
    int nCmdUpdateTab;
    int nCmdErrorTab;
    int nCmdSettingsButton;
    BOOL fIsItemWorking = FALSE;

    m_iTab = iTab;

    EnableWindow(GetDlgItem(m_hwnd, IDC_PROGRESS_TABS), m_fExpanded); // enable/disable tabs based on if dialog is expanded.
    EnableWindow(GetDlgItem(m_hwnd, IDC_TOOLBAR), m_fExpanded); // enable/disable  pushpin based on if dialog is expanded.

    nCmdUpdateTab = ((iTab == PROGRESS_TAB_UPDATE) && (m_fExpanded)) ? SW_SHOW: SW_HIDE;
    nCmdErrorTab = ((iTab == PROGRESS_TAB_ERRORS) && (m_fExpanded)) ? SW_SHOW: SW_HIDE;

    nCmdSettingsButton = ((iTab == PROGRESS_TAB_UPDATE) && (m_fExpanded) && m_fSensInstalled) ? SW_SHOW: SW_HIDE;

    switch (iTab)
    {
        case PROGRESS_TAB_UPDATE:
            // Hide the error listview, show the tasks list
            ShowWindow(GetDlgItem(m_hwnd,IDC_LISTBOXERROR), nCmdErrorTab);
            TabCtrl_SetCurSel(m_hwndTabs, iTab);

            EnableWindow(GetDlgItem(m_hwnd,IDC_UPDATE_LIST),m_fExpanded);

            // only enable the skip button if there is a selection
            // and IsItemWorking()
            if (-1 != m_iProgressSelectedItem)
            {
                fIsItemWorking = IsItemWorking(m_iProgressSelectedItem);
            }

            EnableWindow(GetDlgItem(m_hwnd,IDC_SKIP_BUTTON_MAIN),m_fExpanded && fIsItemWorking);
            EnableWindow(GetDlgItem(m_hwnd,IDC_PROGRESS_OPTIONS_BUTTON_MAIN),m_fExpanded && m_fSensInstalled);

            EnableWindow(GetDlgItem(m_hwnd,IDC_LISTBOXERROR), FALSE);

            ShowWindow(GetDlgItem(m_hwnd,IDC_STATIC_SKIP_TEXT),nCmdUpdateTab);
            ShowWindow(GetDlgItem(m_hwnd,IDC_SKIP_BUTTON_MAIN),nCmdUpdateTab);
            ShowWindow(GetDlgItem(m_hwnd,IDC_PROGRESS_OPTIONS_BUTTON_MAIN),nCmdSettingsButton);
            ShowWindow(GetDlgItem(m_hwnd,IDC_UPDATE_LIST),nCmdUpdateTab);

            break;

        case PROGRESS_TAB_ERRORS:
                // Hide the update listview, show the error list
            ShowWindow(GetDlgItem(m_hwnd,IDC_UPDATE_LIST),nCmdUpdateTab);
            ShowWindow(GetDlgItem(m_hwnd,IDC_STATIC_SKIP_TEXT),nCmdUpdateTab);
            ShowWindow(GetDlgItem(m_hwnd,IDC_SKIP_BUTTON_MAIN),nCmdUpdateTab);
            ShowWindow(GetDlgItem(m_hwnd,IDC_PROGRESS_OPTIONS_BUTTON_MAIN),nCmdSettingsButton);

            TabCtrl_SetCurSel(m_hwndTabs, iTab);

            EnableWindow(GetDlgItem(m_hwnd,IDC_UPDATE_LIST),FALSE);
            EnableWindow(GetDlgItem(m_hwnd,IDC_SKIP_BUTTON_MAIN),FALSE);
            EnableWindow(GetDlgItem(m_hwnd,IDC_PROGRESS_OPTIONS_BUTTON_MAIN),FALSE);
            EnableWindow(GetDlgItem(m_hwnd,IDC_LISTBOXERROR), m_fExpanded);

            ShowWindow(GetDlgItem(m_hwnd,IDC_LISTBOXERROR), nCmdErrorTab);
            break;

        default:
            AssertSz(0,"Unknown Tab");
            break;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgressDlg::IsItemWorking, private
//
//  Synopsis:  Determines if Skip should be enabled
//              for the listViewItem;
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    12-Aug-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CProgressDlg::IsItemWorking(int iListViewItem)
{
    BOOL fItemWorking;
    LPARAM ItemStatus;

    // lastest status is stored in the lParam of the ListBoxItem.
    if (!(m_pItemListView->GetItemlParam(iListViewItem,&ItemStatus)))
    {
        ItemStatus = SYNCMGRSTATUS_STOPPED;
    }

    fItemWorking = ( ItemStatus == SYNCMGRSTATUS_PENDING   ||
                                      ItemStatus == SYNCMGRSTATUS_UPDATING  ||
                                      ItemStatus == SYNCMGRSTATUS_PAUSED    ||
                                      ItemStatus == SYNCMGRSTATUS_RESUMING     );

    return fItemWorking;
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgressDlg::OnNotifyListViewEx, private
//
//  Synopsis:  Handles ListView Notifications
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

LRESULT CProgressDlg::OnNotifyListViewEx(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    int idCtrl = (int) wParam;
    LPNMHDR pnmhdr = (LPNMHDR) lParam;

    if ( (IDC_UPDATE_LIST != idCtrl) || (NULL == m_pItemListView))
    {
        Assert(IDC_UPDATE_LIST == idCtrl);
        Assert(m_pItemListView);
        return 0;
    }

    switch (pnmhdr->code)
    {
        case LVN_ITEMCHANGED:
        {
            NM_LISTVIEW *pnmv = (NM_LISTVIEW FAR *) pnmhdr;

            if (pnmv->uChanged == LVIF_STATE)
            {
                if (pnmv->uNewState & LVIS_SELECTED)
                {
                    m_iProgressSelectedItem = ((LPNMLISTVIEW) pnmhdr)->iItem;


                    // see if an item is selected and set the properties
                    // button accordingly
                    SetButtonState(IDC_SKIP_BUTTON_MAIN,IsItemWorking(m_iProgressSelectedItem));
                }
                else if (pnmv->uOldState & LVIS_SELECTED)
                {
                    // on deselect see if any other selected items and if not
                    // set skip to false.
                    if (0 == m_pItemListView->GetSelectedCount())
                    {
                        m_iProgressSelectedItem = -1;
                        SetButtonState(IDC_SKIP_BUTTON_MAIN,FALSE);
                    }
                }
            }

            break;
        }
        default:
            break;
    }

    return 0;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION:   CProgressDlg::OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr)
//
//  PURPOSE:    Handle the various notification messages dispatched from the dialog
//
//--------------------------------------------------------------------------------

LRESULT CProgressDlg::OnNotify(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    int idFrom = (int) wParam;
    LPNMHDR pnmhdr = (LPNMHDR) lParam;

    // if notification for UpdateListPass it on.
    if ((IDC_UPDATE_LIST == idFrom) && m_pItemListView)
    {
        return m_pItemListView->OnNotify(pnmhdr);
    }
    else if (IDC_TOOLBAR == idFrom)
    {
        if (pnmhdr->code == NM_KEYDOWN)
        {
            if (((LPNMKEY) lParam)->nVKey == TEXT(' ') )
            {
                UINT state = (UINT)SendDlgItemMessage(m_hwnd, IDC_TOOLBAR, TB_GETSTATE, IDC_PUSHPIN, 0);

                state = state^TBSTATE_CHECKED;

                SendDlgItemMessage(m_hwnd, IDC_TOOLBAR, TB_SETSTATE, IDC_PUSHPIN, state);

                m_fPushpin = state & TBSTATE_CHECKED;
            
                SendDlgItemMessage(m_hwnd, IDC_TOOLBAR, TB_CHANGEBITMAP, IDC_PUSHPIN, 
                                   MAKELPARAM(m_fPushpin ? IMAGE_TACK_IN : IMAGE_TACK_OUT, 0));
            }            
        }
    }
    else if (IDC_PROGRESS_TABS == idFrom)
    {
        switch (pnmhdr->code)
        {
            case TCN_SELCHANGE:
            {
                // Find out which tab is currently active
                m_iTab = TabCtrl_GetCurSel(GetDlgItem(m_hwnd, IDC_PROGRESS_TABS));
                if (-1 == m_iTab)
                {
                   break;
                }

                ShowProgressTab(m_iTab);
                break;
            }
            default:
                 break;
        }
    }

    return 0;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION:   CProgressDlg::UpdateProgressValues()
//
//  PURPOSE:    Updates the value of the ProgressBar
//
//--------------------------------------------------------------------------------

void CProgressDlg::UpdateProgressValues()
{
    int iProgValue;
    int iMaxValue;
    int iNumItemsComplete;
    int iNumItemsTotal;
    TCHAR pszComplete[MAX_STRING_RES];

    if (!m_pItemListView || !m_HndlrQueue)
    {
        return;
    }

    LoadString(g_hInst, IDS_NUM_ITEMS_COMPLETE, pszComplete, ARRAYSIZE(pszComplete));

    if (S_OK ==  m_HndlrQueue->GetProgressInfo(&iProgValue, &iMaxValue, &iNumItemsComplete, &iNumItemsTotal) )
    {
        HWND hwndProgress = GetDlgItem(m_hwnd,IDC_PROGRESSBAR);
        TCHAR szHowManBuf[50];

        if (hwndProgress)
        {
            SendMessage(hwndProgress,PBM_SETRANGE,0,MAKELPARAM(0, iMaxValue));
            SendMessage(hwndProgress,PBM_SETPOS,(WPARAM) iProgValue,0);
        }

        StringCchPrintf(szHowManBuf, ARRAYSIZE(szHowManBuf), pszComplete, iNumItemsComplete, iNumItemsTotal);
        Static_SetText(GetDlgItem(m_hwnd,IDC_STATIC_HOW_MANY_COMPLETE), szHowManBuf);
    }
}

//--------------------------------------------------------------------------------
//
//  FUNCTION:   CProgressDlg::UpdateDetailsInfo(DWORD dwStatusType, HWND hwndList,
//                                                          int iItem, TCHAR *pszItemInfo)
//
//  PURPOSE:    provide info in the non-details progress view.
//
//--------------------------------------------------------------------------------
void CProgressDlg::UpdateDetailsInfo(DWORD dwStatusType,int iItem, TCHAR *pszItemInfo)
{
    BOOL fNewNameField = TRUE;
    BOOL fInfoField = FALSE;

    TCHAR pszItemName[MAX_SYNCMGRITEMNAME + 1];
    TCHAR pszFormatString[MAX_PATH + 1];
    TCHAR pszNameString[MAX_PATH + 1];

    if ((m_dwLastStatusType == dwStatusType) && (m_iLastItem == iItem))
    {
        fNewNameField = FALSE;
    }

    //Strip the item info of white space
    if (pszItemInfo)
    {
        int i = lstrlen(pszItemInfo) - 1;

        while (i >=0 &&
                  (pszItemInfo[i] == TEXT(' ') || pszItemInfo[i] == TEXT('\n')
                            || pszItemInfo[i] == TEXT('\t')))
        {
                pszItemInfo[i] = NULL;
                i--;
        }
        if (i >= 0)
        {
                fInfoField = TRUE;
        }
    }


    // If Called Callback for an Item in Pending mode
    // but no item text don't bother updating the top display.

    if ((SYNCMGRSTATUS_PENDING == dwStatusType) && (FALSE == fInfoField))
    {
        return;
    }

    m_dwLastStatusType = dwStatusType;
    m_iLastItem = iItem;

    if (fNewNameField && m_pItemListView)
    {
        //Get the item name
        *pszItemName = NULL;

        m_pItemListView->GetItemText(iItem, PROGRESSLIST_NAMECOLUMN, pszItemName, MAX_SYNCMGRITEMNAME);

        switch (dwStatusType)
        {
            case SYNCMGRSTATUS_STOPPED:
                {
                    LoadString(g_hInst, IDS_STOPPED_ITEM, pszFormatString, ARRAYSIZE(pszFormatString));
                }
                break;

            case SYNCMGRSTATUS_SKIPPED:
                {
                    LoadString(g_hInst, IDS_SKIPPED_ITEM, pszFormatString, ARRAYSIZE(pszFormatString));
                }
                break;

            case SYNCMGRSTATUS_PENDING:
                {
                    LoadString(g_hInst, IDS_PENDING_ITEM, pszFormatString, ARRAYSIZE(pszFormatString));
                }
                break;

            case SYNCMGRSTATUS_UPDATING:
                {
                    LoadString(g_hInst, IDS_SYNCHRONIZING_ITEM,pszFormatString, ARRAYSIZE(pszFormatString));
                }
                break;

            case SYNCMGRSTATUS_SUCCEEDED:
                {
                    LoadString(g_hInst, IDS_SUCCEEDED_ITEM,pszFormatString, ARRAYSIZE(pszFormatString));
                }
                break;

            case SYNCMGRSTATUS_FAILED:
                {
                    LoadString(g_hInst, IDS_FAILED_ITEM,pszFormatString, ARRAYSIZE(pszFormatString));
                }
                break;

            case SYNCMGRSTATUS_PAUSED:
                {
                    LoadString(g_hInst, IDS_PAUSED_ITEM,pszFormatString, ARRAYSIZE(pszFormatString));
                }
                break;

            case SYNCMGRSTATUS_RESUMING:
                {
                    LoadString(g_hInst, IDS_RESUMING_ITEM,pszFormatString, ARRAYSIZE(pszFormatString));
                }
                break;

            default:
                {
                    AssertSz(0,"Unknown Status Type");
                    StringCchCopy(pszFormatString, ARRAYSIZE(pszFormatString), TEXT("%ws"));
                }
                break;
        }

        StringCchPrintf(pszNameString, ARRAYSIZE(pszNameString), pszFormatString, pszItemName);
        Static_SetText(GetDlgItem(m_hwnd,IDC_STATIC_WHATS_UPDATING), pszNameString);
    }

    // if don't have an info field but did update the name then set the info field
    // to blank
    if (fInfoField)
    {
        Static_SetText(GetDlgItem(m_hwnd,IDC_STATIC_WHATS_UPDATING_INFO), pszItemInfo);
    }
    else if (fNewNameField)
    {
        Static_SetText(GetDlgItem(m_hwnd,IDC_STATIC_WHATS_UPDATING_INFO), L"");
    }
}

//--------------------------------------------------------------------------------
//
//  FUNCTION:   CProgressDlg::HandleProgressUpdate(HWND hwnd, WPARAM wParam,LPARAM lParam)
//
//  PURPOSE:    Handle the progress bar update for the progress dialog
//
//--------------------------------------------------------------------------------
void CProgressDlg::HandleProgressUpdate(HWND hwnd, WPARAM wParam,LPARAM lParam)
{
    PROGRESSUPDATEDATA *progressData = (PROGRESSUPDATEDATA *) wParam;
    SYNCMGRPROGRESSITEM *lpSyncProgressItem = (SYNCMGRPROGRESSITEM *) lParam;
    LVHANDLERITEMBLOB lvHandlerItemBlob;
    int iItem = -1;
    BOOL fProgressItemChanged = FALSE;

    if (!m_pItemListView)
    {
        return;
    }

    // if emptyItem is in list View delete it.
    lvHandlerItemBlob.cbSize = sizeof(LVHANDLERITEMBLOB);
    lvHandlerItemBlob.clsidServer = (progressData->clsidHandler);
    lvHandlerItemBlob.ItemID = (progressData->ItemID);

    iItem = m_pItemListView->FindItemFromBlob((LPLVBLOB) &lvHandlerItemBlob);

    if (-1 == iItem)
    {
        AssertSz(0,"Progress Update on Item not in ListView");
        return;
    }

    if (SYNCMGRPROGRESSITEM_STATUSTYPE & lpSyncProgressItem->mask)
    {
        if (lpSyncProgressItem->dwStatusType <= SYNCMGRSTATUS_RESUMING) 
        {
            // update the listview items lParam
            m_pItemListView->SetItemlParam(iItem,lpSyncProgressItem->dwStatusType);

            m_pItemListView->SetItemText(iItem,PROGRESSLIST_STATUSCOLUMN,
                                         m_pszStatusText[lpSyncProgressItem->dwStatusType]);

            //Update Skip button if this item is selected
            if (m_iProgressSelectedItem == iItem)
            {
                BOOL fItemComplete = ( (lpSyncProgressItem->dwStatusType == SYNCMGRSTATUS_SUCCEEDED) ||
                                                       (lpSyncProgressItem->dwStatusType == SYNCMGRSTATUS_FAILED) ||
                                                       (lpSyncProgressItem->dwStatusType == SYNCMGRSTATUS_SKIPPED) ||
                                                       (lpSyncProgressItem->dwStatusType == SYNCMGRSTATUS_STOPPED)   );

                EnableWindow(GetDlgItem(m_hwnd,IDC_SKIP_BUTTON_MAIN),!fItemComplete);
            }
        }
    }

    if (SYNCMGRPROGRESSITEM_STATUSTEXT & lpSyncProgressItem->mask )
    {
#define MAXDISPLAYBUF 256
        TCHAR displaybuf[MAXDISPLAYBUF]; // make a local copy of ths display buf

        *displaybuf = NULL;

        if (lpSyncProgressItem->lpcStatusText)
        {
           StringCchCopy(displaybuf, ARRAYSIZE(displaybuf), lpSyncProgressItem->lpcStatusText);

            TCHAR *pEndBuf = displaybuf + MAXDISPLAYBUF -1;
            *pEndBuf = NULL;
        }

        m_pItemListView->SetItemText(iItem,PROGRESSLIST_INFOCOLUMN,displaybuf);

        LPARAM ItemStatus;
        if (!(SYNCMGRPROGRESSITEM_STATUSTYPE & lpSyncProgressItem->mask))
        {
            if (!(m_pItemListView->GetItemlParam(iItem,&ItemStatus)))
            {
                AssertSz(0,"failed to get item lParam");
                ItemStatus = SYNCMGRSTATUS_STOPPED;
            }
        }
        else
        {
            ItemStatus = lpSyncProgressItem->dwStatusType;
        }

        Assert(ItemStatus == ((LPARAM) (DWORD) ItemStatus));

        UpdateDetailsInfo( (DWORD) ItemStatus,iItem, displaybuf);
    }


    // now update the items progress value information
    if (S_OK == m_HndlrQueue->SetItemProgressInfo( progressData->pHandlerID,
                                                        progressData->wItemId,
                                                        lpSyncProgressItem, 
                                                        &fProgressItemChanged))
    {

        // recalcing the progress bar and numItems completed values 
        // can become expensive with a large amount of items so it callback
        // was called but didn't change status or min/max of the item
        // don't bother updating the progress values.
        if (fProgressItemChanged)
        {
            UpdateProgressValues();
        }
    }
}


//--------------------------------------------------------------------------------
//
//  FUNCTION:   CProgressDlg::AddListData(LBDATA *pData,int iNumChars, HWND hwndList)
//
//  PURPOSE:    Handle the adding item data to the list for the results pane
//
//--------------------------------------------------------------------------------
void CProgressDlg::AddListData(LBDATA *pData, int iNumChars, HWND hwndList)
{
    // Save current item in global for use by MeasureItem handler

    Assert(NULL == m_CurrentListEntry); // catch any recursion case.

    m_CurrentListEntry = pData;
    // ... add the string first...
    //the text is freed by the list box

    int iItem = ListBox_AddString( hwndList, pData->pszText);
    
    // (Note that the WM_MEASUREITEM is sent at this point)
    // ...now attach the data.

    ListBox_SetItemData( hwndList, iItem, pData);

    m_CurrentListEntry = NULL;

    // pData is freed by the list box
}

//--------------------------------------------------------------------------------
//
//  FUNCTION:   CProgressDlg::HandleLogError(HWND hwnd, WORD pHandlerID,MSGLogErrors *msgLogErrors)
//
//  PURPOSE:    Handle the error logging tab for the progress dialog
//
//--------------------------------------------------------------------------------
void CProgressDlg::HandleLogError(HWND hwnd, HANDLERINFO *pHandlerID,MSGLogErrors *lpmsgLogErrors)
{
    LBDATA          *pData = NULL;
    INT             iNumChars;
    TCHAR           szBuffer[MAX_STRING_RES]; // buffer used for loading string resources
    HWND            hwndList;

    hwndList = GetDlgItem(m_hwnd,IDC_LISTBOXERROR);
    if (!hwndList)
    {
        return;
    }

    //Remove the "No Errors" when the first error is encountered
    if (++m_iResultCount == 0)
    {
        ListBox_ResetContent(hwndList);
    }

    // determine if handlerId and ItemId are valid.ItemID
    // if handlerId isn't valid we don't bother with the ItemId

    SYNCMGRHANDLERINFO SyncMgrHandlerInfo;
    SYNCMGRITEM offlineItem;
    DWORD cchItemLen = 0;
    DWORD cchHandlerLen = 0;
    UINT uIDResource;

    // preset both to NULL
    *(SyncMgrHandlerInfo.wszHandlerName) = NULL;
    *(offlineItem.wszItemName) = NULL;

    // if can't get the ParentInfo then don't add the Item
    // pHandlerId can be NULL if we logged the Error Ourselves.
    if (pHandlerID && m_HndlrQueue
        && (S_OK == m_HndlrQueue->GetHandlerInfo(pHandlerID,&SyncMgrHandlerInfo)))
    {
        cchHandlerLen = lstrlen(SyncMgrHandlerInfo.wszHandlerName);

        // now see if we can get the itemName.
        if (lpmsgLogErrors->mask & SYNCMGRLOGERROR_ITEMID)
        {
            BOOL fHiddenItem;
            CLSID clsidDataHandler;

            if (S_OK == m_HndlrQueue->GetItemDataAtIndex(pHandlerID, lpmsgLogErrors->ItemID,
				                                        &clsidDataHandler,&offlineItem,&fHiddenItem) )
            {
                cchItemLen = lstrlen(offlineItem.wszItemName);
            }
        }
    }

    // note: handlerName can be an empty string even if GetHandlerInfo did not fail and we
    // can still have an Item so need to do the right thing.

    //  cases
    //  valid handler and ItemID in LogError
    // 1) <icon> <handler name> <(item name)>: <message> (valid handler and ItemID in LogError)
    // 2) <icon> <(item name)>: <message>  handler name NULL .
    // 3) <icon> <handler name>: <message> only valid handler in LogError
    // 4) <icon> <message> (handler invalid or mobsync error in LogError)
    // => three different format strings
    //  1,2     - "%ws (%ws): %ws"    // valid item
    //  3       - "%ws: %ws"          // only valid handler.
    //  4       - "%ws"               // no handler or item

    if (cchItemLen)
    {
        uIDResource = IDS_LOGERRORWITHITEMID;
    }
    else if (cchHandlerLen)
    {
        uIDResource = IDS_LOGERRORNOITEMID;
    }
    else
    {
        uIDResource = IDS_LOGERRORNOHANDLER;
    }

    if (0 == LoadString(g_hInst, uIDResource, szBuffer, ARRAYSIZE(szBuffer)))
    {
        // if couldn't loadstring then set to empty string so an empty string
        // gets logged. If string is truncated will just print the trucated string.
        *szBuffer = NULL;
    }
    // get the number of characters we need to allocate for
    iNumChars = lstrlen(lpmsgLogErrors->lpcErrorText)
                    + cchHandlerLen
                    + cchItemLen
                    + lstrlen(szBuffer); 

    // Allocate a struct for the item data
    if ( !(pData = (LBDATA *) ALLOC(sizeof(LBDATA) + ( (iNumChars+1) *sizeof(TCHAR)))) )
    {
        return;
    }

    // now format the string using the same logic as used to load
    // the proper resource
    if (cchItemLen)
    {
        StringCchPrintf(pData->pszText, iNumChars+1, szBuffer, SyncMgrHandlerInfo.wszHandlerName,
                                offlineItem.wszItemName, lpmsgLogErrors->lpcErrorText);
    }
    else if (cchHandlerLen)
    {
        StringCchPrintf(pData->pszText, iNumChars+1, szBuffer, SyncMgrHandlerInfo.wszHandlerName,
                                lpmsgLogErrors->lpcErrorText);
    }
    else
    {
        StringCchPrintf(pData->pszText, iNumChars+1, szBuffer, lpmsgLogErrors->lpcErrorText);
    }

    // error text is not a jump but has same ErrorID
    pData->fIsJump = FALSE;
    pData->fTextRectValid = FALSE;
    pData->ErrorID = lpmsgLogErrors->ErrorID;
    pData->dwErrorLevel = lpmsgLogErrors->dwErrorLevel;
    pData->pHandlerID = pHandlerID;
    pData->fHasBeenClicked = FALSE;
    pData->fAddLineSpacingAtEnd = FALSE;

    // insert the icon
    // ToDo: Add client customizable icons?
    switch (lpmsgLogErrors->dwErrorLevel)
    {
        case SYNCMGRLOGLEVEL_INFORMATION:
            pData->IconIndex = m_ErrorImages[ErrorImage_Information];
            break;

        case SYNCMGRLOGLEVEL_WARNING:
            ++m_iWarningCount;
            pData->IconIndex = m_ErrorImages[ErrorImage_Warning];
            break;

        case SYNCMGRLOGLEVEL_ERROR:
        default:
            // if an error occurs we want to keep the dialog alive
            ++m_iErrorCount;
            pData->IconIndex = m_ErrorImages[ErrorImage_Error];
            break;
    }

    if (!lpmsgLogErrors->fHasErrorJumps)
    {
         pData->fAddLineSpacingAtEnd = TRUE;
    }

    // Add the item data
    AddListData(pData, (iNumChars)*sizeof(TCHAR), hwndList);
    if (lpmsgLogErrors->fHasErrorJumps)
    {
        //This is make the "For more info" apprear closer,
        //More associated with the item it corresponds to

        // Allocate a struct for the item data
        LoadString(g_hInst, IDS_JUMPTEXT, szBuffer, ARRAYSIZE(szBuffer));

        // Review, why not strlen instead of total size of szBuffer.
        iNumChars = ARRAYSIZE(szBuffer);
        pData = (LBDATA *) ALLOC(sizeof(LBDATA) + iNumChars * sizeof(TCHAR));
        if (!pData)
        {
            return;
        }

        pData->IconIndex = -1;

        // we always set ErrorID to GUID_NULL if one wasn't given
        // and fHasErrorJumps to false.
        pData->fIsJump = lpmsgLogErrors->fHasErrorJumps;
        pData->fTextRectValid = FALSE;
        pData->ErrorID = lpmsgLogErrors->ErrorID;
        pData->dwErrorLevel = lpmsgLogErrors->dwErrorLevel;
        pData->pHandlerID = pHandlerID;
        pData->fHasBeenClicked = FALSE;
        pData->fAddLineSpacingAtEnd = TRUE; // always put space after

        StringCchCopy(pData->pszText, iNumChars, szBuffer);

        AddListData(pData, sizeof(szBuffer), hwndList);
    }

    // new item could have caused the Scrollbar to be drawn. Need to
    // recalc listbox
    OnProgressResultsSize(m_hwnd,this,WM_SIZE,0,0);

    // if tray icon is shown and not currently syncing any items
    // make sure it has the most up to date info. if syncing just
    // let the timer.

    if (!(m_dwProgressFlags & PROGRESSFLAG_SYNCINGITEMS))
    {
        UpdateTrayIcon();
    }

    return;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION:   CProgressDlg::HandleDeleteLogError(HWND hwnds)
//
//  PURPOSE:    Deletes matching errors that have been logged.
//
//--------------------------------------------------------------------------------

void  CProgressDlg::HandleDeleteLogError(HWND hwnd,MSGDeleteLogErrors *pDeleteLogError)
{
    HWND hwndList = GetDlgItem(m_hwnd,IDC_LISTBOXERROR);
    int  iItemCount;
    LBDATA  *pData = NULL;

    if (NULL == hwndList)
        return;

    iItemCount  = ListBox_GetCount(hwndList);

    // loop through the logged errors finding any matches.
    // if the passed in ErrorID is GUID_NULL then delete all errors associated with this
    // handler.
    while(iItemCount--)
    {
        if (pData = (LBDATA *) ListBox_GetItemData(hwndList,iItemCount))
        {
            if ((pData->pHandlerID == pDeleteLogError->pHandlerId)
                && ( (pData->ErrorID == pDeleteLogError->ErrorID)
                    || (GUID_NULL == pDeleteLogError->ErrorID) )
                )
            {
                if ( !pData->fIsJump )
                {
                    //
                    // Decrement count for non-jump items only to avoid
                    // double decrements.
                    //

                    m_iResultCount--;

                    if ( pData->dwErrorLevel == SYNCMGRLOGLEVEL_WARNING )
                    {
                        Assert( m_iWarningCount > 0 );
                        m_iWarningCount--;
                    }
                    else if ( pData->dwErrorLevel == SYNCMGRLOGLEVEL_ERROR )
                    {
                        Assert( m_iErrorCount > 0 );
                        m_iErrorCount--;
                    }
                }

                ListBox_DeleteString(hwndList,iItemCount);
            }
        }
    }

    //
    // If all items have been removed, add default no-error item
    //
    iItemCount = ListBox_GetCount(hwndList);

    if ( iItemCount == 0 )
    {
        m_iResultCount = -1;

        TCHAR pszError[MAX_STRING_RES];
        LoadString(g_hInst, IDS_NOERRORSREPORTED, pszError, ARRAYSIZE(pszError));

        //
        // Allocate a struct for the item data
        //
        DWORD cchDataText = 0;

        cchDataText = ARRAYSIZE(pszError);
        pData = (LBDATA *) ALLOC(sizeof(LBDATA) + ARRAYSIZE(pszError)*sizeof(TCHAR));
        if (!pData)
            return;

        pData->fIsJump = FALSE;
        pData->fTextRectValid = FALSE;
        pData->fHasBeenClicked = FALSE;
        pData->fAddLineSpacingAtEnd = FALSE;
        pData->ErrorID = GUID_NULL;
        pData->dwErrorLevel = SYNCMGRLOGLEVEL_INFORMATION;
        pData->pHandlerID = 0;
        StringCchCopy(pData->pszText, cchDataText, pszError);
        pData->IconIndex = m_ErrorImages[ErrorImage_Information];

        AddListData(pData, sizeof(pszError), hwndList);
    }

    // recalc listbox heights to accomodate the new value.
    OnProgressResultsSize(m_hwnd,this,WM_SIZE,0,0);

    // if tray icon is shown and not currently syncing any items
    // make sure it has the most up to date info. if syncing just
    // let the timer.

    if (!(m_dwProgressFlags & PROGRESSFLAG_SYNCINGITEMS))
        UpdateTrayIcon();
}


//--------------------------------------------------------------------------------
//
//  FUNCTION:   BOOL CProgressDlg::ShowCompletedProgress(BOOL fComplete)
//
//  PURPOSE:   Show the dialog in the completed state
//
//--------------------------------------------------------------------------------
BOOL CProgressDlg::ShowCompletedProgress(BOOL fComplete,BOOL fDialogIsLocked)
{
    TCHAR szBuf[MAX_STRING_RES];

    LoadString( g_hInst, 
                fComplete? IDS_PROGRESSCOMPLETETITLE : IDS_PROGRESSWORKINGTITLE,
                szBuf,
                ARRAYSIZE(szBuf));

    SetWindowText(m_hwnd, szBuf);

    if (fComplete)
    {
        ShowWindow(GetDlgItem(m_hwnd,IDC_UPDATEAVI), SW_HIDE);
        ShowWindow(GetDlgItem(m_hwnd,IDC_FOLDER1), SW_HIDE);
        ShowWindow(GetDlgItem(m_hwnd,IDC_FOLDER2), SW_HIDE);
        ShowWindow(GetDlgItem(m_hwnd,IDC_STATIC_WHATS_UPDATING), SW_HIDE);
        ShowWindow(GetDlgItem(m_hwnd,IDC_STATIC_WHATS_UPDATING_INFO), SW_HIDE);
        ShowWindow(GetDlgItem(m_hwnd,IDC_PROGRESSBAR), SW_HIDE);
        ShowWindow(GetDlgItem(m_hwnd,IDC_STATIC_HOW_MANY_COMPLETE), SW_HIDE);

        if (m_iErrorCount > 0 )
        {
            LoadString(g_hInst, IDS_PROGRESSCOMPLETEERROR, szBuf, ARRAYSIZE(szBuf));
        }
        else if (m_iWarningCount > 0 )
        {
            LoadString(g_hInst, IDS_PROGRESSCOMPLETEWARNING, szBuf, ARRAYSIZE(szBuf));
        }
        else
        {
            LoadString(g_hInst, IDS_PROGRESSCOMPLETEOK, szBuf, ARRAYSIZE(szBuf));
        }

        SetDlgItemText(m_hwnd, IDC_RESULTTEXT, szBuf);
		ShowWindow(GetDlgItem(m_hwnd,IDC_RESULTTEXT), SW_SHOW);

		//Change the Stop to "Close" if the dialog is going to be remained open

        if (fDialogIsLocked)
        {
		    LoadString(g_hInst, IDS_CLOSE, szBuf, ARRAYSIZE(szBuf));
		    SetWindowText(GetDlgItem(m_hwnd,IDSTOP), szBuf);      
            EnableWindow(GetDlgItem(m_hwnd,IDSTOP), TRUE);
        }
    }
    else
    {
        ShowWindow(GetDlgItem(m_hwnd,IDC_RESULTTEXT), SW_HIDE);

        ShowWindow(GetDlgItem(m_hwnd,IDC_UPDATEAVI), SW_SHOW);
        ShowWindow(GetDlgItem(m_hwnd,IDC_FOLDER1), SW_SHOW);
        ShowWindow(GetDlgItem(m_hwnd,IDC_FOLDER2), SW_SHOW);
        ShowWindow(GetDlgItem(m_hwnd,IDC_STATIC_WHATS_UPDATING), SW_SHOW);
        ShowWindow(GetDlgItem(m_hwnd,IDC_STATIC_WHATS_UPDATING_INFO), SW_SHOW);
        ShowWindow(GetDlgItem(m_hwnd,IDC_PROGRESSBAR), SW_SHOW);
        ShowWindow(GetDlgItem(m_hwnd,IDC_STATIC_HOW_MANY_COMPLETE), SW_SHOW);

        //Change the "Close" to "Stop"
		LoadString(g_hInst, IDS_STOP, szBuf, ARRAYSIZE(szBuf));
		SetWindowText(GetDlgItem(m_hwnd,IDSTOP), szBuf);
        EnableWindow(GetDlgItem(m_hwnd,IDSTOP), TRUE);
    }

    RedrawIcon();

    return TRUE;
}

//--------------------------------------------------------------------------------
//
//  Function:   DoSyncTask
//
//  Synopsis:   Drives the handlers actual synchronization routines
//
//--------------------------------------------------------------------------------

void CProgressDlg::DoSyncTask(HWND hwnd)
{
    HANDLERINFO *pHandlerID;
    ULONG cDlgRefs;
    BOOL fRepostedStart = FALSE; // set if posted message to ourselves.
    CLSID pHandlerClsid;

    Assert(!(m_dwProgressFlags &  PROGRESSFLAG_DEAD));

    ++m_dwHandleThreadNestcount;

    // if handlerNestCount is > 1 which it can on a transfer
    // or when multiple items are going even on an error
    // if this is the case then just return
    if (m_dwHandleThreadNestcount > 1)
    {
        Assert(1 == m_dwHandleThreadNestcount);
        m_dwHandleThreadNestcount--;
        return;
    }

    // review - order should be set  inhandleroutcall
    // an then reset flags for completion and transfers.

    // reset callback flag so receive another one if
    // message comes in
    m_dwProgressFlags &= ~PROGRESSFLAG_CALLBACKPOSTED;

    // first thing through make sure all our state is setup.
    // set the syncing flag
    m_dwProgressFlags |= PROGRESSFLAG_SYNCINGITEMS;

    // set our Call flag so callback knows not to post to us
    // if we are handling call
    Assert(!(m_dwProgressFlags & PROGRESSFLAG_INHANDLEROUTCALL));
    m_dwProgressFlags |= PROGRESSFLAG_INHANDLEROUTCALL;
    m_dwProgressFlags &= ~PROGRESSFLAG_COMPLETIONROUTINEWHILEINOUTCALL; // reset completion routine
    m_dwProgressFlags &= ~PROGRESSFLAG_NEWITEMSINQUEUE;  // reset new items in queue flag
    m_dwProgressFlags &=  ~PROGRESSFLAG_STARTPROGRESSPOSTED; // reset post flag.

    if (!(m_dwProgressFlags & PROGRESSFLAG_IDLENETWORKTIMER))
    {
        m_dwProgressFlags |= PROGRESSFLAG_IDLENETWORKTIMER;
        // reset network idle initially to keep hangup from happening and setup a timer
        // to keep resetting the idle until the sync is complete.
        ResetNetworkIdle();
        SetTimer(m_hwnd,TIMERID_NOIDLEHANGUP,NOIDLEHANGUP_REFRESHRATE,NULL);
    }

    UpdateProgressValues();

    if (m_clsid != GUID_PROGRESSDLGIDLE)
    {
        // if there is a server we are currently synchronizing but out count
        // is zero then reset to GUID_NULL else use our clsidHandlerInSync
        // so next handler matches the one we are currently syncing.

        if (0 == m_dwHandlerOutCallCount) // if no outcalls we don't care what handler gets matched.
        {
            m_clsidHandlerInSync = GUID_NULL;
        }

        // find the next set of items that match our criteria by seeing
        // if there is any handler that matches out guid (if guid_null just
        // matches first item in state

        // then loop through all handlers matching the guid
        // in the same state.

        // see if there are any items that need PrepareForSyncCalled on them
        if (S_OK == m_HndlrQueue->FindFirstHandlerInState(
                                    HANDLERSTATE_PREPAREFORSYNC,m_clsidHandlerInSync,
                                    &pHandlerID,&m_clsidHandlerInSync))
        {
            ++m_dwHandlerOutCallCount;
            ++m_dwPrepareForSyncOutCallCount;
            m_HndlrQueue->PrepareForSync(pHandlerID,hwnd);

            // see if any other handlers that match the clsid and also call their
            // PrepareForSync methods.

            while (S_OK == m_HndlrQueue->FindFirstHandlerInState(
                                    HANDLERSTATE_PREPAREFORSYNC,m_clsidHandlerInSync,
                                    &pHandlerID,&m_clsidHandlerInSync))
            {
                ++m_dwHandlerOutCallCount;
                ++m_dwPrepareForSyncOutCallCount;
                m_HndlrQueue->PrepareForSync(pHandlerID,hwnd);
            }
        }
        else if ( (0 == m_dwPrepareForSyncOutCallCount)
                    && (S_OK == m_HndlrQueue->FindFirstHandlerInState(
                                    HANDLERSTATE_SYNCHRONIZE,m_clsidHandlerInSync,&pHandlerID,
                                    &m_clsidHandlerInSync)) )
        {
            // no prepareforsync so if there aren't any more handlers in prerpareforsync
            // calls kick off someones synchronize. see if any synchronize methods.
            ++m_dwHandlerOutCallCount;
            ++m_dwSynchronizeOutCallCount;
            m_HndlrQueue->Synchronize(pHandlerID,hwnd);

            // see if any other handlers that match the clsid and also call their
            // synchronize methods.

            while (S_OK == m_HndlrQueue->FindFirstHandlerInState(
                                    HANDLERSTATE_SYNCHRONIZE,m_clsidHandlerInSync,
                                    &pHandlerID,&m_clsidHandlerInSync))
            {
                ++m_dwHandlerOutCallCount;
                ++m_dwSynchronizeOutCallCount;
                m_HndlrQueue->Synchronize(pHandlerID,hwnd);
            }
        }

        // set noMoreItemsToSync flag if
    }
    else
    {
        // for idle queue synchronize any items first since
        // no need to call prepareforsync until we have too and don't kick off more than
        // one at a time.

        // a transfer can come in while processing an out call should be the only time
        // this should happen. This can happen on Idle if in a Retry Error when the next
        // idle fires.

        // Assert(0 == m_dwHandlerOutCallCount);

        // not doing anything while still in an out call emulates the old behavior of
        // only ever doing one handler at a time.

        if (0 == m_dwHandlerOutCallCount)
        {
            if (S_OK == m_HndlrQueue->FindFirstHandlerInState(
                                        HANDLERSTATE_SYNCHRONIZE,GUID_NULL,&pHandlerID,&pHandlerClsid))
            {
                ++m_dwHandlerOutCallCount;
                ++m_dwSynchronizeOutCallCount;
                m_HndlrQueue->Synchronize(pHandlerID,hwnd);
            }
            else if (S_OK == m_HndlrQueue->FindFirstHandlerInState(
                                        HANDLERSTATE_PREPAREFORSYNC,GUID_NULL,&pHandlerID,&pHandlerClsid))
            {
                // msidle only allows one idle registration at a time.
                // reset idle in case last handler we called took it away from us

                if (m_pSyncMgrIdle && (m_dwProgressFlags & PROGRESSFLAG_REGISTEREDFOROFFIDLE))
                {
                    // !!!don't reset the registered if idle flag will do this
                    //  when all handlers are completed.
                    if (!(m_dwProgressFlags & PROGRESSFLAG_RECEIVEDOFFIDLE))
                    {
                        m_pSyncMgrIdle->ReRegisterIdleDetection(this); // reregisterIdle in case handle overrode it.
                        m_pSyncMgrIdle->CheckForIdle();
                    }
                }

                ++m_dwHandlerOutCallCount;
                ++m_dwPrepareForSyncOutCallCount;
               m_HndlrQueue->PrepareForSync(pHandlerID,hwnd);
            }
            else
            {
                // even if nothing to do need to call
                // reset idle hack
                if (m_pSyncMgrIdle && !(m_dwProgressFlags & PROGRESSFLAG_RECEIVEDOFFIDLE)
                    && (m_dwProgressFlags & PROGRESSFLAG_REGISTEREDFOROFFIDLE))
                {  
                    m_pSyncMgrIdle->ReRegisterIdleDetection(this); // reregisterIdle in case handle overrode it.
                    m_pSyncMgrIdle->CheckForIdle();
                }
            }
        }
    }

    UpdateProgressValues(); // update progress values when come out of calls.

    // no longer in any out calls, reset our flag and see if a completion
    // routine came in or items were added to the queue during our out call
    m_dwProgressFlags &= ~PROGRESSFLAG_INHANDLEROUTCALL;

    if ((PROGRESSFLAG_COMPLETIONROUTINEWHILEINOUTCALL & m_dwProgressFlags)
        || (PROGRESSFLAG_NEWITEMSINQUEUE & m_dwProgressFlags) )
    {
        Assert(!(m_dwProgressFlags & PROGRESSFLAG_SHUTTINGDOWNLOOP)); // shouldn't get here if shutting down.

        fRepostedStart = TRUE;

        if (!(m_dwProgressFlags &  PROGRESSFLAG_STARTPROGRESSPOSTED))
        {
            m_dwProgressFlags |=  PROGRESSFLAG_STARTPROGRESSPOSTED;
            PostMessage(m_hwnd,WM_PROGRESS_STARTPROGRESS,0,0);
        }
    }

    // if no more items to synchronize and all synchronizations
    // are done and we are currently syncing items then shut things down.
    // if user is currently in a cancel call then don't start shutting
    Assert(!(m_dwProgressFlags & PROGRESSFLAG_SHUTTINGDOWNLOOP)); // assert if in shutdown this loop shouldn't get called.

    if (!(m_dwProgressFlags & PROGRESSFLAG_SHUTTINGDOWNLOOP)
        && (0 == m_dwHandlerOutCallCount) && !(fRepostedStart)
            && (m_dwProgressFlags & PROGRESSFLAG_SYNCINGITEMS))
    {
        BOOL fTransferAddRef;
        BOOL fOffIdleBeforeShutDown = (m_dwProgressFlags & PROGRESSFLAG_RECEIVEDOFFIDLE);
        BOOL fKeepDialogAlive;

        // if no out calls shouldn't be any call specific out calls either

        Assert(0 == m_dwPrepareForSyncOutCallCount);
        Assert(0 == m_dwSynchronizeOutCallCount);

        m_dwProgressFlags |= PROGRESSFLAG_SHUTTINGDOWNLOOP;
        // reset newItemsInQueue so know for sure it got set while we
        // yielded in cleanup calls.
        m_dwProgressFlags &= ~PROGRESSFLAG_NEWITEMSINQUEUE;

        // treat progress as one long out call
        Assert(!(m_dwProgressFlags & PROGRESSFLAG_INHANDLEROUTCALL));
        m_dwProgressFlags |= PROGRESSFLAG_INHANDLEROUTCALL;
        m_dwProgressFlags &= ~PROGRESSFLAG_COMPLETIONROUTINEWHILEINOUTCALL; // reset completion routine.


        // reset PROGRESSFLAG_TRANSFERADDREF flag but don't release
        // if another transfer happens during this shutdown then the transfer
        // will reset the flag and put and addref on. need to store state
        // in case get this shutdown routine called twice without another
        // transfer we don't call too many releases.

        fTransferAddRef = m_dwProgressFlags & PROGRESSFLAG_TRANSFERADDREF;
        Assert(fTransferAddRef); // should always have a transfer at this statge.
        m_dwProgressFlags &= ~PROGRESSFLAG_TRANSFERADDREF;

        SetProgressReleaseDlgCmdId(m_clsid,this,RELEASEDLGCMDID_OK);

        UpdateProgressValues();
        m_HndlrQueue->RemoveFinishedProgressItems(); // let the queue know to reset the progress bar

        // if not in a cancel or setIetmstatus go ahead and release handlers
        // and kill the terminate timer.
        // review if there is a better opportunity to do cleanup.
        if (!(m_dwProgressFlags & PROGRESSFLAG_INCANCELCALL)
            && !(m_dwProgressFlags & PROGRESSFLAG_INTERMINATE)
            && (0 == m_dwSetItemStateRefCount) )
        {
            if (m_lTimerSet)
            {
                 InterlockedExchange(&m_lTimerSet, 0);
                 KillTimer(m_hwnd,TIMERID_KILLHANDLERS);
            }
 
            m_HndlrQueue->ReleaseCompletedHandlers(); // munge the queue.
        }

        fKeepDialogAlive = KeepProgressAlive(); // determine if progress should stick around

        if ((m_dwProgressFlags & PROGRESSFLAG_PROGRESSANIMATION))
         {
            m_dwProgressFlags &= ~PROGRESSFLAG_PROGRESSANIMATION;
            KillTimer(m_hwnd,TIMERID_TRAYANIMATION);

            Animate_Stop(GetDlgItem(m_hwnd,IDC_UPDATEAVI));
            ShowWindow(GetDlgItem(m_hwnd,IDC_UPDATEAVI),SW_HIDE);
            ShowCompletedProgress(TRUE /* fComplete */ ,fKeepDialogAlive /* fDialogIsLocked */);
         }

        UpdateTrayIcon(); // if Icon is showing make sure we have the uptodate one.

        ConnectObj_CloseConnections(); // Close any connections we held open during the Sync.

        if (m_dwProgressFlags & PROGRESSFLAG_IDLENETWORKTIMER)
        {
            m_dwProgressFlags &= ~PROGRESSFLAG_IDLENETWORKTIMER;
            KillTimer(m_hwnd,TIMERID_NOIDLEHANGUP); // don't need to keep connection open.
        }

        // make sure any previous locks on dialog are removed
        // before going into wait logic. This can happen in the case of a retry.
        LockProgressDialog(m_clsid,this,FALSE);

        // if there are no items to lock the progress open and the
        // force close flag isn't set wait in a loop
        // for two seconds
        if (!(fKeepDialogAlive) && (FALSE == m_fForceClose))
        {
            HANDLE hTimer =  CreateEvent(NULL, TRUE, FALSE, NULL);

            // should use Create/SetWaitable timer to accomplish this but these
            // functions aren't available on Win9x yet.
            if (hTimer)
            {
                // sit in loop until timer event sets it.
                DoModalLoop(hTimer,NULL,m_hwnd,TRUE,1000*2);
                CloseHandle(hTimer);
            }
        }
        else
        {
            LockProgressDialog(m_clsid,this,TRUE);
            ExpandCollapse(TRUE,FALSE); // make sure the dialog is expanded.
            ShowProgressTab(PROGRESS_TAB_ERRORS);
        }

        //if the user hit the pushpin after we started the 2 second delay
        if ((m_fPushpin) && !(fKeepDialogAlive))
        {
	        ShowCompletedProgress(TRUE /* fComplete */,TRUE /* fDialogIsLocked */);
            LockProgressDialog(m_clsid,this,TRUE);
        }

        // if this is an idle dialog handle the logic for
        // either releasing the IdleLock or reregistering.
        if (m_pSyncMgrIdle)
        {
            // if we have already received an OffIdle and not
            // still handling the offidle then release the Idle Lock.
            if ( (m_dwProgressFlags & PROGRESSFLAG_RECEIVEDOFFIDLE)
               && !(m_dwProgressFlags &  PROGRESSFLAG_INOFFIDLE)) 
            {
                // Release our IdleLock so TS can fire use again even if progress
                // sticks around.
                ReleaseIdleLock();
            }
            else if ( (m_dwProgressFlags & PROGRESSFLAG_REGISTEREDFOROFFIDLE)
                    && !(m_dwProgressFlags & PROGRESSFLAG_RECEIVEDOFFIDLE) )
            {
                // if have registered for idle but haven't seen it yet then
                // we want to stay alive.

                // if we aren't suppose to repeat idle or
                // user has maximized the window then just call idle as if
                // an OffIdle occured. Mostly done as a safety precaution
                // in case someone has registered for Idle with MSIdle in 
                // our process space so we fail to receive the true offidle

                if (!(m_dwProgressFlags & PROGRESSFLAG_IDLERETRYENABLED) || !m_fHasShellTrayIcon)
                {
                    IdleCallback(STATE_USER_IDLE_END);

                     // release idle lock since OffIdle won't since we are still
                    //  in the syncing Item state.
                    ReleaseIdleLock();
                }
                else
                {
                    // if haven't yet received an offidle reregister
                    m_pSyncMgrIdle->ReRegisterIdleDetection(this); // reregisterIdle in case handle overrode it.
                    m_pSyncMgrIdle->CheckForIdle();

                    // first thing hide our window. Only hide if we are in the shelltray
                    // and no errors have occured.

                    if (m_fHasShellTrayIcon && !(KeepProgressAlive()))
                    {
                        RegisterShellTrayIcon(FALSE);
                    }

                    m_pSyncMgrIdle->ResetIdle(m_ulIdleRetryMinutes);
                }
            }
        }

        // if no new items in the queue no longer need the connection.
        // do this before releasing dialog ref 
        
        if (!(m_dwProgressFlags & PROGRESSFLAG_NEWITEMSINQUEUE))
        {
            m_HndlrQueue->EndSyncSession();
        }

        // see if Release takes care or our progress, if not,
        // there are more things to synchronize.

        if (fTransferAddRef)
        {
            cDlgRefs = ReleaseProgressDialog(m_fForceClose); // release transfer addref.
        }
        else
        {
            Assert(fTransferAddRef);  // this shouldn't happen but if it does addref/release.

            AddRefProgressDialog();
            cDlgRefs = ReleaseProgressDialog(m_fForceClose);
        }


        // !!!! warning - no longer hold onto a reference to
        // this dialog. Do not do anything to allow this thread
        // to be reentrant.

        // its possible that items got placed in the queue why we were in our
        // sleep loop, if so then restart the loop

        m_dwProgressFlags &= ~PROGRESSFLAG_INHANDLEROUTCALL;

        // if there are new items in the queue need to kick off another loop
        if (m_dwProgressFlags & PROGRESSFLAG_NEWITEMSINQUEUE)
        {
           // m_dwProgressFlags &= ~PROGRESSFLAG_NEWITEMSINQUEUE;
            Assert(m_cInternalcRefs);

            // reset the user cancel flag if new items comein
            m_dwProgressFlags &= ~PROGRESSFLAG_CANCELPRESSED;

            if (!(m_dwProgressFlags & PROGRESSFLAG_STARTPROGRESSPOSTED))
            {
                m_dwProgressFlags |= PROGRESSFLAG_STARTPROGRESSPOSTED;
                PostMessage(hwnd,WM_PROGRESS_STARTPROGRESS,0,0); // restart the sync.
            }
        }
        else
        {
            if (m_dwShowErrorRefCount || m_dwSetItemStateRefCount
                || (m_dwProgressFlags & PROGRESSFLAG_INCANCELCALL) 
                || (m_dwProgressFlags & PROGRESSFLAG_INTERMINATE) )
            {
                // cases that crefs should not be zero caused by out calls
                Assert(m_cInternalcRefs);
            }
            else
            {
                // if get here refs should be zero, be an idle or a queue transfer is in
                // progress.ADD
                Assert(0 == m_cInternalcRefs 
                    || (m_dwProgressFlags & PROGRESSFLAG_INOFFIDLE)
                    || (m_dwProgressFlags & PROGRESSFLAG_REGISTEREDFOROFFIDLE)
                    || (m_dwQueueTransferCount));
            }

            m_dwProgressFlags &= ~PROGRESSFLAG_SYNCINGITEMS; // no longer syncing items.            
        }

        m_dwProgressFlags &=  ~PROGRESSFLAG_CANCELWHILESHUTTINGDOWN; // if cancel came in during shutdown reset flag now.
        m_dwProgressFlags &= ~PROGRESSFLAG_SHUTTINGDOWNLOOP;
    }

    --m_dwHandleThreadNestcount;
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressDlg::KeepProgressAlive, private
//
//  Synopsis:  returns true if progress dialog shouln't go away
//              when the sync is complete
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CProgressDlg::KeepProgressAlive()
{
    HKEY  hkKeepProgress;
    // Default behavior is to stick around on warnings and errors only.
    DWORD dwKeepProgressSetting = PROGRESS_STICKY_WARNINGS | PROGRESS_STICKY_ERRORS;
    DWORD dwErrorsFlag = 0;
    DWORD dwType = REG_DWORD;
    DWORD dwDataSize = sizeof(DWORD);

    if (m_fPushpin)
    {
        return TRUE;
    }
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, TOPLEVEL_REGKEY, 0, KEY_READ, &hkKeepProgress))
    {
        RegQueryValueEx(hkKeepProgress,TEXT("KeepProgressLevel"),NULL, &dwType,
                                       (LPBYTE) &(dwKeepProgressSetting),
                                       &dwDataSize);

	    RegCloseKey(hkKeepProgress);
    }

    if (m_iInfoCount)
    {
	    dwErrorsFlag |= PROGRESS_STICKY_INFO;
    }
    
    if (m_iWarningCount)
    {
	    dwErrorsFlag |= PROGRESS_STICKY_WARNINGS;
    }
    
    if (m_iErrorCount)
    {
	    dwErrorsFlag |= PROGRESS_STICKY_ERRORS;
    }
	
    if (dwKeepProgressSetting & dwErrorsFlag)
    {
        return TRUE;
    }

    return FALSE;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CProgressDlg::TransferQueueData(CHndlrQueue *HndlrQueue)
//
//  PURPOSE:  Get the queue date
//
//      COMMENTS:  transfer items from the specified queue into our queue
//              It is legal fo the HndlrQueue arg to be NULL in the case that
//              the queue is being restarted from a retry. Review - May want
//              to break this function to make the bottom part for the
//              retry a separate function so can assert if someone tries
//              to transfer a NULL queue.
//
//--------------------------------------------------------------------------------

STDMETHODIMP CProgressDlg::TransferQueueData(CHndlrQueue *pHndlrQueue)
{
    HRESULT hr = E_UNEXPECTED;

    SendMessage(m_hwnd, WM_PROGRESS_TRANSFERQUEUEDATA,(WPARAM) &hr, (LPARAM) pHndlrQueue);

    return hr;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CProgressDlg::TransferQueueData(CHndlrQueue *HndlrQueue)
//
//  PURPOSE:  Get the queue date
//
//      COMMENTS:  transfer items from the specified queue into our queue
//              It is legal fo the HndlrQueue arg to be NULL in the case that
//              the queue is being restarted from a retry. Review - May want
//              to break this function to make the bottom part for the
//              retry a separate function so can assert if someone tries
//              to transfer a NULL queue.
//
//--------------------------------------------------------------------------------

STDMETHODIMP CProgressDlg::PrivTransferQueueData(CHndlrQueue *HndlrQueue)
{
    HRESULT hr = S_OK;

    Assert(!(m_dwProgressFlags & PROGRESSFLAG_DEAD));

    Assert(m_HndlrQueue);
    if (NULL == m_HndlrQueue)
    {
        return E_UNEXPECTED;
    }

    ++m_dwQueueTransferCount;

    if (HndlrQueue && m_HndlrQueue)
    {
        // set the transfer flag so main loop knows there are new items to look at
        m_HndlrQueue->TransferQueueData(HndlrQueue);

        // fill in the list box right away so

        // a) better visual UI
        // b) don't have to worry about race conditions with PrepareForSync.
        //      since adding UI won't make an outgoing call.

        if (m_pItemListView)
        {
            AddItemsFromQueueToListView(m_pItemListView,m_HndlrQueue,
                                LVS_EX_FULLROWSELECT |  LVS_EX_INFOTIP ,SYNCMGRSTATUS_PENDING,
                                -1 /* iDateColumn */ ,PROGRESSLIST_STATUSCOLUMN /*status column */
                                ,FALSE /* fUseHandlerAsParent */,TRUE /* fAddOnlyCheckedItems */);

            // set the selection to the first item
            m_pItemListView->SetItemState(0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED );
        }

        UpdateProgressValues();
    	UpdateWindow(m_hwnd);

        // now check if there is already a transfer in progress and if
        // there isn't post the message, else Addref the progress dialog as appropriate.
    }

    m_dwProgressFlags &= ~PROGRESSFLAG_NEWDIALOG; // no longer a new dialog once something is in the queue.

    ShowCompletedProgress(FALSE,FALSE);

    // if the animation isn't going then start it up.
    if (!(m_dwProgressFlags & PROGRESSFLAG_PROGRESSANIMATION))
    {
        m_dwProgressFlags |= PROGRESSFLAG_PROGRESSANIMATION;

        RedrawIcon();
        ShowProgressTab(PROGRESS_TAB_UPDATE);

        Animate_Play(GetDlgItem(m_hwnd,IDC_UPDATEAVI),0,-1,-1);

        ShowWindow(GetDlgItem(m_hwnd,IDC_UPDATEAVI),SW_SHOW );
        SetTimer(m_hwnd,TIMERID_TRAYANIMATION,TRAYANIMATION_SPEED,NULL);
    }

    // if we are an idle set up our callback
    // successfully loaded msIdle, then set up the callback
    // review - make these progress flags
    if (m_pSyncMgrIdle && !(PROGRESSFLAG_REGISTEREDFOROFFIDLE & m_dwProgressFlags))
    {
        m_dwProgressFlags &= ~PROGRESSFLAG_RECEIVEDOFFIDLE; // reset offidle flag

        // read in the defaults to use for Idle shutdown delay and
        // wait until retryIdle based on the first Job in the queue.

        if (0 == m_pSyncMgrIdle->BeginIdleDetection(this,1,0))
        {
            m_dwProgressFlags |= PROGRESSFLAG_REGISTEREDFOROFFIDLE;
            AddRefProgressDialog(); // put an addref on to keep alive, will be released in OffIdle.
        }
        else
        {
            m_dwProgressFlags &= ~PROGRESSFLAG_REGISTEREDFOROFFIDLE;
        }
    }


    // if don't have a transfer addref then add one and make sure idle is setup
    if (!(PROGRESSFLAG_TRANSFERADDREF & m_dwProgressFlags))
    {
        m_dwProgressFlags |= PROGRESSFLAG_TRANSFERADDREF;
        AddRefProgressDialog(); // put an addref on to keep alive.
    }

    --m_dwQueueTransferCount;

    // don't post message if we are in an out call or in the shutdown
    // loop or if newitemsqueue is already set.
    if (!(m_dwProgressFlags & PROGRESSFLAG_INHANDLEROUTCALL)
            && !(m_dwProgressFlags & PROGRESSFLAG_SHUTTINGDOWNLOOP)
            && !(m_dwProgressFlags & PROGRESSFLAG_NEWITEMSINQUEUE)
            && !(m_dwProgressFlags & PROGRESSFLAG_STARTPROGRESSPOSTED) )
    {
         if ( !(m_dwProgressFlags & PROGRESSFLAG_SYNCINGITEMS) )
         {
             // set here even though main loop does in case power managment or another transfer
             // occurs between here and the postMessage being processed.
             m_dwProgressFlags |= PROGRESSFLAG_SYNCINGITEMS;
             m_HndlrQueue->BeginSyncSession();
         }

         m_dwProgressFlags |= PROGRESSFLAG_STARTPROGRESSPOSTED;

         PostMessage(m_hwnd,WM_PROGRESS_STARTPROGRESS,0,0);
    }

    // set newitems flag event if don't post the message so when  handler comes out of
    // state can check the flag.

    m_dwProgressFlags |= PROGRESSFLAG_NEWITEMSINQUEUE;

    // reset the user cancel flag if new items comein
    m_dwProgressFlags &= ~PROGRESSFLAG_CANCELPRESSED;

    if (m_lTimerSet)
    {
        InterlockedExchange(&m_lTimerSet, 0);

        // if we are in a terminate no need to kill the Timer
        if (!(m_dwProgressFlags & PROGRESSFLAG_INTERMINATE))
        {
            KillTimer(m_hwnd,TIMERID_KILLHANDLERS);
        }
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressDlg::CallCompletionRoutine, private
//
//  Synopsis:   method called when a call has been completed.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    02-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CProgressDlg::CallCompletionRoutine(DWORD dwThreadMsg,LPCALLCOMPLETIONMSGLPARAM lpCallCompletelParam)
{
    // !!!warning: This code assumes that the completion routine is only called
    // after the original out call has returned. This code is currently handled
    // by the queue and proxy. If switch to com need to make sure don't start winding
    // up the stack if handlers are calling comletion routines before the original
    // call comes back

    // for anything but ShowErrors can just kick off a progress.
    // for ShowErrors we need to pretend a transfer happened if a retry should occur
    // else don't do anything.

    switch(dwThreadMsg)
    {
    case ThreadMsg_ShowError:
        if (lpCallCompletelParam && (S_SYNCMGR_RETRYSYNC == lpCallCompletelParam->hCallResult))
        {
            // if still in original ShowError Call let ShowEror post the message
            // when done, else treat it like a transfer occured.
            if (m_dwProgressFlags & PROGRESSFLAG_INSHOWERRORSCALL)
            {
                Assert(!(m_dwProgressFlags & PROGRESSFLAG_SHOWERRORSCALLBACKCALLED)); // only support one.
                m_dwProgressFlags |=  PROGRESSFLAG_SHOWERRORSCALLBACKCALLED;
            }
            else
            {
                // sendmessage so it is queued up before release
                SendMessage(m_hwnd,WM_PROGRESS_TRANSFERQUEUEDATA,(WPARAM) 0, (LPARAM) NULL);
            }
        }
        --m_dwShowErrorRefCount;

        // count can go negative if handler calls completion routine on an error. if
        // this is the case just set it to zero
        if ( ((LONG) m_dwShowErrorRefCount) < 0)
        {
            AssertSz(0,"Negative ErrorRefCount");
            m_dwShowErrorRefCount = 0;
        }
        else
        {
            ReleaseProgressDialog(m_fForceClose);
        }
        break;

    case ThreadMsg_PrepareForSync:
    case ThreadMsg_Synchronize:
        {
            DWORD *pdwMsgOutCallCount = (ThreadMsg_PrepareForSync  == dwThreadMsg) ?
                        &m_dwPrepareForSyncOutCallCount : &m_dwSynchronizeOutCallCount;

            if (m_dwProgressFlags & PROGRESSFLAG_INHANDLEROUTCALL)
            {
               m_dwProgressFlags |=PROGRESSFLAG_COMPLETIONROUTINEWHILEINOUTCALL;
            }
            else
            {
                if (!(m_dwProgressFlags &  PROGRESSFLAG_STARTPROGRESSPOSTED))
                {
                    Assert(!(m_dwProgressFlags & PROGRESSFLAG_SHUTTINGDOWNLOOP));
                    m_dwProgressFlags |= PROGRESSFLAG_CALLBACKPOSTED;
                    m_dwProgressFlags |=  PROGRESSFLAG_STARTPROGRESSPOSTED;
                    PostMessage(m_hwnd,WM_PROGRESS_STARTPROGRESS,0,0);
                }
            }

            // fix up call count.

            --(*pdwMsgOutCallCount);
            if ( ((LONG) *pdwMsgOutCallCount) < 0)
            {
                AssertSz(0,"Negative Message Specific OutCall");
                *pdwMsgOutCallCount = 0;
            }

            --m_dwHandlerOutCallCount; // decrement the handler outcall.
            if ( ((LONG) m_dwHandlerOutCallCount) < 0)
            {
                AssertSz(0,"NegativeHandlerOutCallCount");
                m_dwHandlerOutCallCount = 0;
            }
        }
        break;

    default:
        AssertSz(0,"Unknown Callback method");
        break;
    }

    // if have an lparam free it now
    if (lpCallCompletelParam)
    {
        FREE(lpCallCompletelParam);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgressDlg::QueryCanSystemShutdown, private
//
//  Synopsis:   called by object manager to determine if can shutdown.
//
//          !!!Warning - can be called on any thread. make sure this is
//              readonly.
//
//          !!!Warning - Do not yield in the function;
//
//  Arguments:
//
//  Returns:   S_OK - if can shutdown
//             S_FALSE - system should not shutdown, must fill in out params.
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT CProgressDlg::QueryCanSystemShutdown(/* [out] */ HWND *phwnd, /* [out] */ UINT *puMessageId,
                                             /* [out] */ BOOL *pfLetUserDecide)
{
    HRESULT hr = S_OK;

    if (m_dwShowErrorRefCount > 0)
    {
        *puMessageId = IDS_HANDLERSHOWERRORQUERYENDSESSION ;
        *phwnd = NULL; // don't know showError parent so keep NULL
        *pfLetUserDecide = FALSE;

        hr = S_FALSE;
    }
    else  if (m_clsid != GUID_PROGRESSDLGIDLE) // idle should allow shutdown even if syncing.
    {
        // if a sync is in progress prompt user to if they want to cancel.
        if (PROGRESSFLAG_SYNCINGITEMS & m_dwProgressFlags)
        {
            *puMessageId = IDS_PROGRESSQUERYENDSESSION;
            *phwnd = m_hwnd;
            *pfLetUserDecide = TRUE;

            hr = S_FALSE;
        }
    }

    return hr;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION:   CProgressDlg::ExpandCollapse()
//
//  PURPOSE:    Takes care of showing and hiding the "details" part of the
//                              dialog.
//
//  PARAMETERS:
//      <in> fExpand - TRUE if we should be expanding the dialog.
//              <in> fSetFocus - TRUE forces a recalc.
//
//--------------------------------------------------------------------------------
void CProgressDlg::ExpandCollapse(BOOL fExpand, BOOL fForce)
{
    RECT rcSep;
    TCHAR szBuf[MAX_STRING_RES];
    RECT rcCurDlgRect;
    BOOL fSetWindowPos = FALSE;
    BOOL fOrigExpanded = m_fExpanded;

    if ( (m_fExpanded == fExpand) && !fForce) // no need to do anything if already in requested state
        return;

    m_fExpanded = fExpand;

    GetWindowRect(GetDlgItem(m_hwnd, IDC_SP_SEPARATOR), &rcSep);
    GetWindowRect(m_hwnd,&rcCurDlgRect);

    if (!m_fExpanded)
    {
        // update or rcDlg rect so can reset to proper height next time.
        if (GetWindowRect(m_hwnd,&m_rcDlg))
        {
            fSetWindowPos = SetWindowPos(m_hwnd, HWND_NOTOPMOST, 0, 0, rcCurDlgRect.right - rcCurDlgRect.left,
                                            m_cyCollapsed, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
        }
    }
    else
    {
        fSetWindowPos = SetWindowPos(m_hwnd, HWND_NOTOPMOST, 0, 0, rcCurDlgRect.right - rcCurDlgRect.left,
                                        m_rcDlg.bottom - m_rcDlg.top, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
    }

    // if couldn't change window, leave as is
    if (!fSetWindowPos)
    {
        m_fExpanded = fOrigExpanded;
        return;
    }

    // Make sure the entire dialog is visible on the screen.  If not,
    // then push it up
    RECT rc;
    RECT rcWorkArea;
    GetWindowRect(m_hwnd, &rc);
    SystemParametersInfo(SPI_GETWORKAREA, 0, (LPVOID) &rcWorkArea, 0);
    if (rc.bottom > rcWorkArea.bottom)
    {
        rc.top = max(0, (int) rc.top - (rc.bottom - rcWorkArea.bottom));
        SetWindowPos(m_hwnd, HWND_NOTOPMOST, rc.left, rc.top, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
    }

    LoadString(g_hInst, m_fExpanded ? IDS_HIDE_DETAILS : IDS_SHOW_DETAILS, szBuf, ARRAYSIZE(szBuf));
    SetDlgItemText(m_hwnd, IDC_DETAILS, szBuf);

    // Make sure the proper tab is up to date shown.
    ShowProgressTab(m_iTab);

    // Raid-34387: Spooler: Closing details with ALT-D while focus is on a task disables keyboard input
    // if any control other than the cancel button has the focus set the focus to details.

    if (!fExpand)
    {
        HWND hwndFocus = GetFocus();

        if (hwndFocus != GetDlgItem(m_hwnd, IDSTOP))
        {
            SetFocus(GetDlgItem(m_hwnd, IDC_DETAILS));
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgressDlg::OnTimer, private
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CProgressDlg::OnTimer(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    WORD wTimerID = (WORD) wParam;

    if (wTimerID == TIMERID_TRAYANIMATION)
    {
        UpdateTrayIcon();
    }
    else if (TIMERID_NOIDLEHANGUP == wTimerID)
    {
        ResetNetworkIdle();
    }
    else if (TIMERID_KILLHANDLERS == wTimerID)
    {
        if (m_lTimerSet)
        {
            if (!(m_dwProgressFlags & PROGRESSFLAG_DEAD)
                && !(m_dwProgressFlags & PROGRESSFLAG_SHUTTINGDOWNLOOP)
                && !(m_dwProgressFlags & PROGRESSFLAG_INTERMINATE))
            {
                BOOL fItemToKill;

                m_dwProgressFlags |= PROGRESSFLAG_INTERMINATE;

                // Even though KillTimer,
                // don't reset  m_lTimerSet timer until done with ForceKill
                // in case cancel is pressed again.

                KillTimer(m_hwnd,TIMERID_KILLHANDLERS);
            
                SetProgressReleaseDlgCmdId(m_clsid,this,RELEASEDLGCMDID_CANCEL); // set so cleanup knows it was stopped by user..

                AddRefProgressDialog(); // hold dialog alive until cancel is complete

                m_HndlrQueue->ForceKillHandlers(&fItemToKill);

                // reset the timer if TimerSet is still set, i.e. if was 
                // set to zero because of a transfer or actually done don't reset.

                if (m_lTimerSet)
                {
                    // only settimer if actually killed anything. if looped through
                    // and found nothing then can turn off timer.
                    if (fItemToKill)
                    {
                        Assert(m_nKillHandlerTimeoutValue >= TIMERID_KILLHANDLERSMINTIME);
                        SetTimer(m_hwnd,TIMERID_KILLHANDLERS,m_nKillHandlerTimeoutValue,NULL);
                    }
                    else
                    {
                        m_lTimerSet = 0;
                    }
                }

                m_dwProgressFlags &= ~PROGRESSFLAG_INTERMINATE;
                
                ReleaseProgressDialog(FALSE);
            }
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgressDlg::OnTaskBarCreated, private
//
//  Synopsis:  Receive this when the Tray has been restarted.
//              Need to put back our tray icon.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    31-Aug-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CProgressDlg::OnTaskBarCreated(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    if (m_fHasShellTrayIcon)
    {
        m_fAddedIconToTray = FALSE; // set added to false to force update to add again.
        UpdateTrayIcon();
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressDlg::OnSysCommand, private
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CProgressDlg::OnSysCommand(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    UINT uCmdType = (UINT) wParam;        // type of system command requested
    WORD xPos = LOWORD(lParam);    // horizontal postion, in screen coordinates
    WORD yPos = HIWORD(lParam);    // vertical postion, in screen coordinates

    //
    // WARNING: USER uses low four bits for some undocumented feature
    //  (only for SC_*). We need to mask those bits to make this case
    //  statement work.

    uCmdType &= 0xFFF0;

    switch(uCmdType)
    {
    case SC_MINIMIZE:
        // if already in the tray do nothing
        if (!m_fHasShellTrayIcon)
        {
            if (RegisterShellTrayIcon(TRUE))
            {
                AnimateTray(TRUE);
                ShowWindow(m_hwnd,SW_HIDE);
              //  AnimateTray(TRUE);
                return -1;
            }
        }
        else
        {
            return -1; // if already in the tray we handled.
        }
        break;

    case SC_MAXIMIZE:
    case SC_RESTORE:
        {
            // if we are being maximized or restored from a maximize
            // make sure  details is open

            if ( (uCmdType ==  SC_RESTORE && m_fMaximized)
                    || (uCmdType ==  SC_MAXIMIZE) )
            {
                if (!m_fExpanded)
                {
                    ExpandCollapse(TRUE,FALSE);
                }
            }

            m_fMaximized = (uCmdType ==  SC_MAXIMIZE) ?  TRUE : FALSE;
        }
        break;

    default:
        break;
    }

    return FALSE; // fall through to defWndProc
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgressDlg::OnShellTrayNotification, private
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CProgressDlg::OnShellTrayNotification(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    DWORD dwMsg = (DWORD) lParam;

    switch (dwMsg)
    {
    case WM_LBUTTONUP:
        {
            UpdateWndPosition(SW_SHOWNORMAL,TRUE /* fForce */);
        }
        break;

    default:
        break;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressDlg::OnClose, private
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CProgressDlg::OnClose(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    OnCancel(FALSE /* fOffIdle */); // treat close as a cancel.
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressDlg::OnGetMinMaxInfo, private
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CProgressDlg::OnGetMinMaxInfo(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    MINMAXINFO   *pMinMax = (MINMAXINFO *) lParam ;

    // minimum width is a constant but minimum height depends on
    // if dialog is collapsed or expanded.

    if (!m_fExpanded)
    {
         pMinMax->ptMinTrackSize.y = m_cyCollapsed;
         pMinMax->ptMaxTrackSize.y = m_cyCollapsed; // maximum is also the collapsed height
    }
    else
    {
        pMinMax->ptMinTrackSize.y = m_ptMinimumDlgExpandedSize.y;
    }

    pMinMax->ptMinTrackSize.x  = m_ptMinimumDlgExpandedSize.x;
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgressDlg::OnMoving, private
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CProgressDlg::OnMoving(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    LPRECT lprc = (LPRECT) lParam;    // screen coordinates of drag rectangle

    // if we are maxmized don't allow moving
    if (m_fMaximized)
    {
        GetWindowRect(m_hwnd,lprc);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressDlg::OnContextMenu, private
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL  CProgressDlg::OnContextMenu(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    WinHelp ((HWND)wParam, g_szSyncMgrHelp, HELP_CONTEXTMENU, (ULONG_PTR)g_aContextHelpIds);
    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressDlg::OnPowerBroadcast, private
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CProgressDlg::OnPowerBroadcast(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    if (wParam == PBT_APMQUERYSUSPEND)
    {
        // if just created or syncing don't suspend
        if (m_dwProgressFlags & PROGRESSFLAG_NEWDIALOG
            || m_dwProgressFlags & PROGRESSFLAG_SYNCINGITEMS)
        {
            SetWindowLongPtr(m_hwnd,DWLP_MSGRESULT,BROADCAST_QUERY_DENY);
            return TRUE;
        }
    }

    return TRUE;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: ProgressWndProc(HWND hwnd, UINT uMsg,WPARAM wParam,LPARAM lParam)
//
//  PURPOSE:  Callback for Progress Dialog
//
//      COMMENTS: Implemented on main thread.
//
//
//--------------------------------------------------------------------------------

INT_PTR CALLBACK ProgressWndProc(HWND hwnd, UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    CProgressDlg *pThis = (CProgressDlg *) GetWindowLongPtr(hwnd, DWLP_USER);
    UINT horizExtent = 0;
    BOOL bResult;

    // spcial case destroy and init.
    switch (uMsg)
    {
    case WM_DESTROY:
        PostQuitMessage(0); // done with this thread.
	    break;

    case WM_INITDIALOG:
        {
            SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)lParam);
            pThis = (CProgressDlg *) lParam;

            if (pThis)
            {
                pThis->InitializeHwnd(hwnd,uMsg,wParam,lParam);
            }

            return FALSE; // return FALSE so system doesn't give us the focus
        }
        break;

    default:
        {
            if (pThis)
            {
                switch (uMsg)
                {
                case WM_POWERBROADCAST:
                    return pThis->OnPowerBroadcast(uMsg,wParam,lParam);
                    break;
                case WM_CONTEXTMENU:
                    return pThis->OnContextMenu(uMsg,wParam,lParam);
                    break;
                case WM_DRAWITEM:
                    return OnProgressResultsDrawItem(hwnd,pThis,(UINT)wParam,(const DRAWITEMSTRUCT*)lParam);
                    break;
                case WM_MEASUREITEM:
                    bResult = OnProgressResultsMeasureItem(hwnd,pThis, &horizExtent,(UINT)wParam,(MEASUREITEMSTRUCT *)lParam);
                    if (horizExtent)
                    {
                        //make sure there is a horizontal scroll bar if needed
                        SendMessage(GetDlgItem(hwnd,IDC_LISTBOXERROR), LB_SETHORIZONTALEXTENT, horizExtent, 0L);
                    }
                    return bResult;
                    break;
                case WM_DELETEITEM:
                    return OnProgressResultsDeleteItem(hwnd,(UINT)wParam,(const DELETEITEMSTRUCT *)lParam);
                    break;
                case WM_NOTIFY:
                    pThis->OnNotify(uMsg,wParam,lParam);
                    break;
                case WM_COMMAND:
                    pThis->OnCommand(uMsg,wParam,lParam);
                    break;
                case WM_MOVING:
                     pThis->OnMoving(uMsg,wParam,lParam);
                     break;
                case WM_SIZE:
                    pThis->OnSize(uMsg,wParam,lParam);
                    break;
                case WM_GETMINMAXINFO:
                    pThis->OnGetMinMaxInfo(uMsg,wParam,lParam);
                    break;
                case WM_PAINT:
                    pThis->OnPaint(uMsg,wParam,lParam);
                    return 0;
                    break;
                case WM_BASEDLG_SHOWWINDOW:
                    pThis->UpdateWndPosition((int)wParam,FALSE); // nCmdShow is stored in the wParam
                    break;
                case WM_BASEDLG_NOTIFYLISTVIEWEX:
                    pThis->OnNotifyListViewEx(uMsg,wParam,lParam);
                    break;
                case WM_BASEDLG_COMPLETIONROUTINE:
                    pThis->CallCompletionRoutine((DWORD)wParam /*dwThreadMsg */ ,(LPCALLCOMPLETIONMSGLPARAM) lParam);
                    break;
                case WM_BASEDLG_HANDLESYSSHUTDOWN:
                    // set the force shutdown member then treat as a close
                    pThis->m_fForceClose = TRUE;
                    PostMessage(hwnd,WM_CLOSE,0,0);
                    break;
                case WM_TIMER: // timer message for delat when sync is done.
                   pThis->OnTimer(uMsg,wParam,lParam);
                   break;
                case WM_PROGRESS_UPDATE:
                    pThis->HandleProgressUpdate(hwnd,wParam,lParam);
                    break;
                case WM_PROGRESS_LOGERROR:
                    pThis->HandleLogError(hwnd,(HANDLERINFO *) wParam,(MSGLogErrors *) lParam);
                    break;
                case WM_PROGRESS_DELETELOGERROR:
                    pThis->HandleDeleteLogError(hwnd,(MSGDeleteLogErrors *) lParam);
                    break;
                case WM_PROGRESS_STARTPROGRESS:
                    pThis->DoSyncTask(hwnd);
                    break;
                case WM_PROGRESS_RESETKILLHANDLERSTIMER:
                    pThis->OnResetKillHandlersTimers();
                    break;
                case WM_CLOSE:
                    pThis->OnClose(uMsg,wParam,lParam);
                    break;
                case WM_PROGRESS_SHELLTRAYNOTIFICATION:
                    pThis->OnShellTrayNotification(uMsg,wParam,lParam);
                    break;
                case WM_SYSCOMMAND:
                    return pThis->OnSysCommand(uMsg,wParam,lParam);
                    break;
                case WM_PROGRESS_TRANSFERQUEUEDATA:
                    {
                        HRESULT *phr = (HRESULT *) wParam;
                        HRESULT hr;

                        hr = pThis->PrivTransferQueueData( (CHndlrQueue *) lParam);

                        // phr is only valid on a SendMessage.
                        if (phr)
                        {
                            *phr = hr;
                        }

                        return TRUE;
                    }
                    break;
                case WM_PROGRESS_RELEASEDLGCMD:
                    pThis->PrivReleaseDlg((WORD)wParam);
                    break;
                default:
                    if (uMsg == g_WMTaskbarCreated)
                    {
                        pThis->OnTaskBarCreated(uMsg,wParam,lParam);
                    }
                    break;
                }
            }
        }
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\exe\resource.h ===
//{{NO_DEPENDENCIES}}
//  Copyright (C) Microsoft Corporation, 1999.
// Microsoft Developer Studio generated include file.
// Used by syncmgr.rc
//

#define MAINDIALOG_HWNDCLASSNAME  "SyncMgr_HwndDialog" // class name for our choice/progress dialog


#define IDS_HIDE_DETAILS                1
#define IDC_CHOICELISTVIEW              1
#define IDS_SHOW_DETAILS                2
#define IDS_UPDATETAB                   3
#define IDS_ERRORSTAB                   4
#define IDS_PROGRESSCOMPLETETITLE       5
#define IDS_PROGRESSWORKINGTITLE        6
#define IDS_PROGRESSCOMPLETEOK          7
#define IDS_PROGRESSCOMPLETEERROR       8
#define IDS_PROGRESSCOMPLETEWARNING     9
#define IDS_LISTBOXDESCRIPTION          10
#define IDS_NOITEMS                     11
#define IDS_LAN_CONNECTION              12
#define IDS_NOERRORSREPORTED    	13
#define IDS_SYNCMGRNAME         	14
#define IDS_NUM_ITEMS_COMPLETE  	15
#define IDS_PROGRESSQUERYENDSESSION     16
#define IDS_SETTINGSQUERYENDSESSION     17
#define IDS_HANDLERPROPERTIESQUERYENDSESSION 18
#define IDS_HANDLERSHOWERRORQUERYENDSESSION 19
#define IDS_NULL_HANDLERNOTRESPONDING   20
#define IDS_HANDLERNOTRESPONDING        21
#define IDS_SYNCMGR_ERROR               22

#define IDS_STOP                     	40
#define IDS_CLOSE                     	41

#define IDS_STOPPING                    49
#define IDS_STOPPED                     50
#define IDS_SKIPPED                     51
#define IDS_PENDING                     52
#define IDS_SYNCHRONIZING               53
#define IDS_SUCCEEDED                   54
#define IDS_FAILED                      55
#define IDS_PAUSED                      56
#define IDS_RESUMING                    57
#define IDS_JUMPTEXT                    58

#define IDS_STOPPED_ITEM                60
#define IDS_SKIPPED_ITEM                61
#define IDS_PENDING_ITEM                62
#define IDS_SYNCHRONIZING_ITEM          63
#define IDS_SUCCEEDED_ITEM              64
#define IDS_FAILED_ITEM                 65
#define IDS_PAUSED_ITEM                 66
#define IDS_RESUMING_ITEM               67

#define IDS_CHOICEHANDLERCOLUMN         70
#define IDS_CHOICELASTUPDATECOLUMN      71
#define IDS_PROGRESS_DLG_COLUMN_INFO    72
#define IDS_PROGRESS_DLG_COLUMN_NAME    73
#define IDS_PROGRESS_DLG_COLUMN_STATUS  74

#define IDS_LOGERRORWITHITEMID          80
#define IDS_LOGERRORNOITEMID            81
#define IDS_LOGERRORNOHANDLER           82

#define IDD_PROGRESS                    101
#define IDD_CHOICE                      102
#define IDD_PROPERTY                    111
#define IDD_PROGRESS_UPDATE             119
#define IDD_PROGRESS_RESULTS            120
#define IDI_ICON_ERROR                  121
#define IDI_ICON_INFO                   122
#define IDC_HARROW                      126
#define IDI_OFFLINE                     127
#define IDA_UPDATE                      128
#define IDI_PHONE                       129
#define IDI_SYNCMGR                     132
#define IDI_SETTINGS                    133
#define IDI_ICON1                       135
#define IDI_FOLDOPEN                    139
#define IDC_PROGRESSBAR                 1000
#define IDC_OFFLINEICON                 1002
#define IDC_DETAILS                     1003
#define IDC_SP_SEPARATOR                1004
#define IDC_SKIP_BUTTON                 1006
#define IDC_PROPERTY                    1007
#define IDC_OPTIONS                     1009
#define IDC_CLOSE                       1010
#define IDC_PROGRESS_TABS               1011
#define IDC_DONT_PROMPT                 1012
#define IDC_START                       1013
#define IDC_UPDATE_LIST                 1015
#define IDC_STATIC_SKIP_TEXT            1017
#define IDC_PROGRESS_OPTIONS_BUTTON     1018
#define IDC_STATIC_WHATS_UPDATING       1019
#define IDC_STATIC_HOW_MANY_COMPLETE    1020
#define IDSTOP                          1022
#define IDC_RESULTS_LIST                1023
#define IDC_LISTBOXERROR                1024
#define IDC_UPDATEAVI                   1025
#define IDC_PROGRESSRESIZESCROLLBAR     1026
#define IDC_CONNECTICON                 1027
#define IDC_SYNCHELP                    1028
#define IDC_FOLDER2                     1029
#define IDC_FOLDER1                     1030
#define IDC_RESULTTEXT                  1031
#define IDHIDE                          1032
#define IDC_HIDE                        1033

#define IDC_PROGRESS_OPTIONS_BUTTON_MAIN     1053
#define IDC_SKIP_BUTTON_MAIN                 1054
#define IDC_STATIC_WHATS_UPDATING_INFO       1055
#define IDC_CHOICERESIZESCROLLBAR          1060

#define IDC_STATIC			-1
#define IDC_STATIC1                     1501
#define IDC_STATIC2                     1502
#define IDC_STATIC3                     1503
#define IDC_STATIC4                     1504
#define IDC_STATIC5                     1505

#define IDS_UNDEFINED_ERROR	     2000

// define values for Tray Icons
#define IDI_SYSTRAYINFORMATION          2050
#define IDI_SYSTRAYWARNING              2051
#define IDI_SYSTRAYERROR                2052
#define IDI_SYSTRAYANI1                 2053
#define IDI_SYSTRAYANI2                 2054
#define IDI_SYSTRAYANI3                 2055
#define IDI_SYSTRAYANI4                 2056
#define IDI_SYSTRAYANI5                 2057
#define IDI_SYSTRAYANI6                 2058
#define IDB_PUSHPIN			2059
#define IDC_PUSHPIN			2060
#define IDC_TOOLBAR			2061





// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        140
#define _APS_NEXT_COMMAND_VALUE         40004
#define _APS_NEXT_CONTROL_VALUE         1032
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\exe\progtab.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Progtab.cpp
//
//  Contents:   Progress tab
//
//  Classes:
//
//  Notes:		Handle the custom results pane.
//
//  History:    05-Nov-97   Susia      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"
							
extern HINSTANCE g_hInst; // current instance

extern INT_PTR CALLBACK ProgressWndProc(HWND hwnd, UINT uMsg,WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK ResultsProgressWndProc(HWND hwnd, UINT uMsg,WPARAM wParam,LPARAM lParam);


//--------------------------------------------------------------------------------
//
//  FUNCTION: ListBox_HitTest(HWND hwnd, LONG xPos, LONG yPos)
//
//  PURPOSE:  HitTest for a ListBox, since Windows was nice enough to not provide one
//          This is really a function to see if the hittest falls in the range
//          of the More Info Jump text.
//
//	COMMENTS: Implemented on main thread.
//
//--------------------------------------------------------------------------------
INT ListBox_HitTest(HWND hwnd, LONG xPos, LONG yPos)
{
int begin = ListBox_GetTopIndex(hwnd);
int end = ListBox_GetCount(hwnd);
int i;
RECT rcRect;

    for (i=begin;i<end;i++)
    {
    LBDATA *pData = NULL;

	if (ListBox_GetItemRect(hwnd, i, &rcRect))
        {
            pData = (LBDATA *) ListBox_GetItemData(hwnd,i);

            if (pData == NULL)
            {
                // if no data then  try the next one
                continue;
            }

            // if textRect not calculated then this isn't visible.
            if (pData->fTextRectValid)
            {
                // only use left and right vars for hit test. top and bottom
                // can change.

                // compare y values first since they are the ones
                // most likely to be different.
	        if (    (yPos >= rcRect.top)	&&
                        (yPos <= rcRect.bottom) &&
                        (xPos >= pData->rcTextHitTestRect.left) &&
                        (xPos <= pData->rcTextHitTestRect.right) )
                {
                    return i;
                }
            }
        }
    }
		
    return -1;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: OnProgressResultsDrawItem(HWND hwnd, UINT idCtl, LPDRAWITEMSTRUCT lpdis)
//
//  PURPOSE:  Handle DrawItem events for Progress Dialog Results Tab
//
//	COMMENTS: Implemented on main thread.
//
//--------------------------------------------------------------------------------
BOOL OnProgressResultsDrawItem(HWND hwnd,CProgressDlg *pProgress,UINT idCtl, const DRAWITEMSTRUCT* lpDrawItem)
{
HDC      hdc = lpDrawItem->hDC;
COLORREF clrText, clrBack;
RECT     rcText, rcFocus;
LOGFONT	 lf;
HGDIOBJ  hFont, hFontOld;
HFONT hFontJumpText = NULL;
int nSavedDC;
LBDATA *pData = (LBDATA *) lpDrawItem->itemData;

    if (!hdc || !pData)
    {
        return FALSE;
    }

    nSavedDC = SaveDC(hdc);

    Assert(lpDrawItem->CtlType == ODT_LISTBOX);
    if (lpDrawItem->itemID == -1)
        goto exit;

   clrBack = SetBkColor(hdc, GetSysColor(COLOR_WINDOW));

   // Clear the item for drawing
   // + 1 is just the way you do it for some reason
   FillRect(hdc, &(lpDrawItem->rcItem),
                            (HBRUSH) (COLOR_WINDOW + 1) );


    if (pData->IconIndex != -1)
    {
	    ImageList_Draw(pProgress->m_errorimage,
               pData->IconIndex,
               hdc,
               BULLET_INDENT,
               lpDrawItem->rcItem.top  + BULLET_INDENT,
               ILD_TRANSPARENT);
    }

    // Set up the font, text and background colors
    hFont = (HFONT) SendMessage(hwnd, WM_GETFONT, 0, 0);

    if (hFont)
    {
        Assert(NULL == hFontJumpText);

        if (pData->fIsJump && GetObject(hFont,sizeof(LOGFONT),&lf))
        {
	
	    lf.lfUnderline = TRUE;
            hFontJumpText = CreateFontIndirect(&lf);

            if (hFontJumpText)
            {
	        hFontOld = SelectObject(hdc,hFontJumpText);
            }

        }

        if (!hFontJumpText)
        {
           hFontOld = SelectObject(hdc,hFont);
        }

    }

    // set up colors
    if (pData->fIsJump)
    {
        // even if don't get font change the attribs;
        if (pData->fHasBeenClicked)
	{
	    clrText = SetTextColor(hdc, RGB(128,0,128));
	}
	else
	{
	    clrText = SetTextColor(hdc, RGB(0,0,255));
	}

    }
    else
    {	
	clrText = SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
    }

    // calc what the drawText should be. Need to take our stored
    // text value and adjust the top.

    {
        RECT rpDataRect =  pData->rcText;

        rcText = lpDrawItem->rcItem;
        rcText.top = lpDrawItem->rcItem.top + BULLET_INDENT;
        rcText.left +=   rpDataRect.left;
        rcText.right =   rcText.left  +  WIDTH(rpDataRect);
    }

   /* rcText = lpDrawItem->rcItem;
    rcText.left += (pProgress->m_iIconMetricX*3)/2 + BULLET_INDENT; // move over Icon distance
    rcText.top += BULLET_INDENT;
*/
    // draw the text using the TextBox we calc'd in Measure Item
    DrawText(hdc,pData->pszText, -1,
           &rcText,
           DT_NOCLIP | DT_WORDBREAK );

    // If we need a focus rect, do that too
    if (lpDrawItem->itemState & ODS_FOCUS)
    {
        rcFocus = lpDrawItem->rcItem;
      //  rcFocus.left += (pProgress->m_iIconMetricX*3)/2;

        rcFocus.top += BULLET_INDENT;
        rcFocus.left += BULLET_INDENT;
        DrawFocusRect(hdc, &rcFocus);
    }

//    SetBkColor(hdc, clrBack);
 //   SetTextColor(hdc, clrText);

    if (nSavedDC)
    {
        RestoreDC(hdc,nSavedDC);
    }

    if (hFontJumpText)
    {
        DeleteObject(hFontJumpText);
    }


exit:

    return TRUE;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: OnProgressResultsMeasureItem(HWND hwnd, CProgressDlg *pProgress, UINT *horizExtent UINT idCtl, MEASUREITEMSTRUCT *pMeasureItem)
//
//  PURPOSE:  Handle MeasureItem events for Progress Dialog Results Tab
//
//	COMMENTS: Implemented on main thread.
//
//--------------------------------------------------------------------------------
BOOL OnProgressResultsMeasureItem(HWND hwnd,CProgressDlg *pProgress, UINT *horizExtent, UINT /* idCtl */, MEASUREITEMSTRUCT *pMeasureItem)
{
LBDATA *pData = NULL;
HWND hwndList = GetDlgItem(hwnd,IDC_LISTBOXERROR);

    if (!hwndList)
    {
        return FALSE;
    }

    pData = (LBDATA *) ListBox_GetItemData(hwndList, pMeasureItem->itemID);

    if (pData == NULL)
    {
        Assert(pProgress);
        Assert(pProgress->m_CurrentListEntry);
        pData = pProgress->m_CurrentListEntry;
    }

    if (pData == NULL)
    {
        return FALSE;
    }

    HFONT hfont = NULL;
    HFONT hFontJumpText = NULL;
    HDC hdc;
    int iHeight;
    int nSavedDC;

    hdc = GetDC(hwndList);

    if (NULL == hdc)
    {
        return FALSE;
    }

    nSavedDC = SaveDC(hdc);

    // Get the size of the string
    hfont = (HFONT) SendMessage(hwnd, WM_GETFONT, 0, 0);

    // if can't get font or jump text font just use the
    // current font.
    if (hfont)
    {
        // if this is jump text then change some
        // font attributes.
        if (pData->fIsJump)
        {
        LOGFONT lf;

            if (GetObject(hfont,sizeof(LOGFONT),&lf))
            {
	        lf.lfUnderline = TRUE;

                 hFontJumpText = CreateFontIndirect(&lf);
            }
        }


        if (hFontJumpText)
        {
            SelectFont(hdc, hFontJumpText);
        }
        else
        {
            SelectFont(hdc, hfont);
        }

    }

    int cxResultsWidth;
    RECT rcRect;

    // GetClientRect seems to subtract off the Scroll Bars for us.
    GetClientRect(hwndList, &rcRect);

    cxResultsWidth = rcRect.right;

    SetRect(&rcRect, 0, 0, cxResultsWidth, 0);

    // subtract off the length of Icon + 1/2
    rcRect.right -=  ((pProgress->m_iIconMetricX*3)/2
            + BULLET_INDENT );

    int tempwidth = rcRect.right;
    iHeight = DrawText(hdc, pData->pszText, -1, &rcRect,
           DT_NOCLIP | DT_CALCRECT | DT_WORDBREAK) + BULLET_INDENT;



    //We have a smegging word in the string wider than the rect.
    if (rcRect.right > tempwidth)
    {
        *horizExtent = cxResultsWidth + (rcRect.right - tempwidth);
   	    // fix up the proper width
        rcRect.right = cxResultsWidth + (rcRect.right - tempwidth);

    }
    else
    {
        rcRect.right = cxResultsWidth;
    }
    rcRect.left +=  ((pProgress->m_iIconMetricX*3)/2
            + BULLET_INDENT );

    // bottom is either the height of the line or if it has
    // an icon the max of these two.
    if (-1 != pData->IconIndex)
    {
        rcRect.bottom = max(iHeight,pProgress->m_iIconMetricY + BULLET_INDENT*2);
    }
    else
    {
        rcRect.bottom = iHeight;
    }

    // if need to add space on the end then do that
    if (pData->fAddLineSpacingAtEnd)
    {
        SIZE Size;

        if (!GetTextExtentPoint(hdc,SZ_SYNCMGRNAME,
                            lstrlen(SZ_SYNCMGRNAME),&Size))
        {
            // if can't get size make up a number
            Size.cy = 13;
        }

        // lets do 2/3 a line spacing.
        rcRect.bottom += (Size.cy*2)/3;

    }


    // store the TextRect in the pData field.
    pMeasureItem->itemHeight = rcRect.bottom;
    pMeasureItem->itemWidth = cxResultsWidth;


    pData->rcText = rcRect;

    pData->fTextRectValid = TRUE;
    pData->rcTextHitTestRect = rcRect;

    if (pData->fIsJump)
    {
    SIZE size;

        // on jump text want the hit test only over the actual text
        // in the horizontal location.
	if(GetTextExtentPoint(hdc,pData->pszText,lstrlen(pData->pszText), &size))
	{
            pData->rcTextHitTestRect.right = size.cx +  pData->rcTextHitTestRect.left;
	}

    }

    if (nSavedDC)
    {
        RestoreDC(hdc,nSavedDC);
    }

    if (hFontJumpText)
    {
        DeleteObject(hFontJumpText);
    }

    ReleaseDC(hwndList, hdc);


    return TRUE;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: OnProgressResultsDeleteItem(HWND hwnd, UINT idCtl, const DELETEITEMSTRUCT * lpDeleteItem)
//
//  PURPOSE:  Handle DeleteItem events for Progress Dialog Results Tab
//
//	COMMENTS: Implemented on main thread.
//
//--------------------------------------------------------------------------------
BOOL OnProgressResultsDeleteItem(HWND hwnd,UINT idCtl, const DELETEITEMSTRUCT * lpDeleteItem)
{

   // Assert(lpDeleteItem->itemData);

   if (lpDeleteItem->itemData)
   {
       FREE((LPVOID) lpDeleteItem->itemData);
   }

   return TRUE;
}

void OnProgressResultsSize(HWND hwnd,CProgressDlg *pProgress,UINT uMsg,WPARAM wParam,LPARAM lParam)
{
HWND hwndList = GetDlgItem(hwnd,IDC_LISTBOXERROR);
int iItems = ListBox_GetCount(hwndList);
int iCurItem;
MEASUREITEMSTRUCT measureItem;
RECT rect;

UINT horizExtent = 0;

    SendMessage(hwndList,WM_SETREDRAW,FALSE /*fRedraw */,0);

    GetClientRect(hwndList,&rect);

    for (iCurItem = 0 ; iCurItem < iItems; ++iCurItem)
    {
        measureItem.itemID = iCurItem;

        if (OnProgressResultsMeasureItem(hwnd,pProgress,&horizExtent, -1,&measureItem))
        {
            ListBox_SetItemHeight(hwndList, iCurItem, measureItem.itemHeight);
        }
    }
    //make sure there is a horizontal scroll bar if needed.
    SendMessage(hwndList, LB_SETHORIZONTALEXTENT, horizExtent, 0L);

    SendMessage(hwndList,WM_SETREDRAW,TRUE /*fRedraw */,0);

    InvalidateRect(hwndList,&rect,FALSE);

}

//--------------------------------------------------------------------------------
//
//  FUNCTION: ResultsListBoxWndProc(HWND hwnd, UINT uMsg,WPARAM wParam,LPARAM lParam)
//
//  PURPOSE:  Callback for Progress Dialog Update Tab
//
//	COMMENTS: Implemented on main thread.
//
//--------------------------------------------------------------------------------
INT_PTR CALLBACK ResultsListBoxWndProc(HWND hwnd, UINT uMsg,WPARAM wParam,LPARAM lParam)
{
CProgressDlg *pProgressDlg = (CProgressDlg *) GetWindowLongPtr(GetParent(hwnd), DWLP_USER);
                // OUR PARENT HAS A POINTER TO THE progress in dwl_user.

    switch (uMsg)
    {
    case WM_POWERBROADCAST:
	{
        DWORD dwRet = TRUE;

		if (wParam == PBT_APMQUERYSUSPEND)
		{
                // if just created or syncing don't suspend
                    if (pProgressDlg)
                    {

                        if ( (pProgressDlg->m_dwProgressFlags & PROGRESSFLAG_NEWDIALOG)
                            || (pProgressDlg->m_dwProgressFlags & PROGRESSFLAG_SYNCINGITEMS))
                        {
                            dwRet = BROADCAST_QUERY_DENY;
                        }
                    }

                    return dwRet;
                }


	}
	break;

    case WM_SETCURSOR:
        return TRUE; // rely on mousemove to set the cursor.
        break;
    case WM_MOUSEMOVE:
	{
		int index = ListBox_HitTest(hwnd, (LONG) LOWORD(lParam),(LONG) HIWORD(lParam));
		
		LBDATA *lbData =(LBDATA *) ListBox_GetItemData(hwnd, index);

		if (lbData)
                {
		    if ((index != -1) && (lbData->fIsJump))
		    {
			    SetCursor(LoadCursor(g_hInst,MAKEINTRESOURCE(IDC_HARROW)));
		    }
		    else
		    {
			    SetCursor(LoadCursor(NULL,IDC_ARROW));
		    }
                }
	}
	break;
    case WM_KEYDOWN:
    case WM_LBUTTONDBLCLK:
    case WM_LBUTTONDOWN:
    {
    int index = -1;
    LBDATA *lbData = NULL;
        // get index either through hittest of selection based on
        // if keydown or not.
        if (uMsg == WM_KEYDOWN)
        {
            if (VK_SPACE == ((int) wParam) )
            {
                index =  ListBox_GetCurSel(hwnd);
            }
            else
            {
                break; // don't mess with any other keys
            }

        }
        else
        {
            index = ListBox_HitTest(hwnd, (LONG) LOWORD(lParam),(LONG) HIWORD(lParam));
        }

        if (-1 != index)
        {
            lbData =(LBDATA *) ListBox_GetItemData(hwnd, index);
        }


        if ((lbData) && (lbData->fIsJump))
	{
		if (pProgressDlg)
		{
                    if (S_OK == pProgressDlg->OnShowError(lbData->pHandlerID,
				                         hwnd,
				                         lbData->ErrorID))
                    {
                        lbData->fHasBeenClicked = TRUE;
                        RedrawWindow(hwnd, NULL,NULL, RDW_INVALIDATE | RDW_UPDATENOW);
                    }

                return 0;
                }
        }
        break;
    }
    default:
	    break;
    }

    if (pProgressDlg && pProgressDlg->m_fnResultsListBox)
    {
        return CallWindowProc(pProgressDlg->m_fnResultsListBox, hwnd, uMsg, wParam, lParam);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\h\alloc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Alloc.h
//
//  Contents:   Allocation routines
//
//  Classes:
//
//  Notes:
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#ifndef _ONESTOPALLOC_
#define _ONESTOPALLOC_

inline void* __cdecl operator new (size_t size);
inline void __cdecl operator delete(void FAR* lpv);

extern "C" void __RPC_API MIDL_user_free(IN void __RPC_FAR * ptr);
extern "C" void __RPC_FAR * __RPC_API MIDL_user_allocate(IN size_t len);

LPVOID ALLOC(ULONG cb);
void FREE(void* pv);
DWORD REALLOC(void **ppv,ULONG cb);

#endif // _ONESTOPALLOC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\exe\reg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Reg.cpp
//
//  Contents:   Registration Routines
//
//  Classes:    
//
//  Notes:      
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"


//--------------------------------------------------------------------------------
//
//  FUNCTION: GetLastIdleHandler()
//
//  PURPOSE:  returns last handler synchronized on an Idle
//
//
//--------------------------------------------------------------------------------

STDMETHODIMP GetLastIdleHandler(CLSID *clsidHandler)
{
    HRESULT hr = E_UNEXPECTED;
    HKEY hkeyIdle;
    TCHAR szGuid[GUID_SIZE];
     
    // write out the Handler to the Registry.
    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, 
                            IDLESYNC_REGKEY, 0, NULL,
                            REG_OPTION_NON_VOLATILE, KEY_QUERY_VALUE, NULL, &hkeyIdle,
                            NULL))
    {
        DWORD dwDataSize;
        DWORD dwType;

        dwDataSize = sizeof(szGuid);
        dwType = REG_SZ;
        if (ERROR_SUCCESS != RegQueryValueEx(hkeyIdle, SZ_IDLELASTHANDLERKEY ,NULL, &dwType, (LPBYTE) szGuid, &dwDataSize))
        {
            hr = S_FALSE;
        }

        // Explicit NULL termination...
        szGuid[ARRAYSIZE(szGuid)-1] = 0;
        RegCloseKey(hkeyIdle);
    }
    else
    {
        hr = S_FALSE;
    }

    if (hr == S_FALSE)
    {
        return hr;
    }

    return CLSIDFromString(szGuid, clsidHandler);
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: SetLastIdleHandler()
//
//  PURPOSE:  sets the last handler synchronized on an Idle
//
//
//--------------------------------------------------------------------------------

STDMETHODIMP SetLastIdleHandler(REFCLSID clsidHandler)
{
    HRESULT hr = E_UNEXPECTED;
    HKEY hkeyIdle;
    TCHAR szGuid[GUID_SIZE];
    DWORD dwDataSize;
    
    if (0 == StringFromGUID2(clsidHandler, szGuid, ARRAYSIZE(szGuid)))
    {
        AssertSz(0,"SetLastIdleHandler Failed");
        return E_UNEXPECTED;
    }


    // write out the Handler to the Registry.
    if (ERROR_SUCCESS ==  RegCreateKeyEx(HKEY_CURRENT_USER, 
                            IDLESYNC_REGKEY,0,NULL,
                            REG_OPTION_NON_VOLATILE,KEY_WRITE,NULL,&hkeyIdle,
                            NULL))
    {
        dwDataSize = sizeof(szGuid);

        DWORD dwRet = RegSetValueEx(hkeyIdle,SZ_IDLELASTHANDLERKEY ,NULL, REG_SZ, (LPBYTE) szGuid, dwDataSize);
        hr = HRESULT_FROM_WIN32(dwRet);

        RegCloseKey(hkeyIdle);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\exe\winmain.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       OneStop.cpp
//
//  Contents:   Main application
//
//  Classes:
//
//  Notes:
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

// Global Variables:
HINSTANCE g_hInst = NULL;      // current instance
LANGID g_LangIdSystem;      // LangId of system we are running on.
DWORD g_WMTaskbarCreated; // TaskBar Created WindowMessage;

// Forward declarations of functions included in this code module:

BOOL InitApplication(HINSTANCE);
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow,CMsgServiceHwnd *pMsgService);
void UnitApplication();
BOOL SetupUserEnvironment();

//+---------------------------------------------------------------------------
//
//  Function:	WinMain, public
//
//  Synopsis:   The start of all things
//
//  Arguments:  Standard WinMain.
//
//  Returns:
//
//  Modifies:
//
//  History:    18-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

#ifdef _DEBUG
extern DWORD g_ThreadCount;
#endif // _DEBUG

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
    MSG msg;
    CMsgServiceHwnd *pMsgService;
    BOOL fMsgServiceCreated = FALSE;
    HRESULT hr;

    g_hInst = hInstance; // Store instance handle in our global variable

#ifdef _DEBUG
    InitDebugFlags();
#endif // _DEBUG

    InitCommonLib();

    g_LangIdSystem = GetSystemDefaultLangID();

    SetupUserEnvironment();

    if (!hPrevInstance) 
    {
        // Perform instance initialization:
        if (!InitApplication(hInstance)) 
        {
            return (FALSE);
        }
    }

    hr = CoInitializeEx(NULL,COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE); // main thread is freeThreaded
    if (FAILED(hr))
    {
        AssertSz(0,"CoInitFailed");
        return FALSE;
    }

    // Initialize the Message Service for all threads
    if (S_OK != InitMessageService())
    {
        AssertSz(0,"Unable to Init Message Service");
        return FALSE;
    }

    // crate a MessageService for main thread
    pMsgService = new CMsgServiceHwnd;
    if (pMsgService)
    {
        fMsgServiceCreated = pMsgService->Initialize(GetCurrentThreadId(),MSGHWNDTYPE_MAINTHREAD);
        Assert(fMsgServiceCreated);
    }

    if (fMsgServiceCreated && InitInstance(hInstance, nCmdShow,pMsgService))
    {
        // hAccelTable = LoadAccelerators (hInstance, APPNAME); // Currently don't have any accelerators

        // Main message loop:
        while (GetMessage(&msg, NULL, 0, 0))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    else
    {
        msg.wParam = 0;

        if (pMsgService) // get rid of this threads messageService
            pMsgService->Destroy();
    }

    UnitApplication();  // unitialize application.

    return (int)(msg.wParam);

    lpCmdLine; // This will prevent 'unused formal parameter' warnings
}

//+---------------------------------------------------------------------------
//
//  Function:	InitApplication, public
//
//  Synopsis:   Peforms any application specific tasks
//
//  Arguments:  [hInstance] - hInstance.
//
//  Returns:
//
//  Modifies:
//
//  History:    18-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL InitApplication(HINSTANCE hInstance)
{
    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:	UnitApplication, public
//
//  Synopsis:   Peforms any application specific cleanup
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    19-Jun-98      rogerg        Created.
//
//----------------------------------------------------------------------------

void  UnitApplication()
{
    ReleaseConnectionObjects(); // release global connection object class.

    gSingleNetApiObj.DeleteNetApiObj(); // get rid of globa NetObj

    Assert(g_ThreadCount == 0); // make sure all our threads are cleaned up.

    CoFreeUnusedLibraries();
    CoUninitialize();
    UnInitCommonLib();
}


//+---------------------------------------------------------------------------
//
//  Function:	InitInstance, public
//
//  Synopsis:   Peforms instance specific initialization
//
//  Arguments:  [hInstance] - hInstance.
//		[nCmdShow] - value to start windows as
//		[pMsgService] - Message service for this instance
//
//  Returns:    TRUE will put application into a message loop
//		FALSE will cause application to terminate immediately
//
//  Modifies:
//
//  History:    18-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL InitInstance(HINSTANCE hInstance, int nCmdShow,CMsgServiceHwnd *pMsgService)
{
    HRESULT hr;
    CCmdLine cmdLine;
    DWORD cmdLineFlags;
    BOOL fEmbeddingFlag;
    ATOM aWndClass;

    g_WMTaskbarCreated = RegisterWindowMessage(L"TaskbarCreated"); // get taskbar created message.

    cmdLine.ParseCommandLine();
    cmdLineFlags = cmdLine.GetCmdLineFlags();
    fEmbeddingFlag = cmdLineFlags & CMDLINE_COMMAND_EMBEDDING;

    // register a windows class to store the icon for the OneStop dialogs
    // get an icon for the dialog
    WNDCLASS wc;
    wc.style = CS_DBLCLKS | CS_SAVEBITS | CS_BYTEALIGNWINDOW;

    wc.lpfnWndProc = DefDlgProcW;

    // WRAPPER, need wrappers for LoadIcon/LoadCursor.
    wc.cbClsExtra = 0;
    wc.cbWndExtra = DLGWINDOWEXTRA;
    wc.hInstance = g_hInst;
    wc.hIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_SYNCMGR));
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH) (COLOR_WINDOW + 1);
    wc.lpszMenuName = NULL;
    wc.lpszClassName = TEXT(MAINDIALOG_HWNDCLASSNAME);

    aWndClass = RegisterClass(&wc);

    Assert(aWndClass);

    // if register flag is passed, just register and return.
    if (cmdLineFlags & CMDLINE_COMMAND_REGISTER)
    {
        AssertSz(0,"SyncMgr launched with obsolete /register flag.");
        return FALSE;
    }

    INITCOMMONCONTROLSEX controlsEx;
    controlsEx.dwSize = sizeof(INITCOMMONCONTROLSEX);
    controlsEx.dwICC = ICC_USEREX_CLASSES | ICC_WIN95_CLASSES | ICC_NATIVEFNTCTL_CLASS;
    InitCommonControlsEx(&controlsEx);

    hr = InitObjectManager(pMsgService); // Initialize Object manager
    if (S_OK != hr)
    {
        Assert(S_OK == hr);
        return FALSE;
    }

    hr = InitConnectionObjects(); // initialize connection objects.
    if (S_OK != hr)
    {
        Assert(S_OK == hr);
        return FALSE;
    }

    // If the embedding flag is set force a Register.
    // Review - Activate as Interactive user doesn't work for Logoff

    // don't register class factory for schedules or Idle since if an error occurs
    // we want TS to launch us again next time it is time for the
    // schedule to Fire.

    if (!(cmdLineFlags & CMDLINE_COMMAND_SCHEDULE) && !(cmdLineFlags & CMDLINE_COMMAND_IDLE))
    {
        hr = RegisterOneStopClassFactory(fEmbeddingFlag);
    }
    else
    {
        hr = S_OK;
    }

    // if didn't force a register then continue on our journey
    // and wait to fail until CoCreateInstance does

    Assert( (S_OK == hr) || !fEmbeddingFlag);

    if (S_OK == hr || !fEmbeddingFlag )
    {
        // if only /Embedding is specified we were launch to service someone else so
        // dont' do anything, just wait for them to connect.

        if (!fEmbeddingFlag)
        {
            LPPRIVSYNCMGRSYNCHRONIZEINVOKE pUnk;

            // If there are other command lines or known to the proper thing. (manual, schedule, etc.).
	
            // addref our lifetime in case update doesn't take, treat as external
            // since invoke can go to another process.
            AddRefOneStopLifetime(TRUE /*External*/);

            // if class factory registered successful then CoCreate
             
            if (SUCCEEDED(hr))
            {
                // CODE REVIEW:
                // NOTENOTE:
                //  Is this a valid use of CLSCTX_ALL ?
                hr = CoCreateInstance(CLSID_SyncMgrp,NULL,CLSCTX_ALL,IID_IPrivSyncMgrSynchronizeInvoke,(void **) &pUnk);
            }

            // if have failure either from class factory or CoCreateIntance
            // then create a class directlry.
	        if (FAILED(hr))
	        {
                // this is really an error path that shouldn't happen.
                // AssertSz(SUCCEEDED(hr),"COM Activation Failed");

                // If COM Activation Fails go ahead and create a class directly
                // unless it is a schedule or idle event.
                if ( !(cmdLineFlags & CMDLINE_COMMAND_SCHEDULE) && !(cmdLineFlags & CMDLINE_COMMAND_IDLE) )
                {
        		    pUnk = new CSynchronizeInvoke;
		            hr = pUnk ? S_OK : E_OUTOFMEMORY;

		            // Assert(S_OK == hr);
                }
	        }

	        if (S_OK == hr)
	        {
                AllowSetForegroundWindow(ASFW_ANY); // let mobsync.exe come to front if necessary

		        if (cmdLineFlags & CMDLINE_COMMAND_LOGON)
		        {
		            pUnk->Logon();
		        }
		        else if (cmdLineFlags & CMDLINE_COMMAND_LOGOFF)
		        {
		            pUnk->Logoff();
		        }
		        else if (cmdLineFlags & CMDLINE_COMMAND_SCHEDULE)
		        {
		            pUnk->Schedule(cmdLine.GetJobFile());
		        }
		        else if (cmdLineFlags & CMDLINE_COMMAND_IDLE)
		        {
		            pUnk->Idle();
		        }
		        else
		        {
		            // default is a manual sync
		            pUnk->UpdateAll();
		        }

    		    pUnk->Release();
            }
	        else
	        {
		        // AssertSz(0,"Unable to Create Invoke Instance");
	        }
	        
	        ReleaseOneStopLifetime(TRUE /*External*/); // Release our reference.
        }

        return TRUE; // even on failure return true, locking will take care of releasing object.
    }

    return (FALSE); // if couldn't forward the update then end.
}

//+---------------------------------------------------------------------------
//
//  Function:	SetupUserEnvironment,private
//
//  Synopsis:   Sets up any use environment variables we need to run.
//
//              When we are launched as interactive User by DCOM the
//              environment variables aren't set so we need to set
//              any up that us or the handlers rely on.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    14-Aug-98      rogerg        Created.
//
//----------------------------------------------------------------------------

#define SZ_ENVIRONVARIABLE_USERPROFILE TEXT("USERPROFILE")
#define SZ_ENVIRONVARIABLE_USERNAME TEXT("USERNAME")

BOOL SetupUserEnvironment()
{
    HANDLE  hToken = NULL;
    BOOL fValidToken;
    BOOL fSetEnviron = FALSE;
    BOOL fSetUserName = FALSE;

    // setup the User Profile Dir
    fValidToken = TRUE;
    if (!OpenThreadToken (GetCurrentThread(), TOKEN_READ,TRUE, &hToken))
    {
        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_READ, &hToken))
        {
            AssertSz(0,"Failed to GetToken");
            fValidToken = FALSE;
        }
    }

    if (fValidToken)
    {
        DWORD cbSize;

        // Call GetUserProfile once for Size and then again for real allocation
        cbSize = 0;
        GetUserProfileDirectory(hToken,NULL,&cbSize);

        if (cbSize > 0)
        {
            WCHAR *pwszProfileDir = (WCHAR *) ALLOC(cbSize*sizeof(WCHAR));

            if (pwszProfileDir && GetUserProfileDirectory(hToken,pwszProfileDir,&cbSize))
            {
                fSetEnviron = SetEnvironmentVariable(SZ_ENVIRONVARIABLE_USERPROFILE,pwszProfileDir);
            }

            if (pwszProfileDir)
            {
                FREE(pwszProfileDir);
            }
        }

        Assert(fSetEnviron); // assert if anything fails when we have a valid token

        CloseHandle(hToken);
    }

    // setup the UserName
    TCHAR szBuffer[UNLEN + 1];
    DWORD dwBufSize = ARRAYSIZE(szBuffer);

    if (GetUserName(szBuffer,&dwBufSize))
    {
	    fSetUserName = SetEnvironmentVariable(SZ_ENVIRONVARIABLE_USERNAME,szBuffer);
	    Assert(fSetUserName);
    }

    return (fSetEnviron && fSetUserName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\h\osdefine.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:	osdefine.h
//
//  Contents:	Generic header OneStop defines
//
//  History:	24-Oct-97	SusiA	Created
//
//----------------------------------------------------------------------------

#ifndef __OSDEFINE_H__
#define __OSDEFINE_H__


#define LVIS_STATEIMAGEMASK_CHECK (0x2000)
#define LVIS_STATEIMAGEMASK_UNCHECK (0x1000)

#define MAX_STRING_RES					64
#define MAX_ERR0R_ICONS					20
#define BULLET_INDENT					 2

#ifndef ILC_MIRROR
#define ILC_MIRROR              0x2000 
#endif // ILC_MIRROR

#endif __OSDEFINE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\h\netapi.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       netapi.h
//
//  Contents:   Network/SENS API wrappers
//
//  Classes:
//
//  Notes:
//
//  History:    08-Dec-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#ifndef _SYNCMGRNETAPI_
#define _SYNCMGRNETAPI_

#include <ras.h>
#include <raserror.h>
#include <wininet.h>

#ifndef AUTODIAL_MODE_NEVER
//
// Define constants for autodial mode that are present
// in IE5 and later. These are normally defined in wininet.h
//
#   define AUTODIAL_MODE_NEVER              1
#   define AUTODIAL_MODE_ALWAYS             2
#   define AUTODIAL_MODE_NO_NETWORK_PRESENT 4
#endif

#ifdef _SENS
#include <eventsys.h> // EventSystem Headers
#include <sens.h>
#endif // _SENS

#ifndef NETWORK_ALIVE_LAN
#define NETWORK_ALIVE_LAN   0x00000001
#endif // NETWORK_ALIVE_LAN

#ifndef NETWORK_ALIVE_WAN
#define NETWORK_ALIVE_WAN   0x00000002
#endif // NETWORK_ALIVE_WAN


#define CNETAPI_CONNECTIONTYPEUNKNOWN   0x00
#define CNETAPI_CONNECTIONTYPELAN       0x01
#define CNETAPI_CONNECTIONTYPEWAN       0x02

#define RASERROR_MAXSTRING 256


// interface delcaration so can get at
// NetApi through MobsyncGetClassObject

interface  INetApi : public IUnknown
{
    // SENS Methods
    virtual STDMETHODIMP_(BOOL) IsSensInstalled(void) = 0;
    virtual STDMETHODIMP_(BOOL) IsNetworkAlive(LPDWORD lpdwFlags) = 0;
    
    virtual STDMETHODIMP GetWanConnections(DWORD *cbNumEntries,RASCONN **pWanConnections) = 0;
    virtual STDMETHODIMP FreeWanConnections(RASCONN *pWanConnections) = 0;
    virtual STDMETHODIMP GetConnectionStatus(LPCTSTR pszConnectionName,DWORD ConnectionType,BOOL *fConnected,BOOL *fCanEstablishConnection) = 0;
    virtual STDMETHODIMP_(DWORD) RasEnumConnections(LPRASCONNW lprasconn,LPDWORD lpcb,LPDWORD lpcConnections) = 0;
    virtual STDMETHODIMP RasGetAutodial( BOOL& fEnabled ) = 0;
    virtual STDMETHODIMP RasSetAutodial( BOOL fEnabled ) = 0;
    virtual STDMETHODIMP_(DWORD) RasGetErrorStringProc( UINT uErrorValue, LPTSTR lpszErrorString,DWORD cBufSize) = 0;
    virtual STDMETHODIMP_(DWORD) RasEnumEntries(LPWSTR reserved,LPWSTR lpszPhoneBook,
                    LPRASENTRYNAME lprasEntryName,LPDWORD lpcb,LPDWORD lpcEntries) = 0;
  
    // methods for calling wininet
    virtual STDMETHODIMP_(DWORD) InternetDialA(HWND hwndParent,char* lpszConnectoid,DWORD dwFlags,
                                                    LPDWORD lpdwConnection, DWORD dwReserved) = 0;
    virtual STDMETHODIMP_(DWORD)InternetDialW(HWND hwndParent,WCHAR* lpszConnectoid,DWORD dwFlags,
                                                    LPDWORD lpdwConnection, DWORD dwReserved) = 0;
    virtual STDMETHODIMP_(DWORD)InternetHangUp(DWORD dwConnection,DWORD dwReserved) = 0;
    virtual STDMETHODIMP_(BOOL) InternetAutodial(DWORD dwFlags,DWORD dwReserved) = 0;
    virtual STDMETHODIMP_(BOOL) InternetAutodialHangup(DWORD dwReserved) = 0;
    virtual STDMETHODIMP  InternetGetAutodial( DWORD *pdwMode ) = 0;
    virtual STDMETHODIMP  InternetSetAutodial( DWORD dwMode ) = 0;
    virtual STDMETHODIMP_(BOOL) IsGlobalOffline(void) = 0;
    virtual STDMETHODIMP_(BOOL) SetOffline(BOOL fOffline) = 0;

};
typedef INetApi *LPNETAPI;

STDAPI ResetNetworkIdle();


#endif // _SYNCMGRNETAPI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\h\critsect.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       critsect.h
//
//  Contents:   critical section helper class
//
//  Classes:    CCriticalSection
//		CLockHandler
//		CLock
//		
//
//  Notes:      
//
//  History:    13-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------



#ifndef _CRITSECT_
#define _CRITSECT_

class CLock;

class CCriticalSection 
{
DWORD cRefs;
CRITICAL_SECTION *m_pcsect;
DWORD m_dwThreadID;

public:
    inline CCriticalSection(CRITICAL_SECTION *pcsect,DWORD dwThreadID)
    {	
	m_pcsect = pcsect;
	cRefs = 0;
	m_dwThreadID = dwThreadID;
    };


    inline ~CCriticalSection()
    {
	AssertSz(0 == cRefs,"UnReleased Critical Section");
	Assert(m_dwThreadID == GetCurrentThreadId());

	while(cRefs--) // unwind any left over cRefs
	{
	    LeaveCriticalSection(m_pcsect);
	}

    };

    inline void Enter()
    {
	EnterCriticalSection(m_pcsect);

	Assert(m_dwThreadID == GetCurrentThreadId());
	++cRefs;

	Assert(1 == cRefs); // we don't allow nested calls.
    };

    inline void Leave()
    {
	Assert(m_dwThreadID == GetCurrentThreadId());
	Assert(0 < cRefs);

	if (0 >= cRefs)
	    return;

	--cRefs;
	Assert(0 == cRefs);

	LeaveCriticalSection(m_pcsect);
    };

};


class CLockHandler {

public:
    CLockHandler();
    ~CLockHandler();

    void Lock(DWORD dwThreadId); 
    void UnLock();
    inline DWORD GetLockThreadId() { return m_dwLockThreadId; };

private:
    CRITICAL_SECTION m_CriticalSection; // critical section for the queue.
    DWORD m_dwLockThreadId; // thread that has the lock.

    friend CLock;
};


// helper class for making sure locks on the queue are released.
class CLock 
{
DWORD cRefs;
CLockHandler *m_pLockHandler;
DWORD m_dwThreadID;

public:
    inline CLock(CLockHandler *pLockHandler)
    {	
	m_pLockHandler = pLockHandler;
	cRefs = 0;
	m_dwThreadID = GetCurrentThreadId();
    };


    inline ~CLock()
    {
	AssertSz(0 == cRefs,"UnReleased Lock");
	Assert(m_dwThreadID == GetCurrentThreadId());

	while(cRefs--) // unwind any left over cRefs
	{
	    m_pLockHandler->UnLock();
	}

    };

    inline void Enter()
    {
	Assert(m_dwThreadID == GetCurrentThreadId());

	++cRefs;
	Assert(1 == cRefs); // we don't allow nested calls.
	m_pLockHandler->Lock(m_dwThreadID);
    };

    inline void Leave()
    {
	Assert(m_dwThreadID == GetCurrentThreadId());
	Assert(0 < cRefs);

	if (0 >= cRefs)
	    return;

	--cRefs;
	Assert(0 == cRefs);
	m_pLockHandler->UnLock();

    };

};


#define ASSERT_LOCKHELD(pLockHandler) Assert(pLockHandler->GetLockThreadId() == GetCurrentThreadId());
#define ASSERT_LOCKNOTHELD(pLockHandler) Assert(pLockHandler->GetLockThreadId() == 0);

// helper class for Mutex locking

class CMutex 
{
HANDLE m_hMutex;
BOOL m_fHasLock;
BOOL m_fReleasedLock;

public:
    inline CMutex(LPSECURITY_ATTRIBUTES lpMutexAttributes,BOOL bInitialOwner,LPCTSTR lpName)
    {	
	 m_hMutex = CreateMutex(lpMutexAttributes,bInitialOwner,lpName);

         // on failure routines go on just don't take the lock

         m_fHasLock = FALSE;
         m_fReleasedLock = FALSE;
    };


    inline ~CMutex()
    {
	AssertSz(!m_fHasLock,"UnReleased Mutex ");

        // if failed to release mutex release now.
        if (m_hMutex && m_fHasLock)
        {
	    ReleaseMutex(m_hMutex);
        }        
        if (m_hMutex)
        {
            CloseHandle(m_hMutex);
        }
    };

    inline void Enter(DWORD dwMilliseconds = INFINITE)
    {
	AssertSz(!m_fHasLock,"Tried to take Lock Twice");
        AssertSz(!m_fReleasedLock,"Tried to take lock After Released Mutex");

        if (!m_fHasLock && m_hMutex)
        {
            if (WAIT_OBJECT_0 ==WaitForSingleObject( m_hMutex, dwMilliseconds ))
            {
                m_fHasLock = TRUE;
            }
        }
    
    };

    inline void Leave()
    {
        Assert(m_fHasLock);

        if (m_fHasLock && m_hMutex)
        {
	    ReleaseMutex(m_hMutex);
        }
        
        if (m_hMutex)
        {
            CloseHandle(m_hMutex);
        }
        m_hMutex = NULL;
        m_fHasLock = FALSE;
        m_fReleasedLock = TRUE;

    };


};



#endif // _CRITSECT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\h\listview.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       listview.h
//
//  Contents:   Implements Mobsync Custom Listview/TreeView control
//
//  Classes:    CListView
//
//  Notes:
//
//  History:    23-Jul-98   rogerg      Created.
//
//--------------------------------------------------------------------------

#ifndef _MOBSYNCLISTVIEW_
#define _MOBSYNCLISTVIEW_

/*

    wraps standard ListView control so can do TreeView like operations.

    ItemdId still refers to linear location in the ListView independent
    of who many levels deep the item is 

      Item                          itemID
    toplevel1                           0
        child1                          1
        child2                          2
    toplevel2                           3

    This works fine except causes some confusion on insert. On an insert

    if the LVIFEX_PARENT flag isn't set the item is inserted as it always was
    and indent is the same as the item is is inserted after. For example, if
    if was inserted after toplevel1 it would be a toplevel item. If it was inserted
    after child1 is would be another child of toplevel1

    if the LVIFEX_PARENT flag is set the item is inserted as a child of iParent.
    if the client specified LVI_FIRST, LVI_LAST the item is inserted a first or
    last child. if a normal itemId is specified then it must fall within a valid 
    range to be the specified parents child or the inser fails.

    For example, if I specified a parent of TopLevel1 an itemID of 1,2 or 3 would be valid.
    a vlue of 4 would not be since it would fall outside the child range for toplevel1
*/

#define LVI_ROOT    -1 // itemID to pass in for ParenItemID for root
#define LVI_FIRST   -0x0FFFE
#define LVI_LAST    -0x0FFFF

// The blob field is for perf so a user of the listview doesn't have to
// enumerate, getting the lParam or storing its own lookup for an item.
// when a blob is added the listview makes its own copy and automatically
// frees it when the item is deleted. The blob field is not allowed on subitems.

// define blob structure that app can set and listview 
typedef struct _tagLVBLOB
{
    ULONG cbSize;   // size of the blob struture. !!!Include cbSize itself.
    BYTE  data[1];
} LVBLOB;
typedef LVBLOB* LPLVBLOB;

// state flags for ListView Item check,uncheck conform to real ListView others are our own defines.

// #define LVIS_STATEIMAGEMASK_UNCHECK (0x1000)
// #define LVIS_STATEIMAGEMASK_CHECK (0x2000)

typedef enum _tagLVITEMEXSTATE
{
    // mutually exclusive 
    LVITEMEXSTATE_UNCHECKED		= 0x0000, 
    LVITEMEXSTATE_CHECKED		= 0x0001, 
    LVITEMEXSTATE_INDETERMINATE		= 0x0002, 

} LVITEMSTATE;

// extended flags 
#define LVIFEX_PARENT          0x0001  
#define LVIFEX_BLOB            0x0002

#define LVIFEX_VALIDFLAGMASK   0x0003

// make private LVITEM structure,
// Blob is only allowed on a insert and set.
// parent is only allowed on insert
typedef struct _tagLVITEMEX
{
   // original listviewItem Structure
    UINT mask;
    int iItem;
    int iSubItem;
    UINT state;
    UINT stateMask;
    LPWSTR pszText;
    int cchTextMax;
    int iImage;
    LPARAM lParam;
    int iIndent; // need to add indent to depth

    // new item methods that we need.
    UINT maskEx;
    int iParent;     // set LVIFEX_PARENT maskEx when this field valid. If not LVI_ROOT is assumed.
    LPLVBLOB pBlob;  // set LVIFEX_BLOB maskEx when this field is valid. Currently not returned on a GetItem.
} LVITEMEX, *LPLVITEMEX;

// notification structures for this listview First fields are identical to real listView

typedef struct tagNMLISTVIEWEX{  
    NMLISTVIEW nmListView;

    // specific notification items
    int iParent;     
    LPLVBLOB pBlob;  
} NMLISTVIEWEX, *LPNMLISTVIEWEX;


typedef struct tagNMLISTVIEWEXITEMCHECKCOUNT{  
    NMHDR hdr;;

    // specific notification items
    int iCheckCount;   // new checkCount 
    int iItemId; // ItemIds who checkCount was changed.
    LVITEMSTATE dwItemState; // new state of the item whose checkcount has changed.
} NMLISTVIEWEXITEMCHECKCOUNT, *LPNMLISTVIEWEXITEMCHECKCOUNT;



// notification codes we wrap
#define LVNEX_ITEMCHANGED       LVN_ITEMCHANGED
#define LVNEX_DBLCLK            NM_DBLCLK
#define LVNEX_CLICK             NM_CLICK

// notificaiton codes we send
#define LVNEX_ITEMCHECKCOUNT  (LVN_LAST + 1)  // lparam contains number of items selected in the ListView.

// #define INDEXTOSTATEIMAGEMASK(i) ((i) << 12) (Macro from commctrl.h usefull for setting state)


// itemID is just how far into the list an item is.  We keep a flat list of 
// of items in the same order they are displayed in the ListView. 

// have parent, children pointers just for optimization, Review if really need when done implimenting.
typedef struct _tagListViewItem
{
    // vars for keeping track of tree view status
    struct _tagListViewItem *pSubItems; // ptr to array of subItems for ListView Row.

    // internal vars
    BOOL fExpanded; // true if children are expanded
    int iChildren; // Number of children this node has.

    // native ListView structure and Item
    int iNativeListViewItemId;    // id of Item in acutal listView - If not shown it is set to -1
    LVITEMEX lvItemEx;  // current lvItemEx state for this item
} LISTVIEWITEM;
typedef LISTVIEWITEM* LPLISTVIEWITEM;


class CListView
{
public:
    
    CListView(HWND hwnd,HWND hwndParent,int idCtrl,UINT MsgNotify); // contructor gives in ptr to the listView.
    ~CListView(); 

    // wrappers for top-level ListView calls
    BOOL DeleteAllItems();
    int GetItemCount(); // returns total number of items in the listview.
    UINT GetSelectedCount();
    int GetSelectionMark();
    HIMAGELIST GetImageList(int iImageList);
    HIMAGELIST SetImageList(HIMAGELIST himage,int iImageList);
    void SetExtendedListViewStyle(DWORD dwExStyle); // !!Handle checkboxes ourselves.

    // wrappers for basic listviewItem calls that we support
    // ids are given from our list, not the true ListView id.

    BOOL InsertItem(LPLVITEMEX pitem); 
    BOOL DeleteItem(int iItem);
    BOOL DeleteChildren(int iItem);

    BOOL SetItem(LPLVITEMEX pitem);    
    BOOL SetItemlParam(int iItem,LPARAM lParam);
    BOOL SetItemState(int iItem,UINT state,UINT mask);
    BOOL SetItemText(int iItem,int iSubItem,LPWSTR pszText);

    BOOL GetItem(LPLVITEMEX pitem);    
    BOOL GetItemText(int iItem,int iSubItem,LPWSTR pszText,int cchTextMax);    
    BOOL GetItemlParam(int iItem,LPARAM *plParam);    

    HWND GetHwnd();
    HWND GetParent();
    
    // really helper function for generic set/getitem calls.
    int GetCheckState(int iItem); // return state from LVITEMEXSTATE enum.
    int GetCheckedItemsCount(); // returns the number of checked items. 

    // wrapper for ListView Column Calls
    BOOL SetColumn(int iCol,LV_COLUMN * pColumn);
    int InsertColumn(int iCol,LV_COLUMN * pColumn);
    BOOL SetColumnWidth(int iCol,int cx);
    
    // TreeView like calls

    BOOL Expand(int iItemId);  // expand children of this item,
    BOOL Collapse(int iItemId); // collapse children of this item, 

    // helper functions not impl in either standard ListView or TreeView control
    int FindItemFromBlob(LPLVBLOB pBlob); // returns first toplevel item in list that matches blob
    LPLVBLOB GetItemBlob(int ItemId,LPLVBLOB pBlob,ULONG cbBlobSize);

    // notification method client must call when receives native listview notification
    LRESULT OnNotify(LPNMHDR pnmv); 

private:
    HWND m_hwnd;
    HWND m_hwndParent;
    int m_idCtrl;
    UINT m_MsgNotify;
    LPLISTVIEWITEM m_pListViewItems;        // ptr to the array of listview Items.
    int m_iListViewNodeCount;               // total number of nodes in the listView (Doesn't include SubItems
    int m_iListViewArraySize;               // number of elements allocated in listViewItems array
    int m_iNumColumns;                      // number of columns for this listView
    int m_iCheckCount;                      // not of checked items in the ListView (Does not include indeterminate
    DWORD m_dwExStyle;                      // Extendend Style for this ListView

private:
    LPLISTVIEWITEM ListViewItemFromNativeListViewItemId(int iNativeListViewItemId); // returns ptr to ListViewItem from native ListView ID.
    LPLISTVIEWITEM ListViewItemFromNativeListViewItemId(int iNativeListViewItemId,int iSubItem); // returns ptr to ListViewItem from native ListView ID.
    LPLISTVIEWITEM ListViewItemFromIndex(int iItemID);  //  returns ptr to ListViewItem from internal list.
    LPLISTVIEWITEM ListViewItemFromIndex(int iItemID,int iSubitem,int *piNativeListViewItemId);
    void DeleteListViewItemSubItems(LPLISTVIEWITEM pListItem);
    BOOL ExpandCollapse(LPLISTVIEWITEM pListViewItem,BOOL fExpand);
    BOOL IsEqualBlob(LPLVBLOB pBlob1,LPLVBLOB pBlob2);
    void OnGetDisplayInfo(UINT code,LV_DISPINFO *plvdi);
    BOOL   OnHandleUIEvent(UINT code,UINT flags,WORD wVKey,int iItemNative);

};

#endif // _MOBSYNCLISTVIEW_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\h\validate.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       validate.h
//
//  Contents:   validation routines
//
//  Classes:
//
//  Notes:
//
//  History:    13-Aug-98   rogerg      Created.
//
//--------------------------------------------------------------------------

#ifndef _MOBSYNCVALIDATE_
#define _MOBSYNCVALIDATE_

BOOL IsValidSyncMgrItem(SYNCMGRITEM *poffItem);
BOOL IsValidSyncMgrHandlerInfo(LPSYNCMGRHANDLERINFO pSyncMgrHandlerInfo);
BOOL IsValidSyncProgressItem(LPSYNCMGRPROGRESSITEM lpProgItem);
BOOL IsValidSyncLogErrorInfo(DWORD dwErrorLevel,const WCHAR *lpcErrorText,
                                        LPSYNCMGRLOGERRORINFO lpSyncLogError);

#endif // _MOBSYNCVALIDATE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\h\clsobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       clsobj.h
//
//  Contents:  header MobsyncGetClassObject.
//
//  Classes:
//
//  Notes:
//
//  History:    04-Aug-98   rogerg      Created.
//
//--------------------------------------------------------------------------

#ifndef _MOBSYNC_CLASSOBJ
#define MOBSYNC_CLASSOBJ

typedef enum _tagMOBSYNC_CLASSOBJECTID
{
    MOBSYNC_CLASSOBJECTID_NETAPI        = 0x01,


} MOBSYNC_CLASSOBJECTID;

STDAPI MobsyncGetClassObject(ULONG mobsyncClassObjectId,void **pCObj);


#endif // MOBSYNC_CLASSOBJ
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\h\debug.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Debug.h
//
//  Contents:   Debug Routines
//
//  Classes:
//
//  Notes:
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#ifndef _ONESTOPDEBUG_
#define _ONESTOPDEBUG_


#define _SENS 1

#if (DBG == 1)
#undef DEBUG
#undef _DEBUG

#define DEBUG 1
#define _DEBUG 1

#endif // DGB

#define ErrJmp(label, errval, var) \
{\
    var = errval;\
    goto label;\
}
#define smBoolChk(e) if (!(e)) {return FALSE;} else 1

#define smErr(l, e) ErrJmp(l, e, sc)
#define smChkTo(l, e) if (ERROR_SUCCESS != (sc = (e))) smErr(l, sc) else 1
#define smChk(e) smChkTo(EH_Err, e)
#define smMemTo(l, e) \
    if ((e) == NULL) smErr(l, E_OUTOFMEMORY) else 1
#define smMem(e) smMemTo(EH_Err, e)

#if DEBUG

STDAPI_(void) InitDebugFlags(void);
STDAPI FnAssert( LPSTR lpstrExpr, LPSTR lpstrMsg, LPSTR lpstrFileName, UINT iLine );
STDAPI FnTrace(LPSTR lpstrMsg, LPSTR lpstrFileName, UINT iLine );

#undef Assert
#undef AssertSz
#define Assert(a) { if (!(a)) FnAssert(#a, NULL, __FILE__, __LINE__); }
#define AssertSz(a, b) { if (!(a)) FnAssert(#a, b, __FILE__, __LINE__); }

#undef TRACE
#define TRACE(s)  /* FnTrace(s,__FILE__,__LINE__) */ // tracing isn't turned on by default


#else // !DEBUG

#define Assert(a)
#define AssertSz(a, b)

#define TRACE(s)

#endif  // DEBUG


#endif // _ONESTOPDEBUG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\h\stringc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       stringc.h
//
//  Contents:   SyncMgr string constants
//
//  History:    18-Feb-98   SusiA      Created.
//
//--------------------------------------------------------------------------

#ifndef _LIB_STRINGC_
#define _LIB_STRINGC_

extern "C" { 
extern const WCHAR SZ_SYNCMGRNAME[];

extern const WCHAR REGSTR_WINLOGON[];    
extern const WCHAR REGSTR_DEFAULT_DOMAIN[];  

extern const WCHAR CREATOR_SYNCMGR_TASK[];
extern const WCHAR SCHED_COMMAND_LINE_ARG[];

// registration constants. should be able to move to dll string constants
// if write wrapper class for preference access instead of exe reading these
// keys directly.

extern const WCHAR TOPLEVEL_REGKEY[];

extern const WCHAR HANDLERS_REGKEY[];
extern const WCHAR AUTOSYNC_REGKEY[];
extern const WCHAR IDLESYNC_REGKEY[];
extern const WCHAR SCHEDSYNC_REGKEY[];
extern const WCHAR MANUALSYNC_REGKEY[];
extern const WCHAR PROGRESS_REGKEY[];

extern const WCHAR SZ_IDLELASTHANDLERKEY[];
extern const WCHAR SZ_IDLERETRYMINUTESKEY[];
extern const WCHAR SZ_IDLEDELAYSHUTDOWNTIMEKEY[];
extern const WCHAR SZ_IDLEREPEATESYNCHRONIZATIONKEY[];
extern const WCHAR SZ_IDLEWAITAFTERIDLEMINUTESKEY[];
extern const WCHAR SZ_IDLERUNONBATTERIESKEY[];

extern const WCHAR SZ_REGISTRATIONFLAGSKEY[];
extern const WCHAR SZ_REGISTRATIONTIMESTAMPKEY[];

extern const WCHAR SZ_DEFAULTDOMAINANDUSERNAME[];
};

#endif // _LIB_STRINGC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\lib\lib.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       lib.h
//
//  Contents:   contains headers needed to build the lib project
//
//  Classes:
//
//  Notes:
//
//  History:    04-Aug-98   rogerg      Created.
//
//--------------------------------------------------------------------------

// standard includes for  MobSync lib

#include <objbase.h>
#include <windows.h>
#include <shellapi.h>
#include <commctrl.h>
#include <inetreg.h>
#include <sensapip.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#include "mobsync.h"
#include "mobsyncp.h"

#include "debug.h"
#include "alloc.h"
#include "critsect.h"
#include "stringc.h"
#include "osdefine.h"

#include "validate.h"
#include "netapi.h"
#include "listview.h"
#include "util.hxx"
#include "clsobj.h"

#include "shlwapi.h"
#include "sddl.h"



#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\lib\netapi.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       netapi.cpp
//
//  Contents:   Network/SENS API wrappers
//
//  Classes:
//
//  Notes:
//
//  History:    08-Dec-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "lib.h"

//+---------------------------------------------------------------------------
//
//  Function:   ResetNetworkIdle, public
//
//  Synopsis:   post messages to wininet to keep wininet connection
//          from thinking it is idle so the connection isn't closed
//          in the middle of a sync.
//
//          Code supplied by Darren Mitchell.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    01-June-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI ResetNetworkIdle()
{
#define WM_DIALMON_FIRST        WM_USER+100
#define WM_WINSOCK_ACTIVITY     WM_DIALMON_FIRST + 0

    // Inform dial monitor that stuff is going on to keep it from
    // hanging up any idle connections.
    HWND hwndMonitorWnd = FindWindow(TEXT("MS_AutodialMonitor"),NULL);
    if (hwndMonitorWnd)
    {
        PostMessage(hwndMonitorWnd,WM_WINSOCK_ACTIVITY,0,0);
    }

    hwndMonitorWnd = FindWindow(TEXT("MS_WebcheckMonitor"),NULL);
    if (hwndMonitorWnd)
    {
        PostMessage(hwndMonitorWnd,WM_WINSOCK_ACTIVITY,0,0);
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\lib\makefile.inc ===
SENSDIR = ..\..\SENS\CONN\IDL

$(O)\notify.idl : $(SENSDIR)\notify.idl
        copy $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\lib\listview.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       listview.cpp
//
//  Contents:   Implements Mobsync Custom Listview/TreeView control
//
//  Classes:    CListView
//
//  Notes:
//
//  History:    23-Jul-98   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "lib.h"

//+---------------------------------------------------------------------------
//
//  Member:     CListView::CListView, public
//
//  Synopsis:   Constructor
//
//  Arguments:  hwnd - hwnd of the listView we are wrapping
//              hwndParent - Parent for this HWND.
//              idCtrl - ControlID for this item
//              msgNotify - messageID to use for sending notifyCommand to the Parent.
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

CListView::CListView(HWND hwnd,HWND hwndParent,int idCtrl,UINT MsgNotify)
{
    Assert(hwnd);

    m_hwnd = hwnd;
    m_hwndParent = hwndParent; // if parent null we just don't send notify messages
    m_idCtrl = idCtrl;
    m_MsgNotify = MsgNotify;

    m_pListViewItems = NULL;
    m_iListViewNodeCount = 0;
    m_iListViewArraySize = 0;
    m_iNumColumns = 0;
    m_iCheckCount = 0;
    m_dwExStyle = 0;

    // Up to caller to setup listView as OwnerData
    Assert(GetWindowLongA(m_hwnd,GWL_STYLE) & LVS_OWNERDATA);
    ListView_SetCallbackMask(m_hwnd, LVIS_STATEIMAGEMASK); // set for checkmark

}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::~CListView, public
//
//  Synopsis:   Constructor
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

CListView::~CListView()
{
    DeleteAllItems();
}




//+---------------------------------------------------------------------------
//
//  Member:     CListView::DeleteAllItems, public
//
//  Synopsis:   Removes all items from the ListView
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CListView::DeleteAllItems()
{
BOOL fReturn;

    fReturn = ListView_DeleteAllItems(m_hwnd);

    if (fReturn)
    {
        if (m_iListViewNodeCount)
        {
        LPLISTVIEWITEM pListViewCurItem;       

            Assert(m_pListViewItems);

            // loop through the listview items deleting any subitems
            pListViewCurItem = m_pListViewItems + m_iListViewNodeCount -1;

            while(pListViewCurItem >= m_pListViewItems)
            {
                if(pListViewCurItem->pSubItems)
                {
                    DeleteListViewItemSubItems(pListViewCurItem);
                }

                if (pListViewCurItem->lvItemEx.pszText)
                {
                    Assert(LVIF_TEXT & pListViewCurItem->lvItemEx.mask);
                    FREE(pListViewCurItem->lvItemEx.pszText);
                }

                if (pListViewCurItem->lvItemEx.pBlob)
                {
                    Assert(LVIFEX_BLOB & pListViewCurItem->lvItemEx.maskEx);
                    FREE(pListViewCurItem->lvItemEx.pBlob);
                }

                pListViewCurItem--;
            }

            m_iListViewNodeCount = 0;
        }

        // free our item buffer
        if (m_pListViewItems)
        {
            FREE(m_pListViewItems);
            m_pListViewItems = NULL;
            m_iListViewArraySize = 0;
        }

        m_iCheckCount = 0;
    }

    return fReturn;
}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::GetItemCount, public
//
//  Synopsis:   returns total number of items in the listview.
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

int CListView::GetItemCount()
{
    return m_iListViewNodeCount;
}


//+---------------------------------------------------------------------------
//
//  Member:     CListView::GetSelectedCount, public
//
//  Synopsis:   returns number of selected items from the listview
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

UINT CListView::GetSelectedCount()
{
    Assert(m_hwnd);

    return ListView_GetSelectedCount(m_hwnd);
}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::GetSelectionMark, public
//
//  Synopsis:   returns index of the selection mark
//
//  Arguments:  
//
//  Returns:    itemId of the selection
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

int CListView::GetSelectionMark()
{
int iNativeListViewId; 
int iReturnItem = -1;
LPLISTVIEWITEM pListViewItem;

    Assert(m_hwnd);

    iNativeListViewId =  ListView_GetSelectionMark(m_hwnd);

    if (-1 != iNativeListViewId)
    {
        pListViewItem = ListViewItemFromNativeListViewItemId(iNativeListViewId);

        if (pListViewItem)
        {   
            iReturnItem = pListViewItem->lvItemEx.iItem;

            Assert(pListViewItem->iNativeListViewItemId == iNativeListViewId);
        }
    }

    return iReturnItem;
}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::GetImageList, public
//
//  Synopsis:   returns specified imagelist 
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

HIMAGELIST CListView::GetImageList(int iImageList)
{
    Assert(m_hwnd);
    return ListView_GetImageList(m_hwnd,iImageList);
}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::SetImageList, public
//
//  Synopsis:   sets specified imagelist 
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

HIMAGELIST CListView::SetImageList(HIMAGELIST himage,int iImageList)
{
    Assert(m_hwnd);
    return ListView_SetImageList(m_hwnd,himage,iImageList);
}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::SetExtendedListViewStyle, public
//
//  Synopsis:   sets the list view style
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CListView::SetExtendedListViewStyle(DWORD dwExStyle)
{
    // !!Handle checkboxes ourselves.
    // AssertSz(0,"impl extended style with checkboxes");
    
    Assert(m_hwnd);
    ListView_SetExtendedListViewStyle(m_hwnd,dwExStyle);
    m_dwExStyle = dwExStyle;
}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::InsertItem, public
//
//  Synopsis:   wrapper for ListView_InsertItem
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CListView::InsertItem(LPLVITEMEX pitem)
{
LPLISTVIEWITEM pNewListViewItem = NULL;
LPLISTVIEWITEM pListViewSubItems = NULL;
LPWSTR pszText = NULL;
LPLVBLOB pBlob = NULL;
int iListViewIndex; // location item will be inserted
int iParentIndex = LVI_ROOT;
BOOL fInsertNative = FALSE;
int iIndent = 0; // indent for the item.
int iNativeInsertAtItemID = -1;
    
    // Cannot use insert to add a subitem
    // and need at least one column
    if (0 != pitem->iSubItem || (0 == m_iNumColumns))
    {
        Assert(0 != m_iNumColumns);
        Assert(0 == pitem->iSubItem);
        goto error;
    }


    Assert(0 == (pitem->maskEx & ~(LVIFEX_VALIDFLAGMASK)));

    // if a parent is specified check for special flags and
    // calc iItem or determine given iItem is invalid
    // #define LVI_ROOT    -1; // itemID to pass in for ParenItemID for root
    // #define LVI_FIRST   -0x0FFFE
    // #define LVI_LAST    -0x0FFFF

    // While validatin Determine if item should be immediately added to the listview
    // by a) if has parent that is expanded and has an assigned listviewID
    // or b) this is a toplevel item.
    // this is done when validating the itemID and setting the fInsertNative var

   LPLISTVIEWITEM pParentItem;
   LISTVIEWITEM lviRootNode;
    
    // if have a valid parent look it up else use the root

    if ((LVIFEX_PARENT & pitem->maskEx) && !(LVI_ROOT == pitem->iParent) )
    {
         pParentItem = ListViewItemFromIndex(pitem->iParent);
    }
    else
    {
        pParentItem = &lviRootNode;

        lviRootNode.lvItemEx.iItem = LVI_ROOT;
        lviRootNode.lvItemEx.iIndent = -1;
        lviRootNode.fExpanded = TRUE;
    }

        
    if (NULL == pParentItem)
    {
        Assert(NULL != pParentItem);
        goto error;
    }

    // found parent so go ahead and set the iIndent
    iParentIndex = pParentItem->lvItemEx.iItem;
    iIndent = pParentItem->lvItemEx.iIndent + 1;
    fInsertNative = pParentItem->fExpanded;

    // if LVI_FIRST for item then parent item + 1
    // else we need to find either the next node
    // at the same level as the parent or hit the 
    // end of the list.
    if (LVI_FIRST == pitem->iItem)
    {
        iListViewIndex = pParentItem->lvItemEx.iItem + 1;
    }
    else
    {
    int iNextParentiItem = -1;
    LPLISTVIEWITEM pNextParent = pParentItem + 1;
    LPLISTVIEWITEM pLastItem = m_pListViewItems + m_iListViewNodeCount -1;

        // if parent is the root node then skip since know Nextparent is the
        // last node. 

        if (pParentItem != &lviRootNode)
        {
            // calc of last item assumes have at least one node
            // if we don't then how can we have a parent?
            if (m_iListViewNodeCount < 1)
            {
                goto error;
            }

            while (pNextParent <= pLastItem)
            {
                if (pNextParent->lvItemEx.iIndent == pParentItem->lvItemEx.iIndent)
                {
                    iNextParentiItem = pNextParent->lvItemEx.iItem;
                    break;
                }

                ++pNextParent;
            }
        }

        // if out of loop and NexParentItem is still -1 means hit the 
        // end of list
        if (-1 == iNextParentiItem)
        {
            if (m_iListViewNodeCount)
            {
                iNextParentiItem = pLastItem->lvItemEx.iItem + 1;
            }
            else
            {
                iNextParentiItem = 0;
            }
        }
      

        if (LVI_LAST == pitem->iItem)
        {
            iListViewIndex = iNextParentiItem;
        }
        else
        {
            // if user specified theitem it better fall within a valid range.
            if (pitem->iItem > iNextParentiItem ||
                    pitem->iItem <= pParentItem->lvItemEx.iItem)
            {
                Assert(pitem->iItem <= iNextParentiItem);
                Assert(pitem->iItem > pParentItem->lvItemEx.iItem);

                goto error;
            }

            iListViewIndex =  pitem->iItem;
        }

    }

    // make sure buffer is big enough
    // !!! Warning any pointers items in the ListView Array
    // will be invalid after the realloc/alloc.
    if (m_iListViewArraySize < (m_iListViewNodeCount + 1))
    {
    int iNewArraySize = m_iListViewNodeCount + 10;
    LPLISTVIEWITEM pListViewItemsOrig = m_pListViewItems;
    ULONG cbAlloc = iNewArraySize*sizeof(LISTVIEWITEM);

        if (m_pListViewItems)
        {
            if (ERROR_SUCCESS != REALLOC((void **)&m_pListViewItems, cbAlloc))
            {
                FREE(m_pListViewItems);
                m_pListViewItems = NULL;
            }
        }        
        else
        {
            m_pListViewItems = (LPLISTVIEWITEM) ALLOC(cbAlloc);
        }

        // if couldn't alloc or realloc failed then fail the insert
        if (NULL == m_pListViewItems)
        {
            m_pListViewItems = pListViewItemsOrig;
            goto error;
        }

        m_iListViewArraySize = iNewArraySize;
    }
    
    Assert(m_pListViewItems);
    if (NULL == m_pListViewItems)
    {
        goto error;
    }

    // if have subitems make sure we can allocate the subitems before
    // moving all the nodes. This is number of columns minus one since
    // column offset 0 is stored in main array 

    pListViewSubItems = NULL;
    if (m_iNumColumns > 1)
    {
    ULONG ulAllocSize = (m_iNumColumns -1)*sizeof(LISTVIEWITEM);
    int iSubItem;
    LPLISTVIEWITEM pCurSubItem;

        pListViewSubItems = (LPLISTVIEWITEM) ALLOC(ulAllocSize);

        if (NULL == pListViewSubItems)
        {
            goto error;
        }

        pCurSubItem = pListViewSubItems;
        iSubItem = 1;

        while (iSubItem < m_iNumColumns)
        {
            pCurSubItem->lvItemEx.iItem = iListViewIndex;
            pCurSubItem->lvItemEx.iSubItem = iSubItem;

            ++iSubItem;
            ++pCurSubItem;
        }
            
    }

    // make sure can allocate text and anything else
    // that can faile if need to before move
    // everything down so don't have to undo.

    if (pitem->mask & LVIF_TEXT)
    {
    int cchSize;

        if (NULL == pitem->pszText)
        {
            pszText = NULL;
        }
        else
        {
        
            cchSize = (lstrlen(pitem->pszText) + 1);

            pszText = (LPWSTR) ALLOC(cchSize * sizeof(WCHAR));

            if (NULL == pszText)
            {
                goto error;
            }

            StrCpyN(pszText, pitem->pszText, cchSize);
        }
    }

    if (pitem->maskEx & LVIFEX_BLOB)
    {
    ULONG cbSize;

        if (NULL == pitem->pBlob)
        {
            Assert(pitem->pBlob);
            goto error;
        }
        
        cbSize = pitem->pBlob->cbSize;
        pBlob =  (LPLVBLOB) ALLOC(cbSize);
        if (NULL == pBlob)
        {
            goto error;
        }
        
        memcpy(pBlob,pitem->pBlob,cbSize);

    }

    // !!!Nothing should fail after this line other than possibly
    // inserting into the Native ListView in which case 
    // it will still be in our list but not shown to the User.


    // Move existing elements down that item is inserted ahead of.
    // if the item is going to be immediately added to the ListView then 
     pNewListViewItem = m_pListViewItems + iListViewIndex;
    if (m_iListViewNodeCount)
    {
    LPLISTVIEWITEM pListViewMoveItem;

        pListViewMoveItem = m_pListViewItems + m_iListViewNodeCount -1;
        Assert(m_iListViewArraySize > m_iListViewNodeCount);

        while (pListViewMoveItem >= pNewListViewItem) // want >= so move node at current item location
        {
        int iMoveParent;

            ++(pListViewMoveItem->lvItemEx.iItem); // increment the iItem

            // if parent fails within move range increment the ParentId
            iMoveParent = pListViewMoveItem->lvItemEx.iParent;

            if ( (LVI_ROOT != iMoveParent) && (iMoveParent >= iListViewIndex))
            {
                ++(pListViewMoveItem->lvItemEx.iParent);
            }

            *(pListViewMoveItem + 1) = *(pListViewMoveItem);
            --pListViewMoveItem;
        }
    }


    // now insert the item at the specified location
    ++m_iListViewNodeCount;
    
    pNewListViewItem->pSubItems = pListViewSubItems;
    pNewListViewItem->fExpanded = TRUE; /// Review if want this to be user defined.but we expand children by default
    pNewListViewItem->iChildren = 0;
    pNewListViewItem->iNativeListViewItemId = -1;

    // fixup lvItem data
    pNewListViewItem->lvItemEx = *pitem;
    pNewListViewItem->lvItemEx.pszText = pszText;
    pNewListViewItem->lvItemEx.iItem = iListViewIndex;
    pNewListViewItem->lvItemEx.iIndent = iIndent;
 
    pNewListViewItem->lvItemEx.maskEx |= LVIFEX_PARENT; // always force valid parent
    pNewListViewItem->lvItemEx.pBlob = pBlob;
    pNewListViewItem->lvItemEx.iParent = iParentIndex; 

    // Review - For now Don't call SetItem so State CheckBox isn't updated.
    // Client must call SetItem after the insert to setup the ImageState
    // Assert that client isn't passing in a statImage on an Insert.  

    Assert(!(pNewListViewItem->lvItemEx.mask & LVIF_STATE)
            || !(pNewListViewItem->lvItemEx.stateMask &  LVIS_STATEIMAGEMASK)); 

    pNewListViewItem->lvItemEx.state = 0;
    pNewListViewItem->lvItemEx.stateMask = 0;

    // if have a parent other than the root incrment its children count
    // !! Note have to find again in case a realloc happened

    if (iParentIndex != LVI_ROOT)
    {
    pParentItem = ListViewItemFromIndex(iParentIndex);

        Assert(pParentItem);
        if (pParentItem)
        {
            ++(pParentItem->iChildren);
        }
    }


    if (fInsertNative)
    {
        // walk back and add 1 to
        // first item we come to that already is in the listview. if none assigned
        // iNativeInsertAtItemID should be zero.
        iNativeInsertAtItemID = 0;
        LPLISTVIEWITEM pListViewPrevItem;

        pListViewPrevItem = pNewListViewItem -1;
        while (pListViewPrevItem >= m_pListViewItems)
        {
            if (-1 != pListViewPrevItem->iNativeListViewItemId)
            {
                iNativeInsertAtItemID = pListViewPrevItem->iNativeListViewItemId + 1;
                break;
            }

            --pListViewPrevItem;
        }
    }
    else
    {
        iNativeInsertAtItemID = -1;
    }

    if (-1 != iNativeInsertAtItemID)
    {
    LV_ITEM lvi = { 0 };    
    LPLISTVIEWITEM pListViewMoveItem;
    LPLISTVIEWITEM pLastItem;

        Assert(fInsertNative);

        lvi.iItem = iNativeInsertAtItemID;
        pNewListViewItem->iNativeListViewItemId = ListView_InsertItem(m_hwnd,&lvi);
       
        Assert(iNativeInsertAtItemID == pNewListViewItem->iNativeListViewItemId);
        
        if (-1 != pNewListViewItem->iNativeListViewItemId)
        {
            // fix up NativeIds of items below
            pLastItem = m_pListViewItems + m_iListViewNodeCount - 1;
            pListViewMoveItem = pNewListViewItem + 1;

            while (pListViewMoveItem <= pLastItem)
            {
                if (-1 != pListViewMoveItem->iNativeListViewItemId)
                {
                    ++(pListViewMoveItem->iNativeListViewItemId);
                }

                ++pListViewMoveItem;
            }
        }

    }

    // after calling native listview fix up the state vars in local item to
    // not include the low byte
    pNewListViewItem->lvItemEx.state &= ~0xFF;
    pNewListViewItem->lvItemEx.stateMask &= ~0xFF;


    return iListViewIndex; // return new index even if fail to add to native listview

error:

    if (pListViewSubItems)
    {
        FREE(pListViewSubItems);
    }

    if (pszText)
    {
        FREE(pszText);
    }

    if (pBlob)
    {
        FREE(pBlob);
    }

    return FALSE;

}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::DeleteItem, public
//
//  Synopsis:   Deletes the specified lvItem
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CListView::DeleteItem(int iItem)
{
LPLISTVIEWITEM pListViewItem = ListViewItemFromIndex(iItem);
LPLISTVIEWITEM pListViewCurItem;
LPLISTVIEWITEM pListViewLastItem;
int iNativeListViewId;
int iParent;

    if (NULL == pListViewItem || (m_iListViewNodeCount < 1))
    {
        Assert(pListViewItem);
        Assert(m_iListViewNodeCount > 0); // should be at least one item.
        return FALSE;
    }

    // delete the item data and then move all items below this one up 
    // in the array. if the Item is in the ListView and native delete succeeded
    // decrement their nativeID count.
    
    // !REMEMBER TO DECREMENT THE parents iChildren count if have a parent and
    // total count of number of items in the list view.

    if (0 != pListViewItem->iChildren)
    {
        Assert(0 == pListViewItem->iChildren); // don't support delete of parent nodes.
        return FALSE;
    }


    iNativeListViewId = pListViewItem->iNativeListViewItemId;
    iParent = pListViewItem->lvItemEx.iParent;
    
    // update toplevel vars and item info by calling
    // setitem to uncheck and clear text, and blob so
    LVITEMEX pitem;

    pitem.iItem = iItem;
    pitem.iSubItem = 0;
    pitem.mask = LVIF_TEXT;
    pitem.maskEx = LVIFEX_BLOB;

    pitem.pszText = NULL;
    pitem.pBlob = NULL;
    
    // only need to set the state if have checkboxes
    if (m_dwExStyle & LVS_EX_CHECKBOXES)
    {
        pitem.mask |= LVIF_STATE;
        pitem.state = LVIS_STATEIMAGEMASK_UNCHECK;
        pitem.stateMask = LVIS_STATEIMAGEMASK;
    }

    SetItem(&pitem);
    
     // update parent to tell it it has one less item.
    if (LVI_ROOT != iParent)
    {
    LPLISTVIEWITEM pListViewItemParent;

        if (pListViewItemParent = ListViewItemFromIndex(iParent))
        {
            --(pListViewItemParent->iChildren); 
            Assert(pListViewItemParent->iChildren >= 0);
        }

        Assert(pListViewItemParent);
    }

    // set the current item to the end of the list
    Assert(m_iListViewNodeCount >= 1); // if no nodes should have already bailed.
    pListViewLastItem = m_pListViewItems + m_iListViewNodeCount - 1;

    // delete the SubItems if any associated with the ListView.
    DeleteListViewItemSubItems(pListViewItem);
    Assert(NULL == pListViewItem->lvItemEx.pszText);
    Assert(NULL == pListViewItem->lvItemEx.pBlob);

    // delete the item from the native listView if fails will just have
    // a blank item at the bottom of the native listview. 
    if (-1 != iNativeListViewId)
    {
        ListView_DeleteItem(m_hwnd,iNativeListViewId);
    }

      // decrement the toplevel nodecount
    --m_iListViewNodeCount;

    pListViewCurItem = pListViewItem;

    // move items remaining in the ListView up updateing iNativeListViewId
    // if appropriate.
    while (pListViewCurItem < pListViewLastItem)
    {
        *(pListViewCurItem) = *(pListViewCurItem + 1);
       
        if ( (-1 != iNativeListViewId)
              && (-1 != pListViewCurItem->iNativeListViewItemId))
        {
            --pListViewCurItem->iNativeListViewItemId;
        }

        --(pListViewCurItem->lvItemEx.iItem); // decrement it iItem

        // if items parentID falls within pListViewItem and this item
        // range need to update our iParent.
        // parent should nevert be == iItem since don't allow nodes
        // with children to be deleted but check <= anyways
        if (LVI_ROOT != pListViewCurItem->lvItemEx.iParent)
        {
            if (iItem <= pListViewCurItem->lvItemEx.iParent)
            {
                --(pListViewCurItem->lvItemEx.iParent);
            }
        }

        ++pListViewCurItem;
    }


    return TRUE;

}


//+---------------------------------------------------------------------------
//
//  Member:     CListView::DeleteChildren, public
//
//  Synopsis:   Deletes all child nodes associated with the item.
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CListView::DeleteChildren(int iItem)
{
LPLISTVIEWITEM pListViewItem = ListViewItemFromIndex(iItem);
LPLISTVIEWITEM pListViewCurItem;
LPLISTVIEWITEM pLastListViewItem;
int iNumChildren;

    if (!pListViewItem || m_iListViewNodeCount < 1)
    {
        Assert(pListViewItem);
        Assert(m_iListViewNodeCount >= 1); // should at least have one node.
        return FALSE;
    }
 
    iNumChildren = pListViewItem->iChildren;
    pLastListViewItem = m_pListViewItems + m_iListViewNodeCount - 1;

    if (0 > iNumChildren)
    {
        Assert(0 <= iNumChildren); // this count should never go negative.
        return FALSE;
    }

    // if no children just return;
    if (0 == iNumChildren)
    {
        return TRUE;
    }
    // verify all children don't have any children of there own. if they
    // do we don't support this. Also verify that don't run off
    // end of the list in which case we fail too.
    pListViewCurItem = pListViewItem  + iNumChildren;

    if (pListViewCurItem > pLastListViewItem)
    {
        AssertSz(0,"Children run off end of ListView");
        return FALSE;
    }

    while (pListViewCurItem > pListViewItem)
    {
        if (pListViewCurItem->iChildren > 0)
        {
            AssertSz(0,"Trying to DeleteChildren when Children have Children");
            return FALSE;
        }

        --pListViewCurItem;
    }

    // all items verified, just loop through deleting the items starting at the bottom.
    pListViewCurItem = pListViewItem  + iNumChildren;

    while (pListViewCurItem > pListViewItem)
    {
        DeleteItem(pListViewCurItem->lvItemEx.iItem); // if any fail delete what we can.
        --pListViewCurItem;
    }


    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CListView::SetItem, public
//
//  Synopsis:   wrapper for ListView_SetItem
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CListView::SetItem(LPLVITEMEX pitem)
{
int iNativeListViewItemId;
LPLISTVIEWITEM pListViewItem = ListViewItemFromIndex(pitem->iItem,pitem->iSubItem,&iNativeListViewItemId);
LPLVITEMEX plvItemEx;
BOOL fCheckCountChanged = FALSE;
LVITEMSTATE fNewCheckCountState;
LPWSTR pszNewText = NULL;
LPLVBLOB pNewBlob = NULL;



    if (NULL == pListViewItem)
    {
        Assert(pListViewItem);
        return FALSE;
    }

    Assert(pListViewItem->lvItemEx.iSubItem == pitem->iSubItem);
    Assert(pListViewItem->lvItemEx.iSubItem > 0 
            || pListViewItem->iNativeListViewItemId == iNativeListViewItemId);
    

    plvItemEx = &(pListViewItem->lvItemEx);

     // allocate new text
    if (LVIF_TEXT & pitem->mask)
    {
    int cchSize;

        if (NULL == pitem->pszText)
        {
            pszNewText = NULL;
        }
        else
        {
            cchSize = (lstrlen(pitem->pszText) + 1);
            pszNewText = (LPWSTR) ALLOC(cchSize *sizeof(WCHAR));

            if (NULL == pszNewText)
            {
                goto error;
            }

            StrCpyN(pszNewText, pitem->pszText, cchSize);

        }

    }

    // allocate new blob
    if (LVIFEX_BLOB & pitem->maskEx)
    {

        if (NULL == pitem->pBlob)
        {
            pNewBlob = NULL;
        }
        else
        {
            pNewBlob = (LPLVBLOB) ALLOC(pitem->pBlob->cbSize);

            if (NULL == pNewBlob)
            {
               goto error;
            }

            memcpy(pNewBlob,pitem->pBlob,pitem->pBlob->cbSize);

        }

    }

    // now that can't fail update the text and blob field appropriately
    if (LVIF_TEXT & pitem->mask)
    {
        if (plvItemEx->pszText)
        {
            FREE(plvItemEx->pszText);
        }

        plvItemEx->pszText = pszNewText;
        plvItemEx->mask |= LVIF_TEXT; 

        pszNewText = NULL; 
    }

    if (LVIFEX_BLOB & pitem->maskEx)
    {
        if (plvItemEx->pBlob)
        {
            FREE(plvItemEx->pBlob);
        }

        plvItemEx->pBlob = pNewBlob;
        plvItemEx->mask |= LVIFEX_BLOB; 

        pNewBlob = NULL;
    }



    if (LVIF_IMAGE & pitem->mask)
    {
        plvItemEx->mask |= LVIF_IMAGE; 
        plvItemEx->iImage = pitem->iImage;
    }

    if (LVIF_PARAM & pitem->mask)
    {
        plvItemEx->mask |= LVIF_PARAM; 
        plvItemEx->lParam = pitem->lParam;
    }

    // update the item state. 
    if (LVIF_STATE & pitem->mask)
    {
        plvItemEx->mask |= LVIF_STATE; 

        // only care about #define LVIS_OVERLAYMASK, LVIS_STATEIMAGEMASK
        if (pitem->stateMask & LVIS_OVERLAYMASK)
        {
            plvItemEx->stateMask |= LVIS_OVERLAYMASK;
            plvItemEx->state = (pitem->state & LVIS_OVERLAYMASK )
                                      +  (plvItemEx->state & ~LVIS_OVERLAYMASK);
        }

        if (pitem->stateMask & LVIS_STATEIMAGEMASK)
        {
            // update the m_iCheckCount (indeterminate doesn't contribute.
            if ( (plvItemEx->iSubItem == 0)
                && ( (pitem->state & LVIS_STATEIMAGEMASK) !=  (plvItemEx->state & LVIS_STATEIMAGEMASK)))
            {

                // don't set fCheckCountChange unless it actually did.
                if ( (pListViewItem->lvItemEx.state & LVIS_STATEIMAGEMASK) ==  LVIS_STATEIMAGEMASK_CHECK)
                {
                     fCheckCountChanged = TRUE;
                     fNewCheckCountState =  LVITEMEXSTATE_UNCHECKED;
                    --m_iCheckCount;
                }
                
                if ( (pitem->state  & LVIS_STATEIMAGEMASK) ==  LVIS_STATEIMAGEMASK_CHECK)
                {
                    fCheckCountChanged = TRUE;
                     fNewCheckCountState =  LVITEMEXSTATE_CHECKED;
                    ++m_iCheckCount;
                }

                Assert(m_iCheckCount >= 0);
                Assert(m_iCheckCount <= m_iListViewNodeCount);
            }  
            

            plvItemEx->stateMask |= LVIS_STATEIMAGEMASK;
            plvItemEx->state = (pitem->state & LVIS_STATEIMAGEMASK)
                                      +  (plvItemEx->state & ~LVIS_STATEIMAGEMASK);

        }
    }        

    // if the check count changed and we have checkboxes send the notification
    // if item state has changed send the count notification
     if (fCheckCountChanged && m_hwndParent && (m_dwExStyle & LVS_EX_CHECKBOXES))
     {
     NMLISTVIEWEXITEMCHECKCOUNT lvCheckCount;
 
         lvCheckCount.hdr.hwndFrom = m_hwnd;
         lvCheckCount.hdr.idFrom = m_idCtrl;
         lvCheckCount.hdr.code = LVNEX_ITEMCHECKCOUNT;
         lvCheckCount.iCheckCount = m_iCheckCount;

          lvCheckCount.iItemId = pitem->iItem;
          lvCheckCount.dwItemState = fNewCheckCountState; // new state of the item whose checkcount has changed.

         SendMessage(m_hwndParent,m_MsgNotify,m_idCtrl,(LPARAM) &lvCheckCount);
     }



    // if item is in the native list view, redraw item to reflect new state
    // bug  bug, doesn't handle subitems
    if (-1 != iNativeListViewItemId)
    {
        // if state changed pass it along for focus
        if ((LVIF_STATE & pitem->mask) && (0 == pitem->iSubItem))
        {
        int stateMask = pitem->stateMask   & 0xff;
            
            if (stateMask)
            {
                ListView_SetItemState(m_hwnd,iNativeListViewItemId,pitem->state,stateMask);
        
            }
            
        }

        ListView_RedrawItems(m_hwnd,iNativeListViewItemId,iNativeListViewItemId);
    }

    return TRUE;

error:

    if (pszNewText)
    {
        FREE(pszNewText);
    }

    if (pNewBlob)
    {
        FREE(pNewBlob);
    }

    return FALSE;

}




//+---------------------------------------------------------------------------
//
//  Member:     CListView::SetItemState, public
//
//  Synopsis:   wrapper for ListView_SetItemState
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------
    
BOOL CListView::SetItemState(int iItem,UINT state,UINT mask)
{
LVITEMEX lvitemEx;

    lvitemEx.iItem = iItem;
    lvitemEx.iSubItem  = 0;
    lvitemEx.mask = LVIF_STATE ;
    lvitemEx.state = state;
    lvitemEx.stateMask = mask;
    lvitemEx.maskEx = 0;

    return SetItem(&lvitemEx);
}


//+---------------------------------------------------------------------------
//
//  Member:     CListView::SetItemlParam, public
//
//  Synopsis:   wrapper for setting the lParam
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CListView::SetItemlParam(int iItem,LPARAM lParam)
{
LVITEMEX lvitemEx;

    lvitemEx.iItem = iItem;
    lvitemEx.iSubItem  = 0;
    lvitemEx.mask = LVIF_PARAM ;
    lvitemEx.lParam = lParam;
    lvitemEx.maskEx = 0;

    return SetItem(&lvitemEx);
}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::SetItemText, public
//
//  Synopsis:   wrapper for setting the item text.
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CListView::SetItemText(int iItem,int iSubItem,LPWSTR pszText)
{
LVITEMEX lvitemEx;

    lvitemEx.iItem = iItem;
    lvitemEx.iSubItem  = iSubItem;
    lvitemEx.mask = LVIF_TEXT;
    lvitemEx.pszText = pszText;
    lvitemEx.maskEx = 0;

    return SetItem(&lvitemEx);
}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::GetItem, public
//
//  Synopsis:   wrapper for ListView_GetItem
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CListView::GetItem(LPLVITEMEX pitem)
{
int iNativeListViewItemId;
LPLISTVIEWITEM pListViewItem = ListViewItemFromIndex(pitem->iItem,pitem->iSubItem,&iNativeListViewItemId);

    if (NULL == pListViewItem)
    {
        Assert(pListViewItem);
        return FALSE;
    }

     // add text first. Since it is the only item
    if (LVIF_TEXT & pitem->mask)
    {
        
        if (!(pListViewItem->lvItemEx.pszText) || (0 == pitem->cchTextMax)
            || !(pListViewItem->lvItemEx.mask & LVIF_TEXT) )
        {
            pitem->pszText = NULL;
        }
        else
        {
        int cchListTextSize = lstrlen(pListViewItem->lvItemEx.pszText);

            StrCpyN(pitem->pszText,pListViewItem->lvItemEx.pszText,pitem->cchTextMax);
        }   
    }

    if (LVIF_IMAGE & pitem->mask)
    {
        pitem->iImage = pListViewItem->lvItemEx.iImage;
    }

    if (LVIF_PARAM & pitem->mask)
    {
        pitem->lParam =  pListViewItem->lvItemEx.lParam;
    }

    // update the item state. 
    if (LVIF_STATE & pitem->mask)
    {
        pitem->state  = pListViewItem->lvItemEx.state;
    }        


    return TRUE;

}


//+---------------------------------------------------------------------------
//
//  Member:     CListView::GetItemText, public
//
//  Synopsis:   wrapper for ListView_GetItem
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CListView::GetItemText(int iItem,int iSubItem,LPWSTR pszText,int cchTextMax)
{
LVITEMEX lvitem;

    lvitem.mask = LVIF_TEXT;
    lvitem.maskEx = 0;

    lvitem.iItem = iItem;
    lvitem.iSubItem = iSubItem;
    lvitem.pszText = pszText;
    lvitem.cchTextMax = cchTextMax;
    
    return GetItem(&lvitem);
}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::GetItemlParam, public
//
//  Synopsis:   wrapper for gettting the lparam
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------


BOOL CListView::GetItemlParam(int iItem,LPARAM *plParam)
{
LVITEMEX lvitem;
BOOL fReturn;

    lvitem.mask = LVIF_PARAM;
    lvitem.maskEx = 0;

    lvitem.iItem = iItem;
    lvitem.iSubItem = 0;

    if (fReturn = GetItem(&lvitem))
    {
        *plParam = lvitem.lParam;
    }

    return fReturn;
}


//+---------------------------------------------------------------------------
//
//  Member:     CListView::GetHwnd, public
//
//  Synopsis:   return Hwnd of the ListView
//
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    07-Sep-98       rogerg        Created.
//
//----------------------------------------------------------------------------

HWND CListView::GetHwnd()
{
    return m_hwnd;
}


//+---------------------------------------------------------------------------
//
//  Member:     CListView::GetParent, public
//
//  Synopsis:   return Hwnd of the ListViews Parent
//
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    07-Sep-98       rogerg        Created.
//
//----------------------------------------------------------------------------

HWND CListView::GetParent()
{
    return m_hwndParent;
}




//+---------------------------------------------------------------------------
//
//  Member:     CListView::GetCheckState, public
//
//  Synopsis:   wrapper for ListView_GetCheckState
//
//              return state from LVITEMEXSTATE enum 
//              !!!return -1 if not item match to have same behavior as ListView
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

int CListView::GetCheckState(int iItem)
{
LPLISTVIEWITEM pListViewItem = ListViewItemFromIndex(iItem);
UINT state;
  
    if (NULL == pListViewItem)
    {
        return -1; // return -1 same as for native listbox
    }
    
    // check state is actually define -1 than the image. 
    // Don't know why. Just what the native listview does.
    // change whant supply our own image that will map exactly
    state = ((pListViewItem->lvItemEx.state & LVIS_STATEIMAGEMASK) >> 12) -1;

#ifdef _DEBUG
    if (-1 != pListViewItem->iNativeListViewItemId)
    {
    UINT lvState = ListView_GetCheckState(m_hwnd,pListViewItem->iNativeListViewItemId);

        Assert(state == lvState);
    }

#endif // _DEBUG
    
    // if this is a toplevel item then okay for state to be
    // negative -1. Should change this when go indeterminate.
    // Review - maybe just make -1 indeterinate state.
    if (-1 == state && 0 == pListViewItem->lvItemEx.iIndent)
    {
        state = LVITEMEXSTATE_INDETERMINATE;
    }

    Assert(state <= LVITEMEXSTATE_INDETERMINATE);
    return state; 
}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::GetCheckedItemsCount, public
//
//  Synopsis:  returns the number of checked items in the list.
//
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

int CListView::GetCheckedItemsCount()
{
    return m_iCheckCount;
}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::SetColumn, public
//
//  Synopsis:   wrapper for ListView_SetColumn
//
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CListView::SetColumn(int iCol,LV_COLUMN * pColumn)
{
    Assert(m_hwnd);
    return ListView_SetColumn(m_hwnd,iCol,pColumn);
}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::InsertColumn, public
//
//  Synopsis:   wrapper for ListView_InsertColumn
//
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

int CListView::InsertColumn(int iCol,LV_COLUMN * pColumn)
{
int iReturn;

    Assert(m_hwnd);

    iReturn =  ListView_InsertColumn(m_hwnd,iCol,pColumn);

    if (-1 != iReturn)
    {
        m_iNumColumns++;

        // need to realloc any existing listviewItems with subitems and move
        // the column appropriate

        //currently only support setting up columns before adding any items
        Assert(0 == m_iListViewNodeCount); 

    }

    return iReturn;
}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::SetColumnWidth, public
//
//  Synopsis:   wrapper for ListView_SetColumnWidth
//
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CListView::SetColumnWidth(int iCol,int cx)
{

    Assert(m_hwnd);

    return ListView_SetColumnWidth(m_hwnd,iCol,cx);

}


//+---------------------------------------------------------------------------
//
//  Member:     CListView::Expand, public
//
//  Synopsis:   expands all children of specified Item
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CListView::Expand(int iItemId)
{
LPLISTVIEWITEM pListViewItem = ListViewItemFromIndex(iItemId);

    if (!pListViewItem)
    {
        return FALSE;
    }

    return ExpandCollapse(pListViewItem,TRUE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::Collapse, public
//
//  Synopsis:   collapses all children of specified Item
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CListView::Collapse(int iItemId)
{
LPLISTVIEWITEM pListViewItem = ListViewItemFromIndex(iItemId);

    if (!pListViewItem)
    {
        return FALSE;
    }

    return ExpandCollapse(pListViewItem,FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::FindItemFromBlob, public
//
//  Synopsis:   returns first item in list that matches blob
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

int CListView::FindItemFromBlob(LPLVBLOB pBlob)
{
LPLISTVIEWITEM pListViewItem;

    // if not items just return
    if (m_iListViewNodeCount < 1)
    {
        return -1;
    }

    pListViewItem = m_pListViewItems + m_iListViewNodeCount -1;  

    while(pListViewItem >= m_pListViewItems)
    {
        if (IsEqualBlob(pBlob,pListViewItem->lvItemEx.pBlob))
        {
            return pListViewItem->lvItemEx.iItem;
        }

        --pListViewItem;
    }

    return -1;
}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::GetItemBlob, public
//
//  Synopsis:   finds blob is any associated with an
//              item and then fill in mem pointed
//              to by pBlob if cbSize in BlobStruc is >
//              specified cbBlockSize NULL is returned
//
//  Arguments:  
//
//  Returns:    NULL on failure
//              on success a pointer to the passed in buffer
//              strictly for convenience to the caller.
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

LPLVBLOB CListView::GetItemBlob(int ItemId,LPLVBLOB pBlob,ULONG cbBlobSize)
{
LPLISTVIEWITEM pListViewItem = ListViewItemFromIndex(ItemId);
LPLVBLOB pItemBlob;

    if (!pListViewItem
        || (NULL == pListViewItem->lvItemEx.pBlob)
        || (NULL == pBlob))
    {
        Assert(pListViewItem);
        Assert(pBlob);
        return NULL;
    }

    pItemBlob = pListViewItem->lvItemEx.pBlob;

    // make sure out buffer is big enough
    if (cbBlobSize < pItemBlob->cbSize)
    {
        Assert(cbBlobSize >= pItemBlob->cbSize);
        return NULL;
    }

    memcpy(pBlob,pItemBlob,pItemBlob->cbSize);

    return pBlob;

}


//+---------------------------------------------------------------------------
//
//  Member:     CListView::IsEqualBlob, private
//
//  Synopsis:   compares two blobs. Valid to pass in NULL put two NULLS is
//              not a match.
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CListView::IsEqualBlob(LPLVBLOB pBlob1,LPLVBLOB pBlob2)
{
    if (NULL == pBlob1 || NULL == pBlob2)
    {
        return FALSE;
    }

    // compare sizes
    if (pBlob1->cbSize != pBlob2->cbSize)
    {
        return FALSE;
    }

    if (0 != memcmp(pBlob1,pBlob2,pBlob2->cbSize))
    {
        return FALSE;
    }

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CListView::OnNotify, public
//
//  Synopsis:   Called by client whenever a native listview
//              notifiication is sent. We turn around, package
//              it up and send it as our notification message.
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

LRESULT CListView::OnNotify(LPNMHDR pnmv)
{
LPNMLISTVIEW pnlv = (LPNMLISTVIEW) pnmv; 
NMLISTVIEWEX nmvEx; 
LPLISTVIEWITEM pListViewItem;

    if ((NULL == pnmv) || ( ((int) pnmv->idFrom) != m_idCtrl) || (NULL == m_hwndParent))
    {
        Assert(pnmv);
        Assert( ((int) pnmv->idFrom) == m_idCtrl);
        Assert(m_hwndParent);
        return 0;
    }

    // take care of notifies we handle ourselves.
    switch(pnmv->code)
    {
        case LVN_GETDISPINFOW:
        {
            OnGetDisplayInfo(pnmv->code,(LV_DISPINFO *) pnmv);
            return 0;
            break;
        }
        case NM_DBLCLK:
        case NM_CLICK:
        {
        LV_HITTESTINFO lvhti;
        RECT Rect;

            lvhti.pt = pnlv->ptAction;

            // Have the ListView tell us what element this was on
            if (-1 != ListView_HitTest(m_hwnd, &lvhti))
            {

                // if flags are onitem change to either label or state depending
                // on the click positiion
                if (LVHT_ONITEM == lvhti.flags)
                {
                    lvhti.flags = LVHT_ONITEMLABEL; 

                    if (ListView_GetSubItemRect(m_hwnd,pnlv->iItem,0,LVIR_ICON,&Rect))
                    {
                        if (lvhti.pt.x < Rect.left)
                        {
                            lvhti.flags = LVHT_ONITEMSTATEICON; 
                        }
                        else if (lvhti.pt.x <= Rect.right)
                        {
                            // this doesn't ever get hit since icon is between label and state
                            // but its here for completeness.
                            lvhti.flags = LVHT_ONITEMICON; 
                        }

                    }

                }


                if (OnHandleUIEvent(pnmv->code,lvhti.flags,0,pnlv->iItem))
                {
                    return 0; // don't pass on clicks we process
                }
            }
            break;
        }
        case LVN_KEYDOWN:
        {
        LV_KEYDOWN* pnkd = (LV_KEYDOWN*) pnmv; 
        int iItem;
 
            if (-1 != (iItem = ListView_GetSelectionMark(m_hwnd)))
            {
                if(OnHandleUIEvent(pnmv->code,0,pnkd->wVKey,iItem))
                {
                    return 0;
                }
            }
    
            break;
        }
        default:
            break;
    }


    Assert(LVNEX_ITEMCHANGED == LVN_ITEMCHANGED);
    Assert(LVNEX_DBLCLK == NM_DBLCLK);
    Assert(LVNEX_CLICK == NM_CLICK);

    // only pass along notifications we know how to handle
    if (LVN_ITEMCHANGED != pnmv->code && NM_DBLCLK != pnmv->code && NM_CLICK != pnmv->code)
    {
        return 0;
    }

    // listview can send a iItem of -1 for example when
    // a double-click or click occurs in empty space. 
    // if get a -1 just pass through

    if (-1 == pnlv->iItem)
    {
        memcpy(&(nmvEx.nmListView),pnmv,sizeof(nmvEx.nmListView));
        nmvEx.iParent =  -1;  
        nmvEx.pBlob = NULL;

    }
    else
    {
        pListViewItem = ListViewItemFromNativeListViewItemId(pnlv->iItem);
        if (NULL == pListViewItem)
        {
            // if couldn't find itme 
            Assert(pListViewItem);
            return 0;
        }

        // assumes only pass along notifications of
        // type LPNMLISTVIEW

        // fix up the notify structure
        memcpy(&(nmvEx.nmListView),pnmv,sizeof(nmvEx.nmListView));
        nmvEx.nmListView.iItem = pListViewItem->lvItemEx.iItem; // make item point to our internal id

        nmvEx.iParent =  pListViewItem->lvItemEx.iParent;  
        nmvEx.pBlob = pListViewItem->lvItemEx.pBlob;
  
        if (LVIF_STATE & pnlv->uChanged )
        {
            // update our internal itemState for the item.
            // Note don't care about lower state bits
            if ( (pnlv->uNewState ^ pnlv->uOldState) &  LVIS_STATEIMAGEMASK)
            {
                pListViewItem->lvItemEx.state = (pnlv->uNewState & LVIS_STATEIMAGEMASK)
                               + (pListViewItem->lvItemEx.state & ~LVIS_STATEIMAGEMASK);
            }

            if ( (pnlv->uNewState ^ pnlv->uOldState) &  LVIS_OVERLAYMASK)
            {
                pListViewItem->lvItemEx.state = (pnlv->uNewState & LVIS_OVERLAYMASK)
                               + (pListViewItem->lvItemEx.state & ~LVIS_OVERLAYMASK);
            }

        }
    }

    // send off the message
    return SendMessage(m_hwndParent,m_MsgNotify,m_idCtrl,(LPARAM) &nmvEx);

}



//+---------------------------------------------------------------------------
//
//  Member:     CListView::ListViewItemFromNativeListViewItemId, private
//
//  Synopsis:  Given a native listview control itemId finds our internal ListViewItem
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

LPLISTVIEWITEM CListView::ListViewItemFromNativeListViewItemId(int iNativeListViewItemId)
{
    return ListViewItemFromNativeListViewItemId(iNativeListViewItemId,0);
}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::ListViewItemFromNativeListViewItemId, private
//
//  Synopsis:  Given a native listview control itemId finds our internal ListViewItem
//
//  Arguments:  iNativeListViewItemId - ItemId of the ListViewItem
//              iNativeListViewSubItemId - SubItemID of the ListViewItem
//              piNativeListViewItemId - [out] on succes iteId in nativelistview.
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

LPLISTVIEWITEM CListView::ListViewItemFromNativeListViewItemId(int iNativeListViewItemId,
                                                    int iSubItem)
{
LPLISTVIEWITEM pListViewItem;

    if (-1 == iNativeListViewItemId)
    {
        return NULL;
    }

    if (NULL == m_pListViewItems || m_iListViewNodeCount < 1 
        ||  (iSubItem  > m_iNumColumns - 1))
    {
        Assert(NULL != m_pListViewItems);
        Assert(m_iListViewNodeCount >=  1);
        Assert(iSubItem <= (m_iNumColumns - 1));
        return NULL;
    }

    pListViewItem = m_pListViewItems + m_iListViewNodeCount -1;  

    while(pListViewItem >= m_pListViewItems)
    {
        if (iNativeListViewItemId == pListViewItem->iNativeListViewItemId)
        {
            break;
        }

        --pListViewItem;
    }

    if (pListViewItem < m_pListViewItems)
    {
        return NULL;
    }

    // if subItem is zero then we just return this listviewItem, else
    // need to walk forward the subItem array.
    
    if (0 == iSubItem)
    {
        return pListViewItem;
    }

    Assert(m_iNumColumns > 1); // should have already caught about but double-check
    
    pListViewItem = pListViewItem->pSubItems + iSubItem -1;

    return pListViewItem;
}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::ListViewItemFromIndex, private
//
//  Synopsis:   Finds internal listviewItem from ItemID we gave to client.
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

LPLISTVIEWITEM CListView::ListViewItemFromIndex(int iItemID)
{
    return ListViewItemFromIndex(iItemID,0,NULL);
}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::ListViewItemFromIndex, private
//
//  Synopsis:   Finds internal listviewItem from ItemID we gave to client.
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

LPLISTVIEWITEM CListView::ListViewItemFromIndex(int iItemID,int iSubitem,int *piNativeListViewItemId)
{
LPLISTVIEWITEM pListViewItem;

    // if item isn't valid return NULL
    if (iItemID < 0 || iItemID >= m_iListViewNodeCount
            || (iSubitem  > m_iNumColumns - 1))
    {
        Assert(iItemID >= 0);
        Assert(iSubitem  <= m_iNumColumns - 1);

        // Assert(iItemID < m_iListViewNodeCount); choice dlg Calls GetCheckState until hits -1. 

        return NULL;
    }

    pListViewItem =  m_pListViewItems + iItemID;

    if (piNativeListViewItemId)
    {
        *piNativeListViewItemId = pListViewItem->iNativeListViewItemId;
    }

    if (0 == iSubitem)
    {
        return pListViewItem;
    }

    pListViewItem = pListViewItem->pSubItems + iSubitem -1;

    return pListViewItem;
}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::DeleteListViewItemSubItems, private
//
//  Synopsis:   Helper function to delete subItems associated with a ListViewItem
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    04-Aug-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CListView::DeleteListViewItemSubItems(LPLISTVIEWITEM pListItem)
{
LPLISTVIEWITEM pListViewSubItem;

    // if not subItems or number of columns isn't at least 2 bail.
    if ((NULL == pListItem->pSubItems) || (m_iNumColumns < 2))
    {
        Assert(NULL == pListItem->pSubItems && m_iNumColumns < 2); // should always match.
        return;
    }
            

    pListViewSubItem = pListItem->pSubItems + m_iNumColumns -2; // -2 ; covers first subItem and column of main item
   
    // free any text associated with the subItems
    Assert(m_iNumColumns > 1); 
    Assert(pListViewSubItem >= pListItem->pSubItems); 

    while (pListViewSubItem >= pListItem->pSubItems)
    {
        if (pListViewSubItem->lvItemEx.pszText)
        {
            Assert(LVIF_TEXT & pListViewSubItem->lvItemEx.mask);
            FREE(pListViewSubItem->lvItemEx.pszText);
        }

        --pListViewSubItem;
    }

    FREE(pListItem->pSubItems);
    pListItem->pSubItems = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::ExpandCollapse, private
//
//  Synopsis:   Expands or collapses children of given node.
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CListView::ExpandCollapse(LPLISTVIEWITEM pListViewItem,BOOL fExpand)
{
LPLISTVIEWITEM pCurListViewItem = pListViewItem + 1;
LPLISTVIEWITEM pLastListViewItem = m_pListViewItems + m_iListViewNodeCount -1;
int iIndent = pListViewItem->lvItemEx.iIndent;
int iInsertDeleteCount = 0;
LV_ITEM lvi = { 0 };    

    Assert(pListViewItem);
    Assert(m_iListViewNodeCount); 
    
    // if specified node isn't in the list view fail
    if (-1 == pListViewItem->iNativeListViewItemId)
    {
        Assert(-1 != pListViewItem->iNativeListViewItemId);
        return FALSE;
    }

    lvi.iItem = pListViewItem->iNativeListViewItemId + 1;
    
    while (pCurListViewItem <= pLastListViewItem 
            && pCurListViewItem->lvItemEx.iIndent > iIndent)
    {

        if (fExpand)
        {
            if ( (-1 == pCurListViewItem->iNativeListViewItemId)
                && (pCurListViewItem->lvItemEx.iIndent == iIndent + 1)) // only expand next level deep
            {
                pCurListViewItem->iNativeListViewItemId  = ListView_InsertItem(m_hwnd,&lvi);
                
                Assert(pCurListViewItem->iNativeListViewItemId  == lvi.iItem);
                if (-1 != pCurListViewItem->iNativeListViewItemId)
                {
                    ++lvi.iItem;
                    ++iInsertDeleteCount;
                }
            }
        }
        else
        {
           if (-1 != pCurListViewItem->iNativeListViewItemId)
            {
                pCurListViewItem->fExpanded = FALSE;
                if (ListView_DeleteItem(m_hwnd,lvi.iItem))
                {
                    pCurListViewItem->iNativeListViewItemId  = -1;
                    --iInsertDeleteCount;
                }
           }
        }

        ++pCurListViewItem;
    }

    // fixup nativeIds of any remaining items in the list
    while (pCurListViewItem <= pLastListViewItem)
    {
        if (-1 != pCurListViewItem->iNativeListViewItemId)
        {
            pCurListViewItem->iNativeListViewItemId += iInsertDeleteCount;
            Assert(pCurListViewItem->iNativeListViewItemId >= 0);
            Assert(pCurListViewItem->iNativeListViewItemId <  m_iListViewNodeCount);
        }
        
        ++pCurListViewItem;
    }

    pListViewItem->fExpanded = fExpand;

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CListView::OnGetDisplayInfo, private
//
//  Synopsis:   Handles Display info notification.
//
//  Arguments:  code -  code from notification header either
//                   LVN_GETDISPINFOW, LVN_GETDISPINFOA. need this
//                   so know how to handle Text.
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CListView::OnGetDisplayInfo(UINT code,LV_DISPINFO *plvdi)
{
LPLISTVIEWITEM pListViewItem = ListViewItemFromNativeListViewItemId(plvdi->item.iItem,
                                                                   plvdi->item.iSubItem);


    if (NULL == pListViewItem)
        return;

    // verify subitem iound matches item we asked for.
    Assert(pListViewItem->lvItemEx.iSubItem == plvdi->item.iSubItem);

    // The ListView needs text for this row
    if (plvdi->item.mask & LVIF_TEXT)
    {

        if (pListViewItem->lvItemEx.pszText)
        {
            if (LVN_GETDISPINFOW == code)
            {
                StrCpyN(plvdi->item.pszText,pListViewItem->lvItemEx.pszText,plvdi->item.cchTextMax);
            }
        }
    }

    // The ListView needs an image
    if (plvdi->item.mask & LVIF_IMAGE)
    {
      // plvdi->item.iItem, plvdi->item.iSubItem, &(plvdi->item.iImage));
        plvdi->item.iImage = pListViewItem->lvItemEx.iImage;
    }

    // The ListView needs the indent level
    if (plvdi->item.mask & LVIF_INDENT)
    {
       // if (m_fThreadMessages)
       //     m_pTable->GetIndentLevel(plvdi->item.iItem, (LPDWORD) &(plvdi->item.iIndent));
       // else

        // for no checks on top-level set image state to empty pict and
        // indent to -1. Need additional State Logic if want to 
        // choose if toplevel checks are shown.
        plvdi->item.iIndent = pListViewItem->lvItemEx.iIndent;

        if ( (m_dwExStyle & LVS_EX_CHECKBOXES) && (0 == plvdi->item.iIndent) )
        {   
            plvdi->item.iIndent = -1;
        }
    }

    // The ListView needs the state image
    if (plvdi->item.mask & LVIF_STATE)
    {
       //nt iIcon = 0;
      //  _GetColumnStateImage(plvdi->item.iItem, plvdi->item.iSubItem, &iIcon);
        plvdi->item.state = pListViewItem->lvItemEx.state & LVIS_STATEIMAGEMASK;
    }

}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::OnHandleUIEvent private
//
//  Synopsis:   sent when a click or double-click,keyboard, is sent to 
//              the listview
//
//  Arguments:  code -  indicates why this function was called
//                      Support NM_DBLCLK, NM_CLICK, LVN_KEYDOWN:
//
//              flags - flags from hitTest. Only valid for DBCLK and CLICK
//                          flag = LVHT_ONITEMSTATEICON | LVHT_ONITEMICON) |LVHT_ONITEMLABEL
//              wVKey - Virtual key code of key presses. Ony valide cfor LVN_KEYDOWN
//              iItemNative - ItemID in NativeListView
//
//
//  Returns:   TRUE - if handled event and notification shouldn't be passed on. 
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CListView::OnHandleUIEvent(UINT code,UINT flags,WORD wVKey,int iItemNative)
{
LPLISTVIEWITEM pListViewItem = ListViewItemFromNativeListViewItemId(iItemNative);
int iStateMask;
BOOL fItemHasCheckBoxes; // for now this is hardcoded depending on the indent. Need to change this.
BOOL fToggleCheckBox = FALSE;
BOOL fExpand = FALSE;
BOOL fCollapse = FALSE;
BOOL fReturn = FALSE;

    if (NULL == pListViewItem)
    {
        return TRUE; // no need passing this on
    }

    fItemHasCheckBoxes = pListViewItem->lvItemEx.iIndent ? TRUE : FALSE;

   //  If Item has chechboxes toggle on keyboard space or mouse clicks
    //  over the itemState Icon.

    // double-clicks on itemIcon togles the whether the branch is expanded/collasse    
    // if left/right keyboard expand collapse

    switch(code)
    {
        case LVN_KEYDOWN:
        {
            switch(wVKey)
            {
                case VK_SPACE:
                    if (fItemHasCheckBoxes)
                    {
                        fToggleCheckBox = TRUE;
                    }
                   break;
                case VK_RIGHT:
                case VK_LEFT:
                    if (pListViewItem->iChildren)
                    {
                        fExpand = VK_RIGHT == wVKey ? TRUE : FALSE;
                        fCollapse = !fExpand;
                    }
                    break;
                default:
                    break;
            }
        }
        case NM_DBLCLK:
            if ( (flags & LVHT_ONITEMICON) && (pListViewItem->iChildren))
            {
                fExpand = pListViewItem->fExpanded ? FALSE : TRUE;
                fCollapse = !fExpand;
                break;
            }
            // double-click falls through to a click.
        case NM_CLICK:
            if ((flags & LVHT_ONITEMSTATEICON) 
                 && fItemHasCheckBoxes)
            {
                fToggleCheckBox = TRUE;
            }
            break;
        default:
            break;
    }


    if (fExpand || fCollapse)
    {
        // don't bother if already in current state
        if (pListViewItem->fExpanded != fExpand)
        {
            ExpandCollapse(pListViewItem,fExpand);
        }
        return TRUE;
    }
    else if (fToggleCheckBox)
    {
        // for now just toggle the state. if have children need to set them appropriately.
        iStateMask = LVITEMEXSTATE_CHECKED == GetCheckState(pListViewItem->lvItemEx.iItem) 
                        ? LVIS_STATEIMAGEMASK_UNCHECK : LVIS_STATEIMAGEMASK_CHECK;

        SetItemState(pListViewItem->lvItemEx.iItem,iStateMask,LVIS_STATEIMAGEMASK);
        
        return TRUE;
    }

    return fReturn; // default we pass it along
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\lib\debug.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Debug.cpp
//
//  Contents:   Debug Code
//
//  Classes:    
//
//  Notes:      
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "lib.h"

#ifdef _DEBUG

// globals for keeping track of debug flags
DWORD g_dwDebugLogAsserts = 0;

#endif // _DEBUG

#ifdef _DEBUG

//+---------------------------------------------------------------------------
//
//  Function:   InitDebugFlags, public
//
//  Synopsis:   Called to setup  global debugFlags
//
//  Arguments: 
//
//  Returns:    
//
//  Modifies:   
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI_(void) InitDebugFlags(void)
{
DWORD cbData;
DWORD cbType;
HKEY hkeyDebug;

    // always use Ansii version so can setup debug before

    g_dwDebugLogAsserts = 0;

    if (ERROR_SUCCESS == RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                          "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Syncmgr\\Debug"
						      ,0,KEY_READ,&hkeyDebug) )
    {
        cbType = REG_DWORD;
        cbData = sizeof(g_dwDebugLogAsserts);

        if (ERROR_SUCCESS != RegQueryValueExA(hkeyDebug,
		          "LogAsserts",
		          NULL,  
		          &cbType,    
		          (LPBYTE) &g_dwDebugLogAsserts,    
		          &cbData))
        {
	    g_dwDebugLogAsserts = 0;
        }

        RegCloseKey(hkeyDebug);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   FnAssert, public
//
//  Synopsis:   Displays the Assert dialog
//
//  Arguments:  [lpstrExptr] - Expression
//		[lpstrMsg] - Msg, if any, to append to the Expression
//		[lpstrFilename] - File Assert Occured in
//		[iLine] - Line Number of Assert
//
//  Returns:    Appropriate status code
//
//  Modifies:   
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------


STDAPI FnAssert( LPSTR lpstrExpr, LPSTR lpstrMsg, LPSTR lpstrFileName, UINT iLine )
{
    int iResult = 0;
    char lpTemp[] = "";
    char lpBuffer[512];
    char lpLocBuffer[256];


    if (NULL == lpstrMsg)
	    lpstrMsg = lpTemp;

    if (!g_dwDebugLogAsserts)
    {

        wnsprintfA(lpBuffer, ARRAYSIZE(lpBuffer), "Assertion \"%s\" failed! %s", lpstrExpr, lpstrMsg);
        wnsprintfA(lpLocBuffer, ARRAYSIZE(lpLocBuffer), "File %s, line %d; (A=exit; R=break; I=continue)", lpstrFileName, iLine);

        iResult = MessageBoxA(NULL, lpLocBuffer, lpBuffer,
		        MB_ABORTRETRYIGNORE | MB_SYSTEMMODAL);

        if (iResult == IDRETRY)
        {
            DebugBreak();
        }
        else if (iResult == IDABORT)
        {
            FatalAppExitA(0, "Assertion failure");
        }
    }
    else
    {
	    wnsprintfA(lpBuffer, ARRAYSIZE(lpBuffer), "Assertion \"%s\" failed! %s\n", lpstrExpr, lpstrMsg);
	    wnsprintfA(lpLocBuffer, ARRAYSIZE(lpLocBuffer), "File %s, line %d\n\n",lpstrFileName, iLine);

	    OutputDebugStringA(lpBuffer);
	    OutputDebugStringA(lpLocBuffer);
    }

    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Function:   FnTrace, public
//
//  Synopsis:   Displays the Assert dialog
//
//  Arguments: 	[lpstrMsg] - Msg in trace
//		[lpstrFilename] - File TRACE Occured in
//		[iLine] - Line Number of TRACE
//
//  Returns:    Appropriate status code
//
//  Modifies:   
//
//  History:    14-Jan-98      rogerg        Created.
//
//----------------------------------------------------------------------------


STDAPI FnTrace(LPSTR lpstrMsg, LPSTR lpstrFileName, UINT iLine )
{
    int iResult = 0;
    char lpTemp[] = "";
    char lpBuffer[512];

    if (NULL == lpstrMsg)
	    lpstrMsg = lpTemp;

    // should have flag to turn tracing on instead of changing header.
    wnsprintfA(lpBuffer, ARRAYSIZE(lpBuffer), "%s  %s(%d)\r\n",lpstrMsg,lpstrFileName,iLine);

    OutputDebugStringA(lpBuffer);

    return NOERROR;
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\lib\alloc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Alloc.cpp
//
//  Contents:   Allocation routines
//
//  Classes:
//
//  Notes:
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "lib.h"

//+-------------------------------------------------------------------
//
//  Function:    ::operator new
//
//  Synopsis:   Our operator new implementation
//
//  Arguments:  [size] -- Size of memory to allocate
//
//
//  Notes:
//
//--------------------------------------------------------------------

inline void* __cdecl operator new (size_t size)
{
    return(ALLOC(size));
}


//+-------------------------------------------------------------------
//
//  Function:    ::operator delete
//
//  Synopsis:   Our operator deleteimplementation
//
//  Arguments:  lpv-- Pointer to memory to free
//
//
//  Notes:
//
//--------------------------------------------------------------------

inline void __cdecl operator delete(void FAR* lpv)
{
    FREE(lpv);
}

//
// Allocator for MIDL stubs
//

//+-------------------------------------------------------------------
//
//  Function:   MIDL_user_allocate
//
//  Synopsis:   
//
//  Arguments:  lpv-- Pointer to memory to free
//
//
//  Notes:
//
//--------------------------------------------------------------------

extern "C" void __RPC_FAR * __RPC_API
MIDL_user_allocate(
    IN size_t len
    )
{
    return ALLOC(len);
}

//+-------------------------------------------------------------------
//
//  Function:   MIDL_user_free
//
//  Synopsis:   
//
//  Arguments:  ptr-- Pointer to memory to free
//
//
//  Notes:
//
//--------------------------------------------------------------------

extern "C" void __RPC_API
MIDL_user_free(
    IN void __RPC_FAR * ptr
    )
{
    FREE(ptr);
}

//+---------------------------------------------------------------------------
//
//  function:   ALLOC, public
//
//  Synopsis:   memory allocator
//
//  Arguments:  [cb] - requested size of memory to alloc.
//
//  Returns:    Pointer to newly allocated memory, NULL on failure
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

LPVOID ALLOC(ULONG cb)
{
void *pv;

    pv = LocalAlloc(LPTR,cb);

    return pv;
}


//+---------------------------------------------------------------------------
//
//  function:   FREE, public
//
//  Synopsis:   memory destructor
//
//  Arguments:  [pv] - pointer to memory to be released.
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------


void FREE(void* pv)
{
    LocalFree(pv);
}


//+---------------------------------------------------------------------------
//
//  function:   REALLOC, public
//
//  Synopsis:   reallocs memory
//
//  Arguments:  [ppv] - address of pointer to memory to be released.
//              [cb]  - size to resize the memory to.
//
//  Returns:    ERROR_SUCCESS if memory was successfully reallocated.
//
//              Win32 error value if memory was not successfully reallocated.
//              If an error occurs, the pointer addressed by ppv is unchanged,
//              the original memory buffer is left unchanged, and it is the 
//              caller's responsibility to free the original memory buffer.
//            
//  Modifies:
//
//  History:    22-Jul-98      rogerg        Created.
//              18-Jan-02      brianau       Rewrote to prevent leak on realloc
//                                           failure.
//
//----------------------------------------------------------------------------

DWORD REALLOC(void **ppv, ULONG cb)
{
    Assert(ppv);
    Assert(*ppv);

    void *pvNew = LocalReAlloc(*ppv, cb, LMEM_MOVEABLE);
    if (pvNew)
    {
        *ppv = pvNew;
        return ERROR_SUCCESS;
    }
    return GetLastError();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\lib\stringc.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       stringc.c
//
//  Contents:   SyncMgr string constants
//
//  History:    18-Feb-98   SusiA      Created.
//
//--------------------------------------------------------------------------

#include <objbase.h>

const WCHAR SZ_SYNCMGRNAME[] =  TEXT("Synchronization Manager");

const WCHAR REGSTR_WINLOGON[] = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon");
const WCHAR  REGSTR_DEFAULT_DOMAIN[] = TEXT("DefaultDomainName");

const WCHAR  CREATOR_SYNCMGR_TASK[] = L"SyncMgrInternalCreatorName";
const WCHAR  SCHED_COMMAND_LINE_ARG[] = L" /Schedule=";

// strings consts used for registration
// should have a preference class so these strings can be moved to the dll.
const WCHAR TOPLEVEL_REGKEY[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\SyncMgr");

const WCHAR HANDLERS_REGKEY[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\SyncMgr\\Handlers");
const WCHAR AUTOSYNC_REGKEY[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\SyncMgr\\AutoSync");
const WCHAR IDLESYNC_REGKEY[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\SyncMgr\\Idle");
const WCHAR SCHEDSYNC_REGKEY[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\SyncMgr\\SchedSync");
const WCHAR MANUALSYNC_REGKEY[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\SyncMgr\\Manual");
const WCHAR PROGRESS_REGKEY[]   = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\SyncMgr\\ProgressState");

const WCHAR SZ_IDLELASTHANDLERKEY[]  = TEXT("LastIdleHandler");
const WCHAR SZ_IDLERETRYMINUTESKEY[]  = TEXT("IdleRetryMinutes");
const WCHAR SZ_IDLEDELAYSHUTDOWNTIMEKEY[]  = TEXT("DelayShutDownTime");
const WCHAR SZ_IDLEREPEATESYNCHRONIZATIONKEY[] = TEXT("RepeatSynchronization");
const WCHAR SZ_IDLEWAITAFTERIDLEMINUTESKEY[] = TEXT("WaitMinutesAfterIdle");
const WCHAR SZ_IDLERUNONBATTERIESKEY[]    = TEXT("RunOnBattery");

const WCHAR SZ_REGISTRATIONFLAGSKEY[] = TEXT("RegistrationFlags");
const WCHAR SZ_REGISTRATIONTIMESTAMPKEY[] = TEXT("TimeStamp");

const WCHAR SZ_DEFAULTDOMAINANDUSERNAME[] = TEXT("Default");
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\lib\critsect.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       critsect.cpp
//
//  Contents:   critical section helper class
//
//  Classes:    CCriticalSection
//		CLockHandler
//		CLock
//		
//
//  Notes:      
//
//  History:    13-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "lib.h"

//+---------------------------------------------------------------------------
//
//  Member:     CLockHandler::CLockHandler, public
//
//  Synopsis:   Constructor
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

CLockHandler::CLockHandler()
{
    m_dwLockThreadId = 0;
    InitializeCriticalSection(&m_CriticalSection);
}

//+---------------------------------------------------------------------------
//
//  Member:     CLockHandler::~CLockHandler, public
//
//  Synopsis:   Destructor
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

CLockHandler::~CLockHandler()
{
    Assert (0 == m_dwLockThreadId);
    DeleteCriticalSection(&m_CriticalSection);
}

//+---------------------------------------------------------------------------
//
//  Member:     CLockHandler::Lock, public
//
//  Synopsis:   Adds a lock to the specified class
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

void CLockHandler::Lock(DWORD dwThreadId)
{ 
    EnterCriticalSection(&m_CriticalSection); 

    m_dwLockThreadId = dwThreadId;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLockHandler::UnLock, public
//
//  Synopsis:   Removes a lock to the specified class
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

void CLockHandler::UnLock()
{ 
    m_dwLockThreadId = 0;
    LeaveCriticalSection(&m_CriticalSection); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\types\proxy\dlldatax.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/


#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( mobsync )
EXTERN_PROXY_FILE( mobsyncp )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( mobsync ),
  REFERENCE_PROXY_FILE( mobsyncp ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\types\idl\makefile.inc ===
#
# Inference rules.
#
.SUFFIXES:.idl

# Copy .idl file from sdk\inc to here
{$(SDK_INC_PATH)}.idl{$(O)}.idl:
    copy $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\types\proxy\stub_mobsync_p.c ===
#include <mobsync_p.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\binary_release\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

!IFNDEF BUILDFLAVOR
BUILDFLAVOR=\fre
!ENDIF

!IFNDEF plat
plat=i386
!ENDIF


$(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\netfxstd.inf : $(SDXROOT)\com\netfx\Binary_release\$(plat)$(BUILDFLAVOR)\netfx.inf $(SDXROOT)\MergedComponents\SetupInfs\$(LANGUAGE)\mednames.txt
	-mkdir .$(BUILDFLAVOR)\$(O)
	$(SDXROOT)\tools\x86\unitext -m -o $(SDXROOT)\MergedComponents\SetupInfs\$(LANGUAGE)\mednames.txt $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\mednames.tmp
	copy $(SDXROOT)\com\netfx\Binary_release\$(plat)$(BUILDFLAVOR)\netfx.inf  +  \
	$(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\mednames.tmp \
	$(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\netfxocm.inf
	prodfilt -u $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\netfxocm.inf $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\netfxocm1.tmp +s
	prodfilt -u $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\netfxocm1.tmp $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\netfxstd.inf +i


$(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\netfxads.inf :  $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\netfxocm.inf
	prodfilt -u $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\netfxocm.inf $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\netfxocm2.tmp +e
	prodfilt -u $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\netfxocm2.tmp $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\netfxads.inf +i


$(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\netfxwbs.inf :  $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\netfxocm.inf
	prodfilt -u $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\netfxocm.inf $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\netfxocm3.tmp +b
	prodfilt -u $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\netfxocm3.tmp $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\netfxwbs.inf +i


$(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\netfxdct.inf :  $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\netfxocm.inf
	prodfilt -u $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\netfxocm.inf $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\netfxocm4.tmp +d
	prodfilt -u $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\netfxocm4.tmp $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\netfxdct.inf +i

$(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\netfxsbs.inf :  $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\netfxocm.inf
	prodfilt -u $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\netfxocm.inf $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\netfxocm5.tmp +l
	prodfilt -u $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\netfxocm5.tmp $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\netfxsbs.inf +i

$(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\aspstd.inf : $(SDXROOT)\com\netfx\Binary_release\$(plat)$(BUILDFLAVOR)\aspnet.inf $(SDXROOT)\MergedComponents\SetupInfs\$(LANGUAGE)\mednames.txt
	copy $(SDXROOT)\com\netfx\Binary_release\$(plat)$(BUILDFLAVOR)\aspnet.inf  +  \
	$(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\mednames.tmp \
	$(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\aspnetoc.inf
	prodfilt -u $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\aspnetoc.inf $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\aspnetoc1.tmp +s
	prodfilt -u $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\aspnetoc1.tmp $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\aspstd.inf +i


$(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\aspads.inf : $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\aspnetoc.inf
	prodfilt -u $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\aspnetoc.inf $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\aspnetoc2.tmp +e
	prodfilt -u $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\aspnetoc2.tmp $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\aspads.inf +i


$(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\aspwbs.inf : $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\aspnetoc.inf
	prodfilt -u $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\aspnetoc.inf $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\aspnetoc3.tmp +b
	prodfilt -u $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\aspnetoc3.tmp $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\aspwbs.inf +i


$(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\aspdct.inf : $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\aspnetoc.inf
	prodfilt -u $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\aspnetoc.inf $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\aspnetoc4.tmp +d
	prodfilt -u $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\aspnetoc4.tmp $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\aspdct.inf +i

$(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\aspsbs.inf : $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\aspnetoc.inf
	prodfilt -u $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\aspnetoc.inf $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\aspnetoc5.tmp +l
	prodfilt -u $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\aspnetoc5.tmp $(SDXROOT)\com\netfx\Binary_release$(BUILDFLAVOR)\$(O)\aspsbs.inf +i
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\types\proxy\stub_mobsyncp_p.c ===
#include <mobsyncp_p.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\types\proxy\prxstub.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       prxstub.c
//
//  Contents:   local marshalling code
//
//  Classes:    
//
//  Notes:   	HICON marshals are not explosed through ole32.def
//		so this file defines them locally and just turns
//		around and call the HWND routines which are exposed
//		and marshalled the same way HICON is internal in OLE.
//
//		If Ole32 adds this to the .def on all platforms interested
//		in remoting then this code is no longer necessary
//		   
//
//  History:    11-Nov-98   rogerg      Created.
//
//--------------------------------------------------------------------------

#ifdef _REMOTINTERFACES

#include "rpcproxy.h"

// local file to define unexported marshal interfaces

unsigned long  __RPC_USER  HICON_UserSize(
		unsigned long * pFlags,
		unsigned long   Offset,
		HICON * pH )
{

	return HWND_UserSize(pFlags,Offset ,(HWND *) pH);
}

unsigned char __RPC_FAR * __RPC_USER  HICON_UserMarshal( 
		unsigned long * pFlags,
		unsigned char * pBuffer,
		HICON	* pH)
{

	return HWND_UserMarshal( pFlags,pBuffer,(HWND *) pH);

}
 
unsigned char __RPC_FAR * __RPC_USER  HICON_UserUnmarshal(
		unsigned long * pFlags,
		unsigned char * pBuffer,
		HICON	* pH)
{

	return HWND_UserUnmarshal(pFlags
				,pBuffer
				, (HWND *) pH);
}

void    __RPC_USER  HICON_UserFree(
		unsigned long * pFlags,
		HICON	* pH)
{

	HWND_UserFree( pFlags,(HWND *) pH);
} 

#endif // #ifdef _REMOTINTERFACES
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\lib\util.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       util.cxx
//
//  Contents:   utility functions
//
//
//  History:    12-05-1997   SusiA
//
//---------------------------------------------------------------------------

#include "lib.h"
#ifndef SECURITY_WIN32
#define SECURITY_WIN32
#endif
#include "security.h"

CRITICAL_SECTION g_CritSectCommonLib; // initialized by InitCommonLib

void InitCommonLib()
{
    InitializeCriticalSection(&g_CritSectCommonLib);
}

void UnInitCommonLib(void)
{
    DeleteCriticalSection(&g_CritSectCommonLib);
}

typedef BOOLEAN (APIENTRY *PFNGETUSERNAMEEX) (EXTENDED_NAME_FORMAT NameFormat,
    LPWSTR lpNameBuffer, PULONG nSize );

STRING_FILENAME(szSecur32Dll, "SECUR32.DLL");
STRING_INTERFACE(szGetUserNameEx,"GetUserNameExW");
BOOL g_fLoadedSecur32 = FALSE;
HINSTANCE g_hinstSecur32 = NULL;
PFNGETUSERNAMEEX g_pfGetUserNameEx = NULL;

//+---------------------------------------------------------------------------
//
//  Function:   CenterDialog
//
//  Synopsis:   Helper to center a dialog on screen.
//
//  Arguments:  [hDlg]   -- Dialog handle.
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
CenterDialog(HWND hDlg)
{
    RECT rc;
    GetWindowRect(hDlg, &rc);

    SetWindowPos(hDlg,
                 NULL,
                 ((GetSystemMetrics(SM_CXSCREEN) - (rc.right - rc.left)) / 2),
                 ((GetSystemMetrics(SM_CYSCREEN) - (rc.bottom - rc.top)) / 2),
                 0,
                 0,
                 SWP_NOSIZE | SWP_NOACTIVATE);
}

void LoadSecur32Dll()
{
    if (g_fLoadedSecur32)
        return;

    CCriticalSection cCritSect(&g_CritSectCommonLib,GetCurrentThreadId());

    cCritSect.Enter();

    // make sure not loaded again in case someone took lock first
    if (!g_fLoadedSecur32)
    {
        g_hinstSecur32 = LoadLibrary(szSecur32Dll);

        if (g_hinstSecur32)
        {
	    g_pfGetUserNameEx = (PFNGETUSERNAMEEX) GetProcAddress(g_hinstSecur32, szGetUserNameEx);

	    // won't get the export on NT 4.0
  	}

        g_fLoadedSecur32 = TRUE;
    }

    cCritSect.Leave();

}

//+--------------------------------------------------------------------------
//
//  Function:   GetDefaultDomainAndUserName
//
//  Synopsis:   Fill [ptszDomainAndUserName] with "domain\user" string
//
//  Arguments:  [ptszDomainAndUserName] - buffer to receive string
//              [cchBuf]                - should be at least UNLEN
//
//  Modifies:   *[ptszDomainAndUserName].
//
//  History:    06-03-1997   DavidMun   Created
//
//  Notes:      If an error occurs while retrieving the domain name, only
//              the user name is returned.  If even that cannot be
//              retrieved, the buffer is set to an empty string.
//
//---------------------------------------------------------------------------

// if output buffer is too small it gets truncated.

VOID
GetDefaultDomainAndUserName(
    LPTSTR ptszDomainAndUserName,
    LPTSTR ptszSeparator,
    ULONG  cchBuf)
{
    HRESULT hr = E_FAIL;
    LONG  lr = 0;

    LoadSecur32Dll();
    
    if (g_pfGetUserNameEx)
    {
        ULONG cchTemp = cchBuf;
        lr = g_pfGetUserNameEx(NameSamCompatible,ptszDomainAndUserName, &cchTemp);
        
        if (lr)
        {
        LPTSTR ptszWorker = ptszDomainAndUserName;

            while ( (TEXT('\0') != *ptszWorker) && *ptszWorker != TEXT('\\'))
            {
                ptszWorker++;
            }

            if ( TEXT('\0') != *ptszWorker)
            {
                *ptszWorker = ptszSeparator[0];
            }
        }
    }

    Assert(NULL != *ptszDomainAndUserName);
    return;

}

//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL ConvertString(LPTSTR pszOut, LPWSTR pwszIn, DWORD dwSize)
//
//  PURPOSE: utility function for ANSI/UNICODE conversion
//
//  RETURN VALUE: return TRUE if we process it ok.
//
//+-------------------------------------------------------------------------------
BOOL ConvertString(char * pszOut, LPWSTR pwszIn, DWORD dwSize)
{

    if(WideCharToMultiByte( CP_ACP,0,pwszIn,-1,pszOut,dwSize,NULL,NULL))
    {
            return TRUE;
    }
    return FALSE;

}

//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL ConvertString(LPWSTR pwszOut, LPTSTR pszIn, DWORD dwSize)
//
//  PURPOSE: utility function for ANSI/UNICODE conversion
//
//  RETURN VALUE: return TRUE if we process it ok.
//
//+-------------------------------------------------------------------------------
BOOL ConvertString(LPWSTR pwszOut,char * pszIn, DWORD dwSize)
{

    if(MultiByteToWideChar( CP_ACP,0,pszIn,-1,pwszOut,dwSize))
    {
            return TRUE;
    }

    return FALSE;

}




//+-------------------------------------------------------------------------------
//
//  FUNCTION: Bogus function temporary until get transitioned to unicode
//      so I don't have to fix up every existing converstring call.
//
//  PURPOSE: utility function for ANSI/UNICODE conversion
//
//  RETURN VALUE: return TRUE if we process it ok.
//
//+-------------------------------------------------------------------------------

BOOL ConvertString(LPWSTR pszOut, LPWSTR pwszIn, DWORD dwSize)
{
    StrCpyN(pszOut, pwszIn, dwSize);
    return TRUE;
}

//
// Local constants
//
// DEFAULT_TIME_FORMAT - what to use if there's a problem getting format
//                       from system.
//
#define DEFAULT_TIME_FORMAT         TEXT("hh:mm tt")
#define GET_LOCALE_INFO(lcid)                           \
        {                                               \
            cch = GetLocaleInfo(LOCALE_USER_DEFAULT,    \
                                (lcid),                 \
                                tszScratch,             \
                                ARRAYLEN(tszScratch));  \
            if (!cch)                                   \
            {                                           \
                break;                                  \
            }                                           \
        }
//+--------------------------------------------------------------------------
//
//  Function:   UpdateTimeFormat
//
//  Synopsis:   Construct a time format containing hour and minute for use
//              with the date picker control.
//
//  Arguments:  [tszTimeFormat] - buffer to fill with time format
//              [cchTimeFormat] - size in chars of buffer
//
//  Modifies:   *[tszTimeFormat]
//
//  History:    11-18-1996   DavidMun   Created
//
//  Notes:      This is called on initialization and for wininichange
//              processing.
//
//---------------------------------------------------------------------------
void
UpdateTimeFormat(
        LPTSTR tszTimeFormat,
        ULONG  cchTimeFormat)
{
    ULONG cch;
    TCHAR tszScratch[80] = {0};
    BOOL  fAmPm         = FALSE;
    BOOL  fAmPmPrefixes = FALSE;
    BOOL  fLeadingZero  = FALSE;

    do
    {
        GET_LOCALE_INFO(LOCALE_ITIME);
        fAmPm = (*tszScratch == TEXT('0'));

        if (fAmPm)
        {
            GET_LOCALE_INFO(LOCALE_ITIMEMARKPOSN);
            fAmPmPrefixes = (*tszScratch == TEXT('1'));
        }

        GET_LOCALE_INFO(LOCALE_ITLZERO);
        fLeadingZero = (*tszScratch == TEXT('1'));

        GET_LOCALE_INFO(LOCALE_STIME);

        //
        // See if there's enough room in destination string
        //

        cch = 1                     +  // terminating nul
              1                     +  // first hour digit specifier "h"
              2                     +  // minutes specifier "mm"
              (fLeadingZero != 0)   +  // leading hour digit specifier "h"
              lstrlen(tszScratch)   +  // separator string
              (fAmPm ? 3 : 0);         // space and "tt" for AM/PM

        if (cch > cchTimeFormat)
        {
            cch = 0; // signal error
        }
    } while (0);

    //
    // If there was a problem in getting locale info for building time string
    // just use the default and bail.
    //

    if (!cch)
    {
        StrCpyN(tszTimeFormat, DEFAULT_TIME_FORMAT, cchTimeFormat);
        return;
    }

    //
    // Build a time string that has hours and minutes but no seconds.
    //

    tszTimeFormat[0] = TEXT('\0');

    if (fAmPm)
    {
        if (fAmPmPrefixes)
        {
            StrCpyN(tszTimeFormat, TEXT("tt "), cchTimeFormat);
        }

        StrCatBuff(tszTimeFormat, TEXT("h"), cchTimeFormat);

        if (fLeadingZero)
        {
            StrCatBuff(tszTimeFormat, TEXT("h"), cchTimeFormat);
        }
    }
    else
    {
        StrCatBuff(tszTimeFormat, TEXT("H"), cchTimeFormat);

        if (fLeadingZero)
        {
            StrCatBuff(tszTimeFormat, TEXT("H"), cchTimeFormat);
        }
    }

    StrCatBuff(tszTimeFormat, tszScratch, cchTimeFormat); // separator
    StrCatBuff(tszTimeFormat, TEXT("mm"), cchTimeFormat);

    if (fAmPm && !fAmPmPrefixes)
    {
        StrCatBuff(tszTimeFormat, TEXT(" tt"), cchTimeFormat);
    }
}

//+--------------------------------------------------------------------------
//
//  Function:   FillInStartDateTime
//
//  Synopsis:   Fill [pTrigger]'s starting date and time values from the
//              values in the date/time picker controls.
//
//  Arguments:  [hwndDatePick] - handle to control with start date
//              [hwndTimePick] - handle to control with start time
//              [pTrigger]     - trigger to init
//
//  Modifies:   *[pTrigger]
//
//  History:    12-08-1997   SusiA      Stole from task scheduler
//
//---------------------------------------------------------------------------

VOID FillInStartDateTime( HWND hwndDatePick, HWND hwndTimePick,TASK_TRIGGER *pTrigger)
{
    SYSTEMTIME st;

    DateTime_GetSystemtime(hwndDatePick, &st);

    pTrigger->wBeginYear  = st.wYear;
    pTrigger->wBeginMonth = st.wMonth;
    pTrigger->wBeginDay   = st.wDay;

    DateTime_GetSystemtime(hwndTimePick, &st);

    pTrigger->wStartHour   = st.wHour;
    pTrigger->wStartMinute = st.wMinute;
}


//+---------------------------------------------------------------------------
//
//  function:     InsertListViewColumn, private
//
//  Synopsis:   Inserts a column into the ListView..
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    30-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------


BOOL InsertListViewColumn(CListView *pListView,int iColumnId,LPWSTR pszText,int fmt,int cx)
{
LV_COLUMN columnInfo;

    columnInfo.mask = LVCF_FMT  | LVCF_TEXT  | LVCF_WIDTH  | LVCF_SUBITEM;
    columnInfo.fmt = fmt;
    columnInfo.cx = cx;
    columnInfo.pszText = pszText;
    columnInfo.iSubItem = 0;


    return pListView->InsertColumn(iColumnId,&columnInfo);
}


//+--------------------------------------------------------------------------
//
//  Function:   InitResizeItem
//
//  Synopsis:   Setups the ResizeInfo Structure.
//
//              !!Can either pass in a ParentScreenRect or
//              function will calculate. If passing in
//              make sure you don't include the NC area
//              of the window. See code below GetClientRect on parent
//              then ClientToScreen.
//
//  Arguments:
//
//  Modifies:
//
//  History:    30-07-1998   rogerg
//
//---------------------------------------------------------------------------

BOOL InitResizeItem(int iCtrlId,DWORD dlgResizeFlags,HWND hwndParent,
                        LPRECT pParentClientRect,DLGRESIZEINFO *pDlgResizeInfo)
{
RECT rectCtrl;
RECT rectLocalParentScreenRect;

    Assert(pDlgResizeInfo);

    Assert(0 == pParentClientRect->left); // catch any case not handing in ClientRect.

    pDlgResizeInfo->iCtrlId = -1;  // set ctrlId to -1 so GetDlgItem will fail in resize


    // if dont' have parentScreenRect get it ourselves
    if (!pParentClientRect)
    {
        pParentClientRect = &rectLocalParentScreenRect;

        if (!GetClientRect(hwndParent,&rectLocalParentScreenRect))
        {
            AssertSz(0,"Unable to get Parent Rects");
            return FALSE;
        }

    }

    Assert(pParentClientRect);

    if (!GetWindowRect(GetDlgItem(hwndParent,iCtrlId),&rectCtrl))
    {
        AssertSz(0,"Failed to GetWindowRect");
        return FALSE;
    }

    MapWindowPoints(NULL,hwndParent,(LPPOINT) &rectCtrl,2);

    pDlgResizeInfo->iCtrlId  = iCtrlId;
    pDlgResizeInfo->hwndParent =  hwndParent;
    pDlgResizeInfo->dlgResizeFlags = dlgResizeFlags;

    // calc the offsets
 
    pDlgResizeInfo->rectParentOffsets.left = rectCtrl.left - pParentClientRect->left;
    pDlgResizeInfo->rectParentOffsets.top = rectCtrl.top - pParentClientRect->top;

    pDlgResizeInfo->rectParentOffsets.right = pParentClientRect->right - rectCtrl.right;
    pDlgResizeInfo->rectParentOffsets.bottom = pParentClientRect->bottom - rectCtrl.bottom;

    return TRUE;

}


//+--------------------------------------------------------------------------
//
//  Function:   ResizeItems
//
//  Synopsis:   Resizes the Item.
//
//
//  Arguments:
//
//  Modifies:
//
//  History:    30-07-1998   rogerg
//
//---------------------------------------------------------------------------

void ResizeItems(ULONG cbNumItems,DLGRESIZEINFO *pDlgResizeInfo)
{
RECT rectLocalParentClientCoord; // used if caller doesn't pass in parent coords.
DWORD dlgResizeFlags;
LPRECT  prectOffsets;
RECT rectClient;
HWND hwndCtrl;
HWND hwndLastParent = NULL;
LPRECT prectParentClientCoords = NULL;
ULONG ulCount;
DLGRESIZEINFO *pCurDlgResizeInfo;
int x,y,cx,cy;


    if (!pDlgResizeInfo)
    {
        Assert(pDlgResizeInfo);
    }


    for (ulCount = 0; ulCount < cbNumItems; ulCount++)
    {

        pCurDlgResizeInfo = &(pDlgResizeInfo[ulCount]);

        dlgResizeFlags =  pCurDlgResizeInfo->dlgResizeFlags;
        prectOffsets =    &(pCurDlgResizeInfo->rectParentOffsets);

        // if not pinright or pin bottom there is nothing
        // to do.
        if (!(dlgResizeFlags & DLGRESIZEFLAG_PINRIGHT) &&
                !(dlgResizeFlags &  DLGRESIZEFLAG_PINBOTTOM) )
        {
            continue;
        }

        if (NULL == prectParentClientCoords || (hwndLastParent != pCurDlgResizeInfo->hwndParent))
        {
            prectParentClientCoords = &rectLocalParentClientCoord;

            if (!GetClientRect(pCurDlgResizeInfo->hwndParent,&rectLocalParentClientCoord))
            {
                prectParentClientCoords = NULL; // if GetClientRect failed for a recalc on next item
                continue;
            }

            hwndLastParent = pCurDlgResizeInfo->hwndParent; // set lastparent now that we calc'd the rect.        
        }

        Assert(prectParentClientCoords);

        hwndCtrl = GetDlgItem(pCurDlgResizeInfo->hwndParent,pCurDlgResizeInfo->iCtrlId);

        if ( (NULL == hwndCtrl) || !(GetWindowRect(hwndCtrl,&rectClient)) )
        {
            continue;
        }

        // get current values
        x = (prectParentClientCoords->left + prectOffsets->left);
        y = (prectParentClientCoords->top + prectOffsets->top);

        cx = WIDTH(rectClient);
        cy = HEIGHT(rectClient);

        // if pinned both right and left adjust the width
        if ((dlgResizeFlags & DLGRESIZEFLAG_PINLEFT)
            && (dlgResizeFlags & DLGRESIZEFLAG_PINRIGHT))
        {
            cx = prectParentClientCoords->right - (prectOffsets->right + prectOffsets->left);
        }

        // if pinned both top and bottom adjust height
        if ((dlgResizeFlags & DLGRESIZEFLAG_PINTOP)
            && (dlgResizeFlags & DLGRESIZEFLAG_PINBOTTOM))
        {
            cy = prectParentClientCoords->bottom - (prectOffsets->bottom + prectOffsets->top);
        }

        // adjust the x position if pin right
        if (dlgResizeFlags & DLGRESIZEFLAG_PINRIGHT)
        { 
            x = (prectParentClientCoords->right - prectOffsets->right)  - cx;
        }

        // adjust the y position if pin bottom
        if (dlgResizeFlags & DLGRESIZEFLAG_PINBOTTOM)
        {
            y = (prectParentClientCoords->bottom - prectOffsets->bottom)   - cy;
        }

        SetWindowPos(hwndCtrl, 0,x,y,cx,cy,SWP_NOZORDER | SWP_NOACTIVATE);
    }

    // now that the items are moved, loop through them again invalidating
    // any items with the nocopy bits flag set

    for (ulCount = 0; ulCount < cbNumItems; ulCount++)
    {
        pCurDlgResizeInfo = &(pDlgResizeInfo[ulCount]);

        if (pCurDlgResizeInfo->dlgResizeFlags & DLGRESIZEFLAG_NOCOPYBITS)
        {
            hwndCtrl = GetDlgItem(pCurDlgResizeInfo->hwndParent,pCurDlgResizeInfo->iCtrlId);

            if (hwndCtrl && GetClientRect(hwndCtrl,&rectClient))
            {
                InvalidateRect(hwndCtrl,&rectClient,FALSE);
            }
        }

    }


}


//+--------------------------------------------------------------------------
//
//  Function:   CalcListViewWidth
//
//  Synopsis:   Calcs width of listview - scroll bars
//
//
//  Arguments:
//
//  Modifies:
//
//  History:    30-07-1998   rogerg
//
//---------------------------------------------------------------------------

int CalcListViewWidth(HWND hwndList,int iDefault)
{
NONCLIENTMETRICSA metrics;
RECT rcClientRect;


    metrics.cbSize = sizeof(metrics);

    // explicitly ask for ANSI version of SystemParametersInfo since we just
    // care about the ScrollWidth and don't want to conver the LOGFONT info.
    if (GetClientRect(hwndList,&rcClientRect)
        && SystemParametersInfoA(SPI_GETNONCLIENTMETRICS,sizeof(metrics),(PVOID) &metrics,0))
    {
        // subtract off scroll bar distance
        rcClientRect.right -= (metrics.iScrollWidth);
    }
    else
    {
        rcClientRect.right = iDefault;  // if fail, use default
    }


    return rcClientRect.right;
}

//+--------------------------------------------------------------------------
//
//  Function:   IsHwndRightToLeft
//
//  Synopsis:   determine if hwnd is right to left.
//
//
//  Arguments:
//
//  Modifies:
//
//  History:    04-02-1999   rogerg
//
//---------------------------------------------------------------------------

BOOL IsHwndRightToLeft(HWND hwnd)
{
LONG_PTR ExStyles;

    if (NULL == hwnd)
    {
        Assert(hwnd);
        return FALSE;
    }

    ExStyles = GetWindowLongPtr(hwnd,GWL_EXSTYLE);

    if (WS_EX_LAYOUTRTL  & ExStyles)
    {
        // this is righ to left
        return TRUE;
    }

    return FALSE;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetDateFormatReadingFlags
//
//  Synopsis:   returns necessary flags settings for passing proper
//              Reading order flags to GetDateFormat()
//
//
//  Arguments:
//
//  Modifies:
//
//  History:    09-07-1999   rogerg
//
//---------------------------------------------------------------------------

DWORD GetDateFormatReadingFlags(HWND hwnd)
{
DWORD dwDateReadingFlags = 0;
LCID locale = GetUserDefaultLCID();

     // only set on NT 5.0 or higher.
    if ((PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_ARABIC)
        || (PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_HEBREW))
    {
    LONG_PTR dwExStyle = GetWindowLongPtr(hwnd, GWL_EXSTYLE);

        if ((!!(dwExStyle & WS_EX_RTLREADING)) != (!!(dwExStyle & WS_EX_LAYOUTRTL)))
        {
            dwDateReadingFlags = DATE_RTLREADING;
        }
        else
        {
            dwDateReadingFlags = DATE_LTRREADING;
        }
    }  
 
    return dwDateReadingFlags;
}

//+--------------------------------------------------------------------------
//
//  Function:   QueryHandleException
//
//  Synopsis:   in debug prompts user how to handle the exception
//              return always handle.
//
//
//  Arguments:
//
//  Modifies:
//
//  History:    01-04-1999   rogerg
//
//---------------------------------------------------------------------------

extern DWORD g_dwDebugLogAsserts; // conform to logAsserts

BOOL QueryHandleException(void)
{
#ifndef _DEBUG
    return EXCEPTION_EXECUTE_HANDLER;
#else // _DEBUG

    int iMsgResult = 0;
    BOOL fQueryResult = EXCEPTION_EXECUTE_HANDLER;

    // if logging asserts just execute the handler
    if (g_dwDebugLogAsserts)
    {
        return EXCEPTION_EXECUTE_HANDLER;
    }

    iMsgResult = MessageBoxA(NULL,
                    "An Exception Occured.\nWould you like to Debug this Exception?", 
                    "Exception Failure.",
		    MB_YESNO | MB_SYSTEMMODAL);

    if (iMsgResult == IDYES)
    {
        fQueryResult = EXCEPTION_CONTINUE_SEARCH;
    }

    // ask the User what they want to do
    return fQueryResult;

#endif // _DEBUG
}

// following are routines for calling sens service directly to write HKLM data
// for us on a locked down machine

#define _SENSCALLS
#define _SENSINTERNAL

#ifdef _SENSCALLS

#include "notify.h"

// may or may not need depending on if in sensapip.h

DWORD SyncMgrExecCmd(DWORD nCmdID, DWORD nCmdOpt);

typedef enum SYNCMGRCMDEXECID
{
    SYNCMGRCMDEXECID_UPDATERUNKEY = 1, 
    SYNCMGRCMDEXECID_RESETREGSECURITY = 2,
} SYNCMGRCMDEXECID;


#ifdef _SENSINTERNAL
// functions for if want to call sens internal without
// dependency on sensapip.lib

// these defines are from Sens common.h
#define SENS_PROTSEQ  TEXT("ncalrpc")
#define SENS_ENDPOINT TEXT("senssvc")


RPC_STATUS GetSensNotifyBindHandle(RPC_BINDING_HANDLE *phSensNotify)
{
RPC_STATUS status = RPC_S_OK;
WCHAR * BindingString = NULL;
SID LocalSystem = { 1, 1, SECURITY_NT_AUTHORITY, SECURITY_LOCAL_SYSTEM_RID};
RPC_SECURITY_QOS_V3 RpcSecQos;

    status = RpcStringBindingCompose(
                 NULL,               // NULL ObjUuid
                 SENS_PROTSEQ,
                 NULL,               // Local machine
                 SENS_ENDPOINT,
                 NULL,               // No Options
                 &BindingString
                 );

    if (BindingString != NULL)
    {
        *phSensNotify = NULL;
        status = RpcBindingFromStringBinding(BindingString,phSensNotify);
        RpcStringFree(&BindingString);

        if (RPC_S_OK == status)
        {
            RpcSecQos.Version= RPC_C_SECURITY_QOS_VERSION_3;
            RpcSecQos.ImpersonationType= RPC_C_IMP_LEVEL_IMPERSONATE;
            RpcSecQos.IdentityTracking= RPC_C_QOS_IDENTITY_DYNAMIC;
            RpcSecQos.Capabilities= RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;
            RpcSecQos.AdditionalSecurityInfoType = 0;
            RpcSecQos.u.HttpCredentials = NULL;
            RpcSecQos.Sid = (PVOID)&LocalSystem;

            status= RpcBindingSetAuthInfoEx(*phSensNotify,
                                            NULL,
                                            RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                            RPC_C_AUTHN_WINNT,
                                            NULL,
                                            RPC_C_AUTHZ_NONE,
                                            (RPC_SECURITY_QOS *)&RpcSecQos);

            if (RPC_S_OK != status)
            {
                RpcBindingFree(phSensNotify);
                *phSensNotify = NULL;
            }
        }
    }

    return (status);
}



RPC_STATUS SyncMgrExecCmdInternal(DWORD nCmdID, DWORD nCmdOpt)
{
RPC_STATUS status;
RPC_BINDING_HANDLE hSensNotify;

    status = GetSensNotifyBindHandle(&hSensNotify);
    
    if (RPC_S_OK != status)
    {
        return status;
    }
    
    status = RPC_SyncMgrExecCmd(hSensNotify,nCmdID,nCmdOpt);

    RpcBindingFree(&hSensNotify);
    
    return status;
}

#endif // _SENSINTERNAL

//+--------------------------------------------------------------------------
//
//  Function:   SyncMgrExecCmdp
//
//  Synopsis:  helper function that actually calls into sensapip.lib
//
//
//  Arguments:
//
//  Modifies:
//
//  History:   03-11-99 rogerg  created
//
//---------------------------------------------------------------------------

BOOL SyncMgrExecCmdp(DWORD nCmdID, DWORD nCmdOpt)
{
RPC_STATUS RpcStatus;
HRESULT hr;
BOOL fReturn = FALSE;

    __try
    {

#ifdef _SENSINTERNAL
	RpcStatus = SyncMgrExecCmdInternal(nCmdID,nCmdOpt);
#else
        RpcStatus = SyncMgrExecCmd(nCmdID,nCmdOpt);
#endif // _SENSINTERNAL
        fReturn = (RPC_S_OK == RpcStatus ) ? TRUE: FALSE;

    }
    __except(QueryHandleException())
    {
        hr = HRESULT_FROM_WIN32(GetExceptionCode());
        AssertSz(0,"Exception Calling SensApip_SyncMgrExecCmd");
    }

    return fReturn;
}


#endif // _SENSCALLS


//+--------------------------------------------------------------------------
//
//  Function:   SyncMgrExecCmd_UpdateRunKey
//
//  Synopsis:  Calls SENS Service to write or remove the run Key
//
//
//  Arguments:
//
//  Modifies:
//
//  History:   03-11-99 rogerg  created
//
//---------------------------------------------------------------------------

BOOL SyncMgrExecCmd_UpdateRunKey(BOOL fSet)
{
BOOL fReturn = FALSE;
CCriticalSection cCritSect(&g_CritSectCommonLib,GetCurrentThreadId());

    cCritSect.Enter(); // DoRpcSetup in Sensapip is not thread safe.
#ifdef _SENSCALLS
    fReturn = SyncMgrExecCmdp(
            SYNCMGRCMDEXECID_UPDATERUNKEY,fSet ? 1 : 0);
#endif // _SENSCALLS
    cCritSect.Leave();


    return fReturn;
}

//+--------------------------------------------------------------------------
//
//  Function:   SyncMgrExecCmd_ResetRegSecurity
//
//  Synopsis:  Calls SENS Service to reset the security on regkeys 
//              to everyone.
//
//
//  Arguments:
//
//  Modifies:
//
//  History:   03-11-99 rogerg  created
//
//---------------------------------------------------------------------------

BOOL SyncMgrExecCmd_ResetRegSecurity(void)
{
BOOL fReturn = FALSE;
CCriticalSection cCritSect(&g_CritSectCommonLib,GetCurrentThreadId());

    cCritSect.Enter(); // DoRpcSetup in Sensapip is not thread safe.
#ifdef _SENSCALLS
    fReturn = SyncMgrExecCmdp(SYNCMGRCMDEXECID_RESETREGSECURITY,0);
#endif // _SENSCALLS
    cCritSect.Leave(); 

    return fReturn;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetUserTextualSid
//
//  Synopsis:   Get a user SID and convert to its string representation
//
//----------------------------------------------------------------------------

BOOL 
GetUserTextualSid(
    LPTSTR pszSidText,  // buffer for Textual representaion of Sid
    DWORD cchSidText    // provided pszSidText buffersize
    )
{
    // Get user's SID from current process token
    HANDLE hToken;
    BOOL bResult = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken);
    if (bResult)
    {
        BYTE buf[MAX_PATH];
        PTOKEN_USER pTokenInfo = (PTOKEN_USER)buf;
        DWORD cbTokenInfo = sizeof (buf);
        bResult = GetTokenInformation(hToken, TokenUser, pTokenInfo, cbTokenInfo,  &cbTokenInfo);
        if (bResult)
        {
            PSID pSid = pTokenInfo->User.Sid;
            if (pSid && IsValidSid(pSid))
            {
                // Convert the SID to a string
                LPWSTR pszTempSid;
                bResult = ConvertSidToStringSidW(pSid, &pszTempSid);
                if (bResult)
                {
                    if (FAILED(StringCchCopy(pszSidText, cchSidText, pszTempSid)))
                    {
                        bResult = FALSE;
                    }
                    LocalFree(pszTempSid);
                }
            }
            else
            {
                bResult = FALSE;
            }
        }
        CloseHandle(hToken);
    }

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\syncmgr\lib\validate.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       validate.cpp
//
//  Contents:   validation routines
//
//  Classes:
//
//  Notes:
//
//  History:    13-Aug-98   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "lib.h"



//+---------------------------------------------------------------------------
//
//  function:   IsValidSyncMgrItem
//
//  Synopsis:   validates SYNCMGRITEM
//
//  Arguments:  
//
//  Returns:   TRUE if valid.
//
//  Modifies:
//
//  History:    13-Aug-98       rogerg        Created.
//
//+---------------------------------------------------------------------------

BOOL IsValidSyncMgrItem(SYNCMGRITEM *poffItem)
{
BOOL fValid = TRUE;

    if (NULL == poffItem)
    {
        Assert(poffItem);
        return FALSE;
    }
    __try
    {
        if (poffItem->cbSize == sizeof(SYNCMGRITEM))
        {
        
            if ( (0 != (poffItem->dwFlags & ~(SYNCMGRITEM_ITEMFLAGMASK) ) )
                || (SYNCMGRITEMSTATE_CHECKED <  poffItem->dwItemState) )
            {
                AssertSz(0,"Invalid SYNCMGRITEM returned from Enumerator");
                Assert(0 == (poffItem->dwFlags & ~(SYNCMGRITEM_ITEMFLAGMASK)));
                Assert(SYNCMGRITEMSTATE_CHECKED >= poffItem->dwItemState);

                fValid = FALSE;
            }
            else if (GUID_NULL == poffItem->ItemID)
            {
                AssertSz(0,"ItemID Cannot be GUID_NULL");
                fValid = FALSE;
            }
        }
        else
        {
            AssertSz(0,"Invalid SYNCMGRITEM returned from Enumerator");
            fValid = FALSE;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //bogus non-NULL pointer.
        AssertSz(0,"Bogus, non-NULL SYNCMGRITEM pointer returned from Enumerator");
        fValid = FALSE;
    }
    return fValid;
}

//+---------------------------------------------------------------------------
//
//  function:   IsValidSyncMgrHandlerInfo
//
//  Synopsis:   validates SYNCMGRITEM
//
//  Arguments:  
//
//  Returns:   TRUE if valid.
//
//  Modifies:
//
//  History:    13-Aug-98       rogerg        Created.
//
//+---------------------------------------------------------------------------

BOOL IsValidSyncMgrHandlerInfo(LPSYNCMGRHANDLERINFO pSyncMgrHandlerInfo)
{
    // validate the arguments.
    __try
    {
        if ( (pSyncMgrHandlerInfo->cbSize != sizeof(SYNCMGRHANDLERINFO))
            || (0 != (pSyncMgrHandlerInfo->SyncMgrHandlerFlags & ~(SYNCMGRHANDLERFLAG_MASK))) )
        {
            AssertSz(0,"Invalid HandlerInfo Size returned from GetHandlerInfo");
            Assert(pSyncMgrHandlerInfo->cbSize == sizeof(SYNCMGRHANDLERINFO));
            Assert(0 == (pSyncMgrHandlerInfo->SyncMgrHandlerFlags & ~(SYNCMGRHANDLERFLAG_MASK)));

            return FALSE;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        AssertSz(0,"Bogus, non-NULL LPSYNCMGRHANDLERINFO pointer.");
        return FALSE;
    }
    return TRUE;
}



//+---------------------------------------------------------------------------
//
//  Function:   IsValidSyncProgressItem, private
//
//  Synopsis:   Determines if the syncprogress item structure is valid
//
//  Arguments:  [lpProgItem] - Pointer to SyncProgress Item to validate.
//
//  Returns:    Returns true is the structure is valid.
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL IsValidSyncProgressItem(LPSYNCMGRPROGRESSITEM lpProgItem)
{

    if (NULL == lpProgItem)
    {
        Assert(lpProgItem);
        return FALSE;
    }
    __try
    {
        if (lpProgItem->cbSize != sizeof(SYNCMGRPROGRESSITEM))
        {
            AssertSz(0,"SYNCMGRPROGRESSITEM cbSize Incorrect");
            return FALSE;
        }

        if (lpProgItem->mask >= (SYNCMGRPROGRESSITEM_MAXVALUE << 1))
        {
            AssertSz(0,"Invalid ProgressItem Mask");
            return FALSE;
        }

        if (SYNCMGRPROGRESSITEM_STATUSTYPE & lpProgItem->mask)
        {
            if (lpProgItem->dwStatusType  >  SYNCMGRSTATUS_RESUMING)
            {
                AssertSz(0,"Unknown StatusType passed to Progress");
                return FALSE;
            }

        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        AssertSz(0,"Bogus, non-NULL LPSYNCMGRPROGRESSITEM pointer.");
        return FALSE;
    }
    
    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:   IsValidSyncLogErrorInfo, private
//
//  Synopsis:   Determines if the ErrorInfomation is valid,
//
//  Arguments:  [lpLogError] - Pointer to LogError structure to validate.
//
//  Returns:    Returns true is the structure is valid.
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

#define SYNCMGRLOGERROR_VALIDMASK (SYNCMGRLOGERROR_ERRORFLAGS | SYNCMGRLOGERROR_ERRORID | SYNCMGRLOGERROR_ITEMID)
#define SYNCMGRERRROFLAG_MASK (SYNCMGRERRORFLAG_ENABLEJUMPTEXT)

BOOL IsValidSyncLogErrorInfo(DWORD dwErrorLevel,const WCHAR *lpcErrorText,
                                        LPSYNCMGRLOGERRORINFO lpSyncLogError)
{

    if (SYNCMGRLOGLEVEL_ERROR < dwErrorLevel)
    {
        AssertSz(0,"Invalid ErrorLevel");
        return FALSE;
    }

    // must provide error text
    if (NULL == lpcErrorText)
    {
        AssertSz(0,"Invalid ErrorText");
        return FALSE;
    }

    // Optional to have the LogError information.
    __try
    {
        if (lpSyncLogError)
        {
            if (lpSyncLogError->cbSize != sizeof(SYNCMGRLOGERRORINFO))
            {
                AssertSz(0,"Unknown LogError cbSize");
                return FALSE;
            }

            if (0 != (lpSyncLogError->mask & ~(SYNCMGRLOGERROR_VALIDMASK)) )
            {
                AssertSz(0,"Invalid LogError Mask");
                return FALSE;
            }

            if (lpSyncLogError->mask & SYNCMGRLOGERROR_ERRORFLAGS)
            {
                if (0 != (~(SYNCMGRERRROFLAG_MASK) & lpSyncLogError->dwSyncMgrErrorFlags))
                {
                    AssertSz(0,"Invalid LogError ErrorFlags");
                    return FALSE;
                }

            }

        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        AssertSz(0,"Bogus, non-NULL LPSYNCMGRLOGERRORINFO pointer.");
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\binary_release\i386\fre\aspnet_perf.h ===
#define OBJECT_1                                           0
#define OBJECT_2                                           2
#define ASPNET_APPLICATION_RESTARTS                        4
#define ASPNET_APPLICATIONS_RUNNING                        6
#define ASPNET_REQUESTS_DISCONNECTED                       8
#define ASPNET_REQUEST_EXECUTION_TIME                      10
#define ASPNET_REQUESTS_REJECTED                           12
#define ASPNET_REQUESTS_QUEUED                             14
#define ASPNET_WPS_RUNNING                                 16
#define ASPNET_WPS_RESTARTS                                18
#define ASPNET_REQUEST_WAIT_TIME                           20
#define ASPNET_STATE_SERVER_SESSIONS_ACTIVE                22
#define ASPNET_STATE_SERVER_SESSIONS_ABANDONED             24
#define ASPNET_STATE_SERVER_SESSIONS_TIMED_OUT             26
#define ASPNET_STATE_SERVER_SESSIONS_TOTAL                 28
#define ASPNET_REQUESTS_CURRENT                            30
#define ASPNET_ANONYMOUS_REQUESTS                          32
#define ASPNET_ANONYMOUS_REQUESTS_RATE                     34
#define ASPNET_TOTAL_CACHE_ENTRIES                         36
#define ASPNET_TOTAL_CACHE_TURNOVER_RATE                   38
#define ASPNET_TOTAL_CACHE_HITS                            40
#define ASPNET_TOTAL_CACHE_MISSES                          42
#define ASPNET_TOTAL_CACHE_RATIO                           44
#define ASPNET_TOTAL_CACHE_RATIO_BASE                      46
#define ASPNET_API_CACHE_ENTRIES                           48
#define ASPNET_API_CACHE_TURNOVER_RATE                     50
#define ASPNET_API_CACHE_HITS                              52
#define ASPNET_API_CACHE_MISSES                            54
#define ASPNET_API_CACHE_RATIO                             56
#define ASPNET_API_CACHE_RATIO_BASE                        58
#define ASPNET_OUTPUT_CACHE_ENTRIES                        60
#define ASPNET_OUTPUT_CACHE_TURNOVER_RATE                  62
#define ASPNET_OUTPUT_CACHE_HITS                           64
#define ASPNET_OUTPUT_CACHE_MISSES                         66
#define ASPNET_OUTPUT_CACHE_RATIO                          68
#define ASPNET_OUTPUT_CACHE_RATIO_BASE                     70
#define ASPNET_COMPILATIONS                                72
#define ASPNET_DEBUGGING_REQUESTS                          74
#define ASPNET_ERRORS_PRE_PROCESSING                       76
#define ASPNET_ERRORS_COMPILING                            78
#define ASPNET_ERRORS_DURING_REQUEST                       80
#define ASPNET_ERRORS_UNHANDLED                            82
#define ASPNET_ERRORS_UNHANDLED_RATE                       84
#define ASPNET_ERRORS_TOTAL                                86
#define ASPNET_ERRORS_TOTAL_RATE                           88
#define ASPNET_PIPELINES                                   90
#define ASPNET_REQUEST_BYTES_IN                            92
#define ASPNET_REQUEST_BYTES_OUT                           94
#define ASPNET_REQUESTS_EXECUTING                          96
#define ASPNET_REQUESTS_FAILED                             98
#define ASPNET_REQUESTS_NOT_FOUND                          100
#define ASPNET_REQUESTS_NOT_AUTHORIZED                     102
#define ASPNET_REQUESTS_IN_APPLICATION_QUEUE               104
#define ASPNET_REQUESTS_TIMED_OUT                          106
#define ASPNET_REQUESTS_SUCCEDED                           108
#define ASPNET_REQUESTS_TOTAL                              110
#define ASPNET_REQUESTS_TOTAL_RATE                         112
#define ASPNET_SESSIONS_ACTIVE                             114
#define ASPNET_SESSIONS_ABANDONED                          116
#define ASPNET_SESSIONS_TIMED_OUT                          118
#define ASPNET_SESSIONS_TOTAL                              120
#define ASPNET_TRANSACTIONS_ABORTED                        122
#define ASPNET_TRANSACTIONS_COMMITTED                      124
#define ASPNET_TRANSACTIONS_PENDING                        126
#define ASPNET_TRANSACTIONS_TOTAL                          128
#define ASPNET_TRANSACTIONS_RATE                           130
#define ASPNET_SESSION_STATE_SERVER_CONNECTIONS            132
#define ASPNET_SESSION_SQL_SERVER_CONNECTIONS              134
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\binary_release\i386\fre\corperfmonsymbols.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//------------------------------------------------------------------------ 
// WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING 
//
//   AUTO GENERATED FILE. DO NOT EDIT. USE $/com99/src/profile/perfmonhelp 
//
// WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING 
//------------------------------------------------------------------------ 
#define DotNetCLR_Memory_OBJECT                            0
#define GEN0_COLLECTIONS_COUNTER                           2
#define GEN1_COLLECTIONS_COUNTER                           4
#define GEN2_COLLECTIONS_COUNTER                           6
#define GEN0_BYTES_PROMOTED_COUNTER                        8
#define GEN1_BYTES_PROMOTED_COUNTER                        10
#define GEN0_PROMOTION_RATE                                12
#define GEN1_PROMOTION_RATE                                14
#define GEN0_FINALIZATION_BYTES_PROMOTED_COUNTER           16
#define GEN1_FINALIZATION_BYTES_PROMOTED_COUNTER           18
#define GEN0_HEAP_SIZE_COUNTER                             20
#define GEN1_HEAP_SIZE_COUNTER                             22
#define GEN2_HEAP_SIZE_COUNTER                             24
#define LARGE_OBJECT_SIZE_COUNTER                          26
#define SURVIVE_FINALIZE_COUNTER                           28
#define NUM_HANDLES_COUNTER                                30
#define ALLOCATION_RATE_COUNTER                            32
#define INDUCED_GC_COUNTER                                 34
#define PER_TIME_IN_GC_COUNTER                             36
#define PER_TIME_IN_GC_COUNTER_BASE                        38
#define TOTAL_HEAP_SIZE_COUNTER                            40
#define TOTAL_COMMITTED_MEM_COUNTER                        42
#define TOTAL_RESERVED_MEM_COUNTER                         44
#define GC_PINNED_OBJECTS                                  46
#define GC_SINKBLOCKS                                      48
#define DotNetCLR_Loading_OBJECT                           50
#define LOADING_CLASSES_TOTAL                              52
#define LOADING_TIME                                       54
#define LOADING_ASMSEARCHLEN                               56
#define LOADING_LOADFAILURES_TOTAL                         58
#define LOADING_LOADFAILURES_INST                          60
#define LOADING_HEAPSIZE                                   62
#define LOADING_APPDOMAINS_UNLOADED_TOTAL                  64
#define LOADING_APPDOMAINS_UNLOADED_INST                   66
#define LOADING_CLASSES_CUR                                68
#define LOADING_CLASSES_INST                               70
#define LOADING_APPDOMAINS_CUR                             72
#define LOADING_APPDOMAINS_TOTAL                           74
#define LOADING_APPDOMAINS_INST                            76
#define LOADING_ASSEMBLIES_CUR                             78
#define LOADING_ASSEMBLIES_TOTAL                           80
#define LOADING_ASSEMBLIES_INST                            82
#define DotNetCLR_Jit_OBJECT                               84
#define TOTAL_METHODS_JITTED                               86
#define JITTED_IL_CUR                                      88
#define JITTED_IL_TOTAL                                    90
#define JITTED_IL_INST                                     92
#define JIT_FAILURES                                       94
#define TIME_IN_JIT                                        96
#define TIME_IN_JIT_BASE                                   98
#define DotNetCLR_Interop_OBJECT                           100
#define CURRENT_CCW                                        102
#define CURRENT_STUBS                                      104
#define NUM_MARSHALLING                                    106
#define TOTAL_TLB_IMPORTS                                  108
#define TOTAL_TLB_EXPORTS                                  110
#define DotNetCLR_LocksAndThreads_OBJECT                   112
#define CONTENTION_TOTAL                                   114
#define CONTENTION_INST                                    116
#define QUEUE_LENGTH_CUR                                   118
#define QUEUE_LENGTH_TOTAL                                 120
#define QUEUE_LENGTH_INST                                  122
#define CURRENT_LOGICAL_THREADS                            124
#define CURRENT_PHYSICAL_THREADS                           126
#define RECOGNIZED_THREADS_CUR                             128
#define RECOGNIZED_THREADS_TOTAL                           130
#define RECOGNIZED_THREADS_INST                            132
#define DotNetCLR_Security_OBJECT                          134
#define SECURITY_TOTALRTCHECKS                             136
#define SECURITY_TIMEAUTHORIZE                             138
#define SECURITY_LINKCHECKS                                140
#define SECURITY_TIMERTCHECKS                              142
#define SECURITY_TIMERTCHECKS_BASE                         144
#define SECURITY_DEPTHSECURITY                             146
#define DotNetCLR_Remoting_OBJECT                          148
#define CONTEXT_REMOTECALLS_INST                           150
#define CONTEXT_CHANNELS                                   152
#define CONTEXT_PROXIES                                    154
#define CONTEXT_CLASSES                                    156
#define CONTEXT_OBJALLOC                                   158
#define CONTEXT_CONTEXTS                                   160
#define CONTEXT_REMOTECALLS_TOTAL                          162
#define DotNetCLR_Excep_OBJECT                             164
#define EXCEP_THROWN_TOTAL                                 166
#define EXCEP_THROWN_INST                                  168
#define TOTAL_EXCEP_FILTERS_RUN                            170
#define TOTAL_EXCEP_FINALLYS_RUN                           172
#define EXCEPT_STACK_DEPTH                                 174
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\binary_release\i386\fre\_networkingperfcounters.h ===
//------------------------------------------------------------------------------
// <copyright file="_NetworkingPerfCounters.h" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   _NetworkingPerfCounters.h
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
#define OBJECT_1 0;
#define DEVICE_COUNTER_1 2;
#define DEVICE_COUNTER_2 4;
#define DEVICE_COUNTER_3 6;
#define DEVICE_COUNTER_4 8;
#define DEVICE_COUNTER_5 10;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\binary_release\i386\fre\_dataperfcounters.h ===
//------------------------------------------------------------------------------
// <copyright file="_dataperfcounters.h" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   _dataperfcounters.h
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
#define OBJECT_1 0;
#define DEVICE_COUNTER_1 2;
#define DEVICE_COUNTER_2 4;
#define DEVICE_COUNTER_3 6;
#define DEVICE_COUNTER_4 8;
#define DEVICE_COUNTER_5 10;
#define DEVICE_COUNTER_6 12;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\makefile.inc ===
!ifdef _BUILD_WINCE
!undef COOL_TYPELIB_EXPORT      # can't execute 'comreg' for WinCE mscorlib.dll
!endif

!INCLUDE $(NTMAKEENV)\makefile.cool

!if "$(OS)" == "Windows_NT"
SYSTEMDIR=$(WINDIR)\system32
!else
SYSTEMDIR=$(WINDIR)\system
!endif

MSCOREE_TARGET=$(SYSTEMDIR)\mscoree.dll

####################################################################################
# Include extra source files specifying the assembly version and strong name as
# custom attributes.

$(O)\Version.cs: Version.pp $(CORBASE)\src\inc\version\__file__.ver
        perl $(CORENV)\bin\keylocationex.pl EcmaPublicKey.snk > $(O)\KeyDefine.h
        cl /EP /C /FI ..\inc\version\__file__.ver /FI $(O)\KeyDefine.h /DCOOL_INCLUDE Version.pp > $(O)\Version.cs

$(TARGETCOMPLUS)\int_tools\stripxml.pl: $(CORENV)\bin\stripxml.pl
        copy $(CORENV)\bin\stripxml.pl $(TARGETCOMPLUS)\int_tools\stripxml.pl

$(TARGETPATH)\machine.runtime.config.retail: $(TARGETPATH)\machine.runtime.config $(TARGETCOMPLUS)\int_tools\stripxml.pl
        -perl $(TARGETCOMPLUS)\int_tools\stripxml.pl $(TARGETPATH)\machine.runtime.config runtime $(TARGETPATH)\machine.runtime.config.retail

$(TARGETCOMPLUS)\config\machine.runtime.config.retail: $(TARGETPATH)\machine.runtime.config.retail
        copy $(TARGETPATH)\machine.runtime.config.retail $(TARGETCOMPLUS)\config\machine.runtime.config.retail

$(TARGETCOMPLUS)\int_tools\machine.runtime.config.retail: $(TARGETPATH)\machine.runtime.config.retail
        copy $(TARGETPATH)\machine.runtime.config.retail $(TARGETCOMPLUS)\int_tools\machine.runtime.config.retail

$(TARGETCOMPLUS)\int_tools\mergeconfig.pl: $(CORENV)\bin\mergeconfig.pl
        copy $(CORENV)\bin\mergeconfig.pl $(TARGETCOMPLUS)\int_tools\mergeconfig.pl

$(TARGETPATH)\machine.runtime.config: $(TARGETCORLIB)\DevelopersConfig.pl
        -perl $(TARGETCORLIB)\DevelopersConfig.pl > $(TARGETPATH)\machine.runtime.config

$(TARGETCOMPLUS)\config\machine.runtime.config: $(TARGETPATH)\machine.runtime.config
        copy  $(TARGETPATH)\machine.runtime.config $(TARGETCOMPLUS)\config\machine.runtime.config

$(TARGETCOMPLUS)\int_tools\machine.runtime.config: $(TARGETPATH)\machine.runtime.config
        copy  $(TARGETPATH)\machine.runtime.config $(TARGETCOMPLUS)\int_tools\machine.runtime.config
        
$(TARGETCOMPLUS)\config\machine.config: $(TARGETCOMPLUS)\int_tools\mergeconfig.pl $(TARGETCOMPLUS)\config\machine.runtime.config
        -perl $(TARGETCOMPLUS)\int_tools\mergeconfig.pl $(TARGETCOMPLUS)\config\machine.config $(TARGETCOMPLUS)\config\machine.runtime.config

$(TARGETCOMPLUS)\int_tools\configfile.lst: $(CORBASE)\bin\configfile.lst
        copy $(CORBASE)\bin\configfile.lst $(TARGETCOMPLUS)\int_tools\configfile.lst

$(TARGETCOMPLUS)\int_tools\configfile.bat: $(CORBASE)\bin\configfile.bat
        copy $(CORBASE)\bin\configfile.bat $(TARGETCOMPLUS)\int_tools\configfile.bat

$(TARGETCOMPLUS)\int_tools\GenerateConfigFiles.bat: $(CORBASE)\bin\GenerateConfigFiles.bat
        copy $(CORBASE)\bin\GenerateConfigFiles.bat $(TARGETCOMPLUS)\int_tools\GenerateConfigFiles.bat

$(TARGETCOMPLUS)\int_tools\PrintVersion.pl: $(CORBASE)\bin\PrintVersion.pl
        copy $(CORBASE)\bin\PrintVersion.pl $(TARGETCOMPLUS)\int_tools\PrintVersion.pl

$(TARGETCOMPLUS)\int_tools\updateconfig.pl: $(CORBASE)\bin\updateconfig.pl
        copy $(CORBASE)\bin\updateconfig.pl $(TARGETCOMPLUS)\int_tools\updateconfig.pl

$(TARGETCOMPLUS)\int_tools\updateconfig.bat: $(CORBASE)\bin\updateconfig.bat
        copy $(CORBASE)\bin\updateconfig.bat $(TARGETCOMPLUS)\int_tools\updateconfig.bat

$(TARGETCOMPLUS)\int_tools\scanconfig.bat: $(CORBASE)\bin\scanconfig.bat
        copy $(CORBASE)\bin\scanconfig.bat $(TARGETCOMPLUS)\int_tools\scanconfig.bat

####################################################################################
# Include extra source files specifying the assembly version and strong name as
$(O)\doc:
        @mkdir $(O)\doc

$(O)\doc\AppdomainSetup.uex: $(O)\doc
        copy system\doc\AppDomainSetup.uex $(O)\doc\AppDomainSetup.uex

$(O)\AppDomainSetup.cs: system\AppDomainSetup.cs 
        perl $(CORENV)\bin\finddefines.pl ..\inc\fusion.h > $(O)\FDefines.h
        perl $(CORENV)\bin\finddefines.pl ..\inc\fusionpriv.h > $(O)\FPrivDefines.h
        perl $(CORENV)\bin\finddefines.pl ..\inc\FusionSetup.h > $(O)\FusionSetup.h
        cl /EP /C /I. /FI $(O)\FPrivDefines.h /FI $(O)\FDefines.h /FI $(O)\FusionSetup.h system\AppDomainSetup.cs > $(O)\AppDomainSetup.cs

####################################################################################
#
# ResGen Stuff.
#
####################################################################################
!ifndef _BUILD_WINCE

RESGEN_PATH = $(CORBASE)\Src\Tools\InternalResGen
RESGEN_SRC = $(RESGEN_PATH)\InternalResGen.cpp
RESGEN_TARGET = $(TARGETPATH)\InternalResGen.exe

$(RESGEN_TARGET): $(RESGEN_SRC) $(MSCOREE_TARGET)
    -del $(RESGEN_TARGET)
    cd $(RESGEN_PATH)
    build -c
    cd $(COOL_SOURCE_DIR)

!endif # _BUILD_WINCE


####################################################################################
#
# This rule is always run and it is run before $(COOL_TARGET):: is run.
#
####################################################################################
SETUP: $(RESGEN_TARGET) $(O)\AppDomainSetup.cs $(O)\Version.cs $(O)\doc\AppDomainSetup.uex
   -del -f $(COOL_SECURITY_DB).idx
   -del -f $(COOL_SECURITY_DB).db
   -del -f $(COOL_SECURITY_DB).raw
   copy $(COOL_SECURITY_DB).IDX.VSS $(COOL_SECURITY_DB).idx
   copy $(COOL_SECURITY_DB).db.VSS $(COOL_SECURITY_DB).db
   attrib -r $(COOL_SECURITY_DB).idx
   attrib -r $(COOL_SECURITY_DB).db
   -mkdir $(TARGETCOMPLUS)\docs
!ifndef _BUILD_WINCE
    $(TARGETPATH)\InternalResGen $(COOL_SOURCE_DIR)\resources.txt $(TARGETPATH)\mscorlib.resources
!endif


####################################################################################
# PHASE 1 pass.
#   - Create a C# file containing the version that will be added in during the link 
#   - Create a C# file containing defines used in the runtime
#   - Copy the machine.config file
#   - create a config file for the compilers
####################################################################################
prep_target: $(TARGETCOMPLUS)\config\machine.config \
             $(TARGETCOMPLUS)\config\machine.runtime.config.retail \
             $(TARGETCOMPLUS)\int_tools\machine.runtime.config.retail \
             $(TARGETCOMPLUS)\int_tools\machine.runtime.config \
             $(TARGETCOMPLUS)\int_tools\configfile.bat \
             $(TARGETCOMPLUS)\int_tools\configfile.lst \
             $(TARGETCOMPLUS)\int_tools\GenerateConfigFiles.bat \
             $(TARGETCOMPLUS)\int_tools\printversion.pl \
             $(TARGETCOMPLUS)\int_tools\updateconfig.pl \
             $(TARGETCOMPLUS)\int_tools\updateconfig.bat \
             $(TARGETCOMPLUS)\int_tools\scanconfig.bat

####################################################################################

####################################################################################
#
# This rule generates mscorlib.dll it is important to add the source files that
# make up the dependents such as ResGen and CustomMarshalers so that they can be
# built if their source files change.
#
####################################################################################
$(COOL_TARGET): $(COOL_SOURCES) $(COOL_SOURCE_DIR)\resources.txt $(RESGEN_TARGET) $(O)\holder.foo $(O)\$(WIN32_RESOURCE_FILE:.rc=.res) 
####################################################################################
# Ensure strong name delay signed assemblies are treated properly.
####################################################################################
    start /wait /b sn -Vr *,b03f5f7f11d50a3a
    start /wait /b sn -Vr *,b77a5c561934e089
####################################################################################
#  Create the configuration files
####################################################################################
   $(CORBASE)\bin\configfile.bat build

####################################################################################
# Copy all the nlp's to the current path to be able to run coolc on them.
####################################################################################
    set COPYCMD=/Y
    xcopy /r $(COOL_SOURCE_DIR)\System\Globalization\Tables\ctype.nlp    $(TARGETPATH)
    xcopy /r $(COOL_SOURCE_DIR)\System\Globalization\Tables\l_intl.nlp   $(TARGETPATH)
    xcopy /r $(COOL_SOURCE_DIR)\System\Globalization\Tables\l_except.nlp $(TARGETPATH)
    xcopy /r $(COOL_SOURCE_DIR)\System\Globalization\Tables\culture.nlp  $(TARGETPATH)
    xcopy /r $(COOL_SOURCE_DIR)\System\Globalization\Tables\region.nlp   $(TARGETPATH)
    xcopy /r $(COOL_SOURCE_DIR)\System\Globalization\Tables\sortkey.nlp  $(TARGETPATH)
    xcopy /r $(COOL_SOURCE_DIR)\System\Globalization\Tables\sorttbls.nlp $(TARGETPATH)
    xcopy /r $(COOL_SOURCE_DIR)\System\Globalization\Tables\CharInfo.nlp $(TARGETPATH)

    xcopy /r $(COOL_SOURCE_DIR)\System\Globalization\Tables\big5.nlp     $(TARGETPATH)
    xcopy /r $(COOL_SOURCE_DIR)\System\Globalization\Tables\bopomofo.nlp $(TARGETPATH)
    xcopy /r $(COOL_SOURCE_DIR)\System\Globalization\Tables\ksc.nlp      $(TARGETPATH)
    xcopy /r $(COOL_SOURCE_DIR)\System\Globalization\Tables\prc.nlp      $(TARGETPATH)
    xcopy /r $(COOL_SOURCE_DIR)\System\Globalization\Tables\prcp.nlp     $(TARGETPATH)
    xcopy /r $(COOL_SOURCE_DIR)\System\Globalization\Tables\xjis.nlp     $(TARGETPATH)
    xcopy /r $(COOL_SOURCE_DIR)\System\Globalization\Tables\c_g18030.dll $(TARGETPATH)
    xcopy /r $(COOL_SOURCE_DIR)\System\Globalization\Tables\pdb\x86fre\c_g18030.pdb $(TARGETPATH)	

    -del $(TARGETPATH)\$(TARGETNAME)
    -del $(O)\$(TARGETNAME)
!if "$(TARGETCOMPLUS)" != ""
    -del $(TARGETCOMPLUS)\$(TARGETNAME)
!endif
# Generate a response file for the CSC compiler flags.
     echo <<BclFiles.$(DDKBUILDENV)
$(COOL_COMPILE_FLAGS) $(COOL_RESOURCE_FLAGS) /nostdlib
$(COOL_SOURCES: =
)
<<keep
    set __SECURITY_BOOTSTRAP_DB=$(COOL_SOURCE_DIR)
    $(MANAGED_COMPILER) @BclFiles.$(DDKBUILDENV) $(O)\Version.cs $(O)\AppDomainSetup.cs
    set __SECURITY_BOOTSTRAP_DB=
    perl $(CORENV)\bin\GetBaseAddress.pl $(TARGETPATH)\mscorlib.dll $(COOL_BASE)


####################################################################################
# Copy all the files to the deployed CLR installation. (Part 1)
####################################################################################
!if "$(TARGETCOMPLUS)" != ""
        copy $(TARGETPATH)\mscorlib.dll $(TARGETCOMPLUS)
        copy $(TARGETPATH)\*.nlp $(TARGETCOMPLUS)
        copy $(TARGETPATH)\c_g18030.dll $(TARGETCOMPLUS)
        copy $(TARGETPATH)\c_g18030.pdb $(TARGETCOMPLUS)
!endif

TARGET_EXTESION_ = dll
TARGET_MANAGED_PDB = $(TARGETPATH)\mscorlib.pdb
!INCLUDE $(NTMAKEENV)\mk_mngpdb.inc

####################################################################################
# Check whether mscorlib.dll is using security permissions that it wasn't before.
# This will result in null declarative security blobs being placed into the metadata
# (since we need a working mscorlib to do the permission set translation) and a
# $(COOL_SECURITY_DB).raw file being generated (during the compile of mscorlib.dll)
# to indicate that we need to update the mapping database used to locate the correct
# metadata blobs. Once the security mapping database has been updated we rebuild
# mscorlib from scratch, and this time all the permissions should be mapped into
# metadata correctly. The user needs to check the updated database (which consists
# of two file) into VSS to prevent this dual build happening every time.
####################################################################################
    cmd /C "if exist $(COOL_SECURITY_DB).raw pushd ..\ToolBox\SecDBEdit && build -cC && popd"
    cmd /C "if exist $(COOL_SECURITY_DB).raw SecDBEdit -regen $(COOL_SECURITY_DB) xml"
    cmd /C "if exist $(COOL_SECURITY_DB).raw sd edit $(COOL_SECURITY_DB).*.vss"
    cmd /C "if exist $(COOL_SECURITY_DB).raw copy $(COOL_SECURITY_DB).idx $(COOL_SECURITY_DB).idx.VSS"
    cmd /C "if exist $(COOL_SECURITY_DB).raw copy $(COOL_SECURITY_DB).db $(COOL_SECURITY_DB).db.VSS"
    cmd /C "if exist $(COOL_SECURITY_DB).raw echo lib ( : **** Security bootstrap database altered, action required **** Please checkin updated versions of $(COOL_SECURITY_DB).idx.VSS and $(COOL_SECURITY_DB).db.VSS along with your changes. See security team for details.
    cmd /C "if exist $(COOL_SECURITY_DB).raw build -cC"

!ifdef _BUILD_WINCE
!if "$(WINCEREL)" != "" && "$(_FLATRELEASEDIR)" != ""
        copy $(TARGETPATH)\mscorlib.dll $(_FLATRELEASEDIR)
!endif
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "MSCORLIB.DLL"
#define VER_FILEDESCRIPTION_STR "Microsoft Common Language Runtime Class Library\0"
#define VER_ORIGFILENAME_STR    "mscorlib.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\microsoft\win32\registry.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*
 * Information Contained Herein is Proprietary and Confidential.
 */
namespace Microsoft.Win32 {
    
	using System;
	using System.Runtime.InteropServices;
    // Registry encapsulation. Contains members representing all top level system
    // keys.
    //
    //This class contains only static members and does not need to be serializable.
    /// <include file='doc\Registry.uex' path='docs/doc[@for="Registry"]/*' />
    public sealed class Registry {
    
    	private Registry() {}
    	
        // Current User Key.
        // 
        // This key should be used as the root for all user specific settings.
        /// <include file='doc\Registry.uex' path='docs/doc[@for="Registry.CurrentUser"]/*' />
        public static readonly RegistryKey CurrentUser        = RegistryKey.GetBaseKey(RegistryKey.HKEY_CURRENT_USER);
        
        // Local Machine Key.
        // 
        // This key should be used as the root for all machine specific settings.
        /// <include file='doc\Registry.uex' path='docs/doc[@for="Registry.LocalMachine"]/*' />
        public static readonly RegistryKey LocalMachine       = RegistryKey.GetBaseKey(RegistryKey.HKEY_LOCAL_MACHINE);
        
        // Classes Root Key.
        // 
        // This is the root key of class information.
        /// <include file='doc\Registry.uex' path='docs/doc[@for="Registry.ClassesRoot"]/*' />
        public static readonly RegistryKey ClassesRoot        = RegistryKey.GetBaseKey(RegistryKey.HKEY_CLASSES_ROOT);
        
        // Users Root Key.
        // 
        // This is the root of users.
        /// <include file='doc\Registry.uex' path='docs/doc[@for="Registry.Users"]/*' />
        public static readonly RegistryKey Users              = RegistryKey.GetBaseKey(RegistryKey.HKEY_USERS);
        
        // Performance Root Key.
        // 
        // This is where dynamic performance data is stored on NT.
        // This does not exist on Win9X.
        /// <include file='doc\Registry.uex' path='docs/doc[@for="Registry.PerformanceData"]/*' />
        public static readonly RegistryKey PerformanceData    = RegistryKey.GetBaseKey(RegistryKey.HKEY_PERFORMANCE_DATA);
        
        // Current Config Root Key.
        // 
        // This is where current configuration information is stored.
        /// <include file='doc\Registry.uex' path='docs/doc[@for="Registry.CurrentConfig"]/*' />
        public static readonly RegistryKey CurrentConfig      = RegistryKey.GetBaseKey(RegistryKey.HKEY_CURRENT_CONFIG);
        
        // Dynamic Data Root Key.
        // 
        // This is where dynamic performance data is stored on Win9X.
        // This does not exist on NT.
        /// <include file='doc\Registry.uex' path='docs/doc[@for="Registry.DynData"]/*' />
        public static readonly RegistryKey DynData            = RegistryKey.GetBaseKey(RegistryKey.HKEY_DYN_DATA);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\microsoft\win32\registrykey.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*
 * Information Contained Herein is Proprietary and Confidential.
 */
namespace Microsoft.Win32 {

    using System;
    using System.Collections;
    using System.Security;
    using System.Security.Permissions;
    using System.Text;
    using System.IO;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using RegistryPermission = System.Security.Permissions.RegistryPermission;
    using RegistryPermissionAccess = System.Security.Permissions.RegistryPermissionAccess;
    // Registry hive values.  Useful only for GetRemoteBaseKey
    /// <include file='doc\RegistryKey.uex' path='docs/doc[@for="RegistryHive"]/*' />
    [Serializable]
    public enum RegistryHive
    {
        /// <include file='doc\RegistryKey.uex' path='docs/doc[@for="RegistryHive.ClassesRoot"]/*' />
        ClassesRoot = unchecked((int)0x80000000),
        /// <include file='doc\RegistryKey.uex' path='docs/doc[@for="RegistryHive.CurrentUser"]/*' />
        CurrentUser = unchecked((int)0x80000001),
        /// <include file='doc\RegistryKey.uex' path='docs/doc[@for="RegistryHive.LocalMachine"]/*' />
        LocalMachine = unchecked((int)0x80000002),
        /// <include file='doc\RegistryKey.uex' path='docs/doc[@for="RegistryHive.Users"]/*' />
        Users = unchecked((int)0x80000003),
        /// <include file='doc\RegistryKey.uex' path='docs/doc[@for="RegistryHive.PerformanceData"]/*' />
        PerformanceData = unchecked((int)0x80000004),
        /// <include file='doc\RegistryKey.uex' path='docs/doc[@for="RegistryHive.CurrentConfig"]/*' />
        CurrentConfig = unchecked((int)0x80000005),
        /// <include file='doc\RegistryKey.uex' path='docs/doc[@for="RegistryHive.DynData"]/*' />
        DynData = unchecked((int)0x80000006),
    }
    
    
    
    // Registry encapsulation. To get an instance of a RegistryKey use the 
    // Registry class's static members then call OpenSubKey.
    // 
    /// <include file='doc\RegistryKey.uex' path='docs/doc[@for="RegistryKey"]/*' />
    public sealed class RegistryKey : MarshalByRefObject, IDisposable {

        // We could use const here, if C# supported ELEMENT_TYPE_I fully.
        internal static readonly IntPtr HKEY_CLASSES_ROOT         = new IntPtr(unchecked((int)0x80000000));
        internal static readonly IntPtr HKEY_CURRENT_USER         = new IntPtr(unchecked((int)0x80000001));
        internal static readonly IntPtr HKEY_LOCAL_MACHINE        = new IntPtr(unchecked((int)0x80000002));
        internal static readonly IntPtr HKEY_USERS                = new IntPtr(unchecked((int)0x80000003));
        internal static readonly IntPtr HKEY_PERFORMANCE_DATA     = new IntPtr(unchecked((int)0x80000004));
        internal static readonly IntPtr HKEY_CURRENT_CONFIG       = new IntPtr(unchecked((int)0x80000005));
        internal static readonly IntPtr HKEY_DYN_DATA             = new IntPtr(unchecked((int)0x80000006));
    
        // Win32 constants
        private const int GMEM_ZEROINIT = 0x0040;
        
        private const int DELETE                          = 0x00010000;
        private const int READ_CONTROL                    = 0x00020000;
        private const int WRITE_DAC                       = 0x00040000;
        private const int WRITE_OWNER                     = 0x00080000;
        private const int SYNCHRONIZE                     = 0x00100000;
        private const int STANDARD_RIGHTS_REQUIRED        = 0x000F0000;
        private const int STANDARD_RIGHTS_READ            = READ_CONTROL;
        private const int STANDARD_RIGHTS_WRITE           = READ_CONTROL;
        private const int STANDARD_RIGHTS_EXECUTE         = READ_CONTROL;
        private const int STANDARD_RIGHTS_ALL             = 0x001F0000;
        private const int SPECIFIC_RIGHTS_ALL             = 0x0000FFFF;
        private const int ACCESS_SYSTEM_SECURITY          = 0x01000000;
        private const int MAXIMUM_ALLOWED                 = 0x02000000;
        private const int GENERIC_READ                     = unchecked((int)0x80000000);
        private const int GENERIC_WRITE                    = 0x40000000;
        private const int GENERIC_EXECUTE                  = 0x20000000;
        private const int GENERIC_ALL                      = 0x10000000;
    
        private const int KEY_QUERY_VALUE        = 0x0001;
        private const int KEY_SET_VALUE          = 0x0002;
        private const int KEY_CREATE_SUB_KEY     = 0x0004;
        private const int KEY_ENUMERATE_SUB_KEYS = 0x0008;
        private const int KEY_NOTIFY             = 0x0010;
        private const int KEY_CREATE_LINK        = 0x0020;
    
        private const int KEY_READ               =((STANDARD_RIGHTS_READ       |
                                                           KEY_QUERY_VALUE            |
                                                           KEY_ENUMERATE_SUB_KEYS     |
                                                           KEY_NOTIFY)                 
                                                          &                           
                                                          (~SYNCHRONIZE));
    
        private const int KEY_WRITE              =((STANDARD_RIGHTS_WRITE      |
                                                           KEY_SET_VALUE              |
                                                           KEY_CREATE_SUB_KEY)         
                                                          &                           
                                                          (~SYNCHRONIZE));
    
        private const int KEY_EXECUTE            =((KEY_READ)                   
                                                          &                           
                                                          (~SYNCHRONIZE));
    
        private const int KEY_ALL_ACCESS         =((STANDARD_RIGHTS_ALL        |
                                                           KEY_QUERY_VALUE            |
                                                           KEY_SET_VALUE              |
                                                           KEY_CREATE_SUB_KEY         |
                                                           KEY_ENUMERATE_SUB_KEYS     |
                                                           KEY_NOTIFY                 |
                                                           KEY_CREATE_LINK)            
                                                          &                           
                                                          (~SYNCHRONIZE));
    
        //
        // Open/Create Options
        //
    
        private const int REG_OPTION_RESERVED        = 0x00000000;    // Parameter is reserved
    
        private const int REG_OPTION_NON_VOLATILE    = 0x00000000;    // Key is preserved
        // when system is rebooted
    
        private const int REG_OPTION_VOLATILE        = 0x00000001;    // Key is not preserved
        // when system is rebooted
    
        private const int REG_OPTION_CREATE_LINK     = 0x00000002;    // Created key is a
        // symbolic link
    
        private const int REG_OPTION_BACKUP_RESTORE  = 0x00000004;    // open for backup or restore
        // special access rules
        // privilege required
    
        private const int REG_OPTION_OPEN_LINK       = 0x00000008;    // Open symbolic link
    
        private const int REG_LEGAL_OPTION           = (REG_OPTION_RESERVED            |
                                                               REG_OPTION_NON_VOLATILE        |
                                                               REG_OPTION_VOLATILE            |
                                                               REG_OPTION_CREATE_LINK         |
                                                               REG_OPTION_BACKUP_RESTORE      |
                                                               REG_OPTION_OPEN_LINK);
    
        //
        // Key creation/open disposition
        //
    
        private const int REG_CREATED_NEW_KEY        = 0x00000001;   // New Registry Key created
        private const int REG_OPENED_EXISTING_KEY    = 0x00000002;   // Existing Key opened
    
    
        private const int REG_NONE                    = 0;    // No value type
        private const int REG_SZ                      = 1;    // Unicode nul terminated string
        private const int REG_EXPAND_SZ               = 2;    // Unicode nul terminated string
        // (with environment variable references)
        private const int REG_BINARY                  = 3;    // Free form binary
        private const int REG_DWORD                   = 4;    // 32-bit number
        private const int REG_DWORD_LITTLE_ENDIAN     = 4;    // 32-bit number (same as REG_DWORD)
        private const int REG_DWORD_BIG_ENDIAN        = 5;    // 32-bit number
        private const int REG_LINK                    = 6;    // Symbolic Link (unicode)
        private const int REG_MULTI_SZ                = 7;    // Multiple Unicode strings
        private const int REG_RESOURCE_LIST           = 8;    // Resource list in the resource map
        private const int REG_FULL_RESOURCE_DESCRIPTOR  = 9;   // Resource list in the hardware description
        private const int REG_RESOURCE_REQUIREMENTS_LIST = 10; 
    
        // Dirty indicates that we have munged data that should be potentially
        // written to disk.
        //
        private const int STATE_DIRTY        = 0x0001;
    
        // SystemKey indicates that this is a "SYSTEMKEY" and shouldn't be "opened"
        // or "closed".
        //
        private const int STATE_SYSTEMKEY    = 0x0002;
    
        // Access
        //
        private const int STATE_WRITEACCESS  = 0x0004;
    
        // Names of keys.  This array must be in the same order as the HKEY values listed above.
        //
        private static readonly String[] hkeyNames = new String[] {
                "HKEY_CLASSES_ROOT",
                "HKEY_CURRENT_USER",
                "HKEY_LOCAL_MACHINE",
                "HKEY_USERS",
                "HKEY_PERFORMANCE_DATA",
                "HKEY_CURRENT_CONFIG",
                "HKEY_DYN_DATA"
                };
    
        // Keys with exactly 256 characters seem to corrupt the registry
        // on NT4.  We'll disallow those.
        private const int MaxKeyLength = 255;

        private static readonly IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1);
        
        private IntPtr hkey = INVALID_HANDLE_VALUE;
        private int state = 0;
        private String keyName;
        private bool remoteKey = false;

        private static readonly int _SystemDefaultCharSize = 3 - Win32Native.lstrlen(new sbyte [] {0x41, 0x41, 0, 0});
        
    
        // Creates a RegistryKey.
        //  
        // This key is bound to hkey, if writable is false then no write operations 
        // will be allowed.
        private RegistryKey(IntPtr hkey, bool writable) 
            : this(hkey, writable, false, false) {
        }
    
        // Creates a RegistryKey.
        //  
        // This key is bound to hkey, if writable is false then no write operations 
        // will be allowed. If systemkey is set then the hkey won't be released
        // when the object is GC'ed.
        // The remoteKey flag when set to true indicates that we are dealing with registry entries
        // on a remote machine and requires the program making these calls to have full trust.
        private RegistryKey(IntPtr hkey, bool writable, bool systemkey,bool remoteKey) {
            this.hkey = hkey;
            this.keyName = "";
            this.remoteKey = remoteKey;
            if (systemkey) {
                this.state |= STATE_SYSTEMKEY;
            }
            if (writable) {
                this.state |= STATE_WRITEACCESS;
            }
        }
    
        // Releases all resources associated with this Registy Key.
        // Registry keys must be closed, just like files.
        /// <include file='doc\RegistryKey.uex' path='docs/doc[@for="RegistryKey.Finalize"]/*' />
        ~RegistryKey() {
            Dispose(false);
        }
    
        // Closes this key, flushes it to disk if the contents have been modified.
        /// <include file='doc\RegistryKey.uex' path='docs/doc[@for="RegistryKey.Close"]/*' />
        public void Close() {
            Dispose(true);
            GC.nativeSuppressFinalize(this);
        }

        private void Dispose(bool disposing) {
            if (hkey != INVALID_HANDLE_VALUE) {
                if (!GetSystemKey()) { // System keys should never be closed
                    Win32Native.RegCloseKey(hkey);
                    hkey = INVALID_HANDLE_VALUE;
                }
            }
        }

        /// <include file='doc\RegistryKey.uex' path='docs/doc[@for="RegistryKey.Flush"]/*' />
        public void Flush() {
            if (hkey != INVALID_HANDLE_VALUE) {
                 if (GetDirty()) {
                     Win32Native.RegFlushKey(hkey);
                }
            }
        }
    
        /// <include file='doc\RegistryKey.uex' path='docs/doc[@for="RegistryKey.IDisposable.Dispose"]/*' />
        /// <internalonly/>
        void IDisposable.Dispose() {
            Dispose(true);
            GC.nativeSuppressFinalize(this);
        }

        // Creates a new subkey, or opens an existing one.
        // 
        /// <include file='doc\RegistryKey.uex' path='docs/doc[@for="RegistryKey.CreateSubKey"]/*' />
        public RegistryKey CreateSubKey(String subkey) {
            if (subkey==null)
                throw new ArgumentNullException("subkey");
            if (subkey.Length >= MaxKeyLength)
                throw new ArgumentException(Environment.GetResourceString("Arg_RegKeyStrLenBug"));
    
            ValidateState(true);
            
            subkey = FixupName(subkey); // Fixup multiple slashes to a single slash     
                    
            if (!remoteKey) 
            {
                RegistryKey key = InternalOpenSubKey(subkey,true);
                if (key != null) // Key already exits
                {
                    new RegistryPermission(RegistryPermissionAccess.Write, keyName + "\\" + subkey + "\\.").Demand();
                    return key;
                }
                else
                    new RegistryPermission(RegistryPermissionAccess.Create, keyName + "\\" + subkey + "\\.").Demand();
            }
            else 
                // unmanaged code trust required for remote access
                new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Demand();
    
            IntPtr result = INVALID_HANDLE_VALUE;
            int disposition = 0;
    
            int ret = Win32Native.RegCreateKeyEx(hkey,
                subkey,
                0,
                null,
                0,
                KEY_READ | KEY_WRITE,
                null, //RegistryKey.defaultSecurity,
                out result,
                out disposition);
    
            if (ret == 0 && result != INVALID_HANDLE_VALUE) {
                RegistryKey key = new RegistryKey(result, true);
                if (subkey.Length == 0)
                    key.keyName = keyName;
                else
                    key.keyName = keyName + "\\" + subkey;
                return key;
            }
            else if (ret != 0) // syscall failed, ret is an error code. 
                Win32Error(ret, keyName + "\\" + subkey);  // Access denied?

            BCLDebug.Assert(false, "Unexpected code path in RegistryKey::CreateSubKey");
            return null;
        }
    
        // Deletes the specified subkey. Will throw an exception if the subkey has
        // subkeys. To delete a tree of subkeys use, DeleteSubKeyTree.
        //
        /// <include file='doc\RegistryKey.uex' path='docs/doc[@for="RegistryKey.DeleteSubKey"]/*' />
        public void DeleteSubKey(String subkey) {
            DeleteSubKey(subkey, true);
        }

        /// <include file='doc\RegistryKey.uex' path='docs/doc[@for="RegistryKey.DeleteSubKey1"]/*' />
        public void DeleteSubKey(String subkey, bool throwOnMissingSubKey) {
            if (subkey==null)
                throw new ArgumentNullException("subkey");
    
            ValidateState(true);

            subkey = FixupName(subkey); // Fixup multiple slashes to a single slash     

            if (!remoteKey)
                new RegistryPermission(RegistryPermissionAccess.Write, keyName + "\\" + subkey + "\\." ).Demand();
            else
                // unmanaged code trust required for remote access
                new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Demand();
            
            // Open the key we are deleting and check for children. Be sure to 
            // explicitly call close to avoid keeping an extra HKEY open.
            //
            RegistryKey key = InternalOpenSubKey(subkey,false);
            if (key != null) {
                if (key.InternalSubKeyCount() > 0) {
                    throw new InvalidOperationException(Environment.GetResourceString("InvalidOperation_RegRemoveSubKey"));
                }
                key.Close();
                key = null;
    
                int ret = Win32Native.RegDeleteKey(hkey, subkey);
                if (ret!=0) {
                    if (ret == Win32Native.ERROR_FILE_NOT_FOUND) {
                        if (throwOnMissingSubKey) 
                            throw new ArgumentException(Environment.GetResourceString("Arg_RegSubKeyAbsent"));
                    }
                    else
                        Win32Error(ret, null);
                }
            }
            else { // there is no key which also means there is no subkey
                if (throwOnMissingSubKey) 
                    throw new ArgumentException(Environment.GetResourceString("Arg_RegSubKeyAbsent"));
            }
        }
    
        // Recursively deletes a subkey and any child subkeys.
        //
        /// <include file='doc\RegistryKey.uex' path='docs/doc[@for="RegistryKey.DeleteSubKeyTree"]/*' />
        public void DeleteSubKeyTree(String subkey) {
            if (subkey==null)
                throw new ArgumentNullException("subkey");
            // Security concern: Deleting a hive's "" subkey would delete all
            // of that hive's contents.  Don't allow "".
            if (subkey.Length==0 && (state & STATE_SYSTEMKEY) != 0)
                throw new ArgumentException(Environment.GetResourceString("Arg_RegKeyDelHive"));
    
            ValidateState(true);

            subkey = FixupName(subkey); // Fixup multiple slashes to a single slash     

            if (!remoteKey)
                new RegistryPermission(RegistryPermissionAccess.Write, keyName + "\\" + subkey).Demand();
            else
                // unmanaged code trust required for remote access
                new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Demand();
    
            RegistryKey key = InternalOpenSubKey(subkey, true);
            if (key != null) {
                if (key.InternalSubKeyCount() > 0) {
                    String[] keys = key.InternalGetSubKeyNames();
    
                    for (int i=0; i<keys.Length; i++) {
                        key.DeleteSubKeyTree(keys[i]);
                    }
                }
                key.Close();
                key = null;
    
                int ret = Win32Native.RegDeleteKey(hkey, subkey);
                if (ret!=0) Win32Error(ret, null);
            }
            else
                throw new ArgumentException(Environment.GetResourceString("Arg_RegSubKeyAbsent"));
        }
    
        // Deletes the specified value from this key.
        //
        /// <include file='doc\RegistryKey.uex' path='docs/doc[@for="RegistryKey.DeleteValue"]/*' />
        public void DeleteValue(String name) {
            DeleteValue(name, true);
        }

        /// <include file='doc\RegistryKey.uex' path='docs/doc[@for="RegistryKey.DeleteValue1"]/*' />
        public void DeleteValue(String name, bool throwOnMissingValue) {
            if (name==null)
                throw new ArgumentNullException("name");
            
            ValidateState(true);

            if (!remoteKey)
                new RegistryPermission(RegistryPermissionAccess.Write, keyName+"\\"+name).Demand();
            else
                // unmanaged code trust required for remote access
                new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Demand();
            
            int hr = Win32Native.RegDeleteValue(hkey, name);
            if (hr == Win32Native.ERROR_FILE_NOT_FOUND && throwOnMissingValue) 
                    throw new ArgumentException(Environment.GetResourceString("Arg_RegSubKeyValueAbsent"));
        }
    
        // Retrieves a new RegistryKey that represents the requested key. Valid
        // values are:
        //
        // HKEY_CLASSES_ROOT, 
        // HKEY_CURRENT_USER,
        // HKEY_LOCAL_MACHINE,
        // HKEY_USERS,
        // HKEY_PERFORMANCE_DATA,
        // HKEY_CURRENT_CONFIG,
        // HKEY_DYN_DATA.
        //
        internal static RegistryKey GetBaseKey(IntPtr hKey) {
            // @TODO PORTING: Verify this is good on 64 bits.
            int index = ((int)hKey) & 0x0FFFFFFF;
            if (index < 0 || index > hkeyNames.Length || (((int)hKey) & 0xFFFFFFF0) != 0x80000000) {
                throw new ArgumentException(Environment.GetResourceString("Arg_RegKeyOutOfRange"));
            }
            
            RegistryKey key = new RegistryKey(hKey, true, true,false);
            key.keyName = hkeyNames[index];
            return key;
        }
        
        // Retrieves a new RegistryKey that represents the requested key on a foreign
        // machine.  Valid values for hKey are members of the RegistryHive enum, or 
        // Win32 integers such as:
        // 
        // HKEY_CLASSES_ROOT, 
        // HKEY_CURRENT_USER,
        // HKEY_LOCAL_MACHINE,
        // HKEY_USERS,
        // HKEY_PERFORMANCE_DATA,
        // HKEY_CURRENT_CONFIG,
        // HKEY_DYN_DATA.
        //
        /// <include file='doc\RegistryKey.uex' path='docs/doc[@for="RegistryKey.OpenRemoteBaseKey"]/*' />
        public static RegistryKey OpenRemoteBaseKey(RegistryHive hKey, String machineName) {
            if (machineName==null)
                throw new ArgumentNullException("machineName");
            int index = (int)hKey & 0x0FFFFFFF;
            if (index < 0 || index > hkeyNames.Length || ((int)hKey & 0xFFFFFFF0) != 0x80000000) {
                throw new ArgumentException(Environment.GetResourceString("Arg_RegKeyOutOfRange"));
            }
    
            // unmanaged code trust required for remote access
            new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Demand();
                    
            // connect to the specified remote registry
            IntPtr foreignHKey = INVALID_HANDLE_VALUE;
            int ret = Win32Native.RegConnectRegistry(machineName, new IntPtr((int)hKey), out foreignHKey);
    
            if (ret == Win32Native.ERROR_DLL_INIT_FAILED)
                // return value indicates an error occurred
                throw new ArgumentException(Environment.GetResourceString("Arg_DllInitFailure"));
    
            if (ret != 0)
                Win32Error(ret, null);

            if (foreignHKey == INVALID_HANDLE_VALUE)
                // return value indicates an error occurred
                throw new ArgumentException(String.Format(Environment.GetResourceString("Arg_RegKeyNoRemoteConnect"), machineName));
            
            RegistryKey key = new RegistryKey(foreignHKey, true, false, true);
            key.keyName = hkeyNames[index];
            return key;
        }
    
        // Retrieves the current state of the dirty property.
        // 
        // A key is marked as dirty if any operation has occured that modifies the
        // contents of the key.
        // 
        private bool GetDirty() {
            return (this.state & STATE_DIRTY) != 0;
        }
    
        // Retrieves a subkey. If readonly is true, then the subkey is opened with
        // read-only access.
        // 
        /// <include file='doc\RegistryKey.uex' path='docs/doc[@for="RegistryKey.OpenSubKey"]/*' />
        public RegistryKey OpenSubKey(String name, bool writable) {
            if (name==null)
                throw new ArgumentNullException("name");
            if (name.Length >= MaxKeyLength)
                throw new ArgumentException(Environment.GetResourceString("Arg_RegKeyStrLenBug"));
            ValidateState(false);
    
            name = FixupName(name); // Fixup multiple slashes to a single slash     

            int winAccess = 0;
            if (!writable) {
                winAccess = KEY_READ;
            }
            else {
                winAccess = KEY_READ | KEY_WRITE;
            }
    
            if (!remoteKey)
                new RegistryPermission(RegistryPermissionAccess.Read, keyName + "\\" + name + "\\.").Demand();
            else
                // unmanaged code trust required for remote access
                new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Demand();
                
            
            IntPtr result;
            int ret = Win32Native.RegOpenKeyEx(hkey, name, 0, winAccess, out result);
            if (ret == 0 && result != INVALID_HANDLE_VALUE) {
                RegistryKey key = new RegistryKey(result, writable);
                key.keyName = keyName + "\\" + name;
                return key;
            }
    
            if (ret == Win32Native.ERROR_ACCESS_DENIED) 
                throw new SecurityException(Environment.GetResourceString("Security_RegistryPermission"));
    
            return null;
        }

        // This required no security checks. This is to get around the Deleting SubKeys which only require
        // write permission. They call OpenSubKey which required read. Now instead call this function w/o security checks
        internal RegistryKey InternalOpenSubKey(String name, bool writable) {
            if (name==null)
                throw new ArgumentNullException("name");
            if (name.Length >= MaxKeyLength)
                throw new ArgumentException(Environment.GetResourceString("Arg_RegKeyStrLenBug"));
            ValidateState(false);
            
            int winAccess = 0;
            if (!writable) {
                winAccess = KEY_READ;
            }
            else {
                winAccess = KEY_READ | KEY_WRITE;
            }
                        
            IntPtr result;
            int ret = Win32Native.RegOpenKeyEx(hkey, name, 0, winAccess, out result);
            if (ret == 0 && result != INVALID_HANDLE_VALUE) {
                RegistryKey key = new RegistryKey(result, writable);
                key.keyName = keyName + "\\" + name;
                return key;
            }
    
            //if (ret == Win32Native.ERROR_ACCESS_DENIED) 
            //  throw new SecurityException(Environment.GetResourceString("Security_RegistryPermission"));
    
            return null;
        }
    
        // Returns a subkey with read only permissions.
        // 
        /// <include file='doc\RegistryKey.uex' path='docs/doc[@for="RegistryKey.OpenSubKey1"]/*' />
        public RegistryKey OpenSubKey(String name) {
            ValidateState(false);
    
            return OpenSubKey(name, false);
        }
    
        // Retrieves the count of subkeys.
        // 
        /// <include file='doc\RegistryKey.uex' path='docs/doc[@for="RegistryKey.SubKeyCount"]/*' />
        public int SubKeyCount {
            get {
                    new RegistryPermission(RegistryPermissionAccess.Read, keyName + "\\.").Demand();
                    return InternalSubKeyCount();
            }
        }

        internal int InternalSubKeyCount() {
                ValidateState(false);

                int subkeys = 0;
                int junk = 0;
                int ret = Win32Native.RegQueryInfoKey(hkey,
                                          null,
                                          null,
                                          Win32Native.NULL, 
                                          ref subkeys,  // subkeys
                                          null, 
                                          null,
                                          ref junk,     // values
                                          null,
                                          null,
                                          null,
                                          null);

                if (ret != 0)
                    Win32Error(ret, null);
                return subkeys;
        }
    
        // Retrieves an array of strings containing all the subkey names.
        // 
        /// <include file='doc\RegistryKey.uex' path='docs/doc[@for="RegistryKey.GetSubKeyNames"]/*' />
        public String[] GetSubKeyNames() {
            new RegistryPermission(RegistryPermissionAccess.Read, keyName + "\\.").Demand();
            return InternalGetSubKeyNames();
        }

         internal String[] InternalGetSubKeyNames() {
            ValidateState(false);
    
            int subkeys = InternalSubKeyCount();
            String[] names = new String[subkeys];  // Returns 0-length array if empty.
    
            if (subkeys > 0) {
                StringBuilder name = new StringBuilder(256);
                int namelen;
    
                for (int i=0; i<subkeys; i++) {
                    namelen = name.Capacity; // Don't remove this. The API's doesn't work if this is not properly initialised.
                    int ret = Win32Native.RegEnumKeyEx(hkey,
                        i,
                        name,
                        out namelen,
                        null,
                        null,
                        null,
                        null);
                    if (ret != 0)
                        Win32Error(ret, null);
                    names[i] = name.ToString();
                }
            }
    
            return names;
        }
    
        // Retrieves the count of values.
        // 
        /// <include file='doc\RegistryKey.uex' path='docs/doc[@for="RegistryKey.ValueCount"]/*' />
        public int ValueCount {
            get {
                new RegistryPermission(RegistryPermissionAccess.Read, keyName + "\\.").Demand();
                return InternalValueCount();
            }
        }

        internal int InternalValueCount() {
            ValidateState(false);
            int values = 0;
            int junk = 0;
            int ret = Win32Native.RegQueryInfoKey(hkey,
                                      null,
                                      null,
                                      Win32Native.NULL, 
                                      ref junk,     // subkeys
                                      null,
                                      null,
                                      ref values,   // values
                                      null,
                                      null,
                                      null,
                                      null);
            if (ret != 0)
               Win32Error(ret, null);
            return values;
        }
    
        // Retrieves an array of strings containing all the value names.
        // 
        /// <include file='doc\RegistryKey.uex' path='docs/doc[@for="RegistryKey.GetValueNames"]/*' />
        public String[] GetValueNames() {
            new RegistryPermission(RegistryPermissionAccess.Read, keyName + "\\.").Demand();
            ValidateState(false);
    
            int values = InternalValueCount();
            String[] names = new String[values];
    
            if (values > 0) {
                StringBuilder name = new StringBuilder(256);
                int namelen;
    
                for (int i=0; i<values; i++) {
                    namelen = name.Capacity;

                    int ret = Win32Native.RegEnumValue(hkey,
                        i,
                        name,
                        ref namelen,
                        Win32Native.NULL,
                        null,
                        null,
                        null);
                    if (ret != 0)
                        Win32Error(ret, null);
                    names[i] = name.ToString();
                }
            }
    
            return names;
        }
    
        // Retrieves the specified value. defaultValue is returned if the value doesn't exist.
        // 
        // Note that name can be null or "", at which point the 
        // unnamed or default value of this Registry key is returned, if any.
        // The default values for RegistryKeys are OS-dependent.  NT doesn't
        // have them by default, but they can exist and be of any type.  On
        // Win95, the default value is always an empty key of type REG_SZ.  
        // Win98 supports default values of any type, but defaults to REG_SZ.
        //
        /// <include file='doc\RegistryKey.uex' path='docs/doc[@for="RegistryKey.GetValue"]/*' />
        public Object GetValue(String name, Object defaultValue) {
            return InternalGetValue(name, defaultValue, true);
        }

        internal Object InternalGetValue(String name, Object defaultValue, bool checkSecurity) {
            if (checkSecurity) {
                new RegistryPermission(RegistryPermissionAccess.Read, keyName + "\\" + name).Demand();
                // Name can be null!  It's the most common use of RegQueryValueEx
                ValidateState(false);
            }
            
            Object data = defaultValue;
            int type = 0;
            int datasize = 0;
    
            int ret = Win32Native.RegQueryValueEx(hkey, name, null, ref type, (byte[])null, ref datasize);
            
            if (ret != 0) {
                if (hkey == HKEY_PERFORMANCE_DATA) {
                    int size = 32;
                    int r;
                    byte[] blob = new byte[size];
                    while (Win32Native.ERROR_MORE_DATA == (r = Win32Native.RegQueryValueEx(hkey, name, null, ref type, blob, ref size))) {
                        size *= 2;
                        blob = new byte[size];
                    }
                    if (r != 0) 
                        Win32Error(r, null);
                    data = blob;
                }
                return data;
            }
        
            switch (type) {
            case REG_DWORD_BIG_ENDIAN:
            case REG_BINARY: {
                                 byte[] blob = new byte[datasize];
                                 ret = Win32Native.RegQueryValueEx(hkey, name, null, ref type, blob, ref datasize);
                                 data = blob;
                             }
                             break;
            case REG_DWORD:
                             {    // also REG_DWORD_LITTLE_ENDIAN
                                 int blob = 0;
                                 BCLDebug.Assert(datasize==4, "datasize==4");
                                 // Here, datasize must be four when calling this
                                 ret = Win32Native.RegQueryValueEx(hkey, name, null, null, ref blob, ref datasize);

                                 data = blob;
                             }
                             break;
            case REG_SZ:                     
            
                             {
                                 if (_SystemDefaultCharSize != 1) {
                                     BCLDebug.Assert(_SystemDefaultCharSize==2, "_SystemDefaultCharSize==2");
                                     StringBuilder blob = new StringBuilder(datasize/2);
                                     ret = Win32Native.RegQueryValueEx(hkey, name, null, ref type, blob, ref datasize);
                                     data = blob.ToString();
                                 }
                                 else {
                                     byte[] blob = new byte[datasize];
                                     ret = Win32Native.RegQueryValueEx(hkey, name, null, ref type, blob, ref datasize);
                                     data = Encoding.Default.GetString(blob, 0, blob.Length-1);
                                 }
                             }
                             break;
    
            case REG_EXPAND_SZ: 
                              {
                                 if (_SystemDefaultCharSize != 1) {
                                     StringBuilder blob = new StringBuilder(datasize/2);
                                     ret = Win32Native.RegQueryValueEx(hkey, name, null, ref type, blob, ref datasize);
                                     data = Environment.ExpandEnvironmentVariables(blob.ToString());                                    
                                 }
                                 else {
                                     byte[] blob = new byte[datasize];
                                     ret = Win32Native.RegQueryValueEx(hkey, name, null, ref type, blob, ref datasize);
                                     String unexpandedData = Encoding.Default.GetString(blob, 0, blob.Length-1);
                                     data = Environment.ExpandEnvironmentVariables(unexpandedData);
                                 }
                             }
                             break;
            case REG_MULTI_SZ: 
                             {
                                 bool unicode = (_SystemDefaultCharSize != 1);
    
                                 IList strings = new ArrayList();
    
                                 if (unicode) {
                                     char[] blob = new char[datasize/2];
                                     ret = Win32Native.RegQueryValueEx(hkey, name, null, ref type, blob, ref datasize);
    
                                     int cur = 0;
                                     int len = blob.Length;
    
                                     while (cur < len) {
    
                                         int nextNull = cur;
                                         while (nextNull < len && blob[nextNull] != (char)0) {
                                             nextNull++;
                                         }
    
                                         if (nextNull < len) {
                                             if (blob[nextNull] == (char)0 && nextNull-cur > 0) {
                                                 strings.Add(new String(blob, cur, nextNull-cur));
                                             }
                                         }
                                         else {
                                             strings.Add(new String(blob, cur, len-cur));
                                         }
                                         cur = nextNull+1;
                                     }
    
                                 }
                                 else {
                                     byte[] blob = new byte[datasize];
                                     ret = Win32Native.RegQueryValueEx(hkey, name, null, ref type, blob, ref datasize);
                            
                                     int cur = 0;
                                     int len = blob.Length;
    
                                     while (cur < len) {
    
                                         int nextNull = cur;
                                         while (nextNull < len && blob[nextNull] != (byte)0) {
                                             nextNull++;
                                         }
    
                                         if (nextNull < len) {
                                             if (blob[nextNull] == (byte)0 && nextNull-cur > 0) {
                                                strings.Add(Encoding.Default.GetString(blob, cur, nextNull-cur));
                                             }
                                         }
                                         else {
                                            strings.Add(Encoding.Default.GetString(blob, cur, len-cur));
                                         }
                                         cur = nextNull + 1;
                                     }
                                 }
    
                                 data = new String[strings.Count];
                                 strings.CopyTo((Array)data, 0);
                                 //data = strings.GetAllItems(String.class);
                             }
                             break;
            case REG_NONE:
            case REG_LINK:
            default:
                break;
            }
    
            return data;
        }
    
        // Retrieves the specified value. null is returned if the value 
        // doesn't exist.  
        //
        // Note that name can be null or "", at which point the 
        // unnamed or default value of this Registry key is returned, if any.
        // 
        /// <include file='doc\RegistryKey.uex' path='docs/doc[@for="RegistryKey.GetValue1"]/*' />
        public Object GetValue(String name) {
            return GetValue(name, null);
        }
    
        private bool GetSystemKey() {
            return (this.state & STATE_SYSTEMKEY) != 0;
        }
    
        private bool GetWritable() {
            return (this.state & STATE_WRITEACCESS) != 0;
        }
    
        /// <include file='doc\RegistryKey.uex' path='docs/doc[@for="RegistryKey.Name"]/*' />
        public String Name {
            get { ValidateState(false);
                  return keyName; }
        }
        
        private void SetDirty(bool dirty) {
            if (dirty) {
                this.state |= STATE_DIRTY;
            }
            else {
                this.state &= (~STATE_DIRTY);
            }
        }
    
        // Sets the specified value.
        // 
        /// <include file='doc\RegistryKey.uex' path='docs/doc[@for="RegistryKey.SetValue"]/*' />
        public unsafe void SetValue(String name, Object value) {
            if (value==null)
                throw new ArgumentNullException("value");
            if (name != null && name.Length >= MaxKeyLength)
                throw new ArgumentException(Environment.GetResourceString("Arg_RegKeyStrLenBug"));
    
            ValidateState(true);
            
            if (!remoteKey)
            {
                int type = 0;
                int datasize = 0;
                int retval = Win32Native.RegQueryValueEx(hkey, name, null, ref type, (byte[])null, ref datasize);
                if (retval == 0) // Existing key
                    new RegistryPermission(RegistryPermissionAccess.Write, keyName + "\\" + name).Demand();
                else // Creating a new key
                    new RegistryPermission(RegistryPermissionAccess.Create, keyName + "\\" + name).Demand();
            }
            else
                // unmanaged code trust required for remote access
            new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Demand();
            
            int ret = 0;
    
            if (value is Int32) {
                int data = ((Int32)value);
    
                ret = Win32Native.RegSetValueEx(hkey,
                    name,
                    0,
                    REG_DWORD,
                    new int[]{data},
                    4);
            }
            else if (value is Array) {
                byte[] dataBytes = null;
                String[] dataStrings = null;
    
                if (value is byte[])
                    dataBytes = (byte[])value;
                else if (value is String[])
                    dataStrings = (String[])value;
                else
                    throw new ArgumentException(String.Format(Environment.GetResourceString("Arg_RegSetBadArrType"), value.GetType().Name));
    
                if (dataBytes != null) {
                    ret = Win32Native.RegSetValueEx(hkey,
                        name,
                        0,
                        REG_BINARY,
                        dataBytes,
                        dataBytes.Length);
                }
                else if (dataStrings != null) {
                    bool unicode = (_SystemDefaultCharSize != 1);
    
                    IntPtr currentPtr = new IntPtr(0);
                    int sizeInBytes = 0;
    
                    // First determine the size of the array
                    //
                    if (unicode) {
                        for (int i=0; i<dataStrings.Length; i++) {
                            if (dataStrings[i] == null)
                                throw new ArgumentException(Environment.GetResourceString("Arg_RegSetStrArrNull"));
                            sizeInBytes += (dataStrings[i].Length+1) * 2;
                        }
                        sizeInBytes += 2;
                    }
                    else {
                        for (int i=0; i<dataStrings.Length; i++) {
                            if (dataStrings[i] == null)
                                throw new ArgumentException(Environment.GetResourceString("Arg_RegSetStrArrNull"));
                            sizeInBytes += (Encoding.Default.GetByteCount(dataStrings[i]) + 1);
                            }
                            sizeInBytes ++;
                        }

                        // Alloc the Win32 memory
                        //
                        IntPtr basePtr = Win32Native.LocalAlloc(GMEM_ZEROINIT, new IntPtr(sizeInBytes));
                        if (basePtr == Win32Native.NULL) {
                            return;
                        }
                        currentPtr = basePtr;
                   

                        // Write out the strings...
                        //
                        for (int i=0; i<dataStrings.Length; i++) {
                             if (unicode) { // Assumes that the Strings are always null terminated.
                                String.InternalCopy(dataStrings[i],currentPtr,(dataStrings[i].Length*2));
                                currentPtr = new IntPtr((long)currentPtr + (dataStrings[i].Length*2));
                                *(char*)(currentPtr.ToPointer()) = '\0';
                                currentPtr = new IntPtr((long)currentPtr + 2);
                            }
                            else {
                                byte[] data = Encoding.Default.GetBytes(dataStrings[i]);
                                System.IO.__UnmanagedMemoryStream.memcpy(data, 0, (byte*)currentPtr.ToPointer(), 0, data.Length) ;
                                currentPtr = new IntPtr((long)currentPtr + data.Length);
                                *(byte*)(currentPtr.ToPointer()) = 0;
                                currentPtr = new IntPtr((long)currentPtr + 1 );
                            }
                        }

                        if (unicode) {
                            *(char*)(currentPtr.ToPointer()) = '\0';
                            currentPtr = new IntPtr((long)currentPtr + 2);
                        }
                        else {
                            *(byte*)(currentPtr.ToPointer()) = 0;
                            currentPtr = new IntPtr((long)currentPtr + 1);
                        }

                     
    
                     ret = Win32Native.RegSetValueEx(hkey,
                            name,
                            0,
                            REG_MULTI_SZ,
                            basePtr,
                            sizeInBytes);

                        Win32Native.LocalFree(basePtr);
                    }
                }
                else {
                    String data = value.ToString();

                    if (_SystemDefaultCharSize == 1) {
                        byte[] blob = Encoding.Default.GetBytes(data);
                        byte[] rawdata = new byte[blob.Length+1];
                        Array.Copy(blob, 0, rawdata, 0, blob.Length);

                        ret = Win32Native.RegSetValueEx(hkey,
                            name,
                            0,
                            REG_SZ,
                            rawdata,
                            blob.Length);
                    }
                    else {
                        ret = Win32Native.RegSetValueEx(hkey,
                            name,
                            0,
                            REG_SZ,
                            data,
                            data.Length * 2);
                    }
                }

                if (ret == 0) {
                    SetDirty(true);
                }
                else 
                    Win32Error(ret, null);
          }

        // Retrieves a string representation of this key.
        // 
        /// <include file='doc\RegistryKey.uex' path='docs/doc[@for="RegistryKey.ToString"]/*' />
        public override String ToString() {
            ValidateState(false);
            if (IntPtr.Size == 4)
                return keyName + " [0x" + ((uint)hkey.ToInt32()).ToString("x") + "]";
            return keyName + " [0x" + ((ulong)hkey.ToInt64()).ToString("x") + "]";
        }
    
        
        private void ValidateState(bool needWrite) {
            if (hkey == INVALID_HANDLE_VALUE) {
                throw new ObjectDisposedException(keyName, Environment.GetResourceString("ObjectDisposed_RegKeyClosed"));
            }
            if (needWrite && !GetWritable()) {
                throw new UnauthorizedAccessException(Environment.GetResourceString("UnauthorizedAccess_RegistryNoWrite"));
            }
        }
    
        private static String GetMessage(int errorCode) {
            StringBuilder sb = new StringBuilder(256);
            int result = Win32Native.FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS |
                FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                Win32Native.NULL, errorCode, 0, sb, sb.Capacity + 1, Win32Native.NULL);
            if (result != 0) {
                // result is the # of characters copied to the StringBuilder on NT,
                // but on Win9x, it appears to be the number of MBCS bytes.
                // Just give up and return the String as-is...
                String s = sb.ToString();
                return s;
            }
            else {
                return Environment.GetResourceString("InvalidOperation_UnknownWin32Error", (errorCode).ToString());
            }
        }
        
        // After calling GetLastWin32Error(), it clears the last error field,
        // so you must save the HResult and pass it to this method.  This method
        // will determine the appropriate exception to throw dependent on your 
        // error, and depending on the error, insert a string into the message 
        // gotten from the ResourceManager.
        internal static void Win32Error(int errorCode, String str) {
            switch (errorCode) {
            case Win32Native.ERROR_ACCESS_DENIED:
                throw new UnauthorizedAccessException(String.Format(Environment.GetResourceString("UnauthorizedAccess_RegistryKeyGeneric_Key"), str));

            default:
                throw new IOException(GetMessage(errorCode));
            }
        }

        internal static String FixupName(String name)
        {
            BCLDebug.Assert(name!=null,"[FixupName]name!=null");
            if (name.IndexOf('\\') == -1)
                return name;

            StringBuilder sb = new StringBuilder(name);
            FixupPath(sb);
            int temp = sb.Length - 1;
            if (sb[temp] == '\\') // Remove trailing slash
                sb.Length = temp;
            return sb.ToString();
        }


       	private static void FixupPath(StringBuilder path)
		{
			int length  = path.Length;
			bool fixup = false;
			char markerChar = (char)0xFFFF;
			
			int i = 1;
			while (i < length - 1)
			{
				if (path[i] == '\\')
				{
					i++;
					while (i < length)
					{
						if (path[i] == '\\')
						{
						   path[i] = markerChar;
						   i++;
						   fixup = true;
						}
						else
						   break;
					}
					
				}
				i++;
			}

			if (fixup)
			{
				i = 0;
				int j = 0;
				while (i < length)
				{
					if(path[i] == markerChar) 
					{
						i++;
						continue;
					}
					path[j] = path[i];
					i++;
					j++;
				}
				path.Length += j - i;
			}
			
		}
    
        // Win32 constants for error handling
        private const int FORMAT_MESSAGE_IGNORE_INSERTS = 0x00000200;
        private const int FORMAT_MESSAGE_FROM_SYSTEM    = 0x00001000;
        private const int FORMAT_MESSAGE_ARGUMENT_ARRAY = 0x00002000;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\bcl\microsoft\win32\win32native.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Class:  Microsoft.Win32.Native
**
** Author: Brian Grunkemeyer (BrianGru)
**
** Purpose: The CLR wrapper for all Win32 (Win2000, NT4, Win9x, etc.)
**          native operations.
**
** Date:  September 28, 1999
**
===========================================================*/

// Notes to PInvoke users:  Getting the syntax exactly correct is crucial, and
// more than a little confusing.  Here's some guidelines.
//
// Use IntPtr for all OS handles and pointers.  IntPtr will do the right thing
// whe