ILED(hr);
    }

    hr = FilterDfsLinksDlg.put_MaxLimit(m_ulLinkFilterMaxLimit);
    RETURN_IF_FAILED(hr);

    hr = FilterDfsLinksDlg.DoModal(); 
    RETURN_IF_NOT_S_OK(hr);

    CWaitCursor wait;

    ULONG ulMaxLimit = 0;
    hr = FilterDfsLinksDlg.get_MaxLimit(&ulMaxLimit);
    RETURN_IF_FAILED(hr);

    FILTERDFSLINKS_TYPE lLinkFilterType = FILTERDFSLINKS_TYPE_NO_FILTER;
    hr = FilterDfsLinksDlg.get_EnumFilterType(&lLinkFilterType);
    RETURN_IF_FAILED(hr);

    CComBSTR bstrFilterName;
    if (lLinkFilterType != FILTERDFSLINKS_TYPE_NO_FILTER)
    {
        hr = FilterDfsLinksDlg.get_EnumFilter(&bstrFilterName);
        RETURN_IF_FAILED(hr);
    }

    m_lLinkFilterType = lLinkFilterType;
    m_bstrLinkFilterName = bstrFilterName;
    m_ulLinkFilterMaxLimit = ulMaxLimit;

    dfsDebugOut((_T("m_lLinkFilterType=%d, m_bstrLinkFilterName=%s, m_ulLinkFilterMaxLimit=%d\n"),
        m_lLinkFilterType,
        m_bstrLinkFilterName,
        m_ulLinkFilterMaxLimit));

    hr = OnRefresh();
    if (S_FALSE == hr)
    {
        // this root has already been deleted by others, no more reference
        DisplayMessageBox(::GetActiveWindow(), MB_OK, 0, IDS_INVALID_ROOT);
    }

    return hr;
}

HRESULT
CMmcDfsRoot::SetDescriptionBarText(
  IN LPRESULTDATA            i_lpResultData
  )
/*++

Routine Description:

  A routine used set the text in the Description bar above 
  the result view.

Arguments:
  i_lpResultData  -  Pointer to the IResultData callback which is
            used to set the description text

--*/
{
    RETURN_INVALIDARG_IF_NULL(i_lpResultData);

    CComBSTR  bstrTextForDescriptionBar;
    HRESULT   hr = FormatResourceString(IDS_DESCRIPTION_BAR_TEXT_ROOT, m_bstrDisplayName, &bstrTextForDescriptionBar);

    if (SUCCEEDED(hr))
        hr = i_lpResultData->SetDescBarText(bstrTextForDescriptionBar);

    return hr;
}

HRESULT
CMmcDfsRoot::SetStatusText(
  IN LPCONSOLE2            i_lpConsole
  )
/*++

Routine Description:

  Set the text in the Status bar.

Arguments:
  i_lpConsole  - IConsole2 from IComponent

--*/
{
    RETURN_INVALIDARG_IF_NULL(i_lpConsole);

    ULONG   ulTotalNumOfJPs = 0;
    HRESULT hr = m_DfsRoot->get_CountOfDfsJunctionPoints((long*)&ulTotalNumOfJPs);
    RETURN_IF_FAILED(hr);

    ULONG   ulDisplayedNumOfJPs = m_MmcJPList.size();

    CComBSTR  bstrText;
    hr = FormatMessageString(&bstrText, 0,
        IDS_STATUS_BAR_TEXT_ROOT, ulDisplayedNumOfJPs, ulTotalNumOfJPs);

    if (SUCCEEDED(hr))
        hr = i_lpConsole->SetStatusText(bstrText);

    return hr;
}

STDMETHODIMP  
CMmcDfsRoot::EnumerateResultPane(
  IN OUT IResultData*      io_pResultData
  )
/*++

Routine Description:

To eumerate(add) items in the result pane. Root level Replicas in this case

Arguments:

  io_pResultData - The callback used to add items to the Result pane

--*/
{
    RETURN_INVALIDARG_IF_NULL(io_pResultData);

    HRESULT   hr = S_OK;

    if (m_MmcRepList.empty())
    {
        CComPtr<IEnumVARIANT>       pRepEnum;
        hr = m_DfsRoot->get_RootReplicaEnum((IUnknown**) &pRepEnum);
        RETURN_IF_FAILED(hr);

        VARIANT varReplicaObject;
        VariantInit(&varReplicaObject);

        while ( S_OK == (hr = pRepEnum->Next(1, &varReplicaObject, NULL)) )
        {
            CComPtr<IDfsReplica> pReplicaObject = (IDfsReplica*) varReplicaObject.pdispVal;

            CMmcDfsReplica*   pMMCReplicaObject = new CMmcDfsReplica(pReplicaObject, this);
            if (!pMMCReplicaObject)
            {
                hr = E_OUTOFMEMORY;
            } else
            {
              hr = pMMCReplicaObject->m_hrValueFromCtor;
              if (SUCCEEDED(hr))
                  hr = pMMCReplicaObject->AddItemToResultPane(io_pResultData);

              if (SUCCEEDED(hr))
                {
                    REP_LIST_NODE* pRepNode = new REP_LIST_NODE (pMMCReplicaObject);
                    if (!pRepNode)
                        hr = E_OUTOFMEMORY;
                    else
                        m_MmcRepList.push_back(pRepNode);
                }

                if (FAILED(hr))
                    delete pMMCReplicaObject;
            }

            VariantClear(&varReplicaObject);

            if (FAILED(hr))
                break;
        } // while
    }
    else
    {
                // The replicas of this junction are already enumerated,
                // and the list exists, just add result items.
        for (DFS_REPLICA_LIST::iterator i = m_MmcRepList.begin(); i != m_MmcRepList.end(); i++)
        {
            hr = ((*i)->pReplica)->AddItemToResultPane(io_pResultData);
            BREAK_IF_FAILED(hr);
        }
    }

  return hr;
}

STDMETHODIMP 
CMmcDfsRoot::QueryPagesFor(
  )
/*++

Routine Description:

  Used to decide whether the object wants to display property pages.
  Returning S_OK typically results in a call to CreatePropertyPages.

--*/
{
    // bug#543194: ask user to close all other open property pages before we bring up the root properties.
    // This is because the OnRefresh() below will close them silently and we have to call OnRefresh
    // to pick up possible namespace updates by other DfsGui instances.
    if (S_FALSE == CloseAllPropertySheets(FALSE))
        return S_FALSE;

    //
    // refresh to pick up possible namespace updates by others
    //
    HRESULT hr = OnRefresh();
    if (S_FALSE == hr)
    {
        // this root has been deleted by others, no more reference
        DisplayMessageBox(::GetActiveWindow(), MB_OK, 0, IDS_INVALID_ROOT);
        return hr; // no property page
    }

    return S_OK; // since we want to display a propertysheet.
}


// Creates and passes back the pages to be displayed
STDMETHODIMP 
CMmcDfsRoot::CreatePropertyPages(
  IN LPPROPERTYSHEETCALLBACK      i_lpPropSheetCallback,
  IN LONG_PTR                i_lNotifyHandle
  )
/*++

Routine Description:

  Used to display the property sheet pages

Arguments:

  i_lpPropSheetCallback  -  The callback used to create the propertysheet.
  i_lNotifyHandle      -  Notify handle used by the property page

Return value:

  S_OK since we want to display a propertysheet.

--*/
{
    RETURN_INVALIDARG_IF_NULL(i_lpPropSheetCallback);

    m_lpConsole->SelectScopeItem(m_hScopeItem);

    CWaitCursor WaitCursor;
    HRESULT             hr = S_OK;

    do {
        hr = m_PropPage.Initialize((IDfsRoot*)m_DfsRoot, NULL);
        BREAK_IF_FAILED(hr);

                    // Create the page for the replica set.
                    // Pass it to the Callback
        HPROPSHEETPAGE  h_proppage = m_PropPage.Create();
        if (!h_proppage)
            hr = HRESULT_FROM_WIN32(::GetLastError());
        BREAK_IF_FAILED(hr);

                  // Pass on the notify data to the Property Page
        hr = m_PropPage.SetNotifyData(i_lNotifyHandle, (LPARAM)this);
        BREAK_IF_FAILED(hr);

        hr = i_lpPropSheetCallback->AddPage(h_proppage);
        BREAK_IF_FAILED(hr);

        //
        // Create "Replica Set" page
        //
        hr = CreateFrsPropertyPage(i_lpPropSheetCallback, i_lNotifyHandle);
        if (S_OK != hr)
        {
            if (FAILED(hr))
                DisplayMessageBox(::GetActiveWindow(), MB_OK, hr, IDS_REPPAGE_ERROR);
            hr = S_OK; // allow the other tabs to be brought up
        }

        //
        // Create "Publish" page
        //
        hr = CreatePublishPropertyPage(i_lpPropSheetCallback, i_lNotifyHandle);
        if (S_OK != hr)
        {
            if (FAILED(hr))
                DisplayMessageBox(::GetActiveWindow(), MB_OK, hr, IDS_PUBLISHPAGE_ERROR);
            hr = S_OK; // allow the other tabs to be brought up
        }

    } while (0);

    if (FAILED(hr))
        DisplayMessageBoxForHR(hr);

    return hr;
}

STDMETHODIMP 
CMmcDfsRoot::CreateFrsPropertyPage
(
  IN LPPROPERTYSHEETCALLBACK    i_lpPropSheetCallback,
  IN LONG_PTR                   i_lNotifyHandle
)
{
    //
    // init m_piReplicaSet
    //
    HRESULT hr = _InitReplicaSet();
    if (S_OK != hr) return hr;

    CComBSTR bstrType;
    hr = m_piReplicaSet->get_Type(&bstrType);
    RETURN_IF_FAILED(hr);

    if (lstrcmpi(bstrType, FRS_RSTYPE_DFS))
        return hr;

    //
    // set initial values on the property page
    //
    hr = m_frsPropPage.Initialize(m_piReplicaSet);
    RETURN_IF_FAILED(hr);

    //
    // create the property page
    //
    HPROPSHEETPAGE  h_frsproppage = m_frsPropPage.Create();
    if (!h_frsproppage)
        return HRESULT_FROM_WIN32(::GetLastError());

    //
    // pass on the notify data to the Property Page
    //
    hr = m_frsPropPage.SetNotifyData(i_lNotifyHandle, (LPARAM)this);
    RETURN_IF_FAILED(hr);

    //
    // AddPage
    //
    return i_lpPropSheetCallback->AddPage(h_frsproppage);
}

//
// m_enumNewSchema is set to SCHEMA_VERSION_UNKNOWN at instance creation time
//
BOOL CMmcDfsRoot::IsNewSchema()
{
    if (m_enumNewSchema == SCHEMA_VERSION_UNKNOWN)
    {
        HRESULT hr = S_OK;
        if (DFS_TYPE_FTDFS == m_lDfsRootType)
        {
            CComBSTR bstrDomainName;
            hr = m_DfsRoot->get_DomainName(&bstrDomainName);
            if (SUCCEEDED(hr))
                m_enumNewSchema = (S_OK == GetSchemaVersionEx(bstrDomainName, FALSE)) ? SCHEMA_VERSION_NEW : SCHEMA_VERSION_OLD;
        } else
        {
            CComBSTR bstrServer, bstrShare;
            hr = m_DfsRoot->GetOneDfsHost(&bstrServer, &bstrShare);
            if (SUCCEEDED(hr))
                m_enumNewSchema = (S_OK == GetSchemaVersionEx(bstrServer)) ? SCHEMA_VERSION_NEW : SCHEMA_VERSION_OLD;
        }
    }

    return ((m_enumNewSchema == SCHEMA_VERSION_NEW) ? TRUE : FALSE);
}

STDMETHODIMP 
CMmcDfsRoot::CreatePublishPropertyPage
(
  IN LPPROPERTYSHEETCALLBACK    i_lpPropSheetCallback,
  IN LONG_PTR                   i_lNotifyHandle
)
{
    //
    // check schema version
    //
    if (!IsNewSchema())
        return S_FALSE;

    //
    // check group policy
    //
    if (!CheckPolicyOnSharePublish())
        return S_FALSE;

    //
    // create the property page
    //
    HPROPSHEETPAGE  hpage = m_publishPropPage.Create();
    if (!hpage)
        return HRESULT_FROM_WIN32(::GetLastError());

    m_publishPropPage.Initialize(m_DfsRoot);

    //
    // pass on the notify data to the Property Page
    //
    HRESULT hr = m_publishPropPage.SetNotifyData(i_lNotifyHandle, (LPARAM)this);
    RETURN_IF_FAILED(hr);

    //
    // AddPage
    //
    return i_lpPropSheetCallback->AddPage(hpage);
}

STDMETHODIMP 
CMmcDfsRoot::PropertyChanged(
    )
/*++

Routine Description:

  Used to update the properties.

--*/
{
    return S_OK;
}

HRESULT 
CMmcDfsRoot::ToolbarSelect(
  IN const LONG          i_lArg,
  IN  IToolbar*          i_pToolBar
  )
/*++

Routine Description:

  Handle a select event for a toolbar
  Create a toolbar, it it doesn't exist.
  Attach the toolbar and enable the buttons, if the event for a selection.
  Disable the buttons, if the event was for a deselection

Arguments:
  i_lArg        -  The argument passed to the actual method.
  i_pToolBar      -  Pointer to Toolbar.

--*/
{ 
    RETURN_INVALIDARG_IF_NULL(i_pToolBar);

    BOOL    bSelect = (BOOL) HIWORD(i_lArg);  // Is the event for selection?
  
    EnableToolbarButtons(i_pToolBar, IDT_ROOT_MIN, IDT_ROOT_MAX, bSelect);

    if (bSelect)          // Should we disable or enable the toolbar?
    {
        BOOL    bReplicaSetExist = FALSE;
        HRESULT hr = m_DfsRoot->get_ReplicaSetExist(&bReplicaSetExist);
        RETURN_IF_FAILED(hr);
    
        if(DFS_TYPE_STANDALONE == m_lDfsRootType)
        {
            i_pToolBar->SetButtonState(IDT_ROOT_NEW_ROOT_REPLICA, ENABLED, FALSE);
            i_pToolBar->SetButtonState(IDT_ROOT_NEW_ROOT_REPLICA, HIDDEN, TRUE);
        }

        if (m_MmcJPList.empty())
        {
            i_pToolBar->SetButtonState(IDT_ROOT_DELETE_DISPLAYED_DFS_LINKS, ENABLED, FALSE);
            i_pToolBar->SetButtonState(IDT_ROOT_DELETE_DISPLAYED_DFS_LINKS, HIDDEN, TRUE);
        }

        if (bReplicaSetExist || 1 >= m_MmcRepList.size())
        {
            i_pToolBar->SetButtonState(IDT_ROOT_REPLICATION_TOPOLOGY, ENABLED, FALSE);
            i_pToolBar->SetButtonState(IDT_ROOT_REPLICATION_TOPOLOGY, HIDDEN, TRUE);
        }

        if (!bReplicaSetExist)
        {
            i_pToolBar->SetButtonState(IDT_ROOT_SHOW_REPLICATION, ENABLED, FALSE);
            i_pToolBar->SetButtonState(IDT_ROOT_SHOW_REPLICATION, HIDDEN, TRUE);
            i_pToolBar->SetButtonState(IDT_ROOT_HIDE_REPLICATION, ENABLED, FALSE);
            i_pToolBar->SetButtonState(IDT_ROOT_HIDE_REPLICATION, HIDDEN, TRUE);
            i_pToolBar->SetButtonState(IDT_ROOT_STOP_REPLICATION, ENABLED, FALSE);
            i_pToolBar->SetButtonState(IDT_ROOT_STOP_REPLICATION, HIDDEN, TRUE);
        } else
        {
            if (m_bShowFRS)
            {
                i_pToolBar->SetButtonState(IDT_ROOT_SHOW_REPLICATION, ENABLED, FALSE);
                i_pToolBar->SetButtonState(IDT_ROOT_SHOW_REPLICATION, HIDDEN, TRUE);
            } else
            {
                i_pToolBar->SetButtonState(IDT_ROOT_HIDE_REPLICATION, ENABLED, FALSE);
                i_pToolBar->SetButtonState(IDT_ROOT_HIDE_REPLICATION, HIDDEN, TRUE);
            }
        }

        // excluded when empty root container
        if (m_MmcRepList.empty())
        {
            i_pToolBar->SetButtonState(IDT_ROOT_NEW_DFS_LINK, ENABLED, FALSE);
            i_pToolBar->SetButtonState(IDT_ROOT_NEW_DFS_LINK, HIDDEN, TRUE);
            i_pToolBar->SetButtonState(IDT_ROOT_CHECK_STATUS, ENABLED, FALSE);
            i_pToolBar->SetButtonState(IDT_ROOT_CHECK_STATUS, HIDDEN, TRUE);
            i_pToolBar->SetButtonState(IDT_ROOT_FILTER_DFS_LINKS, ENABLED, FALSE);
            i_pToolBar->SetButtonState(IDT_ROOT_FILTER_DFS_LINKS, HIDDEN, TRUE);
        }
    }

    return S_OK; 
}




HRESULT
CMmcDfsRoot::CreateToolbar(
  IN const LPCONTROLBAR      i_pControlbar,
  IN const LPEXTENDCONTROLBAR          i_lExtendControlbar,
  OUT  IToolbar**          o_ppToolBar
  )
/*++

Routine Description:

  Create the toolbar.
  Involves the actual toolbar creation call, creating the bitmap and adding it
  and finally adding the buttons to the toolbar

Arguments:
  i_pControlbar    -  The controlbar used to create toolbar.
  i_lExtendControlbar  -  The object implementing IExtendControlbar. This is 
              the class exposed to MMC.
  o_ppToolBar      -  The Toolbar pointer.
--*/
{
    RETURN_INVALIDARG_IF_NULL(i_pControlbar);
    RETURN_INVALIDARG_IF_NULL(i_lExtendControlbar);
    RETURN_INVALIDARG_IF_NULL(o_ppToolBar);

                      // Create the toolbar
    HRESULT hr = i_pControlbar->Create(TOOLBAR, i_lExtendControlbar, reinterpret_cast<LPUNKNOWN*>(o_ppToolBar));
    RETURN_IF_FAILED(hr);

                      // Add the bitmap to the toolbar
    hr = AddBitmapToToolbar(*o_ppToolBar, IDB_ROOT_TOOLBAR);
    RETURN_IF_FAILED(hr);

    int      iButtonPosition = 0;    // The first button position
    for (int iCommandID = IDT_ROOT_MIN, iMenuResource = IDS_MENUS_ROOT_TOP_NEW_DFS_LINK;
        iCommandID <= IDT_ROOT_MAX; 
        iCommandID++,iMenuResource++,iButtonPosition++)
    {
        CComBSTR bstrMenuText;
        CComBSTR bstrToolTipText;
        hr = GetMenuResourceStrings(iMenuResource, &bstrMenuText, &bstrToolTipText, NULL);
        RETURN_IF_FAILED(hr);  

        MMCBUTTON      ToolbarButton;
        ZeroMemory(&ToolbarButton, sizeof ToolbarButton);
        ToolbarButton.nBitmap  = iButtonPosition;
        ToolbarButton.idCommand = iCommandID;
        ToolbarButton.fsState = TBSTATE_ENABLED;
        ToolbarButton.fsType = TBSTYLE_BUTTON;
        ToolbarButton.lpButtonText = bstrMenuText; // not used anyway
        ToolbarButton.lpTooltipText = bstrToolTipText;

                          // Add the button to the toolbar
        hr = (*o_ppToolBar)->InsertButton(iButtonPosition, &ToolbarButton);
        BREAK_IF_FAILED(hr);
    }

    return hr;
}



STDMETHODIMP 
CMmcDfsRoot::ToolbarClick(
  IN const LPCONTROLBAR            i_pControlbar, 
  IN const LPARAM                i_lParam
  ) 
/*++

Routine Description:

  Action to take on a click on a toolbar

Arguments:
  i_pControlbar    -  The controlbar used to create toolbar.
  i_lParam      -  The lparam to the actual notify. This is the command id of
              the button on which a click occurred.
--*/
{ 
    RETURN_INVALIDARG_IF_NULL(i_pControlbar);

    HRESULT hr = S_OK;

    switch(i_lParam)
    {
    case IDT_ROOT_NEW_DFS_LINK:
        hr = OnCreateNewJunctionPoint ();
        break;
    case IDT_ROOT_NEW_ROOT_REPLICA:
        hr = OnNewRootReplica();
        break;
    case IDT_ROOT_CHECK_STATUS:
        hr = OnCheckStatus();
        break;
    case IDT_ROOT_DELETE_DISPLAYED_DFS_LINKS:
        hr = OnDeleteDisplayedDfsLinks();
        break;
    case IDT_ROOT_DELETE_CONNECTION_TO_DFS_ROOT:
        hr = OnDeleteConnectionToDfsRoot();
        break;
    case IDT_ROOT_DELETE_DFS_ROOT:
        hr = OnDeleteDfsRoot();
        break;
    case IDT_ROOT_FILTER_DFS_LINKS:
        hr = OnFilterDfsLinks();
        break;
    case IDT_ROOT_REPLICATION_TOPOLOGY:
        hr = OnNewReplicaSet();
        break;
    case IDT_ROOT_SHOW_REPLICATION:
    case IDT_ROOT_HIDE_REPLICATION:
        m_bShowFRS = !m_bShowFRS;
        hr = OnShowReplication();
        break;
    case IDT_ROOT_STOP_REPLICATION:
        hr = OnStopReplication(TRUE);
        if (FAILED(hr))
            DisplayMessageBoxForHR(hr);
        break;
    default:
        hr = E_INVALIDARG;
        break;
    };

    return hr; 
}

HRESULT
CMmcDfsRoot::ClosePropertySheet(BOOL bSilent)
{
    if (!m_PropPage.m_hWnd && !m_frsPropPage.m_hWnd && !m_publishPropPage.m_hWnd)
        return S_OK; // no outstanding property sheet, return S_OK;

    //
    // handle property sheet for the root
    //
    CComPtr<IPropertySheetProvider>  pPropSheetProvider;
    HRESULT hr = m_lpConsole->QueryInterface(IID_IPropertySheetProvider, reinterpret_cast<void**>(&pPropSheetProvider));
    if (FAILED(hr))
    {
        hr = S_OK; // ignore the QI failure
    } else
    {
        //
        // find outstanding property sheet and bring it to foreground
        //
        hr = pPropSheetProvider->FindPropertySheet((MMC_COOKIE)m_hScopeItem, NULL, this);
        if (S_OK == hr)
        {
            if (!bSilent)
            {
                //
                // ask user to close it, return S_FALSE to quit user's operation
                //
                DisplayMessageBox(::GetActiveWindow(), MB_OK, 0, IDS_PROPERTYPAGE_NOTCLOSED);
                return S_FALSE;
            } else
            {
                //
                // silently close the property sheet, return S_OK
                //
                if (m_PropPage.m_hWnd)
                    ::SendMessage(m_PropPage.m_hWnd, WM_PARENT_NODE_CLOSING, 0, 0);

                if (m_frsPropPage.m_hWnd)
                    ::SendMessage(m_frsPropPage.m_hWnd, WM_PARENT_NODE_CLOSING, 0, 0);

                if (m_publishPropPage.m_hWnd)
                    ::SendMessage(m_publishPropPage.m_hWnd, WM_PARENT_NODE_CLOSING, 0, 0);
            }
        } else
        {
            hr = S_OK; // no outstanding property sheet, return S_OK
        }
    }

    //
    // reset HWND
    //
    m_PropPage.m_hWnd = NULL;
    m_frsPropPage.m_hWnd = NULL;
    m_publishPropPage.m_hWnd = NULL;

    return hr;
}

HRESULT
CMmcDfsRoot::ClosePropertySheetsOfAllLinks(BOOL bSilent)
{
    HRESULT hr = S_OK;

    //
    // handle property sheets for its links
    //
    if (!m_MmcJPList.empty())
    {
        for (DFS_JUNCTION_LIST::iterator i = m_MmcJPList.begin(); i != m_MmcJPList.end(); i++)
        {
            hr = ((*i)->pJPoint)->ClosePropertySheet(bSilent);
            if (!bSilent && S_FALSE == hr)
                return S_FALSE; // found an outstanding one for a link, return S_FALSE to quit user's operation
        }
    }

    return S_OK;
}

// Close all outstanding property sheets for its own and its links
// Return: S_OK if there is no open property sheet, or they have all been closed silently
// Return: S_FALSE if an open sheet is found and msgbox poped up to remind user of closing it
HRESULT
CMmcDfsRoot::CloseAllPropertySheets(BOOL bSilent)
{
    //
    // handle property sheet for the root
    //
    HRESULT hr = ClosePropertySheet(bSilent);


    if (!bSilent && S_FALSE == hr)
        return S_FALSE;

    //
    // handle property sheets for its links
    //
    return ClosePropertySheetsOfAllLinks(bSilent);
}

HRESULT
CMmcDfsRoot::OnRefresh()
{
    // Select this node first
    m_lpConsole->SelectScopeItem(m_hScopeItem);

    CWaitCursor wait;
    HRESULT     hr = S_OK;

    // silently close outstanding property sheet.        
    CloseAllPropertySheets(TRUE);

    CleanScopeChildren();
    CleanResultChildren();

    m_bShowFRS = FALSE;
    if ((IReplicaSet *)m_piReplicaSet)
        m_piReplicaSet.Release();

                  // Re-Initialize!
    hr = m_DfsRoot->Initialize(m_bstrRootEntryPath);
    if (S_OK != hr) // failt to init the root, or no such root any more, we have to stop managing the root
    {
        if (FAILED(hr))
            DisplayMessageBox(::GetActiveWindow(), MB_OK, hr, IDS_STOP_MANAGING_ROOT);

        // Delete the item from Scope Pane
        (void)m_lpConsoleNameSpace->DeleteItem(m_hScopeItem, TRUE);

        // Delete it from the internal list
        (void)m_pParent->DeleteMmcRootNode(this);

        Release();  // delete this CMmcDfsRoot object

        return S_FALSE;
    }

    BOOL bReplicaSetExist = FALSE;
    CComBSTR bstrDC;
    (void)m_DfsRoot->get_ReplicaSetExistEx(&bstrDC, &bReplicaSetExist);

                // Enumerate Junction points
    (void)EnumerateScopePane(m_lpConsoleNameSpace, m_hScopeItem);

    // set the root icon
    if (m_lpConsoleNameSpace != NULL)
    {
        SCOPEDATAITEM      ScopeDataItem;
        ZeroMemory(&ScopeDataItem, sizeof(SCOPEDATAITEM));
        ScopeDataItem.ID = m_hScopeItem;

        hr = m_lpConsoleNameSpace->GetItem(&ScopeDataItem);
        if (SUCCEEDED(hr))
        {
            ScopeDataItem.mask = SDI_IMAGE | SDI_OPENIMAGE;
            ScopeDataItem.nImage = CMmcDfsRoot::m_iIMAGEINDEX + ((DFS_TYPE_FTDFS == m_lDfsRootType)? 4 : 0) + (bReplicaSetExist ? 4 : 0);
            ScopeDataItem.nOpenImage = CMmcDfsRoot::m_iIMAGEINDEX + ((DFS_TYPE_FTDFS == m_lDfsRootType)? 4 : 0) + (bReplicaSetExist ? 4 : 0);

            m_lpConsoleNameSpace->SetItem(&ScopeDataItem);
        }
    }

                // Re-Display Result Pane.
    m_lpConsole->UpdateAllViews((IDataObject*)this, 0, 1);

    return S_OK;
}

HRESULT
CMmcDfsRoot::OnRefreshFilteredLinks()
{
    // Select this node first
    m_lpConsole->SelectScopeItem(m_hScopeItem);

    CWaitCursor wait;

    HRESULT     hr = S_OK;

    CleanScopeChildren();
    CleanResultChildren();

    m_bShowFRS = FALSE;
    if ((IReplicaSet *)m_piReplicaSet)
        m_piReplicaSet.Release();

    BOOL bReplicaSetExist = FALSE;
    CComBSTR bstrDC;
    hr = m_DfsRoot->get_ReplicaSetExistEx(&bstrDC, &bReplicaSetExist);
    if (FAILED(hr))
    {
        return OnRefresh(); // fail to access info, see if the root can be contacted or not
    }

                // Enumerate Junction points
    (void)EnumerateScopePane(m_lpConsoleNameSpace, m_hScopeItem);

    // set the root icon
    if (m_lpConsoleNameSpace != NULL)
    {
        SCOPEDATAITEM      ScopeDataItem;
        ZeroMemory(&ScopeDataItem, sizeof(SCOPEDATAITEM));
        ScopeDataItem.ID = m_hScopeItem;

        hr = m_lpConsoleNameSpace->GetItem(&ScopeDataItem);
        if (SUCCEEDED(hr))
        {
            ScopeDataItem.mask = SDI_IMAGE | SDI_OPENIMAGE;
            ScopeDataItem.nImage = CMmcDfsRoot::m_iIMAGEINDEX + ((DFS_TYPE_FTDFS == m_lDfsRootType)? 4 : 0) + (bReplicaSetExist ? 4 : 0);
            ScopeDataItem.nOpenImage = CMmcDfsRoot::m_iIMAGEINDEX + ((DFS_TYPE_FTDFS == m_lDfsRootType)? 4 : 0) + (bReplicaSetExist ? 4 : 0);
            m_lpConsoleNameSpace->SetItem(&ScopeDataItem);

        }
    }

    // re-display the result pane items
    m_lpConsole->UpdateAllViews((IDataObject*)this, 0, 1);

    return S_OK;
}

HRESULT
CMmcDfsRoot::_DeleteDfsRoot(
    IN BSTR    i_bstrServerName,
    IN BSTR    i_bstrShareName,
    IN BSTR    i_bstrFtDfsName
     )
{
/*++

Routine Description:

  Helper member function to actually delete (Stop hosting) the Dfs Root.
  This is also called to delete root level replica.

Arguments:
  
  i_bstrServerName - The server on which the Dfs has to be torn down.
  i_bRootReplica - This DfsRoot is been torn down as Root Replica.
  i_bstrFtDfsName - The FtDfs name of the Dfs. NULL for Standalone Dfs.

--*/
    RETURN_INVALIDARG_IF_NULL(i_bstrServerName);
    RETURN_INVALIDARG_IF_NULL(i_bstrShareName);

    CWaitCursor    WaitCursor;  // Display the wait cursor
    BOOL bNewSchema = IsNewSchema();
    HRESULT hr = m_DfsRoot->DeleteDfsHost(i_bstrServerName, i_bstrShareName, FALSE);
    BOOL bFTDfs = (i_bstrFtDfsName && *i_bstrFtDfsName);

    if (bFTDfs)
    {
        if (FAILED(hr) && HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) != hr)
        {
            if (IDYES == DisplayMessageBox(
                                    GetActiveWindow(), 
                                    MB_YESNO | MB_ICONEXCLAMATION, 
                                    hr, 
                                    IDS_MSG_WIZ_DELETE_FAILURE_RETRY, 
                                    i_bstrServerName))
            {
                // force delete
                hr = m_DfsRoot->DeleteDfsHost(i_bstrServerName, i_bstrShareName, TRUE);
            } else
            {
                // leave it alone
                hr = S_FALSE;
            }
        }
    }

    if (FAILED(hr))
        DisplayMessageBox(::GetActiveWindow(), MB_OK, hr, IDS_MSG_WIZ_DELETE_FAILURE, i_bstrServerName);

    //
    // delete volume object if it's standalone
    //
    if (SUCCEEDED(hr) && !bFTDfs && bNewSchema)
    {
        (void) ModifySharePublishInfoOnSARoot(
                                               i_bstrServerName,
                                               i_bstrShareName,
                                               FALSE,
                                               NULL,
                                               NULL,
                                               NULL,
                                               NULL
                                               );
    }

    return hr;
}

STDMETHODIMP CMmcDfsRoot::RemoveFromMMC()
{
    HRESULT hr = S_OK;

    if (m_hScopeItem)
    {
        if (!m_MmcJPList.empty())
        {
            // clean up the display objects
            for (DFS_JUNCTION_LIST::iterator i = m_MmcJPList.begin(); i != m_MmcJPList.end(); i++)
            {
                (*i)->pJPoint->RemoveFromMMC();
            }
        }

        // delete result pane items
        m_lpConsole->UpdateAllViews((IDataObject*)this, 0, 0);

        // delete itself from MMC scope pane
        (void)m_lpConsoleNameSpace->DeleteItem(m_hScopeItem, TRUE);

        m_hScopeItem = NULL;
    }

    return S_OK;
}

STDMETHODIMP CMmcDfsRoot::CleanScopeChildren()
{
    HRESULT hr = S_OK;

    if (!m_MmcJPList.empty())
    {
        // clean up the display objects
        for (DFS_JUNCTION_LIST::iterator i = m_MmcJPList.begin(); i != m_MmcJPList.end(); i++)
        {
            (*i)->pJPoint->RemoveFromMMC();
            delete (*i);
        }

        m_MmcJPList.erase(m_MmcJPList.begin(), m_MmcJPList.end());
    }

    return S_OK;
}


STDMETHODIMP CMmcDfsRoot::CleanResultChildren(
    )
{
    if (!m_MmcRepList.empty())
    {
        // delete result pane items
        m_lpConsole->UpdateAllViews((IDataObject*)this, 0, 0);

        // delete display object
        for (DFS_REPLICA_LIST::iterator i = m_MmcRepList.begin(); i != m_MmcRepList.end(); i++)
        {
            delete (*i);
        }

        m_MmcRepList.erase(m_MmcRepList.begin(), m_MmcRepList.end());
    }

    return(S_OK);
}

STDMETHODIMP CMmcDfsRoot::RefreshResultChildren(
    )
{
    CleanResultChildren();

    m_DfsRoot->RefreshRootReplicas();

    // Send View change notification for all veiws.
    m_lpConsole->UpdateAllViews((IDataObject*)this, 0, 1);

    return(S_OK);
}

STDMETHODIMP CMmcDfsRoot::ViewChange(
    IResultData*    i_pResultData,
    LONG_PTR        i_lHint
  )
/*++

Routine Description:

  This method handles the MMCN_VIEW_CHANGE notification.
  This updates the result view for the scope node on which the
  UpdateAllViews was called.

  if (0 == i_lHint) clean result pane only.

--*/
{
    RETURN_INVALIDARG_IF_NULL(i_pResultData);

    i_pResultData->DeleteAllRsltItems();

    CComPtr<IHeaderCtrl2> spiHeader;
    HRESULT hr = i_pResultData->QueryInterface(IID_IHeaderCtrl2, reinterpret_cast<void**>(&spiHeader));
    RETURN_IF_FAILED(hr);

    if (m_bShowFRS)
    {
        CComBSTR  bstrColumn3;
        hr = LoadStringFromResource(IDS_RESULT_COLUMN_FRS, &bstrColumn3);
        RETURN_IF_FAILED(hr);

        spiHeader->DeleteColumn(3);
        spiHeader->InsertColumn(3, bstrColumn3, LVCFMT_LEFT, MMCLV_AUTO);
    } else
    {
        spiHeader->DeleteColumn(3);
    }

    if (i_lHint)
        EnumerateResultPane(i_pResultData);

    return(S_OK);
}


STDMETHODIMP CMmcDfsRoot::AddResultPaneItem(
  CMmcDfsReplica*    i_pReplicaDispObject
  )
/*++

Routine Description:

  This method adds a new replica object to the list of replicas displayed
  in the result view.

Arguments:

  i_pReplicaDispObject - The CMmcReplica display object pointer..

--*/
{
    REP_LIST_NODE*  pNewReplica = new REP_LIST_NODE(i_pReplicaDispObject);
    if (!pNewReplica)
        return E_OUTOFMEMORY;

    m_MmcRepList.push_back(pNewReplica);

          // Re-display to display this item.
    m_lpConsole->UpdateAllViews((IDataObject*)this, 0, 1);

    return S_OK;
}

//
// This function is called when deleting a link from the scope pane
//
STDMETHODIMP CMmcDfsRoot::RemoveJP(CMmcDfsJunctionPoint *i_pJPoint, LPCTSTR i_pszDisplayName)
{
    if (!i_pJPoint || !i_pszDisplayName)
        return E_INVALIDARG;

    CWaitCursor wait;

    CComBSTR bstrDisplayName = i_pszDisplayName;
    HRESULT hr = i_pJPoint->OnRemoveJP();

    if (FAILED(hr))
    {
        DisplayMessageBox(::GetActiveWindow(), MB_OK, hr, IDS_MSG_WIZ_DELETE_JP_FAILURE, bstrDisplayName);
        return hr;
    }

    return hr;
}

//
// This function is called when removing a target from the result pane
//
STDMETHODIMP CMmcDfsRoot::RemoveReplica(LPCTSTR i_pszDisplayName)
{
    if (!i_pszDisplayName)
        return E_INVALIDARG;

    //
    // refresh to pick up possible namespace updates on root targets by other means
    //
    HRESULT hr = OnRefresh();
    if (S_FALSE == hr)
    {
        // this root has already been deleted by others, no more reference
        DisplayMessageBox(::GetActiveWindow(), MB_OK, 0, IDS_INVALID_ROOT);
        return hr;
    }

    CWaitCursor wait;

    //
    // locate the correct target to remove, then call back
    //
    for (DFS_REPLICA_LIST::iterator i = m_MmcRepList.begin(); i != m_MmcRepList.end(); i++)
    {
        if (!lstrcmpi((*i)->pReplica->m_bstrDisplayName, i_pszDisplayName))
        {
            if (m_MmcRepList.size() == 1)
            {
                //  
                // We're going to tear down the whole DFS namespace, make sure that 
                // we delete the rest of replica sets related to this Dfs root
                //
                (void)m_DfsRoot->DeleteAllReplicaSets();
            }

            hr = (*i)->pReplica->RemoveReplica();
            break;
        }
    }

    return hr;
}

STDMETHODIMP CMmcDfsRoot::RemoveResultPaneItem(
  CMmcDfsReplica*    i_pReplicaDispObject
  )
/*++

Routine Description:

  This method removes a replica object from the list of replicas displayed
  in the result view.

Arguments:

  i_pReplicaDispObject - The CMmcReplica display object pointer..

--*/
{
  dfsDebugOut((_T("CMmcDfsRoot::RemoveResultPaneItem jplist=%d, replist=%d\n"),
    m_MmcJPList.size(), m_MmcRepList.size()));

                // Remove item from list.
  for (DFS_REPLICA_LIST::iterator i = m_MmcRepList.begin(); i != m_MmcRepList.end(); i++)
  {
    if ((*i)->pReplica == i_pReplicaDispObject)
    {
      delete (*i);
      m_MmcRepList.erase(i);
      break;
    }
  }

              // Last node is removed.
  if (m_MmcRepList.empty())
  {
    // silently close any open property sheet
    CloseAllPropertySheets(TRUE);

    CleanScopeChildren();

    // Delete the item from Scope Pane
    HRESULT hr = m_lpConsoleNameSpace->DeleteItem(m_hScopeItem, TRUE);
    RETURN_IF_FAILED(hr);

        // Delete it from the internal list
    hr = m_pParent->DeleteMmcRootNode(this);
    RETURN_IF_FAILED(hr);

    Release(); // delete this CMmsDfsRoot object
  }
  else
  {
                  // Re-display to remove this item.
    m_lpConsole->UpdateAllViews((IDataObject*)this, 0, 1);
  }

  return S_OK;
}

STDMETHODIMP 
CMmcDfsRoot::OnCheckStatus() 
{ 
    //
    // refresh to pick up possible namespace updates on targets by others
    //
    HRESULT hr = OnRefresh();
    if (S_FALSE == hr)
    {
        // this root has been deleted by others, no more reference
        DisplayMessageBox(::GetActiveWindow(), MB_OK, 0, IDS_INVALID_ROOT);
        return hr;
    }

    CWaitCursor wait;

    UINT nTotal = m_MmcRepList.size();
    _ASSERT(nTotal != 0);

    UINT nMappingOn = 0;
    UINT nMappingOff = 0;
    UINT nUnreachable = 0;
                // Update state of all replicas also.
    for (DFS_REPLICA_LIST::iterator i = m_MmcRepList.begin(); i != m_MmcRepList.end(); i++)
    {
        (*i)->pReplica->OnCheckStatus();

        if (DFS_TARGET_STATE_UNREACHABLE == (*i)->pReplica->m_lTargetState)
        {
            nUnreachable++;
        } else
        {
            switch ((*i)->pReplica->m_lReferralState)
            {
            case DFS_REFERRAL_STATE_ONLINE:
                nMappingOn++;
                break;
            case DFS_REFERRAL_STATE_OFFLINE:
                nMappingOff++;
                break;
            default:
                _ASSERT(FALSE);
                break;
            }
        }
    }

    if (0xffffffff != GetFileAttributes(m_bstrRootEntryPath))
    {
        if (nTotal == nMappingOn)
        {
            m_lRootJunctionState = DFS_JUNCTION_STATE_ALL_REP_OK;
        } else if (nTotal != (nMappingOff + nUnreachable))
        {
            m_lRootJunctionState = DFS_JUNCTION_STATE_NOT_ALL_REP_OK;
        } else
        {
            m_lRootJunctionState = DFS_JUNCTION_STATE_UNREACHABLE;
        }
    } else
    {
        m_lRootJunctionState = DFS_JUNCTION_STATE_UNREACHABLE;
    }

    BOOL    bReplicaSetExist = FALSE;
    hr = m_DfsRoot->get_ReplicaSetExist(&bReplicaSetExist);
    RETURN_IF_FAILED(hr);

    if (m_lpConsoleNameSpace)
    {
        SCOPEDATAITEM     ScopeDataItem;
        ZeroMemory(&ScopeDataItem, sizeof(SCOPEDATAITEM));
        ScopeDataItem.ID = m_hScopeItem;
        hr = m_lpConsoleNameSpace->GetItem(&ScopeDataItem);// Get the item data
        RETURN_IF_FAILED(hr);

        ScopeDataItem.mask = SDI_IMAGE | SDI_OPENIMAGE;              // Set the image flag
        ScopeDataItem.nImage = CMmcDfsRoot::m_iIMAGEINDEX + ((DFS_TYPE_FTDFS == m_lDfsRootType)? 4 : 0) + (bReplicaSetExist ? 4 : 0) + m_lRootJunctionState;  // Specify the bitmap to use
        ScopeDataItem.nOpenImage = CMmcDfsRoot::m_iIMAGEINDEX + ((DFS_TYPE_FTDFS == m_lDfsRootType)? 4 : 0) + (bReplicaSetExist ? 4 : 0) + m_lRootJunctionState;  // Specify the bitmap to use

        hr = m_lpConsoleNameSpace->SetItem(&ScopeDataItem);    // set the updated item data
        RETURN_IF_FAILED(hr);
    }

    return hr;
}

HRESULT CMmcDfsRoot::GetIReplicaSetPtr(IReplicaSet** o_ppiReplicaSet)
{
    RETURN_INVALIDARG_IF_NULL(o_ppiReplicaSet);

    HRESULT hr = _InitReplicaSet();
    if (S_OK == hr)
    {
        m_piReplicaSet.p->AddRef();
        *o_ppiReplicaSet = m_piReplicaSet;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\newfrs.cpp ===
/*++
Module Name:

    NewFrs.cpp

Abstract:

    This module contains the implementation for CNewReplicaSetPage pages.
    These classes implement pages in the Create Replica Set wizard.
--*/


#include "stdafx.h"
#include "resource.h"    // To be able to use the resource symbols
#include "DfsEnums.h"    // for common enums, typedefs, etc
#include "Utils.h"      // For the LoadStringFromResource method
#include "mmcrep.h"
#include "newfrs.h"
#include "custop.h" // RSTOPOLOGYPREF_STRING g_TopologyPref[];
#include "staging.h"

////////////////////////////////////////////////
//
// CNewReplicaSetPage0: welcome page
//

CNewReplicaSetPage0::CNewReplicaSetPage0()
  : CQWizardPageImpl<CNewReplicaSetPage0>(false),
  m_hBigBoldFont(NULL)
{
}

CNewReplicaSetPage0::~CNewReplicaSetPage0()
{
    DestroyFonts(m_hBigBoldFont, NULL);
}

BOOL CNewReplicaSetPage0::OnSetActive()
{
   ::PropSheet_SetWizButtons(GetParent(), PSWIZB_NEXT);

   return TRUE;
}

LRESULT CNewReplicaSetPage0::OnInitDialog(
    IN UINT          i_uMsg, 
    IN WPARAM        i_wParam, 
    IN LPARAM        i_lParam, 
    IN OUT BOOL&     io_bHandled
    )
{
    SetupFonts( _Module.GetResourceInstance(), NULL, &m_hBigBoldFont, NULL);
    SetControlFont(m_hBigBoldFont, m_hWnd, IDC_NEWFRS_WELCOME);
    return TRUE;
}

////////////////////////////////////////////////
//
// CNewReplicaSetPage1: pick initial master page
//

CNewReplicaSetPage1::CNewReplicaSetPage1(CNewReplicaSet* i_pRepSet)
  : CQWizardPageImpl<CNewReplicaSetPage1>(false),
  m_pRepSet(i_pRepSet),
  m_nCount(0)
{
}

BOOL CNewReplicaSetPage1::OnSetActive()
{
   ::PropSheet_SetWizButtons(GetParent(), PSWIZB_BACK | PSWIZB_NEXT);

    HWND hwnd = GetDlgItem(IDC_NEWFRSWIZ_MASTER);
    int nIndex = -1;

    if ((BSTR)(m_pRepSet->m_bstrPrimaryServer))
    {
        while (-1 != (nIndex = ListView_GetNextItem(hwnd, nIndex, LVNI_ALL)))
        {
            CAlternateReplicaInfo *pInfo = (CAlternateReplicaInfo *)GetListViewItemData(hwnd, nIndex);
            if (pInfo && !lstrcmpi(m_pRepSet->m_bstrPrimaryServer, pInfo->m_bstrDnsHostName))
                break;
        }
    }

    if (-1 == nIndex)
        nIndex = 0;

    ListView_SetItemState(hwnd, nIndex, LVIS_SELECTED | LVIS_FOCUSED, 0xffffffff);

    return TRUE;
}

LRESULT CNewReplicaSetPage1::OnInitDialog(
    IN UINT          i_uMsg, 
    IN WPARAM        i_wParam, 
    IN LPARAM        i_lParam, 
    IN OUT BOOL&     io_bHandled
    )
{
    HWND        hwnd = GetDlgItem(IDC_NEWFRSWIZ_MASTER);
    HIMAGELIST  hImageList = NULL;
    int         nIconIDs[] = {IDI_16x16_SHARE, IDI_16x16_SHARENA};
    HRESULT     hr = CreateSmallImageList(
                            _Module.GetResourceInstance(),
                            nIconIDs,
                            sizeof(nIconIDs) / sizeof(nIconIDs[0]),
                            &hImageList);
    if (SUCCEEDED(hr))
    {
        ListView_SetImageList(hwnd, hImageList, LVSIL_SMALL);

        AddLVColumns(hwnd, IDS_REPLICATION_COLUMN_1, 2);
        ListView_SetExtendedListViewStyle(hwnd, LVS_EX_FULLROWSELECT);

        CComBSTR bstrNotApply;
        LoadStringFromResource(IDS_REPLICATION_NOTAPPLY, &bstrNotApply);

        AltRepList* pList = &(m_pRepSet->m_AltRepList);
        AltRepList::iterator i;
        int nIndex = 0;
        BOOL bEligible = FALSE;
        for (i = pList->begin(); i != pList->end(); i++)
        {
            bEligible = (FRSSHARE_TYPE_OK == (*i)->m_nFRSShareType);

            LVITEM  lvItem;
            ZeroMemory(&lvItem, sizeof(lvItem));
            lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
            lvItem.lParam = (LPARAM)(*i);
            lvItem.pszText = (*i)->m_bstrDisplayName;
            lvItem.iSubItem = 0;
            lvItem.iImage = (bEligible ? 0 : 1);
            nIndex = ListView_InsertItem(hwnd, &lvItem);

            lvItem.mask = LVIF_TEXT;
            lvItem.pszText = (bEligible ? (*i)->m_bstrStagingPath : bstrNotApply);
            lvItem.iItem = nIndex;
            lvItem.iSubItem = 1;
            ListView_SetItem(hwnd, &lvItem);

            //
            // count number of eligible members
            //
            if (bEligible)
                m_nCount++;
        }
    }

    return TRUE;
}

LRESULT CNewReplicaSetPage1::OnNotify(
    IN UINT            i_uMsg, 
    IN WPARAM          i_wParam, 
    IN LPARAM          i_lParam, 
    IN OUT BOOL&       io_bHandled
    )
{
    io_bHandled = FALSE;  // So that the base class gets this notify too

    NMHDR*    pNMHDR = (NMHDR*)i_lParam;
    if (NULL == pNMHDR)
        return TRUE;

    if (IDC_NEWFRSWIZ_MASTER != pNMHDR->idFrom)
        return TRUE;

    NM_LISTVIEW *pnmv = (NM_LISTVIEW *)i_lParam;
    
    switch(pNMHDR->code)
    {
    case LVN_ITEMCHANGED:
    case NM_CLICK:
        if (OnItemChanged())
        {
            ::PropSheet_SetWizButtons(GetParent(), PSWIZB_BACK | PSWIZB_NEXT);
            ::EnableWindow(GetDlgItem(IDC_NEWFRSWIZ_STAGING), TRUE);
        } else
        {
            ::PropSheet_SetWizButtons(GetParent(), PSWIZB_BACK);
            ::EnableWindow(GetDlgItem(IDC_NEWFRSWIZ_STAGING), FALSE);
        }
        return 0;    // Should be returning 0

    case NM_DBLCLK:      // Double click event
        if (OnItemChanged())
        {
            ::PropSheet_SetWizButtons(GetParent(), PSWIZB_BACK | PSWIZB_NEXT);
            ::PropSheet_PressButton(GetParent(), PSBTN_NEXT);
        }
        break;

    default:
        break;
    }

    return TRUE;  
}

BOOL CNewReplicaSetPage1::OnItemChanged()
{
    HWND hwnd = GetDlgItem(IDC_NEWFRSWIZ_MASTER);

    CAlternateReplicaInfo *pInfo = NULL;
    int nIndex = ListView_GetNextItem(hwnd, -1, LVNI_ALL | LVNI_SELECTED);
    if (-1 != nIndex)
        pInfo = (CAlternateReplicaInfo *)GetListViewItemData(hwnd, nIndex);
    if (-1 == nIndex || !pInfo)
    {
        SetDlgItemText(IDC_NEWFRSWIZ_MASTER_DESC, _T(""));
        return FALSE;
    }

    CComBSTR bstrText;
    if (FRSSHARE_TYPE_UNKNOWN == pInfo->m_nFRSShareType)
        FormatMessageString(&bstrText, pInfo->m_hrFRS, IDS_REPLICATION_UNKNOWN);

    int nID = 0;
    switch (pInfo->m_nFRSShareType)
    {
    case FRSSHARE_TYPE_NONTFRS:
        nID = IDS_REPLICATION_NONTFRS;
        break;
    case FRSSHARE_TYPE_NOTDISKTREE:
        nID = IDS_REPLICATION_NOTDISKTREE;
        break;
    case FRSSHARE_TYPE_NOTNTFS:
        nID = IDS_REPLICATION_NOTNTFS;
        break;
    case FRSSHARE_TYPE_CONFLICTSTAGING:
        nID = IDS_REPLICATION_CONFLICTSTAGING;
        break;
    case FRSSHARE_TYPE_NODOMAIN:
        nID = IDS_REPLICATION_NODOMAIN;
        break;
    case FRSSHARE_TYPE_NOTSMBDISK:
        nID = IDS_REPLICATION_NOTSMBDISK;
        break;
    case FRSSHARE_TYPE_OVERLAPPING:
        nID = IDS_REPLICATION_OVERLAPPING;
        break;
    default:
        break;
    }
    if (nID)
        LoadStringFromResource(nID, &bstrText);

    if (!bstrText)
    {
        SetDlgItemText(IDC_NEWFRSWIZ_MASTER_DESC, _T(""));
        return TRUE; // okay to enable Next button
    } else
    {
        SetDlgItemText(IDC_NEWFRSWIZ_MASTER_DESC, bstrText);
        return FALSE;
    }
}

BOOL CNewReplicaSetPage1::OnStaging(
    IN WORD            wNotifyCode,
    IN WORD            wID,
    IN HWND            hWndCtl,
    IN BOOL&           bHandled
)
{
    HWND hwnd = GetDlgItem(IDC_NEWFRSWIZ_MASTER);

    int nIndex = ListView_GetNextItem(hwnd, -1, LVNI_ALL | LVNI_SELECTED);
    if (-1 == nIndex)
        return FALSE;

    CAlternateReplicaInfo *pInfo = (CAlternateReplicaInfo *)GetListViewItemData(hwnd, nIndex);
    if (!pInfo)
        return FALSE;

    CStagingDlg dlg;
    HRESULT hr = dlg.Init(pInfo);
    if (FAILED(hr))
    {
        DisplayMessageBoxForHR(hr);
        return FALSE;
    }

    if (S_OK == dlg.DoModal())
    {
        LVITEM lvItem;
        ZeroMemory(&lvItem, sizeof(lvItem));
        lvItem.mask = LVIF_TEXT;
        lvItem.pszText = pInfo->m_bstrStagingPath;
        lvItem.iItem = nIndex;
        lvItem.iSubItem = 1;
        ListView_SetItem(hwnd, &lvItem);
    }

    return TRUE;
}

BOOL CNewReplicaSetPage1::OnWizardBack()
{
    _Reset();
    return TRUE;
}

BOOL CNewReplicaSetPage1::OnWizardNext()
{
    _Reset();

    if (m_nCount < 2)
    {
        DisplayMessageBoxWithOK(IDS_REPLICA_SET_TOPOLOGY_MINIMUM);
        return FALSE;
    }

    HWND hwnd = GetDlgItem(IDC_NEWFRSWIZ_MASTER);
    int nIndex = ListView_GetNextItem(hwnd, -1, LVNI_SELECTED);
    if (-1 == nIndex)
    {
        DisplayMessageBoxWithOK(IDS_NEWFRSWIZ_NOSELECTION);
        return FALSE;
    }

    CAlternateReplicaInfo *pInfo = (CAlternateReplicaInfo *)GetListViewItemData(hwnd, nIndex);
    m_pRepSet->m_bstrPrimaryServer = pInfo->m_bstrDnsHostName;
    if (!(m_pRepSet->m_bstrPrimaryServer))
    {
        DisplayMessageBoxForHR(E_OUTOFMEMORY);
        return FALSE;
    }

    return TRUE;
}

void CNewReplicaSetPage1::_Reset()
{
    m_pRepSet->m_bstrPrimaryServer.Empty();
}

////////////////////////////////////////////////
//
// CNewReplicaSetPage2: TopologyPref page
//

CNewReplicaSetPage2::CNewReplicaSetPage2(CNewReplicaSet* i_pRepSet, BOOL i_bNewSchema)
  : CQWizardPageImpl<CNewReplicaSetPage2>(false),
  m_pRepSet(i_pRepSet),
  m_bNewSchema(i_bNewSchema)
{
}

BOOL CNewReplicaSetPage2::OnSetActive()
{
    ::PropSheet_SetWizButtons(GetParent(), PSWIZB_BACK | PSWIZB_FINISH);

    SendDlgItemMessage(IDC_NEWFRSWIZ_TOPOLOGYPREF, CB_SETCURSEL, 0, 0);
    SendDlgItemMessage(IDC_NEWFRSWIZ_HUBSERVER, CB_SETCURSEL, 0, 0);

    MyShowWindow(GetDlgItem(IDC_NEWFRSWIZ_HUBSERVER_LABEL), FALSE);
    MyShowWindow(GetDlgItem(IDC_NEWFRSWIZ_HUBSERVER), FALSE);

    return TRUE;
}

LRESULT CNewReplicaSetPage2::OnInitDialog(
    IN UINT          i_uMsg, 
    IN WPARAM        i_wParam, 
    IN LPARAM        i_lParam, 
    IN OUT BOOL&     io_bHandled
    )
{
    //
    // add strings to Topology combo box
    //
    CComBSTR bstrTopologyPref;
    int j = 0;
    for (j = 0; j < 3; j++)
    {
        bstrTopologyPref.Empty();
        LoadStringFromResource(g_TopologyPref[j].nStringID, &bstrTopologyPref);
        SendDlgItemMessage(IDC_NEWFRSWIZ_TOPOLOGYPREF, CB_INSERTSTRING, j, (LPARAM)(BSTR)bstrTopologyPref);
    }
    bstrTopologyPref.Empty();
    LoadStringFromResource(IDS_NEWFRSWIZ_CUSTOM, &bstrTopologyPref);
    SendDlgItemMessage(IDC_NEWFRSWIZ_TOPOLOGYPREF, CB_INSERTSTRING, j, (LPARAM)(BSTR)bstrTopologyPref);

    //
    // add strings to Hub combo box
    //
    AltRepList* pList = &(m_pRepSet->m_AltRepList);
    AltRepList::iterator i;
    for (i = pList->begin(); i != pList->end(); i++)
    {
        if (FRSSHARE_TYPE_OK == (*i)->m_nFRSShareType)
        {
            SendDlgItemMessage(
                IDC_NEWFRSWIZ_HUBSERVER,
                CB_ADDSTRING,
                0, // not used 
                (LPARAM)((BSTR)(*i)->m_bstrDnsHostName)
                );
        }
    }

    MyShowWindow(GetDlgItem(IDC_NEWFRSWIZ_OLDSCHEMA), !m_bNewSchema);

    return TRUE;
}

BOOL CNewReplicaSetPage2::OnTopologyPref(
    IN WORD             wNotifyCode,
    IN WORD             wID,
    IN HWND             hWndCtl,
    IN BOOL&            bHandled
)
{
    int index = SendDlgItemMessage(IDC_NEWFRSWIZ_TOPOLOGYPREF, CB_GETCURSEL, 0, 0);
    if (!lstrcmpi(FRS_RSTOPOLOGYPREF_HUBSPOKE, g_TopologyPref[index].pszTopologyPref))
    {
        MyShowWindow(GetDlgItem(IDC_NEWFRSWIZ_HUBSERVER_LABEL), TRUE);
        MyShowWindow(GetDlgItem(IDC_NEWFRSWIZ_HUBSERVER), TRUE);
    } else
    {
        MyShowWindow(GetDlgItem(IDC_NEWFRSWIZ_HUBSERVER_LABEL), FALSE);
        MyShowWindow(GetDlgItem(IDC_NEWFRSWIZ_HUBSERVER), FALSE);
    }

    return TRUE;
}

BOOL CNewReplicaSetPage2::OnWizardBack()
{
    _Reset();
    return TRUE;
}

BOOL CNewReplicaSetPage2::OnWizardFinish()
{
    CWaitCursor wait;

    _Reset();

    HRESULT hr = S_OK;

    int index = SendDlgItemMessage(IDC_NEWFRSWIZ_TOPOLOGYPREF, CB_GETCURSEL, 0, 0);
    m_pRepSet->m_bstrTopologyPref = g_TopologyPref[index].pszTopologyPref;
    if (!(m_pRepSet->m_bstrTopologyPref))
    {
        DisplayMessageBoxForHR(E_OUTOFMEMORY);
        return FALSE;
    }

    if (!lstrcmpi(FRS_RSTOPOLOGYPREF_HUBSPOKE, m_pRepSet->m_bstrTopologyPref))
    {
        hr = GetComboBoxText(GetDlgItem(IDC_NEWFRSWIZ_HUBSERVER), &(m_pRepSet->m_bstrHubServer));
        if (FAILED(hr))
        {
            DisplayMessageBoxForHR(hr);
            return FALSE;
        }
    }

    if (!lstrcmpi(FRS_RSTOPOLOGYPREF_CUSTOM, m_pRepSet->m_bstrTopologyPref))
    {
        DisplayMessageBox(::GetActiveWindow(), MB_OK | MB_ICONINFORMATION, 0, IDS_NEWFRSWIZ_CUSTOM_MSG);
    }

    m_pRepSet->m_bstrDirFilter.Empty();
    m_pRepSet->m_bstrFileFilter = DEFAULT_FILEFILTER;
    if (!(m_pRepSet->m_bstrFileFilter))
    {
        DisplayMessageBoxForHR(E_OUTOFMEMORY);
        return FALSE;
    }

    hr = _CreateReplicaSet();
    if (FAILED(hr))
        return FALSE;  // error reported already

    m_pRepSet->m_hr = S_OK; // the only way out successfully

    return TRUE;
}

void CNewReplicaSetPage2::_Reset()
{
    m_pRepSet->m_hr = S_FALSE;
    m_pRepSet->m_bstrTopologyPref.Empty();
    m_pRepSet->m_bstrHubServer.Empty();
}

HRESULT CNewReplicaSetPage2::_CreateReplicaSet()
{
    HRESULT hr = S_OK;

    CComPtr<IReplicaSet> piReplicaSet;
    BOOL bUndo = FALSE;

    AltRepList* pList = &(m_pRepSet->m_AltRepList);
    AltRepList::iterator i;

    do {
        for (i = pList->begin(); i != pList->end(); i++)
        {
            if (FRSSHARE_TYPE_OK == (*i)->m_nFRSShareType)
            {
                (void) CreateAndHideStagingPath(
                                                (*i)->m_bstrDnsHostName,
                                                (*i)->m_bstrStagingPath
                                                );
                hr = ConfigAndStartNtfrs((*i)->m_bstrDnsHostName);
                if (FAILED(hr))
                {
                    if (IDYES != DisplayMessageBox(
                                            m_hWnd,
                                            MB_YESNO,
                                            hr,
                                            IDS_MSG_FRS_BADSERVICE,
                                            (*i)->m_bstrDisplayName,
                                            (*i)->m_bstrDnsHostName))
                    {
                        bUndo = TRUE;
                        break;
                    }

                    hr = S_OK;
                }
            }
        } // for

        BREAK_IF_FAILED(hr);

        //
        // Create replica set object with attribute:
        //      TopologyPref/HubMember/PrimaryMember/FileFilter/DirFilter
        //
        hr = CoCreateInstance(CLSID_ReplicaSet, NULL, CLSCTX_INPROC_SERVER, IID_IReplicaSet, (void**)&piReplicaSet);
        BREAK_IF_FAILED(hr);

        hr = piReplicaSet->Create(
                        m_pRepSet->m_bstrDomain,
                        m_pRepSet->m_bstrReplicaSetDN,
                        FRS_RSTYPE_DFS,
                        m_pRepSet->m_bstrTopologyPref,
                        NULL, // HubMemberDN, will set later after we know member DN
                        NULL, // PrimaryMemberDN, will set later after we know member DN
                        m_pRepSet->m_bstrFileFilter,
                        m_pRepSet->m_bstrDirFilter
                        );
        if (FAILED(hr))
        {
            piReplicaSet.Release();  // no need to call DeleteReplicaSet method when Undo
            break;
        }

        //
        // create each member
        //
        BOOL bPrimaryServerFound = FALSE;
        CComBSTR bstrPrimaryMemberDN;
        BOOL bHubSpoke = !lstrcmpi(FRS_RSTOPOLOGYPREF_HUBSPOKE, m_pRepSet->m_bstrTopologyPref);
        BOOL bHubServerFound = FALSE;
        CComBSTR bstrHubMemberDN;

        for (i = pList->begin(); i != pList->end(); i++)
        {
            if (FRSSHARE_TYPE_OK == (*i)->m_nFRSShareType)
            {
                CComBSTR bstrMemberDN;
                hr = piReplicaSet->AddMember(
                                        (*i)->m_bstrDnsHostName,
                                        (*i)->m_bstrRootPath,
                                        (*i)->m_bstrStagingPath,
                                        FALSE, // add  connection later
                                        &bstrMemberDN);
                BREAK_IF_FAILED(hr);

                if (!bPrimaryServerFound && 
                    !lstrcmpi((*i)->m_bstrDnsHostName, m_pRepSet->m_bstrPrimaryServer))
                {
                    bPrimaryServerFound = TRUE;
                    bstrPrimaryMemberDN = bstrMemberDN;
                    BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrPrimaryMemberDN, &hr);
                }

                if (bHubSpoke && !bHubServerFound &&
                    !lstrcmpi((*i)->m_bstrDnsHostName, m_pRepSet->m_bstrHubServer))
                {
                    bHubServerFound = TRUE;
                    bstrHubMemberDN = bstrMemberDN;
                    BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrHubMemberDN, &hr);
                }
            }
        }
        BREAK_IF_FAILED(hr);

        //
        // set PrimaryMember and HubMember
        //
        hr = piReplicaSet->put_PrimaryMemberDN(bstrPrimaryMemberDN);
        BREAK_IF_FAILED(hr);

        if (bHubSpoke)
        {
            hr = piReplicaSet->put_HubMemberDN(bstrHubMemberDN);
            BREAK_IF_FAILED(hr);
        }

        //
        // build connection based on specified TopologyPref
        //
        hr = piReplicaSet->CreateConnections();
        BREAK_IF_FAILED(hr);

    } while (0);


    if (!bUndo && FAILED(hr))
    {
        DisplayMessageBox(m_hWnd, MB_OK, hr, IDS_NEWFRSWIZ_FAILURE);
        bUndo = TRUE;
    }

    if (bUndo)
    {
        //
        // Delete replica set
        //
        if ((IReplicaSet *)(piReplicaSet))
        {
            piReplicaSet->Delete();
            piReplicaSet.Release();
        }

    } else
    {
        m_pRepSet->m_piReplicaSet = piReplicaSet;
    }

    return hr;
}

/////////////////////////////////////////////////
//
// CNewReplicaSet
//

HRESULT CNewReplicaSet::Initialize(
    BSTR i_bstrDomain,
    BSTR i_bstrReplicaSetDN,
    DFS_REPLICA_LIST* i_pMmcRepList
    )
{
    RETURN_INVALIDARG_IF_NULL(i_bstrDomain);
    RETURN_INVALIDARG_IF_NULL(i_bstrReplicaSetDN);
    RETURN_INVALIDARG_IF_NULL(i_pMmcRepList);

    _Reset();

    m_bstrDomain = i_bstrDomain;
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)m_bstrDomain);

    m_bstrReplicaSetDN = i_bstrReplicaSetDN;
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)m_bstrReplicaSetDN);

    HRESULT hr = S_OK;
    BOOL bTargetsOnSameServers = FALSE;

    CAlternateReplicaInfo* pInfo = NULL;
    DFS_REPLICA_LIST::iterator i;
    for (i = i_pMmcRepList->begin(); i != i_pMmcRepList->end(); i++)
    {
        hr = ((*i)->pReplica)->GetReplicationInfoEx(&pInfo);
        BREAK_IF_FAILED(hr);

        if (_InsertList(pInfo))
            bTargetsOnSameServers = TRUE; // should return S_FALSE

        pInfo = NULL;
    }

    if (FAILED(hr))
        _Reset();
    else if (bTargetsOnSameServers)
        hr = S_FALSE;

    return hr;
}

BOOL CNewReplicaSet::_InsertList(CAlternateReplicaInfo* pInfo)
{
    BOOL bFound = FALSE;
    if (pInfo)
    {
        AltRepList::iterator i;
        for (i = m_AltRepList.begin(); i != m_AltRepList.end(); i++)
        {
            if (FRSSHARE_TYPE_OK == pInfo->m_nFRSShareType &&
		!lstrcmpi(pInfo->m_bstrDnsHostName, (*i)->m_bstrDnsHostName))
            {
                bFound = TRUE;
                break;
            }
        }

        if (!bFound)
        {
            m_AltRepList.push_back(pInfo);
        } else
        {
            if ( (FRSSHARE_TYPE_OK != (*i)->m_nFRSShareType &&
                  FRSSHARE_TYPE_OK == pInfo->m_nFRSShareType) ||
                 (FRSSHARE_TYPE_UNKNOWN == (*i)->m_nFRSShareType &&
                  FRSSHARE_TYPE_UNKNOWN != pInfo->m_nFRSShareType &&
                  FRSSHARE_TYPE_OK != pInfo->m_nFRSShareType) )
            { // replace the element
                CAlternateReplicaInfo* pTemp = *i;
                *i = pInfo;
                delete pTemp;
            } else
            { // no change
                delete pInfo;
            }
        }
    }

    return bFound;
}

void CNewReplicaSet::_Reset()
{
    m_bstrDomain.Empty();
    m_bstrReplicaSetDN.Empty();
    m_bstrPrimaryServer.Empty();
    m_bstrTopologyPref.Empty();
    m_bstrHubServer.Empty();
    m_bstrFileFilter.Empty();
    m_bstrDirFilter.Empty();

    m_hr = S_FALSE;

    FreeAltRepList(&m_AltRepList);

    if ((IReplicaSet *)m_piReplicaSet)
        m_piReplicaSet.Release();
}

void FreeAltRepList(AltRepList* pList)
{
    if (pList && !pList->empty())
    {
        AltRepList::iterator i;
        for (i = pList->begin(); i != pList->end(); i++)
            delete (*i);

        pList->clear();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\mmcroot.h ===
/*++
Module Name:

    MmcRoot.h

Abstract:

    This module contains the definition for CMmcDfsRoot class. This is an class 
  for MMC display related calls for the first level node(the DfsRoot nodes)
  Also contains members and method to be able to manipulate IDfsRoot object
  and add the same to the MMC Console

--*/



#if !defined(AFX_MMCDFSROOT_H__D78B64F3_3E2B_11D1_AA1A_00C06C00392D__INCLUDED_)
#define AFX_MMCDFSROOT_H__D78B64F3_3E2B_11D1_AA1A_00C06C00392D__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000



#include "MmcDispl.h"
#include "DfsCore.h"
#include "JPProp.h"
#include "frsProp.h"
#include "pubProp.h"
#include "DfsEnums.h"

#include <list>
using namespace std;

class CMmcDfsAdmin;
class CMmcDfsJunctionPoint;
class CMmcDfsReplica;

class JP_LIST_NODE
{
public:
  CMmcDfsJunctionPoint*      pJPoint;

  JP_LIST_NODE (CMmcDfsJunctionPoint* i_pMmcJP);    // constructor defined as inline in MmcJp.cpp

  ~JP_LIST_NODE ();                  // destructor defined as inline in MmcJp.cpp
};

typedef list<JP_LIST_NODE*> DFS_JUNCTION_LIST;

class REP_LIST_NODE
{
public:
  CMmcDfsReplica*          pReplica;

  REP_LIST_NODE (CMmcDfsReplica*  i_pMmcReplica);      // constructor defined as inline in MmcRep.cpp

  ~REP_LIST_NODE ();                    // destructor defined as inline in MmcRep.cpp
};


typedef list<REP_LIST_NODE*> DFS_REPLICA_LIST;

enum SCHEMA_VERSION {
    SCHEMA_VERSION_UNKNOWN = 0,
    SCHEMA_VERSION_NEW,
    SCHEMA_VERSION_OLD
};

class CMmcDfsRoot : public CMmcDisplay  
{

public:
  CMmcDfsRoot(
    IN IDfsRoot*            i_pDfsRoot,
    IN CMmcDfsAdmin*        i_pMmcDfsAdmin,
    IN LPCONSOLE2           i_lpConsole,  
    IN ULONG                i_ulLinkFilterMaxLimit = FILTERDFSLINKS_MAXLIMIT_DEFAULT,
    IN FILTERDFSLINKS_TYPE  i_lLinkFilterType = FILTERDFSLINKS_TYPE_NO_FILTER,
    IN BSTR                 i_bstrLinkFilterName = NULL
    );

  virtual ~CMmcDfsRoot();


  // Not implemented
private:
  CMmcDfsRoot();

public:

  // For adding context menu items
  STDMETHOD(AddMenuItems)(  
    IN LPCONTEXTMENUCALLBACK    i_lpContextMenuCallback, 
    IN LPLONG            i_lpInsertionAllowed
    );



  // For taking action on a context menu selection.
  STDMETHOD(Command)(
    IN LONG              i_lCommandID
    );



  // Set the headers for the listview (in the result pane) column
  STDMETHOD(SetColumnHeader)(
    IN LPHEADERCTRL2         i_piHeaderControl
    );



  // Return the requested display information for the Result Pane
  STDMETHOD(GetResultDisplayInfo)(
    IN OUT LPRESULTDATAITEM      io_pResultDataItem
    );

  

  // Return the requested display information for the Scope Pane
  STDMETHOD(GetScopeDisplayInfo)(
    IN OUT  LPSCOPEDATAITEM      io_pScopeDataItem
    );

  

  // Add all containing items to the Scope Pane
  STDMETHOD(EnumerateScopePane)(
    IN LPCONSOLENAMESPACE      i_lpConsoleNameSpace,
    IN HSCOPEITEM          i_hParent
    );



  // Add all containing items to the Result Pane
  STDMETHOD(EnumerateResultPane)(
    IN OUT   IResultData*      io_pResultData
    );


  // Delete the node from m_MmcJPList
  STDMETHOD(DeleteMmcJPNode)(
      IN CMmcDfsJunctionPoint*    i_pJPoint,
      IN BOOL                     i_bRefresh = TRUE
    );

  // Delete the current object
  STDMETHOD(OnDeleteConnectionToDfsRoot)(
    BOOLEAN              i_bForRemoveDfs = FALSE
    );



  // Add the current item to the Scope Pane
  STDMETHOD(AddItemToScopePane)(
    IN LPCONSOLENAMESPACE      i_lpConsoleNameSpace,
    IN HSCOPEITEM          i_hParent
    );



  // Set the console verb settings. Change the state, decide the default verb, etc
  STDMETHOD(SetConsoleVerbs)(
    IN  LPCONSOLEVERB        i_lpConsoleVerb
    );


  // let MMC handle the default verb.
  STDMETHOD(DoDblClick)(
    )  { return S_FALSE; }


  // Delete the current item.
  STDMETHOD(DoDelete)(
    );


  // Checks whether the object has pages to display
  STDMETHOD(QueryPagesFor)(
    );



  // Creates and passes back the pages to be displayed
  STDMETHOD(CreatePropertyPages)(
    IN LPPROPERTYSHEETCALLBACK      i_lpPropSheetCallback,
    IN LONG_PTR                i_lNotifyHandle
    );

    STDMETHOD(CreateFrsPropertyPage)(
        IN LPPROPERTYSHEETCALLBACK    i_lpPropSheetCallback,
        IN LONG_PTR                   i_lNotifyHandle
        );

    STDMETHOD(CreatePublishPropertyPage)(
        IN LPPROPERTYSHEETCALLBACK    i_lpPropSheetCallback,
        IN LONG_PTR                   i_lNotifyHandle
        );

  // Used to notify the object that it's properties have changed
  STDMETHOD(PropertyChanged)(
    );



  // Used to set the result view description bar text
  STDMETHOD(SetDescriptionBarText)(
    IN LPRESULTDATA            i_lpResultData
    );

    STDMETHOD(SetStatusText)(
        IN LPCONSOLE2           i_lpConsole
        );


  // Delete the Remove (Stop hosting) the Dfs Root.
  STDMETHOD(OnDeleteDfsRoot)(
     );

  STDMETHOD(OnDeleteDisplayedDfsLinks)(
     );

  // Handle a select event for the node. Handle only toolbar related 
  // activities here
  STDMETHOD(ToolbarSelect)(
    IN const LONG                i_lArg,
    IN  IToolbar*                i_pToolBar
    );



  // Handle a click on the toolbar
  STDMETHOD(ToolbarClick)(
    IN const LPCONTROLBAR            i_pControlbar, 
    IN const LPARAM                i_lParam
    );


  // Handle the menu item (and toolbar) for root replica.
  STDMETHOD(OnNewRootReplica)(
    );

  // Helper member function to actually delete (Stop hosting) the Dfs Root.
  // This is also called to delete root level replica.
  HRESULT _DeleteDfsRoot(
    IN BSTR                    i_bstrServerName,
    IN BSTR                    i_bstrShareName,
    IN BSTR                    i_bstrFtDfsName
     );

  STDMETHOD(RemoveFromMMC)();

  STDMETHOD(CleanScopeChildren)(
    VOID
    );

  STDMETHOD(CleanResultChildren)(
    );

  STDMETHOD(RefreshResultChildren)(
    );

  STDMETHOD(ViewChange)(
    IResultData*    i_pResultData,
    LONG_PTR        i_lHint
  );

  STDMETHOD(AddResultPaneItem)(
    CMmcDfsReplica*    i_pReplicaDispObject
    );

  STDMETHOD(RemoveJP)(CMmcDfsJunctionPoint *i_pJPoint, LPCTSTR i_pszDisplayName);

  STDMETHOD(RemoveReplica)(LPCTSTR i_pszDisplayName);

  STDMETHOD(RemoveResultPaneItem)(
    CMmcDfsReplica*    i_pReplicaDispObject
    );

  // Check the replica status
  STDMETHOD(OnCheckStatus)(
    );

  STDMETHOD(GetEntryPath)(BSTR* o_pbstrEntryPath)
  { GET_BSTR(m_bstrRootEntryPath, o_pbstrEntryPath); }


  DISPLAY_OBJECT_TYPE GetDisplayObjectType() { return DISPLAY_OBJECT_TYPE_ROOT; }


  HRESULT CreateToolbar(
    IN const LPCONTROLBAR      i_pControlbar,
    IN const LPEXTENDCONTROLBAR          i_lExtendControlbar,
    OUT  IToolbar**          o_ppToolBar
    );


  HRESULT OnRefresh(
    );

  HRESULT OnRefreshFilteredLinks(
    );

  STDMETHOD(OnFilterDfsLinks)();

  ULONG                 get_LinkFilterMaxLimit() { return m_ulLinkFilterMaxLimit; }
  FILTERDFSLINKS_TYPE   get_LinkFilterType() { return m_lLinkFilterType; }
  BSTR                  get_LinkFilterName() { return (BSTR)m_bstrLinkFilterName; }
  BOOL                  get_ShowFRS() { return m_bShowFRS; }

  HRESULT ClosePropertySheet(BOOL bSilent);
  HRESULT ClosePropertySheetsOfAllLinks(BOOL bSilent);
  HRESULT CloseAllPropertySheets(BOOL bSilent);

private:
  // Create a new junction point. Displays the dialog box and call the other method
  STDMETHOD(OnCreateNewJunctionPoint)();


  // Create a new junction point.
  STDMETHOD(OnCreateNewJunctionPoint)(
    IN LPCTSTR          i_szJPName,
    IN LPCTSTR          i_szServerName,
    IN LPCTSTR          i_szShareName,
    IN LPCTSTR          i_szComment,
    IN long            i_lTimeOut
    );

  HRESULT OnNewReplicaSet();

  HRESULT OnShowReplication();

  HRESULT OnStopReplication(BOOL bConfirm = FALSE, BOOL bRefresh=TRUE);

  HRESULT GetIReplicaSetPtr(IReplicaSet** o_ppiReplicaSet);

  // Confirm the delete operation with the user.
  HRESULT ConfirmOperationOnDfsRoot(int idString);

  HRESULT ConfirmDeleteDisplayedDfsLinks(
    );

  HRESULT _InitReplicaSet();  // init m_piReplicaSet

  BOOL IsNewSchema();

  // Constants, Statics, etc
public:
  static const int  m_iIMAGEINDEX;
  static const int  m_iOPENIMAGEINDEX;


  // Data members
private:
  friend class CMmcDfsJunctionPoint;
  friend class CMmcDfsReplica; // so that MmcJP can access m_DfsRoot;

  CComPtr<IDfsRoot>  m_DfsRoot;        // IDfsRoot object
  CComPtr<IReplicaSet>    m_piReplicaSet;
  
  CComBSTR      m_bstrDisplayName;    // Display name of the current DfsRoot
  CComBSTR      m_bstrRootEntryPath;  // Root EntryPath;
  DFS_TYPE      m_lDfsRootType;      // Type of the DfsRoot, Standalone or Fault Tolerant
  long          m_lRootJunctionState;

  HSCOPEITEM                    m_hScopeItem;      // Scopeitem handle
  CMmcDfsAdmin*                 m_pParent;      // Pointer to the parent

  DFS_JUNCTION_LIST             m_MmcJPList;      // The list of child Junction points
  DFS_REPLICA_LIST              m_MmcRepList;      // The list of replicas

  CComBSTR                      m_bstrFullDisplayName;
  ULONG                         m_ulLinkFilterMaxLimit;
  FILTERDFSLINKS_TYPE           m_lLinkFilterType;
  CComBSTR                      m_bstrLinkFilterName;  // string filter on junction points
  ULONG                         m_ulCountOfDfsJunctionPointsFiltered;

  CReplicaSetPropPage           m_PropPage;        // The property page
  CRealReplicaSetPropPage       m_frsPropPage;
  BOOL                          m_bShowFRS;

  enum SCHEMA_VERSION           m_enumNewSchema;
  CPublishPropPage              m_publishPropPage;

  CComPtr<IConsole2>            m_lpConsole;  // The Console callback. The mother of all mmc interfaces
  CComPtr<IConsoleNameSpace>    m_lpConsoleNameSpace;  // The Callback used to do Scope Pane operations
};

#endif // !defined(AFX_MMCDFSROOT_H__D78B64F3_3E2B_11D1_AA1A_00C06C00392D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\mvedit.h ===
/*++
Module Name:

    mvEdit.cpp

Abstract:

    This module contains the declaration of the CMultiValuedStringEdit.
    This class displays the dialog to edit multi-valued string.

*/

#ifndef __MVEDIT_H_
#define __MVEDIT_H_

#include "resource.h"       // main symbols
#include "DfsEnums.h"

/////////////////////////////////////////////////////////////////////////////
// CMultiValuedStringEdit
class CMultiValuedStringEdit : 
  public CDialogImpl<CMultiValuedStringEdit>
{
public:
  CMultiValuedStringEdit(int nDlgTitle = 0, int nText = 0, UINT uiStringLengthLimit = 0);
  ~CMultiValuedStringEdit();

  enum { IDD = IDD_MVSTRINGEDIT };

BEGIN_MSG_MAP(CMultiValuedStringEdit)
  MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
  MESSAGE_HANDLER(WM_HELP, OnCtxHelp)
  MESSAGE_HANDLER(WM_CONTEXTMENU, OnCtxMenuHelp)
  MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
  COMMAND_ID_HANDLER(IDOK, OnOK)
  COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
  COMMAND_ID_HANDLER(IDC_MVSTRINGEDIT_STRING, OnString)
  COMMAND_ID_HANDLER(IDC_MVSTRINGEDIT_ADD, OnAdd)
  COMMAND_ID_HANDLER(IDC_MVSTRINGEDIT_REMOVE, OnRemove)
END_MSG_MAP()

//  Command Handlers
  LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnCtxHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnCtxMenuHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
  LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
  LRESULT OnString(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
  LRESULT OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
  LRESULT OnRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

//  Methods to access data in the dialog.
  HRESULT put_Strings(
    IN BSTR     i_bstrValues, 
    IN BSTR     i_bstrSeparators
    );
  HRESULT get_Strings(BSTR *o_bstrValues);

protected:
  CComBSTR  m_bstrSeparators;
  CComBSTR  m_bstrValues;
  int       m_nDlgTitle;
  int       m_nText;
  UINT      m_uiStringLengthLimit;
};

HRESULT InvokeMultiValuedStringEditDlg(
    IN BSTR* io_pbstr,
    IN BSTR i_bstrSeparators,
    IN int  i_nDlgTitle = 0,
    IN int  i_nText = 0,
    IN UINT i_uiStringLengthLimit = 0
    );

#endif //__MVEDIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\mvedit.cpp ===
/*++
Module Name:

    mvEdit.cpp

Abstract:

    This module contains the declaration of the CMultiValuedStringEdit.
    This class displays the dialog to edit multi-valued string.

*/

#include "stdafx.h"
#include "mvEdit.h"
#include "utils.h"
#include "dfshelp.h"

/////////////////////////////////////////////////////////////////////////////
// CMultiValuedStringEdit

CMultiValuedStringEdit::CMultiValuedStringEdit(int nDlgTitle, int nText, UINT uiStringLengthLimit) :
    m_nDlgTitle(nDlgTitle),
    m_nText(nText)
{
    m_uiStringLengthLimit = ((0 == uiStringLengthLimit || MAX_PATH <= uiStringLengthLimit) ? (MAX_PATH - 1) : uiStringLengthLimit);
}

CMultiValuedStringEdit::~CMultiValuedStringEdit()
{
}


HRESULT CMultiValuedStringEdit::put_Strings(
    IN BSTR     i_bstrValues, 
    IN BSTR     i_bstrSeparators
    )
{
    if (!i_bstrSeparators || 1 != lstrlen(i_bstrSeparators))
        return E_INVALIDARG;

    m_bstrValues.Empty();
    if (i_bstrValues)
    {
        m_bstrValues = i_bstrValues;
        RETURN_OUTOFMEMORY_IF_NULL((BSTR)m_bstrValues);
    }

    m_bstrSeparators = i_bstrSeparators;
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)m_bstrSeparators);

    if ((BSTR)m_bstrValues)
        _tcslwr((BSTR)m_bstrValues);
    _tcslwr((BSTR)m_bstrSeparators);

    return S_OK;
}


HRESULT CMultiValuedStringEdit::get_Strings
(
  BSTR *o_pbstrValues
)
{
    RETURN_INVALIDARG_IF_NULL(o_pbstrValues);

    *o_pbstrValues = NULL;

    if ((BSTR)m_bstrValues)
        GET_BSTR(m_bstrValues, o_pbstrValues);
}

LRESULT CMultiValuedStringEdit::OnInitDialog
(
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam,
  BOOL& bHandled
)
{
    HWND    hwnd = GetDlgItem(IDC_MVSTRINGEDIT_LIST);
    RECT    rect = {0};
    ::GetWindowRect(hwnd, &rect);
    int nControlWidth = rect.right - rect.left;
    int nVScrollbarWidth = GetSystemMetrics(SM_CXVSCROLL);
    int nBorderWidth = GetSystemMetrics(SM_CXBORDER);
    int nControlNetWidth = nControlWidth - 4 * nBorderWidth;

    LVCOLUMN  lvColumn = {0};
    lvColumn.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_WIDTH;
    lvColumn.fmt = LVCFMT_LEFT;
    lvColumn.iSubItem = 0;
    lvColumn.cx = nControlNetWidth;
    ListView_InsertColumn(hwnd, 0, &lvColumn);

    ::EnableWindow(GetDlgItem(IDC_MVSTRINGEDIT_ADD), FALSE);
    ::EnableWindow(GetDlgItem(IDC_MVSTRINGEDIT_REMOVE), FALSE);

    if (m_nDlgTitle)
    {
        CComBSTR bstrTitle;
        LoadStringFromResource(m_nDlgTitle, &bstrTitle);
        SetWindowText(bstrTitle);
    }

    if (m_nText)
    {
        CComBSTR bstrText;
        LoadStringFromResource(m_nText, &bstrText);
        SetDlgItemText(IDC_MVSTRINGEDIT_TEXT, bstrText);
    }

    SendDlgItemMessage(IDC_MVSTRINGEDIT_STRING, EM_LIMITTEXT, m_uiStringLengthLimit, 0);

    if (!m_bstrValues || !*m_bstrValues)
        return TRUE;

    CComBSTR    bstrToken;
    int         index = 0;
    HRESULT     hr = mystrtok(m_bstrValues, &index, m_bstrSeparators, &bstrToken);
    while (SUCCEEDED(hr) && (BSTR)bstrToken)
    {
        _tcslwr((BSTR)bstrToken);

        LVITEM  lvItem = {0};
        lvItem.mask = LVIF_TEXT;
        lvItem.pszText = bstrToken;
        ListView_InsertItem(hwnd, &lvItem);

        bstrToken.Empty();
        hr = mystrtok(m_bstrValues, &index, m_bstrSeparators, &bstrToken);;
    }

  return TRUE;  // Let the system set the focus
}

/*++
This function is called when a user clicks the ? in the top right of a property sheet
 and then clciks a control, or when they hit F1 in a control.
--*/
LRESULT CMultiValuedStringEdit::OnCtxHelp(
    IN UINT          i_uMsg,
    IN WPARAM        i_wParam,
    IN LPARAM        i_lParam,
    IN OUT BOOL&     io_bHandled
  )
{
  LPHELPINFO lphi = (LPHELPINFO) i_lParam;
  if (!lphi || lphi->iContextType != HELPINFO_WINDOW || lphi->iCtrlId < 0)
    return FALSE;

  ::WinHelp((HWND)(lphi->hItemHandle),
        DFS_CTX_HELP_FILE,
        HELP_WM_HELP,
        (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_MVSTRINGEDIT);

  return TRUE;
}

/*++
This function handles "What's This" help when a user right clicks the control
--*/
LRESULT CMultiValuedStringEdit::OnCtxMenuHelp(
    IN UINT          i_uMsg,
    IN WPARAM        i_wParam,
    IN LPARAM        i_lParam,
    IN OUT BOOL&     io_bHandled
  )
{
  ::WinHelp((HWND)i_wParam,
        DFS_CTX_HELP_FILE,
        HELP_CONTEXTMENU,
        (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_MVSTRINGEDIT);

  return TRUE;
}

LRESULT CMultiValuedStringEdit::OnString
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
  ::EnableWindow(GetDlgItem(IDC_MVSTRINGEDIT_ADD), 
      (0 < ::GetWindowTextLength(GetDlgItem(IDC_MVSTRINGEDIT_STRING))));

  return TRUE;
}

LRESULT CMultiValuedStringEdit::OnNotify
(
    IN UINT          i_uMsg,
    IN WPARAM        i_wParam,
    IN LPARAM        i_lParam,
    IN OUT BOOL&     io_bHandled
)
{
    NMHDR*    pNMHDR = (NMHDR*)i_lParam;

    if (IDC_MVSTRINGEDIT_LIST == pNMHDR->idFrom)
    {
         if (LVN_ITEMCHANGED == pNMHDR->code)
         {
             int nCount = ListView_GetSelectedCount(GetDlgItem(IDC_MVSTRINGEDIT_LIST));
            ::EnableWindow(GetDlgItem(IDC_MVSTRINGEDIT_REMOVE), (nCount >= 1));
         }
    }

    return FALSE;
}

LRESULT CMultiValuedStringEdit::OnAdd
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
    CComBSTR    bstr;
    DWORD       dwTextLength = 0;
    HRESULT hr = GetInputText(GetDlgItem(IDC_MVSTRINGEDIT_STRING), &bstr, &dwTextLength);
    if (FAILED(hr))
    {
        DisplayMessageBoxForHR(hr);
    } else if (0 < dwTextLength)
    {
        _tcslwr((BSTR)bstr);

        if (!_tcschr(bstr, *m_bstrSeparators))
        {
            LVFINDINFO lvInfo = {0};
            lvInfo.flags = LVFI_STRING;
            lvInfo.psz = bstr;

            HWND hwnd = GetDlgItem(IDC_MVSTRINGEDIT_LIST);
            if (-1 == ListView_FindItem(hwnd, -1, &lvInfo))
            {
                LVITEM  lvItem = {0};
                lvItem.mask = LVIF_TEXT;
                lvItem.pszText = bstr;
                ListView_InsertItem(hwnd, &lvItem);
            }

            SetDlgItemText(IDC_MVSTRINGEDIT_STRING, _T(""));
        } else
        {
            DisplayMessageBox(hWndCtl, MB_OK, 0, IDS_MVSTRINGEDIT_STRING_INVALID, m_bstrSeparators);
        }
    }

    ::SetFocus(GetDlgItem(IDC_MVSTRINGEDIT_STRING));

    return TRUE;
}

LRESULT CMultiValuedStringEdit::OnRemove
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
    HWND hwnd = GetDlgItem(IDC_MVSTRINGEDIT_LIST);
    int nIndex = -1;
    while (-1 != (nIndex = ListView_GetNextItem(hwnd, -1, LVNI_SELECTED)))
        ListView_DeleteItem(hwnd, nIndex);

    return TRUE;
}

LRESULT CMultiValuedStringEdit::OnOK
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
    m_bstrValues.Empty();

    HRESULT   hr = S_OK;

    HWND hwnd = GetDlgItem(IDC_MVSTRINGEDIT_LIST);
    if (0 < ListView_GetItemCount(hwnd))
    {
        PTSTR pszText = (PTSTR)calloc(m_uiStringLengthLimit+1, sizeof(TCHAR));
        if (pszText)
        {
            int nIndex = -1;
            while (-1 != (nIndex = ListView_GetNextItem(hwnd, nIndex, LVNI_ALL)))
            {
                ListView_GetItemText(hwnd, nIndex, 0, pszText, m_uiStringLengthLimit+1);

                if (!m_bstrValues || !*m_bstrValues)
                {
                    m_bstrValues = pszText;
                    BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrValues, &hr);
                } else
                {
                    m_bstrValues += m_bstrSeparators;
                    BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrValues, &hr);
                    m_bstrValues += pszText;
                    BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrValues, &hr);
                }
            }

            free(pszText);
        } else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (FAILED(hr))
    {
        DisplayMessageBoxForHR(hr);
        ::SetFocus(GetDlgItem(IDC_MVSTRINGEDIT_STRING));
        return FALSE;
    }

    EndDialog(S_OK);
    return TRUE;
}

LRESULT CMultiValuedStringEdit::OnCancel
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
/*++

Routine Description:

  Called OnCancel. Ends the dialog with S_FALSE;

*/
  EndDialog(S_FALSE);
  return TRUE;
}

//
// Invoke the dialog.
//
// S_OK: io_pbstr contains the new string
// S_FALSE: dlg cancelled, or string unchanged
// others: error occurred and reported
//
HRESULT InvokeMultiValuedStringEditDlg(
    IN BSTR* io_pbstr,
    IN BSTR i_bstrSeparators,
    IN int  i_nDlgTitle,
    IN int  i_nText,
    IN UINT i_uiStringLengthLimit
    )
{

    HRESULT hr = S_OK;
    CMultiValuedStringEdit editDlg(i_nDlgTitle, i_nText, i_uiStringLengthLimit);
    
    do {
        if (!io_pbstr)
        {
            hr = E_INVALIDARG;
            break;
        }

        hr = editDlg.put_Strings(*io_pbstr, i_bstrSeparators);
        BREAK_IF_FAILED(hr);

        if (S_OK == editDlg.DoModal())
        {
            CComBSTR bstr;
            hr = editDlg.get_Strings(&bstr);
            BREAK_IF_FAILED(hr);

            if (!*io_pbstr && (BSTR)bstr ||
                *io_pbstr && !bstr ||
                0 != lstrcmpi(*io_pbstr, bstr))
            {
                SysFreeString(*io_pbstr);
                *io_pbstr = bstr.Detach();
                hr = S_OK;
            } else
            {
                hr = S_FALSE; // string unchanged
            }
        }
    } while (0);

    if (FAILED(hr))
        DisplayMessageBoxForHR(hr);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\permpage.h ===
// PermPage.h : Declaration of the standard permissions page class

#ifndef _PERMPAGE_H_
#define _PERMPAGE_H_

#include <dssec.h> // private\inc

HRESULT 
CreateDfsSecurityPage(
    IN LPPROPERTYSHEETCALLBACK  pCallBack,
    IN LPCTSTR                  pszObjectPath,
    IN LPCTSTR                  pszObjectClass,
    IN DWORD                    dwFlags
);

#endif // _PERMPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\newfrs.h ===
/*++
Module Name:

    NewFrs.h

Abstract:

    This module contains the declaration for CNewReplicaSet wizard pages.
  These classes implement pages in the Create Replica Set wizard.

--*/


#ifndef _NEWFRS_H_
#define _NEWFRS_H_

#include "dfscore.h"
#include "QWizPage.h"
#include "mmcroot.h"

#include <list>
using namespace std;

class CAlternateReplicaInfo
{
public:
    CComBSTR        m_bstrDisplayName;
    CComBSTR        m_bstrDnsHostName;
    CComBSTR        m_bstrRootPath;
    CComBSTR        m_bstrStagingPath;
    FRSSHARE_TYPE   m_nFRSShareType;
    HRESULT         m_hrFRS;
    DWORD           m_dwServiceStartType;
    DWORD           m_dwServiceState;

    CAlternateReplicaInfo() { Reset(); }

    void Reset();
};

typedef list<CAlternateReplicaInfo *> AltRepList;

void FreeAltRepList(AltRepList* pList);

class CNewReplicaSet
{
public:
    CComBSTR                m_bstrDomain;
    CComBSTR                m_bstrReplicaSetDN;
    CComBSTR                m_bstrPrimaryServer;
    CComBSTR                m_bstrTopologyPref;
    CComBSTR                m_bstrHubServer;
    CComBSTR                m_bstrFileFilter;
    CComBSTR                m_bstrDirFilter;
    HRESULT                 m_hr;
    AltRepList              m_AltRepList;
    CComPtr<IReplicaSet>    m_piReplicaSet;

    HRESULT Initialize(
        BSTR i_bstrDomain,
        BSTR i_bstrReplicaSetDN,
        DFS_REPLICA_LIST* i_pMmcRepList
        );

private:
    BOOL _InsertList(CAlternateReplicaInfo* pInfo);
    void _Reset();
};

class CNewReplicaSetPage0:
public CQWizardPageImpl<CNewReplicaSetPage0>
{
BEGIN_MSG_MAP(CNewReplicaSetPage0)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    CHAIN_MSG_MAP(CQWizardPageImpl<CNewReplicaSetPage0>)
END_MSG_MAP()

public:
  
    enum { IDD = IDD_NEWFRSWIZ_PAGE0 };

    CNewReplicaSetPage0();
    ~CNewReplicaSetPage0();

    BOOL OnSetActive();

    LRESULT OnInitDialog(
        IN UINT            i_uMsg, 
        IN WPARAM          i_wParam, 
        IN LPARAM          i_lParam, 
        IN OUT BOOL&        io_bHandled
    );

private:
    HFONT m_hBigBoldFont;
};

class CNewReplicaSetPage1:
public CQWizardPageImpl<CNewReplicaSetPage1>
{
BEGIN_MSG_MAP(CNewReplicaSetPage1)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
    COMMAND_ID_HANDLER(IDC_NEWFRSWIZ_STAGING, OnStaging)
    CHAIN_MSG_MAP(CQWizardPageImpl<CNewReplicaSetPage1>)
END_MSG_MAP()

public:
  
    enum { IDD = IDD_NEWFRSWIZ_PAGE1 };

    CNewReplicaSetPage1(CNewReplicaSet* i_pRepSet);

    BOOL OnSetActive();
    BOOL OnWizardBack();
    BOOL OnWizardNext();

    LRESULT OnInitDialog(
        IN UINT            i_uMsg, 
        IN WPARAM          i_wParam, 
        IN LPARAM          i_lParam, 
        IN OUT BOOL&       io_bHandled
    );

    LRESULT OnNotify(
        IN UINT            i_uMsg, 
        IN WPARAM          i_wParam, 
        IN LPARAM          i_lParam, 
        IN OUT BOOL&       io_bHandled
    );

    BOOL OnItemChanged();

    BOOL OnStaging(
        IN WORD            wNotifyCode,
        IN WORD            wID,
        IN HWND            hWndCtl,
        IN BOOL&           bHandled
    );

private:
    void _Reset();

    CNewReplicaSet* m_pRepSet;
    int             m_nCount;   // number of eligible members
};

class CNewReplicaSetPage2:
public CQWizardPageImpl<CNewReplicaSetPage2>
{
BEGIN_MSG_MAP(CNewReplicaSetPage2)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    COMMAND_ID_HANDLER(IDC_NEWFRSWIZ_TOPOLOGYPREF, OnTopologyPref)
    CHAIN_MSG_MAP(CQWizardPageImpl<CNewReplicaSetPage2>)
END_MSG_MAP()
  
public:

    enum { IDD = IDD_NEWFRSWIZ_PAGE2 };

    CNewReplicaSetPage2(CNewReplicaSet* i_pRepSet, BOOL i_bNewSchema);

    BOOL OnSetActive();
    BOOL OnWizardBack();
    BOOL OnWizardFinish();

    LRESULT OnInitDialog(
        IN UINT            i_uMsg, 
        IN WPARAM          i_wParam, 
        IN LPARAM          i_lParam, 
        IN OUT BOOL&        io_bHandled
    );

    BOOL OnTopologyPref(
        IN WORD             wNotifyCode,
        IN WORD             wID,
        IN HWND             hWndCtl,
        IN BOOL&            bHandled
    );

private:
    void _Reset();
    HRESULT _CreateReplicaSet();

    CNewReplicaSet* m_pRepSet;
    BOOL            m_bNewSchema;
};

#endif // _NEWFRS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\pubprop.h ===
/*++
Module Name:

    pubProp.h

Abstract:

--*/


#ifndef __PUBPROP_H_
#define __PUBPROP_H_

#include "dfscore.h"
#include "dfsenums.h"
#include "qwizpage.h"   // The base class that implements the common functionality  
                        // of property and wizard pages



// ----------------------------------------------------------------------------
// CPublishPropPage: Property Page for publishing root as volume object

class CPublishPropPage : public CQWizardPageImpl<CPublishPropPage>
{
public:
  enum { IDD = IDD_PUBLISH_PROP };
  
  BEGIN_MSG_MAP(CPublishPropPage)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER(WM_HELP, OnCtxHelp)
    MESSAGE_HANDLER(WM_CONTEXTMENU, OnCtxMenuHelp)
    MESSAGE_HANDLER(WM_PARENT_NODE_CLOSING, OnParentClosing)
    COMMAND_ID_HANDLER(IDC_PUBPROP_PUBLISH, OnPublish)
    COMMAND_ID_HANDLER(IDC_PUBPROP_DESCRIPTION, OnDescription)
    COMMAND_ID_HANDLER(IDC_PUBPROP_KEYWORDS_EDIT, OnEditKeywords)
    COMMAND_ID_HANDLER(IDC_PUBPROP_MANAGEDBY, OnManagedBy)

    CHAIN_MSG_MAP(CQWizardPageImpl<CPublishPropPage>)
  END_MSG_MAP()

  CPublishPropPage();
  ~CPublishPropPage();

  LRESULT OnInitDialog(
    IN UINT          i_uMsg, 
    IN WPARAM        i_wParam, 
    LPARAM          i_lParam, 
    IN OUT BOOL&      io_bHandled
    );

  LRESULT OnCtxHelp(
    IN UINT          i_uMsg, 
    IN WPARAM        i_wParam, 
    IN LPARAM        i_lParam, 
    IN OUT BOOL&     io_bHandled
    );

  LRESULT OnCtxMenuHelp(
    IN UINT          i_uMsg, 
    IN WPARAM        i_wParam, 
    IN LPARAM        i_lParam, 
    IN OUT BOOL&     io_bHandled
    );

  HRESULT Initialize(IN IDfsRoot* i_piDfsRoot);

  // Message handlers

  LRESULT OnApply(
    );

  LRESULT OnPublish(
    IN WORD            i_wNotifyCode, 
    IN WORD            i_wID, 
    IN HWND            i_hWndCtl, 
    IN OUT BOOL&        io_bHandled
    );

  LRESULT OnDescription(
    IN WORD            i_wNotifyCode, 
    IN WORD            i_wID, 
    IN HWND            i_hWndCtl, 
    IN OUT BOOL&        io_bHandled
    );

  LRESULT OnEditKeywords(
    IN WORD            i_wNotifyCode, 
    IN WORD            i_wID, 
    IN HWND            i_hWndCtl, 
    IN OUT BOOL&        io_bHandled
    );

  LRESULT OnManagedBy(
    IN WORD            i_wNotifyCode, 
    IN WORD            i_wID, 
    IN HWND            i_hWndCtl, 
    IN OUT BOOL&        io_bHandled
    );

  // Used by the node to tell the propery page to close.
  LRESULT OnParentClosing(
    IN UINT             i_uMsg, 
    IN WPARAM           i_wParam, 
    LPARAM              i_lParam, 
    IN OUT BOOL&        io_bHandled
    );


  // Used to set notification data
  HRESULT SetNotifyData(
    IN LONG_PTR         i_lNotifyHandle,
    IN LPARAM           i_lParam
    );

protected:
    void _Reset();
    void _Load();
    HRESULT _Save(
        IN BOOL i_bPublish,
        IN BSTR i_bstrDescription,
        IN BSTR i_bstrKeywords,
        IN BSTR i_bstrManagedBy
        );

private:
    LONG_PTR    m_lNotifyHandle;
    LPARAM      m_lNotifyParam;

    CComPtr<IDfsRoot> m_piDfsRoot;

    BOOL        m_bPublish;
    CComBSTR    m_bstrUNCPath;
    CComBSTR    m_bstrDescription;
    CComBSTR    m_bstrKeywords;
    CComBSTR    m_bstrManagedBy;
    CComBSTR    m_bstrError;
};

#endif // __PUBPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\permpage.cpp ===
// PermPage.cpp : Implementation of data object classes

#include "stdafx.h"
#include "PermPage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static HINSTANCE            g_hDll = NULL;
static PFNDSCREATESECPAGE   g_hProc = NULL;

HRESULT 
CreateDfsSecurityPage(
    IN LPPROPERTYSHEETCALLBACK  pCallBack,
    IN LPCTSTR                  pszObjectPath,
    IN LPCTSTR                  pszObjectClass,
    IN DWORD                    dwFlags
)
{
  _ASSERT( pCallBack );

  HRESULT hr = S_OK;
  HPROPSHEETPAGE hPage = NULL;

  if (!g_hDll)
  {
    if ( !(g_hDll = LoadLibrary(_T("dssec.dll"))) ||
         !(g_hProc = (PFNDSCREATESECPAGE)GetProcAddress(g_hDll, "DSCreateSecurityPage")) )
    {
      DWORD dwErr = GetLastError();
      if (g_hDll)
      {
        FreeLibrary(g_hDll);
        g_hDll = NULL;
      }
      return HRESULT_FROM_WIN32(dwErr);
    }
  }

  hr = (*g_hProc)(pszObjectPath,
                  pszObjectClass,
                  dwFlags,
                  &hPage,
                  NULL,
                  NULL,
                  0);

  if (SUCCEEDED(hr) && hPage)
    pCallBack->AddPage(hPage);
  
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\qwizpage.h ===
/*++
Module Name:

	QWizPage.h

Abstract:

	This class provides a class for using Wizard pages
	Definition for CQWizardPageImpl.
	
	Coincidence: The code looks a lot like ATL code. :)

	Note: 
	1. Q just to be sure when someone does writes a Wizard Page
	class, we don't clash. 
	
--*/


#ifndef __CQWIZARDPAGEIMPL_H_
#define __CQWIZARDPAGEIMPL_H_


#ifndef _PRSHT_H_
	#error QueWiz.h requires prsht.h to be included first
#endif

#pragma comment(lib, "comctl32.lib")

template <class T>
class CQWizardPageImpl : public CDialogImplBase
{
public:
	PROPSHEETPAGE	m_psp;
	HPROPSHEETPAGE	m_hpsp;
	CComBSTR		m_bstrTitle;
	CComBSTR		m_bstrSubTitle;


	operator PROPSHEETPAGE*() { return &m_psp; }

	CQWizardPageImpl(
		IN bool			i_bShowHeader
		)
		:m_hpsp(NULL)
	{
		
		ZeroMemory(&m_psp, sizeof m_psp);

		m_psp.dwSize = sizeof m_psp;
		m_psp.hInstance = _Module.GetResourceInstance();

		m_psp.pszTemplate = MAKEINTRESOURCE(T::IDD);
		m_psp.pfnDlgProc = T::StartDialogProc;
		
		m_psp.dwFlags = PSP_DEFAULT | PSP_USECALLBACK;
		m_psp.pfnCallback = T::PropPageCallback;
		
		if ( false == i_bShowHeader)
		{
			m_psp.dwFlags |= PSP_HIDEHEADER;
		}

		m_psp.lParam = (LPARAM)this;
	}


	void SetHeaderTitle(
		IN LPCTSTR		i_lpszHeaderTitle
		)
	{
		m_psp.dwFlags |= PSP_USEHEADERTITLE;	// Header title. Wizard 97
		m_bstrTitle = i_lpszHeaderTitle;
		m_psp.pszHeaderTitle = m_bstrTitle;
	}


	void SetHeaderSubTitle(
		IN LPCTSTR		i_lpszHeaderSubTitle
		)
	{
		m_psp.dwFlags |= PSP_USEHEADERSUBTITLE;	// Header sub title. Wizard 97
		m_bstrSubTitle = i_lpszHeaderSubTitle;
		m_psp.pszHeaderSubTitle = m_bstrSubTitle;
	}

	static UINT CALLBACK PropPageCallback(
		HWND	hWnd, 
		UINT	uMsg, 
		LPPROPSHEETPAGE ppsp
		)
	{
		if(uMsg == PSPCB_CREATE)
		{
			_ASSERTE(hWnd == NULL);
			CDialogImplBase* pPage = (CDialogImplBase*)ppsp->lParam;
			_Module.AddCreateWndData(&pPage->m_thunk.cd, pPage);
		}
		else if(uMsg == PSPCB_RELEASE)
		{
			CQWizardPageImpl* pPage = (CQWizardPageImpl*)ppsp->lParam;
			pPage->Delete();
		}

		return 1;
	}

	virtual HPROPSHEETPAGE Create()
	{
		return (m_hpsp = ::CreatePropertySheetPage(&m_psp));
	}

							// Implement this in derived class to do clean up when property
							// Page is closed.
	virtual void Delete()
	{
		return;
	}

	virtual BOOL EndDialog(int)
	{
		// Calling ::EndDialog will close the whole sheet
		_ASSERTE(FALSE);
		return FALSE;
	}


	BEGIN_MSG_MAP(CQWizardPageImpl<T>)
		MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
	END_MSG_MAP()


	LRESULT OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		_ASSERTE(::IsWindow(m_hWnd));

		NMHDR*		pNMHDR = (NMHDR*)lParam;
		_ASSERT(NULL != pNMHDR);
		if (NULL == pNMHDR)
		{
			bHandled = FALSE;
			return 1;
		}


		// Ignore messages not from the page/sheet itself
		if(pNMHDR->hwndFrom != m_hWnd && pNMHDR->hwndFrom != ::GetParent(m_hWnd))
		{
			bHandled = FALSE;
			return 1;
		}

		T*			pT = (T*)this;
		LRESULT		lResult = 0;
		
		
		switch(pNMHDR->code)	// Used to call actual methods
		{
		case PSN_SETACTIVE:
			lResult = pT->OnSetActive() ? 0 : -1;
			break;

		case PSN_KILLACTIVE:
			lResult = !pT->OnKillActive();
			break;

		case PSN_RESET:
			pT->OnReset();
			break;

		case PSN_QUERYCANCEL:
			lResult = !pT->OnQueryCancel();
			break;

		case PSN_WIZNEXT:
			lResult = !pT->OnWizardNext();
			break;

		case PSN_WIZBACK:
			lResult = !pT->OnWizardBack();
			break;

		case PSN_WIZFINISH:
			lResult = !pT->OnWizardFinish();
			break;

		case PSN_HELP:
			lResult = pT->OnHelp();
			break;

		case PSN_APPLY:
			lResult = pT->OnApply() ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
			break;

		default:
			bHandled = FALSE;	// not handled
		}

		return lResult;
	}

	BOOL OnSetActive()
	{
		return TRUE;
	}

	BOOL OnKillActive()
	{
		return TRUE;
	}

	void OnReset()
	{
	}

	BOOL OnQueryCancel()
	{
		return TRUE;    // ok to cancel
	}
	
	BOOL OnWizardBack()
	{
		return TRUE;
	}
	
	BOOL OnWizardNext()
	{
		return TRUE;
	}
	
	BOOL OnWizardFinish()
	{
		return TRUE;
	}
	
	BOOL OnHelp()
	{
		return TRUE;
	}

	BOOL OnApply()
	{
		return TRUE;
	}

};

#endif	// __CQWIZARDPAGEIMPL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\staging.cpp ===
/*++
Module Name:

    staging.cpp

Abstract:

    This module contains the Implementation of CStagingDlg.
    This class displays the Staging Folder Dialog.

*/

#include "stdafx.h"
#include "utils.h"
#include <lm.h>
#include "staging.h"
#include "dfshelp.h"

/////////////////////////////////////////////////////////////////////////////
// CStagingDlg

CStagingDlg::CStagingDlg() : m_pRepInfo(NULL)
{
}

HRESULT CStagingDlg::Init(CAlternateReplicaInfo* pRepInfo)
{
    if (!pRepInfo ||
        FRSSHARE_TYPE_OK != pRepInfo->m_nFRSShareType ||
        !(pRepInfo->m_bstrDisplayName) || !*(pRepInfo->m_bstrDisplayName) ||    // DFS target
        !(pRepInfo->m_bstrDnsHostName) || !*(pRepInfo->m_bstrDnsHostName) ||    // FRS member machine
        !(pRepInfo->m_bstrRootPath) || !*(pRepInfo->m_bstrRootPath) ||          // FRS replication folder
        !(pRepInfo->m_bstrStagingPath) || !*(pRepInfo->m_bstrStagingPath)       // the staging path we've picked
        )
        return E_INVALIDARG;

    m_pRepInfo = pRepInfo;

    return S_OK;
}

LRESULT CStagingDlg::OnInitDialog
(
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam,
  BOOL& bHandled
)
{
    ::SendMessage(GetDlgItem(IDC_STAGING_FOLDER), EM_LIMITTEXT, _MAX_DIR - 1, 0);
    SetDlgItemText(IDC_STAGING_TARGET, m_pRepInfo->m_bstrDisplayName);
    SetDlgItemText(IDC_STAGING_FOLDER, m_pRepInfo->m_bstrStagingPath);

    return TRUE;  // Let the system set the focus
}

/*++
This function is called when a user clicks the ? in the top right of a property sheet
 and then clciks a control, or when they hit F1 in a control.
--*/
LRESULT CStagingDlg::OnCtxHelp(
    IN UINT          i_uMsg,
    IN WPARAM        i_wParam,
    IN LPARAM        i_lParam,
    IN OUT BOOL&     io_bHandled
  )
{
    LPHELPINFO lphi = (LPHELPINFO) i_lParam;
    if (!lphi || lphi->iContextType != HELPINFO_WINDOW || lphi->iCtrlId < 0)
        return FALSE;

    ::WinHelp((HWND)(lphi->hItemHandle),
            DFS_CTX_HELP_FILE,
            HELP_WM_HELP,
            (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_STAGING);

    return TRUE;
}

/*++
This function handles "What's This" help when a user right clicks the control
--*/
LRESULT CStagingDlg::OnCtxMenuHelp(
    IN UINT          i_uMsg,
    IN WPARAM        i_wParam,
    IN LPARAM        i_lParam,
    IN OUT BOOL&     io_bHandled
  )
{
    ::WinHelp((HWND)i_wParam,
            DFS_CTX_HELP_FILE,
            HELP_CONTEXTMENU,
            (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_STAGING);

    return TRUE;
}

LRESULT CStagingDlg::OnOK
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
    BOOL      bValidInput = FALSE;
    int       idString = 0;
    HRESULT   hr = S_OK;

    do {
        CWaitCursor wait;

        CComBSTR bstrStagingPath;
        DWORD    dwTextLength = 0;

        hr = GetInputText(GetDlgItem(IDC_STAGING_FOLDER), &bstrStagingPath, &dwTextLength);
        if (FAILED(hr))
            break;
        if (0 == dwTextLength)
        {
            idString = IDS_MSG_EMPTY_FIELD;
            break;
        }

        if (!lstrcmpi(bstrStagingPath, m_pRepInfo->m_bstrStagingPath))
        {
            // no change
            bValidInput = TRUE;
            break;
        }

        //
        // validate user's input
        //

        int nLengthOfStagingPath = lstrlen(bstrStagingPath);

        // local path?
        if (!IsValidLocalAbsolutePath(bstrStagingPath) ||
            S_OK != VerifyDriveLetter(m_pRepInfo->m_bstrDnsHostName, bstrStagingPath))
        {
            idString = IDS_INVALID_FOLDER;
            break;
        }

        // lie under root path?
        if (_totupper(*bstrStagingPath) == _totupper(*(m_pRepInfo->m_bstrRootPath)))
        {
            int nLengthOfRootPath = lstrlen(m_pRepInfo->m_bstrRootPath);

            if (!lstrcmpi(bstrStagingPath, m_pRepInfo->m_bstrRootPath) ||
                (nLengthOfStagingPath > nLengthOfRootPath && 
                !mylstrncmpi(bstrStagingPath, m_pRepInfo->m_bstrRootPath, nLengthOfRootPath) &&
                (*(m_pRepInfo->m_bstrRootPath + nLengthOfRootPath - 1) == _T('\\') ||
                 *(bstrStagingPath + nLengthOfRootPath) == _T('\\')))
                )
            {
                idString = IDS_STAGING_LIE_UNDER_ROOTPATH;
                break;
            }
        }

        // on NTFS file system that support object identifiers?
        if (_totupper(*bstrStagingPath) != _totupper(*(m_pRepInfo->m_bstrStagingPath)))
        {
            TCHAR szSuffix[] = _T("C:\\");
            szSuffix[0] = *bstrStagingPath;

            CComBSTR bstrVolumeRootPath;
            if (S_OK == IsComputerLocal(m_pRepInfo->m_bstrDnsHostName))
            {
                bstrVolumeRootPath = szSuffix;  // bstrVolumeRootPath points at "X:\" if local machine
            } else
            {
                if (*(m_pRepInfo->m_bstrDnsHostName) == _T('\\') &&
                    *(m_pRepInfo->m_bstrDnsHostName + 1) == _T('\\'))
                {
                    bstrVolumeRootPath = m_pRepInfo->m_bstrDnsHostName;
                } else
                {
                    bstrVolumeRootPath = _T("\\\\");
                    bstrVolumeRootPath += m_pRepInfo->m_bstrDnsHostName;
                }
                bstrVolumeRootPath += _T("\\");
            
                szSuffix[1] = _T('$');
                bstrVolumeRootPath += szSuffix; // bstrVolumeRootPath points at "\\server\X$\" if remote machine
            }

            TCHAR szFileSystemName[MAX_PATH];
            DWORD dwMaxCompLength = 0;
            DWORD dwFileSystemFlags = 0;
            if (!GetVolumeInformation(bstrVolumeRootPath, NULL, 0, NULL, &dwMaxCompLength,
                                    &dwFileSystemFlags, szFileSystemName, MAX_PATH))
            {
                if (IDYES != DisplayMessageBox(::GetActiveWindow(), MB_YESNO, 0, IDS_STAGING_NO_VOLUME_INFO))
                    break;
            } else if (CSTR_EQUAL != CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, _T("NTFS"), -1, szFileSystemName, -1) ||
                       !(FILE_SUPPORTS_OBJECT_IDS & dwFileSystemFlags))
            {
                idString = IDS_STAGING_NOT_NTFS;
                break;
            }
        }

        m_pRepInfo->m_bstrStagingPath = bstrStagingPath;

        bValidInput = TRUE;

    } while (0);

    if (FAILED(hr))
    {
        DisplayMessageBoxForHR(hr);
        ::SetFocus(GetDlgItem(IDC_STAGING_FOLDER));
        return FALSE;
    } else if (bValidInput)
    {
        EndDialog(S_OK);
        return TRUE;
    }
    else
    {
        if (idString)
            DisplayMessageBoxWithOK(idString);
        ::SetFocus(GetDlgItem(IDC_STAGING_FOLDER));
        return FALSE;
    }
}

LRESULT CStagingDlg::OnCancel
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
    EndDialog(S_FALSE);
    return TRUE;
}

BOOL CStagingDlg::OnBrowse(
    IN WORD            wNotifyCode,
    IN WORD            wID,
    IN HWND            hWndCtl,
    IN BOOL&           bHandled
)
{
    CWaitCursor wait;
    PTSTR       pszServer = m_pRepInfo->m_bstrDnsHostName;
    BOOL        bLocalComputer = (S_OK == IsComputerLocal(pszServer));

    TCHAR       szDir[MAX_PATH * 2] = _T(""); // double the size in case the remote path is itself close to MAX_PATH
    OpenBrowseDialog(m_hWnd, IDS_BROWSE_STAGING_FOLDER, bLocalComputer, pszServer, szDir);

    CComBSTR bstrPath;
    if (szDir[0])
    {
        if (bLocalComputer)
            bstrPath = szDir;
        else
        { // szDir is in the form of \\server\share or \\server\share\path....
            LPTSTR pShare = _tcschr(szDir + 2, _T('\\'));
            pShare++;
            LPTSTR pLeftOver = _tcschr(pShare, _T('\\'));
            if (pLeftOver && *pLeftOver)
                *pLeftOver++ = _T('\0');

            SHARE_INFO_2 *psi = NULL;
            if (NERR_Success == NetShareGetInfo(pszServer, pShare, 2, (LPBYTE *)&psi))
            {
                bstrPath = psi->shi2_path;
                if (pLeftOver && *pLeftOver)
                {
                    if (_T('\\') != bstrPath[lstrlen(bstrPath) - 1])
                        bstrPath += _T("\\");
                    bstrPath += pLeftOver;
                }
                NetApiBufferFree(psi);
            }
        }
    }

    if ((BSTR)bstrPath && *bstrPath)
        SetDlgItemText(IDC_STAGING_FOLDER, bstrPath);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\pubprop.cpp ===
/*++
Module Name:

    pubProp.cpp

Abstract:

--*/

#include "stdafx.h"
#include "resource.h"
#include "utils.h"
#include "pubProp.h"
#include "mvEdit.h"
#include "dfshelp.h"
#include "ldaputils.h"

CPublishPropPage::CPublishPropPage() :
    m_lNotifyHandle(0), 
    m_lNotifyParam(0), 
	CQWizardPageImpl<CPublishPropPage>(false)
{
    m_bPublish = FALSE;
}

CPublishPropPage::~CPublishPropPage()
{
    // do not call MMCFreeNotifyHandle(m_lNotifyHandle);
    //
    // It should only be called once, and is already called 
    // by the main property page
}

void CPublishPropPage::_Load()
{
    HRESULT hr = S_OK;

    CComBSTR bstrUNCPath;
    do {
        if (!m_piDfsRoot)
        {
            hr = E_INVALIDARG;
            break;
        }

        DFS_TYPE lDfsType = DFS_TYPE_UNASSIGNED;
        hr = m_piDfsRoot->get_DfsType((long *)&lDfsType);
        BREAK_IF_FAILED(hr);

        if (lDfsType != DFS_TYPE_FTDFS)
        {
            CComBSTR bstrServerName, bstrShareName;
            hr = m_piDfsRoot->GetOneDfsHost(&bstrServerName, &bstrShareName);
            BREAK_IF_FAILED(hr);

            if (lstrlen(bstrShareName) > MAX_RDN_KEY_SIZE)
            {
                LoadStringFromResource(IDS_PUBPAGE_ERRMSG_64, &m_bstrError);
                return;
            }

            bstrUNCPath = _T("\\\\");
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrUNCPath, &hr);
            bstrUNCPath += bstrServerName;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrUNCPath, &hr);
            bstrUNCPath += _T("\\");
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrUNCPath, &hr);
            bstrUNCPath += bstrShareName;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrUNCPath, &hr);

            hr = ReadSharePublishInfoOnSARoot(
                                    bstrServerName,
                                    bstrShareName,
                                    &m_bPublish,
                                    &m_bstrUNCPath,
                                    &m_bstrDescription,
                                    &m_bstrKeywords,
                                    &m_bstrManagedBy
                                    );
            BREAK_IF_FAILED(hr);
        } else
        {
            CComBSTR bstrDomainName;
            hr = m_piDfsRoot->get_DomainName(&bstrDomainName);
            BREAK_IF_FAILED(hr);

            CComBSTR bstrDfsName;
            hr = m_piDfsRoot->get_DfsName(&bstrDfsName);
            BREAK_IF_FAILED(hr);

            bstrUNCPath = _T("\\\\");
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrUNCPath, &hr);
            bstrUNCPath += bstrDomainName;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrUNCPath, &hr);
            bstrUNCPath += _T("\\");
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrUNCPath, &hr);
            bstrUNCPath += bstrDfsName;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrUNCPath, &hr);

            hr = ReadSharePublishInfoOnFTRoot(
                                    bstrDomainName,
                                    bstrDfsName,
                                    &m_bPublish,
                                    &m_bstrUNCPath,
                                    &m_bstrDescription,
                                    &m_bstrKeywords,
                                    &m_bstrManagedBy
                                    );
            BREAK_IF_FAILED(hr);
        }
    } while (0);

    if (FAILED(hr))
    {
        _Reset();
        GetMessage(&m_bstrError, hr, IDS_PUBPAGE_ERRMSG);
    }

    if (!m_bstrUNCPath || !*m_bstrUNCPath)
        m_bstrUNCPath = bstrUNCPath;
}

HRESULT CPublishPropPage::_Save(
    IN BOOL i_bPublish,
    IN BSTR i_bstrDescription,
    IN BSTR i_bstrKeywords,
    IN BSTR i_bstrManagedBy
    )
{
    RETURN_INVALIDARG_IF_NULL((IDfsRoot *)m_piDfsRoot);

    HRESULT hr = S_OK;

    do {
        if (m_bPublish == i_bPublish &&
            PROPSTRNOCHNG((BSTR)m_bstrDescription, i_bstrDescription) &&
            PROPSTRNOCHNG((BSTR)m_bstrKeywords, i_bstrKeywords) &&
            PROPSTRNOCHNG((BSTR)m_bstrManagedBy, i_bstrManagedBy) )
            break; // no change

        DFS_TYPE lDfsType = DFS_TYPE_UNASSIGNED;
        hr = m_piDfsRoot->get_DfsType((long *)&lDfsType);
        BREAK_IF_FAILED(hr);

        if (lDfsType != DFS_TYPE_FTDFS)
        {
            CComBSTR bstrServerName, bstrShareName;
            hr = m_piDfsRoot->GetOneDfsHost(&bstrServerName, &bstrShareName);
            BREAK_IF_FAILED(hr);

            hr = ModifySharePublishInfoOnSARoot(
                                    bstrServerName,
                                    bstrShareName,
                                    i_bPublish,
                                    m_bstrUNCPath,
                                    i_bstrDescription,
                                    i_bstrKeywords,
                                    i_bstrManagedBy
                                    );
            if (S_OK == hr)
            {
                m_bPublish = i_bPublish;
                m_bstrDescription = i_bstrDescription;
                m_bstrKeywords = i_bstrKeywords;
                m_bstrManagedBy = i_bstrManagedBy;
            } else if (S_FALSE == hr)
                hr = S_OK; // ignore non-existing object

            BREAK_IF_FAILED(hr);
        } else
        {
            CComBSTR bstrDomainName;
            hr = m_piDfsRoot->get_DomainName(&bstrDomainName);
            BREAK_IF_FAILED(hr);

            CComBSTR bstrDfsName;
            hr = m_piDfsRoot->get_DfsName(&bstrDfsName);
            BREAK_IF_FAILED(hr);

            hr = ModifySharePublishInfoOnFTRoot(
                                    bstrDomainName,
                                    bstrDfsName,
                                    i_bPublish,
                                    m_bstrUNCPath,
                                    i_bstrDescription,
                                    i_bstrKeywords,
                                    i_bstrManagedBy
                                    );
            if (S_OK == hr)
            {
                m_bPublish = i_bPublish;
                m_bstrDescription = i_bstrDescription;
                m_bstrKeywords = i_bstrKeywords;
                m_bstrManagedBy = i_bstrManagedBy;
            }
            BREAK_IF_FAILED(hr);
        }
    } while (0);

    return hr;
}

LRESULT
CPublishPropPage::OnInitDialog(
	IN UINT						i_uMsg,
	IN WPARAM					i_wParam,
	LPARAM						i_lParam,
	IN OUT BOOL&				io_bHandled
	)
{
    CWaitCursor wait;

    _Load();

    CheckDlgButton(IDC_PUBPROP_PUBLISH, (m_bPublish ? BST_CHECKED : BST_UNCHECKED));
    ::EnableWindow(GetDlgItem(IDC_PUBPROP_UNCPATH_LABEL), m_bPublish);
    ::EnableWindow(GetDlgItem(IDC_PUBPROP_UNCPATH), m_bPublish);
    ::EnableWindow(GetDlgItem(IDC_PUBPROP_DESCRIPTION_LABEL), m_bPublish);
    ::EnableWindow(GetDlgItem(IDC_PUBPROP_DESCRIPTION), m_bPublish);
    ::EnableWindow(GetDlgItem(IDC_PUBPROP_KEYWORDS_LABEL), m_bPublish);
    ::EnableWindow(GetDlgItem(IDC_PUBPROP_KEYWORDS), m_bPublish);
    ::EnableWindow(GetDlgItem(IDC_PUBPROP_KEYWORDS_EDIT), m_bPublish);
    ::EnableWindow(GetDlgItem(IDC_PUBPROP_MANAGEDBY_LABEL), m_bPublish);
    ::EnableWindow(GetDlgItem(IDC_PUBPROP_MANAGEDBY), m_bPublish);

    SetDlgItemText(IDC_PUBPROP_ERROR, ((BSTR)m_bstrError) ? m_bstrError : _T(""));
    SetDlgItemText(IDC_PUBPROP_UNCPATH, ((BSTR)m_bstrUNCPath) ? m_bstrUNCPath : _T(""));
    SetDlgItemText(IDC_PUBPROP_DESCRIPTION, ((BSTR)m_bstrDescription) ? m_bstrDescription : _T(""));
    SetDlgItemText(IDC_PUBPROP_KEYWORDS, ((BSTR)m_bstrKeywords) ? m_bstrKeywords : _T(""));
    SetDlgItemText(IDC_PUBPROP_MANAGEDBY, ((BSTR)m_bstrManagedBy) ? m_bstrManagedBy : _T(""));
    
    if (!m_bstrError)
    {
        ::SendMessage(GetDlgItem(IDC_PUBPROP_DESCRIPTION), EM_LIMITTEXT, 1024, 0); // AD schema defines its upper to be 1024
        MyShowWindow(GetDlgItem(IDC_PUBPROP_ERROR), FALSE);
    } else
    {
        MyShowWindow(GetDlgItem(IDC_PUBPROP_PUBLISH), FALSE);
        MyShowWindow(GetDlgItem(IDC_PUBPROP_UNCPATH), FALSE);
        MyShowWindow(GetDlgItem(IDC_PUBPROP_UNCPATH_LABEL), FALSE);
        MyShowWindow(GetDlgItem(IDC_PUBPROP_DESCRIPTION), FALSE);
        MyShowWindow(GetDlgItem(IDC_PUBPROP_DESCRIPTION_LABEL), FALSE);
        MyShowWindow(GetDlgItem(IDC_PUBPROP_KEYWORDS), FALSE);
        MyShowWindow(GetDlgItem(IDC_PUBPROP_KEYWORDS_LABEL), FALSE);
        MyShowWindow(GetDlgItem(IDC_PUBPROP_KEYWORDS_EDIT), FALSE);
        MyShowWindow(GetDlgItem(IDC_PUBPROP_MANAGEDBY), FALSE);
        MyShowWindow(GetDlgItem(IDC_PUBPROP_MANAGEDBY_LABEL), FALSE);
    }

    return TRUE;			// To let the dialg set the control
}

/*++
This function is called when a user clicks the ? in the top right of a property sheet
 and then clciks a control, or when they hit F1 in a control.
--*/
LRESULT CPublishPropPage::OnCtxHelp(
    IN UINT          i_uMsg,
    IN WPARAM        i_wParam,
    IN LPARAM        i_lParam,
    IN OUT BOOL&     io_bHandled
  )
{
    LPHELPINFO lphi = (LPHELPINFO) i_lParam;
    if (!lphi || lphi->iContextType != HELPINFO_WINDOW || lphi->iCtrlId < 0)
        return FALSE;

    ::WinHelp((HWND)(lphi->hItemHandle),
            DFS_CTX_HELP_FILE,
            HELP_WM_HELP,
            (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_PUBLISH_PROP);

    return TRUE;
}

/*++
This function handles "What's This" help when a user right clicks the control
--*/
LRESULT CPublishPropPage::OnCtxMenuHelp(
    IN UINT          i_uMsg,
    IN WPARAM        i_wParam,
    IN LPARAM        i_lParam,
    IN OUT BOOL&     io_bHandled
  )
{
    ::WinHelp((HWND)i_wParam,
            DFS_CTX_HELP_FILE,
            HELP_CONTEXTMENU,
            (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_PUBLISH_PROP);

    return TRUE;
}

void CPublishPropPage::_Reset()
{
    m_bPublish = FALSE;

    m_bstrUNCPath.Empty();
    m_bstrDescription.Empty();
    m_bstrKeywords.Empty();
    m_bstrManagedBy.Empty();
}

HRESULT CPublishPropPage::Initialize(
    IN IDfsRoot* i_piDfsRoot
    )
{
    RETURN_INVALIDARG_IF_NULL(i_piDfsRoot);

    if ((IDfsRoot *)m_piDfsRoot)
        m_piDfsRoot.Release();

    m_piDfsRoot = i_piDfsRoot;

    _Reset();

    return S_OK;
}

LRESULT
CPublishPropPage::OnApply()
{
    CWaitCursor wait;

    HRESULT hr = S_OK;
    DWORD   dwTextLength = 0;
    int     idControl = 0;
    int     idString = 0;
    BOOL    bValidInput = FALSE;

    BOOL bPublish = IsDlgButtonChecked(IDC_PUBPROP_PUBLISH);
    CComBSTR bstrDescription;
    CComBSTR bstrKeywords;
    CComBSTR bstrManagedBy;
    do {
        idControl = IDC_PUBPROP_DESCRIPTION;
        hr = GetInputText(GetDlgItem(idControl), &bstrDescription, &dwTextLength);
        BREAK_IF_FAILED(hr);

        idControl = IDC_PUBPROP_KEYWORDS;
        hr = GetInputText(GetDlgItem(idControl), &bstrKeywords, &dwTextLength);
        BREAK_IF_FAILED(hr);

        idControl = IDC_PUBPROP_MANAGEDBY;
        hr = GetInputText(GetDlgItem(idControl), &bstrManagedBy, &dwTextLength);
        BREAK_IF_FAILED(hr);

        bValidInput = TRUE;

    } while (0);

    if (FAILED(hr))
    {
        SetActivePropertyPage(GetParent(), m_hWnd);
        DisplayMessageBoxForHR(hr);
        ::SetFocus(GetDlgItem(idControl));
        return FALSE;
    } else if (bValidInput)
    {
        hr = _Save(bPublish, bstrDescription, bstrKeywords, bstrManagedBy);
        if (FAILED(hr))
        {
           SetActivePropertyPage(GetParent(), m_hWnd);
           if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
                DisplayMessageBox(::GetActiveWindow(), MB_OK, 0, IDS_FAILED_TO_PUBLISH_DFSROOT_BADUSER);
            else   
                DisplayMessageBox(::GetActiveWindow(), MB_OK, hr, IDS_FAILED_TO_PUBLISH_DFSROOT, m_bstrUNCPath);
            return FALSE;
        } else if (S_FALSE == hr) // no dfs root object in the DS
        {
            SetActivePropertyPage(GetParent(), m_hWnd);
            DisplayMessageBox(::GetActiveWindow(), MB_OK, 0, IDS_FAILED_TO_PUBLISH_NOROOTOBJ);
            return FALSE;
        }

        ::SendMessage(GetParent(), PSM_UNCHANGED, (WPARAM)m_hWnd, 0);

        if (m_lNotifyHandle && m_lNotifyParam)
            MMCPropertyChangeNotify(m_lNotifyHandle, m_lNotifyParam);

        return TRUE;
    } else
    {
        SetActivePropertyPage(GetParent(), m_hWnd);
        if (idString)
            DisplayMessageBoxWithOK(idString);
        ::SetFocus(GetDlgItem(idControl));
        return FALSE;
    }
}

LRESULT
CPublishPropPage::OnPublish(
	IN WORD						i_wNotifyCode,
	IN WORD						i_wID,
	IN HWND						i_hWndCtl,
	IN OUT BOOL&				io_bHandled
	)
{
	if (BN_CLICKED == i_wNotifyCode)
    {
		::SendMessage(GetParent(), PSM_CHANGED, (WPARAM)m_hWnd, 0);

        BOOL bEnable = (BST_CHECKED == IsDlgButtonChecked(i_wID));
        ::EnableWindow(GetDlgItem(IDC_PUBPROP_UNCPATH_LABEL), bEnable);
        ::EnableWindow(GetDlgItem(IDC_PUBPROP_UNCPATH), bEnable);
        ::EnableWindow(GetDlgItem(IDC_PUBPROP_DESCRIPTION_LABEL), bEnable);
        ::EnableWindow(GetDlgItem(IDC_PUBPROP_DESCRIPTION), bEnable);
        ::EnableWindow(GetDlgItem(IDC_PUBPROP_KEYWORDS_LABEL), bEnable);
        ::EnableWindow(GetDlgItem(IDC_PUBPROP_KEYWORDS), bEnable);
        ::EnableWindow(GetDlgItem(IDC_PUBPROP_KEYWORDS_EDIT), bEnable);
        ::EnableWindow(GetDlgItem(IDC_PUBPROP_MANAGEDBY_LABEL), bEnable);
        ::EnableWindow(GetDlgItem(IDC_PUBPROP_MANAGEDBY), bEnable);
    }

    return TRUE;
}

LRESULT
CPublishPropPage::OnDescription(
	IN WORD						i_wNotifyCode,
	IN WORD						i_wID,
	IN HWND						i_hWndCtl,
	IN OUT BOOL&				io_bHandled
	)
{
	if (EN_CHANGE == i_wNotifyCode)
    {
		::SendMessage(GetParent(), PSM_CHANGED, (WPARAM)m_hWnd, 0);
    }

	return TRUE;
}

LRESULT
CPublishPropPage::OnEditKeywords(
	IN WORD						i_wNotifyCode,
	IN WORD						i_wID,
	IN HWND						i_hWndCtl,
	IN OUT BOOL&				io_bHandled
	)
{
    DWORD dwTextLength = 0;
    CComBSTR bstrKeywords;
    GetInputText(GetDlgItem(IDC_PUBPROP_KEYWORDS), &bstrKeywords, &dwTextLength);

    if (S_OK == InvokeMultiValuedStringEditDlg(
                        &bstrKeywords,
                        _T(";"),
                        IDS_MVSTRINGEDIT_TITLE_KEYWORDS,
                        IDS_MVSTRINGEDIT_TEXT_KEYWORDS,
                        KEYTWORDS_UPPER_RANGER))
    {
        SetDlgItemText(IDC_PUBPROP_KEYWORDS, bstrKeywords);
        ::SendMessage(GetParent(), PSM_CHANGED, (WPARAM)m_hWnd, 0);
    }

	return TRUE;
}

LRESULT
CPublishPropPage::OnManagedBy(
	IN WORD						i_wNotifyCode,
	IN WORD						i_wID,
	IN HWND						i_hWndCtl,
	IN OUT BOOL&				io_bHandled
	)
{
	if (EN_CHANGE == i_wNotifyCode)
    {
        ::SendMessage(GetParent(), PSM_CHANGED, (WPARAM)m_hWnd, 0);
    }

	return TRUE;
}

LRESULT
CPublishPropPage::OnParentClosing(
	IN UINT							i_uMsg,
	IN WPARAM						i_wParam,
	LPARAM							i_lParam,
	IN OUT BOOL&					io_bHandled
	)
{
	::SendMessage(GetParent(), PSM_PRESSBUTTON, PSBTN_CANCEL, 0);

	return TRUE;
}

HRESULT
CPublishPropPage::SetNotifyData(
	IN LONG_PTR						i_lNotifyHandle,
	IN LPARAM						i_lParam
	)
{
	m_lNotifyHandle = i_lNotifyHandle;
	m_lNotifyParam = i_lParam;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DFSGUI.RC
//
#define IDI_MAIN32x32                   1
#define IDD_CREATE_DFSROOT_WIZ_PAGE4    101
#define IDS_APPLICATION_NAME            102
#define IDS_NODENAME                    103
#define IDD_DLGCONNECTTO                103
#define IDR_DFSSNAPINSCOPEMANAGER       104
#define IDR_DFSSNAPINRESULTMANAGER      105
#define IDD_CREATE_DFSROOT_WIZ_PAGE1    105
#define IDD_CREATE_DFSROOT_WIZ_PAGE3    106
#define IDS_RESULT_COLUMN_ROOTREPLICA   107
#define IDS_RESULT_COLUMN_REPLICA       108
#define IDS_RESULT_COLUMN_FRS           109
#define IDI_16x16_DOMAIN                110
#define IDI_16x16_SHARE                 111
#define IDI_16x16_SHARENA               112
#define IDI_16x16_FTROOT                113
#define IDI_16x16_SAROOT                114
#define IDD_CREATE_DFSROOT_WIZ_PAGE2    114
#define IDD_CREATE_DFSROOT_WIZ_PAGE5    115
#define IDD_CREATE_DFSROOT_WIZ_PAGE6    116
#define IDD_CREATE_DFSROOT_WIZ_PAGE7    117
#define IDB_SCOPE_IMAGES_16x16          120
#define IDB_SCOPE_IMAGES_32x32          121
#define IDB_MAIN16x16                   122
#define IDB_MAIN32x32                   123
#define IDB_ADMIN_TOOLBAR               124
#define IDB_ROOT_TOOLBAR                125
#define IDB_JP_TOOLBAR                  126
#define IDB_REPLICA_TOOLBAR             127
#define IDB_CONNECT_16x16               128
#define IDB_CREATE_DFSROOT_WATERMARK    129
#define IDB_CREATE_DFSROOT_HEADER       130
#define IDB_NEWFRSWIZ_BANNER            131
#define IDS_MSG_STOP_REPLICATION        186
#define IDS_MSG_STOP_REPLICATION_TARGET 187
#define IDS_MSG_DELETE_DISPLAYEDDFSLINKS 188
#define IDS_MSG_DELETE_CONNECTION_TO_DFSROOT 189
#define IDS_MSG_DELETE_DFSROOT          190
#define IDS_MSG_REMOVE_ROOT_REPLICA     191
#define IDS_MSG_REMOVE_REPLICA          192
#define IDS_MSG_REMOVE_JP               193
#define IDS_MSG_FAILED_TO_INITIALIZE_DFSROOT 194
#define IDD_ADDTODFS                    194
#define IDS_FAILED_TO_BROWSE_NETWORKPATH 196
#define IDS_BROWSE_NET_DLG              198
#define IDS_MSG_FAILED_TO_CREATE_JUNCTION_POINT 199
#define IDS_MSG_FAILED_TO_CREATE_REPLICA 200
#define IDC_EditDfsRoot                 201
#define IDS_FAILED_TO_BROWSE_SERVER     201
#define IDS_MSG_INCORRECT_DOMAIN        202
#define IDC_TREEDFSRoots                203
#define IDS_MSG_INCORRECT_SERVER        203
#define IDD_ADDREP                      205
#define IDC_ADDREP_REPLICATE            206
#define IDS_APP_BINARY_NAME             208
#define IDS_DESCRIPTION_BAR_TEXT_ADMIN  209
#define IDS_DESCRIPTION_BAR_TEXT_ROOT   210
#define IDS_DESCRIPTION_BAR_TEXT_JUNCTIONPOINT 211
#define IDS_STATUS_BAR_TEXT_ROOT        212
#define IDS_MSG_WIZ_DFS_ALREADY_PRESENT 213
#define IDS_MSG_WIZ_DELETE_FAILURE      214
#define IDC_WELCOME_SMALL_TITLE         215
#define IDC_WELCOME_BIG_TITLE           216
#define IDC_DFSWIZ_TEXT                 217
#define IDD_JP_PROP                     223
#define IDC_EDITCHLDNODE                224
#define IDC_EDITNETPATH                 225
#define IDC_BUTTONNETBROWSE             226
#define IDC_EDITCOMMENT                 227
#define IDC_EDITTIME                    228
#define IDC_EDIT_ADDLINK_DFSLINK_PATH   229
#define IDC_REPLICA_SET_NAME            230
#define IDC_EDIT_ADDREP_DFSLINK_PATH    231
#define IDC_REPLICA_SET_COMMENT         232
#define IDC_REFFERAL_TIME_LABEL         233
#define IDC_REFFERAL_TIME               234
#define IDS_MSG_WIZ_DELETE_JP_FAILURE   236
#define IDS_MSG_WIZ_DELETE_REPLICA_FAILURE 237
#define IDS_WIZ_PAGE2_TITLE             238
#define IDS_WIZ_PAGE2_SUBTITLE          239
#define IDS_WIZ_PAGE3_TITLE             240
#define IDS_WIZ_PAGE3_SUBTITLE          241
#define IDS_WIZ_PAGE4_TITLE             242
#define IDS_WIZ_PAGE4_SUBTITLE          243
#define IDS_WIZ_PAGE5_TITLE             244
#define IDS_WIZ_PAGE5_SUBTITLE          245
#define IDS_WIZ_PAGE6_TITLE             246
#define IDS_WIZ_PAGE6_SUBTITLE          247
#define IDS_ENABLED                     250
#define IDS_DISABLED                    251
#define IDS_REPLICATION_STATUS_NOTELIGIBLE 252
#define IDS_REPLICATION_STATUS_UNKNOWN  253
#define IDS_REPLICATION_STATUSBAR_MEMBER 254
#define IDS_REPLICATION_STATUSBAR_NONMEMBER 255
#define IDS_REPLICATION_STATUSBAR_NONTFRS 256
#define IDS_REPLICATION_STATUSBAR_NOTDISKTREE 257
#define IDS_REPLICATION_STATUSBAR_NOTNTFS 258
#define IDS_REPLICATION_STATUSBAR_CONFLICTSTAGING 259
#define IDS_REPLICATION_STATUSBAR_NODOMAIN 260
#define IDS_REPLICATION_STATUSBAR_NOTSMBDISK 261
#define IDS_REPLICATION_STATUSBAR_OVERLAPPING 262
#define IDS_REPLICATION_COLUMN_1        271
#define IDS_REPLICATION_COLUMN_2        272
#define IDS_REPLICATION_NOTAPPLY        274
#define IDS_REPLICATION_NONTFRS         275
#define IDS_REPLICATION_NOTDISKTREE     276
#define IDS_REPLICATION_NOTNTFS         277
#define IDS_REPLICATION_CONFLICTSTAGING 278
#define IDS_REPLICATION_NODOMAIN        279
#define IDS_REPLICATION_NOTSMBDISK      280
#define IDS_REPLICATION_OVERLAPPING     281
#define IDS_REPLICATION_UNKNOWN         282
#define IDC_FILTERDFSLINKS_MAXLIMIT     331
#define IDC_FILTERDFSLINKS_RADIO_NO     332
#define IDC_FILTERDFSLINKS_RADIO_YES    333
#define IDC_FILTERDFSLINKS_FILTER_TYPE  334
#define IDC_FILTERDFSLINKS_FILTER       335
#define IDC_FILTERDFSLINKS_FILTER_LABEL 336
#define IDC_FRSPROP_FILEFILTER          340
#define IDC_FRSPROP_FILEFILTER_EDIT     341
#define IDC_FRSPROP_DIRFILTER           342
#define IDC_FRSPROP_DIRFILTER_EDIT      343
#define IDC_FRSPROP_PRIMARYMEMBER_LABEL 344
#define IDC_FRSPROP_PRIMARYMEMBER       345
#define IDC_FRSPROP_TOPOLOGYPREF        346
#define IDC_FRSPROP_HUBSERVER_LABEL     347
#define IDC_FRSPROP_HUBSERVER           348
#define IDC_FRSPROP_RESETSCHEDULE       349
#define IDC_FRSPROP_CUSTOMIZE           350
#define IDC_FRS_CUSTOP_TOPOLOGYPREF     355
#define IDC_FRS_CUSTOP_REBUILD          356
#define IDC_FRS_CUSTOP_HUBSERVER_LABEL  357
#define IDC_FRS_CUSTOP_HUBSERVER        358
#define IDC_FRS_CUSTOP_CONNECTIONS      359
#define IDC_FRS_CUSTOP_CONNECTIONS_NEW  360
#define IDC_FRS_CUSTOP_CONNECTIONS_DELETE 361
#define IDC_FRS_CUSTOP_SCHEDULE         362
#define IDC_FRS_CUSTOP_ADVANCED         363
#define IDC_FRS_NEWCONN_FROM            365
#define IDC_FRS_NEWCONN_TO              366
#define IDC_NEWFRS_WELCOME              370
#define IDC_NEWFRSWIZ_MASTER            371
#define IDC_NEWFRSWIZ_MASTER_DESC       372
#define IDC_NEWFRSWIZ_TOPOLOGYPREF      373
#define IDC_NEWFRSWIZ_HUBSERVER_LABEL   374
#define IDC_NEWFRSWIZ_HUBSERVER         375
#define IDC_NEWFRSWIZ_OLDSCHEMA         376
#define IDD_PUBLISH_PROP                380
#define IDC_PUBPROP_PUBLISH             381
#define IDC_PUBPROP_UNCPATH_LABEL       382
#define IDC_PUBPROP_UNCPATH             383
#define IDC_PUBPROP_DESCRIPTION_LABEL   384
#define IDC_PUBPROP_DESCRIPTION         385
#define IDC_PUBPROP_KEYWORDS_LABEL      386
#define IDC_PUBPROP_KEYWORDS            387
#define IDC_PUBPROP_KEYWORDS_EDIT       388
#define IDC_PUBPROP_MANAGEDBY_LABEL     389
#define IDC_PUBPROP_MANAGEDBY           390
#define IDC_PUBPROP_ERROR               391
#define IDD_MVSTRINGEDIT                394
#define IDC_MVSTRINGEDIT_TEXT           395
#define IDC_MVSTRINGEDIT_STRING         396
#define IDC_MVSTRINGEDIT_LIST           397
#define IDC_MVSTRINGEDIT_ADD            398
#define IDC_MVSTRINGEDIT_REMOVE         399
#define IDS_MVSTRINGEDIT_TITLE_FILEFILTER 400
#define IDC_MROOTS_TEXT                 400
#define IDS_MVSTRINGEDIT_TEXT_FILEFILTER 401
#define IDC_MROOTS_LIST                 401
#define IDS_MVSTRINGEDIT_TITLE_DIRFILTER 402
#define IDC_SERVER_SHARE                402
#define IDS_MVSTRINGEDIT_TEXT_DIRFILTER 403
#define IDC_SERVER_SHARE_LABEL          403
#define IDS_MVSTRINGEDIT_TITLE_KEYWORDS 404
#define IDC_ROOT_SHARE                  404
#define IDS_MVSTRINGEDIT_TEXT_KEYWORDS  405
#define IDS_MVSTRINGEDIT_STRING_INVALID 406
#define IDC_STAGING_TARGET              406
#define IDS_MENUS_STATIC_TOP_NEW_DFSROOT 407
#define IDC_STAGING_FOLDER              407
#define IDS_MENUS_STATIC_TOP_CONNECTTO  408
#define IDC_STAGING_BROWSE              408
#define IDC_NEWFRSWIZ_STAGING           409
#define IDS_MENUS_ROOT_TOP_NEW_DFS_LINK 410
#define IDS_MENUS_ROOT_TOP_NEW_ROOT_REPLICA 411
#define IDS_MENUS_ROOT_TOP_CHECK_STATUS 412
#define IDS_MENUS_ROOT_TOP_FILTER_DFS_LINKS 413
#define IDS_MENUS_ROOT_TOP_DELETE_CONNECTION_TO_DFS_ROOT 414
#define IDS_MENUS_ROOT_TOP_DELETE_DFS_ROOT 415
#define IDS_MENUS_ROOT_TOP_DELETE_DISPLAYED_DFS_LINKS 416
#define IDS_MENUS_ROOT_TOP_REPLICATION_TOPOLOGY 417
#define IDS_MENUS_ROOT_TOP_SHOW_REPLICATION 418
#define IDS_MENUS_ROOT_TOP_HIDE_REPLICATION 419
#define IDS_MENUS_ROOT_TOP_STOP_REPLICATION 420
#define IDS_MENUS_JUNCTION_TOP_NEW_DFS_REPLICA 440
#define IDS_MENUS_JUNCTION_TOP_CHECK_STATUS 441
#define IDS_MENUS_JUNCTION_TOP_REMOVE_FROM_DFS 442
#define IDS_MENUS_JUNCTION_TOP_REPLICATION_TOPOLOGY 443
#define IDS_MENUS_JUNCTION_TOP_SHOW_REPLICATION 444
#define IDS_MENUS_JUNCTION_TOP_HIDE_REPLICATION 445
#define IDS_MENUS_JUNCTION_TOP_STOP_REPLICATION 446
#define IDS_MENUS_REPLICA_TOP_OPEN      460
#define IDS_MENUS_REPLICA_TOP_CHECK_STATUS 461
#define IDS_MENUS_REPLICA_TOP_TAKE_REPLICA_OFFLINE_ONLINE 462
#define IDS_MENUS_REPLICA_TOP_REMOVE_FROM_DFS 463
#define IDS_MENUS_REPLICA_TOP_REPLICATE 464
#define IDS_MENUS_REPLICA_TOP_STOP_REPLICATION 465
#define IDS_MSG_NOT_50                  499
#define IDS_MSG_NOT_RUNNING_DFS         500
#define IDS_MSG_SERVER_FROM_ANOTHER_DOMAIN 501
#define IDS_LARGEFONTNAME               503
#define IDS_LARGEFONTSIZE               504
#define IDS_MSG_EXPLORE_FAILURE         505
#define IDS_MSG_INVALID_SERVER_NAME     506
#define IDS_MSG_INVALID_SHARE_NAME      507
#define IDS_MSG_SHARE_EXITS             508
#define IDS_MSG_EMPTY_FIELD             509
#define IDS_MSG_EMPTY_DFSROOT           510
#define IDS_MSG_EMPTY_LINKFILTMAX       511
#define IDS_MSG_TIMEOUT_INVALIDRANGE    512
#define IDS_MSG_FRS_BADSERVICE          513
#define IDS_MSG_ROOT_ALREADY_EXISTS     530
#define IDS_MSG_JUNCTION_ALREADY_EXISTS 531
#define IDS_MSG_WIZ_BAD_DFS_NAME        532
#define IDS_MSG_MID_JUNCTION            538
#define IDS_SNAPIN_DESCRIPTION          539
#define IDS_REPLICA_SET_TOPOLOGY_MINIMUM 540
#define IDS_MSG_DFS_INTRO               543
#define IDS_MMC_HELP_FILE_PATH          544
#define IDS_LINKED_HELP_FILE_PATH       545
#define IDS_MMC_HELP_FILE_TOPIC         546
#define IDS_INVALID_LINKNAME            549
#define IDS_MSG_FRS_NOTALLOWED_ON_SAME_SERVER 551
#define IDS_MSG_WIZ_DELETE_FAILURE_RETRY 552
#define IDS_NOT_UNC_PATH                553
#define IDS_NETPATH_ADD_ANYWAY          554
#define IDS_NON_DNSNAME_ADD_ANYWAY      556
#define IDS_PATH_NOT_FOLDER             557
#define IDS_INVALID_FOLDER              562
#define IDS_FAILED_TO_VALIDATE_FOLDER   563
#define IDS_CREATE_FOLDER               564
#define IDS_FAILED_TO_CREATE_FOLDER     565
#define IDS_FAILED_TO_CREATE_DFSROOT    566
#define IDS_FAILED_TO_GETINFO_FOLDER    567
#define IDS_DOMAIN_DFSROOTS_LABEL       570
#define IDS_ALL_DFSROOTS_LABEL          571
#define IDS_DFSROOT_DISPLAY_STRING      594
#define IDS_DFSROOT_NOT_EXIST           595
#define IDD_FILTERDFSLINKS              595
#define IDS_FILTERDFSLINKS_BEGINWITH    596
#define IDS_FILTERDFSLINKS_CONTAIN      597
#define IDD_FRS_PROP                    600
#define IDD_FRS_CUSTOM_TOPOLOGY         601
#define IDD_FRS_NEW_CONNECTIONS         602
#define IDS_FRSPROP_RING                610
#define IDS_FRSPROP_HUBSPOKE            611
#define IDS_FRSPROP_FULLMESH            612
#define IDS_FRSPROP_CUSTOM              613
#define IDS_FRS_CUSTOP_COL_ENABLE       620
#define IDS_FRS_CUSTOP_COL_FROMSERVER   621
#define IDS_FRS_CUSTOP_COL_TOSERVER     622
#define IDS_FRS_CUSTOP_COL_FROMSITE     623
#define IDS_FRS_CUSTOP_COL_TOSITE       624
#define IDS_FRS_CUSTOP_NOSELECTION      625
#define IDS_FRS_NEWCONN_COL_FROMSERVER  630
#define IDS_FRS_NEWCONN_COL_FROMSITE    631
#define IDS_FRS_NEWCONN_COL_TOSERVER    632
#define IDS_FRS_NEWCONN_COL_TOSITE      633
#define IDS_FRS_NEWCONN_NOSELECTION     634
#define IDS_FAILED_TO_PUBLISH_DFSROOT_BADUSER 636
#define IDS_FAILED_TO_PUBLISH_DFSROOT   637
#define IDS_FAILED_TO_PUBLISH_NOROOTOBJ 638
#define IDD_NEWFRSWIZ_PAGE0             640
#define IDD_NEWFRSWIZ_PAGE1             641
#define IDD_NEWFRSWIZ_PAGE2             642
#define IDS_NEWFRSWIZ_CUSTOM_MSG        645
#define IDS_NEWFRSWIZ_CUSTOM            646
#define IDS_NEWFRSWIZ_NOSELECTION       647
#define IDS_NEWFRSWIZ_FAILURE           648
#define IDS_MSG_CANNOT_DELETE_HUBMEMBER 650
#define IDS_MSG_ERROR_ALLOWFRSMEMBERDELETION 651
#define IDS_MSG_ADDMEMBER_TO_CUSTOM     652
#define IDS_MSG_NEWFRS_NOW              653
#define IDS_MSG_ADDFRSMEMBER_FAILED     654
#define IDS_MSG_ADDFRSMEMBER_FAILED_EX  655
#define IDS_DFSWIZ_TEXT_FTDFS           670
#define IDS_DFSWIZ_TEXT_SADFS           671
#define IDS_SCHEDULE                    672
#define IDS_MSG_TARGETS_ONSAMECOMPUTER  673
#define IDS_MSG_TARGETS_ONSAMECOMPUTER_1 674
#define IDS_REPPAGE_ERROR               675
#define IDS_PUBLISHPAGE_ERROR           676
#define IDS_MSG_ERROR_BADFRSMEMBERDELETION 677
#define IDS_PROPERTYPAGE_NOTCLOSED      678
#define IDS_STOP_MANAGING_ROOT          679
#define IDS_PUBPAGE_ERRMSG              680
#define IDS_PUBPAGE_ERRMSG_64           681
#define IDS_INVALID_ROOT                690
#define IDS_INVALID_LINK                691
#define IDS_INVALID_TARGET              692
#define IDS_SMB_PROVIDER                695
#define IDS_MROOTS_TEXT                 696
#define IDD_MROOTS                      700
#define IDD_STAGING                     701
#define IDD_FRS_ADVANCED                702
#define IDC_FRS_ADVANCED_EXPLANATION    703
#define IDC_FRS_ADVANCED_SERVER         704
#define IDC_FRS_ADVANCED_SITE           705
#define IDC_FRS_ADVANCED_INBOUND_CONNS  706
#define IDC_FRS_ADVANCED_NEW_PRIORITY   707
#define IDC_FRS_ADVANCED_CHANGE         708
#define IDC_FRS_ADVANCED_NEW_PRIORITY_DESC 709
#define IDS_MSG_ROOTSHARE_NOGOOD        710
#define IDS_MSG_ROOTSHARE_NOTNTFS5      711
#define IDS_MSG_WIZ_ALREADY_ROOTTARGET  720
#define IDS_BROWSE_FOLDER               721
#define IDS_CANNOT_BROWSE_FOLDER        722
#define IDS_STAGING_LIE_UNDER_ROOTPATH  723
#define IDS_STAGING_NOT_NTFS            724
#define IDS_STAGING_NO_VOLUME_INFO      725
#define IDS_BROWSE_STAGING_FOLDER       726
#define IDS_RESULT_COLUMN_DFSREFERRAL   727
#define IDS_RESULT_COLUMN_STATUS        728
#define IDS_BROWSE_FOLDER_INVALID       729
#define IDS_FRS_ADVANCED_PRIORITY_HIGH  740
#define IDS_FRS_ADVANCED_PRIORITY_MEDIUM 741
#define IDS_FRS_ADVANCED_PRIORITY_LOW   742
#define IDS_FRS_ADVANCED_PRIORITY_HIGH_DESC  743
#define IDS_FRS_ADVANCED_PRIORITY_MEDIUM_DESC 744
#define IDS_FRS_ADVANCED_PRIORITY_LOW_DESC   745
#define IDS_FRS_ADVANCED_COL_SYNC       746
#define IDS_FRS_ADVANCED_COL_FROMSERVER 747
#define IDS_FRS_ADVANCED_COL_SITE       748
#define IDS_FRS_ADVANCED_COL_PRIORITY   749
#define IDS_TARGET_STATUS_OK            760
#define IDS_TARGET_STATUS_UNREACHABLE   761
#define IDS_TARGET_STATUS_UNKNOWN       762
#define IDC_EDIT_SELECTED_DOMAIN        1024
#define IDC_LIST_DOMAINS                1025
#define IDC_EDIT_SELECTED_SERVER        1026
#define IDCSERVERS_BROWSE               1028
#define IDCSHARE_BROWSE                 1029
#define IDC_RADIO_FTDFSROOT             1030
#define IDC_RADIO_STANDALONE_DFSROOT    1031
#define IDC_RADIO_EXISTINGSHARE         1034
#define IDC_RADIO_NEWSHARE              1035
#define IDC_EDIT_SHARE_PATH             1036
#define IDC_COMBO_EXISTING_SHARES       1038
#define IDC_TEXT_DFSROOT_PREFIX         1039
#define IDC_EDIT_DFSROOT_NAME           1040
#define IDC_EDIT_DFSROOT_COMMENT        1042
#define IDC_COMPLETE_SMALL_TITLE        1055
#define IDC_COMPLETE_BIG_TITLE          1056

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        1000
#define _APS_NEXT_COMMAND_VALUE         32769
#define _APS_NEXT_CONTROL_VALUE         1060
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\staging.h ===
/*++
Module Name:

    Staging.cpp

Abstract:

    This module contains the declaration of the CStagingDlg.
    This class displays the Staging Folder Dialog.

*/

#ifndef __STAGING_H_
#define __STAGING_H_

#include "resource.h"       // main symbols
#include "DfsEnums.h"
//#include "netutils.h"
#include "newfrs.h"         // CAlternateReplicaInfo

/////////////////////////////////////////////////////////////////////////////
// CStagingDlg
class CStagingDlg : 
    public CDialogImpl<CStagingDlg>
{
public:
    CStagingDlg();

    enum { IDD = IDD_STAGING };

BEGIN_MSG_MAP(CStagingDlg)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER(WM_HELP, OnCtxHelp)
    MESSAGE_HANDLER(WM_CONTEXTMENU, OnCtxMenuHelp)
    COMMAND_ID_HANDLER(IDC_STAGING_BROWSE, OnBrowse)
    COMMAND_ID_HANDLER(IDOK, OnOK)
    COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
END_MSG_MAP()

//  Command Handlers
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCtxHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCtxMenuHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    BOOL OnBrowse(
        IN WORD            wNotifyCode,
        IN WORD            wID,
        IN HWND            hWndCtl,
        IN BOOL&           bHandled
    );

    //  Methods to access data in the dialog.
    HRESULT Init(CAlternateReplicaInfo* pRepInfo);

protected:
    CAlternateReplicaInfo* m_pRepInfo;
};

#endif //__STAGING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\stdafx.h ===
/*++

Module Name:

    stdafx.h

Abstract:

		Include file for standard system include files,
		Or project specific include files that are used frequently, but are 
		changed infrequently

--*/


#if !defined(AFX_STDAFX_H__D8861A25_3343_11D1_BE3D_00A024DFD45D__INCLUDED_)
#define AFX_STDAFX_H__D8861A25_3343_11D1_BE3D_00A024DFD45D__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#pragma warning (disable: 4706 4100)
#endif // _MSC_VER >= 1000

#define STRICT
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <shellapi.h>	
#include <atlcom.h>
#include <atlwin.h>
#include <commctrl.h>		// For using the TreeView(TV).
#include <shfusion.h>


#include "DfsCore_i.c"


#if     __RPCNDR_H_VERSION__ < 440
#define __RPCNDR_H_VERSION__ 440
#define MIDL_INTERFACE(x) interface
#endif

#include "dfsDebug.h"

#include <mmc.h>

#define DFS_NAME_COLUMN_WIDTH		120

typedef enum _NODETYPE
{
        UNASSIGNED = 0,
        TRUSTED_DOMAIN,
        DOMAIN_DFSROOTS,
        ALL_DFSROOTS,
        FTDFS,
        SADFS
} NODETYPE;

/////////////////////////////////////////////////////////////////////////////
// Inline methods

template<class TYPE>
inline void SAFE_RELEASE(TYPE*& pObj)
{
    if (NULL != pObj) 
    { 
		try
		{
			pObj->Release(); 
			pObj = NULL; 
		}
		catch(...)
		{
			pObj = NULL; 
		}
    } 
    else 
    { 
        ATLTRACE(_T("SAFE_RELEASE: called on NULL interface ptr\n")); 
    }
}


template<class TYPE>
inline void SAFE_DELETE(TYPE*& pObj)
{
    if (NULL != pObj) 
    { 
		try
		{
			delete pObj; 
			pObj = NULL; 
		}
		catch(...)
		{
			pObj = NULL; 
		}
    } 
    else 
    { 
        ATLTRACE(_T("SAFE_DELETE: called on NULL object\n")); 
    }
}


inline void SAFE_SYSFREESTRING(BSTR* i_pbstr)
{
    if (NULL != i_pbstr) 
    { 
		try
		{
			SysFreeString(*i_pbstr); 
			*i_pbstr = NULL; 
		}
		catch(...)
		{
			*i_pbstr = NULL; 
		}
    } 
    else 
    { 
        ATLTRACE(_T("SAFE_SYSFREESTRING: called on NULL BSTR\n")); 
    }
}


#ifndef _DEBUG
// Put unreferenced parameter warning off
#pragma warning(disable : 4100)
#endif // _DEBUG

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__D8861A25_3343_11D1_BE3D_00A024DFD45D__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsshlex\dfshelp.h ===
#ifndef __DFSHELP_H_
#define __DFSHELP_H_

#define DFS_CTX_HELP_FILE		_T("dfs.hlp")

#define IDH_SHELL_DIR_PATH          70005150
#define IDH_SHELL_ALTERNATE_LIST    70005151
#define	IDH_SHELL_FLUSH_PKT 	    70005152
#define	IDH_SHELL_CHECK_STATUS      70005153
#define	IDH_SHELL_SET_ACTIVE        70005154

const DWORD g_aHelpIDs_IDD_DFS_SHELL_PROP[]=
{
	IDC_DIR_PATH, IDH_SHELL_DIR_PATH,
	IDC_ALTERNATE_LIST, IDH_SHELL_ALTERNATE_LIST,
	IDC_FLUSH_PKT, IDH_SHELL_FLUSH_PKT,
	IDC_CHECK_STATUS, IDH_SHELL_CHECK_STATUS,
	IDC_SET_ACTIVE, IDH_SHELL_SET_ACTIVE,
	0,0
};

#endif // __DFSHELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\utils.h ===
/*++
Module Name:

    Utils.h

Abstract:

    This module contains the definition for CUtils class. 
	Contains utility method which are used throughout the project.

--*/


#if !defined(AFX_UTILS_H__B3542C03_4260_11D1_AA28_00C06C00392D__INCLUDED_)
#define AFX_UTILS_H__B3542C03_4260_11D1_AA28_00C06C00392D__INCLUDED_



#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <lmcons.h>
#include <lmerr.h>
#include <icanon.h>
#include "dfsenums.h"
#include <schedule.h>
#include "ldaputils.h"

class CThemeContextActivator
{
public:
    CThemeContextActivator() : m_ulActivationCookie(0)
        { SHActivateContext (&m_ulActivationCookie); }

    ~CThemeContextActivator()
        { SHDeactivateContext (m_ulActivationCookie); }

private:
    ULONG_PTR m_ulActivationCookie;
};

class CWaitCursor
{
public:
	CWaitCursor() { SetStandardCursor(IDC_WAIT); }
	~CWaitCursor() { SetStandardCursor(IDC_ARROW); }

    HRESULT SetStandardCursor(
        IN LPCTSTR			i_lpCursorName
    );
};

BOOL Is256ColorSupported(
  VOID
  );

VOID SetControlFont(
  IN HFONT    hFont, 
  IN HWND     hwnd, 
  IN INT      nId
  );

VOID SetupFonts(
  IN HINSTANCE    hInstance,
  IN HWND         hwnd,
  IN HFONT        *pBigBoldFont,
  IN HFONT        *pBoldFont
  );

VOID 
DestroyFonts(
  IN HFONT        hBigBoldFont,
  IN HFONT        hBoldFont
  );

HRESULT LoadStringFromResource(
	IN const UINT		i_uResourceID, 
	OUT BSTR*			o_pbstrReadValue
	);

HRESULT FormatResourceString(
	IN const UINT		i_uResourceID, 
	IN LPCTSTR			i_szFirstArg,
	OUT BSTR*			o_pbstrReadString
	);

HRESULT CreateSmallImageList(
    IN HINSTANCE            i_hInstance,
    IN int*                 i_pIconID,
    IN const int            i_nNumOfIcons,
    OUT HIMAGELIST*         o_phImageList
    );

HRESULT InsertIntoListView(
	IN HWND				i_hwndList, 
	IN LPCTSTR			i_szItemText, 
	IN int				i_iImageIndex = 0
	);

HRESULT GetListViewItemText(
	IN HWND				i_hwndListView, 
	IN int				i_iItemID, 
	OUT BSTR*			o_pbstrItemText
	);

HRESULT GetComboBoxText(
    IN  HWND            i_hwndCombo,
    OUT BSTR*           o_pbstrText
    );

HRESULT	EnableToolbarButtons(
	IN const LPTOOLBAR				i_lpToolbar,
	IN const INT					i_iFirstButtonID, 
	IN const INT					i_iLastButtonID, 
	IN const BOOL					i_bEnableState
	);

HRESULT AddBitmapToToolbar(
	IN const LPTOOLBAR				i_lpToolbar,
	IN const INT					i_iBitmapResource
	);

HRESULT
GetMessage(
    OUT BSTR*   o_pbstrMsg,
    IN  DWORD   dwErr,
    IN  UINT    iStringId,
	...);

int
DisplayMessageBox(
	IN HWND hwndParent,
	IN UINT uType,
	IN DWORD dwErr,
	IN UINT iStringId,
	...);

HRESULT DisplayMessageBoxWithOK(
	IN const int	i_iMessageResID,
	IN const BSTR	i_bstrArgument = NULL
	);

HRESULT DisplayMessageBoxForHR(
	IN HRESULT		i_hr
	);

HRESULT GetInputText(
    IN  HWND    hwnd, 
    OUT BSTR*   o_pbstrText,
    OUT DWORD*  o_pdwTextLength
);

BOOL CheckRegKey();

BOOL
ValidateNetPath(
    IN  BSTR i_bstrNetPath,
    OUT BSTR *o_pbstrServer,
    OUT BSTR *o_pbstrShare
);

HRESULT
IsComputerLocal(
    IN LPCTSTR lpszServer
);

BOOL
IsValidLocalAbsolutePath(
    IN LPCTSTR lpszPath
);

HRESULT
GetFullPath(
    IN  LPCTSTR   lpszServer,
    IN  LPCTSTR   lpszPath,
    OUT BSTR      *o_pbstrFullPath
);

HRESULT
VerifyDriveLetter(
    IN LPCTSTR lpszServer,
    IN LPCTSTR lpszPath
);

HRESULT
IsAdminShare(
    IN LPCTSTR lpszServer,
    IN LPCTSTR lpszPath
);

HRESULT
IsAnExistingFolder(
    IN HWND     hwnd,
    IN LPCTSTR  pszPath
);

HRESULT
CreateLayeredDirectory(
    IN LPCTSTR lpszServer,
    IN LPCTSTR lpszPath
);

HRESULT
BrowseNetworkPath(
    IN  HWND    hwndParent,
    OUT BSTR    *o_pbstrPath
);

BOOL
ValidateTimeout(
  IN  LPCTSTR   lpszTimeOut,
  OUT ULONG     *pulTimeout
);

TCHAR
GetDiskForStagingPath(
    IN LPCTSTR    lpszServer,
    IN TCHAR      tch
);

HRESULT GetDfsRootDisplayName
(
    IN  BSTR    i_bstrScopeName,
    IN  BSTR    i_bstrDfsName,
    OUT BSTR*   o_pbstrDisplayName
);

HRESULT GetDfsReplicaDisplayName
(
    IN  BSTR    i_bstrServerName,
    IN  BSTR    i_bstrShareName,
    OUT BSTR*   o_pbstrDisplayName
);

HRESULT
AddLVColumns(
  IN const HWND     hwndListBox,
  IN const INT      iStartingResourceID,
  IN const UINT     uiColumns
  );

LPARAM GetListViewItemData(
    IN HWND hwndList,
    IN int  index
);

HRESULT CreateAndHideStagingPath(
    IN BSTR i_bstrServer,
    IN BSTR i_bstrStagingPath
    );

HRESULT ConfigAndStartNtfrs
(
  BSTR  i_bstrServer
);

HRESULT CheckResourceProvider(LPCTSTR pszResource);

HRESULT FRSShareCheck
(
  BSTR  i_bstrServer,
  BSTR  i_bstrFolder,
  OUT FRSSHARE_TYPE *pFRSShareType
);

HRESULT FRSIsNTFRSInstalled
(
  BSTR  i_bstrServer
);

HRESULT InvokeScheduleDlg(
    IN     HWND      i_hwndParent,
    IN OUT SCHEDULE* io_pSchedule
    );

HRESULT ReadSharePublishInfoOnFTRoot(
    LPCTSTR i_pszDomainName,
    LPCTSTR i_pszRootName,
    OUT BOOL* o_pbPublish,
    OUT BSTR* o_pbstrUNCPath,
    OUT BSTR* o_pbstrDescription,
    OUT BSTR* o_pbstrKeywords,
    OUT BSTR* o_pbstrManagedBy);

HRESULT ReadSharePublishInfoOnSARoot(
    LPCTSTR i_pszServerName,
    LPCTSTR i_pszShareName,
    OUT BOOL* o_pbPublish,
    OUT BSTR* o_pbstrUNCPath,
    OUT BSTR* o_pbstrDescription,
    OUT BSTR* o_pbstrKeywords,
    OUT BSTR* o_pbstrManagedBy);

HRESULT ModifySharePublishInfoOnFTRoot(
    IN PCTSTR i_pszDomainName,
    IN PCTSTR i_pszRootName,
    IN BOOL   i_bPublish,
    IN PCTSTR i_pszUNCPath,
    IN PCTSTR i_pszDescription,
    IN PCTSTR i_pszKeywords,
    IN PCTSTR i_pszManagedBy
    );

HRESULT ModifySharePublishInfoOnSARoot(
    IN PCTSTR i_pszServerName,
    IN PCTSTR i_pszShareName,
    IN BOOL   i_bPublish,
    IN PCTSTR i_pszUNCPath,
    IN PCTSTR i_pszDescription,
    IN PCTSTR i_pszKeywords,
    IN PCTSTR i_pszManagedBy
    );

HRESULT PutMultiValuesIntoAttrValList(
    IN PCTSTR   i_pszValues,
    OUT LDAP_ATTR_VALUE** o_pVal
    );

HRESULT PutMultiValuesIntoStringArray(
    IN PCTSTR   i_pszValues,
    OUT PTSTR** o_pVal
    );

void FreeStringArray(PTSTR* i_ppszStrings);

HRESULT mystrtok(
    IN PCTSTR   i_pszString,
    IN OUT int* io_pnIndex,  // start from 0
    IN PCTSTR   i_pszCharSet,
    OUT BSTR*   o_pbstrToken
    );

void TrimBSTR(BSTR bstr);

BOOL CheckPolicyOnSharePublish();

BOOL CheckPolicyOnDisplayingInitialMaster();

HRESULT GetMenuResourceStrings(
    IN  int     i_iStringID,
    OUT BSTR*   o_pbstrMenuText,
    OUT BSTR*   o_pbstrToolTipText,
    OUT BSTR*   o_pbstrStatusBarText
    );

LRESULT CALLBACK 
NoPasteEditCtrlProc(
    HWND    hwnd,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
);

void SetActivePropertyPage(IN HWND i_hwndParent, IN HWND i_hwndPage);

void MyShowWindow(HWND hwnd, BOOL bShow);

void OpenBrowseDialog(
    IN HWND hwndParent,
    IN int  idLabel,
    IN BOOL bLocalComputer,
    IN LPCTSTR lpszComputer,
    OUT LPTSTR lpszDir
);

#endif // !defined(AFX_UTILS_H__B3542C03_4260_11D1_AA28_00C06C00392D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\utils.cpp ===
/*++
Module Name:

    Utils.cpp

Abstract:

    This module contains the declaration for CWaitCursor class. 
  Contains utility methods which are used throughout the project.

--*/



#include "stdafx.h"
#include "resource.h"
#include "Utils.h"
#include "netutils.h"
#include <dns.h>

HRESULT 
CWaitCursor::SetStandardCursor(
  IN LPCTSTR    i_lpCursorName
  )
/*++

Routine Description:

This method sets the cursor to the standard cursor specified.
Usage:  SetStandardCursor(IDC_WAIT)

Arguments:

  i_lpCursorName  -  The name of a standard cursor, IDC_WAIT, IDC_ARROW.

--*/
{
    RETURN_INVALIDARG_IF_NULL(i_lpCursorName);

    HCURSOR  m_hcur = ::LoadCursor(NULL, i_lpCursorName);
    if (!m_hcur)
        return HRESULT_FROM_WIN32(GetLastError());

    ::ShowCursor(FALSE);
    SetCursor(m_hcur);
    ::ShowCursor(TRUE);

    return S_OK;
}

BOOL
Is256ColorSupported(
    VOID
    )
{
/*++

Routine Description:

  Determines whether the display supports 256 colors.

Arguments:

  None

Return value:

  TRUE if display supports 256 colors
  FALSE if not.

--*/

    BOOL bRetval = FALSE;

    HDC hdc = ::GetDC(NULL);

    if( hdc )
    {
        if( ::GetDeviceCaps( hdc, BITSPIXEL ) >= 8 )
        {
            bRetval = TRUE;
        }
        ::ReleaseDC(NULL, hdc);
    }
    return bRetval;
}

VOID
SetControlFont(
    IN HFONT    hFont, 
    IN HWND     hwnd, 
    IN INT      nId
    )
{
/*++

Routine Description:

  Sets the text font of a dialog control to the input font.

Arguments:

  hFont - The font to use.

  hwnd  - The parent dialog window.

  nId    - The control Id.  

Return value:

  None

--*/
    if( hFont )
    {
        HWND hwndControl = ::GetDlgItem(hwnd, nId);

        if( hwndControl )
            ::SendMessage(hwndControl, WM_SETFONT, (WPARAM) hFont, MAKELPARAM(TRUE, 0));
    }
}

VOID 
SetupFonts(
    IN HINSTANCE    hInstance,
    IN HWND         hwnd,
    IN HFONT        *pBigBoldFont,
    IN HFONT        *pBoldFont
    )
{
/*++

Routine Description:

  Creates fonts for Wizard Titles.

Arguments:

  hInstance  - The module instance.

  hwnd    - The dialog window.

  pBigBoldFont- The font for large title.

  pBoldFont  - The font for small title.

Return value:

  None

--*/
    
    NONCLIENTMETRICS ncm = {0};
    ncm.cbSize = sizeof(ncm);
    SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

    LOGFONT BigBoldLogFont  = ncm.lfMessageFont;
    LOGFONT BoldLogFont     = ncm.lfMessageFont;


                      // Create Big Bold Font and Bold Font

    BigBoldLogFont.lfWeight   = FW_BOLD;
    BoldLogFont.lfWeight      = FW_BOLD;

    TCHAR FontSizeString[24];
    INT FontSize;

                    // Load size and name from resources, since these may change
                    // from locale to locale based on the size of the system font, etc.

    if(!LoadString(hInstance,IDS_LARGEFONTNAME,BigBoldLogFont.lfFaceName,LF_FACESIZE)) 
    {
        lstrcpy(BigBoldLogFont.lfFaceName,TEXT("MS Shell Dlg"));
    }

    if(LoadString(hInstance,IDS_LARGEFONTSIZE,FontSizeString,sizeof(FontSizeString)/sizeof(TCHAR))) 
    {
        FontSize = _tcstoul( FontSizeString, NULL, 10 );
    } 
    else 
    {
        FontSize = 18;
    }

    HDC hdc = ::GetDC( hwnd );

    if( hdc )
    {
        BigBoldLogFont.lfHeight = 0 - (GetDeviceCaps(hdc,LOGPIXELSY) * FontSize / 72);

        if (pBigBoldFont)
            *pBigBoldFont = CreateFontIndirect(&BigBoldLogFont);

        if (pBoldFont)
            *pBoldFont    = CreateFontIndirect(&BoldLogFont);

        ::ReleaseDC(hwnd,hdc);
    }
}

VOID 
DestroyFonts(
    IN HFONT        hBigBoldFont,
    IN HFONT        hBoldFont
    )
{
/*++

Routine Description:

  Creates fonts for Wizard Titles.

Arguments:

  hBigBoldFont- The font for large title.

  hBoldFont  - The font for small title.

Return value:

  None

--*/

    if( hBigBoldFont )
    {
        DeleteObject( hBigBoldFont );
    }

    if( hBoldFont )
    {
        DeleteObject( hBoldFont );
    }
}


HRESULT 
LoadStringFromResource(
  IN const UINT    i_uResourceID, 
  OUT BSTR*      o_pbstrReadValue
  )
/*++

Routine Description:

This method returns a resource string.
The method no longer uses a fixed string to read the resource.
Inspiration from MFC's CString::LoadString.

Arguments:
  i_uResourceID    -  The resource id
  o_pbstrReadValue  -  The BSTR* into which the value is copied

--*/
{
  RETURN_INVALIDARG_IF_NULL(o_pbstrReadValue);

  TCHAR    szResString[1024];
  ULONG    uCopiedLen = 0;
  
  szResString[0] = NULL;
  
  // Read the string from the resource
  uCopiedLen = ::LoadString(_Module.GetModuleInstance(), i_uResourceID, szResString, 1024);

  // If nothing was copied it is flagged as an error
  if(uCopiedLen <= 0)
  {
    return HRESULT_FROM_WIN32(::GetLastError());
  }
  else
  {
    *o_pbstrReadValue = ::SysAllocString(szResString);
    if (!*o_pbstrReadValue)
      return E_OUTOFMEMORY;
  }

  return S_OK;
}


HRESULT 
FormatResourceString(
  IN const UINT    i_uResourceID, 
  IN LPCTSTR      i_szFirstArg,
  OUT BSTR*      o_pbstrReadString
  )
/*++

Routine Description:

  Reads a string from resource, puts the argument into this string and 
  returns it.
  The returned string should be freed using SysFreeString.

Arguments:

    i_uResourceID    -  The resource id of the string to be read. This string 
              should contain a %1 to allow us to insert the argument

  i_szFirstArg    -  The argument to be inserted

  o_pbstrReadString  -  The string that is returned by the method after processing
--*/
{
  RETURN_INVALIDARG_IF_NULL(i_szFirstArg);
  RETURN_INVALIDARG_IF_NULL(o_pbstrReadString);

  CComBSTR    bstrResString;
  LPTSTR      lpszFormatedMessage = NULL;

  HRESULT hr = LoadStringFromResource(i_uResourceID, &bstrResString);
  RETURN_IF_FAILED(hr);
                    // Create a new string using the argument and the res string
  int iBytes = ::FormatMessage(
                  FORMAT_MESSAGE_FROM_STRING | 
                  FORMAT_MESSAGE_ARGUMENT_ARRAY |
                  FORMAT_MESSAGE_ALLOCATE_BUFFER,  // Format a string with %1, %2, etc
                  bstrResString,          // Input buffer with a %1
                  0,                // Message id. None
                  0,                // Language id. Nothing particular 
                  (LPTSTR)&lpszFormatedMessage,  // Output buffer
                  0,
                  (va_list*)&i_szFirstArg      // List of arguments. Only 1 right now
                );

  if (0 == iBytes)
  {
    return HRESULT_FROM_WIN32(GetLastError());
  }
  else
  {
    CComBSTR bstrRet(lpszFormatedMessage);
    *o_pbstrReadString = bstrRet.Copy();
    LocalFree(lpszFormatedMessage);
    return S_OK;
  }
}



HRESULT
GetMessage(
  OUT BSTR* o_pbstrMsg,
  IN  DWORD dwErr,
  IN  UINT  iStringId, // OPTIONAL: String resource Id
  ...)        // Optional arguments
{
  RETURN_INVALIDARG_IF_NULL(o_pbstrMsg);

  _ASSERT(dwErr != 0 || iStringId != 0);    // One of the parameter must be non-zero

  HRESULT hr = S_OK;

  TCHAR szString[1024];
  CComBSTR bstrErrorMsg, bstrResourceString, bstrMsg;

  if (dwErr)
    hr = GetErrorMessage(dwErr, &bstrErrorMsg);

  if (SUCCEEDED(hr))
  {
    if (iStringId == 0)
    {
      bstrMsg = bstrErrorMsg;
    }
    else
    {
      ::LoadString(_Module.GetModuleInstance(), iStringId, 
                   szString, sizeof(szString)/sizeof(TCHAR));

      va_list arglist;
      va_start(arglist, iStringId);
      LPTSTR lpBuffer = NULL;
      DWORD dwRet = ::FormatMessage(
                        FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                        szString,
                        0,                // dwMessageId
                        0,                // dwLanguageId, ignored
                        (LPTSTR)&lpBuffer,
                        0,            // nSize
                        &arglist);
      va_end(arglist);

      if (dwRet == 0)
      {
        hr = HRESULT_FROM_WIN32(GetLastError());
      }
      else
      {
        bstrMsg = lpBuffer;
        if (dwErr)
          bstrMsg += bstrErrorMsg;
  
        LocalFree(lpBuffer);
      }
    }
  }

  if (FAILED(hr))
  {
   // Failed to retrieve the proper message, report the failure directly to user
    _stprintf(szString, _T("0x%x"), hr); 
    bstrMsg = szString;
  }

  *o_pbstrMsg = bstrMsg.Copy();
  if (!*o_pbstrMsg)
      return E_OUTOFMEMORY;

  return S_OK;
}

int
DisplayMessageBox(
  IN HWND hwndParent,
  IN UINT uType,    // style of message box
  IN DWORD dwErr,
  IN UINT iStringId, // OPTIONAL: String resource Id
  ...)        // Optional arguments
{
  _ASSERT(dwErr != 0 || iStringId != 0);    // One of the parameter must be non-zero

  HRESULT hr = S_OK;

  TCHAR szCaption[1024], szString[1024];
  CComBSTR bstrErrorMsg, bstrResourceString, bstrMsg;

  ::LoadString(_Module.GetModuleInstance(), IDS_APPLICATION_NAME, 
               szCaption, sizeof(szCaption)/sizeof(TCHAR));

  if (dwErr)
    hr = GetErrorMessage(dwErr, &bstrErrorMsg);

  if (SUCCEEDED(hr))
  {
    if (iStringId == 0)
    {
      bstrMsg = bstrErrorMsg;
    }
    else
    {
      ::LoadString(_Module.GetModuleInstance(), iStringId, 
                   szString, sizeof(szString)/sizeof(TCHAR));

      va_list arglist;
      va_start(arglist, iStringId);
      LPTSTR lpBuffer = NULL;
      DWORD dwRet = ::FormatMessage(
                        FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                        szString,
                        0,                // dwMessageId
                        0,                // dwLanguageId, ignored
                        (LPTSTR)&lpBuffer,
                        0,            // nSize
                        &arglist);
      va_end(arglist);

      if (dwRet == 0)
      {
        hr = HRESULT_FROM_WIN32(GetLastError());
      }
      else
      {
        bstrMsg = lpBuffer;
        if (dwErr)
          bstrMsg += bstrErrorMsg;
  
        LocalFree(lpBuffer);
      }
    }
  }

  if (FAILED(hr))
  {
   // Failed to retrieve the proper message, report the failure directly to user
    _stprintf(szString, _T("0x%x"), hr); 
    bstrMsg = szString;
  }

  CThemeContextActivator activator;
  return ::MessageBox(hwndParent, bstrMsg, szCaption, uType);
}

HRESULT 
DisplayMessageBoxWithOK(
  IN const int  i_iMessageResID,
  IN const BSTR  i_bstrArgument/* = NULL*/
  )
{
  if (i_bstrArgument)
    DisplayMessageBox(::GetActiveWindow(), MB_OK, 0, i_iMessageResID, i_bstrArgument);
  else
    DisplayMessageBox(::GetActiveWindow(), MB_OK, 0, i_iMessageResID);

  return S_OK;
}

HRESULT 
DisplayMessageBoxForHR(
  IN HRESULT    i_hr
  )
{
    DisplayMessageBox(::GetActiveWindow(), MB_OK, i_hr, 0);

    return S_OK;
}

HRESULT CreateSmallImageList(
    IN HINSTANCE            i_hInstance,
    IN int*                 i_pIconID,
    IN const int            i_nNumOfIcons,
    OUT HIMAGELIST*         o_phImageList
    )
{
    RETURN_INVALIDARG_IF_NULL(i_hInstance);

    HRESULT     hr = S_OK;
    HIMAGELIST  hImageList = ImageList_Create(
                                    GetSystemMetrics(SM_CXSMICON), 
                                    GetSystemMetrics(SM_CYSMICON), 
                                    ILC_COLORDDB | ILC_MASK,
                                    i_nNumOfIcons,
                                    0);
    if (!hImageList)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        return hr;
    }

    int i = 0;
    for (i = 0; i < i_nNumOfIcons; i++)
    {
        HICON hIcon = LoadIcon(i_hInstance, MAKEINTRESOURCE(i_pIconID[i])); 
        if (!hIcon)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        if (-1 == ImageList_AddIcon(hImageList, hIcon))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }
    }

    if (FAILED(hr))
    {
        if (hImageList)
            ImageList_Destroy(hImageList);
    } else
    {
        if (o_phImageList)
            *o_phImageList = hImageList;
    }

    return hr;
}

HRESULT 
InsertIntoListView(
  IN HWND       i_hwndList, 
  IN LPCTSTR    i_szItemText, 
  IN int        i_iImageIndex /*= 0*/
  )
/*++

Routine Description:

  Insert and item into the listview. The image index for the item is optional
  while the item text is necessary

Arguments:

  i_hwndList    -  HWND of the list view
  i_szItemText  -  The text for the item
  i_iImageIndex  -  The image index for the item. Default is 0.

--*/
{
    RETURN_INVALIDARG_IF_NULL(i_hwndList);
    RETURN_INVALIDARG_IF_NULL(i_szItemText);

    LVITEM    lvi; 
    ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask = LVIF_TEXT | LVIF_IMAGE; 
    lvi.pszText = (LPTSTR)i_szItemText;
    lvi.iImage = i_iImageIndex;

    int  iItemIndex = ListView_InsertItem(i_hwndList, &lvi);  // Insert the item into the list view
    if ( -1 == iItemIndex)  
        return E_FAIL;

    return S_OK;
}



HRESULT 
GetListViewItemText(
  IN HWND       i_hwndListView, 
  IN int        i_iItemID, 
  OUT BSTR*     o_pbstrItemText
  )
/*++

Routine Description:

  Needed to write a method as the standard one has a slight problem.
  Here, we make sure that string allocated is of proper length.

Arguments:

  i_hwndList    -  HWND of the list view
  i_iItemID    -  The ID of the item to be read
  o_pbstrItemText  -  The item text returned by this method
--*/
{
    RETURN_INVALIDARG_IF_NULL(i_hwndListView);
    RETURN_INVALIDARG_IF_NULL(o_pbstrItemText);

    *o_pbstrItemText = NULL;
    if (-1 == i_iItemID)
        return S_FALSE; // not a valid item index

    LRESULT      iReadTextLen = 0;
    TCHAR    szText[1024];

    LVITEM    lvItem;
    ZeroMemory(&lvItem, sizeof(lvItem));
    lvItem.mask = LVIF_TEXT;        // Initialize the LV item 
    lvItem.iItem = i_iItemID;
    lvItem.pszText = szText;
    lvItem.cchTextMax = 1024;

                  // Get the LV item text
    iReadTextLen = SendMessage(i_hwndListView, LVM_GETITEMTEXT, lvItem.iItem, (LPARAM)&lvItem);

    if(iReadTextLen <= 0)
    {
        return HRESULT_FROM_WIN32(::GetLastError());
    }
    else
    {
        *o_pbstrItemText = SysAllocString(szText);
        if (!*o_pbstrItemText)
            return E_OUTOFMEMORY;
    }

    return S_OK;
}

HRESULT GetComboBoxText(
    IN  HWND            i_hwndCombo,
    OUT BSTR*           o_pbstrText
    )
{
    RETURN_INVALIDARG_IF_NULL(o_pbstrText);

    int index = ::SendMessage(i_hwndCombo, CB_GETCURSEL, 0, 0);
    int len = ::SendMessage(i_hwndCombo, CB_GETLBTEXTLEN, index, 0);
    if (!len)
        return S_FALSE; // no text

    PTSTR   pszText = (PTSTR)calloc(len + 1, sizeof(TCHAR));
    RETURN_OUTOFMEMORY_IF_NULL(pszText);

    ::SendMessage(i_hwndCombo, CB_GETLBTEXT, index, (LPARAM)pszText);

    *o_pbstrText = SysAllocString(pszText);

    free(pszText);

    RETURN_OUTOFMEMORY_IF_NULL(*o_pbstrText);

    return S_OK;
}

HRESULT
EnableToolbarButtons(
  IN const LPTOOLBAR        i_lpToolbar,
  IN const INT          i_iFirstButtonID, 
  IN const INT          i_iLastButtonID, 
  IN const BOOL          i_bEnableState
  )
/*++

Routine Description:

  Enable or disable the toolbar buttons

Arguments:

  i_lpToolbar      -  Callback used to do toolbar related operations
  i_iFirstButtonID  -  The ID of the first button to be operated on.
  i_iLastButtonID    -  The ID of the last button to be operated on.
  i_bEnableState    -  The new state for enabled. Can be TRUE or FALSE

--*/
{
    RETURN_INVALIDARG_IF_NULL(i_lpToolbar);
    RETURN_INVALIDARG_IF_TRUE((i_iLastButtonID - i_iFirstButtonID) < 0);

    for (int iCommandID = i_iFirstButtonID; iCommandID <= i_iLastButtonID; iCommandID++ )
    {
        i_lpToolbar->SetButtonState(iCommandID, ENABLED, i_bEnableState);
        i_lpToolbar->SetButtonState(iCommandID, HIDDEN, !i_bEnableState);
    }

    return S_OK;
}

HRESULT
AddBitmapToToolbar(
  IN const LPTOOLBAR    i_lpToolbar,
  IN const INT          i_iBitmapResource
  )
/*++

Routine Description:

  Creates and adds the bitmap to the toolbar. 
  This bitmap is used by the toolbar buttons. 
  
Arguments:
  
  i_lpToolbar      -  Callback used to do toolbar related operations
  i_iBitmapResource  -  The resource id of the bitmap.

--*/
{
    RETURN_INVALIDARG_IF_NULL(i_lpToolbar);

                      // Load the bitmap from resource
    HBITMAP hBitmap = (HBITMAP)LoadImage(_Module.GetModuleInstance(), MAKEINTRESOURCE(i_iBitmapResource), 
                  IMAGE_BITMAP, 0, 0, LR_DEFAULTCOLOR);
    if(!hBitmap)
        return HRESULT_FROM_WIN32(GetLastError());

    HRESULT hr = S_FALSE;
    BITMAP  bmpRec;
    if (GetObject(hBitmap, sizeof(bmpRec), &bmpRec))
    {
        if (bmpRec.bmHeight > 0)
        {
            int icyBitmap = bmpRec.bmHeight;
            int icxBitmap = icyBitmap; // Since the bitmaps are squares
            int iNoOfBitmaps = bmpRec.bmWidth / bmpRec.bmHeight;

            hr = i_lpToolbar->AddBitmap(iNoOfBitmaps, hBitmap, icxBitmap, icyBitmap, 
                      RGB(255, 0, 255)    // Pink is the mask color
                     );
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    DeleteObject(hBitmap);

    return hr;
}

HRESULT GetInputText(
    IN  HWND    hwnd, 
    OUT BSTR*   o_pbstrText,
    OUT DWORD*  o_pdwTextLength
)
{
  _ASSERT(hwnd);
  _ASSERT(o_pbstrText);
  _ASSERT(o_pdwTextLength);

  *o_pdwTextLength = 0;
  *o_pbstrText = NULL;

  HRESULT   hr = S_OK;
  int       nLength = GetWindowTextLength(hwnd);
  if (nLength == 0)
  {
    *o_pbstrText = SysAllocString(_T(""));
  } else
  {
    PTSTR ptszText = (PTSTR)calloc(nLength+1, sizeof(TCHAR));
    if (ptszText)
    {
      nLength = GetWindowText(hwnd, ptszText, nLength+1);

      // trim right
      PTSTR p = NULL;
      for (p = ptszText + nLength - 1; p >= ptszText && _istspace(*p); p--)
      {
        *p = _T('\0');
      }

      // trim left
      for (p = ptszText; *p && _istspace(*p); p++)
        ;

      *o_pdwTextLength = _tcslen(p);
      *o_pbstrText = SysAllocString(p);

      free(ptszText);
    }
  }

  if (!*o_pbstrText)
    hr = E_OUTOFMEMORY;

  return hr;
}

// return FALSE, if value is not present or 0
// return TRUE, if value is present and non-zero
BOOL CheckRegKey()
{
  BOOL bReturn = FALSE;
  LONG lErr = ERROR_SUCCESS;
  HKEY hKey = 0;

  lErr = RegOpenKeyEx(
                      HKEY_LOCAL_MACHINE,
                      _T("System\\CurrentControlSet\\Services\\Dfs"),
                      0,
                      KEY_QUERY_VALUE,
                      &hKey);
  if (ERROR_SUCCESS == lErr)
  {
    DWORD dwType; 
    DWORD dwData = 0;
    DWORD dwSize = sizeof(DWORD);
    lErr = RegQueryValueEx(hKey, _T("DfsDnsConfig"), 0, &dwType, (LPBYTE)&dwData, &dwSize);

    if (ERROR_SUCCESS == lErr && REG_DWORD == dwType && 0 != (dwData & 0x1))
      bReturn = TRUE; 

    RegCloseKey(hKey);
  }

  return bReturn;
}

// called when adding a new junction point or adding a new replica member
BOOL
ValidateNetPath(
    IN  BSTR i_bstrNetPath,
    OUT BSTR *o_pbstrServer,
    OUT BSTR *o_pbstrShare
)
{
  HRESULT   hr = S_OK;
  BOOL      bReturn = FALSE;
  CComBSTR  bstrServer;
  CComBSTR  bstrShare;
  HWND      hwnd = ::GetActiveWindow();

  do {
    // Check UNC path
    hr = CheckUNCPath(i_bstrNetPath);
    if (S_OK != hr)
    {
      DisplayMessageBox(hwnd, MB_OK, 0, IDS_NOT_UNC_PATH, i_bstrNetPath);
      break;
    }

    CComBSTR  bstrNetPath = i_bstrNetPath; // make a copy

    // remove the ending backslash if any
    TCHAR *p = bstrNetPath + lstrlen(bstrNetPath) - 1;
    if (*p == _T('\\'))
        *p = _T('\0');
/*
LinanT 6/2/2000:
a) add "check if path is contactable", warn user
*/
    DWORD dwRet = GetFileAttributes(bstrNetPath);
    if (-1 == dwRet)
    {
        if (IDYES != DisplayMessageBox(hwnd, MB_YESNO, GetLastError(), IDS_NETPATH_ADD_ANYWAY, i_bstrNetPath))
            break;
    } else if (!(dwRet & FILE_ATTRIBUTE_DIRECTORY))
    {
        DisplayMessageBox(hwnd, MB_OK, 0, IDS_PATH_NOT_FOLDER, i_bstrNetPath);
        break;
    }

    PTSTR     lpszServer = bstrNetPath + 2; // skip the first "\\"
    PTSTR     lpszShare = _tcschr(lpszServer, _T('\\'));
    if (!lpszShare)
        break;
    *lpszShare++ = _T('\0');
    bstrShare = lpszShare;

/*
LinanT 3/19/99:
a) remove "check if path is contactable", leave it to dfs API
b) remove "get dns server name":
c) add code to do simple check for dots, if non-dns-look, pop up dialog for confirmation
*/
    bstrServer = lpszServer;
    if ( CheckRegKey() &&
         NULL == _tcschr(bstrServer, _T('.')) &&
         IDYES != DisplayMessageBox(hwnd, MB_YESNO, 0,
                      IDS_NON_DNSNAME_ADD_ANYWAY, i_bstrNetPath) )
    {
      break;
    }

    bReturn = TRUE;

  } while (0);

  if (bReturn)
  {
    if ( !(*o_pbstrServer = bstrServer.Copy()) ||
         !(*o_pbstrShare = bstrShare.Copy()) )
    {
      bReturn = FALSE;
      DisplayMessageBox(hwnd, MB_OK | MB_ICONSTOP, (DWORD)E_OUTOFMEMORY, 0);
    }
  }

  return bReturn;
}

/////////////////////////////////////////////////////////////////////
//  IsLocalComputername(): cut & pasted from ..\..\framewrk\islocal.cpp
//
TCHAR g_achComputerName[ MAX_COMPUTERNAME_LENGTH+1 ] = _T("");
TCHAR g_achDnsComputerName[DNS_MAX_NAME_BUFFER_LENGTH] = _T("");

BOOL
IsLocalComputername( IN LPCTSTR pszMachineName )
{
  if ( NULL == pszMachineName || _T('\0') == pszMachineName[0] )
    return TRUE;

  if ( _T('\\') == pszMachineName[0] && _T('\\') == pszMachineName[1] )
    pszMachineName += 2;

  // compare with the local computer netbios name
  if ( _T('\0') == g_achComputerName[0] )
  {
    DWORD dwSize = sizeof(g_achComputerName)/sizeof(TCHAR);
    GetComputerName( g_achComputerName, &dwSize );
    _ASSERT(_T('\0') != g_achComputerName[0]);
  }
  if ( 0 == lstrcmpi( pszMachineName, g_achComputerName ) )
  {
    return TRUE;
  }

  // compare with the local DNS name
  // SKwan confirms that ComputerNameDnsFullyQualified is the right name to use
  // when clustering is taken into account
  if ( _T('\0') == g_achDnsComputerName[0] )
  {
    DWORD dwSize = sizeof(g_achDnsComputerName)/sizeof(TCHAR);
    GetComputerNameEx(
      ComputerNameDnsFullyQualified,
      g_achDnsComputerName,
      &dwSize );
    _ASSERT( _T('\0') != g_achDnsComputerName[0] );
  }
  if ( 0 == lstrcmpi( pszMachineName, g_achDnsComputerName ) )
  {
    return TRUE;
  }

  return FALSE;

} // IsLocalComputername()

// S_OK:    a local computer
// S_FALSE: not a local computer
HRESULT
IsComputerLocal(
    IN LPCTSTR lpszServer
)
{
  return (IsLocalComputername(lpszServer) ? S_OK : S_FALSE);
}

BOOL
IsValidLocalAbsolutePath(
    IN LPCTSTR lpszPath
)
{
  DWORD dwPathType = 0;
  DWORD dwStatus = I_NetPathType(
                  NULL,
                  const_cast<LPTSTR>(lpszPath),
                  &dwPathType,
                  0);
  if (dwStatus)
    return FALSE;

  if (dwPathType ^ ITYPE_PATH_ABSD)
    return FALSE;

  return TRUE;
}


//
// This function will return the full path with the \\?\ prefix.
// That is, \\?\X:\a\b\c if local, or \\?\UNC\server\X$\a\b\c if remote.
//
HRESULT
GetFullPath(
    IN  LPCTSTR   lpszServer,
    IN  LPCTSTR   lpszPath,
    OUT BSTR      *o_pbstrFullPath
)
{
    _ASSERT(IsValidLocalAbsolutePath(lpszPath));

    CComBSTR bstrFullPath;
    if (S_OK == IsComputerLocal(lpszServer))
    {
        bstrFullPath = _T("\\\\?\\");
        bstrFullPath += lpszPath;
    } else
    {
        bstrFullPath = _T("\\\\?\\UNC\\");
        if (mylstrncmpi(_T("\\\\"), lpszServer, 2))
        {
            bstrFullPath += lpszServer;
        } else
        {
            bstrFullPath += lpszServer + 2;
        }
        bstrFullPath += _T("\\");
        bstrFullPath += lpszPath;

        TCHAR *p = _tcschr(bstrFullPath, _T(':'));
        if (p)
        {
            *p = _T('$');
        }
    }

    *o_pbstrFullPath = bstrFullPath.Detach();

    return S_OK;
}

// Purpose: verify if the specified drive belongs to a list of disk drives on the server
// Return:
//    S_OK: yes
//    S_FALSE: no
//    hr: some error happened
HRESULT
VerifyDriveLetter(
    IN LPCTSTR lpszServer,
    IN LPCTSTR lpszPath
)
{
  _ASSERT(IsValidLocalAbsolutePath(lpszPath));
  HRESULT hr = S_FALSE;
  LPBYTE  pBuffer = NULL;
  DWORD   dwEntriesRead = 0;
  DWORD   dwTotalEntries = 0;
  DWORD   dwRet = NetServerDiskEnum(
                                const_cast<LPTSTR>(lpszServer),
                                0,
                                &pBuffer,        
                                (DWORD)-1,
                                &dwEntriesRead,
                                &dwTotalEntries,
                                NULL);

  if (NERR_Success == dwRet)
  {
    LPTSTR pDrive = (LPTSTR)pBuffer;
    for (UINT i=0; i<dwEntriesRead; i++)
    {
      if (!mylstrncmpi(pDrive, lpszPath, 1))
      {
        hr = S_OK;
        break;
      }
      pDrive += 3;
    }

    NetApiBufferFree(pBuffer);
  } else
  {
    hr = HRESULT_FROM_WIN32(dwRet);
  }

  return hr;
}

// Purpose: is there a related admin $ share
// Return:
//    S_OK: yes
//    S_FALSE: no
//    hr: some error happened
HRESULT
IsAdminShare(
    IN LPCTSTR lpszServer,
    IN LPCTSTR lpszPath
)
{
  _ASSERT(S_OK != IsComputerLocal(lpszServer));
  _ASSERT(IsValidLocalAbsolutePath(lpszPath));

  HRESULT hr = S_FALSE;
  LPBYTE  pBuffer = NULL;
  DWORD   dwEntriesRead = 0;
  DWORD   dwTotalEntries = 0;
  DWORD   dwRet = NetShareEnum( 
                                const_cast<LPTSTR>(lpszServer),
                                1,
                                &pBuffer,        
                                (DWORD)-1,
                                &dwEntriesRead,
                                &dwTotalEntries,
                                NULL);

  if (NERR_Success == dwRet)
  {
    PSHARE_INFO_1 pShareInfo = (PSHARE_INFO_1)pBuffer;
    for (UINT i=0; i<dwEntriesRead; i++)
    {
      if ( (pShareInfo->shi1_type & STYPE_SPECIAL) &&
           _tcslen(pShareInfo->shi1_netname) == 2 &&
           *(pShareInfo->shi1_netname + 1) == _T('$') &&
           !mylstrncmpi(pShareInfo->shi1_netname, lpszPath, 1) )
      {
        hr = S_OK;
        break;
      }
      pShareInfo++;
    }

    NetApiBufferFree(pBuffer);
  } else
  {
    hr = HRESULT_FROM_WIN32(dwRet);
  }

  return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsAnExistingFolder
//
//  Synopsis:   Check if pszPath is pointing at an existing folder.
//
//    S_OK:     The specified path points to an existing folder.
//    S_FALSE:  The specified path doesn't point to an existing folder.
//    hr:       Failed to get info on the specified path, or
//              the path exists but doesn't point to a folder.
//              The function reports error msg for both failures if desired.
//----------------------------------------------------------------------------
HRESULT
IsAnExistingFolder(
    IN HWND     hwnd,
    IN LPCTSTR  pszPath    // points to path with "\\?\" prefix
)
{
    if (!hwnd)
    hwnd = GetActiveWindow();

    HRESULT   hr = S_OK;

    WIN32_FILE_ATTRIBUTE_DATA fad = {0};
    if (!GetFileAttributesEx(pszPath, GetFileExInfoStandard, &fad))
    {
        DWORD dwErr = GetLastError();
        if (ERROR_PATH_NOT_FOUND == dwErr || ERROR_FILE_NOT_FOUND == dwErr)
        {
            // the specified path doesn't exist
            hr = S_FALSE;
        }
        else
        {
            DisplayMessageBox(hwnd, MB_OK, dwErr, IDS_FAILED_TO_GETINFO_FOLDER, pszPath);
            hr = HRESULT_FROM_WIN32(dwErr);
        }
    } else if ( 0 == (fad.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) )
    {
        // the specified path is not pointing to a folder
        DisplayMessageBox(hwnd, MB_OK, 0, IDS_PATH_NOT_FOLDER, pszPath);
        hr = E_FAIL;
    }

    return hr;
}

// create the directories layer by layer
HRESULT
CreateLayeredDirectory(
    IN LPCTSTR lpszServer,
    IN LPCTSTR lpszPath
)
{
    _ASSERT(IsValidLocalAbsolutePath(lpszPath));

    //
    // get the full path with \\?\ prefix, such that CreateDirectory
    // will turn off path parsing in case our path is longer than MAX_PATH
    //
    CComBSTR bstrFullPath;
    GetFullPath(lpszServer, lpszPath, &bstrFullPath);

    LPTSTR   p = _tcschr(bstrFullPath, 
                       (S_OK == IsComputerLocal(lpszServer)) ? _T(':') : _T('$'));

    //
    // bstrFullPath is either "\\?\C:\a\b\c\d" or "\\?\UNC\server\C$\a\b\c\d"
    // move p to point at "a\b\c\d"
    //
    p += 2;

    BOOL bRet = TRUE;
    while (p && *p)
    {
        p = _tcschr(p, _T('\\'));

        if (p)
            *p = _T('\0');

        bRet = CreateDirectory(bstrFullPath, NULL);
        if (!bRet)
        {
            DWORD dwErr = GetLastError();
            if (dwErr != ERROR_ALREADY_EXISTS)
                return HRESULT_FROM_WIN32(dwErr);
        }

        if (p)
            *p++ = _T('\\'); // restore the backslash, move p to point at the char after the backslash
    }

    return S_OK;
}

HRESULT
BrowseNetworkPath(
    IN  HWND    hwndParent,
    OUT BSTR    *o_pbstrPath
)
{
  _ASSERT(o_pbstrPath);

  HRESULT hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
  if (SUCCEEDED(hr))
  {
    do
    {
      CComPtr<IMalloc>   pMalloc;
      hr = SHGetMalloc(&pMalloc);
      if (FAILED(hr))
        break;

      CComBSTR bstrDlgLabel;
      hr = LoadStringFromResource(IDS_BROWSE_NET_DLG, &bstrDlgLabel);
      if (FAILED(hr))
        break;

      LPITEMIDLIST pItemIdList = NULL;
      hr = SHGetSpecialFolderLocation(NULL, CSIDL_NETWORK, &pItemIdList);
      if (FAILED(hr))
        break;

      BROWSEINFO    bi = {hwndParent,
                          pItemIdList,
                          0,
                          bstrDlgLabel,
                          BIF_RETURNONLYFSDIRS,
                          NULL,
                          NULL,
                          0};

      LPITEMIDLIST  pItemIdListBr = SHBrowseForFolder(&bi);
      if (!pItemIdListBr)
      {
          hr = S_FALSE;  // user clicked Cancel
      } else
      {
        CComBSTR  bstrPath;
        TCHAR     szPath[MAX_PATH] = _T("\0");
        SHGetPathFromIDList(pItemIdListBr, szPath);
        
        //
        // try to use Dns server name
        //
        if (CheckRegKey() && 
            S_OK == CheckUNCPath(szPath))
        {
          PTSTR     lpszServer = szPath + 2; // skip the first "\\"
          PTSTR     lpszShare = _tcschr(lpszServer, _T('\\'));
          CComBSTR  bstrServer = CComBSTR(lpszShare - lpszServer, lpszServer);
          CComBSTR  bstrDnsServer;
          hr = GetServerInfo(bstrServer,
                              NULL, // Domain
                              NULL, // NetbiosName
                              NULL, // bValidDSObject
                              &bstrDnsServer);
          if (S_OK == hr)
          {
            bstrPath = _T("\\\\");
            bstrPath += bstrDnsServer;
            bstrPath += lpszShare;
          } else
          {
            hr = S_OK;  // reset hr
            bstrPath = szPath;
          }
        } else
        {
            bstrPath = szPath;
        }

        *o_pbstrPath = bstrPath.Detach();

        pMalloc->Free(pItemIdListBr);
      }

      pMalloc->Free(pItemIdList);

    } while (0);

    CoUninitialize();
  }

  if (FAILED(hr))
    DisplayMessageBox(hwndParent, MB_OK, hr, IDS_FAILED_TO_BROWSE_NETWORKPATH);

  return hr;
}
#define MAX_DFS_REFERRAL_TIME   0xFFFFFFFF

BOOL
ValidateTimeout(
  IN  LPCTSTR   lpszTimeout,
  OUT ULONG     *pulTimeout
)
{
    BOOL bReturn = FALSE;

    if (pulTimeout)
    {
        *pulTimeout = 0;

        __int64 i64Timeout = _wtoi64(lpszTimeout);

        if (i64Timeout <= MAX_DFS_REFERRAL_TIME)
        {
            bReturn = TRUE;
            *pulTimeout = (ULONG)i64Timeout;
        }
    }

    return bReturn;
}

#include "winnetp.h"

// retrieve system drive letter on the specified machine
HRESULT GetSystemDrive(IN LPCTSTR lpszComputer, OUT TCHAR *ptch)
{
  _ASSERT(ptch);

  HRESULT         hr = S_OK;
  SHARE_INFO_2*   pShareInfo = NULL;
  NET_API_STATUS  nstatRetVal = NetShareGetInfo(
                                  const_cast<LPTSTR>(lpszComputer),
                                  _T("Admin$"),
                                  2,
                                  (LPBYTE *)&pShareInfo);

  if (nstatRetVal == NERR_Success)
  {
    _ASSERT(_T(':') == *(pShareInfo->shi2_path + 1));
    *ptch = *(pShareInfo->shi2_path);
  } else
  {
    hr = HRESULT_FROM_WIN32(nstatRetVal);
  }

  return hr;
}

//
// return a drive letter X, the staging path will be created at <X>:\FRS-Staging
// Try to exclude the following drives for performance consideration:
// 1. system drive: because the jet database ntfrs uses resides on system drive
// 2. the drive the replica folder sits on
// Will try to return a drive with the most free space
//
TCHAR
GetDiskForStagingPath(
    IN LPCTSTR    i_lpszServer,
    IN TCHAR      i_tch
)
{
  _ASSERT(i_lpszServer && *i_lpszServer);
  _ASSERT(_istalpha(i_tch));

  TCHAR     tchDrive = i_tch;

  //
  // retrieve the system drive letter on the specified machine
  //
  TCHAR     tchSystemDrive;
  if (S_OK != GetSystemDrive(i_lpszServer, &tchSystemDrive))
    return tchDrive;

  //
  // enumerate all shareable disks, e.g., \\server\C$, \\server\D$, etc.
  //
  CComBSTR  bstrServer;
  if (mylstrncmpi(i_lpszServer, _T("\\\\"), 2))
  {
    bstrServer = _T("\\\\");
    bstrServer += i_lpszServer;
  } else
    bstrServer = i_lpszServer;

  NETRESOURCE nr;
  nr.dwScope = RESOURCE_SHAREABLE;
  nr.dwType = RESOURCETYPE_ANY;
  nr.dwDisplayType = RESOURCEDISPLAYTYPE_GENERIC;  
  nr.dwUsage = RESOURCEUSAGE_CONTAINER;
  nr.lpLocalName = _T("");
  nr.lpRemoteName = bstrServer;
  nr.lpComment = _T("");
  nr.lpProvider = _T("");

  HANDLE    hEnum = NULL;
  DWORD     dwResult = WNetOpenEnum (
                          RESOURCE_SHAREABLE,
                          RESOURCETYPE_ANY,
                          RESOURCEUSAGE_CONNECTABLE | RESOURCEUSAGE_CONTAINER,
                          &nr,
                          &hEnum);
  if (dwResult == NO_ERROR) 
  {
    NETRESOURCE nrBuffer[26];
    DWORD       dwBufferSize = 26 * sizeof(NETRESOURCE);
    DWORD       dwNumEntries = 0xFFFFFFFF;  // Enumerate all possible entries.
    dwResult = WNetEnumResource (
                    hEnum,
                    &dwNumEntries,
                    nrBuffer,
                    &dwBufferSize);

    if (dwResult == NO_ERROR) 
    {
      ULONGLONG   ullFreeSpace = 0;
      for (DWORD dwIndex = 0; dwIndex < dwNumEntries; dwIndex++)
      {
        //
        // lpRemoteName contains string in the form of \\server\C$
        //
        TCHAR *p = nrBuffer[dwIndex].lpRemoteName;
        TCHAR tchCurrent = *(p + _tcslen(p) - 2);

        //
        // exclude the current drive specified in i_tch
        //
        if ( _totupper(i_tch) == _totupper(tchCurrent) )
          continue;

        //
        // skip if it's not a NTFS file system that supports object identifiers
        //
        TCHAR  szFileSystemName[MAX_PATH + 1];
        DWORD  dwMaxCompLength = 0, dwFileSystemFlags = 0;
        CComBSTR bstrRootPath = p;
        if (_T('\\') != *(p + _tcslen(p) - 1))
          bstrRootPath += _T("\\");
        if (FALSE == GetVolumeInformation(bstrRootPath, NULL, 0, NULL, &dwMaxCompLength,
                                        &dwFileSystemFlags, szFileSystemName, MAX_PATH))
          continue;

        if (CSTR_EQUAL != CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, _T("NTFS"), -1, szFileSystemName, -1) ||
            !(FILE_SUPPORTS_OBJECT_IDS & dwFileSystemFlags))
          continue;

        //
        // 1. when i_tch is on a non-system drive and system drive is NTFS, 
        //    change default to system drive
        // 2. when other NTFS drives present, exclude system drive
        //
        if ( _totupper(tchSystemDrive) == _totupper(tchCurrent) )
        {
          if ( 0 == ullFreeSpace )
            tchDrive = tchSystemDrive;

          continue;
        }

        //
        // find out the drive that has the most free space
        //
        ULARGE_INTEGER ulgiFreeBytesAvailableToCaller;
        ULARGE_INTEGER ulgiTotalNumberOfBytes;

        if (GetDiskFreeSpaceEx(p,
                          &ulgiFreeBytesAvailableToCaller,
                          &ulgiTotalNumberOfBytes,
                          NULL))
        {
          if (ulgiFreeBytesAvailableToCaller.QuadPart > ullFreeSpace)
          {
            tchDrive = tchCurrent;
            ullFreeSpace = ulgiFreeBytesAvailableToCaller.QuadPart;
          }
        }
      }
    }

    WNetCloseEnum (hEnum);
  }

  return tchDrive;
}

HRESULT GetUNCPath
(
    IN  BSTR    i_bstrServerName,
    IN  BSTR    i_bstrShareName,
    OUT BSTR*   o_pbstrUNCPath
)
{
    RETURN_INVALIDARG_IF_NULL(i_bstrServerName);
    RETURN_INVALIDARG_IF_NULL(i_bstrShareName);
    RETURN_INVALIDARG_IF_NULL(o_pbstrUNCPath);

    CComBSTR bstrUNCPath;

    bstrUNCPath = _T("\\\\");
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrUNCPath);
    bstrUNCPath += i_bstrServerName;
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrUNCPath);
    bstrUNCPath += _T("\\");
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrUNCPath);
    bstrUNCPath += i_bstrShareName;
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrUNCPath);

    *o_pbstrUNCPath = bstrUNCPath.Detach();

    return S_OK;
}

HRESULT GetDfsRootDisplayName
(
    IN  BSTR    i_bstrScopeName,
    IN  BSTR    i_bstrDfsName,
    OUT BSTR*   o_pbstrDisplayName
)
{
    return GetUNCPath(i_bstrScopeName, i_bstrDfsName, o_pbstrDisplayName);
}

HRESULT GetDfsReplicaDisplayName
(
    IN  BSTR    i_bstrServerName,
    IN  BSTR    i_bstrShareName,
    OUT BSTR*   o_pbstrDisplayName
)
{
    return GetUNCPath(i_bstrServerName, i_bstrShareName, o_pbstrDisplayName);
}

HRESULT
AddLVColumns(
  IN const HWND     hwndListBox,
  IN const INT      iStartingResourceID,
  IN const UINT     uiColumns
  )
{
  //
  // calculate the listview column width
  //
  RECT      rect;
  ZeroMemory(&rect, sizeof(rect));
  ::GetWindowRect(hwndListBox, &rect);
  int nControlWidth = rect.right - rect.left;
  int nVScrollbarWidth = GetSystemMetrics(SM_CXVSCROLL);
  int nBorderWidth = GetSystemMetrics(SM_CXBORDER);
  int nControlNetWidth = nControlWidth - 4 * nBorderWidth;
  int nWidth = nControlNetWidth / uiColumns;

  LVCOLUMN  lvColumn;
  ZeroMemory(&lvColumn, sizeof(lvColumn));
  lvColumn.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;

  lvColumn.fmt = LVCFMT_LEFT;
  lvColumn.cx = nWidth;

  for (UINT i = 0; i < uiColumns; i++)
  {
    CComBSTR  bstrColumnText;

    LoadStringFromResource(iStartingResourceID + i, &bstrColumnText);

    lvColumn.pszText = bstrColumnText;
    lvColumn.iSubItem = i;

    ListView_InsertColumn(hwndListBox, i, &lvColumn);
  }

  return S_OK;
}

LPARAM GetListViewItemData(
    IN HWND hwndList,
    IN int  index
)
{
    if (-1 == index)
        return NULL;

    LVITEM lvItem;
    ZeroMemory(&lvItem, sizeof(lvItem));

    lvItem.mask = LVIF_PARAM;
    lvItem.iItem = index;
    if (ListView_GetItem(hwndList, &lvItem))
        return lvItem.lParam;

    return NULL;
}

HRESULT CreateAndHideStagingPath(
    IN BSTR i_bstrServer,
    IN BSTR i_bstrStagingPath
    )
{
    RETURN_INVALIDARG_IF_NULL(i_bstrServer);
    RETURN_INVALIDARG_IF_NULL(i_bstrStagingPath);

    //
    // Create the directory
    //
    HRESULT hr = CreateLayeredDirectory(i_bstrServer, i_bstrStagingPath);
    if (FAILED(hr))
        return hr;

    //
    // try to hide the staging directory, ignore errors
    //
    CComBSTR bstrFullPath;
    GetFullPath(i_bstrServer, i_bstrStagingPath, &bstrFullPath);

    WIN32_FILE_ATTRIBUTE_DATA fad = {0};
    if (GetFileAttributesEx(bstrFullPath, GetFileExInfoStandard, &fad))
    {
        (void) SetFileAttributes(bstrFullPath, fad.dwFileAttributes | FILE_ATTRIBUTE_HIDDEN);
    }

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   ConfigAndStartNtfrs
//
//  Synopsis:   Config ntfrs to be AUTO_START, and start the service.
//
//--------------------------------------------------------------------------
HRESULT
ConfigAndStartNtfrs
(
  BSTR  i_bstrServer
)
{
  HRESULT         hr = S_OK;
  SC_HANDLE       hScManager = NULL;
  SC_HANDLE       hService = NULL;
  SERVICE_STATUS  svcStatus;
  DWORD dwDesiredAccess = SERVICE_CHANGE_CONFIG | SERVICE_QUERY_STATUS | SERVICE_START;

  do
  {
    if ((hScManager = ::OpenSCManager(i_bstrServer, NULL, SC_MANAGER_CONNECT )) == NULL ||
        (hService = ::OpenService(hScManager, _T("ntfrs"), dwDesiredAccess)) == NULL ||
        !ChangeServiceConfig(hService, SERVICE_NO_CHANGE, SERVICE_AUTO_START, SERVICE_NO_CHANGE,
                            NULL, NULL, NULL, NULL, NULL, NULL, NULL) ||
        !::QueryServiceStatus(hService, &svcStatus) )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        break;
    }
    
    if (SERVICE_RUNNING != svcStatus.dwCurrentState)
    {
      if (!StartService(hService, 0, NULL))
      {
        hr = HRESULT_FROM_WIN32(GetLastError());
        break;
      }
 
      // The following is a cut&paste from MSDN article
      // Check the status until the service is no longer start pending. 
      if (!QueryServiceStatus(hService,&svcStatus))
      {
        hr = HRESULT_FROM_WIN32(GetLastError());
        break;
      }
 
      // Get the tick count before entering the loop.
      DWORD dwStartTickCount = GetTickCount();
      DWORD dwOldCheckPoint = svcStatus.dwCheckPoint;
      DWORD dwWaitTime;

      while (svcStatus.dwCurrentState == SERVICE_START_PENDING) 
      { 
 
          // Do not wait longer than the wait hint. A good interval is 
          // one tenth the wait hint, but no less than 1 second and no 
          // more than 10 seconds. 
 
          dwWaitTime = svcStatus.dwWaitHint / 10;

          if ( dwWaitTime < 1000 )
              dwWaitTime = 1000;
          else if ( dwWaitTime > 10000 )
              dwWaitTime = 10000;

          Sleep( dwWaitTime );

          // Check the status again. 
          if (!QueryServiceStatus(hService, &svcStatus))
              break; 
 
          if (svcStatus.dwCheckPoint > dwOldCheckPoint)
          {
              // The service is making progress

              dwStartTickCount = GetTickCount();
              dwOldCheckPoint  = svcStatus.dwCheckPoint; 
          }
          else
          {
              if (GetTickCount() - dwStartTickCount > svcStatus.dwWaitHint)
              {
                  // No progress made within the wait hint

                  break;
              }
          }
      } 
 
      if (svcStatus.dwCurrentState == SERVICE_RUNNING) 
          hr = S_OK;
      else 
          hr = HRESULT_FROM_WIN32(GetLastError());
    }

  } while ( FALSE );

  if (hService)
    CloseServiceHandle(hService);
  if (hScManager)
    CloseServiceHandle(hScManager);

  return(hr);
}

//+-------------------------------------------------------------------------
//
//  Function:   CheckResourceProvider
//
//  Synopsis:   see if pszResource is provided by "Microsoft Windows Network".
//
//--------------------------------------------------------------------------
HRESULT
CheckResourceProvider(LPCTSTR pszResource)
{  
    DWORD          dwError = 0;
    NETRESOURCE    nr = {0};
    NETRESOURCE    nrOut = {0};
    LPTSTR         pszSystem = NULL;          // pointer to variable-length strings
    NETRESOURCE    *pBuffer  = &nrOut;        // buffer
    DWORD          cbResult  = sizeof(nrOut); // buffer size

    nr.dwScope       = RESOURCE_GLOBALNET;
    nr.dwType        = RESOURCETYPE_DISK;
    nr.lpRemoteName  = (LPTSTR)pszResource;

    //
    // Find the right provider string for "Microsoft Windows Network".
    //
    // Network provider string is localizable. In order to support localized
    // system or MUI on ENG system, we need to retrieve the name from system
    // instead of load the string from a resource file.
    //
    TCHAR szProviderName[MAX_PATH];
    DWORD dwNumOfChars = MAX_PATH;
    PTSTR pszProviderName = szProviderName;
    dwError = WNetGetProviderName(WNNC_NET_LANMAN, pszProviderName, &dwNumOfChars);
    if (dwError == ERROR_MORE_DATA)
    {
        pszProviderName = (PTSTR)LocalAlloc(LMEM_FIXED, dwNumOfChars * sizeof(TCHAR));
        if (!pszProviderName)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            dwError = WNetGetProviderName(WNNC_NET_LANMAN, pszProviderName, &dwNumOfChars);
        }
    }

    if (dwError == NO_ERROR)
    {
        nr.lpProvider  = pszProviderName;

        //
        // First call the WNetGetResourceInformation function with 
        //  memory allocated to hold only a NETRESOURCE structure. This 
        //  method can succeed if all the NETRESOURCE pointers are NULL.
        //
        dwError = WNetGetResourceInformation(&nr, (LPBYTE)pBuffer, &cbResult, &pszSystem);

        //
        // If the call fails because the buffer is too small, 
        //   call the LocalAlloc function to allocate a larger buffer.
        //
        if (dwError == ERROR_MORE_DATA)
        {
            pBuffer = (NETRESOURCE *)LocalAlloc(LMEM_FIXED, cbResult);

            if (!pBuffer)
            {
                dwError = ERROR_NOT_ENOUGH_MEMORY;
            } else
            {
                // Call WNetGetResourceInformation again with the larger buffer.
                dwError = WNetGetResourceInformation(&nr, (LPBYTE)pBuffer, &cbResult, &pszSystem);
            }
        }

        if (dwError == NO_ERROR)
        {
            // If the call succeeds, process the contents of the 
            //  returned NETRESOURCE structure and the variable-length
            //  strings in lpBuffer. Then free the memory.
            //
            if (pBuffer != &nrOut)
            {
                LocalFree(pBuffer);
            }
        }
    }

    if (pszProviderName && pszProviderName != szProviderName)
    {
        LocalFree(pszProviderName);
    }

    return (dwError == NO_ERROR ? S_OK : HRESULT_FROM_WIN32(dwError));
}

HRESULT FRSShareCheck
(
  BSTR  i_bstrServer,
  BSTR  i_bstrFolder,
  OUT FRSSHARE_TYPE *pFRSShareType
)
/*++
Routine Description:
  Performs FRS checks for the share to be able particiapte in a FRS set.
Arguments:
  i_bstrServer  - The server hosting the share
  i_bstrFolder    - The share path.
--*/
{
  _ASSERT(i_bstrServer && *i_bstrServer && i_bstrFolder && *i_bstrFolder && pFRSShareType);

          // Is the server a NT 5.0 server with FRS?
  HRESULT    hr = S_FALSE;
  hr = FRSIsNTFRSInstalled(i_bstrServer);
  if (S_FALSE == hr)
  {
    *pFRSShareType = FRSSHARE_TYPE_NONTFRS;
    return hr;
  } else if (FAILED(hr))
  {
    *pFRSShareType = FRSSHARE_TYPE_UNKNOWN;
    return hr;
  }

  // Is the path on a valid disktree share?
  hr = GetFolderInfo(i_bstrServer, i_bstrFolder);
  if (STG_E_NOTFILEBASEDSTORAGE == hr)
  {
    *pFRSShareType = FRSSHARE_TYPE_NOTDISKTREE;
    return S_FALSE;
  } else if (FAILED(hr))
  {
    *pFRSShareType = FRSSHARE_TYPE_UNKNOWN;
    return hr;
  }

          // Get root path as \\server\share
  CComBSTR  bstrRootPath = _T("\\\\");
  bstrRootPath+= i_bstrServer;
  bstrRootPath+= _T("\\");
  TCHAR *p = _tcschr(i_bstrFolder, _T('\\'));
  if (p)
  {
    bstrRootPath += CComBSTR(p - i_bstrFolder + 1, i_bstrFolder);
  } else
  {
    bstrRootPath += i_bstrFolder;
    bstrRootPath+= _T("\\");
  }

  TCHAR  szFileSystemName[MAX_PATH];
  DWORD  dwMaxCompLength = 0, dwFileSystemFlags = 0;

  _ASSERT(bstrRootPath);

  // on NTFS file system that supports object identifiers? 
  if (0 == GetVolumeInformation(
                    bstrRootPath,  // Volume path
                    NULL,      // Volume name not required
                    0,        // Size of volume name buffer
                    NULL,      // Serial number not required.
                    &dwMaxCompLength,
                    &dwFileSystemFlags,
                    szFileSystemName,
                    MAX_PATH
                  ))
  {
    *pFRSShareType = FRSSHARE_TYPE_UNKNOWN;
    return HRESULT_FROM_WIN32(GetLastError());
  }

  if (CSTR_EQUAL != CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, _T("NTFS"), -1, szFileSystemName, -1) || !(FILE_SUPPORTS_OBJECT_IDS & dwFileSystemFlags))
  {
    *pFRSShareType = FRSSHARE_TYPE_NOTNTFS;
    return S_FALSE;
  }

  *pFRSShareType = FRSSHARE_TYPE_OK;
  return S_OK;
}

HRESULT FRSIsNTFRSInstalled
(
  BSTR  i_bstrServer
)
/*++
Routine Description:
  Checks if the computer has ntfrs service.
Arguments:
  i_bstrServer  - The name of the server.
Return value:
  S_OK, if server has ntfrs service.
  S_FALSE, if server does not have ntfrs service installed.
--*/
{
  if (!i_bstrServer)
    return(E_INVALIDARG);

  SC_HANDLE        SCMHandle = NULL, NTFRSHandle = NULL;
  HRESULT          hr = S_FALSE;

  SCMHandle = OpenSCManager (i_bstrServer, NULL, SC_MANAGER_CONNECT);
  if (!SCMHandle)
    return(HRESULT_FROM_WIN32(GetLastError()));

  NTFRSHandle  = OpenService (
                SCMHandle, 
                _T("ntfrs"), 
                SERVICE_QUERY_STATUS
                 );
  if (!NTFRSHandle)
  {
    DWORD    dwError = GetLastError();
    if (ERROR_SERVICE_DOES_NOT_EXIST == dwError)
      hr = S_FALSE;
    else
      hr = HRESULT_FROM_WIN32(dwError);

    CloseServiceHandle(SCMHandle);
    return(hr);
  } else
    hr = S_OK;

  CloseServiceHandle(NTFRSHandle);
  CloseServiceHandle(SCMHandle);

  return(hr);
}

typedef HRESULT (*pfnReplicationScheduleDialogEx)
(
    HWND hwndParent,       // parent window
    BYTE ** pprgbData,     // pointer to pointer to array of 84 bytes
    LPCTSTR pszTitle,     // dialog title
    DWORD   dwFlags       // option flags
);

static HINSTANCE                        g_hDllSchedule = NULL;
static pfnReplicationScheduleDialogEx   g_hProcSchedule = NULL;

//
// S_OK: button OK is clicked and the new schedule is returned in io_pSchedule
// S_FALSE: button Cancle is clicked, io_pSchedule is not touched
//
HRESULT InvokeScheduleDlg(
    IN     HWND      i_hwndParent,
    IN OUT SCHEDULE* io_pSchedule
    )
{
    CComBSTR bstrTitle;
    HRESULT hr = LoadStringFromResource(IDS_SCHEDULE, &bstrTitle);
    RETURN_IF_FAILED(hr);

    //
    // LoadLibrary
    //
    if (!g_hDllSchedule)
    {
        if (!(g_hDllSchedule = LoadLibrary(_T("loghours.dll"))) ||
            !(g_hProcSchedule = (pfnReplicationScheduleDialogEx)GetProcAddress(g_hDllSchedule, "ReplicationScheduleDialogEx")) )
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            if (g_hDllSchedule)
            {
                FreeLibrary(g_hDllSchedule);
                g_hDllSchedule = NULL;
            }
            return hr;
        }
    }

    //
    // invoke the schedule dialog
    //
    BYTE* pbScheduleData = (BYTE *)io_pSchedule + io_pSchedule->Schedules->Offset;
    hr = (*g_hProcSchedule)(i_hwndParent, &pbScheduleData, bstrTitle, 0);

    return hr;
}

HRESULT TranslateManagedBy(
    IN  PCTSTR          i_pszDC,
    IN  PCTSTR          i_pszIn,
    OUT BSTR*           o_pbstrOut,
    IN DS_NAME_FORMAT   i_formatIn,
    IN DS_NAME_FORMAT   i_formatOut
    )
{
    RETURN_INVALIDARG_IF_NULL(o_pbstrOut);

    *o_pbstrOut = NULL;

    HRESULT hr = S_OK;
    if (!i_pszIn || !*i_pszIn)
        return hr;

    CComBSTR bstr;
    HANDLE hDS = NULL;
    DWORD dwErr = DsBind(i_pszDC, NULL, &hDS);
    if (ERROR_SUCCESS != dwErr)
    {
        hr = HRESULT_FROM_WIN32(dwErr);
    } else
    {
        hr = CrackName( hDS,
                        (PTSTR)i_pszIn,
                        i_formatIn,
                        i_formatOut,
                        &bstr
                        );
        DsUnBind(&hDS);
    }

    if (SUCCEEDED(hr))
        *o_pbstrOut = bstr.Detach();

    return hr;
}

HRESULT GetFTDfsObjectDN(
    IN PCTSTR i_pszDomainName,
    IN PCTSTR i_pszRootName,
    OUT BSTR* o_pbstrFTDfsObjectDN
    )
{
    CComBSTR bstrDomainDN;
    HRESULT hr = GetDomainInfo(
                    i_pszDomainName,
                    NULL,               // return DC's Dns name
                    NULL,               // return Domain's Dns name
                    &bstrDomainDN      // return DC=nttest,DC=micr
                    );
    RETURN_IF_FAILED(hr);

    CComBSTR bstrFTDfsObjectDN = _T("CN=");
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrFTDfsObjectDN);
    bstrFTDfsObjectDN += i_pszRootName;
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrFTDfsObjectDN);
    bstrFTDfsObjectDN += _T(",");
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrFTDfsObjectDN);
    bstrFTDfsObjectDN += _T("CN=Dfs-Configuration,CN=System,");
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrFTDfsObjectDN);
    bstrFTDfsObjectDN += bstrDomainDN;
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrFTDfsObjectDN);

    *o_pbstrFTDfsObjectDN = bstrFTDfsObjectDN.Detach();

    return hr;
}

HRESULT ReadSharePublishInfoHelper(
    PLDAP i_pldap,
    LPCTSTR i_pszDN,
    LPCTSTR i_pszSearchFilter,
    OUT BOOL* o_pbPublish,
    OUT BSTR* o_pbstrUNCPath,
    OUT BSTR* o_pbstrDescription,
    OUT BSTR* o_pbstrKeywords,
    OUT BSTR* o_pbstrManagedBy)
{
    dfsDebugOut((_T("ReadSharePublishInfoHelper %s %s\n"),
        i_pszDN, i_pszSearchFilter));

    *o_pbPublish = FALSE;

    HRESULT hr = S_OK;
    hr = IsValidObject(i_pldap, (PTSTR)i_pszDN);
    if (S_OK != hr)
        return hr;

    LListElem* pElem = NULL;

    do {
        PCTSTR ppszAttributes[] = {
                                    ATTR_SHRPUB_UNCNAME,
                                    ATTR_SHRPUB_DESCRIPTION,
                                    ATTR_SHRPUB_KEYWORDS,
                                    ATTR_SHRPUB_MANAGEDBY,
                                    0
                                    };

        hr = GetValuesEx(
                                i_pldap,
                                i_pszDN,
                                LDAP_SCOPE_BASE,
                                i_pszSearchFilter,
                                ppszAttributes,
                                &pElem);
        RETURN_IF_FAILED(hr);

        if (!pElem || !pElem->pppszAttrValues)
            return hr;

        PTSTR** pppszValues = pElem->pppszAttrValues;

        if (pppszValues[0] && *(pppszValues[0]))
        {
            *o_pbstrUNCPath = SysAllocString(*(pppszValues[0]));
            BREAK_OUTOFMEMORY_IF_NULL(*o_pbstrUNCPath, &hr);
            *o_pbPublish = TRUE;
        }

        if (pppszValues[1] && *(pppszValues[1]))
        {
            *o_pbstrDescription = SysAllocString(*(pppszValues[1]));
            BREAK_OUTOFMEMORY_IF_NULL(*o_pbstrDescription, &hr);
        }

        if (pppszValues[2] && *(pppszValues[2]))
        {
            CComBSTR bstrKeywords;
            PTSTR *ppszStrings = pppszValues[2];
            while (*ppszStrings)
            {
                if (!bstrKeywords)
                {
                    bstrKeywords = *ppszStrings;
                    BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrKeywords, &hr);
                } else
                {
                    bstrKeywords += _T(";");
                    BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrKeywords, &hr);
                    bstrKeywords += *ppszStrings;
                    BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrKeywords, &hr);
                }
                ppszStrings++;
            }
            *o_pbstrKeywords = bstrKeywords.Detach();
        }

        if (pppszValues[3] && *(pppszValues[3]))
        {
            *o_pbstrManagedBy = SysAllocString(*(pppszValues[3]));
            BREAK_OUTOFMEMORY_IF_NULL(*o_pbstrManagedBy, &hr);
        }

    } while (0);

    if (pElem)
        FreeLListElem(pElem);

    return hr;
}
HRESULT ReadSharePublishInfoOnFTRoot(
    LPCTSTR i_pszDomainName,
    LPCTSTR i_pszRootName,
    OUT BOOL* o_pbPublish,
    OUT BSTR* o_pbstrUNCPath,
    OUT BSTR* o_pbstrDescription,
    OUT BSTR* o_pbstrKeywords,
    OUT BSTR* o_pbstrManagedBy)
{
    HRESULT hr = S_OK;

    CComBSTR bstrFTDfsObjectDN;
    hr = GetFTDfsObjectDN(i_pszDomainName, i_pszRootName, &bstrFTDfsObjectDN);
    if (FAILED(hr))
        return hr;

    CComBSTR bstrDC;
    PLDAP pldap = NULL;
    hr = ConnectToDS(i_pszDomainName, &pldap, &bstrDC); // PDC is preferred
    if (SUCCEEDED(hr))
    {
        CComBSTR bstrManagedByFQDN;
        hr = ReadSharePublishInfoHelper(
                    pldap,
                    bstrFTDfsObjectDN,
                    OBJCLASS_SF_FTDFS,
                    o_pbPublish,
                    o_pbstrUNCPath,
                    o_pbstrDescription,
                    o_pbstrKeywords,
                    &bstrManagedByFQDN);

        if (SUCCEEDED(hr))
        {
            hr = TranslateManagedBy(bstrDC, 
                                    bstrManagedByFQDN, 
                                    o_pbstrManagedBy, 
                                    DS_FQDN_1779_NAME,
                                    DS_USER_PRINCIPAL_NAME);
            if (FAILED(hr))
                hr = TranslateManagedBy(bstrDC, 
                                        bstrManagedByFQDN, 
                                        o_pbstrManagedBy, 
                                        DS_FQDN_1779_NAME,
                                        DS_NT4_ACCOUNT_NAME);
        }

        CloseConnectionToDS(pldap);
    }

    return hr;
}

HRESULT ReadSharePublishInfoOnSARoot(
    LPCTSTR i_pszServerName,
    LPCTSTR i_pszShareName,
    OUT BOOL* o_pbPublish,
    OUT BSTR* o_pbstrUNCPath,
    OUT BSTR* o_pbstrDescription,
    OUT BSTR* o_pbstrKeywords,
    OUT BSTR* o_pbstrManagedBy)
{
    RETURN_INVALIDARG_IF_NULL(i_pszServerName);
    RETURN_INVALIDARG_IF_NULL(i_pszShareName);
    RETURN_INVALIDARG_IF_NULL(o_pbPublish);
    RETURN_INVALIDARG_IF_NULL(o_pbstrUNCPath);
    RETURN_INVALIDARG_IF_NULL(o_pbstrDescription);
    RETURN_INVALIDARG_IF_NULL(o_pbstrKeywords);
    RETURN_INVALIDARG_IF_NULL(o_pbstrManagedBy);

    *o_pbPublish = FALSE;
    *o_pbstrUNCPath = NULL;
    *o_pbstrDescription = NULL;
    *o_pbstrKeywords = NULL;
    *o_pbstrManagedBy = NULL;

    CComBSTR bstrDomainName, bstrFQDN;
    HRESULT hr = GetServerInfo(
                        (PTSTR)i_pszServerName, 
                        &bstrDomainName,
                        NULL, //NetbiosName
                        NULL, //ValidDSObject
                        NULL, //DnsName,
                        NULL, //Guid,
                        &bstrFQDN);
    if (S_OK != hr)
        return hr;

    CComBSTR bstrVolumeObjectDN = _T("CN=");
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrVolumeObjectDN);
    bstrVolumeObjectDN += i_pszShareName;
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrVolumeObjectDN);
    bstrVolumeObjectDN += _T(",");
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrVolumeObjectDN);
    bstrVolumeObjectDN += bstrFQDN;
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrVolumeObjectDN);
    
    CComBSTR bstrDC;
    PLDAP pldap = NULL;
    hr = ConnectToDS(bstrDomainName, &pldap, &bstrDC);
    if (SUCCEEDED(hr))
    {
        CComBSTR bstrManagedByFQDN;
        hr = ReadSharePublishInfoHelper(
                    pldap,
                    bstrVolumeObjectDN,
                    OBJCLASS_SF_VOLUME,
                    o_pbPublish,
                    o_pbstrUNCPath,
                    o_pbstrDescription,
                    o_pbstrKeywords,
                    &bstrManagedByFQDN);

        if (SUCCEEDED(hr))
        {
            hr = TranslateManagedBy(bstrDC, 
                                    bstrManagedByFQDN, 
                                    o_pbstrManagedBy, 
                                    DS_FQDN_1779_NAME,
                                    DS_USER_PRINCIPAL_NAME);
            if (FAILED(hr))
                hr = TranslateManagedBy(bstrDC, 
                                        bstrManagedByFQDN, 
                                        o_pbstrManagedBy, 
                                        DS_FQDN_1779_NAME,
                                        DS_NT4_ACCOUNT_NAME);
        }

        CloseConnectionToDS(pldap);
    }

    return hr;
}

HRESULT CreateVolumeObject(
    PLDAP  i_pldap,
    PCTSTR i_pszDN,
    PCTSTR i_pszUNCPath,
    PCTSTR i_pszDescription,
    PCTSTR i_pszKeywords,
    PCTSTR i_pszManagedBy)
{
    HRESULT hr = S_OK;

    LDAP_ATTR_VALUE  pAttrVals[5];

    int i =0;
    pAttrVals[i].bstrAttribute = OBJCLASS_ATTRIBUTENAME;
    pAttrVals[i].vpValue = (void *)OBJCLASS_VOLUME;
    pAttrVals[i].bBerValue = false;
    i++;

    pAttrVals[i].bstrAttribute = ATTR_SHRPUB_UNCNAME;
    pAttrVals[i].vpValue = (void *)i_pszUNCPath;
    pAttrVals[i].bBerValue = false;
    i++;

    if (i_pszDescription && *i_pszDescription)
    {
        pAttrVals[i].bstrAttribute = ATTR_SHRPUB_DESCRIPTION;
        pAttrVals[i].vpValue = (void *)i_pszDescription;
        pAttrVals[i].bBerValue = false;
        i++;
    }

    LDAP_ATTR_VALUE *pHead = NULL;
    if (i_pszKeywords && *i_pszKeywords)
    {
        hr = PutMultiValuesIntoAttrValList(i_pszKeywords, &pHead);
        if (S_OK == hr)
        {
            pAttrVals[i].bstrAttribute = ATTR_SHRPUB_KEYWORDS;
            pAttrVals[i].vpValue = (void *)pHead->vpValue; // multi-valued
            pAttrVals[i].bBerValue = false;
            pAttrVals[i].Next = pHead->Next;
            i++;
        }
    }

    if (i_pszManagedBy && *i_pszManagedBy)
    {
        pAttrVals[i].bstrAttribute = ATTR_SHRPUB_MANAGEDBY;
        pAttrVals[i].vpValue = (void *)i_pszManagedBy;
        pAttrVals[i].bBerValue = false;
        i++;
    }
    
    hr = AddValues(i_pldap, i_pszDN, i, pAttrVals);

    if (pHead)
        FreeAttrValList(pHead);

    return hr;
}

HRESULT ModifyShareObject(
    PLDAP  i_pldap,
    PCTSTR i_pszDN,
    PCTSTR i_pszUNCPath,
    PCTSTR i_pszDescription,
    PCTSTR i_pszKeywords,
    PCTSTR i_pszManagedBy)
{
    HRESULT hr = S_OK;

    hr = IsValidObject(i_pldap, (PTSTR)i_pszDN);
    if (S_OK != hr)
        return hr;

    LDAP_ATTR_VALUE  pAttrVals[4];
    ZeroMemory(pAttrVals, sizeof(pAttrVals));

    //
    // modify values if any
    //
    int i =0;
    if (i_pszUNCPath && *i_pszUNCPath)
    {
        pAttrVals[i].bstrAttribute = ATTR_SHRPUB_UNCNAME;
        pAttrVals[i].vpValue = (void *)i_pszUNCPath;
        pAttrVals[i].bBerValue = false;
        i++;
    }

    if (i_pszDescription && *i_pszDescription)
    {
        pAttrVals[i].bstrAttribute = ATTR_SHRPUB_DESCRIPTION;
        pAttrVals[i].vpValue = (void *)i_pszDescription;
        pAttrVals[i].bBerValue = false;
        i++;
    }

    LDAP_ATTR_VALUE *pHead = NULL;
    if (i_pszKeywords && *i_pszKeywords)
    {
        hr = PutMultiValuesIntoAttrValList(i_pszKeywords, &pHead);
        if (S_OK == hr)
        {
            pAttrVals[i].bstrAttribute = ATTR_SHRPUB_KEYWORDS;
            pAttrVals[i].vpValue = (void *)pHead->vpValue; // multi-valued
            pAttrVals[i].bBerValue = false;
            pAttrVals[i].Next = pHead->Next;
            i++;
        }
    }

    if (i_pszManagedBy && *i_pszManagedBy)
    {
        pAttrVals[i].bstrAttribute = ATTR_SHRPUB_MANAGEDBY;
        pAttrVals[i].vpValue = (void *)i_pszManagedBy;
        pAttrVals[i].bBerValue = false;
        i++;
    }
    
    if (i > 0)
    {
        hr = ModifyValues(i_pldap, i_pszDN, i, pAttrVals);
        dfsDebugOut((_T("ModifyValues i=%d, hr=%x\n"), i, hr));
    }

    if (pHead)
        FreeAttrValList(pHead);

    RETURN_IF_FAILED(hr);

    //
    // delete values if any
    //
    i =0;
    ZeroMemory(pAttrVals, sizeof(pAttrVals));
    if (!i_pszUNCPath || !*i_pszUNCPath)
    {
        pAttrVals[i].bstrAttribute = ATTR_SHRPUB_UNCNAME;
        pAttrVals[i].vpValue = NULL;
        pAttrVals[i].bBerValue = false;
        i++;
    }

    if (!i_pszDescription || !*i_pszDescription)
    {
        pAttrVals[i].bstrAttribute = ATTR_SHRPUB_DESCRIPTION;
        pAttrVals[i].vpValue = NULL;
        pAttrVals[i].bBerValue = false;
        i++;
    }

    if (!i_pszKeywords || !*i_pszKeywords)
    {
        pAttrVals[i].bstrAttribute = ATTR_SHRPUB_KEYWORDS;
        pAttrVals[i].vpValue = NULL;
        pAttrVals[i].bBerValue = false;
        i++;
    }

    if (!i_pszManagedBy || !*i_pszManagedBy)
    {
        pAttrVals[i].bstrAttribute = ATTR_SHRPUB_MANAGEDBY;
        pAttrVals[i].vpValue = NULL;
        pAttrVals[i].bBerValue = false;
        i++;
    }

    if (i > 0)
    {
        hr = DeleteValues(i_pldap, i_pszDN, i, pAttrVals);
        dfsDebugOut((_T("DeleteValues i=%d, hr=%x\n"), i, hr));
    }

    return hr;
}

HRESULT ModifySharePublishInfoOnFTRoot(
    IN PCTSTR i_pszDomainName,
    IN PCTSTR i_pszRootName,
    IN BOOL   i_bPublish,
    IN PCTSTR i_pszUNCPath,
    IN PCTSTR i_pszDescription,
    IN PCTSTR i_pszKeywords,
    IN PCTSTR i_pszManagedBy
    )
{
    dfsDebugOut((_T("ModifySharePublishInfoOnFTRoot %s, %s, %d, %s, %s, %s, %s\n"),
            i_pszDomainName,
            i_pszRootName,
            i_bPublish,
            i_pszUNCPath,
            i_pszDescription,
            i_pszKeywords,
            i_pszManagedBy
                ));

    CComBSTR bstrFTDfsObjectDN;
    HRESULT hr = GetFTDfsObjectDN(i_pszDomainName, i_pszRootName, &bstrFTDfsObjectDN);
    if (FAILED(hr))
        return hr;

    CComBSTR bstrDC;
    PLDAP pldap = NULL;
    hr = ConnectToDS(i_pszDomainName, &pldap, &bstrDC); // PDC is preferred
    if (SUCCEEDED(hr))
    {
        if (i_bPublish)
        {
            CComBSTR bstrManagedByFQDN;
            if (i_pszManagedBy && *i_pszManagedBy)
            {
                hr = TranslateManagedBy(bstrDC, 
                                        i_pszManagedBy, 
                                        &bstrManagedByFQDN, 
                                        (_tcschr(i_pszManagedBy, _T('@')) ? DS_USER_PRINCIPAL_NAME : DS_NT4_ACCOUNT_NAME),
                                        DS_FQDN_1779_NAME);
            }

            if (SUCCEEDED(hr))
                hr = ModifyShareObject(
                        pldap,
                        bstrFTDfsObjectDN,
                        i_pszUNCPath,
                        i_pszDescription,
                        i_pszKeywords,
                        bstrManagedByFQDN);
        } else {
            hr = ModifyShareObject(
                    pldap,
                    bstrFTDfsObjectDN,
                    NULL,
                    NULL,
                    NULL,
                    NULL);
            if (S_FALSE == hr)
                hr = S_OK; // ignore non-existing object
        }

        CloseConnectionToDS(pldap);
    }

    dfsDebugOut((_T("ModifySharePublishInfoOnFTRoot hr=%x\n"), hr));

    return hr;
}

HRESULT ModifySharePublishInfoOnSARoot(
    IN PCTSTR i_pszServerName,
    IN PCTSTR i_pszShareName,
    IN BOOL   i_bPublish,
    IN PCTSTR i_pszUNCPath,
    IN PCTSTR i_pszDescription,
    IN PCTSTR i_pszKeywords,
    IN PCTSTR i_pszManagedBy
    )
{
    dfsDebugOut((_T("ModifySharePublishInfoOnSARoot %s, %s, %d, %s, %s, %s, %s\n"),
            i_pszServerName,
            i_pszShareName,
            i_bPublish,
            i_pszUNCPath,
            i_pszDescription,
            i_pszKeywords,
            i_pszManagedBy
                ));

    CComBSTR bstrDomainName, bstrFQDN;
    HRESULT hr = GetServerInfo(
                        (PTSTR)i_pszServerName, 
                        &bstrDomainName,
                        NULL, //NetbiosName
                        NULL, //ValidDSObject
                        NULL, //DnsName,
                        NULL, //Guid,
                        &bstrFQDN);
    if (S_OK != hr)
        return hr;

    CComBSTR bstrVolumeObjectDN = _T("CN=");
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrVolumeObjectDN);
    bstrVolumeObjectDN += i_pszShareName;
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrVolumeObjectDN);
    bstrVolumeObjectDN += _T(",");
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrVolumeObjectDN);
    bstrVolumeObjectDN += bstrFQDN;
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrVolumeObjectDN);

    CComBSTR bstrDC;
    PLDAP pldap = NULL;
    hr = ConnectToDS(bstrDomainName, &pldap, &bstrDC);
    if (SUCCEEDED(hr))
    {
        if (i_bPublish)
        {
            CComBSTR bstrManagedByFQDN;
            if (i_pszManagedBy && *i_pszManagedBy)
            {
                hr = TranslateManagedBy(bstrDC, 
                                        i_pszManagedBy, 
                                        &bstrManagedByFQDN, 
                                        (_tcschr(i_pszManagedBy, _T('@')) ? DS_USER_PRINCIPAL_NAME : DS_NT4_ACCOUNT_NAME),
                                        DS_FQDN_1779_NAME);
            }

            if (SUCCEEDED(hr))
            {
                hr = IsValidObject(pldap, bstrVolumeObjectDN);
                if (S_OK == hr)
                {
                    hr = ModifyShareObject(
                            pldap,
                            bstrVolumeObjectDN,
                            i_pszUNCPath,
                            i_pszDescription,
                            i_pszKeywords,
                            bstrManagedByFQDN);
                } else 
                {
                    hr = CreateVolumeObject(
                            pldap,
                            bstrVolumeObjectDN,
                            i_pszUNCPath,
                            i_pszDescription,
                            i_pszKeywords,
                            bstrManagedByFQDN);
                }
            }
        } else
        {
            hr = DeleteDSObject(pldap, bstrVolumeObjectDN, TRUE);
            if (S_FALSE == hr)
                hr = S_OK; // ignore non-existing object
        }

        CloseConnectionToDS(pldap);
    }
    
    dfsDebugOut((_T("ModifySharePublishInfoOnSARoot hr=%x\n"), hr));

    return hr;
}

HRESULT PutMultiValuesIntoAttrValList(
    IN PCTSTR   i_pszValues,
    OUT LDAP_ATTR_VALUE** o_pVal
    )
{
    if (!i_pszValues || !o_pVal)
        return E_INVALIDARG;

    LDAP_ATTR_VALUE* pHead = NULL;
    LDAP_ATTR_VALUE* pCurrent = NULL;

    int         index = 0;
    CComBSTR    bstrToken;
    HRESULT     hr = mystrtok(i_pszValues, &index, _T(";"), &bstrToken);
    while (SUCCEEDED(hr) && (BSTR)bstrToken)
    {
        TrimBSTR(bstrToken);

        if (*bstrToken)
        {
            LDAP_ATTR_VALUE* pNew = new LDAP_ATTR_VALUE;
            RETURN_OUTOFMEMORY_IF_NULL(pNew);
            pNew->vpValue = _tcsdup(bstrToken);
            if (!(pNew->vpValue))
            {
                delete pNew;
                hr = E_OUTOFMEMORY;
                break;
            }

            if (!pHead)
            {
                pHead = pCurrent = pNew;
            } else
            {
                pCurrent->Next = pNew;
                pCurrent = pNew;
            }
        }

        bstrToken.Empty();
        hr = mystrtok(i_pszValues, &index, _T(";"), &bstrToken);
    }

    if (FAILED(hr))
    {
        FreeAttrValList(pHead);
        return hr;
    }

    int nCount = 0;
    pCurrent = pHead;
    while (pCurrent)
    {
        nCount++;
        pCurrent = pCurrent->Next;
    }
    if (!nCount)
        return S_FALSE;  // no token

    *o_pVal = pHead;

    return S_OK;
}

HRESULT PutMultiValuesIntoStringArray(
    IN PCTSTR   i_pszValues,
    OUT PTSTR** o_pVal
    )
{
    if (!i_pszValues || !o_pVal)
        return E_INVALIDARG;

    int         nCount = 0;
    CComBSTR    bstrToken;
    int         index = 0;
    HRESULT     hr = mystrtok(i_pszValues, &index, _T(";"), &bstrToken);
    while (SUCCEEDED(hr) && (BSTR)bstrToken)
    {
        nCount++;

        bstrToken.Empty();
        hr = mystrtok(i_pszValues, &index, _T(";"), &bstrToken);;
    }

    if (!nCount)
        return E_INVALIDARG;

    PTSTR* ppszStrings = (PTSTR *)calloc(nCount + 1, sizeof(PTSTR *));
    RETURN_OUTOFMEMORY_IF_NULL(ppszStrings);

    nCount = 0;
    index = 0;
    bstrToken.Empty();
    hr = mystrtok(i_pszValues, &index, _T(";"), &bstrToken);
    while (SUCCEEDED(hr) && (BSTR)bstrToken)
    {
        TrimBSTR(bstrToken);
        if (*bstrToken)
        {
            ppszStrings[nCount] = _tcsdup(bstrToken);
            BREAK_OUTOFMEMORY_IF_NULL(ppszStrings[nCount], &hr);

            nCount++;
        }

        bstrToken.Empty();
        hr = mystrtok(i_pszValues, &index, _T(";"), &bstrToken);;
    }

    if (FAILED(hr))
        FreeStringArray(ppszStrings);
    else
        *o_pVal = ppszStrings;

    return hr;
}

//
// free a null-terminated array of strings
//
void FreeStringArray(PTSTR* i_ppszStrings)
{
    if (i_ppszStrings)
    {
        PTSTR* ppszString = i_ppszStrings;
        while (*ppszString)
        {
            free(*ppszString);
            ppszString++;
        }

        free(i_ppszStrings);
    }
}

HRESULT mystrtok(
    IN PCTSTR   i_pszString,
    IN OUT int* io_pnIndex,  // start from 0
    IN PCTSTR   i_pszCharSet,
    OUT BSTR*   o_pbstrToken
    )
{
    if (!i_pszString || !*i_pszString ||
        !i_pszCharSet || !io_pnIndex ||
        !o_pbstrToken)
        return E_INVALIDARG;

    *o_pbstrToken = NULL;

    HRESULT hr = S_OK;

    if (*io_pnIndex >= lstrlen(i_pszString))
    {
        return hr;  // no more tokens
    }

    TCHAR *ptchStart = (PTSTR)i_pszString + *io_pnIndex;
    if (!*i_pszCharSet)
    {
        *o_pbstrToken = SysAllocString(ptchStart);
        if (!*o_pbstrToken)
            hr = E_OUTOFMEMORY;
        return hr;
    }

    //
    // move p to the 1st char of the token
    //
    TCHAR *p = ptchStart;
    while (*p)
    {
        if (_tcschr(i_pszCharSet, *p))
            p++;
        else
            break;
    }

    ptchStart = p; // adjust ptchStart to point at the 1st char of the token

    //
    // move p to the char after the last char of the token
    //
    while (*p)
    {
        if (_tcschr(i_pszCharSet, *p))
            break;
        else
            p++;
    }

    //
    // ptchStart:   points at the 1st char of the token
    // p:           points at the char after the last char of the token
    //
    if (ptchStart != p)
    {
        *o_pbstrToken = SysAllocStringLen(ptchStart, (int)(p - ptchStart));
        if (!*o_pbstrToken)
            hr = E_OUTOFMEMORY;
        *io_pnIndex = (int)(p - i_pszString);
    }

    return hr;
}

//
// trim off space chars at the beginning and at the end of the string
//
void TrimBSTR(BSTR bstr)
{
    if (!bstr)
        return;

    TCHAR* p = bstr;

    //
    // trim off space chars at the beginning
    //
    while (*p)
    {
        if (_istspace(*p))
            p++;
        else
            break;
    }

    if (p > bstr)
        _tcscpy(bstr, p);

    int len = _tcslen(bstr);
    if (len > 0)
    {
        //
        // trim off space chars at the end
        //
        p = bstr + len - 1; // the char before the ending '\0'
        while (p > bstr)
        {
            if (_istspace(*p))
                p--;
            else
            {
                *(p+1) = _T('\0');
                break;
            }
        }
    }

}

BOOL CheckPolicyOnSharePublish()
{
    //
    // check group policy
    //
    BOOL    bAddPublishPage = TRUE; // by default, we display the share publish page

    HKEY    hKey = NULL;
    DWORD   dwType = 0;
    DWORD   dwData = 0;
    DWORD   cbData = sizeof(dwData);
    LONG    lErr = RegOpenKeyEx(
                    HKEY_CURRENT_USER,
                    _T("Software\\Policies\\Microsoft\\Windows NT\\SharedFolders"),
                    0,
                    KEY_QUERY_VALUE,
                    &hKey);
    if (ERROR_SUCCESS == lErr)
    {
        lErr = RegQueryValueEx(hKey, _T("PublishDfsRoots"), 0, &dwType, (LPBYTE)&dwData, &cbData);

        if (ERROR_SUCCESS == lErr && 
            REG_DWORD == dwType && 
            0 == dwData) // policy is disabled
            bAddPublishPage = FALSE;

        RegCloseKey(hKey);
    }

    return bAddPublishPage;

}

BOOL CheckPolicyOnDisplayingInitialMaster()
{
    BOOL    bShowInitialMaster = FALSE; // by default, we hide the initial master on property page

    HKEY    hKey = NULL;
    DWORD   dwType = 0;
    DWORD   dwData = 0;
    DWORD   cbData = sizeof(dwData);
    LONG    lErr = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    _T("Software\\Microsoft\\DfsGui"),
                    0,
                    KEY_QUERY_VALUE,
                    &hKey);
    if (ERROR_SUCCESS == lErr)
    {
        lErr = RegQueryValueEx(hKey, _T("ShowInitialMaster"), 0, &dwType, (LPBYTE)&dwData, &cbData);

        if (ERROR_SUCCESS == lErr && 
            REG_DWORD == dwType && 
            1 == dwData)
            bShowInitialMaster = TRUE;

        RegCloseKey(hKey);
    }

    return bShowInitialMaster;

}

HRESULT GetMenuResourceStrings(
    IN  int     i_iStringID,
    OUT BSTR*   o_pbstrMenuText,
    OUT BSTR*   o_pbstrToolTipText,
    OUT BSTR*   o_pbstrStatusBarText
    )
{
    if (!i_iStringID)
        return E_INVALIDARG;

    if (o_pbstrMenuText)
        *o_pbstrMenuText = NULL;
    if (o_pbstrToolTipText)
        *o_pbstrToolTipText = NULL;
    if (o_pbstrStatusBarText)
        *o_pbstrStatusBarText = NULL;

    TCHAR *pszMenuText = NULL;
    TCHAR *pszToolTipText = NULL;
    TCHAR *pszStatusBarText = NULL;
    TCHAR *p = NULL;

    CComBSTR  bstr;    
    HRESULT hr = LoadStringFromResource(i_iStringID, &bstr);
    RETURN_IF_FAILED(hr);  

    pszMenuText = (BSTR)bstr;
    p = _tcschr(pszMenuText, _T('|'));
    RETURN_INVALIDARG_IF_NULL(p);
    *p++ = _T('\0');

    pszToolTipText = p;
    p = _tcschr(pszToolTipText, _T('|'));
    RETURN_INVALIDARG_IF_NULL(p);
    *p++ = _T('\0');

    pszStatusBarText = p;

    do {
        if (o_pbstrMenuText)
        {
            *o_pbstrMenuText = SysAllocString(pszMenuText);
            BREAK_OUTOFMEMORY_IF_NULL(*o_pbstrMenuText, &hr);
        }

        if (o_pbstrToolTipText)
        {
            *o_pbstrToolTipText = SysAllocString(pszToolTipText);
            BREAK_OUTOFMEMORY_IF_NULL(*o_pbstrToolTipText, &hr);
        }

        if (o_pbstrStatusBarText)
        {
            *o_pbstrStatusBarText = SysAllocString(pszStatusBarText);
            BREAK_OUTOFMEMORY_IF_NULL(*o_pbstrStatusBarText, &hr);
        }
    } while (0);

    if (FAILED(hr))
    {
        if (o_pbstrMenuText && *o_pbstrMenuText)
            SysFreeString(*o_pbstrMenuText);
        if (o_pbstrToolTipText && *o_pbstrToolTipText)
            SysFreeString(*o_pbstrToolTipText);
        if (o_pbstrStatusBarText && *o_pbstrStatusBarText)
            SysFreeString(*o_pbstrStatusBarText);
    }

    return hr;
}

WNDPROC g_fnOldEditCtrlProc;

//+----------------------------------------------------------------------------
//
//  Function:   NoPasteEditCtrlProc
//
//  Synopsis:   The subclassed edit control callback procedure. 
//              The paste of this edit control is disabled. 
//
//-----------------------------------------------------------------------------
LRESULT CALLBACK 
NoPasteEditCtrlProc(
    HWND    hwnd,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    if (WM_PASTE == uMsg)
    {
      ::MessageBeep (0);
      return TRUE;
    }

    return CallWindowProc(g_fnOldEditCtrlProc, hwnd, uMsg, wParam, lParam);
}

void SetActivePropertyPage(IN HWND i_hwndParent, IN HWND i_hwndPage)
{
    int index = ::SendMessage(i_hwndParent, PSM_HWNDTOINDEX, (WPARAM)i_hwndPage, 0);
    if (-1 != index)
        ::SendMessage(i_hwndParent, PSM_SETCURSEL, (WPARAM)index, 0);
}

void MyShowWindow(HWND hwnd, BOOL bShow)
{
    ::ShowWindow(hwnd, (bShow ? SW_NORMAL : SW_HIDE));
    ::EnableWindow(hwnd, (bShow ? TRUE : FALSE));
}

//
// 7/11/2001 LinanT bug#426953
// Since connection made by Terminal Service may bring some client side resources 
// (disks, serial ports, etc.) into "My Computer" namespace, we want to disable
// the OK button when browsing to a non-local folder. We don't have this problem
// when browsing a remote machine.
//
typedef struct _LOCAL_DISKS
{
    LPTSTR pszDisks;
    DWORD  dwNumOfDisks;
} LOCAL_DISKS;

#define DISK_ENTRY_LENGTH   3  // Drive letter, colon, NULL
#define DISK_NAME_LENGTH    2  // Drive letter, colon

BOOL InDiskList(IN LPCTSTR pszDir, IN LOCAL_DISKS *pDisks)
{
    if (!pszDir || !pDisks)
        return FALSE;

    DWORD i = 0;
    PTSTR pszDisk = pDisks->pszDisks;
    for (; pszDisk && i < pDisks->dwNumOfDisks; i++)
    {
        if (!_tcsnicmp(pszDisk, pszDir, DISK_NAME_LENGTH))
            return TRUE;

        pszDisk += DISK_ENTRY_LENGTH;
    }

    return FALSE;
}

int CALLBACK
BrowseCallbackProc(
    IN HWND hwnd,
    IN UINT uMsg,
    IN LPARAM lp,
    IN LPARAM pData
)
{
  switch(uMsg) {
  case BFFM_SELCHANGED:
    { 
      // enable the OK button if the selected path is local to that computer.
      BOOL bEnableOK = FALSE;
      TCHAR szDir[MAX_PATH];
      if (SHGetPathFromIDList((LPITEMIDLIST) lp ,szDir))
      {
          if (pData)
          {
              // we're looking at a local computer, verify if szDir is on a local disk
              bEnableOK = InDiskList(szDir, (LOCAL_DISKS *)pData);
          } else
          {
              // no such problem when browsing at a remote computer, always enable OK button.
              bEnableOK = TRUE;
          }
      }
      SendMessage(hwnd, BFFM_ENABLEOK, 0, (LPARAM)bEnableOK);
      break;
    }
  case BFFM_VALIDATEFAILED:
  {
    DisplayMessageBox(hwnd, MB_OK, 0, IDS_BROWSE_FOLDER_INVALID);
    return 1;
  }
  default:
    break;
  }

  return 0;
}

void OpenBrowseDialog(
    IN HWND hwndParent,
    IN int  idLabel,
    IN BOOL bLocalComputer,
    IN LPCTSTR lpszComputer,
    OUT LPTSTR lpszDir)
{
  _ASSERT(lpszComputer && *lpszComputer);

  LOCAL_DISKS localDisks = {0};

  CComBSTR bstrComputer;
  if (*lpszComputer != _T('\\') || *(lpszComputer + 1) != _T('\\'))
  {
    bstrComputer = _T("\\\\");
    bstrComputer += lpszComputer;
  } else
  {
    bstrComputer = lpszComputer;
  }

  HRESULT hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
  if (SUCCEEDED(hr))
  {
    LPMALLOC pMalloc;
    hr = SHGetMalloc(&pMalloc);
    if (SUCCEEDED(hr))
    {
      LPSHELLFOLDER pDesktopFolder;
      hr = SHGetDesktopFolder(&pDesktopFolder);
      if (SUCCEEDED(hr))
      {
        LPITEMIDLIST  pidlRoot;
        if (bLocalComputer)
        {
          hr = SHGetSpecialFolderLocation(NULL, CSIDL_DRIVES, &pidlRoot);
          if (SUCCEEDED(hr))
          {
                //
                // 7/11/2001 LinanT bug#426953
                // Since connection made by Terminal Service may bring some client side resources 
                // (disks, serial ports, etc.) into "My Computer" namespace, we want to disable
                // the OK button when browsing to a non-local folder. We don't have this problem
                // when browsing a remote machine.
                //
               //
               // Get an array of local disk names, this information is later used
               // in the browse dialog to disable OK button if non-local path is selected.
               //
               DWORD dwTotalEntries = 0;
               DWORD nStatus = NetServerDiskEnum(
                                                NULL,   // local computer
                                               0,       // level must be zero
                                               (LPBYTE *)&(localDisks.pszDisks),
                                               -1,      // dwPrefMaxLen,
                                               &(localDisks.dwNumOfDisks),
                                               &dwTotalEntries,
                                               NULL);
               if (NERR_Success != nStatus)
               {
                   hr = HRESULT_FROM_WIN32(nStatus);
               }
          }
        } else
        {
          hr = pDesktopFolder->ParseDisplayName(hwndParent, NULL, bstrComputer, NULL, &pidlRoot, NULL);
        }

        if (SUCCEEDED(hr))
        {
          CComBSTR bstrLabel;
          LoadStringFromResource(idLabel, &bstrLabel);

          BROWSEINFO bi;
          ZeroMemory(&bi,sizeof(bi));
          bi.hwndOwner = hwndParent;
          bi.pszDisplayName = 0;
          bi.lpszTitle = bstrLabel;
          bi.pidlRoot = pidlRoot;
          bi.ulFlags = BIF_RETURNONLYFSDIRS | BIF_SHAREABLE | BIF_USENEWUI | BIF_VALIDATE;
          bi.lpfn = BrowseCallbackProc;
          if (localDisks.pszDisks)
            bi.lParam = (LPARAM)&localDisks; // pass the structure to the browse dialog

          LPITEMIDLIST pidl = SHBrowseForFolder(&bi);
          if (pidl) {
            SHGetPathFromIDList(pidl, lpszDir);
            pMalloc->Free(pidl);
          }
          pMalloc->Free(pidlRoot);
        }
        pDesktopFolder->Release();
      }
      pMalloc->Release();
    }

    CoUninitialize();
  }

  if (localDisks.pszDisks)
    NetApiBufferFree(localDisks.pszDisks);

  if (FAILED(hr))
    DisplayMessageBox(::GetActiveWindow(), MB_OK, hr, IDS_CANNOT_BROWSE_FOLDER, lpszComputer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsshlex\dfspath.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

DfsPath.cpp

Abstract:
    This is the implementation file for Dfs Shell path handling modules for the Dfs Shell
    Extension object.

Author:

Environment:
    
     NT only.
--*/

#include <nt.h>
#include <ntrtl.h>
#include <ntioapi.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <lmerr.h>
#include <lmcons.h>
#include <lmdfs.h>
#include <lmapibuf.h>
#include <tchar.h>
#include "DfsPath.h"


//--------------------------------------------------------------------------------------------
//
// caller of this function must call free() on *o_ppszRemotePath
//
HRESULT GetRemotePath(
    LPCTSTR i_pszPath,
    PTSTR  *o_ppszRemotePath
    )
{
    if (!i_pszPath || !*i_pszPath || !o_ppszRemotePath)
        return E_INVALIDARG;

    if (*o_ppszRemotePath)
        free(*o_ppszRemotePath);  // to prevent memory leak

    UNICODE_STRING unicodePath;
    RtlInitUnicodeString(&unicodePath, i_pszPath);

    OBJECT_ATTRIBUTES ObjectAttributes;
    InitializeObjectAttributes(&ObjectAttributes,
                                &unicodePath,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL);

    HANDLE hFile = NULL;
    IO_STATUS_BLOCK ioStatusBlock;
    NTSTATUS ntStatus = NtOpenFile(&hFile,
                                    SYNCHRONIZE,
                                    &ObjectAttributes,
                                    &ioStatusBlock,
                                    FILE_SHARE_READ,
                                    FILE_DIRECTORY_FILE);

    if (!NT_SUCCESS(ntStatus)) 
        return HRESULT_FROM_WIN32(ntStatus);

    TCHAR buffer[MAX_PATH + sizeof(FILE_NAME_INFORMATION) + 1] = {0};
    PFILE_NAME_INFORMATION pFileNameInfo = (PFILE_NAME_INFORMATION)buffer;
    ntStatus = NtQueryInformationFile(hFile,
                                    &ioStatusBlock,
                                    pFileNameInfo,
                                    sizeof(buffer) - sizeof(TCHAR), // leave room for the ending '\0'
                                    FileNameInformation);

    NtClose(hFile);

    if (!NT_SUCCESS(ntStatus)) 
    {
        return HRESULT_FROM_WIN32(ntStatus);
    }

    UINT uiRequiredLength = (pFileNameInfo->FileNameLength / sizeof(TCHAR)) + 2; // +1 for prefix '\\', the other for the ending NULL
    *o_ppszRemotePath = (PTSTR)calloc(uiRequiredLength, sizeof(TCHAR));
    if (!*o_ppszRemotePath)
        return E_OUTOFMEMORY;

    // prepend a "\" as the Api puts only 1 "\" as in \dfsserver\dfsroot
    (*o_ppszRemotePath)[0] = _T('\\');

    RtlCopyMemory((BYTE*)&((*o_ppszRemotePath)[1]),
                pFileNameInfo->FileName,
                pFileNameInfo->FileNameLength);

    return S_OK;
}

bool IsPathWithDriveLetter(LPCTSTR pszPath)
{
    if (!pszPath || lstrlen(pszPath) < 3)
        return false;

    if (*(pszPath+1) == _T(':') &&
        *(pszPath+2) == _T('\\') &&
        (*pszPath >= _T('a') && *pszPath <= _T('z') ||
         *pszPath >= _T('A') && *pszPath <= _T('Z')))
        return true;

    return false;
}

HRESULT ResolveDfsPath(
    IN  LPCTSTR         pcszPath,   // check if this UNC path is a DFS path
    OUT PDFS_INFO_3*    ppInfo      // will hold the pointer to a DFS_INFO_3
    )
/*++

Routine Description:

    Given a UNC path, detect whether it is a DFS path.
    Return info on the last leg of redirection in *ppInfo.
 
Return value:

    On error or a non-DFS path, *ppInfo will be NULL.
    On a DFS path, *ppInfo will contain info on the last leg of redirection.
    The caller needs to free it via NetApiBufferFree.

Algorithm:

Since we are bringing up the property page of the given path, DFS should have
brought in all the relevant entries into its PKT cache.

Upon every success call of NetDfsGetClientInfo, we can be sure that
the InputPath must start with the EntryPath in the returned structure.
We can replace the portion of the InputPath with the EntryPath's active target
and feed the new path to the next call of NetDfsGetClientInfo until we
reach the last leg of redirection. The DFS_INFO_3 returned most recently
has the info we want.

Here are several examples:

If (EntryPath == InputPath), the returned DFS_INFO_3 has the info we want.
        C:\>dfsapi getclientinfo \\products\Public\boneyard "" "" 3
        \products\Public\Boneyard    "(null)"    OK      1
                \\boneyard\boneyard$    active online

If (InputPath > EntryPath), replace the path and continue the loop.
a) If the API call fails, the DFS_INFO_3 returned previously has the info we want.
        C:\>dfsapi getclientinfo \\ntdev\public\release\main "" "" 3
        \ntdev\public\release    "(null)"    OK      1
                \\ntdev.corp.microsoft.com\release      online
        C:\>dfsapi getclientinfo \\ntdev.corp.microsoft.com\release\main "" "" 3
        \ntdev.corp.microsoft.com\release    "(null)"    OK      2
                \\WINBUILDS\release     active online
                \\WINBUILDS2\release    online
        C:\>dfsapi getclientinfo \\WINBUILDS\release\main "" "" 3
        c:\public\dfsapi failed: 2662

b) If the API call returns a structure where the EntryPath==ActivePath, stop,
   the current structure has the info we want.
        C:\>dfsapi getclientinfo \\products\Public\multimedia "" "" 3
        \products\Public    "(null)"    OK      1
                \\PRODUCTS\Public       active online
--*/
{
    if (!pcszPath || !*pcszPath || !ppInfo)
        return E_INVALIDARG;

    *ppInfo = NULL;

    PTSTR pszDfsPath = _tcsdup(pcszPath);
    if (!pszDfsPath)
        return E_OUTOFMEMORY;

    //
    // call NetDfsGetClientInfo to find the best entry in PKT cache
    //
    HRESULT     hr = S_OK;
    BOOL        bOneWhack = TRUE;   // true if EntryPath starts with 1 whack
    DFS_INFO_3* pDfsInfo3 = NULL;
    DFS_INFO_3* pBuffer = NULL;
    while (NERR_Success == NetDfsGetClientInfo(pszDfsPath, NULL, NULL, 3, (LPBYTE *)&pBuffer))
    {
        _ASSERT(pBuffer->EntryPath);
        _ASSERT(lstrlen(pBuffer->EntryPath) > 1);
        bOneWhack = (_T('\\') == *(pBuffer->EntryPath) &&
                     _T('\\') != *(pBuffer->EntryPath + 1));

        //
        // find the active target of this entry, we need it to resolve the rest of path
        //
        PTSTR pszActiveServerName = NULL;
        PTSTR pszActiveShareName = NULL;
        if (pBuffer->NumberOfStorages == 1)
        {
            pszActiveServerName = pBuffer->Storage[0].ServerName;
            pszActiveShareName = pBuffer->Storage[0].ShareName;
        }
        else
        {
            for (DWORD i = 0; i < pBuffer->NumberOfStorages; i++)
            {
                if (pBuffer->Storage[i].State & DFS_STORAGE_STATE_ACTIVE)
                {
                    pszActiveServerName = pBuffer->Storage[i].ServerName;
                    pszActiveShareName = pBuffer->Storage[i].ShareName;
                    break;
                }
            }

            if (!pszActiveServerName)
            {
                hr = E_FAIL; // active target is missing, error out
                break;
            }
        }

        //
        // An entry is found, record its info.
        //
        if (pDfsInfo3)
            NetApiBufferFree(pDfsInfo3);
        pDfsInfo3 = pBuffer;
        pBuffer = NULL;

        //
        // When the entry path matches its active target, return the current structure
        //
        PTSTR pszActiveTarget = (PTSTR)calloc(
                                    (bOneWhack ? 1 : 2) +           // prepend 1 or 2 whacks
                                    lstrlen(pszActiveServerName) + 
                                    1 +                             // '\\'
                                    lstrlen(pszActiveShareName) + 
                                    1,                              // ending '\0'
                                    sizeof(TCHAR));
        if (!pszActiveTarget)
        {
            hr = E_OUTOFMEMORY;
            break;
        }
        _stprintf(pszActiveTarget,
            (bOneWhack ? _T("\\%s\\%s") : _T("\\\\%s\\%s")),
            pszActiveServerName,
            pszActiveShareName);

        BOOL bEntryPathMatchActiveTarget = !lstrcmpi(pszActiveTarget, pDfsInfo3->EntryPath);

        free(pszActiveTarget);

        if (bEntryPathMatchActiveTarget)
            break;  // return current pDfsInfo3

        //
        // pszDfsPath must have begun with pDfsInfo3->EntryPath.
        // If no extra chars left in the path, we have found the pDfsInfo3.
        //
        int nLenDfsPath = lstrlen(pszDfsPath);
        int nLenEntryPath = lstrlen(pDfsInfo3->EntryPath) + (bOneWhack ? 1 : 0);
        if (nLenDfsPath == nLenEntryPath)
            break;

        //
        // compose a new path which contains the active target and the rest of path.
        // continue to call NetDfsGetClientInfo to find the best entry for this new path.
        //
        PTSTR pszNewPath = (PTSTR)calloc(2 + lstrlen(pszActiveServerName) + 1 + lstrlen(pszActiveShareName) + nLenDfsPath - nLenEntryPath + 1, sizeof(TCHAR));
        if (!pszNewPath)
        {
            hr = E_OUTOFMEMORY;
            break;
        }
        _stprintf(pszNewPath, _T("\\\\%s\\%s%s"), pszActiveServerName, pszActiveShareName, pszDfsPath + nLenEntryPath);

        free(pszDfsPath);
        pszDfsPath = pszNewPath;

    } // end of while

    if (pszDfsPath)
        free(pszDfsPath);

    if (pBuffer)
        NetApiBufferFree(pBuffer);

    //
    // Fill in the output:
    // pDfsInfo3 will be NULL on a non-DFS path.
    // pDfsInfo3 will contain info on the last leg of redirection on a DFS path.
    // The caller needs to free it via NetApiBufferFree.
    //
    if (SUCCEEDED(hr))
    {
        *ppInfo = pDfsInfo3;
    }
    else
    {
        if (pDfsInfo3)
            NetApiBufferFree(pDfsInfo3);
    }

    return hr;
}

bool 
IsDfsPath
(
    LPTSTR                i_lpszDirPath,
    LPTSTR*               o_plpszEntryPath,
    LPDFS_ALTERNATES**    o_pppDfsAlternates
)
/*++

Routine Description:

    Checks if the give directory path is a Dfs Path.
    If it is then it returns the largest Dfs entry path that matches 
    this directory.

 Arguments:

    i_lpszDirPath        - The directory path.
        
    o_plpszEntryPath        - The largest Dfs entrypath is returned here.
                          if the dir path is not Dfs path then this is NULL.

    o_pppDfsAlternates    - If the path is a dfs path, then an array of pointers to the possible alternate
                          paths are returned here.
  
Return value:

    true if the path is determined to be a Dfs Path 
    false if otherwise.
--*/
{
    if (!i_lpszDirPath || !*i_lpszDirPath || !o_pppDfsAlternates || !o_plpszEntryPath)
    {
        return(false);
    }

    *o_pppDfsAlternates = NULL;
    *o_plpszEntryPath = NULL;

    //
    // Convert a path to UNC format:
    // Local path (C:\foo) is not a DFS path, return false.
    // Remote path (X:\foo) needs to be converted to UNC format via NtQueryInformationFile.
    // Remote path already in UNC format needs no further conversion.
    //

    PTSTR    lpszSharePath = NULL; // this variable will hold the path in UNC format
    
                                // Is the dir path of type d:\* or \\server\share\*?
    if (_T('\\') == i_lpszDirPath[0])
    {
        //
        // This path is already in UNC format.
        //
        lpszSharePath = _tcsdup(i_lpszDirPath);
        if (!lpszSharePath)
            return false; // out of memory
    }
    else if (!IsPathWithDriveLetter(i_lpszDirPath))
    {
        return false; // unknown path format
    }
    else
    {
        //
        // This path starts with a drive letter. Check if it is local.
        //
        TCHAR lpszDirPath[] = _T("\\??\\C:\\");
        PTSTR lpszDrive = lpszDirPath + 4;

                                // Copy the drive letter,
        *lpszDrive = *i_lpszDirPath;

                                // See if it is a remote drive. If not return false.
        if (DRIVE_REMOTE != GetDriveType(lpszDrive))
            return false;
        
        //
        // Find UNC path behind this drive letter.
        //
        PTSTR pszRemotePath = NULL;
        if (FAILED(GetRemotePath(lpszDirPath, &pszRemotePath)))
            return false;

        //
        // Construct the full path in UNC.
        //
        lpszSharePath = (PTSTR)calloc(lstrlen(pszRemotePath) + lstrlen(i_lpszDirPath), sizeof(TCHAR));
        if (!lpszSharePath)
        {
            free(pszRemotePath);
            return false; // out of memory
        }

        _stprintf(lpszSharePath, _T("%s%s"), pszRemotePath,
            (pszRemotePath[lstrlen(pszRemotePath) - 1] == _T('\\') ? i_lpszDirPath + 3 : i_lpszDirPath + 2));

        free(pszRemotePath);
    }

    //
    // Check if this UNC is a DFS path. If it is, pDfsInfo3 will contain info of
    // the last leg of redirection.
    //
    bool        bIsDfsPath = false;
    DFS_INFO_3* pDfsInfo3 = NULL;
    HRESULT     hr = ResolveDfsPath(lpszSharePath, &pDfsInfo3);
    if (SUCCEEDED(hr) && pDfsInfo3)
    {
        _ASSERT(pDfsInfo3->EntryPath);
        _ASSERT(lstrlen(pDfsInfo3->EntryPath) > 1);
        BOOL bOneWhack = (_T('\\') == *(pDfsInfo3->EntryPath) &&
                          _T('\\') != *(pDfsInfo3->EntryPath + 1));
        do
        {
            //
            // This is a DFS path, output the entry path.
            //
            *o_plpszEntryPath = new TCHAR [(bOneWhack ? 1 : 0) +    // prepend an extra whack
                                            _tcslen(pDfsInfo3->EntryPath) +
                                            1];                     // ending '\0'
            if (!*o_plpszEntryPath)
            {
                break;
            }
            _stprintf(*o_plpszEntryPath,
                    (bOneWhack ? _T("\\%s") : _T("%s")),
                    pDfsInfo3->EntryPath);

                                    // Allocate null terminated array for alternate pointers.
            *o_pppDfsAlternates = new LPDFS_ALTERNATES[pDfsInfo3->NumberOfStorages + 1];
            if (!*o_pppDfsAlternates)
            {
                delete[] *o_plpszEntryPath;
                *o_plpszEntryPath = NULL;
                break;
            }
        
            (*o_pppDfsAlternates)[pDfsInfo3->NumberOfStorages] = NULL;

                                    // Allocate space for each alternate.
            DWORD i = 0;
            for (i = 0; i < pDfsInfo3->NumberOfStorages; i++)
            {
                (*o_pppDfsAlternates)[i] = new DFS_ALTERNATES;
                if (NULL == (*o_pppDfsAlternates)[i])
                {
                    for(int j = i-1; j >= 0; j--)
                        delete (*o_pppDfsAlternates)[j];
                    delete[] *o_pppDfsAlternates;
                    *o_pppDfsAlternates = NULL;
                    delete[] *o_plpszEntryPath;
                    *o_plpszEntryPath = NULL;
                    break;
                }
            }
            if (i < pDfsInfo3->NumberOfStorages)
                break;

                                    // Copy alternate paths.                                        
            for (i = 0; i < pDfsInfo3->NumberOfStorages; i++)
            {    
                (*o_pppDfsAlternates)[i]->bstrServer = (pDfsInfo3->Storage[i]).ServerName;
                (*o_pppDfsAlternates)[i]->bstrShare = (pDfsInfo3->Storage[i]).ShareName;
                (*o_pppDfsAlternates)[i]->bstrAlternatePath = _T("\\\\");
                (*o_pppDfsAlternates)[i]->bstrAlternatePath += (pDfsInfo3->Storage[i]).ServerName;
                (*o_pppDfsAlternates)[i]->bstrAlternatePath += _T("\\");
                (*o_pppDfsAlternates)[i]->bstrAlternatePath += (pDfsInfo3->Storage[i]).ShareName;

                                        // Set replica state.
                if ((pDfsInfo3->Storage[i]).State & DFS_STORAGE_STATE_ACTIVE)
                {
                    (*o_pppDfsAlternates)[i]->ReplicaState = SHL_DFS_REPLICA_STATE_ACTIVE_UNKNOWN;
                }        
            }

            bIsDfsPath = true;
        } while(false);

        NetApiBufferFree(pDfsInfo3);
    }

    if (lpszSharePath)
        free(lpszSharePath);

    return bIsDfsPath;
}
//----------------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsshlex\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsshlex\dfspath.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

DfsPath.h

Abstract:
	This is the header file for Dfs Shell path handling modules for the Dfs Shell
	Extension object.

Author:

    Constancio Fernandes (ferns@qspl.stpp.soft.net) 12-Jan-1998

Environment:
	
	 NT only.
--*/

//--------------------------------------------------------------------------------------------

#ifndef _DFS_PATHS_H
#define _DFS_PATHS_H

enum SHL_DFS_REPLICA_STATE
{
	SHL_DFS_REPLICA_STATE_ACTIVE_UNKNOWN = 0,
	SHL_DFS_REPLICA_STATE_ACTIVE_OK,
	SHL_DFS_REPLICA_STATE_ACTIVE_UNREACHABLE,
	SHL_DFS_REPLICA_STATE_UNKNOWN,     // online
	SHL_DFS_REPLICA_STATE_OK,          // online
	SHL_DFS_REPLICA_STATE_UNREACHABLE  // online
};

#include "atlbase.h"

class  DFS_ALTERNATES
{
public:
	CComBSTR	bstrAlternatePath;
	CComBSTR	bstrServer;
	CComBSTR	bstrShare;
	enum SHL_DFS_REPLICA_STATE	ReplicaState;
	
	DFS_ALTERNATES():ReplicaState(SHL_DFS_REPLICA_STATE_UNKNOWN)
	{
	}

	~DFS_ALTERNATES()
	{
	}
};

typedef  DFS_ALTERNATES *LPDFS_ALTERNATES;


						// Checks if the directory path is a Dfs Path or not.
bool IsDfsPath
(
	LPTSTR				i_lpszDirPath,
	LPTSTR*				o_pszEntryPath,
	LPDFS_ALTERNATES**	o_pppDfsAlternates
);

#endif //#ifndef _DFS_PATHS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsshlex\dfsshell.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

DfsShell.cpp

Abstract:
	This is the implementation file for Dfs Shell Extension object which implements
	IShellIExtInit and IShellPropSheetExt.

Author:

    Constancio Fernandes (ferns@qspl.stpp.soft.net) 12-Jan-1998

Environment:
	
	 NT only.
*/

#include "stdafx.h"
#include "DfsShlEx.h"	
#include "DfsShell.h"

/*----------------------------------------------------------------------
					IShellExtInit Implementation.
------------------------------------------------------------------------*/

STDMETHODIMP CDfsShell::Initialize
(
	IN LPCITEMIDLIST	pidlFolder,		// Points to an ITEMIDLIST structure
	IN LPDATAOBJECT	lpdobj,			// Points to an IDataObject interface
	IN HKEY			hkeyProgID		// Registry key for the file object or folder type
)
{
/*++

Routine Description:

	Called by Shell when our extension is loaded.

--*/

    STGMEDIUM medium;
    FORMATETC fe = { CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

								// Fail the call if lpdobj is NULL.
    if (lpdobj == NULL)
	{
        return E_FAIL;
	}

								// Render the data referenced by the IDataObject pointer to an HGLOBAL
								// storage medium in CF_HDROP format.
    HRESULT hr = lpdobj->GetData (&fe, &medium);
    if (FAILED (hr))
	{
        return hr;
	}


							    // If only one item is selected, retrieve the item name and store it in
								// m_lpszFile. Otherwise fail the call.
    if (DragQueryFile ((HDROP) medium.hGlobal, 0xFFFFFFFF, NULL, 0) == 1) 
	{
        if (m_lpszFile)
            delete [] m_lpszFile;

        UINT uiChars = DragQueryFile ((HDROP) medium.hGlobal, 0, NULL, 0);
        m_lpszFile = new TCHAR [uiChars + 1];
        if (!m_lpszFile)
        {
            hr = E_OUTOFMEMORY;
        } else
        {
            ZeroMemory(m_lpszFile, sizeof(TCHAR) * (uiChars + 1));
		    DragQueryFile ((HDROP) medium.hGlobal, 0, m_lpszFile, uiChars + 1);
        }
	}
    else
	{
        hr = E_FAIL;
	}

    ReleaseStgMedium (&medium);

    if (FAILED(hr))
        return hr;

				// Display hour glass.
	CWaitCursor WaitCursor;

	if (IsDfsPath(m_lpszFile, &m_lpszEntryPath, &m_ppDfsAlternates))
	{
		return S_OK;
	}
	else
	{
		if (NULL != m_lpszFile) 
		{
			delete [] m_lpszFile;
			m_lpszFile = NULL;
		}

		return E_FAIL;
	}
}


STDMETHODIMP CDfsShell::AddPages
(
	IN LPFNADDPROPSHEETPAGE lpfnAddPage, 
	IN LPARAM lParam
)
/*++

Routine Description:

	Called by the shell just before the property sheet is displayed.

Arguments:

    lpfnAddPage -  Pointer to the Shell's AddPage function
    lParam      -  Passed as second parameter to lpfnAddPage	

Return value:

    NOERROR in all cases.  If for some reason our pages don't get added,
    the Shell still needs to bring up the Properties' sheet.

--*/
{
  BOOL bAddPage = TRUE;

  // check policy
  LONG lErr = ERROR_SUCCESS;
  HKEY hKey = 0;

  lErr = RegOpenKeyEx(
    HKEY_CURRENT_USER,
    _T("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\explorer"),
    0,
    KEY_QUERY_VALUE,
    &hKey);
  if (ERROR_SUCCESS == lErr)
  {
    lErr = RegQueryValueEx(hKey, _T("NoDFSTab"), 0, NULL, NULL, NULL);
    
    if (ERROR_SUCCESS == lErr)
      bAddPage = FALSE;  // data exist, do not add the Dfs tab

    RegCloseKey(hKey);
  }

  if (!bAddPage)
    return NOERROR;

								// Create the page for the replica set.
								// Pass it to the Callback
	HPROPSHEETPAGE	h_proppage = m_psDfsShellExtProp.Create();
    if (!h_proppage)
        return E_OUTOFMEMORY;

    if (lpfnAddPage(h_proppage, lParam))
    {
	    m_psDfsShellExtProp.put_DfsShellPtr((IShellPropSheetExt *)this);
	    CComBSTR	bstrDirPath = m_lpszFile;
	    CComBSTR	bstrEntryPath = m_lpszEntryPath;

	    m_psDfsShellExtProp.put_DirPaths(bstrDirPath, bstrEntryPath);
    } else
    {
        // must call this function for pages that have not been added. 
        DestroyPropertySheetPage(h_proppage); 
    }

    return S_OK;
}


STDMETHODIMP CDfsShell::ReplacePage
(
	IN UINT uPageID, 
    IN LPFNADDPROPSHEETPAGE lpfnReplaceWith, 
    IN LPARAM lParam
)
/*++

Routine Description:

	Called by the shell only for Control Panel property sheet extensions

 Arguments:

    uPageID         -  ID of page to be replaced
    lpfnReplaceWith -  Pointer to the Shell's Replace function
    lParam          -  Passed as second parameter to lpfnReplaceWith
	
Return value:

    E_FAIL, since we don't support this function.
--*/
{
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsshlex\dfsshell.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

DfsShell.h

Abstract:
    This is the header file for Dfs Shell Extension object which implements
    IShellIExtInit and IShellPropSheetExt.

Author:

    Constancio Fernandes (ferns@qspl.stpp.soft.net) 12-Jan-1998

Environment:
    
     NT only.
--*/


#ifndef __DFSSHELL_H_
#define __DFSSHELL_H_

#include "resource.h"       // main symbols
#include "DfsShPrp.h"
#include "DfsPath.h"

/////////////////////////////////////////////////////////////////////////////
// CDfsShell
class ATL_NO_VTABLE CDfsShell : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDfsShell, &CLSID_DfsShell>,
    public IShellExtInit,
    public IShellPropSheetExt
{
public:
    CDfsShell()
    {
        m_lpszFile = NULL;
        m_ppDfsAlternates = NULL;
        m_lpszEntryPath = NULL;
    }

    ~CDfsShell()
    {    
        if (m_ppDfsAlternates)
        {
            for (int i = 0; NULL != m_ppDfsAlternates[i] ; i++)
            {
                delete m_ppDfsAlternates[i];
            }
            
            delete[] m_ppDfsAlternates;
            m_ppDfsAlternates = NULL;
        }

        if (m_lpszEntryPath) 
        {
            delete [] m_lpszEntryPath;
            m_lpszEntryPath = NULL;
        }

        if (m_lpszFile)
        {
            delete [] m_lpszFile;
            m_lpszFile = NULL;
        }
    }

DECLARE_REGISTRY_RESOURCEID(IDR_DFSSHELL)

BEGIN_COM_MAP(CDfsShell)
    COM_INTERFACE_ENTRY(IShellExtInit)
    COM_INTERFACE_ENTRY(IShellPropSheetExt)
END_COM_MAP()

// IDfsShell
public:


// IShellExtInit Methods

    STDMETHOD (Initialize)
    (
        IN LPCITEMIDLIST    pidlFolder,        // Points to an ITEMIDLIST structure
        IN LPDATAOBJECT    lpdobj,            // Points to an IDataObject interface
        IN HKEY            hkeyProgID        // Registry key for the file object or folder type
    );    

    //IShellPropSheetExt methods
    STDMETHODIMP AddPages
    (
        IN LPFNADDPROPSHEETPAGE lpfnAddPage, 
        IN LPARAM lParam
    );
    
    STDMETHODIMP ReplacePage
    (
        IN UINT uPageID, 
        IN LPFNADDPROPSHEETPAGE lpfnReplaceWith, 
        IN LPARAM lParam
    );
    
private:
    
    friend    class CDfsShellExtProp;

    LPTSTR              m_lpszFile;
    
    LPTSTR                m_lpszEntryPath;

    CDfsShellExtProp    m_psDfsShellExtProp;

    LPDFS_ALTERNATES*    m_ppDfsAlternates; 
};

#endif //__DFSSHELL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsshlex\dfsshlex.cpp ===
// DfsShlEx.cpp : Implementation of DLL Exports.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "DfsShlEx.h"

#include "DfsShlEx_i.c"
#include "DfsShell.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_DfsShell, CDfsShell)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();

    //
    // #253178 manually remove this registry value (added in dfsshell.rgs)
    //
    HKEY hKey = 0;
    LONG lErr = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        _T("Software\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved"),
                        0,
                        KEY_ALL_ACCESS,
                        &hKey);
    if (ERROR_SUCCESS == lErr)
    {
        (void)RegDeleteValue(hKey, _T("{ECCDF543-45CC-11CE-B9BF-0080C87CDBA6}"));

        RegCloseKey(hKey);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsshlex\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dfsshlex.rc
//
#define IDR_DFSSHELL                    101
#define IDS_APPLICATION_NAME            102
#define IDS_ALTERNATE_LIST_PATH         103
#define IDS_ALTERNATE_LIST_ACTIVE       104
#define IDS_ALTERNATE_LIST_STATUS       105
#define IDS_ALTERNATE_LIST_YES          106
#define IDS_ALTERNATE_LIST_NO           107
#define IDS_ALTERNATE_LIST_OK           108
#define IDS_ALTERNATE_LIST_UNREACHABLE  109
#define IDB_Replica                     200
#define IDD_DFS_SHELL_PROP              201
#define IDC_DIR_PATH                    202
#define IDC_ALTERNATE_LIST              203
#define IDC_FLUSH_PKT                   204
#define IDC_CHECK_STATUS                205
#define IDC_SET_ACTIVE                  206

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        110
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         207
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsshlex\dfsshprp.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    DfsShPrp.cpp

Abstract:

    This module contains the implementation for CDfsShellExtProp
  This is used to implement the property page for Shell Extension.


Author:

    Constancio Fernandes (ferns@qspl.stpp.soft.net) 12-Jan-1998

Environment:


Revision History:

--*/

#include "stdafx.h"
#include "resource.h"
#include "DfsShlEx.h"
#include "DfsPath.h"
#include "DfsShPrp.h"
#include "DfsShell.h"
#include <lmcons.h>
#include <lmerr.h>
#include <lmdfs.h>
#include "dfshelp.h"

CDfsShellExtProp::CDfsShellExtProp():CQWizardPageImpl<CDfsShellExtProp>(false)
/*++
Routine Description:
  Ctor of CDfsShellExtProp.
  Calls the ctor of it's parent
--*/
{
  m_pIShProp = NULL;
  LoadStringFromResource(IDS_ALTERNATE_LIST_PATH, &m_bstrAlternateListPath);
  LoadStringFromResource(IDS_ALTERNATE_LIST_ACTIVE, &m_bstrAlternateListActive);
  LoadStringFromResource(IDS_ALTERNATE_LIST_STATUS, &m_bstrAlternateListStatus);
  LoadStringFromResource(IDS_ALTERNATE_LIST_YES, &m_bstrAlternateListYes);
  LoadStringFromResource(IDS_ALTERNATE_LIST_NO, &m_bstrAlternateListNo);
  LoadStringFromResource(IDS_ALTERNATE_LIST_OK, &m_bstrAlternateListOK);
  LoadStringFromResource(IDS_ALTERNATE_LIST_UNREACHABLE, &m_bstrAlternateListUnreachable);
}

CDfsShellExtProp::~CDfsShellExtProp(
  )
/*++
Routine Description:
  dtor of CDfsShellExtProp.
  Free the notify handle.
--*/
{
/* ImageList_Destroy already called by the desctructor of list control
  if (NULL !=  m_hImageList)
    ImageList_Destroy(m_hImageList);
*/
}

LRESULT
CDfsShellExtProp::OnInitDialog(
  IN UINT            i_uMsg,
  IN WPARAM          i_wParam,
  LPARAM            i_lParam,
  IN OUT BOOL&        io_bHandled
  )
/*++
Routine Description:
  Called at the start. Used to set dialog defaults
--*/
{
  SetDlgItemText(IDC_DIR_PATH, m_bstrDirPath);

  _SetImageList();
  _SetAlternateList();

  return TRUE;
}

HRESULT
CDfsShellExtProp::put_DfsShellPtr(
    IN IShellPropSheetExt*      i_pDfsShell
    )
/*++
Routine Description:
  Called at the start by CDfsShell. Used to set a back pointer to CDfsShell object to call Release().
--*/
{
  if (!i_pDfsShell)
    return(E_INVALIDARG);

  if (m_pIShProp)
      m_pIShProp->Release();

  m_pIShProp = i_pDfsShell;
  m_pIShProp->AddRef();

  return(S_OK);
}

HRESULT
CDfsShellExtProp::put_DirPaths(
  IN BSTR            i_bstrDirPath,
  IN BSTR            i_bstrEntryPath
  )
/*++
Routine Description:
  Set the value of Directory Path for this directory. and the largest entrypath.

Arguments:
  i_bstrDirPath - Contains the new value for Entry Path
  i_bstrEntryPath - The largest Dfs entry path that matches this directory.
--*/
{
  if (!i_bstrDirPath)
    return(E_INVALIDARG);

  m_bstrDirPath = i_bstrDirPath;
  m_bstrEntryPath = i_bstrEntryPath;

  if (!m_bstrDirPath || !i_bstrEntryPath)
    return(E_OUTOFMEMORY);

  return S_OK;
}

LRESULT
CDfsShellExtProp::OnApply(
    )
{
  return TRUE;
}

LRESULT
CDfsShellExtProp::OnParentClosing(
  IN UINT              i_uMsg,
  IN WPARAM            i_wParam,
  LPARAM              i_lParam,
  IN OUT BOOL&          io_bHandled
  )
/*++
Routine Description:
  Used by the node to tell the propery page to close.
--*/
{
  return TRUE;
}

void
CDfsShellExtProp::Delete()
/*++
Routine Description:
  Called when property sheet is release to do clean up.
*/
{
  if (m_pIShProp)
    m_pIShProp->Release();
}

LRESULT
CDfsShellExtProp::OnFlushPKT(
    IN WORD            i_wNotifyCode,
    IN WORD            i_wID,
    IN HWND            i_hWndCtl,
    IN OUT BOOL&        io_bHandled
  )
/*++
Routine Description:
  Called when Flush PKT table is called.
  Flushes client PKT table.
*/
{
  if (!m_bstrEntryPath)
    return(E_FAIL);

  NET_API_STATUS      nstatRetVal = 0;
  DFS_INFO_102      DfsInfoLevel102;

        // Set timeout = 0 to flush local PKT.
  DfsInfoLevel102.Timeout = 0;

        // Display hour glass.
  CWaitCursor WaitCursor;

  nstatRetVal = NetDfsSetClientInfo(
                    m_bstrEntryPath,
                    NULL,
                    NULL,
                    102,
                    (LPBYTE) &DfsInfoLevel102
                   );

  if (nstatRetVal != NERR_Success)
    DisplayMessageBoxForHR(HRESULT_FROM_WIN32(nstatRetVal));

  return(true);
}

void
CDfsShellExtProp::_UpdateTextForReplicaState(
    IN HWND                   hwndControl,
    IN int                    nIndex,
    IN enum SHL_DFS_REPLICA_STATE ReplicaState
)
{
  LVITEM    lvi = {0};

  lvi.iItem = nIndex;
  lvi.mask  = LVIF_TEXT;

  // insert the 2nd column "Active"
  lvi.iSubItem = 1;
  if (ReplicaState == SHL_DFS_REPLICA_STATE_ACTIVE_UNKNOWN ||
      ReplicaState == SHL_DFS_REPLICA_STATE_ACTIVE_OK ||
      ReplicaState == SHL_DFS_REPLICA_STATE_ACTIVE_UNREACHABLE )
    lvi.pszText  = m_bstrAlternateListYes;
  else
    lvi.pszText  = m_bstrAlternateListNo;

  ListView_SetItem(hwndControl, &lvi);

  // insert the 3rd column "Status"
  lvi.iSubItem = 2;
  switch (ReplicaState)
  {
  case SHL_DFS_REPLICA_STATE_ACTIVE_UNKNOWN:
  case SHL_DFS_REPLICA_STATE_UNKNOWN:
    lvi.pszText  = _T("");
    break;
  case SHL_DFS_REPLICA_STATE_ACTIVE_OK:
  case SHL_DFS_REPLICA_STATE_OK:
    lvi.pszText  = m_bstrAlternateListOK;
    break;
  case SHL_DFS_REPLICA_STATE_ACTIVE_UNREACHABLE:
  case SHL_DFS_REPLICA_STATE_UNREACHABLE:
    lvi.pszText  = m_bstrAlternateListUnreachable;
    break;
  }
  ListView_SetItem(hwndControl, &lvi);
}

void
CDfsShellExtProp::_SetAlternateList()
/*++
Routine Description:
  Finds out if the given path is a Dfs Path, and if it is
  then finds out the alternates available for this path up to
  the last directory. These are then added to the alternate list.
*/
{
  HWND hwndControl = ::GetDlgItem(m_hWnd, IDC_ALTERNATE_LIST);

  if (NULL == ((CDfsShell *)m_pIShProp)->m_ppDfsAlternates)
    return;

  //
  // calculate the listview column width
  //
  RECT      rect;
  ZeroMemory(&rect, sizeof(rect));
  ::GetWindowRect(hwndControl, &rect);
  int nControlWidth = rect.right - rect.left;
  int nVScrollbarWidth = GetSystemMetrics(SM_CXVSCROLL);
  int nBorderWidth = GetSystemMetrics(SM_CXBORDER);
  int nControlNetWidth = nControlWidth - nVScrollbarWidth - 4 * nBorderWidth;
  int nWidth1 = nControlNetWidth / 2;
  int nWidth2 = nControlNetWidth / 4;
  int nWidth3 = nControlNetWidth - nWidth1 - nWidth2;

  //
  // insert columns
  //
  LV_COLUMN col;
  ZeroMemory(&col, sizeof(col));
  col.mask = LVCF_TEXT | LVCF_WIDTH;
  col.cx = nWidth1;
  col.pszText = m_bstrAlternateListPath;
  ListView_InsertColumn(hwndControl, 0, &col);
  col.cx = nWidth2;
  col.pszText = m_bstrAlternateListActive;
  ListView_InsertColumn(hwndControl, 1, &col);
  col.cx = nWidth3;
  col.pszText = m_bstrAlternateListStatus;
  ListView_InsertColumn(hwndControl, 2, &col);

  //
  // Set full row selection style
  //
  ListView_SetExtendedListViewStyleEx(hwndControl, LVS_EX_FULLROWSELECT, LVS_EX_FULLROWSELECT);

                  // For each alternate stored in the parent shell object
                  // add to list.
  for (int i = 0; NULL != ((CDfsShell *)m_pIShProp)->m_ppDfsAlternates[i] ; i++)
  {
    int       nIndex = 0;
    LVITEM    lvi = {0};

    lvi.mask   = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
    lvi.pszText  = (((CDfsShell *)m_pIShProp)->m_ppDfsAlternates[i])->bstrAlternatePath;
    lvi.iImage   = (((CDfsShell *)m_pIShProp)->m_ppDfsAlternates[i])->ReplicaState;
    lvi.lParam   = (LPARAM)(((CDfsShell *)m_pIShProp)->m_ppDfsAlternates[i]);
    lvi.iSubItem = 0;

                  // Select the active replica.
    switch ((((CDfsShell *)m_pIShProp)->m_ppDfsAlternates[i])->ReplicaState)
    {
    case SHL_DFS_REPLICA_STATE_ACTIVE_UNKNOWN:
    case SHL_DFS_REPLICA_STATE_ACTIVE_OK:
    case SHL_DFS_REPLICA_STATE_ACTIVE_UNREACHABLE:
      lvi.mask |= LVIF_STATE;
      lvi.state = LVIS_SELECTED | LVIS_FOCUSED;
      nIndex = ListView_InsertItem(hwndControl, &lvi);
      break;
    case SHL_DFS_REPLICA_STATE_UNKNOWN:
    case SHL_DFS_REPLICA_STATE_OK:
    case SHL_DFS_REPLICA_STATE_UNREACHABLE:
      nIndex = ListView_InsertItem(hwndControl, &lvi);
      break;
    default:
      _ASSERT(FALSE);
      break;
    }

    _UpdateTextForReplicaState(hwndControl, nIndex, (((CDfsShell *)m_pIShProp)->m_ppDfsAlternates[i])->ReplicaState);
  }
}

HRESULT
CDfsShellExtProp::_SetImageList(
  )
/*++
Routine Description:
  Create and initialize the Imagelist for alternates.
--*/
{
                // Load bitmap from resource
  HBITMAP hBitmap = (HBITMAP)LoadImage(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDB_Replica),
                IMAGE_BITMAP, 0, 0, LR_SHARED | LR_LOADTRANSPARENT);
  if(!hBitmap)
    return HRESULT_FROM_WIN32(GetLastError());;

                // Try and get the exact bitmap size and number of bitmaps for
                // image list
  int      icxBitmap = 16;
  int      icyBitmap = 16;
  int      iNoOfBitmaps = 6;
  BITMAP   bmpRec;
  if (GetObject(hBitmap, sizeof(bmpRec), &bmpRec))
  {
    if (bmpRec.bmHeight > 0)
    {
      icyBitmap = bmpRec.bmHeight;
                // Since the bitmaps are squares
      icxBitmap = icyBitmap;
                // Since all the bitmaps are in a line in the original bitmap
      iNoOfBitmaps = bmpRec.bmWidth / bmpRec.bmHeight;
    }
  }

                // Create the image list
  HIMAGELIST hImageList = ImageList_Create(icxBitmap, icyBitmap, ILC_COLOR, iNoOfBitmaps, 0);
  if (NULL == hImageList)
  {
    DeleteObject(hBitmap);
    return E_FAIL;
  }

  ImageList_Add(hImageList, hBitmap, (HBITMAP)NULL);

  // The specified image list will be destroyed when the list view control is destroyed.
  SendDlgItemMessage( IDC_ALTERNATE_LIST, LVM_SETIMAGELIST, LVSIL_SMALL, (LPARAM)hImageList);

  DeleteObject(hBitmap);

  return S_OK;
}

LRESULT
CDfsShellExtProp::OnNotify(
  IN UINT            i_uMsg,
  IN WPARAM          i_wParam,
  IN LPARAM          i_lParam,
  IN OUT BOOL&        io_bHandled
  )
/*++
Routine Description:
  Notify message for user actions. We handle only the mouse double click right now

Arguments:
  i_lParam  -  Details about the control sending the notify
  io_bHandled  -  Whether we handled this message or not.
--*/
{
    io_bHandled = FALSE;  // So that the base class gets this notify too

    NMHDR*    pNMHDR = (NMHDR*)i_lParam;
    if (!pNMHDR)
        return FALSE;

    if (IDC_ALTERNATE_LIST == pNMHDR->idFrom)
    {
        if (NM_DBLCLK == pNMHDR->code)
        {
            SetActive();
        } else if (LVN_ITEMCHANGED == pNMHDR->code)
        {
            int n = ListView_GetSelectedCount(GetDlgItem(IDC_ALTERNATE_LIST));
            ::EnableWindow(GetDlgItem(IDC_SET_ACTIVE), (n == 1));
        }
    }

    return TRUE;
}

BOOL
CDfsShellExtProp::SetActive()
/*++
Routine Description:
  Sets the first selected alternate to be active.
--*/
{
    HWND  hwndAlternateLV = GetDlgItem(IDC_ALTERNATE_LIST);
    int iSelected = ListView_GetNextItem(hwndAlternateLV, -1, LVNI_ALL | LVNI_SELECTED);
    if (-1 == iSelected)
        return FALSE; // nothing selected

    LV_ITEM  lvItem = {0};
    lvItem.mask  = LVIF_PARAM;
    lvItem.iItem = iSelected;

    ListView_GetItem(hwndAlternateLV, &lvItem);

    LPDFS_ALTERNATES  pDfsAlternate = (LPDFS_ALTERNATES)lvItem.lParam;
    if (!pDfsAlternate )
        return(FALSE);

    // set the item to be active
    DFS_INFO_101  DfsInfo101 = {0};
    DfsInfo101.State = DFS_STORAGE_STATE_ACTIVE;
    NET_API_STATUS  nstatRetVal = NetDfsSetClientInfo(
                    m_bstrEntryPath,
                    pDfsAlternate->bstrServer,
                    pDfsAlternate->bstrShare,
                    101,
                    (LPBYTE) &DfsInfo101
                   );

    if (nstatRetVal != NERR_Success)
    {
        DisplayMessageBoxForHR(HRESULT_FROM_WIN32(nstatRetVal));
        return FALSE;
    }

                // Reset the image of the last Active alternate/s to normal.
    int nIndex = -1;
    while ((nIndex = ListView_GetNextItem(hwndAlternateLV, nIndex, LVNI_ALL)) != -1)
    {
        ZeroMemory(&lvItem, sizeof(lvItem));
        lvItem.mask  = LVIF_PARAM;
        lvItem.iItem = nIndex;

        ListView_GetItem(hwndAlternateLV, &lvItem);

        LPDFS_ALTERNATES  pTempDfsAlternate = (LPDFS_ALTERNATES)lvItem.lParam;

        BOOL bActive = TRUE;
        switch (pTempDfsAlternate->ReplicaState)
        {
        case SHL_DFS_REPLICA_STATE_ACTIVE_UNKNOWN:
            pTempDfsAlternate->ReplicaState = SHL_DFS_REPLICA_STATE_UNKNOWN;
            break;
        case SHL_DFS_REPLICA_STATE_ACTIVE_OK:
            pTempDfsAlternate->ReplicaState = SHL_DFS_REPLICA_STATE_OK;
            break;
        case SHL_DFS_REPLICA_STATE_ACTIVE_UNREACHABLE:
            pTempDfsAlternate->ReplicaState = SHL_DFS_REPLICA_STATE_UNREACHABLE;
            break;
        case SHL_DFS_REPLICA_STATE_UNKNOWN:
        case SHL_DFS_REPLICA_STATE_OK:
        case SHL_DFS_REPLICA_STATE_UNREACHABLE:
        default:
            bActive = FALSE;
            break;
        }

        if (bActive)
        {
            lvItem.mask = LVIF_IMAGE | LVIF_STATE;
            lvItem.state = LVIS_SELECTED | LVIS_FOCUSED;
            lvItem.iImage = pTempDfsAlternate->ReplicaState;
            ListView_SetItem(hwndAlternateLV,&lvItem);
            _UpdateTextForReplicaState(hwndAlternateLV, nIndex, pTempDfsAlternate->ReplicaState);

            break;
        }
    }


    // set the new active alternate
    BOOL bActive = FALSE;
    switch (pDfsAlternate->ReplicaState)
    {
    case SHL_DFS_REPLICA_STATE_UNKNOWN:
        pDfsAlternate->ReplicaState = SHL_DFS_REPLICA_STATE_ACTIVE_UNKNOWN;
        break;
    case SHL_DFS_REPLICA_STATE_OK:
        pDfsAlternate->ReplicaState = SHL_DFS_REPLICA_STATE_ACTIVE_OK;
        break;
    case SHL_DFS_REPLICA_STATE_UNREACHABLE:
        pDfsAlternate->ReplicaState = SHL_DFS_REPLICA_STATE_ACTIVE_UNREACHABLE;
        break;
    case SHL_DFS_REPLICA_STATE_ACTIVE_UNKNOWN:
    case SHL_DFS_REPLICA_STATE_ACTIVE_OK:
    case SHL_DFS_REPLICA_STATE_ACTIVE_UNREACHABLE:
    default:
        bActive = TRUE;
        break;
    }

    if (!bActive)
    {
        lvItem.iItem = iSelected;
        lvItem.mask = LVIF_IMAGE;
        lvItem.iImage = pDfsAlternate->ReplicaState;
        ListView_SetItem(hwndAlternateLV,&lvItem);
        _UpdateTextForReplicaState(hwndAlternateLV, iSelected, pDfsAlternate->ReplicaState);
    }

    return TRUE;
}

/*++
This function is called when a user clicks the ? in the top right of a property sheet
 and then clciks a control, or when they hit F1 in a control.
--*/
LRESULT CDfsShellExtProp::OnCtxHelp(
    IN UINT          i_uMsg,
    IN WPARAM        i_wParam,
    IN LPARAM        i_lParam,
    IN OUT BOOL&     io_bHandled
  )
{
  LPHELPINFO lphi = (LPHELPINFO) i_lParam;
  if (!lphi || lphi->iContextType != HELPINFO_WINDOW || lphi->iCtrlId < 0)
    return FALSE;

  ::WinHelp((HWND)(lphi->hItemHandle),
        DFS_CTX_HELP_FILE,
        HELP_WM_HELP,
        (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_DFS_SHELL_PROP);

  return TRUE;
}

/*++
This function handles "What's This" help when a user right clicks the control
--*/
LRESULT CDfsShellExtProp::OnCtxMenuHelp(
    IN UINT          i_uMsg,
    IN WPARAM        i_wParam,
    IN LPARAM        i_lParam,
    IN OUT BOOL&     io_bHandled
  )
{
  ::WinHelp((HWND)i_wParam,
        DFS_CTX_HELP_FILE,
        HELP_CONTEXTMENU,
        (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_DFS_SHELL_PROP);

  return TRUE;
}

LRESULT CDfsShellExtProp::OnCheckStatus(
    IN WORD            i_wNotifyCode,
    IN WORD            i_wID,
    IN HWND            i_hWndCtl,
    IN OUT BOOL&        io_bHandled
  )
/*++
Routine Description:
  Checks the status of all selected alternates. If it is reachable then the
  reachable icon is displayed or the unreachable icon is displayed.
--*/
{
  CWaitCursor WaitCursor;
  HWND  hwndAlternateLV = GetDlgItem(IDC_ALTERNATE_LIST);

  int nIndex = -1;
  while (-1 != (nIndex = ListView_GetNextItem(hwndAlternateLV, nIndex, LVNI_ALL | LVNI_SELECTED)))
  {
      LV_ITEM  lvItem = {0};
      lvItem.mask  = LVIF_PARAM;
      lvItem.iItem = nIndex;

      ListView_GetItem(hwndAlternateLV, &lvItem);

      LPDFS_ALTERNATES  pDfsAlternate = (LPDFS_ALTERNATES)lvItem.lParam;
      if (!pDfsAlternate )
        return(FALSE);

                  // See if the path actaully exists (reachable).
      DWORD dwErr = GetFileAttributes(pDfsAlternate->bstrAlternatePath);
      if (0xffffffff == dwErr)
      {            // We failed to get the file attributes for entry path
        switch (pDfsAlternate->ReplicaState)
        {
        case SHL_DFS_REPLICA_STATE_ACTIVE_UNKNOWN:
        case SHL_DFS_REPLICA_STATE_ACTIVE_OK:
        case SHL_DFS_REPLICA_STATE_ACTIVE_UNREACHABLE:
          pDfsAlternate->ReplicaState = SHL_DFS_REPLICA_STATE_ACTIVE_UNREACHABLE;
          break;
        case SHL_DFS_REPLICA_STATE_UNKNOWN:
        case SHL_DFS_REPLICA_STATE_OK:
        case SHL_DFS_REPLICA_STATE_UNREACHABLE:
          pDfsAlternate->ReplicaState = SHL_DFS_REPLICA_STATE_UNREACHABLE;
          break;
        default:
          _ASSERT(FALSE);
          break;
        }
      }
      else
      {
        switch (pDfsAlternate->ReplicaState)
        {
        case SHL_DFS_REPLICA_STATE_ACTIVE_UNKNOWN:
        case SHL_DFS_REPLICA_STATE_ACTIVE_OK:
        case SHL_DFS_REPLICA_STATE_ACTIVE_UNREACHABLE:
          pDfsAlternate->ReplicaState = SHL_DFS_REPLICA_STATE_ACTIVE_OK;
          break;
        case SHL_DFS_REPLICA_STATE_UNKNOWN:
        case SHL_DFS_REPLICA_STATE_OK:
        case SHL_DFS_REPLICA_STATE_UNREACHABLE:
          pDfsAlternate->ReplicaState = SHL_DFS_REPLICA_STATE_OK;
          break;
        default:
          _ASSERT(FALSE);
          break;
        }
      }

      lvItem.mask = LVIF_IMAGE;
      lvItem.iImage = pDfsAlternate->ReplicaState;
      ListView_SetItem(hwndAlternateLV,&lvItem);

      _UpdateTextForReplicaState(hwndAlternateLV, nIndex, pDfsAlternate->ReplicaState);
  }

  return TRUE;
}


LRESULT CDfsShellExtProp::OnSetActiveReferral(
    IN WORD            i_wNotifyCode,
    IN WORD            i_wID,
    IN HWND            i_hWndCtl,
    IN OUT BOOL&       io_bHandled
  )
{
    SetActive();
    return TRUE;
}

HRESULT 
LoadStringFromResource(
  IN const UINT    i_uResourceID, 
  OUT BSTR*      o_pbstrReadValue
  )
/*++

Routine Description:

This method returns a resource string.
The method no longer uses a fixed string to read the resource.
Inspiration from MFC's CString::LoadString.

Arguments:
  i_uResourceID    -  The resource id
  o_pbstrReadValue  -  The BSTR* into which the value is copied

--*/
{
  if (!o_pbstrReadValue)
      return E_INVALIDARG;

  TCHAR    szResString[1024];
  ULONG    uCopiedLen = 0;
  
  szResString[0] = NULL;
  
  // Read the string from the resource
  uCopiedLen = ::LoadString(_Module.GetModuleInstance(), i_uResourceID, szResString, 1024);

  // If nothing was copied it is flagged as an error
  if(uCopiedLen <= 0)
  {
    return HRESULT_FROM_WIN32(::GetLastError());
  }
  else
  {
    *o_pbstrReadValue = ::SysAllocString(szResString);
    if (!*o_pbstrReadValue)
      return E_OUTOFMEMORY;
  }

  return S_OK;
}

HRESULT 
GetErrorMessage(
  IN  DWORD        i_dwError,
  OUT BSTR*        o_pbstrErrorMsg
)
{
  if (0 == i_dwError || !o_pbstrErrorMsg)
    return E_INVALIDARG;

  HRESULT      hr = S_OK;
  LPTSTR       lpBuffer = NULL;

  DWORD dwRet = ::FormatMessage(
              FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
              NULL, i_dwError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
              (LPTSTR)&lpBuffer, 0, NULL);
  if (0 == dwRet)
  {
    // if no message is found, GetLastError will return ERROR_MR_MID_NOT_FOUND
    hr = HRESULT_FROM_WIN32(GetLastError());

    if (HRESULT_FROM_WIN32(ERROR_MR_MID_NOT_FOUND) == hr ||
        0x80070000 == (i_dwError & 0xffff0000) ||
        0 == (i_dwError & 0xffff0000) )
    { // Try locating the message from NetMsg.dll.
      hr = S_OK;
      DWORD dwNetError = i_dwError & 0x0000ffff;
      
      HINSTANCE  hLib = LoadLibrary(_T("netmsg.dll"));
      if (!hLib)
        hr = HRESULT_FROM_WIN32(GetLastError());
      else
      {
        dwRet = ::FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
            hLib, dwNetError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
            (LPTSTR)&lpBuffer, 0, NULL);

        if (0 == dwRet)
          hr = HRESULT_FROM_WIN32(GetLastError());

        FreeLibrary(hLib);
      }
    }
  }

  if (SUCCEEDED(hr))
  {
    *o_pbstrErrorMsg = SysAllocString(lpBuffer);
    LocalFree(lpBuffer);
  }
  else
  {
    // we failed to retrieve the error message from system/netmsg.dll,
    // report the error code directly to user
    hr = S_OK;
    TCHAR szString[32];
    _stprintf(szString, _T("0x%x"), i_dwError); 
    *o_pbstrErrorMsg = SysAllocString(szString);
  }

  if (!*o_pbstrErrorMsg)
    hr = E_OUTOFMEMORY;

  return hr;
}

int
DisplayMessageBox(
  IN HWND hwndParent,
  IN UINT uType,    // style of message box
  IN DWORD dwErr,
  IN UINT iStringId, // OPTIONAL: String resource Id
  ...)        // Optional arguments
{
  _ASSERT(dwErr != 0 || iStringId != 0);    // One of the parameter must be non-zero

  HRESULT hr = S_OK;

  TCHAR szCaption[1024], szString[1024];
  CComBSTR bstrErrorMsg, bstrResourceString, bstrMsg;

  ::LoadString(_Module.GetModuleInstance(), IDS_APPLICATION_NAME, 
               szCaption, sizeof(szCaption)/sizeof(TCHAR));

  if (dwErr)
    hr = GetErrorMessage(dwErr, &bstrErrorMsg);

  if (SUCCEEDED(hr))
  {
    if (iStringId == 0)
    {
      bstrMsg = bstrErrorMsg;
    }
    else
    {
      ::LoadString(_Module.GetModuleInstance(), iStringId, 
                   szString, sizeof(szString)/sizeof(TCHAR));

      va_list arglist;
      va_start(arglist, iStringId);
      LPTSTR lpBuffer = NULL;
      DWORD dwRet = ::FormatMessage(
                        FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                        szString,
                        0,                // dwMessageId
                        0,                // dwLanguageId, ignored
                        (LPTSTR)&lpBuffer,
                        0,            // nSize
                        &arglist);
      va_end(arglist);

      if (dwRet == 0)
      {
        hr = HRESULT_FROM_WIN32(GetLastError());
      }
      else
      {
        bstrMsg = lpBuffer;
        if (dwErr)
          bstrMsg += bstrErrorMsg;
  
        LocalFree(lpBuffer);
      }
    }
  }

  if (FAILED(hr))
  {
   // Failed to retrieve the proper message, report the failure directly to user
    _stprintf(szString, _T("0x%x"), hr); 
    bstrMsg = szString;
  }

  return ::MessageBox(hwndParent, bstrMsg, szCaption, uType);
}

HRESULT 
DisplayMessageBoxForHR(
  IN HRESULT    i_hr
  )
{
    DisplayMessageBox(::GetActiveWindow(), MB_OK, i_hr, 0);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsshlex\dfsshprp.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    DfsShPrp.h

Abstract:

    This module contains the declaration for CDfsShellExtProp
  This is used to implement the property page for Shell Extension.

Author:

    Constancio Fernandes (ferns@qspl.stpp.soft.net) 12-Jan-1998

Environment:
    
    NT Only.

Revision History:

--*/

#ifndef _DFS_EXT_PROP_SHEET_H_
#define _DFS_EXT_PROP_SHEET_H_

#include "dfsenums.h"
#include "qwizpage.h"      // The base class that implements the common functionality  
                // of property and wizard pages
// ----------------------------------------------------------------------------
// CDfsShellExtProp: Property Sheet Page for Shell Extension

class CDfsShellExtProp : public CQWizardPageImpl<CDfsShellExtProp>
{
public:
  enum { IDD = IDD_DFS_SHELL_PROP };
  
  BEGIN_MSG_MAP(CDfsShellExtProp)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER(WM_PARENT_NODE_CLOSING, OnParentClosing)
    MESSAGE_HANDLER(WM_HELP, OnCtxHelp)
    MESSAGE_HANDLER(WM_CONTEXTMENU, OnCtxMenuHelp)
    MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
    COMMAND_ID_HANDLER(IDC_FLUSH_PKT, OnFlushPKT)
    COMMAND_ID_HANDLER(IDC_CHECK_STATUS, OnCheckStatus)
    COMMAND_ID_HANDLER(IDC_SET_ACTIVE, OnSetActiveReferral)
    CHAIN_MSG_MAP(CQWizardPageImpl<CDfsShellExtProp>)
  END_MSG_MAP()
  
  CDfsShellExtProp();
  ~CDfsShellExtProp();

  LRESULT OnInitDialog(
    IN UINT          i_uMsg, 
    IN WPARAM        i_wParam, 
    IN LPARAM        i_lParam, 
    IN OUT BOOL&     io_bHandled
    );

  // Used by the node to tell the propery page to close.
  LRESULT OnParentClosing(
    IN UINT          i_uMsg, 
    IN WPARAM        i_wParam, 
    IN LPARAM        i_lParam, 
    IN OUT BOOL&     io_bHandled
    );

  LRESULT OnCtxHelp(
    IN UINT          i_uMsg, 
    IN WPARAM        i_wParam, 
    IN LPARAM        i_lParam, 
    IN OUT BOOL&     io_bHandled
    );

  LRESULT OnCtxMenuHelp(
    IN UINT          i_uMsg, 
    IN WPARAM        i_wParam, 
    IN LPARAM        i_lParam, 
    IN OUT BOOL&     io_bHandled
    );

  // Called to pass notifications.
  LRESULT OnNotify(
    IN UINT            i_uMsg, 
    IN WPARAM          i_wParam, 
    IN LPARAM          i_lParam, 
    IN OUT BOOL&       io_bHandled
    );

  LRESULT OnFlushPKT(
    IN WORD            i_wNotifyCode, 
    IN WORD            i_wID, 
    IN HWND            i_hWndCtl, 
    IN OUT BOOL&       io_bHandled
  );

  LRESULT OnCheckStatus(
    IN WORD            i_wNotifyCode, 
    IN WORD            i_wID, 
    IN HWND            i_hWndCtl, 
    IN OUT BOOL&       io_bHandled
    );

  LRESULT OnSetActiveReferral(
    IN WORD            i_wNotifyCode, 
    IN WORD            i_wID, 
    IN HWND            i_hWndCtl, 
    IN OUT BOOL&       io_bHandled
    );

  // Getters and Setters
  HRESULT  put_DfsShellPtr(
    IN IShellPropSheetExt*  i_pDfsShell
    );

  HRESULT put_DirPaths(
    IN BSTR          i_bstrDirPath,
    IN BSTR          i_bstrEntryPath
    );

  LRESULT OnApply();

  // Called when the property page gets deleted.
  void Delete();

  // Called when user double clicks an entry to make that alternate active.
  BOOL SetActive();

// helper functions

private:
  HRESULT _SetImageList();
  void _SetAlternateList();
  void _UpdateTextForReplicaState(
    IN HWND                   hwndControl,
    IN int                    nIndex,
    IN enum SHL_DFS_REPLICA_STATE ReplicaState
  );

private:
  CComBSTR      m_bstrDirPath;
  CComBSTR      m_bstrEntryPath;
  IShellPropSheetExt*  m_pIShProp;  
  CComBSTR  m_bstrAlternateListPath,
            m_bstrAlternateListActive,
            m_bstrAlternateListStatus,
            m_bstrAlternateListYes,
            m_bstrAlternateListNo,
            m_bstrAlternateListOK,
            m_bstrAlternateListUnreachable;

};

HRESULT LoadStringFromResource(
    IN const UINT    i_uResourceID,
    OUT BSTR*      o_pbstrReadValue
    );

HRESULT DisplayMessageBoxForHR(HRESULT i_hr);

#endif // _DFS_EXT_PROP_SHEET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\aclpage.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       aclpage.cpp
//
//--------------------------------------------------------------------------


// ACLPAGE.CPP
#include "preDNSsn.h"
#include <snapbase.h>

#ifdef DEBUG_ALLOCATOR
	#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
	#endif
#endif

#include <aclpag_.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsshlex\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__ECCDF539_45CC_11CE_B9BF_0080C87CDBA6__INCLUDED_)
#define AFX_STDAFX_H__ECCDF539_45CC_11CE_B9BF_0080C87CDBA6__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <shellapi.h>
#include <atlwin.h>
#include <commctrl.h>		// For using controls
#include <shlobj.h>

	// CWaitCursor: A class that sets the cursor to wait in the ctor and arrow in the dtor
class CWaitCursor
{
public:

HRESULT SetStandardCursor(IN LPCTSTR i_lpCursorName)
	{
		if (NULL == i_lpCursorName)
			return(E_INVALIDARG);


		HCURSOR	m_hcur = ::LoadCursor(NULL, i_lpCursorName);
		if (NULL == m_hcur)
			return(E_INVALIDARG);

		// Hide the cursor, change it and show it again
		::ShowCursor(FALSE);
			SetCursor(m_hcur);
		::ShowCursor(TRUE);


		return S_OK;
	}

	CWaitCursor() { SetStandardCursor(IDC_WAIT); };
	~CWaitCursor() { SetStandardCursor(IDC_ARROW); };
};


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
	
#endif // !defined(AFX_STDAFX_H__ECCDF539_45CC_11CE_B9BF_0080C87CDBA6__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\browser.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       browser.cpp
//
//--------------------------------------------------------------------------


#include "preDNSsn.h"
#include <SnapBase.h>

#include "resource.h"
#include "dnsutil.h"
#include "DNSSnap.h"
#include "snapdata.h"

#include "server.h"
#include "domain.h"
#include "record.h"
#include "zone.h"

#include "browser.h"

#ifdef DEBUG_ALLOCATOR
	#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
	#endif
#endif

/////////////////////////////////////////////////////////////////////////////////
#define N_TOOLBAR_COMMAND_GO_UP IDC_TOOLBAR_CTRL

////////////////////////////////////////////////////////////////////////
// CDNSComboBoxEx

inline HIMAGELIST CDNSComboBoxEx::SetImageList(HIMAGELIST himl)
{
	ASSERT(::IsWindow(m_hWnd));
   return (HIMAGELIST) ::SendMessage(m_hWnd, CBEM_SETIMAGELIST,
		    0, (LPARAM)himl);
}

inline int CDNSComboBoxEx::GetCount() const
{
	ASSERT(::IsWindow(m_hWnd));
	return (int)::SendMessage(m_hWnd, CB_GETCOUNT, 0, 0);
}

inline int CDNSComboBoxEx::GetCurSel() const
{
	ASSERT(::IsWindow(m_hWnd));
	return (int)::SendMessage(m_hWnd, CB_GETCURSEL, 0, 0);
}


inline int CDNSComboBoxEx::SetCurSel(int nSelect)
{
	ASSERT(::IsWindow(m_hWnd));
	return (int)::SendMessage(m_hWnd, CB_SETCURSEL, nSelect, 0);
}

inline int CDNSComboBoxEx::InsertItem(const COMBOBOXEXITEM* pItem)
{
	ASSERT(::IsWindow(m_hWnd));
	return (int) ::SendMessage(m_hWnd, CBEM_INSERTITEM, 0, (LPARAM)pItem);
}


LPARAM CDNSComboBoxEx::GetItemData(int nIndex) const
{
  COMBOBOXEXITEM item;
  item.iItem = nIndex;
  item.mask = CBEIF_LPARAM;

  ASSERT(::IsWindow(m_hWnd));
  if (::SendMessage(m_hWnd, CBEM_GETITEM, 0, (LPARAM)&item))
  {
    return item.lParam;
  }
	return NULL;
}

BOOL CDNSComboBoxEx::SetItemData(int nIndex, LPARAM lParam)
{
  COMBOBOXEXITEM item;
  item.iItem = nIndex;
  item.mask = CBEIF_LPARAM;
  item.lParam = lParam;

  ASSERT(::IsWindow(m_hWnd));
  return (::SendMessage(m_hWnd, CBEM_SETITEM, 0, (LPARAM)&item) != 0);
}

inline void CDNSComboBoxEx::ResetContent()
{
	ASSERT(::IsWindow(m_hWnd));
	::SendMessage(m_hWnd, CB_RESETCONTENT, 0, 0);
}



inline DWORD CDNSComboBoxEx::GetExtendedStyle() const
{
	ASSERT(::IsWindow(m_hWnd));
	return (DWORD) ::SendMessage(m_hWnd, CBEM_GETEXSTYLE, 0, 0);
}

inline DWORD CDNSComboBoxEx::SetExtendedStyle(DWORD dwExMask, DWORD dwExStyle)
{
	ASSERT(::IsWindow(m_hWnd));
	return (DWORD) ::SendMessage(m_hWnd, CBEM_SETEXSTYLE, (WPARAM)dwExMask, (LPARAM)dwExStyle);
}


inline BOOL CDNSComboBoxEx::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT)
{
	return CreateEx(0,				// extended style
					WC_COMBOBOXEX, // window class
					NULL,			// window name
					dwStyle,		// window style
					rect.left, rect.top, // x,y
					rect.right - rect.left, rect.bottom - rect.top, // width, height
					pParentWnd->GetSafeHwnd(), // parent window
					NULL, // menu
					NULL);	 // lpParam for window creation
}



//////////////////////////////////////////////////////////////////////////
// CDNSBrowseItem

inline int CDNSBrowseItem::GetImageIndex(BOOL bOpenImage)
{
	if (m_pTreeNode == NULL)
		return 0; // error
	return m_pTreeNode->GetImageIndex(bOpenImage);
}

inline LPCWSTR CDNSBrowseItem::GetString(int nCol)
{
	if (m_pTreeNode == NULL)
		return L"ERROR"; // error
	return m_pTreeNode->GetString(nCol);
}

inline BOOL CDNSBrowseItem::AddChild(CDNSBrowseItem* pChildBrowseItem)
{
	ASSERT(m_pTreeNode != NULL);
	if (!m_pTreeNode->IsContainer())
		return FALSE;
	pChildBrowseItem->m_pParent = this;
	m_childList.AddTail(pChildBrowseItem);
	return TRUE;
}


inline BOOL CDNSBrowseItem::IsContainer()
{
	ASSERT(m_pTreeNode != NULL);
	return m_pTreeNode->IsContainer();
}

BOOL CDNSBrowseItem::RemoveChildren(CDNSBrowseItem* pNotThisItem)
{
	BOOL bFound = FALSE;
	while (!m_childList.IsEmpty())
	{
		CDNSBrowseItem* pItem = m_childList.RemoveTail();
		ASSERT(pItem != NULL);
		if (pItem == pNotThisItem)
		{
			ASSERT(!bFound);
			bFound = TRUE;
		}
		else
		{
			delete pItem;
		}
	}
	if (bFound)
	{
		m_childList.AddTail(pNotThisItem);
	}
	return bFound;
}


void CDNSBrowseItem::AddTreeNodeChildren(CDNSFilterCombo* pFilter,
						                             CComponentDataObject*)
{
	ASSERT(m_pTreeNode != NULL);
	if (!m_pTreeNode->IsContainer())
		return;
	
	CContainerNode* pContNode = (CContainerNode*)m_pTreeNode;
	CNodeList* pChildList = pContNode->GetContainerChildList();
	POSITION pos;
	for (pos = pChildList->GetHeadPosition(); pos != NULL; )
	{
		CTreeNode* pCurrChildNode = pChildList->GetNext(pos);
		if (pFilter->IsValidTreeNode(pCurrChildNode))
		{
			CDNSBrowseItem* pItem = new CDNSBrowseItem;
         if (pItem)
         {
			   pItem->SetTreeNode(pCurrChildNode);
			   AddChild(pItem);
         }
		}
	}

	pChildList = pContNode->GetLeafChildList();
	POSITION pos2;
	for (pos2 = pChildList->GetHeadPosition(); pos2 != NULL; )
	{
		CTreeNode* pCurrChildNode = pChildList->GetNext(pos2);
		if (pFilter->IsValidTreeNode(pCurrChildNode))
		{
			CDNSBrowseItem* pItem = new CDNSBrowseItem;
         if (pItem)
         {
			   pItem->SetTreeNode(pCurrChildNode);
			   AddChild(pItem);
         }
		}
	}

}

void CDNSBrowseItem::AddToContainerCombo(CDNSCurrContainerCombo* pCtrl,
									CDNSBrowseItem* pSelectedBrowseItem,
									int nIndent,int* pNCurrIndex)
{
	// add itself
	pCtrl->InsertBrowseItem(this, *pNCurrIndex, nIndent);
	if (this == pSelectedBrowseItem)
	{
		pCtrl->SetCurSel(*pNCurrIndex);
		return;
	}

	m_nIndex = *pNCurrIndex; // index in the combobox, for lookup
	(*pNCurrIndex)++;

	// depth first on children
	POSITION pos;
	for( pos = m_childList.GetHeadPosition(); pos != NULL; )
	{
		CDNSBrowseItem* pCurrentChild = m_childList.GetNext(pos);
		if (pCurrentChild->IsContainer())
			pCurrentChild->AddToContainerCombo(pCtrl, pSelectedBrowseItem,
									(nIndent+1), pNCurrIndex);
	}
}



//////////////////////////////////////////////////////////////////////////
// CDNSFilterCombo

BOOL CDNSFilterCombo::Initialize(UINT nCtrlID, UINT nIDFilterString, CDNSBrowserDlg* pDlg)
{
	ASSERT(m_option != LAST); // must have a filter selected

	if (!SubclassDlgItem(nCtrlID,pDlg))
		return FALSE;

	// load string with '\n' separated string options
	int nMaxLen = 512;
	WCHAR* szBuf = 0;
  
  szBuf = (WCHAR*)malloc(sizeof(WCHAR)*nMaxLen);
  if (!szBuf)
  {
    return FALSE;
  }

	if ( ::LoadString(_Module.GetModuleInstance(), nIDFilterString, szBuf, nMaxLen) == 0)
  {
    free(szBuf);
		return FALSE;
  }

	// parse and get an array of pointers to each potential
	// entry in the combobox
	LPWSTR* lpszArr = 0;
  lpszArr = (LPWSTR*)malloc(sizeof(LPWSTR*)*nMaxLen);
  if (!lpszArr)
  {
    free(szBuf);
    return FALSE;
  }

	UINT nArrEntries;
	ParseNewLineSeparatedString(szBuf,lpszArr, &nArrEntries);

	// determine which entries are actually inserted
	int nEntry = 0;
	int nSelEntry = -1;
	for (UINT k=0; k<nArrEntries; k++)
	{
		if (CanAddToUIString(k))
		{
			if (k == (UINT)m_option)
				nSelEntry = nEntry;
			AddString(lpszArr[k]);
			SetItemData(nEntry,(DWORD)k);
			nEntry++;
		}
	}
	ASSERT( (nSelEntry > -1) && (nSelEntry < nEntry));
	SetCurSel(nSelEntry);

  if (szBuf)
  {
    free(szBuf);
  }

  if (lpszArr)
  {
    free(lpszArr);
  }
	return TRUE;
}

void CDNSFilterCombo::OnSelectionChange()
{
	int nSel = GetCurSel();
	ASSERT(nSel != -1);
	if (nSel == -1)
		return;
	ASSERT(((DNSBrowseFilterOptionType)nSel) <= LAST);
	m_option = (DNSBrowseFilterOptionType)GetItemData(nSel);
}

BOOL CDNSFilterCombo::CanAddToUIString(UINT n)
{
	switch(m_option)
	{
	case SERVER:
		return (n == (UINT)SERVER);
	case ZONE_FWD:
		return (n == (UINT)ZONE_FWD);
	case ZONE_REV:
		return (n == (UINT)ZONE_REV);
	case RECORD_A:
		return (n == (UINT)RECORD_A) || (n == (UINT)RECORD_ALL);
	case RECORD_CNAME:
		return (n == (UINT)RECORD_CNAME) || (n == (UINT)RECORD_ALL);
	case RECORD_A_AND_CNAME:
		return (n == (UINT)RECORD_A) ||
				(n == (UINT)RECORD_CNAME) ||
				(n == (UINT)RECORD_A_AND_CNAME) ||
				(n == (UINT)RECORD_ALL);
	case RECORD_RP:
		return (n == (UINT)RECORD_RP) || (n == (UINT)RECORD_ALL);
	case RECORD_TEXT:
		return (n == (UINT)RECORD_TEXT) || (n == (UINT)RECORD_ALL);
	case RECORD_MB:
		return (n == (UINT)RECORD_MB) || (n == (UINT)RECORD_ALL);
	case RECORD_ALL:
		return (n == (UINT)RECORD_ALL);
	};
	return FALSE;
}

BOOL CDNSFilterCombo::IsValidTreeNode(CTreeNode* pTreeNode)
{
	BOOL bValid = FALSE; // by default, filter out
	if (pTreeNode->IsContainer())
	{
		if (IS_CLASS(*pTreeNode, CDNSServerNode))
		{
			if (m_szExcludeServerName.IsEmpty())
				bValid = TRUE;
			else
				bValid = m_szExcludeServerName != pTreeNode->GetDisplayName();
		}
		else if (IS_CLASS(*pTreeNode, CDNSForwardZonesNode ))
		{
			bValid = (m_option != ZONE_REV);
		}
		else if (IS_CLASS(*pTreeNode, CDNSReverseZonesNode ))
		{
			bValid = (m_option == ZONE_REV);
		}
		else if (IS_CLASS(*pTreeNode, CDNSZoneNode))
		{
			bValid = TRUE; // already screened at the auth. zones folder
		}
		else if (IS_CLASS(*pTreeNode, CDNSDomainNode))
		{
			// zone filtering stops at the zone level
			bValid = (m_option != ZONE_FWD) && (m_option != ZONE_REV);
		}
	}
	else // it is a record or a root hints or forwarder node
	{		
      // This will see if we have a record node.  If so, continue on. If not,
      // return false

      CDNSRecordNodeBase* pRecordNode = dynamic_cast<CDNSRecordNodeBase*>(pTreeNode);
      if (pRecordNode)
      {
		   WORD wType = pRecordNode->GetType();
		   switch(m_option)
		   {
		   case RECORD_A:
			   bValid = (wType == DNS_TYPE_A);
			   break;
		   case RECORD_CNAME:
			   bValid = (wType == DNS_TYPE_CNAME);
			   break;
		   case RECORD_A_AND_CNAME:
			   bValid = (wType == DNS_TYPE_A) || (wType == DNS_TYPE_CNAME);
			   break;
		   case RECORD_RP:
			   bValid = (wType == DNS_TYPE_RP);
			   break;
		   case RECORD_TEXT:
			   bValid = (wType == DNS_TYPE_TEXT);
			   break;
		   case RECORD_MB:
			   bValid = (wType == DNS_TYPE_MB);
			   break;
		   case RECORD_ALL:
			   bValid = TRUE;
		   }; // switch
      }
	} //if else
	return bValid;
}

BOOL CDNSFilterCombo::IsValidResult(CDNSBrowseItem* pBrowseItem)
{
	if (pBrowseItem == NULL)
		return FALSE;

	CTreeNode* pTreeNode = pBrowseItem->GetTreeNode();
	if (pTreeNode == NULL)
		return FALSE;

	BOOL bValid = FALSE;
	if (pTreeNode->IsContainer())
	{
		CDNSMTContainerNode* pContainer = (CDNSMTContainerNode*)pTreeNode;
		if ( (m_option == ZONE_FWD) || (m_option == ZONE_REV) )
		{
			bValid = IS_CLASS(*pContainer, CDNSZoneNode);
		}
		else if (m_option == SERVER)
		{
			bValid = IS_CLASS(*pContainer, CDNSServerNode);
		}
	}
	else // it is a record
	{
      CDNSRecordNodeBase* pRecordNode = dynamic_cast<CDNSRecordNodeBase*>(pTreeNode);
      if (pRecordNode)
      {
		   WORD wType = pRecordNode->GetType();
		   switch(m_option)
		   {
		   case RECORD_ALL:
			   bValid = TRUE;
			   break;
		   case RECORD_A:
			   bValid = (wType == DNS_TYPE_A);
			   break;
		   case RECORD_CNAME:
			   bValid = (wType == DNS_TYPE_CNAME);
			   break;
		   case RECORD_A_AND_CNAME:
			   bValid = (wType == DNS_TYPE_A) || (wType == DNS_TYPE_CNAME);
			   break;
		   case RECORD_RP:
			   bValid = (wType == DNS_TYPE_RP);
			   break;
		   case RECORD_TEXT:
			   bValid = (wType == DNS_TYPE_TEXT);
			   break;
		   case RECORD_MB:
			   bValid = (wType == DNS_TYPE_MB);
			   break;
		   };
      }
	}
	return bValid;
}

void CDNSFilterCombo::GetStringOf(CDNSBrowseItem* pBrowseItem,
									 CString& szResult)
{
	if (pBrowseItem == NULL)
		return;

	CTreeNode* pTreeNode = pBrowseItem->GetTreeNode();
	if (pTreeNode == NULL)
		return;

	if (pTreeNode->IsContainer())
	{
		CDNSMTContainerNode* pContainer = (CDNSMTContainerNode*)pTreeNode;
		if (IS_CLASS(*pTreeNode, CDNSZoneNode))
		{
			szResult = (dynamic_cast<CDNSZoneNode*>(pContainer))->GetFullName();
		}
		else if (IS_CLASS(*pTreeNode , CDNSServerNode))
		{
			szResult = pContainer->GetDisplayName();
		}
		else
		{
			szResult.Empty();
		}
	}
	else // it is a record
	{
		CDNSRecordNodeBase* pRecordNode = dynamic_cast<CDNSRecordNodeBase*>(pTreeNode);
      if (pRecordNode)
      {
		   WORD wType = pRecordNode->GetType();
		   if (wType == DNS_TYPE_MB)
		   {
			   szResult = ((CDNS_MB_RecordNode*)pRecordNode)->GetNameNodeString();
		   }
		   //else if (wType == DNS_TYPE_RP)
		   //{
		   //}
		   else
		   {
			   // for generic RR's we just get the FQDN
			   pRecordNode->GetFullName(szResult);
		   }
      }
	}
}


//////////////////////////////////////////////////////////////////////////
// CDNSCurrContainerCombo

BOOL CDNSCurrContainerCombo::Initialize(UINT nCtrlID, UINT nBitmapID, CDNSBrowserDlg* pDlg)
{
	if (!SubclassDlgItem(nCtrlID,pDlg))
		return FALSE;

	if (!m_imageList.Create(nBitmapID, 16, 1, BMP_COLOR_MASK))
		return FALSE;
	SetImageList((HIMAGELIST)m_imageList);
	return TRUE;
}

CDNSBrowseItem*	CDNSCurrContainerCombo::GetSelection()
{
  CDNSBrowseItem* pBrowseItem = NULL;
	int nSel = GetCurSel();
  if (nSel >= 0)
  {
    pBrowseItem = reinterpret_cast<CDNSBrowseItem*>(GetItemData(nSel));
  }
	return pBrowseItem;
}


void CDNSCurrContainerCombo::InsertBrowseItem(CDNSBrowseItem* pBrowseItem,
										int nIndex,
										int nIndent)
{
	ASSERT(pBrowseItem != NULL);
	LPCWSTR lpszString = pBrowseItem->GetString(N_HEADER_NAME);

	COMBOBOXEXITEM cbei;
	cbei.mask = CBEIF_TEXT | CBEIF_INDENT | CBEIF_IMAGE | CBEIF_SELECTEDIMAGE;
    // Initialize the COMBOBOXEXITEM struct.
    cbei.iItem          = nIndex;
    cbei.pszText        = (LPWSTR)lpszString;
    cbei.cchTextMax     = static_cast<int>(wcslen(lpszString));
    cbei.iImage         = pBrowseItem->GetImageIndex(FALSE);
    cbei.iSelectedImage = pBrowseItem->GetImageIndex(TRUE);
    cbei.iIndent        = nIndent;

	VERIFY(InsertItem(&cbei) != -1);
	SetItemData(nIndex,reinterpret_cast<LPARAM>(pBrowseItem));
}

void CDNSCurrContainerCombo::SetTree(CDNSBrowseItem* pRootBrowseItem,
				CDNSBrowseItem* pSelectedBrowseItem)
{
	ASSERT(pRootBrowseItem != NULL);
	ASSERT(pSelectedBrowseItem != NULL);

	// remove all the contents
	ResetContent();

	// add depth first to the listbox
	int nCurrIndex = 0;
	int nIndent = 0;
	pRootBrowseItem->AddToContainerCombo(this, pSelectedBrowseItem,
										nIndent, &nCurrIndex);
}




//////////////////////////////////////////////////////////////////////////
// CDNSChildrenListView

BOOL CDNSChildrenListView::Initialize(UINT nCtrlID, UINT nBitmapID, CDNSBrowserDlg* pDlg)
{
	m_pDlg = pDlg;
	if (!SubclassDlgItem(nCtrlID,pDlg))
		return FALSE;

	if (!m_imageList.Create(nBitmapID, 16, 1, BMP_COLOR_MASK))
		return FALSE;
   ::SendMessage(GetSafeHwnd(), LVM_SETIMAGELIST, LVSIL_SMALL, (LPARAM)(HIMAGELIST)m_imageList);

	//
	// get width of control, width of potential scrollbar, width needed for sub-item
	// string
	// get size of control to help set the column widths
	CRect controlRect;
	GetClientRect(controlRect);

	int controlWidth = controlRect.Width();
	int scrollThumbWidth = ::GetSystemMetrics(SM_CXHTHUMB);

	// clean net width
	int nNetControlWidth = controlWidth - scrollThumbWidth  -
			12 * ::GetSystemMetrics(SM_CXBORDER);

	// fields widths
	int nTotalUnscaledWidth = 0;
	for (int iCol = 0; iCol < N_DEFAULT_HEADER_COLS; iCol++)
		nTotalUnscaledWidth += _DefaultHeaderStrings[iCol].nWidth;

	// set up columns
	for (iCol = 0; iCol < N_DEFAULT_HEADER_COLS; iCol++)
	{
		int nWidth = nNetControlWidth *
			_DefaultHeaderStrings[iCol].nWidth / nTotalUnscaledWidth;
		InsertColumn(iCol,	_DefaultHeaderStrings[iCol].szBuffer,
							_DefaultHeaderStrings[iCol].nFormat,
							nWidth);
	}
	return TRUE;
}

void CDNSChildrenListView::SetChildren(CDNSBrowseItem* pBrowseItem)
{
	// clear the listview
	DeleteAllItems();
	if (pBrowseItem == NULL)
		return;

	// add all the children that satisfy the filtering option
	POSITION pos;
	int itemIndex = 0;
	CDNSBrowseItem* pSelection = NULL;
	for( pos = pBrowseItem->m_childList.GetHeadPosition(); pos != NULL; )
	{
		CDNSBrowseItem* pCurrentChild = pBrowseItem->m_childList.GetNext(pos);

		// insert the name into the list view item, clear the subitem text
		UINT nState = 0;
		if (itemIndex == 0 )
		{
			nState = LVIS_SELECTED | LVIS_FOCUSED; // have at lest one item, select it
			pSelection = pCurrentChild;
		}
		VERIFY(-1 != InsertItem(LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE,
								itemIndex,
								pCurrentChild->GetString(N_HEADER_NAME),
								nState,
								0,
								pCurrentChild->GetImageIndex(FALSE),
								(LPARAM)pCurrentChild));
		// set the text for subitems
		for (int iCol = N_HEADER_TYPE; iCol<N_DEFAULT_HEADER_COLS; iCol++)
			VERIFY(SetItemText(itemIndex, iCol, pCurrentChild->GetString(iCol)));

		// move to next index into the collection
		itemIndex++;
	}
	m_pDlg->UpdateSelectionEdit(pSelection);
	// enable/disable the OK button
	GetParent()->GetDlgItem(IDOK)->EnableWindow(FALSE);
	// enable/disable "UP" button
    m_pDlg->m_toolbar.EnableButton(N_TOOLBAR_COMMAND_GO_UP, pBrowseItem->m_pParent != NULL);
}

CDNSBrowseItem*	CDNSChildrenListView::GetSelection()
{
	int nSel = GetNextItem(-1, LVIS_SELECTED);
	return (nSel >= 0) ? (CDNSBrowseItem*)GetItemData(nSel) : NULL;
}




///////////////////////////////////////////////////////////////////////////////
// CDNSBrowserDlg



BEGIN_MESSAGE_MAP(CDNSBrowserDlg, CHelpDialog)
  ON_COMMAND(N_TOOLBAR_COMMAND_GO_UP, OnButtonUp)
  ON_NOTIFY_EX( TTN_NEEDTEXT, 0, OnTooltip)
	ON_CBN_SELCHANGE(IDC_COMBO_SEL_NODE, OnSelchangeComboSelNode)
	ON_NOTIFY(NM_DBLCLK, IDC_LIST_NODE_ITEMS, OnDblclkListNodeItems)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST_NODE_ITEMS, OnItemchangedListNodeItems)
	ON_CBN_SELCHANGE(IDC_COMBO_FILTER, OnSelchangeComboFilter)
END_MESSAGE_MAP()


CDNSBrowserDlg::CDNSBrowserDlg(CComponentDataObject* pComponentDataObject,
							   CPropertyPageHolderBase* pHolder,
							   DNSBrowseFilterOptionType option, BOOL bEnableEdit,
							   LPCTSTR lpszExcludeServerName)
	: CHelpDialog(IDD_BROWSE_DIALOG, pComponentDataObject)
{
	ASSERT(pComponentDataObject != NULL);
	m_pComponentDataObject = pComponentDataObject;
	m_pHolder = pHolder;
	m_filter.Set(option, lpszExcludeServerName);
	m_bEnableEdit = bEnableEdit;

	// point to the DNS snapin static folder
	m_pMasterRootNode = m_pComponentDataObject->GetRootData();

	// create a browse root item
	m_pBrowseRootItem = new CDNSBrowseItem;
   if (m_pBrowseRootItem)
   {
	   m_pBrowseRootItem->SetTreeNode(m_pMasterRootNode);
   }

	m_pCurrSelContainer = NULL;
	m_pFinalSelection = NULL;
}

INT_PTR CDNSBrowserDlg::DoModal()
{
	// make sure commoncontrolex initialized (for ComboBoxEx)
  INITCOMMONCONTROLSEX icex;
  icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
  icex.dwICC = ICC_USEREX_CLASSES;
  if (!InitCommonControlsEx(&icex))
    return -1;

  return CHelpDialog::DoModal();
}

void CDNSBrowserDlg::OnCancel()
{
	if (m_pHolder != NULL)
		m_pHolder->PopDialogHWnd();
	CHelpDialog::OnCancel();
}

CDNSBrowserDlg::~CDNSBrowserDlg()
{
	if (m_pBrowseRootItem != NULL)
	{
		delete m_pBrowseRootItem;
		m_pBrowseRootItem = NULL;
	}
}

CEdit* CDNSBrowserDlg::GetSelectionEdit()
{
	return (CEdit*)GetDlgItem(IDC_SELECTION_EDIT);
}


CTreeNode* CDNSBrowserDlg::GetSelection()
{
	if (m_pFinalSelection == NULL)
		return NULL;
	return m_pFinalSelection->GetTreeNode();
}

LPCTSTR CDNSBrowserDlg::GetSelectionString()
{
	return m_szSelectionString;
}


BOOL CDNSBrowserDlg::OnInitDialog()
{
	CHelpDialog::OnInitDialog();
	if (m_pHolder != NULL)
		m_pHolder->PushDialogHWnd(m_hWnd);

	InitializeControls();

	InitBrowseTree();

	m_pCurrSelContainer = m_pBrowseRootItem;
	m_currContainer.SetTree(m_pBrowseRootItem, m_pBrowseRootItem);
	m_childrenList.SetChildren(m_pBrowseRootItem);

	return TRUE;
}

//////////// CBrowseDlg : message handlers ////////////////

void CDNSBrowserDlg::OnButtonUp()
{
	CDNSBrowseItem* pSelectedBrowseItem = m_currContainer.GetSelection();
	ASSERT(pSelectedBrowseItem != NULL);
	if (pSelectedBrowseItem == NULL)
		return;
	ASSERT(pSelectedBrowseItem->m_pParent != NULL);
	if (pSelectedBrowseItem->m_pParent == NULL)
		return;
	MoveUpHelper(pSelectedBrowseItem->m_pParent);
}

BOOL CDNSBrowserDlg::OnTooltip(UINT, NMHDR* pHdr, LRESULT* plRes)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    ASSERT(pHdr->code == TTN_NEEDTEXT);
    LPTOOLTIPTEXT pTT =  (LPTOOLTIPTEXT)(pHdr);

    pTT->lpszText = (LPTSTR)IDS_BROWSE_TOOLTIP;
    pTT->hinst = AfxGetApp()->m_hInstance;
    *plRes = 0;
    return TRUE;
}

void CDNSBrowserDlg::OnSelchangeComboSelNode()
{
	CDNSBrowseItem* pSelectedBrowseItem = m_currContainer.GetSelection();
	ASSERT(pSelectedBrowseItem != NULL);
	if (pSelectedBrowseItem == NULL)
		return;
	MoveUpHelper(pSelectedBrowseItem);
}

void CDNSBrowserDlg::OnDblclkListNodeItems(NMHDR* pNMHDR, LRESULT* pResult)
{
	*pResult = 0;
	ASSERT(pNMHDR->code == NM_DBLCLK);
	HandleOkOrDblClick(reinterpret_cast<NMITEMACTIVATE*>(pNMHDR));
}

void CDNSBrowserDlg::OnOK()
{
	HandleOkOrDblClick();
}

void CDNSBrowserDlg::OnItemchangedListNodeItems(NMHDR*, LRESULT*)
{
	//EnableOkButton(m_filter.IsValidResult(pSelectedBrowseItem));
	CDNSBrowseItem* pSelectedBrowseItem = m_childrenList.GetSelection();
	BOOL bEnable = pSelectedBrowseItem != NULL;
	if (bEnable)
		bEnable = m_filter.IsValidResult(pSelectedBrowseItem) ||
						pSelectedBrowseItem->IsContainer();
	EnableOkButton(bEnable);

	UpdateSelectionEdit(pSelectedBrowseItem);
}

void CDNSBrowserDlg::OnSelchangeComboFilter()
{
	m_filter.OnSelectionChange();
	ReEnumerateChildren();

	GetSelectionEdit()->EnableWindow(m_bEnableEdit);//m_filter.Get() == SERVER);
}

////////////// CBrowseDlg : internal helpers //////////////////////

void CDNSBrowserDlg::InitializeToolbar()
{
    CWnd* pWnd = GetDlgItem(IDC_TOOLBAR_CTRL);
    CRect r;
    pWnd->GetWindowRect(r);
    ScreenToClient(r);
    pWnd->DestroyWindow();

    DWORD dwStyle = WS_CHILD | WS_VISIBLE | CCS_NORESIZE | CCS_TOP | CCS_NODIVIDER | TBSTYLE_TOOLTIPS ;
	m_toolbar.Create(dwStyle,r,this, IDC_TOOLBAR_CTRL);
    m_toolbar.AddBitmap(1, IDB_BROWSE_TOOLBAR);
    TBBUTTON btn[2];

    btn[0].iBitmap = 0;    // zero-based index of button image
    btn[0].idCommand = 0;  // command to be sent when button pressed
    btn[0].fsState = 0;   // button state--see below
    btn[0].fsStyle = TBSTYLE_SEP;   // button style--see below
    btn[0].dwData = 0;   // application-defined value
    btn[0].iString = NULL;    // zero-based index of button label string

    btn[1].iBitmap = 0;    // zero-based index of button image
    btn[1].idCommand = N_TOOLBAR_COMMAND_GO_UP;  // command to be sent when button pressed
    btn[1].fsState = TBSTATE_ENABLED;   // button state--see below
    btn[1].fsStyle = TBSTYLE_BUTTON;   // button style--see below
    btn[1].dwData = 0;   // application-defined value
    btn[1].iString = NULL;    // zero-based index of button label string

    m_toolbar.AddButtons(2, btn);
}


void CDNSBrowserDlg::InitializeControls()
{
	// init the controls
	VERIFY(m_currContainer.Initialize(IDC_COMBO_SEL_NODE, IDB_16x16, this));
	VERIFY(m_childrenList.Initialize(IDC_LIST_NODE_ITEMS, IDB_16x16, this));
	VERIFY(m_filter.Initialize(IDC_COMBO_FILTER, IDS_BROWSE_FILTER_OPTIONS, this));

  InitializeToolbar();

	GetSelectionEdit()->EnableWindow(m_bEnableEdit);//m_filter.Get() == SERVER);
}

void CDNSBrowserDlg::EnableOkButton(BOOL bEnable)
{
	GetDlgItem(IDOK)->EnableWindow(bEnable);
}

void CDNSBrowserDlg::HandleOkOrDblClick(NMITEMACTIVATE* pItemActivate)
{
  CDNSBrowseItem* pSelectedBrowseItem = NULL;
   
  if (pItemActivate)
  {
    pSelectedBrowseItem = reinterpret_cast<CDNSBrowseItem*>(m_childrenList.GetItemData(pItemActivate->iItem));
  }
  else
  {
    pSelectedBrowseItem = m_childrenList.GetSelection();
  }
  ASSERT(pSelectedBrowseItem != NULL);
  if (pSelectedBrowseItem == NULL)
    return;

	if (m_filter.IsValidResult(pSelectedBrowseItem))
	{
		if (m_bEnableEdit)
		{
			GetSelectionEdit()->GetWindowText(m_szSelectionString);
			m_szSelectionString.TrimLeft();
			m_szSelectionString.TrimRight();
		}
		m_pFinalSelection = pSelectedBrowseItem;
		if (m_pHolder != NULL)
			m_pHolder->PopDialogHWnd();
		CHelpDialog::OnOK();
	}
	else
	{
		MoveDownHelper();
	}
}

void CDNSBrowserDlg::UpdateSelectionEdit(CDNSBrowseItem* pBrowseItem)
{
	if (pBrowseItem == NULL)
		m_szSelectionString.Empty();
	else
		m_filter.GetStringOf(pBrowseItem, m_szSelectionString);
	GetSelectionEdit()->SetWindowText(m_szSelectionString);
}


void CDNSBrowserDlg::InitBrowseTree()
{
	ASSERT(m_pMasterRootNode != NULL);
	ASSERT(m_pBrowseRootItem != NULL);

	// assume we have no children
	//ASSERT(m_pBrowseRootItem->m_childList.GetCount() == 0);

	// get all the child nodes of the snapin root
	AddTreeNodeChildrenHelper(m_pBrowseRootItem, &m_filter);
}

void CDNSBrowserDlg::ReEnumerateChildren()
{
	ASSERT(m_pMasterRootNode != NULL);
	ASSERT(m_pBrowseRootItem != NULL);
	ASSERT(m_pCurrSelContainer != NULL);
	m_pCurrSelContainer->RemoveChildren(NULL);
	AddTreeNodeChildrenHelper(m_pCurrSelContainer, &m_filter);
	m_childrenList.SetChildren(m_pCurrSelContainer);
}

void CDNSBrowserDlg::ExpandBrowseTree(CDNSBrowseItem* pCurrBrowseItem,
						CDNSBrowseItem* pChildBrowseItem)
{
	ASSERT(m_pMasterRootNode != NULL);
	ASSERT(m_pBrowseRootItem != NULL);
	ASSERT(pCurrBrowseItem != NULL);
	ASSERT(pChildBrowseItem != NULL);
	ASSERT(pChildBrowseItem->m_pParent == pCurrBrowseItem);

	// we are going down one level:
	// 1. remove all the children of the current item but the specified child
	VERIFY(pCurrBrowseItem->RemoveChildren(pChildBrowseItem));
	// 2. move down to the child
	
	// 3. enumerate all the children of the specified child (filtering)
	AddTreeNodeChildrenHelper(pChildBrowseItem, &m_filter);
}

void CDNSBrowserDlg::ContractBrowseTree(CDNSBrowseItem* pParentBrowseItem)
{
	ASSERT(m_pMasterRootNode != NULL);
	ASSERT(m_pBrowseRootItem != NULL);
	ASSERT(pParentBrowseItem != NULL);

	// we are going up one of more levels (possibly up to the root)
	// 1. remove all the children below the specified item
	pParentBrowseItem->RemoveChildren(NULL);
	// 3. enumerate all the children of the specified item (filtering)
	AddTreeNodeChildrenHelper(pParentBrowseItem, &m_filter);
}


void CDNSBrowserDlg::MoveUpHelper(CDNSBrowseItem* pNewBrowseItem)
{
	ASSERT(m_pCurrSelContainer != NULL);
	ASSERT(pNewBrowseItem != NULL);

	if (m_pCurrSelContainer == pNewBrowseItem)
		return; // the same was picked, nothing to do

#ifdef _DEBUG
	// we assume that the new item is NOT a child of the current selection
	CDNSBrowseItem* pItem = pNewBrowseItem;
	BOOL bFound = FALSE;
	while (pItem != NULL)
	{
		bFound = (pItem == m_pCurrSelContainer);
		if (bFound)
			break;
		pItem = pItem->m_pParent;
	}
	ASSERT(!bFound);
#endif

	ContractBrowseTree(pNewBrowseItem);
	m_currContainer.SetTree(m_pBrowseRootItem, pNewBrowseItem);
	m_childrenList.SetChildren(pNewBrowseItem);

	// set new selection
	m_pCurrSelContainer = pNewBrowseItem;
}

void CDNSBrowserDlg::MoveDownHelper()
{
	CDNSBrowseItem* pChildBrowseItem = m_childrenList.GetSelection();
	if (pChildBrowseItem == NULL)
  {
		return;
  }

	// 
  // If it is not a container we should do something else, for now we will just return
  //
	if (!pChildBrowseItem->IsContainer())
  {
		return;
  }

  //
	// get the selection in the combobox
  //
	CDNSBrowseItem* pSelectedBrowseItem =	m_currContainer.GetSelection();
	ASSERT(pSelectedBrowseItem != NULL);
	if (pSelectedBrowseItem == NULL)
  {
		return;
  }

	ExpandBrowseTree(pSelectedBrowseItem, pChildBrowseItem);
	m_currContainer.SetTree(m_pBrowseRootItem, pChildBrowseItem);
	m_childrenList.SetChildren(pChildBrowseItem);
	m_pCurrSelContainer = pChildBrowseItem;
  SetForegroundWindow();
}


class CBrowseExecContext : public CExecContext
{
public:
	virtual void Execute(LPARAM arg)
	{
		m_dlg->AddTreeNodeChildrenHelper(m_pBrowseItem, m_pFilter, (BOOL)arg);
	}
	CDNSBrowserDlg* m_dlg;
	CDNSBrowseItem* m_pBrowseItem;
	CDNSFilterCombo* m_pFilter;
};

void CDNSBrowserDlg::AddTreeNodeChildrenHelper(CDNSBrowseItem* pBrowseItem,
								CDNSFilterCombo* pFilter, BOOL bExpand)
{
	if (bExpand)
	{
		// need to do this always from the UI thread (main for Wiz, 2nd for prop pages)
		CTreeNode* pTreeNode = pBrowseItem->GetTreeNode();
		if (!pTreeNode->IsContainer())
			return;

		CContainerNode* pContNode = (CContainerNode*)pTreeNode;
		if ( (pContNode->GetContainer() != NULL) && (!pContNode->IsEnumerated()) )
		{
			EnumerateMTNodeHelper((CMTContainerNode*)pContNode,
								 m_pComponentDataObject);
		}
	}

	// have to figure out if we are running in the main thread
	if (_MainThreadId == ::GetCurrentThreadId())
	{
		pBrowseItem->AddTreeNodeChildren(pFilter, m_pComponentDataObject);
		return;
	}
	// we are from a secondary thread, execute in the context for the main
	// thread by posting a message and waiting
	ASSERT(m_pComponentDataObject != NULL);
	CBrowseExecContext ctx;
	ctx.m_dlg = this;
	ctx.m_pBrowseItem = pBrowseItem;
	ctx.m_pFilter = pFilter;

	TRACE(_T("before post message()\n"));
	VERIFY(m_pComponentDataObject->PostExecMessage(&ctx,(WPARAM)FALSE));
	ctx.Wait();

	TRACE(_T("after wait()\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\browser.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       browser.h
//
//--------------------------------------------------------------------------

#ifndef _BROWSER_H
#define _BROWSER_H


///////////////////////////////////////////////////////////////////////////////
// FORWARD DECLARATIONS

class CTreeNode;
class CDNSBrowseItem;
class CDNSFilterCombo;
class CDNSBrowserDlg;
class CDNSCurrContainerCombo;
class CDNSChildrenListView;
class CPropertyPageHolderBase;


////////////////////////////////////////////////////////////////////////
// CDNSComboBoxEx : simple C++/MFC wrapper for ComboBoxEx32 control

class CDNSComboBoxEx : public CWnd
{
public:
	BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);

	// simple inlines
   HIMAGELIST SetImageList(HIMAGELIST himl);
	int GetCount() const;
	int GetCurSel() const;
	int SetCurSel(int nSelect);

	int InsertItem(const COMBOBOXEXITEM* pItem);

	LPARAM GetItemData(int nIndex) const;
	BOOL SetItemData(int nIndex, LPARAM lParam);

	void ResetContent();

	DWORD GetExtendedStyle() const;
	DWORD SetExtendedStyle(DWORD dwExMask, DWORD dwExStyle);

};


//////////////////////////////////////////////////////////////////////////
// CDNSBrowseItem : proxy items for the nodes in the snapin

typedef CList< CDNSBrowseItem*, CDNSBrowseItem* > CDNSBrowseItemList;

class CDNSBrowseItem
{
public:
	CDNSBrowseItem()
	{
		m_nIndex = -1;
		m_pParent = NULL;
		m_pTreeNode = NULL;
	}
	~CDNSBrowseItem()
	{
		RemoveChildren();
		if (m_pTreeNode != NULL)
			m_pTreeNode->DecrementSheetLockCount();
	}

	BOOL AddChild(CDNSBrowseItem* pChildBrowseItem);
	BOOL RemoveChildren(CDNSBrowseItem* pNotThisItem = NULL);

	// manipulation of CTreeNode pointer
	void SetTreeNode(CTreeNode* pTreeNode)
	{
		ASSERT(pTreeNode != NULL);
		pTreeNode->IncrementSheetLockCount();
		m_pTreeNode = pTreeNode;
	}
	CTreeNode* GetTreeNode() { return m_pTreeNode;}
	LPCTSTR GetSelectionString();

	// proxies for the CTreeNode functions
	int GetImageIndex(BOOL bOpenImage);
	LPCWSTR GetString(int nCol);
	BOOL IsContainer();

	// Master tree manipulation routines
	void AddTreeNodeChildren(CDNSFilterCombo* pFilter,
			CComponentDataObject* pComponentDataObject);
	
private:
	void AddToContainerCombo(CDNSCurrContainerCombo* pCtrl,
								CDNSBrowseItem* pSelectedBrowseItem,
								int nIndent,int* pNCurrIndex);

	// DATA
public:
	int					m_nIndex;		// index in the container combobox, for direct lookup
	CDNSBrowseItem*		m_pParent;		// parent in the browse tree

private:
	CTreeNode*			m_pTreeNode;	// pointer to the node in the snapin master tree
	CDNSBrowseItemList  m_childList;		// list if children of the current node

	friend class CDNSChildrenListView;
	friend class CDNSCurrContainerCombo;
};


//////////////////////////////////////////////////////////////////////////
// CDNSFilterCombo : dropdown list with filtering options and logic

// NOTICE: the ordering will be the same as the strings in the filter combobox
typedef enum
{
	// these options are for containers
	SERVER = 0 ,
	ZONE_FWD,
	ZONE_REV,

	// these options are for records (leaves)
	RECORD_A,
	RECORD_CNAME,
	RECORD_A_AND_CNAME,
	RECORD_RP,
	RECORD_TEXT,
	RECORD_MB,
	RECORD_ALL,

	LAST	// dummy item, just to know how many there are

} DNSBrowseFilterOptionType;



class CDNSFilterCombo : public CComboBox
{
public:
	CDNSFilterCombo() { m_option = LAST; }
	BOOL Initialize(UINT nCtrlID, UINT nIDFilterString, CDNSBrowserDlg* pDlg);

	void Set(DNSBrowseFilterOptionType option, LPCTSTR lpszExcludeServerName)
	{
		m_option = option;
		m_szExcludeServerName = lpszExcludeServerName;
	}
	DNSBrowseFilterOptionType Get() { return m_option;}
	void OnSelectionChange();

	BOOL CanAddToUIString(UINT n);
	BOOL IsValidTreeNode(CTreeNode* pTreeNode);
	BOOL IsValidResult(CDNSBrowseItem* pBrowseItem);
	void GetStringOf(CDNSBrowseItem* pBrowseItem, CString& szResult);

private:
	DNSBrowseFilterOptionType m_option;
	CString m_szExcludeServerName;
};

//////////////////////////////////////////////////////////////////////////
// CDNSCurrContainerCombo : deals with the selection of the current container

class CDNSCurrContainerCombo : public CDNSComboBoxEx
{
public:
	BOOL Initialize(UINT nCtrlID, UINT nBitmapID, CDNSBrowserDlg* pDlg);

	CDNSBrowseItem*	GetSelection();
	void InsertBrowseItem(CDNSBrowseItem* pBrowseItem, int nIndex, int nIndent);
	
	void SetTree(CDNSBrowseItem* pRootBrowseItem,
					CDNSBrowseItem* pSelectedBrowseItem);

private:
   WTL::CImageList	m_imageList;
};


//////////////////////////////////////////////////////////////////////////
// CDNSChildrenListView : displays the list of childern for the current container

class CDNSChildrenListView : public CListCtrl
{
public:
	CDNSChildrenListView() { m_pDlg = NULL;}
	BOOL Initialize(UINT nCtrlID, UINT nBitmapID, CDNSBrowserDlg* pDlg);
	
	void SetChildren(CDNSBrowseItem* pBrowseItem);
	CDNSBrowseItem*	GetSelection();

private:
   WTL::CImageList	m_imageList;
	CDNSBrowserDlg* m_pDlg;
};

///////////////////////////////////////////////////////////////////////////////
// CDNSBrowserDlg : the browser itself
class CBrowseExecContext; // fwd decl

class CDNSBrowserDlg : public CHelpDialog
{
// Construction
public:
	CDNSBrowserDlg(CComponentDataObject* pComponentDataObject, CPropertyPageHolderBase* pHolder,
		DNSBrowseFilterOptionType option, BOOL bEnableEdit = FALSE,
		LPCTSTR lpszExcludeServerName = NULL);
	~CDNSBrowserDlg();

  virtual INT_PTR DoModal();

	// API's

	CTreeNode* GetSelection();
	LPCTSTR GetSelectionString();

// Implementation
protected:

	// message handlers and MFC overrides
	virtual BOOL OnInitDialog();
	afx_msg void OnButtonUp();
    afx_msg BOOL OnTooltip(UINT, NMHDR* pHdr, LRESULT* plRes);
	afx_msg void OnSelchangeComboSelNode();
	afx_msg void OnDblclkListNodeItems(NMHDR* pNMHDR, LRESULT* pResult);
	virtual void OnOK();
	virtual void OnCancel();
	afx_msg void OnItemchangedListNodeItems(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSelchangeComboFilter();
  afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);

	DECLARE_MESSAGE_MAP()

private:
	// internal helper functions
	CEdit* GetSelectionEdit();

	void InitializeControls();
    void InitializeToolbar();
	void EnableOkButton(BOOL bEnable);
	void HandleOkOrDblClick(NMITEMACTIVATE* pItemActivate = NULL);
	void UpdateSelectionEdit(CDNSBrowseItem* pBrowseItem);
	
	// browse tree manipulation
	void InitBrowseTree();
	void ReEnumerateChildren();			
	void ExpandBrowseTree(CDNSBrowseItem* pCurrBrowseItem,
							CDNSBrowseItem* pChildBrowseItem);
	void ContractBrowseTree(CDNSBrowseItem* pParentBrowseItem);
	void MoveUpHelper(CDNSBrowseItem* pNewBrowseItem);
	void MoveDownHelper();
	void AddTreeNodeChildrenHelper(CDNSBrowseItem* pBrowseItem,
									CDNSFilterCombo* pFilter, BOOL bExpand = TRUE);

	// dialog controls
	CDNSCurrContainerCombo	m_currContainer;
    CToolBarCtrl            m_toolbar;
	CDNSChildrenListView	m_childrenList;
	CDNSFilterCombo			m_filter;

	// dialog data
	BOOL					m_bEnableEdit;			// enable editbox
	CContainerNode*			m_pMasterRootNode;		// root of master browsable tree
	CDNSBrowseItem*			m_pBrowseRootItem;		// root of proxy tree
	CDNSBrowseItem*			m_pCurrSelContainer;	// current container selection

	// final item selection
	CDNSBrowseItem*			m_pFinalSelection;
	CString					m_szSelectionString;

	// component data object pointer
	CComponentDataObject* m_pComponentDataObject;

	// porperty page holder pointer, if needed
	CPropertyPageHolderBase* m_pHolder;

	friend class CDNSChildrenListView;
	friend class CBrowseExecContext;
	friend class CDNSFilterCombo;
};





#endif // _BROWSER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\delegwiz.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       delegwiz.cpp
//
//--------------------------------------------------------------------------


#include "preDNSsn.h"
#include <SnapBase.h>

#include "resource.h"
#include "dnsutil.h"
#include "DNSSnap.h"
#include "snapdata.h"

#include "server.h"
#include "domain.h"
#include "record.h"
#include "zone.h"


#include "delegwiz.h"

#ifdef DEBUG_ALLOCATOR
	#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
	#endif
#endif

///////////////////////////////////////////////////////////////////////////////
// CDNSDelegationWiz_StartPropertyPage

CDNSDelegationWiz_StartPropertyPage::CDNSDelegationWiz_StartPropertyPage() 
				: CPropertyPageBase(IDD_DELEGWIZ_START)
{
	InitWiz97(TRUE, 0,0, true);
}

BOOL CDNSDelegationWiz_StartPropertyPage::OnInitDialog()
{
  CPropertyPageBase::OnInitDialog();
  SetBigBoldFont(m_hWnd, IDC_STATIC_WELCOME);
	return TRUE;
}

BOOL CDNSDelegationWiz_StartPropertyPage::OnSetActive()
{
	// need at least one record in the page to finish
	GetHolder()->SetWizardButtonsFirst(TRUE);
	return TRUE;
}

void CDNSDelegationWiz_StartPropertyPage::OnWizardHelp()
{
  CComPtr<IDisplayHelp> spHelp;
  HRESULT hr = GetHolder()->GetComponentData()->GetConsole()->QueryInterface(IID_IDisplayHelp, (void **)&spHelp);
  if (SUCCEEDED(hr)) 
    spHelp->ShowTopic(L"DNSConcepts.chm::/sag_DNS_DELWIZ_01.htm");
}


///////////////////////////////////////////////////////////////////////////////
// CDNSDelegationWiz_DomainNamePropertyPage

BEGIN_MESSAGE_MAP(CDNSDelegationWiz_DomainNamePropertyPage, CPropertyPageBase)
	ON_EN_CHANGE(IDC_NEW_DOMAIN_NAME_EDIT, OnChangeDomainNameEdit)
END_MESSAGE_MAP()


CDNSDelegationWiz_DomainNamePropertyPage::CDNSDelegationWiz_DomainNamePropertyPage() 
				: CPropertyPageBase(IDD_DELEGWIZ_DOMAIN_NAME)
{
	InitWiz97(FALSE, IDS_DELEGWIZ_DOMAIN_NAME_TITLE,IDS_DELEGWIZ_DOMAIN_NAME_SUBTITLE, true);
}

void CDNSDelegationWiz_DomainNamePropertyPage::OnWizardHelp()
{
  CComPtr<IDisplayHelp> spHelp;
  HRESULT hr = GetHolder()->GetComponentData()->GetConsole()->QueryInterface(IID_IDisplayHelp, (void **)&spHelp);
  if (SUCCEEDED(hr)) 
    spHelp->ShowTopic(L"DNSConcepts.chm::/sag_DNS_DELWIZ_02.htm");
}


BOOL CDNSDelegationWiz_DomainNamePropertyPage::OnInitDialog()
{
	CPropertyPageBase::OnInitDialog();

	CDNSDelegationWizardHolder* pHolder = (CDNSDelegationWizardHolder*)GetHolder();
	m_nUTF8ParentLen = UTF8StringLen(pHolder->GetDomainNode()->GetFullName());

  CWnd* pWnd = GetDlgItem(IDC_NEW_DOMAIN_FQDN);
  CString szText;

  PCWSTR pszFullName = pHolder->GetDomainNode()->GetFullName();
  if (pszFullName && pszFullName[0] == L'.')
  {
     szText = pszFullName;
  }
  else if (pszFullName)
  {
     szText.Format(_T(".%s"), pszFullName);
  }
  pWnd->SetWindowText(szText);

	return TRUE;
}


void CDNSDelegationWiz_DomainNamePropertyPage::OnChangeDomainNameEdit()
{
	CDNSDelegationWizardHolder* pHolder = (CDNSDelegationWizardHolder*)GetHolder();
  DWORD dwNameChecking = pHolder->GetDomainNode()->GetZoneNode()->GetServerNode()->GetNameCheckFlag();

  //
  // Get the name from the control
  //
  GetDomainEdit()->GetWindowText(m_szDomainName);

  //
  // Trim spaces
  //
	m_szDomainName.TrimLeft();
	m_szDomainName.TrimRight();

  //
  // Construct the FQDN
  //
  CString szText;

  PCWSTR pszFullName = pHolder->GetDomainNode()->GetFullName();
  if (pszFullName && pszFullName[0] == L'.')
  {
     szText.Format(_T("%s%s"), m_szDomainName, pszFullName);
  }
  else if (pszFullName)
  {
     szText.Format(_T("%s.%s"), m_szDomainName, pszFullName);
  }

  //
  // Enable next button if it is a valid name
  //
  BOOL bIsValidName = (0 == ValidateDnsNameAgainstServerFlags(szText,
                                                              DnsNameDomain,
                                                              dwNameChecking)); 
	GetHolder()->SetWizardButtonsMiddle(bIsValidName);

  //
  // Set the FQDN in the control
  //
  CWnd* pWnd = GetDlgItem(IDC_NEW_DOMAIN_FQDN);
  pWnd->SetWindowText(szText);

}


BOOL CDNSDelegationWiz_DomainNamePropertyPage::OnSetActive()
{
  //
  // Retrieve server flags
  //
	CDNSDelegationWizardHolder* pHolder = (CDNSDelegationWizardHolder*)GetHolder();
  DWORD dwNameChecking = pHolder->GetDomainNode()->GetZoneNode()->GetServerNode()->GetNameCheckFlag();

  //
  // Construct the FQDN
  //
  CString szText;
  szText.Format(_T("%s.%s"), m_szDomainName, pHolder->GetDomainNode()->GetFullName());

  //
  // Enable next button if it is a valid name
  //
  BOOL bIsValidName = (0 == ValidateDnsNameAgainstServerFlags(szText,
                                                              DnsNameDomain,
                                                              dwNameChecking)); 

  //
  // Set the next button if its a valid name
  //
  GetHolder()->SetWizardButtonsMiddle(bIsValidName);
	return TRUE;
}

BOOL CDNSDelegationWiz_DomainNamePropertyPage::OnKillActive()
{
	CDNSDelegationWizardHolder* pHolder = (CDNSDelegationWizardHolder*)GetHolder();
	CDNSRootData* pRootData = (CDNSRootData*)pHolder->GetComponentData()->GetRootData();
	ASSERT(pHolder->m_pSubdomainNode != NULL);
	pHolder->GetDomainNode()->SetSubdomainName(pHolder->m_pSubdomainNode, 
												m_szDomainName,
												pRootData->IsAdvancedView()); 
	return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// CDNSDelegationWiz_NameServersPropertyPage


CDNSDelegationWiz_NameServersPropertyPage::CDNSDelegationWiz_NameServersPropertyPage()
		: CDNSNameServersPropertyPage(IDD_DELEGWIZ_NAME_SERVERS)
{
	InitWiz97(FALSE, IDS_DELEGWIZ_DOMAIN_NS_TITLE,IDS_DELEGWIZ_DOMAIN_NS_SUBTITLE, true);
}

void CDNSDelegationWiz_NameServersPropertyPage::OnWizardHelp()
{
  CComPtr<IDisplayHelp> spHelp;
  HRESULT hr = GetHolder()->GetComponentData()->GetConsole()->QueryInterface(IID_IDisplayHelp, (void **)&spHelp);
  if (SUCCEEDED(hr)) 
    spHelp->ShowTopic(L"DNSConcepts.chm::/sag_DNS_DELWIZ_03.htm");
}

BOOL CDNSDelegationWiz_NameServersPropertyPage::OnSetActive()
{
	// need at least one record in the page to finish
	GetHolder()->SetWizardButtonsMiddle(m_listCtrl.GetItemCount() > 0);
	return TRUE;
}

void CDNSDelegationWiz_NameServersPropertyPage::OnCountChange(int nCount)
{
	GetHolder()->SetWizardButtonsMiddle(nCount > 0);
}


BOOL CDNSDelegationWiz_NameServersPropertyPage::CreateNewNSRecords(CDNSDomainNode* pSubdomainNode)
{
	ASSERT(pSubdomainNode != NULL);
	BOOL bRes = pSubdomainNode->UpdateNSRecordNodesInfo(m_pCloneInfoList, GetHolder()->GetComponentData());
	if (!bRes)
		return OnWriteNSRecordNodesListError();
	return bRes;
}

///////////////////////////////////////////////////////////////////////////////
// CDNSDelegationWiz_FinishPropertyPage

CDNSDelegationWiz_FinishPropertyPage::CDNSDelegationWiz_FinishPropertyPage() 
				: CPropertyPageBase(IDD_DELEGWIZ_FINISH)
{
	InitWiz97(TRUE, 0,0, true);
}

void CDNSDelegationWiz_FinishPropertyPage::OnWizardHelp()
{
  CComPtr<IDisplayHelp> spHelp;
  HRESULT hr = GetHolder()->GetComponentData()->GetConsole()->QueryInterface(IID_IDisplayHelp, (void **)&spHelp);
  if (SUCCEEDED(hr)) 
    spHelp->ShowTopic(L"DNSConcepts.chm::/sag_DNS_DELWIZ_04.htm");
}

BOOL CDNSDelegationWiz_FinishPropertyPage::OnSetActive()
{
	// need at least one record in the page to finish
	GetHolder()->SetWizardButtonsLast(TRUE);
	DisplaySummaryInfo();
	return TRUE;
}

BOOL CDNSDelegationWiz_FinishPropertyPage::OnWizardFinish()
{
	CDNSDelegationWizardHolder* pHolder = (CDNSDelegationWizardHolder*)GetHolder();
	ASSERT(pHolder->IsWizardMode());

	return pHolder->OnFinish();
}

void CDNSDelegationWiz_FinishPropertyPage::DisplaySummaryInfo()
{
	CDNSDelegationWizardHolder* pHolder = (CDNSDelegationWizardHolder*)GetHolder();
	GetDlgItem(IDC_NAME_STATIC)->SetWindowText(pHolder->m_pSubdomainNode->GetFullName());
}

///////////////////////////////////////////////////////////////////////////////
// CDNSDelegationWizardHolder

CDNSDelegationWizardHolder::CDNSDelegationWizardHolder(CDNSMTContainerNode* pContainerNode, 
							CDNSDomainNode* pThisDomainNode, CComponentDataObject* pComponentData)
		: CPropertyPageHolderBase(pContainerNode, pThisDomainNode, pComponentData)
{
	ASSERT(pComponentData != NULL);
	ASSERT(pContainerNode != NULL);
	ASSERT(pContainerNode == GetContainerNode());
	ASSERT(pThisDomainNode != NULL);
	ASSERT(pThisDomainNode == GetDomainNode());

	m_bAutoDeletePages = FALSE; // we have the page as embedded member

	AddPageToList((CPropertyPageBase*)&m_startPage);
	AddPageToList((CPropertyPageBase*)&m_domainNamePage);
	AddPageToList((CPropertyPageBase*)&m_nameServersPage);
	AddPageToList((CPropertyPageBase*)&m_finishPage);

	m_pSubdomainNode = GetDomainNode()->CreateSubdomainNode(/*bDelegation*/TRUE);
	ASSERT(m_pSubdomainNode != NULL);
	m_nameServersPage.SetDomainNode(m_pSubdomainNode);
}

CDNSDelegationWizardHolder::~CDNSDelegationWizardHolder()
{
	if (m_pSubdomainNode != NULL)
		delete m_pSubdomainNode; 
}

CDNSDomainNode* CDNSDelegationWizardHolder::GetDomainNode()
{ 
	return (CDNSDomainNode*)GetTreeNode();
}

BOOL CDNSDelegationWizardHolder::OnFinish()
{
	ASSERT(m_pSubdomainNode != NULL);
  if (m_pSubdomainNode == NULL)
  {
    return FALSE;
  }

  //
  // See if a child of that name already exists
  //
  RECORD_SEARCH recordSearch = RECORD_NOT_FOUND;

  CDNSDomainNode* pNewParentDomain = NULL;
  CString szFullDomainName;
  szFullDomainName = m_pSubdomainNode->GetFullName();
  CString szNonExistentDomain;
  CDNSRecordNodeBase* pExistingRecordNode = 0;

  recordSearch = GetDomainNode()->GetZoneNode()->DoesContain(szFullDomainName, 
                                                             GetComponentData(),
                                                             &pNewParentDomain,
                                                             &pExistingRecordNode,
                                                             szNonExistentDomain,
                                                             TRUE);

  if (recordSearch == RECORD_NOT_FOUND && pNewParentDomain != NULL)
  {
    //
	  // first create the subdomain in the server and UI
    //
	  DNS_STATUS err = pNewParentDomain->CreateSubdomain(m_pSubdomainNode, GetComponentData());
	  if (err != 0)
	  {
		  DNSErrorDialog(err, IDS_MSG_DELEGWIZ_SUBDOMAIN_FAILED);
	  }
	  else
	  {
      //
		  // mark the node as enumerated and force transition to "loaded"
      //
		  m_pSubdomainNode->MarkEnumeratedAndLoaded(GetComponentData());

      //
		  // then create the NS records underneath
      //
		  BOOL bSuccess = m_nameServersPage.CreateNewNSRecords(m_pSubdomainNode);
		  if (!bSuccess)
			  DNSErrorDialog(-1, IDS_MSG_DELEGWIZ_NS_RECORD_FAILED);
		  m_pSubdomainNode = NULL; // relinquish ownership
	  }
  }
  else if (recordSearch == NON_EXISTENT_SUBDOMAIN && pNewParentDomain != NULL)
  {
    //
	  // first create the subdomain in the server and UI
    //
    DNS_STATUS err = m_pSubdomainNode->Create();
	  if (err != 0)
	  {
		  DNSErrorDialog(err, IDS_MSG_DELEGWIZ_SUBDOMAIN_FAILED);
      return FALSE;
	  }
	  else
	  {
      //
		  // then create the NS records underneath
      //
		  BOOL bSuccess = m_nameServersPage.CreateNewNSRecords(m_pSubdomainNode);
		  if (!bSuccess)
      {
			  DNSErrorDialog(-1, IDS_MSG_DELEGWIZ_NS_RECORD_FAILED);
        return FALSE;
      }

      ASSERT(!szNonExistentDomain.IsEmpty());
      if (!szNonExistentDomain.IsEmpty())
      {
        //
        // Create the first subdomain because the current domain is already enumerated
        // so we have to start the remaining enumeration at the new subdomain that is needed
        //
	      CDNSDomainNode* pSubdomainNode = pNewParentDomain->CreateSubdomainNode();
	      ASSERT(pSubdomainNode != NULL);
	      CDNSRootData* pRootData = (CDNSRootData*)GetComponentData()->GetRootData();
	      pNewParentDomain->SetSubdomainName(pSubdomainNode, szNonExistentDomain, pRootData->IsAdvancedView());

        VERIFY(pNewParentDomain->AddChildToListAndUISorted(pSubdomainNode, GetComponentData()));
        GetComponentData()->SetDescriptionBarText(pNewParentDomain);

        //
        // I don't care what the results of this are, I am just using it 
        // to do the expansion to the new record
        //
        recordSearch = pSubdomainNode->GetZoneNode()->DoesContain(szFullDomainName, 
                                                                  GetComponentData(),
                                                                  &pNewParentDomain,
                                                                  &pExistingRecordNode,
                                                                  szNonExistentDomain,
                                                                  TRUE);
      }
    
      //
		  // mark the node as enumerated and force transition to "loaded"
      //
		  m_pSubdomainNode->MarkEnumeratedAndLoaded(GetComponentData());

		  m_pSubdomainNode = NULL; // relinquish ownership
	  }
  }
  else if (recordSearch == RECORD_NOT_FOUND_AT_THE_NODE)
  {
    DNSMessageBox(IDS_MSG_DELEGWIZ_SUDOMAIN_EXISTS);
    return FALSE;
  }
  else
  {
  }


	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\dnsmgr.h ===
#ifndef DNSMGR_H_INCLUDED
#define DNSMGR_H_INCLUDED



// Flags to DnsSetup

static const DWORD DNS_SETUP_ZONE_CREATE_FOR_DCPROMO_FOREST = 0x01;
static const DWORD DNS_SETUP_AUTOCONFIG_CLIENT              = 0x02;



#endif   // DNSMGR_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\delegwiz.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       delegwiz.h
//
//--------------------------------------------------------------------------


#ifndef _DELEGWIZ_H
#define _DELEGWIZ_H

///////////////////////////////////////////////////////////////////////////////
// CDNSDelegationWiz_StartPropertyPage

class CDNSDelegationWiz_StartPropertyPage : public CPropertyPageBase 
{
public:
	CDNSDelegationWiz_StartPropertyPage();

  virtual BOOL OnInitDialog();
	virtual BOOL OnSetActive();
   virtual void OnWizardHelp();

	friend class CDNSDelegationWizardHolder;
};

///////////////////////////////////////////////////////////////////////////////
// CDNSDelegationWiz_DomainNamePropertyPage

class CDNSDelegationWiz_DomainNamePropertyPage : public CPropertyPageBase 
{
public:
	virtual BOOL OnInitDialog();
	virtual BOOL OnSetActive();

	CDNSDelegationWiz_DomainNamePropertyPage();

	virtual BOOL OnKillActive();
   virtual void OnWizardHelp();

protected:
	afx_msg void OnChangeDomainNameEdit();

private:
	CString	m_szDomainName;
	int m_nUTF8ParentLen;

	CEdit* GetDomainEdit() { return (CEdit*)GetDlgItem(IDC_NEW_DOMAIN_NAME_EDIT);}

	DECLARE_MESSAGE_MAP()

	friend class CDNSDelegationWizardHolder;
};

///////////////////////////////////////////////////////////////////////////////
// CDNSDelegationWiz_NameServersPropertyPage

class CDNSDelegationWiz_NameServersPropertyPage : public CDNSNameServersPropertyPage
{
public:
	CDNSDelegationWiz_NameServersPropertyPage();
	virtual BOOL OnSetActive();
   virtual void OnWizardHelp();

protected:
	virtual void ReadRecordNodesList() { } // we do not load anything
	virtual BOOL WriteNSRecordNodesList() { ASSERT(FALSE); return FALSE;} // never called
	virtual void OnCountChange(int nCount);

private:
	BOOL CreateNewNSRecords(CDNSDomainNode* pSubdomainNode);

	friend class CDNSDelegationWizardHolder;
};

///////////////////////////////////////////////////////////////////////////////
// CDNSDelegationWiz_FinishPropertyPage

class CDNSDelegationWiz_FinishPropertyPage : public CPropertyPageBase 
{
public:
	virtual BOOL OnSetActive();
	virtual BOOL OnWizardFinish(); 
   virtual void OnWizardHelp();

	CDNSDelegationWiz_FinishPropertyPage();
private:
	void DisplaySummaryInfo();
	friend class CDNSDelegationWizardHolder;
};

///////////////////////////////////////////////////////////////////////////////
// CDNSDelegationWizardHolder

class CDNSDelegationWizardHolder : public CPropertyPageHolderBase
{
public:
	CDNSDelegationWizardHolder(CDNSMTContainerNode* pContainerNode, CDNSDomainNode* pThisDomainNode,
				CComponentDataObject* pComponentData);
	virtual ~CDNSDelegationWizardHolder();

private:
	CDNSDomainNode* GetDomainNode();

	BOOL OnFinish();

	CDNSDomainNode* m_pSubdomainNode;

	CDNSDelegationWiz_StartPropertyPage				m_startPage;
	CDNSDelegationWiz_DomainNamePropertyPage		m_domainNamePage;
	CDNSDelegationWiz_NameServersPropertyPage		m_nameServersPage;
	CDNSDelegationWiz_FinishPropertyPage			m_finishPage;

	friend class CDNSDelegationWiz_DomainNamePropertyPage;
	friend class CDNSDelegationWiz_NameServersPropertyPage;
	friend class CDNSDelegationWiz_FinishPropertyPage;

};



#endif // _DELEGWIZ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\dnssnap.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

// You will need the NT SUR Beta 2 SDK or VC 4.2 in order to build this
// project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

#include "preDNSsn.h"
#include <SnapBase.h>

#include "resource.h"
#include "dnsutil.h"
#include "DNSSnap.h"
#include "snapdata.h"

#include "server.h"
#include "domain.h"
#include "record.h"
#include "zone.h"

#include "HelpArr.h"	// context help ID's

// Version info
#include <ntverp.h>
#define IDS_SNAPIN_VERSION VER_PRODUCTVERSION_STR
#define IDS_SNAPIN_PROVIDER VER_COMPANYNAME_STR


#ifdef DEBUG_ALLOCATOR
	#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
	#endif
#endif

//////////////////////////////////////////////////////////////////////////////
// regsvr debugging

// define to enable MsgBox debugging for regsvr32
//#define _MSGBOX_ON_REG_FAIL


#ifdef _MSGBOX_ON_REG_FAIL
#define _MSGBOX(x) AfxMessageBox(x)
#else
#define _MSGBOX(x)
#endif

#ifdef _MSGBOX_ON_REG_FAIL
#define _REPORT_FAIL(lpszMessage, lpszClsid, lRes) \
  ReportFail(lpszMessage, lpszClsid, lRes)

void ReportFail(LPCWSTR lpszMessage, LPCWSTR lpszClsid, LONG lRes)
{
  if (lRes == ERROR_SUCCESS)
    return;

  CString sz;
  sz.Format(_T("%s %s %d"), lpszMessage,lpszClsid, lRes);
  CThemeContextActivator activator;
  AfxMessageBox(sz);
}

#else
#define _REPORT_FAIL(lpszMessage, lpszClsid, lRes)
#endif


//////////////////////////////////////////////////////////////////////////////
// global constants and macros

// GUIDs for snapin
const CLSID CLSID_DNSSnapin =
{ 0x2faebfa2, 0x3f1a, 0x11d0, { 0x8c, 0x65, 0x0, 0xc0, 0x4f, 0xd8, 0xfe, 0xcb } };

// {80105023-50B1-11d1-B930-00A0C9A06D2D}
const CLSID CLSID_DNSSnapinEx =
{ 0x80105023, 0x50b1, 0x11d1, { 0xb9, 0x30, 0x0, 0xa0, 0xc9, 0xa0, 0x6d, 0x2d } };

// {6C1303DC-BA00-11d1-B949-00A0C9A06D2D}
const CLSID CLSID_DNSSnapinAbout =
{ 0x6c1303dc, 0xba00, 0x11d1, { 0xb9, 0x49, 0x0, 0xa0, 0xc9, 0xa0, 0x6d, 0x2d } };

// {6C1303DD-BA00-11d1-B949-00A0C9A06D2D}
const CLSID CLSID_DNSSnapinAboutEx =
{ 0x6c1303dd, 0xba00, 0x11d1, { 0xb9, 0x49, 0x0, 0xa0, 0xc9, 0xa0, 0x6d, 0x2d } };


///////////////////////////////////////////////////////////////////////////////
// RESOURCES


BEGIN_MENU(CDNSRootDataMenuHolder)
	BEGIN_CTX
		CTX_ENTRY_VIEW(IDM_SNAPIN_ADVANCED_VIEW, L"_DNS_ADVANCED")
    CTX_ENTRY_VIEW(IDM_SNAPIN_FILTERING, L"_DNS_FILTER")
		CTX_ENTRY_TOP(IDM_SNAPIN_CONNECT_TO_SERVER, L"_DNS_CONNECTTOP")
		CTX_ENTRY_TASK(IDM_SNAPIN_CONNECT_TO_SERVER, L"_DNS_CONNECTTASK")
	END_CTX
	BEGIN_RES
		RES_ENTRY(IDS_SNAPIN_ADVANCED_VIEW)
    RES_ENTRY(IDS_SNAPIN_FILTERING)
		RES_ENTRY(IDS_SNAPIN_CONNECT_TO_SERVER)
		RES_ENTRY(IDS_SNAPIN_CONNECT_TO_SERVER)
	END_RES
END_MENU

BEGIN_MENU(CDNSServerMenuHolder)
	BEGIN_CTX
    CTX_ENTRY_VIEW(IDM_SNAPIN_ADVANCED_VIEW, L"_DNS_ADVANCED")
    CTX_ENTRY_VIEW(IDM_SNAPIN_MESSAGE, L"_DNS_MESSAGE")
    CTX_ENTRY_VIEW(IDM_SNAPIN_FILTERING, L"_DNS_FILTER")
    CTX_ENTRY_TOP(IDM_SERVER_CONFIGURE, L"_DNS_CONFIGURETOP")
#ifdef USE_NDNC
    CTX_ENTRY_TOP(IDM_SERVER_CREATE_NDNC, L"_DNS_CREATENDNC")
#endif
    CTX_ENTRY_TOP(IDM_SERVER_NEW_ZONE, L"_DNS_ZONE")
    CTX_ENTRY_TOP(IDM_SERVER_SET_AGING, L"_DNS_AGING")
    CTX_ENTRY_TOP(IDM_SERVER_SCAVENGE, L"_DNS_SCAVENGETOP")
    CTX_ENTRY_TOP(IDM_SERVER_UPDATE_DATA_FILES, L"_DNS_UPDATETOP")
    CTX_ENTRY_TOP(IDM_SERVER_CLEAR_CACHE, L"_DNS_CLEARCACHETOP")
    CTX_ENTRY_TOP(IDM_SERVER_NSLOOKUP, L"_DNS_NSLOOKUPTOP")
    CTX_ENTRY_TASK(IDM_SERVER_CONFIGURE, L"_DNS_CONFIGURETASK")
    CTX_ENTRY_TASK(IDM_SERVER_SCAVENGE, L"_DNS_SCAVENGETASK")
    CTX_ENTRY_TASK(IDM_SERVER_UPDATE_DATA_FILES, L"_DNS_UPDATETASK")
    CTX_ENTRY_TASK(IDM_SERVER_CLEAR_CACHE, L"_DNS_CLEARCACHETASK")
    CTX_ENTRY_TASK(IDM_SERVER_NSLOOKUP, L"_DNS_NSLOOKUPTASK")
	END_CTX
	BEGIN_RES
    RES_ENTRY(IDS_SNAPIN_ADVANCED_VIEW)
    RES_ENTRY(IDS_SNAPIN_MESSAGE)
    RES_ENTRY(IDS_SNAPIN_FILTERING)
    RES_ENTRY(IDS_SERVER_CONFIGURE)
#ifdef USE_NDNC
    RES_ENTRY(IDS_SERVER_CREATE_NDNC)
#endif
    RES_ENTRY(IDS_SERVER_NEW_ZONE)
    RES_ENTRY(IDS_SERVER_SET_AGING)
    RES_ENTRY(IDS_SERVER_SCAVENGE)
    RES_ENTRY(IDS_SERVER_UPDATE_DATA_FILES)
    RES_ENTRY(IDS_SERVER_CLEAR_CACHE)
    RES_ENTRY(IDS_SERVER_NSLOOKUP)
    RES_ENTRY(IDS_SERVER_CONFIGURE)
    RES_ENTRY(IDS_SERVER_SCAVENGE)
    RES_ENTRY(IDS_SERVER_UPDATE_DATA_FILES)
    RES_ENTRY(IDS_SERVER_CLEAR_CACHE)
    RES_ENTRY(IDS_SERVER_NSLOOKUP)
	END_RES
END_MENU

BEGIN_MENU(CDNSCathegoryFolderHolder)
	BEGIN_CTX
    CTX_ENTRY_VIEW(IDM_SNAPIN_ADVANCED_VIEW, L"_DNS_ADVANCED")		
    CTX_ENTRY_VIEW(IDM_SNAPIN_FILTERING, L"_DNS_FILTER")
	END_CTX
	BEGIN_RES
    RES_ENTRY(IDS_SNAPIN_ADVANCED_VIEW)
    RES_ENTRY(IDS_SNAPIN_FILTERING)
	END_RES
END_MENU


BEGIN_MENU(CDNSAuthoritatedZonesMenuHolder)
	BEGIN_CTX
    CTX_ENTRY_VIEW(IDM_SNAPIN_ADVANCED_VIEW, L"_DNS_ADVANCED")		
    CTX_ENTRY_VIEW(IDM_SNAPIN_FILTERING, L"_DNS_FILTER")
    CTX_ENTRY_TOP(IDM_SERVER_NEW_ZONE, L"_DNS_ZONETOP")
	END_CTX
	BEGIN_RES
    RES_ENTRY(IDS_SNAPIN_ADVANCED_VIEW)
    RES_ENTRY(IDS_SNAPIN_FILTERING)
    RES_ENTRY(IDS_SERVER_NEW_ZONE)
	END_RES
END_MENU

BEGIN_MENU(CDNSCacheMenuHolder)
	BEGIN_CTX
    CTX_ENTRY_TOP(IDM_CACHE_FOLDER_CLEAR_CACHE, L"_DNS_CLEARCACHETOP")		
    CTX_ENTRY_TASK(IDM_CACHE_FOLDER_CLEAR_CACHE, L"_DNS_CLEARCACHETASK")		
	END_CTX
	BEGIN_RES
		RES_ENTRY(IDS_CACHE_FOLDER_CLEAR_CACHE)
		RES_ENTRY(IDS_CACHE_FOLDER_CLEAR_CACHE)
	END_RES
END_MENU


BEGIN_MENU(CDNSZoneMenuHolder)
	BEGIN_CTX
    CTX_ENTRY_VIEW(IDM_SNAPIN_ADVANCED_VIEW, L"_DNS_ADVANCED")		
    CTX_ENTRY_VIEW(IDM_SNAPIN_FILTERING, L"_DNS_FILTER")

		CTX_ENTRY_TOP(IDM_ZONE_UPDATE_DATA_FILE, L"_DNS_UPDATETOP")
    CTX_ENTRY_TOP(IDM_ZONE_RELOAD, L"_DNS_RELOADTOP")
    CTX_ENTRY_TOP(IDM_ZONE_TRANSFER, L"_DNS_TRANSFERTOP")
    CTX_ENTRY_TOP(IDM_ZONE_RELOAD_FROM_MASTER, L"_DNS_RELOADMASTERTOP")
		CTX_ENTRY_TOP(IDM_DOMAIN_NEW_HOST, L"_DNS_NEWHOST")
		CTX_ENTRY_TOP(IDM_DOMAIN_NEW_PTR, L"_DNS_NEWPTR")
		CTX_ENTRY_TOP(IDM_DOMAIN_NEW_ALIAS, L"_DNS_NEWALIAS")
		CTX_ENTRY_TOP(IDM_DOMAIN_NEW_MX, L"_DNS_NEWMX")
		CTX_ENTRY_TOP(IDM_DOMAIN_NEW_DOMAIN, L"_DNS_NEWDOMAIN")
		CTX_ENTRY_TOP(IDM_DOMAIN_NEW_DELEGATION, L"_DNS_NEWDELEGATION")
		CTX_ENTRY_TOP(IDM_DOMAIN_NEW_RECORD, L"_DNS_NEWRECORD")
		CTX_ENTRY_TASK(IDM_ZONE_UPDATE_DATA_FILE, L"_DNS_UPDATETASK")
    CTX_ENTRY_TASK(IDM_ZONE_RELOAD, L"_DNS_RELOADTASK")
    CTX_ENTRY_TASK(IDM_ZONE_TRANSFER, L"_DNS_TRANSFERTASK")
    CTX_ENTRY_TASK(IDM_ZONE_RELOAD_FROM_MASTER, L"_DNS_RELOADMASTERTASK")
	END_CTX
	BEGIN_RES
		RES_ENTRY(IDS_SNAPIN_ADVANCED_VIEW)
    RES_ENTRY(IDS_SNAPIN_FILTERING)

		//RES_ENTRY(IDS_ZONE_PAUSE)
		RES_ENTRY(IDS_ZONE_UPDATE_DATA_FILE)
    RES_ENTRY(IDS_ZONE_RELOAD)
    RES_ENTRY(IDS_ZONE_TRANSFER)
    RES_ENTRY(IDS_ZONE_RELOAD_FROM_MASTER)
		RES_ENTRY(IDS_DOMAIN_NEW_NEW_HOST)
		RES_ENTRY(IDS_DOMAIN_NEW_NEW_PTR)
		RES_ENTRY(IDS_DOMAIN_NEW_NEW_ALIAS)
		RES_ENTRY(IDS_DOMAIN_NEW_NEW_MX)
		RES_ENTRY(IDS_DOMAIN_NEW_NEW_DOMAIN)
		RES_ENTRY(IDS_DOMAIN_NEW_NEW_DELEGATION)
		RES_ENTRY(IDS_DOMAIN_NEW_NEW_RECORD)
		RES_ENTRY(IDS_ZONE_UPDATE_DATA_FILE)
    RES_ENTRY(IDS_ZONE_RELOAD)
    RES_ENTRY(IDS_ZONE_TRANSFER)
    RES_ENTRY(IDS_ZONE_RELOAD_FROM_MASTER)
	END_RES
END_MENU

BEGIN_MENU(CDNSDomainMenuHolder)
	BEGIN_CTX
    CTX_ENTRY_VIEW(IDM_SNAPIN_ADVANCED_VIEW, L"_DNS_ADVANCED")		
    CTX_ENTRY_VIEW(IDM_SNAPIN_FILTERING, L"_DNS_FITLER")

    CTX_ENTRY_TOP(IDM_DOMAIN_NEW_HOST, L"_DNS_NEWHOST")
		CTX_ENTRY_TOP(IDM_DOMAIN_NEW_PTR, L"_DNS_NEWPTR")
		CTX_ENTRY_TOP(IDM_DOMAIN_NEW_ALIAS, L"_DNS_NEWALIAS")
		CTX_ENTRY_TOP(IDM_DOMAIN_NEW_MX, L"_DNS_NEWMX")
		CTX_ENTRY_TOP(IDM_DOMAIN_NEW_DOMAIN, L"_DNS_NEWDOMAIN")
		CTX_ENTRY_TOP(IDM_DOMAIN_NEW_DELEGATION, L"_DNS_NEWDELEGATION")
		CTX_ENTRY_TOP(IDM_DOMAIN_NEW_RECORD, L"_DNS_NEWRECORD")
	END_CTX
	BEGIN_RES
		RES_ENTRY(IDS_SNAPIN_ADVANCED_VIEW)
    RES_ENTRY(IDS_SNAPIN_FILTERING)

    RES_ENTRY(IDS_DOMAIN_NEW_NEW_HOST)
		RES_ENTRY(IDS_DOMAIN_NEW_NEW_PTR)
		RES_ENTRY(IDS_DOMAIN_NEW_NEW_ALIAS)
		RES_ENTRY(IDS_DOMAIN_NEW_NEW_MX)
		RES_ENTRY(IDS_DOMAIN_NEW_NEW_DOMAIN)
		RES_ENTRY(IDS_DOMAIN_NEW_NEW_DELEGATION)
		RES_ENTRY(IDS_DOMAIN_NEW_NEW_RECORD)
	END_RES
END_MENU

BEGIN_MENU(CDNSRecordMenuHolder)
	BEGIN_CTX
	END_CTX

	BEGIN_RES
	END_RES
END_MENU


// # of columns in the result pane and map for resource strings

extern RESULT_HEADERMAP _DefaultHeaderStrings[] =
{
	{ L"", IDS_HEADER_NAME, LVCFMT_LEFT, 180},
	{ L"", IDS_HEADER_TYPE, LVCFMT_LEFT, 150},
	{ L"", IDS_HEADER_DATA, LVCFMT_LEFT, 160}
};

extern RESULT_HEADERMAP _ServerHeaderStrings[] =
{
	{ L"", IDS_HEADER_NAME, LVCFMT_LEFT, 180},
};

extern RESULT_HEADERMAP _ZoneHeaderStrings[] =
{
	{ L"", IDS_HEADER_NAME,   LVCFMT_LEFT, 180},
	{ L"", IDS_HEADER_TYPE,   LVCFMT_LEFT, 90},
//  { L"", IDS_HEADER_PARTITION, LVCFMT_LEFT, 100},
	{ L"", IDS_HEADER_STATUS, LVCFMT_LEFT, 160}
};

#define N_ZONE_TYPES (7)
extern ZONE_TYPE_MAP _ZoneTypeStrings[] = 
{
  { L"", IDS_ZONE_TYPE_AD_INTEGRATED },
  { L"", IDS_ZONE_TYPE_STANDARD_PRIMARY },
  { L"", IDS_ZONE_TYPE_SECONDARY },
  { L"", IDS_ZONE_TYPE_RUNNING },
  { L"", IDS_ZONE_TYPE_PAUSED },
  { L"", IDS_ZONE_TYPE_STUB },
  { L"", IDS_ZONE_TYPE_STUB_DS }
};

//
// Toolbar buttons
//

MMCBUTTON g_DNSMGR_SnapinButtons[] =
{
  { 0, toolbarNewServer, !TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0 },
  { 1, toolbarNewRecord, !TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0 },
  { 2, toolbarNewZone,   !TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0 }
};

//
// We have to maintain the memory for the toolbar button strings
// so this class holds the strings until it is time for them to be
// deleted
//
class CButtonStringsHolder
{
public:
  CButtonStringsHolder()
  {
    m_astr = NULL;
  }
  ~CButtonStringsHolder()
  {
    if (m_astr != NULL)
      delete[] m_astr;
  }
  CString* m_astr; // dynamic array of CStrings
};

CButtonStringsHolder g_astrButtonStrings;

BOOL LoadZoneTypeResources(ZONE_TYPE_MAP* pHeaderMap, int nCols)
{
	HINSTANCE hInstance = _Module.GetModuleInstance();
	for ( int i = 0; i < nCols ; i++)
	{
		if ( 0 == ::LoadString(hInstance, pHeaderMap[i].uResID, pHeaderMap[i].szBuffer, MAX_RESULT_HEADER_STRLEN))
			return TRUE;
	}
	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// CDNSMgrModule

HRESULT WINAPI CDNSMgrModule::UpdateRegistryCLSID(const CLSID& clsid, BOOL bRegister)
{
   static const WCHAR szIPS32[] = _T("InprocServer32");
   static const WCHAR szCLSID[] = _T("CLSID");

   HRESULT hRes = S_OK;

   LPOLESTR lpOleStrCLSIDValue = NULL;
   ::StringFromCLSID(clsid, &lpOleStrCLSIDValue);
   if (lpOleStrCLSIDValue == NULL)
   {
      return E_OUTOFMEMORY;
   }

	CRegKey key;
	if (bRegister)
	{
      LONG lRes = key.Open(HKEY_CLASSES_ROOT, szCLSID);
      _REPORT_FAIL(L"key.Open(HKEY_CLASSES_ROOT", lpOleStrCLSIDValue, lRes);
      if (lRes == ERROR_SUCCESS)
      {
         lRes = key.Create(key, lpOleStrCLSIDValue);
         _REPORT_FAIL(L"key.Create(key", lpOleStrCLSIDValue, lRes);
			if (lRes == ERROR_SUCCESS)
			{
            DWORD bufferSizeInCharacters = MAX_PATH; 
				WCHAR* szModule = 0;
            
            do
            {
               if (szModule)
               {
                  delete[] szModule;
                  szModule = 0;
               }
               
               szModule = new WCHAR[bufferSizeInCharacters + 1];
               if (szModule)
               {
                  ZeroMemory(szModule, sizeof(WCHAR) * (bufferSizeInCharacters + 1));

				      DWORD result = 
                     ::GetModuleFileName(
                        m_hInst, 
                        szModule, 
                        bufferSizeInCharacters);

                  if (result < bufferSizeInCharacters)
                  {
                     break;
                  }

                  // truncation occurred, grow the buffer and try again

                  bufferSizeInCharacters *= 2;
               }
               else
               {
                  break;
               }
            } while (bufferSizeInCharacters < USHRT_MAX);

            if (szModule)
            {
				   lRes = key.SetKeyValue(szIPS32, szModule);
               _REPORT_FAIL(L"key.SetKeyValue(szIPS32", lpOleStrCLSIDValue, lRes);

               delete[] szModule;
            }
			}
		}
		if (lRes != ERROR_SUCCESS)
      {
         hRes = HRESULT_FROM_WIN32(lRes);
      }
	}
	else
	{
		key.Attach(HKEY_CLASSES_ROOT);
		if (key.Open(key, szCLSID) == ERROR_SUCCESS)
			key.RecurseDeleteKey(lpOleStrCLSIDValue);
	}
	::CoTaskMemFree(lpOleStrCLSIDValue);
	return hRes;
}


///////////////////////////////////////////////////////////////////////////////
// Module, Object Map and DLL entry points

CDNSMgrModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_DNSSnapin, CDNSComponentDataObject)		// standalone snapin
	OBJECT_ENTRY(CLSID_DNSSnapinEx, CDNSComponentDataObjectEx)	// namespace extension

  OBJECT_ENTRY(CLSID_DNSSnapinAbout, CDNSSnapinAbout)	// standalone snapin about
  OBJECT_ENTRY(CLSID_DNSSnapinAboutEx, CDNSSnapinAboutEx)	// namespace extension about
END_OBJECT_MAP()


STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}


static _NODE_TYPE_INFO_ENTRY _NodeTypeInfoEntryArray[] = {
	{ &CDNSRootData::NodeTypeGUID,			_T("Root DNS Snapin Subtree")	},
	{ &CDNSServerNode::NodeTypeGUID,		_T("DNS Snapin Server Node")	},
	{ &CDNSZoneNode::NodeTypeGUID,			_T("DNS Snapin Zone Node")		},
	{ &CDNSDomainNode::NodeTypeGUID,		_T("DNS Snapin Domain Node")	},
	{ &CDNSRecordNodeBase::NodeTypeGUID,	_T("DNS Snapin Record Node")	},
	{ NULL, NULL }
};


///////////////////////////////////////////////////////////////////////////
// external GUIDs (from Computer Management Snapin)

const CLSID CLSID_SystemServiceManagementExt =	
	{0x58221C6a,0xEA27,0x11CF,{0xAD,0xCF,0x00,0xAA,0x00,0xA8,0x00,0x33}};

const CLSID CLSID_NodeTypeServerApps =
  { 0x476e6449, 0xaaff, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };

const CLSID CLSID_EventViewerExt = 
  { 0x394C052E, 0xB830, 0x11D0, { 0x9A, 0x86, 0x00, 0xC0, 0x4F, 0xD8, 0xDB, 0xF7 } };


////////////////////////////////////////////////////////////////////
// Server Applications Registration functions

const TCHAR DNS_KEY[] = TEXT("System\\CurrentControlSet\\Services\\DNS");
const TCHAR CONTROL_KEY[] = TEXT("System\\CurrentControlSet\\Control\\");

BOOL IsDNSServerInstalled()
{
  CRegKey regkeyDNSService;
	LONG lRes = regkeyDNSService.Open(HKEY_LOCAL_MACHINE, DNS_KEY);
	return (lRes == ERROR_SUCCESS);
}


////////////////////////////////////////////////////////////////////





STDAPI DllRegisterServer(void)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
	// registers all objects
	HRESULT hr = _Module.RegisterServer(/* bRegTypeLib */ FALSE);
	ASSERT(SUCCEEDED(hr));
	if (FAILED(hr))
  {
    _MSGBOX(_T("_Module.RegisterServer() failed"));
		return hr;
  }

  CString szVersion, szProvider, szSnapinName, szSnapinNameEx;

  szVersion = IDS_SNAPIN_VERSION;
  szProvider = IDS_SNAPIN_PROVIDER;
  szSnapinName.LoadString(IDS_SNAPIN_NAME);
  szSnapinNameEx.LoadString(IDS_SNAPIN_NAME_EX);

	// register the standalone DNS snapin into the console snapin list
	hr = RegisterSnapin(&CLSID_DNSSnapin,
                      &CDNSRootData::NodeTypeGUID,
                      &CLSID_DNSSnapinAbout,
						szSnapinName, szVersion, szProvider,
            FALSE /*bExtension*/,
						_NodeTypeInfoEntryArray,
            IDS_SNAPIN_NAME);
	ASSERT(SUCCEEDED(hr));
	if (FAILED(hr))
  {
    _MSGBOX(_T("RegisterSnapin(&CLSID_DNSSnapin) failed"));
		return hr;
  }

	// register the extension DNS snapin into the console snapin list
	hr = RegisterSnapin(&CLSID_DNSSnapinEx,
                      &CDNSRootData::NodeTypeGUID,
                      &CLSID_DNSSnapinAboutEx,
						szSnapinNameEx, szVersion, szProvider,
            TRUE /*bExtension*/,
						_NodeTypeInfoEntryArray,
            IDS_SNAPIN_NAME);
	ASSERT(SUCCEEDED(hr));
	if (FAILED(hr))
  {
    _MSGBOX(_T("RegisterSnapin(&CLSID_DNSSnapinEx) failed"));
		return hr;
  }


	// register the snapin nodes into the console node list
	for (_NODE_TYPE_INFO_ENTRY* pCurrEntry = _NodeTypeInfoEntryArray;
			pCurrEntry->m_pNodeGUID != NULL; pCurrEntry++)
	{
		hr = RegisterNodeType(pCurrEntry->m_pNodeGUID,pCurrEntry->m_lpszNodeDescription);
		ASSERT(SUCCEEDED(hr));
		if (FAILED(hr))
    {
      _MSGBOX(_T("RegisterNodeType() failed"));
			return hr;
    }
	}

	// the Services Snapin will extend the Server Node (context menu to start/stop DNS)
	//
	// JonN 9/15/98: Removed the "dynamic" setting.  I don't understand why this was
	// being registered as a dynamic extension.
	hr = RegisterNodeExtension(&CDNSServerNode::NodeTypeGUID, _T("ContextMenu"),
						&CLSID_SystemServiceManagementExt,
						_T("System Service Management Extension"), FALSE /*bDynamic*/);
	if (FAILED(hr))
  {
    _MSGBOX(_T("RegisterNodeExtension(&CDNSServerNode::NodeTypeGUID) failed"));
		return hr;
  }

  //
  // Register the event viewer as a namespace extension of the server node
  //
  hr = RegisterNodeExtension(&CDNSServerNode::NodeTypeGUID, _T("NameSpace"),
                             &CLSID_EventViewerExt, _T("Event Viewer Extension"), FALSE);
  if (FAILED(hr))
  {
    _MSGBOX(_T("RegisterNodeExtension(&CDNSServerNode::NodeTypeGUID) failed"));
		return hr;
  }

  //
  // the DNS Snapin will be a namespace extension for the Server Apps node
  // in the Computer Management Snapin
  //
	//
  // Fixed Bug 13620	DNSMGR: on workstation with AdminPak, dnsmgr.dll should not get loaded
  // 
  OSVERSIONINFOEX verInfoEx;
  verInfoEx.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
  if (!::GetVersionEx((OSVERSIONINFO*)&verInfoEx) || verInfoEx.wProductType != VER_NT_WORKSTATION)
  {
	  hr = RegisterNodeExtension(&CLSID_NodeTypeServerApps, _T("NameSpace"),
						  &CLSID_DNSSnapinEx, szSnapinNameEx, TRUE /*bDynamic*/);
	  if (FAILED(hr))
    {
      _MSGBOX(_T("RegisterNodeExtension(&CLSID_NodeTypeServerApps) failed"));
		  return hr;
    }
  }
	return hr;
}

STDAPI DllUnregisterServer(void)
{
	HRESULT hr  = _Module.UnregisterServer();
	ASSERT(SUCCEEDED(hr));

	// un register the standalone snapin
	hr = UnregisterSnapin(&CLSID_DNSSnapin);
	ASSERT(SUCCEEDED(hr));

 	// un register the extension snapin
	hr = UnregisterSnapin(&CLSID_DNSSnapinEx);
	ASSERT(SUCCEEDED(hr));

	// unregister the snapin nodes,
  // this removes also the server node, with the Services Snapin extension keys
	for (_NODE_TYPE_INFO_ENTRY* pCurrEntry = _NodeTypeInfoEntryArray;
			pCurrEntry->m_pNodeGUID != NULL; pCurrEntry++)
	{
		hr = UnregisterNodeType(pCurrEntry->m_pNodeGUID);
		ASSERT(SUCCEEDED(hr));
	}

  // the DNS Snapin will be a namespace extension for the Server Apps node
  // in the Computer Management Snapin
	hr = UnregisterNodeExtension(&CLSID_NodeTypeServerApps, _T("NameSpace"),
						&CLSID_DNSSnapinEx, TRUE /*bDynamic*/);
  ASSERT(SUCCEEDED(hr));

	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// CDNSSnapinApp

class CDNSSnapinApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
};

CDNSSnapinApp theApp;

BOOL CDNSSnapinApp::InitInstance()
{
	_Module.Init(ObjectMap, m_hInstance);
  
  // Add theming support

  SHFusionInitializeFromModuleID(m_hInstance, 2);

  // initialize font for Mask Control
  WCHAR szFontName[LF_FACESIZE];
  int nFontSize;
  VERIFY(LoadFontInfoFromResource(IDS_MASK_CTRL_FONT_NAME,
                            IDS_MASK_CTRL_FONT_SIZE,
                            szFontName, LF_FACESIZE,
                            nFontSize,
                            L"MS Shell Dlg", 8 // default if something goes wrong
                            ));

	if (!DNS_ControlsInitialize(m_hInstance, szFontName, nFontSize))
		return FALSE;

	if (!CDNSComponentDataObject::LoadResources())
		return FALSE;
	return CWinApp::InitInstance();
}

int CDNSSnapinApp::ExitInstance()
{
#ifdef _DEBUG_REFCOUNT
	TRACE(_T("CDNSSnapinApp::ExitInstance()\n"));
	ASSERT(CComponentDataObject::m_nOustandingObjects == 0);
	ASSERT(CComponentObject::m_nOustandingObjects == 0);
	ASSERT(CDataObject::m_nOustandingObjects == 0);
#endif // _DEBUG_REFCOUNT

   // Theming support

   SHFusionUninitialize();

	_Module.Term();
	return CWinApp::ExitInstance();
}

////////////////////////////////////////////////////////////////////////
// CDNSComponentObject (.i.e "view")


HRESULT CDNSComponentObject::InitializeHeaders(CContainerNode* pContainerNode)
{
  HRESULT hr = S_OK;
  ASSERT(m_pHeader);

  CColumnSet* pColumnSet = pContainerNode->GetColumnSet();
  POSITION pos = pColumnSet->GetHeadPosition();
  while (pos != NULL)
  {
    CColumn* pColumn = pColumnSet->GetNext(pos);

    hr = m_pHeader->InsertColumn(pColumn->GetColumnNum(), 
                                  pColumn->GetHeader(),
								                  pColumn->GetFormat(),
								                  AUTO_WIDTH);
    if (FAILED(hr))
      return hr;

    hr = m_pHeader->SetColumnWidth(pColumn->GetColumnNum(), pColumn->GetWidth());
    if (FAILED(hr))
      return hr;
  }
  return hr;
}

HRESULT CDNSComponentObject::InitializeBitmaps(CTreeNode*)
{
  // image lists for nodes
  CBitmapHolder<IDB_16x16> _bmp16x16;
  CBitmapHolder<IDB_32x32> _bmp32x32;

  HRESULT hr = S_OK;
  BOOL bLoaded = _bmp16x16.LoadBitmap() && _bmp32x32.LoadBitmap();
  if (bLoaded)
  {
    ASSERT(m_pImageResult != NULL);
    hr = m_pImageResult->ImageListSetStrip(reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(_bmp16x16)),
                                           reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(_bmp32x32)),
                                           0, BMP_COLOR_MASK);
  }
  else
  {
    hr = S_FALSE;
  }
  return hr;
}

CONST INT cButtons = sizeof(g_DNSMGR_SnapinButtons)/sizeof(MMCBUTTON);

HRESULT CDNSComponentObject::InitializeToolbar(IToolbar* pToolbar)
{
  ASSERT(pToolbar != NULL);
  HRESULT hr = S_OK;

  LoadToolbarStrings(g_DNSMGR_SnapinButtons);

  CBitmapHolder<IDB_TOOLBAR_BUTTONS> _bmpToolbarButtons;
  BOOL bLoaded = _bmpToolbarButtons.LoadBitmap();
  if (bLoaded)
  {
    hr = m_pToolbar->AddBitmap(cButtons, (HBITMAP)_bmpToolbarButtons, 16, 16, RGB(255,0,255));
  }
  hr = m_pToolbar->AddButtons(cButtons,  g_DNSMGR_SnapinButtons);

  return hr;
}

HRESULT CDNSComponentObject::LoadToolbarStrings(MMCBUTTON * Buttons)
{
  if (g_astrButtonStrings.m_astr == NULL ) 
  {
    //
    // load strings
    //
    g_astrButtonStrings.m_astr = new CString[2*cButtons];
    for (UINT i = 0; i < cButtons; i++) 
    {
      UINT iButtonTextId = 0, iTooltipTextId = 0;

      switch (Buttons[i].idCommand)
      {
        case toolbarNewServer:
          iButtonTextId = IDS_BUTTON_NEW_SERVER;
          iTooltipTextId = IDS_TOOLTIP_NEW_SERVER;
          break;
        case toolbarNewRecord:
          iButtonTextId = IDS_BUTTON_NEW_RECORD;
          iTooltipTextId = IDS_TOOLTIP_NEW_RECORD;
          break;
        case toolbarNewZone:
          iButtonTextId = IDS_BUTTON_NEW_ZONE;
          iTooltipTextId = IDS_TOOLTIP_NEW_ZONE;
          break;
        default:
          ASSERT(FALSE);
          break;
      }

      if (g_astrButtonStrings.m_astr)
      {
         g_astrButtonStrings.m_astr[i*2].LoadString(iButtonTextId);
         Buttons[i].lpButtonText =
            const_cast<BSTR>((LPCTSTR)(g_astrButtonStrings.m_astr[i*2]));

         g_astrButtonStrings.m_astr[(i*2)+1].LoadString(iTooltipTextId);
         Buttons[i].lpTooltipText =
           const_cast<BSTR>((LPCTSTR)(g_astrButtonStrings.m_astr[(i*2)+1]));
      }
    }
  }
  return S_OK;
}
////////////////////////////////////////////////////////////////////////
// CDNSComponentDataObjectBase (.i.e "document")

CDNSComponentDataObjectBase::CDNSComponentDataObjectBase()
{
   CWatermarkInfo* pWatermarkInfo = new CWatermarkInfo;
   if (pWatermarkInfo)
   {
      pWatermarkInfo->m_nIDBanner = IDB_WIZBANNER;
      pWatermarkInfo->m_nIDWatermark = IDB_WIZWATERMARK;
   }
   SetWatermarkInfo(pWatermarkInfo);

   CDNSDefaultColumnSet* pDefaultCols = 
      new CDNSDefaultColumnSet(L"---Default Column Set---");

   if (pDefaultCols)
   {
      m_columnSetList.AddTail(pDefaultCols);
   }

   CDNSServerColumnSet* pServerCols = 
      new CDNSServerColumnSet(L"---Server Column Set---");

   if (pServerCols)
   {
      m_columnSetList.AddTail(pServerCols);
   }

   CDNSZoneColumnSet* pZoneCols =
      new CDNSZoneColumnSet(L"---Zone Column Set---");
   
   if (pZoneCols)
   {
      m_columnSetList.AddTail(pZoneCols);
   }

   SetLogFileName(L"dcpromodns");
}



HRESULT CDNSComponentDataObjectBase::OnSetImages(LPIMAGELIST lpScopeImage)
{
  // image lists for nodes
  CBitmapHolder<IDB_16x16> _bmp16x16;
  CBitmapHolder<IDB_32x32> _bmp32x32;

  BOOL bLoaded = _bmp16x16.LoadBitmap() && _bmp32x32.LoadBitmap();

  HRESULT hr = S_OK;
  if (bLoaded)
  {
    ASSERT(lpScopeImage != NULL);
	  hr = lpScopeImage->ImageListSetStrip(reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(_bmp16x16)),
		                                     reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(_bmp32x32)),
		                                     0, BMP_COLOR_MASK);
  }
  else
  {
    hr = S_FALSE;
  }
  return hr;
}


CRootData* CDNSComponentDataObjectBase::OnCreateRootData()
{
   
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	CString szSnapinType;
	szSnapinType.LoadString(IDS_SNAPIN_NAME);

	CDNSRootData* pDNSRootNode = new CDNSRootData(this);
	if (pDNSRootNode)
   {
      pDNSRootNode->SetDisplayName(szSnapinType);
   }
	return pDNSRootNode;
}

BOOL CDNSComponentDataObjectBase::LoadResources()
{
  return 
	       LoadContextMenuResources(CDNSRootDataMenuHolder::GetMenuMap()) &&
	       LoadContextMenuResources(CDNSServerMenuHolder::GetMenuMap()) &&
	       LoadContextMenuResources(CDNSCathegoryFolderHolder::GetMenuMap()) &&
	       LoadContextMenuResources(CDNSAuthoritatedZonesMenuHolder::GetMenuMap()) &&
         LoadContextMenuResources(CDNSCacheMenuHolder::GetMenuMap()) &&
	       LoadContextMenuResources(CDNSZoneMenuHolder::GetMenuMap()) &&
	       LoadContextMenuResources(CDNSDomainMenuHolder::GetMenuMap()) &&
         LoadContextMenuResources(CDNSRecordMenuHolder::GetMenuMap()) &&
 	       LoadResultHeaderResources(_DefaultHeaderStrings,N_DEFAULT_HEADER_COLS) &&
         LoadResultHeaderResources(_ServerHeaderStrings,N_SERVER_HEADER_COLS) &&
         LoadResultHeaderResources(_ZoneHeaderStrings,N_ZONE_HEADER_COLS) &&
         LoadZoneTypeResources(_ZoneTypeStrings, N_ZONE_TYPES) &&
	       CDNSRecordInfo::LoadResources();
}


STDMETHODIMP CDNSComponentDataObjectBase::CreateComponent(LPCOMPONENT* ppComponent)
{
    ASSERT(ppComponent != NULL);

    CComObject<CDNSComponentObject>* pObject;
    CComObject<CDNSComponentObject>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);

    // Store IComponentData
    pObject->SetIComponentData(this);

    return  pObject->QueryInterface(IID_IComponent,
                    reinterpret_cast<void**>(ppComponent));
}


void CDNSComponentDataObjectBase::OnTimer()
{
	CDNSRootData* pDNSRootData = (CDNSRootData*)GetRootData();
	pDNSRootData->TestServers(m_dwTimerTime, GetTimerInterval(), this);
	m_dwTimerTime += GetTimerInterval();
}

void CDNSComponentDataObjectBase::OnTimerThread(WPARAM wParam, LPARAM lParam)
{
	CDNSRootData* pDNSRootData = (CDNSRootData*)GetRootData();
	pDNSRootData->OnServerTestData(wParam,lParam, this);
}

CTimerThread* CDNSComponentDataObjectBase::OnCreateTimerThread()
{
	return new CDNSServerTestTimerThread;
}



void CDNSComponentDataObjectBase::OnNodeContextHelp(CNodeList* pNodeList)
{
   ASSERT(pNodeList);

   if (pNodeList)
   {
      ASSERT(pNodeList->GetCount() > 0);

      OnNodeContextHelp(pNodeList->GetHead());
   }
}

void CDNSComponentDataObjectBase::OnNodeContextHelp(CTreeNode* /*pNode*/)
{
  CComPtr<IDisplayHelp> spHelp;
  HRESULT hr = GetConsole()->QueryInterface(IID_IDisplayHelp, (void **)&spHelp);
  if (SUCCEEDED(hr)) 
    spHelp->ShowTopic(L"DNSconcepts.chm::/sag_DNStopnode.htm");

/*
  CString szNode;

  if (IS_CLASS(*pNode, CDNSRootData))
  {
    szNode = _T("Root Node");
  }
  else if (IS_CLASS(*pNode, CDNSServerNode))
  {
    szNode = _T("Server Node");
  }
  else if (IS_CLASS(*pNode, CDNSForwardZonesNode))
  {
    szNode = _T("Forward Zones Node");
  }
  else if (IS_CLASS(*pNode, CDNSReverseZonesNode))
  {
    szNode = _T("Reverse Zones Node");
  }
  else if (IS_CLASS(*pNode, CDNSZoneNode))
  {
    szNode = _T("Zone Node");
  }
  else if (IS_CLASS(*pNode, CDNSDomainNode))
  {
    szNode = _T("Domain Node");
  }
  else if (IS_CLASS(*pNode, CDNSCacheNode))
  {
    szNode = _T("Domain Node");
  }
  else if (dynamic_cast<CDNSRecordNodeBase*>(pNode) != NULL)
  {
    szNode = _T("Record Node");
  }

  if (!szNode.IsEmpty())
  {
    CString szMsg = _T("Context Help on ");
    szMsg += szNode;
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CThemeContextActivator activator;
    AfxMessageBox(szMsg);
  }
*/
}

LPCWSTR g_szContextHelpFileName = L"\\help\\dnsmgr.hlp";
LPCWSTR g_szHTMLHelpFileName = L"\\help\\dnsmgr.chm";

LPCWSTR CDNSComponentDataObjectBase::GetHTMLHelpFileName()
{
  return g_szHTMLHelpFileName;
}

void CDNSComponentDataObjectBase::OnDialogContextHelp(UINT nDialogID, HELPINFO* pHelpInfo)
{
	ULONG nContextTopic;
  if (FindDialogContextTopic(nDialogID, pHelpInfo, &nContextTopic))
	  WinHelp(g_szContextHelpFileName, HELP_CONTEXTPOPUP, nContextTopic);
}

////////////////////////////////////////////////////////////////////////////////
// help context macros and maps

#define BEGIN_HELP_MAP(map)	static DWORD_PTR map[] = {
#define HELP_MAP_ENTRY(x)	x, (DWORD_PTR)&g_aHelpIDs_##x ,
#define END_HELP_MAP		 0, 0 };


#define NEXT_HELP_MAP_ENTRY(p) ((p)+2)
#define MAP_ENTRY_DLG_ID(p) (*p)
#define MAP_ENTRY_TABLE(p) ((DWORD*)(*(p+1)))
#define IS_LAST_MAP_ENTRY(p) (MAP_ENTRY_DLG_ID(p) == 0)

#define NEXT_HELP_TABLE_ENTRY(p) ((p)+2)
#define TABLE_ENTRY_CTRL_ID(p) (*p)
#define TABLE_ENTRY_HELP_ID(p) (*(p+1))
#define IS_LAST_TABLE_ENTRY(p) (TABLE_ENTRY_CTRL_ID(p) == 0)

BEGIN_HELP_MAP(_DNSMgrContextHelpMap)
  // misc dialogs
  HELP_MAP_ENTRY(IDD_CHOOSER_CHOOSE_MACHINE)
  HELP_MAP_ENTRY(IDD_BROWSE_DIALOG)
  HELP_MAP_ENTRY(IDD_FILTERING_LIMITS)
  HELP_MAP_ENTRY(IDD_FILTERING_NAME)

  // misc. add dialogs
  HELP_MAP_ENTRY(IDD_DOMAIN_ADDNEWHOST) // TODO
  HELP_MAP_ENTRY(IDD_DOMAIN_ADDNEWDOMAIN)// TODO
  HELP_MAP_ENTRY(IDD_SELECT_RECORD_TYPE_DIALOG)

  // name servers page, there are more than one
  HELP_MAP_ENTRY(IDD_NAME_SERVERS_PAGE)
  HELP_MAP_ENTRY(IDD_COPY_ROOTHINTS_DIALOG)

  // server property pages
  HELP_MAP_ENTRY(IDD_SERVER_INTERFACES_PAGE)
  HELP_MAP_ENTRY(IDD_SERVER_DOMAIN_FORWARDERS_PAGE)
  HELP_MAP_ENTRY(IDD_SERVER_NEW_DOMAIN_FORWARDER)
  HELP_MAP_ENTRY(IDD_SERVER_ADVANCED_PAGE)
  HELP_MAP_ENTRY(IDD_SERVER_DEBUG_LOGGING_PAGE)
  HELP_MAP_ENTRY(IDD_IP_FILTER_DIALOG)
  HELP_MAP_ENTRY(IDD_SERVER_EVENT_LOGGING_PAGE)
  HELP_MAP_ENTRY(IDD_SERVMON_TEST_PAGE)
  HELP_MAP_ENTRY(IDD_SERVER_AGING_DIALOG)

  // zone property pages
#ifdef USE_NDNC
  HELP_MAP_ENTRY(IDD_ZONE_GENERAL_PAGE_NDNC)
  HELP_MAP_ENTRY(IDD_ZONE_GENERAL_CHANGE_REPLICATION)
#else
  HELP_MAP_ENTRY(IDD_ZONE_GENERAL_PAGE)
#endif // USE_NDNC
  HELP_MAP_ENTRY(IDD_ZONE_GENERAL_CHANGE_TYPE)
  HELP_MAP_ENTRY(IDD_ZONE_WINS_PAGE)
  HELP_MAP_ENTRY(IDD_ZONE_NBSTAT_PAGE)
  HELP_MAP_ENTRY(IDD_ZONE_ZONE_TRANSFER_PAGE)
  HELP_MAP_ENTRY(IDD_ZONE_WINS_ADVANCED) // this is a subdialog
  HELP_MAP_ENTRY(IDD_ZONE_NOTIFY_SUBDIALOG) // this is a subdialog
  HELP_MAP_ENTRY(IDD_ZONE_AGING_DIALOG)

  // record property pages
  HELP_MAP_ENTRY(IDD_RR_NS_EDIT)
  HELP_MAP_ENTRY(IDD_RR_SOA)
  HELP_MAP_ENTRY(IDD_RR_A)
  HELP_MAP_ENTRY(IDD_RR_ATMA)
  HELP_MAP_ENTRY(IDD_RR_CNAME)
  HELP_MAP_ENTRY(IDD_RR_MX)
  HELP_MAP_ENTRY(IDD_RR_UNK)
  HELP_MAP_ENTRY(IDD_RR_TXT)
  HELP_MAP_ENTRY(IDD_RR_X25)
  HELP_MAP_ENTRY(IDD_RR_ISDN)
  HELP_MAP_ENTRY(IDD_RR_HINFO)
  HELP_MAP_ENTRY(IDD_RR_AAAA)
  HELP_MAP_ENTRY(IDD_RR_MB)
  HELP_MAP_ENTRY(IDD_RR_MG)
  HELP_MAP_ENTRY(IDD_RR_MD)
  HELP_MAP_ENTRY(IDD_RR_MF)
  HELP_MAP_ENTRY(IDD_RR_MR)
  HELP_MAP_ENTRY(IDD_RR_MINFO)
  HELP_MAP_ENTRY(IDD_RR_RP)
  HELP_MAP_ENTRY(IDD_RR_RT)
  HELP_MAP_ENTRY(IDD_RR_AFSDB)
  HELP_MAP_ENTRY(IDD_RR_WKS)
  HELP_MAP_ENTRY(IDD_RR_PTR)
  HELP_MAP_ENTRY(IDD_RR_SRV)
  HELP_MAP_ENTRY(IDD_RR_KEY)
  HELP_MAP_ENTRY(IDD_RR_SIG)
  HELP_MAP_ENTRY(IDD_RR_NXT)
END_HELP_MAP



BOOL CDNSComponentDataObjectBase::FindDialogContextTopic(/*IN*/UINT nDialogID,
                                              /*IN*/ HELPINFO* pHelpInfo,
                                              /*OUT*/ ULONG* pnContextTopic)
{
	ASSERT(pHelpInfo != NULL);
    *pnContextTopic = 0;
	const DWORD_PTR* pMapEntry = _DNSMgrContextHelpMap;
	while (!IS_LAST_MAP_ENTRY(pMapEntry))
	{
		if (nDialogID == MAP_ENTRY_DLG_ID(pMapEntry))
		{
			DWORD* pTable = MAP_ENTRY_TABLE(pMapEntry);
			// look inside the table
			while (!IS_LAST_TABLE_ENTRY(pTable))
			{
				if (TABLE_ENTRY_CTRL_ID(pTable) == static_cast<UINT>(pHelpInfo->iCtrlId))
        {
					*pnContextTopic = TABLE_ENTRY_HELP_ID(pTable);
          return TRUE;
        }
				pTable = NEXT_HELP_TABLE_ENTRY(pTable);
			}
		}
		pMapEntry = NEXT_HELP_MAP_ENTRY(pMapEntry);
	}
	return FALSE;
}

////////////////////////////////////////////////////////////////////////
// CDNSComponentDataObjectEx (.i.e "document")
// extension snapin


unsigned int g_CFMachineName =
	RegisterClipboardFormat(L"MMC_SNAPIN_MACHINE_NAME");


LPWSTR ExtractMachineName(LPDATAOBJECT lpDataObject)
{
    ASSERT(lpDataObject != NULL);

    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
	FORMATETC formatetc = { (CLIPFORMAT)g_CFMachineName, NULL,
                            DVASPECT_CONTENT, -1, TYMED_HGLOBAL
                          };

    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, 512);

	LPWSTR pwszMachineName = NULL;
    // Attempt to get data from the object
    do
	{
		if (stgmedium.hGlobal == NULL)
			break;

		if (FAILED(lpDataObject->GetDataHere(&formatetc, &stgmedium)))
			break;
		
        pwszMachineName = reinterpret_cast<LPWSTR>(stgmedium.hGlobal);

   		if (pwszMachineName == NULL)
			break;

	} while (FALSE);

    return pwszMachineName;
}




HRESULT CDNSComponentDataObjectEx::OnExtensionExpand(LPDATAOBJECT lpDataObject, LPARAM param)
{
	// this is a namespace extension, need to add
	// the root of the snapin

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// NOTICE: the name of the root node is already set in the constructor

	// insert the root node in the console
	CDNSRootData* pDNSRootNode = (CDNSRootData*)GetRootData();
	HSCOPEITEM pParent = param;
	pDNSRootNode->SetScopeID(pParent);
	HRESULT hr = AddContainerNode(pDNSRootNode, pParent);
	if (FAILED(hr))
		return hr;

  BOOL bLocalHost = FALSE;
  if (!pDNSRootNode->IsEnumerated())
  {
   	// get information from the data object
	  LPWSTR pwszMachineName = ExtractMachineName(lpDataObject);
	  if ( (pwszMachineName == NULL) || (pwszMachineName[0] == NULL) )
	  {		
		  if (pwszMachineName != NULL)
			  ::GlobalFree((void*)pwszMachineName);
		  DWORD dwCharLen = MAX_COMPUTERNAME_LENGTH+1;
		  pwszMachineName = (LPWSTR)GlobalAlloc(GMEM_SHARE, sizeof(WCHAR)*dwCharLen);
      if (pwszMachineName)
      {
		    BOOL bRes = ::GetComputerName(pwszMachineName, &dwCharLen);
		    ASSERT(dwCharLen <= MAX_COMPUTERNAME_LENGTH);
		    if (!bRes)
        {
			    wcscpy(pwszMachineName, _T("localhost."));
        }
        bLocalHost = TRUE;
      }
	  }

	  // add a new server node with the server name from the data object
	  CDNSServerNode* pDNSServerNode = new CDNSServerNode(pwszMachineName, bLocalHost);
	  FREE_INTERNAL((void*)pwszMachineName);

     if (pDNSServerNode)
     {
        VERIFY(pDNSRootNode->AddChildToList(pDNSServerNode));
        pDNSRootNode->AddServerToThreadList(pDNSServerNode, this);
     }

    pDNSRootNode->MarkEnumerated();
  }
	return hr;
}


HRESULT CDNSComponentDataObjectEx::OnRemoveChildren(LPDATAOBJECT, LPARAM)
{
  ASSERT(IsExtensionSnapin());

  CDNSRootData* pDNSRootNode = (CDNSRootData*)GetRootData();
	CNodeList* pChildList = pDNSRootNode->GetContainerChildList();
	ASSERT(pChildList != NULL);

  // loop through thelist of servers and remove them from
  // the test list
	for(POSITION pos = pChildList->GetHeadPosition(); pos != NULL; )
	{
    CDNSServerNode* pCurrServerNode = (CDNSServerNode*)pChildList->GetNext(pos);
		ASSERT(pCurrServerNode != NULL);
    pDNSRootNode->RemoveServerFromThreadList(pCurrServerNode, this);
  }

  // detach all the threads that might be still running
	GetRunningThreadTable()->RemoveAll();

  // shut down property sheets, if any
	GetPropertyPageHolderTable()->WaitForAllToShutDown();

  // remove all the children of the root from chaild list
  pDNSRootNode->RemoveAllChildrenFromList();

  pDNSRootNode->MarkEnumerated(FALSE);
	return S_OK;
}


//////////////////////////////////////////////////////////////////////////
// CDNSSnapinAbout

CDNSSnapinAbout::CDNSSnapinAbout()
{
  m_szProvider = IDS_SNAPIN_PROVIDER;
	m_szVersion = IDS_SNAPIN_VERSION;
	m_uIdStrDestription = IDS_SNAPINABOUT_DESCRIPTION;
	m_uIdIconImage = IDI_DNS_SNAPIN;
	m_uIdBitmapSmallImage = IDB_ABOUT_16x16;
	m_uIdBitmapSmallImageOpen = IDB_ABOUT_OPEN_16x16;
	m_uIdBitmapLargeImage = IDB_ABOUT_32x32;
	m_crImageMask = BMP_COLOR_MASK;
}


//////////////////////////////////////////////////////////////////////////
// CDNSSnapinAboutEx

CDNSSnapinAboutEx::CDNSSnapinAboutEx()
{
  m_szProvider = IDS_SNAPIN_PROVIDER;
	m_szVersion = IDS_SNAPIN_VERSION;
	m_uIdStrDestription = IDS_SNAPINABOUT_DESCRIPTION;
	m_uIdIconImage = IDI_DNS_SNAPIN;
	m_uIdBitmapSmallImage = IDB_16x16;
	m_uIdBitmapSmallImageOpen = IDB_16x16;
	m_uIdBitmapLargeImage = IDB_32x32;
	m_crImageMask = BMP_COLOR_MASK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\dnsutil.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dnsutil.cpp
//
//--------------------------------------------------------------------------



#include "preDNSsn.h"
#include <SnapBase.h>

#include "resource.h"
#include "dnsutil.h"
#include "uiutil.h"

#ifdef DEBUG_ALLOCATOR
    #ifdef _DEBUG
    #define new DEBUG_NEW
    #undef THIS_FILE
    static char THIS_FILE[] = __FILE__;
    #endif
#endif

// formatting of IPv4 address to string

LPCWSTR g_szIpStringFmt = TEXT("%d.%d.%d.%d");

#ifdef NTRAID_628931
// Wide character version of DNS_ZONE_ROOT_HINTS

CString g_zoneRootHints(L"");

HRESULT GetWideCharZoneRootHints(CString& zoneRootHints)
{
    HRESULT hr = S_OK;

    // Initialize the wide char version if it has
    // not already been initialized.
    if (g_zoneRootHints == L"")
    {
        // Determine how long wide string needs to be.
        int wideLength = MultiByteToWideChar(
            CP_ACP,
            0,
            DNS_ZONE_ROOT_HINTS,
            -1, // Let MBtoWC() determine length.
            NULL,
            0);

        LPWSTR lpszZoneRootHints = new WCHAR[wideLength];
        if (lpszZoneRootHints)
        {
            // Convert ascii to wide string.
            int convertedLength = MultiByteToWideChar(
                CP_ACP,
                0,
                DNS_ZONE_ROOT_HINTS,
                -1,
                lpszZoneRootHints,
                wideLength);

            // Should never happen.
            if (convertedLength != wideLength)
            {
                hr = E_FAIL;
                ASSERT(false);
            }

            g_zoneRootHints = lpszZoneRootHints;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        delete [] lpszZoneRootHints;
    }

    if (SUCCEEDED(hr))
    {
        zoneRootHints = g_zoneRootHints;
    }
    return hr;
}
#endif //NTRAID_628931


///////////////////////////////////////////////////////////////
// General Purpose Utility Functions

BYTE HexCharToByte(WCHAR ch)
{
    if (ch >= TEXT('0') && ch <= TEXT('9'))
        return static_cast<BYTE>(ch-TEXT('0'));
    else if (ch >= TEXT('A') && ch <= TEXT('F'))
        return static_cast<BYTE>(ch-TEXT('A') + 10);
    else if (ch >= TEXT('a') && ch <= TEXT('f')) 
        return static_cast<BYTE>(ch-TEXT('a') + 10);
  else
    return static_cast<BYTE>(0xFF); // marks out of range, expect 0x00 to 0x0f
}


void ReverseString(LPWSTR p, LPWSTR q)
{
    WCHAR c;
    while (p < q)
    {
        c = *p;
        *p = *q;
        *q = c;
        p++; q--;
    }
}

int ReverseIPString(LPWSTR lpsz)
{
    if (!lpsz)
        return 0;
    // reverse the whole string
    size_t nLen = wcslen(lpsz);
    ReverseString(lpsz, lpsz+(nLen-1));

    // reverse each octect
    WCHAR *p,*q1,*q2;
    p = q1 = q2 = lpsz;
    int nOctects = 0;
    while (TRUE)
    {
        if ( (*p == '.') || (*p == '\0') && (p >lpsz) )
        {
            q1 = p-1; // point to the digit before the dot
            ReverseString(q2,q1);
            nOctects++;
            q2 = p+1; // for next loop, set trailing pointer
        }
        if (!*p)
            break;
        p++;
    }
    return nOctects;
}


BOOL IsValidIPString(LPCWSTR lpsz)
{
    return IPStringToAddr(lpsz) != INADDR_NONE;
}


DWORD IPStringToAddr(LPCWSTR lpsz)
{
    USES_CONVERSION;
    DWORD dw =  inet_addr(W2A(lpsz));
    return dw;
}




/*

#define MAX_OCTECT_DIGITS (3) // IPv4 only

BOOL IsValidIPString(LPCWSTR lpsz)
{
    if (!lpsz)
        return FALSE; // null
    int nLen = wcslen(lpsz);
    if (nLen <= 0)
        return FALSE; // empty
    if ((lpsz[0] == TEXT('.')) || (lpsz[nLen-1] == TEXT('.')) )
        return FALSE; // leading and trailing dots
    for (int k=0; k<nLen; k++)
        if ((lpsz[k] != TEXT('.')) && !isdigit(lpsz[k]))
            return FALSE; // wrong characters

    // look for octects and dots
    WCHAR *p,*q1,*q2;
    p = q1 = q2 = (WCHAR*)lpsz;
    while (TRUE)
    {
        if ( (*p == TEXT('.')) || (*p == TEXT('\0')) && (p >lpsz) )
        {
            q1 = p-1; // point to the digit before the dot
            if ((q1-q2)+1 > MAX_OCTECT_DIGITS)
                return FALSE; // too many digits
            q2 = p+1; // for next loop, set trailing pointer
        }
        if (!*p)
            break; 
        p++;
    }
    return TRUE; // got at the end fine
}

*/

BOOL RemoveInAddrArpaSuffix(LPWSTR lpsz)
{
    if (!lpsz)
        return FALSE;
    // assume NULL terminated string
    size_t nSuffixLen = wcslen(INADDR_ARPA_SUFFIX);
    size_t nLen = wcslen(lpsz);
    // first char in the suffix, if present
    WCHAR* p = lpsz + nLen - nSuffixLen; 
    if ((p < lpsz) || (_wcsicmp(p,INADDR_ARPA_SUFFIX) != 0)) 
        return FALSE; // string too short or not matching suffix
    // got the match, trim the suffix
    ASSERT(*p == L'.');
    *p = NULL;
    return TRUE;
}

DNS_STATUS ValidateDnsNameAgainstServerFlags(LPCWSTR lpszName, 
                                             DNS_NAME_FORMAT format, 
                                             DWORD serverNameChecking)
{
  DNS_STATUS errName = ::DnsValidateName_W(lpszName, format);

  if (errName == ERROR_INVALID_NAME)
  {
    //
    // Always fail for invalid names
    // Invalid names are:
    //    - Longer than 255 characters
    //    - contains label longer than 63 characters
    //    - contains a space
    //    - contains two or more consecutive dots
    //    - begins with a dot
    //    - contains a dot if the name is submitted with format DnsNameHostDomainLabel or DnsNameHostNameLabel
    //
    return errName;
  }

  if (errName == DNS_ERROR_INVALID_NAME_CHAR)
  {
    if (serverNameChecking == DNS_ALLOW_MULTIBYTE_NAMES ||
        serverNameChecking == DNS_ALLOW_ALL_NAMES)
    {
      //
      // If server is set to allow UTF8 or all names let it pass
      //
      return 0;
    }
    else
    {
      //
      // If server is set to Strict RFC or non-RFC fail
      // DNS_ERROR_INVALID_NAME_CHAR will result from the following:
      //    - Contains any of the following invalid characters:  {|}~[\]^':;<=>?@!"#$%`()+/,
      //    - contains an asterisk (*) unless the asterisk is the first label in the multi-labeled name
      //      and submitted with format DnsNameWildcard
      //
      return errName;
    }
  }

  if (errName == DNS_ERROR_NUMERIC_NAME)
  {
    //
    // Always allow numeric names
    //
    return 0;
  }

  if (errName == DNS_ERROR_NON_RFC_NAME)
  {
    if (serverNameChecking == DNS_ALLOW_RFC_NAMES_ONLY)
    {
      //
      // Fail if the server is only allowing strict RFC names
      // DNS_ERROR_NON_RFC_NAME will result from the following:
      //    - Contains at least one extended or Unicode character
      //    - contains underscore (_) unless the underscore is the first character in a label
      //      in the name submitted with format set to DnsNameSrvRecord
      //
      return errName;
    }
    else
    {
      //
      // Allow the name for any other server settings
      //
      return 0;
    }
  }

  return errName;
}


BOOL _HasSuffixAtTheEnd(LPCWSTR lpsz, int nLen, LPCWSTR lpszSuffix)
{
    if (!lpsz)
        return FALSE; // was NULL
    // assume NULL terminated string
    size_t nSuffixLen = wcslen(lpszSuffix);
    // first char in the suffix, if present
    WCHAR* p = (WCHAR*)(lpsz + nLen - nSuffixLen);
    if (p < lpsz)
        return FALSE; // string too short
    if (_wcsicmp(p,lpszSuffix) != 0)
        return FALSE; // not matching suffix

    if (p == lpsz)
        return TRUE; // exactly matching

    // the suffix can be matching, but as part of a label
    if (p[-1] == TEXT('.'))
        return TRUE;

    return FALSE;
}


BOOL _IsValidDnsFwdLookupZoneName(CString& szName)
{
    int nLen = szName.GetLength();

    // this is the "." (root zone)
    if ( nLen == 1 && (szName[0] == TEXT('.')) )
        return TRUE;

    // no dots at the beginning of the name
    if (szName[0] == TEXT('.'))
        return FALSE;

    // we can allow only one dot at the end
    if ( nLen >=2 && szName[nLen-1] == TEXT('.')  && szName[nLen-2] == TEXT('.') )
    {
        return FALSE;
    }

    // do not allow repeated dots
    for (int k=1; k < nLen; k++)
        if ( (szName[k] == TEXT('.')) && (szName[k-1] == TEXT('.')) )
            return FALSE;

    if (_HasSuffixAtTheEnd(szName, nLen, _T("ipv6.int")) || 
        _HasSuffixAtTheEnd(szName, nLen, _T("ipv6.int.")) ||
        _HasSuffixAtTheEnd(szName, nLen, _T("arpa")) ||
        _HasSuffixAtTheEnd(szName, nLen, _T("arpa.")) ||
        _HasSuffixAtTheEnd(szName, nLen, _T("ip6.int")) ||
        _HasSuffixAtTheEnd(szName, nLen, _T("ip6.int.")))
        return FALSE;
    return TRUE;
}

BOOL _IsValidDnsRevLookupZoneName(CString& szName)
{
    int nLen = szName.GetLength();
    // do not allow dots at the beginning
    if (szName[0] == TEXT('.'))
    {
        return FALSE;
    }

    // do not allow repeated dots
    for (int k=1; k < nLen; k++)
    {
        if ( (szName[k] == TEXT('.')) && (szName[k-1] == TEXT('.')) )
        {
            return FALSE;
        }
    }

    if (!_HasSuffixAtTheEnd(szName, nLen, _T("ipv6.int")) &&
        !_HasSuffixAtTheEnd(szName, nLen, _T("ipv6.int.")) &&
        !_HasSuffixAtTheEnd(szName, nLen, _T("arpa")) &&
        !_HasSuffixAtTheEnd(szName, nLen, _T("arpa.")) &&
        !_HasSuffixAtTheEnd(szName, nLen, _T("ip6.int")) &&
        !_HasSuffixAtTheEnd(szName, nLen, _T("ip6.int.")))
    {
        return FALSE;
    }

    // Do not allow our question mark prefix.  Should have been removed.
    if (szName.Find(QUESTION_MARK_PREFIX) != -1)
    {
        return FALSE;
    }

    return TRUE;
}

/*
BOOL _IsValidDnsRevLookupZoneName(CString& szName)
{
    int nLen = szName.GetLength();
    // do not allow dots at the end or at the beginning
    if ( (szName[nLen-1] == TEXT('.')) || (szName[0] == TEXT('.')) )
        return FALSE;

    // do not allow repeated dots
    for (int k=1; k < nLen; k++)
        if ( (szName[k] == TEXT('.')) && (szName[k-1] == TEXT('.')) )
            return FALSE;

    if (!_HasSuffixAtTheEnd(szName, nLen, _T("ip6.int")) && 
        !_HasSuffixAtTheEnd(szName, nLen, _T("arpa")))
        return FALSE;

    return TRUE;
}
*/

BOOL IsValidDnsZoneName(CString& szName, BOOL bFwd)
{
    // check for length
    int nLen = UTF8StringLen(szName);
    if ( (nLen <= 0) || (nLen > MAX_DNS_NAME_LEN))
        return FALSE;

    // do not allow blanks inside the zone name
    if (szName.Find(TEXT(' ')) != -1)
        return FALSE;

    return bFwd ? _IsValidDnsFwdLookupZoneName(szName) :
                _IsValidDnsRevLookupZoneName(szName);
}


///////////////////////////////////////////////////////////////
// helper functions for IPv6 format

void FormatIPv6Addr(CString& szAddr, IPV6_ADDRESS* ipv6Addr)
{
    szAddr.Format(_T("%.4x:%.4x:%.4x:%.4x:%.4x:%.4x:%.4x:%.4x"),
        REVERSE_WORD_BYTES(ipv6Addr->IP6Word[0]),
        REVERSE_WORD_BYTES(ipv6Addr->IP6Word[1]), 
        REVERSE_WORD_BYTES(ipv6Addr->IP6Word[2]), 
        REVERSE_WORD_BYTES(ipv6Addr->IP6Word[3]), 
        REVERSE_WORD_BYTES(ipv6Addr->IP6Word[4]), 
        REVERSE_WORD_BYTES(ipv6Addr->IP6Word[5]), 
        REVERSE_WORD_BYTES(ipv6Addr->IP6Word[6]), 
        REVERSE_WORD_BYTES(ipv6Addr->IP6Word[7])    );
}




//////////////////////////////////////////////////////////////////////////////
// CDNSServerInfoEx

extern LPCSTR _DnsServerRegkeyStringArr[] = {
    DNS_REGKEY_NO_RECURSION,
    DNS_REGKEY_BIND_SECONDARIES,
    DNS_REGKEY_STRICT_FILE_PARSING,
    DNS_REGKEY_ROUND_ROBIN,
    DNS_REGKEY_LOCAL_NET_PRIORITY,
    DNS_REGKEY_SECURE_RESPONSES,
};


CDNSServerInfoEx::CDNSServerInfoEx()
{
    m_pServInfo = NULL;
    m_errServInfo = 0;
}

CDNSServerInfoEx::~CDNSServerInfoEx()
{
    FreeInfo();
}

DNS_STATUS CDNSServerInfoEx::Query(LPCTSTR lpszServerName)
{
    DNS_RPC_SERVER_INFO* pServerInfo = NULL;

    // update original struct
    m_errServInfo = ::DnssrvGetServerInfo(lpszServerName, &pServerInfo);
    if (m_errServInfo != 0)
    {
        if (pServerInfo != NULL)
            ::DnssrvFreeServerInfo(pServerInfo);
        return m_errServInfo;
    }
    ASSERT(pServerInfo != NULL); 
    FreeInfo();
    m_pServInfo = pServerInfo;

    // if we succeeded and it is an NT 4.0 server, change the version info
    if (m_pServInfo->dwVersion == 0)
    {
        m_pServInfo->dwVersion = DNS_SRV_VERSION_NT_4;
    }

    return m_errServInfo;
}

void CDNSServerInfoEx::FreeInfo()
{
    if (m_pServInfo != NULL)
    {
        ::DnssrvFreeServerInfo(m_pServInfo);
        m_pServInfo = NULL;
    }
    m_errServInfo = 0;
}


//////////////////////////////////////////////////////////////////////////////
// CDNSZoneInfoEx
CDNSZoneInfoEx::CDNSZoneInfoEx()
{
    m_pZoneInfo = NULL;
//  m_nAllowsDynamicUpdate = ZONE_UPDATE_OFF;
    m_errZoneInfo = 0;
//  m_errAllowsDynamicUpdate = 0;
}

CDNSZoneInfoEx::~CDNSZoneInfoEx()
{
    FreeInfo();
}

DNS_STATUS CDNSZoneInfoEx::Query(LPCTSTR lpszServerName, LPCTSTR lpszZoneName, 
                                    DWORD)
{
    USES_CONVERSION;
    DNS_RPC_ZONE_INFO* pZoneInfo = NULL;
    LPCSTR lpszAnsiZoneName = W_TO_UTF8(lpszZoneName);

    // update original struct
    m_errZoneInfo = ::DnssrvGetZoneInfo(lpszServerName, lpszAnsiZoneName, &pZoneInfo);

    if (m_errZoneInfo != 0)
    {
        if (pZoneInfo != NULL)
            ::DnssrvFreeZoneInfo(pZoneInfo);
        return m_errZoneInfo;
    }
    ASSERT(pZoneInfo != NULL);
    FreeInfo();
    m_pZoneInfo = pZoneInfo;

    // if we succeeeded and it is an NT 5.0 server, 
    // update additional flags not originally in the zone info struct

/*  
    if (DNS_SRV_MAJOR_VERSION(dwServerVersion) >= DNS_SRV_MAJOR_VERSION_NT_5)
    {
        DWORD dw;
        m_errAllowsDynamicUpdate = ::DnssrvQueryZoneDwordProperty(lpszServerName, 
                                                    lpszAnsiZoneName,
                                                    DNS_REGKEY_ZONE_ALLOW_UPDATE,
                                                    &dw);
        if (m_errAllowsDynamicUpdate == 0)
            m_nAllowsDynamicUpdate = (UINT)dw ;
    }
    return ((m_errZoneInfo == 0) && (m_errAllowsDynamicUpdate == 0)) ?
          0 : (DWORD)-1;
*/
    return (m_errZoneInfo == 0) ? 0 : (DWORD)-1;
}

void CDNSZoneInfoEx::FreeInfo()
{
    if (m_pZoneInfo != NULL)
    {
        ::DnssrvFreeZoneInfo(m_pZoneInfo);
        m_pZoneInfo = NULL;
    }
    m_errZoneInfo = 0;
//  m_errAllowsDynamicUpdate = 0;
}


///////////////////////////////////////////////////////////////////////////////
//////////////////// ERROR MESSAGES HANDLING //////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

int DNSMessageBox(LPCTSTR lpszText, UINT nType)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
   CThemeContextActivator activator;
    return ::AfxMessageBox(lpszText, nType);
}

int DNSMessageBox(UINT nIDPrompt, UINT nType)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
   CThemeContextActivator activator;
    return ::AfxMessageBox(nIDPrompt, nType);
}

int DNSErrorDialog(DNS_STATUS err, UINT nErrorMsgID)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
   CThemeContextActivator activator;
    CString szMsg;
    szMsg.LoadString(nErrorMsgID);
    return DNSErrorDialog(err, szMsg);
}

void DNSDisplaySystemError(DWORD dwErr)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
   CThemeContextActivator activator;
    LPVOID  lpMsgBuf = 0;
        
    FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,    
            NULL,
            dwErr,
            MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
             (LPWSTR) &lpMsgBuf,    0,    NULL);
        
    ::AfxMessageBox ((LPWSTR) lpMsgBuf, MB_OK | MB_ICONINFORMATION);
    // Free the buffer.
    LocalFree (lpMsgBuf);
}

int DNSErrorDialog(DNS_STATUS err, LPCTSTR lpszErrorMsg)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
   CThemeContextActivator activator;

    CString s;
    CString szError;
    if (CDNSErrorInfo::GetErrorString(err,szError))
    {
        s.Format(_T("%s\n%s"), lpszErrorMsg, (LPCTSTR)szError);
    }
    else
    {
        s.Format(_T("%s\n Error 0x%x"), lpszErrorMsg, err);
    }
    return ::AfxMessageBox(s, MB_OK | MB_ICONERROR);
}

void DNSCreateErrorMessage(DNS_STATUS err, UINT nErrorMsgID, CString& refszMessage)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CString szMsg;
    szMsg.LoadString(nErrorMsgID);

    CString szError;
    if (CDNSErrorInfo::GetErrorString(err,szError))
    {
        refszMessage.Format(_T("%s %s"), szMsg, (LPCTSTR)szError);
    }
    else
    {
        refszMessage.Format(_T("%s Error 0x%x"), szMsg, err);
    }
}

int DNSConfirmOperation(UINT nMsgID, CTreeNode* p)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  CString szFmt;
  szFmt.LoadString(nMsgID);
  CString szConfirmMsg;
  szConfirmMsg.Format((LPCWSTR)szFmt, p->GetDisplayName());
  return DNSMessageBox(szConfirmMsg, MB_YESNO);
}


BOOL CDNSErrorInfo::GetErrorString(DNS_STATUS err, CString& szError)
{
  if (GetErrorStringFromTable(err, szError))
    return TRUE;
  return GetErrorStringFromWin32(err, szError);
}



BOOL CDNSErrorInfo::GetErrorStringFromWin32(DNS_STATUS err, CString& szError)
{
  szError.Empty();
  PTSTR ptzSysMsg = NULL;
  int nChars = ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
                      | FORMAT_MESSAGE_FROM_SYSTEM, NULL, err,
                      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                      (PTSTR)&ptzSysMsg, 0, NULL);
  if (nChars > 0)
  {
    szError = ptzSysMsg;
    ::LocalFree(ptzSysMsg);
  }
  return (nChars > 0);
}


struct DNS_ERROR_TABLE_ENTRY
{
    DNS_STATUS dwErr;
    DWORD dwType;
    DWORD dwVal;
};

#define ERROR_ENTRY_TYPE_END ((DWORD)0)
#define ERROR_ENTRY_TYPE_STRINGID ((DWORD)1)

#define ERROR_ENTRY_STRINGID(err)           { err , ERROR_ENTRY_TYPE_STRINGID , IDS_##err },
#define ERROR_ENTRY_STRINGID_EX(err, id)    { err , ERROR_ENTRY_TYPE_STRINGID , id },
#define END_OF_TABLE_ERROR_ENTRY            { 0 , ERROR_ENTRY_TYPE_END, NULL}


BOOL CDNSErrorInfo::GetErrorStringFromTable(DNS_STATUS err, CString& szError)
{
    static DNS_ERROR_TABLE_ENTRY errorInfo[] =
    {
        //  DNS Specific errors (from WINERROR.H, previously they were in DNS.H)
        //  Response codes mapped to non-colliding errors
        ERROR_ENTRY_STRINGID(DNS_ERROR_RCODE_FORMAT_ERROR)    
        ERROR_ENTRY_STRINGID(DNS_ERROR_RCODE_SERVER_FAILURE)  
        ERROR_ENTRY_STRINGID(DNS_ERROR_RCODE_NAME_ERROR)      
        ERROR_ENTRY_STRINGID(DNS_ERROR_RCODE_NOT_IMPLEMENTED) 
        ERROR_ENTRY_STRINGID(DNS_ERROR_RCODE_REFUSED)         
        ERROR_ENTRY_STRINGID(DNS_ERROR_RCODE_NOTAUTH)         
        ERROR_ENTRY_STRINGID(DNS_ERROR_RCODE_NOTZONE)         
        //  Packet format
        ERROR_ENTRY_STRINGID(DNS_INFO_NO_RECORDS)                         
        ERROR_ENTRY_STRINGID(DNS_ERROR_BAD_PACKET)                        
        ERROR_ENTRY_STRINGID(DNS_ERROR_NO_PACKET)                        
        //  General API errors
        ERROR_ENTRY_STRINGID(DNS_ERROR_INVALID_NAME)                      
        ERROR_ENTRY_STRINGID(DNS_ERROR_INVALID_DATA)                      

        ERROR_ENTRY_STRINGID(DNS_ERROR_INVALID_TYPE)                      
        ERROR_ENTRY_STRINGID(DNS_ERROR_INVALID_IP_ADDRESS)                
        ERROR_ENTRY_STRINGID(DNS_ERROR_INVALID_PROPERTY)                  
        //  Zone errors
        ERROR_ENTRY_STRINGID(DNS_ERROR_ZONE_DOES_NOT_EXIST)               
        ERROR_ENTRY_STRINGID(DNS_ERROR_NO_ZONE_INFO)                      
        ERROR_ENTRY_STRINGID(DNS_ERROR_INVALID_ZONE_OPERATION)            
        ERROR_ENTRY_STRINGID(DNS_ERROR_ZONE_CONFIGURATION_ERROR)          
        ERROR_ENTRY_STRINGID(DNS_ERROR_ZONE_HAS_NO_SOA_RECORD)            
        ERROR_ENTRY_STRINGID(DNS_ERROR_ZONE_HAS_NO_NS_RECORDS)            
        ERROR_ENTRY_STRINGID(DNS_ERROR_ZONE_LOCKED)                       

        ERROR_ENTRY_STRINGID(DNS_ERROR_ZONE_CREATION_FAILED)              
        ERROR_ENTRY_STRINGID(DNS_ERROR_ZONE_ALREADY_EXISTS)               
        ERROR_ENTRY_STRINGID(DNS_ERROR_AUTOZONE_ALREADY_EXISTS)           
        ERROR_ENTRY_STRINGID(DNS_ERROR_INVALID_ZONE_TYPE)                 
        ERROR_ENTRY_STRINGID(DNS_ERROR_SECONDARY_REQUIRES_MASTER_IP)      

        ERROR_ENTRY_STRINGID(DNS_ERROR_ZONE_NOT_SECONDARY)                
        ERROR_ENTRY_STRINGID(DNS_ERROR_NEED_SECONDARY_ADDRESSES)          
        ERROR_ENTRY_STRINGID(DNS_ERROR_WINS_INIT_FAILED)                  
        ERROR_ENTRY_STRINGID(DNS_ERROR_NEED_WINS_SERVERS)                 
        //  Datafile errors
        ERROR_ENTRY_STRINGID(DNS_ERROR_PRIMARY_REQUIRES_DATAFILE)         
        ERROR_ENTRY_STRINGID(DNS_ERROR_INVALID_DATAFILE_NAME)             
        ERROR_ENTRY_STRINGID(DNS_ERROR_DATAFILE_OPEN_FAILURE)             
        ERROR_ENTRY_STRINGID(DNS_ERROR_FILE_WRITEBACK_FAILED)             
        ERROR_ENTRY_STRINGID(DNS_ERROR_DATAFILE_PARSING)                  
        //  Database errors
        ERROR_ENTRY_STRINGID(DNS_ERROR_RECORD_DOES_NOT_EXIST)             
        ERROR_ENTRY_STRINGID(DNS_ERROR_RECORD_FORMAT)                     
        ERROR_ENTRY_STRINGID(DNS_ERROR_NODE_CREATION_FAILED)              
        ERROR_ENTRY_STRINGID(DNS_ERROR_UNKNOWN_RECORD_TYPE)               
        ERROR_ENTRY_STRINGID(DNS_ERROR_RECORD_TIMED_OUT)                  

        ERROR_ENTRY_STRINGID(DNS_ERROR_NAME_NOT_IN_ZONE)                  
        ERROR_ENTRY_STRINGID(DNS_ERROR_CNAME_COLLISION)                   
        ERROR_ENTRY_STRINGID(DNS_ERROR_RECORD_ALREADY_EXISTS)             
        ERROR_ENTRY_STRINGID(DNS_ERROR_NAME_DOES_NOT_EXIST)               

        ERROR_ENTRY_STRINGID(DNS_WARNING_PTR_CREATE_FAILED)               
        ERROR_ENTRY_STRINGID(DNS_WARNING_DOMAIN_UNDELETED)                
        //  Operation errors
        ERROR_ENTRY_STRINGID(DNS_INFO_AXFR_COMPLETE)                      
        ERROR_ENTRY_STRINGID(DNS_ERROR_AXFR)                              
        ERROR_ENTRY_STRINGID(DNS_ERROR_DS_UNAVAILABLE)

        // Generic errors (from WINERROR.H)
        ERROR_ENTRY_STRINGID(RPC_S_SERVER_UNAVAILABLE)
        ERROR_ENTRY_STRINGID_EX(RPC_E_ACCESS_DENIED, IDS_ERROR_ACCESS_DENIED)
        ERROR_ENTRY_STRINGID_EX(ERROR_ACCESS_DENIED, IDS_ERROR_ACCESS_DENIED)

    // DS errors from WINERROR.H
        ERROR_ENTRY_STRINGID(DNS_ERROR_NO_BOOTFILE_IF_DS_ZONE)                      

        //  end of table
        END_OF_TABLE_ERROR_ENTRY
    };

    DNS_ERROR_TABLE_ENTRY* pEntry = errorInfo;

    while (pEntry->dwType != ERROR_ENTRY_TYPE_END)
    {
        if (pEntry->dwErr == err)
        {
      if (pEntry->dwType == ERROR_ENTRY_TYPE_STRINGID)
            {
                return szError.LoadString((UINT)pEntry->dwVal);
            }
        }
        pEntry++;
    }
    szError.Empty();
    return FALSE;
}


//////////////////////////////////////////////////////////////////
//  Copied from ds\dns\dnslib\record.c by JeffJon on 4/27/2000
//  modified to support WCHAR
//

WCHAR  DnsSecurityBase64Mapping[] =
{
    L'A', L'B', L'C', L'D', L'E', L'F', L'G', L'H',
    L'I', L'J', L'K', L'L', L'M', L'N', L'O', L'P',
    L'Q', L'R', L'S', L'T', L'U', L'V', L'W', L'X',
    L'Y', L'Z', L'a', L'b', L'c', L'd', L'e', L'f',
    L'g', L'h', L'i', L'j', L'k', L'l', L'm', L'n',
    L'o', L'p', L'q', L'r', L's', L't', L'u', L'v',
    L'w', L'x', L'y', L'z', L'0', L'1', L'2', L'3',
    L'4', L'5', L'6', L'7', L'8', L'9', L'+', L'/'
};


WCHAR
Dns_SecurityBase64CharToBits(IN WCHAR wch64)
/*++

Routine Description:

    Get value of security base64 character.

Arguments:

    ch64 -- character in security base64

Return Value:

    Value of character, only low 6-bits are significant, high bits zero.
    (-1) if not a base64 character.

--*/
{
    //  A - Z map to 0 -25
    //  a - z map to 26-51
    //  0 - 9 map to 52-61
    //  + is 62
    //  / is 63

    //  could do a lookup table
    //  since we can in general complete mapping with an average of three
    //  comparisons, just encode

    if ( wch64 >= L'a' )
    {
        if ( wch64 <= L'z' )
        {
            return static_cast<WCHAR>( wch64 - L'a' + 26 );
        }
    }
    else if ( wch64 >= L'A' )
    {
        if ( wch64 <= L'Z' )
        {
            return static_cast<WCHAR>( wch64 - L'A' );
        }
    }
    else if ( wch64 >= L'0')
    {
        if ( wch64 <= L'9' )
        {
            return static_cast<WCHAR>( wch64 - L'0' + 52 );
        }
        else if ( wch64 == L'=' )
        {
            //*pPadCount++;
            return static_cast<WCHAR>( 0 );
        }
    }
    else if ( wch64 == L'+' )
    {
        return static_cast<WCHAR>( 62 );
    }
    else if ( wch64 == L'/' )
    {
        return static_cast<WCHAR>( 63 );
    }

    //  all misses fall here

    return static_cast<WCHAR>(-1);
}


DNS_STATUS
Dns_SecurityBase64StringToKey(
    OUT     PBYTE           pKey,
    OUT     PDWORD          pKeyLength,
    IN      PWCHAR          pchString,
    IN      DWORD           cchLength
    )
/*++
 
Routine Description:
 
    Write base64 representation of key to buffer.
 
Arguments:
 
    pchString   - base64 string to write
 
    cchLength   - length of string
 
    pKey        - ptr to key to write
 
Return Value:
 
    None
 
--*/
{
    DWORD   blend = 0;
    DWORD   index = 0;
    UCHAR   bits;
    PBYTE   pkeyStart = pKey;
 
    //
    //  Mapping is essentially in 24 bit quantums.
    //  Take 4 characters of string key and convert to 3 bytes of binary key.
    //
 
    while ( cchLength-- )
    {
        bits = static_cast<UCHAR>(Dns_SecurityBase64CharToBits( *pchString++ ));
        if ( bits >= 64 )
        {
            return ERROR_INVALID_PARAMETER;
        }
        blend <<= 6;
        blend |= bits;
        index++;
 
        if ( index == 4 )
        {
            index = 0;
 
            //
            //  The first byte of key is top 8 bits of the 24 bit quantum.
            //
 
            *pKey++ = ( UCHAR ) ( ( blend & 0x00ff0000 ) >> 16 );
 
            if ( cchLength || *( pchString - 1 ) != SECURITY_PAD_CHAR )
            {
                //
                //  There is no padding so the next two bytes of key
                //  are bottom 16 bits of the 24 bit quantum. 
                //
 
                *pKey++ = ( UCHAR ) ( ( blend & 0x0000ff00 ) >> 8 );
                *pKey++ = ( UCHAR ) ( blend & 0x000000ff );
            }
            else if ( *( pchString - 2 ) != SECURITY_PAD_CHAR )
            {
                //
                //  There is one pad character, so we need to get one
                //  more byte of key out of the 24 bit quantum. Make sure
                //  that there are no one bits in the bottom 8 bits of the
                //  quantum.
                //
 
                if ( blend & 0x000000ff )
                {
                    return ERROR_INVALID_PARAMETER;
                }
                *pKey++ = ( UCHAR ) ( ( blend & 0x0000ff00 ) >> 8 );
            }
            else
            {
                //
                //  There are two pad characters. Make sure that there
                //  are no one bits in the bottom 16 bits of the quantum.
                //
                
                if ( blend & 0x0000ffff )
                {
                    return ERROR_INVALID_PARAMETER;
                }
            }
            blend = 0;
        }
    }
 
    //
    //  Base64 representation should always be padded out to an even
    //  multiple of 4 characters.
    //
 
    if ( index == 0 )
    {
        //
        //  Key length does not include padding.
        //
 
        *pKeyLength = ( DWORD ) ( pKey - pkeyStart );
        return ERROR_SUCCESS;
    }
    return ERROR_INVALID_PARAMETER;
}


PWSTR
Dns_SecurityKeyToBase64String(
    IN      PBYTE   pKey,
    IN      DWORD   KeyLength,
    OUT     PWSTR   pchBuffer
    )
/*++

Routine Description:

    Write base64 representation of key to buffer.

Arguments:

    pKey        - ptr to key to write

    KeyLength   - length of key in bytes

    pchBuffer   - buffer to write to (must be adequate for key length)

Return Value:

    Ptr to next byte in buffer after string.

--*/
{
    DWORD   blend = 0;
    DWORD   index = 0;

    //
    //  mapping is essentially in 24bit blocks
    //  read three bytes of key and transform into four 64bit characters
    //

    while ( KeyLength-- )
    {
        blend <<= 8;
        blend += *pKey++;
        index++;

        if ( index == 3)
        {
            *pchBuffer++ = DnsSecurityBase64Mapping[ (blend & 0x00fc0000) >> 18 ];
            *pchBuffer++ = DnsSecurityBase64Mapping[ (blend & 0x0003f000) >> 12 ];
            *pchBuffer++ = DnsSecurityBase64Mapping[ (blend & 0x00000fc0) >> 6 ];
            *pchBuffer++ = DnsSecurityBase64Mapping[ (blend & 0x0000003f) ];
            blend = 0;
            index = 0;
        }
    }

    //
    //  key terminates on byte boundary, but not necessarily 24bit block boundary
    //  shift to fill 24bit block filling with zeros
    //  if two bytes written
    //          => write three 6-bits chars and one pad
    //  if one byte written
    //          => write two 6-bits chars and two pads
    //

    if ( index )
    {
        blend <<= (8 * (3-index));

        *pchBuffer++ = DnsSecurityBase64Mapping[ (blend & 0x00fc0000) >> 18 ];
        *pchBuffer++ = DnsSecurityBase64Mapping[ (blend & 0x0003f000) >> 12 ];
        if ( index == 2 )
        {
            *pchBuffer++ = DnsSecurityBase64Mapping[ (blend & 0x00000fc0) >> 6 ];
        }
        else
        {
            *pchBuffer++ = SECURITY_PAD_CHAR;
        }
        *pchBuffer++ = SECURITY_PAD_CHAR;
    }

    return( pchBuffer );
}

// NOTICE-2002/04/24-artm  ntraid#ntbug9-547641
// Unused functions need to be removed.  I've left in comments in
// case they are later needed.
//DNS_STATUS Dns_SecurityHexToKey(OUT   PBYTE   pKey,
//                                OUT   PDWORD  pKeyLength,
//                                IN    PWSTR   pchString,
//                                IN    DWORD)
//{
//  DWORD byteIdx = 0;
//  size_t strLength = wcslen(pchString);
//  for (UINT idx = 0; idx < strLength; idx++)
//  {
//    CString szTemp;
//    szTemp = pchString[idx++];
//    szTemp += pchString[idx];
//    int result = swscanf(szTemp, L"%x", &(pKey[byteIdx++]));
//    ASSERT(result == 1);
//  }
//
//  *pKeyLength = byteIdx;
//  return ERROR_SUCCESS;
//}
//
//void Dns_SecurityKeyToHexString(IN      PBYTE   pKey,
//                                IN      DWORD   KeyLength,
//                                OUT     CString& strref)
//{
//  strref.Empty();
//  for (DWORD dwIdx = 0; dwIdx < KeyLength; dwIdx++)
//  {
//    CString szTemp;
//    szTemp = strref;
//    strref.Format(L"%s%2.2x", szTemp, pKey[dwIdx]);
//  }
//}

void TimetToFileTime( time_t t, LPFILETIME pft )
{
  LONGLONG ll = Int32x32To64(t, 10000000) + 116444736000000000;
  pft->dwLowDateTime = (DWORD) ll;
  pft->dwHighDateTime = static_cast<DWORD>(ll >>32);
}

DWORD FileTimeToTimet(FILETIME* pft)
{
  LONGLONG ll = 0;
  ll = pft->dwHighDateTime;
  ll = ll << 32;
  ll |= pft->dwLowDateTime;
  ll -= 116444736000000000;
  ll /= 10000000;

  return (DWORD)ll;
}

void ConvertTTLToSystemTime(TIME_ZONE_INFORMATION*,
                            DWORD dwTTL, 
                            SYSTEMTIME* pSysTime)
{
  time_t ttlTime = static_cast<time_t>(dwTTL);

  FILETIME ftTime;
  memset(&ftTime, 0, sizeof(FILETIME));
  TimetToFileTime(ttlTime, &ftTime);

  ::FileTimeToSystemTime(&ftTime, pSysTime);
}

DWORD ConvertSystemTimeToTTL(SYSTEMTIME* pSysTime)
{
 FILETIME ft;
 ::SystemTimeToFileTime(pSysTime, &ft);
 return FileTimeToTimet(&ft);
}

BOOL ConvertTTLToLocalTimeString(const DWORD dwTTL,
                                 CString& strref)
{
   SYSTEMTIME sysLTimeStamp, sysUTimeStamp;
   BOOL bRes = TRUE;

   //
   // Convert from seconds since Jan 1, 1970 to SystemTime
   //
   ConvertTTLToSystemTime(NULL, dwTTL, &sysUTimeStamp);

   strref.Empty();

   //
   // Convert to local SystemTime
   //
   if (!::SystemTimeToTzSpecificLocalTime(NULL, &sysUTimeStamp, &sysLTimeStamp))
   {
      return FALSE;
   }

   //
   // Format the string with respect to locale
   //
   PTSTR ptszDate = NULL;
   int cchDate = 0;

   //
   // Get the date
   //
   cchDate = GetDateFormat(LOCALE_USER_DEFAULT, 0 , 
                           &sysLTimeStamp, NULL, 
                           ptszDate, 0);

   ptszDate = (PTSTR)malloc(sizeof(TCHAR) * cchDate);

   if (ptszDate)
   {
      if (GetDateFormat(LOCALE_USER_DEFAULT, 0, 
                     &sysLTimeStamp, NULL, 
                     ptszDate, cchDate))
      {
         strref = ptszDate;
      }
      else
      {
         strref = L"";
         bRes = FALSE;
      }
      free(ptszDate);
   }
   else
   {
      strref = L"";
      bRes = FALSE;
   }

   PTSTR ptszTime = NULL;

   //
   // Get the time
   //
   cchDate = GetTimeFormat(LOCALE_USER_DEFAULT, 0 , 
                           &sysLTimeStamp, NULL, 
                           ptszTime, 0);

   ptszTime = (PTSTR)malloc(sizeof(TCHAR) * cchDate);
   if (ptszTime)
   {
      if (GetTimeFormat(LOCALE_USER_DEFAULT, 0, 
                        &sysLTimeStamp, NULL, 
                        ptszTime, cchDate))
      {
         strref += _T(" ") + CString(ptszTime);
      }
      else
      {
         strref += _T("");
         bRes = FALSE;
      }
      free(ptszTime);
   }
   else
   {
      strref += _T("");
      bRes = FALSE;
   }

   return bRes;
}

// Converts a base64 BLOB into a string by using 4 characters to represent
// 3 bytes.  Each character is 6bits of the BLOB. If the encoding doesn't
// end on a 3 byte boundary '=' is used as a pad character

CString Base64BLOBToString(PBYTE blob, DWORD blobSizeInBytes)
{
  if (!blob ||
      !blobSizeInBytes)
  {
     return L"";
  }

  // The largest string will have 4 characters for every 3 bytes in the string
  // I have to add one more before multiplying just in case there are pad characters
  // and another for NULL termination

  DWORD stringSize = (((blobSizeInBytes / 3) + 1) * 4) + 1;

  WCHAR* szBuffer = new WCHAR[stringSize];

  if (!szBuffer)
  {
     return L"";
  }

  ::ZeroMemory(szBuffer, stringSize * sizeof(WCHAR));

  PWSTR pszEnd = Dns_SecurityKeyToBase64String(blob, 
                                               blobSizeInBytes,
                                               szBuffer);
  if (pszEnd != NULL)
  {
    //
    // NULL terminate the string
    //
    *pszEnd = L'\0';
  }

  CString result = szBuffer;
  delete[] szBuffer;

  return result;
}

CString Base64BLOBToString(CByteBlob& blob)
{
   return Base64BLOBToString(blob.GetData(), blob.GetSize());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\dnssnap.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dnssnap.h
//
//--------------------------------------------------------------------------


#ifndef _DNSSNAP_H
#define _DNSSNAP_H

//////////////////////////////////////////////////////////////////////////////
// global constants and macros

extern const CLSID CLSID_DNSSnapin;    // In-Proc server GUID
extern const CLSID CLSID_DNSSnapinEx;    // In-Proc server GUID
extern const CLSID CLSID_DNSSnapinAbout;    // In-Proc server GUID
extern const CLSID CLSID_DNSSnapinAboutEx;    // In-Proc server GUID

///////////////////////////////////////////////////////////////////////////////
// RESOURCES

// enumeration for image strips
enum
{
	ROOT_IMAGE = 0,

	SEPARATOR_1,
	
	// 10 (5 regular, 5 test failed) images for server
	SERVER_IMAGE_NOT_LOADED,
	SERVER_IMAGE_LOADING,
	SERVER_IMAGE_LOADED,
	SERVER_IMAGE_UNABLE_TO_LOAD,
	SERVER_IMAGE_ACCESS_DENIED,

	SERVER_IMAGE_NOT_LOADED_TEST_FAIL,
	SERVER_IMAGE_LOADING_TEST_FAIL,
	SERVER_IMAGE_LOADED_TEST_FAIL,
	SERVER_IMAGE_UNABLE_TO_LOAD_TEST_FAIL,
	SERVER_IMAGE_ACCESS_DENIED_TEST_FAIL,

	SEPARATOR_2,

	// 12 (6 primary, 6 secondary) images for zones
	ZONE_IMAGE_1,
	ZONE_IMAGE_LOADING_1,
	ZONE_IMAGE_UNABLE_TO_LOAD_1,
	ZONE_IMAGE_PAUSED_1,
	ZONE_IMAGE_EXPIRED_1,
	ZONE_IMAGE_ACCESS_DENIED_1,

	SEPARATOR_3,

	ZONE_IMAGE_2,
	ZONE_IMAGE_LOADING_2,
	ZONE_IMAGE_UNABLE_TO_LOAD_2,
	ZONE_IMAGE_PAUSED_2,
	ZONE_IMAGE_EXPIRED_2,
	ZONE_IMAGE_ACCESS_DENIED_2,
	
	SEPARATOR_4,
	
	// 4 images for domains
	DOMAIN_IMAGE,
	DOMAIN_IMAGE_UNABLE_TO_LOAD,
	DOMAIN_IMAGE_LOADING,
	DOMAIN_IMAGE_ACCESS_DENIED,
	
	SEPARATOR_5,

	// 4 images for delegated domains
	DELEGATED_DOMAIN_IMAGE,
	DELEGATED_DOMAIN_IMAGE_UNABLE_TO_LOAD,
	DELEGATED_DOMAIN_IMAGE_LOADING,
	DELEGATED_DOMAIN_IMAGE_ACCESS_DENIED,

	SEPARATOR_6,

	// 4 generic images shared by cache, fwd and rev lookup zones
	FOLDER_IMAGE,
	FOLDER_IMAGE_UNABLE_TO_LOAD,
	FOLDER_IMAGE_LOADING,
	FOLDER_IMAGE_ACCESS_DENIED,

	SEPARATOR_7,

	// 1 record image
	RECORD_IMAGE_BASE,
	
	OPEN_FOLDER, // unused
	FOLDER_WITH_HAND,

   SEPARATOR_8,

   // server options nodes
   SERVER_OPTIONS_IMAGE
};

////////////////////////////////////////////////////////////////
// aliases for images indexes that share the same icon

#define ZONE_IMAGE_NOT_LOADED_1				ZONE_IMAGE_1
#define ZONE_IMAGE_NOT_LOADED_2				ZONE_IMAGE_2
#define ZONE_IMAGE_LOADED_1					ZONE_IMAGE_1
#define ZONE_IMAGE_LOADED_2					ZONE_IMAGE_2

#define DOMAIN_IMAGE_NOT_LOADED				DOMAIN_IMAGE
#define DOMAIN_IMAGE_LOADED					DOMAIN_IMAGE

#define	DELEGATED_DOMAIN_IMAGE_NOT_LOADED	DELEGATED_DOMAIN_IMAGE
#define	DELEGATED_DOMAIN_IMAGE_LOADED		DELEGATED_DOMAIN_IMAGE

#define FOLDER_IMAGE_NOT_LOADED				FOLDER_IMAGE
#define FOLDER_IMAGE_LOADED					FOLDER_IMAGE

///////////////////////////////////////////////////////////////
// bitmaps and images constants

#define	BMP_COLOR_MASK RGB(255,0,255) // pink


///////////////////////////////////////////////////////////////
// headers for result pane

#define N_HEADER_COLS (3)
#define N_DEFAULT_HEADER_COLS (3)
#define N_SERVER_HEADER_COLS (1)
#define N_ZONE_HEADER_COLS (3)

#define N_HEADER_NAME	(0)
#define N_HEADER_TYPE	(1)
#define N_HEADER_DATA	(2)
//#define N_HEADER_PARTITION (3)

extern RESULT_HEADERMAP _DefaultHeaderStrings[];
extern RESULT_HEADERMAP _ServerHeaderStrings[];
extern RESULT_HEADERMAP _ZoneHeaderStrings[];

struct ZONE_TYPE_MAP
{
	WCHAR szBuffer[MAX_RESULT_HEADER_STRLEN];
	UINT uResID;
};

extern ZONE_TYPE_MAP _ZoneTypeStrings[];

BOOL LoadZoneTypeResources(ZONE_TYPE_MAP* pHeaderMap, int nCols);

///////////////////////////////////////////////////////////////
// context menus

// Identifiers for each of the commands in the context menu.
enum
{
	// items for the root node
	IDM_SNAPIN_ADVANCED_VIEW,
  IDM_SNAPIN_MESSAGE,
  IDM_SNAPIN_FILTERING,
	IDM_SNAPIN_CONNECT_TO_SERVER,

	// items for the server node
  IDM_SERVER_CONFIGURE,
  IDM_SERVER_CREATE_NDNC,
	IDM_SERVER_NEW_ZONE,
  IDM_SERVER_SET_AGING,
  IDM_SERVER_SCAVENGE,
	IDM_SERVER_UPDATE_DATA_FILES,
  IDM_SERVER_CLEAR_CACHE,
  IDM_SERVER_NSLOOKUP,

  // items for the cache folder
  IDM_CACHE_FOLDER_CLEAR_CACHE,

	// items for the zone node
	IDM_ZONE_UPDATE_DATA_FILE,
  IDM_ZONE_RELOAD,
  IDM_ZONE_TRANSFER,
  IDM_ZONE_RELOAD_FROM_MASTER,

	// items for the domain node
	IDM_DOMAIN_NEW_RECORD,
	IDM_DOMAIN_NEW_DOMAIN,
	IDM_DOMAIN_NEW_DELEGATION,
	IDM_DOMAIN_NEW_HOST,
	IDM_DOMAIN_NEW_ALIAS,
	IDM_DOMAIN_NEW_MX,
	IDM_DOMAIN_NEW_PTR,
	
	// common items
};


DECLARE_MENU(CDNSRootDataMenuHolder)
DECLARE_MENU(CDNSServerMenuHolder)
DECLARE_MENU(CDNSCathegoryFolderHolder)
DECLARE_MENU(CDNSAuthoritatedZonesMenuHolder)
DECLARE_MENU(CDNSCacheMenuHolder);
DECLARE_MENU(CDNSZoneMenuHolder)
DECLARE_MENU(CDNSDomainMenuHolder)
DECLARE_MENU(CDNSRecordMenuHolder)


//
// Toolbar events
//
DECLARE_TOOLBAR_EVENT(toolbarNewServer, 1001)
DECLARE_TOOLBAR_EVENT(toolbarNewRecord, 1002)  
DECLARE_TOOLBAR_EVENT(toolbarNewZone,   1003)

////////////////////////////////////////////////////////////////////////
// CDNSComponentObject (.i.e "view")

class CDNSComponentObject : public CComponentObject
{
BEGIN_COM_MAP(CDNSComponentObject)
	COM_INTERFACE_ENTRY(IComponent) // have to have at least one static entry, so pick one
	COM_INTERFACE_ENTRY_CHAIN(CComponentObject) // chain to the base class
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CDNSComponentObject)

protected:
	virtual HRESULT InitializeHeaders(CContainerNode* pContainerNode);
	virtual HRESULT InitializeBitmaps(CTreeNode* cookie);
  virtual HRESULT InitializeToolbar(IToolbar* pToolbar);
  HRESULT LoadToolbarStrings(MMCBUTTON * Buttons);
};


//////////////////////////////////////////////////////////////////////////
// CDNSDefaultColumnSet

class CDNSDefaultColumnSet : public CColumnSet
{
public :
	CDNSDefaultColumnSet(LPCWSTR lpszColumnID)
		: CColumnSet(lpszColumnID)
	{
		for (int iCol = 0; iCol < N_DEFAULT_HEADER_COLS; iCol++)
		{
         CColumn* pNewColumn = new CColumn(_DefaultHeaderStrings[iCol].szBuffer,
                                             _DefaultHeaderStrings[iCol].nFormat,
                                             _DefaultHeaderStrings[iCol].nWidth,
                                             iCol);

         if (pNewColumn)
         {
            AddTail(pNewColumn);
         }
 		}
	}
};

//////////////////////////////////////////////////////////////////////////
// CDNSServerColumnSet

class CDNSServerColumnSet : public CColumnSet
{
public :
	CDNSServerColumnSet(LPCWSTR lpszColumnID)
		: CColumnSet(lpszColumnID)
	{
		for (int iCol = 0; iCol < N_SERVER_HEADER_COLS; iCol++)
		{
         CColumn* pNewColumn = new CColumn(_ServerHeaderStrings[iCol].szBuffer,
                                          _ServerHeaderStrings[iCol].nFormat,
                                          _ServerHeaderStrings[iCol].nWidth,
                                          iCol);

         if (pNewColumn)
         {
            AddTail(pNewColumn);
         }
 		}
	}
};

//////////////////////////////////////////////////////////////////////////
// CDNSZoneColumnSet

class CDNSZoneColumnSet : public CColumnSet
{
public :
	CDNSZoneColumnSet(LPCWSTR lpszColumnID)
		: CColumnSet(lpszColumnID)
	{
		for (int iCol = 0; iCol < N_ZONE_HEADER_COLS; iCol++)
		{
         CColumn* pNewColumn = new CColumn(_ZoneHeaderStrings[iCol].szBuffer,
                                          _ZoneHeaderStrings[iCol].nFormat,
                                          _ZoneHeaderStrings[iCol].nWidth,
                                          iCol);

         if (pNewColumn)
         {
            AddTail(pNewColumn);
         }
 		}
	}
};

////////////////////////////////////////////////////////////////////////
// CDNSComponentDataObjectBase (.i.e "document")

class CDNSComponentDataObjectBase :	public CComponentDataObject
{
BEGIN_COM_MAP(CDNSComponentDataObjectBase)
	COM_INTERFACE_ENTRY(IComponentData) // have to have at least one static entry, so pick one
	COM_INTERFACE_ENTRY_CHAIN(CComponentDataObject) // chain to the base class
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CDNSComponentDataObjectBase)


public:
	CDNSComponentDataObjectBase();
  virtual ~CDNSComponentDataObjectBase()
  {
  }

	// IComponentData interface members
	STDMETHOD(CreateComponent)(LPCOMPONENT* ppComponent);

public:
	static BOOL LoadResources();
private:
	static BOOL FindDialogContextTopic(/*IN*/UINT nDialogID,
                                /*IN*/ HELPINFO* pHelpInfo,
                                /*OUT*/ ULONG* pnContextTopic);

// virtual functions
protected:
	virtual HRESULT OnSetImages(LPIMAGELIST lpScopeImage);
	
	virtual CRootData* OnCreateRootData();

	// help handling
  virtual LPCWSTR GetHTMLHelpFileName();
	virtual void OnNodeContextHelp(CNodeList* pNodeList);
   virtual void OnNodeContextHelp(CTreeNode* pNode);
public:
	virtual void OnDialogContextHelp(UINT nDialogID, HELPINFO* pHelpInfo);

// Timer and Background Thread
protected:
	virtual void OnTimer();
	virtual void OnTimerThread(WPARAM wParam, LPARAM lParam);
	virtual CTimerThread* OnCreateTimerThread();

	DWORD m_dwTime; // in

public:
  CColumnSet* GetColumnSet(LPCWSTR lpszID) 
  { 
    return m_columnSetList.FindColumnSet(lpszID);
  }

private:
  CColumnSetList m_columnSetList;
};



////////////////////////////////////////////////////////////////////////
// CDNSComponentDataObject (.i.e "document")
// primary snapin

class CDNSComponentDataObject :
		public CDNSComponentDataObjectBase,
		public CComCoClass<CDNSComponentDataObject,&CLSID_DNSSnapin>
{
BEGIN_COM_MAP(CDNSComponentDataObject)
	COM_INTERFACE_ENTRY(IComponentData) // have to have at least one static entry, so pick one
	COM_INTERFACE_ENTRY_CHAIN(CDNSComponentDataObjectBase) // chain to the base class
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CDNSComponentDataObject)

DECLARE_REGISTRY_CLSID()

public:
	CDNSComponentDataObject()
	{
	}

	// IPersistStream interface members
	HRESULT STDMETHODCALLTYPE GetClassID(CLSID __RPC_FAR *pClassID)
	{
		ASSERT(pClassID != NULL);
		memcpy(pClassID, (GUID*)&GetObjectCLSID(), sizeof(CLSID));
		return S_OK;
	}

  virtual BOOL IsMultiSelect() { return TRUE; }

};


////////////////////////////////////////////////////////////////////////
// CDNSComponentDataObjectEx (.i.e "document")
// extension snapin

class CDNSComponentDataObjectEx :
		public CDNSComponentDataObjectBase,
		public CComCoClass<CDNSComponentDataObjectEx,&CLSID_DNSSnapinEx>
{
BEGIN_COM_MAP(CDNSComponentDataObjectEx)
	COM_INTERFACE_ENTRY(IComponentData) // have to have at least one static entry, so pick one
	COM_INTERFACE_ENTRY_CHAIN(CDNSComponentDataObjectBase) // chain to the base class
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CDNSComponentDataObjectEx)

DECLARE_REGISTRY_CLSID()

public:
	CDNSComponentDataObjectEx()
	{
		SetExtensionSnapin(TRUE);
	}

	// IPersistStream interface members
	HRESULT STDMETHODCALLTYPE GetClassID(CLSID __RPC_FAR *pClassID)
	{
		ASSERT(pClassID != NULL);
		memcpy(pClassID, (GUID*)&GetObjectCLSID(), sizeof(CLSID));
		return S_OK;
	}

protected:
	virtual HRESULT OnExtensionExpand(LPDATAOBJECT lpDataObject, LPARAM param);
  virtual HRESULT OnRemoveChildren(LPDATAOBJECT lpDataObject, LPARAM arg);
};

//////////////////////////////////////////////////////////////////////////
// CDNSSnapinAbout

class CDNSSnapinAbout :
	public CSnapinAbout,
	public CComCoClass<CDNSSnapinAbout, &CLSID_DNSSnapinAbout>

{
public:
DECLARE_REGISTRY_CLSID()
	CDNSSnapinAbout();
};

//////////////////////////////////////////////////////////////////////////
// CDNSSnapinAboutEx

class CDNSSnapinAboutEx :
	public CSnapinAbout,
	public CComCoClass<CDNSSnapinAboutEx, &CLSID_DNSSnapinAboutEx>

{
public:
DECLARE_REGISTRY_CLSID()
	CDNSSnapinAboutEx();
};



#endif _DNSSNAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\domain.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       domain.cpp
//
//--------------------------------------------------------------------------


#include "preDNSsn.h"
#include <SnapBase.h>

#include "resource.h"
#include "dnsutil.h"
#include "DNSSnap.h"
#include "snapdata.h"

#include "server.h"
#include "domain.h"
#include "record.h"
#include "zone.h"

#include "delegwiz.h"

#ifdef DEBUG_ALLOCATOR
	#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
	#endif
#endif

BOOL _match(LPCWSTR lpszNSName,
			CDNS_A_RecordNode* pARecordNode)
{
	TRACE(_T("NS %s A %s\n"), lpszNSName, pARecordNode->GetString(0));
	return DnsNameCompare_W((LPWSTR)lpszNSName, (LPWSTR)pARecordNode->GetString(0));
}



/////////////////////////////////////////////////////////////////////////
// CNewDomainDialog

class CNewDomainDialog : public CHelpDialog
{
// Construction
public:
	CNewDomainDialog(CDNSDomainNode* pParentDomainNode, 
						CComponentDataObject* pComponentData);   

	enum { IDD = IDD_DOMAIN_ADDNEWDOMAIN };

// Implementation
protected:
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnEditChange();
	afx_msg void OnIPv4CtrlChange();
  afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	DECLARE_MESSAGE_MAP()
private:
	CDNSDomainNode* m_pParentDomainNode;
	CComponentDataObject* m_pComponentData;
	CEdit* GetDomainEdit() { return (CEdit*)GetDlgItem(IDC_EDIT_DOMAIN_NAME);}
	CDNSIPv4Control* GetDomainIPv4Ctrl() 
			{ return (CDNSIPv4Control*)GetDlgItem(IDC_IPEDIT_DOMAIN_NAME);}

	CString	m_szDomainName;
	BOOL	m_bAdvancedView;
	int		m_nOctects;
	int		m_nUTF8ParentLen;
};

BEGIN_MESSAGE_MAP(CNewDomainDialog, CHelpDialog)
	ON_EN_CHANGE(IDC_EDIT_DOMAIN_NAME,OnEditChange)
	ON_EN_CHANGE(IDC_IPEDIT_DOMAIN_NAME, OnIPv4CtrlChange)
END_MESSAGE_MAP()

CNewDomainDialog::CNewDomainDialog(CDNSDomainNode* pParentDomainNode, 
								   CComponentDataObject* pComponentData)
	: CHelpDialog(CNewDomainDialog::IDD, pComponentData)
{
	ASSERT(pParentDomainNode != NULL);
	ASSERT(pComponentData != NULL);
	m_pParentDomainNode = pParentDomainNode;
	m_pComponentData = pComponentData;
	m_bAdvancedView = TRUE;
	m_nOctects = -1; // invalid if advanced view
	m_nUTF8ParentLen = UTF8StringLen(pParentDomainNode->GetFullName());
}

BOOL CNewDomainDialog::OnInitDialog() 
{
	CHelpDialog::OnInitDialog();

	// move the edit box in place of the IP control
	CDNSIPv4Control* pNameIPCtrl = GetDomainIPv4Ctrl();
	CEdit* pNameEdit = GetDomainEdit();
	pNameEdit->SetLimitText(MAX_DNS_NAME_LEN - m_nUTF8ParentLen - 1);
	CRect editRect;
	pNameEdit->GetWindowRect(editRect);
	ScreenToClient(editRect);
	CRect ipRect;
	pNameIPCtrl->GetWindowRect(ipRect);
	ScreenToClient(ipRect);
	ipRect.bottom = editRect.top + ipRect.Height();
	ipRect.right = editRect.left + ipRect.Width();
	ipRect.top = editRect.top;
	ipRect.left = editRect.left;
	pNameIPCtrl->MoveWindow(ipRect,TRUE);

	// determine if we need/can have advanced view
	CDNSRootData* pRootData = (CDNSRootData*)m_pComponentData->GetRootData();
	ASSERT(pRootData != NULL);
	m_bAdvancedView = pRootData->IsAdvancedView();

	// force advanced view if we are in a forward lookup zone
	if (!(m_pParentDomainNode->GetZoneNode()->IsReverse()))
		m_bAdvancedView = TRUE;

	// determine if we can have a normal view representation
	CString szDomainName = m_pParentDomainNode->GetFullName();
	if (!m_bAdvancedView)
	{
		// to have normal view we have to have a valid arpa suffix
		BOOL bArpa = RemoveInAddrArpaSuffix(szDomainName.GetBuffer(1));
		szDomainName.ReleaseBuffer(); // got "77.80.55.157"
		if (!bArpa)
		{
			m_bAdvancedView = TRUE; // no need to toggle
		}
		else
		{
			m_nOctects = ReverseIPString(szDomainName.GetBuffer(1));
			szDomainName.ReleaseBuffer(); // finally got "157.55.80.77"
			// to have a normal view representation we cannot 
			// have more than 2 octects
			if (m_nOctects > 2)
			{
				m_bAdvancedView = TRUE; // force advanced for classless
			}
			else
			{
				ASSERT(m_nOctects > 0);
				switch(m_nOctects)
				{
				case 1: // e.g. "157", now "157._"
					szDomainName += _T(".0.0"); // got "157._.0.0"
					break;
				case 2: // e.g. "157.55"
					szDomainName += _T(".0"); // got "157.55._.0"
					break;
				};
				// set the IP control with IP mask value
				IP_ADDRESS ipAddr = IPStringToAddr(szDomainName);
				ASSERT(ipAddr != INADDR_NONE);
				pNameIPCtrl->SetIPv4Val(ipAddr);

				for (int k=0; k<4; k++)
					pNameIPCtrl->EnableField(k, k == m_nOctects);	
			}
		}

	} // if (!m_bAdvancedView) 

	
  // toggle text in static control
  CDNSToggleTextControlHelper staticTextToggle;
	UINT pnButtonStringIDs[2] = { IDS_NEW_DOMAIN_INST1, IDS_NEW_DOMAIN_INST2 };
  VERIFY(staticTextToggle.Init(this, IDC_STATIC_TEXT, pnButtonStringIDs));
  staticTextToggle.SetToggleState(m_bAdvancedView);

  //
  // enable/hide appropriate controls
  //
	if (m_bAdvancedView)
	{
		pNameIPCtrl->EnableWindow(FALSE);
		pNameIPCtrl->ShowWindow(FALSE);
	}
	else
	{
		pNameEdit->EnableWindow(FALSE);
		pNameEdit->ShowWindow(FALSE);
	}

	GetDlgItem(IDOK)->EnableWindow(!m_bAdvancedView);
	return TRUE;  // return TRUE unless you set the focus to a control
}

void CNewDomainDialog::OnEditChange()
{
	ASSERT(m_bAdvancedView);

  //
  // Get new name from control
  //
	GetDomainEdit()->GetWindowText(m_szDomainName);

  //
  // Trim white space
  //
	m_szDomainName.TrimLeft();
	m_szDomainName.TrimRight();

  //
  // Enable OK button if its a valid name
  //
 	CString szFullDomainName;

  if (_wcsicmp(m_pParentDomainNode->GetFullName(), L".") == 0)
  {
    //
    // If the parent domain is the root zone just check the name followed by a '.'
    //
    szFullDomainName.Format(L"%s.", m_szDomainName);
  }
  else
  {
    //
    // Else append the parent domain name to the new name
    //
    szFullDomainName.Format(L"%s.%s", m_szDomainName, m_pParentDomainNode->GetFullName());
  }
 
  //
  // Get server flags
  //
  DWORD dwNameChecking = m_pParentDomainNode->GetServerNode()->GetNameCheckFlag();

  //
  // Is valid?
  //
  BOOL bIsValidName = (0 == ValidateDnsNameAgainstServerFlags(szFullDomainName, 
                                                              DnsNameDomain, 
                                                              dwNameChecking));
	GetDlgItem(IDOK)->EnableWindow(bIsValidName);
}

void CNewDomainDialog::OnIPv4CtrlChange()
{
	ASSERT(!m_bAdvancedView);
	CDNSIPv4Control* pNameIPCtrl = GetDomainIPv4Ctrl();
	DWORD dwArr[4];
	pNameIPCtrl->GetArray(dwArr, 4);
	BOOL bEmpty = (dwArr[m_nOctects] == FIELD_EMPTY); 
	if (!bEmpty)
	{
		ASSERT(dwArr[m_nOctects] <= 255);
		m_szDomainName.Format(_T("%d"), dwArr[m_nOctects]);
	}
	GetDlgItem(IDOK)->EnableWindow(!bEmpty);
}


void CNewDomainDialog::OnOK()
{
  RECORD_SEARCH recordSearch = RECORD_NOT_FOUND;
  CDNSDomainNode* pNewParentDomain = NULL;
  CString szFullRecordName = m_szDomainName + L"." + m_pParentDomainNode->GetFullName();
  CString szNonExistentDomain;
  CDNSRecordNodeBase* pExistingRecordNode = 0;

  recordSearch = m_pParentDomainNode->GetZoneNode()->DoesContain(szFullRecordName, 
                                                                  m_pComponentData,
                                                                  &pNewParentDomain,
                                                                  &pExistingRecordNode,
                                                                  szNonExistentDomain,
                                                                  TRUE);

  if (recordSearch == RECORD_NOT_FOUND && 
      pNewParentDomain != NULL)
  {
	  DNS_STATUS err = pNewParentDomain->CreateSubdomain(m_szDomainName,m_pComponentData);
	  if (err != 0)
	  {
		  // creation error, warn the user and prompt again
		  DNSErrorDialog(err, IDS_MSG_DOMAIN_FAIL_CREATE);
		  CEdit* pDomainNameEdit = GetDomainEdit();
		  pDomainNameEdit->SetSel(0,-1);
		  pDomainNameEdit->SetFocus();
		  return;
	  }
  }
  else if (recordSearch == NON_EXISTENT_SUBDOMAIN && pNewParentDomain != NULL)
  {
	  CDNSRootData* pRootData = (CDNSRootData*)m_pComponentData->GetRootData();

    //
    // Create the node on the server
    //
    CDNSDomainNode* pNewDomainNode = pNewParentDomain->CreateSubdomainNode();
    if (pNewDomainNode == NULL)
    {
      ASSERT(pNewDomainNode != NULL);
      return;
    }

    pNewParentDomain->SetSubdomainName(pNewDomainNode, m_szDomainName, pRootData->IsAdvancedView());

    //
	  // tell the newly created object to write to the server
    //
	  DNS_STATUS err = pNewDomainNode->Create();
	  if (err != 0)
    {
      DNSErrorDialog(err, IDS_MSG_DOMAIN_FAIL_CREATE);
      return;
    }


    if (!szNonExistentDomain.IsEmpty())
    {
      //
      // Create the first subdomain because the current domain is already enumerated
      // so we have to start the remaining enumeration at the new subdomain that is needed
      //
	    CDNSDomainNode* pSubdomainNode = pNewParentDomain->CreateSubdomainNode();
	    ASSERT(pSubdomainNode != NULL);
	    pNewParentDomain->SetSubdomainName(pSubdomainNode, szNonExistentDomain, pRootData->IsAdvancedView());

      VERIFY(pNewParentDomain->AddChildToListAndUISorted(pSubdomainNode, m_pComponentData));
      m_pComponentData->SetDescriptionBarText(pNewParentDomain);

      //
      // I don't care what the results of this are, I am just using it 
      // to do the expansion to the new record
      //
      recordSearch = pSubdomainNode->GetZoneNode()->DoesContain(szFullRecordName, 
                                                                 m_pComponentData,
                                                                 &pNewParentDomain,
                                                                 &pExistingRecordNode,
                                                                 szNonExistentDomain,
                                                                 TRUE);
    }
  }
  else if (recordSearch == RECORD_NOT_FOUND_AT_THE_NODE)
  {
    //
    // Do nothing since this is a domain and it already exists
    //
  }
  else
  {
	  DNS_STATUS err = m_pParentDomainNode->CreateSubdomain(m_szDomainName,m_pComponentData);
	  if (err != 0)
	  {
		  // creation error, warn the user and prompt again
		  DNSErrorDialog(err, IDS_MSG_DOMAIN_FAIL_CREATE);
		  CEdit* pDomainNameEdit = GetDomainEdit();
		  pDomainNameEdit->SetSel(0,-1);
		  pDomainNameEdit->SetFocus();
		  return;
	  }
  }
	CHelpDialog::OnOK();
}

/////////////////////////////////////////////////////////////////////////
// CDNSDomainQueryObj

class CDNSDomainMsg : public CObjBase
{
};


BOOL CDNSDomainQueryObj::Enumerate()
{
	USES_CONVERSION;
	TRACE(_T("CDNSDomainQueryObj::Enumerate(): Server <%s> Zone/Domain %s Enumerating\n"), (LPCTSTR)m_szServerName, (LPCTSTR)m_szNodeName);

	DNS_STATUS err = 0;

  // if needed, get the zone info
	if (m_bIsZone && !m_bCache)
	{
		CDNSZoneInfoEx* pZoneInfo = new CDNSZoneInfoEx;
      if (pZoneInfo)
      {
		   err = pZoneInfo->Query(m_szServerName, m_szFullNodeName, m_dwServerVersion);
		   if (err != 0)
		   {
			   delete pZoneInfo;
			   pZoneInfo = NULL;
			   OnError(err);
			   return FALSE; // no need to enumerate if we have no zone info
		   }
		   else
		   {
			   VERIFY(AddQueryResult(pZoneInfo));
		   }
      }
      else
      {
         OnError(ERROR_OUTOFMEMORY);
         return FALSE;
      }
	}


  // if executing a query for a specific RR type, just do it right away
  if (m_wRecordType != DNS_TYPE_ALL)
  {
    // we assume that a type specific query does not have filtering enabled
    ASSERT(m_bGetAll);
    ASSERT(m_nFilterOption == DNS_QUERY_FILTER_DISABLED);
    err = EnumerateFiltered(m_wRecordType);
    if (err != 0)
      OnError(err);
    return FALSE; // we are done
  }

  // DO A MULTI PASS QUERY
  m_bFirstPass = TRUE;

  // there are items that cannot be filtered out for consistency
  // (zone info, SOA, Ns, etc.), so we disable any filtering while
  // getting them
  BOOL bGetAllOld = m_bGetAll;
  BOOL nFilterOptionOld = m_nFilterOption;
  m_bGetAll = TRUE;
  m_nFilterOption = DNS_QUERY_FILTER_DISABLED;

  
  // only zones or the cache have SOA RR's
  if (m_bIsZone || m_bCache)
  {
    err = EnumerateFiltered(DNS_TYPE_SOA);
    if (err != 0)
    {
		  OnError(err);
	    return FALSE;
    }
  }

  // only zones have WINS and NBSTAT RR's
  if (m_bIsZone)
  {
    if (m_bReverse)
      err = EnumerateFiltered(DNS_TYPE_NBSTAT);
    else
      err = EnumerateFiltered(DNS_TYPE_WINS);
    if (err != 0)
    {
		  OnError(err);
	    return FALSE;
    }
  }

  // need also to check for NS (zone or delegation)
  err = EnumerateFiltered(DNS_TYPE_NS);
  if (err != 0)
  {
		OnError(err);
	  return FALSE;
  }

  // add a message in the queue to signal we are done with
  // the first phase
  CDNSDomainMsg* pDomainMsg = new CDNSDomainMsg;
  if (pDomainMsg)
  {
     AddQueryResult(pDomainMsg);
  }
  else
  {
     OnError(ERROR_OUTOFMEMORY);
     return FALSE;
  }

  // now query again, for all RR's, but need to filter the 
  // known types out
  m_bFirstPass = FALSE;

  // restore the filtering parameters we had before
  m_bGetAll = bGetAllOld;
  m_nFilterOption = nFilterOptionOld;

  err = EnumerateFiltered(DNS_TYPE_ALL);
	if (err != 0)
		OnError(err);
	return FALSE;
}


DNS_STATUS CDNSDomainQueryObj::EnumerateFiltered(WORD wRecordType)
{

  DWORD dwSelectFlags = m_dwSelectFlags; 
  // for single type queries, we do not want subfolders
  if (wRecordType != DNS_TYPE_ALL)
    dwSelectFlags |= DNS_RPC_VIEW_NO_CHILDREN;

	return CDNSDomainNode::EnumerateNodes(m_szServerName,
                     m_szZoneName.IsEmpty() ? NULL : (LPCWSTR)m_szZoneName,
										 m_szNodeName,
										 m_szFullNodeName,
										 wRecordType,
										 dwSelectFlags,
										 m_bIsZone,
										 m_bReverse,
										 m_bAdvancedView,
										 this);
}


BOOL CDNSDomainQueryObj::CanAddRecord(WORD wRecordType, LPCWSTR lpszRecordName)
{
  if (m_nFilterOption == DNS_QUERY_FILTER_DISABLED)
    return TRUE; // we have no filtering at all

  // determine if this is a special record type for filtered queries
  BOOL bSpecialType = (wRecordType == DNS_TYPE_SOA) || (wRecordType == DNS_TYPE_NS) ||
    (wRecordType == DNS_TYPE_WINS) || (wRecordType == DNS_TYPE_NBSTAT);

  // in the first pass only special types allowed
  if (m_bFirstPass)
    return bSpecialType;

  // in the second pass do not allow special types
  if (!m_bFirstPass && bSpecialType)
    return FALSE;

  // we are left with normal types, apply the filtering, if required
  if (m_nFilterOption == DNS_QUERY_FILTER_NONE)
    return TRUE; // allow all

  // need to match the record name
  return MatchName(lpszRecordName);
}



/////////////////////////////////////////////////////////////////////////
// CDNSDomainNode

BEGIN_TOOLBAR_MAP(CDNSDomainNode)
  TOOLBAR_EVENT(toolbarNewRecord, OnNewRecord)
END_TOOLBAR_MAP()


// {720132BA-44B2-11d1-B92F-00A0C9A06D2D}
const GUID CDNSDomainNode::NodeTypeGUID =
{ 0x720132ba, 0x44b2, 0x11d1, { 0xb9, 0x2f, 0x0, 0xa0, 0xc9, 0xa0, 0x6d, 0x2d } };


CDNSDomainNode::CDNSDomainNode(BOOL bDelegation)
{
  m_bDelegation = bDelegation;
	m_pZoneNode = NULL;
	m_pNSRecordNodeList = new CDNS_NS_RecordNodeList;
	ASSERT(m_pNSRecordNodeList != NULL);
  m_bHasDataForPropPages = FALSE;
}

CDNSDomainNode::~CDNSDomainNode() 
{
	TRACE(_T("~CDNSDomainNode(), name <%s>\n"),GetDisplayName());
	ASSERT(m_pNSRecordNodeList != NULL);
	delete m_pNSRecordNodeList;
	m_pNSRecordNodeList = NULL;
}

DWORD CDNSDomainNode::GetDefaultTTL()
{
  if ( (m_pZoneNode != NULL) && (m_pZoneNode->GetZoneType() != DNS_ZONE_TYPE_CACHE) )
	  return m_pZoneNode->GetSOARecordMinTTL();
  else
    return (DWORD)0; // no info available from SOA RR
}


void CDNSDomainNode::SetFullDNSName(BOOL bIsZone, 
                                    BOOL, 
				                            LPCTSTR lpszNodeName, 
                                    LPCTSTR lpszParentFullName)
{
	ASSERT(lpszNodeName != NULL);
	ASSERT(lpszParentFullName != NULL);

	if (bIsZone)
	{
    //
		// the two names have to be the same, zone parent of itself
    //
		ASSERT(_wcsicmp(lpszParentFullName, lpszNodeName) == 0);
		m_szFullName = lpszParentFullName;
	}
	else // it is a domain
	{
		ASSERT(_wcsicmp(lpszParentFullName, lpszNodeName) != 0);

    //
		// chain the node name to the parent full name to get the node's full name
    //
		if (lpszParentFullName[0] == L'.' )
		{
      //
			// if parent is "." and name is "bar", get "bar.": this is the case for the root
			// if parent is ".com" and name is "bar", get "bar.com": 
      //
			m_szFullName.Format(_T("%s%s"), lpszNodeName,lpszParentFullName);
		}
		else
		{
      //
			// if parent is "foo.com" and name is "bar", get "bar.foo.com"
      //
			m_szFullName.Format(_T("%s.%s"), lpszNodeName,lpszParentFullName);
		}
	}
	TRACE(_T("CDNSDomainNode::SetFullDNSName() fullName = <%s>\n"), (LPCTSTR)m_szFullName);
}

void CDNSDomainNode::SetDisplayDNSName(BOOL bIsZone, 
                                       BOOL bReverse, 
                                       BOOL bAdvancedView, 
				                               LPCTSTR lpszNodeName, 
                                       LPCTSTR lpszParentFullName)
{
	ASSERT(lpszNodeName != NULL);
	ASSERT(lpszParentFullName != NULL);

  if (_wcsicmp(lpszNodeName, L".") == 0)
  {
    CString szRootString;
    VERIFY(szRootString.LoadString(IDS_ROOT_ZONE_LABEL));
    m_szDisplayName = L"." + szRootString;
  }
  else
  {
	  m_szDisplayName = lpszNodeName;
  }

	if (bIsZone && bReverse && !bAdvancedView)
	{
		CDNSZoneNode::SetZoneNormalViewHelper(m_szDisplayName);
	}
}


void CDNSDomainNode::SetNames(BOOL bIsZone, BOOL bReverse, BOOL bAdvancedView,
							  LPCTSTR lpszNodeName, LPCTSTR lpszParentFullName)
{
	ASSERT(lpszNodeName != NULL);
	ASSERT(lpszParentFullName != NULL);
	TRACE(_T("CDNSDomainNode::SetNames(bIsZone=%d, bReverse=%d, bAdvancedView=%d, lpszNodeName=<%s>, lpszParentFullName=<%s>)\n"),
					bIsZone, bReverse, bAdvancedView, lpszNodeName,lpszParentFullName);
	SetFullDNSName(bIsZone, bReverse, lpszNodeName, lpszParentFullName);
	SetDisplayDNSName(bIsZone, bReverse, bAdvancedView, lpszNodeName, lpszParentFullName);

}


void CDNSDomainNode::ChangePTRRecordsViewOption(BOOL bAdvanced,
				CComponentDataObject* pComponentDataObject)
{
	POSITION pos;
	for( pos = m_containerChildList.GetHeadPosition(); pos != NULL; )
	{
		CTreeNode* pCurrentChild = m_containerChildList.GetNext(pos);

    // recurse down the tree
		CDNSDomainNode* pDomainNode = dynamic_cast<CDNSDomainNode*>(pCurrentChild);
		ASSERT(pDomainNode != NULL);
		pDomainNode->ChangePTRRecordsViewOption(bAdvanced, pComponentDataObject);
	}

  POSITION leafPos;
  for ( leafPos = m_leafChildList.GetHeadPosition(); leafPos != NULL; )
  {
    CTreeNode* pCurrentLeafNode = m_leafChildList.GetNext(leafPos);
		CDNSRecordNodeBase* pRecordNode = dynamic_cast<CDNSRecordNodeBase*>(pCurrentLeafNode);
		if (pRecordNode &&
          DNS_TYPE_PTR == pRecordNode->GetType())
		{
			CDNS_PTR_RecordNode* pPTRRecordNode = (CDNS_PTR_RecordNode*)pRecordNode;
			pPTRRecordNode->ChangeDisplayName(this, bAdvanced);
		}
	}

}


CQueryObj* CDNSDomainNode::OnCreateQuery()
{
  // generic default setting
  WORD wRecordType = DNS_TYPE_ALL;
	DWORD dwSelectFlags = (m_pZoneNode->GetZoneType() == DNS_ZONE_TYPE_CACHE) ?
						DNS_RPC_VIEW_CACHE_DATA : DNS_RPC_VIEW_AUTHORITY_DATA;

  
  if (IsDelegation())
  {
    // special case the delegation: show only NS records and
    // will have no children shown (delegation cut)
    wRecordType = DNS_TYPE_NS;
    dwSelectFlags = DNS_RPC_VIEW_GLUE_DATA | DNS_RPC_VIEW_NO_CHILDREN;
    //dwSelectFlags = DNS_RPC_VIEW_GLUE_DATA | 
    //        DNS_RPC_VIEW_NO_CHILDREN | DNS_RPC_VIEW_ADDITIONAL_DATA;
  }

  BOOL bCache = GetZoneNode()->GetZoneType() == DNS_ZONE_TYPE_CACHE;
  LPCWSTR lpszZoneName = bCache ? NULL : m_pZoneNode->GetFullName();


	CDNSRootData* pRootData = (CDNSRootData*)GetRootContainer();
	ASSERT(pRootData != NULL);
	CDNSDomainQueryObj* pQuery = new
			CDNSDomainQueryObj(GetServerNode()->GetRPCName(),
                          lpszZoneName,
                          GetServerNode()->GetVersion(),
                          GetDisplayName(),
                          m_szFullName,
                          wRecordType,
                          dwSelectFlags,
                          IsZone(),
                          GetZoneNode()->IsReverse(),
                          bCache,
                          pRootData->IsAdvancedView());

  // delegations will not have any filtering option (data consistency)
  if (!IsDelegation())
  {
    pQuery->SetFilterOptions(pRootData->GetFilter());
  }
	return pQuery;
}

BOOL CDNSDomainNode::OnRefresh(CComponentDataObject* pComponentData,
                               CNodeList* pNodeList)
{
  if (pNodeList->GetCount() > 1) // multiple selection
  {
    BOOL bRet = TRUE;
    POSITION pos = pNodeList->GetHeadPosition();
    while (pos != NULL)
    {
      CTreeNode* pNode = pNodeList->GetNext(pos);
      ASSERT(pNode != NULL);

      CNodeList nodeList;
      nodeList.AddTail(pNode);
      if (!pNode->OnRefresh(pComponentData, &nodeList))
      {
        bRet = FALSE;
      }
    }
    return bRet;
  }

  //
  // single selection
  //
	if (CMTContainerNode::OnRefresh(pComponentData, pNodeList))
	{
		GetNSRecordNodeList()->RemoveAll();
    m_bHasDataForPropPages = FALSE;
		return TRUE;
	}
	return FALSE;
}

void CDNSDomainNode::OnThreadExitingNotification(CComponentDataObject* pComponentDataObject)
{
  if (!m_bHasDataForPropPages)
  {
    // never got a CDNSDomainMsg notification object
    // but we are done anyway, so change it back
    m_bHasDataForPropPages = TRUE;
  }
  // call now the base class
  CDNSMTContainerNode::OnThreadExitingNotification(pComponentDataObject);
}

void CDNSDomainNode::OnHaveData(CObjBase* pObj, CComponentDataObject* pComponentDataObject)
{
  if (IS_CLASS(*pObj, CDNSDomainMsg))
  {
    // special case for a "message" object sent through to update verbs
    TRACE(_T("Got CDNSDomainMsg\n"));
    delete pObj;
    ASSERT(!m_bHasDataForPropPages); // should get only once
    m_bHasDataForPropPages = TRUE;
    VERIFY(SUCCEEDED(pComponentDataObject->UpdateVerbState(this)));
    return;
  }

  if (IS_CLASS(*pObj, CDNSDomainNode))
	{
		// assume all the child containers are derived from this class
		CDNSDomainNode* pDomainNode = dynamic_cast<CDNSDomainNode*>(pObj);
		pDomainNode->SetServerNode(GetServerNode());
		pDomainNode->SetZone(m_pZoneNode);
	}
	else
	{
		OnHaveRecord(dynamic_cast<CDNSRecordNodeBase*>(pObj), pComponentDataObject);
	}
	AddChildToListAndUI(dynamic_cast<CTreeNode*>(pObj), pComponentDataObject);
  pComponentDataObject->SetDescriptionBarText(this);
}

void CDNSDomainNode::OnHaveRecord(CDNSRecordNodeBase* pRecordNode, 
								  CComponentDataObject* pComponentDataObject)
{
	WORD wType = pRecordNode->GetType();
	if (wType == DNS_TYPE_PTR)
	{
		ASSERT(pComponentDataObject != NULL); // assume this for PTR
		CDNSRootData* pRootData = (CDNSRootData*)pComponentDataObject->GetRootData();
		ASSERT(pRootData != NULL);
		// if we are in normal view, have to change the 
		// default advanced representation
		BOOL bAdvancedView = pRootData->IsAdvancedView();
		if (!bAdvancedView)
			((CDNS_PTR_RecordNode*)pRecordNode)->ChangeDisplayName(this, bAdvancedView);
	}
	else if (wType == DNS_TYPE_NS)
	{
		ASSERT(pRecordNode->IsAtTheNode());
		GetNSRecordNodeList()->AddTail((CDNS_NS_RecordNode*)pRecordNode);
	}
}

BOOL CDNSDomainNode::OnAddMenuItem(LPCONTEXTMENUITEM2 pContextMenuItem2,
								                   long*)
{ 
	if (pContextMenuItem2->lCommandID == IDM_SNAPIN_ADVANCED_VIEW)
	{
		pContextMenuItem2->fFlags = ((CDNSRootData*)GetRootContainer())->IsAdvancedView() ? MF_CHECKED : 0;
		return TRUE;
	}
	if (pContextMenuItem2->lCommandID == IDM_SNAPIN_FILTERING)
	{
		if (((CDNSRootData*)GetRootContainer())->IsFilteringEnabled())
		{
			pContextMenuItem2->fFlags = MF_CHECKED;
		}
		return TRUE;
	}

	DWORD dwType = m_pZoneNode->GetZoneType();
	BOOL bIsAutocreated = m_pZoneNode->IsAutocreated();
	BOOL bIsSecondaryOrCache = (dwType == DNS_ZONE_TYPE_SECONDARY) || 
										          (dwType == DNS_ZONE_TYPE_CACHE)    ||
                              (dwType == DNS_ZONE_TYPE_STUB);
	BOOL bIsDelegatedDomain = !IsZone() && IsDelegation(); 


	if (bIsSecondaryOrCache || bIsAutocreated || bIsDelegatedDomain)
	{
		return FALSE;
	}

	// different add operations depending on the FWD/REV type
	if (!GetZoneNode()->IsReverse() && 
		(pContextMenuItem2->lCommandID == IDM_DOMAIN_NEW_PTR))
	{
		// do not add a PTR to a FWD lookup zone
		return FALSE;
	}
	if (GetZoneNode()->IsReverse() && 
		  ((pContextMenuItem2->lCommandID == IDM_DOMAIN_NEW_HOST) ||
			  (pContextMenuItem2->lCommandID == IDM_DOMAIN_NEW_MX)))
	{
		// do not add a HOST, MX, ALIAS to a REV lookup zone
		return FALSE;
	}

	// have the menu item added. but it might be grayed out...
	if (m_nState != loaded)
	{
		pContextMenuItem2->fFlags |= MF_GRAYED;
	}
	return TRUE;
}

HRESULT CDNSDomainNode::OnSetToolbarVerbState(IToolbar* pToolbar, 
                                              CNodeList* pNodeList)
{
  HRESULT hr = S_OK;

  //
  // Set the button state for each button on the toolbar
  //
  hr = pToolbar->SetButtonState(toolbarNewServer, ENABLED, FALSE);
  ASSERT(SUCCEEDED(hr));

  hr = pToolbar->SetButtonState(toolbarNewZone, ENABLED, FALSE);
  ASSERT(SUCCEEDED(hr));

  if (pNodeList->GetCount() > 1) // multiple selection
  {
    hr = pToolbar->SetButtonState(toolbarNewRecord, ENABLED, FALSE);
  }
  else if (pNodeList->GetCount() == 1) // single selection
  {
	  DWORD dwType = m_pZoneNode->GetZoneType();
	  BOOL bIsAutocreated = m_pZoneNode->IsAutocreated();
	  BOOL bIsSecondaryOrCache = (dwType == DNS_ZONE_TYPE_SECONDARY) || 
										            (dwType == DNS_ZONE_TYPE_CACHE)    ||
                                (dwType == DNS_ZONE_TYPE_STUB);
	  BOOL bIsDelegatedDomain = !IsZone() && IsDelegation(); 

    BOOL bEnable = TRUE;
	  if (bIsSecondaryOrCache || bIsAutocreated || bIsDelegatedDomain)
	  {
		  bEnable = FALSE;
	  }
    hr = pToolbar->SetButtonState(toolbarNewRecord, ENABLED, bEnable);
  }
  return hr;
}   

BOOL CDNSDomainNode::OnSetDeleteVerbState(DATA_OBJECT_TYPES type, 
                                          BOOL* pbHide,
                                          CNodeList* pNodeList)
{
  if (pNodeList->GetCount() > 1) // multiple selection
  {
    BOOL bRet = TRUE;
    BOOL bRetHide = FALSE;
    *pbHide = FALSE;

    POSITION pos = pNodeList->GetHeadPosition();
    while (pos != NULL)
    {
      CTreeNode* pNode = pNodeList->GetNext(pos);
      ASSERT(pNode != NULL);

      CNodeList nodeList;
      nodeList.AddTail(pNode);
      if (!pNode->OnSetDeleteVerbState(type, &bRetHide, &nodeList))
      {
        bRet = FALSE;
        break;
      }
      if (bRetHide)
      {
        *pbHide = TRUE;
      }
    }
    return bRet;
  }

	*pbHide = FALSE;
	DWORD dwType = m_pZoneNode->GetZoneType();
	BOOL bIsAutocreated = m_pZoneNode->IsAutocreated();
	
	if (IsThreadLocked())
  {
    return FALSE;
  }

  //
	// cannot delete from an autocreate zone/domain
  //
	if (bIsAutocreated)
  {
		return FALSE;
  }

  //
	// cannot delete from a secondary or stub zone, but can delete the zone itself
	// cannot delete the cache 
  //
	if	( 
			  (
				  ( ((dwType == DNS_ZONE_TYPE_SECONDARY) || (dwType == DNS_ZONE_TYPE_STUB)) && !IsZone() ) || // subdomain of secondary
				  ( (dwType == DNS_ZONE_TYPE_CACHE) && IsZone() )			// cache zone itself
			  )
		  )
	{
		 return FALSE;
	}

	return TRUE;
}

BOOL CDNSDomainNode::OnSetRefreshVerbState(DATA_OBJECT_TYPES, 
                                           BOOL* pbHide,
                                           CNodeList*)
{
	*pbHide = FALSE;
	return !IsThreadLocked();
}


HRESULT CDNSDomainNode::OnCommand(long nCommandID, 
                                  DATA_OBJECT_TYPES, 
								                  CComponentDataObject* pComponentData,
                                  CNodeList* pNodeList)
{
  if (pNodeList->GetCount() > 1) // multiple selection
  {
    return E_FAIL;
  }

	switch (nCommandID)
	{
		case IDM_DOMAIN_NEW_DOMAIN:
			OnNewDomain(pComponentData);
			break;
		case IDM_DOMAIN_NEW_DELEGATION:
			OnNewDelegation(pComponentData);
			break;
		case IDM_DOMAIN_NEW_RECORD:
			OnNewRecord(pComponentData, pNodeList);
			break;
		case IDM_DOMAIN_NEW_HOST:
			OnNewHost(pComponentData);
			break;
		case IDM_DOMAIN_NEW_ALIAS:
			OnNewAlias(pComponentData);
			break;
		case IDM_DOMAIN_NEW_MX:
			OnNewMailExchanger(pComponentData);
			break;
		case IDM_DOMAIN_NEW_PTR:
			OnNewPointer(pComponentData);
			break;
		case IDM_SNAPIN_ADVANCED_VIEW:
			((CDNSRootData*)pComponentData->GetRootData())->OnViewOptions(pComponentData);
			break;
		case IDM_SNAPIN_FILTERING:
      {
        if(((CDNSRootData*)pComponentData->GetRootData())->OnFilteringOptions(pComponentData))
        {
          pComponentData->SetDescriptionBarText(this);
        }
      }
			break;
		default:
			ASSERT(FALSE); // Unknown command!
			return E_FAIL;
	}
    return S_OK;
}

LPWSTR CDNSDomainNode::GetDescriptionBarText()
{
  static CString szFilterEnabled;
  static CString szRecordsFormat;

  INT_PTR nContainerCount = GetContainerChildList()->GetCount();
  INT_PTR nLeafCount = GetLeafChildList()->GetCount();

  //
  // If not already loaded, then load the format string L"%d record(s)"
  //
  if (szRecordsFormat.IsEmpty())
  {
    szRecordsFormat.LoadString(IDS_FORMAT_RECORDS);
  }

  //
  // Format the child count into the description bar text
  //
  m_szDescriptionBar.Format(szRecordsFormat, nContainerCount + nLeafCount);

  //
  // Add L"[Filter Activated]" if the filter is on
  //
  if(((CDNSRootData*)GetRootContainer())->IsFilteringEnabled())
  {
    //
    // If not already loaded, then load the L"[Filter Activated]" string
    //
    if (szFilterEnabled.IsEmpty())
    {
      szFilterEnabled.LoadString(IDS_FILTER_ENABLED);
    }
    m_szDescriptionBar += szFilterEnabled;
  }

  return (LPWSTR)(LPCWSTR)m_szDescriptionBar;
}

int CDNSDomainNode::GetImageIndex(BOOL) 
{
	int nIndex = 0;
	BOOL bDelegation = IsDelegation();
	switch (m_nState)
	{
	case notLoaded:
		nIndex = bDelegation ? DELEGATED_DOMAIN_IMAGE_NOT_LOADED : DOMAIN_IMAGE_NOT_LOADED;
		break;
	case loading:
		nIndex = bDelegation ? DELEGATED_DOMAIN_IMAGE_LOADING : DOMAIN_IMAGE_LOADING;
		break;
	case loaded:
		nIndex = bDelegation ? DELEGATED_DOMAIN_IMAGE_LOADED : DOMAIN_IMAGE_LOADED;
		break;
	case unableToLoad:
		nIndex = bDelegation ? DELEGATED_DOMAIN_IMAGE_UNABLE_TO_LOAD : DOMAIN_IMAGE_UNABLE_TO_LOAD;
		break;
	case accessDenied:
		nIndex = bDelegation ? DELEGATED_DOMAIN_IMAGE_ACCESS_DENIED : DOMAIN_IMAGE_ACCESS_DENIED;
		break;
	default:
		ASSERT(FALSE);
	}
	return nIndex;
}



void CDNSDomainNode::OnDelete(CComponentDataObject* pComponentData,
                              CNodeList* pNodeList)
{
  if (pNodeList->GetCount() > 1) // multiple selection
  {
    OnMultiselectDelete(pComponentData, pNodeList);
    return;
  }

  UINT nRet = DNSConfirmOperation(IDS_MSG_DOMAIN_DELETE, this);
	if (IDNO == nRet ||
      IDCANCEL == nRet)
  {
    return;
  }

	if (IsSheetLocked())
	{
		if (!CanCloseSheets())
			return;
		pComponentData->GetPropertyPageHolderTable()->DeleteSheetsOfNode(this);
	}
	ASSERT(!IsSheetLocked());

	DNS_STATUS err = Delete();
	if (err != 0)
	{
		DNSErrorDialog(err, IDS_MSG_DOMAIN_FAIL_DELETE);
		return;
	}
	// now remove from the UI and from the cache
	DeleteHelper(pComponentData);
	delete this; // gone
}

void CDNSDomainNode::OnMultiselectDelete(CComponentDataObject* pComponentData,
                                         CNodeList* pNodeList)
{
  CThemeContextActivator activator;

  UINT nRet = DNSConfirmOperation(IDS_MSG_DOMAIN_MULTI_DELETE, this);
  if (IDCANCEL == nRet ||
      IDNO == nRet)
  {
    return;
  }

  DNS_STATUS* errArray = new DNS_STATUS[pNodeList->GetCount()];
  if (errArray == NULL)
  {
    DNSErrorDialog(E_OUTOFMEMORY, IDS_MSG_DOMAIN_FAIL_DELETE);
    return;
  }

  memset(errArray, 0, sizeof(DNS_STATUS) * pNodeList->GetCount());

  BOOL bErrorOccurred = FALSE;
  UINT idx = 0;
  POSITION pos = pNodeList->GetHeadPosition();
  while (pos != NULL)
  {
    CTreeNode* pTreeNode = pNodeList->GetNext(pos);
    if (pTreeNode != NULL)
    {
	    if (pTreeNode->IsSheetLocked())
	    {
		    if (!pTreeNode->CanCloseSheets())
        {
          idx++;
			    continue;
        }
		    pComponentData->GetPropertyPageHolderTable()->DeleteSheetsOfNode(pTreeNode);
	    }
	    ASSERT(!pTreeNode->IsSheetLocked());

      CDNSDomainNode* pDomainNode = dynamic_cast<CDNSDomainNode*>(pTreeNode);
      if (pDomainNode != NULL)
      {
	      errArray[idx] = pDomainNode->Delete();
	      if (errArray[idx] != 0)
	      {
          bErrorOccurred = TRUE;
          idx++;
		      continue;
	      }
        //
	      // now remove from the UI and from the cache
        //
	      pDomainNode->DeleteHelper(pComponentData);
	      delete pDomainNode; // gone
      }
      else
      {
        //
        // If its not a domain node then it must be a record node
        //
        CDNSRecordNodeBase* pRecordNode = dynamic_cast<CDNSRecordNodeBase*>(pTreeNode);
        if (pRecordNode != NULL)
        {
          errArray[idx] = pRecordNode->DeleteOnServerAndUI(pComponentData);
	        if (errArray[idx] != 0)
	        {
            bErrorOccurred = TRUE;
		        idx++;
		        continue;
	        }
	        delete pRecordNode; // gone
        }
        else
        {
          //
          // What type of node is this???
          //
          ASSERT(FALSE);
        }
      }
    }
    idx++;
  }

  //
  // Now display the errors in some meaningful manner
  //
  if (bErrorOccurred)
  {
    CMultiselectErrorDialog dlg;

    CString szTitle;
    CString szCaption;
    CString szColumnHeader;

    VERIFY(szTitle.LoadString(IDS_MULTISELECT_ERROR_DIALOG_TITLE));
    VERIFY(szCaption.LoadString(IDS_MULTISELECT_ERROR_DIALOG_CAPTION));
    VERIFY(szColumnHeader.LoadString(IDS_MULTISELECT_ERROR_DIALOG_COLUMN_HEADER));

    HRESULT hr = dlg.Initialize(pNodeList, 
                                errArray, 
                                static_cast<UINT>(pNodeList->GetCount()), 
                                szTitle,
                                szCaption,
                                szColumnHeader);
    if (SUCCEEDED(hr))
    {
      dlg.DoModal();
    }
  }
}

void CDNSDomainNode::OnNewDomain(CComponentDataObject* pComponentData)
{
   CThemeContextActivator activator;

   CNewDomainDialog dlg(this, pComponentData);
   // the dialog will do the creation
   dlg.DoModal();
}

void CDNSDomainNode::OnNewDelegation(CComponentDataObject* pComponentData)
{
   CThemeContextActivator activator;

	ASSERT(pComponentData != NULL);
	CDNSMTContainerNode* pContainerNode = (CDNSMTContainerNode*)GetContainer();
	ASSERT(pContainerNode != NULL);
	
   CDNSDelegationWizardHolder* pHolder = 
			new CDNSDelegationWizardHolder(pContainerNode, this, pComponentData);
	
   if (pHolder != NULL)
   {
	   pHolder->DoModalWizard();
   }
}

RECORD_SEARCH CDNSDomainNode::DoesContain(PCWSTR pszRecName, 
                                          CComponentDataObject* pComponentData,
                                          CDNSDomainNode** ppDomainNode,
                                          CDNSRecordNodeBase** ppExistingRecordNode,
                                          CString& szNonExistentDomain,
                                          BOOL bExpandNodes)
{
  CDNSNameTokenizer recordTokenizer(pszRecName);
  CDNSNameTokenizer domainTokenizer((IsZone()) ? GetFullName() : GetDisplayName());

  if (!recordTokenizer.Tokenize(L".") || !domainTokenizer.Tokenize(L"."))
  {
    *ppDomainNode = NULL;
    return RECORD_NOT_FOUND;
  }



  recordTokenizer.RemoveMatchingFromTail(domainTokenizer);

  if (recordTokenizer.GetCount() == 0 && domainTokenizer.GetCount() == 0)
  {
    //
    // Record is "At the node"
    //
    *ppDomainNode = this;
    return RECORD_NOT_FOUND_AT_THE_NODE;
  }
  else if ((recordTokenizer.GetCount() == 0 && domainTokenizer.GetCount() != 0) ||
           (recordTokenizer.GetCount() != 0 && domainTokenizer.GetCount() != 0))
  {
    //
    // I don't understand how we got in this situation.  It means we are searching in
    // the wrong domain.
    //
    ASSERT(FALSE);
    *ppDomainNode = NULL;
    return RECORD_NOT_FOUND;
  }
  else // recordTokenizer.GetCount() != 0 && domainTokenizer.GetCount() == 0
  {
    //
    // Need to search the children lists
    //

    //
    // If the node hasn't been enumerated, do that now
    //
    if (!IsEnumerated())
    {
      if (!bExpandNodes)
      {
        *ppDomainNode = this;
        return DOMAIN_NOT_ENUMERATED;
      }
      else
      {
        //
        // Expand the node
        //
        HWND hWnd = NULL;
	      HRESULT hr = pComponentData->GetConsole()->GetMainWindow(&hWnd);
	      ASSERT(SUCCEEDED(hr));
        CWnd* pParentWnd = CWnd::FromHandle(hWnd);
         CThemeContextActivator activator;

         CNodeEnumerationThread* pNodeEnumThread =
            new CNodeEnumerationThread(pComponentData, this);

         if (pNodeEnumThread)
         {
	         CLongOperationDialog dlg(
			      pNodeEnumThread,
               pParentWnd,
			      IDR_SEARCH_AVI);
	         dlg.DoModal();
         }
      }
    }

    CString szRemaining;
    recordTokenizer.GetRemaining(szRemaining, L".");

    //
    // Search for domains that match the last token remaining in the record name
    //
    POSITION pos = m_containerChildList.GetHeadPosition();
    while (pos != NULL)
    {
      CTreeNode* pCurrentChild = m_containerChildList.GetNext(pos);

      CDNSDomainNode* pDomainNode = dynamic_cast<CDNSDomainNode*>(pCurrentChild);
      if (pDomainNode == NULL)
      {
        ASSERT(FALSE);
        continue;
      }

      if (_wcsicmp(pDomainNode->GetDisplayName(), recordTokenizer.GetTail()) == 0)
      {
        //
        // Found a sub-domain in the path that we have in the UI
        // recurse to see if it or any of its child match pszFullName
        //
        return pDomainNode->DoesContain(
                  szRemaining, 
                  pComponentData, 
                  ppDomainNode, 
                  ppExistingRecordNode,
                  szNonExistentDomain, 
                  bExpandNodes);
      }
    }

    //
    // If the remaining name doesn't match a domain and there
    // is still a '.' in it then there is a non-existent domain
    //
    if (szRemaining.Find(L'.') != -1)
    {
      szNonExistentDomain = recordTokenizer.GetTail();
      *ppDomainNode = this;
      return NON_EXISTENT_SUBDOMAIN;
    }
      
    //
    // Since no domains match, lets check the records
    //
    pos = m_leafChildList.GetHeadPosition();
    while (pos != NULL)
    {
      CTreeNode* pCurrentChild = m_leafChildList.GetNext(pos);
      if (pCurrentChild == NULL)
      {
        ASSERT(FALSE);
        continue;
      }

      if (_wcsicmp(pCurrentChild->GetDisplayName(), szRemaining) == 0)
      {
        //
        // We found the record and its in this domain
        //
        *ppDomainNode = this;

        // the dynamic_cast will return NULL if the node is a zone or domain node

        *ppExistingRecordNode = dynamic_cast<CDNSRecordNodeBase*>(pCurrentChild);
        return RECORD_FOUND;
      }
    }
  }

  *ppDomainNode = this;
  return RECORD_NOT_FOUND;
}


CDNSDomainNode* CDNSDomainNode::FindSubdomainNode(LPCTSTR lpszSubdomainNode)
{
  //
	// assume the string is the name of the subnode as FQDN
  //

  //
  // Check the current node first since it could be zone that is a delegation of
  // one of the protocol domains
  //
  if (_wcsicmp(GetFullName(), lpszSubdomainNode) == 0)
  {
    return this;
  }

	POSITION pos;
	for( pos = m_containerChildList.GetHeadPosition(); pos != NULL; )
	{
		CTreeNode* pCurrentChild = m_containerChildList.GetNext(pos);

    CDNSDomainNode* pSubDomainNode = dynamic_cast<CDNSDomainNode*>(pCurrentChild);
		ASSERT(pSubDomainNode != NULL);
		if (_wcsicmp(pSubDomainNode->GetFullName(), lpszSubdomainNode) == 0)
    {
			return pSubDomainNode;
    }
	}
	return NULL; // not found
}

CDNSDomainNode* CDNSDomainNode::CreateSubdomainNode(BOOL bDelegation)
{
	CDNSDomainNode* pNode = new CDNSDomainNode(bDelegation);
   if (pNode)
   {
	   pNode->SetServerNode(GetServerNode());
	   ASSERT(m_pZoneNode != NULL);
	   pNode->SetZone(m_pZoneNode);
   }

	return pNode;
}

void CDNSDomainNode::SetSubdomainName(CDNSDomainNode* pSubdomainNode,
									  LPCTSTR lpszSubdomainName, BOOL bAdvancedView)
{
	ASSERT(m_pZoneNode != NULL);
	ASSERT(pSubdomainNode != NULL);
	BOOL bReverse = GetZoneNode()->IsReverse();
	pSubdomainNode->SetNames(FALSE, bReverse, bAdvancedView, lpszSubdomainName, GetFullName());
}


DNS_STATUS CDNSDomainNode::CreateSubdomain(CDNSDomainNode* pSubdomainNode, 
											CComponentDataObject* pComponentData)
{
	// tell the newly created object to write to the server
	DNS_STATUS err = pSubdomainNode->Create();
	if (err == 0)
	{
		// success, add to the UI
		VERIFY(AddChildToListAndUI(pSubdomainNode, pComponentData));
    pComponentData->SetDescriptionBarText(this);
	}
	return err;
}

DNS_STATUS CDNSDomainNode::CreateSubdomain(LPCTSTR lpszDomainName,
							CComponentDataObject* pComponentData)
{
	CDNSDomainNode* pSubdomainNode = CreateSubdomainNode();
	ASSERT(pSubdomainNode != NULL);
	CDNSRootData* pRootData = (CDNSRootData*)pComponentData->GetRootData();
	SetSubdomainName(pSubdomainNode, lpszDomainName, pRootData->IsAdvancedView());

	// tell the newly created object to write to the server
	DNS_STATUS err = CreateSubdomain(pSubdomainNode, pComponentData);
	if (err != 0)
	{
		// something went wrong, bail out
		delete pSubdomainNode;
	}
	return err;
}

void CDNSDomainNode::OnNewRecordHelper(CComponentDataObject* pComponentData, WORD wType)
{
   CThemeContextActivator activator;

	ASSERT(pComponentData != NULL);
	if (wType == 0)
	{
		CSelectDNSRecordTypeDialog dlg(this, pComponentData);
		dlg.DoModal();
	}
	else
	{
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
		CString szTitle;
		szTitle.LoadString(IDS_NEW_RECORD_TITLE);
		CDNSRecordPropertyPageHolder recordHolder(this, NULL, pComponentData, wType);
		recordHolder.DoModalDialog(szTitle);
	}
}

HRESULT CDNSDomainNode::OnNewRecord(CComponentDataObject* pComponentData, 
                                    CNodeList* pNodeList)
{
  ASSERT(pNodeList->GetCount() == 1);
	OnNewRecordHelper(pComponentData, 0);
  return S_OK;
}

void CDNSDomainNode::OnNewHost(CComponentDataObject* pComponentData)
{
   CThemeContextActivator activator;

	//AFX_MANAGE_STATE(AfxGetStaticModuleState());
	//OnNewRecordHelper(pComponentData, DNS_TYPE_A);
	CNewHostDialog dlg(this, pComponentData);
	dlg.DoModal();
}

void CDNSDomainNode::OnNewAlias(CComponentDataObject* pComponentData)
{
	OnNewRecordHelper(pComponentData, DNS_TYPE_CNAME);
}

void CDNSDomainNode::OnNewMailExchanger(CComponentDataObject* pComponentData)
{
	OnNewRecordHelper(pComponentData, DNS_TYPE_MX);
}

void CDNSDomainNode::OnNewPointer(CComponentDataObject* pComponentData)
{
	OnNewRecordHelper(pComponentData, DNS_TYPE_PTR);
}

//////////////////////////////////////////////////////////////////////////////////
// display of property pages

BOOL CDNSDomainNode::HasPropertyPages(DATA_OBJECT_TYPES, 
                                      BOOL* pbHideVerb,
                                      CNodeList* pNodeList)
{ 
  if (pNodeList->GetCount() > 1) // multiple selection
  {
    *pbHideVerb = TRUE;
    return FALSE;
  }

	*pbHideVerb = FALSE; // always show the verb

  if (!m_bHasDataForPropPages)
    return FALSE;

	// cannot have property pages only in loaded state
	//if (m_nState != loaded)
	//	return FALSE;
	// have pages if it is a delegation
	return IsDelegation(); 
}

HRESULT CDNSDomainNode::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, 
                                            LONG_PTR handle,
                                            CNodeList* pNodeList)
{
  ASSERT(pNodeList->GetCount() == 1); // multi-select not supported

	ASSERT(m_bHasDataForPropPages);
	ASSERT(IsDelegation() || GetZoneNode()->IsDSIntegrated());
	if (GetSheetCount() > 0)
	{
		CComponentDataObject* pComponentDataObject = 
				((CRootData*)(GetContainer()->GetRootContainer()))->GetComponentDataObject();
		ASSERT(pComponentDataObject != NULL);
		pComponentDataObject->GetPropertyPageHolderTable()->BroadcastSelectPage(this, DOMAIN_HOLDER_NS);
		return S_OK;
	}	
	return CreatePropertyPagesHelper(lpProvider, handle, DOMAIN_HOLDER_NS);
}


void CDNSDomainNode::Show(BOOL bShow, CComponentDataObject* pComponentData)
{
  CDNSMTContainerNode::Show(bShow, pComponentData);
  if (!bShow)
    GetNSRecordNodeList()->RemoveAll();
}

HRESULT CDNSDomainNode::CreatePropertyPagesHelper(LPPROPERTYSHEETCALLBACK lpProvider, 
									LONG_PTR handle, long)
{
	CComponentDataObject* pComponentDataObject = 
			((CRootData*)(GetContainer()->GetRootContainer()))->GetComponentDataObject();
	ASSERT(pComponentDataObject != NULL);
	
   HRESULT hr = S_OK;

	CDNSDomainPropertyPageHolder* pHolder = 
			new CDNSDomainPropertyPageHolder((CDNSDomainNode*)GetContainer(), this, pComponentDataObject);
	
   if (pHolder)
   {
      pHolder->SetSheetTitle(IDS_PROP_SHEET_TITLE_FMT, this);
	   hr = pHolder->CreateModelessSheet(lpProvider, handle);
   }
   else
   {
      hr = E_OUTOFMEMORY;
   }
   return hr;
}

//////////////////////////////////////////////////////////////////////////////////
// Record Sorting in result pane

int FieldCompareHelper(CTreeNode* pNodeA, CTreeNode* pNodeB, int nCol)
{
  int iRet = 0;

  if (nCol == N_HEADER_NAME)
  {
    //
    // If the name column is selected we have to sort PTR records by their
    // address 
    //
    CDNS_PTR_RecordNode* pRecNodeA = dynamic_cast<CDNS_PTR_RecordNode*>(pNodeA);
    CDNS_PTR_RecordNode* pRecNodeB = dynamic_cast<CDNS_PTR_RecordNode*>(pNodeB);

    if (pRecNodeA == NULL && pRecNodeB == NULL)
    {
      //
      // Neither node is a PTR record, process normally
      //
	    LPCTSTR lpszA = pNodeA->GetString(nCol);
	    LPCTSTR lpszB = pNodeB->GetString(nCol);

      //
	    // cannot process NULL strings, have to use ""
      //
      if (lpszA == NULL || lpszB == NULL)
      {
	      ASSERT(FALSE);
        return -1;
      }
	    iRet = _wcsicmp(lpszA, lpszB);
    }
    else if (pRecNodeA == NULL)
    {
      //
      // Push non PTR records down in the list
      //
      iRet = 1;
    }
    else if (pRecNodeB == NULL)
    {
      //
      // Push non PTR records down in the list
      //
      iRet = -1;
    }
    else
    {
      //
      // Both nodes are PTR records, compare their Addresses
      // Subtract one from the other
      // This will result in < 0 returned if the first one is less than the second
      // 0 if they are equal, and > 0 if the first is greater than the second
      //
      LPCWSTR lpszNameA, lpszNameB;
      lpszNameA = pRecNodeA->GetTrueRecordName();
      lpszNameB = pRecNodeB->GetTrueRecordName();
      
      if (lpszNameA == NULL)
      {
        return -1;
      }

      if (lpszNameB == NULL)
      {
        return 1;
      }

      DWORD dwAddrA, dwAddrB;
      int iConverts = swscanf(lpszNameA, L"%d", &dwAddrA);
      if (iConverts != 1)
      {
        return -1;
      }

      iConverts = swscanf(lpszNameB, L"%d", &dwAddrB);
      if (iConverts != 1)
      {
        return 1;
      }

      iRet = dwAddrA - dwAddrB;
    }
  }
  else if (nCol == N_HEADER_DATA)
  {
    //
    // If the data column is selected we have to check the record type so
    // that we can sort by IP address
    //
    CDNS_A_RecordNode* pRecNodeA = dynamic_cast<CDNS_A_RecordNode*>(pNodeA);
    CDNS_A_RecordNode* pRecNodeB = dynamic_cast<CDNS_A_RecordNode*>(pNodeB);

    if (pRecNodeA == NULL && pRecNodeB == NULL)
    {
      //
      // Neither node is an A record, process normally
      //
	    LPCTSTR lpszA = pNodeA->GetString(nCol);
	    LPCTSTR lpszB = pNodeB->GetString(nCol);

      //
	    // cannot process NULL strings, have to use ""
      //
      if (lpszA == NULL || lpszB == NULL)
      {
	      ASSERT(FALSE);
        return -1;
      }
	    iRet = _wcsicmp(lpszA, lpszB);
    }
    else if (pRecNodeA == NULL)
    {
      //
      // Push non A records down in the list
      //
      iRet = 1;
    }
    else if (pRecNodeB == NULL)
    {
      //
      // Push non A records down in the list
      //
      iRet = -1;
    }
    else
    {
      //
      // Both nodes are A records, compare their IP Addresses
      // Subtract one from the other
      // This will result in < 0 returned if the first one is less than the second
      // 0 if they are equal, and > 0 if the first is greater than the second
      //
      DWORD dwIPA, dwIPB;
      dwIPA = pRecNodeA->GetIPAddress();
      dwIPB = pRecNodeB->GetIPAddress();
      
      UINT nOctetCount = 0;
      iRet = 0;
      while (iRet == 0 && nOctetCount < 4)
      {
        iRet = (dwIPA & 0xff) - (dwIPB & 0xff);
        dwIPA = dwIPA >> 8;
        dwIPB = dwIPB >> 8;
        ++nOctetCount;
      }
    }
  }
  else
  {
	  LPCTSTR lpszA = pNodeA->GetString(nCol);
	  LPCTSTR lpszB = pNodeB->GetString(nCol);

    //
	  // cannot process NULL strings, have to use ""
    //
    if (lpszA == NULL || lpszB == NULL)
    {
	    ASSERT(FALSE);
      return -1;
    }
	  iRet = _wcsicmp(lpszA, lpszB);
  }
  return iRet;
}

int CDNSDomainNode::Compare(CTreeNode* pNodeA, CTreeNode* pNodeB, int nCol, long)
{
	// sorting rules for secondary fields
	int nColSec = N_HEADER_TYPE;
  int nColThird = N_HEADER_DATA;
	switch (nCol)
	{
	case N_HEADER_NAME:
		nColSec = N_HEADER_TYPE;
		nColThird = N_HEADER_DATA;
		break;
	case N_HEADER_TYPE:
		nColSec = N_HEADER_NAME;
		nColThird = N_HEADER_DATA;
		break;
	case N_HEADER_DATA:
		nColSec = N_HEADER_NAME;
		nColThird = N_HEADER_TYPE;
		break;
	default:
		ASSERT(FALSE);
	}
	int nResult = FieldCompareHelper(pNodeA, pNodeB, nCol);
	if (nResult != 0)
		return nResult;
	nResult = FieldCompareHelper(pNodeA, pNodeB, nColSec);
	if (nResult != 0)
		return nResult;
	return FieldCompareHelper(pNodeA, pNodeB, nColThird);
}

//////////////////////////////////////////////////////////////////////////////////
// NS record bulk manipulation



// function to the user for confirmation on editing of A records
// associated with an NS record
BOOL _ConfirmEditAction(CDNSRecordNodeEditInfo* pInfo, BOOL bAsk)
{
  if (!bAsk)
    return TRUE; // silently do it

  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  ASSERT(pInfo->m_pRecord->GetType() == DNS_TYPE_A);
  ASSERT(pInfo->m_pRecord != NULL);
  CDNS_A_RecordNode* pARecordNode = (CDNS_A_RecordNode*)pInfo->m_pRecordNode;

  // load format message
  CString szFmt;
  szFmt.LoadString(IDS_MSG_RECORD_DEL_A_FROM_NS);
  
  // compose message
  CString szMsg;
  szMsg.Format((LPCWSTR)szFmt, pARecordNode->GetString(0), pARecordNode->GetString(2));

  return (IDYES == DNSMessageBox(szMsg, MB_YESNO | MB_ICONWARNING ) );
}






void CDNSDomainNode::GetNSRecordNodesInfo(CDNSRecordNodeEditInfoList* pNSInfoList)
{
	ASSERT(pNSInfoList != NULL);
	if (!pNSInfoList->IsEmpty())
	{
		ASSERT(FALSE); // should never happen
		pNSInfoList->RemoveAllNodes();
	}
	CDNS_NS_RecordNodeList* pNodeList = GetNSRecordNodeList();
	
	// for each NS record in the list, create an entry in the info list
	POSITION pos;
	for( pos = pNodeList->GetHeadPosition(); pos != NULL; )
	{
		CDNS_NS_RecordNode* pCurrNode = pNodeList->GetNext(pos);
		ASSERT(pCurrNode != NULL);
		CDNSRecordNodeEditInfo* pNSNodeInfo = new CDNSRecordNodeEditInfo();
    if (pNSNodeInfo)
    {
		  // set the data for the NS record, already in the list, so we do now own the memory
		  pNSNodeInfo->CreateFromExistingRecord(pCurrNode, FALSE /*bOwnMemory*/, TRUE /*bUpdateUI*/);
		  // for the current NS record, find the associated A records
		  FindARecordsFromNSInfo(pCurrNode->GetString(2),pNSNodeInfo->m_pEditInfoList);
		  pNSInfoList->AddTail(pNSNodeInfo);
    }
	}
}


BOOL CDNSDomainNode::HasNSRecords() 
{
	return GetNSRecordNodeList()->GetCount() > 0; 
}

BOOL CDNSDomainNode::UpdateNSRecordNodesInfo(CDNSRecordNodeEditInfoList* pNewInfoList, 
										 CComponentDataObject* pComponentData)
{
	ASSERT(pNewInfoList != NULL);

	// return false if at least one operation failed
	BOOL bRes = TRUE;
	CDNS_NS_RecordNodeList* pNSRecordNodeList = GetNSRecordNodeList();

	// clear the current state in this domain object
	pNSRecordNodeList->RemoveAll();

	// rebuild the current list from the new one, while applying the changes
	POSITION pos;
	for ( pos = pNewInfoList->GetHeadPosition(); pos != NULL; )
	{
		CDNSRecordNodeEditInfo* pCurrentInfo = pNewInfoList->GetNext(pos);
		ASSERT(pCurrentInfo->m_pRecordNode != NULL);
		ASSERT(pCurrentInfo->m_pRecord != NULL);
		switch (pCurrentInfo->m_action)
		{
		case CDNSRecordNodeEditInfo::add:
		case CDNSRecordNodeEditInfo::edit:
			{
				if (pCurrentInfo->Update(this, pComponentData) == 0)
				{
          ASSERT(pCurrentInfo->m_pRecordNode->GetType() == DNS_TYPE_NS);
					pNSRecordNodeList->AddTail((CDNS_NS_RecordNode*)pCurrentInfo->m_pRecordNode);
					pCurrentInfo->m_bOwnMemory = FALSE; // relinquish ownership
				}
				else
				{
					bRes = FALSE; 
				}
			}
			break;
		case CDNSRecordNodeEditInfo::remove:
			{
				if (pCurrentInfo->m_bExisting)
				{
					if (pCurrentInfo->Remove(this, pComponentData) != 0)
						bRes = FALSE;
				}
			}
			break;

      case CDNSRecordNodeEditInfo::none:
         //
         // Do nothing if the the node has been added and then removed without having been applied
         //
         break;

		default:
			{
				ASSERT(pCurrentInfo->m_bOwnMemory == FALSE);
				ASSERT(pCurrentInfo->m_action == CDNSRecordNodeEditInfo::unchanged);

        //
				// We still have to update the NS record because the server needs to 
        // update the record in memory (bug 23905)
        //
        if (pCurrentInfo->Update(this, pComponentData) == 0)
        {
				  pNSRecordNodeList->AddTail((CDNS_NS_RecordNode*)pCurrentInfo->m_pRecordNode);
        }
			}
		}; // switch
		// now we have to apply the changes in the list of A records
		if (pCurrentInfo->m_dwErr == 0 && pCurrentInfo->m_action != CDNSRecordNodeEditInfo::none)
			UpdateARecordsOfNSInfo(pCurrentInfo, pComponentData);
	} // for

	return bRes;
}

// static function
void CDNSDomainNode::UpdateARecordsOfNSInfoHelper(CDNSDomainNode* pDomainNode,
												  CDNSRecordNodeEditInfo* pNSInfo,
											   CComponentDataObject* pComponentData,
                         BOOL bAskConfirmation)
{
	ASSERT(pNSInfo->m_dwErr == 0);
	ASSERT(pNSInfo->m_pRecordNode != NULL);
	ASSERT(pNSInfo->m_pRecordNode->GetType() == DNS_TYPE_NS);
	POSITION pos;

	// get the list of related A records
	CDNSRecordNodeEditInfoList* pNSInfoList = pNSInfo->m_pEditInfoList;

	for( pos = pNSInfoList->GetHeadPosition(); pos != NULL; )
	{
		CDNSRecordNodeEditInfo* pCurrentInfo = pNSInfoList->GetNext(pos);
		ASSERT(pCurrentInfo->m_pRecordNode != NULL);
		ASSERT(pCurrentInfo->m_pRecord != NULL);
		CDNS_A_RecordNode* pARecordNode = (CDNS_A_RecordNode*)pCurrentInfo->m_pRecordNode;
		ASSERT(pNSInfo->m_pRecord != NULL);
		CDNS_NS_Record* pNSRecord = (CDNS_NS_Record*)pNSInfo->m_pRecord;

		BOOL bHostNameChanged = !_match(pNSRecord->m_szNameNode, pARecordNode);
		if (bHostNameChanged)
		{
      // the NS record points to a different host, so need
      // to delete the old A RR and create a new one
      BOOL bRemoveOld = _ConfirmEditAction(pCurrentInfo, bAskConfirmation);

			CDNSRecordNodeEditInfo::actionType oldAction = pCurrentInfo->m_action;
			if (pCurrentInfo->m_bExisting && bRemoveOld)
			{
				// if the A record was an existing one, need to remove first
				pCurrentInfo->m_action = CDNSRecordNodeEditInfo::remove;
				pCurrentInfo->Remove(pDomainNode, pComponentData);
			}
			// now decide if have to add
			if (oldAction == CDNSRecordNodeEditInfo::remove && bRemoveOld)
			{
				// it was meant to be removed anyway
				pCurrentInfo->m_bOwnMemory = TRUE; // edit info will clean up memory
			}
			else
			{
				// it was meant to be edited or added, restore old action code
				pCurrentInfo->m_action = oldAction;
				// change the name of the record
				pCurrentInfo->m_pRecordNode->SetRecordName(pNSRecord->m_szNameNode, FALSE /*bAtTheNode*/);
				// add new A record with different FQDN
				pCurrentInfo->m_action = CDNSRecordNodeEditInfo::add;
				pCurrentInfo->Update(pDomainNode, pComponentData);
				pCurrentInfo->m_bOwnMemory = FALSE; // written im master structures
			}

		}
		else	// the name is still the same
		{
			switch(pNSInfo->m_action)
			{
			case CDNSRecordNodeEditInfo::remove:
				{
					// NS record marked for deletion means removing the associated A records
					if (pCurrentInfo->m_bExisting && _ConfirmEditAction(pCurrentInfo, bAskConfirmation))
					{
						pCurrentInfo->Remove(pDomainNode, pComponentData);
						pCurrentInfo->m_bOwnMemory = TRUE; // it will cleanup itself
					}

				}
				break;
			case CDNSRecordNodeEditInfo::add:
				{
					if (!pCurrentInfo->m_bExisting)
					{
						pCurrentInfo->Update(pDomainNode, pComponentData);
						pCurrentInfo->m_bOwnMemory = FALSE; // written im master structures
					}
				}
				break;
			case CDNSRecordNodeEditInfo::edit:
				{
					// NS host name not changed, just update list of A records
					switch(pCurrentInfo->m_action)
					{
						case CDNSRecordNodeEditInfo::remove:
							{
								if (pCurrentInfo->m_bExisting && _ConfirmEditAction(pCurrentInfo, bAskConfirmation))
								{
									pCurrentInfo->Remove(pDomainNode, pComponentData);
									pCurrentInfo->m_bOwnMemory = TRUE; // it will cleanup itself
								}
							}
							break;
						case CDNSRecordNodeEditInfo::edit:
							{
								// we just changed the TTL
								ASSERT(pCurrentInfo->m_bExisting);
								pCurrentInfo->Update(pDomainNode, pComponentData);
								pCurrentInfo->m_bOwnMemory = FALSE; // written im master structures
							}
							break;
						case CDNSRecordNodeEditInfo::add:
							{
								if (!pCurrentInfo->m_bExisting)
								{
									pCurrentInfo->Update(pDomainNode, pComponentData);
									pCurrentInfo->m_bOwnMemory = FALSE; // written im master structures
								}
							}
							break;
					}; // switch
				}
				break;
			}; // switch
		} // if,else
	} // for

}


void CDNSDomainNode::UpdateARecordsOfNSInfo(CDNSRecordNodeEditInfo* pNSInfo,
											CComponentDataObject* pComponentData)
{
  // create a fake domain object to run a query looking for 
  // A records that match the given list of NS records
	CDNSDummyDomainNode fakeDomain;
	fakeDomain.SetServerNode(GetServerNode());
  fakeDomain.SetZone(GetZoneNode());
  BOOL bAskConfirmation = TRUE; // we migth delete A RR's that we need
	UpdateARecordsOfNSInfoHelper(&fakeDomain, pNSInfo, pComponentData, bAskConfirmation);
}



void CDNSDomainNode::FindARecordsFromNSInfo(LPCTSTR lpszNSName, 
											CDNSRecordNodeEditInfoList* pNSInfoList)
{
	// just call the static version
	CDNSRootData* pRootData = (CDNSRootData*)GetRootContainer();
	ASSERT(pRootData != NULL);

 	DWORD cAddrCount;
	PIP_ADDRESS pipAddrs;
	GetServerNode()->GetListenAddressesInfo(&cAddrCount, &pipAddrs);
  if (cAddrCount == 0)
	{
		// listening on all addresses
		GetServerNode()->GetServerAddressesInfo(&cAddrCount, &pipAddrs);
	}

	FindARecordsFromNSInfo(GetServerNode()->GetRPCName(),
		                     GetServerNode()->GetVersion(), 
                         cAddrCount, pipAddrs,
                         GetZoneNode()->GetFullName(),
                         lpszNSName, 
		                     pNSInfoList, 
                         pRootData->IsAdvancedView());
}

void CDNSDomainNode::FindARecordsFromNSInfo(LPCWSTR lpszServerName, DWORD dwServerVersion,
                      DWORD cServerAddrCount, PIP_ADDRESS pipServerAddrs,
                      LPCWSTR lpszZoneName,
											LPCWSTR lpszNSName, 
											CDNSRecordNodeEditInfoList* pNSInfoList,
											BOOL bAdvancedView)
{
	ASSERT(pNSInfoList != NULL);
	ASSERT(pNSInfoList->IsEmpty());

  // specifically look for A records matching a given NS name

  // set query flags to get all the possible data
	DWORD dwSelectFlags = DNS_RPC_VIEW_AUTHORITY_DATA | DNS_RPC_VIEW_GLUE_DATA |
                        DNS_RPC_VIEW_ADDITIONAL_DATA;

	CDNSDomainQueryObj query(lpszServerName,
                            lpszZoneName,
                            dwServerVersion,
                            NULL, // lpszNodeName, no need here
                            lpszNSName,
                            DNS_TYPE_A,
                            dwSelectFlags,
                            FALSE, // zone
                            FALSE, // reverse
                            FALSE, // cache
                            bAdvancedView);
	query.Enumerate();

	// get record from the queue into the info
	CObjBaseList* pChildList = query.GetQueue();
	//int n = pChildList->GetCount();
	while (!pChildList->IsEmpty())
	{
		CTreeNode* pNode = dynamic_cast<CTreeNode*>(pChildList->RemoveHead());
		if (pNode &&
          !pNode->IsContainer())
		{
			CDNSRecordNodeBase* pRec = (CDNSRecordNodeBase*)pNode;
			if (pRec->GetType() == DNS_TYPE_A)
			{
				TRACE(_T("Record <%s>\n"), pRec->GetString(2));
				pRec->SetRecordName(lpszNSName, FALSE /*bAtTheNode*/);
				CDNSRecordNodeEditInfo* pANodeInfo = new CDNSRecordNodeEditInfo;	
        if (pANodeInfo)
        {
				  // NOTICE: we assume that all the nodes are glue, so we own the memory
				  pANodeInfo->CreateFromExistingRecord(pRec, TRUE /*bOwnMemory*/, FALSE /*bUpdateUI*/);
				  pNSInfoList->AddTail(pANodeInfo);
        }
			}
		}
		else
			delete pNode; // discard
	}

	if (pNSInfoList->GetCount() > 0)
		return; // got the info we needed just using RPC

	// Could not find the A records, we need to try DnsQuery to get info outside the server

	// search using DnsQuery and convert
	PDNS_RECORD pDnsQueryARecordList = NULL;
  
  // if available, use the provided addresses to do a DnsQuery()
  PIP_ARRAY pipArr = NULL;
  if ( (cServerAddrCount > 0) && (pipServerAddrs != NULL) )
  {
 		pipArr = (PIP_ARRAY)malloc(sizeof(DWORD)+sizeof(IP_ADDRESS)*cServerAddrCount);
    if (!pipArr)
    {
      return;
    }
		pipArr->AddrCount = cServerAddrCount;
		memcpy(pipArr->AddrArray, pipServerAddrs, sizeof(IP_ADDRESS)*cServerAddrCount);
  }

	DWORD dwErr = ::DnsQuery((LPWSTR)lpszNSName, DNS_TYPE_A, 
		    DNS_QUERY_NO_RECURSION, pipArr, &pDnsQueryARecordList, NULL);

  if (pipArr)
  {
    free(pipArr);
    pipArr = 0;
  }

  // no luck, try a simple query, with no IP addresses specified

  if (pDnsQueryARecordList == NULL)
  {
    dwErr = ::DnsQuery((LPWSTR)lpszNSName, DNS_TYPE_A, 
		    DNS_QUERY_NO_RECURSION, NULL, &pDnsQueryARecordList, NULL);
  }

	if (pDnsQueryARecordList == NULL)
		return; // failed, no way to resolve IP address

	PDNS_RECORD pCurrDnsQueryRecord = pDnsQueryARecordList; 
	while (pCurrDnsQueryRecord)
	{
		if (pCurrDnsQueryRecord->Flags.S.Section == DNSREC_ANSWER)
		{
			if (pCurrDnsQueryRecord->wType == DNS_TYPE_A)
			{
				// create a record node
				CDNSRecordNodeBase* pRecordNode = 
					CDNSRecordInfo::CreateRecordNode(pCurrDnsQueryRecord->wType);
				pRecordNode->CreateFromDnsQueryRecord(pCurrDnsQueryRecord, 0x0); 

				pRecordNode->SetRecordName(lpszNSName, FALSE /*bAtTheNode*/);
				CDNSRecordNodeEditInfo* pANodeInfo = new CDNSRecordNodeEditInfo;
        if (pANodeInfo)
        {
          pANodeInfo->m_bFromDnsQuery = TRUE;

          //
          // NOTICE: we assume that all the nodes are glue, so we own the memory
          //
				  pANodeInfo->CreateFromExistingRecord(pRecordNode, TRUE /*bOwnMemory*/, FALSE /*bUpdateUI*/);
				  pNSInfoList->AddTail(pANodeInfo);
        }
			}
		}

		// goto next record
		pCurrDnsQueryRecord = pCurrDnsQueryRecord->pNext;
	}

	DnsRecordListFree(pDnsQueryARecordList, DnsFreeRecordListDeep);
}


//////////////////////////////////////////////////////////////////////////////////

DNS_STATUS CDNSDomainNode::EnumerateNodes(LPCTSTR lpszServerName,
                     LPCTSTR lpszZoneName,
										 LPCTSTR lpszNodeName,
										 LPCTSTR lpszFullNodeName,
										 WORD wRecordType,
										 DWORD dwSelectFlag,
										 BOOL, BOOL bReverse, BOOL bAdvancedView,
										 CDNSDomainQueryObj* pQuery)
{
  ASSERT(pQuery != NULL);
  USES_CONVERSION;
  DNS_STATUS err = 0;
  CHAR szStartChildAnsi[3*MAX_DNS_NAME_LEN + 1]; // can have multibyte chars, count NULL
  szStartChildAnsi[0] = NULL;
  WCHAR szStartChild[MAX_DNS_NAME_LEN + 1]; // count NULL
  szStartChild[0] = NULL;

  CTreeNode* pNodeToInsert = NULL; // delayed insert
  CDNSRecordNodeBase* pMoreDataNode = NULL;

  // convert to UTF8 names
  LPCSTR lpszFullNodeNameAnsi = W_TO_UTF8(lpszFullNodeName);
  LPCSTR lpszZoneNameAnsi = W_TO_UTF8(lpszZoneName);

  BOOL bTooMuchData = FALSE; 

  do // while more data
  {
    // get a chunk of data from RPC call
    BYTE* pbRpcBuffer = NULL;
    DWORD cbRpcBufferUsed = 0;

    err = ::DnssrvEnumRecords(lpszServerName,
                              lpszZoneNameAnsi,
                              lpszFullNodeNameAnsi, // e.g. "foo.bar.com."
                              szStartChildAnsi,				// Start Child
                              wRecordType, 
                              dwSelectFlag,
                              NULL, // pszFilterStart
                              NULL, // pszFilterStop
                              &cbRpcBufferUsed, 
                              &pbRpcBuffer);

    if ((err != ERROR_MORE_DATA) && (err != 0))
	   return err; // bail out if there is an error
		
    // walk the memory and build objects
    DNS_RPC_NODE * pDnsNode = (DNS_RPC_NODE *)pbRpcBuffer;
    DNS_RPC_RECORD * pDnsRecord;
    void* pvEndOfRpcBuffer = pbRpcBuffer + cbRpcBufferUsed;
    while ( (!bTooMuchData) && (pDnsNode < pvEndOfRpcBuffer) )
    {
      // get an ANSI null terminated copy
      memcpy(szStartChildAnsi, pDnsNode->dnsNodeName.achName, pDnsNode->dnsNodeName.cchNameLength);
      szStartChildAnsi[pDnsNode->dnsNodeName.cchNameLength] = NULL;

      //
      // get a UNICODE null terminated copy
      //
      if (szStartChildAnsi[0] == NULL)
      {
        szStartChild[0] = NULL;
      }
      else
      {
        DnsUtf8ToWHelper(szStartChild, szStartChildAnsi, pDnsNode->dnsNodeName.cchNameLength+1); 
      }

      if (pDnsNode->dwChildCount || (pDnsNode->dwFlags & DNS_RPC_NODE_FLAG_STICKY))
      {
        BOOL bDelegation = ( ((dwSelectFlag & DNS_RPC_VIEW_CACHE_DATA) == 0) && 
                              ((pDnsNode->dwFlags & DNS_RPC_FLAG_ZONE_ROOT) != 0) );
        CDNSDomainNode* p = NULL;
        if (pQuery->CanAddDomain(szStartChild))
        {
          bTooMuchData = pQuery->TooMuchData();
          if (!bTooMuchData)
          {
            p = new CDNSDomainNode(bDelegation);
            if (p)
            {
               p->SetNames(FALSE, bReverse, bAdvancedView, szStartChild, lpszFullNodeName);
            }
          }
        }
        if (pNodeToInsert != NULL)
        {
          VERIFY(pQuery->AddQueryResult(pNodeToInsert));
        }
        pNodeToInsert = p;
      } 
      pDnsRecord = (DNS_RPC_RECORD *)((BYTE *)pDnsNode + NEXT_DWORD(pDnsNode->wLength));
      ASSERT(IS_DWORD_ALIGNED(pDnsRecord));
      
      //
      // Add the records under that node 
      //
      UINT cRecordCount = pDnsNode->wRecordCount;
      while ( (!bTooMuchData) && (cRecordCount--) )
      {
        CDNSRecordNodeBase* p = NULL;
        BOOL bAtTheNode = szStartChild[0] == NULL;
        LPCWSTR lpszRecordName = (bAtTheNode) ? lpszNodeName : szStartChild;
        if (pQuery->CanAddRecord(pDnsRecord->wType, lpszRecordName))
        {
          TRACE(_T("\tCan add record %ws\n"), lpszRecordName);
          bTooMuchData = pQuery->TooMuchData();
          if (!bTooMuchData)
          {
            if (bAtTheNode)
            {
              p = CDNSRecordInfo::CreateRecordNodeFromRPCData(
              lpszRecordName, pDnsRecord,bAtTheNode);
            }
            else
            {
              // filter out the NS records that are not at the node
              if (pDnsRecord->wType != DNS_TYPE_NS)
              {
                p = CDNSRecordInfo::CreateRecordNodeFromRPCData(
                lpszRecordName, pDnsRecord,bAtTheNode);
              }
            }
          } // if not too much data
        } // if can add

        if (p != NULL)
        {
          p->SetFlagsDown(TN_FLAG_DNS_RECORD_FULL_NAME, !bAdvancedView);
          if (pNodeToInsert != NULL)
          {
            VERIFY(pQuery->AddQueryResult(pNodeToInsert));
          }

          if (pMoreDataNode != NULL)
          {
            //
            // If there was more data check to see if the new node is the same as the 
            // last node from the previous batch. Insert it if they are different, delete
            // it if they are not
            //
            CString szMoreDataName = pMoreDataNode->GetDisplayName();
            CString szPName = p->GetDisplayName();

            if (szMoreDataName == szPName &&
                pMoreDataNode->GetType() == p->GetType() &&
                _wcsicmp(pMoreDataNode->GetString(3), p->GetString(3)) == 0)
            {
              delete pMoreDataNode;
            }
            else
            {
              VERIFY(pQuery->AddQueryResult(pMoreDataNode));
            }
            pMoreDataNode = NULL;
          }
          pNodeToInsert = p;
        }
        else
        {
          if (pMoreDataNode)
          {
            // We might still have to add the "more data" node
            // even if the current node didn't match the filter
 
            VERIFY(pQuery->AddQueryResult(pMoreDataNode));
            pMoreDataNode = NULL;
          }
        }

        pDnsRecord = DNS_NEXT_RECORD(pDnsRecord);
      } // while cRecordCount
      
      // The new node is found at the end of the last record
      pDnsNode = (DNS_RPC_NODE *)pDnsRecord;
    } // while end of buffer


    // we still have a node to insert, but we discard it if there is more data
    // because we are going to get it again and we want to avoid duplication
    if (pNodeToInsert != NULL)
    {
      if (bTooMuchData)
      {
        delete pNodeToInsert;
      }
      else if (err == ERROR_MORE_DATA)
      {
        //
        // Doesn't matter if this turns out NULL because we only want
        // pMoreDataNode to be a record node.  If its a domain node we
        // can just ignore it
        //
        pMoreDataNode = dynamic_cast<CDNSRecordNodeBase*>(pNodeToInsert);
      }
      else
      {
        VERIFY(pQuery->AddQueryResult(pNodeToInsert));
      }
      pNodeToInsert = NULL;
    }

    ::DnssrvFreeRecordsBuffer(pbRpcBuffer);

  } while ( !bTooMuchData && (err == ERROR_MORE_DATA) ) ;

  // we are bailing out because of too much data,
  // need to let the main tread know
  if (bTooMuchData && (err != ERROR_MORE_DATA))
  {
    err = ERROR_MORE_DATA;
  }

  return err;
}


DNS_STATUS CDNSDomainNode::Create()
{
	USES_CONVERSION;
  LPCWSTR lpszFullZoneName = NULL;
  
  CDNSZoneNode* pZoneNode = GetZoneNode();

  if (pZoneNode != NULL)
    lpszFullZoneName = pZoneNode->GetFullName();
	DNS_STATUS err = ::DnssrvUpdateRecord(GetServerNode()->GetRPCName(), 
                     W_TO_UTF8(lpszFullZoneName),
									   W_TO_UTF8(GetFullName()),
									   NULL, NULL);
  return err;
}

DNS_STATUS CDNSDomainNode::Delete()
{
	USES_CONVERSION;
  LPCWSTR lpszFullZoneName = NULL;
  CDNSZoneNode* pZoneNode = GetZoneNode();
  if (pZoneNode != NULL)
    lpszFullZoneName = pZoneNode->GetFullName();

	return ::DnssrvDeleteNode(GetServerNode()->GetRPCName(), 
               W_TO_UTF8(lpszFullZoneName),
						   W_TO_UTF8(GetFullName()),
						   TRUE // fDeleteSubtree
						  );
}


/////////////////////////////////////////////////////////////////////////
// CDNSRootHintsNode



DNS_STATUS CDNSRootHintsNode::QueryForRootHints(LPCTSTR lpszServerName, DWORD dwServerVersion)
{
  USES_CONVERSION;
	DWORD dwSelectFlags = DNS_RPC_VIEW_ROOT_HINT_DATA | DNS_RPC_VIEW_ADDITIONAL_DATA | DNS_RPC_VIEW_NO_CHILDREN;
	CDNSDomainQueryObj query(lpszServerName,
                  UTF8_TO_W(DNS_ZONE_ROOT_HINTS), //lpszZoneName, needs to be "..RootHints" as defined in dnsrpc.h
	                dwServerVersion,
	                GetDisplayName(),
	                m_szFullName,
	                DNS_TYPE_NS,
	                dwSelectFlags,
	                FALSE, // zone
	                FALSE, // reverse
	                FALSE, // cache
	                FALSE);
	query.Enumerate();
	DWORD dwErr = query.GetError();
	if (dwErr != 0)
		return dwErr;
	// get record from the queue into the folder
	CObjBaseList* pChildList = query.GetQueue();
	//int n = pChildList->GetCount();
	while (!pChildList->IsEmpty())
	{
		CTreeNode* pNode = dynamic_cast<CTreeNode*>(pChildList->RemoveHead());
		// NOTICE: for NT 4.0 servers, we get bogus container nodes
		// that we have to suppress
		if(pNode->IsContainer())
		{
			delete pNode;
		}
		else
		{
			OnHaveRecord((CDNSRecordNodeBase*)pNode, NULL); // add to the list of NS records
			AddChildToList(pNode);
		}
	}
	return (DNS_STATUS)dwErr;
}


void CDNSRootHintsNode::FindARecordsFromNSInfo(LPCTSTR lpszNSName, 
											   CDNSRecordNodeEditInfoList* pNSInfoList)
{
	ASSERT(pNSInfoList != NULL);

  //
  // for root hints, we have all the records in this folder and we
	// can edit them
  //

	POSITION pos;
	for( pos = m_leafChildList.GetHeadPosition(); pos != NULL; )
	{
		CTreeNode* pCurrentChild = m_leafChildList.GetNext(pos);
		ASSERT(!pCurrentChild->IsContainer());
		CDNSRecordNodeBase* pRecordNode = dynamic_cast<CDNSRecordNodeBase*>(pCurrentChild);
		if (pRecordNode &&
          DNS_TYPE_A == pRecordNode->GetType())
		{
			CDNS_A_RecordNode* pARecordNode = (CDNS_A_RecordNode*)pRecordNode;
			if (_match(lpszNSName, pARecordNode))
			{
				CDNSRecordNodeEditInfo* pANodeInfo = new CDNSRecordNodeEditInfo;

        //
        // NOTICE: the root hints folder owns the memory
        //
        if (pANodeInfo != NULL)
        {
				  pANodeInfo->CreateFromExistingRecord(pARecordNode, FALSE /*bOwnMemory*/, TRUE /*bUpdateUI*/);
				  pNSInfoList->AddTail(pANodeInfo);
        }
        else
        {
          TRACE(_T("Failed to allocate memory in CDNSRootHintsNode::FindARecordsFromNSInfo"));
          ASSERT(FALSE);
        }
			}
		}
	}
}

void CDNSRootHintsNode::UpdateARecordsOfNSInfo(CDNSRecordNodeEditInfo* pNSInfo,
											   CComponentDataObject* pComponentData)
{
  BOOL bAskConfirmation = FALSE; // need to edit ALL A records
	UpdateARecordsOfNSInfoHelper(this, pNSInfo, pComponentData, bAskConfirmation);
}





DNS_STATUS CDNSRootHintsNode::Clear()
{
  //
	// clear the list of cached NS record pointers
  //
	GetNSRecordNodeList()->RemoveAll();

  //
	// remove all the records from the server
  //
	DNS_STATUS err = 0;
	POSITION pos;

	for( pos = m_leafChildList.GetHeadPosition(); pos != NULL; )
	{
		CTreeNode* pCurrentChild = m_leafChildList.GetNext(pos);
		ASSERT(!pCurrentChild->IsContainer());
		CDNSRecordNodeBase* pRecordNode = (CDNSRecordNodeBase*)pCurrentChild;
		DNS_STATUS currErr = pRecordNode->DeleteOnServer();
		if (currErr != 0)
    {
      //
      // just ge the last error, if any
      //
			err = currErr; 
    }
	}
  //
	// clear the list of children in the folder (we are hidden, so no UI deletions)
  //
	RemoveAllChildrenFromList();
	return err;
}


DNS_STATUS CDNSRootHintsNode::InitializeFromDnsQueryData(PDNS_RECORD pRootHintsRecordList)
{
	// need to remove all the previous root hints from the server
	// let's be sure we get recent data

	// clear the list of children in the folder (we are hidden, so no UI deletions)
	RemoveAllChildrenFromList();
	// acqure the list of current root hints
	CDNSServerNode* pServerNode = GetServerNode();
	DNS_STATUS dwErr = QueryForRootHints(pServerNode->GetRPCName(), pServerNode->GetVersion());
	if (dwErr != 0)
	{
		TRACE(_T("Failed to remove old Root Hints, dwErr = %x hex\n"), dwErr);
		return dwErr;
	}

	// remove all the old root hints from server and client side
	dwErr = Clear();
	if (dwErr != 0)
	{
		TRACE(_T("Failed to clear Root Hints, dwErr = %x hex\n"), dwErr);
		return dwErr;
	}

	// walk through the list of root hints, 
	// convert to C++ format, 
	// write to server and add to the folder list (no UI, folder hidden)
	PDNS_RECORD pCurrDnsQueryRecord = pRootHintsRecordList;
	while (pCurrDnsQueryRecord != NULL)
	{
		ASSERT( (pCurrDnsQueryRecord->wType == DNS_TYPE_A) ||
				(pCurrDnsQueryRecord->wType == DNS_TYPE_NS) );
		// create a record node and read data from DnsQuery format
		CDNSRecordNodeBase* pRecordNode = 
			CDNSRecordInfo::CreateRecordNode(pCurrDnsQueryRecord->wType);
		pRecordNode->CreateFromDnsQueryRecord(pCurrDnsQueryRecord, DNS_RPC_RECORD_FLAG_ZONE_ROOT); 

		// set the record node container
		pRecordNode->SetContainer(this);

		// set the record node name
		BOOL bAtTheNode = (pCurrDnsQueryRecord->wType == DNS_TYPE_NS);
		pRecordNode->SetRecordName(pCurrDnsQueryRecord->pName, bAtTheNode);

		// write on server
		// the default TTL does not apply here 
		DNS_STATUS err = pRecordNode->Update(NULL, FALSE); // NULL = create new, FALSE = use def TTL
		if (err == 0)
			VERIFY(AddChildToList(pRecordNode));
		else
		{
			dwErr = err; // mark las error
			delete pRecordNode; // something went wrong
		}
		pCurrDnsQueryRecord = pCurrDnsQueryRecord->pNext;
	}

  // force a write on the server, to make sure the cache file is written right away
  return CDNSZoneNode::WriteToDatabase(pServerNode->GetRPCName(), DNS_ZONE_ROOT_HINTS);
}

void CDNSRootHintsNode::ShowPageForNode(CComponentDataObject* pComponentDataObject) 
{
	ASSERT(pComponentDataObject != NULL);

   if (pComponentDataObject)
   {
	   pComponentDataObject->GetPropertyPageHolderTable()->BroadcastSelectPage(GetServerNode(), 3);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\dnsutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dnsutil.h
//
//--------------------------------------------------------------------------

#ifndef _DNSUTIL_H
#define _DNSUTIL_H

//#define NTRAID_628931

/////////////////////////////////////////////////////////////////
// C++ helper classes wrapping the raw DNS RPC API's

#define DNS_TYPE_UNK DNS_TYPE_NULL  // we treat the two as the same

#ifdef USE_NDNC
typedef enum 
{ 
  none = 0, // not AD integrated
  forest, 
  domain, 
  w2k, 
  custom
} ReplicationType;
#endif


//////////////////////////////////////////////////////////////
// macros defining the DNS server version

#define DNS_SRV_MAJOR_VERSION(dw) (LOBYTE(LOWORD(dw)))
#define DNS_SRV_MINOR_VERSION(dw) (HIBYTE(LOWORD(dw)))
#define DNS_SRV_BUILD_NUMBER(dw) (HIWORD(dw))

#define DNS_SRV_MAJOR_VERSION_NT_4 (0x4)
#define DNS_SRV_MAJOR_VERSION_NT_5 (0x5)
#define DNS_SRV_MINOR_VERSION_WIN2K (0x0)
#define DNS_SRV_MINOR_VERSION_WHISTLER (0x1)
#define DNS_SRV_BUILD_NUMBER_WHISTLER (2230)
#define DNS_SRV_BUILD_NUMBER_WHISTLER_NEW_SECURITY_SETTINGS (2474)
#define	DNS_SRV_VERSION_NT_4 DNS_SRV_MAJOR_VERSION_NT_4

//////////////////////////////////////////////////////////////
// MACROS & DEFINES

#define MAX_DNS_NAME_LEN 255

#define IP_OCTET_COUNT 4

// record enumeration

#define NEXT_DWORD(cb)			((cb + 3) & ~3)
//#define IS_DWORD_ALIGNED(pv)	(((int)(void *)pv & 3) == 0)
#define DNS_SIZE_OF_DNS_RPC_RR(pDnsRecord)\
		(SIZEOF_DNS_RPC_RECORD_HEADER + pDnsRecord->wDataLength)
#define DNS_NEXT_RECORD(pDnsRecord)	\
	(DNS_RPC_RECORD *)((BYTE*)pDnsRecord + ((DNS_SIZE_OF_DNS_RPC_RR(pDnsRecord) + 3) & ~3))

// RR field manipulation
//#define INET_NTOA(s) (inet_ntoa (*(in_addr *)&(s)))
#define REVERSE_WORD_BYTES(w) \
	MAKEWORD(HIBYTE(w), LOBYTE(w))

// DNS keywords
#define INADDR_ARPA_SUFFIX _T(".in-addr.arpa")
#define ARPA_SUFFIX _T(".arpa")
#define IP6_INT_SUFFIX _T(".ipv6.int")

#define AUTOCREATED_0		_T("0.in-addr.arpa")
#define AUTOCREATED_127		_T("127.in-addr.arpa")
#define AUTOCREATED_255		_T("255.in-addr.arpa")

#define QUESTION_MARK_PREFIX _T("?")


// formatting of IPv4 address to string
extern LPCWSTR g_szIpStringFmt;

#define IP_STRING_MAX_LEN 20 // safe size for a wsprintf buffer
#define IP_STRING_FMT_ARGS(x) \
  FOURTH_IPADDRESS(x), THIRD_IPADDRESS(x), SECOND_IPADDRESS(x), FIRST_IPADDRESS(x)


//////////////////////////////////////////////////////////////
// macros and functions for UTF8 <-> UNICODE conversion
// modified from the ATL 1.1 ones in atlbase.h


inline LPWSTR WINAPI DnsUtf8ToWHelper(LPWSTR lpw, LPCSTR lpa, int nChars)
{
	_ASSERTE(lpa != NULL);
	_ASSERTE(lpw != NULL);
	// verify that no illegal character present
	// since lpw was allocated based on the size of lpa
	// don't worry about the number of chars
	lpw[0] = '\0';
	MultiByteToWideChar(CP_UTF8, 0, lpa, -1, lpw, nChars);
	return lpw;
}

inline LPSTR WINAPI DnsWToUtf8Helper(LPSTR lpa, LPCWSTR lpw, int nChars)
{
	_ASSERTE(lpw != NULL);
	_ASSERTE(lpa != NULL);
	// verify that no illegal character present
	// since lpa was allocated based on the size of lpw
	// don't worry about the number of chars
	lpa[0] = '\0';
	WideCharToMultiByte(CP_UTF8, 0, lpw, -1, lpa, nChars, NULL, NULL);
	return lpa;
}

inline void WINAPI DnsUtf8ToWCStringHelper(CString& sz, LPCSTR lpa, int nBytes)
{
	// Make sure we return an empty string when either the string is null or
	// the first character is null or the string length is defined as zero

	if ( (lpa == NULL) || 
        ((lpa != NULL) && (lpa[0] == L'\0')) ||
        (nBytes <= 0) )
	{
		sz.Empty();
		return;
	}
	// allocate buffer in string (worst case scenario + NULL)
	int nWideChars = nBytes + 1;
	LPWSTR lpw = sz.GetBuffer(nWideChars);
	int nWideCharsLen = MultiByteToWideChar(CP_UTF8, 0, lpa, nBytes, lpw, nWideChars);
	sz.ReleaseBuffer(nWideCharsLen);
} 

#define UTF8_LEN lstrlenA

#define UTF8_TO_W(lpa) (\
	((LPCSTR)lpa == NULL) ? NULL : (\
		_convert = (lstrlenA(lpa)+1),\
		DnsUtf8ToWHelper((LPWSTR) alloca(_convert*2), lpa, _convert)))

#define W_TO_UTF8(lpw) (\
	((LPCWSTR)lpw == NULL) ? NULL : (\
		_convert = (lstrlenW(lpw)+1)*4,\
		DnsWToUtf8Helper((LPSTR) alloca(_convert), lpw, _convert)))

#define UTF8_TO_CW(lpa) ((LPCWSTR)UTF8_TO_W(lpa))
#define W_TO_CUTF8(lpw) ((LPCSTR)W_TO_UTF8(lpw))

//////////////////////////////////////////////////////////////
// estimate UTF8 len of a UNICODE string

inline int UTF8StringLen(LPCWSTR lpszWideString)
{
	USES_CONVERSION;
	LPSTR lpszUTF8 = W_TO_UTF8(lpszWideString);
	return UTF8_LEN(lpszUTF8);
}



///////////////////////////////////////////////////////////////
// General Purpose Utility Functions

WORD CharToNumber(WCHAR ch);
BYTE HexCharToByte(WCHAR ch);

BOOL IsValidIPString(LPCWSTR lpsz);
DNS_STATUS ValidateDnsNameAgainstServerFlags(LPCWSTR lpszName, 
                                             DNS_NAME_FORMAT format, 
                                             DWORD serverNameChecking);
DWORD IPStringToAddr(LPCWSTR lpsz);

inline void FormatIpAddress(LPWSTR lpszBuf, DWORD dwIpAddr)
{
  wsprintf(lpszBuf, g_szIpStringFmt, IP_STRING_FMT_ARGS(dwIpAddr));
}

inline void FormatIpAddress(CString& szBuf, DWORD dwIpAddr)
{
  LPWSTR lpszBuf = szBuf.GetBuffer(IP_STRING_MAX_LEN);
  wsprintf(lpszBuf, g_szIpStringFmt, IP_STRING_FMT_ARGS(dwIpAddr));
  szBuf.ReleaseBuffer();
}


void ReverseString(LPWSTR p, LPWSTR q);
int ReverseIPString(LPWSTR lpsz);

BOOL RemoveInAddrArpaSuffix(LPWSTR lpsz);

BOOL IsValidDnsZoneName(CString& szName, BOOL bFwd);

#ifdef NTRAID_628931
HRESULT GetWideCharZoneRootHints(CString& zoneRootHints);
#endif //NTRAID_628931

///////////////////////////////////////////////////////////////
// definitions and helper functions for IPv6 format

void FormatIPv6Addr(CString& szAddr, IPV6_ADDRESS* ipv6Addr);


///////////////////////////////////////////////////////////////
// flags for different states and options of DNS objects
// use LOWORD only because used in CTreeNode::m_dwNodeFlags

#define TN_FLAG_DNS_RECORD_FULL_NAME		(0x01)	// use full name to display resource records
#define TN_FLAG_DNS_RECORD_SHOW_TTL			(0x02)	// show TLL in record properties


typedef CArray<IP_ADDRESS,IP_ADDRESS> CIpAddressArray;



//////////////////////////////////////////////////////////////////////////////
// CBlob
template <class T> class CBlob
{
public:
	CBlob()
	{
		m_pData = NULL;
		m_nSize = 0;
	}
	~CBlob()
	{
		Empty();
	}
	UINT GetSize() { return m_nSize;}
	T* GetData() { return m_pData;}
	void Set(T* pData, UINT nSize)
	{
		ASSERT(pData != NULL);
		Empty();

      if (nSize > 0 &&
          sizeof(T) > 0)
      {
		  m_pData = (BYTE*)malloc(sizeof(T)*nSize);
		  ASSERT(m_pData != NULL);
        if (m_pData != NULL)
        {
		    m_nSize = nSize;
		    memcpy(m_pData, pData, sizeof(T)*nSize);
        }
      }
	}
	UINT Get(T* pData)
	{
		ASSERT(pData != NULL);
		memcpy(pData, m_pData, sizeof(T)*m_nSize);
		return m_nSize;
	}
	void Empty()
	{
		if (m_pData != NULL)
		{
			free(m_pData);
			m_pData = NULL;
			m_nSize = 0;
		}
	}

private:
	T* m_pData;
	UINT m_nSize;
};

typedef CBlob<BYTE> CByteBlob;
typedef CBlob<WORD> CWordBlob;


//////////////////////////////////////////////////////////////////////////////
// CDNSServerInfoEx

// definitions for the extended server flags (NT 5.0) only
#define SERVER_REGKEY_ARR_SIZE							6 

#define SERVER_REGKEY_ARR_INDEX_NO_RECURSION			    0
#define SERVER_REGKEY_ARR_INDEX_BIND_SECONDARIES		  1
#define SERVER_REGKEY_ARR_INDEX_STRICT_FILE_PARSING		2
#define SERVER_REGKEY_ARR_INDEX_ROUND_ROBIN				    3
#define SERVER_REGKEY_ARR_LOCAL_NET_PRIORITY			    4
#define SERVER_REGKEY_ARR_CACHE_POLLUTION						5


extern LPCSTR _DnsServerRegkeyStringArr[];

class CDNSServerInfoEx : public CObjBase
{
public:
	CDNSServerInfoEx();
	~CDNSServerInfoEx();
	DNS_STATUS Query(LPCTSTR lpszServerName);

	BOOL HasData(){ return m_pServInfo != NULL;}
	void FreeInfo();

	// obtained from DnsGetServerInfo() RPC call (NT 4.0)
	DNS_RPC_SERVER_INFO* m_pServInfo; 
	// error codes for query
	DNS_STATUS		m_errServInfo;

private:
	void QueryRegKeyOptionsHelper(LPCSTR lpszAnsiServerName);

};

//////////////////////////////////////////////////////////////////////////////
// CDNSZoneInfoEx

class CDNSZoneInfoEx : public CObjBase
{
public:
	CDNSZoneInfoEx();
	~CDNSZoneInfoEx();
	DNS_STATUS Query(LPCTSTR lpszServerName, LPCTSTR lpszZoneName, DWORD dwServerVersion);

	BOOL HasData(){ return m_pZoneInfo != NULL;}
	void FreeInfo();

	// struct obtained from DnssrvGetZoneInfo() 5.0 RPC call (NT 4.0 format)
	DNS_RPC_ZONE_INFO* m_pZoneInfo; 
	// obtained from DnssrvQueryZoneDwordProperty() (NT 5.0)
//	UINT			m_nAllowsDynamicUpdate; 

	// error codes for query
	DNS_STATUS		m_errZoneInfo;
//	DNS_STATUS		m_errAllowsDynamicUpdate;
};

///////////////////////////////////////////////////////////////////////////////
//////////////////// ERROR MESSAGES HANDLING //////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

int DNSMessageBox(LPCTSTR lpszText, UINT nType = MB_OK);
int DNSMessageBox(UINT nIDPrompt, UINT nType = MB_OK);

int DNSErrorDialog(DNS_STATUS err, LPCTSTR lpszErrorMsg = NULL);
int DNSErrorDialog(DNS_STATUS err, UINT nErrorMsgID);
void DNSDisplaySystemError(DWORD dwErr);
void DNSCreateErrorMessage(DNS_STATUS err, UINT nErrorMsgID, CString& refszMessage);

int DNSConfirmOperation(UINT nMsgID, CTreeNode* p);

class CDNSErrorInfo
{
public:
	static BOOL GetErrorString(DNS_STATUS err, CString& szError);
  static BOOL GetErrorStringFromTable(DNS_STATUS err, CString& szError);
  static BOOL GetErrorStringFromWin32(DNS_STATUS err, CString& szError);
};

///////////////////////////////////////////////////////////////////////////////

//
//  Security KEY, SIG 6-bit values to base64 character mapping
//
#define SECURITY_PAD_CHAR   (L'=')
WCHAR Dns_SecurityBase64CharToBits(IN WCHAR wch64);

DNS_STATUS Dns_SecurityBase64StringToKey(OUT     PBYTE   pKey,
                                         OUT     PDWORD  pKeyLength,
                                         IN      PWSTR   pchString,
                                         IN      DWORD   cchLength);

PWSTR Dns_SecurityKeyToBase64String(IN      PBYTE   pKey,
                                    IN      DWORD   KeyLength,
                                    OUT     PWSTR   pchBuffer);

// NOTICE-2002/04/24-artm  ntraid#ntbug9-547641
// Unused functions need to be removed.  I've left in comments in
// case they are later needed.
//DNS_STATUS Dns_SecurityHexToKey(OUT   PBYTE   pKey,
//                                OUT   PDWORD  pKeyLength,
//                                IN    PWSTR   pchString,
//                                IN    DWORD   cchLength);
//
//void Dns_SecurityKeyToHexString(PBYTE pKey,
//                                DWORD KeyLength,
//                                CString& strref);

void TimetToFileTime( time_t t, LPFILETIME pft );
DWORD FileTimeToTimet(FILETIME* pft);
void ConvertTTLToSystemTime(TIME_ZONE_INFORMATION*,
                            DWORD dwTTL, 
                            SYSTEMTIME* pSysTime);
DWORD ConvertSystemTimeToTTL(SYSTEMTIME* pSysTime);
BOOL ConvertTTLToLocalTimeString(const DWORD dwTTL,
                                 CString& strref);

CString Base64BLOBToString(PBYTE blob, DWORD blobSizeInBytes);
CString Base64BLOBToString(CByteBlob& blob);

#endif // _DNSUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\domain.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       domain.h
//
//--------------------------------------------------------------------------


#ifndef _DOMAIN_H
#define _DOMAIN_H

#include "dnsutil.h"
#include "record.h"
#include "domainUI.h"

///////////////////////////////////////////////////////////////////////////////
// FORWARD DECLARATIONS

class CDNSServerNode; 
class CDNSRecordNodeBase;
class CDNSZoneNode;
class CDNSRootHintsNode;
class CDNS_NS_RecordNodeList;
class CDNSRecordNodeEditInfoList;


BOOL _match(LPCWSTR lpszNSName, CDNS_A_RecordNode* pARecordNode);

/////////////////////////////////////////////////////////////////////////
// CDNSDomainQueryObj 


class CDNSDomainQueryObj : public CDNSQueryObj
{
public:
	CDNSDomainQueryObj(LPCTSTR lpszServerName,
              LPCTSTR lpszZoneName,
              DWORD dwServerVersion,
              LPCTSTR lpszNodeName,
              LPCTSTR lpszFullNodeName,
              WORD wRecordType,
              DWORD dwSelectFlags,
              BOOL bIsZone,
              BOOL bReverse,
              BOOL bCache,
              BOOL bAdvancedView)
		: CDNSQueryObj(bAdvancedView, dwServerVersion)
	{
    m_szServerName = lpszServerName;
    m_szZoneName = lpszZoneName;
    m_szNodeName = lpszNodeName;
    m_szFullNodeName = lpszFullNodeName;
    m_wRecordType = wRecordType;
    m_dwSelectFlags = dwSelectFlags;
    m_bReverse = bReverse;
    m_bIsZone = bIsZone;
    m_bCache = bCache;

    // internal state variables
    m_bFirstPass = TRUE;
	}
	virtual BOOL Enumerate();

// implementation for DNS domain/zone type
  BOOL CanAddRecord(WORD wRecordType, LPCWSTR lpszRecordName);
  BOOL CanAddDomain(LPCWSTR lpszDomainName)
    { return MatchName(lpszDomainName);}

protected:
  DNS_STATUS EnumerateFiltered(WORD wRecordType);

protected:
	// query parameters (in the sequence expected by CDNSDomainNode::EnumerateNodes)
	CString m_szNodeName;
  CString m_szZoneName;
	CString m_szFullNodeName;
	WORD m_wRecordType;
	DWORD m_dwSelectFlags;
	BOOL m_bIsZone;
	BOOL m_bReverse;
	BOOL m_bCache;

  // query flag to do multiple pass filtered query
  BOOL m_bFirstPass;
  
};


/////////////////////////////////////////////////////////////////////////
// CDNSDomainNode

class CDNSDomainNode : public CDNSMTContainerNode
{
public:
	CDNSDomainNode(BOOL bDelegation = FALSE);
	virtual ~CDNSDomainNode();

	// node info
	DECLARE_NODE_GUID()

	void SetZone(CDNSZoneNode* pZoneNode){m_pZoneNode = pZoneNode;}
	virtual CDNSZoneNode* GetZoneNode() 
	{ ASSERT(m_pZoneNode != NULL); return m_pZoneNode;}

protected:	
	// helpers for setting names
	void SetFullDNSName(BOOL bIsZone, BOOL bReverse,  
					LPCTSTR lpszNodeName, LPCTSTR lpszParentFullName);
	void SetDisplayDNSName(BOOL bIsZone, BOOL bReverse, BOOL bAdvancedView, 
					LPCTSTR lpszNodeName, LPCTSTR lpszParentFullName);
	void ChangePTRRecordsViewOption(BOOL bAdvanced,
					CComponentDataObject* pComponentDataObject);

  void OnMultiselectDelete(CComponentDataObject* pComponentData, CNodeList* pNodeList);

public:
	void SetNames(BOOL bIsZone, BOOL bReverse, BOOL bAdvancedView, 
					LPCTSTR lpszNodeName, LPCTSTR lpszParentFullName);

	virtual HRESULT OnCommand(long nCommandID, 
                            DATA_OBJECT_TYPES type, 
                            CComponentDataObject* pComponentData,
                            CNodeList* pNodeList);
	virtual void OnDelete(CComponentDataObject* pComponentData,
                        CNodeList* pNodeList);
	virtual BOOL OnRefresh(CComponentDataObject* pComponentData,
                         CNodeList* pNodeList);
	virtual LPCWSTR GetString(int nCol) 
	{ 
		return (nCol == 0) ? GetDisplayName() : g_lpszNullString;
	}

	virtual int GetImageIndex(BOOL bOpenImage);
  virtual LPWSTR GetDescriptionBarText();

	virtual BOOL HasPropertyPages(DATA_OBJECT_TYPES type, 
                                BOOL* pbHideVerb,
                                CNodeList* pNodeList);
	virtual HRESULT CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, 
                                      LONG_PTR handle,
                                      CNodeList* pNodeList);
	virtual HRESULT CreatePropertyPagesHelper(LPPROPERTYSHEETCALLBACK lpProvider, 
		LONG_PTR handle, long nStartPageCode);
	virtual int Compare(CTreeNode* pNodeA, CTreeNode* pNodeB, int nCol, long lUserParam);

  virtual void Show(BOOL bShow, CComponentDataObject* pComponentData);

  virtual RECORD_SEARCH DoesContain(PCWSTR pszFullName, 
                                    CComponentDataObject* pComponentData,
                                    CDNSDomainNode** ppDomainNode,
                                    CDNSRecordNodeBase** ppExistingRecord,
                                    CString& szNonExistentDomain,
                                    BOOL bExpandNodes = FALSE);

protected:
	virtual LPCONTEXTMENUITEM2 OnGetContextMenuItemTable() 
				{ return CDNSDomainMenuHolder::GetContextMenuItem(); }
	virtual BOOL OnAddMenuItem(LPCONTEXTMENUITEM2 pContextMenuItem2,
								             long *pInsertionAllowed);
	virtual BOOL OnSetDeleteVerbState(DATA_OBJECT_TYPES type, 
                                    BOOL* pbHide,
                                    CNodeList* pNodeList);
	virtual BOOL OnSetRefreshVerbState(DATA_OBJECT_TYPES type, 
                                     BOOL* pbHide,
                                     CNodeList* pNodeList); 
  virtual HRESULT OnSetToolbarVerbState(IToolbar* pToolbar, 
                                        CNodeList* pNodeList);

  // query creation
	virtual CQueryObj* OnCreateQuery();

  // main message handlers for thread messages
  virtual void OnThreadExitingNotification(CComponentDataObject* pComponentDataObject);
  virtual void OnHaveData(CObjBase* pObj, CComponentDataObject* pComponentDataObject);

// command handlers
private:
	void OnNewRecordHelper(CComponentDataObject* pComponentData, WORD wType);
	
protected:
	HRESULT OnNewRecord(CComponentDataObject* pComponentData, 
                      CNodeList* pNodeList);
	void OnNewDomain(CComponentDataObject* pComponentData);
	void OnNewDelegation(CComponentDataObject* pComponentData);

	void OnNewHost(CComponentDataObject* pComponentData);
	void OnNewAlias(CComponentDataObject* pComponentData);
	void OnNewMailExchanger(CComponentDataObject* pComponentData);
	void OnNewPointer(CComponentDataObject* pComponentData);

// DNS specific data
protected:
	CString m_szFullName;						// FQN for the current zone/domain
	CDNSZoneNode* m_pZoneNode;					// pointer to the zone the domain
  BOOL m_bHasDataForPropPages;    // TRUE if we have enough data to display PPages 

private:
	CDNS_NS_RecordNodeList*	m_pNSRecordNodeList;	// list of cached pointers to NS records
													// (used for zones and delegated domains)
  BOOL m_bDelegation; // TRUE of the node is a delegated domain

protected:	
	CDNS_NS_RecordNodeList* GetNSRecordNodeList() 
		{ ASSERT(m_pNSRecordNodeList != NULL); return m_pNSRecordNodeList; }

public:
	LPCWSTR GetFullName() { return m_szFullName; }
	BOOL IsZone() { return (CDNSDomainNode*)m_pZoneNode == this; }
	DWORD GetDefaultTTL();

	// subdomain creation
	CDNSDomainNode* FindSubdomainNode(LPCTSTR lpszSubdomainNode);
	CDNSDomainNode* CreateSubdomainNode(BOOL bDelegation = FALSE); // create C++ object and hook it up
	void SetSubdomainName(CDNSDomainNode* pSubdomainNode,
							LPCTSTR lpszSubdomainName,
							BOOL bAdvancedView); // set the name of the C++ object
	DNS_STATUS CreateSubdomain(
		CDNSDomainNode* pSubdomainNode, 
		CComponentDataObject* pComponentData); // assume the 2 above API's got used

	DNS_STATUS CreateSubdomain(LPCTSTR lpszDomainName,
				CComponentDataObject* pComponentData); // one step API using the ones above
	DNS_STATUS Create(); // from a new C++ node, create on the server

	// child enumeration
	static DNS_STATUS EnumerateNodes(LPCTSTR lpszServerName,
                   LPCTSTR lpszZoneName,
									 LPCTSTR lpszNodeName,
									 LPCTSTR lpszFullNodeName,
									 WORD wRecordType,
									 DWORD dwSelectFlag,
									 BOOL bIsZone, BOOL bReverse, BOOL bAdvancedView,
									 CDNSDomainQueryObj* pQuery);

public:
  BOOL IsDelegation() { return m_bDelegation;}

  // NS records management
	BOOL HasNSRecords();
	void GetNSRecordNodesInfo(CDNSRecordNodeEditInfoList* pNSInfoList);
	BOOL UpdateNSRecordNodesInfo(CDNSRecordNodeEditInfoList* pNewInfoList,
								CComponentDataObject* pComponentData);
	static void FindARecordsFromNSInfo(LPCWSTR lpszServerName, DWORD dwServerVersion,
                      DWORD cServerAddrCount, PIP_ADDRESS pipServerAddrs,
                      LPCWSTR lpszZoneName,
											LPCWSTR lpszNSName, 
											CDNSRecordNodeEditInfoList* pNSInfoList,
											BOOL bAdvancedView);
	virtual void FindARecordsFromNSInfo(LPCTSTR lpszNSName, CDNSRecordNodeEditInfoList* pNSInfoList);

protected:
	virtual void UpdateARecordsOfNSInfo(CDNSRecordNodeEditInfo* pNSInfo,
										CComponentDataObject* pComponentData);
	static void UpdateARecordsOfNSInfoHelper(CDNSDomainNode* pDomainNode,
											CDNSRecordNodeEditInfo* pNSInfo,
											CComponentDataObject* pComponentData,
                      BOOL bAskConfirmation);

protected:
	// called by OnHaveData() to set cached RR ptrs and generally preprocess RR's
	virtual void OnHaveRecord(CDNSRecordNodeBase* pRecordNode, 
								CComponentDataObject* pComponentDataObject); 
	

private:
	DNS_STATUS Delete();

  DECLARE_TOOLBAR_MAP()
};


/////////////////////////////////////////////////////////////////////////
// CDNSDummyDomainNode
// 
// * not multithreaded and hidden in the UI

class CDNSDummyDomainNode : public CDNSDomainNode
{
public:
	CDNSDummyDomainNode()
	{ 
		m_dwNodeFlags |= TN_FLAG_HIDDEN;
	}

protected:
	virtual CQueryObj* OnCreateQuery() 
	{
		// should never be called, only for MT objects
		ASSERT(FALSE); 
		return NULL;
	}
};

/////////////////////////////////////////////////////////////////////////
// CDNSRootHintsNode
// 
// * exists only if the server is not authoritated for the root
// * not multithreaded and hidden in the UI

class CDNSRootHintsNode : public CDNSDummyDomainNode
{
public:
	CDNSRootHintsNode()
	{ 
		m_szFullName = _T(".");
		m_szDisplayName = _T(".");
	}
  // this "domain" object is not associated to any zone
	virtual CDNSZoneNode* GetZoneNode() 
  	{ ASSERT(m_pZoneNode == NULL); return NULL;}

	DNS_STATUS QueryForRootHints(LPCTSTR lpszServerName, DWORD dwServerVersion);

	DNS_STATUS InitializeFromDnsQueryData(PDNS_RECORD pRootHintsRecordList);

   void ShowPageForNode(CComponentDataObject* pComponentDataObject);

protected:
	virtual void FindARecordsFromNSInfo(LPCTSTR lpszNSName, CDNSRecordNodeEditInfoList* pNSInfoList);
	virtual void UpdateARecordsOfNSInfo(CDNSRecordNodeEditInfo* pNSInfo,
										CComponentDataObject* pComponentData);
private:
	DNS_STATUS Clear();
};



#endif // _DOMAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\domainui.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       domainui.cpp
//
//--------------------------------------------------------------------------


#include "preDNSsn.h"
#include <SnapBase.h>

#include "resource.h"
#include "dnsutil.h"
#include "DNSSnap.h"
#include "snapdata.h"

#include "server.h"
#include "domain.h"
#include "record.h"
#include "zone.h"

///////////////////////////////////////////////////////////////////////////////
// CDNSDelegatedDomainNameServersPropertyPage


void CDNSDelegatedDomainNameServersPropertyPage::ReadRecordNodesList()
{
  CString szBuffer;
  szBuffer.LoadString(IDS_DELEGATION_DESCR);
  SetDescription(szBuffer);

	ASSERT(m_pCloneInfoList != NULL);
	CDNSDomainPropertyPageHolder* pHolder = (CDNSDomainPropertyPageHolder*)GetHolder();
	CDNSDomainNode* pDomainNode = pHolder->GetDomainNode();
	SetDomainNode(pDomainNode);
	pDomainNode->GetNSRecordNodesInfo(m_pCloneInfoList);
}



///////////////////////////////////////////////////////////////////////////////

CDNSDomainPropertyPageHolder::CDNSDomainPropertyPageHolder(CDNSDomainNode* pContainerDomainNode, 
							CDNSDomainNode* pThisDomainNode, CComponentDataObject* pComponentData)
		: CPropertyPageHolderBase(pContainerDomainNode, pThisDomainNode, pComponentData)
{
	ASSERT(pComponentData != NULL);
	ASSERT(pContainerDomainNode != NULL);
	ASSERT(pContainerDomainNode == GetContainerNode());
	ASSERT(pThisDomainNode != NULL);
	ASSERT(pThisDomainNode == GetDomainNode());

	ASSERT(pThisDomainNode->IsDelegation());

	m_bAutoDeletePages = FALSE; // we have the page as embedded member

  //
	// add NS page if delegation
  //
	if (pThisDomainNode->IsDelegation())
	{
		AddPageToList((CPropertyPageBase*)&m_nameServersPage);
    DWORD dwZoneType = pThisDomainNode->GetZoneNode()->GetZoneType();
		if (dwZoneType == DNS_ZONE_TYPE_SECONDARY ||
        dwZoneType == DNS_ZONE_TYPE_STUB)
    {
			m_nameServersPage.SetReadOnly();
    }
	}

  //
	// security page added only if DS integrated and it is a delegation:
  // if a delegation, we are guaranteed we have RR's at the node
  //
	m_pAclEditorPage = NULL;
	CDNSZoneNode* pZoneNode = pThisDomainNode->GetZoneNode();
	if (pZoneNode->IsDSIntegrated() && pThisDomainNode->IsDelegation())
	{
		CString szPath;
		pZoneNode->GetServerNode()->CreateDsNodeLdapPath(pZoneNode, pThisDomainNode, szPath);
		if (!szPath.IsEmpty())
			m_pAclEditorPage = CAclEditorPage::CreateInstance(szPath, this);
	}
}

CDNSDomainPropertyPageHolder::~CDNSDomainPropertyPageHolder()
{
	if (m_pAclEditorPage != NULL)
		delete m_pAclEditorPage;
}


CDNSDomainNode* CDNSDomainPropertyPageHolder::GetDomainNode()
{ 
	CDNSDomainNode* pDomainNode = (CDNSDomainNode*)GetTreeNode();
	ASSERT(!pDomainNode->IsZone());
	return pDomainNode;
}


HRESULT CDNSDomainPropertyPageHolder::OnAddPage(int nPage, CPropertyPageBase*)
{
	// add the ACL editor page after the last, if present
	if ( (nPage != -1) || (m_pAclEditorPage == NULL) )
		return S_OK; 

	// add the ACLU page 
	HPROPSHEETPAGE  hPage = m_pAclEditorPage->CreatePage();
	if (hPage == NULL)
		return E_FAIL;
	// add the raw HPROPSHEETPAGE to sheet, not in the list
	return AddPageToSheetRaw(hPage);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\domainui.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       domainui.h
//
//--------------------------------------------------------------------------


#ifndef _DOMAINUI_H
#define _DOMAINUI_H


#include "nspage.h"
#include "aclpage.h"

///////////////////////////////////////////////////////////////////////////////
// FORWARD DECLARATIONS

//class CDNSDomainNode;

///////////////////////////////////////////////////////////////////////////////
// CDNSDelegatedDomainNameServersPropertyPage

class CDNSDelegatedDomainNameServersPropertyPage : public CDNSNameServersPropertyPage
{
protected:
	virtual void ReadRecordNodesList();
};


///////////////////////////////////////////////////////////////////////////////
// CDNSDomainPropertyPageHolder
// page holder to contain DNS Domain property pages

#define DOMAIN_HOLDER_NS		RR_HOLDER_NS

class CDNSDomainPropertyPageHolder : public CPropertyPageHolderBase
{
public:
	CDNSDomainPropertyPageHolder(CDNSDomainNode* pContainerDomainNode, CDNSDomainNode* pThisDomainNode,
				CComponentDataObject* pComponentData);
	virtual ~CDNSDomainPropertyPageHolder();

protected:
	virtual int OnSelectPageMessage(long nPageCode) 
		{ return (nPageCode == DOMAIN_HOLDER_NS) ? 0 : -1; }
	virtual HRESULT OnAddPage(int nPage, CPropertyPageBase* pPage);

private:
	CDNSDomainNode* GetDomainNode();

	CDNSDelegatedDomainNameServersPropertyPage		m_nameServersPage;
	// optional security page
	CAclEditorPage*					m_pAclEditorPage;

	friend class CDNSDelegatedDomainNameServersPropertyPage; // for GetDomainNode()
};


#endif // _DOMAINUI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\helparr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       helparr.h
//
//--------------------------------------------------------------------------

#define IDH_COMBO_SEL_NODE	                    50000000
#define IDH_LIST_NODE_ITEMS	                    50000001
#define IDH_SELECTION_EDIT	                    50000002
#define IDH_COMBO_FILTER	                      50000003
#define IDH_CHOOSER_RADIO_LOCAL_MACHINE	        50000050
#define IDH_CHOOSER_RADIO_SPECIFIC_MACHINE	    50000051
#define IDH_CHOOSER_EDIT_MACHINE_NAME	          50000052
#define IDH_CHOOSER_BUTTON_BROWSE_MACHINENAMES	50000053
#define IDH_CHOOSER_CHECK_CONTACT	              50000054
#define IDH_EDIT_DOMAIN_NAME	                  50000100
#define IDH_IPEDIT_DOMAIN_NAME	                50000101
#define IDH_RR_DOMAIN_EDIT_ADDNEWHOST	          50000150
#define IDH_RR_NAME_EDIT_ADDNEWHOST	            50000151
#define IDH_IPEDIT_ADDNEWHOST	                  50000152
#define IDH_UPDATE_PRT_CHECK	                  50000153
#define IDH_TTLEDIT_ADDNEWHOST	                50000154
#define IDH_BUTTON_ADDHOST	                    50000155

//
// Filter limit
//
#define IDH_EDIT_COUNT	                        50000200

//
// Filter name
//
#define IDH_RADIO_FILTER_NONE	                  50000250
#define IDH_RADIO_FILTER_STARTS	                50000251
#define IDH_EDIT_FILTER_STARTS	                50000252
#define IDH_RADIO_FILTER_CONTAINS	              50000253
#define IDH_EDIT_FILTER_CONTAINS	              50000254
#define IDH_RADIO_FILTER_RANGE	                50000255
#define IDH_EDIT_FILTER_RANGE_FROM	            50000256
#define IDH_EDIT_FILTER_RANGE_TO	              50000257
#define IDH_NS_LIST	                            50000300
#define IDH_ADD_NS_BUTTON	                      50000301
#define IDH_REMOVE_NS_BUTTON	                  50000302
#define IDH_EDIT_NS_BUTTON	                    50000303


//
//  Host RR
//
#define IDH_TIME_STAMP_A                        50000348
#define IDH_DEFAULT_DELETE_STALE_RECORD_A       50000349
#define IDH_RR_DOMAIN_EDIT_A	                  50000350
#define IDH_RR_NAME_EDIT_A	                    50000351
#define IDH_IPEDIT_A	                          50000352
#define IDH_TTLEDIT_A	                          50000354
#define IDH_UPDATE_SECURITY_CHECK               50000355
//
//  AAAA RR
//
#define IDH_TIME_STAMP_AAAA                     50000398
#define IDH_DEFAULT_DELETE_STALE_RECORD_AAAA    50000399
#define IDH_RR_DOMAIN_EDIT_AAAA	                50000400
#define IDH_RR_NAME_EDIT_AAAA	                  50000401
#define IDH_IPV6EDIT	                          50000402
#define IDH_TTLEDIT_AAAA	                      50000403

//
//  AFSDB RR
//
#define IDH_TIME_STAMP_AFSDB                    50000448
#define IDH_DEFAULT_DELETE_STALE_RECORD_AFSDB   50000449
#define IDH_RR_DOMAIN_EDIT_AFSDB	              50000450
#define IDH_RR_NAME_EDIT_AFSDB	                50000451
#define IDH_AFS_VLS_RADIO	                      50000452
#define IDH_DCE_ANS_RADIO	                      50000453
#define IDH_OTHER_RADIO	                        50000454
#define IDH_SUBTYPE_EDIT	                      50000455
#define IDH_BROWSE_BUTTON	                      50000456
#define IDH_TTLEDIT_AFSDB	                      50000457
#define IDH_NAME_EXCHANGE_EDIT_AFSDB            50000458

//
//  ATMA RR
//
#define IDH_TIME_STAMP_ATMA                     50000498
#define IDH_DEFAULT_DELETE_STALE_RECORD_ATMA    50000499
#define IDH_RR_DOMAIN_EDIT_ATMA	                50000500
#define IDH_RR_NAME_EDIT_ATMA	                  50000501
#define IDH_RADIO_E164	                        50000502
#define IDH_RADIO_NSAP	                        50000503
#define IDH_EDIT_ATMA_ADDRESS	                  50000504
#define IDH_TTLEDIT_ATMA	                      50000505

//
//  Alias RR
//
#define IDH_TIME_STAMP_CNAME                    50000548
#define IDH_DEFAULT_DELETE_STALE_RECORD_CNAME   50000549
#define IDH_RR_DOMAIN_EDIT_CNAME	              50000550
#define IDH_RR_NAME_EDIT_CNAME	                50000551
#define IDH_NAME_NODE_EDIT	                    50000552
#define IDH_TTLEDIT_CNAME	                      50000554

//
//  HINFO RR
//
#define IDH_TIME_STAMP_HINFO                    50000598
#define IDH_DEFAULT_DELETE_STALE_RECORD_HINFO   50000599
#define IDH_RR_DOMAIN_EDIT_HINFO	              50000600
#define IDH_RR_NAME_EDIT_HINFO	                50000601
#define IDH_CPU_TYPE_EDIT	                      50000602
#define IDH_OPERATING_SYSTEM_EDIT	              50000603
#define IDH_TTLEDIT_HINFO	                      50000604

//
//  ISDN RR
//
#define IDH_TIME_STAMP_ISDN                     50000648
#define IDH_DEFAULT_DELETE_STALE_RECORD_ISDN    50000649
#define IDH_RR_DOMAIN_EDIT_ISDN	                50000650
#define IDH_RR_NAME_EDIT_ISDN	                  50000651
#define IDH_PHONE_NUM_AND_DDI_EDIT	            50000652
#define IDH_SUBADDRESS_EDIT	                    50000653
#define IDH_TTLEDIT_ISDN	                      50000654

//
//  Public Key RR
//
#define IDH_TIME_STAMP_KEY                      50000698
#define IDH_DEFAULT_DELETE_STALE_RECORD_KEY     50000699
#define IDH_RR_DOMAIN_EDIT_KEY	                50000700
#define IDH_RR_NAME_EDIT_KEY	                  50000701
#define IDH_TTLEDIT_KEY	                        50000702
#define IDH_BITFIELD_EDIT                       50000703
#define IDH_KEY_TYPE_COMBO                      50000704
#define IDH_NAME_TYPE_COMBO                     50000705
#define IDH_LOGGING_OPTIONS_LIST_KEY            50000706
#define IDH_PROTOCOL_COMBO                      50000707
#define IDH_ALGORITHM_COMBO_KEY                 50000708
#define IDH_DISPLAY_KEY_COMBO                   50000709
#define IDH_KEY_EDIT                            50000710

//
//  Mailbox RR
//
#define IDH_TIME_STAMP_MB                       50000748
#define IDH_DEFAULT_DELETE_STALE_RECORD_MB      50000749
#define IDH_RR_DOMAIN_EDIT_MB	                  50000750
#define IDH_RR_NAME_EDIT_MB	                    50000751
#define IDH_TTLEDIT_MB	                        50000754


#define IDH_TIME_STAMP_MD                       50000798
#define IDH_DEFAULT_DELETE_STALE_RECORD_MD      50000799
#define IDH_RR_DOMAIN_EDIT_MD	                  50000800
#define IDH_RR_NAME_EDIT_MD	                    50000801
#define IDH_NAME_NODE_EDIT_MD	                  50000802
#define IDH_BROWSE_BUTTON_MD	                  50000803
#define IDH_TTLEDIT_MD	                        50000804


#define IDH_TIME_STAMP_MF                       50000848
#define IDH_DEFAULT_DELETE_STALE_RECORD_MF      50000849
#define IDH_RR_DOMAIN_EDIT_MF	                  50000850
#define IDH_RR_NAME_EDIT_MF	                    50000851
#define IDH_NAME_NODE_EDIT_MF	                  50000852
#define IDH_BROWSE_BUTTON_MF	                  50000853
#define IDH_TTLEDIT_MF	                        50000854


#define IDH_TIME_STAMP_MG                       50000898
#define IDH_DEFAULT_DELETE_STALE_RECORD_MG      50000899
#define IDH_RR_DOMAIN_EDIT_MG	                  50000900
#define IDH_RR_NAME_EDIT_MG	                    50000901
#define IDH_NAME_NODE_EDIT_MG	                  50000902
#define IDH_BROWSE_BUTTON_MG	                  50000903
#define IDH_TTLEDIT_MG	                        50000904


#define IDH_TIME_STAMP_MINFO                    50000948
#define IDH_DEFAULT_DELETE_STALE_RECORD_MINFO   50000949
#define IDH_RR_DOMAIN_EDIT_MINFO	              50000950
#define IDH_RR_NAME_EDIT_MINFO	                50000951
#define IDH_NAME_MAILBOX_EDIT	                  50000952
#define IDH_BROWSE_NAME_MAILBOX_BUTTON	        50000953
#define IDH_ERROR_MAILBOX_EDIT	                50000954
#define IDH_BROWSE_ERROR_MAILBOX_BUTTON	        50000955
#define IDH_TTLEDIT_MINFO	                      50000956


#define IDH_TIME_STAMP_MR                       50000998
#define IDH_DEFAULT_DELETE_STALE_RECORD_MR      50000999
#define IDH_RR_DOMAIN_EDIT_MR	                  50001000
#define IDH_RR_NAME_EDIT_MR	                    50001001
#define IDH_NAME_NODE_EDIT_MR	                  50001002
#define IDH_BROWSE_BUTTON_MR	                  50001003
#define IDH_TTLEDIT_MR	                        50001004

//
//  Mail Exchange RR
//
#define IDH_TIME_STAMP_MX                       50001048
#define IDH_DEFAULT_DELETE_STALE_RECORD_MX      50001049
#define IDH_RR_DOMAIN_EDIT_MX	                  50001050
#define IDH_RR_NAME_EDIT_MX	                    50001051
#define IDH_NAME_EXCHANGE_EDIT	                50001052
#define IDH_BROWSE_BUTTON_MX	                  50001053
#define IDH_PREFERENCE_EDIT	                    50001054
#define IDH_TTLEDIT_MX	                        50001055

//
//  Name servers RR
//
#define IDH_DEFAULT_DELETE_STALE_RECORD_NS_CACHE 50001099
#define IDH_RR_DOMAIN_EDIT_NS_CACHE	            50001100
#define IDH_RR_NAME_EDIT_NS_CACHE	              50001101
#define IDH_NAME_NODE_EDIT_NS_CACHE	            50001102
#define IDH_BROWSE_BUTTON_NS_CACHE	            50001103
#define IDH_TTLEDIT_NS_CACHE	                  50001104
#define IDH_SERVER_NAME_EDIT	                  50001150
#define IDH_BROWSE_BUTTONNS_EDIT	              50001151
#define IDH_IPEDIT_NS_EDIT	                    50001152
#define IDH_LIST_NS_EDIT	                      50001153
#define IDH_BUTTON_ADD_NS_EDIT	                50001154
#define IDH_BUTTON_REMOVE_NS_EDIT	              50001155
#define IDH_QUERY_BUTTON	                      50001156
#define IDH_BUTTON_UP	                          50001157
#define IDH_BUTTON_DOWN	                        50001158
#define IDH_TTLEDIT_NS_EDIT	                    50001159

//
//  Pointer RR
//
#define IDH_TIME_STAMP_PTR                      50001198
#define IDH_DEFAULT_DELETE_STALE_RECORD_PTR     50001199
#define IDH_RR_DOMAIN_EDIT_PTR	                50001200
#define IDH_RR_NAME_IPEDIT	                    50001201
#define IDH_RR_NAME_EDIT_PTR	                  50001202
#define IDH_NAME_NODE_EDIT_PTR	                50001203
#define IDH_BROWSE_BUTTON_PTR	                  50001204
#define IDH_TTLEDIT_PTR	                        50001205

//
// Responsible Party RR
//
#define IDH_TIME_STAMP_RP                       50001248
#define IDH_DEFAULT_DELETE_STALE_RECORD_RP      50001249
#define IDH_RR_DOMAIN_EDIT_RP	                  50001250
#define IDH_RR_NAME_EDIT_RP	                    50001251
#define IDH_NAME_MAILBOX_EDIT_RP	              50001252
#define IDH_BROWSE_NAME_MAILBOX_BUTTON_RP	      50001253
#define IDH_ERROR_MAILBOX_EDIT_RP	              50001254
#define IDH_BROWSE_ERROR_MAILBOX_BUTTON_RP	    50001255
#define IDH_TTLEDIT_RP	                        50001256


#define IDH_TIME_STAMP_RT                       50001298
#define IDH_DEFAULT_DELETE_STALE_RECORD_RT      50001299
#define IDH_RR_DOMAIN_EDIT_RT	                  50001300
#define IDH_RR_NAME_EDIT_RT	                    50001301
#define IDH_NAME_EXCHANGE_EDIT_RT	              50001302
#define IDH_BROWSE_BUTTON_RT	                  50001303
#define IDH_PREFERENCE_EDIT_RT	                50001304
#define IDH_TTLEDIT_RT	                        50001305

//
//  Signatory RR
//
#define IDH_TIME_STAMP_SIG                      50001348
#define IDH_DEFAULT_DELETE_STALE_RECORD_SIG     50001349
#define IDH_RR_DOMAIN_EDIT_SIG	                50001350
#define IDH_RR_NAME_EDIT_SIG	                  50001351
#define IDH_TTLEDIT_SIG	                        50001352
#define IDH_RECORD_TYPE_COMBO                   50001353
#define IDH_ALGORITHM_COMBO_SIG                 50001354
#define IDH_LABELS_EDIT                         50001355
#define IDH_KEY_TAG_EDIT                        50001356
#define IDH_ORIG_TTL                            50001357
#define IDH_EXP_DATE                            50001358
#define IDH_EXP_TIME                            50001359
#define IDH_INC_DATE                            50001360
#define IDH_INC_TIME                            50001361
#define IDH_SIGNERS_NAME_EDIT                   50001362
#define IDH_DISPLAY_SIG_COMBO                   50001363
#define IDH_SIG_EDIT                            50001364


#define IDH_SERIAL_NUMBER_EDIT	                50001400
#define IDH_SERIAL_UP	                          50001401
#define IDH_SERIAL_DOWN	                        50001402
#define IDH_PRIMARY_SERV_EDIT	                  50001403
#define IDH_BROWSE_SERV_BUTTON	                50001404
#define IDH_RESP_PARTY_EDIT	                    50001405
#define IDH_BROWSE_PARTY_BUTTON	                50001406
#define IDH_REFR_INT_EDIT	                      50001407
#define IDH_REFR_INT_COMBO	                    50001408
#define IDH_RETRY_INT_EDIT	                    50001409
#define IDH_RETRY_INT_COMBO	                    50001410
#define IDH_EXP_INT_EDIT	                      50001411
#define IDH_EXP_INT_COMBO	                      50001412
#define IDH_MIN_TTLEDIT	                        50001413
#define IDH_TTLEDIT_SOA	                        50001414
#define IDH_MIN_TTLCOMBO                        50001415
#define IDH_TIME_STAMP_SRV                      50001448
#define IDH_DEFAULT_DELETE_STALE_RECORD_SRV     50001449
#define IDH_RR_DOMAIN_EDIT_SRV	                50001450
#define IDH_SERVICE_NAME_COMBO	                50001451
#define IDH_PROTOCOL_NAME_COMBO	                50001452
#define IDH_PRIORITY_EDIT	                      50001453
#define IDH_WEIGHT_EDIT	                        50001454
#define IDH_PORT_EDIT	                          50001455
#define IDH_NAME_TARGET_EDIT	                  50001456
#define IDH_TTLEDIT_SRV	                        50001457
#define IDH_TIME_STAMP_TXT                      50001498
#define IDH_DEFAULT_DELETE_STALE_RECORD_TXT     50001499
#define IDH_RR_DOMAIN_EDIT_TXT	                50001500
#define IDH_RR_NAME_EDIT_TXT	                  50001501
#define IDH_RR_TXT_EDIT	                        50001502
#define IDH_TTLEDIT_TXT	                        50001503
#define IDH_TIME_STAMP_UNK                      50001548
#define IDH_DEFAULT_DELETE_STALE_RECORD_UNK     50001549
#define IDH_RR_DOMAIN_EDIT_UNK	                50001550
#define IDH_RR_NAME_EDIT_UNK	                  50001551
#define IDH_DATA_EDIT	                          50001552
#define IDH_TTLEDIT_UNK	                        50001553
#define IDH_TIME_STAMP_WKS                      50001598
#define IDH_DEFAULT_DELETE_STALE_RECORD_WKS     50001599
#define IDH_RR_DOMAIN_EDIT_WKS	                50001600
#define IDH_RR_NAME_EDIT_WKS	                  50001601
#define IDH_IPEDIT_WKS	                        50001602
#define IDH_TCP_RADIO	                          50001603
#define IDH_UDP_RADIO	                          50001604
#define IDH_SERVICES_EDIT	                      50001605
#define IDH_TTLEDIT_WKS	                        50001606
#define IDH_TIME_STAMP_X25                      50001648
#define IDH_DEFAULT_DELETE_STALE_RECORD_X25     50001649
#define IDH_RR_DOMAIN_EDIT_X25	                50001650
#define IDH_RR_NAME_EDIT_X25	                  50001651
#define IDH_X121_ADDRESS_EDIT	                  50001652
#define IDH_TTLEDIT_X25	                        50001653
#define IDH_RECORD_TYPE_LIST	                  50001700
#define IDH_CREATE_RECORD_BUTTON	              50001701
#define IDH_RECORD_TYPE_DESCR	                  50001702
#define IDH_SERVER_VERSION_EDIT	                50001750
#define IDH_ADVANCED_OPTIONS_LIST	              50001751
#define IDH_NAME_CHECKING_COMBO	                50001752
#define IDH_BOOT_METHOD_COMBO	                  50001753
#define IDH_RESET_BUTTON	                      50001754
#define IDH_CHECK_ENABLE_SCAVENGING             50001755
#define IDH_REFR_INT_EDIT2                      50001756
#define IDH_REFR_INT_COMBO2                     50001757
#define IDH_USE_FORWARDERS_CHECK	              50001800
#define IDH_SLAVE_CHECK	                        50001801
#define IDH_IPEDIT_FORWARDERS	                  50001802
#define IDH_LIST_FORWARDERS	                    50001803
#define IDH_BUTTON_ADD_FORWARDERS	              50001804
#define IDH_BUTTON_REMOVE_FORWARDERS	          50001805
#define IDH_FWD_TIMEOUT_EDIT	                  50001808
#define IDH_LISTEN_ON_SPECIFIED_RADIO           50001849
#define IDH_LISTEN_ON_ALL_RADIO	                50001850
#define IDH_IPEDIT_INTERFACES	                  50001851
#define IDH_LIST_INTERFACES	                    50001852
#define IDH_BUTTON_ADD_INTERFACES	              50001853
#define IDH_BUTTON_REMOVE_INTERFACES	          50001854
#define IDH_RESET_BUTTON_LOGGING	              50001901
#define IDH_SIMPLE_QUERY_CHECK	                50001950
#define IDH_RECURSIVE_QUERY_CHECK	              50001951
#define IDH_TEST_NOW_BUTTON	                    50001952
#define IDH_ENABLE_TESTING_CHECK	              50001953
#define IDH_POLLING_INT_EDIT	                  50001954
#define IDH_POLLING_INT_COMBO	                  50001955
#define IDH_RESULTS_LIST	                      50001956
#define IDH_RADIO_ZONE_PRIMARY	                50002000
#define IDH_RADIO_ZONE_DS_PRIMARY	              50002001
#define IDH_RADIO_ZONE_SECONDARY	              50002002
#define IDH_RADIO_ZONE_STUB                     50002003
#define IDH_ADINT_CHECK                         50002004
#define IDH_RADIO_USE_DS_DATA	                  50002050
#define IDH_RADIO_USE_MEM_DATA	                50002051
#define IDH_AGING_BUTTON                        50002099
#define IDH_PAUSE_START_BUTTON	                50002100
#define IDH_CHANGE_TYPE_BUTTON	                50002101
#define IDH_FILE_NAME_EDIT	                    50002102
#define IDH_MASTERS_IPEDIT	                    50002103
#define IDH_MASTERS_IP_LIST	                    50002104
#define IDH_MASTERS_BUTTON_ADD	                50002105
#define IDH_MASTERS_BUTTON_REMOVE	              50002106
#define IDH_BROWSE_MASTERS_BUTTON	              50002107
#define IDH_FIND_MASTERS_NAMES_BUTTON	          50002108
#define IDH_MASTERS_BUTTON_UP	                  50002109
#define IDH_MASTERS_BUTTON_DOWN	                50002110
#define IDH_PRIMARY_DYN_UPD_COMBO	              50002111
#define IDH_LOCAL_LIST_CHECK                    50002112
#ifdef USE_NDNC
#define IDH_CHANGE_REPL_BUTTON                  50002113
#endif // USE_NDNC
#define IDH_USE_WINS_RES_CHECK	                50002150
#define IDH_NOT_REPL_CHECK	                    50002151
#define IDH_DOMAIN_NAME_EDIT_NBSTAT	            50002152
#define IDH_TTLEDIT_NBSTAT	                    50002153
#define IDH_ADVANCED_BUTTON_NBSTAT	            50002154
#define IDH_RADIO_NOTIFY_LIST                   50002199
#define IDH_RADIO_NOTIFY_OFF	                  50002200
#define IDH_RADIO_NOTIFY_ALL	                  50002201
#define IDH_IPEDIT_ZONE_NOTIFY	                50002202
#define IDH_LIST_ZONE_NOTIFY	                  50002203
#define IDH_BUTTON_ADD_ZONE_NOTIFY	            50002204
#define IDH_BUTTON_REMOVE_ZONE_NOTIFY	          50002205
#define IDH_CACHE_TIMEOUT_TTLEDIT	              50002250
#define IDH_LOOKUP_TIMEOUT_TTLEDIT	            50002251
#define IDH_NETBIOS_CHECK	                      50002252
#define IDH_IPEDIT_ZONE_WINS	                  50002302
#define IDH_LIST_ZONE_WINS	                    50002303
#define IDH_BUTTON_ADD_ZONE_WINS	              50002304
#define IDH_BUTTON_REMOVE_ZONE_WINS	            50002305
#define IDH_TTLEDIT_ZONE_WINS	                  50002308
#define IDH_ADVANCED_BUTTON_ZONE_WINS	          50002309
#define IDH_RADIO_SECSECURE_NONE	              50002350
#define IDH_RADIO_SECSECURE_OFF	                50002351
#define IDH_RADIO_SECSECURE_NS	                50002352
#define IDH_RADIO_SECSECURE_LIST	              50002353
#define IDH_IPEDIT_ZONE_TRANSFER	              50002354
#define IDH_LIST_ZONE_TRANSFER	                50002355
#define IDH_BUTTON_ADD_ZONE_TRANSFER	          50002356
#define IDH_BUTTON_REMOVE_ZONE_TRANSFER	        50002357
#define IDH_BUTTON_NOTIFY	                      50002360
#define IDH_SCAVENGING_ENABLED                  50002400
#define IDH_REFR_INT_EDIT3                      50002401
#define IDH_REFR_INT_COMBO3                     50002402
#define IDH_REFR_INT_EDIT4                      50002403
#define IDH_REFR_INT_COMBO4                     50002404
#define IDH_TIME_STAMP                          50002405

//
//  Next Domain RR
//
#define IDH_TIME_STAMP_NXT                      50002406
#define IDH_DEFAULT_DELETE_STALE_RECORD_NXT     50002407
#define IDH_RR_DOMAIN_EDIT_NXT	                50002408
#define IDH_RR_NAME_EDIT_NXT	                  50002409
#define IDH_TTLEDIT_NXT	                        50002410
#define IDH_NEXT_DOMAIN_EDIT                    50002411
#define IDH_LOGGING_OPTIONS_LIST_NXT            50002412


//
//  Server Domain Forwarders page
//
#define IDH_DOMAIN_LIST                         50002413
#define IDH_DOMAIN_ADD_BUTTON                   50002414
#define IDH_DOMAIN_REMOVE_BUTTON                50002415

//
//  Server New Domain Forwarder Dialog
//
#define IDH_DOMAIN_NAME_EDIT                    50002416
#define IDH_NEW_DOMAIN_FORWARDER_OK             50002417
#define IDH_NEW_DOMAIN_FORWARDER_CANCEL         50002418

//
//  Server Debug Logging page
//
#define IDH_SEND_CHECK                          50002419
#define IDH_RECEIVE_CHECK                       50002420
#define IDH_UDP_CHECK                           50002421
#define IDH_TCP_CHECK                           50002422
#define IDH_QUERIES_CHECK                       50002423
#define IDH_UPDATES                             50002424
#define IDH_NOTIFIES_CHECK                      50002425
#define IDH_REQUEST_CHECK                       50002426
#define IDH_RESPONSE_CHECK                      50002427
#define IDH_FILTERING_CHECK                     50002428
#define IDH_FILTER_BUTTON                       50002429
#define IDH_LOGFILE_EDIT                        50002430
#define IDH_MAX_SIZE_EDIT                       50002431
#define IDH_DETAIL_CHECK                        50002445
#define IDH_DEBUG_LOGGING_CHECK                 50002446

//
//  Server Debug Logging IP Filter Dialog
//
#define IDH_IPEDIT_LOGGING_FILTER               50002432
#define IDH_LIST_LOGGING_FILTER                 50002433
#define IDH_BUTTON_ADD_LOGGING_FILTER           50002434
#define IDH_BUTTON_REMOVE_LOGGING_FILTER        50002435
#define IDH_LOGGING_FILTER_OK                   50002436
#define IDH_LOGGING_FILTER_CANCEL               50002437

//
//  Server Event Logging Page
//
#define IDH_NO_EVENTS_RADIO                     50002438
#define IDH_ERRORS_RADIO                        50002439
#define IDH_ERRORS_WARNINGS_RADIO               50002440
#define IDH_ALL_RADIO                           50002441


//
//  Server Copy Root Hints Dialog
//
#define IDH_COPY_ROOTHINTS_IPEDIT               50002442
#define IDH_COPY_ROOTHINTS_OK                   50002443
#define IDH_COPY_ROOTHINTS_CANCEL               50002444

#ifdef USE_NDNC
#define IDH_FOREST_RADIO                        50002450
#define IDH_DOMAIN_RADIO                        50002451
#define IDH_DOMAIN_DC_RADIO                     50002452
#define IDH_CUSTOM_RADIO                        50002453
#define IDH_CUSTOM_COMBO                        50002454

const DWORD g_aHelpIDs_IDD_ZONE_GENERAL_CHANGE_REPLICATION[] =
{
  IDC_FOREST_RADIO,    IDH_FOREST_RADIO,         
  IDC_DOMAIN_RADIO,    IDH_DOMAIN_RADIO,      
  IDC_DOMAIN_DC_RADIO, IDH_DOMAIN_DC_RADIO,      
  IDC_CUSTOM_RADIO,    IDH_CUSTOM_RADIO,         
  IDC_CUSTOM_COMBO,    IDH_CUSTOM_COMBO,  
  0, 0
};
#endif

const DWORD g_aHelpIDs_IDD_BROWSE_DIALOG[]=
{
	IDC_COMBO_SEL_NODE, IDH_COMBO_SEL_NODE,
	IDC_LIST_NODE_ITEMS, IDH_LIST_NODE_ITEMS,
	IDC_SELECTION_EDIT, IDH_SELECTION_EDIT,
	IDC_COMBO_FILTER, IDH_COMBO_FILTER,
	0, 0
};

const DWORD g_aHelpIDs_IDD_CHOOSER_CHOOSE_MACHINE[]=
{
	IDC_CHOOSER_RADIO_LOCAL_MACHINE, IDH_CHOOSER_RADIO_LOCAL_MACHINE,
	IDC_CHOOSER_RADIO_SPECIFIC_MACHINE, IDH_CHOOSER_RADIO_SPECIFIC_MACHINE,
	IDC_CHOOSER_EDIT_MACHINE_NAME, IDH_CHOOSER_EDIT_MACHINE_NAME,
	IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES, IDH_CHOOSER_BUTTON_BROWSE_MACHINENAMES,
	IDC_CHOOSER_CHECK_CONTACT, IDH_CHOOSER_CHECK_CONTACT,
	0, 0
};

const DWORD g_aHelpIDs_IDD_DOMAIN_ADDNEWDOMAIN[]=
{
	IDC_EDIT_DOMAIN_NAME, IDH_EDIT_DOMAIN_NAME,
	IDC_IPEDIT_DOMAIN_NAME, IDH_IPEDIT_DOMAIN_NAME,
	0, 0
};

const DWORD g_aHelpIDs_IDD_DOMAIN_ADDNEWHOST[]=
{
	IDC_RR_DOMAIN_EDIT, IDH_RR_DOMAIN_EDIT_ADDNEWHOST,
	IDC_RR_NAME_EDIT, IDH_RR_NAME_EDIT_ADDNEWHOST,
	IDC_IPEDIT, IDH_IPEDIT_ADDNEWHOST,
	IDC_UPDATE_PRT_CHECK, IDH_UPDATE_PRT_CHECK,
	IDC_TTLEDIT, IDH_TTLEDIT_ADDNEWHOST,
	IDC_BUTTON_ADDHOST, IDH_BUTTON_ADDHOST,
	IDC_UPDATE_SECURITY_CHECK, IDH_UPDATE_SECURITY_CHECK,
   0, 0
};

const DWORD g_aHelpIDs_IDD_FILTERING_LIMITS[]=
{
	IDC_EDIT_COUNT, IDH_EDIT_COUNT,
	0, 0
};

const DWORD g_aHelpIDs_IDD_FILTERING_NAME[]=
{
	IDC_RADIO_FILTER_NONE,      IDH_RADIO_FILTER_NONE,
	IDC_RADIO_FILTER_STARTS,    IDH_RADIO_FILTER_STARTS,
	IDC_EDIT_FILTER_STARTS,     IDH_EDIT_FILTER_STARTS,
	IDC_RADIO_FILTER_CONTAINS,  IDH_RADIO_FILTER_CONTAINS,
	IDC_EDIT_FILTER_CONTAINS,   IDH_EDIT_FILTER_CONTAINS,
	IDC_RADIO_FILTER_RANGE,     IDH_RADIO_FILTER_RANGE,
	IDC_EDIT_FILTER_RANGE_FROM, IDH_EDIT_FILTER_RANGE_FROM,
	IDC_EDIT_FILTER_RANGE_TO,   IDH_EDIT_FILTER_RANGE_TO,
	0, 0
};

const DWORD g_aHelpIDs_IDD_NAME_SERVERS_PAGE[]=
{
	IDC_NS_LIST, IDH_NS_LIST,
	IDC_ADD_NS_BUTTON, IDH_ADD_NS_BUTTON,
	IDC_REMOVE_NS_BUTTON, IDH_REMOVE_NS_BUTTON,
	IDC_EDIT_NS_BUTTON, IDH_EDIT_NS_BUTTON,
	0, 0
};

const DWORD g_aHelpIDs_IDD_RR_A[]=
{
	IDC_RR_DOMAIN_EDIT, IDH_RR_DOMAIN_EDIT_A,
	IDC_RR_NAME_EDIT, IDH_RR_NAME_EDIT_A,
	IDC_IPEDIT, IDH_IPEDIT_A,
	IDC_UPDATE_PRT_CHECK, IDH_UPDATE_PRT_CHECK,
	IDC_TTLEDIT, IDH_TTLEDIT_A,
  IDC_DEFAULT_DELETE_STALE_RECORD, IDH_DEFAULT_DELETE_STALE_RECORD_A,
  IDC_TIME_EDIT, IDH_TIME_STAMP_A,
  IDC_UPDATE_SECURITY_CHECK, IDH_UPDATE_SECURITY_CHECK,
	0, 0
};

const DWORD g_aHelpIDs_IDD_RR_AAAA[]=
{
	IDC_RR_DOMAIN_EDIT, IDH_RR_DOMAIN_EDIT_AAAA,
	IDC_RR_NAME_EDIT, IDH_RR_NAME_EDIT_AAAA,
	IDC_IPV6EDIT, IDH_IPV6EDIT,
	IDC_TTLEDIT, IDH_TTLEDIT_AAAA,
  IDC_DEFAULT_DELETE_STALE_RECORD, IDH_DEFAULT_DELETE_STALE_RECORD_AAAA,
  IDC_TIME_EDIT, IDH_TIME_STAMP_AAAA,
	0, 0
};

const DWORD g_aHelpIDs_IDD_RR_AFSDB[]=
{
	IDC_RR_DOMAIN_EDIT, IDH_RR_DOMAIN_EDIT_AFSDB,
	IDC_RR_NAME_EDIT, IDH_RR_NAME_EDIT_AFSDB,
	IDC_NAME_EXCHANGE_EDIT, IDH_NAME_EXCHANGE_EDIT_AFSDB,
	IDC_AFS_VLS_RADIO, IDH_AFS_VLS_RADIO,
	IDC_DCE_ANS_RADIO, IDH_DCE_ANS_RADIO,
	IDC_OTHER_RADIO, IDH_OTHER_RADIO,
	IDC_SUBTYPE_EDIT, IDH_SUBTYPE_EDIT,
	IDC_BROWSE_BUTTON, IDH_BROWSE_BUTTON,
	IDC_TTLEDIT, IDH_TTLEDIT_AFSDB,
  IDC_DEFAULT_DELETE_STALE_RECORD, IDH_DEFAULT_DELETE_STALE_RECORD_AFSDB,
  IDC_TIME_EDIT, IDH_TIME_STAMP_AFSDB,
	0, 0
};

const DWORD g_aHelpIDs_IDD_RR_ATMA[]=
{
	IDC_RR_DOMAIN_EDIT, IDH_RR_DOMAIN_EDIT_ATMA,
	IDC_RR_NAME_EDIT, IDH_RR_NAME_EDIT_ATMA,
	IDC_RADIO_E164, IDH_RADIO_E164,
	IDC_RADIO_NSAP, IDH_RADIO_NSAP,
	IDC_EDIT_ATMA_ADDRESS, IDH_EDIT_ATMA_ADDRESS,
	IDC_TTLEDIT, IDH_TTLEDIT_ATMA,
  IDC_DEFAULT_DELETE_STALE_RECORD, IDH_DEFAULT_DELETE_STALE_RECORD_ATMA,
  IDC_TIME_EDIT, IDH_TIME_STAMP_ATMA,
	0, 0
};

const DWORD g_aHelpIDs_IDD_RR_CNAME[]=
{
	IDC_RR_DOMAIN_EDIT, IDH_RR_DOMAIN_EDIT_CNAME,
	IDC_RR_NAME_EDIT, IDH_RR_NAME_EDIT_CNAME,
	IDC_NAME_NODE_EDIT, IDH_NAME_NODE_EDIT,
	IDC_BROWSE_BUTTON, IDH_BROWSE_BUTTON,
	IDC_TTLEDIT, IDH_TTLEDIT_CNAME,
  IDC_DEFAULT_DELETE_STALE_RECORD, IDH_DEFAULT_DELETE_STALE_RECORD_CNAME,
  IDC_TIME_EDIT, IDH_TIME_STAMP_CNAME,
  IDC_UPDATE_SECURITY_CHECK, IDH_UPDATE_SECURITY_CHECK,
	0, 0
};

const DWORD g_aHelpIDs_IDD_RR_HINFO[]=
{
	IDC_RR_DOMAIN_EDIT, IDH_RR_DOMAIN_EDIT_HINFO,
	IDC_RR_NAME_EDIT, IDH_RR_NAME_EDIT_HINFO,
	IDC_CPU_TYPE_EDIT, IDH_CPU_TYPE_EDIT,
	IDC_OPERATING_SYSTEM_EDIT, IDH_OPERATING_SYSTEM_EDIT,
	IDC_TTLEDIT, IDH_TTLEDIT_HINFO,
  IDC_DEFAULT_DELETE_STALE_RECORD, IDH_DEFAULT_DELETE_STALE_RECORD_HINFO,
  IDC_TIME_EDIT, IDH_TIME_STAMP_HINFO,
	0, 0
};

const DWORD g_aHelpIDs_IDD_RR_ISDN[]=
{
	IDC_RR_DOMAIN_EDIT, IDH_RR_DOMAIN_EDIT_ISDN,
	IDC_RR_NAME_EDIT, IDH_RR_NAME_EDIT_ISDN,
	IDC_PHONE_NUM_AND_DDI_EDIT, IDH_PHONE_NUM_AND_DDI_EDIT,
	IDC_SUBADDRESS_EDIT, IDH_SUBADDRESS_EDIT,
	IDC_TTLEDIT, IDH_TTLEDIT_ISDN,
  IDC_DEFAULT_DELETE_STALE_RECORD, IDH_DEFAULT_DELETE_STALE_RECORD_ISDN,
  IDC_TIME_EDIT, IDH_TIME_STAMP_ISDN,
	0, 0
};

const DWORD g_aHelpIDs_IDD_RR_KEY[]=
{
	IDC_RR_DOMAIN_EDIT,               IDH_RR_DOMAIN_EDIT_KEY,
	IDC_RR_NAME_EDIT,                 IDH_RR_NAME_EDIT_KEY,
	IDC_TTLEDIT,                      IDH_TTLEDIT_KEY,
  IDC_BITFIELD_EDIT,                IDH_BITFIELD_EDIT,
  IDC_KEY_TYPE_COMBO,               IDH_KEY_TYPE_COMBO,
  IDC_NAME_TYPE_COMBO,              IDH_NAME_TYPE_COMBO,
  IDC_LOGGING_OPTIONS_LIST,         IDH_LOGGING_OPTIONS_LIST_KEY,
  IDC_PROTOCOL_COMBO,               IDH_PROTOCOL_COMBO,
  IDC_ALGORITHM_COMBO,              IDH_ALGORITHM_COMBO_KEY,
  IDC_KEY_EDIT,                     IDH_KEY_EDIT,
  IDC_DEFAULT_DELETE_STALE_RECORD,  IDH_DEFAULT_DELETE_STALE_RECORD_KEY,
  IDC_TIME_EDIT,                    IDH_TIME_STAMP_KEY,
	0, 0
};

const DWORD g_aHelpIDs_IDD_RR_MB[]=
{
	IDC_RR_DOMAIN_EDIT, IDH_RR_DOMAIN_EDIT_MB,
	IDC_RR_NAME_EDIT, IDH_RR_NAME_EDIT_MB,
	IDC_NAME_NODE_EDIT, IDH_NAME_NODE_EDIT,
	IDC_BROWSE_BUTTON, IDH_BROWSE_BUTTON,
	IDC_TTLEDIT, IDH_TTLEDIT_MB,
  IDC_DEFAULT_DELETE_STALE_RECORD, IDH_DEFAULT_DELETE_STALE_RECORD_MB,
  IDC_TIME_EDIT, IDH_TIME_STAMP_MB,
	0, 0
};

const DWORD g_aHelpIDs_IDD_RR_MD[]=
{
	IDC_RR_DOMAIN_EDIT, IDH_RR_DOMAIN_EDIT_MD,
	IDC_RR_NAME_EDIT, IDH_RR_NAME_EDIT_MD,
	IDC_NAME_NODE_EDIT, IDH_NAME_NODE_EDIT_MD,
	IDC_BROWSE_BUTTON, IDH_BROWSE_BUTTON_MD,
	IDC_TTLEDIT, IDH_TTLEDIT_MD,
  IDC_DEFAULT_DELETE_STALE_RECORD, IDH_DEFAULT_DELETE_STALE_RECORD_MD,
  IDC_TIME_EDIT, IDH_TIME_STAMP_MD,
	0, 0
};

const DWORD g_aHelpIDs_IDD_RR_MF[]=
{
	IDC_RR_DOMAIN_EDIT, IDH_RR_DOMAIN_EDIT_MF,
	IDC_RR_NAME_EDIT, IDH_RR_NAME_EDIT_MF,
	IDC_NAME_NODE_EDIT, IDH_NAME_NODE_EDIT_MF,
	IDC_BROWSE_BUTTON, IDH_BROWSE_BUTTON_MF,
	IDC_TTLEDIT, IDH_TTLEDIT_MF,
  IDC_DEFAULT_DELETE_STALE_RECORD, IDH_DEFAULT_DELETE_STALE_RECORD_MF,
  IDC_TIME_EDIT, IDH_TIME_STAMP_MF,
	0, 0
};

const DWORD g_aHelpIDs_IDD_RR_MG[]=
{
	IDC_RR_DOMAIN_EDIT, IDH_RR_DOMAIN_EDIT_MG,
	IDC_RR_NAME_EDIT, IDH_RR_NAME_EDIT_MG,
	IDC_NAME_NODE_EDIT, IDH_NAME_NODE_EDIT_MG,
	IDC_BROWSE_BUTTON, IDH_BROWSE_BUTTON_MG,
	IDC_TTLEDIT, IDH_TTLEDIT_MG,
  IDC_DEFAULT_DELETE_STALE_RECORD, IDH_DEFAULT_DELETE_STALE_RECORD_MG,
  IDC_TIME_EDIT, IDH_TIME_STAMP_MG,
	0, 0
};

const DWORD g_aHelpIDs_IDD_RR_MINFO[]=
{
	IDC_RR_DOMAIN_EDIT, IDH_RR_DOMAIN_EDIT_MINFO,
	IDC_RR_NAME_EDIT, IDH_RR_NAME_EDIT_MINFO,
	IDC_NAME_MAILBOX_EDIT, IDH_NAME_MAILBOX_EDIT,
	IDC_BROWSE_NAME_MAILBOX_BUTTON, IDH_BROWSE_NAME_MAILBOX_BUTTON,
	IDC_ERROR_MAILBOX_EDIT, IDH_ERROR_MAILBOX_EDIT,
	IDC_BROWSE_ERROR_MAILBOX_BUTTON, IDH_BROWSE_ERROR_MAILBOX_BUTTON,
	IDC_TTLEDIT, IDH_TTLEDIT_MINFO,
  IDC_DEFAULT_DELETE_STALE_RECORD, IDH_DEFAULT_DELETE_STALE_RECORD_MINFO,
  IDC_TIME_EDIT, IDH_TIME_STAMP_MINFO,
	0, 0
};

const DWORD g_aHelpIDs_IDD_RR_MR[]=
{
	IDC_RR_DOMAIN_EDIT, IDH_RR_DOMAIN_EDIT_MR,
	IDC_RR_NAME_EDIT, IDH_RR_NAME_EDIT_MR,
	IDC_NAME_NODE_EDIT, IDH_NAME_NODE_EDIT_MR,
	IDC_BROWSE_BUTTON, IDH_BROWSE_BUTTON_MR,
	IDC_TTLEDIT, IDH_TTLEDIT_MR,
  IDC_DEFAULT_DELETE_STALE_RECORD, IDH_DEFAULT_DELETE_STALE_RECORD_MR,
  IDC_TIME_EDIT, IDH_TIME_STAMP_MR,
	0, 0
};

const DWORD g_aHelpIDs_IDD_RR_MX[]=
{
	IDC_RR_DOMAIN_EDIT, IDH_RR_DOMAIN_EDIT_MX,
	IDC_RR_NAME_EDIT, IDH_RR_NAME_EDIT_MX,
	IDC_NAME_EXCHANGE_EDIT, IDH_NAME_EXCHANGE_EDIT,
	IDC_BROWSE_BUTTON, IDH_BROWSE_BUTTON_MX,
	IDC_PREFERENCE_EDIT, IDH_PREFERENCE_EDIT,
	IDC_TTLEDIT, IDH_TTLEDIT_MX,
  IDC_DEFAULT_DELETE_STALE_RECORD, IDH_DEFAULT_DELETE_STALE_RECORD_MX,
  IDC_TIME_EDIT, IDH_TIME_STAMP_MX,
	0, 0
};

const DWORD g_aHelpIDs_IDD_RR_NS_CACHE[]=
{
	IDC_RR_DOMAIN_EDIT, IDH_RR_DOMAIN_EDIT_NS_CACHE,
	IDC_RR_NAME_EDIT, IDH_RR_NAME_EDIT_NS_CACHE,
	IDC_NAME_NODE_EDIT, IDH_NAME_NODE_EDIT_NS_CACHE,
	IDC_BROWSE_BUTTON, IDH_BROWSE_BUTTON_NS_CACHE,
	IDC_TTLEDIT, IDH_TTLEDIT_NS_CACHE,
  IDC_DEFAULT_DELETE_STALE_RECORD, IDH_DEFAULT_DELETE_STALE_RECORD_NS_CACHE,
	0, 0
};

const DWORD g_aHelpIDs_IDD_RR_NS_EDIT[]=
{
	IDC_SERVER_NAME_EDIT, IDH_SERVER_NAME_EDIT,
	IDC_BROWSE_BUTTON, IDH_BROWSE_BUTTONNS_EDIT,
	IDC_IPEDIT, IDH_IPEDIT_NS_EDIT,
	IDC_LIST, IDH_LIST_NS_EDIT,
	IDC_BUTTON_ADD, IDH_BUTTON_ADD_NS_EDIT,
	IDC_BUTTON_REMOVE, IDH_BUTTON_REMOVE_NS_EDIT,
	IDC_QUERY_BUTTON, IDH_QUERY_BUTTON,
	IDC_BUTTON_UP, IDH_BUTTON_UP,
	IDC_BUTTON_DOWN, IDH_BUTTON_DOWN,
	IDC_TTLEDIT, IDH_TTLEDIT_NS_EDIT,
	0, 0
};

const DWORD g_aHelpIDs_IDD_RR_NXT[]=
{
	IDC_RR_DOMAIN_EDIT,                 IDH_RR_DOMAIN_EDIT_NXT,
	IDC_RR_NAME_EDIT,                   IDH_RR_NAME_EDIT_NXT,
	IDC_TTLEDIT,                        IDH_TTLEDIT_NXT,
  IDC_NEXT_DOMAIN_EDIT,               IDH_NEXT_DOMAIN_EDIT,
  IDC_LOGGING_OPTIONS_LIST,           IDH_LOGGING_OPTIONS_LIST_NXT,
  IDC_DEFAULT_DELETE_STALE_RECORD,    IDH_DEFAULT_DELETE_STALE_RECORD_NXT,
  IDC_TIME_EDIT,                      IDH_TIME_STAMP_NXT,
	0, 0
};

const DWORD g_aHelpIDs_IDD_RR_PTR[]=
{
	IDC_RR_DOMAIN_EDIT, IDH_RR_DOMAIN_EDIT_PTR,
	IDC_RR_NAME_IPEDIT, IDH_RR_NAME_IPEDIT,
	IDC_RR_NAME_EDIT, IDH_RR_NAME_EDIT_PTR,
	IDC_NAME_NODE_EDIT, IDH_NAME_NODE_EDIT_PTR,
	IDC_BROWSE_BUTTON, IDH_BROWSE_BUTTON_PTR,
	IDC_TTLEDIT, IDH_TTLEDIT_PTR,
  IDC_DEFAULT_DELETE_STALE_RECORD, IDH_DEFAULT_DELETE_STALE_RECORD_PTR,
  IDC_TIME_EDIT, IDH_TIME_STAMP_PTR,
	IDC_UPDATE_SECURITY_CHECK, IDH_UPDATE_SECURITY_CHECK,
	0, 0
};

const DWORD g_aHelpIDs_IDD_RR_RP[]=
{
	IDC_RR_DOMAIN_EDIT, IDH_RR_DOMAIN_EDIT_RP,
	IDC_RR_NAME_EDIT, IDH_RR_NAME_EDIT_RP,
	IDC_NAME_MAILBOX_EDIT, IDH_NAME_MAILBOX_EDIT_RP,
	IDC_BROWSE_NAME_MAILBOX_BUTTON, IDH_BROWSE_NAME_MAILBOX_BUTTON_RP,
	IDC_ERROR_MAILBOX_EDIT, IDH_ERROR_MAILBOX_EDIT_RP,
	IDC_BROWSE_ERROR_MAILBOX_BUTTON, IDH_BROWSE_ERROR_MAILBOX_BUTTON_RP,
	IDC_TTLEDIT, IDH_TTLEDIT_RP,
  IDC_DEFAULT_DELETE_STALE_RECORD, IDH_DEFAULT_DELETE_STALE_RECORD_RP,
  IDC_TIME_EDIT, IDH_TIME_STAMP_RP,
	0, 0
};

const DWORD g_aHelpIDs_IDD_RR_RT[]=
{
	IDC_RR_DOMAIN_EDIT, IDH_RR_DOMAIN_EDIT_RT,
	IDC_RR_NAME_EDIT, IDH_RR_NAME_EDIT_RT,
	IDC_NAME_EXCHANGE_EDIT, IDH_NAME_EXCHANGE_EDIT_RT,
	IDC_BROWSE_BUTTON, IDH_BROWSE_BUTTON_RT,
	IDC_PREFERENCE_EDIT, IDH_PREFERENCE_EDIT_RT,
	IDC_TTLEDIT, IDH_TTLEDIT_RT,
  IDC_DEFAULT_DELETE_STALE_RECORD, IDH_DEFAULT_DELETE_STALE_RECORD_RT,
  IDC_TIME_EDIT, IDH_TIME_STAMP_RT,
	0, 0
};

const DWORD g_aHelpIDs_IDD_RR_SIG[]=
{
	IDC_RR_DOMAIN_EDIT,                 IDH_RR_DOMAIN_EDIT_SIG,
	IDC_RR_NAME_EDIT,                   IDH_RR_NAME_EDIT_SIG,
	IDC_TTLEDIT,                        IDH_TTLEDIT_SIG,
  IDC_RECORD_TYPE_COMBO,              IDH_RECORD_TYPE_COMBO,
  IDC_ALGORITHM_COMBO,                IDH_ALGORITHM_COMBO_SIG,
  IDC_LABELS_EDIT,                    IDH_LABELS_EDIT,
  IDC_KEY_TAG_EDIT,                   IDH_KEY_TAG_EDIT,
  IDC_ORIG_TTL,                       IDH_ORIG_TTL,
  IDC_EXP_DATE,                       IDH_EXP_DATE,
  IDC_EXP_TIME,                       IDH_EXP_TIME,
  IDC_INC_DATE,                       IDH_INC_DATE,
  IDC_INC_TIME,                       IDH_INC_TIME,
  IDC_SIGNERS_NAME_EDIT,              IDH_SIGNERS_NAME_EDIT,
  IDC_SIG_EDIT,                       IDH_SIG_EDIT,
  IDC_DEFAULT_DELETE_STALE_RECORD,    IDH_DEFAULT_DELETE_STALE_RECORD_SIG,
  IDC_TIME_EDIT,                      IDH_TIME_STAMP_SIG,
	0, 0
};

const DWORD g_aHelpIDs_IDD_RR_SOA[]=
{
	IDC_SERIAL_NUMBER_EDIT,   IDH_SERIAL_NUMBER_EDIT,
	IDC_SERIAL_UP,            IDH_SERIAL_UP,
	IDC_SERIAL_DOWN,          IDH_SERIAL_DOWN,
	IDC_PRIMARY_SERV_EDIT,    IDH_PRIMARY_SERV_EDIT,
	IDC_BROWSE_SERV_BUTTON,   IDH_BROWSE_SERV_BUTTON,
	IDC_RESP_PARTY_EDIT,      IDH_RESP_PARTY_EDIT,
	IDC_BROWSE_PARTY_BUTTON,  IDH_BROWSE_PARTY_BUTTON,
	IDC_REFR_INT_EDIT,        IDH_REFR_INT_EDIT,
	IDC_REFR_INT_COMBO,       IDH_REFR_INT_COMBO,
	IDC_RETRY_INT_EDIT,       IDH_RETRY_INT_EDIT,
	IDC_RETRY_INT_COMBO,      IDH_RETRY_INT_COMBO,
	IDC_EXP_INT_EDIT,         IDH_EXP_INT_EDIT,
	IDC_EXP_INT_COMBO,        IDH_EXP_INT_COMBO,
	IDC_MINTTL_INT_EDIT,      IDH_MIN_TTLEDIT,
  IDC_MINTTL_INT_COMBO,     IDH_MIN_TTLCOMBO,
	IDC_TTLEDIT,              IDH_TTLEDIT_SOA,
	0, 0
};

const DWORD g_aHelpIDs_IDD_RR_SRV[]=
{
	IDC_RR_DOMAIN_EDIT, IDH_RR_DOMAIN_EDIT_SRV,
	IDC_SERVICE_NAME_COMBO, IDH_SERVICE_NAME_COMBO,
	IDC_PROTOCOL_NAME_COMBO, IDH_PROTOCOL_NAME_COMBO,
	IDC_PRIORITY_EDIT, IDH_PRIORITY_EDIT,
	IDC_WEIGHT_EDIT, IDH_WEIGHT_EDIT,
	IDC_PORT_EDIT, IDH_PORT_EDIT,
	IDC_NAME_TARGET_EDIT, IDH_NAME_TARGET_EDIT,
	IDC_TTLEDIT, IDH_TTLEDIT_SRV,
  IDC_DEFAULT_DELETE_STALE_RECORD, IDH_DEFAULT_DELETE_STALE_RECORD_SRV,
  IDC_TIME_EDIT, IDH_TIME_STAMP_SRV,
  IDC_UPDATE_SECURITY_CHECK, IDH_UPDATE_SECURITY_CHECK,
	0, 0
};

const DWORD g_aHelpIDs_IDD_RR_TXT[]=
{
	IDC_RR_DOMAIN_EDIT, IDH_RR_DOMAIN_EDIT_TXT,
	IDC_RR_NAME_EDIT, IDH_RR_NAME_EDIT_TXT,
	IDC_RR_TXT_EDIT, IDH_RR_TXT_EDIT,
	IDC_TTLEDIT, IDH_TTLEDIT_TXT,
  IDC_DEFAULT_DELETE_STALE_RECORD, IDH_DEFAULT_DELETE_STALE_RECORD_TXT,
  IDC_TIME_EDIT, IDH_TIME_STAMP_TXT,
	0, 0
};

const DWORD g_aHelpIDs_IDD_RR_UNK[]=
{
	IDC_RR_DOMAIN_EDIT, IDH_RR_DOMAIN_EDIT_UNK,
	IDC_RR_NAME_EDIT, IDH_RR_NAME_EDIT_UNK,
	IDC_DATA_EDIT, IDH_DATA_EDIT,
	IDC_TTLEDIT, IDH_TTLEDIT_UNK,
  IDC_DEFAULT_DELETE_STALE_RECORD, IDH_DEFAULT_DELETE_STALE_RECORD_UNK,
  IDC_TIME_EDIT, IDH_TIME_STAMP_UNK,
	0, 0
};

const DWORD g_aHelpIDs_IDD_RR_WKS[]=
{
	IDC_RR_DOMAIN_EDIT, IDH_RR_DOMAIN_EDIT_WKS,
	IDC_RR_NAME_EDIT, IDH_RR_NAME_EDIT_WKS,
	IDC_IPEDIT, IDH_IPEDIT_WKS,
	IDC_TCP_RADIO, IDH_TCP_RADIO,
	IDC_UDP_RADIO, IDH_UDP_RADIO,
	IDC_SERVICES_EDIT, IDH_SERVICES_EDIT,
	IDC_TTLEDIT, IDH_TTLEDIT_WKS,
  IDC_DEFAULT_DELETE_STALE_RECORD, IDH_DEFAULT_DELETE_STALE_RECORD_WKS,
  IDC_TIME_EDIT, IDH_TIME_STAMP_WKS,
	0, 0
};

const DWORD g_aHelpIDs_IDD_RR_X25[]=
{
	IDC_RR_DOMAIN_EDIT, IDH_RR_DOMAIN_EDIT_X25,
	IDC_RR_NAME_EDIT, IDH_RR_NAME_EDIT_X25,
	IDC_X121_ADDRESS_EDIT, IDH_X121_ADDRESS_EDIT,
	IDC_TTLEDIT, IDH_TTLEDIT_X25,
  IDC_DEFAULT_DELETE_STALE_RECORD, IDH_DEFAULT_DELETE_STALE_RECORD_X25,
  IDC_TIME_EDIT, IDH_TIME_STAMP_X25,
	0, 0
};

const DWORD g_aHelpIDs_IDD_SELECT_RECORD_TYPE_DIALOG[]=
{
	IDC_RECORD_TYPE_LIST, IDH_RECORD_TYPE_LIST,
	IDC_CREATE_RECORD_BUTTON, IDH_CREATE_RECORD_BUTTON,
	IDC_RECORD_TYPE_DESCR, IDH_RECORD_TYPE_DESCR,
	0, 0
};

const DWORD g_aHelpIDs_IDD_SERVER_ADVANCED_PAGE[]=
{
	IDC_SERVER_VERSION_EDIT, IDH_SERVER_VERSION_EDIT,
	IDC_ADVANCED_OPTIONS_LIST, IDH_ADVANCED_OPTIONS_LIST,
	IDC_NAME_CHECKING_COMBO, IDH_NAME_CHECKING_COMBO,
	IDC_BOOT_METHOD_COMBO, IDH_BOOT_METHOD_COMBO,
	IDC_RESET_BUTTON, IDH_RESET_BUTTON,
  IDC_CHECK_ENABLE_SCAVENGING, IDH_CHECK_ENABLE_SCAVENGING,
  IDC_REFR_INT_EDIT, IDH_REFR_INT_EDIT2,
  IDC_REFR_INT_COMBO, IDH_REFR_INT_COMBO2,
	0, 0
};

const DWORD g_aHelpIDs_IDD_SERVER_INTERFACES_PAGE[]=
{
	IDC_LISTEN_ON_ALL_RADIO, IDH_LISTEN_ON_ALL_RADIO,
  IDC_LISTEN_ON_SPECIFIED_RADIO, IDH_LISTEN_ON_SPECIFIED_RADIO,
	IDC_IPEDIT, IDH_IPEDIT_INTERFACES,
	IDC_LIST, IDH_LIST_INTERFACES,
	IDC_BUTTON_ADD, IDH_BUTTON_ADD_INTERFACES,
	IDC_BUTTON_REMOVE, IDH_BUTTON_REMOVE_INTERFACES,
	IDC_BUTTON_UP, IDH_BUTTON_UP,
	IDC_BUTTON_DOWN, IDH_BUTTON_DOWN,
	0, 0
};

const DWORD g_aHelpIDs_IDD_SERVER_DEBUG_LOGGING_PAGE[]=
{
  IDC_DEBUG_LOGGING_CHECK,    IDH_DEBUG_LOGGING_CHECK,
  IDC_SEND_CHECK,             IDH_SEND_CHECK,
  IDC_RECEIVE_CHECK,          IDH_RECEIVE_CHECK,
  IDC_UDP_CHECK,              IDH_UDP_CHECK,
  IDC_TCP_CHECK,              IDH_TCP_CHECK,
  IDC_QUERIES_CHECK,          IDH_QUERIES_CHECK,
  IDC_UPDATES_CHECK,          IDH_UPDATES,
  IDC_NOTIFIES_CHECK,         IDH_NOTIFIES_CHECK,
  IDC_REQUEST_CHECK,          IDH_REQUEST_CHECK,
  IDC_RESPONSE_CHECK,         IDH_RESPONSE_CHECK,
  IDC_DETAIL_CHECK,           IDH_DETAIL_CHECK,
  IDC_FILTERING_CHECK,        IDH_FILTERING_CHECK,
  IDC_FILTER_BUTTON,          IDH_FILTER_BUTTON,
  IDC_LOGFILE_EDIT,           IDH_LOGFILE_EDIT,
  IDC_MAX_SIZE_EDIT,          IDH_MAX_SIZE_EDIT,
	0, 0
};

const DWORD g_aHelpIDs_IDD_IP_FILTER_DIALOG[]=
{
  IDC_IPEDIT,                   IDH_IPEDIT_LOGGING_FILTER,
  IDC_LIST,                     IDH_LIST_LOGGING_FILTER,
  IDC_BUTTON_ADD,               IDH_BUTTON_ADD_LOGGING_FILTER,
  IDC_BUTTON_REMOVE,            IDH_BUTTON_REMOVE_LOGGING_FILTER,
  IDC_BUTTON_UP,                IDH_BUTTON_UP,
  IDC_BUTTON_DOWN,              IDH_BUTTON_DOWN,
  IDOK,                         IDH_LOGGING_FILTER_OK,
  IDCANCEL,                     IDH_LOGGING_FILTER_CANCEL,
  0, 0
};

const DWORD g_aHelpIDs_IDD_SERVER_EVENT_LOGGING_PAGE[]=
{
  IDC_NO_EVENTS_RADIO,        IDH_NO_EVENTS_RADIO,
  IDC_ERRORS_RADIO,           IDH_ERRORS_RADIO,
  IDC_ERRORS_WARNINGS_RADIO,  IDH_ERRORS_WARNINGS_RADIO,
  IDC_ALL_RADIO,              IDH_ALL_RADIO,
	0, 0
};

const DWORD g_aHelpIDs_IDD_SERVMON_TEST_PAGE[]=
{
	IDC_SIMPLE_QUERY_CHECK, IDH_SIMPLE_QUERY_CHECK,
	IDC_RECURSIVE_QUERY_CHECK, IDH_RECURSIVE_QUERY_CHECK,
	IDC_TEST_NOW_BUTTON, IDH_TEST_NOW_BUTTON,
	IDC_ENABLE_TESTING_CHECK, IDH_ENABLE_TESTING_CHECK,
	IDC_POLLING_INT_EDIT, IDH_POLLING_INT_EDIT,
	IDC_POLLING_INT_COMBO, IDH_POLLING_INT_COMBO,
	IDC_RESULTS_LIST, IDH_RESULTS_LIST,
	0, 0
};

const DWORD g_aHelpIDs_IDD_ZONE_GENERAL_CHANGE_TYPE[]=
{
	IDC_RADIO_ZONE_PRIMARY,       IDH_RADIO_ZONE_PRIMARY,
	IDC_RADIO_ZONE_SECONDARY,     IDH_RADIO_ZONE_SECONDARY,
  IDC_RADIO_ZONE_STUB,          IDH_RADIO_ZONE_STUB,
  IDC_ADINT_CHECK,              IDH_ADINT_CHECK,
	0, 0
};

const DWORD g_aHelpIDs_IDD_ZONE_GENERAL_CHANGE_TYPE_DATA_CONFLICT[]=
{
	IDC_RADIO_USE_DS_DATA, IDH_RADIO_USE_DS_DATA,	
	IDC_RADIO_USE_MEM_DATA, IDH_RADIO_USE_MEM_DATA,
	0, 0
};

#ifdef USE_NDNC
const DWORD g_aHelpIDs_IDD_ZONE_GENERAL_PAGE_NDNC[]=
{
  IDC_PAUSE_START_BUTTON,         IDH_PAUSE_START_BUTTON,	
  IDC_CHANGE_TYPE_BUTTON,         IDH_CHANGE_TYPE_BUTTON,
  IDC_CHANGE_REPL_BUTTON,         IDH_CHANGE_REPL_BUTTON,
  IDC_FILE_NAME_EDIT,             IDH_FILE_NAME_EDIT,
  IDC_MASTERS_IPEDIT,             IDH_MASTERS_IPEDIT,
  IDC_MASTERS_IP_LIST,            IDH_MASTERS_IP_LIST,
  IDC_MASTERS_BUTTON_ADD,         IDH_MASTERS_BUTTON_ADD,
  IDC_MASTERS_BUTTON_REMOVE,      IDH_MASTERS_BUTTON_REMOVE,
  IDC_BROWSE_MASTERS_BUTTON,      IDH_BROWSE_MASTERS_BUTTON,
  IDC_FIND_MASTERS_NAMES_BUTTON,  IDH_FIND_MASTERS_NAMES_BUTTON,
  IDC_MASTERS_BUTTON_UP,          IDH_MASTERS_BUTTON_UP,
  IDC_MASTERS_BUTTON_DOWN,        IDH_MASTERS_BUTTON_DOWN,
  IDC_LOCAL_LIST_CHECK,           IDH_LOCAL_LIST_CHECK,
  IDC_PRIMARY_DYN_UPD_COMBO,      IDH_PRIMARY_DYN_UPD_COMBO,
  IDC_AGING_BUTTON,               IDH_AGING_BUTTON,
  0, 0
};
#else
const DWORD g_aHelpIDs_IDD_ZONE_GENERAL_PAGE[]=
{
	IDC_PAUSE_START_BUTTON,         IDH_PAUSE_START_BUTTON,	
	IDC_CHANGE_TYPE_BUTTON,         IDH_CHANGE_TYPE_BUTTON,
	IDC_FILE_NAME_EDIT,             IDH_FILE_NAME_EDIT,
	IDC_MASTERS_IPEDIT,             IDH_MASTERS_IPEDIT,
	IDC_MASTERS_IP_LIST,            IDH_MASTERS_IP_LIST,
	IDC_MASTERS_BUTTON_ADD,         IDH_MASTERS_BUTTON_ADD,
	IDC_MASTERS_BUTTON_REMOVE,      IDH_MASTERS_BUTTON_REMOVE,
	IDC_BROWSE_MASTERS_BUTTON,      IDH_BROWSE_MASTERS_BUTTON,
	IDC_FIND_MASTERS_NAMES_BUTTON,  IDH_FIND_MASTERS_NAMES_BUTTON,
	IDC_MASTERS_BUTTON_UP,          IDH_MASTERS_BUTTON_UP,
	IDC_MASTERS_BUTTON_DOWN,        IDH_MASTERS_BUTTON_DOWN,
  IDC_LOCAL_LIST_CHECK,           IDH_LOCAL_LIST_CHECK,
	IDC_PRIMARY_DYN_UPD_COMBO,      IDH_PRIMARY_DYN_UPD_COMBO,
  IDC_AGING_BUTTON,               IDH_AGING_BUTTON,
	0, 0
};
#endif

const DWORD g_aHelpIDs_IDD_ZONE_NBSTAT_PAGE[]=
{
	IDC_USE_WINS_RES_CHECK, IDH_USE_WINS_RES_CHECK,	
	IDC_NOT_REPL_CHECK, IDH_NOT_REPL_CHECK,
	IDC_DOMAIN_NAME_EDIT, IDH_DOMAIN_NAME_EDIT_NBSTAT,
	IDC_TTLEDIT, IDH_TTLEDIT_NBSTAT,
	IDC_ADVANCED_BUTTON, IDH_ADVANCED_BUTTON_NBSTAT,
	0, 0
};

const DWORD g_aHelpIDs_IDD_ZONE_NOTIFY_SUBDIALOG[]=
{
	IDC_CHECK_AUTO_NOTIFY, IDH_RADIO_NOTIFY_OFF,
	IDC_RADIO_NOTIFY_ALL, IDH_RADIO_NOTIFY_ALL,
	IDC_IPEDIT, IDH_IPEDIT_ZONE_NOTIFY,
	IDC_LIST, IDH_LIST_ZONE_NOTIFY,
	IDC_BUTTON_ADD, IDH_BUTTON_ADD_ZONE_NOTIFY,
	IDC_BUTTON_REMOVE, IDH_BUTTON_REMOVE_ZONE_NOTIFY,
	IDC_BUTTON_UP, IDH_BUTTON_UP,
	IDC_BUTTON_DOWN, IDH_BUTTON_DOWN,
  IDC_RADIO_NOTIFY_LIST, IDH_RADIO_NOTIFY_LIST,
	0, 0
};

const DWORD g_aHelpIDs_IDD_ZONE_WINS_ADVANCED[]=
{
	IDC_CACHE_TIMEOUT_TTLEDIT, IDH_CACHE_TIMEOUT_TTLEDIT,
	IDC_LOOKUP_TIMEOUT_TTLEDIT, IDH_LOOKUP_TIMEOUT_TTLEDIT,
	IDC_NETBIOS_CHECK, IDH_NETBIOS_CHECK,
	0, 0
};

const DWORD g_aHelpIDs_IDD_ZONE_WINS_PAGE[]=
{
	IDC_USE_WINS_RES_CHECK, IDH_USE_WINS_RES_CHECK,
	IDC_NOT_REPL_CHECK, IDH_NOT_REPL_CHECK,
	IDC_IPEDIT, IDH_IPEDIT_ZONE_WINS,
	IDC_LIST, IDH_LIST_ZONE_WINS,
	IDC_BUTTON_ADD, IDH_BUTTON_ADD_ZONE_WINS,
	IDC_BUTTON_REMOVE, IDH_BUTTON_REMOVE_ZONE_WINS,
	IDC_BUTTON_UP, IDH_BUTTON_UP,
	IDC_BUTTON_DOWN, IDH_BUTTON_DOWN,
	IDC_TTLEDIT, IDH_TTLEDIT_ZONE_WINS,
	IDC_ADVANCED_BUTTON, IDH_ADVANCED_BUTTON_ZONE_WINS,
	0, 0
};

const DWORD g_aHelpIDs_IDD_ZONE_ZONE_TRANSFER_PAGE[]=
{
	IDC_CHECK_ALLOW_TRANSFERS, IDH_RADIO_SECSECURE_NONE,
	IDC_RADIO_SECSECURE_OFF, IDH_RADIO_SECSECURE_OFF,
	IDC_RADIO_SECSECURE_NS, IDH_RADIO_SECSECURE_NS,
	IDC_RADIO_SECSECURE_LIST, IDH_RADIO_SECSECURE_LIST,
	IDC_IPEDIT, IDH_IPEDIT_ZONE_TRANSFER,
	IDC_LIST, IDH_LIST_ZONE_TRANSFER,
	IDC_BUTTON_ADD, IDH_BUTTON_ADD_ZONE_TRANSFER,
	IDC_BUTTON_REMOVE, IDH_BUTTON_REMOVE_ZONE_TRANSFER,
	IDC_BUTTON_UP, IDH_BUTTON_UP,
	IDC_BUTTON_DOWN, IDH_BUTTON_DOWN,
	IDC_BUTTON_NOTIFY, IDH_BUTTON_NOTIFY,
	0, 0
};

const DWORD g_aHelpIDs_IDD_ZONE_AGING_DIALOG[]=
{
  IDC_SCAVENGING_ENABLED, IDH_SCAVENGING_ENABLED,
  IDC_REFR_INT_EDIT1, IDH_REFR_INT_EDIT3,
  IDC_REFR_INT_COMBO1, IDH_REFR_INT_COMBO3,
  IDC_REFR_INT_EDIT2, IDH_REFR_INT_EDIT4,
  IDC_REFR_INT_COMBO2, IDH_REFR_INT_COMBO4,
  IDC_TIME_STAMP, IDH_TIME_STAMP,
  0, 0
};

const DWORD g_aHelpIDs_IDD_SERVER_AGING_DIALOG[]=
{
  IDC_SCAVENGING_ENABLED, IDH_SCAVENGING_ENABLED,
  IDC_REFR_INT_EDIT1, IDH_REFR_INT_EDIT3,
  IDC_REFR_INT_COMBO1, IDH_REFR_INT_COMBO3,
  IDC_REFR_INT_EDIT2, IDH_REFR_INT_EDIT4,
  IDC_REFR_INT_COMBO2, IDH_REFR_INT_COMBO4,
  IDC_TIME_STAMP, IDH_TIME_STAMP,
  0, 0
};

const DWORD g_aHelpIDs_IDD_SERVER_DOMAIN_FORWARDERS_PAGE[]=
{
  IDC_DOMAIN_LIST,              IDH_DOMAIN_LIST,
  IDC_DOMAIN_ADD_BUTTON,        IDH_DOMAIN_ADD_BUTTON,
  IDC_DOMAIN_REMOVE_BUTTON,     IDH_DOMAIN_REMOVE_BUTTON,
  IDC_FWD_TIMEOUT_EDIT,         IDH_FWD_TIMEOUT_EDIT,
  IDC_SLAVE_CHECK,              IDH_SLAVE_CHECK,
  IDC_IPEDIT,                   IDH_IPEDIT_FORWARDERS,
  IDC_LIST,                     IDH_LIST_FORWARDERS,
  IDC_BUTTON_ADD,               IDH_BUTTON_ADD_FORWARDERS,
  IDC_BUTTON_REMOVE,            IDH_BUTTON_REMOVE_FORWARDERS,
  IDC_BUTTON_UP,                IDH_BUTTON_UP,
  IDC_BUTTON_DOWN,              IDH_BUTTON_DOWN,
  0, 0
};

const DWORD g_aHelpIDs_IDD_SERVER_NEW_DOMAIN_FORWARDER[]=
{
  IDC_DOMAIN_NAME_EDIT,         IDH_DOMAIN_NAME_EDIT,
  IDOK,                         IDH_NEW_DOMAIN_FORWARDER_OK,
  IDCANCEL,                     IDH_NEW_DOMAIN_FORWARDER_CANCEL,
  0, 0,
};

const DWORD g_aHelpIDs_IDD_COPY_ROOTHINTS_DIALOG[]=
{
  IDC_IPEDIT,                   IDH_COPY_ROOTHINTS_IPEDIT,
  IDOK,                         IDH_COPY_ROOTHINTS_OK,
  IDCANCEL,                     IDH_COPY_ROOTHINTS_CANCEL,
  0, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\ipeditor.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       ipeditor.cpp
//
//--------------------------------------------------------------------------

// ipeditor.cpp : implementation file
//

#include "preDNSsn.h"
#include <SnapBase.h>

#include "dnsutil.h"
#include "dnssnap.h"
#include "snapdata.h"
#include "server.h"
#include "ipeditor.h"

#ifdef DEBUG_ALLOCATOR
   #ifdef _DEBUG
   #define new DEBUG_NEW
   #undef THIS_FILE
   static char THIS_FILE[] = __FILE__;
   #endif
#endif


/////////////////////////////////////////////////////////////////////////////
// CIPListBox 

BEGIN_MESSAGE_MAP(CIPListBox, CListBox)
   //{{AFX_MSG_MAP(CIPListBox)
   ON_CONTROL_REFLECT(LBN_SELCHANGE, OnSelChange)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CIPListBox::OnAdd(DWORD dwIpAddr)
{
   if (FindIndexOfIpAddr(dwIpAddr) != -1)
      return FALSE;

   int nCount = GetCount();
  CString szIpAddr;
  FormatIpAddress(szIpAddr, dwIpAddr); 
   InsertString(nCount, szIpAddr);
   SetItemData(nCount,dwIpAddr);
   return TRUE;
}

BOOL CIPListBox::OnAddEx(DWORD dwIpAddr, LPCTSTR lpszServerName)
{
   if (FindIndexOfIpAddr(dwIpAddr) != -1)
      return FALSE;

   int nCount = GetCount();

   // NTRAID#NTBUG9-697838-2002/08/30-artm
   // '?' moved to resource file where it can be localized if needed
   CString serverNameNotAvailable;
   if (!serverNameNotAvailable.LoadString(IDS_QUESTION_MARK))
   {
      return FALSE;
   }

   USES_CONVERSION;
   CString s;
   s.Format(_T("%d.%d.%d.%d (%s)"), 
            IP_STRING_FMT_ARGS(dwIpAddr), 
            (lpszServerName != NULL) ? lpszServerName : serverNameNotAvailable);
   InsertString(nCount, s);
   SetItemData(nCount,dwIpAddr);
   return TRUE;
}

void CIPListBox::OnRemove(DWORD* pdwIpAddr)
{
   int nSel = GetCurSel();
   int nCount = GetCount();
   ASSERT(nSel >= 0);
   ASSERT(nSel < nCount);

   // get item data to return and remove item
   *pdwIpAddr = static_cast<DWORD>(GetItemData(nSel));
   DeleteString(nSel);
   // reset the selection
   if (nSel == nCount-1) // deleted the last position in the list
      SetCurSel(nSel-1); // move up one line (might get to -1)
   else
      SetCurSel(nSel); // stay on the same line
}

void CIPListBox::OnUp()
{
   int nSel = GetCurSel();
   ASSERT(nSel > 0);
   ASSERT(nSel < GetCount());
   // save selection
   CString s;
   GetText(nSel,s);
   DWORD x = static_cast<DWORD>(GetItemData(nSel));
   // delete selection
   DeleteString(nSel);
   // insert back
   InsertString(nSel-1,s);
   SetItemData(nSel-1,x);
   SetCurSel(nSel-1);
}

void CIPListBox::OnDown()
{
   int nSel = GetCurSel();
   ASSERT(nSel >= 0);
   ASSERT(nSel < GetCount()-1);
   // save selection
   CString s;
   GetText(nSel,s);
   DWORD x = static_cast<DWORD>(GetItemData(nSel));
   // delete selection
   DeleteString(nSel);
   // insert back
   InsertString(nSel+1,s);
   SetItemData(nSel+1,x);
   SetCurSel(nSel+1);
}

void CIPListBox::OnSelChange() 
{
   m_pEditor->OnListBoxSelChange();
}

void CIPListBox::UpdateHorizontalExtent()
{
   int nHorzExtent = 0;
   CClientDC dc(this);
   int nItems = GetCount();
   for   (int i=0; i < nItems; i++)
   {
      TEXTMETRIC tm;
      VERIFY(dc.GetTextMetrics(&tm));
      CString szBuffer;
      GetText(i, szBuffer);
      CSize ext = dc.GetTextExtent(szBuffer,szBuffer.GetLength());
      nHorzExtent = max(ext.cx ,nHorzExtent); 
   }
   SetHorizontalExtent(nHorzExtent);
}


int CIPListBox::FindIndexOfIpAddr(DWORD dwIpAddr)
{
   int nItems = GetCount();
   for   (int i=0; i < nItems; i++)
   {
      DWORD x = static_cast<DWORD>(GetItemData(i));
      if (x == dwIpAddr)
         return i;
   }
   return -1; // not found
}

/////////////////////////////////////////////////////////////////////////////
// CIPEdit 

BEGIN_MESSAGE_MAP(CIPEdit, CDNSIPv4Control)
   //{{AFX_MSG_MAP(CIPEdit)
   ON_CONTROL_REFLECT(EN_CHANGE, OnChange)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CIPEdit::OnChange() 
{
   m_pEditor->OnEditChange();
}


/////////////////////////////////////////////////////////////////////////////
// CMyButton

BEGIN_MESSAGE_MAP(CMyButton, CButton)
   //{{AFX_MSG_MAP(CMyButton)
   ON_CONTROL_REFLECT(BN_CLICKED, OnClicked)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CMyButton::OnClicked() 
{
   m_pEditor->OnButtonClicked(this);
}


/////////////////////////////////////////////////////////////////////////////
// CIPEditor

BOOL CIPEditor::Initialize(CWnd* pParentWnd,
                           CWnd* pControlWnd,
            UINT nIDBtnUp, UINT nIDBtnDown,
            UINT nIDBtnAdd, UINT nIDBtnRemove,
            UINT nIDIPCtrl, UINT nIDIPListBox)

{
   ASSERT(pParentWnd != NULL);
   if (pParentWnd == NULL)
      return FALSE;
   m_pParentWnd = pParentWnd;

  if (pControlWnd == NULL)
  {
    m_pControlWnd = pParentWnd;
  }
  else
  {
    m_pControlWnd = pControlWnd;
  }

   // set back pointers
   m_upButton.SetEditor(this);
   m_removeButton.SetEditor(this);
   m_downButton.SetEditor(this);
   m_addButton.SetEditor(this);
   m_edit.SetEditor(this);
   m_listBox.SetEditor(this);
   
   // sublclass buttons
   BOOL bRes = m_upButton.SubclassDlgItem(nIDBtnUp, m_pParentWnd);
   ASSERT(bRes);
   if (!bRes) return FALSE;
   bRes = m_removeButton.SubclassDlgItem(nIDBtnRemove, m_pParentWnd);
   ASSERT(bRes);
   if (!bRes) return FALSE;
   bRes = m_downButton.SubclassDlgItem(nIDBtnDown, m_pParentWnd);
   ASSERT(bRes);
   if (!bRes) return FALSE;
   bRes = m_addButton.SubclassDlgItem(nIDBtnAdd, m_pParentWnd);

   // subclass listbox
   ASSERT(bRes);
   if (!bRes) return FALSE;
   bRes = m_listBox.SubclassDlgItem(nIDIPListBox, m_pParentWnd);

   // sublclass edit control
   bRes = m_edit.SubclassDlgItem(nIDIPCtrl, m_pParentWnd);
   ASSERT(bRes);
   if (!bRes) return FALSE;

   //m_edit.SetAlertFunction(CDNSMaskCtrl::AlertFunc);

   if (m_bNoUpDown)
   {
      m_upButton.ShowWindow(FALSE);
      m_upButton.EnableWindow(FALSE);
      m_downButton.ShowWindow(FALSE);
      m_downButton.EnableWindow(FALSE);
   }

  LRESULT lDefID = SendMessage(m_addButton.GetParent()->GetSafeHwnd(), DM_GETDEFID, 0, 0);
  if (lDefID != 0)
  {
    m_nDefID = LOWORD(lDefID);
  }

   return bRes;
}

BOOL CIPEditor::OnButtonClicked(CMyButton* pButton)
{

   BOOL bRet = TRUE;
   if (pButton == &m_upButton)
   {
    if (m_bNoUpDown)
    {
      return TRUE;
    }
      m_listBox.OnUp();
      SetButtonsState();
      OnChangeData();
   }
   else if (pButton == &m_downButton)
   {
    if (m_bNoUpDown)
    {
      return TRUE;
    }
      m_listBox.OnDown();
      SetButtonsState();
      OnChangeData();
   }
   else if (pButton == &m_addButton)
   {
      DWORD dwIpAddr;
      m_edit.GetIPv4Val(&dwIpAddr);
      if (m_listBox.OnAdd(dwIpAddr))
      {
         SetButtonsState();
         m_edit.Clear();
      m_edit.SetFocusField(0);
         OnChangeData();
         m_listBox.UpdateHorizontalExtent();
      }
      else
      {
         // if already there, cleard edit but do not add
         m_edit.Clear();
      m_edit.SetFocusField(0);
         bRet = FALSE;
      }

   }
   else if (pButton == &m_removeButton)
   {
      DWORD dwIpAddr;
      m_listBox.OnRemove(&dwIpAddr);
      SetButtonsState();
      m_edit.SetIPv4Val(dwIpAddr);
      OnChangeData();
      m_listBox.UpdateHorizontalExtent();
   }
   else
   {
      bRet = FALSE;
   }
   return bRet;
}

void CIPEditor::OnEditChange()
{
  BOOL bEnable = !m_edit.IsEmpty();
  CWnd* pFocus = CWnd::GetFocus();
  if ( !bEnable && (pFocus == &m_addButton))
  {
    m_edit.SetFocus();
  }

  if (bEnable)
  {
     m_addButton.EnableWindow(TRUE);

    //
    // Set the add button as the default push button
    //
    SendMessage(GetParentWnd()->GetSafeHwnd(), DM_SETDEFID, (WPARAM)m_addButton.GetDlgCtrlID(), 0);

    //
    // Force the Add button to redraw itself
    //
    SendMessage(m_addButton.GetSafeHwnd(),
                BM_SETSTYLE,
                BS_DEFPUSHBUTTON,
                MAKELPARAM(TRUE, 0));
                       
    //
    // Force the previous default button to redraw itself
    //
    SendDlgItemMessage(m_pControlWnd->GetSafeHwnd(),
                       m_nDefID,
                       BM_SETSTYLE,
                       BS_PUSHBUTTON,
                       MAKELPARAM(TRUE, 0));

  }
  else
  {
    //
    // Set the previous default button back as the default push button
    //
    SendMessage(m_pControlWnd->GetSafeHwnd(), DM_SETDEFID, (WPARAM)m_nDefID, 0);

    //
    // Force the previous default button to redraw itself
    //
    SendMessage(GetDlgItem(m_pControlWnd->GetSafeHwnd(), m_nDefID),
                BM_SETSTYLE,
                BS_DEFPUSHBUTTON,
                MAKELPARAM(TRUE, 0));

    //
    // Force the Add button to redraw itself
    //
    SendMessage(m_addButton.GetSafeHwnd(),
                BM_SETSTYLE,
                BS_PUSHBUTTON,
                MAKELPARAM(TRUE, 0));

    m_addButton.EnableWindow(FALSE);
  }
}

void CIPEditor::AddAddresses(DWORD* pArr, int nArraySize)
{
   ASSERT(nArraySize > 0);
   for (int i=0; i<nArraySize; i++)
   {
      m_listBox.OnAdd(pArr[i]);
   }
   m_listBox.SetCurSel((m_listBox.GetCount() > 0) ? 0 : -1);
   SetButtonsState();
   OnChangeData();
   m_listBox.UpdateHorizontalExtent();
}

void CIPEditor::AddAddresses(DWORD* pArr, LPCTSTR* pStringArr, int nArraySize)
{
   ASSERT(nArraySize > 0);
   for (int i=0; i<nArraySize; i++)
   {
      m_listBox.OnAddEx(pArr[i], pStringArr[i]);
   }
   m_listBox.SetCurSel((m_listBox.GetCount() > 0) ? 0 : -1);
   SetButtonsState();
   OnChangeData();
   m_listBox.UpdateHorizontalExtent();
}

void CIPEditor::GetAddresses(DWORD* pArr, int nArraySize, int* pFilled)
{
   ASSERT(nArraySize > 0);
   int nCount = m_listBox.GetCount();
   ASSERT(nCount <= nArraySize);
   *pFilled = (nArraySize > nCount) ? nCount : nArraySize;
   for (int i=0; i < (*pFilled); i++)
   {
      pArr[i] = static_cast<DWORD>(m_listBox.GetItemData(i));
   }
}

void CIPEditor::Clear()
{
   m_listBox.ResetContent();
   m_edit.Clear();
   SetButtonsState();
   m_listBox.UpdateHorizontalExtent();
}

BOOL CIPEditor::BrowseFromDNSNamespace(CComponentDataObject* pComponentDataObject,
                              CPropertyPageHolderBase* pHolder,
                              BOOL bEnableBrowseEdit,
                              LPCTSTR lpszExcludeServerName)
{
   BOOL bRet = TRUE;
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
  FIX_THREAD_STATE_MFC_BUG();
   CThemeContextActivator activator;


  CDNSBrowserDlg dlg(pComponentDataObject, pHolder, SERVER, 
            bEnableBrowseEdit, lpszExcludeServerName);
   if (IDOK == dlg.DoModal())
   {
    //
    // First check to see if we can get the server IP address(es) from the node.
    //
    CDNSServerNode* pServerNode = dynamic_cast<CDNSServerNode*>(dlg.GetSelection());
    if (pServerNode != NULL)
    {
      DWORD dwCount = 0;
      PIP_ADDRESS pipServerAddresses = NULL;
      pServerNode->GetServerAddressesInfo(&dwCount, &pipServerAddresses);
      if (dwCount > 0 && pipServerAddresses != NULL)
      {
        AddAddresses(pipServerAddresses, dwCount);
        return TRUE;
      }
    }

    //
    // If we didn't get the IP address(es) from the node, then try the name
    //
      LPCTSTR lpszServerName = dlg.GetSelectionString();

    //
      // try to see if the name is already an IP address
    //
      IP_ADDRESS ipAddr = IPStringToAddr(lpszServerName);
      if (ipAddr != INADDR_NONE)
      {
         AddAddresses(&ipAddr, 1);
         return bRet; // it was a valid IP address, just converted
      }

    //
      // it was not an IP address, so try to query for all 
      // the A records for the server name
    //
      PDNS_RECORD pARecordList;
      DNS_STATUS dwErr = ::DnsQuery((LPTSTR)lpszServerName, 
                     DNS_TYPE_A, 
                     DNS_QUERY_STANDARD, 
                     NULL, &pARecordList, NULL);
      int nIPCountFromARec = 0;
      PDNS_RECORD pTemp = NULL;
      if (dwErr != 0)
      {
         bRet = FALSE;
      }
      else
      {
         pTemp = pARecordList;
         while (pTemp != NULL)
         {
            nIPCountFromARec++;
            pTemp = pTemp->pNext;
         }
         bRet = (nIPCountFromARec > 0);
      }
      if (!bRet)
      {
         if (pARecordList != NULL)
            ::DnsRecordListFree(pARecordList, DnsFreeRecordListDeep);
         return FALSE; // could not do resolution
      }

      // get the IP addresses from the A record list
      // and add them to the IP editor.
      // build an array of IP addresses to pass to the IP editor
      IP_ADDRESS* ipArray = (IP_ADDRESS*)malloc(nIPCountFromARec*sizeof(IP_ADDRESS));
    if (!ipArray)
    {
      return FALSE;
    }

      //scan the array of lists of A records we just found
      PIP_ADDRESS pCurrAddr = ipArray;
      pTemp = pARecordList;
      while (pTemp != NULL)
      {
         CString szTemp;
      FormatIpAddress(szTemp, pTemp->Data.A.IpAddress);
         TRACE(_T("found address = %s\n"), (LPCTSTR)szTemp);

         *pCurrAddr = pTemp->Data.A.IpAddress;
         pTemp = pTemp->pNext;
         pCurrAddr++;
      }
      // fill in the array if server names (all the same value, IP's of same host)
      LPCTSTR* lpszServerNameArr = (LPCTSTR*)malloc(sizeof(LPCTSTR)*nIPCountFromARec);
    if (lpszServerNameArr)
    {
        for (int i=0; i< nIPCountFromARec; i++)
           lpszServerNameArr[i] = lpszServerName; 
        // add to the editor
        AddAddresses(ipArray, lpszServerNameArr, nIPCountFromARec);
    }

      ASSERT(pARecordList != NULL);
      ::DnsRecordListFree(pARecordList, DnsFreeRecordListDeep);

    if (ipArray)
    {
      free(ipArray);
      ipArray = 0;
    }

    if (lpszServerNameArr)
    {
      free(lpszServerNameArr);
      lpszServerNameArr = 0;
    }
   }
   return bRet;
}

void CIPEditor::FindNames()
{
   int nCount = GetCount();
   if (nCount == 0)
      return;

   // retrieve an array of IP addresses
   DWORD* pIpArr = (DWORD*)malloc(sizeof(DWORD)*nCount);
   if (!pIpArr)
   {
      return;
   }

   LPCTSTR* lpszServerNameArr = 0;
   PDNS_RECORD* pPTRRecordListArr = 0;
   do // false loop
   {
      int nFilled;
      GetAddresses(pIpArr, nCount, &nFilled);
      ASSERT(nFilled == nCount);

      // try IP to host name resoulution
      lpszServerNameArr = (LPCTSTR*)malloc(sizeof(LPCTSTR)*nCount);
      if (!lpszServerNameArr)
      {
         break;
      }
      memset(lpszServerNameArr, 0x0, sizeof(LPCTSTR)*nCount);

      pPTRRecordListArr = (PDNS_RECORD*)malloc(sizeof(PDNS_RECORD)*nCount);
      if (!pPTRRecordListArr)
      {
         break;
      }
      memset(pPTRRecordListArr, 0x0, sizeof(PDNS_RECORD)*nCount);

      USES_CONVERSION;
      for (int k=0; k<nCount; k++)
      {
         // get the name of the PTR record
         CString szIpAddress;
         FormatIpAddress(szIpAddress, pIpArr[k]); // e.g. "157.55.89.116"
         ReverseIPString(szIpAddress.GetBuffer(1));       // e.g. "116.89.55.157"
         szIpAddress += INADDR_ARPA_SUFFIX;            // e.g. "116.89.55.157.in-addr.arpa"

         DNS_STATUS dwErr = ::DnsQuery((LPTSTR)(LPCTSTR)szIpAddress, 
                        DNS_TYPE_PTR, 
                        DNS_QUERY_STANDARD, 
                        NULL, &pPTRRecordListArr[k], NULL);
         if (dwErr == 0)
         {
            DWORD nPTRCount = 0;
            PDNS_RECORD pTemp = pPTRRecordListArr[k];
            while (pTemp != NULL)
            {
               nPTRCount++;
               pTemp = pTemp->pNext;
            }
            ASSERT(nPTRCount >= 1); // getting multiple host names for a given IP address?
            lpszServerNameArr[k] = pPTRRecordListArr[k]->Data.PTR.pNameHost;
         }
      }

      // remove the old entries and add the new ones
      int nSel = m_listBox.GetCurSel();
      Clear();
      AddAddresses(pIpArr, lpszServerNameArr, nCount);
      m_listBox.SetCurSel(nSel);
      SetButtonsState();

      // free memory from DnsQuery()
      for (k=0; k<nCount; k++)
      {
         if(pPTRRecordListArr[k] != NULL)
         {
            ::DnsRecordListFree(pPTRRecordListArr[k], DnsFreeRecordListDeep);
         }
      }
   } while (false);

   if (pIpArr)
   {
      free(pIpArr);
      pIpArr = 0;
   }

   if (lpszServerNameArr)
   {
      free(lpszServerNameArr);
      lpszServerNameArr = 0;
   }

   if (pPTRRecordListArr)
   {
      free(pPTRRecordListArr);
      pPTRRecordListArr = 0;
   }
}

void CIPEditor::EnableUI(BOOL bEnable, BOOL bListBoxAlwaysEnabled)
{
   // cache the value, needed on listbox selections notifications
   m_bUIEnabled = bEnable;
   m_upButton.EnableWindow(bEnable);
   m_removeButton.EnableWindow(bEnable);
   m_downButton.EnableWindow(bEnable);

   if (bEnable)
      m_addButton.EnableWindow(!m_edit.IsEmpty());
   else
      m_addButton.EnableWindow(FALSE);

   m_edit.EnableWindow(bEnable);
   if (!bListBoxAlwaysEnabled)
      m_listBox.EnableWindow(bEnable);

   if (bEnable)
      SetButtonsState();
}

void CIPEditor::ShowUI(BOOL bShow)
{
   m_upButton.ShowWindow(bShow);
   m_removeButton.ShowWindow(bShow);
   m_downButton.ShowWindow(bShow);
   m_addButton.ShowWindow(bShow);
   m_edit.ShowWindow(bShow);
   m_listBox.ShowWindow(bShow);
   EnableUI(bShow);
}


void CIPEditor::SetButtonsState()
{
   if (!m_bUIEnabled)
      return;

   int nSel = m_listBox.GetCurSel();
   int nCount = m_listBox.GetCount();

  CWnd* pFocus = CWnd::GetFocus();

   // must have item selected to remove
  BOOL bEnable = nSel != -1;
  if (!bEnable && (pFocus == &m_removeButton))
  {
    m_edit.SetFocus();
  }
   m_removeButton.EnableWindow(bEnable);
   
   if (m_bNoUpDown)
      return;
   // must have item selected not at the to to move it up
  bEnable = nSel > 0;
  if (!bEnable && (pFocus == &m_upButton))
  {
    m_edit.SetFocus();
  }
   m_upButton.EnableWindow(bEnable);
   // must have intem selected not at the bottom to move it down
  bEnable = (nSel >= 0) && (nSel < nCount-1);
  if (!bEnable && (pFocus == &m_downButton))
  {
    m_edit.SetFocus();
  }
   m_downButton.EnableWindow(bEnable);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\ipeditor.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       ipeditor.h
//
//--------------------------------------------------------------------------


#ifndef _IPEDITOR_H
#define _IPEDITOR_H

/////////////////////////////////////////////////////////////////////////////

#include "uiutil.h"
#include "browser.h"

///////////////////////////////////////////////////////////////////////////////
// FORWARD DECLARATIONS

class CComponentDataObject;

/////////////////////////////////////////////////////////////////////////////
// CIPListBox 

class CIPEditor; // fwd decl

class CIPListBox : public CListBox
{
// Construction
public:
	CIPListBox() {}

// Attributes
public:

// Operations
public:
	void SetEditor(CIPEditor* pEditor) { ASSERT(pEditor != NULL); m_pEditor = pEditor; }
	BOOL OnAdd(DWORD dwIpAddr);
	BOOL OnAddEx(DWORD dwIpAddr, LPCTSTR lpszServerName);
	void OnRemove(DWORD* pdwIpAddr);
	void OnUp();
	void OnDown();

	void UpdateHorizontalExtent();
	int FindIndexOfIpAddr(DWORD dwIpAddr);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CIPListBox)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CIPListBox() {}

	// Generated message map functions
protected:
	CIPEditor* m_pEditor;
	//{{AFX_MSG(CIPListBox)
	afx_msg void OnSelChange();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CIPEdit 

class CIPEdit : public CDNSIPv4Control
{
// Construction
public:
	CIPEdit() {};

// Attributes
public:

// Operations
public:
	void SetEditor(CIPEditor* pEditor) { ASSERT(pEditor != NULL); m_pEditor = pEditor; }
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CIPEdit)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CIPEdit(){};

	// Generated message map functions
protected:
	CIPEditor* m_pEditor;
	//{{AFX_MSG(CIPEdit)
	afx_msg void OnChange();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CMyButton

class CMyButton : public CButton
{
// Construction
public:
	CMyButton() {}

// Attributes
public:

// Operations
public:
	void SetEditor(CIPEditor* pEditor) { ASSERT(pEditor != NULL); m_pEditor = pEditor; }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMyButton)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMyButton() {}

	// Generated message map functions
protected:
	CIPEditor* m_pEditor;

	//{{AFX_MSG(CMyButton)
	afx_msg void OnClicked();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CIPEditor

class CIPEditor
{
public:
	CIPEditor(BOOL bNoUpDown = FALSE)	
	{
		m_bNoUpDown = bNoUpDown;
		m_pParentWnd = NULL;
		m_bUIEnabled = TRUE;
    m_nDefID = 0;
	}
	~CIPEditor() {}
	
	BOOL Initialize(CWnd* pParentWnd,
                  CWnd* pControlWnd,
					UINT nIDBtnUp, UINT nIDBtnDown,
					UINT nIDBtnAdd, UINT nIDBtnRemove,
					UINT nIDIPCtrl, UINT nIDIPListBox);
	
	BOOL OnButtonClicked(CMyButton* pButton);
	void OnEditChange();
	void OnListBoxSelChange()
	{
		SetButtonsState();
	}
	void AddAddresses(DWORD* pArr, int nArraySize);
	void GetAddresses(DWORD* pArr, int nArraySize, int* pFilled);
	void Clear();
	BOOL BrowseFromDNSNamespace(CComponentDataObject* pComponentDataObject,
								CPropertyPageHolderBase* pHolder,
								BOOL bEnableBrowseEdit = FALSE,
								LPCTSTR lpszExcludeServerName = NULL);
	void FindNames();
	void EnableUI(BOOL bEnable, BOOL bListBoxAlwaysEnabled = FALSE);
	void ShowUI(BOOL bShow);
	int GetCount() { return m_listBox.GetCount();}
	CWnd* GetParentWnd() { ASSERT(m_pParentWnd != NULL); return m_pParentWnd;}

protected:
	virtual void OnChangeData() {}

private:
	void AddAddresses(DWORD* pArr, LPCTSTR* lpszServerNameArr, int nArraySize);


	BOOL			m_bNoUpDown;  // disable and hide the up/down buttons
	BOOL			m_bUIEnabled;

	// Control Objects the editor uses
	CMyButton		m_upButton;
	CMyButton		m_removeButton;
	CMyButton		m_downButton;
	CMyButton		m_addButton;

	CIPEdit			m_edit;
	CIPListBox	m_listBox;
	CWnd*			  m_pParentWnd; // parent dialog or property page
  CWnd*       m_pControlWnd; // parent dialog or property sheet when being used in a property page

  UINT        m_nDefID;
	void SetButtonsState();
};

#endif //_IPEDITOR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\maskctrl.h ===
/* Copyright (C) 1991, Microsoft Corporation, all rights reserved

    maskctrl.h - TCP/IP Address custom control, global definitions

    November 10, 1992   - Greg Strange
	February 11, 1997 - Marco Chierotti (extend to IPv6 and TTL for DNS snapin)
*/

#ifndef _MASKCTRL_H
#define _MASKCTRL_H

/////////////////////////////////////////////////////////////////////////////////////////
// Messages sent to DNS_MaskControl 

#define DNS_MASK_CTRL_CLEAR			WM_USER+100 // no parameters

#define DNS_MASK_CTRL_SET			WM_USER+101 // wparam = array if DWORD, lparam = elements of the array
#define DNS_MASK_CTRL_GET			WM_USER+102 // wparam = array if DWORD, lparam = elements of the array

#define DNS_MASK_CTRL_SET_LOW_RANGE WM_USER+103 // wparam = field, lparam = low val
#define DNS_MASK_CTRL_SET_HI_RANGE	WM_USER+104 // wparam = field, lparam = hi val

#define DNS_MASK_CTRL_SETFOCUS		WM_USER+105 // wparam = field
#define DNS_MASK_CTRL_ISBLANK		WM_USER+106 // no parameters
#define DNS_MASK_CTRL_SET_ALERT		WM_USER+107 // wparam = function pointer for alert on field error
#define DNS_MASK_CTRL_ENABLE_FIELD	WM_USER+108 // wparam = field, lparam = 1/0 to enable/disable

// convert an IP address from 4 WORDs format into a single DWORD
#define MAKEIPADDRESS(b1,b2,b3,b4)  ((LPARAM)(((DWORD)(b1)<<24)+((DWORD)(b2)<<16)+((DWORD)(b3)<<8)+((DWORD)(b4))))

// get the first 8 bits out of a DWORD
#define OCTECT(x) (x & 0x000000ff)

// extract IP octects from a DWORD
#define FIRST_IPADDRESS(x)  ((x>>24) & 0xff)
#define SECOND_IPADDRESS(x) ((x>>16) & 0xff)
#define THIRD_IPADDRESS(x)  ((x>>8) & 0xff)
#define FOURTH_IPADDRESS(x) (x & 0xff)

// value for marking an empty field in the UI
#define FIELD_EMPTY ((DWORD)-1)

// helpful definitions for IPv4 and IPv4 field
#define EMPTY_IPV4_FIELD (0xff)
#define EMPTY_IPV4 ((DWORD)-1)

/* Strings defining the different control class names */
#define DNS_IP_V4_ADDRESS_CLASS				TEXT("DNS_IPv4AddressCtrl")
#define DNS_IP_V6_ADDRESS_CLASS				TEXT("DNS_IPv6AddressCtrl")
#define DNS_TTL_CLASS						TEXT("DNS_TTLCtrl")



BOOL DNS_ControlInit(HANDLE hInstance, LPCTSTR lpszClassName, WNDPROC lpfnWndProc,
                            LPCWSTR lpFontName, int nFontSize);

BOOL DNS_ControlsInitialize(HANDLE hInstance, LPCWSTR lpFontName, int nFontSize);


#endif // _MASKCTRL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\prednssn.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1998
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#include "preDNSsn.h"

#include <atlimpl.cpp>
//#include <atlwin21.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\nspage.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       nspage.h
//
//--------------------------------------------------------------------------


#ifndef _NSPAGE_H
#define _NSPAGE_H

///////////////////////////////////////////////////////////////////////////////
// FORWARD DECLARATIONS

class CDNS_NS_Record; 
class CDNSRecordNodeEditInfoList;
class CDNSRecordNodeEditInfo;
class CDNSDomainNode; 

////////////////////////////////////////////////////////////////////////////

class CNSListCtrl : public CListCtrl
{
public:
	void Initialize();
	BOOL InsertNSRecordEntry(CDNSRecordNodeEditInfo* pNSInfo, int nItemIndex);
	void UpdateNSRecordEntry(int nItemIndex);
	int GetSelection();
	void SetSelection(int nSel);
	CDNSRecordNodeEditInfo* GetSelectionEditInfo();
private:
	void InsertItemHelper(int nIndex, CDNSRecordNodeEditInfo* pNSInfo, 
								   LPCTSTR lpszName, LPCTSTR lpszValue);
	void BuildIPAddrDisplayString(CDNSRecordNodeEditInfo* pNSInfo, CString& szDisplayData);
	void GetIPAddressString(CDNSRecordNodeEditInfo* pNSInfo, CString& sz);

	DECLARE_MESSAGE_MAP()
};

///////////////////////////////////////////////////////////////////////////////
// CDNSNameServersPropertyPage

class CDNSNameServersPropertyPage : public CPropertyPageBase
{

// Construction
public:
	CDNSNameServersPropertyPage(UINT nIDTemplate = IDD_NAME_SERVERS_PAGE,
		UINT nIDCaption = 0);
	virtual ~CDNSNameServersPropertyPage();

	void SetReadOnly() { m_bReadOnly = TRUE;}

	virtual BOOL OnPropertyChange(BOOL bScopePane, long* pChangeMask);

	BOOL HasMeaningfulTTL() { return m_bMeaningfulTTL; }

// Overrides
	virtual BOOL OnApply();

	CDNSDomainNode* GetDomainNode() { ASSERT(m_pDomainNode != NULL);  return m_pDomainNode;}
	void SetDomainNode(CDNSDomainNode* pDomainNode) 
		{ASSERT(pDomainNode != NULL); m_pDomainNode = pDomainNode;}


protected:
	BOOL m_bMeaningfulTTL;	// true if TTL has meaning (zone, delegation), false on root hints
	BOOL m_bReadOnly;
	CDNSRecordNodeEditInfoList* m_pCloneInfoList;

	// access to external list of NS records (must override to hook up)
	virtual void ReadRecordNodesList() = 0;
	virtual BOOL WriteNSRecordNodesList();
	virtual BOOL OnWriteNSRecordNodesListError();
	virtual void OnCountChange(int){}

	// message handlers
	virtual BOOL OnInitDialog();
	afx_msg void OnAddButton();
	afx_msg void OnRemoveButton();
	afx_msg void OnEditButton();
   afx_msg void OnListItemChanged(NMHDR*, LRESULT*);

	// data
	CNSListCtrl		m_listCtrl;

	// internal helpers

	void LoadUIData();
	void FillNsListView();
	void EnableEditorButtons(int nListBoxSel);
  void EnableButtons(BOOL bEnable);

  void SetDescription(LPCWSTR lpsz) { SetDlgItemText(IDC_STATIC_DESCR, lpsz);}
  CStatic* GetDescription() { return (CStatic*)GetDlgItem(IDC_STATIC_DESCR); }
  void SetMessage(LPCWSTR lpsz) { SetDlgItemText(IDC_STATIC_MESSAGE, lpsz);}

	CButton* GetAddButton() { return (CButton*)GetDlgItem(IDC_ADD_NS_BUTTON);}
	CButton* GetRemoveButton() { return (CButton*)GetDlgItem(IDC_REMOVE_NS_BUTTON);}
	CButton* GetEditButton() { return (CButton*)GetDlgItem(IDC_EDIT_NS_BUTTON);}

	DECLARE_MESSAGE_MAP()

private:
	CDNSDomainNode* m_pDomainNode;

};

///////////////////////////////////////////////////////////////////////////////
// CDNSNameServersWizardPage

class CDNSNameServersWizardPage : public CPropertyPageBase
{

// Construction
public:
	CDNSNameServersWizardPage(UINT nIDTemplate = IDD_NAME_SERVERS_PAGE);
	virtual ~CDNSNameServersWizardPage();

	void SetReadOnly() { m_bReadOnly = TRUE;}

	virtual BOOL OnPropertyChange(BOOL bScopePane, long* pChangeMask);

	BOOL HasMeaningfulTTL() { return m_bMeaningfulTTL; }

// Overrides
	virtual BOOL OnApply();

	CDNSDomainNode* GetDomainNode() { ASSERT(m_pDomainNode != NULL);  return m_pDomainNode;}
	void SetDomainNode(CDNSDomainNode* pDomainNode) 
		{ASSERT(pDomainNode != NULL); m_pDomainNode = pDomainNode;}


protected:
	BOOL m_bMeaningfulTTL;	// true if TTL has meaning (zone, delegation), false on root hints
	BOOL m_bReadOnly;
	CDNSRecordNodeEditInfoList* m_pCloneInfoList;

	// access to external list of NS records (must override to hook up)
	virtual void ReadRecordNodesList() = 0;
	virtual BOOL WriteNSRecordNodesList();
	virtual BOOL OnWriteNSRecordNodesListError();
	virtual void OnCountChange(int){}

	// message handlers
	virtual BOOL OnInitDialog();
	afx_msg void OnAddButton();
	afx_msg void OnRemoveButton();
	afx_msg void OnEditButton();
   afx_msg void OnListItemChanged(NMHDR*, LRESULT*);

	// data
	CNSListCtrl		m_listCtrl;

	// internal helpers

	void LoadUIData();
	void FillNsListView();
	void EnableEditorButtons(int nListBoxSel);
  void EnableButtons(BOOL bEnable);

  void SetDescription(LPCWSTR lpsz) { SetDlgItemText(IDC_STATIC_DESCR, lpsz);}
  CStatic* GetDescription() { return (CStatic*)GetDlgItem(IDC_STATIC_DESCR); }
  void SetMessage(LPCWSTR lpsz) { SetDlgItemText(IDC_STATIC_MESSAGE, lpsz);}

	CButton* GetAddButton() { return (CButton*)GetDlgItem(IDC_ADD_NS_BUTTON);}
	CButton* GetRemoveButton() { return (CButton*)GetDlgItem(IDC_REMOVE_NS_BUTTON);}
	CButton* GetEditButton() { return (CButton*)GetDlgItem(IDC_EDIT_NS_BUTTON);}

	DECLARE_MESSAGE_MAP()

private:
	CDNSDomainNode* m_pDomainNode;

};

#endif // _NSPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\nspage.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       nspage.cpp
//
//--------------------------------------------------------------------------

#include "preDNSsn.h"
#include <SnapBase.h>

#include "resource.h"
#include "dnsutil.h"
#include "DNSSnap.h"
#include "snapdata.h"

#include "server.h"
#include "domain.h"
#include "record.h"
#include "zone.h"

#include "nspage.h"

#include "uiutil.h"
#include "ipeditor.h"

#include "browser.h"


///////////////////////////////////////////////////////////////////////////////
// CDNS_NS_RecordDialog

class CDNS_NS_RecordDialog : public CPropertyPage
{
public:
	CDNS_NS_RecordDialog(CDNSNameServersPropertyPage* pNSPage, BOOL bNew);
  CDNS_NS_RecordDialog(CDNSNameServersWizardPage* pNSWiz, BOOL bNew);
	~CDNS_NS_RecordDialog();

	INT_PTR DoModalSheet(HWND parent = 0);

	// data 
	BOOL m_bDirty;
	CDNSRecordNodeEditInfo* m_pNSInfo;

protected:
  virtual int OnCreate(LPCREATESTRUCT lpCreateStruct);
	virtual BOOL OnInitDialog();
	virtual BOOL OnApply();

	afx_msg void OnServerNameChange();
	afx_msg void OnBrowse();
	afx_msg void OnQuery();
  BOOL OnHelpInfo(HELPINFO* pHelpInfo);

	DECLARE_MESSAGE_MAP()

private:
	class CARecordAddressesIPEditor : public CIPEditor
	{
	public:
		CARecordAddressesIPEditor(CDNS_NS_RecordDialog* pNSRecordDialog)
			{ m_pNSRecordDialog = pNSRecordDialog;}
		void SetIpAddresses(CDNSRecordNodeEditInfo* pNSInfo);
		BOOL GetIpAddresses(CDNSRecordNodeEditInfo* pNSInfo);
	protected:
		virtual void OnChangeData();

	private:
		CDNS_NS_RecordDialog* m_pNSRecordDialog;
	};

	CARecordAddressesIPEditor	m_RecordAddressesEditor;
	BOOL m_bNew;
	CDNSNameServersPropertyPage* m_pNSPage;
  CDNSNameServersWizardPage* m_pNSWiz;

  CPropertyPageBase* GetPage()
  {
    if (m_pNSPage != NULL)
    {
      return m_pNSPage;
    }
    return m_pNSWiz;
  }

	HWND						m_hWndOKButton;
	HWND						m_hWndQueryButton;

	CDNSTTLControl* GetTTLCtrl() { return (CDNSTTLControl*)GetDlgItem(IDC_TTLEDIT);}
  CEdit* GetServerEdit() { return (CEdit*)GetDlgItem(IDC_SERVER_NAME_EDIT); }

	CDNS_NS_Record* GetNSRecord()
	{	
		ASSERT( m_pNSInfo != NULL);
		ASSERT( m_pNSInfo->m_pRecord->m_wType == DNS_TYPE_NS);
		return (CDNS_NS_Record*)m_pNSInfo->m_pRecord;
	}

	void GetNSServerName(CString& szNameNode);
	void SyncUIButtons();
	void EnableTTLCtrl(BOOL bShow);

	friend class CARecordAddressesIPEditor;
};

INT_PTR CDNS_NS_RecordDialog::DoModalSheet(HWND parent)
{
  /* NOTE : The first call to this may cause a first-chance exception. Excerpt from MSDN January 2000.

  Note   The first time a property page is created from its corresponding dialog resource, 
  it may cause a first-chance exception. This is a result of the property page changing 
  the style of the dialog resource to the required style prior to creating the page. Because 
  resources are generally read-only, this causes an exception. The exception is handled by 
  the system, and a copy of the modified resource is made automatically by the system. The 
  first-chance exception can thus be ignored.

  Since this exception must be handled by the operating system, do not wrap calls to 
  CPropertySheet::DoModal with a C++ try/catch block in which the catch handles all exceptions, 
  for example, catch (...). This will handle the exception intended for the operating system, 
  causing unpredictable behavior. Using C++ exception handling with specific exception types 
  or using structured exception handling where the Access Violation exception is passed through 
  to the operating system is safe, however.
  */

  AFX_MANAGE_STATE(AfxGetStaticModuleState());
   CThemeContextActivator activator;

	CString szTitle;
	szTitle.LoadString(m_bNew ? IDS_NEW_RECORD_TITLE : IDS_EDIT_RECORD_TITLE);
	CPropertySheet hostSheet;

  hostSheet.m_psh.dwFlags |= PSH_NOAPPLYNOW;
	hostSheet.m_psh.pszCaption = (LPCTSTR)szTitle;
   hostSheet.m_psh.hwndParent = parent;
	hostSheet.AddPage(this);

  INT_PTR iRes = hostSheet.DoModal();

  GetPage()->GetHolder()->PopDialogHWnd();
	return iRes;
}


void CDNS_NS_RecordDialog::CARecordAddressesIPEditor::OnChangeData()
{
	m_pNSRecordDialog->SyncUIButtons();
}

void CDNS_NS_RecordDialog::CARecordAddressesIPEditor::
				SetIpAddresses(CDNSRecordNodeEditInfo* pNSInfo)
{
	Clear();
	ASSERT(pNSInfo != NULL);
	INT_PTR nArraySize = pNSInfo->m_pEditInfoList->GetCount();
	if (nArraySize == 0)
		return;
	DWORD* pArr = (DWORD*)malloc(nArraySize*sizeof(DWORD));
  if (!pArr)
  {
    return;
  }

	int k=0;
	POSITION pos;
	for( pos = pNSInfo->m_pEditInfoList->GetHeadPosition(); pos != NULL; )
	{
		CDNSRecordNodeEditInfo* pARecordInfo = pNSInfo->m_pEditInfoList->GetNext(pos);
		ASSERT(pARecordInfo != NULL);
		if (pARecordInfo->m_action != CDNSRecordNodeEditInfo::remove)
		{
			ASSERT(pARecordInfo->m_pRecord != NULL);
			ASSERT(pARecordInfo->m_pRecord->m_wType == DNS_TYPE_A);
			CDNS_A_Record* pARecord = (CDNS_A_Record*)pARecordInfo->m_pRecord;
			pArr[k++] = pARecord->m_ipAddress;
		}
	}
	AddAddresses(pArr, k);
  if (pArr)
  {
    free(pArr);
  }
}

BOOL CDNS_NS_RecordDialog::CARecordAddressesIPEditor::
				GetIpAddresses(CDNSRecordNodeEditInfo* pNSInfo)
{
	BOOL bDirty = FALSE;
	int nArraySize = GetCount();

	// if the count of IP addresses is zero, 
	// we mark the NS record as slated for removal
	if (nArraySize == 0)
		pNSInfo->m_action = CDNSRecordNodeEditInfo::remove;

	// read the IP addresses from IP editor, if any
	DWORD* pArr = (nArraySize >0) ? (DWORD*)malloc(nArraySize*sizeof(DWORD)) : NULL;
  if (!pArr)
  {
    return FALSE;
  }

	int nFilled = 0;
	if (nArraySize > 0)
		GetAddresses(pArr, nArraySize, &nFilled);
	ASSERT(nFilled == nArraySize);

	ASSERT(pNSInfo->m_pRecord != NULL);
	ASSERT(pNSInfo->m_pRecord->GetType() == DNS_TYPE_NS);

	CDNS_NS_Record* pNSRecord = (CDNS_NS_Record*)pNSInfo->m_pRecord;
	CDNSRecordNodeEditInfoList* pNSInfoList = pNSInfo->m_pEditInfoList;
	CDNSRecordNodeEditInfoList NSInfoRemoveList;

	POSITION pos;

	// walk the list of A records, to mark the ones to be deleted,
	// if nArraySize == 0, all of them well be marked for removal
	for( pos = pNSInfoList->GetHeadPosition(); pos != NULL; )
	{
		CDNSRecordNodeEditInfo* pCurrentInfo = pNSInfoList->GetNext(pos);
		ASSERT(pCurrentInfo->m_pRecordNode != NULL);
		ASSERT(pCurrentInfo->m_pRecord != NULL);
		ASSERT(pCurrentInfo->m_pRecord->GetType() == DNS_TYPE_A);
		CDNS_A_Record* pARecord = (CDNS_A_Record*)pCurrentInfo->m_pRecord;
		BOOL bFound = FALSE;
		for (int k=0; k<nArraySize; k++)
		{
			if (pARecord->m_ipAddress == pArr[k])
			{
				bFound = TRUE;
				break;
			}
		}
		if (!bFound)
		{
			bDirty = TRUE;
			if (pCurrentInfo->m_bExisting)
			{
				pCurrentInfo->m_action = CDNSRecordNodeEditInfo::remove; // mark as deleted 
			}
			else
			{
				NSInfoRemoveList.AddTail(pCurrentInfo);
			}
		}
	} // for

	// This gives NSInfoRemoveList ownership of all memory management for all nodes
	// removed from the pNSInfoList
	POSITION listPos = NSInfoRemoveList.GetHeadPosition();
	while (listPos != NULL)
	{
		CDNSRecordNodeEditInfo* pCurrentInfo = NSInfoRemoveList.GetNext(listPos);
		ASSERT(pCurrentInfo != NULL);

		POSITION removePos = pNSInfoList->Find(pCurrentInfo);
		pNSInfoList->RemoveAt(removePos);
	}
	// Remove and delete all nodes that were removed from the pNSInfoList
	NSInfoRemoveList.RemoveAllNodes();


	// walk the list of addresses, to look for matching A records to add
	// if nArraySize == 0, loop skipped, nothing to add
	for (int k=0; k<nArraySize; k++)
	{
		BOOL bFound = FALSE;
		for( pos = pNSInfoList->GetHeadPosition(); pos != NULL; )
		{
			CDNSRecordNodeEditInfo* pCurrentInfo = pNSInfoList->GetNext(pos);
			ASSERT(pCurrentInfo->m_pRecordNode != NULL);
			ASSERT(pCurrentInfo->m_pRecord != NULL);
			ASSERT(pCurrentInfo->m_pRecord->GetType() == DNS_TYPE_A);
			CDNS_A_Record* pARecord = (CDNS_A_Record*)pCurrentInfo->m_pRecord;
			if (pARecord->m_ipAddress == pArr[k])
			{
				bFound = TRUE;
				if (pCurrentInfo->m_action == CDNSRecordNodeEditInfo::remove) // we got it already, resuscitate it
				{
					bDirty = TRUE;
					if(pCurrentInfo->m_bExisting)
						pCurrentInfo->m_action = CDNSRecordNodeEditInfo::edit;
					else
						pCurrentInfo->m_action = CDNSRecordNodeEditInfo::add;
				}
				break;
			}

		}
		if (!bFound)
		{
			// A record not found, need to create one
			CDNSRecordNodeEditInfo* pNewInfo = new CDNSRecordNodeEditInfo;
         if (pNewInfo)
         {
           CDNS_A_RecordNode* pARecordNode = new CDNS_A_RecordNode;
           if (pARecordNode)
           {
			     pNewInfo->CreateFromNewRecord(pARecordNode);
			     CDNS_A_Record* pARecord = (CDNS_A_Record*)pNewInfo->m_pRecord;
			     pARecord->m_ipAddress = pArr[k];
			     pNewInfo->m_pRecordNode->m_bAtTheNode = FALSE;
			     pNewInfo->m_pRecordNode->SetRecordName(pNSRecord->m_szNameNode, FALSE /*bAtTheNode*/);

			     // inherit the TTL of the NS record
			     pNewInfo->m_pRecord->m_dwTtlSeconds = pNSInfo->m_pRecord->m_dwTtlSeconds;

			     pNSInfoList->AddTail(pNewInfo);
			     bDirty = TRUE;
           }
           else
           {
              delete pNewInfo;
           }
         }
		}
	} // for

  if (pArr)
  {
    free(pArr);
  }

	return bDirty;
}

BEGIN_MESSAGE_MAP(CDNS_NS_RecordDialog, CPropertyPage)
  ON_WM_CREATE()
	ON_EN_CHANGE(IDC_SERVER_NAME_EDIT, OnServerNameChange)
	ON_BN_CLICKED(IDC_BROWSE_BUTTON, OnBrowse)
	ON_BN_CLICKED(IDC_QUERY_BUTTON, OnQuery)
  ON_WM_HELPINFO()
END_MESSAGE_MAP()

CDNS_NS_RecordDialog::CDNS_NS_RecordDialog(CDNSNameServersPropertyPage* pNSPage, BOOL bNew)
		: CPropertyPage(IDD_RR_NS_EDIT),
		m_RecordAddressesEditor(this)
{
	ASSERT(pNSPage != NULL);
	m_pNSPage = pNSPage;
  m_pNSWiz = NULL;
	m_bNew = bNew;
	m_bDirty = FALSE;
	m_pNSInfo = NULL;
	m_hWndOKButton = m_hWndQueryButton = NULL;
}

CDNS_NS_RecordDialog::CDNS_NS_RecordDialog(CDNSNameServersWizardPage* pNSWiz, BOOL bNew)
		: CPropertyPage(IDD_RR_NS_EDIT),
		m_RecordAddressesEditor(this)
{
	ASSERT(pNSWiz != NULL);
	m_pNSPage = NULL;
  m_pNSWiz = pNSWiz;
	m_bNew = bNew;
	m_bDirty = FALSE;
	m_pNSInfo = NULL;
	m_hWndOKButton = m_hWndQueryButton = NULL;
}

CDNS_NS_RecordDialog::~CDNS_NS_RecordDialog()
{

}

int CDNS_NS_RecordDialog::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
  int res = CPropertyPage::OnCreate(lpCreateStruct);

  DWORD dwStyle = ::GetWindowLong(::GetParent(GetSafeHwnd()), GWL_EXSTYLE);
  dwStyle |= WS_EX_CONTEXTHELP; // force the [?] button
  ::SetWindowLong(::GetParent(GetSafeHwnd()), GWL_EXSTYLE, dwStyle);

  return res;
}

BOOL CDNS_NS_RecordDialog::OnHelpInfo(HELPINFO* pHelpInfo)
{
  CComponentDataObject* pComponentData = GetPage()->GetHolder()->GetComponentData();
  ASSERT(pComponentData != NULL);
  pComponentData->OnDialogContextHelp(m_nIDHelp, pHelpInfo);
	return TRUE;
}

void CDNS_NS_RecordDialog::EnableTTLCtrl(BOOL bShow)
{
	CDNSTTLControl* pCtrl = GetTTLCtrl();
	ASSERT(pCtrl != NULL);
	pCtrl->EnableWindow(bShow);
	pCtrl->ShowWindow(bShow);
	CWnd* pWnd = GetDlgItem(IDC_STATIC_TTL);
	ASSERT(pWnd != NULL);
	pWnd->EnableWindow(bShow);
	pWnd->ShowWindow(bShow);

	CWnd* pLabelWnd = GetDlgItem(IDC_TTL_LABEL);
	ASSERT(pLabelWnd != NULL);
	pLabelWnd->EnableWindow(bShow);
	pLabelWnd->ShowWindow(bShow);
}


BOOL CDNS_NS_RecordDialog::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	ASSERT(m_pNSInfo != NULL);
	ASSERT(m_pNSInfo->m_pRecord != NULL);

	ASSERT(m_hWnd != NULL);
	ASSERT(::IsWindow(m_hWnd));
	HWND hParent = ::GetParent(m_hWnd);
	ASSERT(hParent);
	GetPage()->GetHolder()->PushDialogHWnd(hParent);

  //
	// OK button on the sheet
  //
	m_hWndOKButton = ::GetDlgItem(hParent, IDOK);
	ASSERT(::IsWindow(m_hWndOKButton));

  //
	// query button handle
  //
	m_hWndQueryButton = :: GetDlgItem(m_hWnd, IDC_QUERY_BUTTON);
	ASSERT(::IsWindow(m_hWndQueryButton));


  //
	// initialize IP editor
  //
	VERIFY(m_RecordAddressesEditor.Initialize(this,
                                            GetParent(),
							                              IDC_BUTTON_UP, 
                                            IDC_BUTTON_DOWN,
							                              IDC_BUTTON_ADD, 
                                            IDC_BUTTON_REMOVE, 
							                              IDC_IPEDIT, 
                                            IDC_LIST));

  //
	// Load Data in the UI
  //
	m_RecordAddressesEditor.SetIpAddresses(m_pNSInfo);

  GetServerEdit()->LimitText(MAX_DNS_NAME_LEN);
	GetServerEdit()->SetWindowText(GetNSRecord()->m_szNameNode);	
	
	GetTTLCtrl()->SetTTL(m_pNSInfo->m_pRecord->m_dwTtlSeconds);

	// need to decide if we want to show the TTL control
	CDNSRootData* pRootData = (CDNSRootData*)GetPage()->GetHolder()->GetComponentData()->GetRootData();
	ASSERT(pRootData != NULL);
	BOOL bEnableTTLCtrl;
  if (m_pNSPage != NULL)
  {
    bEnableTTLCtrl = m_pNSPage->HasMeaningfulTTL() && pRootData->IsAdvancedView();
  }
  else
  {
    bEnableTTLCtrl = m_pNSWiz->HasMeaningfulTTL() && pRootData->IsAdvancedView();
  }
	EnableTTLCtrl(bEnableTTLCtrl);

	return TRUE;  // return TRUE unless you set the focus to a control
}

void CDNS_NS_RecordDialog::GetNSServerName(CString& szNameNode)
{
	GetServerEdit()->GetWindowText(szNameNode);
  szNameNode.TrimLeft();
  szNameNode.TrimRight();
	if (szNameNode[szNameNode.GetLength()-1] != TEXT('.'))
		szNameNode += TEXT('.');
}

void CDNS_NS_RecordDialog::SyncUIButtons()
{
  CString szServerName;
  GetServerEdit()->GetWindowText(szServerName);
  szServerName.TrimLeft();
  szServerName.TrimRight();

  DWORD dwNameChecking = 0;
  if (m_pNSWiz)
  {
     dwNameChecking = m_pNSWiz->GetDomainNode()->GetServerNode()->GetNameCheckFlag();
  }
  else if (m_pNSPage)
  {
     dwNameChecking = m_pNSPage->GetDomainNode()->GetServerNode()->GetNameCheckFlag();
  }

  //
  // Enable OK button if it is a valid name
  //
  BOOL bIsValidName = (0 == ValidateDnsNameAgainstServerFlags(szServerName,
                                                              DnsNameDomain,
                                                              dwNameChecking)); 
	::EnableWindow(m_hWndOKButton, bIsValidName && 
				m_RecordAddressesEditor. GetCount() > 0);
	::EnableWindow(m_hWndQueryButton, bIsValidName);
}

BOOL CDNS_NS_RecordDialog::OnApply()
{
	ASSERT(m_pNSInfo->m_pRecord != NULL);
	CString szNameNode;
	GetNSServerName(szNameNode);

   // Make sure the new name is an FQDN or else we could have
   // a broken delegation
   CString szNSName;
   GetServerEdit()->GetWindowText(szNSName);

   if (szNSName.Find(L".") == -1)
   {
      DNSMessageBox(IDS_MSG_RECORD_WARNING_NS_NOT_FQDN, MB_OK);
      return false;
   }

	// compare (case insensitive) with old name to see if it changed,
	// NOTICE: CDNSDomainNode::UpdateARecordsOfNSInfoHelper() will then
	// take care of regenerating the list of A records
	m_bDirty = _wcsicmp((LPCWSTR)szNameNode, 
		(LPCWSTR)GetNSRecord()->m_szNameNode);
	if (m_bDirty)
		GetNSRecord()->m_szNameNode = szNameNode;

	// update list of IP addresses
	if (m_bNew)
	{
		// the dialog is used to create a new entry
		ASSERT(!m_pNSInfo->m_bExisting);
		m_pNSInfo->m_action = CDNSRecordNodeEditInfo::add;
	}
	else
	{
		// the dialog is used to edit
		if (m_pNSInfo->m_bExisting)
		{
			 // an existing entry
			m_pNSInfo->m_action = CDNSRecordNodeEditInfo::edit;
		}
		else
		{
			// a newly created entry, edited before committing
			m_pNSInfo->m_action = CDNSRecordNodeEditInfo::add;
		}
	}
	// this call migth mark the info as remove, if no IP addresses are found
	if (m_RecordAddressesEditor.GetIpAddresses(m_pNSInfo))
		m_bDirty = TRUE;

	DWORD dwTTL;
	GetTTLCtrl()->GetTTL(&dwTTL);
	if (m_pNSInfo->m_pRecord->m_dwTtlSeconds != dwTTL)
	{
		m_bDirty = TRUE;
		m_pNSInfo->m_pRecord->m_dwTtlSeconds = dwTTL;
		// Need to change the TTL on all associated A records
		CDNSRecordNodeEditInfoList* pNSInfoList = m_pNSInfo->m_pEditInfoList;
		for(POSITION pos = pNSInfoList->GetHeadPosition(); pos != NULL; )
		{
			CDNSRecordNodeEditInfo* pCurrentInfo = pNSInfoList->GetNext(pos);
			ASSERT(pCurrentInfo->m_pRecordNode != NULL);
			ASSERT(pCurrentInfo->m_pRecord != NULL);
			// if slated for removal, don't bother to change
			if (pCurrentInfo->m_action != CDNSRecordNodeEditInfo::remove)
			{
				pCurrentInfo->m_pRecord->m_dwTtlSeconds = m_pNSInfo->m_pRecord->m_dwTtlSeconds;
				// if already marked "add" or "edit", leave as is,
				// but if unchanged, need to mark as "edit"
				if (pCurrentInfo->m_action == CDNSRecordNodeEditInfo::unchanged)
					pCurrentInfo->m_action = CDNSRecordNodeEditInfo::edit;
			}
		}
	}
	if (m_pNSInfo->m_action == CDNSRecordNodeEditInfo::remove)
	{
		if (IDNO == DNSMessageBox(IDS_MSG_RECORD_WARNING_NS_NO_IP, MB_YESNO))
			return true;
	}

   return true;
}


void CDNS_NS_RecordDialog::OnServerNameChange()
{
	SyncUIButtons();
}



void CDNS_NS_RecordDialog::OnBrowse()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
  FIX_THREAD_STATE_MFC_BUG();
   CThemeContextActivator activator;


	CComponentDataObject* pComponentDataObject = GetPage()->GetHolder()->GetComponentData();
	CDNSBrowserDlg dlg(pComponentDataObject, GetPage()->GetHolder(), RECORD_A_AND_CNAME);
	if (IDOK == dlg.DoModal())
	{
		GetServerEdit()->SetWindowText(dlg.GetSelectionString());

    //
    // if it is an A record, add the IP address to the IP editor
    //
    CDNSRecordNodeBase* pRecordNode = reinterpret_cast<CDNSRecordNodeBase*>(dlg.GetSelection());
    if ((pRecordNode != NULL) && (pRecordNode->GetType() == DNS_TYPE_A))
    {
      DWORD ip = ((CDNS_A_RecordNode*)pRecordNode)->GetIPAddress();
      m_RecordAddressesEditor.AddAddresses(&ip,1);
    }  
	}
}

void CDNS_NS_RecordDialog::OnQuery()
{
  CWaitCursor cursor;

	CDNSRecordNodeEditInfo tempNSInfo; // test
	CString szNameNode;
	GetNSServerName(szNameNode);
	CDNSServerNode* pServerNode;
  if (m_pNSPage != NULL)
  {
    pServerNode = m_pNSPage->GetDomainNode()->GetServerNode();
  }
  else
  {
    pServerNode = m_pNSWiz->GetDomainNode()->GetServerNode();
  }

  LPCWSTR lpszZoneName = NULL;
  CDNSZoneNode* pZoneNode = NULL;
  if (m_pNSPage != NULL)
  {
    pZoneNode = m_pNSPage->GetDomainNode()->GetZoneNode();
  }
  else
  {
    pZoneNode = m_pNSWiz->GetDomainNode()->GetZoneNode();
  }

  if (pZoneNode != NULL)
  {
    lpszZoneName = pZoneNode->GetFullName();
  }
  
	ASSERT(pServerNode != NULL);
	CComponentDataObject* pComponentDataObject = 
				GetPage()->GetHolder()->GetComponentData();
	CDNSRootData* pRootData = (CDNSRootData*)pComponentDataObject->GetRootData();
	ASSERT(pRootData != NULL);

 	DWORD cAddrCount;
	PIP_ADDRESS pipAddrs;
	pServerNode->GetListenAddressesInfo(&cAddrCount, &pipAddrs);
  if (cAddrCount == 0)
	{
		// listening on all addresses
		pServerNode->GetServerAddressesInfo(&cAddrCount, &pipAddrs);
	}

	CDNSDomainNode::FindARecordsFromNSInfo(pServerNode->GetRPCName(), 
											pServerNode->GetVersion(),
                      cAddrCount, pipAddrs,
                      lpszZoneName, 
											szNameNode, 
											tempNSInfo.m_pEditInfoList, 
											pRootData->IsAdvancedView());

	if (tempNSInfo.m_pEditInfoList->GetCount() > 0)
  {
    // update the list only if we have valid data
  	m_RecordAddressesEditor.SetIpAddresses(&tempNSInfo);
  }
  else
  {
    DNSMessageBox(IDS_MSG_RECORD_NS_RESOLVE_IP, MB_OK | MB_ICONERROR);
  }
}

///////////////////////////////////////////////////////////////////////////////
// CNSListCtrl

BEGIN_MESSAGE_MAP(CNSListCtrl, CListCtrl)
END_MESSAGE_MAP()

void CNSListCtrl::Initialize()
{
	// get size of control to help set the column widths
	CRect controlRect;
	GetClientRect(controlRect);

	// get width of control, width of potential scrollbar, width needed for sub-item
	// string
	int controlWidth = controlRect.Width();
	int scrollThumbWidth = ::GetSystemMetrics(SM_CXHTHUMB);

	// clean net width
	int nNetControlWidth = controlWidth - scrollThumbWidth  - 12 * ::GetSystemMetrics(SM_CXBORDER);

	// fields widths
	int nWidth1 = 3 * nNetControlWidth / 4;
	int nWidth2 = nNetControlWidth - nWidth1;
	//
	// set up columns
	CString szHeaders;

	{
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
		szHeaders.LoadString(IDS_NSPAGE_LISTVIEW_HEADERS);
	}
	ASSERT(!szHeaders.IsEmpty());
	LPWSTR lpszArr[2];
	UINT n;
	ParseNewLineSeparatedString(szHeaders.GetBuffer(1), lpszArr, &n);
	szHeaders.ReleaseBuffer();
	ASSERT(n == 2);

	InsertColumn(1, lpszArr[0], LVCFMT_LEFT, nWidth1, 1);
	InsertColumn(2, lpszArr[1], LVCFMT_LEFT, nWidth2 + 28, 2);
}

int CNSListCtrl::GetSelection()
{
	return GetNextItem(-1, LVIS_SELECTED);
}

void CNSListCtrl::SetSelection(int nSel)
{
  VERIFY(SetItemState(nSel, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED));

/*
	VERIFY(SetItem(nSel, // nItem
					0,	// nSubItem
					LVIF_STATE, // nMask
					NULL, // lpszItem
					0, // nImage
					LVIS_SELECTED | LVIS_FOCUSED, // nState
					LVIS_SELECTED | LVIS_FOCUSED, // nStateMask
					NULL // lParam
					)); 
*/
}

void CNSListCtrl::UpdateNSRecordEntry(int nItemIndex)
{
	CDNSRecordNodeEditInfo* pNSInfo = (CDNSRecordNodeEditInfo*)GetItemData(nItemIndex);

	VERIFY(SetItem(nItemIndex, // nItem
					0,	// nSubItem
					LVIF_TEXT, // nMask
					((CDNS_NS_Record*)pNSInfo->m_pRecord)->m_szNameNode, // lpszItem
					0, // nImage
					0, // nState
					0, // nStateMask
					NULL // lParam
					)); 
	CString szTemp;
	GetIPAddressString(pNSInfo, szTemp);
	SetItemText(nItemIndex, 1, szTemp);
}


CDNSRecordNodeEditInfo* CNSListCtrl::GetSelectionEditInfo()
{
	int nSel = GetSelection();
	if (nSel == -1)
		return NULL; // no selection
	return (CDNSRecordNodeEditInfo*)GetItemData(nSel);
}


void CNSListCtrl::BuildIPAddrDisplayString(CDNSRecordNodeEditInfo* pNSInfo, CString& szDisplayData)
{
	USES_CONVERSION;
	// need to chain the IP addresses in a single string
	CString szTemp;
	szTemp.GetBuffer(20); // length of an IP string
	szTemp.ReleaseBuffer();
	szDisplayData.GetBuffer(static_cast<int>(20*pNSInfo->m_pEditInfoList->GetCount()));
	szDisplayData.ReleaseBuffer();
	POSITION pos;
	for( pos = pNSInfo->m_pEditInfoList->GetHeadPosition(); pos != NULL; )
	{
		CDNSRecordNodeEditInfo* pARecordInfo = pNSInfo->m_pEditInfoList->GetNext(pos);
		if (pARecordInfo->m_action != CDNSRecordNodeEditInfo::remove)
		{
			ASSERT(pARecordInfo != NULL);
			ASSERT(pARecordInfo->m_pRecord != NULL);
			ASSERT(pARecordInfo->m_pRecord->m_wType == DNS_TYPE_A);
			CDNS_A_Record* pARecord = (CDNS_A_Record*)pARecordInfo->m_pRecord;

      szDisplayData += _T("[");
      FormatIpAddress(szTemp, pARecord->m_ipAddress);
			szDisplayData += szTemp;
      if (pARecordInfo->m_bFromDnsQuery)
      {
        szDisplayData += _T("*");
      }
      szDisplayData += _T("] ");
		}
	}
}


BOOL CNSListCtrl::InsertNSRecordEntry(CDNSRecordNodeEditInfo* pNSInfo, int nItemIndex)
{
	ASSERT(pNSInfo != NULL);
	ASSERT( (pNSInfo->m_action == CDNSRecordNodeEditInfo::unchanged) ||
			(pNSInfo->m_action == CDNSRecordNodeEditInfo::add) ); 
	ASSERT(pNSInfo->m_pRecord != NULL);
	ASSERT(pNSInfo->m_pRecordNode != NULL);
	ASSERT(pNSInfo->m_pRecordNode->m_bAtTheNode);

  BOOL bAlreadyExists = FALSE;

  //
  // First check to see if its already there
  //
  for (int idx = 0; idx < GetItemCount(); idx++)
  {
    CDNSRecordNodeEditInfo* pIdxInfo = reinterpret_cast<CDNSRecordNodeEditInfo*>(GetItemData(idx));
    ASSERT(pIdxInfo != NULL);
    if (pIdxInfo == NULL)
    {
      continue;
    }

    CDNS_NS_Record* pNSRecord = reinterpret_cast<CDNS_NS_Record*>(pIdxInfo->m_pRecord);
    ASSERT(pNSRecord != NULL);
    if (pNSRecord == NULL)
    {
      continue;
    }

    //
    // Adding trailing '.' if not already present
    //
    CString szUINSName = pNSRecord->m_szNameNode;
    CString szNewNSName = ((CDNS_NS_Record*)pNSInfo->m_pRecord)->m_szNameNode;
    if (szUINSName[szUINSName.GetLength() - 1] != L'.')
    {
      szUINSName += L".";
    }

    if (szNewNSName[szNewNSName.GetLength() - 1] != L'.')
    {
      szNewNSName += L".";
    }

    //
    // if it exists, just update the existing one
    //
    if (_wcsicmp(szNewNSName, szUINSName) == 0)
    {
      bAlreadyExists = TRUE;

      //
      // Merge the A record lists together
      //
      POSITION newPos = pNSInfo->m_pEditInfoList->GetHeadPosition();
      while (newPos != NULL)
      {
        CDNSRecordNodeEditInfo* pAInfo = pNSInfo->m_pEditInfoList->GetNext(newPos);
        CDNS_A_Record* pARecord = reinterpret_cast<CDNS_A_Record*>(pAInfo->m_pRecord);
        ASSERT(pARecord != NULL);
        if (pARecord == NULL)
        {
          continue;
        }

        BOOL bARecordExists = FALSE;
        POSITION IdxPos = pIdxInfo->m_pEditInfoList->GetHeadPosition();
        while (IdxPos != NULL)
        {
          CDNSRecordNodeEditInfo* pIdxAInfo = pIdxInfo->m_pEditInfoList->GetNext(IdxPos);
          CDNS_A_Record* pIdxARecord = reinterpret_cast<CDNS_A_Record*>(pIdxAInfo->m_pRecord);
          ASSERT(pIdxARecord != NULL);
          if (pIdxARecord == NULL)
          {
            continue;
          }

          if (pIdxARecord->m_ipAddress == pARecord->m_ipAddress)
          {
            bARecordExists = TRUE;
            break;
          }
        }

        if (!bARecordExists)
        {
          //
          // Add the A record since it doesn't already exist in the list
          //
          pIdxInfo->m_pEditInfoList->AddTail(pAInfo);
          pIdxInfo->m_action = CDNSRecordNodeEditInfo::edit;
          UpdateNSRecordEntry(idx);
        }
      }
    }
  }

  if (!bAlreadyExists)
  {
	  CString szTemp;
	  GetIPAddressString(pNSInfo, szTemp);
	  InsertItemHelper(nItemIndex, pNSInfo, 
			  ((CDNS_NS_Record*)pNSInfo->m_pRecord)->m_szNameNode,
				  (LPCTSTR)szTemp);

    //
    // Added new item so return TRUE;
    //
    return TRUE;
  }
  //
  // Updated an existing item so return FALSE
  //
  return FALSE;
}


void CNSListCtrl::InsertItemHelper(int nIndex, CDNSRecordNodeEditInfo* pNSInfo, 
								   LPCTSTR lpszName, LPCTSTR lpszValue)
{
	UINT nState = 0;
	if (nIndex == 0 )
		nState = LVIS_SELECTED | LVIS_FOCUSED; // have at least one item, select it
	VERIFY(-1 != InsertItem(LVIF_TEXT | LVIF_PARAM, nIndex, 
			lpszName, nState, 0, 0, (LPARAM)pNSInfo)); 
	SetItemText(nIndex, 1, lpszValue);
}

void CNSListCtrl::GetIPAddressString(CDNSRecordNodeEditInfo* pNSInfo, CString& sz)
{
	if (pNSInfo->m_pEditInfoList->GetCount() > 0)
	{
		BuildIPAddrDisplayString(pNSInfo, sz);
	}
	else
		sz.LoadString(IDS_UNKNOWN);
}
///////////////////////////////////////////////////////////////////////////////
// CDNSNameServersPropertyPage


BEGIN_MESSAGE_MAP(CDNSNameServersPropertyPage, CPropertyPageBase)
	ON_BN_CLICKED(IDC_ADD_NS_BUTTON, OnAddButton)
	ON_BN_CLICKED(IDC_REMOVE_NS_BUTTON, OnRemoveButton)
	ON_BN_CLICKED(IDC_EDIT_NS_BUTTON, OnEditButton)
   ON_NOTIFY(LVN_ITEMCHANGED, IDC_NS_LIST, OnListItemChanged)
END_MESSAGE_MAP()

CDNSNameServersPropertyPage::CDNSNameServersPropertyPage(UINT nIDTemplate, UINT nIDCaption)
				: CPropertyPageBase(nIDTemplate, nIDCaption)
{
	m_pDomainNode = NULL;
	m_pCloneInfoList = new CDNSRecordNodeEditInfoList;
	m_bReadOnly = FALSE;
	m_bMeaningfulTTL = TRUE;
}


CDNSNameServersPropertyPage::~CDNSNameServersPropertyPage()
{
	delete m_pCloneInfoList;
}

BOOL CDNSNameServersPropertyPage::WriteNSRecordNodesList()
{
	ASSERT(!m_bReadOnly);
	ASSERT(m_pCloneInfoList != NULL);
	CDNSDomainNode* pDomainNode = GetDomainNode();
	return pDomainNode->UpdateNSRecordNodesInfo(m_pCloneInfoList, GetHolder()->GetComponentData());
}

BOOL CDNSNameServersPropertyPage::OnWriteNSRecordNodesListError()
{
	ASSERT(!m_bReadOnly);

	BOOL bSuccess = TRUE;
	// loop for each NS record
	POSITION pos;
	for( pos = m_pCloneInfoList->GetHeadPosition(); pos != NULL; )
	{
		CDNSRecordNodeEditInfo* pCurrentInfo = m_pCloneInfoList->GetNext(pos);
		if (pCurrentInfo->m_dwErr != 0)
		{
			if (pCurrentInfo->m_dwErr == DNS_ERROR_RECORD_ALREADY_EXISTS)
			{
				// ignore if the NS record us already there
				pCurrentInfo->m_dwErr = 0;
			}
         else if (pCurrentInfo->m_dwErr == RPC_S_SERVER_UNAVAILABLE)
         {
            // Couldn't contact the server. Give a single error message
            // and then break out.

            DNSErrorDialog(pCurrentInfo->m_dwErr, L"");
            
            return FALSE;
         }
			else
			{
				bSuccess = FALSE;
				ASSERT(pCurrentInfo->m_pRecord->GetType() == DNS_TYPE_NS);
				CString szNSMsg;
				szNSMsg.Format(_T("Failure to write NS record <%s>"), 
					(((CDNS_NS_Record*)pCurrentInfo->m_pRecord))->m_szNameNode);
				DNSErrorDialog(pCurrentInfo->m_dwErr,szNSMsg);
			}
		}
		// loop for each related A record
		CDNSRecordNodeEditInfoList*	pARecordInfoList = pCurrentInfo->m_pEditInfoList;
		ASSERT(pARecordInfoList != NULL);
		POSITION posA;
		for( posA = pARecordInfoList->GetHeadPosition(); posA != NULL; )
		{
			CDNSRecordNodeEditInfo* pARecordCurrentInfo = pARecordInfoList->GetNext(posA);
			if (pARecordCurrentInfo->m_dwErr != 0)
			{
				ASSERT(pARecordCurrentInfo->m_pRecord->GetType() == DNS_TYPE_A);
        CString szTemp;
        FormatIpAddress(szTemp, (((CDNS_A_Record*)pARecordCurrentInfo->m_pRecord))->m_ipAddress);
				CString szAMsg;
				szAMsg.Format(_T("Failure to write A record <%s>, IP Address %s"), 
					(((CDNS_NS_Record*)pARecordCurrentInfo->m_pRecord))->m_szNameNode,
            (LPCWSTR)szTemp );
				DNSErrorDialog(pCurrentInfo->m_dwErr,szAMsg);
			}
		}
	}
	return bSuccess;
}

void CDNSNameServersPropertyPage::OnListItemChanged(NMHDR*, LRESULT*)
{
   EnableEditorButtons(m_listCtrl.GetSelection());
}

BOOL CDNSNameServersPropertyPage::OnApply()
{
	if (m_bReadOnly)
		return TRUE;

	if (!IsDirty())
		return TRUE;

	DNS_STATUS err = GetHolder()->NotifyConsole(this);
	if ( (err != 0) && OnWriteNSRecordNodesListError() )
	{
		err = 0; // error was handled and it was not fatal
	}

	if (err == 0)
	{
		// refresh data from the zone/domain
		LoadUIData();
		SetDirty(FALSE);
	}
	return (err == 0); 
}


BOOL CDNSNameServersPropertyPage::OnPropertyChange(BOOL, long*)
{
	if (m_bReadOnly)
	{
		ASSERT(FALSE); // sould not happen
		return FALSE;
	}

	ASSERT(m_pCloneInfoList != NULL);
	if (m_pCloneInfoList == NULL)
		return FALSE;

	BOOL bRes = WriteNSRecordNodesList();
	if (!bRes)
		GetHolder()->SetError(static_cast<DWORD>(-1));  // something went wrong, error code will be per item
	return bRes; // update flag
}


void CDNSNameServersPropertyPage::OnAddButton()
{
	if (m_bReadOnly)
	{
		ASSERT(FALSE); // sould not happen
		return;
	}

	AFX_MANAGE_STATE(AfxGetStaticModuleState());
  FIX_THREAD_STATE_MFC_BUG();

	ASSERT(m_pCloneInfoList != NULL);
	// provide subdialog to add record, for the time being can have just 
	// dialog to enter the host name
	// create an item in the list of changes

	// TODO: first check if we can recycle some old stuff in the list

	// create new data
	CDNSRecordNodeEditInfo* pNewInfo = new CDNSRecordNodeEditInfo;
  if (!pNewInfo)
  {
    return;
  }

	pNewInfo->m_action = CDNSRecordNodeEditInfo::add;

   CDNS_NS_RecordNode* pNSRecordNode = new CDNS_NS_RecordNode;

   if (!pNSRecordNode)
   {
      delete pNewInfo;
      return;
   }

	pNewInfo->CreateFromNewRecord(pNSRecordNode);

	// NS records are ALWAYS at the node

	CDNSDomainNode* pDomainNode = GetDomainNode();
	CDNSRootData* pRootData = (CDNSRootData*)(GetHolder()->GetComponentData()->GetRootData());
	ASSERT(pRootData != NULL);

   // set name and type flag
   pNewInfo->m_pRecordNode->SetRecordName(pDomainNode->GetDisplayName(), TRUE /*bAtTheNode */);
	pNewInfo->m_pRecordNode->SetFlagsDown(TN_FLAG_DNS_RECORD_FULL_NAME, !pRootData->IsAdvancedView());

  // set TTL
	pNewInfo->m_pRecord->m_dwTtlSeconds = pDomainNode->GetDefaultTTL();

	CDNS_NS_RecordDialog dlg(this,TRUE);
	dlg.m_pNSInfo = pNewInfo;
	if (IDOK == dlg.DoModalSheet(m_hWnd) && pNewInfo->m_action == CDNSRecordNodeEditInfo::add)
	{
    //
		// add to the list view (at the end)
    //
		int nCount = m_listCtrl.GetItemCount();
		if (m_listCtrl.InsertNSRecordEntry(pNewInfo, nCount))
    {
      //
		  // create entry into the record info list
      //
		  m_pCloneInfoList->AddTail(pNewInfo);

      //
      // set selection and button state on the last inserted
      //
      m_listCtrl.SetSelection(nCount);
      EnableEditorButtons(nCount);

      //
		  // notify count change
      //
		  OnCountChange(nCount+1); // added one
    }

    //
		// set dirty flag. It was either a new record or an update of an old one
    //
		SetDirty(TRUE);
	}
	else
	{
		delete pNewInfo->m_pRecordNode;
		pNewInfo->m_pRecordNode = NULL;
		delete pNewInfo->m_pRecord;
		pNewInfo->m_pRecord = NULL;
		delete pNewInfo;
	}
}


void CDNSNameServersPropertyPage::OnEditButton()
{
	if (m_bReadOnly)
	{
		ASSERT(FALSE); // sould not happen
		return;
	}

	AFX_MANAGE_STATE(AfxGetStaticModuleState());
  FIX_THREAD_STATE_MFC_BUG();

	ASSERT(m_pCloneInfoList != NULL);
	// get the selection and bring up the dialog with the host name for editing
	int nSel = m_listCtrl.GetSelection();
	ASSERT(nSel != -1);
	if (nSel == -1)
		return; // should not happen

	CDNSRecordNodeEditInfo* pNSInfo = (CDNSRecordNodeEditInfo*)m_listCtrl.GetItemData(nSel);
	ASSERT(pNSInfo != NULL);
	CDNS_NS_RecordDialog dlg(this, FALSE);
	ASSERT(pNSInfo->m_pRecord->GetType() == DNS_TYPE_NS);
	dlg.m_pNSInfo = pNSInfo;
	if (IDOK == dlg.DoModalSheet() && dlg.m_bDirty)
	{
		if (pNSInfo->m_action == CDNSRecordNodeEditInfo::add)
		{
			// this was a new entry that was edited after creation
			// but before committing the change
			ASSERT(!pNSInfo->m_bExisting);
			// update the listview
			m_listCtrl.UpdateNSRecordEntry(nSel);
		}
		else if (pNSInfo->m_action == CDNSRecordNodeEditInfo::edit)
		{
			// this was an existing entry that was changed
			ASSERT(pNSInfo->m_bExisting);
			// update the listview
			m_listCtrl.UpdateNSRecordEntry(nSel);
		}
		else
		{
			// there were no IP addresses, so mark the item for removal
			ASSERT(pNSInfo->m_action == CDNSRecordNodeEditInfo::remove);
			OnRemoveButton();
		}

		// set dirty flag
		SetDirty(TRUE);
	}
}


void CDNSNameServersPropertyPage::OnRemoveButton()
{
	if (m_bReadOnly)
	{
		ASSERT(FALSE); // sould not happen
		return;
	}

	int nSel = m_listCtrl.GetSelection();
	if (nSel == -1)
  {
    ASSERT(FALSE);
		return; // should not happen
  }

  //
  // save focus to restore afterwards, if needed
  //
  CWnd* pWndFocusOld = CWnd::GetFocus();
  ASSERT(pWndFocusOld != NULL);

  //
	// got a selection, delete from listview
  //
	CDNSRecordNodeEditInfo* pNSInfo = (CDNSRecordNodeEditInfo*)m_listCtrl.GetItemData(nSel);
	ASSERT(pNSInfo != NULL);
	m_listCtrl.DeleteItem(nSel);

  //
	// we lost the selection, set it again
  //
	int nNewCount = m_listCtrl.GetItemCount();
	if (nNewCount == nSel)
  {
    //
    // last item in the list was deleted, move selection up
    //
		nSel--; 
  }

	if (nSel != -1)
	{
		m_listCtrl.SetSelection(nSel);
		ASSERT(m_listCtrl.GetSelection() == nSel);
	}

  //
  // if there are no items left, need to disable the Edit and Remove buttons
  //
  if (nNewCount == 0)
  {
    CButton* pRemoveButton = GetRemoveButton();

    //
    // need to shift focus before disabling buttons
    //
    CButton* pAddButton = GetAddButton();
    pAddButton->SetFocus();

    // avoid to have the OK button on the sheet to become the default button
    pRemoveButton->SendMessage(BM_SETSTYLE, BS_PUSHBUTTON, MAKELPARAM(TRUE, 0));
    pAddButton->SendMessage(BM_SETSTYLE, BS_DEFPUSHBUTTON, 
                            MAKELPARAM(/*redraw flag*/ TRUE, 0));
    
    EnableEditorButtons(nSel); // this will disable both Edit and Remove
  }

  ASSERT(CWnd::GetFocus());

  if (pNSInfo->m_action == CDNSRecordNodeEditInfo::add)
  {
     //
     // mark the item action as none since it was just added without being applied
     //
     pNSInfo->m_action = CDNSRecordNodeEditInfo::none;
  }
  else
  {
	 // mark the item as deleted in the list of changes
	 pNSInfo->m_action = CDNSRecordNodeEditInfo::remove;
  }

	// set dirty flag, removed a record 
	SetDirty(TRUE);
	// notify count change
	OnCountChange(nNewCount);
}

BOOL CDNSNameServersPropertyPage::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();

  // controls initialization
	VERIFY(m_listCtrl.SubclassDlgItem(IDC_NS_LIST, this));
	m_listCtrl.Initialize();

  // load the data
	LoadUIData();

  // set button state
  if (m_bReadOnly)
  {
    EnableButtons(FALSE);
  }
  else
  {
    // set selection to first item in the list, if there
    int nSel = (m_listCtrl.GetItemCount()>0) ? 0 : -1;
    EnableEditorButtons(nSel);
  }
  
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDNSNameServersPropertyPage::LoadUIData()
{
	m_pCloneInfoList->RemoveAllNodes();
	ReadRecordNodesList(); // read from source
	FillNsListView();
}

void CDNSNameServersPropertyPage::FillNsListView()
{
	ASSERT(m_pCloneInfoList != NULL);
	m_listCtrl.DeleteAllItems(); 

	// loop through the list of NS records and insert
	POSITION pos;
	int itemIndex = 0;
	for( pos = m_pCloneInfoList->GetHeadPosition(); pos != NULL; )
	{
		CDNSRecordNodeEditInfo* pCurrentInfo = m_pCloneInfoList->GetNext(pos);
		if (m_listCtrl.InsertNSRecordEntry(pCurrentInfo, itemIndex))
    {
      if (itemIndex == 0)
        m_listCtrl.SetSelection(0);
		  itemIndex++;
    }
	}
}

void CDNSNameServersPropertyPage::EnableEditorButtons(int nListBoxSel)
{
	if (m_bReadOnly)
		return;
	// must have item selected to remove or add
	GetRemoveButton()->EnableWindow(nListBoxSel != -1);
	GetEditButton()->EnableWindow(nListBoxSel != -1);
}

void CDNSNameServersPropertyPage::EnableButtons(BOOL bEnable)
{
	GetAddButton()->EnableWindow(bEnable);
	GetRemoveButton()->EnableWindow(bEnable);
	GetEditButton()->EnableWindow(bEnable);
}


//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// CDNSNameServersWizardPage


BEGIN_MESSAGE_MAP(CDNSNameServersWizardPage, CPropertyPageBase)
	ON_BN_CLICKED(IDC_ADD_NS_BUTTON, OnAddButton)
	ON_BN_CLICKED(IDC_REMOVE_NS_BUTTON, OnRemoveButton)
	ON_BN_CLICKED(IDC_EDIT_NS_BUTTON, OnEditButton)
   ON_NOTIFY(LVN_ITEMCHANGED, IDC_NS_LIST, OnListItemChanged)
END_MESSAGE_MAP()

CDNSNameServersWizardPage::CDNSNameServersWizardPage(UINT nIDTemplate)
				: CPropertyPageBase(nIDTemplate)
{
	InitWiz97(FALSE,IDS_SERVWIZ_ROOTHINTS_TITLE,IDS_SERVWIZ_ROOTHINTS_SUBTITLE);

  m_pDomainNode = NULL;
	m_pCloneInfoList = new CDNSRecordNodeEditInfoList;
	m_bReadOnly = FALSE;
	m_bMeaningfulTTL = TRUE;
}


CDNSNameServersWizardPage::~CDNSNameServersWizardPage()
{
	delete m_pCloneInfoList;
}

BOOL CDNSNameServersWizardPage::WriteNSRecordNodesList()
{
	ASSERT(!m_bReadOnly);
	ASSERT(m_pCloneInfoList != NULL);
	CDNSDomainNode* pDomainNode = GetDomainNode();
	return pDomainNode->UpdateNSRecordNodesInfo(m_pCloneInfoList, GetHolder()->GetComponentData());
}

BOOL CDNSNameServersWizardPage::OnWriteNSRecordNodesListError()
{
	ASSERT(!m_bReadOnly);

	BOOL bSuccess = TRUE;
	// loop for each NS record
	POSITION pos;
	for( pos = m_pCloneInfoList->GetHeadPosition(); pos != NULL; )
	{
		CDNSRecordNodeEditInfo* pCurrentInfo = m_pCloneInfoList->GetNext(pos);
		if (pCurrentInfo->m_dwErr != 0)
		{
			if (pCurrentInfo->m_dwErr == DNS_ERROR_RECORD_ALREADY_EXISTS)
			{
				// ignore if the NS record us already there
				pCurrentInfo->m_dwErr = 0;
			}
			else
			{
				bSuccess = FALSE;
				ASSERT(pCurrentInfo->m_pRecord->GetType() == DNS_TYPE_NS);
				CString szNSMsg;
				szNSMsg.Format(_T("Failure to write NS record <%s>"), 
					(((CDNS_NS_Record*)pCurrentInfo->m_pRecord))->m_szNameNode);
				DNSErrorDialog(pCurrentInfo->m_dwErr,szNSMsg);
			}
		}
		// loop for each related A record
		CDNSRecordNodeEditInfoList*	pARecordInfoList = pCurrentInfo->m_pEditInfoList;
		ASSERT(pARecordInfoList != NULL);
		POSITION posA;
		for( posA = pARecordInfoList->GetHeadPosition(); posA != NULL; )
		{
			CDNSRecordNodeEditInfo* pARecordCurrentInfo = pARecordInfoList->GetNext(posA);
			if (pARecordCurrentInfo->m_dwErr != 0)
			{
				ASSERT(pARecordCurrentInfo->m_pRecord->GetType() == DNS_TYPE_A);
        CString szTemp;
        FormatIpAddress(szTemp, (((CDNS_A_Record*)pARecordCurrentInfo->m_pRecord))->m_ipAddress);
				CString szAMsg;
				szAMsg.Format(_T("Failure to write A record <%s>, IP Address %s"), 
					(((CDNS_NS_Record*)pARecordCurrentInfo->m_pRecord))->m_szNameNode,
            (LPCWSTR)szTemp );
				DNSErrorDialog(pCurrentInfo->m_dwErr,szAMsg);
			}
		}
	}
	return bSuccess;
}


BOOL CDNSNameServersWizardPage::OnApply()
{
	if (m_bReadOnly)
		return TRUE;

	if (!IsDirty())
		return TRUE;

	DNS_STATUS err = GetHolder()->NotifyConsole(this);
	if ( (err != 0) && OnWriteNSRecordNodesListError() )
	{
		err = 0; // error was handled and it was not fatal
	}

	if (err == 0)
	{
		// refresh data from the zone/domain
		LoadUIData();
		SetDirty(FALSE);
	}
  else
  {
    ::SetLastError(err);
  }
	return (err == 0); 
}


BOOL CDNSNameServersWizardPage::OnPropertyChange(BOOL, long*)
{
	if (m_bReadOnly)
	{
		ASSERT(FALSE); // sould not happen
		return FALSE;
	}

	ASSERT(m_pCloneInfoList != NULL);
	if (m_pCloneInfoList == NULL)
		return FALSE;

	BOOL bRes = WriteNSRecordNodesList();
	if (!bRes)
		GetHolder()->SetError(static_cast<DWORD>(-1));  // something went wrong, error code will be per item
	return bRes; // update flag
}

void CDNSNameServersWizardPage::OnListItemChanged(NMHDR*, LRESULT*)
{
   EnableEditorButtons(m_listCtrl.GetSelection());
}

void CDNSNameServersWizardPage::OnAddButton()
{
	if (m_bReadOnly)
	{
		ASSERT(FALSE); // sould not happen
		return;
	}

	AFX_MANAGE_STATE(AfxGetStaticModuleState());
  FIX_THREAD_STATE_MFC_BUG();

	ASSERT(m_pCloneInfoList != NULL);
	// provide subdialog to add record, for the time being can have just 
	// dialog to enter the host name
	// create an item in the list of changes

	// TODO: first check if we can recycle some old stuff in the list

	// create new data
	CDNSRecordNodeEditInfo* pNewInfo = new CDNSRecordNodeEditInfo;
  if (!pNewInfo)
  {
    return;
  }

	pNewInfo->m_action = CDNSRecordNodeEditInfo::add;

   CDNS_NS_RecordNode* pNSRecordNode = new CDNS_NS_RecordNode;

   if (!pNSRecordNode)
   {
      delete pNewInfo;
      return;
   }

	pNewInfo->CreateFromNewRecord(pNSRecordNode);

	// NS records are ALWAYS at the node

	CDNSDomainNode* pDomainNode = GetDomainNode();
	CDNSRootData* pRootData = (CDNSRootData*)(GetHolder()->GetComponentData()->GetRootData());
	ASSERT(pRootData != NULL);

  // set name and type flag
  pNewInfo->m_pRecordNode->SetRecordName(pDomainNode->GetDisplayName(), TRUE /*bAtTheNode */);
	pNewInfo->m_pRecordNode->SetFlagsDown(TN_FLAG_DNS_RECORD_FULL_NAME, !pRootData->IsAdvancedView());

  // set TTL
	pNewInfo->m_pRecord->m_dwTtlSeconds = pDomainNode->GetDefaultTTL();

	CDNS_NS_RecordDialog dlg(this,TRUE);
	dlg.m_pNSInfo = pNewInfo;
	if (IDOK == dlg.DoModalSheet() && pNewInfo->m_action == CDNSRecordNodeEditInfo::add)
	{
    //
		// add to the list view (at the end)
    //
		int nCount = m_listCtrl.GetItemCount();
		if (m_listCtrl.InsertNSRecordEntry(pNewInfo, nCount))
    {
      //
		  // create entry into the record info list
      //
		  m_pCloneInfoList->AddTail(pNewInfo);

      //
      // set selection and button state on the last inserted
      //
      m_listCtrl.SetSelection(nCount);
      EnableEditorButtons(nCount);

      //
		  // notify count change
      //
		  OnCountChange(nCount+1); // added one
    }

    //
		// set dirty flag, it is a new record
    //
		SetDirty(TRUE);

	}
	else
	{
		delete pNewInfo->m_pRecordNode;
		pNewInfo->m_pRecordNode = NULL;
		delete pNewInfo->m_pRecord;
		pNewInfo->m_pRecord = NULL;
		delete pNewInfo;
	}
}


void CDNSNameServersWizardPage::OnEditButton()
{
	if (m_bReadOnly)
	{
		ASSERT(FALSE); // sould not happen
		return;
	}

	AFX_MANAGE_STATE(AfxGetStaticModuleState());
  FIX_THREAD_STATE_MFC_BUG();

	ASSERT(m_pCloneInfoList != NULL);
	// get the selection and bring up the dialog with the host name for editing
	int nSel = m_listCtrl.GetSelection();
	ASSERT(nSel != -1);
	if (nSel == -1)
		return; // should not happen

	CDNSRecordNodeEditInfo* pNSInfo = (CDNSRecordNodeEditInfo*)m_listCtrl.GetItemData(nSel);
	ASSERT(pNSInfo != NULL);
	CDNS_NS_RecordDialog dlg(this, FALSE);
	ASSERT(pNSInfo->m_pRecord->GetType() == DNS_TYPE_NS);
	dlg.m_pNSInfo = pNSInfo;
	if (IDOK == dlg.DoModalSheet() && dlg.m_bDirty)
	{
		if (pNSInfo->m_action == CDNSRecordNodeEditInfo::add)
		{
			// this was a new entry that was edited after creation
			// but before committing the change
			ASSERT(!pNSInfo->m_bExisting);
			// update the listview
			m_listCtrl.UpdateNSRecordEntry(nSel);
		}
		else if (pNSInfo->m_action == CDNSRecordNodeEditInfo::edit)
		{
			// this was an existing entry that was changed
			ASSERT(pNSInfo->m_bExisting);
			// update the listview
			m_listCtrl.UpdateNSRecordEntry(nSel);
		}
		else
		{
			// there were no IP addresses, so mark the item for removal
			ASSERT(pNSInfo->m_action == CDNSRecordNodeEditInfo::remove);
			OnRemoveButton();
		}

		// set dirty flag
		SetDirty(TRUE);
	}
}


void CDNSNameServersWizardPage::OnRemoveButton()
{
	if (m_bReadOnly)
	{
		ASSERT(FALSE); // sould not happen
		return;
	}

	int nSel = m_listCtrl.GetSelection();
	if (nSel == -1)
  {
    ASSERT(FALSE);
		return; // should not happen
  }

  //
  // save focus to restore afterwards, if needed
  //
  CWnd* pWndFocusOld = CWnd::GetFocus();
  ASSERT(pWndFocusOld != NULL);

  //
	// got a selection, delete from listview
  //
	CDNSRecordNodeEditInfo* pNSInfo = (CDNSRecordNodeEditInfo*)m_listCtrl.GetItemData(nSel);
	ASSERT(pNSInfo != NULL);
	m_listCtrl.DeleteItem(nSel);

  //
	// we lost the selection, set it again
  //
	int nNewCount = m_listCtrl.GetItemCount();
	if (nNewCount == nSel)
  {
    //
    // last item in the list was deleted, move selection up
    //
		nSel--; 
  }

	if (nSel != -1)
	{
		m_listCtrl.SetSelection(nSel);
		ASSERT(m_listCtrl.GetSelection() == nSel);
	}

  //
  // if there are no items left, need to disable the Edit and Remove buttons
  //
  if (nNewCount == 0)
  {
    CWnd* pCurrentFocusCtrl = CWnd::GetFocus();
    CButton* pRemoveButton = GetRemoveButton();
    CButton* pEditButton = GetEditButton();

    //
    // need to shift focus before disabling buttons
    //
    if ( (pCurrentFocusCtrl == pRemoveButton) || 
          (pCurrentFocusCtrl == pEditButton) )
    {
      CButton* pAddButton = GetAddButton();
      pAddButton->SetFocus();
      // avoid to have the OK button on the sheet to become the default button
      pAddButton->SendMessage(BM_SETSTYLE, BS_DEFPUSHBUTTON, 
                      MAKELPARAM(/*redraw flag*/ TRUE, 0));
    }
    EnableEditorButtons(nSel); // this will disable both Edit and Remove
  }

  ASSERT(CWnd::GetFocus());

  if (pNSInfo->m_action == CDNSRecordNodeEditInfo::add)
  {
     //
     // mark the item action as none since the item hasn't been added yet anyways
     //
     pNSInfo->m_action = CDNSRecordNodeEditInfo::none;
  }
  else
  {
	  // mark the item as deleted in the list of changes
	  pNSInfo->m_action = CDNSRecordNodeEditInfo::remove;
  }

	// set dirty flag, removed a record 
	SetDirty(TRUE);
	// notify count change
	OnCountChange(nNewCount);
}

BOOL CDNSNameServersWizardPage::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();

  // controls initialization
	VERIFY(m_listCtrl.SubclassDlgItem(IDC_NS_LIST, this));
	m_listCtrl.Initialize();

  // load the data
	LoadUIData();

  // set button state
  if (m_bReadOnly)
  {
    EnableButtons(FALSE);
  }
  else
  {
    // set selection to first item in the list, if there
    int nSel = (m_listCtrl.GetItemCount()>0) ? 0 : -1;
    EnableEditorButtons(nSel);
  }
  
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDNSNameServersWizardPage::LoadUIData()
{
	m_pCloneInfoList->RemoveAllNodes();
	ReadRecordNodesList(); // read from source
	FillNsListView();
}

void CDNSNameServersWizardPage::FillNsListView()
{
	ASSERT(m_pCloneInfoList != NULL);
	m_listCtrl.DeleteAllItems(); 

	// loop through the list of NS records and insert
	POSITION pos;
	int itemIndex = 0;
	for( pos = m_pCloneInfoList->GetHeadPosition(); pos != NULL; )
	{
		CDNSRecordNodeEditInfo* pCurrentInfo = m_pCloneInfoList->GetNext(pos);
		if (m_listCtrl.InsertNSRecordEntry(pCurrentInfo, itemIndex))
    {
      if (itemIndex == 0)
        m_listCtrl.SetSelection(0);
		  itemIndex++;
    }
	}
}

void CDNSNameServersWizardPage::EnableEditorButtons(int nListBoxSel)
{
	if (m_bReadOnly)
		return;
	// must have item selected to remove or add
	GetRemoveButton()->EnableWindow(nListBoxSel != -1);
	GetEditButton()->EnableWindow(nListBoxSel != -1);
}

void CDNSNameServersWizardPage::EnableButtons(BOOL bEnable)
{
	GetAddButton()->EnableWindow(bEnable);
	GetRemoveButton()->EnableWindow(bEnable);
	GetEditButton()->EnableWindow(bEnable);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\prednssn.h ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

// preDNSsn.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

//#define _DEBUG_REFCOUNT
// #define _ATL_DEBUG_QI
//#define DEBUG_ALLOCATOR 

// often, we have local variables for the express purpose of ASSERTion.
// when compiling retail, those assertions disappear, leaving our locals
// as unreferenced.

#ifndef DBG

#pragma warning (disable: 4189 4100)

#endif // DBG

#define STRICT
#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>
#define NT_INCLUDED
#undef ASSERT
#undef ASSERTMSG

// C++ RTTI
#include <typeinfo.h>
#define IS_CLASS(x,y) (typeid(x) == typeid(y))


///////////////////////////////////////////


// MFC Headers
#include <afxwin.h>
#include <afxdisp.h>
#include <afxdlgs.h>
#include <afxcmn.h>
#include <afxtempl.h> 
#include <prsht.h>  

///////////////////////////////////////////////////////////////////
// miscellanea heades
#include <winsock2.h>
#include <aclui.h>

///////////////////////////////////////////////////////////////////
// DNS headers
// DNSRPC.H: nonstandard extension used : zero-sized array in struct/union
#pragma warning( disable : 4200) // disable zero-sized array

#include <dnslib.h> // it includes dnsapi.h
#include <dnsrpc.h> // DNS RPC library

// NTDS headers - for domain and forest version
#include <ntdsapi.h>

///////////////////////////////////////////
// ASSERT's and TRACE's without debug CRT's
#if defined (DBG)
  #if !defined (_DEBUG)
    #define _USE_MTFRMWK_TRACE
    #define _USE_MTFRMWK_ASSERT
    #define _MTFRMWK_INI_FILE (L"\\system32\\dnsmgr.ini")
  #endif
#endif

#include <dbg.h> // from framework



///////////////////////////////////////////////////////////////////
// ATL Headers
#include <atlbase.h>


///////////////////////////////////////////////////////////////////
// CDNSMgrModule
class CDNSMgrModule : public CComModule
{
public:
	HRESULT WINAPI UpdateRegistryCLSID(const CLSID& clsid, BOOL bRegister);
};

#define DECLARE_REGISTRY_CLSID() \
static HRESULT WINAPI UpdateRegistry(BOOL bRegister) \
{ \
		return _Module.UpdateRegistryCLSID(GetObjectCLSID(), bRegister); \
}


extern CDNSMgrModule _Module;

#include <atlcom.h>

/*
 * Define/include the stuff we need for WTL::CImageList.  We need prototypes
 * for IsolationAwareImageList_Read and IsolationAwareImageList_Write here
 * because commctrl.h only declares them if __IStream_INTERFACE_DEFINED__
 * is defined.  __IStream_INTERFACE_DEFINED__ is defined by objidl.h, which
 * we can't include before including afx.h because it ends up including
 * windows.h, which afx.h expects to include itself.  Ugh.
 */
HIMAGELIST WINAPI IsolationAwareImageList_Read(LPSTREAM pstm);
BOOL WINAPI IsolationAwareImageList_Write(HIMAGELIST himl,LPSTREAM pstm);
#define _WTL_NO_AUTOMATIC_NAMESPACE

//#include <atlwin21.h>
#include <atlapp.h>
#include <atlwin.h>
#include <atlctrls.h>

///////////////////////////////////////////////////////////////////
// Console Headers
#include <mmc.h>


///////////////////////////////////////////////////////////////////
// workaround macro for MFC bug 
// (see NTRAID 227193 and MFC "Monte Carlo" RAID db # 1034)

#define FIX_THREAD_STATE_MFC_BUG() \
 	AFX_MODULE_THREAD_STATE* pState = AfxGetModuleThreadState(); \
  CWinThread _dummyWinThread; \
	if (pState->m_pCurrentWinThread == NULL) \
  { \
    pState->m_pCurrentWinThread = &_dummyWinThread; \
  }


//
// This determines whether or not the NDNC functionality is enabled or disabled
//
#define USE_NDNC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\maskctrl.c ===
/* Copyright (C) 1991, Microsoft Corporation, all rights reserved

    ipaddr.c - TCP/IP Address custom control

    November 9, 1992    Greg Strange
	February 11, 1997 - Marco Chierotti (extend to IPv6 and TTL for DNS snapin)
*/

#pragma hdrstop

#include <windows.h>
#include <stdlib.h>

#include "maskctrl.h"             // Global IPAddress definitions

#define BUFFER_LEN 128			// length for static buffers

#define SPACE           TEXT(' ')
#define BACK_SPACE      8

#define HEAD_ROOM       1       // space at top of control
#define LEAD_ROOM       0       // space at front of control

// All the information unique to one control is stuffed in one of these
// structures in global memory and the handle to the memory is stored in the
// Windows extra space.

typedef struct tagFIELD {
  HANDLE      hWnd;
  WNDPROC     lpfnWndProc;
  DWORD       dwLow;			// lowest allowed value for this field.
  DWORD       dwHigh;			// Highest allowed value for this field.
	UINT			nChars;			// # of chars for the field
	UINT        uiWidth;		// width of the field in pixels
} FIELD;


/* class info struct for different types of control */
typedef struct tagCLS_INFO
{
	TCHAR chFiller;			//The character that is displayed between address fields.
	LPCTSTR lpszFiller;
	UINT nNumFields;					// number of fields in the control
	void (*lpfnInit)(int, FIELD*);		// function to initialize the FIELD structs for a given field
	BOOL (*lpfnValChar)(TCHAR);			// function for field validation
	DWORD (*lpfnStringToNumber)(LPTSTR, int);	// function to change a field string into a number
	void (*lpfnNumberToString)(LPTSTR, DWORD); // function to change a number into a field string
  UINT (*lpfnMaxCharWidth)(HDC hDC); // function to get the max width of a char in edit fields
} CLS_INFO;


typedef struct tagCONTROL {
  HWND        hwndParent;
  UINT        uiMaxCharWidth;
  UINT        uiFillerWidth;
  BOOL        fEnabled;
  BOOL        fPainted;
  BOOL        bControlInFocus;        // TRUE if the control is already in focus, dont't send another focus command
  BOOL        bCancelParentNotify;    // Don't allow the edit controls to notify parent if TRUE
  BOOL        fInMessageBox;  // Set when a message box is displayed so that
                              // we don't send a EN_KILLFOCUS message when
                              // we receive the EN_KILLFOCUS message for the
                              // current field.
	FIELD*      ChildrenArr;	// array of structs with info about each field
	CLS_INFO*  pClsInfo;		// struct with info about the constrol type
	int (*lpfnAlert)(HWND, DWORD, DWORD, DWORD);
} CONTROL;


// The following macros extract and store the CONTROL structure for a control.
#define    IPADDRESS_EXTRA            sizeof(DWORD)

#define GET_CONTROL_HANDLE(hWnd)        ((HGLOBAL)(GetWindowLongPtr((hWnd), GWLP_USERDATA)))
#define SAVE_CONTROL_HANDLE(hWnd,x)     (SetWindowLongPtr((hWnd), GWLP_USERDATA, (LONG_PTR)x))


/* internal IPAddress function prototypes */

LRESULT FAR PASCAL IPv4WndFn(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam );
LRESULT FAR PASCAL IPv6WndFn(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam );
LRESULT FAR PASCAL TTLWndFn(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam );

LRESULT FAR PASCAL IPAddressFieldProc(HWND, UINT, WPARAM, LPARAM);
BOOL SwitchFields(CONTROL FAR *, LONG_PTR, LONG_PTR, UINT, UINT);
void EnterField(FIELD FAR *, UINT, UINT);
BOOL ExitField(CONTROL FAR *, LONG_PTR);
DWORD GetFieldValue(FIELD*, CLS_INFO*);


LOGFONT logfont;
BOOL g_bFontInitialized = FALSE;


void SetDefaultFont(LPCWSTR lpFontName, int nFontSize)
{
  HDC dc;
  logfont.lfWidth            = 0;
  logfont.lfEscapement       = 0;
  logfont.lfOrientation      = 0;
  logfont.lfOutPrecision     = OUT_DEFAULT_PRECIS;
  logfont.lfClipPrecision    = CLIP_DEFAULT_PRECIS;
  logfont.lfQuality          = DEFAULT_QUALITY;
  logfont.lfPitchAndFamily   = VARIABLE_PITCH | FF_SWISS;
  logfont.lfUnderline        = 0;
  logfont.lfStrikeOut        = 0;
  logfont.lfItalic           = 0;
  logfont.lfWeight           = FW_NORMAL;

  if (g_bFontInitialized)
    return; // do it only once

  dc = GetDC(NULL);
  if (dc != NULL)
  {
    logfont.lfHeight           = -(nFontSize*GetDeviceCaps(dc,LOGPIXELSY)/72);
    logfont.lfCharSet          = ANSI_CHARSET;
    lstrcpy( logfont.lfFaceName, lpFontName);

    ReleaseDC(NULL, dc);
  }
  g_bFontInitialized = TRUE;
}

/////////////////////////////////////////////////////////////////////////////
BOOL DNS_ControlsInitialize(HANDLE hInstance, LPCWSTR lpFontName, int nFontSize)
{
    return  DNS_ControlInit(hInstance, DNS_IP_V4_ADDRESS_CLASS, IPv4WndFn, lpFontName, nFontSize) &&
            DNS_ControlInit(hInstance, DNS_IP_V6_ADDRESS_CLASS, IPv6WndFn, lpFontName, nFontSize) &&
            DNS_ControlInit(hInstance, DNS_TTL_CLASS, TTLWndFn, lpFontName, nFontSize);
}

/*
    DNS_ControlInit() - DNS custom controls initialization
    call
        hInstance = application instance
    return
        TRUE on success, FALSE on failure.

    This function does all the one time initialization of custom
    controls.
*/
BOOL DNS_ControlInit(HANDLE hInstance, LPCTSTR lpszClassName, WNDPROC lpfnWndProc,
                            LPCWSTR lpFontName, int nFontSize)
{
    WNDCLASS WndClass;
    BOOL bRes;

    ZeroMemory(&WndClass, sizeof(WNDCLASS));
    /* define class attributes */
    WndClass.lpszClassName = lpszClassName;
    WndClass.hCursor =       LoadCursor(NULL,IDC_IBEAM);
    WndClass.lpszMenuName =  (LPCTSTR)NULL;
    WndClass.style =         CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS;//|CS_GLOBALCLASS;
    WndClass.lpfnWndProc =   lpfnWndProc;
    WndClass.hInstance =     hInstance;
    WndClass.hIcon =         NULL;
    WndClass.cbWndExtra =    IPADDRESS_EXTRA;
    WndClass.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);

    /* register  window class */
    bRes = RegisterClass(&WndClass);
    if (!bRes)
    {
        if (GetLastError() == ERROR_CLASS_ALREADY_EXISTS) {
            bRes = TRUE;
        }
    }

    SetDefaultFont(lpFontName, nFontSize);

    return bRes;
}


/*
    IPAddressWndFn() - Main window function for an IPAddress control.

    call
        hWnd    handle to IPAddress window
        wMsg    message number
        wParam  word parameter
        lParam  long parameter
*/

void FormatIPAddress(LPTSTR pszString, DWORD* dwValue)
{
	static TCHAR szBuf[3+1]; // 3 characters per octet + 1 for the '/0'

  int nField, nPos;
  BOOL fFinish = FALSE;

  dwValue[0] = 0; dwValue[1] = 0; dwValue[2] = 0; dwValue[3] = 0;

  if (pszString[0] == 0)
    return;

  for( nField = 0, nPos = 0; !fFinish; nPos++)
  {
    if (( pszString[nPos]<TEXT('0')) || (pszString[nPos]>TEXT('9')))
    {
      // not a number
      nField++;
      fFinish = (nField == 4);
    }
    else
    {
      dwValue[nField] *= 10;
      dwValue[nField] += (pszString[nPos]-TEXT('0'));
    }
  }
}




LRESULT FAR PASCAL IPAddressWndFnEx(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam, CLS_INFO* pClsInfo )
{
  LRESULT lResult;
  CONTROL *pControl;
  UINT i;

  lResult = TRUE;

  switch( wMsg )
  {

  // use empty string (not NULL) to set to blank
    case WM_SETTEXT:
      {
  /*
          static TCHAR szBuf[CHARS_PER_FIELD+1];
          DWORD dwValue[4];
          LPTSTR pszString = (LPTSTR)lParam;

          FormatIPAddress(pszString, &dwValue[0]);
          pControl = (CONTROL *)GET_CONTROL_HANDLE(hWnd);
          pControl->bCancelParentNotify = TRUE;

          for (i = 0; i < pClsInfo->nNumFields; ++i)
          {
              if (pszString[0] == 0)
              {
                  szBuf[0] = 0;
              }
              else
              {
                  wsprintf(szBuf, TEXT("%d"), dwValue[i]);
              }
              SendMessage(pControl->ChildrenArr[i].hWnd, WM_SETTEXT,
                              0, (LPARAM) (LPSTR) szBuf);
          }

          pControl->bCancelParentNotify = FALSE;

          SendMessage(pControl->hwndParent, WM_COMMAND,
              MAKEWPARAM(GetWindowLong(hWnd, GWL_ID), EN_CHANGE), (LPARAM)hWnd);
  */
      }
      break;

    case WM_GETTEXTLENGTH:
    case WM_GETTEXT:
      {
/*
          int iFieldValue;
          int srcPos, desPos;
          DWORD dwValue[4];
          TCHAR pszResult[30];
          TCHAR *pszDest = (TCHAR *)lParam;

          pControl = (CONTROL *)GET_CONTROL_HANDLE(hWnd);

          lResult = 0;
          dwValue[0] = 0;
          dwValue[1] = 0;
          dwValue[2] = 0;
          dwValue[3] = 0;
          for (i = 0; i < pClsInfo->nNumFields; ++i)
          {
              iFieldValue = GetFieldValue(&(pControl->ChildrenArr[i]));
              if (iFieldValue == -1)
                  iFieldValue = 0;
              else
                  ++lResult;
              dwValue[i] = iFieldValue;
          }
          wsprintf( pszResult, TEXT("%d.%d.%d.%d"), dwValue[0], dwValue[1], dwValue[2], dwValue[3] );
          if ( wMsg == WM_GETTEXTLENGTH )
          {
              lResult = lstrlen( pszResult );
          }
          else
          {
              for ( srcPos=0, desPos=0; (srcPos+1<(INT)wParam) && (pszResult[srcPos]!=TEXT('\0')); )
              {
                  pszDest[desPos++] = pszResult[srcPos++];
              }
              pszDest[desPos]=TEXT('\0');
              lResult = desPos;
          }
*/
      }
      break;

    case WM_GETDLGCODE :
      lResult = DLGC_WANTCHARS;
      break;

    case WM_NCCREATE:
      SetWindowLong(hWnd, GWL_EXSTYLE, (GetWindowLong(hWnd, GWL_EXSTYLE) | WS_EX_CLIENTEDGE));
      lResult = TRUE;
      break;

    case WM_CREATE: /* create pallette window */
      {
        HDC hdc;
        HMENU id;
        UINT uiFieldStart;

        pControl = (CONTROL*)GlobalAlloc(GMEM_FIXED, sizeof(CONTROL));

        if (pControl)
        {
          HFONT OldFont;
          RECT rect;
          LPCREATESTRUCT lpCreateStruct;

          lpCreateStruct = ((CREATESTRUCT *)lParam);

          pControl->fEnabled = TRUE;
          pControl->fPainted = FALSE;
          pControl->fInMessageBox = FALSE;
          pControl->hwndParent = lpCreateStruct->hwndParent;
          pControl->bControlInFocus = FALSE;
          pControl->bCancelParentNotify = FALSE;
          pControl->pClsInfo = pClsInfo;
          pControl->ChildrenArr = (FIELD*)GlobalAlloc(GMEM_FIXED, sizeof(FIELD)*(pClsInfo->nNumFields));
          pControl->lpfnAlert = NULL;

          if (!pControl->ChildrenArr)
          {
            GlobalFree(pControl);
            pControl = 0;

            DestroyWindow(hWnd);
            return 0;
          }

          for (i = 0; i < pClsInfo->nNumFields; ++i) {
              (*(pClsInfo->lpfnInit))(i,&(pControl->ChildrenArr[i]));
          }

          hdc = GetDC(hWnd);
          if (hdc != NULL)
          {
            GetClientRect(hWnd, &rect);

            OldFont = SelectObject(hdc, CreateFontIndirect(&logfont));
            pControl->uiMaxCharWidth = (*(pClsInfo->lpfnMaxCharWidth))(hdc);
            GetCharWidth(hdc, pClsInfo->chFiller, pClsInfo->chFiller,
                                    (int *)(&pControl->uiFillerWidth));
            DeleteObject(SelectObject(hdc, OldFont ));
            ReleaseDC(hWnd, hdc);

            uiFieldStart = LEAD_ROOM;

            id = (HMENU)GetWindowLongPtr(hWnd, GWLP_ID);
            for (i = 0; i < pClsInfo->nNumFields; ++i)
            {
              pControl->ChildrenArr[i].uiWidth =
                (pControl->ChildrenArr[i].nChars) * (pControl->uiMaxCharWidth+2);

              pControl->ChildrenArr[i].hWnd = CreateWindowEx(0,
                                  TEXT("Edit"),
                                  NULL,
                                  WS_CHILD | WS_VISIBLE,
                                  uiFieldStart,
                                  HEAD_ROOM,
                                  pControl->ChildrenArr[i].uiWidth,
                                  (rect.bottom-rect.top),
                                  hWnd,
                                  id,
                                  lpCreateStruct->hInstance,
                                  (LPVOID)NULL);

              SAVE_CONTROL_HANDLE(pControl->ChildrenArr[i].hWnd, i);
              SendMessage(pControl->ChildrenArr[i].hWnd, EM_LIMITTEXT,
                          pControl->ChildrenArr[i].nChars, 0L);

              SendMessage(pControl->ChildrenArr[i].hWnd, WM_SETFONT,
                          (WPARAM)CreateFontIndirect(&logfont), TRUE);

              // Disable IME support for the ip editor
              ImmAssociateContext(pControl->ChildrenArr[i].hWnd, NULL);

              pControl->ChildrenArr[i].lpfnWndProc =
                  (WNDPROC) GetWindowLongPtr(pControl->ChildrenArr[i].hWnd,
                                          GWLP_WNDPROC);

              SetWindowLongPtr(pControl->ChildrenArr[i].hWnd,
                            GWLP_WNDPROC, (LONG_PTR)IPAddressFieldProc);

              uiFieldStart += pControl->ChildrenArr[i].uiWidth
                                        + pControl->uiFillerWidth;
            } // for

            SAVE_CONTROL_HANDLE(hWnd, pControl);

            //
            // need to make control wider
            //
            uiFieldStart -= pControl->uiFillerWidth;
            {
              RECT r;
              POINT p1;
              POINT p2;

              GetWindowRect(hWnd, &r); // screen coords
              p1.x = r.left;
              p1.y = r.top;
              p2.x = r.right;
              p2.y = r.bottom;
              ScreenToClient(lpCreateStruct->hwndParent, &p1);
              ScreenToClient(lpCreateStruct->hwndParent, &p2);
              p2.x = p1.x + uiFieldStart + 2;
              MoveWindow(hWnd, p1.x, p1.y, p2.x-p1.x, p2.y-p1.y, FALSE);
            }
          }
        } // if
        else
        {
          DestroyWindow(hWnd);
        }
      }
      lResult = 0;
      break;

    case WM_PAINT: /* paint control window */
      {
        PAINTSTRUCT Ps;
        RECT rect;
  			RECT headRect; /* area before the first edit box */
        COLORREF TextColor;
        COLORREF cRef;
        HFONT OldFont;
        HBRUSH hbr;
  			BOOL fPaintAsEnabled;

			  pControl = (CONTROL *)GET_CONTROL_HANDLE(hWnd);
			  fPaintAsEnabled = pControl->fEnabled;
			  if (fPaintAsEnabled)
			  {
				  /* onlys some of the edit controls might be enabled */
				  for (i = 0; i < pClsInfo->nNumFields; ++i)
				  {
					  if (!IsWindowEnabled(pControl->ChildrenArr[i].hWnd))
					  {
						  fPaintAsEnabled = FALSE; /* need disabled background */
						  break;
            } // if
          } // for
        } // if

        BeginPaint(hWnd, (LPPAINTSTRUCT)&Ps);
        OldFont = SelectObject( Ps.hdc, CreateFontIndirect(&logfont));
        GetClientRect(hWnd, &rect);

        if (fPaintAsEnabled)
        {
            TextColor = GetSysColor(COLOR_WINDOWTEXT);
            cRef = GetSysColor(COLOR_WINDOW);
        }
        else
        {
            TextColor = GetSysColor(COLOR_GRAYTEXT);
            cRef = GetSysColor(COLOR_3DFACE);
        }

        SetBkColor(Ps.hdc, cRef);
		    SetTextColor(Ps.hdc, TextColor);

        hbr = CreateSolidBrush(cRef);
        if (hbr != NULL)
        {
          FillRect(Ps.hdc, &rect, hbr);
          DeleteObject(hbr);

          SetRect(&headRect, 0, HEAD_ROOM, LEAD_ROOM, (rect.bottom-rect.top));
  			  CopyRect(&rect, &headRect);

          for (i = 0; i < pClsInfo->nNumFields-1; ++i)
          {
		        rect.left += pControl->ChildrenArr[i].uiWidth;
            rect.right = rect.left + pControl->uiFillerWidth;

			      if (IsWindowEnabled(pControl->ChildrenArr[i].hWnd))
			      {
				      TextColor = GetSysColor(COLOR_WINDOWTEXT);
				      cRef = GetSysColor(COLOR_WINDOW);
			      }
			      else
			      {
				      TextColor = GetSysColor(COLOR_GRAYTEXT);
				      cRef = GetSysColor(COLOR_3DFACE);
			      }
            SetBkColor(Ps.hdc, cRef);
			      SetTextColor(Ps.hdc, TextColor);
            hbr = CreateSolidBrush(cRef);
            if (hbr != NULL)
            {
				      if (i == 0)
					      FillRect(Ps.hdc, &headRect, hbr);
				      FillRect(Ps.hdc, &rect, hbr);
				      DeleteObject(hbr);
            }
            ExtTextOut(Ps.hdc, rect.left, HEAD_ROOM, ETO_OPAQUE, &rect, pClsInfo->lpszFiller, 1, NULL);
            rect.left = rect.right;
          }
        }

        pControl->fPainted = TRUE;

        DeleteObject(SelectObject(Ps.hdc, OldFont));
        EndPaint(hWnd, &Ps);
        }
      break;

    case WM_SETFOCUS : /* get focus - display caret */
		  pControl = (CONTROL *)GET_CONTROL_HANDLE(hWnd);
		  /* set the focus on the first enabled field */
		  for (i = 0; i < pClsInfo->nNumFields; ++i)
          {
			  if (IsWindowEnabled(pControl->ChildrenArr[i].hWnd))
			  {
				  EnterField(&(pControl->ChildrenArr[i]), 0, pControl->ChildrenArr[i].nChars);
				  break;
			  }
		  }
      break;

    case WM_LBUTTONDOWN : /* left button depressed - fall through */
      SetFocus(hWnd);
      break;

    case WM_ENABLE:
      {
        pControl = (CONTROL *)GET_CONTROL_HANDLE(hWnd);
        pControl->fEnabled = (BOOL)wParam;
        for (i = 0; i < pClsInfo->nNumFields; ++i)
        {
          EnableWindow(pControl->ChildrenArr[i].hWnd, (BOOL)wParam);
        }
        if (pControl->fPainted)
          InvalidateRect(hWnd, NULL, FALSE);
      }
      break;

    case WM_DESTROY :
      pControl = (CONTROL *)GET_CONTROL_HANDLE(hWnd);

	    if (pControl == NULL)
		    break; // memory already freed (MFC DestroyWindow() call)

      // Restore all the child window procedures before we delete our memory block.
      for (i = 0; i < pClsInfo->nNumFields; ++i)
      {
          SendMessage(pControl->ChildrenArr[i].hWnd, WM_DESTROY, 0, 0);
          SetWindowLongPtr(pControl->ChildrenArr[i].hWnd, GWLP_WNDPROC,
                        (LONG_PTR)pControl->ChildrenArr[i].lpfnWndProc);
      }
	    // free memory and reset window long
	    GlobalFree(pControl->ChildrenArr);
          GlobalFree(pControl);
	    SAVE_CONTROL_HANDLE(hWnd, NULL);
      break;

    case WM_COMMAND:
      switch (HIWORD(wParam))
        {
// One of the fields lost the focus, see if it lost the focus to another field
// of if we've lost the focus altogether.  If its lost altogether, we must send
// an EN_KILLFOCUS notification on up the ladder.
        case EN_KILLFOCUS:
            {
                HWND hFocus;
                pControl = (CONTROL *)GET_CONTROL_HANDLE(hWnd);

                if (!pControl->fInMessageBox)
                {
                    hFocus = GetFocus();
                    for (i = 0; i < pClsInfo->nNumFields; ++i)
                        if (pControl->ChildrenArr[i].hWnd == hFocus)
                            break;

                    if (i >= pClsInfo->nNumFields)
                    {
                        SendMessage(pControl->hwndParent, WM_COMMAND,
                                    MAKEWPARAM(GetWindowLong(hWnd, GWL_ID),
                                    EN_KILLFOCUS), (LPARAM)hWnd);
                        pControl->bControlInFocus = FALSE;
                    }
                }
            }
            break;

        case EN_SETFOCUS:
            {
                HWND hFocus;
                pControl = (CONTROL *)GET_CONTROL_HANDLE(hWnd);

                if (!pControl->fInMessageBox)
                {
                    hFocus = (HWND)lParam;

                    for (i = 0; i < pClsInfo->nNumFields; ++i)
                        if (pControl->ChildrenArr[i].hWnd == hFocus)
                            break;

                    // send a focus message when the
                    if (i < pClsInfo->nNumFields && pControl->bControlInFocus == FALSE)
                    {
                        SendMessage(pControl->hwndParent, WM_COMMAND,
                                    MAKEWPARAM(GetWindowLong(hWnd, GWL_ID),
                                    EN_SETFOCUS), (LPARAM)hWnd);

                    pControl->bControlInFocus = TRUE; // only set the focus once
                    }
                }
            }
            break;

        case EN_CHANGE:
            pControl = (CONTROL *)GET_CONTROL_HANDLE(hWnd);
            if (pControl->bCancelParentNotify == FALSE)
            {
                    SendMessage(pControl->hwndParent, WM_COMMAND,
                    MAKEWPARAM(GetWindowLong(hWnd, GWL_ID), EN_CHANGE), (LPARAM)hWnd);

            }
            break;
        }
        break;

// Get the value of the control fields.
    case DNS_MASK_CTRL_GET:
        {
			DWORD* dwArr;
			UINT nArrSize;
            pControl = (CONTROL *)GET_CONTROL_HANDLE(hWnd);

			dwArr = (DWORD*)wParam;
			nArrSize = (UINT)lParam;
            lResult = 0;
             for (i = 0; (i < pClsInfo->nNumFields) && ( i < nArrSize); ++i)
            {
                dwArr[i] = GetFieldValue(&(pControl->ChildrenArr[i]), pClsInfo);
                if (dwArr[i] != FIELD_EMPTY)
                    ++lResult;
            }
        }
        break;

// Clear all fields to blanks.
    case DNS_MASK_CTRL_CLEAR:
        {
            pControl = (CONTROL *)GET_CONTROL_HANDLE(hWnd);
            pControl->bCancelParentNotify = TRUE;
            if (wParam == -1)
            {
              for (i = 0; i < pClsInfo->nNumFields; ++i)
              {
                SendMessage(pControl->ChildrenArr[i].hWnd, WM_SETTEXT,
                            0, (LPARAM) (LPSTR) TEXT(""));
              }
            }
            else
            {
              SendMessage(pControl->ChildrenArr[wParam].hWnd, WM_SETTEXT,
                          0, (LPARAM)(LPSTR) TEXT(""));
            }
            pControl->bCancelParentNotify = FALSE;
            SendMessage(pControl->hwndParent, WM_COMMAND,
                MAKEWPARAM(GetWindowLong(hWnd, GWL_ID), EN_CHANGE), (LPARAM)hWnd);
        }
        break;

// Set the value of the IP Address.  The address is in the lParam with the
// first address byte being the high byte, the second being the second byte,
// and so on.  A lParam value of -1 removes the address.
    case DNS_MASK_CTRL_SET:
        {
			DWORD* dwArr;
			UINT nArrSize;
            static TCHAR szBuf[BUFFER_LEN+1];

			pControl = (CONTROL *)GET_CONTROL_HANDLE(hWnd);
            pControl->bCancelParentNotify = TRUE;
			dwArr = (DWORD*)wParam;
			nArrSize = (UINT)lParam;

            for (i = 0; i < (pClsInfo->nNumFields) && ( i < nArrSize); ++i)
            {
				(*(pControl->pClsInfo->lpfnNumberToString))(szBuf,dwArr[i]);
                SendMessage(pControl->ChildrenArr[i].hWnd, WM_SETTEXT,
                                0, (LPARAM) (LPSTR) szBuf);
             }

            pControl->bCancelParentNotify = FALSE;

            SendMessage(pControl->hwndParent, WM_COMMAND,
                MAKEWPARAM(GetWindowLong(hWnd, GWL_ID), EN_CHANGE), (LPARAM)hWnd);
        }
        break;

    case DNS_MASK_CTRL_SET_LOW_RANGE:
	case DNS_MASK_CTRL_SET_HI_RANGE:
        if (wParam < pClsInfo->nNumFields)
        {
            pControl = (CONTROL *)GET_CONTROL_HANDLE(hWnd);
			if (wMsg == DNS_MASK_CTRL_SET_LOW_RANGE)
				pControl->ChildrenArr[wParam].dwLow = (DWORD)lParam;
			else
				pControl->ChildrenArr[wParam].dwHigh = (DWORD)lParam;
        }
        break;

// Set the focus to this control.
// wParam = the field number to set focus to, or -1 to set the focus to the
// first non-blank field.
    case DNS_MASK_CTRL_SETFOCUS:
        pControl = (CONTROL *)GET_CONTROL_HANDLE(hWnd);

        if (wParam >= pClsInfo->nNumFields)
        {
            for (wParam = 0; wParam < pClsInfo->nNumFields; ++wParam)
                if (GetFieldValue(&(pControl->ChildrenArr[wParam]), pControl->pClsInfo) == FIELD_EMPTY)   break;
            if (wParam >= pClsInfo->nNumFields)    wParam = 0;
        }
        EnterField(&(pControl->ChildrenArr[wParam]), 0, pControl->ChildrenArr[wParam].nChars);
        break;

// Determine whether all four subfields are blank
    case DNS_MASK_CTRL_ISBLANK:
        pControl = (CONTROL *)GET_CONTROL_HANDLE(hWnd);

        lResult = TRUE;
        for (i = 0; i < pClsInfo->nNumFields; ++i)
        {
            if (GetFieldValue(&(pControl->ChildrenArr[i]), pControl->pClsInfo) != FIELD_EMPTY)
            {
                lResult = FALSE;
                break;
            }
        }
        break;
	case DNS_MASK_CTRL_SET_ALERT:
		{
			pControl = (CONTROL *)GET_CONTROL_HANDLE(hWnd);
			pControl->lpfnAlert = (int (*)(HWND, DWORD, DWORD, DWORD))(wParam);
			lResult = TRUE;
		}
		break;
	case DNS_MASK_CTRL_ENABLE_FIELD:
		{
            pControl = (CONTROL *)GET_CONTROL_HANDLE(hWnd);
			//int nField = (int)wParam;
			if ( ((int)wParam >= 0) && ((UINT)wParam < pClsInfo->nNumFields) )
			{
				EnableWindow(pControl->ChildrenArr[(int)wParam].hWnd, (BOOL)lParam);
			}
            if (pControl->fPainted)
                InvalidateRect(hWnd, NULL, FALSE);
		}
		break;
    default:
        lResult = DefWindowProc( hWnd, wMsg, wParam, lParam );
        break;
    }
    return( lResult );
}




/*
    IPAddressFieldProc() - Edit field window procedure

    This function sub-classes each edit field.
*/
LRESULT FAR PASCAL IPAddressFieldProc(HWND hWnd,
                                      UINT wMsg,
                                      WPARAM wParam,
                                      LPARAM lParam)
{
    CONTROL *pControl;
    FIELD *pField;
    HWND hControlWindow;
    LONG_PTR nChildID;
    LRESULT lresult;

    hControlWindow = GetParent(hWnd);
    if (!hControlWindow)
        return 0;

    pControl = (CONTROL *)GET_CONTROL_HANDLE(hControlWindow);
    nChildID = (LONG_PTR)GET_CONTROL_HANDLE(hWnd);
    pField = &(pControl->ChildrenArr[nChildID]);
	

    if (pField->hWnd != hWnd)
        return 0;

    switch (wMsg)
    {
    case WM_DESTROY:
        DeleteObject((HGDIOBJ)SendMessage(hWnd, WM_GETFONT, 0, 0));
        return 0;

    case WM_CHAR:

// Typing in the last digit in a field, skips to the next field.
        //if (wParam >= TEXT('0') && wParam <= TEXT('9'))
		if ( (*(pControl->pClsInfo->lpfnValChar))((TCHAR)wParam))
        {
            DWORD dwResult;

            dwResult = (DWORD)CallWindowProc(pControl->ChildrenArr[nChildID].lpfnWndProc,
                                      hWnd, wMsg, wParam, lParam);
            dwResult = (DWORD)SendMessage(hWnd, EM_GETSEL, 0, 0L);

            if (dwResult == (DWORD)MAKELPARAM((WORD)(pField->nChars), (WORD)(pField->nChars))
                && ExitField(pControl, (UINT)nChildID)
                && nChildID < (int)pControl->pClsInfo->nNumFields-1)
            {
                EnterField(&(pControl->ChildrenArr[nChildID+1]),
                                0, pField->nChars);
            }
            return dwResult;
        }

// spaces and periods fills out the current field and then if possible,
// goes to the next field.
        else if ((TCHAR)wParam == pControl->pClsInfo->chFiller || wParam == SPACE )
        {
            DWORD dwResult;
            dwResult = (DWORD)SendMessage(hWnd, EM_GETSEL, 0, 0L);
            if (dwResult != 0L && HIWORD(dwResult) == LOWORD(dwResult)
                && ExitField(pControl, nChildID))
            {
                if (nChildID >= (int)pControl->pClsInfo->nNumFields-1)
                    MessageBeep((UINT)-1);
                else
                {
                    EnterField(&(pControl->ChildrenArr[nChildID+1]),
                                    0, pControl->ChildrenArr[nChildID+1].nChars);
                }
            }
            return 0;
        }

// Backspaces go to the previous field if at the beginning of the current field.
// Also, if the focus shifts to the previous field, the backspace must be
// processed by that field.
        else if (wParam == BACK_SPACE)
        {
            if (nChildID > 0 && SendMessage(hWnd, EM_GETSEL, 0, 0L) == 0L)
            {
                if (SwitchFields(pControl, 
                                 nChildID, 
                                 nChildID-1,
								                 pControl->ChildrenArr[nChildID-1].nChars, 
                                 pControl->ChildrenArr[nChildID-1].nChars)
                    && SendMessage(pControl->ChildrenArr[nChildID-1].hWnd,
                                   EM_LINELENGTH, 
                                   (WPARAM)0, 
                                   (LPARAM)0L) != 0L 
                    && IsWindowEnabled(pControl->ChildrenArr[nChildID-1].hWnd))
                {
                    SendMessage(pControl->ChildrenArr[nChildID-1].hWnd,
                                wMsg, wParam, lParam);
                }
                return 0;
            }
        }

// Any other printable characters are not allowed.
        else if (wParam > SPACE)
        {
            MessageBeep((UINT)-1);
            return 0;
        }
        break;

    case WM_KEYDOWN:
        switch (wParam)
        {

// Arrow keys move between fields when the end of a field is reached.
        case VK_LEFT:
        case VK_RIGHT:
        case VK_UP:
        case VK_DOWN:
            if (GetKeyState(VK_CONTROL) < 0)
            {
                if ((wParam == VK_LEFT || wParam == VK_UP) && nChildID > 0)
                {
                    SwitchFields(pControl, nChildID, nChildID-1, 0, pField->nChars);
                    return 0;
                }
                else if ((wParam == VK_RIGHT || wParam == VK_DOWN)
                         && nChildID < (int)pControl->pClsInfo->nNumFields-1)
                {
                    SwitchFields(pControl, nChildID, nChildID+1, 0, pField->nChars);
                    return 0;
                }
            }
            else
            {
                DWORD dwResult;
                WORD wStart, wEnd;

                dwResult = (DWORD)SendMessage(hWnd, EM_GETSEL, 0, 0L);
                wStart = LOWORD(dwResult);
                wEnd = HIWORD(dwResult);
                if (wStart == wEnd)
                {
                    if ((wParam == VK_LEFT || wParam == VK_UP)
                        && wStart == 0
                        && nChildID > 0)
                    {
                        SwitchFields(pControl, nChildID, nChildID-1, pField->nChars, pField->nChars);
                        return 0;
                    }
                    else if ((wParam == VK_RIGHT || wParam == VK_DOWN)
                             && nChildID < (int)pControl->pClsInfo->nNumFields-1)
                    {
                        dwResult = (DWORD)SendMessage(hWnd, EM_LINELENGTH, 0, 0L);
                        if (wStart >= dwResult)
                        {
                            SwitchFields(pControl, nChildID, nChildID+1, 0, 0);
                            return 0;
                        }
                    }
                }
            }
            break;

// Home jumps back to the beginning of the first field.
        case VK_HOME:
            if (nChildID > 0)
            {
                SwitchFields(pControl, nChildID, 0, 0, 0);
                return 0;
            }
            break;

// End scoots to the end of the last field.
        case VK_END:
            if (nChildID < (int)pControl->pClsInfo->nNumFields-1)
            {
                SwitchFields(pControl, nChildID, (pControl->pClsInfo->nNumFields)-1, pField->nChars, pField->nChars);
                return 0;
            }
            break;


        } // switch (wParam)

        break;

    case WM_KILLFOCUS:
        if ( !ExitField( pControl, nChildID ))
        {
            return 0;
        }

    } // switch (wMsg)

    lresult = CallWindowProc(pControl->ChildrenArr[nChildID].lpfnWndProc,
        hWnd, wMsg, wParam, lParam);
    return lresult;
}




/*
    Switch the focus from one field to another.
    call
        pControl = Pointer to the CONTROL structure.
        iOld = Field we're leaving.
        iNew = Field we're entering.
        hNew = Window of field to goto
        wStart = First character selected
        wEnd = Last character selected + 1
    returns
        TRUE on success, FALSE on failure.

    Only switches fields if the current field can be validated.
*/
BOOL SwitchFields(CONTROL *pControl, LONG_PTR nOld, LONG_PTR nNew, UINT nStart, UINT nEnd)
{
    if (!ExitField(pControl, nOld))    return FALSE;
    EnterField(&(pControl->ChildrenArr[nNew]), nStart, nEnd);
    return TRUE;
}



/*
    Set the focus to a specific field's window.
    call
        pField = pointer to field structure for the field.
        wStart = First character selected
        wEnd = Last character selected + 1
*/
void EnterField(FIELD *pField, UINT nStart, UINT nEnd)
{
    SetFocus(pField->hWnd);
    SendMessage(pField->hWnd, EM_SETSEL, (WPARAM)nStart, (LPARAM)nEnd);
}


/*
    Exit a field.
    call
        pControl = pointer to CONTROL structure.
        iField = field number being exited.
    returns
        TRUE if the user may exit the field.
        FALSE if he may not.
*/
BOOL ExitField(CONTROL  *pControl, LONG_PTR nField)
{
    HWND hControlWnd;
    HWND hDialog;
    WORD wLength;
    FIELD *pField;
	static TCHAR szBuf[BUFFER_LEN+1];
 	DWORD xVal;

    pField = &(pControl->ChildrenArr[nField]);

	*(WORD *)szBuf = (sizeof(szBuf)/sizeof(TCHAR)) - 1;
    wLength = (WORD)SendMessage(pField->hWnd,EM_GETLINE,0,(LPARAM)(LPSTR)szBuf);
    if (wLength != 0)
    {
        szBuf[wLength] = TEXT('\0');
		xVal = (*(pControl->pClsInfo->lpfnStringToNumber))(szBuf,(int)wLength);
         if (xVal < pField->dwLow || xVal > pField->dwHigh)
        {
            if ( xVal < pField->dwLow )
            {
                /* too small */
                wsprintf(szBuf, TEXT("%d"), pField->dwLow );
            }
            else
            {
                /* must be bigger */
                wsprintf(szBuf, TEXT("%d"), pField->dwHigh );
            }
            SendMessage(pField->hWnd, WM_SETTEXT, 0, (LPARAM) (LPSTR) szBuf);
            if ((hControlWnd = GetParent(pField->hWnd)) != NULL
                && (hDialog = GetParent(hControlWnd)) != NULL)
            {
                pControl->fInMessageBox = TRUE;
				if (pControl->lpfnAlert != NULL) // call user provided hook
				{
					(*(pControl->lpfnAlert))(hDialog, xVal, pField->dwLow, pField->dwHigh);
				}
				else
				{
					MessageBeep(MB_ICONEXCLAMATION);
				}
                pControl->fInMessageBox = FALSE;
                SendMessage(pField->hWnd, EM_SETSEL, 0, pField->nChars);
                return FALSE;
            }
        }
    }
    return TRUE;
}


/*
    Get the value stored in a field.
    call
        pField = pointer to the FIELD structure for the field.
    returns
        The value (0..255) or -1 if the field has not value.
*/
DWORD GetFieldValue(FIELD *pField, CLS_INFO* pClsInfo)
{
    WORD wLength;
	static TCHAR szBuf[BUFFER_LEN+1];

    *(WORD *)szBuf = (sizeof(szBuf)/sizeof(TCHAR)) - 1;
    wLength = (WORD)SendMessage(pField->hWnd,EM_GETLINE,0,(LPARAM)(LPSTR)szBuf);
    if (wLength != 0)
    {
		return (*(pClsInfo->lpfnStringToNumber))(szBuf,wLength);
    }
    else
        return FIELD_EMPTY;
}


////////////////////////////////////////////////////////////////////////////////////////////////

DWORD DecimalStringToNumber(LPCTSTR lpszBuf, int nLen)
{
	DWORD x;
	int j;
    for (x=0, j=0;j<nLen;j++)
    {
		x = x*10+lpszBuf[j]-TEXT('0'); // assume valid char
    }
	return x;
}

void NumberToDecimalString(LPTSTR lpszBuf, DWORD dwX)
{
	if (dwX == FIELD_EMPTY)
  {
		lpszBuf[0] = 0x0; //NULL
  }
	else
  {
		wsprintf(lpszBuf, TEXT("%d"), (UINT)dwX);
  }
}

void NumberToHexString(LPTSTR lpszBuf, DWORD dwX)
{
	wsprintf(lpszBuf, TEXT("%x"), (UINT)dwX);
}


DWORD HexStringToNumber(LPCTSTR lpszBuf, int nLen)
{
	DWORD x;
	int j;
    for (x=0, j=0;j<nLen;j++)
    {
		DWORD digit = 0;
		if (lpszBuf[j] >= TEXT('0') && lpszBuf[j] <= TEXT('9'))
			digit = lpszBuf[j]-TEXT('0');
		else if (lpszBuf[j] >= TEXT('A') && lpszBuf[j] <= TEXT('F'))
			digit = lpszBuf[j]-TEXT('A') + 10;
		else// assume 'a' to 'f'
			digit = lpszBuf[j]-TEXT('a') + 10;
		x = x*16+digit;
    }
	return x;
}



BOOL ValidateDecimalChar(TCHAR ch)
{
	// allow only digits
  WCHAR sz[2];
  BOOL b;

  sz[0]=ch;
  sz[1]=L'';
	b = (ch >= TEXT('0') && ch <= TEXT('9'));

  return b;
}

BOOL ValidateHexChar(TCHAR ch)
{
	// allow only digits
	return ( (ch >= TEXT('0') && ch <= TEXT('9')) ||
			 (ch >= TEXT('a') && ch <= TEXT('f')) ||
			 (ch >= TEXT('A') && ch <= TEXT('F')) );
}


void InitIPv4Field(int nIndex, FIELD* pField)
{
  nIndex; // Must use formal parameters for /W4
	pField->dwLow = 0;//MIN_FIELD_VALUE;
	pField->dwHigh = 255; //MAX_FIELD_VALUE;
	pField->nChars = 3; //CHARS_PER_FIELD;
}

void InitIPv6Field(int nIndex, FIELD* pField)
{
  nIndex; // Must user formal parameters for /W4
	pField->dwLow = 0; //MIN_FIELD_VALUE;
	pField->dwHigh = 0xFFFF; //MAX_FIELD_VALUE;
	pField->nChars = 4; //CHARS_PER_FIELD;
}


void InitTTLField(int nIndex, FIELD* pField)
{
	pField->dwLow = 0;
	switch (nIndex)
	{
	case 0: // days
		pField->dwHigh = 49710;
		pField->nChars = 5;
		break;
	case 1: // hours
		pField->dwHigh = 23;
		pField->nChars = 2;
		break;
	case 2: // minutes
		pField->dwHigh = 59;
		pField->nChars = 2;
		break;
	case 3: // seconds
		pField->dwHigh = 59;
		pField->nChars = 2;
		break;
	default:
		;
	}
}

UINT _MaxCharWidthHelper(HDC hDC, UINT iFirstChar, UINT iLastChar)
{
  FLOAT fFract[10] = {0};
  INT nWidth[10] = {0};
  int i;
  FLOAT maxVal;
  FLOAT curWidth;
  UINT retVal;

  retVal = 8; // good default if we fail

  if (GetCharWidthFloat(hDC, iFirstChar, iLastChar,fFract) &&
      GetCharWidth(hDC,iFirstChar, iLastChar, nWidth))
  {
    maxVal = 0.0;
    for (i=0;i<10;i++)
    {
      curWidth = fFract[i] + (FLOAT)nWidth[i];
      if (curWidth > maxVal)
        maxVal = curWidth;
    }
    if (maxVal > ((FLOAT)((UINT)maxVal)))
      retVal = (UINT) (maxVal+1);
    else
      retVal = (UINT)maxVal;
  }
  return retVal;
}



UINT MaxCharWidthDecimal(HDC hDC)
{
  return _MaxCharWidthHelper(hDC,TEXT('0'), TEXT('9'));
}

UINT MaxCharWidthHex(HDC hDC)
{
  UINT retVal;
  UINT nMax1;
  UINT nMax2;
  UINT nMax3;

  retVal = 0;
  nMax1 = _MaxCharWidthHelper(hDC,TEXT('0'), TEXT('9'));
  if (nMax1 > retVal)
    retVal = nMax1;
  nMax2 = _MaxCharWidthHelper(hDC,TEXT('a'), TEXT('f'));
  if (nMax2 > retVal)
    retVal = nMax2;
  nMax3 = _MaxCharWidthHelper(hDC,TEXT('A'), TEXT('F'));
  if (nMax3 > retVal)
    retVal = nMax3;
  return retVal;
}


/* class info structs for the various types */
CLS_INFO _IPv4ClsInfo = {	TEXT('.'),
							TEXT("."),
							4,
							InitIPv4Field,
							ValidateDecimalChar,
							DecimalStringToNumber,
							NumberToDecimalString,
              MaxCharWidthDecimal
						};

CLS_INFO _IPv6ClsInfo = {	TEXT(':'),
							TEXT(":"),
							8,
							InitIPv6Field,
							ValidateHexChar,
							HexStringToNumber,
							NumberToHexString,
              MaxCharWidthHex
						};
CLS_INFO _TTLClsInfo  = {	TEXT(':'),
							TEXT(":"),
							4,
							InitTTLField,
							ValidateDecimalChar,
							DecimalStringToNumber,
							NumberToDecimalString,
              MaxCharWidthDecimal
						};




LRESULT FAR PASCAL IPv4WndFn(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam )
{
	return IPAddressWndFnEx( hWnd, wMsg, wParam, lParam , &_IPv4ClsInfo);
}

LRESULT FAR PASCAL IPv6WndFn(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam )
{
	return IPAddressWndFnEx( hWnd, wMsg, wParam, lParam , &_IPv6ClsInfo);
}

LRESULT FAR PASCAL TTLWndFn(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam )
{
	return IPAddressWndFnEx( hWnd, wMsg, wParam, lParam , &_TTLClsInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\record.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       record.cpp
//
//--------------------------------------------------------------------------


#include "preDNSsn.h"
#include <SnapBase.h>

#include "resource.h"
#include "dnsutil.h"
#include "DNSSnap.h"
#include "snapdata.h"

#include "server.h"
#include "domain.h"
#include "record.h"
#include "zone.h"

#ifdef DEBUG_ALLOCATOR
	#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
	#endif
#endif


#define DNS_RECORD_CLASS_DEFAULT (0x1) // we support only class one records

#ifdef _USE_BLANK
#else
const WCHAR* g_szAtTheNodeInput = L"@"; // string to mark the "At the node RR"
#endif

extern COMBOBOX_TABLE_ENTRY g_Algorithms[]; 
extern COMBOBOX_TABLE_ENTRY g_Protocols[]; 

////////////////////////////////////////////////////////////////////////////
// CDNSRecord : base class for all the DNS record types

CDNSRecord::CDNSRecord()
{
	m_wType = 0x0;
	m_dwFlags = DNS_RPC_RECORD_FLAG_DEFAULT;
	m_dwTtlSeconds = 60;
  m_dwScavengeStart = 0;
}


////////////////////////////////////////////////////////////////////
//////////////// RPC SPECIFIC //////////////////////////////////////

//
// sizes of data sections for records: some of them have strings
// after the constant size part
//
#define SIZEOF_DNS_RPC_A_RECORD_DATA_HEADER			(sizeof(IP_ADDRESS))
#define SIZEOF_DNS_RPC_ATMA_RECORD_DATA_HEADER			(sizeof(UCHAR))
#define SIZEOF_DNS_RPC_AAAA_RECORD_DATA_HEADER			(sizeof(IPV6_ADDRESS))
#define SIZEOF_DNS_RPC_SOA_RECORD_DATA_HEADER		(5*sizeof(DWORD))	// then string
#define SIZEOF_DNS_RPC_MXAFSBD_RT_RECORD_DATA_HEADER	(sizeof(WORD))	// thsn string
#define SIZEOF_DNS_RPC_WKS_RECORD_DATA_HEADER		(sizeof(IP_ADDRESS)+sizeof(UCHAR))
#define SIZEOF_DNS_RPC_WINS_RECORD_DATA_HEADER		(4*sizeof(DWORD))
#define SIZEOF_DNS_RPC_NBSTAT_RECORD_DATA_HEADER		(3*sizeof(DWORD))
#define SIZEOF_DNS_RPC_SRV_RECORD_DATA_HEADER		(3*sizeof(WORD))
#define SIZEOF_DNS_RPC_SIG_RECORD_DATA_HEADER	\
	(sizeof(WORD)+2*sizeof(BYTE)+3*sizeof(DWORD)+sizeof(WORD)) // then string then blob
#define SIZEOF_DNS_RPC_KEY_RECORD_DATA_HEADER  (sizeof(WORD) + sizeof(BYTE) + sizeof(BYTE))
#define SIZEOF_DNS_RPC_NXT_RECORD_DATA_HEADER  (sizeof(WORD))

DNS_STATUS CDNSRecord::Update(LPCTSTR lpszServerName, LPCTSTR lpszZoneName, LPCTSTR lpszNodeName,
							  CDNSRecord* pDNSRecordOld, BOOL bUseDefaultTTL)
{
   USES_CONVERSION;
   WORD nBytesLen = GetRPCRecordLength();
   BYTE* pMem = (BYTE*)malloc(nBytesLen);
   if (!pMem)
   {
      return ERROR_OUTOFMEMORY;
   }

   memset(pMem, 0x0, nBytesLen);

   DNS_STATUS err = 0;
   BYTE* pMemOld = 0;
   do // false loop
   {
      DNS_RPC_RECORD* pDnsRpcRecord = NULL;
      WriteRPCData(pMem, &pDnsRpcRecord);
      ASSERT(pDnsRpcRecord != NULL);

      DNS_RPC_RECORD* pDnsRpcRecordOld = NULL;
      if (pDNSRecordOld != NULL) // doing an update of existing record
      {
         WORD nOldBytesLen = pDNSRecordOld->GetRPCRecordLength();
         pMemOld = (BYTE*)malloc(nOldBytesLen);

         if (!pMemOld)
         {
            err = ERROR_OUTOFMEMORY;
            break;
         }
         memset(pMemOld, 0x0, nOldBytesLen);

         pDNSRecordOld->WriteRPCData(pMemOld, &pDnsRpcRecordOld);
         ASSERT(pDnsRpcRecordOld != NULL);

         //
         // figure out if it is TTL only or full update
         //
         if (pDnsRpcRecordOld->wDataLength == pDnsRpcRecord->wDataLength)
         {
            //
            // mask the flags
            //
            DWORD dwFlagSave = pDnsRpcRecord->dwFlags;
            pDnsRpcRecord->dwFlags = 0;

            //
            // mask the TTL
            //
            DWORD dwTtlSave = pDnsRpcRecord->dwTtlSeconds;

            //
            // mask the StartRefreshHr
            //
            DWORD dwStartRefreshHrSave = pDnsRpcRecord->dwTimeStamp;

            pDnsRpcRecord->dwTtlSeconds = pDnsRpcRecordOld->dwTtlSeconds;

            BOOL bEqual =
               memcmp(
                  pDnsRpcRecord,
                  pDnsRpcRecordOld,
                  min(
                     pDnsRpcRecord->wDataLength + SIZEOF_DNS_RPC_RECORD_HEADER,
                     pDnsRpcRecordOld->wDataLength + SIZEOF_DNS_RPC_RECORD_HEADER)) == 0;


            //
            // restore masked fields
            //
            pDnsRpcRecord->dwTimeStamp = dwStartRefreshHrSave;
            pDnsRpcRecord->dwTtlSeconds = dwTtlSave;
            pDnsRpcRecord->dwFlags = dwFlagSave;
			  
            //
            // check if TTL only
            //
            if (bEqual && (pDnsRpcRecord->dwTtlSeconds != pDnsRpcRecordOld->dwTtlSeconds))
            {
               pDnsRpcRecord->dwFlags |= DNS_RPC_RECORD_FLAG_TTL_CHANGE;
            }
         }

      }
      if (bUseDefaultTTL)
      {
         pDnsRpcRecord->dwFlags |= DNS_RPC_RECORD_FLAG_DEFAULT_TTL;
      }

      ASSERT(pDnsRpcRecord->wType != 0);

      err = 
         ::DnssrvUpdateRecord(
            lpszServerName,
            W_TO_UTF8(lpszZoneName),
            W_TO_UTF8(lpszNodeName),
            pDnsRpcRecord, pDnsRpcRecordOld);

    //
	  // if we get DNS_ERROR_ALREADY_EXISTS and it is an existing record,
	  // we are actually OK, ignore the error code
    //
    // NTRAID#Windows Bugs-251410-2001/01/17-jeffjon
    // The DNS_ERROR_RECORD_ALREADY_EXISTS was taken out due to bug 251410.  I
    // am leaving it here in case we run into problems after removing it since
    // I don't know why it was here in the first place.
    //
	  /*if ((err == DNS_ERROR_RECORD_ALREADY_EXISTS) && (pDNSRecordOld != NULL))
    {
		  err = 0;
    }*/
  } while (false);

   if (pMem)
   {
      free(pMem);
      pMem = 0;
   }

   if (pMemOld)
   {
      free(pMemOld);
      pMemOld = 0;
   }
   return err;
}

DNS_STATUS CDNSRecord::Delete(LPCTSTR lpszServerName,
                              LPCTSTR lpszZoneName,
                              LPCTSTR lpszNodeName)
{
	USES_CONVERSION;
	WORD nBytesLen = GetRPCRecordLength();
	BYTE* pMem = (BYTE*)malloc(nBytesLen);
  if (!pMem)
  {
    return ERROR_OUTOFMEMORY;
  }
	memset(pMem, 0x0, nBytesLen);

	DNS_RPC_RECORD* pDnsRpcRecord = NULL;
	WriteRPCData(pMem, &pDnsRpcRecord);
	ASSERT(pDnsRpcRecord != NULL);

	DNS_STATUS err =  ::DnssrvUpdateRecord(lpszServerName,
                                         W_TO_UTF8(lpszZoneName),
                                         W_TO_UTF8(lpszNodeName),
					                               NULL, pDnsRpcRecord);
  if (pMem)
  {
    free(pMem);
    pMem = 0;
  }
  return err;
}


// helper function
void CDNSRecord::CopyDNSRecordData(CDNSRecord* pDest, CDNSRecord* pSource)
{
	ASSERT(pDest != NULL);
	ASSERT(pSource != NULL);

	// allocate buffer on the stack
	WORD nBytesLen = pSource->GetRPCRecordLength();
	BYTE* pMem = (BYTE*)malloc(nBytesLen);
  if (!pMem)
  {
    return;
  }
	memset(pMem, 0x0, nBytesLen);

	DNS_RPC_RECORD* pDnsRPCRecord = NULL;
	pSource->WriteRPCData(pMem, &pDnsRPCRecord); // write source to memory
	ASSERT(pDnsRPCRecord != NULL);
	pDest->ReadRPCData(pDnsRPCRecord); // read destination from memory
	// got to test if it is the same
	ASSERT(pDest->GetType() == pSource->GetType());

  if (pMem)
  {
    free(pMem);
    pMem = 0;
  }
}


void CDNSRecord::CloneValue(CDNSRecord* pClone)
{
	ASSERT(pClone != NULL);
	CopyDNSRecordData(pClone,this);
}

void CDNSRecord::SetValue(CDNSRecord* pRecord)
{
	ASSERT(pRecord != NULL);
	CopyDNSRecordData(this,pRecord);
}

void CDNSRecord::ReadRPCData(DNS_RPC_RECORD* pDnsRecord)
{
	ASSERT(pDnsRecord != NULL);
	// base class: just read common attributes

	// either we know the type, or we are an unk/null record type
	ASSERT(( m_wType == DNS_TYPE_NULL) || (m_wType == pDnsRecord->wType) );

    m_wType = pDnsRecord->wType;
    m_dwFlags = pDnsRecord->dwFlags;
    m_dwTtlSeconds = pDnsRecord->dwTtlSeconds;
    m_dwScavengeStart = pDnsRecord->dwTimeStamp;
}

void CDNSRecord::ReadDnsQueryData(DNS_RECORD* pDnsQueryRecord)
{
	ASSERT(pDnsQueryRecord != NULL);
	// base class: just read common attributes

	// either we know the type, or we are an unk/null record type
	ASSERT(( m_wType == DNS_TYPE_NULL) || (m_wType == pDnsQueryRecord->wType) );

	m_wType = pDnsQueryRecord->wType;
	m_dwFlags = 0x0; // pDnsQueryRecord->Flags.W;
	m_dwTtlSeconds = pDnsQueryRecord->dwTtl;
}

void CDNSRecord::WriteRPCData(BYTE* pMem, DNS_RPC_RECORD** ppDnsRecord)
{
	ASSERT(pMem != NULL);
	ASSERT(ppDnsRecord != NULL);
	
	*ppDnsRecord = (DNS_RPC_RECORD*)pMem;
	
	// fill in the common fields
	(*ppDnsRecord)->wType = m_wType;
	(*ppDnsRecord)->dwFlags = m_dwFlags;
	(*ppDnsRecord)->dwTtlSeconds = m_dwTtlSeconds;
  (*ppDnsRecord)->dwTimeStamp = m_dwScavengeStart;

	// fill in the length info: derived classes will ad to it
	(*ppDnsRecord)->wDataLength = 0x0;
}


WORD CDNSRecord::RPCBufferStringLen(LPCWSTR lpsz)
{
	// returns the size of a DNS_RPC_STRING written to the buffer
	USES_CONVERSION;
	LPCSTR lpszAnsi = W_TO_UTF8(lpsz);
	// do not count NULL,
	// add size of cchNameLength (UCHAR) string length
  WORD wLen = 0;
  if (lpszAnsi != NULL && lpszAnsi[0] != L'\0')
  {
	  wLen = static_cast<WORD>(UTF8_LEN(lpszAnsi) + sizeof(UCHAR));
  }
  else
  {
     wLen = sizeof(UCHAR) + sizeof(CHAR);
  }
  return wLen;
}

void CDNSRecord::ReadRPCString(CString& sz, DNS_RPC_NAME* pDnsRPCName)
{
	// the input string is not NULL terminated
	DnsUtf8ToWCStringHelper(sz, pDnsRPCName->achName, pDnsRPCName->cchNameLength);
}

WORD CDNSRecord::WriteString(DNS_RPC_NAME* pDnsRPCName, LPCTSTR lpsz)
{
	USES_CONVERSION;
	ASSERT(pDnsRPCName != NULL);
	LPCSTR lpszAnsi = W_TO_UTF8(lpsz);

  if (lpszAnsi != NULL &&
      lpszAnsi[0] != '\0')
  {
	  // IMPORTANT: string in the RPC BUFFER are NOT NULL terminated
	  pDnsRPCName->cchNameLength = (BYTE)UTF8_LEN(lpszAnsi); // don't count NULL
	  memcpy(pDnsRPCName->achName, lpszAnsi, pDnsRPCName->cchNameLength);
  }
  else
  {
    //
    // NTRAID#Windows Bugs-305034-2001/02/05-jeffjon : 
    // According to JWesth a null string should be passed with cchNameLength = 1
    // and the string a single NULL UTF8 character
    //
    pDnsRPCName->cchNameLength = 1;

    // We don't want the null terminator here so just copy the one byte.
    memcpy(pDnsRPCName->achName, "\0", 1);  
  }

	// return length of the struct
	// (add size of cchNameLength (UCHAR) string length)
	return static_cast<WORD>(pDnsRPCName->cchNameLength + 1);
}

#ifdef _DEBUG
void CDNSRecord::TestRPCStuff(DNS_RPC_RECORD* pDnsRecord)
{
  //
	// TEST ONLY!!!!
  //
	WORD nBytesLen = GetRPCRecordLength();
	BYTE* pMem = (BYTE*)malloc(nBytesLen);
  if (!pMem)
  {
    return;
  }
	memset(pMem, 0x0, nBytesLen);

	DNS_RPC_RECORD* pDnsRecordTest = NULL;
	WriteRPCData(pMem, &pDnsRecordTest);
	ASSERT(pDnsRecordTest != NULL);

  //
	// got to test if it is the same
  //
	ASSERT(pDnsRecord->wDataLength == pDnsRecordTest->wDataLength);
	ASSERT(memcmp(pDnsRecord, pDnsRecordTest,
		SIZEOF_DNS_RPC_RECORD_HEADER + pDnsRecordTest->wDataLength) == 0);

  if (pMem)
  {
    free(pMem);
    pMem = 0;
  }
}
#endif


////////////////////////////////////////////////////////////////////////////
// CDNSRecordNodeBase

// {720132BB-44B2-11d1-B92F-00A0C9A06D2D}
const GUID CDNSRecordNodeBase::NodeTypeGUID =
{ 0x720132bb, 0x44b2, 0x11d1, { 0xb9, 0x2f, 0x0, 0xa0, 0xc9, 0xa0, 0x6d, 0x2d } };


CDNSRecordNodeBase::~CDNSRecordNodeBase()
{
	if (m_pDNSRecord != NULL)
	{
		delete m_pDNSRecord;
		m_pDNSRecord = NULL;
	}
}

void CDNSRecordNodeBase::SetViewOptions(DWORD dwRecordViewOptions)
{
	// we do not own the upper WORD of the flags
	dwRecordViewOptions &= 0x0000ffff; // clear high WORD to be sure
	m_dwNodeFlags &= 0xffff0000; // clear all the flags
	m_dwNodeFlags |= dwRecordViewOptions;
}

HRESULT CDNSRecordNodeBase::OnSetToolbarVerbState(IToolbar* pToolbar, 
                                              CNodeList*)
{
  //
  // Set the button state for each button on the toolbar
  //
  VERIFY(SUCCEEDED(pToolbar->SetButtonState(toolbarNewServer, ENABLED, FALSE)));
  VERIFY(SUCCEEDED(pToolbar->SetButtonState(toolbarNewZone, ENABLED, FALSE)));
  VERIFY(SUCCEEDED(pToolbar->SetButtonState(toolbarNewRecord, ENABLED, FALSE)));
  return S_OK;
}   

BOOL CDNSRecordNodeBase::OnAddMenuItem(LPCONTEXTMENUITEM2,
									                     long*)
{
	ASSERT(FALSE); // never called
	return FALSE;
}

BOOL CDNSRecordNodeBase::OnSetDeleteVerbState(DATA_OBJECT_TYPES, 
                                              BOOL* pbHide,
                                              CNodeList* pNodeList)
{
  if (pNodeList->GetCount() > 1) // multiple selection
  {
    *pbHide = TRUE;
    return FALSE;
  }

	*pbHide = FALSE;
	CDNSZoneNode* pZoneNode = GetDomainNode()->GetZoneNode();
	if (pZoneNode->IsAutocreated() || 
      (pZoneNode->GetZoneType() == DNS_ZONE_TYPE_SECONDARY) ||
      (pZoneNode->GetZoneType() == DNS_ZONE_TYPE_STUB))
  {
		return FALSE;
  }

	if (!CanDelete())
  {
		return FALSE;
  }

	WORD wType = GetType();
	if ((wType == DNS_TYPE_WINS)    || 
      (wType == DNS_TYPE_NBSTAT)  ||
		  (wType == DNS_TYPE_NS)      || 
      (wType == DNS_TYPE_SOA))
  {
		return FALSE;
  }

	return TRUE;
}

HRESULT CDNSRecordNodeBase::OnCommand(long, 
                                      DATA_OBJECT_TYPES,
								                      CComponentDataObject*,
                                      CNodeList*)
{
	ASSERT(FALSE); // never called!!!
	return E_FAIL;
}


LPCWSTR CDNSRecordNodeBase::GetString(int nCol)
{
	switch (nCol)
	{
	case 0:
    return GetDisplayName();
	case 1:
		{
			return CDNSRecordInfo::GetTypeString(m_pDNSRecord->GetType(), CDNSRecordInfo::fullName);
		}
	case 2:
		return (LPCWSTR)m_szDisplayData;
	}
	return g_lpszNullString;
}


int CDNSRecordNodeBase::GetImageIndex(BOOL)
{
	return RECORD_IMAGE_BASE;
}

void CDNSRecordNodeBase::SetRecordName(LPCTSTR lpszName, BOOL bAtTheNode)
{
	m_bAtTheNode = bAtTheNode;
  m_szDisplayName = m_bAtTheNode ? CDNSRecordInfo::GetAtTheNodeDisplayString() : lpszName;
}

BOOL CDNSRecordNodeBase::ZoneIsCache()
{
   CDNSDomainNode* pDomainNode = GetDomainNode();
   return (pDomainNode->GetZoneNode()->GetZoneType() == DNS_ZONE_TYPE_CACHE);
}

void CDNSRecordNodeBase::GetFullName(CString& szFullName)
{
	CDNSDomainNode* pDomainNode = GetDomainNode();
	ASSERT(pDomainNode != NULL);
	if (IsAtTheNode())
	{
		szFullName = pDomainNode->GetFullName();
	}
	else
	{
		CString szTrueName = GetTrueRecordName();
		ASSERT(szTrueName.GetLength() > 0);
		LPCWSTR lpszDomainName = pDomainNode->GetFullName();
		if ((lpszDomainName == NULL) || (lpszDomainName[0] == NULL))
		{
			// domain with no name, use the RR display name as FQDN
			// this should be only with a temporary (fake) domain
			ASSERT(szTrueName[szTrueName.GetLength()-1] == TEXT('.'));
			szFullName = szTrueName;
		}
		else if ((lpszDomainName[0] == TEXT('.')) && (lpszDomainName[1] == NULL))
		{
			// the "." domain could be the Root or Root Hints
			if ( IS_CLASS(*pDomainNode, CDNSRootHintsNode) &&
					(szTrueName[szTrueName.GetLength()-1] == TEXT('.')) )
			{
				// special case A records in Root Hints, they might
				// have "." at the end, e.g. "A.ROOT-SERVERS.NET."
				szFullName = szTrueName;
			}
			else
			{
				// no need for dot in the format string
				// e.g. "myhost" and "." gives "myhost."
				szFullName.Format(_T("%s%s"), (LPCWSTR)szTrueName,
						lpszDomainName);
			}
		}
		else
		{
			// standard case, e.g. "myhost" and "banana.com."
			// to get "myhost.banana.com."
			szFullName.Format(_T("%s.%s"), (LPCWSTR)szTrueName,
					lpszDomainName);
		}
	}
	TRACE(_T("\nCDNSRecordNodeBase::GetFullName(%s)\n"), (LPCTSTR)szFullName);
}

void CDNSRecordNodeBase::CreateFromRPCRecord(DNS_RPC_RECORD* pDnsRecord)
{
	ASSERT(m_pDNSRecord == NULL);
	m_pDNSRecord = CreateRecord();
   if (m_pDNSRecord)
   {
	   m_pDNSRecord->ReadRPCData(pDnsRecord);
	   m_pDNSRecord->UpdateDisplayData(m_szDisplayData);

#ifdef _DEBUG
      //
      // TEST ONLY!!!!
      //
	   m_pDNSRecord->TestRPCStuff(pDnsRecord); 
#endif
   }
}

void CDNSRecordNodeBase::CreateFromDnsQueryRecord(DNS_RECORD* pDnsQueryRecord, DWORD dwFlags)
{
	ASSERT(m_pDNSRecord == NULL);
	m_pDNSRecord = CreateRecord();

   if (m_pDNSRecord)
   {
	   m_pDNSRecord->ReadDnsQueryData(pDnsQueryRecord);
	   m_pDNSRecord->UpdateDisplayData(m_szDisplayData);
	   m_pDNSRecord->m_dwFlags = dwFlags;
   }
}


CDNSRecord* CDNSRecordNodeBase::CreateCloneRecord()
{
	ASSERT(m_pDNSRecord != NULL);
	CDNSRecord* pClone = CreateRecord();
   
   if (pClone)
   {
	   m_pDNSRecord->CloneValue(pClone);
   }

	return pClone;
}

BOOL CDNSRecordNodeBase::CanCloseSheets()
{
	return (IDCANCEL != DNSMessageBox(IDS_MSG_RECORD_CLOSE_SHEET, MB_OKCANCEL));
}

void CDNSRecordNodeBase::OnDelete(CComponentDataObject* pComponentData,
                                  CNodeList* pNodeList)
{
  if (pNodeList->GetCount() > 1) // multiple selection
  {
    return;
  }

  UINT nRet = DNSConfirmOperation(IDS_MSG_RECORD_DELETE, this);
	if (IDCANCEL == nRet ||
      IDNO == nRet)
  {
		return;
  }

	if (IsSheetLocked())
	{
		if (!CanCloseSheets())
			return;
		pComponentData->GetPropertyPageHolderTable()->DeleteSheetsOfNode(this);
	}
	ASSERT(!IsSheetLocked());

	// try first to delete the record in the server

	DNS_STATUS err = DeleteOnServerAndUI(pComponentData);
	if (err != 0)
	{
		DNSErrorDialog(err, IDS_MSG_RECORD_FAIL_DELETE);
		return;
	}
	delete this; // gone
}

DNS_STATUS CDNSRecordNodeBase::DeleteOnServer()
{
	ASSERT(m_pDNSRecord != NULL);
	CDNSDomainNode* pDomainNode = GetDomainNode();
	ASSERT(pDomainNode != NULL);
	CDNSServerNode* pServerNode = pDomainNode->GetServerNode();
	ASSERT(pServerNode != NULL);
	CString szFullName;
	GetFullName(szFullName);

  LPCTSTR lpszZoneNode = NULL;
  CDNSZoneNode* pZoneNode = pDomainNode->GetZoneNode();
  if (pZoneNode != NULL)
  {
    if (pZoneNode->GetZoneType() != DNS_ZONE_TYPE_CACHE)
    {
      lpszZoneNode = pZoneNode->GetFullName();
      if ((lpszZoneNode != NULL) && (lpszZoneNode[0] == NULL))
        lpszZoneNode = NULL;
    }
  }
	return m_pDNSRecord->Delete(pServerNode->GetRPCName(), lpszZoneNode, szFullName);
}


DNS_STATUS CDNSRecordNodeBase::DeleteOnServerAndUI(CComponentDataObject* pComponentData)
{
	ASSERT(pComponentData != NULL);

	DNS_STATUS err = DeleteOnServer();
	if (err == 0)
		DeleteHelper(pComponentData); // delete in the UI and list of children
	return err;
}

BOOL CDNSRecordNodeBase::HasPropertyPages(DATA_OBJECT_TYPES, 
                                          BOOL* pbHideVerb,
                                          CNodeList* pNodeList)
{
  if (pNodeList->GetCount() > 1) // multiple selection
  {
    *pbHideVerb = TRUE;
    return FALSE;
  }

	*pbHideVerb = FALSE; // always show the verb
	return !GetDomainNode()->GetZoneNode()->IsAutocreated();
}

HRESULT CDNSRecordNodeBase::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, 
                                                LONG_PTR handle,
                                                CNodeList* pNodeList)
{
  ASSERT(pNodeList->GetCount() == 1); // multi-select not supported

	CComponentDataObject* pComponentDataObject = ((CRootData*)(GetContainer()->GetRootContainer()))->GetComponentDataObject();
	ASSERT(pComponentDataObject != NULL);

   HRESULT hr = S_OK;

	CDNSRecordPropertyPageHolder* pHolder = new CDNSRecordPropertyPageHolder((CDNSDomainNode*)GetContainer(), this, pComponentDataObject);
	
   if (pHolder)
   {
      if (IsAtTheNode())
      {
         pHolder->SetSheetTitle(IDS_PROP_SHEET_TITLE_FMT, GetContainer());
      }
      else
      {
         pHolder->SetSheetTitle(IDS_PROP_SHEET_TITLE_FMT, this);
      }
      hr = pHolder->CreateModelessSheet(lpProvider, handle);
   }
   else
   {
      hr = E_OUTOFMEMORY;
   }
   return hr;
}


DNS_STATUS CDNSRecordNodeBase::Update(CDNSRecord* pDNSRecordNew, BOOL bUseDefaultTTL,
									  BOOL bIgnoreAlreadyExists)
{
	// get a new record, write to server, if successful copy it and substitute it in place of the old
	
	// passing pDNSRecordNew == NULL meand we are creating a new record
	BOOL bNew = (pDNSRecordNew == NULL);
	if (bNew)
	{	
		pDNSRecordNew = m_pDNSRecord;
		m_pDNSRecord = NULL;
	}
	ASSERT(pDNSRecordNew != NULL);

	// try to write new record to the server, passing the old as comparison
  CDNSDomainNode* pDomainNode = GetDomainNode();
	CString szFullName;
	LPCTSTR lpszServerName = pDomainNode->GetServerNode()->GetRPCName();
	LPCTSTR lpszRecordName;

	if (IsAtTheNode())
	{
		lpszRecordName = pDomainNode->GetFullName(); // e.g. "myzone.com"
	}
	else
	{
		GetFullName(szFullName);
		lpszRecordName = szFullName; // e.g. "myrec.myzone.com"
	}

  LPCTSTR lpszZoneNode = NULL;
  CDNSZoneNode* pZoneNode = pDomainNode->GetZoneNode();
  if (pZoneNode != NULL)
  {
    if (pZoneNode->GetZoneType() != DNS_ZONE_TYPE_CACHE)
    {
      lpszZoneNode = pZoneNode->GetFullName();
      if ((lpszZoneNode != NULL) && (lpszZoneNode[0] == NULL))
        lpszZoneNode = NULL;
    }
  }

	DNS_STATUS err = pDNSRecordNew->Update(lpszServerName, lpszZoneNode, lpszRecordName,
											m_pDNSRecord, bUseDefaultTTL);
	if (bIgnoreAlreadyExists && (err == DNS_ERROR_RECORD_ALREADY_EXISTS) )
		err = 0; // tried to write, but it was already there, so it is fine.

	if (err != 0 && err != DNS_WARNING_PTR_CREATE_FAILED)
		return err; // failed, no update to the record

	if (bNew)
	{
		// put back the existing DNSRecord, no need to create a new one
		ASSERT(pDNSRecordNew != NULL);
		m_pDNSRecord = pDNSRecordNew;
	}

	// update the record with the new one
	if (m_pDNSRecord == NULL) // we are creating a new record
	{
		m_pDNSRecord = CreateRecord();
	}

   if (m_pDNSRecord)
   {
	   m_pDNSRecord->SetValue(pDNSRecordNew);

      //Update the scavenging time on both the temporary and the node's CDNSRecord
      SetScavengingTime(m_pDNSRecord);
      SetScavengingTime(pDNSRecordNew);

	   m_pDNSRecord->UpdateDisplayData(m_szDisplayData);
   }
   else
   {
      err = ERROR_OUTOFMEMORY;
   }

	return err;
}

void CDNSRecordNodeBase::SetScavengingTime(CDNSRecord* pRecord)
{
  if (pRecord->m_dwFlags & DNS_RPC_RECORD_FLAG_AGING_ON)
  {
    pRecord->m_dwScavengeStart = CalculateScavengingTime();
  }
  else
  {
    pRecord->m_dwScavengeStart = 0;
  }
}

DWORD CDNSRecordNodeBase::CalculateScavengingTime()
{
  CDNSZoneNode* pZoneNode = GetDomainNode()->GetZoneNode();
  ASSERT(pZoneNode != NULL);

  if (pZoneNode == NULL)
    return 0;

  SYSTEMTIME currentSysTime;
  ::GetSystemTime(&currentSysTime);
  LONGLONG llResult = GetSystemTime64(&currentSysTime);
  return static_cast<DWORD>(llResult / 3600L);

}

void CDNSRecordNodeBase::CreateDsRecordLdapPath(CString& sz)
{
  CDNSDomainNode* pDomainNode = GetDomainNode();
  CDNSZoneNode* pZoneNode = pDomainNode->GetZoneNode();
  CDNSServerNode* pServerNode = pZoneNode->GetServerNode();
  pServerNode->CreateDsZoneName(pZoneNode, sz);
  if (sz.IsEmpty())
    return; // no LDAP path at all

  CString szTmp;
  // need to figure out the additional "DC = <>" part
  if (pDomainNode->IsZone() && IsAtTheNode())
  {
    szTmp = L"DC=@,";
  }
  else
  {
    CString szRecordFullName;
	  if (IsAtTheNode())
	  {
		  szRecordFullName = GetDomainNode()->GetFullName(); // e.g. "mydom.myzone.com"
	  }
	  else
	  {
		  GetFullName(szRecordFullName); // e.g. "myrec.mydom.myzone.com"
	  }
    LPCTSTR lpszZoneName = pZoneNode->GetFullName();
    // remove zone part (e.g. "myzone.com") from record name,
    // to get e.g. "mydom" or "myrec.mydom"
    int nZoneLen = static_cast<int>(wcslen(lpszZoneName));
    int nRecordLen = szRecordFullName.GetLength();
    ASSERT(nRecordLen > nZoneLen);
    szTmp.Format(_T("DC=%s,"),(LPCTSTR)szRecordFullName.Left(nRecordLen-nZoneLen-1));
  }
  szTmp += sz;
  pServerNode->CreateLdapPathFromX500Name(szTmp, sz);
}


///////////////////////////////////////////////////////////////////
// CDNS_Null_Record

CDNS_Null_Record::CDNS_Null_Record()
{
	m_wType = DNS_TYPE_NULL;
}

WORD CDNS_Null_Record::GetRPCDataLength()
{
	return (WORD)m_blob.GetSize();
}

void CDNS_Null_Record::ReadRPCData(DNS_RPC_RECORD* pDnsRecord)
{
	CDNSRecord::ReadRPCData(pDnsRecord);
	m_blob.Set(pDnsRecord->Data.Null.bData , pDnsRecord->wDataLength);
}

void CDNS_Null_Record::ReadDnsQueryData(DNS_RECORD* pDnsQueryRecord)
{
	CDNSRecord::ReadDnsQueryData(pDnsQueryRecord);
	ASSERT(FALSE); // TODO
}

void CDNS_Null_Record::WriteRPCData(BYTE* pMem, DNS_RPC_RECORD** ppDnsRecord)
{
	CDNSRecord::WriteRPCData(pMem, ppDnsRecord);
	UINT nBytes = m_blob.GetSize();

	memcpy((*ppDnsRecord)->Data.Null.bData, m_blob.GetData(), sizeof(BYTE)*nBytes);

	(*ppDnsRecord)->wDataLength = static_cast<WORD>((((*ppDnsRecord)->wDataLength) + nBytes) & 0xffff);
}

void CDNS_Null_Record::UpdateDisplayData(CString& szDisplayData)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
	szDisplayData.LoadString(IDS_RECORD_DATA_UNK);
}



///////////////////////////////////////////////////////////////////
// CDNS_A_Record

CDNS_A_Record::CDNS_A_Record()
{
	m_wType = DNS_TYPE_A;
	m_ipAddress = 0x0;
}

WORD CDNS_A_Record::GetRPCDataLength()
{
	return (WORD)SIZEOF_DNS_RPC_A_RECORD_DATA_HEADER;
}

void CDNS_A_Record::ReadRPCData(DNS_RPC_RECORD* pDnsRecord)
{
	CDNSRecord::ReadRPCData(pDnsRecord);
	ASSERT(pDnsRecord->wType == DNS_TYPE_A);
	ASSERT(pDnsRecord->wDataLength == SIZEOF_DNS_RPC_A_RECORD_DATA_HEADER);
	m_ipAddress = pDnsRecord->Data.A.ipAddress;
}

void CDNS_A_Record::ReadDnsQueryData(DNS_RECORD* pDnsQueryRecord)
{
	CDNSRecord::ReadDnsQueryData(pDnsQueryRecord);
	ASSERT(pDnsQueryRecord->wType == DNS_TYPE_A);
	m_ipAddress = pDnsQueryRecord->Data.A.IpAddress;
}

void CDNS_A_Record::WriteRPCData(BYTE* pMem, DNS_RPC_RECORD** ppDnsRecord)
{
	CDNSRecord::WriteRPCData(pMem, ppDnsRecord);
	(*ppDnsRecord)->Data.A.ipAddress = m_ipAddress;

	(*ppDnsRecord)->wDataLength += SIZEOF_DNS_RPC_A_RECORD_DATA_HEADER;
}


void CDNS_A_Record::UpdateDisplayData(CString& szDisplayData)
{
	szDisplayData.Format(g_szIpStringFmt, IP_STRING_FMT_ARGS(m_ipAddress));
}

///////////////////////////////////////////////////////////////////
// CDNS_ATMA_Record

void _ATMA_BCD_ToString(CString& s, BYTE* pBuf)
{
  const int nHexChars = 2*DNS_ATMA_MAX_ADDR_LENGTH+1;
  LPWSTR lpszBuf = s.GetBuffer(nHexChars);
  ZeroMemory(lpszBuf, nHexChars*sizeof(WCHAR));

  for (int i=0; i<DNS_ATMA_MAX_ADDR_LENGTH; i++)
  {
		BYTE high = static_cast<BYTE>(*(pBuf+i) >> 4);
		BYTE low = static_cast<BYTE>(*(pBuf+i) & 0x0f);

		// just offset out of the ASCII table
		*(lpszBuf+2*i) =  static_cast<WCHAR>((high <= 9) ? (high + TEXT('0')) : ( high - 10 + TEXT('a')));
		*(lpszBuf+2*i+1) = static_cast<WCHAR>((low <= 9) ? (low + TEXT('0')) : ( low - 10 + TEXT('a')));
  }
  s.ReleaseBuffer();
}


BOOL _ATMA_StringTo_BCD(BYTE* pBuf, LPCWSTR lpsz)
{
  // verify the string is the right length
  size_t nLen = wcslen(lpsz);
  if (nLen != 2*DNS_ATMA_MAX_ADDR_LENGTH)
    return FALSE;

  ZeroMemory(pBuf, DNS_ATMA_MAX_ADDR_LENGTH);

  for (int i=0; i<DNS_ATMA_MAX_ADDR_LENGTH; i++)
  {
    BYTE high = HexCharToByte(lpsz[2*i]);
    if (high == 0xFF)
      return FALSE;
    BYTE low = HexCharToByte(lpsz[2*i+1]);
    if (low == 0xFF)
      return FALSE;
    pBuf[i] = static_cast<BYTE>((high << 4) | (low & 0x0f));
  }
  return TRUE;
}


CDNS_ATMA_Record::CDNS_ATMA_Record()
{
	m_wType = DNS_TYPE_ATMA;
	m_chFormat = DNS_ATMA_FORMAT_E164;
}

WORD CDNS_ATMA_Record::GetRPCDataLength()
{
  DWORD dwLen = SIZEOF_DNS_RPC_ATMA_RECORD_DATA_HEADER;
  ASSERT((m_chFormat == DNS_ATMA_FORMAT_E164) || (m_chFormat == DNS_ATMA_FORMAT_AESA));
  if (m_chFormat == DNS_ATMA_FORMAT_E164)
  {
    USES_CONVERSION;
    // it is a null terminated string
    dwLen += UTF8_LEN(W_TO_UTF8(m_szAddress)); // do not count NULL at the end
  }
  else
  {
    // it is BCD encoding of DNS_ATMA_MAX_ADDR_LENGTH
    dwLen += DNS_ATMA_MAX_ADDR_LENGTH;
  }
  return static_cast<WORD>(dwLen);
}

void CDNS_ATMA_Record::ReadRPCData(DNS_RPC_RECORD* pDnsRecord)
{
	CDNSRecord::ReadRPCData(pDnsRecord);
	ASSERT(pDnsRecord->wType == DNS_TYPE_ATMA);

  m_chFormat = pDnsRecord->Data.ATMA.chFormat;
  ASSERT((m_chFormat == DNS_ATMA_FORMAT_E164) || (m_chFormat == DNS_ATMA_FORMAT_AESA));
  if (m_chFormat == DNS_ATMA_FORMAT_E164)
  {
    // non NULL terminated string
    int nBytes = pDnsRecord->wDataLength - SIZEOF_DNS_RPC_ATMA_RECORD_DATA_HEADER;
  	DnsUtf8ToWCStringHelper(m_szAddress, (LPSTR)pDnsRecord->Data.ATMA.bAddress, nBytes);
  }
  else
  {
    // it is BCD encoding of DNS_ATMA_MAX_ADDR_LENGTH
    ASSERT(pDnsRecord->wDataLength == (SIZEOF_DNS_RPC_ATMA_RECORD_DATA_HEADER+DNS_ATMA_MAX_ADDR_LENGTH));
    _ATMA_BCD_ToString(m_szAddress, pDnsRecord->Data.ATMA.bAddress);
  }
}

void CDNS_ATMA_Record::ReadDnsQueryData(DNS_RECORD* pDnsQueryRecord)
{
	CDNSRecord::ReadDnsQueryData(pDnsQueryRecord);
	ASSERT(pDnsQueryRecord->wType == DNS_TYPE_ATMA);
	ASSERT(FALSE); // TODO
}

void CDNS_ATMA_Record::WriteRPCData(BYTE* pMem, DNS_RPC_RECORD** ppDnsRecord)
{
	CDNSRecord::WriteRPCData(pMem, ppDnsRecord);
	(*ppDnsRecord)->Data.ATMA.chFormat = m_chFormat;

	(*ppDnsRecord)->wDataLength += SIZEOF_DNS_RPC_ATMA_RECORD_DATA_HEADER;

  ASSERT((m_chFormat == DNS_ATMA_FORMAT_E164) || (m_chFormat == DNS_ATMA_FORMAT_AESA));
  if (m_chFormat == DNS_ATMA_FORMAT_E164)
  {
    // it is a non null terminated string
  	USES_CONVERSION;
  	LPCSTR lpszAnsi = W_TO_UTF8(m_szAddress);

    if (lpszAnsi != NULL)
    {
      DWORD nAnsiLen = UTF8_LEN(lpszAnsi);
      if (nAnsiLen > DNS_ATMA_MAX_ADDR_LENGTH)
        nAnsiLen = DNS_ATMA_MAX_ADDR_LENGTH;

      UCHAR* pU = ((*ppDnsRecord)->Data.ATMA.bAddress);
      memcpy(pU, lpszAnsi, nAnsiLen);

      (*ppDnsRecord)->wDataLength = static_cast<WORD>(((*ppDnsRecord)->wDataLength + nAnsiLen) & 0xffff);
    }
  }
  else
  {
    // it is BCD encoding of DNS_ATMA_MAX_ADDR_LENGTH
    VERIFY(_ATMA_StringTo_BCD((*ppDnsRecord)->Data.ATMA.bAddress, m_szAddress));
    (*ppDnsRecord)->wDataLength += DNS_ATMA_MAX_ADDR_LENGTH;
  }
}


void CDNS_ATMA_Record::UpdateDisplayData(CString& szDisplayData)
{
  ASSERT((m_chFormat == DNS_ATMA_FORMAT_E164) || (m_chFormat == DNS_ATMA_FORMAT_AESA));
  if (m_chFormat == DNS_ATMA_FORMAT_E164)
  {
    szDisplayData.Format(L"(E164) %s", (LPCWSTR)m_szAddress);
  }
  else
  {
    szDisplayData.Format(L"(NSAP) %s", (LPCWSTR)m_szAddress);
  }
}



///////////////////////////////////////////////////////////////////
// CDNS_SOA_Record

CDNS_SOA_Record::CDNS_SOA_Record()
{
	m_wType = DNS_TYPE_SOA;

	m_dwSerialNo = 0x0;
	m_dwRefresh = 0x0;
	m_dwRetry = 0x0;
	m_dwExpire = 0x0;
	m_dwMinimumTtl = 0x0;
}

WORD CDNS_SOA_Record::GetRPCDataLength()
{
	return static_cast<WORD>(SIZEOF_DNS_RPC_SOA_RECORD_DATA_HEADER +
		RPCBufferStringLen(m_szNamePrimaryServer) +
		RPCBufferStringLen(m_szResponsibleParty));
}

void CDNS_SOA_Record::ReadRPCData(DNS_RPC_RECORD* pDnsRecord)
{

	CDNSRecord::ReadRPCData(pDnsRecord);
	ASSERT(pDnsRecord->wType == DNS_TYPE_SOA);
	ASSERT(pDnsRecord->wDataLength >= (SIZEOF_DNS_RPC_SOA_RECORD_DATA_HEADER +4));

	// read header data
	m_dwSerialNo = pDnsRecord->Data.SOA.dwSerialNo;
	m_dwRefresh = pDnsRecord->Data.SOA.dwRefresh;
	m_dwRetry = pDnsRecord->Data.SOA.dwRetry;
	m_dwExpire = pDnsRecord->Data.SOA.dwExpire;
	m_dwMinimumTtl = pDnsRecord->Data.SOA.dwMinimumTtl;
	
	// read primary server name
	DNS_RPC_NAME* pRPCName1 = &(pDnsRecord->Data.SOA.namePrimaryServer);
	ReadRPCString(m_szNamePrimaryServer, pRPCName1);

	// read primary server name
	DNS_RPC_NAME* pRPCName2 = DNS_GET_NEXT_NAME(pRPCName1);
	ASSERT(DNS_IS_NAME_IN_RECORD(pDnsRecord,pRPCName2));
	ReadRPCString(m_szResponsibleParty, pRPCName2);

	ASSERT(pDnsRecord->wDataLength == (SIZEOF_DNS_RPC_SOA_RECORD_DATA_HEADER +
		pRPCName1->cchNameLength + pRPCName2->cchNameLength + 2) );
}

void CDNS_SOA_Record::ReadDnsQueryData(DNS_RECORD* pDnsQueryRecord)
{
	CDNSRecord::ReadDnsQueryData(pDnsQueryRecord);
	ASSERT(FALSE); // TODO
}


void CDNS_SOA_Record::WriteRPCData(BYTE* pMem, DNS_RPC_RECORD** ppDnsRecord)
{
	CDNSRecord::WriteRPCData(pMem, ppDnsRecord);

	// write header data
	(*ppDnsRecord)->Data.SOA.dwSerialNo = m_dwSerialNo;
	(*ppDnsRecord)->Data.SOA.dwRefresh = m_dwRefresh;
	(*ppDnsRecord)->Data.SOA.dwRetry = m_dwRetry;
	(*ppDnsRecord)->Data.SOA.dwExpire = m_dwExpire;
	(*ppDnsRecord)->Data.SOA.dwMinimumTtl = m_dwMinimumTtl;
	(*ppDnsRecord)->wDataLength += SIZEOF_DNS_RPC_SOA_RECORD_DATA_HEADER;

	// write primary server name
	DNS_RPC_NAME* pRPCName1 = &((*ppDnsRecord)->Data.SOA.namePrimaryServer);
	ASSERT(DNS_IS_DWORD_ALIGNED(pRPCName1));
	(*ppDnsRecord)->wDataLength = static_cast<WORD>(((*ppDnsRecord)->wDataLength +
                                                     WriteString(pRPCName1, m_szNamePrimaryServer)) & 0xffff);

	// write the responsible party
	DNS_RPC_NAME* pRPCName2 = DNS_GET_NEXT_NAME(pRPCName1);

	(*ppDnsRecord)->wDataLength = static_cast<WORD>(((*ppDnsRecord)->wDataLength +
                                                   WriteString(pRPCName2, m_szResponsibleParty)) & 0xffff);

	ASSERT(DNS_IS_NAME_IN_RECORD((*ppDnsRecord),pRPCName1));
	ASSERT(DNS_IS_NAME_IN_RECORD((*ppDnsRecord),pRPCName2));
}

void CDNS_SOA_Record::UpdateDisplayData(CString& szDisplayData)
{
	szDisplayData.Format(_T("[%u], %s, %s"), m_dwSerialNo,
		(LPCTSTR)m_szNamePrimaryServer,(LPCTSTR)m_szResponsibleParty);
}

///////////////////////////////////////////////////////////////////
// CDNS_PTR_NS_CNAME_MB_MD_MF_MG_MR_Record
CDNS_PTR_NS_CNAME_MB_MD_MF_MG_MR_Record::
	CDNS_PTR_NS_CNAME_MB_MD_MF_MG_MR_Record()
{
}

WORD CDNS_PTR_NS_CNAME_MB_MD_MF_MG_MR_Record::GetRPCDataLength()
{
	return RPCBufferStringLen(m_szNameNode);
}

void CDNS_PTR_NS_CNAME_MB_MD_MF_MG_MR_Record::
		ReadRPCData(DNS_RPC_RECORD* pDnsRecord)
{
	CDNSRecord::ReadRPCData(pDnsRecord);
	ASSERT( (pDnsRecord->wType == DNS_TYPE_PTR) ||
			(pDnsRecord->wType == DNS_TYPE_NS) ||
			(pDnsRecord->wType == DNS_TYPE_CNAME) ||
			(pDnsRecord->wType == DNS_TYPE_MB) ||
			(pDnsRecord->wType == DNS_TYPE_MD) ||
			(pDnsRecord->wType == DNS_TYPE_MF) ||
			(pDnsRecord->wType == DNS_TYPE_MG) ||
			(pDnsRecord->wType == DNS_TYPE_MR) );
	DNS_RPC_NAME* pRPCName = &(pDnsRecord->Data.NS.nameNode);
	ASSERT(pDnsRecord->wDataLength == pRPCName->cchNameLength +1);

	// read name node
	ReadRPCString(m_szNameNode, pRPCName);
}

void CDNS_PTR_NS_CNAME_MB_MD_MF_MG_MR_Record::ReadDnsQueryData(DNS_RECORD* pDnsQueryRecord)
{
	CDNSRecord::ReadDnsQueryData(pDnsQueryRecord);
	ASSERT( (pDnsQueryRecord->wType == DNS_TYPE_PTR) ||
			(pDnsQueryRecord->wType == DNS_TYPE_NS) ||
			(pDnsQueryRecord->wType == DNS_TYPE_CNAME) ||
			(pDnsQueryRecord->wType == DNS_TYPE_MB) ||
			(pDnsQueryRecord->wType == DNS_TYPE_MD) ||
			(pDnsQueryRecord->wType == DNS_TYPE_MF) ||
			(pDnsQueryRecord->wType == DNS_TYPE_MG) ||
			(pDnsQueryRecord->wType == DNS_TYPE_MR) );
	m_szNameNode = pDnsQueryRecord->Data.NS.pNameHost;
}


void CDNS_PTR_NS_CNAME_MB_MD_MF_MG_MR_Record
		::WriteRPCData(BYTE* pMem, DNS_RPC_RECORD** ppDnsRecord)
{
	CDNSRecord::WriteRPCData(pMem, ppDnsRecord);
	
	// write name node
	DNS_RPC_NAME* pRPCName = &((*ppDnsRecord)->Data.NS.nameNode);
	(*ppDnsRecord)->wDataLength = static_cast<WORD>(((*ppDnsRecord)->wDataLength + 
                                                     WriteString(pRPCName,m_szNameNode)) & 0xffff);

}

void CDNS_PTR_NS_CNAME_MB_MD_MF_MG_MR_Record::UpdateDisplayData(CString& szDisplayData)
{
	szDisplayData = m_szNameNode;
}

///////////////////////////////////////////////////////////////////
// CDNS_MINFO_RP_Record

CDNS_MINFO_RP_Record::CDNS_MINFO_RP_Record()
{
}

WORD CDNS_MINFO_RP_Record::GetRPCDataLength()
{
	return static_cast<WORD>(RPCBufferStringLen(m_szNameMailBox) +
			RPCBufferStringLen(m_szErrorToMailbox));		
}

void CDNS_MINFO_RP_Record::ReadRPCData(DNS_RPC_RECORD* pDnsRecord)
{
	CDNSRecord::ReadRPCData(pDnsRecord);
	ASSERT( (pDnsRecord->wType == DNS_TYPE_MINFO) ||
			(pDnsRecord->wType == DNS_TYPE_RP));
	// read mailbox name
	DNS_RPC_NAME* pRPCName1 = &(pDnsRecord->Data.MINFO.nameMailBox);
	ReadRPCString(m_szNameMailBox, pRPCName1);

	// read errors to mailbox
	DNS_RPC_NAME* pRPCName2 = DNS_GET_NEXT_NAME(pRPCName1);
	ASSERT(DNS_IS_NAME_IN_RECORD(pDnsRecord,pRPCName2));
	ReadRPCString(m_szErrorToMailbox, pRPCName2);

	ASSERT(pDnsRecord->wDataLength ==
				(pRPCName1->cchNameLength + pRPCName2->cchNameLength + 2) );
}

void CDNS_MINFO_RP_Record::ReadDnsQueryData(DNS_RECORD* pDnsQueryRecord)
{
	CDNSRecord::ReadDnsQueryData(pDnsQueryRecord);
	ASSERT(FALSE); // TODO
}

void CDNS_MINFO_RP_Record::
		WriteRPCData(BYTE* pMem, DNS_RPC_RECORD** ppDnsRecord)
{
	CDNSRecord::WriteRPCData(pMem, ppDnsRecord);
	// write mailbox name
	DNS_RPC_NAME* pRPCName1 = &((*ppDnsRecord)->Data.MINFO.nameMailBox);
	ASSERT(DNS_IS_DWORD_ALIGNED(pRPCName1));
	(*ppDnsRecord)->wDataLength = static_cast<WORD>(((*ppDnsRecord)->wDataLength +
                                                     WriteString(pRPCName1, m_szNameMailBox)) & 0xffff);

	// write errors to mailbox
	DNS_RPC_NAME* pRPCName2 = DNS_GET_NEXT_NAME(pRPCName1);
	(*ppDnsRecord)->wDataLength = static_cast<WORD>(((*ppDnsRecord)->wDataLength +
                                                     WriteString(pRPCName2, m_szErrorToMailbox)) & 0xffff);

	ASSERT(DNS_IS_NAME_IN_RECORD((*ppDnsRecord),pRPCName1));
	ASSERT(DNS_IS_NAME_IN_RECORD((*ppDnsRecord),pRPCName2));
}

void CDNS_MINFO_RP_Record::UpdateDisplayData(CString& szDisplayData)
{
	if ((GetType() == DNS_TYPE_RP) && (m_szErrorToMailbox.IsEmpty()))
    {
        szDisplayData.Format(_T("%s"),(LPCTSTR)m_szNameMailBox);
    }
    else
    {
            szDisplayData.Format(_T("%s, %s"),
                    (LPCTSTR)m_szNameMailBox,(LPCTSTR)m_szErrorToMailbox);
    }
}

///////////////////////////////////////////////////////////////////
// CDNS_MX_AFSDB_RT_Record

CDNS_MX_AFSDB_RT_Record::CDNS_MX_AFSDB_RT_Record()
{
	m_wPreference = 0x0;
}

WORD CDNS_MX_AFSDB_RT_Record::GetRPCDataLength()
{
	return static_cast<WORD>(SIZEOF_DNS_RPC_MXAFSBD_RT_RECORD_DATA_HEADER +
			RPCBufferStringLen(m_szNameExchange));
}

void CDNS_MX_AFSDB_RT_Record::
		ReadRPCData(DNS_RPC_RECORD* pDnsRecord)
{
	CDNSRecord::ReadRPCData(pDnsRecord);
	ASSERT( (pDnsRecord->wType == DNS_TYPE_MX) ||
			(pDnsRecord->wType == DNS_TYPE_AFSDB) ||
			(pDnsRecord->wType == DNS_TYPE_RT));
	// read header data
	m_wPreference = pDnsRecord->Data.MX.wPreference;
	// read name exchange
	DNS_RPC_NAME* pRPCName = &(pDnsRecord->Data.MX.nameExchange);
	ASSERT(pDnsRecord->wDataLength ==
		SIZEOF_DNS_RPC_MXAFSBD_RT_RECORD_DATA_HEADER + pRPCName->cchNameLength +1);

	ReadRPCString(m_szNameExchange, pRPCName);
}

void CDNS_MX_AFSDB_RT_Record::ReadDnsQueryData(DNS_RECORD* pDnsQueryRecord)
{
	CDNSRecord::ReadDnsQueryData(pDnsQueryRecord);
	ASSERT(FALSE); // TODO
}


void CDNS_MX_AFSDB_RT_Record::
		WriteRPCData(BYTE* pMem, DNS_RPC_RECORD** ppDnsRecord)
{
	CDNSRecord::WriteRPCData(pMem, ppDnsRecord);
	// write header data
	(*ppDnsRecord)->Data.MX.wPreference = m_wPreference;
	(*ppDnsRecord)->wDataLength = static_cast<WORD>(((*ppDnsRecord)->wDataLength +
                                                     SIZEOF_DNS_RPC_MXAFSBD_RT_RECORD_DATA_HEADER) & 0xffff);
	// write name exchange
	DNS_RPC_NAME* pRPCName = &((*ppDnsRecord)->Data.MX.nameExchange);
	(*ppDnsRecord)->wDataLength = static_cast<WORD>(((*ppDnsRecord)->wDataLength +
                                                      WriteString(pRPCName,m_szNameExchange)) & 0xffff);
}

void CDNS_MX_AFSDB_RT_Record::UpdateDisplayData(CString& szDisplayData)
{
	TCHAR szBuf[32];
	szBuf[0] = NULL;
	LPCTSTR lpsz;
	if ( (m_wType == DNS_TYPE_AFSDB) &&
			((m_wPreference == AFSDB_PREF_AFS_CELL_DB_SERV) ||
			 (m_wPreference == AFSDB_PREF_DCE_AUTH_NAME_SERV)) )
	{
		if (m_wPreference == AFSDB_PREF_AFS_CELL_DB_SERV)
			lpsz = _T("AFS");
		else
			lpsz = _T("DCE");
	}
	else
	{
		wsprintf(szBuf,_T("%d"), m_wPreference);
		lpsz = szBuf;
	}
	szDisplayData.Format(_T("[%s]  %s"), lpsz,(LPCTSTR)m_szNameExchange);
}


///////////////////////////////////////////////////////////////////
// CDNS_AAAA_Record

CDNS_AAAA_Record::CDNS_AAAA_Record()
{
	m_wType = DNS_TYPE_AAAA;
	memset(&m_ipv6Address, 0x0,sizeof(IPV6_ADDRESS));
}

WORD CDNS_AAAA_Record::GetRPCDataLength()
{
	return (WORD)SIZEOF_DNS_RPC_AAAA_RECORD_DATA_HEADER;
}

void CDNS_AAAA_Record::ReadRPCData(DNS_RPC_RECORD* pDnsRecord)
{
	CDNSRecord::ReadRPCData(pDnsRecord);
	ASSERT(pDnsRecord->wType == DNS_TYPE_AAAA);
	ASSERT(pDnsRecord->wDataLength == SIZEOF_DNS_RPC_AAAA_RECORD_DATA_HEADER);
	memcpy(&m_ipv6Address, (UNALIGNED IPV6_ADDRESS*)(&(pDnsRecord->Data.AAAA.ipv6Address)), sizeof(IPV6_ADDRESS));
}

void CDNS_AAAA_Record::ReadDnsQueryData(DNS_RECORD* pDnsQueryRecord)
{
	CDNSRecord::ReadDnsQueryData(pDnsQueryRecord);
	ASSERT(FALSE); // TODO
}

void CDNS_AAAA_Record::WriteRPCData(BYTE* pMem, DNS_RPC_RECORD** ppDnsRecord)
{
	CDNSRecord::WriteRPCData(pMem, ppDnsRecord);
	memcpy(&((*ppDnsRecord)->Data.AAAA.ipv6Address), &m_ipv6Address, sizeof(IPV6_ADDRESS));
	(*ppDnsRecord)->wDataLength += SIZEOF_DNS_RPC_AAAA_RECORD_DATA_HEADER;
}

void CDNS_AAAA_Record::UpdateDisplayData(CString& szDisplayData)
{
	FormatIPv6Addr(szDisplayData, &m_ipv6Address);
}

///////////////////////////////////////////////////////////////////
// CDNS_HINFO_ISDN_TXT_X25_Record

CDNS_HINFO_ISDN_TXT_X25_Record::
		CDNS_HINFO_ISDN_TXT_X25_Record()
{
}

WORD CDNS_HINFO_ISDN_TXT_X25_Record::GetRPCDataLength()
{
	ASSERT(FALSE); // intermediate class
	return 0;
}

void CDNS_HINFO_ISDN_TXT_X25_Record::
		ReadRPCData(DNS_RPC_RECORD* pDnsRecord)
{
	CDNSRecord::ReadRPCData(pDnsRecord);
	ASSERT( (pDnsRecord->wType == DNS_TYPE_HINFO) ||
			(pDnsRecord->wType == DNS_TYPE_ISDN)  ||
			(pDnsRecord->wType == DNS_TYPE_TEXT)  ||
			(pDnsRecord->wType == DNS_TYPE_X25) );

	// loop to the end of the buffer and copy into array of strings
	DNS_RPC_NAME* pRPCName = &(pDnsRecord->Data.HINFO.stringData);

	int k = 0;
	WORD wDataLength = 0x0;
	CString szTemp;
	while ((PCHAR)pRPCName < DNS_GET_END_OF_RPC_RECORD_DATA(pDnsRecord))
	{
		ReadRPCString(szTemp, pRPCName);
		OnReadRPCString(szTemp, k++);
		wDataLength = wDataLength + static_cast<WORD>(pRPCName->cchNameLength + 1);
		pRPCName = DNS_GET_NEXT_NAME(pRPCName);
	}
	SetStringCount(k);
		
	ASSERT(pDnsRecord->wDataLength == wDataLength);
}

void CDNS_HINFO_ISDN_TXT_X25_Record::ReadDnsQueryData(DNS_RECORD* pDnsQueryRecord)
{
	CDNSRecord::ReadDnsQueryData(pDnsQueryRecord);
	ASSERT(FALSE); // TODO
}



void CDNS_HINFO_ISDN_TXT_X25_Record::
		WriteRPCData(BYTE* pMem, DNS_RPC_RECORD** ppDnsRecord)
{
	CDNSRecord::WriteRPCData(pMem, ppDnsRecord);
	// loop through the list of strings
	DNS_RPC_NAME* pRPCName = &((*ppDnsRecord)->Data.HINFO.stringData);
	int nCount = GetStringCount();
	for (int j=0; j < nCount; j++)
	{
		//(*ppDnsRecord)->wDataLength += WriteString(pRPCName,m_stringDataArray[j]);
		(*ppDnsRecord)->wDataLength = static_cast<WORD>(((*ppDnsRecord)->wDataLength +
                                                       OnWriteString(pRPCName,j)) & 0xffff);
		pRPCName = DNS_GET_NEXT_NAME(pRPCName);
	}
}

void CDNS_HINFO_ISDN_TXT_X25_Record::UpdateDisplayData(CString& szDisplayData)
{
	ASSERT(FALSE);
	szDisplayData = _T("ERROR, should never happen");
}

///////////////////////////////////////////////////////////////////
// CDNS_HINFO_Record

WORD CDNS_HINFO_Record::GetRPCDataLength()
{
	return static_cast<WORD>(RPCBufferStringLen(m_szCPUType) +
		RPCBufferStringLen(m_szOperatingSystem));
}


void CDNS_HINFO_Record::OnReadRPCString(LPCTSTR lpszStr, int k)
{
	switch (k)
	{
	case 0:
		m_szCPUType = lpszStr;
		break;
	case 1:
		m_szOperatingSystem = lpszStr;
		break;
	default:
		ASSERT(FALSE);
	}
}

WORD CDNS_HINFO_Record::OnWriteString(DNS_RPC_NAME* pDnsRPCName, int k)
{
	switch (k)
	{
	case 0:
		return WriteString(pDnsRPCName,m_szCPUType);
	case 1:
		return WriteString(pDnsRPCName,m_szOperatingSystem);
	default:
		ASSERT(FALSE);
	}
	return 0;
}

void CDNS_HINFO_Record::UpdateDisplayData(CString& szDisplayData)
{
	szDisplayData.Format(_T("%s, %s"),(LPCTSTR)m_szCPUType, (LPCTSTR)m_szOperatingSystem);
}

///////////////////////////////////////////////////////////////////
// CDNS_ISDN_Record

WORD CDNS_ISDN_Record::GetRPCDataLength()
{
	return static_cast<WORD>(RPCBufferStringLen(m_szPhoneNumberAndDDI) +
		RPCBufferStringLen(m_szSubAddress));
}

CDNS_ISDN_Record::CDNS_ISDN_Record()
{
	m_wType = DNS_TYPE_ISDN;
}

void CDNS_ISDN_Record::OnReadRPCString(LPCTSTR lpszStr, int k)
{
	switch (k)
	{
	case 0:
		m_szPhoneNumberAndDDI = lpszStr;
		m_szSubAddress.Empty(); // copy from 2 to 1 strings might not execute case 1:
		break;
	case 1:
		m_szSubAddress = lpszStr;
		break;
	default:
		ASSERT(FALSE);
	}
}

WORD CDNS_ISDN_Record::OnWriteString(DNS_RPC_NAME* pDnsRPCName, int k)
{
	switch (k)
	{
	case 0:
		return WriteString(pDnsRPCName,m_szPhoneNumberAndDDI);
	case 1:
		{
			ASSERT(!m_szSubAddress.IsEmpty());
			if (m_szSubAddress.IsEmpty())
				return 0;
			return WriteString(pDnsRPCName,m_szSubAddress);
		}
	default:
		ASSERT(FALSE);
	}
	return 0;
}

void CDNS_ISDN_Record::UpdateDisplayData(CString& szDisplayData)
{
	if(m_szSubAddress.IsEmpty())
		szDisplayData = m_szPhoneNumberAndDDI;
	else
		szDisplayData.Format(_T("%s, %s"),(LPCTSTR)m_szPhoneNumberAndDDI, (LPCTSTR)m_szSubAddress);
}


///////////////////////////////////////////////////////////////////
// CDNS_TXT_Record


CDNS_TXT_Record::CDNS_TXT_Record()
{
	m_wType = DNS_TYPE_TEXT;
	m_stringDataArray.SetSize(2,2); // SetSize(size, grow by)
	m_nStringDataCount = 0; // empty
}

WORD CDNS_TXT_Record::GetRPCDataLength()
{
	WORD wLen = 0;
	for (int j=0; j<m_nStringDataCount; j++)
	{
    wLen = static_cast<WORD>((wLen + (RPCBufferStringLen(m_stringDataArray[j])) & 0xffff));
	}
	return wLen;
}


void CDNS_TXT_Record::OnReadRPCString(LPCTSTR lpszStr, int k)
{
	m_stringDataArray.SetAtGrow(k,lpszStr);
}

WORD CDNS_TXT_Record::OnWriteString(DNS_RPC_NAME* pDnsRPCName, int k)
{
	return WriteString(pDnsRPCName,m_stringDataArray[k]);
}


#define MAX_TXT_DISPLAYLEN 80 // arbitrary width

void CDNS_TXT_Record::UpdateDisplayData(CString& szDisplayData)
{
	szDisplayData.Empty();
	if (m_nStringDataCount == 0)
		return;
	szDisplayData = m_stringDataArray[0];
	if (szDisplayData.GetLength() > MAX_TXT_DISPLAYLEN)
	{
		szDisplayData.Left(MAX_TXT_DISPLAYLEN);
		szDisplayData += _T(" ...");
		return;
	}

	for (int j=1; j<m_nStringDataCount; j++)
	{
		szDisplayData += _T(", ");
        szDisplayData += m_stringDataArray[j];
		if (szDisplayData.GetLength() > MAX_TXT_DISPLAYLEN)
		{
			szDisplayData.Left(MAX_TXT_DISPLAYLEN);
			szDisplayData += _T(" ...");
			break;
		}
	}

}

///////////////////////////////////////////////////////////////////
// CDNS_X25_Record

WORD CDNS_X25_Record::GetRPCDataLength()
{
	return RPCBufferStringLen(m_szX121PSDNAddress);
}


void CDNS_X25_Record::OnReadRPCString(LPCTSTR lpszStr, int k)
{
	ASSERT(k == 0);
	m_szX121PSDNAddress = lpszStr;
}

WORD CDNS_X25_Record::OnWriteString(DNS_RPC_NAME* pDnsRPCName, int k)
{
	ASSERT(k == 0);
	return WriteString(pDnsRPCName,m_szX121PSDNAddress);
}

void CDNS_X25_Record::UpdateDisplayData(CString& szDisplayData)
{
	szDisplayData = m_szX121PSDNAddress;
}

///////////////////////////////////////////////////////////////////
// CDNS_WKS_Record

CDNS_WKS_Record::CDNS_WKS_Record()
{
	m_wType = DNS_TYPE_WKS;
	m_ipAddress = 0x0;
	m_chProtocol = DNS_WKS_PROTOCOL_TCP;
	//m_bBitMask[0] = 0x0;
}

WORD CDNS_WKS_Record::GetRPCDataLength()
{
	return static_cast<WORD>(SIZEOF_DNS_RPC_WKS_RECORD_DATA_HEADER +
			RPCBufferStringLen(m_szServiceList));
}


void CDNS_WKS_Record::ReadRPCData(DNS_RPC_RECORD* pDnsRecord)
{
	CDNSRecord::ReadRPCData(pDnsRecord);
	ASSERT(pDnsRecord->wType == DNS_TYPE_WKS);
	m_ipAddress = pDnsRecord->Data.WKS.ipAddress;
	m_chProtocol = pDnsRecord->Data.WKS.chProtocol;

	DNS_RPC_NAME* pRPCName = (DNS_RPC_NAME*)(pDnsRecord->Data.WKS.bBitMask);
	ReadRPCString(m_szServiceList, pRPCName);

	
	//ASSERT(pDnsRecord->wDataLength == SIZEOF_DNS_RPC_WKS_RECORD_DATA_HEADER);
	//m_ipAddress = pDnsRecord->Data.WKS.ipAddress;
	//m_chProtocol = pDnsRecord->Data.WKS.chProtocol;
	//m_bBitMask[0] = pDnsRecord->Data.WKS.bBitMask[0];
}

void CDNS_WKS_Record::ReadDnsQueryData(DNS_RECORD* pDnsQueryRecord)
{
	CDNSRecord::ReadDnsQueryData(pDnsQueryRecord);
	ASSERT(FALSE); // TODO
}


void CDNS_WKS_Record::WriteRPCData(BYTE* pMem, DNS_RPC_RECORD** ppDnsRecord)
{
	CDNSRecord::WriteRPCData(pMem, ppDnsRecord);
	(*ppDnsRecord)->Data.WKS.ipAddress = m_ipAddress;
	(*ppDnsRecord)->Data.WKS.chProtocol = m_chProtocol;
	(*ppDnsRecord)->wDataLength += SIZEOF_DNS_RPC_WKS_RECORD_DATA_HEADER;

	DNS_RPC_NAME* pRPCName = (DNS_RPC_NAME*)((*ppDnsRecord)->Data.WKS.bBitMask);
	ASSERT(!DNS_IS_DWORD_ALIGNED(pRPCName));
	(*ppDnsRecord)->wDataLength = static_cast<WORD>(((*ppDnsRecord)->wDataLength +
                                                     WriteString(pRPCName, m_szServiceList)) & 0xffff);

//	(*ppDnsRecord)->Data.WKS.ipAddress = m_ipAddress;
//	(*ppDnsRecord)->Data.WKS.chProtocol = m_chProtocol;
//	(*ppDnsRecord)->Data.WKS.bBitMask[0] = m_bBitMask[0];
}

void CDNS_WKS_Record::UpdateDisplayData(CString& szDisplayData)
{
	TCHAR szBuf[32];
	szBuf[0] = NULL;
	LPCTSTR lpsz;
	if (m_chProtocol == DNS_WKS_PROTOCOL_TCP)
		lpsz = _T("TCP");
	else if (m_chProtocol == DNS_WKS_PROTOCOL_UDP)
		lpsz = _T("UDP");
	else
	{
		wsprintf(szBuf,_T("%d"), m_chProtocol);
		lpsz = szBuf;
	}
	szDisplayData.Format(_T("[%s]  %s"), lpsz,(LPCTSTR)m_szServiceList);
}

///////////////////////////////////////////////////////////////////
// CDNS_WINS_Record

CDNS_WINS_Record::CDNS_WINS_Record()
{
	m_wType = DNS_TYPE_WINS;
	m_dwMappingFlag = 0x0;
	m_dwLookupTimeout = DNS_RR_WINS_LOOKUP_DEFAULT_TIMEOUT;
	m_dwCacheTimeout = DNS_RR_WINS_CACHE_DEFAULT_TIMEOUT;
	m_ipWinsServersArray.SetSize(4,4); // SetSize(size, grow by)
	m_nWinsServerCount = 0; // empty
}


WORD CDNS_WINS_Record::GetRPCDataLength()
{
	return static_cast<WORD>((SIZEOF_DNS_RPC_WINS_RECORD_DATA_HEADER +
		m_nWinsServerCount*sizeof(IP_ADDRESS)) & 0xff);
}


void CDNS_WINS_Record::ReadRPCData(DNS_RPC_RECORD* pDnsRecord)
{
	CDNSRecord::ReadRPCData(pDnsRecord);
	ASSERT(pDnsRecord->wType == DNS_TYPE_WINS);
	ASSERT(pDnsRecord->wDataLength == SIZEOF_DNS_RPC_WINS_RECORD_DATA_HEADER +
			pDnsRecord->Data.WINS.cWinsServerCount*sizeof(IP_ADDRESS));

	m_dwMappingFlag = pDnsRecord->Data.WINS.dwMappingFlag;
	m_dwLookupTimeout = pDnsRecord->Data.WINS.dwLookupTimeout;
	m_dwCacheTimeout = pDnsRecord->Data.WINS.dwCacheTimeout;
	m_nWinsServerCount = pDnsRecord->Data.WINS.cWinsServerCount;
	for (DWORD k=0; k<pDnsRecord->Data.WINS.cWinsServerCount; k++)
		m_ipWinsServersArray.SetAtGrow(k, pDnsRecord->Data.WINS.aipWinsServers[k]);
}


void CDNS_WINS_Record::ReadDnsQueryData(DNS_RECORD* pDnsQueryRecord)
{
	CDNSRecord::ReadDnsQueryData(pDnsQueryRecord);
	ASSERT(FALSE); // TODO
}

void CDNS_WINS_Record::WriteRPCData(BYTE* pMem, DNS_RPC_RECORD** ppDnsRecord)
{
	CDNSRecord::WriteRPCData(pMem, ppDnsRecord);
	(*ppDnsRecord)->Data.WINS.dwMappingFlag = m_dwMappingFlag;
	(*ppDnsRecord)->Data.WINS.dwLookupTimeout = m_dwLookupTimeout;
	(*ppDnsRecord)->Data.WINS.dwCacheTimeout = m_dwCacheTimeout;

	(*ppDnsRecord)->Data.WINS.cWinsServerCount = m_nWinsServerCount;
	for (DWORD k=0; k<(*ppDnsRecord)->Data.WINS.cWinsServerCount; k++)
		(*ppDnsRecord)->Data.WINS.aipWinsServers[k] = m_ipWinsServersArray[k];

	(*ppDnsRecord)->wDataLength = static_cast<WORD>(((*ppDnsRecord)->wDataLength +
                                                     SIZEOF_DNS_RPC_WINS_RECORD_DATA_HEADER +
			                                               (*ppDnsRecord)->Data.WINS.cWinsServerCount*sizeof(IP_ADDRESS)) &
                                                    0xffff);
}

void CDNS_WINS_Record::UpdateDisplayData(CString& szDisplayData)
{
	szDisplayData.Empty();
	if (m_nWinsServerCount == 0)
		return;
	// need to chain the IP addresses in a single string
	CString szTemp;
	szTemp.GetBuffer(20); // length of an IP string
	szTemp.ReleaseBuffer();
	szDisplayData.GetBuffer(20*m_nWinsServerCount);
	szDisplayData.ReleaseBuffer();
	for (int k=0; k<m_nWinsServerCount; k++)
	{
    szDisplayData += _T("[");
    FormatIpAddress(szTemp, m_ipWinsServersArray[k]);
		szDisplayData += szTemp;
    szDisplayData += _T("] ");
	}
}

///////////////////////////////////////////////////////////////////
// CDNS_NBSTAT_Record

CDNS_NBSTAT_Record::CDNS_NBSTAT_Record()
{
	m_wType = DNS_TYPE_NBSTAT;
	m_dwMappingFlag = 0x0;
	m_dwLookupTimeout = DNS_RR_WINS_LOOKUP_DEFAULT_TIMEOUT;
	m_dwCacheTimeout = DNS_RR_WINS_CACHE_DEFAULT_TIMEOUT;
}

WORD CDNS_NBSTAT_Record::GetRPCDataLength()
{
	return static_cast<WORD>(SIZEOF_DNS_RPC_NBSTAT_RECORD_DATA_HEADER +
		RPCBufferStringLen(m_szNameResultDomain));
}


void CDNS_NBSTAT_Record::ReadRPCData(DNS_RPC_RECORD* pDnsRecord)
{
	CDNSRecord::ReadRPCData(pDnsRecord);
	ASSERT(pDnsRecord->wType == DNS_TYPE_NBSTAT);
	m_dwMappingFlag = pDnsRecord->Data.NBSTAT.dwMappingFlag;
	m_dwLookupTimeout = pDnsRecord->Data.NBSTAT.dwLookupTimeout;
	m_dwCacheTimeout = pDnsRecord->Data.NBSTAT.dwCacheTimeout;

	DNS_RPC_NAME* pRPCName = &(pDnsRecord->Data.NBSTAT.nameResultDomain);
	ASSERT(pDnsRecord->wDataLength ==
		SIZEOF_DNS_RPC_NBSTAT_RECORD_DATA_HEADER + pRPCName->cchNameLength +1);

	ReadRPCString(m_szNameResultDomain, pRPCName);
}

void CDNS_NBSTAT_Record::ReadDnsQueryData(DNS_RECORD* pDnsQueryRecord)
{
	CDNSRecord::ReadDnsQueryData(pDnsQueryRecord);
	ASSERT(FALSE); // TODO
}

void CDNS_NBSTAT_Record::WriteRPCData(BYTE* pMem, DNS_RPC_RECORD** ppDnsRecord)
{
	CDNSRecord::WriteRPCData(pMem, ppDnsRecord);
	(*ppDnsRecord)->Data.NBSTAT.dwMappingFlag = m_dwMappingFlag;
	(*ppDnsRecord)->Data.NBSTAT.dwLookupTimeout = m_dwLookupTimeout;
	(*ppDnsRecord)->Data.NBSTAT.dwCacheTimeout= m_dwCacheTimeout;
	(*ppDnsRecord)->wDataLength += SIZEOF_DNS_RPC_NBSTAT_RECORD_DATA_HEADER;

	DNS_RPC_NAME* pRPCName = &((*ppDnsRecord)->Data.NBSTAT.nameResultDomain);
	(*ppDnsRecord)->wDataLength = static_cast<WORD>(((*ppDnsRecord)->wDataLength +
                                                    WriteString(pRPCName,m_szNameResultDomain)) & 0xffff);
}

void CDNS_NBSTAT_Record::UpdateDisplayData(CString& szDisplayData)
{
	szDisplayData = m_szNameResultDomain;
}


///////////////////////////////////////////////////////////////////
// CDNS_SRV_Record

CDNS_SRV_Record::CDNS_SRV_Record()
{
	m_wType = DNS_TYPE_SRV;
	m_wPriority = 0x0;
	m_wWeight = 0x0;
	m_wPort = 0x0;
}

WORD CDNS_SRV_Record::GetRPCDataLength()
{
	return static_cast<WORD>(SIZEOF_DNS_RPC_SRV_RECORD_DATA_HEADER +
		RPCBufferStringLen(m_szNameTarget));
}


void CDNS_SRV_Record::ReadRPCData(DNS_RPC_RECORD* pDnsRecord)
{
	CDNSRecord::ReadRPCData(pDnsRecord);
	ASSERT(pDnsRecord->wType == DNS_TYPE_SRV);
	m_wPriority = pDnsRecord->Data.SRV.wPriority;
	m_wWeight = pDnsRecord->Data.SRV.wWeight;
	m_wPort= pDnsRecord->Data.SRV.wPort;

	DNS_RPC_NAME* pRPCName = &(pDnsRecord->Data.SRV.nameTarget);
	ASSERT(pDnsRecord->wDataLength ==
		SIZEOF_DNS_RPC_SRV_RECORD_DATA_HEADER + pRPCName->cchNameLength +1);

	ReadRPCString(m_szNameTarget, pRPCName);
}

void CDNS_SRV_Record::ReadDnsQueryData(DNS_RECORD* pDnsQueryRecord)
{
	CDNSRecord::ReadDnsQueryData(pDnsQueryRecord);
	ASSERT(FALSE); // TODO
}


void CDNS_SRV_Record::WriteRPCData(BYTE* pMem, DNS_RPC_RECORD** ppDnsRecord)
{
	CDNSRecord::WriteRPCData(pMem, ppDnsRecord);
	(*ppDnsRecord)->Data.SRV.wPriority = m_wPriority;
	(*ppDnsRecord)->Data.SRV.wWeight = m_wWeight;
	(*ppDnsRecord)->Data.SRV.wPort = m_wPort;
	(*ppDnsRecord)->wDataLength += SIZEOF_DNS_RPC_SRV_RECORD_DATA_HEADER;

	DNS_RPC_NAME* pRPCName = &((*ppDnsRecord)->Data.SRV.nameTarget);
	(*ppDnsRecord)->wDataLength = static_cast<WORD>(((*ppDnsRecord)->wDataLength +
                                                     WriteString(pRPCName,m_szNameTarget)) & 0xffff);
}

void CDNS_SRV_Record::UpdateDisplayData(CString& szDisplayData)
{
	szDisplayData.Format(_T("[%d][%d][%d] %s"),
		m_wPriority, m_wWeight, m_wPort, m_szNameTarget);
}

///////////////////////////////////////////////////////////////////
// CDNS_SIG_Record

CDNS_SIG_Record::CDNS_SIG_Record()
{
	m_wType = DNS_TYPE_SIG;

  m_wTypeCovered = 0;
	m_chAlgorithm = 0;
	m_chLabels = 0;
	m_dwOriginalTtl = 0;
	m_dwExpiration = 0;
	m_dwTimeSigned = 0;
	m_wKeyFootprint = 0;
	m_szSignerName = L"";
}

WORD CDNS_SIG_Record::GetRPCDataLength()
{
  WORD wSize = static_cast<WORD>(SIZEOF_DNS_RPC_SIG_RECORD_DATA_HEADER);
  wSize = static_cast<WORD>(wSize + RPCBufferStringLen(m_szSignerName));
  wSize = static_cast<WORD>(wSize + m_Signature.GetSize());
	return wSize;
}

void CDNS_SIG_Record::ReadRPCData(DNS_RPC_RECORD* pDnsRecord)
{
	CDNSRecord::ReadRPCData(pDnsRecord);
	ASSERT(pDnsRecord->wType == DNS_TYPE_SIG);
	ASSERT(pDnsRecord->wDataLength >= (SIZEOF_DNS_RPC_SIG_RECORD_DATA_HEADER));

	// constant length data
  m_wTypeCovered = pDnsRecord->Data.SIG.wTypeCovered;
	m_chAlgorithm = pDnsRecord->Data.SIG.chAlgorithm;
	m_chLabels = pDnsRecord->Data.SIG.chLabelCount;
	m_dwOriginalTtl = pDnsRecord->Data.SIG.dwOriginalTtl;
	m_dwExpiration = pDnsRecord->Data.SIG.dwSigExpiration;
	m_dwTimeSigned = pDnsRecord->Data.SIG.dwSigInception;
	m_wKeyFootprint = pDnsRecord->Data.SIG.wKeyTag;

  ReadRPCString(m_szSignerName, &(pDnsRecord->Data.SIG.nameSigner));
  BYTE* pBlob = (BYTE*)DNS_GET_NEXT_NAME(&(pDnsRecord->Data.SIG.nameSigner));

  UINT blobSize = pDnsRecord->wDataLength - 
                  SIZEOF_DNS_RPC_SIG_RECORD_DATA_HEADER;

  // Due to DNS server bug 716362 we must special case the length of the
  // nameSigner.  The server is returning a cchNameLength of 0 with no achString
  // data. We are expecting a cchNameLength of 1 and an achString of '\0' when
  // the string is empty. This only seems to happen for SIG records
  
  if (pDnsRecord->Data.SIG.nameSigner.cchNameLength == 0)
  {
     blobSize -= sizeof(UCHAR);
  }
  else
  {
     blobSize -= RPCBufferStringLen(m_szSignerName);
  }

  m_Signature.Set(pBlob, blobSize);
}

void CDNS_SIG_Record::ReadDnsQueryData(DNS_RECORD* pDnsQueryRecord)
{
	CDNSRecord::ReadDnsQueryData(pDnsQueryRecord);
	ASSERT(pDnsQueryRecord->wType == DNS_TYPE_SIG);
	ASSERT(FALSE); // TODO
}

void CDNS_SIG_Record::WriteRPCData(BYTE* pMem, DNS_RPC_RECORD** ppDnsRecord)
{
	CDNSRecord::WriteRPCData(pMem, ppDnsRecord);
	
	// constant length data
  (*ppDnsRecord)->Data.SIG.wTypeCovered = m_wTypeCovered;
	(*ppDnsRecord)->Data.SIG.chAlgorithm = m_chAlgorithm;
	(*ppDnsRecord)->Data.SIG.chLabelCount = m_chLabels;
	(*ppDnsRecord)->Data.SIG.dwOriginalTtl = m_dwOriginalTtl;
	(*ppDnsRecord)->Data.SIG.dwSigExpiration = m_dwExpiration;
	(*ppDnsRecord)->Data.SIG.dwSigInception = m_dwTimeSigned;
	(*ppDnsRecord)->Data.SIG.wKeyTag = m_wKeyFootprint;
	(*ppDnsRecord)->wDataLength += SIZEOF_DNS_RPC_SIG_RECORD_DATA_HEADER;

	DNS_RPC_NAME* pRPCName = &((*ppDnsRecord)->Data.SIG.nameSigner);
	(*ppDnsRecord)->wDataLength = static_cast<WORD>(((*ppDnsRecord)->wDataLength + 
                                                     WriteString(pRPCName, m_szSignerName)) & 0xffff);

  BYTE* pSignature = (BYTE*)DNS_GET_NEXT_NAME(&((*ppDnsRecord)->Data.SIG.nameSigner));
  memcpy(pSignature, m_Signature.GetData(), m_Signature.GetSize());
	(*ppDnsRecord)->wDataLength = static_cast<WORD>((*ppDnsRecord)->wDataLength + m_Signature.GetSize());
}

void CDNS_SIG_Record::UpdateDisplayData(CString& szDisplayData)
{
	szDisplayData.Empty();

  //
  // Load the type covered
  //
  PCWSTR pszDisplay = NULL;
	DNS_RECORD_INFO_ENTRY* pTable = (DNS_RECORD_INFO_ENTRY*)CDNSRecordInfo::GetInfoEntryTable();
	while (pTable->nResourceID != DNS_RECORD_INFO_END_OF_TABLE)
	{
    if (pTable->wType == m_wTypeCovered)
		{
      pszDisplay = pTable->lpszShortName;
      break;
		}
		pTable++;
	}
  szDisplayData += L"[";
  szDisplayData += pszDisplay;
  szDisplayData += L"]";

  //
  // Show the inception date
  //
  CString szInceptionTime;
  if (::ConvertTTLToLocalTimeString(m_dwTimeSigned, szInceptionTime))
  {
    szDisplayData += L"[Inception:";
    szDisplayData += szInceptionTime;
    szDisplayData += L"]";
  }

  //
  // Show the expiration date
  //
  CString szExpirationTime;
  if (::ConvertTTLToLocalTimeString(m_dwExpiration, szExpirationTime))
  {
    szDisplayData += L"[Expiration:";
    szDisplayData += szExpirationTime;
    szDisplayData += L"]";
  }

  //
  // Show the signer's name
  //
  szDisplayData += L"[";
  szDisplayData += m_szSignerName;
  szDisplayData += L"]";

  //
  // Show the algorithms
  //
  PCOMBOBOX_TABLE_ENTRY pTableEntry = g_Algorithms;
  while (pTableEntry->nComboStringID != 0)
  {
    if (static_cast<BYTE>(pTableEntry->dwComboData) == m_chAlgorithm)
    {
      CString szAlgorithm;
      VERIFY(szAlgorithm.LoadString(pTableEntry->nComboStringID));

      szDisplayData += L"[";
      szDisplayData += szAlgorithm;
      szDisplayData += L"]";
      break;
    }
    pTableEntry++;
  }

  //
  // Show the label count
  //
  szDisplayData.Format(L"%s[%d]", szDisplayData, m_chLabels);
  
  //
  // Show the key footprint
  //
  szDisplayData.Format(L"%s[%d]", szDisplayData, m_wKeyFootprint);

  //
  // Show the key as base64
  //

  szDisplayData += L"[";
  szDisplayData += Base64BLOBToString(m_Signature);
  szDisplayData += L"]";

}


///////////////////////////////////////////////////////////////////
// CDNS_KEY_Record

CDNS_KEY_Record::CDNS_KEY_Record()
{
	m_wType = DNS_TYPE_KEY;

	m_wFlags = 0;
  m_chProtocol = 0;
  m_chAlgorithm = 0;
}

WORD CDNS_KEY_Record::GetRPCDataLength()
{
  WORD wKeySize = static_cast<WORD>(m_Key.GetSize());
  WORD wSize = static_cast<WORD>(SIZEOF_DNS_RPC_KEY_RECORD_DATA_HEADER + wKeySize);
	return wSize;
}

void CDNS_KEY_Record::ReadRPCData(DNS_RPC_RECORD* pDnsRecord)
{
	CDNSRecord::ReadRPCData(pDnsRecord);
	ASSERT(pDnsRecord->wType == DNS_TYPE_KEY);

  m_wFlags = pDnsRecord->Data.KEY.wFlags;
  m_chProtocol = pDnsRecord->Data.KEY.chProtocol;
  m_chAlgorithm = pDnsRecord->Data.KEY.chAlgorithm;

  //
	// set the blob
  //
	m_Key.Set(pDnsRecord->Data.KEY.bKey,
	          pDnsRecord->wDataLength - SIZEOF_DNS_RPC_KEY_RECORD_DATA_HEADER);
}

void CDNS_KEY_Record::ReadDnsQueryData(DNS_RECORD* pDnsQueryRecord)
{
	CDNSRecord::ReadDnsQueryData(pDnsQueryRecord);
	ASSERT(pDnsQueryRecord->wType == DNS_TYPE_KEY);
	ASSERT(FALSE); // TODO
}

void CDNS_KEY_Record::WriteRPCData(BYTE* pMem, DNS_RPC_RECORD** ppDnsRecord)
{
	CDNSRecord::WriteRPCData(pMem, ppDnsRecord);

	(*ppDnsRecord)->Data.KEY.wFlags = m_wFlags;
  (*ppDnsRecord)->Data.KEY.chProtocol = m_chProtocol;
  (*ppDnsRecord)->Data.KEY.chAlgorithm = m_chAlgorithm;

	(*ppDnsRecord)->wDataLength += SIZEOF_DNS_RPC_KEY_RECORD_DATA_HEADER;
  BYTE* pKey = (*ppDnsRecord)->Data.KEY.bKey;
	(*ppDnsRecord)->wDataLength = static_cast<WORD>(((*ppDnsRecord)->wDataLength + m_Key.Get(pKey)) & 0xffff);
}

void CDNS_KEY_Record::UpdateDisplayData(CString& szDisplayData)
{
  szDisplayData.Empty();

  //
  // Turn the bitfield into a binary string
  //
  CString szTempField;
  WORD wTemp = m_wFlags;
  for (size_t idx = 0; idx < sizeof(WORD) * 8; idx++)
  {
    if ((wTemp & (0x1 << idx)) == 0)
    {
      szTempField = L'0' + szTempField;
    }
    else
    {
      szTempField = L'1' + szTempField;
    }
  }
	szDisplayData += _T("[") + szTempField + _T("]");

  //
  // Load the protocols
  //
  PCOMBOBOX_TABLE_ENTRY pTableEntry = g_Protocols;
  while (pTableEntry->nComboStringID != 0)
  {
    if (static_cast<BYTE>(pTableEntry->dwComboData) == m_chProtocol)
    {
      CString szProtocol;
      VERIFY(szProtocol.LoadString(pTableEntry->nComboStringID));

      szDisplayData += L"[";
      szDisplayData += szProtocol;
      szDisplayData += L"]";
      break;
    }
    pTableEntry++;
  }

  //
  // Load the algorithms
  //
  pTableEntry = g_Algorithms;
  while (pTableEntry->nComboStringID != 0)
  {
    if (static_cast<BYTE>(pTableEntry->dwComboData) == m_chAlgorithm)
    {
      CString szAlgorithm;
      VERIFY(szAlgorithm.LoadString(pTableEntry->nComboStringID));

      szDisplayData += L"[";
      szDisplayData += szAlgorithm;
      szDisplayData += L"]";
      break;
    }
    pTableEntry++;
  }

  //
  // Show the key as base64
  //
  
  szDisplayData += L"[";
  szDisplayData += Base64BLOBToString(m_Key);
  szDisplayData += L"]";
}

///////////////////////////////////////////////////////////////////
// CDNS_NXT_Record

CDNS_NXT_Record::CDNS_NXT_Record()
{
	m_wType = DNS_TYPE_NXT;

  m_wNumTypesCovered = 0;
	m_pwTypesCovered = NULL;
}

CDNS_NXT_Record::~CDNS_NXT_Record()
{
  if (m_pwTypesCovered != NULL)
  {
    delete[] m_pwTypesCovered;
    m_pwTypesCovered = NULL;
  }
  m_wNumTypesCovered = 0;
}

WORD CDNS_NXT_Record::GetRPCDataLength()
{
  WORD wSize = RPCBufferStringLen(m_szNextDomain);
  wSize = wSize + static_cast<WORD>(m_wNumTypesCovered * sizeof(WORD));
  wSize += static_cast<WORD>(SIZEOF_DNS_RPC_NXT_RECORD_DATA_HEADER);
	return wSize;
}

void CDNS_NXT_Record::ReadRPCData(DNS_RPC_RECORD* pDnsRecord)
{
	CDNSRecord::ReadRPCData(pDnsRecord);
	ASSERT(pDnsRecord->wType == DNS_TYPE_NXT);

  m_wNumTypesCovered = pDnsRecord->Data.NXT.wNumTypeWords;
  m_pwTypesCovered = new WORD[m_wNumTypesCovered];
  if (m_pwTypesCovered != NULL)
  {
    for (DWORD dwIdx = 0; dwIdx < m_wNumTypesCovered; dwIdx++)
    {
      m_pwTypesCovered[dwIdx] = pDnsRecord->Data.NXT.wTypeWords[dwIdx];
    }
  }

  ReadRPCString(m_szNextDomain, (DNS_RPC_STRING*)(pDnsRecord->Data.NXT.wTypeWords + m_wNumTypesCovered));
}

void CDNS_NXT_Record::ReadDnsQueryData(DNS_RECORD* pDnsQueryRecord)
{
	CDNSRecord::ReadDnsQueryData(pDnsQueryRecord);
	ASSERT(pDnsQueryRecord->wType == DNS_TYPE_NXT);
	ASSERT(FALSE); // TODO
}

void CDNS_NXT_Record::WriteRPCData(BYTE* pMem, DNS_RPC_RECORD** ppDnsRecord)
{
	CDNSRecord::WriteRPCData(pMem, ppDnsRecord);

  (*ppDnsRecord)->wDataLength += SIZEOF_DNS_RPC_NXT_RECORD_DATA_HEADER;

  (*ppDnsRecord)->Data.NXT.wNumTypeWords = m_wNumTypesCovered;
  WORD* pTypesCovered = (*ppDnsRecord)->Data.NXT.wTypeWords;
  if (pTypesCovered != NULL)
  {
    memcpy(pTypesCovered, m_pwTypesCovered, m_wNumTypesCovered * sizeof(WORD));
    (*ppDnsRecord)->wDataLength = static_cast<WORD>(((*ppDnsRecord)->wDataLength +
                                                       m_wNumTypesCovered * sizeof(WORD)) & 0xffff);
  }

  DNS_RPC_NAME* pRPCName = (DNS_RPC_NAME*)(pTypesCovered + m_wNumTypesCovered);
	(*ppDnsRecord)->wDataLength = static_cast<WORD>(((*ppDnsRecord)->wDataLength +
                                                     WriteString(pRPCName,m_szNextDomain)) & 0xffff);
}

void CDNS_NXT_Record::UpdateDisplayData(CString& szDisplayData)
{
	szDisplayData = m_szNextDomain;
  
  if (m_wNumTypesCovered > 0)
  {
    szDisplayData += L"[";

    UINT nCount = 0;
    for (DWORD dwIdx = 0; dwIdx < m_wNumTypesCovered; dwIdx++)
    {
      DNS_RECORD_INFO_ENTRY* pTable = (DNS_RECORD_INFO_ENTRY*)CDNSRecordInfo::GetInfoEntryTable();
	    while (pTable->nResourceID != DNS_RECORD_INFO_END_OF_TABLE)
	    {
        if (pTable->dwFlags & DNS_RECORD_INFO_FLAG_SHOW_NXT)
		    {
          if (pTable->wType == m_pwTypesCovered[dwIdx])
          {
			      if (nCount > 0)
            {
              szDisplayData += L",";
            }
            szDisplayData += pTable->lpszShortName;
            nCount++;
          }
		    }
		    pTable++;
	    }
    }
    szDisplayData += L"]";
  }
}

///////////////////////////////////////////////////////////////////
// CDNS_PTR_RecordNode

LPCWSTR CDNS_PTR_RecordNode::GetTrueRecordName()
{
	return m_szLastOctectName;
}

void CDNS_PTR_RecordNode::SetRecordName(LPCTSTR lpszName, BOOL bAtTheNode)
{
//	ASSERT(!bAtTheNode); // must have a non null name all the time
	m_bAtTheNode = bAtTheNode;

#ifdef _DEBUG
	int nDots = 0;
	LPWSTR p = (LPWSTR)lpszName;
	while (*p)
	{
		if (*p == TEXT('.'))
			nDots++;
		p++;
	}
	ASSERT(nDots == 0);
#endif // _DEBUG
  m_szDisplayName = m_bAtTheNode ? CDNSRecordInfo::GetAtTheNodeDisplayString() : lpszName;
//	m_szDisplayName = lpszName;
	m_szLastOctectName = lpszName;
}

void CDNS_PTR_RecordNode::ChangeDisplayName(CDNSDomainNode* pDomainNode, BOOL bAdvancedView)
{
  if (IsAtTheNode())
  {
    return;
  }

	if ((!pDomainNode->GetZoneNode()->IsReverse()) || bAdvancedView)
	{
		// for fwd lookup or advanced view, do not change the name
		m_szDisplayName = m_szLastOctectName;
	}
	else
	{
		ASSERT(pDomainNode != NULL);
		LPCWSTR lpszFullName = pDomainNode->GetFullName(); // e.g. "80.55.157.in-addr.arpa"
		m_szDisplayName.Format(_T("%s.%s"), (LPCTSTR)m_szLastOctectName, lpszFullName);
		// now got "77.80.55.157.in-addr.arpa"
		BOOL bArpa = RemoveInAddrArpaSuffix(m_szDisplayName.GetBuffer(1));
		m_szDisplayName.ReleaseBuffer(); // got "77.80.55.157"
		if (!bArpa)
		{
			// failed to detect the arpa suffix, just restore the advanced name
			m_szDisplayName = m_szLastOctectName;
		}
		else
		{
			ReverseIPString(m_szDisplayName.GetBuffer(1));
			m_szDisplayName.ReleaseBuffer(); // finally got "157.55.80.77"
		}
	}
}

////////////////////////////////////////////////////////////////////////////
// special data structures and definitions to handle NS record editing

////////////////////////////////////////////////////////////////////////////
// CDNSRecordNodeEditInfo
CDNSRecordNodeEditInfo::CDNSRecordNodeEditInfo()
{
	m_pRecordNode = NULL;
	m_pRecord = NULL;
	m_pEditInfoList = new CDNSRecordNodeEditInfoList;
	m_bExisting = TRUE;
	m_bUpdateUI = TRUE;
	m_bOwnMemory = FALSE;
  m_bFromDnsQuery = FALSE;
	m_action = unchanged;
	m_dwErr = 0x0;
}

CDNSRecordNodeEditInfo::~CDNSRecordNodeEditInfo()
{
	Cleanup();
	delete m_pEditInfoList;
	ASSERT(m_pRecordNode == NULL);
	ASSERT(m_pRecord == NULL);
}

void CDNSRecordNodeEditInfo::CreateFromExistingRecord(CDNSRecordNodeBase* pNode,
													  BOOL bOwnMemory,
													  BOOL bUpdateUI)
{
	// copy the pointer to record node, and possibli assume ownership of memory
	// but clone the record for editing
	ASSERT(pNode != NULL);
	m_bExisting = TRUE;
	m_bUpdateUI = bUpdateUI;
	m_bOwnMemory = bOwnMemory;
	m_pRecordNode = pNode;
	m_pRecord = pNode->CreateCloneRecord();
	m_action = unchanged;
}

void CDNSRecordNodeEditInfo::CreateFromNewRecord(CDNSRecordNodeBase* pNode)
{
	// this is a new record, so we own the memory
	ASSERT(pNode != NULL);
	m_bExisting = FALSE;
	m_bOwnMemory = TRUE;
	m_pRecordNode = pNode;
	m_pRecord = pNode->CreateRecord();
	m_action = add;
}


void CDNSRecordNodeEditInfo::Cleanup()
{
	if (m_bOwnMemory && (m_pRecordNode != NULL))
		delete m_pRecordNode;
	m_pRecordNode = NULL;
	if (m_pRecord != NULL)
	{
		delete m_pRecord; // if here, always to be discarded
		m_pRecord = NULL;
	}
	m_pEditInfoList->RemoveAllNodes();
}


DNS_STATUS CDNSRecordNodeEditInfo::Update(CDNSDomainNode* pDomainNode, CComponentDataObject* pComponentData)
{
	ASSERT((m_action == add) || (m_action == edit) || (m_action == unchanged));
	if (m_action == add)
	{
		// new record
		// hook up container and set name of node (same as the zone)
		m_pRecordNode->SetContainer(pDomainNode);
	}
	else if (m_action == edit)
	{
		// preexisting, might have touched the TTL
		// just in case domain node was not set when reading the RR
		m_pRecordNode->SetContainer(pDomainNode);
	}

	// force a write, ignoring error if the record already exists
	BOOL bUseDefaultTTL = (m_pRecord->m_dwTtlSeconds == pDomainNode->GetDefaultTTL());
	m_dwErr = m_pRecordNode->Update(m_pRecord, bUseDefaultTTL,
									/*bIgnoreAlreadyExists*/ TRUE);
	if (m_dwErr == 0 && m_bUpdateUI)
	{
		// update the UI
		if (m_action == add)
		{
			VERIFY(pDomainNode->AddChildToListAndUI(m_pRecordNode, pComponentData));
      pComponentData->SetDescriptionBarText(pDomainNode);
		}
		else	// edit
		{
			if (pDomainNode->IsVisible())
			{
				long changeMask = CHANGE_RESULT_ITEM;
				VERIFY(SUCCEEDED(pComponentData->ChangeNode(m_pRecordNode, changeMask)));
			}
		}
	}
	return m_dwErr;
}

DNS_STATUS CDNSRecordNodeEditInfo::Remove(CDNSDomainNode* pDomainNode,
										  CComponentDataObject* pComponentData)
{
	if (m_bUpdateUI)
	{
		ASSERT(m_pRecordNode->GetDomainNode() == pDomainNode);
		m_dwErr = m_pRecordNode->DeleteOnServerAndUI(pComponentData);
	}
	else
	{
		// temporarily attach the provided domain
		if (m_pRecordNode->GetContainer() == NULL)
			m_pRecordNode->SetContainer(pDomainNode);
		m_pRecordNode->DeleteOnServer();
	}
	if (m_dwErr == 0)
	{
		// own memory from now on
		m_bOwnMemory = TRUE;	
	}
	return m_dwErr;
}


////////////////////////////////////////////////////////////////////////////
// CDNSRecordInfo : table driven info for record types

CDNSRecordNodeBase* CDNSRecordInfo::CreateRecordNodeFromRPCData(LPCTSTR lpszName, 
                                                                DNS_RPC_RECORD* pDnsRecord, 
                                                                BOOL bAtTheNode)
{
	ASSERT(pDnsRecord != NULL);

  //
  // construct an object of the right type
  //
	CDNSRecordNodeBase* pNode = CreateRecordNode(pDnsRecord->wType);

	if (pNode == NULL)
  {
		return NULL;
  }

  //
	// set the object from RPC buffer
  //
	pNode->SetRecordName(lpszName, bAtTheNode);
	pNode->CreateFromRPCRecord(pDnsRecord);
	return pNode;
}

#define SWITCH_ENTRY(x) \
	case DNS_TYPE_##x : \
		pNode = new CDNS_##x_RecordNode; \
		break;

CDNSRecordNodeBase* CDNSRecordInfo::CreateRecordNode(WORD wType)
{
	CDNSRecordNodeBase* pNode = NULL;

	// construct an object of the right type
	switch (wType)
	{
	case DNS_TYPE_A:
		pNode = new CDNS_A_RecordNode;
		break;
	case DNS_TYPE_ATMA:
		pNode = new CDNS_ATMA_RecordNode;
		break;
	case DNS_TYPE_SOA:
		{
			pNode = new CDNS_SOA_RecordNode;
         if (pNode)
         {
			   pNode->SetFlagsDown(TN_FLAG_NO_DELETE, TRUE /*bSet*/);
         }
		}
		break;
	case DNS_TYPE_PTR:
		pNode = new CDNS_PTR_RecordNode;
		break;
	case DNS_TYPE_NS:
		pNode = new CDNS_NS_RecordNode;
		break;
	case DNS_TYPE_CNAME:
		pNode = new CDNS_CNAME_RecordNode;
		break;
	case DNS_TYPE_MB:
		pNode = new CDNS_MB_RecordNode;
		break;
	case DNS_TYPE_MD:
		pNode = new CDNS_MD_RecordNode;
		break;
	case DNS_TYPE_MF:
		pNode = new CDNS_MF_RecordNode;
		break;
	case DNS_TYPE_MG:
		pNode = new CDNS_MG_RecordNode;
		break;
	case DNS_TYPE_MR:
		pNode = new CDNS_MR_RecordNode;
		break;
	case DNS_TYPE_MINFO:
		pNode = new CDNS_MINFO_RecordNode;
		break;
	case DNS_TYPE_RP:
		pNode = new CDNS_RP_RecordNode;
		break;
	case DNS_TYPE_MX:
		pNode = new CDNS_MX_RecordNode;
		break;
	case DNS_TYPE_AFSDB:
		pNode = new CDNS_AFSDB_RecordNode;
		break;
	case DNS_TYPE_RT:
		pNode = new CDNS_RT_RecordNode;
		break;
	case DNS_TYPE_AAAA:
		pNode = new CDNS_AAAA_RecordNode;
		break;
	case DNS_TYPE_HINFO:
		pNode = new CDNS_HINFO_RecordNode;
		break;	
	case DNS_TYPE_ISDN:
		pNode = new CDNS_ISDN_RecordNode;
		break;	
	case DNS_TYPE_TEXT:
		pNode = new CDNS_TXT_RecordNode;
		break;
	case DNS_TYPE_X25:
		pNode = new CDNS_X25_RecordNode;
		break;
	case DNS_TYPE_WKS:
		pNode = new CDNS_WKS_RecordNode;
		break;
	case DNS_TYPE_WINS:
		pNode = new CDNS_WINS_RecordNode;
		break;
	case DNS_TYPE_NBSTAT:
		pNode = new CDNS_NBSTAT_RecordNode;
		break;
	case DNS_TYPE_SRV:
		pNode = new CDNS_SRV_RecordNode;
		break;
	case DNS_TYPE_KEY:
		pNode = new CDNS_KEY_RecordNode;
		break;
	case DNS_TYPE_SIG:
		pNode = new CDNS_SIG_RecordNode;
		break;
  case DNS_TYPE_NXT:
    pNode = new CDNS_NXT_RecordNode;
    break;
	case DNS_TYPE_NULL:
		pNode = new CDNS_Null_RecordNode;
		break;
	default:
		{
			pNode = new CDNS_Null_RecordNode; // unknown type of record
		}
	}
	ASSERT(pNode != NULL);
	return pNode;
}


#define INFO_ENTRY(x)	\
    {DNS_TYPE_##x , L#x  , NULL , NULL , IDS_RECORD_INFO_##x , L"", 0x0},
#define INFO_ENTRY_SHOWNXT(x)	\
    {DNS_TYPE_##x , L#x  , NULL , NULL , IDS_RECORD_INFO_##x , L"", DNS_RECORD_INFO_FLAG_SHOW_NXT},
#define INFO_ENTRY_UI_CREATE(x) \
    {DNS_TYPE_##x , L#x  , NULL , NULL , IDS_RECORD_INFO_##x , L"", DNS_RECORD_INFO_FLAG_UICREATE | DNS_RECORD_INFO_FLAG_SHOW_NXT},
#define INFO_ENTRY_UI_CREATE_AT_NODE(x) \
    {DNS_TYPE_##x , L#x  , NULL , NULL , IDS_RECORD_INFO_##x , L"", DNS_RECORD_INFO_FLAG_UICREATE_AT_NODE | DNS_RECORD_INFO_FLAG_SHOW_NXT},
#define INFO_ENTRY_UI_CREATE_WHISTLER_OR_LATER(x) \
    {DNS_TYPE_##x , L#x  , NULL , NULL , IDS_RECORD_INFO_##x , L"", DNS_RECORD_INFO_FLAG_UICREATE | DNS_RECORD_INFO_FLAG_SHOW_NXT | DNS_RECORD_INFO_FLAG_WHISTLER_OR_LATER},

#define INFO_ENTRY_NAME(x, namestr) \
    {DNS_TYPE_##x , namestr  , NULL , NULL , IDS_RECORD_INFO_##x , L"", 0x0},
#define INFO_ENTRY_NAME_SHOWNXT(x, namestr) \
    {DNS_TYPE_##x , namestr  , NULL , NULL , IDS_RECORD_INFO_##x , L"", DNS_RECORD_INFO_FLAG_SHOW_NXT},
#define INFO_ENTRY_NAME_UI_CREATE(x, namestr) \
    {DNS_TYPE_##x , namestr  , NULL , NULL , IDS_RECORD_INFO_##x , L"", DNS_RECORD_INFO_FLAG_UICREATE | DNS_RECORD_INFO_FLAG_SHOW_NXT},
#define INFO_ENTRY_NAME_UI_CREATE_AT_NODE(x, namestr) \
    {DNS_TYPE_##x , namestr  , NULL , NULL , IDS_RECORD_INFO_##x , L"", DNS_RECORD_INFO_FLAG_UICREATE_AT_NODE | DNS_RECORD_INFO_FLAG_SHOW_NXT},





#define END_OF_TABLE_INFO_ENTRY	{			0 , NULL , NULL , NULL , (UINT)-1            , L"", 0x0}


const DNS_RECORD_INFO_ENTRY* CDNSRecordInfo::GetInfoEntryTable()
{
	static DNS_RECORD_INFO_ENTRY info[] =
	{
    // createble record types (at the node also)
		INFO_ENTRY_UI_CREATE_AT_NODE(A)
    INFO_ENTRY_UI_CREATE_AT_NODE(ATMA)
    INFO_ENTRY_UI_CREATE_AT_NODE(AAAA)
    INFO_ENTRY_NAME_UI_CREATE_AT_NODE(TEXT, L"TXT" )

    // createble record types (never at the node)
    INFO_ENTRY_UI_CREATE(CNAME)
		INFO_ENTRY_UI_CREATE(MB)
    INFO_ENTRY_UI_CREATE(MG)
		INFO_ENTRY_UI_CREATE(MR)
		INFO_ENTRY_UI_CREATE(PTR)

    INFO_ENTRY_UI_CREATE(WKS)
		
		INFO_ENTRY_UI_CREATE(HINFO)
		INFO_ENTRY_UI_CREATE(MINFO)
		INFO_ENTRY_UI_CREATE(MX)
		
		INFO_ENTRY_UI_CREATE(RP)
		INFO_ENTRY_UI_CREATE(AFSDB)
		INFO_ENTRY_UI_CREATE(X25)
		INFO_ENTRY_UI_CREATE(ISDN)
		INFO_ENTRY_UI_CREATE(RT)
		INFO_ENTRY_UI_CREATE(SRV)

    INFO_ENTRY_UI_CREATE_WHISTLER_OR_LATER(SIG)                     
    INFO_ENTRY_UI_CREATE_WHISTLER_OR_LATER(KEY)
    INFO_ENTRY_UI_CREATE_WHISTLER_OR_LATER(NXT)

    // non createble record types
		INFO_ENTRY_SHOWNXT(SOA)                     // cannot create an SOA record!!!
		INFO_ENTRY(WINS)                    // cannot create a WINS record from the Wizard
		INFO_ENTRY_NAME(NBSTAT, L"WINS-R" ) //cannot create a NBSTAT(WINS-R) record from the Wizard
		INFO_ENTRY(NBSTAT)

    INFO_ENTRY_SHOWNXT(NS)                      // use the Name Servers property page
		INFO_ENTRY_SHOWNXT(MD)                      // obsolete, should use MX
		INFO_ENTRY_SHOWNXT(MF)                      // obsolete, should use MX
		
		INFO_ENTRY_SHOWNXT(NSAP)
		INFO_ENTRY_SHOWNXT(NSAPPTR)

		INFO_ENTRY_SHOWNXT(PX)
		INFO_ENTRY_SHOWNXT(GPOS)

    INFO_ENTRY(NULL)                    // Null/Unk records can only be viewed
		INFO_ENTRY(UNK)
		END_OF_TABLE_INFO_ENTRY
	};
	return (const DNS_RECORD_INFO_ENTRY*)&info;
}

const DNS_RECORD_INFO_ENTRY* CDNSRecordInfo::GetEntry(int nIndex)
{
	DNS_RECORD_INFO_ENTRY* pTable = (DNS_RECORD_INFO_ENTRY*)GetInfoEntryTable();
	int k = 0;
	while (pTable->nResourceID != DNS_RECORD_INFO_END_OF_TABLE)
	{
		if (k == nIndex)
			return pTable;
		pTable++;
		k++;
	}
	return NULL;
}

const DNS_RECORD_INFO_ENTRY* CDNSRecordInfo::GetEntryFromName(LPCWSTR lpszName)
{
	DNS_RECORD_INFO_ENTRY* pTable = (DNS_RECORD_INFO_ENTRY*)GetInfoEntryTable();
	while (pTable->nResourceID != DNS_RECORD_INFO_END_OF_TABLE)
	{
		LPCWSTR lpszTableName = pTable->lpszFullName;
		if (_wcsicmp(lpszTableName,lpszName) == 0)
			return pTable;
		pTable++;
	}
	return NULL;
}


const DNS_RECORD_INFO_ENTRY* CDNSRecordInfo::GetTypeEntry(WORD wType)
{
	DNS_RECORD_INFO_ENTRY* pTable = (DNS_RECORD_INFO_ENTRY*)GetInfoEntryTable();
	while (pTable->nResourceID != DNS_RECORD_INFO_END_OF_TABLE)
	{
		if (pTable->wType == wType)
		{
      return pTable;
		}
		pTable++;
	}
	return NULL;
}



LPCWSTR CDNSRecordInfo::GetTypeString(WORD wType, stringType type)
{
  const DNS_RECORD_INFO_ENTRY* pTableEntry = GetTypeEntry(wType);
	if (pTableEntry != NULL)
	{
		switch(type)
		{
			case shortName:
				return pTableEntry->lpszShortName;
			case fullName:
				return pTableEntry->lpszFullName;
			case description:
				return pTableEntry->lpszDescription;
		}
	}
  return g_lpszNullString;
}


CString CDNSRecordInfo::m_szAtTheNodeDisplayString;

BOOL CDNSRecordInfo::LoadResources()
{
	HINSTANCE hInstance = _Module.GetModuleInstance();
	ASSERT(hInstance != NULL);
	DNS_RECORD_INFO_ENTRY* pTable = (DNS_RECORD_INFO_ENTRY*)GetInfoEntryTable();

	while (pTable->nResourceID != DNS_RECORD_INFO_END_OF_TABLE)
	{
		if (0 == ::LoadString(hInstance, pTable->nResourceID,
						pTable->cStringData, MAX_RECORD_RESOURCE_STRLEN))
			return FALSE; // mmissing resource string?
		// parse and replace \n with NULL
		pTable->lpszFullName = pTable->cStringData;
		for (WCHAR* pCh = pTable->cStringData; (*pCh) != NULL; pCh++)
		{
			if ( (*pCh) == L'\n')
			{
				pTable->lpszDescription = (pCh+1);
				(*pCh) = NULL;
				break;
			}
		}
		pTable++;
	}

  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  return m_szAtTheNodeDisplayString.LoadString(IDS_RECORD_AT_THE_NODE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\recordui.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       recordui.cpp
//
//--------------------------------------------------------------------------

#include "preDNSsn.h"
#include <SnapBase.h>

#include "resource.h"
#include "dnsutil.h"
#include "DNSSnap.h"
#include "snapdata.h"

#include "server.h"
#include "domain.h"

#include "record.h"
#include "zone.h"

#ifdef DEBUG_ALLOCATOR
	#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
	#endif
#endif


/*
void TestDefButton(HWND hWnd)
{
	HWND hParent = ::GetParent(hWnd);
	LRESULT lres = ::SendMessage(hParent, DM_GETDEFID, 0,0);
	WORD hi = HIWORD(lres);
	ASSERT( DC_HASDEFID == hi);
	UINT nCtrlID = LOWORD(lres);
	if (nCtrlID == IDCANCEL)
	{
		TRACE(_T("Got changed to cancel, reset to OK\n"));
		::SendMessage(hParent, DM_SETDEFID, (WPARAM)IDOK, 0);
	}
}
*/

////////////////////////////////////////////////////////////////////////
// CDNSRecordPropertyPageHolder

CDNSRecordPropertyPageHolder::CDNSRecordPropertyPageHolder(CDNSDomainNode* pDNSDomainNode, 
							CDNSRecordNodeBase* pRecordNode, 
							CComponentDataObject* pComponentData,
							WORD wPredefinedRecordType)
			: CPropertyPageHolderBase(pDNSDomainNode, pRecordNode, pComponentData)
{
	m_nRecordPages = 0;
	m_pTempDNSRecord = NULL;
	m_wPredefinedRecordType = wPredefinedRecordType;
  m_pAclEditorPage = NULL;

  m_forceContextHelpButton = forceOn;

	ASSERT(pRecordNode == GetRecordNode());
	if (pRecordNode != NULL)
	{
		ASSERT(m_wPredefinedRecordType == 0); // we do not use it
		// have record node selected, we are putting up modeless property sheet
		m_pTempDNSRecord = pRecordNode->CreateCloneRecord(); // temporary copy to work on
		ASSERT(m_pTempDNSRecord != NULL);
		AddPagesFromCurrentRecordNode(FALSE); // do not add to sheet, will add later

	  // security page added only if needed
    ASSERT(!IsWizardMode());
    CDNSZoneNode* pZoneNode = pDNSDomainNode->GetZoneNode();
	  if (pZoneNode->IsDSIntegrated())
	  {
		  CString szPath;
      pRecordNode->CreateDsRecordLdapPath(szPath);
		  if (!szPath.IsEmpty())
			  m_pAclEditorPage = CAclEditorPage::CreateInstance(szPath, this);
	  }
	}
	else
	{
		// we do not have a record node selected, we are creating a new one
		ASSERT(m_wPredefinedRecordType != 0);
		// know the record type
		SetRecordSelection(m_wPredefinedRecordType, FALSE); // do not add Page to Sheet
	}
}

CDNSRecordPropertyPageHolder::~CDNSRecordPropertyPageHolder()
{
	if (m_pTempDNSRecord != NULL)
	{
		delete m_pTempDNSRecord;
		m_pTempDNSRecord = NULL;
	}
	if (IsWizardMode())
	{
		CDNSRecordNodeBase* pRecordNode = GetRecordNode();
		if (pRecordNode != NULL)
		{
			// a node was created, but never written to the server
			SetRecordNode(NULL);
			delete pRecordNode;
		}
	}
  if (m_pAclEditorPage != NULL)
	delete m_pAclEditorPage;
}


HRESULT CDNSRecordPropertyPageHolder::OnAddPage(int nPage, CPropertyPageBase*)
{
	// add the ACL editor page after the last, if present
	if ( (nPage != -1) || (m_pAclEditorPage == NULL) )
		return S_OK; 

	// add the ACL page 
	HPROPSHEETPAGE  hPage = m_pAclEditorPage->CreatePage();
	if (hPage == NULL)
		return E_FAIL;
	// add the raw HPROPSHEETPAGE to sheet, not in the list
	return AddPageToSheetRaw(hPage);
}

void CDNSRecordPropertyPageHolder::AddPagesFromCurrentRecordNode(BOOL bAddToSheet)
{
	CDNSRecordNodeBase* pRecordNode = GetRecordNode();
	ASSERT(pRecordNode != NULL);
	// ask the record to get all the property pages
	ASSERT(m_nRecordPages == 0);
	pRecordNode->CreatePropertyPages(m_pRecordPropPagesArr,&m_nRecordPages);
	ASSERT( (m_nRecordPages >= 0 ) && (m_nRecordPages <= DNS_RECORD_MAX_PROPRETY_PAGES) );
	// add them to the list of pages
	for (int k=0; k < m_nRecordPages; k++)
	{
		AddPageToList((CPropertyPageBase*)m_pRecordPropPagesArr[k]);
		if (bAddToSheet)
			VERIFY(SUCCEEDED(AddPageToSheet((CPropertyPageBase*)m_pRecordPropPagesArr[k])));
	}
}

void CDNSRecordPropertyPageHolder::RemovePagesFromCurrentRecordNode(BOOL bRemoveFromSheet)
{
	CDNSRecordNodeBase* pRecordNode = GetRecordNode();
	ASSERT(pRecordNode != NULL);

	ASSERT( (m_nRecordPages >= 0 ) && (m_nRecordPages <= DNS_RECORD_MAX_PROPRETY_PAGES) );
	// add them to the list of pages
	for (int k=0; k < m_nRecordPages; k++)
	{
		if (bRemoveFromSheet)
			VERIFY(SUCCEEDED(RemovePageFromSheet((CPropertyPageBase*)m_pRecordPropPagesArr[k])));
		RemovePageFromList((CPropertyPageBase*)m_pRecordPropPagesArr[k], TRUE); // delete C++ object
	}
	m_nRecordPages = 0; // cleared
}

DNS_STATUS CDNSRecordPropertyPageHolder::CreateNewRecord(BOOL bAllowDuplicates)
{
	ASSERT(IsWizardMode());
	
	CDNSRecordNodeBase* pRecordNode = GetRecordNode();
	ASSERT(pRecordNode != NULL);
  CDNSDomainNode* pDomainNode = GetDomainNode();
  ASSERT(pDomainNode != NULL);
  RECORD_SEARCH recordSearch = RECORD_NOT_FOUND;

  CDNSDomainNode* pNewParentDomain = NULL;
  CString szFullRecordName;
  pRecordNode->GetFullName(szFullRecordName);
  CString szNonExistentDomain;
  CDNSRecordNodeBase* pExistingRecordNode = 0;

  recordSearch = pDomainNode->GetZoneNode()->DoesContain(szFullRecordName, 
                                                          GetComponentData(),
                                                          &pNewParentDomain,
                                                          &pExistingRecordNode,
                                                          szNonExistentDomain,
                                                          TRUE);

  DNS_STATUS err = 0;

  //
  // add the node to the UI if domain doesn't already exist
  //
  if ((recordSearch == RECORD_NOT_FOUND || pRecordNode->IsAtTheNode() || recordSearch == RECORD_NOT_FOUND_AT_THE_NODE) && 
      pNewParentDomain != NULL)
  {
    //
    // Set the container to the found domain and alter the record name to reflect this
    //
    CDNSDomainNode* pOldParent = pRecordNode->GetDomainNode();
    pRecordNode->SetContainer(pNewParentDomain);
    CString szSingleLabel;

    int iFindResult = szFullRecordName.Find(L'.');
    if (iFindResult != -1)
    {
      szSingleLabel = szFullRecordName.Left(iFindResult);
    }

    BOOL isAtTheNode = TRUE;
    if (recordSearch == RECORD_NOT_FOUND)
    {
      isAtTheNode = pRecordNode->IsAtTheNode();
    }

    pRecordNode->SetRecordName(szSingleLabel, isAtTheNode);

    if (IS_CLASS(*pRecordNode, CDNS_PTR_RecordNode))
    {
       CDNSRootData* pRootData = (CDNSRootData*)GetComponentData()->GetRootData();
       BOOL advancedView = pRootData->IsAdvancedView();

       // If the record is a PTR then we have to call ChangeDisplayName
       // so that the display name will properly reflect the Advanced View
       // flag

       ((CDNS_PTR_RecordNode*)pRecordNode)->ChangeDisplayName(pNewParentDomain, advancedView);
    }

    err = WriteCurrentRecordToServer();
	  if (err == DNS_WARNING_PTR_CREATE_FAILED)
	  {
		  DNSMessageBox(IDS_MSG_RECORD_WARNING_CREATE_PTR);
		  err = 0; // this was just a warning
	  }

	  if (err != 0)
    {
       // NTRAID#NTBUG9-487817-2001/10/31-JeffJon
       // reset the parent to the original so that if the name is changed we
       // don't try to create the record in the subdomain
       pRecordNode->SetContainer(pOldParent);

		  return err; // failed the write
    }
	  VERIFY(pNewParentDomain->AddChildToListAndUI(pRecordNode, GetComponentData()));
    GetComponentData()->SetDescriptionBarText(pNewParentDomain);
  }
  else if (recordSearch == DOMAIN_NOT_ENUMERATED && pNewParentDomain != NULL)
  {
    //
    // this shouldn't happen unless we pass FALSE to DoesContain()
    //
    err = WriteCurrentRecordToServer();
    if (err == DNS_WARNING_PTR_CREATE_FAILED)
    {
      DNSMessageBox(IDS_MSG_RECORD_WARNING_CREATE_PTR);
      err = 0;
    }

    if (err != 0)
    {
      return err;
    }
  }
  else if (recordSearch == NON_EXISTENT_SUBDOMAIN && pNewParentDomain != NULL)
  {
    //
    // Create the record and then search for it so that we expand the newly
    // created domains on the way down
    //
    err = WriteCurrentRecordToServer();
    if (err == DNS_WARNING_PTR_CREATE_FAILED)
    {
      DNSMessageBox(IDS_MSG_RECORD_WARNING_CREATE_PTR);
      err = 0;
    }

    if (err != 0)
    {
      return err;
    }

    ASSERT(!szNonExistentDomain.IsEmpty());
    if (!szNonExistentDomain.IsEmpty())
    {
      CString szSingleLabelDomain;
      int iFindResult = szNonExistentDomain.ReverseFind(L'.');
      if (iFindResult == -1)
      {
        szSingleLabelDomain = szNonExistentDomain;
      }
      else
      {
        int iDomainLength = szNonExistentDomain.GetLength();
        szSingleLabelDomain = szNonExistentDomain.Right(iDomainLength - iFindResult - 1);
      }

      //
      // Create the first subdomain because the current domain is already enumerated
      // so we have to start the remaining enumeration at the new subdomain that is needed
      //
	    CDNSDomainNode* pSubdomainNode = pNewParentDomain->CreateSubdomainNode();
	    ASSERT(pSubdomainNode != NULL);
	    CDNSRootData* pRootData = (CDNSRootData*)GetComponentData()->GetRootData();
	    pNewParentDomain->SetSubdomainName(pSubdomainNode, szSingleLabelDomain, pRootData->IsAdvancedView());

      VERIFY(pNewParentDomain->AddChildToListAndUISorted(pSubdomainNode, GetComponentData()));
      GetComponentData()->SetDescriptionBarText(pNewParentDomain);

      //
      // I don't care what the results of this are, I am just using it 
      // to do the expansion to the new record
      //
      recordSearch = pSubdomainNode->GetZoneNode()->DoesContain(szFullRecordName, 
                                                                 GetComponentData(),
                                                                 &pNewParentDomain,
                                                                 &pExistingRecordNode,
                                                                 szNonExistentDomain,
                                                                 TRUE);
    }
  }
  else
  {
    //
    // Record with name exists
    //
    BOOL bContinueCreate = bAllowDuplicates;
    if (!bAllowDuplicates)
    {
      if (pExistingRecordNode &&
          pExistingRecordNode->GetType() != DNS_TYPE_CNAME)
      {
         // let the creation continue so that the user gets an error message

         bContinueCreate = TRUE;
      }
      else
      {
         // Ask the user if they want to replace the existing CNAME record

         if (DNSMessageBox(IDS_MSG_RECORD_WARNING_DUPLICATE_RECORD, MB_YESNO) == IDYES)
         {
            bContinueCreate = TRUE;
         }
         else
         {
            if (pRecordNode != NULL)
            {
               delete pRecordNode;
            }
         }
      }
   }

    if (bContinueCreate)
    {
      if (pNewParentDomain != NULL)
      {
        //
        // Set the container to the found domain and alter the record name to reflect this
        //
        CDNSDomainNode* pOldParent = pRecordNode->GetDomainNode();
        pRecordNode->SetContainer(pNewParentDomain);
        CString szSingleLabel;
        int iFindResult = szFullRecordName.Find(L'.');
        if (iFindResult != -1)
        {
          szSingleLabel = szFullRecordName.Left(iFindResult);
          pRecordNode->SetRecordName(szSingleLabel, pRecordNode->IsAtTheNode());
        }

        err = WriteCurrentRecordToServer();
	      if (err == DNS_WARNING_PTR_CREATE_FAILED)
	      {
		      DNSMessageBox(IDS_MSG_RECORD_WARNING_CREATE_PTR);
		      err = 0; // this was just a warning
	      }

	      if (err != 0)
        {
            // NTRAID#NTBUG9-487817-2001/10/31-JeffJon
            // reset the parent to the original so that if the name is changed we
            // don't try to create the record in the subdomain
            pRecordNode->SetContainer(pOldParent);

		      return err; // failed the write
        }

        VERIFY(pNewParentDomain->AddChildToListAndUI(pRecordNode, GetComponentData()));
        GetComponentData()->SetDescriptionBarText(pNewParentDomain);
        if (!bAllowDuplicates)
        {
          CNodeList myList;
          myList.AddTail(pNewParentDomain);
          pNewParentDomain->OnRefresh(GetComponentData(), &myList);
        }
      }
      else
      {
        //
        // Error message: Cannot create record in a delegation
        //
        DNSMessageBox(IDS_MSG_DOMAIN_EXISTS);
        if (pRecordNode != NULL)
        {
          delete pRecordNode;
        }
      }
    }
  }

  //
	// the holder does not own the record node anymore
  //
	SetRecordNode(NULL); 
	return err;
}

DNS_STATUS CDNSRecordPropertyPageHolder::CreateNonExistentParentDomains(CDNSRecordNodeBase* pRecordNode, 
                                                                        /*IN/OUT*/CDNSDomainNode** ppNewParentDomain)
{
  DNS_STATUS err = 0;
  CString szFullRecordName;
  pRecordNode->GetFullName(szFullRecordName);
  CString szParentFullName = (*ppNewParentDomain)->GetFullName();
  CString szRemaining = szFullRecordName;

  //
  // Determine which domains need to be created
  //
  int iMatching = szFullRecordName.Find(szParentFullName);
  if (iMatching != -1)
  {
    szRemaining = szFullRecordName.Right(szFullRecordName.GetLength() - iMatching);
  }

  return err;
}


BOOL CDNSRecordPropertyPageHolder::OnPropertyChange(BOOL, long*)
{
	TRACE(_T("CDNSRecordPropertyPageHolder::OnPropertyChange()\n"));

  //
	// WARNING!!! this call cannot be made from the secondary thread the sheet runs from
	// the framework calls it from IComponentData::OnPropertyChange()
  //

	ASSERT(!IsWizardMode()); // it is an existing record!!!

	DNS_STATUS err = WriteCurrentRecordToServer();
	SetError(err);
	TRACE(_T("DNSError = %x\n"), err);
	if (err != 0)
	{
		TRACE(_T("// failed, do not update the UI\n"));
		return FALSE; // failed the write, do not update the UI
	}
	TRACE(_T("// now have to update the UI\n"));
	return TRUE; // make the changes to the UI
}

DNS_STATUS CDNSRecordPropertyPageHolder::WriteCurrentRecordToServer()
{
	CDNSRecordNodeBase* pRecordNode = GetRecordNode();
	ASSERT(pRecordNode != NULL);
	CDNSRecord* pRecord = GetTempDNSRecord();
	ASSERT(pRecord != NULL);
	BOOL bUseDefaultTTL = (pRecord->m_dwTtlSeconds == 
							GetDomainNode()->GetDefaultTTL());
	return pRecordNode->Update(pRecord, bUseDefaultTTL);
}

void CDNSRecordPropertyPageHolder::SetRecordSelection(WORD wRecordType, BOOL bAddToSheet)
{
	ASSERT(GetRecordNode() == NULL);

  //
	// do not have record node created yet, create one
  //
	CDNSRecordNodeBase* pRecordNode = CDNSRecordInfo::CreateRecordNode(wRecordType);
	ASSERT(pRecordNode != NULL);

  //
	// set the normal/advanced view option
  //
	CDNSRootData* pRootData = (CDNSRootData*)GetComponentData()->GetRootData();
	ASSERT(pRootData != NULL);
	pRecordNode->SetFlagsDown(TN_FLAG_DNS_RECORD_FULL_NAME, !pRootData->IsAdvancedView());

  //
	// create the temporary record
  //
	ASSERT(GetTempDNSRecord() == NULL);
	CDNSRecord* pTempDNSRecord = pRecordNode->CreateRecord();
   if (!pTempDNSRecord)
   {
      delete pRecordNode;
      return;
   }

	SetTempDNSRecord(pTempDNSRecord);

  //
	// assign the min TTL from the zone
  //
	pTempDNSRecord->m_dwTtlSeconds = GetDomainNode()->GetDefaultTTL();

  //
	// hookup into the holder
  //
	pRecordNode->SetContainer(GetContainerNode());
	SetRecordNode(pRecordNode);

  //
	// add the pages for the specific record
  //
	AddPagesFromCurrentRecordNode(bAddToSheet); // add to sheet
}


//////////////////////////////////////////////////////////////////////////
// CSelectDNSRecordTypeDialog

BEGIN_MESSAGE_MAP(CSelectDNSRecordTypeDialog, CHelpDialog)
	ON_BN_CLICKED(IDC_CREATE_RECORD_BUTTON, OnCreateRecord)
	ON_LBN_DBLCLK(IDC_RECORD_TYPE_LIST, OnDoubleClickSelTypeList)
	ON_LBN_SELCHANGE(IDC_RECORD_TYPE_LIST, OnSelchangeTypeList)
END_MESSAGE_MAP()

CSelectDNSRecordTypeDialog::CSelectDNSRecordTypeDialog(CDNSDomainNode* pDNSDomainNode, 
								CComponentDataObject* pComponentData) 
				: CHelpDialog(IDD_SELECT_RECORD_TYPE_DIALOG, pComponentData)
{
	m_pDNSDomainNode = pDNSDomainNode;
	m_pComponentData = pComponentData;
	m_bFirstCreation = TRUE;
}

void CSelectDNSRecordTypeDialog::SyncDescriptionText()
{
	const DNS_RECORD_INFO_ENTRY* pEntry = GetSelectedEntry();
	ASSERT(pEntry != NULL);
  if (pEntry != NULL)
  {
	  GetDlgItem(IDC_RECORD_TYPE_DESCR)->SetWindowText(pEntry->lpszDescription);
  }
}

const DNS_RECORD_INFO_ENTRY* CSelectDNSRecordTypeDialog::GetSelectedEntry()
{
	CListBox* pListBox = GetRecordTypeListBox();
	int nSel = pListBox->GetCurSel();
	ASSERT(nSel != -1);
	CString s;
	pListBox->GetText(nSel, s);
	const DNS_RECORD_INFO_ENTRY* pEntry = CDNSRecordInfo::GetEntryFromName(s);
	ASSERT(pEntry != NULL);
	return pEntry;
}

BOOL CSelectDNSRecordTypeDialog::OnInitDialog() 
{
	CHelpDialog::OnInitDialog();

	UINT nButtonIDs[2] = { IDS_BUTTON_TEXT_CANCEL, IDS_BUTTON_TEXT_DONE };
	VERIFY(m_cancelDoneTextHelper.Init(this, IDCANCEL, nButtonIDs));
	m_cancelDoneTextHelper.SetToggleState(m_bFirstCreation);
	
   //
   // Get the server version because we can only add certain records if we are
   // administering a certain version of the server
   //
   CDNSServerNode* pServerNode = m_pDNSDomainNode->GetServerNode();
   ASSERT(pServerNode);

	CListBox* pListBox = GetRecordTypeListBox();
	DNS_RECORD_INFO_ENTRY* pTable = (DNS_RECORD_INFO_ENTRY*)CDNSRecordInfo::GetInfoEntryTable();
	while (pTable->nResourceID != DNS_RECORD_INFO_END_OF_TABLE)
	{
		// some record types cannot be created with this wizard
    if (pTable->dwFlags & DNS_RECORD_INFO_FLAG_UICREATE)
    {

      if (pTable->dwFlags & DNS_RECORD_INFO_FLAG_WHISTLER_OR_LATER)
      {
        if (pServerNode->GetBuildNumber() >= DNS_SRV_BUILD_NUMBER_WHISTLER &&
            (pServerNode->GetMajorVersion() >= DNS_SRV_MAJOR_VERSION_NT_5 &&
             pServerNode->GetMinorVersion() >= DNS_SRV_MINOR_VERSION_WHISTLER))
        {
          pListBox->AddString(pTable->lpszFullName);
        }
      }
      else
      {
        pListBox->AddString(pTable->lpszFullName);
      }
    }
    pTable++;
	}
	pListBox->SetCurSel(0);	
	SyncDescriptionText();
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CSelectDNSRecordTypeDialog::OnSelchangeTypeList() 
{
	SyncDescriptionText();
}


void CSelectDNSRecordTypeDialog::OnDoubleClickSelTypeList()
{
	OnCreateRecord();
}

void CSelectDNSRecordTypeDialog::OnCreateRecord()
{
	const DNS_RECORD_INFO_ENTRY* pEntry = GetSelectedEntry();
	ASSERT(pEntry != NULL);
	if (pEntry == NULL)
		return; // should never happen!!!

	AFX_MANAGE_STATE(AfxGetStaticModuleState());
   CThemeContextActivator activator;

	CString szTitle;
	szTitle.LoadString(IDS_NEW_RECORD_TITLE);

	CDNSRecordPropertyPageHolder recordHolder(m_pDNSDomainNode, NULL, m_pComponentData, pEntry->wType);
	if (IDOK == recordHolder.DoModalDialog(szTitle))
	{
		// toggle the Cancel/Done button label
		if (m_bFirstCreation)
		{
			m_bFirstCreation = FALSE;
			m_cancelDoneTextHelper.SetToggleState(m_bFirstCreation);
		}
	}
}


//////////////////////////////////////////////////////////////////////
// CDNSRecordPropertyPage

BEGIN_MESSAGE_MAP(CDNSRecordPropertyPage, CPropertyPageBase)
	ON_EN_CHANGE(IDC_TTLEDIT, OnTTLChange)
  ON_BN_CLICKED(IDC_DEFAULT_DELETE_STALE_RECORD, OnDeleteStaleRecord)
END_MESSAGE_MAP()

CDNSRecordPropertyPage::CDNSRecordPropertyPage(UINT nIDTemplate, UINT nIDCaption) 
	: CPropertyPageBase(nIDTemplate, nIDCaption)
{
}

CDNSRecordPropertyPage::~CDNSRecordPropertyPage()
{
}

BOOL CDNSRecordPropertyPage::OnInitDialog()
{
  CPropertyPageBase::OnInitDialog();

	CDNSRootData* pRootData = (CDNSRootData*)GetHolder()->GetComponentData()->GetRootData();
	ASSERT(pRootData != NULL);
	EnableTTLCtrl(pRootData->IsAdvancedView());
  EnableAgingCtrl(pRootData->IsAdvancedView());
	return TRUE;
}

CDNSTTLControl* CDNSRecordPropertyPage::GetTTLCtrl()
{
	CDNSTTLControl* pTTLCtrl = (CDNSTTLControl*)GetDlgItem(IDC_TTLEDIT);
	ASSERT(pTTLCtrl != NULL);
	return pTTLCtrl;
}

void CDNSRecordPropertyPage::EnableAgingCtrl(BOOL bShow)
{
  GetDeleteStale()->EnableWindow(bShow);
  GetDeleteStale()->ShowWindow(bShow);
  GetTimeStampEdit()->EnableWindow(bShow);
  GetTimeStampEdit()->ShowWindow(bShow);
  GetTimeStampStatic()->EnableWindow(bShow);
  GetTimeStampStatic()->ShowWindow(bShow);
}

void CDNSRecordPropertyPage::EnableTTLCtrl(BOOL bShow)
{
	CDNSTTLControl* pCtrl = GetTTLCtrl();
	ASSERT(pCtrl != NULL);
	pCtrl->EnableWindow(bShow);
	pCtrl->ShowWindow(bShow);
	CWnd* pWnd = GetDlgItem(IDC_STATIC_TTL);
	ASSERT(pWnd != NULL);
	pWnd->EnableWindow(bShow);
	pWnd->ShowWindow(bShow);

	CWnd* pLabelWnd = GetDlgItem(IDC_TTL_LABEL);
	ASSERT(pLabelWnd != NULL);
	pLabelWnd->EnableWindow(bShow);
	pLabelWnd->ShowWindow(bShow);
}

void CDNSRecordPropertyPage::SetValidState(BOOL bValid)
{
  if (GetHolder()->IsWizardMode())
    GetHolder()->EnableSheetControl(IDOK, bValid);
  else
    SetDirty(bValid);
}

void CDNSRecordPropertyPage::OnDeleteStaleRecord()
{
  SetDirty(TRUE);
}

void CDNSRecordPropertyPage::OnTTLChange()
{
	/*
	DWORD dwTTL;
	CDNSRecordPropertyPageHolder* pHolder = (CDNSRecordPropertyPageHolder*)GetHolder();
	CDNSRecord* pRecord = pHolder->GetTempDNSRecord();
	GetTTLCtrl()->GetTTL(&dwTTL);
	if (pRecord->m_dwTtlSeconds != dwTTL)
	*/
		SetDirty(TRUE);
}

BOOL CDNSRecordPropertyPage::OnPropertyChange(BOOL, long*)
{
	ASSERT(FALSE); 
	return FALSE;
}





//////////////////////////////////////////////////////////////////////
// CDNSRecordStandardPropertyPage


BEGIN_MESSAGE_MAP(CDNSRecordStandardPropertyPage, CDNSRecordPropertyPage)
	ON_EN_CHANGE(IDC_RR_NAME_EDIT, OnEditChange)
END_MESSAGE_MAP()

CDNSRecordStandardPropertyPage::CDNSRecordStandardPropertyPage(UINT nIDTemplate, UINT nIDCaption) 
	: CDNSRecordPropertyPage(nIDTemplate, nIDCaption)
{
  m_bAllowAtTheNode = TRUE;
  m_nUTF8ParentLen = 0;
}


BOOL CDNSRecordStandardPropertyPage::CreateRecord()
{
	CDNSRecordPropertyPageHolder* pHolder = (CDNSRecordPropertyPageHolder*)GetHolder();
	ASSERT(pHolder->IsWizardMode());

  //
  // Get the data from the UI
  //
	DNS_STATUS err = GetUIDataEx(FALSE);
	if (err != 0)
	{
		DNSErrorDialog(err,IDS_MSG_RECORD_CREATE_FAILED);
		return FALSE;
	}

  //
  // Create the new record
  //
	err = pHolder->CreateNewRecord(CanCreateDuplicateRecords());
	if (err != 0)
	{
    DNSErrorDialog(err,IDS_MSG_RECORD_CREATE_FAILED);
		return FALSE;
	}
	return TRUE;
}


BOOL CDNSRecordStandardPropertyPage::OnSetActive() 
{
	CDNSRecordPropertyPageHolder* pHolder = (CDNSRecordPropertyPageHolder*)GetHolder();
	ASSERT(pHolder->GetTempDNSRecord() != NULL);

  //
	// load the data from the record to the UI
  //
	SetUIData(); 

  //
	//loading triggered change notifications on controls,
	// so reset the dirty flag
  //
	SetDirty(FALSE); 

	CDNSRecordNodeBase* pRecordNode = pHolder->GetRecordNode();
	ASSERT(pRecordNode != NULL);
	DWORD dwZoneType = pRecordNode->GetDomainNode()->GetZoneNode()->GetZoneType();
	if ((dwZoneType == DNS_ZONE_TYPE_SECONDARY) || 
      (dwZoneType == DNS_ZONE_TYPE_STUB)      ||
      (dwZoneType == DNS_ZONE_TYPE_CACHE))
  {
		EnableDialogControls(m_hWnd, FALSE);
  }

	return CDNSRecordPropertyPage::OnSetActive();
}

BOOL CDNSRecordStandardPropertyPage::OnKillActive() 
{
	GetUIDataEx(TRUE);
	return CDNSRecordPropertyPage::OnKillActive();
}

BOOL CDNSRecordStandardPropertyPage::OnApply() 
{
	CDNSRecordPropertyPageHolder* pHolder = (CDNSRecordPropertyPageHolder*)GetHolder();
	if(pHolder->IsWizardMode())
	{
    //
		// this is the case of record creation,
		// the user hit OK and we want to create the record
    //
		return CreateRecord();
	}

  //
	// we are in the case of modeless sheet on existing record
  //
  CDNSRecordNodeBase* pRecordNode = pHolder->GetRecordNode();
	ASSERT(pRecordNode != NULL);
  DWORD dwZoneType = pRecordNode->GetDomainNode()->GetZoneNode()->GetZoneType();
	if ((dwZoneType == DNS_ZONE_TYPE_SECONDARY) || 
      (dwZoneType == DNS_ZONE_TYPE_STUB)      ||
      (dwZoneType == DNS_ZONE_TYPE_CACHE))
  {
    // read only case
    return TRUE; 
  }

  DNS_STATUS err = GetUIDataEx(FALSE);
	if (err != 0)
	{
		DNSErrorDialog(err,IDS_MSG_RECORD_UPDATE_FAILED);
		return FALSE;
	}

	if (!IsDirty())
  {
		return TRUE;
  }

	err = pHolder->NotifyConsole(this);
	if (err == DNS_WARNING_PTR_CREATE_FAILED)
	{
		DNSMessageBox(IDS_MSG_RECORD_WARNING_CREATE_PTR);
		err = 0; // was just a warning
	}
	if (err != 0)
	{
		DNSErrorDialog(err,IDS_MSG_RECORD_UPDATE_FAILED);
		return FALSE;
	}
	else
	{
		SetDirty(FALSE);
	}
	return TRUE; // all is cool
}

void CDNSRecordStandardPropertyPage::OnInitName()
{
	CDNSRecordPropertyPageHolder* pHolder = (CDNSRecordPropertyPageHolder*)GetHolder();
	
	// limit the text length the user can type
	m_nUTF8ParentLen = UTF8StringLen(pHolder->GetDomainNode()->GetFullName());
  int nUTF8Len = MAX_DNS_NAME_LEN - m_nUTF8ParentLen - 3; // count dot when chaining

  //
  // hook up name edit control
  //
  GetRRNameEdit()->SetLimitText(nUTF8Len);
  GetRRNameEdit()->SetReadOnly(!GetHolder()->IsWizardMode());

	// set the FQDN for the domain the record is in
  if (GetHolder()->IsWizardMode())
  {
	 GetDomainEditBox()->SetWindowText(pHolder->GetDomainNode()->GetFullName());
  }
  else
  {
     CString szName;
     pHolder->GetRecordNode()->GetFullName(szName);
     GetDomainEditBox()->SetWindowText(szName);
  }
}

void CDNSRecordStandardPropertyPage::OnSetName(CDNSRecordNodeBase* pRecordNode)
{
  if (pRecordNode != NULL)
  {
	  GetRRNameEdit()->SetWindowText(pRecordNode->GetDisplayName());
  }
}

void CDNSRecordStandardPropertyPage::OnGetName(CString& s)
{
	GetEditBoxText(s);
}

void CDNSRecordStandardPropertyPage::GetEditBoxText(CString& s)
{
	GetRRNameEdit()->GetWindowText(s);
}

BOOL CDNSRecordStandardPropertyPage::OnInitDialog()
{
	// call base class to enable/disable TTL control
	CDNSRecordPropertyPage::OnInitDialog();

#if (FALSE)
  //REVIEW_MARCOC: still to debate if we need this altogether
  // determine if the RR can be created at the node
  CDNSRecordPropertyPageHolder* pHolder = (CDNSRecordPropertyPageHolder*)GetHolder();
  CDNSRecord* pRecord = pHolder->GetTempDNSRecord();
	ASSERT(pRecord != NULL);

  const DNS_RECORD_INFO_ENTRY* pTableEntry = CDNSRecordInfo::GetTypeEntry(pRecord->GetType());
  if (pTableEntry != NULL)
  {
    ASSERT(pTableEntry->dwFlags & DNS_RECORD_INFO_FLAG_UICREATE);
    m_bAllowAtTheNode = (pTableEntry->dwFlags & DNS_RECORD_INFO_FLAG_CREATE_AT_NODE) > 0;
  }
#endif

	// initialize the control(s) to display the RR node name
	OnInitName();

	return TRUE; 
}

#ifdef _USE_BLANK
void CDNSRecordStandardPropertyPage::OnEditChange()
{
	CDNSRecordPropertyPageHolder* pHolder = GetDNSRecordHolder();
  if (!pHolder->IsWizardMode())
  {
    //
    // Property Pages do not need this
    //
    return; 
  }

  //
  // Get the new name from the control
  //
	CString s;
	GetEditBoxText(s);
  
  CString szFullName;
  CString szDisplayName;

  CString szTempName = pHolder->GetDomainNode()->GetFullName();
  ASSERT(szTempName.GetLength() > 0);

  if (szTempName.GetAt(szTempName.GetLength() - 1) != L'.')
  {
    szTempName += L".";
  }

  if (s.IsEmpty())
  {
    szFullName = szTempName;
  }
  else
  {
    szFullName.Format(L"%s.%s", s, szTempName);
  }

  //
  // Get server flags
  //
  DWORD dwNameChecking = pHolder->GetDomainNode()->GetServerNode()->GetNameCheckFlag();

  //
  // Is valid?
  //
  BOOL bIsValidName = (0 == ValidateRecordName(szFullName, dwNameChecking));


  if (m_bAllowAtTheNode)
  {
    //
	  // must be a valid name or empty
    //
    bIsValidName = bIsValidName || s.IsEmpty();
  }

  SetDirty(bIsValidName);

  //
  // We only have one page up for record creation
  // so we show only the OK button and no apply button
  // therefore we have to enable the OK button because
  // SetDirty doesn't do that for us
  //
  pHolder->EnableSheetControl(IDOK, bIsValidName);

  GetDomainEditBox()->SetWindowText(szFullName);

}

#else

void CDNSRecordStandardPropertyPage::OnEditChange()
{
	CDNSRecordPropertyPageHolder* pHolder = GetDNSRecordHolder();

  //
  // Get the new name from the control
  //
	CString s;
	GetEditBoxText(s);
  
  CString szFullName;
  CString szDisplayName;

  CString szTempName = pHolder->GetDomainNode()->GetFullName();
  if (szTempName.GetAt(szTempName.GetLength() - 1) != L'.')
  {
    szTempName += L".";
  }

  if (s.IsEmpty())
  {
    szFullName = szTempName;
  }
  else
  {
    szFullName.Format(L"%s.%s", s, szTempName);
  }

  //
  // Get server flags
  //
  DWORD dwNameChecking = pHolder->GetDomainNode()->GetServerNode()->GetNameCheckFlag();

  //
  // Is valid?
  //
  BOOL bIsValidName = (0 == ValidateRecordName(szFullName, dwNameChecking));
  pHolder->EnableSheetControl(IDOK, bIsValidName);

  GetDomainEditBox()->SetWindowText(szFullName);
}

#endif

DNS_STATUS CDNSRecordStandardPropertyPage::ValidateRecordName(PCWSTR pszName, DWORD dwNameChecking)
{
  CDNSRecordPropertyPageHolder* pHolder = GetDNSRecordHolder();
  CDNSRootData* pRootData = (CDNSRootData*)pHolder->GetComponentData()->GetRootData();
	ASSERT(pRootData != NULL);
  if (pRootData->IsAdvancedView())
  {
    //
    // Don't validate the name in advanced view
    //
    return 0;
  }

  return ::ValidateDnsNameAgainstServerFlags(pszName, DnsNameDomain, dwNameChecking);
}

void CDNSRecordStandardPropertyPage::SetUIData()
{
	TRACE(_T("CDNSRecordStandardPropertyPage::SetUIData()\n"));
	CDNSRecordPropertyPageHolder* pHolder = GetDNSRecordHolder();
	CDNSRecord* pRecord = pHolder->GetTempDNSRecord();

	OnSetName(pHolder->GetRecordNode()); // overridable

	GetTTLCtrl()->SetTTL(pRecord->m_dwTtlSeconds);

  GetDeleteStale()->SetCheck(pRecord->m_dwScavengeStart != 0);
  SetTimeStampEdit(pRecord->m_dwScavengeStart);
}

void CDNSRecordStandardPropertyPage::SetTimeStampEdit(DWORD dwScavengeStart)
{
  if (dwScavengeStart == 0)
  {
    GetTimeStampEdit()->SetWindowText(_T(""));
    return;
  }

  SYSTEMTIME sysUTimeStamp, sysLTimeStamp;
  VERIFY(SUCCEEDED(Dns_SystemHrToSystemTime(dwScavengeStart, &sysUTimeStamp)));

  if (!::SystemTimeToTzSpecificLocalTime(NULL, &sysUTimeStamp, &sysLTimeStamp))
  {
    GetTimeStampEdit()->SetWindowText(_T(""));
    return;
  }

  // Format the string with respect to locale
  CString strref;
  PTSTR ptszDate = NULL;
  int cchDate = 0;
  cchDate = GetDateFormat(LOCALE_USER_DEFAULT, 0 , 
                          &sysLTimeStamp, NULL, 
                          ptszDate, 0);
  ptszDate = (PTSTR)malloc(sizeof(TCHAR) * cchDate);

  if (ptszDate)
  {
      if (GetDateFormat(LOCALE_USER_DEFAULT, 0, 
                        &sysLTimeStamp, NULL, 
                        ptszDate, cchDate))
      {
         strref = ptszDate;
      }
      else
      {
         strref = L"";
      }
      free(ptszDate);
  }
  else
  {
     strref = L"";
  }

  PTSTR ptszTime = NULL;

  cchDate = GetTimeFormat(LOCALE_USER_DEFAULT, 0 , 
                          &sysLTimeStamp, NULL, 
                          ptszTime, 0);

  ptszTime = (PTSTR)malloc(sizeof(TCHAR) * cchDate);
  if (ptszTime)
  {
      if (GetTimeFormat(LOCALE_USER_DEFAULT, 0, 
                  &sysLTimeStamp, NULL, 
                  ptszTime, cchDate))
      {
         strref += _T(" ") + CString(ptszTime);
      }
      else
      {
         strref += _T("");
      }
      free(ptszTime);
  }
  else
  {
     strref += _T("");
  }

  GetTimeStampEdit()->SetWindowText(strref);
}

DNS_STATUS CDNSRecordStandardPropertyPage::GetUIDataEx(BOOL)
{
  DNS_STATUS dwErr = 0;
	CDNSRecordPropertyPageHolder* pHolder = GetDNSRecordHolder();
	CDNSRecord* pRecord = pHolder->GetTempDNSRecord();

  //
	// only in wizard mode we can change the edit box content
  //
	if(pHolder->IsWizardMode())
	{
		CString s;
		OnGetName(s);
    CDNSZoneNode* pZone = pHolder->GetDomainNode()->GetZoneNode();
    ASSERT(pZone != NULL);

    if (!s.IsEmpty())
    {
      //
      // Validate the record name using the server flags as a guideline
      //
      CString szFullName;
      szFullName.Format(L"%s.%s", s, pHolder->GetDomainNode()->GetFullName());

      DWORD dwNameChecking = pZone->GetServerNode()->GetNameCheckFlag();
      dwErr = ValidateRecordName(szFullName, dwNameChecking);
    }

#ifdef _USE_BLANK
		BOOL bAtTheNode = s.IsEmpty();
#else
    BOOL bAtTheNode = (s == g_szAtTheNodeInput);
#endif

		CDNSRecordNodeBase* pRecordNode = pHolder->GetRecordNode();
		if (bAtTheNode)
		{
			//name null, node is at the node level, use name of parent
			pRecordNode->SetRecordName(pRecordNode->GetDomainNode()->GetDisplayName(),bAtTheNode);
		}
		else
		{
			// non null name, node is a child
			pRecordNode->SetRecordName(s,bAtTheNode);
		}

	}

	GetTTLCtrl()->GetTTL(&(pRecord->m_dwTtlSeconds));

  if (GetDeleteStale()->GetCheck())
  {
    pRecord->m_dwFlags |= DNS_RPC_RECORD_FLAG_AGING_ON;
  }
  else
  {
    pRecord->m_dwFlags &= ~DNS_RPC_RECORD_FLAG_AGING_ON;
  }

  return dwErr;
}


//
// This is a place holder for new pages
//
#if (FALSE)
///////////////////////////////////////////////////////////////////////
// CDNSRecordDummyPropertyPage

CDNSDummyRecordPropertyPageHolder::CDNSDummyRecordPropertyPageHolder(CDNSDomainNode* pDNSDomainNode, 
							CDNSRecordNodeBase* pRecordNode, 
							CComponentDataObject* pComponentData,
							WORD wPredefinedRecordType)
			: CPropertyPageHolderBase(pDNSDomainNode, pRecordNode, pComponentData)
{

	m_bAutoDeletePages = FALSE; // we have the pages as embedded members

	// add pages
	AddPageToList((CPropertyPageBase*)&m_dummyPage);

}

CDNSDummyRecordPropertyPageHolder::~CDNSDummyRecordPropertyPageHolder()
{

}

CDNSRecordDummyPropertyPage::CDNSRecordDummyPropertyPage()
				: CPropertyPageBase(IID_DUMMY_REC_PPAGE)
{
}

BOOL CDNSRecordDummyPropertyPage::OnApply()
{
	return TRUE;
}

void CDNSRecordDummyPropertyPage::OnOK()
{
	
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\record.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       record.h
//
//--------------------------------------------------------------------------

#ifndef _RECORD_H
#define _RECORD_H

#include "dnsutil.h"

#include "recordUI.h"
#include "recpag1.h"
#include "recpag2.h"

#define DNS_RPC_RECORD_FLAG_DEFAULT 0x0

//
// the _USE_BLANK define would revert to using blank for inputting names 
// RR's at the node
//
#define _USE_BLANK

#ifdef _USE_BLANK
#else
extern const WCHAR* g_szAtTheNodeInput; // string to mark the "At the node RR"
#endif


#define KEY_TYPE_COUNT    4
#define NAME_TYPE_COUNT   3
#define PROTOCOL_COUNT    5
#define ALGORITHMS_COUNT  4

////////////////////////////////////////////////////////////////////////////
// CDNSRecord : base class for all the DNS record types

class CDNSRecord
{
public:
	CDNSRecord();
	virtual ~CDNSRecord() {};

//protected:
public:
    WORD        m_wType;
    DWORD       m_dwFlags;
    DWORD       m_dwTtlSeconds;
    DWORD       m_dwScavengeStart;

public:
	WORD GetType() { return m_wType; }
	DNS_STATUS Update(LPCTSTR lpszServerName, LPCTSTR lpszZoneName, LPCTSTR lpszNodeName, 
					CDNSRecord* pDNSRecordOld, BOOL bUseDefaultTTL);
	DNS_STATUS Delete(LPCTSTR lpszServerName, LPCTSTR lpszZoneName, LPCTSTR lpszNodeName);
	void CloneValue(CDNSRecord* pClone);
	void SetValue(CDNSRecord* pRecord);

	WORD GetRPCRecordLength()
		{ return static_cast<WORD>(SIZEOF_DNS_RPC_RECORD_HEADER + GetRPCDataLength());}
	virtual	WORD GetRPCDataLength() = 0;
	virtual void ReadRPCData(DNS_RPC_RECORD* pDnsRecord);
	virtual void ReadDnsQueryData(DNS_RECORD* pDnsQueryRecord);
	virtual void UpdateDisplayData(CString& szDisplayData) = 0;

#ifdef _DEBUG	
	void TestRPCStuff(DNS_RPC_RECORD* pDnsRecord); // TEST ONLY
#endif
protected:
	virtual void WriteRPCData(BYTE* pMem, DNS_RPC_RECORD** ppDnsRecord);

	// static helpers
protected:
	static WORD RPCBufferStringLen(LPCWSTR lpsz);
	static void ReadRPCString(CString& sz, DNS_RPC_NAME* pDnsRPCName);
	static WORD WriteString(DNS_RPC_NAME* pDnsRPCName, LPCTSTR lpsz);
	void CopyDNSRecordData(CDNSRecord* pDest, CDNSRecord* pSource);
};



////////////////////////////////////////////////////////////////////////////
// CDNSRecordNodeBase : base class for all the DNS record types in the UI

class CDNSRecordNodeBase : public CLeafNode
{
public:
	CDNSRecordNodeBase()
	{
		m_bAtTheNode = FALSE;
		m_pDNSRecord = NULL;
	}
	virtual ~CDNSRecordNodeBase();

	// node info
	DECLARE_NODE_GUID()

	void SetViewOptions(DWORD dwRecordViewOptions);
	virtual HRESULT OnCommand(long nCommandID, 
                            DATA_OBJECT_TYPES type, 
                            CComponentDataObject* pComponentData,
                            CNodeList* pNodeList);
	void OnDelete(CComponentDataObject* pComponentData,
                CNodeList* pNodeList);

  virtual HRESULT OnSetToolbarVerbState(IToolbar* pToolbar, 
                                      CNodeList* pNodeList);

	virtual LPCWSTR GetString(int nCol);
	virtual int GetImageIndex(BOOL bOpenImage);

	virtual BOOL HasPropertyPages(DATA_OBJECT_TYPES type, 
                                BOOL* pbHideVerb,
                                CNodeList* pNodeList);
	virtual HRESULT CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, 
                                      LONG_PTR handle,
                                      CNodeList* pNodeList);

// DNS specific
public:
	BOOL IsAtTheNode() { return m_bAtTheNode;}
	virtual void SetRecordName(LPCTSTR lpszName, BOOL bAtTheNode);

  CDNSDomainNode* GetDomainNode()
	{
		ASSERT(m_pContainer != NULL);
		return (CDNSDomainNode*)m_pContainer;
	}

  BOOL ZoneIsCache();

	// will override for PTR record
	virtual LPCWSTR GetTrueRecordName() { return GetDisplayName();}

	void GetFullName(CString& szFullName);
	void CreateFromRPCRecord(DNS_RPC_RECORD* pDnsRecord);
	void CreateFromDnsQueryRecord(DNS_RECORD* pDnsQueryRecord, DWORD dwFlags);
	DNS_STATUS Update(CDNSRecord* pDNSRecordNew, BOOL bUseDefaultTTL, 
							BOOL bIgnoreAlreadyExists = FALSE);
  void SetScavengingTime(CDNSRecord* pRecord);
  DWORD CalculateScavengingTime();

	WORD GetType() 
	{ ASSERT(m_pDNSRecord != NULL); return m_pDNSRecord->GetType();}

	CDNSRecord* CreateCloneRecord();
	// delete the record from the backend and UI, keep the C++ obj
	DNS_STATUS DeleteOnServer(); 
	DNS_STATUS DeleteOnServerAndUI(CComponentDataObject* pComponentData); 

	virtual CDNSRecord* CreateRecord() = 0; // see templatized derived classes

  void CreateDsRecordLdapPath(CString& sz);

protected:
	virtual LPCONTEXTMENUITEM2 OnGetContextMenuItemTable() 
				{ return CDNSRecordMenuHolder::GetContextMenuItem(); }
	virtual BOOL OnAddMenuItem(LPCONTEXTMENUITEM2 pContextMenuItem2,
								             long *pInsertionAllowed);
	virtual BOOL OnSetDeleteVerbState(DATA_OBJECT_TYPES type, 
                                    BOOL* pbHide,
                                    CNodeList* pNodeList);

	virtual BOOL CanCloseSheets();

	// command handlers
  // pure virtual, see templatized derived classes
	virtual void CreatePropertyPages(CDNSRecordPropertyPage** pPageArray, int* pNmax) = 0;

public:
	BOOL m_bAtTheNode;
protected:
	CString		m_szDisplayData; // formatted display string
	CDNSRecord* m_pDNSRecord;

	friend class CDNSRecordPropertyPageHolder; // because of CreatePropertyPages()
};


//////////////////////////////////////////////////////////////////////////////////
// CDNSRecordNode<> 
// templatized class to "glue" a DNS record to a UI record node and its Property Page

template <class record_class, class prop_page> class CDNSRecordNode : public CDNSRecordNodeBase
{
public:
	virtual CDNSRecord* CreateRecord() { return new record_class;}
protected:
	virtual void CreatePropertyPages(CDNSRecordPropertyPage** pPageArray, int* pNmax)
	{
		// this template provides only one property page
		ASSERT(*pNmax == 0);
		*pNmax = 1;
		pPageArray[0] = new prop_page();
	}
};


//////////////////////////////////////////////////////////////////////////////////
// CDNSRecordDelegatePPageNode<> : 
// templatized class to "glue" a DNS record to a UI record node.
// This node type has no property page of its own and invokes the parent container's  Property Page

template <class record_class, long nStartPageCode> class CDNSRecordDelegatePPageNode : 
          public CDNSRecordNodeBase
{
public:
	CDNSRecordDelegatePPageNode()
	{
	}

  virtual BOOL DelegatesPPToContainer() 
  { 
    if (ZoneIsCache())
      return FALSE;
    return TRUE;
  }

  virtual void ShowPageForNode(CComponentDataObject* pComponentDataObject)
  {
    CContainerNode* pCont = GetContainer();
		ASSERT(pCont != NULL);

    if (pCont->GetSheetCount() > 0)
		{
      // bring up the sheet of the container
			ASSERT(pComponentDataObject != NULL);
			pComponentDataObject->GetPropertyPageHolderTable()->BroadcastSelectPage(pCont, nStartPageCode);
		}	
  }

	virtual HRESULT CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, 
                                      LONG_PTR handle, CNodeList* pNodeList)
	{
    ASSERT(pNodeList->GetCount() == 1); // multi-select not supported

		CContainerNode* pCont = GetContainer();
		ASSERT(pCont != NULL);

    // if the RR is in the cache, need to show the page on this node
    if (ZoneIsCache())
    {
      return CDNSRecordNodeBase::CreatePropertyPages(lpProvider, handle, pNodeList);
    }

    // tell the container to create a new sheet
		return pCont->CreatePropertyPagesHelper(lpProvider, handle, nStartPageCode);
	}
	virtual CDNSRecord* CreateRecord() { return new record_class;}

protected:

};


/////////////////////////////////////////////////////////////////////////////
/////////////////// VARIOUS TYPES OF DNS RECORDS ////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#define BEGIN_CLASS_DNS_RECORD(recClass) \
class recClass : public CDNSRecord \
{ \
public: \
	recClass(); \
public: \
	virtual	WORD GetRPCDataLength();\
	virtual void ReadRPCData(DNS_RPC_RECORD* pDnsRecord); \
	virtual void ReadDnsQueryData(DNS_RECORD* pDnsQueryRecord);\
protected: \
	virtual void WriteRPCData(BYTE* pMem, DNS_RPC_RECORD** ppDnsRecord); \
	virtual void UpdateDisplayData(CString& szDisplayData); \
public:
//protected:

#define END_CLASS_DNS_RECORD };

#define BEGIN_DERIVED_CLASS_DNS_RECORD(baseClass, derClass, wType) \
class derClass : public baseClass \
{ \
public: \
	derClass() { m_wType = wType; } 

#define BEGIN_DERIVED_CLASS_DNS_RECORD_CONSTR(baseClass, derClass) \
class derClass : public baseClass \
{ \
public: \
	derClass();



#define DERIVED_CLASS_DNS_RECORD(baseClass, derClass, wType) \
	BEGIN_DERIVED_CLASS_DNS_RECORD(baseClass, derClass, wType)	END_CLASS_DNS_RECORD

#define DERIVED_CLASS_DNS_RECORD_CONSTR(baseClass, derClass) \
	BEGIN_DERIVED_CLASS_DNS_RECORD_CONSTR(baseClass, derClass)	END_CLASS_DNS_RECORD


///////////////////////////////////////////////////////////////////
// CDNS_Null_Record (same as Unk Record)

BEGIN_CLASS_DNS_RECORD(CDNS_Null_Record)
	CByteBlob m_blob; 
END_CLASS_DNS_RECORD


///////////////////////////////////////////////////////////////////
// CDNS_A_Record

BEGIN_CLASS_DNS_RECORD(CDNS_A_Record)
	IP_ADDRESS m_ipAddress; 
END_CLASS_DNS_RECORD

///////////////////////////////////////////////////////////////////
// CDNS_ATMA_Record

BEGIN_CLASS_DNS_RECORD(CDNS_ATMA_Record)
	UCHAR m_chFormat;
  CString m_szAddress; 
END_CLASS_DNS_RECORD


///////////////////////////////////////////////////////////////////
// CDNS_SOA_Record

BEGIN_CLASS_DNS_RECORD(CDNS_SOA_Record)
	DWORD	m_dwSerialNo;
    DWORD   m_dwRefresh;
    DWORD   m_dwRetry;
    DWORD   m_dwExpire;
    DWORD   m_dwMinimumTtl;

	CString m_szNamePrimaryServer;
	CString m_szResponsibleParty;
END_CLASS_DNS_RECORD

///////////////////////////////////////////////////////////////////
// CDNS_PTR_NS_CNAME_MB_MD_MF_MG_MR_Record

BEGIN_CLASS_DNS_RECORD(CDNS_PTR_NS_CNAME_MB_MD_MF_MG_MR_Record)
	CString m_szNameNode; 
END_CLASS_DNS_RECORD


DERIVED_CLASS_DNS_RECORD(CDNS_PTR_NS_CNAME_MB_MD_MF_MG_MR_Record, CDNS_PTR_Record, DNS_TYPE_PTR)
DERIVED_CLASS_DNS_RECORD(CDNS_PTR_NS_CNAME_MB_MD_MF_MG_MR_Record, CDNS_NS_Record, DNS_TYPE_NS)
DERIVED_CLASS_DNS_RECORD(CDNS_PTR_NS_CNAME_MB_MD_MF_MG_MR_Record, CDNS_CNAME_Record, DNS_TYPE_CNAME)
DERIVED_CLASS_DNS_RECORD(CDNS_PTR_NS_CNAME_MB_MD_MF_MG_MR_Record, CDNS_MB_Record, DNS_TYPE_MB)
DERIVED_CLASS_DNS_RECORD(CDNS_PTR_NS_CNAME_MB_MD_MF_MG_MR_Record, CDNS_MD_Record, DNS_TYPE_MD)
DERIVED_CLASS_DNS_RECORD(CDNS_PTR_NS_CNAME_MB_MD_MF_MG_MR_Record, CDNS_MF_Record, DNS_TYPE_MF)
DERIVED_CLASS_DNS_RECORD(CDNS_PTR_NS_CNAME_MB_MD_MF_MG_MR_Record, CDNS_MG_Record, DNS_TYPE_MG)
DERIVED_CLASS_DNS_RECORD(CDNS_PTR_NS_CNAME_MB_MD_MF_MG_MR_Record, CDNS_MR_Record, DNS_TYPE_MR)


///////////////////////////////////////////////////////////////////
// CDNS_MINFO_RP_Record

BEGIN_CLASS_DNS_RECORD(CDNS_MINFO_RP_Record)
	CString m_szNameMailBox;
	CString m_szErrorToMailbox;
END_CLASS_DNS_RECORD

DERIVED_CLASS_DNS_RECORD(CDNS_MINFO_RP_Record, CDNS_MINFO_Record, DNS_TYPE_MINFO)
DERIVED_CLASS_DNS_RECORD(CDNS_MINFO_RP_Record, CDNS_RP_Record, DNS_TYPE_RP)

///////////////////////////////////////////////////////////////////
// CDNS_MX_AFSDB_RT_Record

BEGIN_CLASS_DNS_RECORD(CDNS_MX_AFSDB_RT_Record)
	WORD m_wPreference;
	CString m_szNameExchange;
END_CLASS_DNS_RECORD

DERIVED_CLASS_DNS_RECORD_CONSTR(CDNS_MX_AFSDB_RT_Record, CDNS_MX_Record)

inline CDNS_MX_Record::CDNS_MX_Record()
{
	m_wType = DNS_TYPE_MX;
	m_wPreference = 10;
}

#define AFSDB_PREF_AFS_CELL_DB_SERV		(1)
#define AFSDB_PREF_DCE_AUTH_NAME_SERV	(2)

DERIVED_CLASS_DNS_RECORD_CONSTR(CDNS_MX_AFSDB_RT_Record, CDNS_AFSDB_Record)

inline CDNS_AFSDB_Record::CDNS_AFSDB_Record()
{
	m_wType = DNS_TYPE_AFSDB;
	m_wPreference = AFSDB_PREF_AFS_CELL_DB_SERV;
}

DERIVED_CLASS_DNS_RECORD_CONSTR(CDNS_MX_AFSDB_RT_Record, CDNS_RT_Record)

inline CDNS_RT_Record::CDNS_RT_Record()
{
	m_wType = DNS_TYPE_RT;
	m_wPreference = 0;
}

///////////////////////////////////////////////////////////////////
// CDNS_AAAA_Record

BEGIN_CLASS_DNS_RECORD(CDNS_AAAA_Record)
	IPV6_ADDRESS m_ipv6Address;
END_CLASS_DNS_RECORD

///////////////////////////////////////////////////////////////////
// CDNS_HINFO_ISDN_TXT_X25_Record

BEGIN_CLASS_DNS_RECORD(CDNS_HINFO_ISDN_TXT_X25_Record)
protected:
	// overrides for derived classes
	virtual void SetStringCount(int n) = 0;
	virtual int GetStringCount() = 0;
	virtual void OnReadRPCString(LPCTSTR lpszStr, int k) = 0;
	virtual WORD OnWriteString(DNS_RPC_NAME* pDnsRPCName, int k) = 0;
END_CLASS_DNS_RECORD

///////////////////////////////////////////////////////////////////
// CDNS_HINFO_Record

BEGIN_DERIVED_CLASS_DNS_RECORD(CDNS_HINFO_ISDN_TXT_X25_Record, CDNS_HINFO_Record, DNS_TYPE_HINFO)
	CString m_szCPUType;
	CString m_szOperatingSystem;
public:
	virtual	WORD GetRPCDataLength();
protected:
	void UpdateDisplayData(CString& szDisplayData);

	virtual void SetStringCount(int n) { ASSERT(n == 2);}
	virtual int GetStringCount() { return 2; }
	virtual void OnReadRPCString(LPCTSTR lpszStr, int k);
	virtual WORD OnWriteString(DNS_RPC_NAME* pDnsRPCName, int k);
END_CLASS_DNS_RECORD

///////////////////////////////////////////////////////////////////
// CDNS_ISDN_Record

BEGIN_DERIVED_CLASS_DNS_RECORD_CONSTR(CDNS_HINFO_ISDN_TXT_X25_Record, CDNS_ISDN_Record)
	CString m_szPhoneNumberAndDDI;
	CString m_szSubAddress;
public:
	virtual	WORD GetRPCDataLength();
protected:
	void UpdateDisplayData(CString& szDisplayData);

	virtual void SetStringCount(int n) { ASSERT( (n == 1) || (n == 2) );}
	virtual int GetStringCount() { return m_szSubAddress.IsEmpty() ? 1 : 2; }
	virtual void OnReadRPCString(LPCTSTR lpszStr, int k);
	virtual WORD OnWriteString(DNS_RPC_NAME* pDnsRPCName, int k);
END_CLASS_DNS_RECORD

///////////////////////////////////////////////////////////////////
// CDNS_TXT_Record

BEGIN_DERIVED_CLASS_DNS_RECORD_CONSTR(CDNS_HINFO_ISDN_TXT_X25_Record, CDNS_TXT_Record)
	CStringArray m_stringDataArray;
	int m_nStringDataCount;
public:
	virtual	WORD GetRPCDataLength();
protected:
	void UpdateDisplayData(CString& szDisplayData);

	virtual void SetStringCount(int n) { m_nStringDataCount = n; }
	virtual int GetStringCount() { return m_nStringDataCount; }
	virtual void OnReadRPCString(LPCTSTR lpszStr, int k);
	virtual WORD OnWriteString(DNS_RPC_NAME* pDnsRPCName, int k);
END_CLASS_DNS_RECORD


///////////////////////////////////////////////////////////////////
// CDNS_X25_Record

BEGIN_DERIVED_CLASS_DNS_RECORD(CDNS_HINFO_ISDN_TXT_X25_Record, CDNS_X25_Record, DNS_TYPE_X25)
	CString m_szX121PSDNAddress;
public:
	virtual	WORD GetRPCDataLength();
protected:
	void UpdateDisplayData(CString& szDisplayData);

	virtual void SetStringCount(int n) { ASSERT(n == 1);}
	virtual int GetStringCount() { return 1; }
	virtual void OnReadRPCString(LPCTSTR lpszStr, int k);
	virtual WORD OnWriteString(DNS_RPC_NAME* pDnsRPCName, int k);
END_CLASS_DNS_RECORD


///////////////////////////////////////////////////////////////////
// CDNS_WKS_Record

#define DNS_WKS_PROTOCOL_TCP (6)
#define DNS_WKS_PROTOCOL_UDP (17)

BEGIN_CLASS_DNS_RECORD(CDNS_WKS_Record)
	IP_ADDRESS      m_ipAddress;
	UCHAR           m_chProtocol;
	// this is not what the wire sends
	// currently sending a blank separated string with service names
	// such as "ftp telnet shell", so we use a string
	CString			m_szServiceList;
	//BYTE       m_bBitMask[1]; 
END_CLASS_DNS_RECORD

///////////////////////////////////////////////////////////////////
// CDNS_WINS_Record

#define DNS_RR_WINS_LOOKUP_DEFAULT_TIMEOUT (2) // in seconds
#define DNS_RR_WINS_CACHE_DEFAULT_TIMEOUT (60*15) // in seconds


BEGIN_CLASS_DNS_RECORD(CDNS_WINS_Record)
	DWORD           m_dwMappingFlag;
	DWORD           m_dwLookupTimeout;
	DWORD           m_dwCacheTimeout;
	CIpAddressArray m_ipWinsServersArray;
	int             m_nWinsServerCount;
END_CLASS_DNS_RECORD

///////////////////////////////////////////////////////////////////
// CDNS_NBSTAT_Record

BEGIN_CLASS_DNS_RECORD(CDNS_NBSTAT_Record)
	DWORD		m_dwMappingFlag;
	DWORD		m_dwLookupTimeout;
	DWORD		m_dwCacheTimeout;
	CString		m_szNameResultDomain;
END_CLASS_DNS_RECORD


///////////////////////////////////////////////////////////////////
// CDNS_SRV_Record

BEGIN_CLASS_DNS_RECORD(CDNS_SRV_Record)
    WORD		m_wPriority;
    WORD		m_wWeight;
    WORD		m_wPort;
    CString		m_szNameTarget;
END_CLASS_DNS_RECORD

///////////////////////////////////////////////////////////////////
// CDNS_SIG_Record

BEGIN_CLASS_DNS_RECORD(CDNS_SIG_Record)
    WORD            m_wTypeCovered;		// DNS_TYPE_<x>
    BYTE            m_chAlgorithm;		// 0,255 unsigned int
    BYTE            m_chLabels;			// 0,255 unsigned int (count)
    DWORD           m_dwOriginalTtl;
    DWORD           m_dwExpiration;		// time in sec. from 1 Jan 1970
    DWORD           m_dwTimeSigned;		// time in sec. from 1 Jan 1970
    WORD            m_wKeyFootprint;	// algorithm dependent
    CString         m_szSignerName;	
    CByteBlob       m_Signature;
END_CLASS_DNS_RECORD

///////////////////////////////////////////////////////////////////
// CDNS_KEY_Record

BEGIN_CLASS_DNS_RECORD(CDNS_KEY_Record)
    WORD            m_wFlags;		// 16 one bit flags
    BYTE            m_chProtocol;	// 0,255 unsigned int
    BYTE            m_chAlgorithm;	// 0,255 unsigned int
    CByteBlob       m_Key;
END_CLASS_DNS_RECORD

///////////////////////////////////////////////////////////////////
// CDNS_NXT_RECORD

BEGIN_CLASS_DNS_RECORD(CDNS_NXT_Record)
    CDNS_NXT_Record::~CDNS_NXT_Record();
    
    CString         m_szNextDomain;
    WORD            m_wNumTypesCovered;
    WORD*           m_pwTypesCovered;
END_CLASS_DNS_RECORD

///////////////////////////////////////////////////////////////////
// special derivation for PTR record node
// CDNS_PTR_RecordNode

class CDNS_PTR_RecordNode : public CDNSRecordNode< CDNS_PTR_Record, CDNS_PTR_RecordPropertyPage >
{
public:
	virtual LPCWSTR GetTrueRecordName(); 
	virtual void SetRecordName(LPCTSTR lpszName, BOOL bAtTheNode);

	void ChangeDisplayName(CDNSDomainNode* pDomainNode, BOOL bAdvancedView);
private:
	CString m_szLastOctectName; 
};

//////////////////////////////////////////////////////////////////
// special derivation for MB record, to access name node

class CDNS_MB_RecordNode : public CDNSRecordNode< CDNS_MB_Record, CDNS_MB_RecordPropertyPage >
{
public:
	LPCTSTR GetNameNodeString() 
	{ 
		ASSERT(m_pDNSRecord != NULL);
		return ((CDNS_MB_Record*)m_pDNSRecord)->m_szNameNode;
	}
};

//////////////////////////////////////////////////////////////////
// special derivation for A record, to access IP address

class CDNS_A_RecordNode : public CDNSRecordNode< CDNS_A_Record, CDNS_A_RecordPropertyPage >
{
public:
	IP_ADDRESS GetIPAddress() 
	{ 
		ASSERT(m_pDNSRecord != NULL);
		return ((CDNS_A_Record*)m_pDNSRecord)->m_ipAddress;
	}
};

////////////////////////////////////////////////////////////////////////////////////////////////////
// template classes that glue an RPC record with its property page and the corresponding UI record node

typedef CDNSRecordNode<CDNS_Null_Record,	CDNS_Unk_RecordPropertyPage		> CDNS_Null_RecordNode;

typedef CDNSRecordNode<	CDNS_ATMA_Record,	CDNS_ATMA_RecordPropertyPage	> CDNS_ATMA_RecordNode;

typedef CDNSRecordNode<	CDNS_CNAME_Record,	CDNS_CNAME_RecordPropertyPage	> CDNS_CNAME_RecordNode;

typedef CDNSRecordNode<	CDNS_MD_Record,		CDNS_MD_RecordPropertyPage		> CDNS_MD_RecordNode;
typedef CDNSRecordNode<	CDNS_MF_Record,		CDNS_MF_RecordPropertyPage		> CDNS_MF_RecordNode;	
typedef CDNSRecordNode<	CDNS_MG_Record,		CDNS_MG_RecordPropertyPage		> CDNS_MG_RecordNode;	
typedef CDNSRecordNode<	CDNS_MR_Record,		CDNS_MR_RecordPropertyPage		> CDNS_MR_RecordNode;	

typedef CDNSRecordNode<	CDNS_MINFO_Record,	CDNS_MINFO_RecordPropertyPage	> CDNS_MINFO_RecordNode;
typedef CDNSRecordNode<	CDNS_RP_Record,		CDNS_RP_RecordPropertyPage		> CDNS_RP_RecordNode;
	
typedef CDNSRecordNode<	CDNS_MX_Record,		CDNS_MX_RecordPropertyPage		> CDNS_MX_RecordNode;	
typedef CDNSRecordNode<	CDNS_AFSDB_Record,	CDNS_AFSDB_RecordPropertyPage	> CDNS_AFSDB_RecordNode;
typedef CDNSRecordNode<	CDNS_RT_Record,		CDNS_RT_RecordPropertyPage		> CDNS_RT_RecordNode;

typedef CDNSRecordNode<	CDNS_AAAA_Record,	CDNS_AAAA_RecordPropertyPage	> CDNS_AAAA_RecordNode;	
typedef CDNSRecordNode<	CDNS_HINFO_Record,	CDNS_HINFO_RecordPropertyPage	> CDNS_HINFO_RecordNode;
typedef CDNSRecordNode<	CDNS_ISDN_Record,	CDNS_ISDN_RecordPropertyPage	> CDNS_ISDN_RecordNode;	
typedef CDNSRecordNode<	CDNS_TXT_Record,	CDNS_TXT_RecordPropertyPage		> CDNS_TXT_RecordNode;	
typedef CDNSRecordNode<	CDNS_X25_Record,	CDNS_X25_RecordPropertyPage		> CDNS_X25_RecordNode;

typedef CDNSRecordNode<CDNS_WKS_Record,		CDNS_WKS_RecordPropertyPage		> CDNS_WKS_RecordNode; 

typedef CDNSRecordNode<CDNS_SRV_Record,		CDNS_SRV_RecordPropertyPage		> CDNS_SRV_RecordNode; 

typedef CDNSRecordNode<CDNS_SIG_Record,		CDNS_SIG_RecordPropertyPage		> CDNS_SIG_RecordNode; 
typedef CDNSRecordNode<CDNS_KEY_Record,		CDNS_KEY_RecordPropertyPage		> CDNS_KEY_RecordNode; 
typedef CDNSRecordNode<CDNS_NXT_Record,   CDNS_NXT_RecordPropertyPage   > CDNS_NXT_RecordNode;


////////////////////////////////////////////////////////////////////////////
// special nodes that do not have property pages by their own
// unless they are in the cache

#define RR_HOLDER_SOA		1
#define RR_HOLDER_NS		2
#define RR_HOLDER_WINS	3

#include "zoneui.h" // SOA RR page

class CDNS_SOA_RecordNode : public CDNSRecordDelegatePPageNode< CDNS_SOA_Record, RR_HOLDER_SOA> 
{
public:
	DWORD GetMinTTL()
	{
		ASSERT(m_pDNSRecord != NULL);
		ASSERT(m_pDNSRecord->GetType() == DNS_TYPE_SOA);
		return ((CDNS_SOA_Record*)m_pDNSRecord)->m_dwMinimumTtl;
	}
protected:
	virtual void CreatePropertyPages(CDNSRecordPropertyPage** pPageArray, int* pNmax)
	{
		ASSERT(ZoneIsCache());

		ASSERT(*pNmax == 0);
    *pNmax = 1;
		pPageArray[0] = new CDNSZone_SOA_PropertyPage(FALSE);
	}

};

class CDNS_NS_RecordNode : public CDNSRecordDelegatePPageNode< CDNS_NS_Record, RR_HOLDER_NS> 
{
public:

protected:
	virtual void CreatePropertyPages(CDNSRecordPropertyPage** pPageArray, int* pNmax)
	{
    ASSERT(ZoneIsCache());

		ASSERT(*pNmax == 0);
    *pNmax = 1;
		pPageArray[0] = new CDNS_NSCache_RecordPropertyPage();
	}
};

class CDNS_NBSTAT_RecordNode : public CDNSRecordDelegatePPageNode< CDNS_NBSTAT_Record, RR_HOLDER_WINS >  
{
public:
  virtual BOOL HasPropertyPages(DATA_OBJECT_TYPES type, 
                                BOOL* pbHideVerb,
                                CNodeList* pNodeList)
  {
    if (pNodeList->GetCount() > 1) // multiple selection
    {
      return FALSE;
    }

    if (ZoneIsCache())
      return FALSE;

    return CDNSRecordNodeBase::HasPropertyPages(type, pbHideVerb, pNodeList);
  }
protected:
	virtual void CreatePropertyPages(CDNSRecordPropertyPage**, int* pNmax)
	{
		// this function should NEVER be called, because this record type
		// is never created fron the RR Wiz and does not have PP's
		ASSERT(*pNmax == 0);
		*pNmax = 0;
	}

};

class  CDNS_WINS_RecordNode : public CDNSRecordDelegatePPageNode< CDNS_WINS_Record, RR_HOLDER_WINS >
{
public:
  virtual BOOL HasPropertyPages(DATA_OBJECT_TYPES type, 
                                BOOL* pbHideVerb,
                                CNodeList* pNodeList)
  {
    if (pNodeList->GetCount() > 1) // multiple selection
    {
      return FALSE;
    }

    if (ZoneIsCache())
      return FALSE;

    return CDNSRecordNodeBase::HasPropertyPages(type, pbHideVerb, pNodeList);
  }
protected:
	virtual void CreatePropertyPages(CDNSRecordPropertyPage**, int* pNmax)
	{
		// this function should NEVER be called, because this record type
		// is never created fron the RR Wiz and does not have PP's
		ASSERT(*pNmax == 0);
		*pNmax = 0;
	}

};


////////////////////////////////////////////////////////////////////////////
// special data structures and definitions to handle NS record editing

////////////////////////////////////////////////////////////////////////////
// CDNS_NS_RecordNodeList
// used in domain node(s) (domain, zone and root hints)

class CDNS_NS_RecordNodeList : public CList< CDNS_NS_RecordNode*, CDNS_NS_RecordNode* > {};

////////////////////////////////////////////////////////////////////////////
// CDNSRecordNodeEditInfo

class CDNSRecordNodeEditInfoList; // fwd decl

class CDNSRecordNodeEditInfo
{
public:
	typedef enum { unchanged = 0, add, remove, edit, none } actionType;

	CDNSRecordNodeEditInfo();
	~CDNSRecordNodeEditInfo();
	void CreateFromExistingRecord(CDNSRecordNodeBase* pNode, BOOL bOwnMemory, BOOL bUpdateUI);
	void CreateFromNewRecord(CDNSRecordNodeBase* pNode);

	DNS_STATUS Update(CDNSDomainNode* pDomainNode, CComponentDataObject* pComponentData);
	DNS_STATUS Remove(CDNSDomainNode* pDomainNode, CComponentDataObject* pComponentData);

private:
	void Cleanup();

public:
	CDNSRecordNodeBase*			m_pRecordNode;
	CDNSRecord*					m_pRecord;
	CDNSRecordNodeEditInfoList*	m_pEditInfoList;	// list of associated records
	BOOL						m_bExisting;		// it exists in the UI or in the server
	BOOL						m_bUpdateUI;		// change the UI data structures
	BOOL						m_bOwnMemory;		// own memory pointed by m_pRecordNode
  BOOL            m_bFromDnsQuery;  // the record was obtained through DnsQuery not from the server
	actionType					m_action;			// action to be performed when committing
	DNS_STATUS					m_dwErr;			// error code when committing
};

class CDNSRecordNodeEditInfoList : public CList< CDNSRecordNodeEditInfo*, CDNSRecordNodeEditInfo* > 
{
public:
	CDNSRecordNodeEditInfoList() { }
	~CDNSRecordNodeEditInfoList() { RemoveAllNodes(); }

	void RemoveAllNodes() 
	{	
		while (!IsEmpty())
		{
			CDNSRecordNodeEditInfo* p = RemoveTail();
			delete p;
		}
	}
};


////////////////////////////////////////////////////////////////////////////
// CDNSRecordInfo : table driven info for record types

#define MAX_RECORD_RESOURCE_STRLEN (1024) // lenght of the string in the RC file
#define DNS_RECORD_INFO_END_OF_TABLE ((UINT)-1)  // for looping through record resource tables


// flags for record info entries
#define DNS_RECORD_INFO_FLAG_UICREATE          (0x00000001)  // can create through UI
#define DNS_RECORD_INFO_FLAG_CREATE_AT_NODE    (0x00000002)  // can create at the node
#define DNS_RECORD_INFO_FLAG_SHOW_NXT          (0x00000004)  // can show the record in the NXT property page
#define DNS_RECORD_INFO_FLAG_WHISTLER_OR_LATER (0x00000008)  // the record will only show up if targetting a Whistler server

#define DNS_RECORD_INFO_FLAG_UICREATE_AT_NODE  \
          (DNS_RECORD_INFO_FLAG_UICREATE | DNS_RECORD_INFO_FLAG_CREATE_AT_NODE)

struct DNS_RECORD_INFO_ENTRY
{
	WORD wType;					// as in dnsapi.h for record types
	LPCWSTR lpszShortName;		// e.g. "SOA"
	LPCWSTR lpszFullName;		// e.g. "Start of Authority"
	LPCWSTR lpszDescription;	// e.g. "Record used for..."
	UINT	nResourceID;		// string resource ID in the RC file
	WCHAR	cStringData[MAX_RECORD_RESOURCE_STRLEN];// e.g. "Start of Authority\nRecord used for..."
  DWORD dwFlags;
};

class CDNSRecordInfo
{
public:
	enum stringType { shortName, fullName, description}; 
  static const DNS_RECORD_INFO_ENTRY* GetTypeEntry(WORD wType);
	static LPCWSTR GetTypeString(WORD wType, stringType type);
  static LPCWSTR GetAtTheNodeDisplayString()
            { return m_szAtTheNodeDisplayString;}
	static const DNS_RECORD_INFO_ENTRY* GetEntry(int nIndex);
	static const DNS_RECORD_INFO_ENTRY* GetEntryFromName(LPCWSTR lpszName);
	static CDNSRecordNodeBase* CreateRecordNodeFromRPCData(LPCTSTR lpszName,
										DNS_RPC_RECORD* pDnsRecord, BOOL bAtTheNode);
	static CDNSRecordNodeBase* CreateRecordNode(WORD wType);
	static const DNS_RECORD_INFO_ENTRY* GetInfoEntryTable();
 
	static BOOL LoadResources();

private:
  static CString m_szAtTheNodeDisplayString;

};


#endif // _RECORD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\recpag1.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       recpag1.cpp
//
//--------------------------------------------------------------------------



#include "preDNSsn.h"
#include <SnapBase.h>

#include "resource.h"
#include "dnsutil.h"
#include "DNSSnap.h"
#include "snapdata.h"

#include "server.h"
#include "domain.h"

#include "record.h"

#ifdef DEBUG_ALLOCATOR
	#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
	#endif
#endif


#define DISPLAY_KEY_BASE_COUNT 2
#define HEX_DISPLAY_INDEX     0
#define BASE64_DISPLAY_INDEX  1


////////////////////////////////////////////////////////////////////////////
// CDNS_Unk_RecordPropertyPage

CDNS_Unk_RecordPropertyPage::CDNS_Unk_RecordPropertyPage()
						 : CDNSRecordStandardPropertyPage(IDD_RR_UNK)
{

}

void CDNS_Unk_RecordPropertyPage::SetUIData()
{
	STANDARD_REC_PP_SETUI_PROLOGUE(CDNS_Null_Record);
	// set record type field
	CString szBuf;
	CStatic* pType = (CStatic*)GetDlgItem(IDC_TYPE_STATIC);
	szBuf.Format(_T("%d (0x%x)"), pRecord->m_wType, pRecord->m_wType);
	pType->SetWindowText(szBuf);

	// set data type field
	CStatic* pSize = (CStatic*)GetDlgItem(IDC_SIZE_STATIC);
	szBuf.Format(_T("%d (0x%x)"), pRecord->m_blob.GetSize(), pRecord->m_blob.GetSize());
	pSize->SetWindowText(szBuf);

	LoadHexDisplay();
}

BOOL CDNS_Unk_RecordPropertyPage::OnInitDialog()
{
	CDNSRecordStandardPropertyPage::OnInitDialog();

	CEdit* pEdit = GetEditBox();
	ASSERT(pEdit != NULL);
	VERIFY(m_font.CreatePointFont(120,_T("fixedsys")));
	pEdit->SetFont(&m_font);

	return TRUE;
}


#define MAX_LINE_SIZE 64
#define HEX_BUF_SIZE 12
#define CH_BUF_SIZE 5

void CDNS_Unk_RecordPropertyPage::LoadHexDisplay()
{
	CDNSRecordPropertyPageHolder* pHolder = GetDNSRecordHolder();
	CDNS_Null_Record* pRecord = (CDNS_Null_Record*)pHolder->GetTempDNSRecord();

	UINT nBytes = pRecord->m_blob.GetSize();
	BYTE* pData = pRecord->m_blob.GetData();
	UINT nLines = nBytes/4; // # of complete lines
	if (nLines*4 < nBytes)
		nLines++; // add one truncated line

	TCHAR* pMem = (TCHAR*)malloc(sizeof(TCHAR)*MAX_LINE_SIZE*nLines);
  if (!pMem)
  {
    ASSERT(FALSE);
    return;
  }
	TCHAR* pBuf = pMem;

	CEdit* pEdit = GetEditBox();
	pEdit->SetReadOnly(FALSE);

	// walk the blob and write to the display buffer
	for(UINT k=0; k<nLines; k++)
	{
		UINT i;
		BYTE* pOffset = (pData+4*k);
		UINT nBytesThisLine = min(nBytes - 4*k,4);
		
		// get the values for the hex representation
		TCHAR chHex[HEX_BUF_SIZE]; // "xx" * 4 fields 
		for (i=0;i<HEX_BUF_SIZE-1;i++) chHex[i] = TEXT(' ');

		for (i=0;i<nBytesThisLine;i++)
		{
			BYTE high = static_cast<BYTE>(*(pOffset+i) >> 4);
			BYTE low = static_cast<BYTE>(*(pOffset+i) & 0x0f);
			// just offset out of the ASCII table
			*(chHex+3*i) =  static_cast<TCHAR>((high <= 9) ? (high + TEXT('0')) : ( high - 10 + TEXT('a')));
			*(chHex+3*i+1) = static_cast<TCHAR>((low <= 9) ? (low + TEXT('0')) : ( low - 10 + TEXT('a')));
			*(chHex+3*i+2) = TEXT(' ');
		}
		chHex[HEX_BUF_SIZE-1] = NULL;
		
		// get the values for the character representation
		TCHAR ch[CH_BUF_SIZE];
		for (i=0;i<CH_BUF_SIZE-1;i++) ch[i] = TEXT(' ');

		for (i=0;i<nBytesThisLine;i++)
		{
			// 1. assume the blob of data IS in ASCII 
			// 2. try to interpret bytes as ASCII printable chars
			// 3. if successful convert to UNICODE 
			if (isprint(*(pOffset+i)) && (*(pOffset+i) != '\0')) // compare ASCII
			{
				// convert from ASCII to UNICODE
				USES_CONVERSION;
				CHAR szTmp[2]; // ASCII
				szTmp[0] = *(pOffset+i);
				szTmp[1] = NULL;
				LPWSTR lpszW = A2W(szTmp); // convert
				ch[i] = lpszW[0]; // UNICODE
			}
			else 
				ch[i] = TEXT('?'); // unknown character or NULL, UNICODE
		}
		ch[CH_BUF_SIZE-1] = NULL;

		int nCharsPrinted = wsprintf(pBuf, _T("%.4x  %s  %s\r\n"), k*4, chHex,ch);
		pBuf = pBuf + nCharsPrinted;
	}
	// assign the buffer to the control and update
	pEdit->SetWindowText(pMem);
	pEdit->SetReadOnly(TRUE);
	pEdit->UpdateWindow();

  if (pMem)
  {
    free(pMem);
    pMem = 0;
  }
}



////////////////////////////////////////////////////////////////////////////
// CDNS_TXT_RecordPropertyPage

BEGIN_MESSAGE_MAP(CDNS_TXT_RecordPropertyPage, CDNSRecordStandardPropertyPage)
	ON_EN_CHANGE(IDC_RR_TXT_EDIT, OnTextEditBoxChange)
END_MESSAGE_MAP()


CDNS_TXT_RecordPropertyPage::CDNS_TXT_RecordPropertyPage()
						 : CDNSRecordStandardPropertyPage(IDD_RR_TXT)
{

}


void CDNS_TXT_RecordPropertyPage::SetUIData()
{
	CDNSRecordStandardPropertyPage::SetUIData();
	CDNSRecordPropertyPageHolder* pHolder = GetDNSRecordHolder();
	CDNS_TXT_Record* pRecord = (CDNS_TXT_Record*)pHolder->GetTempDNSRecord();

	SetEditBoxValue(pRecord->m_stringDataArray,pRecord->m_nStringDataCount);
	//SetDirty(FALSE);
}

DNS_STATUS CDNS_TXT_RecordPropertyPage::GetUIDataEx(BOOL bSilent)
{
	DNS_STATUS dwErr = 0;
  dwErr = CDNSRecordStandardPropertyPage::GetUIDataEx(bSilent);
	CDNSRecordPropertyPageHolder* pHolder = GetDNSRecordHolder();
	CDNS_TXT_Record* pRecord = (CDNS_TXT_Record*)pHolder->GetTempDNSRecord();

	GetEditBoxValue(pRecord->m_stringDataArray,&(pRecord->m_nStringDataCount));
  return dwErr;
}

void CDNS_TXT_RecordPropertyPage::OnTextEditBoxChange()
{
	SetDirty(TRUE);
}

void CDNS_TXT_RecordPropertyPage::SetEditBoxValue(CStringArray& sArr, int nSize)
{
	CString szBuf;
	szBuf.GetBufferSetLength(128); // just to avoid too many reallocations
	szBuf.ReleaseBuffer();
	for (int k=0;k<nSize;k++)
	{
		szBuf += sArr[k];
		if (k < nSize-1)
			szBuf += _T("\r\n");
	}
	GetTextEditBox()->SetWindowText(szBuf);
}

void CDNS_TXT_RecordPropertyPage::GetEditBoxValue(CStringArray& sArr, int* pNSize)
{
	CEdit* pEdit = GetTextEditBox();

	int nBufLen = pEdit->GetWindowTextLength() + 1;
	TCHAR* pMem = (TCHAR*) malloc(sizeof(TCHAR)*nBufLen);
  if (!pMem)
  {
    ASSERT(FALSE);
    return;
  }

	VERIFY(pEdit->GetWindowText(pMem, nBufLen) <= nBufLen);
	
	TCHAR *p1,*p2;
	p1=p2 = pMem;
	*pNSize = 0;
	while (TRUE)
	{
		if (*p2 == TEXT('\r'))
		{
			*p2 = NULL;
			sArr.SetAtGrow((*pNSize)++, p1);
			TRACE(_T("parsing<%s>\n"),(LPCTSTR)p1);
			p1 = p2+2;
			p2=p1;
		}
		else if (*p2 == NULL)
		{
			sArr.SetAtGrow((*pNSize)++, p1);
			TRACE(_T("parsing<%s>\n"),(LPCTSTR)p1);
			break;
		}
		else
			p2++;
	} 
	
  if (pMem)
  {
    free(pMem);
    pMem = 0;
  }
}

////////////////////////////////////////////////////////////////////////////

COMBOBOX_TABLE_ENTRY g_Algorithms[] = 
{
  { IDS_ALGORITHM_RSAMD5,   1   },
  { IDS_ALGORITHM_DIFFIE,   2   },
  { IDS_ALGORITHM_DSA,      3   },
  { IDS_ALGORITHM_ELIPTIC,  4   },
  { IDS_ALGORITHM_INDIRECT, 252 },
  { NULL, NULL }
};

COMBOBOX_TABLE_ENTRY g_Protocols[] = 
{
  { IDS_PROTOCOL_TLS,       1   },
  { IDS_PROTOCOL_EMAIL,     2   },
  { IDS_PROTOCOL_DNSSEC,    3   },
  { IDS_PROTOCOL_IPSEC,     4   },
  { IDS_PROTOCOL_ALL,       255 },
  { NULL, NULL }
};

////////////////////////////////////////////////////////////////////////////
// CDNS_SIG_RecordPropertyPage

BEGIN_MESSAGE_MAP(CDNS_SIG_RecordPropertyPage, CDNSRecordStandardPropertyPage)
  ON_EN_CHANGE(IDC_KEY_TAG_EDIT, OnSigEditChange)
  ON_EN_CHANGE(IDC_SIGNERS_NAME_EDIT, OnSigEditChange)
  ON_EN_CHANGE(IDC_ORIG_TTL, OnSigEditChange)
  ON_EN_CHANGE(IDC_SIG_EDIT, OnSigEditChange)
  ON_EN_CHANGE(IDC_LABELS_EDIT, OnSigEditChange)
  ON_CBN_SELCHANGE(IDC_RECORD_TYPE_COMBO, OnComboChange)
  ON_CBN_SELCHANGE(IDC_ALGORITHM_COMBO, OnComboChange)
  ON_NOTIFY(DTN_DATETIMECHANGE, IDC_EXP_DATE, OnDateTimeChange)
  ON_NOTIFY(DTN_DATETIMECHANGE, IDC_EXP_TIME, OnDateTimeChange)
  ON_NOTIFY(DTN_DATETIMECHANGE, IDC_INC_DATE, OnDateTimeChange)
  ON_NOTIFY(DTN_DATETIMECHANGE, IDC_INC_TIME, OnDateTimeChange)
END_MESSAGE_MAP()


CDNS_SIG_RecordPropertyPage::CDNS_SIG_RecordPropertyPage()
						 : CDNSRecordStandardPropertyPage(IDD_RR_SIG)
{
}

BOOL CDNS_SIG_RecordPropertyPage::OnInitDialog()
{
  CDNSRecordStandardPropertyPage::OnInitDialog();

	CDNSRecordStandardPropertyPage::SetUIData();
	CDNSRecordPropertyPageHolder* pHolder = GetDNSRecordHolder();
  CDNSRootData* pRootData = dynamic_cast<CDNSRootData*>(pHolder->GetDomainNode()->GetRootContainer());
  if (pRootData)
  {
    //
    // Load the type covered combo box
    //
	  DNS_RECORD_INFO_ENTRY* pTable = (DNS_RECORD_INFO_ENTRY*)CDNSRecordInfo::GetInfoEntryTable();
	  while (pTable->nResourceID != DNS_RECORD_INFO_END_OF_TABLE)
	  {
		  // some record types cannot be created with this wizard
      if (pTable->dwFlags & DNS_RECORD_INFO_FLAG_SHOW_NXT)
		  {
        PCWSTR pszDisplay = (pTable->lpszFullName);
			  LRESULT idx = SendDlgItemMessage(IDC_RECORD_TYPE_COMBO, CB_ADDSTRING, 0, (LPARAM)pszDisplay);
        if (idx != CB_ERR)
        {
          SendDlgItemMessage(IDC_RECORD_TYPE_COMBO, CB_SETITEMDATA, (WPARAM)idx, (LPARAM)pTable->wType);
        }
		  }
		  pTable++;
	  }
  }

  //
  // Load the Algorithms combo box
  //
  VERIFY(LoadComboBoxFromTable(reinterpret_cast<CComboBox*>(GetDlgItem(IDC_ALGORITHM_COMBO)),
                               g_Algorithms));

  //
  // Select the first item in the combo box
  //
  SendDlgItemMessage(IDC_ALGORITHM_COMBO, CB_SETCURSEL, 0, 0);

  //
  // Limit the key tag to 5 characters (0-65535)
  //
  SendDlgItemMessage(IDC_KEY_TAG_EDIT, EM_SETLIMITTEXT, (WPARAM)5, 0);

  //
  // NTRAID#NTBUG9-505387-2002/01/22-JeffJon
  // Set limit on the key so that we don't AV
  //
  SendDlgItemMessage(IDC_KEY_EDIT, EM_SETLIMITTEXT, (WPARAM)1024, 0);

  //
  // Limit the labels tag to 3 characters (1-127)
  //
  SendDlgItemMessage(IDC_LABELS_EDIT, EM_SETLIMITTEXT, (WPARAM)3, 0);

  return FALSE;
}

void CDNS_SIG_RecordPropertyPage::ConvertUIKeyStringToByteArray(BYTE* pByte, DWORD* pdwLength)
{
  CString szValue;

  GetDlgItemText(IDC_SIG_EDIT, szValue);

  //
  // Switch the value from base 64 to hex
  //
  DNS_STATUS err = Dns_SecurityBase64StringToKey(pByte, pdwLength, (PWSTR)(PCWSTR)szValue, szValue.GetLength());
  ASSERT(err == 0);
}

void CDNS_SIG_RecordPropertyPage::OnDateTimeChange(NMHDR*, LRESULT*)
{
  SetDirty(TRUE);
}

void CDNS_SIG_RecordPropertyPage::OnSigEditChange()
{
  SetDirty(TRUE);
}

void CDNS_SIG_RecordPropertyPage::OnComboChange()
{
  SetDirty(TRUE);
}

void CDNS_SIG_RecordPropertyPage::ShowSigValue(PBYTE pKey, DWORD dwKeySize)
{
  SetDlgItemText(IDC_SIG_EDIT, Base64BLOBToString(pKey, dwKeySize));
}

void CDNS_SIG_RecordPropertyPage::SetUIData()
{
	CDNSRecordStandardPropertyPage::SetUIData();
	CDNSRecordPropertyPageHolder* pHolder = GetDNSRecordHolder();
	CDNS_SIG_Record* pRecord = (CDNS_SIG_Record*)pHolder->GetTempDNSRecord();

  //
  // Set the type covered
  //
  m_wTypeCovered = pRecord->m_wTypeCovered;
  SelectTypeCoveredByType(pRecord->m_wTypeCovered);

  //
  // Set the algorithm
  //
  m_chAlgorithm = pRecord->m_chAlgorithm;
  SetComboSelByData(reinterpret_cast<CComboBox*>(GetDlgItem(IDC_ALGORITHM_COMBO)), pRecord->m_chAlgorithm);

  //
  // Set the label count
  //
  SetDlgItemInt(IDC_LABELS_EDIT, pRecord->m_chLabels);

  //
  // Set the signer's name
  //
  m_szSignerName = pRecord->m_szSignerName;
  SetDlgItemText(IDC_SIGNERS_NAME_EDIT, m_szSignerName);

  //
  // Set the signature value
  //
  ShowSigValue(pRecord->m_Signature.GetData(), pRecord->m_Signature.GetSize());

  //
  // Set the original TTL
  //
  m_dwOriginalTtl = pRecord->m_dwOriginalTtl;
  GetOrigTTL()->SetTTL(m_dwOriginalTtl);

  //
  // Get the local time zone information
  //
  TIME_ZONE_INFORMATION tzInfo;
  memset(&tzInfo, 0, sizeof(TIME_ZONE_INFORMATION));
  ::GetTimeZoneInformation(&tzInfo);

  //
  // Set the expiration TTL
  //
  m_dwExpiration = pRecord->m_dwExpiration;
  SYSTEMTIME stExpTime;
  ::ConvertTTLToSystemTime(&tzInfo, m_dwExpiration, &stExpTime);
  SendDlgItemMessage(IDC_EXP_DATE, DTM_SETSYSTEMTIME, (WPARAM)GDT_VALID, (LPARAM)&stExpTime);
  SendDlgItemMessage(IDC_EXP_TIME, DTM_SETSYSTEMTIME, (WPARAM)GDT_VALID, (LPARAM)&stExpTime);

  //
  // Set the inception TTL
  //
  m_dwTimeSigned = pRecord->m_dwTimeSigned;
  SYSTEMTIME stIncTime;
  ::ConvertTTLToSystemTime(&tzInfo, m_dwTimeSigned, &stIncTime);
  SendDlgItemMessage(IDC_INC_DATE, DTM_SETSYSTEMTIME, (WPARAM)GDT_VALID, (LPARAM)&stIncTime);
  SendDlgItemMessage(IDC_INC_TIME, DTM_SETSYSTEMTIME, (WPARAM)GDT_VALID, (LPARAM)&stIncTime);

  //
  // Set key tag edit
  //
  m_wKeyTag = pRecord->m_wKeyFootprint;
  SetDlgItemInt(IDC_KEY_TAG_EDIT, m_wKeyTag, FALSE);
}

void CDNS_SIG_RecordPropertyPage::SelectTypeCoveredByType(WORD wType)
{
  LRESULT lCount = SendDlgItemMessage(IDC_RECORD_TYPE_COMBO, CB_GETCOUNT, 0, 0);
  if (lCount != CB_ERR)
  {
    for (LRESULT lIdx = 0; lIdx < lCount; lIdx++)
    {
      LRESULT lData = SendDlgItemMessage(IDC_RECORD_TYPE_COMBO, CB_GETITEMDATA, (WPARAM)lIdx, 0);
      if (lData != CB_ERR)
      {
        if (wType == static_cast<WORD>(lData))
        {
          SendDlgItemMessage(IDC_RECORD_TYPE_COMBO, CB_SETCURSEL, (WPARAM)lIdx, 0);
          break;
        }
      }
    }
  }
}

DNS_STATUS CDNS_SIG_RecordPropertyPage::GetUIDataEx(BOOL bSilent)
{
	DNS_STATUS dwErr = CDNSRecordStandardPropertyPage::GetUIDataEx(bSilent);
	CDNSRecordPropertyPageHolder* pHolder = GetDNSRecordHolder();
	CDNS_SIG_Record* pRecord = (CDNS_SIG_Record*)pHolder->GetTempDNSRecord();

  //
  // Get the type covered
  //
  LRESULT lTypeIdx = SendDlgItemMessage(IDC_RECORD_TYPE_COMBO, CB_GETCURSEL, 0, 0);
  if (lTypeIdx != CB_ERR)
  {
    LRESULT lTypeData = SendDlgItemMessage(IDC_RECORD_TYPE_COMBO, CB_GETITEMDATA, (WPARAM)lTypeIdx, 0);
    if (lTypeData != CB_ERR)
    {
      pRecord->m_wTypeCovered = static_cast<WORD>(lTypeData);
    }
  }

  //
  // Get the algorithm
  //
  LRESULT lAlgorithmIdx = SendDlgItemMessage(IDC_ALGORITHM_COMBO, CB_GETCURSEL, 0, 0);
  if (lAlgorithmIdx != CB_ERR)
  {
    pRecord->m_chAlgorithm = static_cast<BYTE>(SendDlgItemMessage(IDC_ALGORITHM_COMBO, CB_GETITEMDATA, (WPARAM)lAlgorithmIdx, 0));
  }

  //
  // Get the labels count
  //
  BOOL bLabelSuccess = FALSE;
  int iLabelVal = GetDlgItemInt(IDC_LABELS_EDIT, &bLabelSuccess, FALSE);
  if (bLabelSuccess)
  {
    if (iLabelVal > 127)
    {
      iLabelVal = 127;
      SetDlgItemInt(IDC_KEY_TAG_EDIT, iLabelVal, FALSE);
      if (!bSilent)
      {
        DNSMessageBox(IDS_MSG_SIG_LABEL_RANGE);
      }
    }
    pRecord->m_chLabels = static_cast<BYTE>(iLabelVal);
  }

  //
  // Get the original ttl
  //
  GetOrigTTL()->GetTTL(&pRecord->m_dwOriginalTtl);

  //
  // Get the expiration date
  //
  SYSTEMTIME stExpDate;
  memset(&stExpDate, 0, sizeof(SYSTEMTIME));
  LRESULT lExpDateRes = SendDlgItemMessage(IDC_EXP_DATE, DTM_GETSYSTEMTIME, 0, (LPARAM)&stExpDate);
  if (lExpDateRes == GDT_VALID)
  {
    SYSTEMTIME stExpTime;
    memset(&stExpTime, 0, sizeof(SYSTEMTIME));
    LRESULT lExpTimeRes = SendDlgItemMessage(IDC_EXP_TIME, DTM_GETSYSTEMTIME, 0, (LPARAM)&stExpTime);
    if (lExpTimeRes == GDT_VALID)
    {
      stExpDate.wHour = stExpTime.wHour;
      stExpDate.wMinute = stExpTime.wMinute;
      stExpDate.wSecond = stExpTime.wSecond;
      stExpDate.wMilliseconds = stExpTime.wMilliseconds;

      pRecord->m_dwExpiration = ConvertSystemTimeToTTL(&stExpDate);
    }
  }

  //
  // Get the inception date
  //
  SYSTEMTIME stIncDate;
  memset(&stIncDate, 0, sizeof(SYSTEMTIME));
  LRESULT lIncDateRes = SendDlgItemMessage(IDC_INC_DATE, DTM_GETSYSTEMTIME, 0, (LPARAM)&stIncDate);
  if (lIncDateRes == GDT_VALID)
  {
    SYSTEMTIME stIncTime;
    memset(&stIncTime, 0, sizeof(SYSTEMTIME));
    LRESULT lIncTimeRes = SendDlgItemMessage(IDC_INC_TIME, DTM_GETSYSTEMTIME, 0, (LPARAM)&stIncTime);
    if (lIncTimeRes == GDT_VALID)
    {
      stIncDate.wHour = stIncTime.wHour;
      stIncDate.wMinute = stIncTime.wMinute;
      stIncDate.wSecond = stIncTime.wSecond;
      stIncDate.wMilliseconds = stIncTime.wMilliseconds;

      pRecord->m_dwTimeSigned = ConvertSystemTimeToTTL(&stIncDate);
    }
  }

  //
  // Get the key tag
  //
  BOOL bSuccess = FALSE;
  int iVal = GetDlgItemInt(IDC_KEY_TAG_EDIT, &bSuccess, FALSE /*unsigned*/);
  if (bSuccess)
  {
    pRecord->m_wKeyFootprint = static_cast<WORD>(iVal);
  }

  //
  // Get the signer's name
  //
  GetDlgItemText(IDC_SIGNERS_NAME_EDIT, pRecord->m_szSignerName);

  //
  // Get the key
  //
  DWORD dwLength;
  CString szValue;
  GetDlgItemText(IDC_SIG_EDIT, szValue);

  //
  // Switch the value from base 64 to byte array
  //

  //
  // The conversion function is expecting characters in multiples of 4. So if we have
  // a string that does not have a multiple of 4 number of characters, pad the string
  // with the pad character, except if the string requires more than 2 pad characters.
  // RFC 2535 Appendix A doesn't address the issue where string length % 4 == 3. In this
  // case we will show an error.
  //
  int iLengthMod4 = szValue.GetLength() % 4;
  int iPads = 4 - iLengthMod4;
  if (iLengthMod4 == 1)
  {
     if (!bSilent)
     {
       dwErr = ERROR_INVALID_PARAMETER;
       ::DNSErrorDialog(dwErr, IDS_ERRMSG_BASE64);
       return dwErr;
     }
  }
  else if (iPads != 0 && iPads != 4)
  {
    for (int i = 0; i < iPads; i++)
    {
      szValue += SECURITY_PAD_CHAR;
    }
  }

  ASSERT(szValue.GetLength() % 4 == 0);

  // The largest string will have 4 characters for every 3 bytes in the string

  DWORD maxDataLength = (szValue.GetLength() / 4) * 3;
  BYTE* pByte = new BYTE[maxDataLength];
  if (pByte)
  {
    ZeroMemory(pByte, sizeof(BYTE) * maxDataLength);

    dwErr = Dns_SecurityBase64StringToKey(pByte, &dwLength, (PWSTR)(PCWSTR)szValue, szValue.GetLength());
    if (dwErr != ERROR_SUCCESS)
    {
      if (!bSilent)
      {
        ::DNSErrorDialog(dwErr, IDS_ERRMSG_BASE64);
      }
    }
    else
    {
      pRecord->m_Signature.Set(pByte, dwLength);
    }

    // The CByteBlob::Set does a copy so we are OK to delete here

    delete[] pByte;
  }
  return dwErr;
}

////////////////////////////////////////////////////////////////////////////
// CDNS_KEY_RecordPropertyPage

BEGIN_MESSAGE_MAP(CDNS_KEY_RecordPropertyPage, CDNSRecordStandardPropertyPage)
  ON_EN_CHANGE(IDC_KEY_EDIT, OnEditChange)
  ON_CBN_SELCHANGE(IDC_KEY_TYPE_COMBO, OnKeyTypeChange)
  ON_CBN_SELCHANGE(IDC_NAME_TYPE_COMBO, OnNameTypeChange)
  ON_CBN_SELCHANGE(IDC_PROTOCOL_COMBO, OnProtocolChange)
  ON_CBN_SELCHANGE(IDC_ALGORITHM_COMBO, OnAlgorithmChange)
	ON_CLBN_CHKCHANGE(IDC_LOGGING_OPTIONS_LIST, OnSignatoryChange)
END_MESSAGE_MAP()


CDNS_KEY_RecordPropertyPage::CDNS_KEY_RecordPropertyPage()
						 : CDNSRecordStandardPropertyPage(IDD_RR_KEY)
{
}


BOOL CDNS_KEY_RecordPropertyPage::OnInitDialog()
{
  CDNSRecordStandardPropertyPage::OnInitDialog();

  VERIFY(LoadStringsToComboBox(_Module.GetModuleInstance(),
                               reinterpret_cast<CComboBox*>(GetDlgItem(IDC_KEY_TYPE_COMBO)),
                               IDS_KEY_TYPES,
                               256,
                               KEY_TYPE_COUNT));
  VERIFY(LoadStringsToComboBox(_Module.GetModuleInstance(),
                               reinterpret_cast<CComboBox*>(GetDlgItem(IDC_NAME_TYPE_COMBO)),
                               IDS_NAME_TYPES,
                               256,
                               NAME_TYPE_COUNT));

  //
  // Load the Protocol combo box
  //
  VERIFY(LoadComboBoxFromTable(reinterpret_cast<CComboBox*>(GetDlgItem(IDC_PROTOCOL_COMBO)),
                               g_Protocols));
  SendDlgItemMessage(IDC_PROTOCOL_COMBO, CB_SETCURSEL, 0, 0);

  //
  // Load the Algorithms combo box
  //
  VERIFY(LoadComboBoxFromTable(reinterpret_cast<CComboBox*>(GetDlgItem(IDC_ALGORITHM_COMBO)),
                               g_Algorithms));
  SendDlgItemMessage(IDC_ALGORITHM_COMBO, CB_SETCURSEL, 0, 0);

  //
  // Subclass the check list box for the signatory field
  //
  VERIFY(m_SignatoryCheckListBox.SubclassDlgItem(IDC_LOGGING_OPTIONS_LIST, this));
  m_SignatoryCheckListBox.SetCheckStyle(BS_AUTOCHECKBOX);

  CString szTemp;
  VERIFY(szTemp.LoadString(IDS_ZONE));
  m_SignatoryCheckListBox.AddString(szTemp);
  
  VERIFY(szTemp.LoadString(IDS_STRONG));
  m_SignatoryCheckListBox.AddString(szTemp);

  VERIFY(szTemp.LoadString(IDS_UNIQUE));
  m_SignatoryCheckListBox.AddString(szTemp);

  SendDlgItemMessage(IDC_BITFIELD_EDIT, EM_SETLIMITTEXT, (WPARAM)sizeof(WORD) * 8, 0);

  //
  // NTRAID#NTBUG9-505387-2002/01/22-JeffJon
  // Set limit on the key so that we don't AV
  //
  SendDlgItemMessage(IDC_SIG_EDIT, EM_SETLIMITTEXT, (WPARAM)1024, 0);

  CEdit* pBitEdit = (CEdit*)GetDlgItem(IDC_BITFIELD_EDIT);
  if (pBitEdit != NULL)
  {
    pBitEdit->SetReadOnly(TRUE);
  }
  SetDirty(FALSE);
  return TRUE;
}

void CDNS_KEY_RecordPropertyPage::OnEditChange()
{
  SetDirty(TRUE);
}

void CDNS_KEY_RecordPropertyPage::OnKeyTypeChange()
{
  LRESULT lSel = SendDlgItemMessage(IDC_KEY_TYPE_COMBO, CB_GETCURSEL, 0, 0);
  if (lSel != CB_ERR)
  {
    //
    // Clear key type bits
    //
    m_wFlags &= ~(0xc000);

    if (lSel == 2)
    {
      m_wFlags |= 0x0000;
    }
    else if (lSel == 1)
    {
      m_wFlags |= 0x4000;
    }
    else if (lSel == 0)
    {
      m_wFlags |= 0x8000;
    }
    else // lSel == 3
    {
      m_wFlags |= 0xc000;
    }
  }
  
  ShowBitField(m_wFlags);
  SetDirty(TRUE);
}

void CDNS_KEY_RecordPropertyPage::OnNameTypeChange()
{
  LRESULT lSel = SendDlgItemMessage(IDC_NAME_TYPE_COMBO, CB_GETCURSEL, 0, 0);
  if (lSel != CB_ERR)
  {
    //
    // Clear key type bits
    //
    m_wFlags &= ~(0x00000300);

    if (lSel == 0)
    {
      m_wFlags |= 0x00000000;
    }
    else if (lSel == 1)
    {
      m_wFlags |= 0x00000100;
    }
    else if (lSel == 2)
    {
      m_wFlags |= 0x00000200;
    }
    else // shouldn't have more than 3
    {
      ASSERT(FALSE);
    }
  }

  ShowBitField(m_wFlags);
  SetDirty(TRUE);
}

void CDNS_KEY_RecordPropertyPage::OnSignatoryChange()
{
  int iZoneCheck = m_SignatoryCheckListBox.GetCheck(0);
  int iStrongCheck = m_SignatoryCheckListBox.GetCheck(1);
  int iUniqueCheck = m_SignatoryCheckListBox.GetCheck(2);

  if (iZoneCheck == 1)
  {
    m_wFlags |= 0x1;
  }
  else
  {
    m_wFlags &= ~(0x1);
  }

  if (iStrongCheck == 1)
  {
    m_wFlags |= 0x2;
  }
  else
  {
    m_wFlags &= ~(0x2);
  }

  if (iUniqueCheck == 1)
  {
    m_wFlags |= 0x4;
  }
  else
  {
    m_wFlags &= ~(0x4);
  }

  ShowBitField(m_wFlags);
  SetDirty(TRUE);
}


void CDNS_KEY_RecordPropertyPage::OnProtocolChange()
{
  LRESULT lProtocolSel = SendDlgItemMessage(IDC_PROTOCOL_COMBO, CB_GETCURSEL, 0, 0);
  if (lProtocolSel != CB_ERR)
  {
    m_chProtocol = static_cast<BYTE>(SendDlgItemMessage(IDC_PROTOCOL_COMBO, CB_GETITEMDATA, (WPARAM)lProtocolSel, 0));
  }
  SetDirty(TRUE);
}

void CDNS_KEY_RecordPropertyPage::OnAlgorithmChange()
{
  LRESULT lAlgorithmSel = SendDlgItemMessage(IDC_ALGORITHM_COMBO, CB_GETCURSEL, 0, 0);
  if (lAlgorithmSel != CB_ERR)
  {
    m_chAlgorithm = static_cast<BYTE>(SendDlgItemMessage(IDC_ALGORITHM_COMBO, CB_GETITEMDATA, (WPARAM)lAlgorithmSel, 0));
  }
  SetDirty(TRUE);
}

void CDNS_KEY_RecordPropertyPage::SetUIData()
{
	CDNSRecordStandardPropertyPage::SetUIData();
	CDNSRecordPropertyPageHolder* pHolder = GetDNSRecordHolder();
	CDNS_KEY_Record* pRecord = (CDNS_KEY_Record*)pHolder->GetTempDNSRecord();

  SetComboSelByData(reinterpret_cast<CComboBox*>(GetDlgItem(IDC_PROTOCOL_COMBO)), pRecord->m_chProtocol);
  SetComboSelByData(reinterpret_cast<CComboBox*>(GetDlgItem(IDC_ALGORITHM_COMBO)), pRecord->m_chAlgorithm);
  
  m_chProtocol = pRecord->m_chProtocol;
  m_chAlgorithm = pRecord->m_chAlgorithm;
  m_wFlags = pRecord->m_wFlags;

  //
  // Fill in the flags fields
  //
  ShowBitField(pRecord->m_wFlags);
  ShowKeyType(pRecord->m_wFlags);
  ShowNameType(pRecord->m_wFlags);
  ShowSignatory(pRecord->m_wFlags);
  
  ShowKeyValue(pRecord->m_Key.GetData(), pRecord->m_Key.GetSize());
}

void CDNS_KEY_RecordPropertyPage::ShowKeyValue(PBYTE pKey, DWORD dwKeySize)
{
  SetDlgItemText(IDC_KEY_EDIT, Base64BLOBToString(pKey, dwKeySize));
}

void CDNS_KEY_RecordPropertyPage::ShowBitField(WORD wFlags)
{
  CString szTempField;

  WORD wTemp = wFlags;
  for (size_t idx = 0; idx < sizeof(WORD) * 8; idx++)
  {
    if ((wTemp & (0x1 << idx)) == 0)
    {
      szTempField = L'0' + szTempField;
    }
    else
    {
      szTempField = L'1' + szTempField;
    }
  }

  SetDlgItemText(IDC_BITFIELD_EDIT, szTempField);
}

//
// REVIEW_JEFFJON : remove magic numbers
//
void CDNS_KEY_RecordPropertyPage::ShowKeyType(WORD wFlags)
{
  UINT nIdx = 0;

  //
  // Note: after the shift we are only concerned with the last two bits
  //
  WORD wKeyType = static_cast<WORD>(wFlags >> 14);
  if ((wKeyType & 0x3) == 0)
  {
    nIdx = 2;
  }
  else if ((wKeyType & 0x3) == 1)
  {
    nIdx = 1;
  }
  else if ((wKeyType & 0x3) == 2)
  {
    nIdx = 0;
  }
  else
  {
    nIdx = 3;
  }
  SendDlgItemMessage(IDC_KEY_TYPE_COMBO, CB_SETCURSEL, (WPARAM)nIdx, 0);
}

void CDNS_KEY_RecordPropertyPage::ShowNameType(WORD wFlags)
{
  UINT nIdx = (UINT)-1;

  //
  // Note: after the shift we are only concerned with the last two bits
  //
  WORD wKeyType = static_cast<WORD>(wFlags >> 8);
  if ((wKeyType & 0x3) == 0)
  {
    nIdx = 0;
  }
  else if ((wKeyType & 0x3) == 1)
  {
    nIdx = 1;
  }
  else if ((wKeyType & 0x3) == 2)
  {
    nIdx = 2;
  }
  else
  {
    //
    // 11 is reserved and should not occur in this dialog
    //
    ASSERT(FALSE);
  }
  if (nIdx != (UINT)-1)
  {
    SendDlgItemMessage(IDC_NAME_TYPE_COMBO, CB_SETCURSEL, (WPARAM)nIdx, 0);
  }
}

void CDNS_KEY_RecordPropertyPage::ShowSignatory(WORD wFlags)
{
  //
  // Zone update?
  //
  if (wFlags & 0x1)
  {
    m_SignatoryCheckListBox.SetCheck(0, 1);
  }
  else
  {
    m_SignatoryCheckListBox.SetCheck(0, 0);
  }

  //
  // Strong update?
  //
  if (wFlags & 0x2)
  {
    m_SignatoryCheckListBox.SetCheck(1, 1);
  }
  else
  {
    m_SignatoryCheckListBox.SetCheck(1, 0);
  }

  //
  // Unique update?
  //
  if (wFlags & 0x4)
  {
    m_SignatoryCheckListBox.SetCheck(2, 1);
  }
  else
  {
    m_SignatoryCheckListBox.SetCheck(2, 0);
  }

}


DNS_STATUS CDNS_KEY_RecordPropertyPage::GetUIDataEx(BOOL bSilent)
{
	DNS_STATUS dwErr = CDNSRecordStandardPropertyPage::GetUIDataEx(bSilent);
	CDNSRecordPropertyPageHolder* pHolder = GetDNSRecordHolder();
	CDNS_KEY_Record* pRecord = (CDNS_KEY_Record*)pHolder->GetTempDNSRecord();

  pRecord->m_chAlgorithm = m_chAlgorithm;
  pRecord->m_chProtocol = m_chProtocol;
  pRecord->m_wFlags = m_wFlags;

  //
  // Get the key
  //
  DWORD dwLength;
  CString szValue;
  GetDlgItemText(IDC_KEY_EDIT, szValue);

  //
  // Switch the value from base 64 to byte array
  //

  //
  // The conversion function is expecting characters in multiples of 4. So if we have
  // a string that does not have a multiple of 4 number of characters, pad the string
  // with the pad character, except if the string requires more than 2 pad characters.
  // RFC 2535 Appendix A doesn't address the issue where string length % 4 == 3. In this
  // case we will show an error.
  //
  int iLengthMod4 = szValue.GetLength() % 4;
  int iPads = 4 - iLengthMod4;
  if (iLengthMod4 == 1)
  {
     if (!bSilent)
     {
       dwErr = ERROR_INVALID_PARAMETER;
       ::DNSErrorDialog(dwErr, IDS_ERRMSG_BASE64);
       return dwErr;
     }
  }
  else if (iPads != 0 && iPads != 4)
  {
    for (int i = 0; i < iPads; i++)
    {
      szValue += SECURITY_PAD_CHAR;
    }
  }

  ASSERT(szValue.GetLength() % 4 == 0);

  // The largest string will have 4 characters for every 3 bytes in the string

  DWORD maxDataLength = (szValue.GetLength() / 4) * 3;
  BYTE* pByte = new BYTE[maxDataLength];
  if (pByte)
  {
    ZeroMemory(pByte, sizeof(BYTE) * maxDataLength);

    dwErr = Dns_SecurityBase64StringToKey(pByte, &dwLength, (PWSTR)(PCWSTR)szValue, szValue.GetLength());
    if (dwErr != 0)
    {
       if (!bSilent)
       {
         DNSMessageBox(IDS_ERRMSG_BASE64);
       }
    }
    else
    {
      pRecord->m_Key.Set(pByte, dwLength);
    }

    // The CByteBlob::Set does a copy so we are OK to delete here

    delete[] pByte;
  }
  return dwErr;
}

////////////////////////////////////////////////////////////////////////////
// CDNS_NXT_RecordPropertyPage

BEGIN_MESSAGE_MAP(CDNS_NXT_RecordPropertyPage, CDNSRecordStandardPropertyPage)
  ON_EN_CHANGE(IDC_NEXT_DOMAIN_EDIT, OnNextDomainEdit)
	ON_CLBN_CHKCHANGE(IDC_LOGGING_OPTIONS_LIST, OnTypeCoveredChange)
END_MESSAGE_MAP()


CDNS_NXT_RecordPropertyPage::CDNS_NXT_RecordPropertyPage()
						 : CDNSRecordStandardPropertyPage(IDD_RR_NXT)
{
}

BOOL CDNS_NXT_RecordPropertyPage::OnInitDialog()
{
  CDNSRecordStandardPropertyPage::OnInitDialog();
 
  CDNSRecordPropertyPageHolder* pHolder = GetDNSRecordHolder();

	VERIFY(m_TypeCheckListBox.SubclassDlgItem(IDC_LOGGING_OPTIONS_LIST, this));
	m_TypeCheckListBox.SetCheckStyle(BS_AUTOCHECKBOX);

  CDNSRootData* pRootData = dynamic_cast<CDNSRootData*>(pHolder->GetDomainNode()->GetRootContainer());
  if (pRootData)
  {
	  DNS_RECORD_INFO_ENTRY* pTable = (DNS_RECORD_INFO_ENTRY*)CDNSRecordInfo::GetInfoEntryTable();
	  while (pTable->nResourceID != DNS_RECORD_INFO_END_OF_TABLE)
	  {
		  // some record types cannot be created with this wizard
      if (pTable->dwFlags & DNS_RECORD_INFO_FLAG_SHOW_NXT)
		  {
			  int idx = m_TypeCheckListBox.AddString(pTable->lpszFullName);
        if (idx != LB_ERR)
        {
          m_TypeCheckListBox.SetItemData(idx, pTable->wType);
          if (pTable->wType == DNS_TYPE_NXT)
          {
            m_TypeCheckListBox.Enable(idx, FALSE);
            m_TypeCheckListBox.SetCheck(idx, TRUE);
          }
        }
		  }
		  pTable++;
	  }
  }

  return TRUE;
}

void CDNS_NXT_RecordPropertyPage::OnNextDomainEdit()
{
  SetDirty(TRUE);
}

void CDNS_NXT_RecordPropertyPage::OnTypeCoveredChange()
{
  SetDirty(TRUE);
}

void CDNS_NXT_RecordPropertyPage::SetUIData()
{
	CDNSRecordStandardPropertyPage::SetUIData();
	CDNSRecordPropertyPageHolder* pHolder = GetDNSRecordHolder();
	CDNS_NXT_Record* pRecord = (CDNS_NXT_Record*)pHolder->GetTempDNSRecord();
  SendDlgItemMessage(IDC_NEXT_DOMAIN_EDIT, EM_SETLIMITTEXT, MAX_DNS_NAME_LEN, 0);
  SetDlgItemText(IDC_NEXT_DOMAIN_EDIT, pRecord->m_szNextDomain);

  for (DWORD dwIdx = 0; dwIdx < pRecord->m_wNumTypesCovered; dwIdx++)
  {
    SetTypeCheckForDNSType(pRecord->m_pwTypesCovered[dwIdx]);
  }
}

void CDNS_NXT_RecordPropertyPage::SetTypeCheckForDNSType(WORD wType)
{
  int iCount = m_TypeCheckListBox.GetCount();
  for (int idx = 0; idx < iCount; idx++)
  {
    DWORD_PTR dwData = m_TypeCheckListBox.GetItemData(idx);
    if (dwData != LB_ERR)
    {
      if (dwData == wType)
      {
        m_TypeCheckListBox.SetCheck(idx, TRUE);
      }
    }
  }
}

DNS_STATUS CDNS_NXT_RecordPropertyPage::GetUIDataEx(BOOL bSilent)
{
	DNS_STATUS dwErr = CDNSRecordStandardPropertyPage::GetUIDataEx(bSilent);
	CDNSRecordPropertyPageHolder* pHolder = GetDNSRecordHolder();
	CDNS_NXT_Record* pRecord = (CDNS_NXT_Record*)pHolder->GetTempDNSRecord();

  //
  // Get the next domain name
  //
  GetDlgItemText(IDC_NEXT_DOMAIN_EDIT, pRecord->m_szNextDomain);

  //
  // Get the types covered
  //
  int iCount = m_TypeCheckListBox.GetCount();
  int iNumChecked = 0;
  WORD* pTempTypesCovered = new WORD[iCount];
  if (pTempTypesCovered != NULL)
  {
    memset(pTempTypesCovered, 0, iCount * sizeof(WORD));

    for (int idx = 0; idx < iCount; idx++)
    {
      int iChecked = m_TypeCheckListBox.GetCheck(idx);
      if (iChecked == 1)
      {
        pTempTypesCovered[idx] = static_cast<WORD>(m_TypeCheckListBox.GetItemData(idx));
        iNumChecked++;
      }
    }

    //
    // Copy the covered types to the record
    //
    pRecord->m_wNumTypesCovered = static_cast<WORD>(iNumChecked);

    if (pRecord->m_pwTypesCovered != NULL)
    {
      delete[] pRecord->m_pwTypesCovered;
      pRecord->m_pwTypesCovered = NULL;
    }

    pRecord->m_pwTypesCovered = new WORD[pRecord->m_wNumTypesCovered];
    if (pRecord->m_pwTypesCovered != NULL)
    {
      int iTypeCoveredIdx = 0;
      for (int iTempCount = 0; iTempCount < iCount; iTempCount++)
      {
        if (pTempTypesCovered[iTempCount] != 0)
        {
          pRecord->m_pwTypesCovered[iTypeCoveredIdx] = pTempTypesCovered[iTempCount];
          iTypeCoveredIdx++;
        }
      }
    }
  }
  return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\recpag1.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       recpag1.h
//
//--------------------------------------------------------------------------


#ifndef _RECPAG1_H
#define _RECPAG1_H


////////////////////////////////////////////////////////////////////////////
// CDNS_Unk_RecordPropertyPage

class CDNS_Unk_RecordPropertyPage : public CDNSRecordStandardPropertyPage
{
public:
	CDNS_Unk_RecordPropertyPage();
protected:
	virtual void SetUIData();
	virtual BOOL OnInitDialog();

private:
	CFont m_font; // for the editbox
	CEdit* GetEditBox() { return (CEdit*)GetDlgItem(IDC_DATA_EDIT);}
	void LoadHexDisplay();
};




////////////////////////////////////////////////////////////////////////////
// CDNS_TXT_RecordPropertyPage

class CDNS_TXT_RecordPropertyPage : public CDNSRecordStandardPropertyPage
{
public:
	CDNS_TXT_RecordPropertyPage();
protected:
	virtual void SetUIData();
	virtual DNS_STATUS GetUIDataEx(BOOL bSilent = TRUE);

	afx_msg void OnTextEditBoxChange();

private:
	CEdit* GetTextEditBox() { return (CEdit*)GetDlgItem(IDC_RR_TXT_EDIT);}
	void SetEditBoxValue(CStringArray& sArr, int nSize);
	void GetEditBoxValue(CStringArray& sArr, int* pNSize);

	DECLARE_MESSAGE_MAP()
};

////////////////////////////////////////////////////////////////////////////
// CDNS_SIG_RecordPropertyPage

class CDNS_SIG_RecordPropertyPage : public CDNSRecordStandardPropertyPage
{
public:
	CDNS_SIG_RecordPropertyPage();
protected:
	virtual void SetUIData();
	virtual DNS_STATUS GetUIDataEx(BOOL bSilent = TRUE);

  virtual BOOL OnInitDialog();
  void SelectTypeCoveredByType(WORD wType);

  afx_msg void OnDateTimeChange(NMHDR* pNotifyStruct, LRESULT* result);
  afx_msg void OnSigEditChange();
  afx_msg void OnComboChange();

  void  ShowSigValue(PBYTE pByte, DWORD dwCount);
  void  ConvertUIKeyStringToByteArray(BYTE* pByte, DWORD* pdwLength);

  CDNSTTLControl* GetOrigTTL() { return (CDNSTTLControl*)GetDlgItem(IDC_ORIG_TTL); }

private:

  WORD            m_wTypeCovered;		// DNS_TYPE_<x>
  BYTE            m_chAlgorithm;		// 0,255 unsigned int
  BYTE            m_chLabels;			  // 0,255 unsigned int (count)
  DWORD           m_dwOriginalTtl;
  DWORD           m_dwExpiration;		// time in sec. from 1 Jan 1970
  DWORD           m_dwTimeSigned;		// time in sec. from 1 Jan 1970
  WORD            m_wKeyTag;	      // algorithm dependent
  CString         m_szSignerName;	
	DECLARE_MESSAGE_MAP()
};

////////////////////////////////////////////////////////////////////////////
// CDNS_KEY_RecordPropertyPage

class CDNS_KEY_Record;

class CDNS_KEY_RecordPropertyPage : public CDNSRecordStandardPropertyPage
{
public:
	CDNS_KEY_RecordPropertyPage();
protected:
  virtual BOOL OnInitDialog();
	virtual void SetUIData();
	virtual DNS_STATUS GetUIDataEx(BOOL bSilent = TRUE);

  void ShowBitField(WORD wFlags);
  void ShowKeyType(WORD wFlags);
  void ShowNameType(WORD wFlags);
  void ShowSignatory(WORD wFlags);
  void ShowKeyValue(PBYTE pByte, DWORD dwCount);

  afx_msg void OnEditChange();
  afx_msg void OnKeyTypeChange();
  afx_msg void OnNameTypeChange();
  afx_msg void OnSignatoryChange();
  afx_msg void OnProtocolChange();
  afx_msg void OnAlgorithmChange();

private:
  BYTE  m_chProtocol;
  BYTE  m_chAlgorithm;
  WORD  m_wFlags;
	CCheckListBox	m_SignatoryCheckListBox;

	DECLARE_MESSAGE_MAP()
};

////////////////////////////////////////////////////////////////////////////
// CDNS_NXT_RecordPropertyPage

class CDNS_NXT_RecordPropertyPage : public CDNSRecordStandardPropertyPage
{
public:
	CDNS_NXT_RecordPropertyPage();
protected:
	virtual void SetUIData();
	virtual DNS_STATUS GetUIDataEx(BOOL bSilent = TRUE);

  virtual BOOL OnInitDialog();
  afx_msg void OnNextDomainEdit();
  afx_msg void OnTypeCoveredChange();

  void SetTypeCheckForDNSType(WORD wType);

private:
	CCheckListBox	m_TypeCheckListBox;

	DECLARE_MESSAGE_MAP()
};

#endif // _RECPAG1_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\recordui.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       recordui.h
//
//--------------------------------------------------------------------------

#ifndef _RECORDUI_H
#define _RECORDUI_H

#include "uiutil.h"
#include "aclpage.h"

///////////////////////////////////////////////////////////////////////////////
// FORWARD DECLARATIONS

class CDNSRecord;
class CDNSRecordNodeBase;
class CDNSDomainNode;
class CDNSRecordPropertyPage;

////////////////////////////////////////////////////////////////////////
// CDNSRecordPropertyPageHolder
// page holder to contain DNS record property pages

#define DNS_RECORD_MAX_PROPRETY_PAGES (4) // max # of pages a record can have

class CDNSRecordPropertyPageHolder : public CPropertyPageHolderBase
{
public:
	CDNSRecordPropertyPageHolder(CDNSDomainNode* pDNSDomainNode, CDNSRecordNodeBase* pRecordNode, 
				CComponentDataObject* pComponentData, WORD wPredefinedRecordType = 0);
	virtual ~CDNSRecordPropertyPageHolder();

protected:
  virtual HRESULT OnAddPage(int nPage, CPropertyPageBase* pPage);

public:
	// simple cast helpers
	CDNSRecordNodeBase* GetRecordNode() { return (CDNSRecordNodeBase*)GetTreeNode();}
	void SetRecordNode(CDNSRecordNodeBase* pRecordNode) { SetTreeNode((CTreeNode*)pRecordNode); }
	CDNSDomainNode* GetDomainNode() { return (CDNSDomainNode*)GetContainerNode();}

	void AddPagesFromCurrentRecordNode(BOOL bAddToSheet);
	void RemovePagesFromCurrentRecordNode(BOOL bRemoveFromSheet);
	CDNSRecord* GetTempDNSRecord() { return m_pTempDNSRecord;}
	void SetTempDNSRecord(CDNSRecord* pTempDNSRecord) { m_pTempDNSRecord = pTempDNSRecord;}

	void SetRecordSelection(WORD wRecordType, BOOL bAddToSheet); // Wizard mode only
	DNS_STATUS CreateNewRecord(BOOL bAllowDuplicates);		// Wizard mode only
	virtual BOOL OnPropertyChange(BOOL bScopePane, long* pChangeMask); // Property Sheet only

  DNS_STATUS CreateNonExistentParentDomains(CDNSRecordNodeBase* pRecordNode, 
                                            /*IN/OUT*/CDNSDomainNode** ppNewParentDomain);

	BOOL HasPredefinedType() { return m_wPredefinedRecordType != 0;}
private:
	WORD m_wPredefinedRecordType; // Wizard mode only

	DNS_STATUS WriteCurrentRecordToServer();
	CDNSRecord* m_pTempDNSRecord;		// temporary DNS record to write to

	CDNSRecordPropertyPage* m_pRecordPropPagesArr[DNS_RECORD_MAX_PROPRETY_PAGES];
	int m_nRecordPages;

 	// optional security page
	CAclEditorPage*	m_pAclEditorPage;

};

//////////////////////////////////////////////////////////////////////////
// CSelectDNSRecordTypeDialog

struct DNS_RECORD_INFO_ENTRY;

class CSelectDNSRecordTypeDialog : public CHelpDialog
{

// Construction
public:
	CSelectDNSRecordTypeDialog(CDNSDomainNode* pDNSDomainNode, 
								CComponentDataObject* pComponentData);

// Implementation
protected:
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeTypeList();
	afx_msg void OnDoubleClickSelTypeList();
	afx_msg void OnCreateRecord();
	
private:
	// context pointers
	CDNSDomainNode*		m_pDNSDomainNode;
	CComponentDataObject* m_pComponentData;

	// manage the Cancel/Done button label
	BOOL						m_bFirstCreation;
	CDNSButtonToggleTextHelper m_cancelDoneTextHelper;

	void SyncDescriptionText();
	CListBox* GetRecordTypeListBox(){ return (CListBox*)GetDlgItem(IDC_RECORD_TYPE_LIST);}
	const DNS_RECORD_INFO_ENTRY* GetSelectedEntry();

	DECLARE_MESSAGE_MAP()

};


//////////////////////////////////////////////////////////////////////
// CDNSRecordPropertyPage
// common class for all the record property pages that have a TTL control

class CDNSRecordPropertyPage : public CPropertyPageBase
{
// Construction
public:
	CDNSRecordPropertyPage(UINT nIDTemplate, UINT nIDCaption = 0);
	virtual ~CDNSRecordPropertyPage();

// Overrides
public:
	virtual BOOL OnPropertyChange(BOOL bScopePane, long* pChangeMask);

  virtual BOOL CanCreateDuplicateRecords() { return TRUE; }

// Implementation
protected:
	virtual BOOL OnInitDialog();

	CDNSTTLControl* GetTTLCtrl();
  CButton* GetDeleteStale() { return (CButton*)GetDlgItem(IDC_DEFAULT_DELETE_STALE_RECORD); }
  CEdit* GetTimeStampEdit() { return (CEdit*)GetDlgItem(IDC_TIME_EDIT); }
  CStatic* GetTimeStampStatic() { return (CStatic*)GetDlgItem(IDC_STATIC_TIME_STAMP); }

	CDNSRecordPropertyPageHolder* GetDNSRecordHolder() // simple cast
	{	return  (CDNSRecordPropertyPageHolder*)GetHolder();}

  void EnableAgingCtrl(BOOL bShow);
	void EnableTTLCtrl(BOOL bShow);

  void SetValidState(BOOL bValid);

	// message map functions
	afx_msg void OnTTLChange();
  afx_msg void OnDeleteStaleRecord();
	
	DECLARE_MESSAGE_MAP()
};




//////////////////////////////////////////////////////////////////////
// CDNSRecordStandardPropertyPage
// common class for all the record property pages that have a TTL control
// and a common editbox. Besides the SOA and WINS property pages, all RR
// pages derive from this class


class CDNSRecordStandardPropertyPage : public CDNSRecordPropertyPage 
{

// Construction
public:
	CDNSRecordStandardPropertyPage(UINT nIDTemplate, UINT nIDCaption = 0);

// Overrides
public:
	virtual BOOL OnSetActive();		// down
	virtual BOOL OnKillActive();	// down
	virtual BOOL OnApply();			// look at new way of doing it

  virtual DNS_STATUS ValidateRecordName(PCWSTR pszName, DWORD dwNameChecking);

// Implementation
protected:

	// RR name handling
	virtual void OnInitName();
	virtual void OnSetName(CDNSRecordNodeBase* pRecordNode);
	virtual void OnGetName(CString& s);
	
	
  virtual CEdit* GetRRNameEdit() { return (CEdit*)GetDlgItem(IDC_RR_NAME_EDIT); }
	CEdit* GetDomainEditBox() { return(CEdit*)GetDlgItem(IDC_RR_DOMAIN_EDIT);}
	void GetEditBoxText(CString& s);

	virtual void SetUIData();
	virtual DNS_STATUS GetUIDataEx(BOOL bSilent = TRUE);

	virtual BOOL OnInitDialog();

	afx_msg void OnEditChange();

	virtual BOOL CreateRecord();
  void SetTimeStampEdit(DWORD dwScavengStart);

private:
	int m_nUTF8ParentLen;

  BOOL m_bAllowAtTheNode;

	DECLARE_MESSAGE_MAP()
};


// Useful macros for classes derived from CDNSRecordStandardPropertyPage 

#define STANDARD_REC_PP_PTRS(recType) \
	CDNSRecordPropertyPageHolder* pHolder = GetDNSRecordHolder(); \
	ASSERT(pHolder != NULL); \
	recType* pRecord = (recType*)pHolder->GetTempDNSRecord();\
	ASSERT(pRecord != NULL);

#define STANDARD_REC_PP_SETUI_PROLOGUE(recType) \
	CDNSRecordStandardPropertyPage::SetUIData(); \
	STANDARD_REC_PP_PTRS(recType)

#define STANDARD_REC_PP_GETUI_PROLOGUE(recType) \
	DNS_STATUS dwErr = CDNSRecordStandardPropertyPage::GetUIDataEx(bSilent); \
	STANDARD_REC_PP_PTRS(recType)



//
// This is a place holder for new pages
//
#if (FALSE)
///////////////////////////////////////////////////////////////////////
// CDNSRecordDummyPropertyPage

class CDNSRecordDummyPropertyPage : public CPropertyPageBase
{
public:
	CDNSRecordDummyPropertyPage();
	virtual BOOL OnApply();
	virtual void OnOK();
};

class CDNSDummyRecordPropertyPageHolder : public CPropertyPageHolderBase
{
public:
	CDNSDummyRecordPropertyPageHolder(CDNSDomainNode* pDNSDomainNode, CDNSRecordNodeBase* pRecordNode, 
				CComponentDataObject* pComponentData, WORD wPredefinedRecordType = 0);
	virtual ~CDNSDummyRecordPropertyPageHolder();

private:
	CDNSRecordDummyPropertyPage m_dummyPage;

};

#endif


#endif // _RECORDUI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\recpag2.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       recpag2.h
//
//--------------------------------------------------------------------------


#ifndef _RECPAG2_H
#define _RECPAG2_H

////////////////////////////////////////////////////////////////////////////
// CDNS_A_RecordPropertyPage

class CDNS_A_RecordPropertyPage : public CDNSRecordStandardPropertyPage
{
public:
	CDNS_A_RecordPropertyPage();
protected:
   virtual BOOL OnInitDialog();
	virtual void SetUIData();
	virtual DNS_STATUS GetUIDataEx(BOOL bSilent = TRUE);

	afx_msg void OnIPv4CtrlChange();
  afx_msg void OnCreatePointerClicked();

private:
	CDNSIPv4Control* GetIPv4Ctrl() { return (CDNSIPv4Control*)GetDlgItem(IDC_IPEDIT);}
	CButton* GetPTRCheckCtrl() { return (CButton*)GetDlgItem(IDC_UPDATE_PRT_CHECK);}
   CButton* GetSecurityCheckCtrl() { return (CButton*)GetDlgItem(IDC_UPDATE_SECURITY_CHECK);}

	DECLARE_MESSAGE_MAP()
};


////////////////////////////////////////////////////////////////////////////
// CDNS_ATMA_RecordPropertyPage

class CDNS_ATMA_RecordPropertyPage : public CDNSRecordStandardPropertyPage
{
public:
	CDNS_ATMA_RecordPropertyPage();
protected:
	virtual void SetUIData();
	virtual DNS_STATUS GetUIDataEx(BOOL bSilent = TRUE);

  afx_msg void OnAddressChange();
  afx_msg void OnFormatRadioChange();

private:

  UCHAR GetFormat();
  void SetFormat(UCHAR chFormat);

  CEdit* GetAddressCtrl() { return (CEdit*)GetDlgItem(IDC_EDIT_ATMA_ADDRESS);}
  CButton* GetRadioNSAP() { return (CButton*)GetDlgItem(IDC_RADIO_NSAP);}
  CButton* GetRadioE164() { return (CButton*)GetDlgItem(IDC_RADIO_E164);}

	DECLARE_MESSAGE_MAP()
};

////////////////////////////////////////////////////////////////////////////
// CDNS_AAAA_RecordPropertyPage

class CDNS_AAAA_RecordPropertyPage : public CDNSRecordStandardPropertyPage
{
public:
	CDNS_AAAA_RecordPropertyPage();
protected:

   // overloaded these to fix NTRAID#NTBUG9-335565-2001/04/24-sburns
   
   virtual BOOL CreateRecord();
   virtual BOOL OnInitDialog();
   virtual BOOL OnApply();
   
	virtual void SetUIData();
	virtual DNS_STATUS GetUIDataEx(BOOL bSilent = TRUE);

	afx_msg void OnIPv6CtrlChange();

private:
	CEdit* GetIPv6Edit() { return (CEdit*)GetDlgItem(IDC_IPV6EDIT);}

	DECLARE_MESSAGE_MAP()
};

////////////////////////////////////////////////////////////////////////////
// CDNS_HINFO_RecordPropertyPage

class CDNS_HINFO_RecordPropertyPage : public CDNSRecordStandardPropertyPage
{
public:
	CDNS_HINFO_RecordPropertyPage();
protected:
  virtual BOOL OnInitDialog();
	virtual void SetUIData();
	virtual DNS_STATUS GetUIDataEx(BOOL bSilent = TRUE);

	afx_msg void OnCPUTypeChange();
	afx_msg void OnOperatingSystemChange();

private:
	CEdit* GetCPUTypeCtrl() { return (CEdit*)GetDlgItem(IDC_CPU_TYPE_EDIT);}
	CEdit* GetOperatingSystemCtrl() { return (CEdit*)GetDlgItem(IDC_OPERATING_SYSTEM_EDIT);}

	DECLARE_MESSAGE_MAP()
};


////////////////////////////////////////////////////////////////////////////
// CDNS_ISDN_RecordPropertyPage

class CDNS_ISDN_RecordPropertyPage : public CDNSRecordStandardPropertyPage
{
public:
	CDNS_ISDN_RecordPropertyPage();
protected:
	virtual void SetUIData();
	virtual DNS_STATUS GetUIDataEx(BOOL bSilent = TRUE);

	afx_msg void OnPhoneNumberAndDDIChange();
	afx_msg void OnSubAddressChange();

private:
	CEdit* GetPhoneNumberAndDDICtrl() { return (CEdit*)GetDlgItem(IDC_PHONE_NUM_AND_DDI_EDIT);}
	CEdit* GetSubAddressCtrl() { return (CEdit*)GetDlgItem(IDC_SUBADDRESS_EDIT);}

	DECLARE_MESSAGE_MAP()
};


////////////////////////////////////////////////////////////////////////////
// CDNS_X25_RecordPropertyPage

class CDNS_X25_RecordPropertyPage : public CDNSRecordStandardPropertyPage
{
public:
	CDNS_X25_RecordPropertyPage();
protected:
  virtual BOOL OnInitDialog();
	virtual void SetUIData();
	virtual DNS_STATUS GetUIDataEx(BOOL bSilent = TRUE);

	afx_msg void OnX121PSDNAddressChange();

  CEdit* GetX121Edit() { return (CEdit*)GetDlgItem(IDC_X121_ADDRESS_EDIT); }
private:
	DECLARE_MESSAGE_MAP()
};


////////////////////////////////////////////////////////////////////////////
// CDNS_PTR_CNAME_MB_MD_MF_MG_MR_NSCache_RecordPropertyPage

class CDNS_PTR_CNAME_MB_MD_MF_MG_MR_NSCache_RecordPropertyPage : 
		public CDNSRecordStandardPropertyPage
{
public:
	CDNS_PTR_CNAME_MB_MD_MF_MG_MR_NSCache_RecordPropertyPage(UINT nIDTemplate);
protected:
	virtual BOOL OnInitDialog();

	virtual void SetUIData();
	virtual DNS_STATUS GetUIDataEx(BOOL bSilent = TRUE);

	afx_msg void OnNameNodeChange();
	virtual afx_msg void OnBrowse();

  CEdit* GetNameNodeEdit() { return (CEdit*)GetDlgItem(IDC_NAME_NODE_EDIT); }

	DECLARE_MESSAGE_MAP()
};

 
////////////////////////////////////////////////////////////////////////////
// CDNS_CNAME_RecordPropertyPage

class CDNS_CNAME_RecordPropertyPage : public CDNS_PTR_CNAME_MB_MD_MF_MG_MR_NSCache_RecordPropertyPage
{
public:
	CDNS_CNAME_RecordPropertyPage();

   CButton* GetSecurityCheckCtrl() { return (CButton*)GetDlgItem(IDC_UPDATE_SECURITY_CHECK);}

   virtual BOOL CanCreateDuplicateRecords() { return FALSE; }

protected:
   virtual BOOL OnInitDialog();
	virtual DNS_STATUS GetUIDataEx(BOOL bSilent = TRUE);
};

////////////////////////////////////////////////////////////////////////////
// CDNS_MB_RecordPropertyPage

class CDNS_MB_RecordPropertyPage : public CDNS_PTR_CNAME_MB_MD_MF_MG_MR_NSCache_RecordPropertyPage
{
public:
	CDNS_MB_RecordPropertyPage();
};


////////////////////////////////////////////////////////////////////////////
// CDNS_MD_RecordPropertyPage

class CDNS_MD_RecordPropertyPage : public CDNS_PTR_CNAME_MB_MD_MF_MG_MR_NSCache_RecordPropertyPage
{
public:
	CDNS_MD_RecordPropertyPage();
};

////////////////////////////////////////////////////////////////////////////
// CDNS_MF_RecordPropertyPage

class CDNS_MF_RecordPropertyPage : public CDNS_PTR_CNAME_MB_MD_MF_MG_MR_NSCache_RecordPropertyPage
{
public:
	CDNS_MF_RecordPropertyPage();
};

////////////////////////////////////////////////////////////////////////////
// CDNS_MG_RecordPropertyPage

class CDNS_MG_RecordPropertyPage : public CDNS_PTR_CNAME_MB_MD_MF_MG_MR_NSCache_RecordPropertyPage
{
public:
	CDNS_MG_RecordPropertyPage();

  DECLARE_MESSAGE_MAP();

protected:
	virtual afx_msg void OnBrowse();
};


////////////////////////////////////////////////////////////////////////////
// CDNS_MR_RecordPropertyPage

class CDNS_MR_RecordPropertyPage : public CDNS_PTR_CNAME_MB_MD_MF_MG_MR_NSCache_RecordPropertyPage
{
public:
	CDNS_MR_RecordPropertyPage();

  void OnNameNodeChange();

  DECLARE_MESSAGE_MAP();

protected:
	virtual afx_msg void OnBrowse();
};

////////////////////////////////////////////////////////////////////////////
// CDNS_NSCache_RecordPropertyPage

class CDNS_NSCache_RecordPropertyPage : public CDNS_PTR_CNAME_MB_MD_MF_MG_MR_NSCache_RecordPropertyPage
{
public:
	CDNS_NSCache_RecordPropertyPage();
};

////////////////////////////////////////////////////////////////////////////
// CDNS_PTR_RecordPropertyPage

class CDNS_PTR_RecordPropertyPage : public CDNS_PTR_CNAME_MB_MD_MF_MG_MR_NSCache_RecordPropertyPage
{
public:
	CDNS_PTR_RecordPropertyPage();
protected:
	virtual BOOL OnInitDialog();

	afx_msg void OnIPv4CtrlChange();

	virtual void SetUIData();
	virtual DNS_STATUS GetUIDataEx(BOOL bSilent = TRUE);

private:
	BOOL	m_bAdvancedView;
	int		m_nOctets;
	CDNSIPv4Control* GetIPv4Ctrl() 
			{ return (CDNSIPv4Control*)GetDlgItem(IDC_RR_NAME_IPEDIT);}
   CButton* GetSecurityCheckCtrl() { return (CButton*)GetDlgItem(IDC_UPDATE_SECURITY_CHECK);}

	DECLARE_MESSAGE_MAP()
};



////////////////////////////////////////////////////////////////////////////
// CDNS_MINFO_RP_RecordPropertyPage

class CDNS_MINFO_RP_RecordPropertyPage : public CDNSRecordStandardPropertyPage
{
public:
	CDNS_MINFO_RP_RecordPropertyPage(UINT nIDTemplate);
protected:
	virtual void SetUIData();
	virtual DNS_STATUS GetUIDataEx(BOOL bSilent = TRUE);

	afx_msg void OnNameMailBoxChange();
	afx_msg void OnErrorToMailboxChange();
	afx_msg void OnBrowseNameMailBox();
	afx_msg void OnBrowseErrorToMailbox();

private:
	CEdit* GetNameMailBoxCtrl() { return (CEdit*)GetDlgItem(IDC_NAME_MAILBOX_EDIT);}
	CEdit* GetErrorToMailboxCtrl() { return (CEdit*)GetDlgItem(IDC_ERROR_MAILBOX_EDIT);}

	DECLARE_MESSAGE_MAP()

};

////////////////////////////////////////////////////////////////////////////
// CDNS_MINFO_RecordPropertyPage

class CDNS_MINFO_RecordPropertyPage : public CDNS_MINFO_RP_RecordPropertyPage
{
public:
	CDNS_MINFO_RecordPropertyPage();
};

////////////////////////////////////////////////////////////////////////////
// CDNS_RP_RecordPropertyPage

class CDNS_RP_RecordPropertyPage : public CDNS_MINFO_RP_RecordPropertyPage
{
public:
	CDNS_RP_RecordPropertyPage();
};



////////////////////////////////////////////////////////////////////////////
// CDNS_MX_AFSDB_RT_RecordPropertyPage

class CDNS_MX_AFSDB_RT_RecordPropertyPage : public CDNSRecordStandardPropertyPage
{
public:
	CDNS_MX_AFSDB_RT_RecordPropertyPage(UINT nIDTemplate);
protected:
	virtual void SetUIData();
	virtual DNS_STATUS GetUIDataEx(BOOL bSilent = TRUE);

	afx_msg void OnNameExchangeChange();
	afx_msg void OnBrowse();

private:
	CEdit* GetNameExchangeCtrl() { return (CEdit*)GetDlgItem(IDC_NAME_EXCHANGE_EDIT);}

	DECLARE_MESSAGE_MAP()
};

////////////////////////////////////////////////////////////////////////////
// CDNS_MX_RT_RecordPropertyPage

class CDNS_MX_RT_RecordPropertyPage : public CDNS_MX_AFSDB_RT_RecordPropertyPage
{
public:
	CDNS_MX_RT_RecordPropertyPage(UINT nIDTemplate);
protected:
	virtual void SetUIData();
	virtual DNS_STATUS GetUIDataEx(BOOL bSilent = TRUE);
	virtual BOOL OnInitDialog();
	
	afx_msg void OnPreferenceChange();
protected:
	CDNSUnsignedIntEdit m_preferenceEdit;
	DECLARE_MESSAGE_MAP()
};

////////////////////////////////////////////////////////////////////////////
// CDNS_MX_RecordPropertyPage

class CDNS_MX_RecordPropertyPage : public CDNS_MX_RT_RecordPropertyPage
{
public:
	CDNS_MX_RecordPropertyPage();

  virtual DNS_STATUS ValidateRecordName(PCWSTR pszName, DWORD dwNameChecking);

};

////////////////////////////////////////////////////////////////////////////
// CDNS_RT_RecordPropertyPage

class CDNS_RT_RecordPropertyPage : public CDNS_MX_RT_RecordPropertyPage
{
public:
	CDNS_RT_RecordPropertyPage();
};

/////////////////////////////////////////////////////////////////////////////
// CDNS_AFSDB_RecordPropertyPage

class CDNS_AFSDB_RecordPropertyPage : public CDNS_MX_AFSDB_RT_RecordPropertyPage
{
public:
	CDNS_AFSDB_RecordPropertyPage();
protected:
	virtual void SetUIData();
	virtual DNS_STATUS GetUIDataEx(BOOL bSilent = TRUE);
	virtual BOOL OnInitDialog();

	afx_msg void OnSubtypeEditChange();
	afx_msg void OnSubtypeRadioChange();

private:

	CButton* GetAFSRadioButton() { return (CButton*)GetDlgItem(IDC_AFS_VLS_RADIO); }
	CButton* GetDCERadioButton() { return (CButton*)GetDlgItem(IDC_DCE_ANS_RADIO); }
	CButton* GetOtherRadioButton() { return (CButton*)GetDlgItem(IDC_OTHER_RADIO); }


	CDNSUnsignedIntEdit m_subtypeEdit;
	DECLARE_MESSAGE_MAP()
};



////////////////////////////////////////////////////////////////////////////
// CDNS_WKS_RecordPropertyPage

class CDNS_WKS_RecordPropertyPage : public CDNSRecordStandardPropertyPage
{
public:
	CDNS_WKS_RecordPropertyPage();
protected:
	virtual void SetUIData();
	virtual DNS_STATUS GetUIDataEx(BOOL bSilent = TRUE);
	virtual BOOL CreateRecord();

	afx_msg void OnIPv4CtrlChange();
	afx_msg void OnProtocolRadioChange();
	afx_msg void OnServicesEditChange();

private:
	CDNSIPv4Control* GetIPv4Ctrl() { return (CDNSIPv4Control*)GetDlgItem(IDC_IPEDIT);}
	
	CButton* GetTCPRadioButton() { return (CButton*)GetDlgItem(IDC_TCP_RADIO); }
	CButton* GetUDPRadioButton() { return (CButton*)GetDlgItem(IDC_UDP_RADIO); }
	CEdit* GetServicesEdit() { return (CEdit*)GetDlgItem(IDC_SERVICES_EDIT); }

	DECLARE_MESSAGE_MAP()
};


////////////////////////////////////////////////////////////////////////////
// CDNS_SRV_RecordPropertyPage

class CDNS_SRV_RR_ComboBox : public CComboBox
{
public:

	BOOL Initialize(UINT nCtrlID, CWnd* pParent);
private:
};


class CDNS_SRV_RecordPropertyPage : public CDNSRecordStandardPropertyPage
{
public:
	CDNS_SRV_RecordPropertyPage();
protected:

	// RR name handling
	virtual void OnInitName();
	virtual void OnSetName(CDNSRecordNodeBase* pRecordNode);
	virtual void OnGetName(CString& s);
	virtual BOOL CreateRecord();

	virtual void SetUIData();
	virtual DNS_STATUS GetUIDataEx(BOOL bSilent = TRUE);
	virtual BOOL OnInitDialog();
	virtual void PrimeServicesCombo();

	afx_msg void OnNumericEditChange();
	afx_msg void OnNameTargetEditChange();
	afx_msg void OnServiceComboEditChange();
	afx_msg void OnProtocolComboEditChange();
	afx_msg void OnServiceComboSelChange();
	afx_msg void OnProtocolComboSelChange();

private:
	CEdit* GetNameTargetEdit() { return (CEdit*)GetDlgItem(IDC_NAME_TARGET_EDIT); }
   CButton* GetSecurityCheckCtrl() { return (CButton*)GetDlgItem(IDC_UPDATE_SECURITY_CHECK);}
	
   CDNS_SRV_RR_ComboBox	m_serviceCombo;
	CDNS_SRV_RR_ComboBox	m_protocolCombo;

	CDNSUnsignedIntEdit m_priorityEdit;
	CDNSUnsignedIntEdit m_weightEdit;
	CDNSUnsignedIntEdit m_portEdit;

	CString m_szProtocolName;
	CDNSDomainNode* m_pSubdomainNode;
	BOOL m_bCreateSubdomain;
  BOOL m_bSubdomainCreated;
	BOOL m_bCreated;
	CDNSDomainNode* m_pOldDomainNode;

	DECLARE_MESSAGE_MAP()
};


////////////////////////////////////////////////////////////////////////
// CNewHostDialog


class CNewHostDialog : public CHelpDialog
{
// Construction
public:
	CNewHostDialog(CDNSDomainNode* pParentDomainNode, 
						CComponentDataObject* pComponentData);  
	~CNewHostDialog();

// Implementation
protected:
	virtual BOOL OnInitDialog();

	afx_msg void OnAddHost();

#ifdef _USE_BLANK
#else
  afx_msg void OnEditChange();
#endif

	DECLARE_MESSAGE_MAP()

private:
  CEdit* GetNameEdit() { return (CEdit*)GetDlgItem(IDC_RR_NAME_EDIT);}
	CEdit* GetDomainEditBox() { return(CEdit*)GetDlgItem(IDC_RR_DOMAIN_EDIT);}
	CDNSTTLControl* GetTTLCtrl() { return (CDNSTTLControl*)GetDlgItem(IDC_TTLEDIT);}
	CDNSIPv4Control* GetIPv4Ctrl() { return (CDNSIPv4Control*)GetDlgItem(IDC_IPEDIT);}
	CButton* GetPTRCheckCtrl() { return (CButton*)GetDlgItem(IDC_UPDATE_PRT_CHECK);}
   CButton* GetSecurityCheckCtrl() { return (CButton*)GetDlgItem(IDC_UPDATE_SECURITY_CHECK);}

	CDNSRecordNodeBase* CreateRecordNode();
	void SetUIData(BOOL bFirstTime);
	DNS_STATUS GetUIData(CDNSRecordNodeBase* pRecordNode);

  DNS_STATUS ValidateRecordName(PCWSTR pszName, DWORD dwNameChecking);

	CDNSDomainNode* m_pParentDomainNode;
	CComponentDataObject* m_pComponentData;

	CDNSRecord* m_pTempDNSRecord;

	int		m_nUTF8ParentLen;

	// manage the Cancel/Done button label
	BOOL						m_bFirstCreation;
	CDNSButtonToggleTextHelper m_cancelDoneTextHelper;

};

#endif // _RECPAG2_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by dnssnap.rc
//
#define IDS_SNAPIN_NAME                 1
#define IDS_NAME                        2
#define IDS_SNAPIN_NAME_EX              2
#define IDS_SERVWIZ_FINISHSCREEN_NOTE   3
#define IDS_ZONENAME_INFO               4
#define IDS_SERVWIZ_FINISH_NOTE_PREAMBLE 5
#define IDS_SERVWIZ_FINISH_NOTE_PRIMARY_SUFFIX 6
#define IDS_SNAPINABOUT_DESCRIPTION     9
#define IDS_PROP_SHEET_TITLE_FMT        10
#define IDS_ERRMSG_SERVER_FORWARDER_NO_SERVER 11
#define IDS_SERVER_CREATE_NDNC          12
#define IDS_ROOT_HINTS_NODE_DISPLAY_NAME 13
#define IDS_SERVER_CREATE_DOMAIN_NDNC_FORMAT 14
#define IDS_SERVER_CREATE_FOREST_NDNC_FORMAT 15
#define IDS_ERRMSG_CREATE_DOMAIN_NDNC   16
#define IDS_ERRMSG_CREATE_FOREST_NDNC   17
#define IDS_ERRMSG_NO_NDNC_DOMAIN_FORMAT 18
#define IDS_ERRMSG_NO_NDNC_FOREST_FORMAT 19
#define IDS_PERIOD                      20
#define IDS_FORWARDERS_NODE_DISPLAY_NAME 21
#define IDS_HEADER_PARTITION            49
#define IDS_HEADER_NAME                 50
#define IDS_HEADER_DATA                 51
#define IDS_HEADER_TYPE                 52
#define IDS_HEADER_STATUS               53
#define IDS_ZONE_TYPE_AD_INTEGRATED     54
#define IDS_ZONE_TYPE_STANDARD_PRIMARY  55
#define IDS_ZONE_TYPE_SECONDARY         56
#define IDS_ZONE_TYPE_RUNNING           57
#define IDS_ZONE_TYPE_PAUSED            58
#define IDS_ZONE_TYPE_STUB              59
#define IDS_BIG_BOLD_FONT_NAME          60
#define IDS_BIG_BOLD_FONT_SIZE          61
#define IDS_MASK_CTRL_FONT_NAME         62
#define IDS_MASK_CTRL_FONT_SIZE         63
#define IDS_UNKNOWN                     64
#define IDS_ZONE_TYPE_STUB_DS           65
#define IDS_ROOT_ZONE_LABEL             66
#define IDS_ERR_PRIME_ROOT_HINTS        67
#define IDS_DNS_EVENTS                  68
#define IDI_DNS_SNAPIN                  100
#define IDS_MULTISELECT_ERROR_DIALOG_TITLE 100
#define IDS_MULTISELECT_ERROR_DIALOG_CAPTION 101
#define IDD_ZWIZ_DYNAMIC_UPDATE         102
#define IDS_MULTISELECT_ERROR_DIALOG_COLUMN_HEADER 102
#define IDD_ZONE_WINS_ADVANCED          103
#define IDD_RR_NS_EDIT                  104
#define IDR_SEARCH_AVI                  105
#define IDD_SERVER_DOMAIN_FORWARDERS_PAGE 106
#define IDD_ZONE_GENERAL_CHANGE_TYPE    108
#define IDB_WIZBANNER                   110
#define IDB_WIZWATERMARK                112
#define IDB_BROWSE_TOOLBAR              114
#define IDD_ZONE_GENERAL_CHANGE_TYPE_DATA_CONFLICT 116
#define IDD_FILTERING                   117
#define IDD_FILTERING_NAME              117
#define IDD_ZONE_AGING_DIALOG           121
#define IDD_SERVER_AGING_DIALOG         124
#define IDB_ABOUT_16x16                 127
#define IDB_ABOUT_OPEN_16x16            128
#define IDD_ZWIZ_SELECT_SERVER          129
#define IDB_ABOUT_32x32                 129
#define IDD_SERVER_AGING_CONFIRMATION   130
#define IDB_TOOLBAR_BUTTONS             131
#define IDD_ZWIZ_MASTERS                132
#define IDD_ZWIZ_STORAGE                133
#define IDD_SERVWIZ_SM_FORWARDERS_PAGE  139
#define IDD_SERVWIZ_SM_ZONE_TYPE_PAGE   140
#define IDD_SERVWIZ_SCENARIO_PAGE       141
#define IDD_SERVWIZ_SM_ROOTHINTS_FAILED_PAGE 142
#define IDD_SERVER_NEW_DOMAIN_FORWARDER 144
#define IDD_MULTISELECT_ERROR_DIALOG    145
#define IDD_SERVWIZ_ROOTHINTS_PAGE      146
#define IDD_RR_NXT                      148
#define IDD_COPY_ROOTHINTS_DIALOG       149
#define IDD_SERVER_EVENT_LOGGING_PAGE   150
#define IDD_IP_FILTER_DIALOG            151
#define IDD_ZWIZ_AD_REPLICATION         155
#define IDD_ZONE_GENERAL_CHANGE_REPLICATION 156
#define IDD_ZONE_GENERAL_PAGE_NDNC      157
#define IDD_SERVER_DEBUG_LOGGING_PAGE_NEW 158
#define IDD_SERVER_DEBUG_LOGGING_PAGE   158
#define IDI_BRACE                       161
#define IDI_ICON1                       167
#define IDI_WARNING_ICON                167
#define IDB_16x16                       202
#define IDB_32x32                       203
#define IDD_ZWIZ_ZONE_TYPE              208
#define IDD_ZWIZ_FWD_ZONE_NAME          209
#define IDD_ZONE_GENERAL_PAGE           210
#define IDD_ZONE_WINS_PAGE              212
#define IDD_ZONE_ZONE_TRANSFER_PAGE     213
#define IDD_SERVER_INTERFACES_PAGE      214
#define IDD_SERVER_ADVANCED_PAGE        216
#define IDD_DOMAIN_ADDNEWDOMAIN         218
#define IDD_RR_SOA                      220
#define IDD_RR_A                        221
#define IDD_RR_CNAME                    223
#define IDD_RR_MX                       224
#define IDD_RR_UNK                      226
#define IDD_RR_TXT                      227
#define IDD_RR_X25                      228
#define IDD_RR_ISDN                     229
#define IDD_RR_HINFO                    230
#define IDD_RR_AAAA                     231
#define IDD_RR_MB                       232
#define IDD_RR_MG                       233
#define IDD_RR_MD                       234
#define IDD_RR_MF                       235
#define IDD_RR_MR                       236
#define IDD_RR_MINFO                    237
#define IDD_RR_RP                       238
#define IDD_RR_RT                       239
#define IDD_RR_AFSDB                    240
#define IDD_RR_WKS                      241
#define IDD_RR_PTR                      242
#define IDD_RR_SRV                      243
#define IDD_NAME_SERVERS_PAGE           244
#define IDD_ZONE_NBSTAT_PAGE            245
#define IDD_DELEGWIZ_DOMAIN_NAME        246
#define IDD_SERVMON_TEST_PAGE           248
#define IDD_SERVWIZ_NAME                249
#define IDD_SERVWIZ_FINISH              250
#define IDD_SERVWIZ_ROOT_SERV           252
#define IDD_SERVWIZ_FWD_ZONE            253
#define IDD_SERVWIZ_REV_ZONE            254
#define IDD_SEARCHING_DIALOG            256
#define IDD_ZWIZ_FINISH                 257
#define IDD_ZWIZ_ZONE_LOOKUP            258
#define IDD_BROWSE_DIALOG               259
#define IDD_ZWIZ_REV_ZONE_NAME          260
#define IDD_RR_KEY                      261
#define IDD_RR_SIG                      262
#define IDD_SELECT_RECORD_TYPE_DIALOG   263
#define IDD_DELEGWIZ_FINISH             264
#define IDD_DELEGWIZ_NAME_SERVERS       265
#define IDD_SERVWIZ_START               267
#define IDS_KEY_TYPES                   500
#define IDS_NAME_TYPES                  501
#define IDS_ZONE                        505
#define IDS_STRONG                      506
#define IDS_UNIQUE                      507
#define IDD_CHOOSER_CHOOSE_MACHINE      970
#define IDC_CHOOSER_GROUP_TARGET_MACHINE 971
#define IDD_DOMAIN_ADDNEWHOST           971
#define IDC_CHOOSER_RADIO_LOCAL_MACHINE 972
#define IDD_ZWIZ_START                  972
#define IDC_CHOOSER_RADIO_SPECIFIC_MACHINE 973
#define IDD_DELEGWIZ_START              973
#define IDC_CHOOSER_EDIT_MACHINE_NAME   974
#define IDD_FILTERING_LIMITS            974
#define IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES 975
#define IDD_RR_ATMA                     975
#define IDD_RR_NS_CACHE                 976
#define IDD_ZONE_NOTIFY_SUBDIALOG       977
#define IDC_RECORD_TYPE_LIST            1000
#define IDC_DATA_EDIT                   1000
#define IDC_COMBO_SEL_NODE              1000
#define IDC_LIST                        1001
#define IDC_LIST_NODE_ITEMS             1001
#define IDS_SNAPIN_ADVANCED_VIEW        1001
#define IDS_SNAPIN_FILTERING            1002
#define IDC_RADIO_PRIMARY               1003
#define IDC_SEARCH_ANIMATE              1003
#define IDC_COMBO_FILTER                1003
#define IDS_SNAPIN_CONNECT_TO_SERVER    1003
#define IDC_RADIO_STUB                  1003
#define IDC_RADIO_SECONDARY             1004
#define IDC_SELECTION_EDIT              1004
#define IDS_SNAPIN_FILTERING_TITLE      1004
#define IDC_RECORD_TYPE_DESCR           1005
#define IDC_RADIO_FWD                   1005
#define IDS_FILTER_ENABLED              1005
#define IDC_RADIO_PRIMARY_ZONE          1005
#define IDC_RADIO_REV                   1006
#define IDC_IPEDIT                      1006
#define IDC_RR_NAME_EDIT                1007
#define IDC_SERVER_NAME_EDIT            1007
#define IDC_NEW_DOMAIN_NAME_EDIT        1007
#define IDC_FWD_TIMEOUT_EDIT            1007
#define IDC_SERVER_VERSION_EDIT         1007
#define IDC_SERVERS_LIST                1009
#define IDC_NS_LIST                     1010
#define IDC_RESULTS_LIST                1010
#define IDC_BUTTON_ADD                  1012
#define IDC_BUTTON_REMOVE               1013
#define IDC_BUTTON_UP                   1014
#define IDC_BUTTON_DOWN                 1015
#define IDC_PRIMARY_SERV_EDIT           1016
#define IDC_NAME_TARGET_EDIT            1016
#define IDC_FILE_NAME_EDIT              1016
#define IDC_DOMAIN_ADD_BUTTON           1016
#define IDC_RADIO_CREATE_NEW_FILE       1017
#define IDC_EDIT_ZONE_NAME              1017
#define IDC_DOMAIN_REMOVE_BUTTON        1017
#define IDC_RADIO_IMPORT_FILE           1018
#define IDC_EDIT_DOMAIN_NAME            1018
#define IDC_EDIT_ZONE_NAME2             1018
#define IDC_TTLEDIT                     1019
#define IDC_EDIT_DNSSERVER              1020
#define IDC_EDIT_NEW_FILE               1020
#define IDC_RR_NAME_STATIC              1020
#define IDC_EDIT_IMPORT_FILE            1021
#define IDC_MIN_TTLEDIT                 1021
#define IDC_ORIG_TTL                    1021
#define IDC_UPDATE_PRT_CHECK            1022
#define IDC_BROWSE_BUTTON               1024
#define IDC_NAME_NODE_EDIT              1025
#define IDC_SERVICES_EDIT               1026
#define IDC_PRIORITY_EDIT               1026
#define IDC_PORT_EDIT                   1027
#define IDC_REFR_INT_EDIT               1028
#define IDC_WEIGHT_EDIT                 1028
#define IDC_REFR_INT_COMBO              1029
#define IDC_RETRY_INT_EDIT              1030
#define IDC_REFR_INT_EDIT2              1030
#define IDC_RETRY_INT_COMBO             1031
#define IDC_REFR_INT_COMBO2             1031
#define IDC_EXP_INT_EDIT                1032
#define IDC_EXP_INT_COMBO               1033
#define IDC_RESP_PARTY_EDIT             1034
#define IDC_BROWSE_SERV_BUTTON          1035
#define IDC_BROWSE_PARTY_BUTTON         1036
#define IDC_USE_WINS_RES_CHECK          1036
#define IDC_NOT_REPL_CHECK              1037
#define IDC_MINTTL_INT_EDIT             1037
#define IDC_TYPE_STATIC                 1038
#define IDC_MINTTL_INT_COMBO            1038
#define IDC_SIZE_STATIC                 1039
#define IDC_SERIAL_NUMBER_EDIT          1040
#define IDC_RR_TXT_EDIT                 1042
#define IDC_SERIAL_UP                   1043
#define IDC_SERIAL_DOWN                 1044
#define IDC_X121_ADDRESS_EDIT           1045
#define IDC_PHONE_NUM_AND_DDI_EDIT      1046
#define IDC_SUBADDRESS_EDIT             1047
#define IDC_CPU_TYPE_EDIT               1048
#define IDC_OPERATING_SYSTEM_EDIT       1049
#define IDC_IPV6EDIT                    1050
#define IDC_BROWSE_ERROR_MAILBOX_BUTTON 1052
#define IDC_NAME_MAILBOX_EDIT           1053
#define IDC_ERROR_MAILBOX_EDIT          1054
#define IDC_BROWSE_NAME_MAILBOX_BUTTON  1055
#define IDC_NAME_EXCHANGE_EDIT          1056
#define IDC_PREFERENCE_EDIT             1057
#define IDC_AFS_VLS_RADIO               1058
#define IDC_DCE_ANS_RADIO               1059
#define IDC_OTHER_RADIO                 1060
#define IDC_SUBTYPE_EDIT                1061
#define IDC_TCP_RADIO                   1062
#define IDC_UDP_RADIO                   1063
#define IDC_CHANGE_TYPE_BUTTON          1065
#define IDC_STATUS_STATIC               1066
#define IDC_PAUSE_START_BUTTON          1067
#define IDC_ENABLE_TESTING_CHECK        1068
#define IDC_ADD_NS_BUTTON               1072
#define IDC_REMOVE_NS_BUTTON            1073
#define IDC_ADVANCED_BUTTON             1076
#define IDC_DOMAIN_NAME_EDIT            1077
#define IDC_CACHE_TIMEOUT_TTLEDIT       1078
#define IDC_LOOKUP_TIMEOUT_TTLEDIT      1079
#define IDC_NETBIOS_CHECK               1080
#define IDC_STORAGE_STATIC              1082
#define IDC_MASTERS_IPEDIT              1083
#define IDC_MASTERS_BUTTON_ADD          1084
#define IDC_MASTERS_BUTTON_REMOVE       1085
#define IDC_MASTERS_BUTTON_UP           1086
#define IDC_MASTERS_BUTTON_DOWN         1087
#define IDC_MASTERS_IP_LIST             1088
#define IDC_EDIT_NS_BUTTON              1091
#define IDC_QUERY_BUTTON                1093
#define IDC_RESET_BUTTON                1095
#define IDC_SLAVE_CHECK                 1098
#define IDC_USE_FORWARDERS_CHECK        1099
#define IDC_SUMMARY_STATIC              1101
#define IDC_NO_DNS_RADIO                1106
#define IDC_DNS_RADIO                   1107
#define IDC_ZONE_RADIO                  1108
#define IDC_NO_ZONE_RADIO               1109
#define IDC_NAME_STATIC                 1110
#define IDC_LOOKUP_STATIC               1111
#define IDC_STORAGE_NAME_STATIC         1114
#define IDC_STORAGE_TYPE_STATIC         1115
#define IDC_USE_EDIT_RADIO              1116
#define IDC_USE_IP_RADIO                1117
#define IDC_BROWSE_MASTERS_BUTTON       1120
#define IDC_FIND_MASTERS_NAMES_BUTTON   1122
#define IDC_TEST_NOW_BUTTON             1124
#define IDC_SIMPLE_QUERY_CHECK          1125
#define IDC_RECURSIVE_QUERY_CHECK       1126
#define IDC_POLLING_INT_EDIT            1127
#define IDC_POLLING_INT_COMBO           1128
#define IDC_CREATE_RECORD_BUTTON        1131
#define IDC_STATIC_TTL                  1132
#define IDC_RR_NAME_IPEDIT              1134
#define IDC_RADIO_ZONE_PRIMARY          1135
#define IDC_RADIO_ZONE_SECONDARY        1136
#define IDC_RADIO_ZONE_STUB             1137
#define IDC_IPEDIT_DOMAIN_NAME          1141
#define IDC_LOGGING_OPTIONS_LIST        1145
#define IDC_ADVANCED_OPTIONS_LIST       1146
#define IDC_NAME_CHECKING_COMBO         1147
#define IDC_BOOT_METHOD_COMBO           1148
#define IDC_CHOOSER_CHECK_CONTACT       1149
#define IDC_BUTTON_ADDHOST              1151
#define IDC_SERVICE_NAME_COMBO          1152
#define IDC_PROTOCOL_NAME_COMBO         1153
#define IDC_LISTEN_ON_ALL_RADIO         1154
#define IDC_LISTEN_ON_SPECIFIED_RADIO   1155
#define IDC_SUBNET_IPEDIT               1156
#define IDC_MASK_IPEDIT                 1157
#define IDC_PRIMARY_DYN_UPD_COMBO       1157
#define IDC_PRIMARY_DYN_UPD_STATIC      1158
#define IDC_FWD_TIMEOUT_STATIC          1159
#define IDC_TOOLBAR_CTRL                1161
#define IDC_STATIC_ERROR                1162
#define IDC_RADIO_USE_DS_DATA           1163
#define IDC_RADIO_USE_MEM_DATA          1164
#define IDC_RADIO_FILTER_NONE           1164
#define IDC_RADIO_FILTER_STARTS         1165
#define IDC_RADIO_FILTER_CONTAINS       1166
#define IDC_EDIT_FILTER_STARTS          1167
#define IDC_EDIT_FILTER_CONTAINS        1168
#define IDC_RADIO_FILTER_RANGE          1169
#define IDC_EDIT_COUNT                  1171
#define IDC_EDIT_FILTER_RANGE_TO        1172
#define IDC_RADIO_E164                  1172
#define IDC_EDIT_FILTER_RANGE_FROM      1173
#define IDC_RADIO_NSAP                  1173
#define IDC_EDIT_ATMA_ADDRESS           1174
#define IDC_STATIC_LIST_CAPTION         1175
#define IDC_STATIC_MESSAGE              1176
#define IDC_STATIC_DESCR                1177
#define IDC_RADIO_SECSECURE_NS          1180
#define IDC_RADIO_SECSECURE_OFF         1182
#define IDC_RADIO_NOTIFY_ALL            1183
#define IDC_RADIO_SECSECURE_LIST        1184
#define IDC_BUTTON_NOTIFY               1185
#define IDC_RADIO_NOTIFY_OFF            1186
#define IDC_RADIO_NOTIFY_LIST           1187
#define IDC_STATIC_WELCOME              1188
#define IDC_STATIC_COMPLETE             1189
#define IDC_CHECK_ALLOW_TRANSFERS       1190
#define IDC_CHECK_AD_APPLY_ALL          1190
#define IDC_ADINT_CHECK                 1190
#define IDC_SEND_CHECK                  1190
#define IDC_LOCAL_LIST_CHECK            1190
#define IDC_UPDATE_SECURITY_CHECK       1190
#define IDC_EDIT_NEW_DEFAULTS           1191
#define IDC_NEW_DOMAIN_FQDN             1191
#define IDC_BITFIELD_EDIT               1191
#define IDC_NEXT_DOMAIN_EDIT            1191
#define IDC_LABELS_EDIT                 1191
#define IDC_LOGFILE_EDIT                1191
#define IDC_CHECK_ENABLE_SCAVENGING     1193
#define IDC_DEFAULT_DELETE_STALE_RECORD 1194
#define IDC_TIME_EDIT                   1199
#define IDS_CATHEGORY_FOLDER_CACHE      1200
#define IDC_REFR_INT_EDIT1              1200
#define IDS_CATHEGORY_FOLDER_FWD        1201
#define IDC_REFR_INT_COMBO1             1201
#define IDS_CATHEGORY_FOLDER_REV        1202
#define IDC_AGING_BUTTON                1202
#define IDC_AGING_STATIC                1203
#define IDS_CATHEGORY_FOLDER_DOMAIN_FORWARDERS 1203
#define IDC_TIME_STAMP                  1206
#define IDC_SCAVENGING_ENABLED          1207
#define IDC_TIME_STAMP_STATIC           1208
#define IDC_TIME_STAMP_STATIC1          1208
#define IDC_CHECK_ENABLE                1210
#define IDC_STATIC_SCAVENGE             1213
#define IDC_TIME_STAMP_STATIC2          1215
#define IDC_STATIC_ADD_FORWARDERS       1223
#define IDC_STATIC_IP                   1224
#define IDC_CHECK_AD                    1225
#define IDC_CHECK_STANDARD              1226
#define IDC_STATIC_TIME_STAMP           1228
#define IDC_CHECK_AUTO_NOTIFY           1229
#define IDC_DENY_DYNAMIC_RADIO          1230
#define IDC_SECURE_DYNAMIC_RADIO        1231
#define IDC_ALLOW_DYNAMIC_RADIO         1232
#define IDC_DOMAIN_LIST                 1235
#define IDC_SMALL_RADIO                 1236
#define IDC_MEDIUM_RADIO                1237
#define IDC_MANUALLY_RADIO              1239
#define IDC_FORWARD_RADIO               1240
#define IDC_NO_FORWARDERS_RADIO         1241
#define IDC_RETRY_RADIO                 1242
#define IDC_CONFIG_MANUALLY_RADIO       1243
#define IDC_MAKE_ROOT_RADIO             1244
#define IDC_IGNORE_RADIO                1245
#define IDC_PRIMARY_RADIO               1246
#define IDC_SECONDARY_RADIO             1247
#define IDC_ERROR_LIST                  1249
#define IDC_KEY_TYPE_COMBO              1250
#define IDC_CUSTOM_COMBO                1250
#define IDC_NAME_TYPE_COMBO             1251
#define IDC_PROTOCOL_COMBO              1254
#define IDC_ALGORITHM_COMBO             1255
#define IDC_KEY_EDIT                    1257
#define IDC_RECORD_TYPE_COMBO           1258
#define IDC_SIGNERS_NAME_EDIT           1260
#define IDC_SIG_EDIT                    1261
#define IDC_HELP_BUTTON                 1262
#define IDC_KEY_TAG_EDIT                1262
#define IDC_EXP_DATE                    1266
#define IDC_EXP_TIME                    1267
#define IDC_INC_DATE                    1268
#define IDC_INC_TIME                    1269
#define IDC_COPY_FROM_BUTTON            1271
#define IDC_RECEIVE_CHECK               1274
#define IDC_UDP_CHECK                   1275
#define IDC_TCP_CHECK                   1276
#define IDC_QUERIES_CHECK               1277
#define IDC_UPDATES                     1278
#define IDC_NOTIFIES_CHECK              1279
#define IDC_REQUEST_CHECK               1280
#define IDC_RESPONSE_CHECK              1281
#define IDC_MAX_SIZE_EDIT               1282
#define IDC_FILTERING_CHECK             1283
#define IDC_FILTER_BUTTON               1284
#define IDC_NO_EVENTS_RADIO             1286
#define IDC_ERRORS_RADIO                1287
#define IDC_ERRORS_WARNINGS_RADIO       1288
#define IDC_ALL_RADIO                   1289
#define IDC_STATIC_CAPTION              1290
#define IDC_DNSQUERY_STATIC             1291
#define IDC_FILENAME_STATIC             1292
#define IDC_MAXSIZE_STATIC              1293
#define IDC_STUB_STATIC                 1295
#define IDC_DETAIL_CHECK                1296
#define IDC_FOREST_RADIO                1297
#define IDC_DOMAIN_RADIO                1298
#define IDC_DOMAIN_DC_RADIO             1299
#define IDC_CUSTOM_RADIO                1300
#define IDC_CUSTOM_STATIC               1301
#define IDC_REPLICATION_STATIC          1302
#define IDC_CHANGE_REPL_BUTTON          1303
#define IDC_REPL_LABEL_STATIC           1304
#define IDC_DEBUG_LOGGING_CHECK         1306
#define IDC_DIRECTION_STATIC            1307
#define IDC_TRANSPORT_STATIC            1308
#define IDC_CONTENTS_STATIC             1309
#define IDC_OPTIONS_STATIC              1310
#define IDC_LOG_STATIC                  1311
#define IDC_BRACE1_STATIC               1312
#define IDC_BRACE2_STATIC               1313
#define IDC_BRACE3_STATIC               1314
#define IDC_BRACE4_STATIC               1315
#define IDC_SELECT1_STATIC              1316
#define IDC_SELECT2_STATIC              1317
#define IDC_SELECT3_STATIC              1318
#define IDC_SELECT4_STATIC              1319
#define IDC_UPDATES_CHECK               1320
#define IDC_FORWARDER_ADINT_STATIC      1321
#define IDC_TTL_LABEL                   1322
#define IDC_IPEDIT2                     1323
#define IDC_FINISH_STATIC               1324
#define IDC_IP_STATIC                   1325
#define IDC_FINISH_STATIC2              1325
#define IDC_ZONENAME_INFO               1326
#define IDC_RR_DOMAIN_EDIT              1526
#define IDC_LIST_LABEL                  1527
#define IDC_WARNING_ICON_STATIC         1528
#define IDC_WARNING_TEXT_STATIC         1529
#define IDS_SERVER_NEW_ZONE             1531
#define IDS_SERVER_CLEAR_CACHE          1532
#define IDS_CACHE_FOLDER_CLEAR_CACHE    1533
#define IDS_SERVER_SET_AGING            1534
#define IDS_SERVER_SCAVENGE             1535
#define IDS_DUPLICATE_SERVER            1536
#define IDS_SERVER_NSLOOKUP             1537
#define IDS_DOMAIN_NEW_NEW_RECORD       1547
#define IDS_DOMAIN_NEW_NEW_DOMAIN       1548
#define IDS_DOMAIN_NEW_NEW_DELEGATION   1549
#define IDS_SERVER_UPDATE_DATA_FILES    1550
#define IDS_DOMAIN_NEW_NEW_HOST         1551
#define IDS_DOMAIN_NEW_NEW_ALIAS        1552
#define IDS_DOMAIN_NEW_NEW_MX           1553
#define IDS_DOMAIN_NEW_NEW_PTR          1554
#define IDS_SERVER_CONFIGURE            1555
#define IDS_SNAPIN_MESSAGE              1556
#define IDS_ZONE_PAUSE                  1600
#define IDS_ZONE_UPDATE_DATA_FILE       1601
#define IDS_ZONE_RELOAD                 1602
#define IDS_ZONE_TRANSFER               1603
#define IDS_ZONE_RELOAD_FROM_MASTER     1604
#define IDS_NSPAGE_LISTVIEW_HEADERS     1608
#define IDS_TEST_LISTVIEW_HEADERS       1609
#define IDS_NSPAGE_ROOT_HINTS           1610
#define IDS_NEW_DOMAIN_INST1            2000
#define IDS_NEW_DOMAIN_INST2            2001
#define IDS_FORMAT_RECORDS              2002
#define IDS_FORMAT_ZONES                2003
#define IDS_FORMAT_SERVERS              2004
#define IDS_SERVWIZ_SMALL_ZONE_TYPE_TITLE 3000
#define IDS_SERVWIZ_SMALL_ZONE_TYPE_SUBTITLE 3001
#define IDS_SERVWIZ_SCENARIO_TITLE      3002
#define IDS_SERVWIZ_SCENARIO_SUBTITLE   3003
#define IDS_SERVWIZ_FORWARDERS_TITLE    3004
#define IDS_SERVWIZ_FORWARDERS_SUBTITLE 3005
#define IDS_SERVWIZ_ROOTHINTS_FAILED_TITLE 3006
#define IDS_SERVWIZ_ROOTHINTS_FAILED_SUBTITLE 3007
#define IDS_MSG_SERVWIZ_FAIL_FORWARDERS 3008
#define IDS_SERVWIZ_ROOTHINTS_TITLE     3009
#define IDS_SERVWIZ_ROOTHINTS_SUBTITLE  3010
#define IDS_OTHER_DOMAINS               3500
#define IDS_RECORD                      3501
#define IDS_ERROR                       3502
#define IDS_MSG_DOMAIN_FORWARDER_ILLEGAL_NAME 3503
#define IDS_MSG_FAIL_CREATE_DOMAIN_FORWARDER 3504
#define IDS_ERRMSG_WKS_INVALID_DATA     3700
#define IDS_ALGORITHM_RSAMD5            4001
#define IDS_ALGORITHM_DIFFIE            4002
#define IDS_ALGORITHM_DSA               4003
#define IDS_ALGORITHM_ELIPTIC           4004
#define IDS_ALGORITHM_INDIRECT          4005
#define IDS_PROTOCOL_TLS                4020
#define IDS_PROTOCOL_EMAIL              4021
#define IDS_PROTOCOL_DNSSEC             4022
#define IDS_PROTOCOL_IPSEC              4023
#define IDS_PROTOCOL_ALL                4024
#define IDS_ZWIZ_AD_REPL_FORMAT         4100
#define IDS_ZWIZ_AD_DOMAIN_FORMAT       4101
#define IDS_ZWIZ_AD_FOREST_FORMAT       4102
#define IDS_ZONE_REPLICATION_FOREST_TEXT 4103
#define IDS_ZONE_REPLICATION_DOMAIN_TEXT 4104
#define IDS_ZONE_REPLICATION_W2K_TEXT   4105
#define IDS_ZONE_REPLICATION_CUSTOM_TEXT 4106
#define IDS_ZONE_REPLICATION_NONDS_TEXT 4107
#define IDS_QUESTION_MARK               4200
#define IDS_MSG_RESPONSIBLE_PARTY_CONTAINS_AT 5000
#define IDS_DNS_ERROR_RCODE_NO_ERROR    38000
#define IDS_DNS_ERROR_RCODE_FORMAT_ERROR 38001
#define IDS_DNS_ERROR_RCODE_SERVER_FAILURE 38002
#define IDS_DNS_ERROR_RCODE_NAME_ERROR  38003
#define IDS_DNS_ERROR_RCODE_NOT_IMPLEMENTED 38004
#define IDS_DNS_ERROR_RCODE_REFUSED     38005
#define IDS_DNS_ERROR_RCODE_YXDOMAIN    38006
#define IDS_DNS_ERROR_RCODE_YXRRSET     38007
#define IDS_DNS_ERROR_RCODE_NXRRSET     38008
#define IDS_DNS_ERROR_RCODE_NOTAUTH     38009
#define IDS_DNS_ERROR_RCODE_NOTZONE     38010
#define IDS_DNS_INFO_NO_RECORDS         38011
#define IDS_DNS_ERROR_BAD_PACKET        38012
#define IDS_DNS_ERROR_NO_PACKET         38013
#define IDS_DNS_ERROR_RCODE             38014
#define IDS_DNS_ERROR_INVALID_NAME      38015
#define IDS_DNS_ERROR_INVALID_DATA      38016
#define IDS_DNS_ERROR_INVALID_TYPE      38017
#define IDS_DNS_ERROR_INVALID_IP_ADDRESS 38018
#define IDS_DNS_ERROR_INVALID_PROPERTY  38019
#define IDS_DNS_ERROR_ZONE_DOES_NOT_EXIST 38020
#define IDS_DNS_ERROR_NO_ZONE_INFO      38021
#define IDS_DNS_ERROR_INVALID_ZONE_OPERATION 38022
#define IDS_DNS_ERROR_ZONE_CONFIGURATION_ERROR 38023
#define IDS_DNS_ERROR_ZONE_HAS_NO_SOA_RECORD 38024
#define IDS_DNS_ERROR_ZONE_HAS_NO_NS_RECORDS 38025
#define IDS_DNS_ERROR_ZONE_LOCKED       38026
#define IDS_DNS_ERROR_ZONE_CREATION_FAILED 38027
#define IDS_DNS_ERROR_ZONE_ALREADY_EXISTS 38028
#define IDS_DNS_ERROR_AUTOZONE_ALREADY_EXISTS 38029
#define IDS_DNS_ERROR_INVALID_ZONE_TYPE 38030
#define IDS_DNS_ERROR_SECONDARY_REQUIRES_MASTER_IP 38031
#define IDS_DNS_ERROR_ZONE_NOT_SECONDARY 38032
#define IDS_DNS_ERROR_NEED_SECONDARY_ADDRESSES 38033
#define IDS_DNS_ERROR_WINS_INIT_FAILED  38034
#define IDS_DNS_ERROR_NEED_WINS_SERVERS 38035
#define IDS_DNS_ERROR_NBSTAT_INIT_FAILED 38036
#define IDS_DNS_ERROR_SOA_DELETE_INVALID 38037
#define IDS_DNS_ERROR_PRIMARY_REQUIRES_DATAFILE 38038
#define IDS_DNS_ERROR_INVALID_DATAFILE_NAME 38039
#define IDS_DNS_ERROR_DATAFILE_OPEN_FAILURE 38040
#define IDS_DNS_ERROR_FILE_WRITEBACK_FAILED 38041
#define IDS_DNS_ERROR_DATAFILE_PARSING  38042
#define IDS_DNS_ERROR_RECORD_DOES_NOT_EXIST 38043
#define IDS_DNS_ERROR_RECORD_FORMAT     38044
#define IDS_DNS_ERROR_NODE_CREATION_FAILED 38045
#define IDS_DNS_ERROR_UNKNOWN_RECORD_TYPE 38046
#define IDS_DNS_ERROR_RECORD_TIMED_OUT  38047
#define IDS_DNS_ERROR_NAME_NOT_IN_ZONE  38048
#define IDS_DNS_ERROR_CNAME_LOOP        38049
#define IDS_DNS_ERROR_NODE_IS_CNAME     38050
#define IDS_DNS_ERROR_CNAME_COLLISION   38051
#define IDS_DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT 38052
#define IDS_DNS_ERROR_RECORD_ALREADY_EXISTS 38053
#define IDS_DNS_ERROR_SECONDARY_DATA    38054
#define IDS_DNS_ERROR_NO_CREATE_CACHE_DATA 38055
#define IDS_DNS_ERROR_NAME_DOES_NOT_EXIST 38056
#define IDS_DNS_WARNING_PTR_CREATE_FAILED 38057
#define IDS_DNS_WARNING_DOMAIN_UNDELETED 38058
#define IDS_DNS_INFO_AXFR_COMPLETE      38059
#define IDS_DNS_ERROR_AXFR              38060
#define IDS_DNS_INFO_ADDED_LOCAL_WINS   38061
#define IDS_DNS_ERROR_DS_UNAVAILABLE    38062
#define IDS_RPC_S_SERVER_UNAVAILABLE    38063
#define IDS_ERROR_ACCESS_DENIED         38064
#define IDS_ERROR_ZONE_DYN_UPD          38065
#define IDS_ERROR_ZONE_PRIMARY          38066
#define IDS_ERROR_ZONE_SECONDARY        38067
#define IDS_ERROR_ZONE_PAUSE            38068
#define IDS_ERROR_ZONE_START            38069
#define IDS_DNS_ERROR_NO_BOOTFILE_IF_DS_ZONE 38070
#define IDS_MSG_ERROR_SCAVENGE_RECORDS  38071
#define IDS_MSG_SERVER_SCAVENGING_STATE 38072
#define IDS_MSG_SERVER_SCAVENGING_INTERVAL 38073
#define IDS_MSG_SERVWIZ_FAIL_SERVER_CONFIGURED 38074
#define IDS_MSG_ERROR_REFRESH_INTERVAL  38075
#define IDS_MSG_ERROR_NO_REFRESH_INTERVAL 38076
#define IDS_MSG_ERROR_SCAVENGING_ENABLED 38077
#define IDS_MSG_FILE_WARNING            38078
#define IDS_MSG_FILE_WARNING_ZONE       38079
#define IDS_ERROR_ZONE_REPLTYPE         38080
#define IDS_NEW_RECORD_TITLE            39900
#define IDS_EDIT_RECORD_TITLE           39901
#define IDS_RECORD_AT_THE_NODE          39902
#define IDS_ERROR_ZONE_STUB             39903
#define IDS_RECORD_INFO_A               40000
#define IDS_RECORD_INFO_NS              40001
#define IDS_RECORD_INFO_MD              40002
#define IDS_RECORD_INFO_MF              40003
#define IDS_RECORD_INFO_CNAME           40004
#define IDS_RECORD_INFO_SOA             40005
#define IDS_RECORD_INFO_MB              40006
#define IDS_RECORD_INFO_MG              40007
#define IDS_RECORD_INFO_MR              40008
#define IDS_RECORD_INFO_NULL            40009
#define IDS_RECORD_INFO_WKS             40010
#define IDS_RECORD_INFO_PTR             40011
#define IDS_RECORD_INFO_HINFO           40012
#define IDS_RECORD_INFO_MINFO           40013
#define IDS_RECORD_INFO_MX              40014
#define IDS_RECORD_INFO_TEXT            40015
#define IDS_RECORD_INFO_RP              40016
#define IDS_RECORD_INFO_AFSDB           40017
#define IDS_RECORD_INFO_X25             40018
#define IDS_RECORD_INFO_ISDN            40019
#define IDS_RECORD_INFO_RT              40020
#define IDS_RECORD_INFO_NSAP            40021
#define IDS_RECORD_INFO_NSAPPTR         40022
#define IDS_RECORD_INFO_KEY             40023
#define IDS_RECORD_INFO_PX              40024
#define IDS_RECORD_INFO_GPOS            40025
#define IDS_RECORD_INFO_AAAA            40026
#define IDS_RECORD_INFO_ATMA            40027
#define IDS_RECORD_INFO_WINS            40031
#define IDS_RECORD_INFO_NBSTAT          40032
#define IDS_RECORD_INFO_SIG             40033
#define IDS_RECORD_INFO_UNK             40034
#define IDS_RECORD_INFO_SRV             40035
#define IDS_RECORD_INFO_NXT             40036
#define IDS_RECORD_DATA_UNK             40040
#define IDS_TIME_AGING_INTERVAL_UNITS   40041
#define IDS_TIME_INTERVAL_UNITS         41000
#define IDS_BROWSE_FILTER_OPTIONS       41001
#define IDS_BROWSE_TOOLTIP              41002
#define IDS_SERVER_ADV_PP_OPTIONS       42100
#define IDS_SERVER_NAME_CHECKING_OPTIONS 42101
#define IDS_SERVER_BOOT_METHOD_OPTIONS  42102
#define IDS_SERVER_TEST_RESULT_PASS     42500
#define IDS_SERVER_TEST_RESULT_FAIL     42501
#define IDS_SERVER_TEST_RESULT_FAIL_ON_NAME_RES 42502
#define IDS_ZONE_PRIMARY_DYN_UPD_OPTIONS 42600
#define IDS_MSG_CONT_CLOSE_SHEET        42980
#define IDS_MSG_RECORD_CLOSE_SHEET      42981
#define IDS_MSG_QUERY_TOO_MANY_ITEMS    42982
#define IDS_MSG_SERVER_LOG_MAX_SIZE_FAILED 42983
#define IDS_MSG_SERVER_LOG_FILE_NAME_FAILED 42984
#define IDS_MSG_SERVER_LOG_FILTER_LIST_FAILED 42985
#define IDS_MSG_SERVER_DELETE           43002
#define IDS_MSG_SERVER_NO_ADVANCED_OPTIONS 43006
#define IDS_MSG_SERVER_NO_BOOT_METHOD   43007
#define IDS_MSG_SERVER_NO_NAME_CHECKING 43008
#define IDS_MSG_SERVER_FAIL_ADV_PROP_FMT 43009
#define IDS_MSG_SERVER_FAIL_CLEAR_CACHE 43010
#define IDS_MSG_SERVER_INTERFACE_UPDATE_FAILED 43011
#define IDS_MSG_SERVER_FORWARDER_UPDATE_FAILED 43012
#define IDS_MSG_SERVER_LOG_LEVEL_OPTIONS_FAILED 43013
#define IDS_MSG_SERVER_TEST_OPTIONS_UPDATE_FAILED 43014
#define IDS_MSG_SERVER_FAILED_SET_EVENTLOGLEVEL 43015
#define IDS_MSG_ZONE_SOA_UPDATE_FAILED  43019
#define IDS_MSG_ZONE_DELETE             43020
#define IDS_MSG_ZONE_MASTERS_BROWSE_FAIL 43021
#define IDS_MSG_ZONE_FAIL_DELETE        43022
#define IDS_MSG_ZONE_WARNING_CHANGE_TYPE 43023
#define IDS_MSG_ZONE_WARNING_CHANGE_TYPE_FROM_DS 43023
#define IDS_MSG_ZONE_WARNING_CHANGE_TYPE_TO_DS 43024
#define IDS_ZONE_WARNING_SHEETS_UP      43025
#define IDS_MSG_ZONE_FAIL_TRANSFER      43026
#define IDS_MSG_ZONE_RELOAD             43027
#define IDS_MSG_ZONE_FAIL_RELOAD        43028
#define IDS_MSG_ZONE_DELETE_FROM_DS     43029
#define IDS_MSG_ZONE_FAIL_UPDATE_ZONE_TRANSFERS 43030
#define IDS_ZONE_LOADED_FROM_DS_WARNING 43031
#define IDS_MSG_ZONE_WINS_FAILED        43032
#define IDS_MSG_ZONE_NBSTAT_FAILED      43033
#define IDS_MSG_ZONE_DELETE_FROM_DS_BOOT3 43034
#define IDS_MSG_ZONE_DELETE_ROOT        43035
#define IDS_MSG_ZONE_FAIL_RELOAD_FROM_MASTER 43036
#define IDS_MSG_DOMAIN_MULTI_DELETE     43039
#define IDS_MSG_DOMAIN_DELETE           43040
#define IDS_MSG_DOMAIN_FAIL_CREATE      43041
#define IDS_MSG_DOMAIN_FAIL_DELETE      43042
#define IDS_MSG_DOMAIN_EXISTS           43043
#define IDS_MSG_SERVER_CONFIRM_SCAVENGE 43044
#define IDS_MSG_FORWARDER_DELETE_FROM_DS 43045
#define IDS_MSG_FORWARDER_DELETE_FROM_DS_BOOT3 43046
#define IDS_MSG_RECORD_DELETE           43060
#define IDS_MSG_RECORD_WARNING_CREATE_PTR 43061
#define IDS_MSG_RECORD_WARNING_NS_NO_IP 43063
#define IDS_MSG_RECORD_FAIL_DELETE      43064
#define IDS_MSG_RECORD_CREATE_HOST_SUCCESS 43065
#define IDS_MSG_RECORD_CREATE_HOST_FAIL 43066
#define IDS_MSG_RECORD_DEL_A_FROM_NS    43067
#define IDS_MSG_RECORD_NS_RESOLVE_IP    43068
#define IDS_MSG_RECORD_CREATE_FAILED    43069
#define IDS_MSG_RECORD_UPDATE_FAILED    43070
#define IDS_MSG_RECORD_CREATE_HOST_NAME_FAILED 43071
#define IDS_MSG_ZONE_INVALID_NAME       43072
#define IDS_MSG_RECORD_WARNING_DUPLICATE_RECORD 43074
#define IDS_DISABLED_FWDS_NO_RECURSION  43100
#define IDS_DISABLED_FWDS_DOWNLEVEL     43102
#define IDS_MSG_ZWIZ_SUCCESS            44000
#define IDS_MSG_ZWIZ_FAIL               44001
#define IDS_MSG_SERVWIZ_FINISH_NAME     44500
#define IDS_MSG_SERVWIZ_FINISH_FORWARDER 44501
#define IDS_MSG_SERVWIZ_FINISH_ROOT_SERVER 44503
#define IDS_MSG_SERVWIZ_FINISH_FWD_ZONE 44504
#define IDS_MSG_SERVWIZ_FINISH_REV_ZONE 44505
#define IDS_MSG_SERVWIZ_CONTACT         44506
#define IDS_MSG_SERVWIZ_COLLECTINFO     44507
#define IDS_MSG_SERVWIZ_FAIL_CONTACT    44508
#define IDS_MSG_SERVWIZ_NOT_NT5         44509
#define IDS_MSG_SERVWIZ_FAIL_CONTACT_ADD 44510
#define IDS_MSG_SERVWIZ_FAIL_ROOT_HINTS 44512
#define IDS_MSG_SERVWIZ_FAIL_UPDATE_ROOT_HINTS 44513
#define IDS_MSG_SERVWIZ_FAIL_ADD_ROOT_ZONE 44514
#define IDS_MSG_SERVWIZ_FAIL_ADD_FWD_ZONE 44515
#define IDS_MSG_SERVWIZ_FAIL_ADD_REV_ZONE 44516
#define IDS_MSG_DELEGWIZ_SUDOMAIN_EXISTS 45010
#define IDS_MSG_DELEGWIZ_NS_RECORD_FAILED 45011
#define IDS_MSG_DELEGWIZ_SUBDOMAIN_FAILED 45012
#define IDS_DELEGWIZ_DOMAIN_NAME_TITLE  45013
#define IDS_DELEGWIZ_DOMAIN_NAME_SUBTITLE 45014
#define IDS_DELEGWIZ_DOMAIN_NS_TITLE    45015
#define IDS_DELEGWIZ_DOMAIN_NS_SUBTITLE 45016
#define IDS_ZWIZ_FWD_ZONE_NAME_TITLE    45017
#define IDS_ZWIZ_FWD_ZONE_NAME_SUBTITLE 45018
#define IDS_ZWIZ_ZONE_LOOKUP_TITLE      45019
#define IDS_ZWIZ_ZONE_LOOKUP_SUBTITLE   45020
#define IDS_ZWIZ_ZONE_TYPE_TITLE        45021
#define IDS_ZWIZ_ZONE_TYPE_SUBTITLE     45022
#define IDS_ZWIZ_REV_ZONE_NAME_TITLE    45023
#define IDS_ZWIZ_REV_ZONE_NAME_SUBTITLE 45024
#define IDS_ZWIZ_MASTERS_TITLE          45025
#define IDS_ZWIZ_MASTERS_SUBTITLE       45026
#define IDS_ZWIZ_SELECT_SERVER_TITLE    45027
#define IDS_ZWIZ_SELECT_SERVER_SUBTITLE 45028
#define IDS_ZWIZ_STORAGE_TITLE          45029
#define IDS_ZWIZ_STORAGE_SUBTITLE       45030
#define IDS_SERVWIZ_FWD_ZONE_TITLE      45031
#define IDS_SERVWIZ_FWD_ZONE_SUBTITLE   45032
#define IDS_SERVWIZ_NAME_TITLE          45033
#define IDS_SERVWIZ_NAME_SUBTITLE       45034
#define IDS_SERVWIZ_REV_ZONE_TITLE      45035
#define IDS_SERVWIZ_REV_ZONE_SUBTITLE   45036
#define IDS_SERVWIZ_ROOT_SERV_TITLE     45037
#define IDS_SERVWIZ_ROOT_SERV_SUBTITLE  45038
#define IDS_ZWIZ_DYNAMIC_TITLE          45039
#define IDS_ZWIZ_DYNAMIC_SUBTITLE       45040
#define IDS_ZWIZ_ADREPLICATION_TITLE    45041
#define IDS_ZWIZ_ADREPLICATION_SUBTITLE 45042
#define IDS_ROOT_HINTS_DESCR            45100
#define IDS_ROOT_HINTS_NO               45101
#define IDS_DELEGATION_DESCR            45102
#define IDS_ERRMSG_BASE64               45103
#define IDS_MSG_SIG_LABEL_RANGE         45104
#define IDS_BUTTON_TEXT_PAUSE_BUTTON    57345
#define IDS_BUTTON_TEXT_START_BUTTON    57346
#define IDS_BUTTON_TEXT_CANCEL          57347
#define IDS_BUTTON_TEXT_DONE            57348
#define IDS_CHECK_TEXT_NOT_REPLICATE    57349
#define IDS_CHECK_TEXT_USE_LOCAL_WINS   57350
#define IDS_CHECK_TEXT_USE_LOCAL_WINSR  57351
#define IDS_MSG_SERVER_UPDATE_AGING     57352
#define IDS_SERVER_SCAVENGE_FORMAT      58000
#define IDS_SERVER_NO_REFRESH_FORMAT    58001
#define IDS_SERVER_REFRESH_FORMAT       58002
#define IDS_ENABLED                     58003
#define IDS_DISABLED                    58004
#define IDS_DAYS                        58005
#define IDS_HOURS                       58006
#define IDS_MSG_INVALID_REFRESH_INTERVAL 58007
#define IDS_MSG_INVALID_NOREFRESH_INTERVAL 58008
#define IDS_MESSAGE_VIEW_NO_SERVER_MESSAGE 58200
#define IDS_MESSAGE_VIEW_NO_SERVER_TITLE 58201
#define IDS_MESSAGE_VIEW_CONFIG_SERVER_TITLE 58202
#define IDS_MESSAGE_VIEW_CONFIG_SERVER_MESSAGE 58203
#define IDS_MESSAGE_VIEW_ACCESS_DENIED_TITLE 58204
#define IDS_MESSAGE_VIEW_ACCESS_DENIED_MESSAGE 58205
#define IDS_MESSAGE_VIEW_NOT_LOADED_TITLE 58206
#define IDS_MESSAGE_VIEW_NOT_LOADED_MESSAGE 58207
#define IDS_MESSAGE_VIEW_QUERY_FAILED_TITLE 58208
#define IDS_MESSAGE_VIEW_QUERY_FAILED_MESSAGE 58209
#define IDS_MESSAGE_VIEW_EMPTY_FOLDER_TITLE 58210
#define IDS_MESSAGE_VIEW_EMPTY_FOLDER_MESSAGE 58211
#define IDS_MESSAGE_VIEW_ZONE_NOT_LOADED_TITLE 58212
#define IDS_MESSAGE_VIEW_ZONE_NOT_LOADED_DS_MESSAGE 58213
#define IDS_MESSAGE_VIEW_ZONE_NOT_LOADED_PRIMARY_MESSAGE 58214
#define IDS_MESSAGE_VIEW_ZONE_NOT_LOADED_SECONDARY_MESSAGE 58215
#define IDS_ERRMSG_BAD_IPV6_TEXT        58216
#define IDS_BUTTON_NEW_RECORD           58500
#define IDS_TOOLTIP_NEW_RECORD          58501
#define IDS_NO_ROOTHINTS                58502
#define IDS_MASK_ALERT                  58503
#define IDS_BUTTON_NEW_ZONE             58504
#define IDS_TOOLTIP_NEW_ZONE            58505
#define IDS_TOOLTIP_NEW_SERVER          58506
#define IDS_BUTTON_NEW_SERVER           58507
#define IDS_SMALL_OPTION_NOTE           58508
#define IDS_MEDIUM_OPTION_NOTE          58509
#define IDS_MANUAL_OPTION_NOTE          58510
#define IDS_MSG_RECORD_WARNING_NS_NOT_FQDN 58511
#define IDC_STATIC_TEXT                 65535

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        168
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1327
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\recpag2.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       recpag2.cpp
//
//--------------------------------------------------------------------------



#include "preDNSsn.h"
#include <SnapBase.h>

#include "resource.h"
#include "dnsutil.h"
#include "DNSSnap.h"
#include "snapdata.h"

#include "server.h"
#include "domain.h"
#include "record.h"
#include "zone.h"

#ifdef DEBUG_ALLOCATOR
	#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
	#endif
#endif


////////////////////////////////////////////////////////////////////////////
// CDNS_A_RecordPropertyPage

BEGIN_MESSAGE_MAP(CDNS_A_RecordPropertyPage, CDNSRecordStandardPropertyPage)
	ON_EN_CHANGE(IDC_IPEDIT, OnIPv4CtrlChange)
  ON_BN_CLICKED(IDC_UPDATE_PRT_CHECK, OnCreatePointerClicked)
END_MESSAGE_MAP()


CDNS_A_RecordPropertyPage::CDNS_A_RecordPropertyPage()
						 : CDNSRecordStandardPropertyPage(IDD_RR_A)
{

}

BOOL CDNS_A_RecordPropertyPage::OnInitDialog()
{
   CDNSRecordStandardPropertyPage::OnInitDialog();

 	STANDARD_REC_PP_PTRS(CDNS_A_Record);
   CDNSZoneNode* pZoneNode = pHolder->GetDomainNode()->GetZoneNode();
   CDNSServerNode* pServerNode = pZoneNode->GetServerNode();

   if (pServerNode->GetBuildNumber() < DNS_SRV_BUILD_NUMBER_WHISTLER_NEW_SECURITY_SETTINGS ||
       (pServerNode->GetMajorVersion() <= DNS_SRV_MAJOR_VERSION_NT_5 &&
        pServerNode->GetMinorVersion() < DNS_SRV_MINOR_VERSION_WHISTLER) ||
       !pHolder->IsWizardMode() ||
       !pZoneNode->IsDSIntegrated())
   {
      GetSecurityCheckCtrl()->ShowWindow(FALSE);
      GetSecurityCheckCtrl()->EnableWindow(FALSE);
   }
   return FALSE;
}

void CDNS_A_RecordPropertyPage::OnIPv4CtrlChange()
{
	STANDARD_REC_PP_PTRS(CDNS_A_Record)
	SetDirty(TRUE);
}

void CDNS_A_RecordPropertyPage::OnCreatePointerClicked()
{
  STANDARD_REC_PP_PTRS(CDNS_A_Record)
  SetDirty(TRUE);
}

void CDNS_A_RecordPropertyPage::SetUIData()
{
	STANDARD_REC_PP_SETUI_PROLOGUE(CDNS_A_Record);
	GetIPv4Ctrl()->SetIPv4Val(pRecord->m_ipAddress);

  CDNSRootData* pRootData = dynamic_cast<CDNSRootData*>(GetHolder()->GetComponentData()->GetRootData());
  if (pRootData != NULL)
  {
    GetPTRCheckCtrl()->SetCheck(pRootData->GetCreatePTRWithHost());
  }
}

DNS_STATUS CDNS_A_RecordPropertyPage::GetUIDataEx(BOOL bSilent)
{
	STANDARD_REC_PP_GETUI_PROLOGUE(CDNS_A_Record);
	GetIPv4Ctrl()->GetIPv4Val(&(pRecord->m_ipAddress));
	if (GetPTRCheckCtrl()->GetCheck())
	{
		pRecord->m_dwFlags |= DNS_RPC_RECORD_FLAG_CREATE_PTR;
	}
  
   if (pHolder->IsWizardMode() &&
       GetSecurityCheckCtrl()->GetCheck())
   {
      pRecord->m_dwFlags |= DNS_RPC_FLAG_OPEN_ACL;
   }

  CDNSRootData* pRootData = dynamic_cast<CDNSRootData*>(GetHolder()->GetComponentData()->GetRootData());
  if (pRootData != NULL)
  {
    pRootData->SetCreatePTRWithHost(GetPTRCheckCtrl()->GetCheck());
  }

  return dwErr;
}


////////////////////////////////////////////////////////////////////////////
// CDNS_ATMA_RecordPropertyPage

BEGIN_MESSAGE_MAP(CDNS_ATMA_RecordPropertyPage, CDNSRecordStandardPropertyPage)
	ON_EN_CHANGE(IDC_EDIT_ATMA_ADDRESS, OnAddressChange)
	ON_BN_CLICKED(IDC_RADIO_E164, OnFormatRadioChange)
	ON_BN_CLICKED(IDC_RADIO_NSAP, OnFormatRadioChange)
END_MESSAGE_MAP()


CDNS_ATMA_RecordPropertyPage::CDNS_ATMA_RecordPropertyPage()
						 : CDNSRecordStandardPropertyPage(IDD_RR_ATMA)
{

}


UCHAR CDNS_ATMA_RecordPropertyPage::GetFormat()
{
  if (GetRadioNSAP()->GetCheck())
    return DNS_ATMA_FORMAT_AESA;

  ASSERT(GetRadioE164()->GetCheck());
  return DNS_ATMA_FORMAT_E164;
}

void CDNS_ATMA_RecordPropertyPage::SetFormat(UCHAR chFormat)
{
  GetRadioNSAP()->SetCheck(chFormat == DNS_ATMA_FORMAT_AESA);
  GetRadioE164()->SetCheck(chFormat == DNS_ATMA_FORMAT_E164);
}

void _StripDots(CString& s)
{
  int nLen = s.GetLength();
  if (nLen == 0)
    return;

  WCHAR* pBuf = (WCHAR*)malloc((nLen+1)*sizeof(WCHAR));
  if (!pBuf)
  {
    return;
  }
  ZeroMemory(pBuf, (nLen+1)*sizeof(WCHAR));
  int k=0;
  for (int i=0; i<nLen; i++)
  {
    if (s[i] != L'.')
    {
      pBuf[k++] = s[i];
    }
  }
  s = pBuf;

  if (pBuf)
  {
    free(pBuf);
    pBuf = 0;
  }
}


void CDNS_ATMA_RecordPropertyPage::OnAddressChange()
{
  BOOL bValid = TRUE;
  UCHAR chFormat = GetFormat();
  CString s;
  GetAddressCtrl()->GetWindowText(s);
  _StripDots(s);

  int nLen = s.GetLength();
  if (chFormat == DNS_ATMA_FORMAT_E164)
  {
     //it is a string
    bValid = (nLen <= DNS_ATMA_MAX_ADDR_LENGTH);
    if (bValid)
    {
      // check only numeric digits
      for (int i=0; i<nLen; i++)
      {
        if (iswdigit(s[i]) == 0)
        {
          bValid = FALSE;
          break;
        }
      }
    }
  }
  else
  {
    // must be of fixed length
    bValid = (nLen == 2*DNS_ATMA_MAX_ADDR_LENGTH);
    if (bValid)
    {
      // check only hex digits
      for (int i=0; i<nLen; i++)
      {
        if (HexCharToByte(s[i]) == 0xFF)
        {
          bValid = FALSE;
          break;
        }
      }
    }
  }
  SetValidState(bValid);
}



void CDNS_ATMA_RecordPropertyPage::OnFormatRadioChange()
{
  // reset the address, we changed format
  GetAddressCtrl()->SetWindowText(NULL);
  // it is OK th have E164 with empty field, but not NSAP
  SetValidState(GetFormat() == DNS_ATMA_FORMAT_E164);
}


void CDNS_ATMA_RecordPropertyPage::SetUIData()
{
	STANDARD_REC_PP_SETUI_PROLOGUE(CDNS_ATMA_Record);

  SetFormat(pRecord->m_chFormat);
  GetAddressCtrl()->SetWindowText(pRecord->m_szAddress);
}

DNS_STATUS CDNS_ATMA_RecordPropertyPage::GetUIDataEx(BOOL bSilent)
{
	STANDARD_REC_PP_GETUI_PROLOGUE(CDNS_ATMA_Record);

  pRecord->m_chFormat = GetFormat();
  GetAddressCtrl()->GetWindowText(pRecord->m_szAddress);
  _StripDots(pRecord->m_szAddress);
  return dwErr;
}

////////////////////////////////////////////////////////////////////////////
// CDNS_AAAA_RecordPropertyPage

BEGIN_MESSAGE_MAP(CDNS_AAAA_RecordPropertyPage, CDNSRecordStandardPropertyPage)
	ON_EN_CHANGE(IDC_IPV6EDIT, OnIPv6CtrlChange)
END_MESSAGE_MAP()


CDNS_AAAA_RecordPropertyPage::CDNS_AAAA_RecordPropertyPage()
						 : CDNSRecordStandardPropertyPage(IDD_RR_AAAA)
{

}

void CDNS_AAAA_RecordPropertyPage::OnIPv6CtrlChange()
{
	SetDirty(TRUE);
}



BOOL
CDNS_AAAA_RecordPropertyPage::OnInitDialog()
{
   CDNSRecordStandardPropertyPage::OnInitDialog();
   
   GetRRNameEdit()->SetLimitText(IP6_ADDRESS_STRING_BUFFER_LENGTH);

   return TRUE;
}



void CDNS_AAAA_RecordPropertyPage::SetUIData()
{
	STANDARD_REC_PP_SETUI_PROLOGUE(CDNS_AAAA_Record);

   // convert the address into it's string represenation

   WCHAR buf[IP6_ADDRESS_STRING_BUFFER_LENGTH + 1];
   ::ZeroMemory(buf, sizeof buf);
   
   Dns_Ip6AddressToString_W(buf, &pRecord->m_ipv6Address);
   
   GetIPv6Edit()->SetWindowText(buf);
}

DNS_STATUS CDNS_AAAA_RecordPropertyPage::GetUIDataEx(BOOL bSilent)
{
	STANDARD_REC_PP_GETUI_PROLOGUE(CDNS_AAAA_Record);

   // convert the string representation to the address

   ::ZeroMemory(&pRecord->m_ipv6Address, sizeof pRecord->m_ipv6Address);

   CString text;
   GetIPv6Edit()->GetWindowText(text);
   
   BOOL successful =
      Dns_Ip6StringToAddress_W(
         &pRecord->m_ipv6Address,
         (PWSTR) (PCWSTR) text);

   if (!successful)
   {
      // the string is not valid.  Complain to the user.  Setting dwErr
      // will cause CreateRecord to silently skip the attempt to create
      // the record.

      dwErr = DNS_ERROR_INVALID_IP_ADDRESS;

      if (!bSilent)
      {
         ::DNSMessageBox(IDS_ERRMSG_BAD_IPV6_TEXT);
      }
   }

  return dwErr;
}


BOOL
CDNS_AAAA_RecordPropertyPage::CreateRecord()
{
	CDNSRecordPropertyPageHolder* pHolder = (CDNSRecordPropertyPageHolder*)GetHolder();
	ASSERT(pHolder->IsWizardMode());

  //
  // Get the data from the UI
  //
	DNS_STATUS err = GetUIDataEx(FALSE);
	if (err != 0)
	{
      // the error message was already raised by GetUIDataEx
		return FALSE;
	}

  //
  // Create the new record
  //
	err = pHolder->CreateNewRecord(CanCreateDuplicateRecords());
	if (err != 0)
	{
    DNSErrorDialog(err,IDS_MSG_RECORD_CREATE_FAILED);
		return FALSE;
	}
	return TRUE;
}



BOOL
CDNS_AAAA_RecordPropertyPage::OnApply() 
{
	CDNSRecordPropertyPageHolder* pHolder = (CDNSRecordPropertyPageHolder*)GetHolder();
	if(pHolder->IsWizardMode())
	{
    //
		// this is the case of record creation,
		// the user hit OK and we want to create the record
    //
		return CreateRecord();
	}

  //
	// we are in the case of modeless sheet on existing record
  //
  CDNSRecordNodeBase* pRecordNode = pHolder->GetRecordNode();
	ASSERT(pRecordNode != NULL);
  DWORD dwZoneType = pRecordNode->GetDomainNode()->GetZoneNode()->GetZoneType();
	if ((dwZoneType == DNS_ZONE_TYPE_SECONDARY) || 
      (dwZoneType == DNS_ZONE_TYPE_STUB)      ||
      (dwZoneType == DNS_ZONE_TYPE_CACHE))
  {
    // read only case
    return TRUE; 
  }

  DNS_STATUS err = GetUIDataEx(FALSE);
	if (err != 0)
	{
		// the error message was already raised by GetUIDataEx

		return FALSE;
	}

	if (!IsDirty())
  {
		return TRUE;
  }

	err = pHolder->NotifyConsole(this);
	if (err == DNS_WARNING_PTR_CREATE_FAILED)
	{
		DNSMessageBox(IDS_MSG_RECORD_WARNING_CREATE_PTR);
		err = 0; // was just a warning
	}
	if (err != 0)
	{
		DNSErrorDialog(err,IDS_MSG_RECORD_UPDATE_FAILED);
		return FALSE;
	}
	else
	{
		SetDirty(FALSE);
	}
	return TRUE; // all is cool
}

   

////////////////////////////////////////////////////////////////////////////
// CDNS_HINFO_RecordPropertyPage

BEGIN_MESSAGE_MAP(CDNS_HINFO_RecordPropertyPage, CDNSRecordStandardPropertyPage)
	ON_EN_CHANGE(IDC_CPU_TYPE_EDIT, OnCPUTypeChange)
	ON_EN_CHANGE(IDC_OPERATING_SYSTEM_EDIT, OnOperatingSystemChange)
END_MESSAGE_MAP()


CDNS_HINFO_RecordPropertyPage::CDNS_HINFO_RecordPropertyPage()
						 : CDNSRecordStandardPropertyPage(IDD_RR_HINFO)
{
}

BOOL CDNS_HINFO_RecordPropertyPage::OnInitDialog()
{
  CDNSRecordStandardPropertyPage::OnInitDialog();

  //
  // The RDATA size field is a byte so we have to limit the size of the string
  // to 253 characters (add one for the trailing NULL character)
  //
  GetCPUTypeCtrl()->SetLimitText(253);
  GetOperatingSystemCtrl()->SetLimitText(253);

  return TRUE;
}

void CDNS_HINFO_RecordPropertyPage::OnCPUTypeChange()
{
	SetDirty((GetCPUTypeCtrl()->GetWindowTextLength() > 0) &&
           (GetOperatingSystemCtrl()->GetWindowTextLength() > 0));
}

void CDNS_HINFO_RecordPropertyPage::OnOperatingSystemChange()
{
	SetDirty((GetCPUTypeCtrl()->GetWindowTextLength() > 0) &&
           (GetOperatingSystemCtrl()->GetWindowTextLength() > 0));
}

void CDNS_HINFO_RecordPropertyPage::SetUIData()
{
	STANDARD_REC_PP_SETUI_PROLOGUE(CDNS_HINFO_Record);
	
	GetCPUTypeCtrl()->SetWindowText(pRecord->m_szCPUType);
	GetOperatingSystemCtrl()->SetWindowText(pRecord->m_szOperatingSystem);
}

DNS_STATUS CDNS_HINFO_RecordPropertyPage::GetUIDataEx(BOOL bSilent)
{
	STANDARD_REC_PP_GETUI_PROLOGUE(CDNS_HINFO_Record);

	GetCPUTypeCtrl()->GetWindowText(pRecord->m_szCPUType);
	GetOperatingSystemCtrl()->GetWindowText(pRecord->m_szOperatingSystem);
  return dwErr;
}


////////////////////////////////////////////////////////////////////////////
// CDNS_ISDN_RecordPropertyPage

BEGIN_MESSAGE_MAP(CDNS_ISDN_RecordPropertyPage, CDNSRecordStandardPropertyPage)
	ON_EN_CHANGE(IDC_PHONE_NUM_AND_DDI_EDIT, OnPhoneNumberAndDDIChange)
	ON_EN_CHANGE(IDC_SUBADDRESS_EDIT, OnSubAddressChange)
END_MESSAGE_MAP()


CDNS_ISDN_RecordPropertyPage::CDNS_ISDN_RecordPropertyPage()
						 : CDNSRecordStandardPropertyPage(IDD_RR_ISDN)
{

}

void CDNS_ISDN_RecordPropertyPage::OnPhoneNumberAndDDIChange()
{
	SetDirty(TRUE);
}

void CDNS_ISDN_RecordPropertyPage::OnSubAddressChange()
{
	SetDirty(TRUE);
}

void CDNS_ISDN_RecordPropertyPage::SetUIData()
{
	STANDARD_REC_PP_SETUI_PROLOGUE(CDNS_ISDN_Record);

   // NTRAID#NTBUG9-503827-2001/12/06-JeffJon
   // This is some arbitrary limit set by the server
   GetPhoneNumberAndDDICtrl()->SetLimitText(255);
	GetPhoneNumberAndDDICtrl()->SetWindowText(pRecord->m_szPhoneNumberAndDDI);

   // NTRAID#NTBUG9-503827-2001/12/06-JeffJon
   // This is some arbitrary limit set by the server
   GetSubAddressCtrl()->SetLimitText(255);
	GetSubAddressCtrl()->SetWindowText(pRecord->m_szSubAddress);
}

DNS_STATUS CDNS_ISDN_RecordPropertyPage::GetUIDataEx(BOOL bSilent)
{
	STANDARD_REC_PP_GETUI_PROLOGUE(CDNS_ISDN_Record);

	GetPhoneNumberAndDDICtrl()->GetWindowText(pRecord->m_szPhoneNumberAndDDI);
	GetSubAddressCtrl()->GetWindowText(pRecord->m_szSubAddress);
  return dwErr;
}

////////////////////////////////////////////////////////////////////////////
// CDNS_X25_RecordPropertyPage

BEGIN_MESSAGE_MAP(CDNS_X25_RecordPropertyPage, CDNSRecordStandardPropertyPage)
	ON_EN_CHANGE(IDC_X121_ADDRESS_EDIT, OnX121PSDNAddressChange)
END_MESSAGE_MAP()


CDNS_X25_RecordPropertyPage::CDNS_X25_RecordPropertyPage()
						 : CDNSRecordStandardPropertyPage(IDD_RR_X25)
{
}


BOOL CDNS_X25_RecordPropertyPage::OnInitDialog()
{
  CDNSRecordStandardPropertyPage::OnInitDialog();
  GetX121Edit()->SetLimitText(MAX_DNS_NAME_LEN);

  return TRUE;
}

void CDNS_X25_RecordPropertyPage::OnX121PSDNAddressChange()
{
	SetDirty(TRUE);
}


void CDNS_X25_RecordPropertyPage::SetUIData()
{
	STANDARD_REC_PP_SETUI_PROLOGUE(CDNS_X25_Record);
	
	GetX121Edit()->SetWindowText(pRecord->m_szX121PSDNAddress);
}

DNS_STATUS CDNS_X25_RecordPropertyPage::GetUIDataEx(BOOL bSilent)
{
	STANDARD_REC_PP_GETUI_PROLOGUE(CDNS_X25_Record);

  //
  // Retrieve the text
  //
  CString szName;
  GetX121Edit()->GetWindowText(szName);

  CDNSZoneNode* pZone = pHolder->GetDomainNode()->GetZoneNode();
  ASSERT(pZone != NULL);

  //
  // Any values are allowed for the data in advanced view
  //
  if (!(((CDNSRootData*)pZone->GetRootContainer()))->IsAdvancedView())
  {
    //
    // Validate the record name using the server flags as a guideline
    //
    CString szFullName;
    szFullName.Format(L"%s.%s", szName, pHolder->GetDomainNode()->GetFullName());

    DWORD dwNameChecking = pZone->GetServerNode()->GetNameCheckFlag();
    dwErr = ValidateRecordName(szFullName, dwNameChecking);
  }

  // Set the valid text
	pRecord->m_szX121PSDNAddress = szName;
  return dwErr;
}


////////////////////////////////////////////////////////////////////////////
// CDNS_PTR_CNAME_MB_MD_MF_MG_MR_NSCache_RecordPropertyPage

BEGIN_MESSAGE_MAP(CDNS_PTR_CNAME_MB_MD_MF_MG_MR_NSCache_RecordPropertyPage, CDNSRecordStandardPropertyPage)
	ON_EN_CHANGE(IDC_NAME_NODE_EDIT, OnNameNodeChange)
	ON_BN_CLICKED(IDC_BROWSE_BUTTON, OnBrowse)
END_MESSAGE_MAP()


CDNS_PTR_CNAME_MB_MD_MF_MG_MR_NSCache_RecordPropertyPage::
		CDNS_PTR_CNAME_MB_MD_MF_MG_MR_NSCache_RecordPropertyPage(UINT nIDTemplate) :
					CDNSRecordStandardPropertyPage(nIDTemplate)
{
}

BOOL CDNS_PTR_CNAME_MB_MD_MF_MG_MR_NSCache_RecordPropertyPage::OnInitDialog()
{
  CDNSRecordStandardPropertyPage::OnInitDialog();
  
  STANDARD_REC_PP_PTRS(CDNS_PTR_NS_CNAME_MB_MD_MF_MG_MR_Record);
  GetNameNodeEdit()->SetLimitText(MAX_DNS_NAME_LEN);

  return TRUE;
}


void CDNS_PTR_CNAME_MB_MD_MF_MG_MR_NSCache_RecordPropertyPage::OnNameNodeChange()
{
  STANDARD_REC_PP_PTRS(CDNS_PTR_NS_CNAME_MB_MD_MF_MG_MR_Record);

  CString szNewName;
  GetNameNodeEdit()->GetWindowText(szNewName);

  CDNSServerNode* pServerNode = pHolder->GetDomainNode()->GetServerNode();

  BOOL bIsValidName = TRUE;
  
  // Only validate the name if it is not advanced view

  if (!(((CDNSRootData*)pServerNode->GetRootContainer()))->IsAdvancedView())
  {
     DWORD dwNameChecking = pServerNode->GetNameCheckFlag();
     bIsValidName = (0 == ValidateDnsNameAgainstServerFlags(szNewName,
                                                            DnsNameDomain,
                                                            dwNameChecking));
  }
  SetValidState(bIsValidName);
}

void CDNS_PTR_CNAME_MB_MD_MF_MG_MR_NSCache_RecordPropertyPage::OnBrowse()
{
	STANDARD_REC_PP_PTRS(CDNS_PTR_NS_CNAME_MB_MD_MF_MG_MR_Record);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
  FIX_THREAD_STATE_MFC_BUG();
   CThemeContextActivator activator;


	CDNSBrowserDlg dlg(GetHolder()->GetComponentData(), GetHolder(),
		(pRecord->GetType() == DNS_TYPE_CNAME) ? RECORD_A_AND_CNAME : RECORD_A);
	if (IDOK == dlg.DoModal())
	{
		GetNameNodeEdit()->SetWindowText(dlg.GetSelectionString());
	}
}

void CDNS_PTR_CNAME_MB_MD_MF_MG_MR_NSCache_RecordPropertyPage::SetUIData()
{
	STANDARD_REC_PP_SETUI_PROLOGUE(CDNS_PTR_NS_CNAME_MB_MD_MF_MG_MR_Record);
	
	GetNameNodeEdit()->SetWindowText(pRecord->m_szNameNode);
}

DNS_STATUS CDNS_PTR_CNAME_MB_MD_MF_MG_MR_NSCache_RecordPropertyPage::GetUIDataEx(BOOL bSilent)
{
	STANDARD_REC_PP_GETUI_PROLOGUE(CDNS_PTR_NS_CNAME_MB_MD_MF_MG_MR_Record);

  //
  // Retrieve the text
  //
  CString szName;
  GetNameNodeEdit()->GetWindowText(szName);

  CDNSZoneNode* pZone = pHolder->GetDomainNode()->GetZoneNode();
  ASSERT(pZone != NULL);


  //
  // Set the valid text, no need to validate the data field
  //
	pRecord->m_szNameNode = szName;
  return dwErr;
}

////////////////////////////////////////////////////////////////////////////
// CDNS_CNAME_RecordPropertyPage

CDNS_CNAME_RecordPropertyPage::CDNS_CNAME_RecordPropertyPage()
	: CDNS_PTR_CNAME_MB_MD_MF_MG_MR_NSCache_RecordPropertyPage(IDD_RR_CNAME)
{

}

BOOL CDNS_CNAME_RecordPropertyPage::OnInitDialog()
{
   CDNS_PTR_CNAME_MB_MD_MF_MG_MR_NSCache_RecordPropertyPage::OnInitDialog();

 	STANDARD_REC_PP_PTRS(CDNS_CNAME_Record);
   CDNSZoneNode* pZoneNode = pHolder->GetDomainNode()->GetZoneNode();
   CDNSServerNode* pServerNode = pZoneNode->GetServerNode();

   if (pServerNode->GetBuildNumber() < DNS_SRV_BUILD_NUMBER_WHISTLER_NEW_SECURITY_SETTINGS ||
       (pServerNode->GetMajorVersion() <= DNS_SRV_MAJOR_VERSION_NT_5 &&
        pServerNode->GetMinorVersion() < DNS_SRV_MINOR_VERSION_WHISTLER) ||
       !pHolder->IsWizardMode() ||
       !pZoneNode->IsDSIntegrated())
   {
      GetSecurityCheckCtrl()->ShowWindow(FALSE);
      GetSecurityCheckCtrl()->EnableWindow(FALSE);
   }
   return FALSE;
}

DNS_STATUS CDNS_CNAME_RecordPropertyPage::GetUIDataEx(BOOL bSilent)
{
   DNS_STATUS dwErr = CDNS_PTR_CNAME_MB_MD_MF_MG_MR_NSCache_RecordPropertyPage::GetUIDataEx(bSilent);
	STANDARD_REC_PP_PTRS(CDNS_CNAME_Record);

   if (pHolder->IsWizardMode() &&
       GetSecurityCheckCtrl()->GetCheck())
   {
      pRecord->m_dwFlags |= DNS_RPC_FLAG_OPEN_ACL;
   }
   return dwErr;
}

////////////////////////////////////////////////////////////////////////////
// CDNS_MB_RecordPropertyPage

CDNS_MB_RecordPropertyPage::CDNS_MB_RecordPropertyPage()
	: CDNS_PTR_CNAME_MB_MD_MF_MG_MR_NSCache_RecordPropertyPage(IDD_RR_MB)
{

}


////////////////////////////////////////////////////////////////////////////
// CDNS_MD_RecordPropertyPage

CDNS_MD_RecordPropertyPage::CDNS_MD_RecordPropertyPage()
	: CDNS_PTR_CNAME_MB_MD_MF_MG_MR_NSCache_RecordPropertyPage(IDD_RR_MD)
{

}

////////////////////////////////////////////////////////////////////////////
// CDNS_MF_RecordPropertyPage

CDNS_MF_RecordPropertyPage::CDNS_MF_RecordPropertyPage()
	: CDNS_PTR_CNAME_MB_MD_MF_MG_MR_NSCache_RecordPropertyPage(IDD_RR_MF)
{

}

////////////////////////////////////////////////////////////////////////////
// CDNS_MG_RecordPropertyPage

CDNS_MG_RecordPropertyPage::CDNS_MG_RecordPropertyPage()
	: CDNS_PTR_CNAME_MB_MD_MF_MG_MR_NSCache_RecordPropertyPage(IDD_RR_MG)
{

}

BEGIN_MESSAGE_MAP(CDNS_MG_RecordPropertyPage, CDNS_PTR_CNAME_MB_MD_MF_MG_MR_NSCache_RecordPropertyPage)
	ON_BN_CLICKED(IDC_BROWSE_BUTTON, OnBrowse)
END_MESSAGE_MAP()

void CDNS_MG_RecordPropertyPage::OnBrowse()
{
	STANDARD_REC_PP_PTRS(CDNS_PTR_NS_CNAME_MB_MD_MF_MG_MR_Record);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
  FIX_THREAD_STATE_MFC_BUG();
   CThemeContextActivator activator;


	CDNSBrowserDlg dlg(GetHolder()->GetComponentData(), GetHolder(), RECORD_MB);
	if (IDOK == dlg.DoModal())
	{
		GetNameNodeEdit()->SetWindowText(dlg.GetSelectionString());
	}
}

////////////////////////////////////////////////////////////////////////////
// CDNS_MR_RecordPropertyPage

BEGIN_MESSAGE_MAP(CDNS_MR_RecordPropertyPage, CDNS_PTR_CNAME_MB_MD_MF_MG_MR_NSCache_RecordPropertyPage)
	ON_EN_CHANGE(IDC_NAME_NODE_EDIT, OnNameNodeChange)
	ON_BN_CLICKED(IDC_BROWSE_BUTTON, OnBrowse)
END_MESSAGE_MAP()

CDNS_MR_RecordPropertyPage::CDNS_MR_RecordPropertyPage()
	: CDNS_PTR_CNAME_MB_MD_MF_MG_MR_NSCache_RecordPropertyPage(IDD_RR_MR)
{

}

void CDNS_MR_RecordPropertyPage::OnNameNodeChange()
{
  //
  // Get the name from the data
  //
  CString szNameNode;
  GetNameNodeEdit()->GetWindowText(szNameNode);

  //
  // Get the new name of the record
  //
	CString szRecordName;
	GetEditBoxText(szRecordName);

  SetValidState(GetNameNodeEdit()->GetWindowTextLength() > 0 &&
                _wcsicmp(szNameNode, szRecordName) != 0);
}

void CDNS_MR_RecordPropertyPage::OnBrowse()
{
	STANDARD_REC_PP_PTRS(CDNS_PTR_NS_CNAME_MB_MD_MF_MG_MR_Record);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
  FIX_THREAD_STATE_MFC_BUG();
   CThemeContextActivator activator;


	CDNSBrowserDlg dlg(GetHolder()->GetComponentData(), GetHolder(), RECORD_MB);
	if (IDOK == dlg.DoModal())
	{
		GetNameNodeEdit()->SetWindowText(dlg.GetSelectionString());
	}
}


////////////////////////////////////////////////////////////////////////////
// CDNS_NSCache_RecordPropertyPage

CDNS_NSCache_RecordPropertyPage::CDNS_NSCache_RecordPropertyPage()
	: CDNS_PTR_CNAME_MB_MD_MF_MG_MR_NSCache_RecordPropertyPage(IDD_RR_NS_CACHE)
{

}

////////////////////////////////////////////////////////////////////////////
// CDNS_PTR_RecordPropertyPage

CDNS_PTR_RecordPropertyPage::CDNS_PTR_RecordPropertyPage()
	: CDNS_PTR_CNAME_MB_MD_MF_MG_MR_NSCache_RecordPropertyPage(IDD_RR_PTR)
{
	m_bAdvancedView = TRUE;
	m_nOctets = -1; // invalid if advanced view
}


BEGIN_MESSAGE_MAP(CDNS_PTR_RecordPropertyPage, 
  CDNS_PTR_CNAME_MB_MD_MF_MG_MR_NSCache_RecordPropertyPage)
  ON_EN_CHANGE(IDC_RR_NAME_IPEDIT, OnIPv4CtrlChange)
END_MESSAGE_MAP()


BOOL CDNS_PTR_RecordPropertyPage::OnInitDialog()
{
  //
	// we call three levels up in the deriviation chain to enable/disable TTL control
	// we do not call the base class
	// CDNSRecordPropertyPage::OnInitDialog();
  //
	CDNSRecordStandardPropertyPage::OnInitDialog();

  //
	// move the edit box in place of the IP control
  //
	CDNSIPv4Control* pNameIPCtrl = GetIPv4Ctrl();
	CRect r;
	pNameIPCtrl->GetWindowRect(r);
	ScreenToClient(r);
	GetRRNameEdit()->MoveWindow(&r);

  //
  // set limit on node name length
  //
  GetNameNodeEdit()->SetLimitText(MAX_DNS_NAME_LEN);

 	STANDARD_REC_PP_PTRS(CDNS_PTR_Record);
   CDNSZoneNode* pZoneNode = pHolder->GetDomainNode()->GetZoneNode();
   CDNSServerNode* pServerNode = pZoneNode->GetServerNode();

   if (pServerNode->GetBuildNumber() < DNS_SRV_BUILD_NUMBER_WHISTLER_NEW_SECURITY_SETTINGS ||
       (pServerNode->GetMajorVersion() <= DNS_SRV_MAJOR_VERSION_NT_5 &&
        pServerNode->GetMinorVersion() < DNS_SRV_MINOR_VERSION_WHISTLER) ||
       !pHolder->IsWizardMode() ||
       !pZoneNode->IsDSIntegrated())
   {
      GetSecurityCheckCtrl()->ShowWindow(FALSE);
      GetSecurityCheckCtrl()->EnableWindow(FALSE);
   }

   return TRUE;
}

void CDNS_PTR_RecordPropertyPage::OnIPv4CtrlChange()
{
	STANDARD_REC_PP_PTRS(CDNS_PTR_Record);
   CString s;
   CDNSDomainNode* pDomainNode = pHolder->GetDomainNode();

   CDNSIPv4Control* pNameIPCtrl = GetIPv4Ctrl();
	DWORD dwArr[4];
	pNameIPCtrl->GetArray(dwArr, IP_OCTET_COUNT);
	ASSERT(dwArr[m_nOctets] <= 255);

   if (dwArr[m_nOctets] != FIELD_EMPTY)
   {
	   s.Format(_T("%d"), dwArr[m_nOctets]);
      for (int idx = m_nOctets + 1; idx < IP_OCTET_COUNT; idx++)
      {
        if (dwArr[idx] != FIELD_EMPTY)
        {
          CString szTemp;
          szTemp.Format(_T("%d."), dwArr[idx]);
          s = szTemp + s;
        }
      }

      s += CString(L".") + pDomainNode->GetFullName();
   }
   else
   {
      s = pDomainNode->GetFullName();
   }
   SetDlgItemText(IDC_RR_DOMAIN_EDIT, s);
	SetDirty(TRUE);
}

void CDNS_PTR_RecordPropertyPage::SetUIData()
{
	STANDARD_REC_PP_PTRS(CDNS_PTR_Record);
	ASSERT(pRecord->GetType() == DNS_TYPE_PTR);

  CDNS_PTR_CNAME_MB_MD_MF_MG_MR_NSCache_RecordPropertyPage::SetUIData();

  //
	// get useful pointers
  //
	CDNSIPv4Control* pNameIPCtrl = GetIPv4Ctrl();
	CDNSRootData* pRootData = (CDNSRootData*)pHolder->GetComponentData()->GetRootData();
	ASSERT(pRootData != NULL);
	CDNSRecordNodeBase* pRecordNodeBase = pHolder->GetRecordNode();
	ASSERT(pRecordNodeBase != NULL);
	CDNSDomainNode* pDomainNode = pHolder->GetDomainNode();
	ASSERT(pDomainNode != NULL);

  //
	// set standard fields
  //
	GetTTLCtrl()->SetTTL(pRecord->m_dwTtlSeconds);
	GetRRNameEdit()->SetWindowText(pRecord->m_szNameNode);

  //
	// set the FQDN for the domain the record is in
  //
	GetDomainEditBox()->SetWindowText(pHolder->GetDomainNode()->GetFullName());

	m_bAdvancedView = pRootData->IsAdvancedView();

  //
	// force advanced view if we are in a forward lookup zone
  //
	if (!(pDomainNode->GetZoneNode()->IsReverse()))
  {
		m_bAdvancedView = TRUE;
  }

  //
	// determine if we can have a normal view representation
  //
	CString szDomainName = pDomainNode->GetFullName();
	if (!m_bAdvancedView)
	{
    //
		// to have normal view we have to have a valid arpa suffix
    //
		BOOL bArpa = RemoveInAddrArpaSuffix(szDomainName.GetBuffer(1));
		szDomainName.ReleaseBuffer(); // got "77.80.55.157"
		if (!bArpa)
		{
			m_bAdvancedView = TRUE; // no need to toggle
		}
		else
		{
			m_nOctets = ReverseIPString(szDomainName.GetBuffer(1));
			szDomainName.ReleaseBuffer(); // finally got "157.55.80.77"
			// to have a normal view representation we cannot 
			// have more than 3 octects
			if (m_nOctets > 3)
			{
				m_bAdvancedView = TRUE; // force advanced for classless
			}
			else
			{
				ASSERT(m_nOctets > 0);
				if (pHolder->IsWizardMode())
				{
					szDomainName += _T(".0"); // placeholder
				}
				else
				{
					szDomainName += _T(".");
					szDomainName += ((CDNS_PTR_RecordNode*)pRecordNodeBase)->GetTrueRecordName();
				}
				switch(m_nOctets)
				{
				case 1: // e.g. "157", now "157._"
					szDomainName += _T(".0.0"); // got "157._.0.0"
					break;
				case 2: // e.g. "157.55"
					szDomainName += _T(".0"); // got "157.55._.0"
					break;
				};
				// set the IP control with IP mask value
				IP_ADDRESS ipAddr = IPStringToAddr(szDomainName);
				if (ipAddr != INADDR_NONE)
				{
					pNameIPCtrl->SetIPv4Val(ipAddr);
          
          switch(m_nOctets)
          {
          case 1:
            pNameIPCtrl->Clear(2);
            pNameIPCtrl->Clear(3);
            break;
          case 2:
            pNameIPCtrl->Clear(3);
            break;
          }

					// in wizard modeneed to disable all fields but the one to fill in 
					if (pHolder->IsWizardMode())
					{
						for (int k=0; k<4; k++)
							pNameIPCtrl->EnableField(k, k >= m_nOctets);	
					}
				}
				else
				{
					m_bAdvancedView = TRUE;
				}
			}
		}

	}

  //
	// view might have been changed to advanced
  //
	if (m_bAdvancedView)
	{
		GetRRNameEdit()->SetWindowText(pRecordNodeBase->GetDisplayName());
	}

  //
	// enable/hide appropriate controls
  //
	if (m_bAdvancedView)
	{
		pNameIPCtrl->EnableWindow(FALSE);
		pNameIPCtrl->ShowWindow(FALSE);

    //
		// can edit the name only when creating the record
    //
		GetRRNameEdit()->SetReadOnly(!pHolder->IsWizardMode());
	}
	else
	{
		GetRRNameEdit()->EnableWindow(FALSE);
		GetRRNameEdit()->ShowWindow(FALSE);

    //
		// can edit the name only when creating the record
    //
		pNameIPCtrl->EnableWindow(pHolder->IsWizardMode());
	}

  //
  // Set the aging/scavenging controls
  //
  GetDeleteStale()->SetCheck(pRecord->m_dwScavengeStart != 0);
  SetTimeStampEdit(pRecord->m_dwScavengeStart);

}

DNS_STATUS CDNS_PTR_RecordPropertyPage::GetUIDataEx(BOOL)
{
	STANDARD_REC_PP_PTRS(CDNS_PTR_Record);

	GetTTLCtrl()->GetTTL(&(pRecord->m_dwTtlSeconds));

	GetNameNodeEdit()->GetWindowText(pRecord->m_szNameNode);

  //
	// only in wizard mode we can change the edit box content
  //
	if(pHolder->IsWizardMode())
	{
		CString s;
		CDNSRecordNodeBase* pRecordNode = pHolder->GetRecordNode();
		if (m_bAdvancedView)
		{
      //
      // No need to validate name for PTR in advanced mode
      //
			GetEditBoxText(s);
			ASSERT(!s.IsEmpty());
			
		}
		else // normal view
		{
			CDNSIPv4Control* pNameIPCtrl = GetIPv4Ctrl();
			DWORD dwArr[4];
			pNameIPCtrl->GetArray(dwArr, IP_OCTET_COUNT);
			ASSERT(dwArr[m_nOctets] <= 255);
			s.Format(_T("%d"), dwArr[m_nOctets]);
      for (int idx = m_nOctets + 1; idx < IP_OCTET_COUNT; idx++)
      {
        if (dwArr[idx] != FIELD_EMPTY)
        {
          CString szTemp;
          szTemp.Format(_T("%d."), dwArr[idx]);
          s = szTemp + s;
        }
      }
		}
		pRecordNode->SetRecordName(s,FALSE /*bAtTheNode*/);
		if (!m_bAdvancedView)
		{
			CDNSRecordNodeBase* pRecordNodeBase = pHolder->GetRecordNode();
			ASSERT(pRecordNodeBase != NULL);
			((CDNS_PTR_RecordNode*)pRecordNodeBase)->ChangeDisplayName(pHolder->GetDomainNode(), 
																		m_bAdvancedView);
		}
	} // if wizard mode

  //
  // Get the aging/scavenging info from controls
  //
  if (GetDeleteStale()->GetCheck())
  {
    pRecord->m_dwFlags |= DNS_RPC_RECORD_FLAG_AGING_ON;
  }
  else
  {
    pRecord->m_dwFlags &= ~DNS_RPC_RECORD_FLAG_AGING_ON;
  }

   if (pHolder->IsWizardMode() &&
       GetSecurityCheckCtrl()->GetCheck())
   {
      pRecord->m_dwFlags |= DNS_RPC_FLAG_OPEN_ACL;
   }

  return 0;
}


////////////////////////////////////////////////////////////////////////////
// CDNS_MINFO_RP_RecordPropertyPage

BEGIN_MESSAGE_MAP(CDNS_MINFO_RP_RecordPropertyPage, CDNSRecordStandardPropertyPage)
	ON_EN_CHANGE(IDC_NAME_MAILBOX_EDIT, OnNameMailBoxChange)
	ON_EN_CHANGE(IDC_ERROR_MAILBOX_EDIT, OnErrorToMailboxChange)
	ON_BN_CLICKED(IDC_BROWSE_NAME_MAILBOX_BUTTON, OnBrowseNameMailBox)
	ON_BN_CLICKED(IDC_BROWSE_ERROR_MAILBOX_BUTTON, OnBrowseErrorToMailbox)
END_MESSAGE_MAP()


CDNS_MINFO_RP_RecordPropertyPage::
		CDNS_MINFO_RP_RecordPropertyPage(UINT nIDTemplate) :
					CDNSRecordStandardPropertyPage(nIDTemplate)
{
}

void CDNS_MINFO_RP_RecordPropertyPage::OnNameMailBoxChange()
{
	SetDirty(TRUE);
}

void CDNS_MINFO_RP_RecordPropertyPage::OnErrorToMailboxChange()
{
	SetDirty(TRUE);
}

void CDNS_MINFO_RP_RecordPropertyPage::OnBrowseNameMailBox()
{
	STANDARD_REC_PP_PTRS(CDNS_MINFO_RP_Record);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
  FIX_THREAD_STATE_MFC_BUG();
   CThemeContextActivator activator;


	CDNSBrowserDlg dlg(pHolder->GetComponentData(), pHolder, RECORD_MB);
	if (IDOK == dlg.DoModal())
	{
		GetNameMailBoxCtrl()->SetWindowText(dlg.GetSelectionString());
	}
}

void CDNS_MINFO_RP_RecordPropertyPage::OnBrowseErrorToMailbox()
{
	STANDARD_REC_PP_PTRS(CDNS_MINFO_RP_Record);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
  FIX_THREAD_STATE_MFC_BUG();
   CThemeContextActivator activator;


	CDNSBrowserDlg dlg(pHolder->GetComponentData(), pHolder, 
		(pRecord->m_wType == DNS_TYPE_RP) ? RECORD_TEXT : RECORD_MB);
	if (IDOK == dlg.DoModal())
	{
		GetErrorToMailboxCtrl()->SetWindowText(dlg.GetSelectionString());
	}
}

void CDNS_MINFO_RP_RecordPropertyPage::SetUIData()
{
	STANDARD_REC_PP_SETUI_PROLOGUE(CDNS_MINFO_RP_Record);
	
  GetNameMailBoxCtrl()->SetLimitText(MAX_DNS_NAME_LEN);
	GetNameMailBoxCtrl()->SetWindowText(pRecord->m_szNameMailBox);
  GetErrorToMailboxCtrl()->SetLimitText(MAX_DNS_NAME_LEN);
	GetErrorToMailboxCtrl()->SetWindowText(pRecord->m_szErrorToMailbox);
}

DNS_STATUS CDNS_MINFO_RP_RecordPropertyPage::GetUIDataEx(BOOL bSilent)
{
	STANDARD_REC_PP_GETUI_PROLOGUE(CDNS_MINFO_RP_Record);

	GetNameMailBoxCtrl()->GetWindowText(pRecord->m_szNameMailBox);
	GetErrorToMailboxCtrl()->GetWindowText(pRecord->m_szErrorToMailbox);
  return dwErr;
}





////////////////////////////////////////////////////////////////////////////
// CDNS_MINFO_RecordPropertyPage

CDNS_MINFO_RecordPropertyPage::CDNS_MINFO_RecordPropertyPage()
	: CDNS_MINFO_RP_RecordPropertyPage(IDD_RR_MINFO)
{

}

////////////////////////////////////////////////////////////////////////////
// CDNS_RP_RecordPropertyPage

CDNS_RP_RecordPropertyPage::CDNS_RP_RecordPropertyPage()
	: CDNS_MINFO_RP_RecordPropertyPage(IDD_RR_RP)
{

}


////////////////////////////////////////////////////////////////////////////
// CDNS_MX_AFSDB_RT_RecordPropertyPage

BEGIN_MESSAGE_MAP(CDNS_MX_AFSDB_RT_RecordPropertyPage, CDNSRecordStandardPropertyPage)
	ON_EN_CHANGE(IDC_NAME_EXCHANGE_EDIT, OnNameExchangeChange)
	ON_BN_CLICKED(IDC_BROWSE_BUTTON, OnBrowse)
END_MESSAGE_MAP()


CDNS_MX_AFSDB_RT_RecordPropertyPage::
		CDNS_MX_AFSDB_RT_RecordPropertyPage(UINT nIDTemplate) :
					CDNSRecordStandardPropertyPage(nIDTemplate)
{
}

void CDNS_MX_AFSDB_RT_RecordPropertyPage::OnNameExchangeChange()
{
	SetDirty(TRUE);
}


void CDNS_MX_AFSDB_RT_RecordPropertyPage::OnBrowse()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
  FIX_THREAD_STATE_MFC_BUG();
   CThemeContextActivator activator;


	CDNSBrowserDlg dlg(GetHolder()->GetComponentData(), GetHolder(), RECORD_A);
	if (IDOK == dlg.DoModal())
	{
		GetNameExchangeCtrl()->SetWindowText(dlg.GetSelectionString());
	}
}


void CDNS_MX_AFSDB_RT_RecordPropertyPage::SetUIData()
{
	STANDARD_REC_PP_SETUI_PROLOGUE(CDNS_MX_AFSDB_RT_Record);
	
  GetNameExchangeCtrl()->SetLimitText(MAX_DNS_NAME_LEN);
	GetNameExchangeCtrl()->SetWindowText(pRecord->m_szNameExchange);
}

DNS_STATUS CDNS_MX_AFSDB_RT_RecordPropertyPage::GetUIDataEx(BOOL bSilent)
{
	STANDARD_REC_PP_GETUI_PROLOGUE(CDNS_MX_AFSDB_RT_Record);

  CString szNameExchange;
	GetNameExchangeCtrl()->GetWindowText(szNameExchange);

  DWORD dwNameChecking = pHolder->GetDomainNode()->GetServerNode()->GetNameCheckFlag();
  dwErr = ::ValidateDnsNameAgainstServerFlags(szNameExchange, 
                                              DnsNameHostnameFull,
                                              dwNameChecking);
  if (dwErr != 0)
  {
    return dwErr;
  }

  pRecord->m_szNameExchange = szNameExchange;
  return dwErr;
}


////////////////////////////////////////////////////////////////////////////
// CDNS_MX_RT_RecordPropertyPage

BEGIN_MESSAGE_MAP(CDNS_MX_RT_RecordPropertyPage, CDNS_MX_AFSDB_RT_RecordPropertyPage)
	ON_EN_CHANGE(IDC_PREFERENCE_EDIT, OnPreferenceChange)
END_MESSAGE_MAP()


CDNS_MX_RT_RecordPropertyPage::
		CDNS_MX_RT_RecordPropertyPage(UINT nIDTemplate) :
					CDNS_MX_AFSDB_RT_RecordPropertyPage(nIDTemplate)
{
}

BOOL CDNS_MX_RT_RecordPropertyPage::OnInitDialog()
{
	CDNS_MX_AFSDB_RT_RecordPropertyPage::OnInitDialog();

	VERIFY(m_preferenceEdit.SubclassDlgItem(IDC_PREFERENCE_EDIT, this));
	m_preferenceEdit.SetRange(0,0xffff ); // unsigned short

  // Disable IME support on the control
  ImmAssociateContext(m_preferenceEdit.GetSafeHwnd(), NULL);

	return TRUE;
}

void CDNS_MX_RT_RecordPropertyPage::OnPreferenceChange()
{
	SetDirty(TRUE);
}

void CDNS_MX_RT_RecordPropertyPage::SetUIData()
{
	STANDARD_REC_PP_PTRS(CDNS_MX_AFSDB_RT_Record)
	CDNS_MX_AFSDB_RT_RecordPropertyPage::SetUIData();
	
	VERIFY(m_preferenceEdit.SetVal(pRecord->m_wPreference));
}

DNS_STATUS CDNS_MX_RT_RecordPropertyPage::GetUIDataEx(BOOL bSilent)
{
	STANDARD_REC_PP_PTRS(CDNS_MX_AFSDB_RT_Record)
	DNS_STATUS dwErr = CDNS_MX_AFSDB_RT_RecordPropertyPage::GetUIDataEx(bSilent);

	pRecord->m_wPreference = (WORD)m_preferenceEdit.GetVal();
  return dwErr;
}


////////////////////////////////////////////////////////////////////////////
// CDNS_MX_RecordPropertyPage

CDNS_MX_RecordPropertyPage::CDNS_MX_RecordPropertyPage()
						 : CDNS_MX_RT_RecordPropertyPage(IDD_RR_MX)
{
}

DNS_STATUS CDNS_MX_RecordPropertyPage::ValidateRecordName(PCWSTR pszName, DWORD dwNameChecking)
{
  CDNSRecordPropertyPageHolder* pHolder = GetDNSRecordHolder();
  CDNSRootData* pRootData = (CDNSRootData*)pHolder->GetComponentData()->GetRootData();
	ASSERT(pRootData != NULL);
  if (pRootData->IsAdvancedView())
  {
    //
    // Don't validate the name in advanced view
    //
    return 0;
  }

  DNS_STATUS dwError = CDNSRecordStandardPropertyPage::ValidateRecordName(pszName, dwNameChecking);
  if (dwError != 0)
  {
    DNS_STATUS dwWildcardError = ::ValidateDnsNameAgainstServerFlags(pszName, DnsNameWildcard, dwNameChecking);
    if (dwWildcardError == 0)
    {
      dwError = 0;
    }
  }
  return dwError;
}

////////////////////////////////////////////////////////////////////////////
// CDNS_RT_RecordPropertyPage

CDNS_RT_RecordPropertyPage::CDNS_RT_RecordPropertyPage()
						 : CDNS_MX_RT_RecordPropertyPage(IDD_RR_RT)
{

}


/////////////////////////////////////////////////////////////////////////////
// CDNS_AFSDB_RecordPropertyPage

BEGIN_MESSAGE_MAP(CDNS_AFSDB_RecordPropertyPage, CDNS_MX_AFSDB_RT_RecordPropertyPage)
	ON_EN_CHANGE(IDC_SUBTYPE_EDIT, OnSubtypeEditChange)
	ON_BN_CLICKED(IDC_AFS_VLS_RADIO, OnSubtypeRadioChange)
	ON_BN_CLICKED(IDC_DCE_ANS_RADIO, OnSubtypeRadioChange)
	ON_BN_CLICKED(IDC_OTHER_RADIO, OnSubtypeRadioChange)

END_MESSAGE_MAP()


CDNS_AFSDB_RecordPropertyPage::CDNS_AFSDB_RecordPropertyPage()
						 : CDNS_MX_AFSDB_RT_RecordPropertyPage(IDD_RR_AFSDB)
{

}

BOOL CDNS_AFSDB_RecordPropertyPage::OnInitDialog()
{
	CDNS_MX_AFSDB_RT_RecordPropertyPage::OnInitDialog();

	VERIFY(m_subtypeEdit.SubclassDlgItem(IDC_SUBTYPE_EDIT, this));
	m_subtypeEdit.SetRange(0,0xffff); // unsigned short
  m_subtypeEdit.SetLimitText(5);

  // Disable IME support on the controls
  ImmAssociateContext(m_subtypeEdit.GetSafeHwnd(), NULL);

	return TRUE;
}

void CDNS_AFSDB_RecordPropertyPage::OnSubtypeEditChange()
{
	SetDirty(TRUE);
}

void CDNS_AFSDB_RecordPropertyPage::OnSubtypeRadioChange()
{
	STANDARD_REC_PP_PTRS(CDNS_MX_AFSDB_RT_Record)

	CButton* pAFSRadioButton = GetAFSRadioButton();
	CButton* pDCERadioButton = GetDCERadioButton();

	if (pAFSRadioButton->GetCheck())
	{
		m_subtypeEdit.EnableWindow(FALSE);
		m_subtypeEdit.SetWindowText(NULL);
		pRecord->m_wPreference = AFSDB_PREF_AFS_CELL_DB_SERV;
	}
	else if (pDCERadioButton->GetCheck())
	{
		m_subtypeEdit.EnableWindow(FALSE);
		m_subtypeEdit.SetWindowText(NULL);
		pRecord->m_wPreference = AFSDB_PREF_DCE_AUTH_NAME_SERV;
	}
	else
	{
		ASSERT(GetOtherRadioButton()->GetCheck());
		m_subtypeEdit.EnableWindow(TRUE);
		VERIFY(m_subtypeEdit.SetVal(pRecord->m_wPreference));
	}

	SetDirty(TRUE);
}


void CDNS_AFSDB_RecordPropertyPage::SetUIData()
{
	STANDARD_REC_PP_PTRS(CDNS_MX_AFSDB_RT_Record)
	CDNS_MX_AFSDB_RT_RecordPropertyPage::SetUIData();

	CButton* pAFSRadioButton = GetAFSRadioButton();
	CButton* pDCERadioButton = GetDCERadioButton();
	CButton* pOtherRadioButton = GetOtherRadioButton();

	switch (pRecord->m_wPreference)
	{
	case AFSDB_PREF_AFS_CELL_DB_SERV:
		{
			pAFSRadioButton->SetCheck(TRUE);
			pDCERadioButton->SetCheck(FALSE);
			pOtherRadioButton->SetCheck(FALSE);

			m_subtypeEdit.EnableWindow(FALSE);
			m_subtypeEdit.SetWindowText(L"");
		}
		break;
	case AFSDB_PREF_DCE_AUTH_NAME_SERV:
		{
			pAFSRadioButton->SetCheck(FALSE);
			pDCERadioButton->SetCheck(TRUE);
			pOtherRadioButton->SetCheck(FALSE);

			m_subtypeEdit.EnableWindow(FALSE);
			m_subtypeEdit.SetWindowText(L"");
		}
		break;
	default:
		{
			pAFSRadioButton->SetCheck(FALSE);
			pDCERadioButton->SetCheck(FALSE);
			pOtherRadioButton->SetCheck(TRUE);

			m_subtypeEdit.EnableWindow(TRUE);
			VERIFY(m_subtypeEdit.SetVal(pRecord->m_wPreference));
		}
	}

}

DNS_STATUS CDNS_AFSDB_RecordPropertyPage::GetUIDataEx(BOOL bSilent)
{
	STANDARD_REC_PP_PTRS(CDNS_MX_AFSDB_RT_Record)
	DNS_STATUS dwErr = CDNS_MX_AFSDB_RT_RecordPropertyPage::GetUIDataEx(bSilent);

	CButton* pAFSRadioButton = GetAFSRadioButton();
	CButton* pDCERadioButton = GetDCERadioButton();

	if (pAFSRadioButton->GetCheck())
	{
		pRecord->m_wPreference = AFSDB_PREF_AFS_CELL_DB_SERV;
	}
	else if (pDCERadioButton->GetCheck())
	{
		pRecord->m_wPreference = AFSDB_PREF_DCE_AUTH_NAME_SERV;
	}
	else
	{
		ASSERT(GetOtherRadioButton()->GetCheck());
		pRecord->m_wPreference = (WORD)m_subtypeEdit.GetVal();
	}
  return dwErr;
}


////////////////////////////////////////////////////////////////////////////
// CDNS_WKS_RecordPropertyPage

BEGIN_MESSAGE_MAP(CDNS_WKS_RecordPropertyPage, CDNSRecordStandardPropertyPage)
	ON_EN_CHANGE(IDC_IPEDIT, OnIPv4CtrlChange)
	ON_BN_CLICKED(IDC_TCP_RADIO, OnProtocolRadioChange)
	ON_BN_CLICKED(IDC_UDP_RADIO, OnProtocolRadioChange)
	ON_EN_CHANGE(IDC_SERVICES_EDIT, OnServicesEditChange)
END_MESSAGE_MAP()


CDNS_WKS_RecordPropertyPage::CDNS_WKS_RecordPropertyPage()
						 : CDNSRecordStandardPropertyPage(IDD_RR_WKS)
{

}

BOOL CDNS_WKS_RecordPropertyPage::CreateRecord()
{
	CDNSRecordPropertyPageHolder* pHolder = (CDNSRecordPropertyPageHolder*)GetHolder();
	ASSERT(pHolder->IsWizardMode());

  //
  // Get the data from the UI
  //
	DNS_STATUS err = GetUIDataEx(FALSE);
	if (err != 0)
	{
		DNSErrorDialog(err,IDS_MSG_RECORD_CREATE_FAILED);
		return FALSE;
	}

  //
  // Create the new record
  //
	err = pHolder->CreateNewRecord(CanCreateDuplicateRecords());
	if (err != 0)
	{
    if (err == DNS_ERROR_INVALID_DATA)
    {
      //
      // Filter out invalid data error and present a more meaningful error message
      //
      DNSMessageBox(IDS_ERRMSG_WKS_INVALID_DATA);
    }
    else
    {
		  DNSErrorDialog(err,IDS_MSG_RECORD_CREATE_FAILED);
    }
		return FALSE;
	}
	return TRUE;
}

void CDNS_WKS_RecordPropertyPage::OnIPv4CtrlChange()
{
	STANDARD_REC_PP_PTRS(CDNS_WKS_Record)
  SetDirty(TRUE);
}

void CDNS_WKS_RecordPropertyPage::OnProtocolRadioChange()
{
	STANDARD_REC_PP_PTRS(CDNS_WKS_Record)

	CButton* pTCPRadio = GetTCPRadioButton();
	CButton* pUDPRadio = GetUDPRadioButton();

	if (pTCPRadio->GetCheck())
	{
		pUDPRadio->SetCheck(FALSE);
	}
	else if (pUDPRadio->GetCheck())
	{
		pTCPRadio->SetCheck(FALSE);
	}

	SetDirty(TRUE);
}

void CDNS_WKS_RecordPropertyPage::OnServicesEditChange()
{
	SetDirty(TRUE);
}

void CDNS_WKS_RecordPropertyPage::SetUIData()
{
	STANDARD_REC_PP_SETUI_PROLOGUE(CDNS_WKS_Record);
	GetIPv4Ctrl()->SetIPv4Val(pRecord->m_ipAddress);

	CButton* pTCPRadio = GetTCPRadioButton();
	CButton* pUDPRadio = GetUDPRadioButton();
	if (pRecord->m_chProtocol == DNS_WKS_PROTOCOL_TCP)
	{
		pTCPRadio->SetCheck(TRUE);
		pUDPRadio->SetCheck(FALSE);
	}
	else // assume UDP
	{
		ASSERT(pRecord->m_chProtocol == DNS_WKS_PROTOCOL_UDP);
		pTCPRadio->SetCheck(FALSE);
		pUDPRadio->SetCheck(TRUE);
	}
	
	GetServicesEdit()->SetWindowText(pRecord->m_szServiceList);
}

DNS_STATUS CDNS_WKS_RecordPropertyPage::GetUIDataEx(BOOL bSilent)
{
	STANDARD_REC_PP_GETUI_PROLOGUE(CDNS_WKS_Record);
	GetIPv4Ctrl()->GetIPv4Val(&(pRecord->m_ipAddress));

	if (GetTCPRadioButton()->GetCheck())
	{
		pRecord->m_chProtocol = DNS_WKS_PROTOCOL_TCP;
	}
	else
	{
		ASSERT(GetUDPRadioButton()->GetCheck());
		pRecord->m_chProtocol = DNS_WKS_PROTOCOL_UDP;
	}

	GetServicesEdit()->GetWindowText(pRecord->m_szServiceList);
  return dwErr;
}


////////////////////////////////////////////////////////////////////////////
// CDNS_SRV_RecordPropertyPage

// Added by JEFFJON 2/26/99
// The following is used to prime the services, protocol, and port combo/edit boxes
//
struct SERVICE
{
	LPCWSTR	lpszService;
	LPCWSTR	protocolArr[2];
	UINT		uiPort;
};

// WARNING!!! REVIEW_JEFFJON : this has to be in alphabetical order on the lpszService field
//											or else everything breaks below

SERVICE services[] = {	L"_finger",		{ L"_tcp", L"_udp" },	79	,
								        L"_ftp",			{ L"_tcp", L"_udp" },	21	,
								        L"_http",		  { L"_tcp", L"_udp" },	80	,
								        L"_kerberos",	{ L"_tcp", L"_udp" },	88	,
								        L"_ldap",		  { L"_tcp", L"_udp" },	389 ,
								        L"_nntp",		  { L"_tcp", L"_udp" },	119 ,
								        L"_telnet",		{ L"_tcp", L"_udp" },	23	,
								        L"_whois",		{ L"_tcp", NULL	   },	43	,
								        NULL,				  { NULL },					    0		};


BOOL CALLBACK _ComboEnumChildWndProc(HWND hwnd, LPARAM lParam)
{
	HWND* pHwnd = (HWND*)lParam;
	*pHwnd = hwnd;
	return TRUE;
}



BOOL CDNS_SRV_RR_ComboBox::Initialize(UINT nCtrlID, CWnd* pParent)
{
	if (!SubclassDlgItem(nCtrlID, pParent))
  {
    return FALSE;
  }

	HWND hwndChildEdit = NULL;
	EnumChildWindows(GetSafeHwnd(),_ComboEnumChildWndProc, (LPARAM)&hwndChildEdit);
	ASSERT(hwndChildEdit != NULL);

  ::SendMessage(hwndChildEdit, EM_LIMITTEXT, MAX_DNS_NAME_LEN, 0);
  return TRUE;
}

#define SRV_RR_PROTOCOL_COMBO_ITEM_COUNT	2


BEGIN_MESSAGE_MAP(CDNS_SRV_RecordPropertyPage, CDNSRecordStandardPropertyPage)
	ON_CBN_EDITCHANGE(IDC_SERVICE_NAME_COMBO, OnServiceComboEditChange)
	ON_CBN_EDITCHANGE(IDC_PROTOCOL_NAME_COMBO, OnProtocolComboEditChange)
	ON_CBN_SELCHANGE(IDC_SERVICE_NAME_COMBO, OnServiceComboSelChange)
	ON_CBN_SELCHANGE(IDC_PROTOCOL_NAME_COMBO, OnProtocolComboSelChange)

	ON_EN_CHANGE(IDC_PRIORITY_EDIT, OnNumericEditChange)
	ON_EN_CHANGE(IDC_WEIGHT_EDIT, OnNumericEditChange)
	ON_EN_CHANGE(IDC_PORT_EDIT, OnNumericEditChange)
	ON_EN_CHANGE(IDC_NAME_TARGET_EDIT, OnNameTargetEditChange)
END_MESSAGE_MAP()


CDNS_SRV_RecordPropertyPage::CDNS_SRV_RecordPropertyPage()
						 : CDNSRecordStandardPropertyPage(IDD_RR_SRV)
{
	m_pOldDomainNode = NULL;
	m_pSubdomainNode = NULL;
	m_bCreateSubdomain = FALSE;
  m_bSubdomainCreated = FALSE;
	m_bCreated = FALSE;
}

void CDNS_SRV_RecordPropertyPage::OnInitName()
{
	CDNSRecordPropertyPageHolder* pHolder = (CDNSRecordPropertyPageHolder*)GetHolder();

  //
	// initialize combo boxes
  //
	VERIFY(m_serviceCombo.Initialize(IDC_SERVICE_NAME_COMBO, this));

	VERIFY(m_protocolCombo.Initialize(IDC_PROTOCOL_NAME_COMBO, this));

  //
	// limit the text length the user can type
  //
	int nUTF8ParentLen = UTF8StringLen(pHolder->GetDomainNode()->GetFullName());
	m_serviceCombo.LimitText(MAX_DNS_NAME_LEN - nUTF8ParentLen - 1); // count dot when chaining
	m_protocolCombo.LimitText(MAX_DNS_NAME_LEN - nUTF8ParentLen - 1); // count dot when chaining

  //
	// can edit/change combos only when creating the record
  //
	m_serviceCombo.EnableWindow(GetHolder()->IsWizardMode());
	m_protocolCombo.EnableWindow(GetHolder()->IsWizardMode());

  //
	// set the FQDN for the parent of the domain the record is in
  //
	CEdit* pEdit = GetDomainEditBox();
	CDNSDomainNode* pDomainNode = pHolder->GetDomainNode();
	if (pHolder->IsWizardMode())
	{
		pEdit->SetWindowText(pDomainNode->GetFullName());
	}
	else
	{
		if (!pDomainNode->IsZone())
		{
			CDNSDomainNode* pParentDomainNode = dynamic_cast<CDNSDomainNode*>(pDomainNode->GetContainer());
			ASSERT(pParentDomainNode != NULL);
			pEdit->SetWindowText(pParentDomainNode->GetFullName());
		}
		else
		{
      //
			// SRV record can be at the zone level if the _<protocol> domain was delegated
      //
      CDNSZoneNode* pZoneNode = dynamic_cast<CDNSZoneNode*>(pDomainNode);
      ASSERT(pZoneNode != NULL);
      if (pZoneNode != NULL)
      {
        pEdit->SetWindowText(pZoneNode->GetFullName());
      }
		}
	}
}

void CDNS_SRV_RecordPropertyPage::PrimeServicesCombo()
{
	m_serviceCombo.ResetContent();

	SERVICE* service = services;
	while (service->lpszService != NULL)
	{
		m_serviceCombo.AddString(service->lpszService);
		service++;
	}
}

void CDNS_SRV_RecordPropertyPage::OnSetName(CDNSRecordNodeBase* pRecordNode)
{
	CDNSRecordPropertyPageHolder* pHolder = (CDNSRecordPropertyPageHolder*)GetHolder();
	if (pHolder->IsWizardMode())
	{
		m_serviceCombo.SetCurSel(0);
		m_protocolCombo.SetCurSel(0);
	}
	else
	{
    //
		// service name is the RR record name
    //
		m_serviceCombo.SetWindowText(pRecordNode->GetDisplayName());

    //
		// protocol name from the parent domain FQDN
    //
		if (!pRecordNode->GetDomainNode()->IsZone())
		{
			m_protocolCombo.SetWindowText(pRecordNode->GetDomainNode()->GetDisplayName());
		}
		else
		{
      //
			// The SRV record can be at the zone level if the _<protocol> domain
      // was delegated
      //
      CString szZoneName = pRecordNode->GetDomainNode()->GetFullName();

      //
      // Retrieve a single label
      //
      int iDot = szZoneName.Find(L'.');
      if (iDot != -1)
      {
        szZoneName = szZoneName.Left(iDot);
      }
			m_protocolCombo.SetWindowText(szZoneName);
		}
	}
}

void CDNS_SRV_RecordPropertyPage::OnGetName(CString& s)
{
	CDNSRecordPropertyPageHolder* pHolder = (CDNSRecordPropertyPageHolder*)GetHolder();
	ASSERT(pHolder->IsWizardMode());	

  //
	// the service name is going to be the name of the RR record
  //
	m_serviceCombo.GetWindowText(s);

  //
	// the protocol name is going to be the name of the created folder
  //
	m_protocolCombo.GetWindowText(m_szProtocolName);

	if (m_bCreated)
  {
		return;
  }

  //
	// find a subfolder in the UI for the protocol
  //
	if (m_pSubdomainNode == NULL)
	{
		CDNSDomainNode* pCurrentDomainNode = pHolder->GetDomainNode();

    //
    // Retrieve the FQDN
    // First check to see if the current domain node is a protocol domain
    // if not then check for a subdomain that is
    //
    CString szCurrentDomainName = pCurrentDomainNode->GetFullName();
    int iDot = szCurrentDomainName.Find(L'.');
    if (iDot != -1)
    {
      szCurrentDomainName = szCurrentDomainName.Left(iDot);
    }

    CDNSDomainNode* pSubdomainNode = NULL;
    if (_wcsicmp(szCurrentDomainName, m_szProtocolName) == 0)
    {
      pSubdomainNode = pCurrentDomainNode;
    }
    else
    {
		  CString szSubdomainFQDN;
		  szSubdomainFQDN.Format(_T("%s.%s"), m_szProtocolName, pCurrentDomainNode->GetFullName());

      //
      // Find the sub-domain node
      //
		  pSubdomainNode = pCurrentDomainNode->FindSubdomainNode(szSubdomainFQDN);
    }

		if (pSubdomainNode == NULL)
		{
      //
      // If sub-domain doesn't exist, create it
      //
			pSubdomainNode = pCurrentDomainNode->CreateSubdomainNode();
			ASSERT(pSubdomainNode != NULL);
			CComponentDataObject* pComponentData = pHolder->GetComponentData();
			CDNSRootData* pRootData = (CDNSRootData*)pComponentData->GetRootData();
			pCurrentDomainNode->SetSubdomainName(pSubdomainNode, m_szProtocolName, 
											pRootData->IsAdvancedView());
			m_bCreateSubdomain = TRUE;
		}

    //
		// move down one level
    //
		m_pOldDomainNode = pCurrentDomainNode;
		m_pSubdomainNode = pSubdomainNode;
		pHolder->SetContainerNode(pSubdomainNode);
		pHolder->GetRecordNode()->SetContainer(m_pSubdomainNode);
	}
}

BOOL CDNS_SRV_RecordPropertyPage::CreateRecord()
{
  if (m_bCreated)
  {
    return TRUE;
  }

  //
	// create a subfolder i the server, if needed
  //
	if (m_bCreateSubdomain && !m_bSubdomainCreated)
	{
		DNS_STATUS err = m_pOldDomainNode->CreateSubdomain(m_pSubdomainNode, 
							                                         GetHolder()->GetComponentData());
		if (err != 0)
		{
			DNSErrorDialog(err,IDS_MSG_RECORD_CREATE_FAILED);

			m_bCreated = FALSE;

      //
			// something went wrong, bail out
      //
			delete m_pSubdomainNode;
			m_pSubdomainNode = NULL;
			GetHolder()->SetContainerNode(m_pOldDomainNode);
			((CDNSRecordPropertyPageHolder*)GetHolder())->GetRecordNode()->SetContainer(m_pOldDomainNode);

			return FALSE;
		}

    m_bSubdomainCreated = TRUE;
    //
		// mark the node as enumerated and force transition to "loaded"
    //
		m_pSubdomainNode->MarkEnumeratedAndLoaded(GetHolder()->GetComponentData());
	}
	m_pSubdomainNode = NULL;
	if (!CDNSRecordStandardPropertyPage::CreateRecord())
  {
    m_bCreated = FALSE;
		return FALSE;
  }

	m_bCreated = TRUE;
	return TRUE;
}

void CDNS_SRV_RecordPropertyPage::OnNumericEditChange()
{
	SetDirty(TRUE);
}

void CDNS_SRV_RecordPropertyPage::OnNameTargetEditChange()
{
	SetDirty(TRUE);
}

void CDNS_SRV_RecordPropertyPage::OnServiceComboEditChange()
{
	CString szText;
	m_serviceCombo.GetWindowText(szText);
	GetHolder()->EnableSheetControl(IDOK,!szText.IsEmpty()); 
}

void CDNS_SRV_RecordPropertyPage::OnProtocolComboEditChange()
{
	CString szText;
	m_protocolCombo.GetWindowText(szText);
	GetHolder()->EnableSheetControl(IDOK,!szText.IsEmpty()); 
}

void CDNS_SRV_RecordPropertyPage::OnServiceComboSelChange()
{
	GetHolder()->EnableSheetControl(IDOK, TRUE);
	
	m_protocolCombo.ResetContent();

	int nSel = m_serviceCombo.GetCurSel();
	for (int idx = 0; idx < SRV_RR_PROTOCOL_COMBO_ITEM_COUNT; idx++)
	{
		if (services[nSel].protocolArr[idx] != NULL)
		{
			m_protocolCombo.AddString(services[nSel].protocolArr[idx]);
		}
	}
	m_protocolCombo.SetCurSel(0);
	m_portEdit.SetVal(services[nSel].uiPort);
}

void CDNS_SRV_RecordPropertyPage::OnProtocolComboSelChange()
{
	GetHolder()->EnableSheetControl(IDOK, TRUE);
}

void CDNS_SRV_RecordPropertyPage::SetUIData()
{
	STANDARD_REC_PP_SETUI_PROLOGUE(CDNS_SRV_Record);

	VERIFY(m_priorityEdit.SetVal(pRecord->m_wPriority));
	VERIFY(m_weightEdit.SetVal(pRecord->m_wWeight));

	if (pRecord->m_wPort != 0)
	{
		VERIFY(m_portEdit.SetVal(pRecord->m_wPort));
	}

  GetNameTargetEdit()->SetLimitText(MAX_DNS_NAME_LEN);
	GetNameTargetEdit()->SetWindowText(pRecord->m_szNameTarget);
}

DNS_STATUS CDNS_SRV_RecordPropertyPage::GetUIDataEx(BOOL bSilent)
{
	STANDARD_REC_PP_GETUI_PROLOGUE(CDNS_SRV_Record);
  ASSERT(dwErr == 0);

	pRecord->m_wPriority = (WORD)m_priorityEdit.GetVal();
	pRecord->m_wWeight = (WORD)m_weightEdit.GetVal();
	pRecord->m_wPort = (WORD)m_portEdit.GetVal();

	GetNameTargetEdit()->GetWindowText(pRecord->m_szNameTarget);

   if (pHolder->IsWizardMode() &&
       GetSecurityCheckCtrl()->GetCheck())
   {
      pRecord->m_dwFlags |= DNS_RPC_FLAG_OPEN_ACL;
   }

  return 0;

}

BOOL CDNS_SRV_RecordPropertyPage::OnInitDialog()
{
	CDNSRecordStandardPropertyPage::OnInitDialog();

	VERIFY(m_priorityEdit.SubclassDlgItem(IDC_PRIORITY_EDIT, this));
	m_priorityEdit.SetRange(0,0xffff ); // unsigned short

	VERIFY(m_weightEdit.SubclassDlgItem(IDC_WEIGHT_EDIT, this));
	m_weightEdit.SetRange(0,0xffff ); // unsigned short
	
	VERIFY(m_portEdit.SubclassDlgItem(IDC_PORT_EDIT, this));
	m_portEdit.SetRange(0,0xffff ); // unsigned short

  //
  // Disable IME support on the controls
  //
  ImmAssociateContext(m_priorityEdit.GetSafeHwnd(), NULL);
  ImmAssociateContext(m_weightEdit.GetSafeHwnd(), NULL);
  ImmAssociateContext(m_portEdit.GetSafeHwnd(), NULL);

  //
	// This has to be done after both m_serviceCombo and m_protocolCombo have been initialized
  //
	PrimeServicesCombo();
	m_serviceCombo.SetCurSel(0);
	OnServiceComboSelChange();

   //
   // Only enable the security checkbox if we are talking to a 2473 or greater
   // Whistler server
   //
	CDNSRecordPropertyPageHolder* pHolder = (CDNSRecordPropertyPageHolder*)GetHolder();
   CDNSZoneNode* pZoneNode = pHolder->GetDomainNode()->GetZoneNode();
   CDNSServerNode* pServerNode = pZoneNode->GetServerNode();

   if (pServerNode->GetBuildNumber() < DNS_SRV_BUILD_NUMBER_WHISTLER_NEW_SECURITY_SETTINGS ||
       (pServerNode->GetMajorVersion() <= DNS_SRV_MAJOR_VERSION_NT_5 &&
        pServerNode->GetMinorVersion() < DNS_SRV_MINOR_VERSION_WHISTLER) ||
       !pHolder->IsWizardMode() ||
       !pZoneNode->IsDSIntegrated())
   {
      GetSecurityCheckCtrl()->ShowWindow(FALSE);
      GetSecurityCheckCtrl()->EnableWindow(FALSE);
   }

   // Set the focus to the Service combo box

   m_serviceCombo.SetFocus();

	return FALSE;
}


////////////////////////////////////////////////////////////////////////
// CNewHostDialog

BEGIN_MESSAGE_MAP(CNewHostDialog, CHelpDialog)
  ON_EN_CHANGE(IDC_RR_NAME_EDIT, OnEditChange)
	ON_BN_CLICKED(IDC_BUTTON_ADDHOST, OnAddHost)
END_MESSAGE_MAP()


CNewHostDialog::CNewHostDialog(CDNSDomainNode* pParentDomainNode, 
								   CComponentDataObject* pComponentData)
	: CHelpDialog(IDD_DOMAIN_ADDNEWHOST, pComponentData)
{
	ASSERT(pParentDomainNode != NULL);
	ASSERT(pComponentData != NULL);
	m_pParentDomainNode = pParentDomainNode;
	m_pComponentData = pComponentData;

	m_nUTF8ParentLen = UTF8StringLen(pParentDomainNode->GetFullName());

	m_pTempDNSRecord = new CDNS_A_Record;
   if (m_pTempDNSRecord)
   {
	   m_pTempDNSRecord->m_dwTtlSeconds = m_pParentDomainNode->GetDefaultTTL();
   }

  m_bFirstCreation = TRUE;
}

CNewHostDialog::~CNewHostDialog()
{
	delete m_pTempDNSRecord;
}


BOOL CNewHostDialog::OnInitDialog() 
{
	CHelpDialog::OnInitDialog();

  //
  // hook up Cancel/Done button
  //
	UINT nButtonIDs[2] = { IDS_BUTTON_TEXT_CANCEL, IDS_BUTTON_TEXT_DONE };
	VERIFY(m_cancelDoneTextHelper.Init(this, IDCANCEL, nButtonIDs));
	m_cancelDoneTextHelper.SetToggleState(m_bFirstCreation);

  //
	// limit the text length the user can type
  //
	int nUTF8ParentLen = UTF8StringLen(m_pParentDomainNode->GetFullName());
  int nUTF8Len = MAX_DNS_NAME_LEN - nUTF8ParentLen - 3; // count dot when chaining

  //
  // hook up name edit control
  //
  GetNameEdit()->SetLimitText(nUTF8Len);

  //
	// determine if we need to hide TTL control
  //
	CDNSRootData* pRootData = (CDNSRootData*)m_pComponentData->GetRootData();
	ASSERT(pRootData != NULL);
	BOOL bShow = pRootData->IsAdvancedView();
	CDNSTTLControl* pCtrl = GetTTLCtrl();
	ASSERT(pCtrl != NULL);
	pCtrl->EnableWindow(bShow);
	pCtrl->ShowWindow(bShow);
	CWnd* pWnd = GetDlgItem(IDC_STATIC_TTL);
	ASSERT(pWnd != NULL);
	pWnd->EnableWindow(bShow);
	pWnd->ShowWindow(bShow);

	CWnd* pLabelWnd = GetDlgItem(IDC_TTL_LABEL);
	ASSERT(pLabelWnd != NULL);
	pLabelWnd->EnableWindow(bShow);
	pLabelWnd->ShowWindow(bShow);

  //
  // Set Create PTR record checkbox
  //
  if (pRootData != NULL)
  {
    GetPTRCheckCtrl()->SetCheck(pRootData->GetCreatePTRWithHost());
  }

  //
	// set the FQDN for the domain the record is in
  //
	GetDomainEditBox()->SetWindowText(m_pParentDomainNode->GetFullName());

   //
   // Only enable the security checkbox if we are talking to a 2473 or greater
   // Whistler server
   //
   CDNSServerNode* pServerNode = m_pParentDomainNode->GetServerNode();
   CDNSZoneNode* pZoneNode = m_pParentDomainNode->GetZoneNode();

   if (pServerNode->GetBuildNumber() < DNS_SRV_BUILD_NUMBER_WHISTLER_NEW_SECURITY_SETTINGS ||
       (pServerNode->GetMajorVersion() <= DNS_SRV_MAJOR_VERSION_NT_5 &&
        pServerNode->GetMinorVersion() < DNS_SRV_MINOR_VERSION_WHISTLER) ||
       !pZoneNode->IsDSIntegrated())
   {
      GetSecurityCheckCtrl()->ShowWindow(FALSE);
      GetSecurityCheckCtrl()->EnableWindow(FALSE);
   }


	SetUIData(TRUE);

	return TRUE;  // return TRUE unless you set the focus to a control
}


#ifdef _USE_BLANK

void CNewHostDialog::OnEditChange()
{
  CString s;
  GetNameEdit()->GetWindowText(s);

  CString szFullName;
  CString szDisplayName;

  CString szTempName = m_pParentDomainNode->GetFullName();
  ASSERT(szTempName.GetLength() > 0);

  if (szTempName.GetAt(szTempName.GetLength() - 1) != L'.')
  {
    szTempName += L".";
  }

  if (s.IsEmpty())
  {
    szFullName = szTempName;
  }
  else
  {
    szFullName.Format(L"%s.%s", s, szTempName);
  }

  SetDlgItemText(IDC_RR_DOMAIN_EDIT, szFullName);
}

#else

void CNewHostDialog::OnEditChange()
{
  //
  // Get the server name checking flags
  //
  DWORD dwNameChecking = m_pParentDomainNode->GetServerNode()->GetNameCheckFlag();

  CString s;
  GetNameEdit()->GetWindowText(s);

  CString szFullName;
  CString szDisplayName;

  CString szTempName = m_pParentDomainNode->GetFullName();
  ASSERT(szTempName.GetLength() > 0);

  if (szTempName.GetAt(szTempName.GetLength() - 1) != L'.')
  {
    szTempName += L".";
  }

  if (s.IsEmpty())
  {
    szFullName = szTempName;
  }
  else
  {
    szFullName.Format(L"%s.%s", s, szTempName);
  }

  GetDlgItem(IDC_BUTTON_ADDHOST)->EnableWindow(ValidateRecordName(szFullName, dwNameChecking) == 0);
  SetDlgItemText(IDC_RR_DOMAIN_EDIT, szFullName);
}

#endif

DNS_STATUS CNewHostDialog::ValidateRecordName(PCWSTR pszName, DWORD dwNameChecking)
{
	CDNSRootData* pRootData = (CDNSRootData*)m_pComponentData->GetRootData();
	ASSERT(pRootData != NULL);
  if (pRootData->IsAdvancedView())
  {
    //
    // Don't validate the name in advanced view
    //
    return 0;
  }
  
  return ::ValidateDnsNameAgainstServerFlags(pszName, DnsNameHostnameFull, dwNameChecking);

}


CDNSRecordNodeBase* CNewHostDialog::CreateRecordNode()
{
  //
	// create a record node of type A
  //
	CDNSRecordNodeBase* pRecordNode = CDNSRecordInfo::CreateRecordNode(DNS_TYPE_A);
	ASSERT(pRecordNode != NULL);

  //
	// set the normal/advanced view option
  //
	CDNSRootData* pRootData = (CDNSRootData*)m_pComponentData->GetRootData();
	ASSERT(pRootData != NULL);
	pRecordNode->SetFlagsDown(TN_FLAG_DNS_RECORD_FULL_NAME, !pRootData->IsAdvancedView());

  //
	// hookup container for node
  //
	pRecordNode->SetContainer(m_pParentDomainNode);

	return pRecordNode;
}

void CNewHostDialog::SetUIData(BOOL bFirstTime)
{
	CDNS_A_Record* pARec = (CDNS_A_Record*)m_pTempDNSRecord;
	if (!bFirstTime)
	{
    //
		// keep the first 3 octects and reset the last one to zero
    //
		pARec->m_ipAddress = static_cast<DWORD>(MAKEIPADDRESS(FIRST_IPADDRESS(0),
						                                              SECOND_IPADDRESS(pARec->m_ipAddress),
						                                              THIRD_IPADDRESS(pARec->m_ipAddress),
						                                              FOURTH_IPADDRESS(pARec->m_ipAddress)));

	}
	GetNameEdit()->SetWindowText(L"");
	GetIPv4Ctrl()->SetIPv4Val(pARec->m_ipAddress);
	GetTTLCtrl()->SetTTL(m_pTempDNSRecord->m_dwTtlSeconds);
}


DNS_STATUS CNewHostDialog::GetUIData(CDNSRecordNodeBase* pRecordNode)
{
	ASSERT(m_pTempDNSRecord->m_dwFlags == DNS_RPC_RECORD_FLAG_DEFAULT);

#ifdef _USE_BLANK
  BOOL bAtTheNode = GetNameEdit()->GetWindowTextLength() == 0;
#else
  BOOL bAtTheNode = (s == g_szAtTheNodeInput);
#endif
	if (bAtTheNode)
	{
    //
		//name null, node is at the node level, use name of parent
    //
		pRecordNode->SetRecordName(pRecordNode->GetDomainNode()->GetDisplayName(),bAtTheNode);
	}
	else
	{
    //
		// non null name, node is a child
    //
    CString szName;
    GetNameEdit()->GetWindowText(szName);
		pRecordNode->SetRecordName(szName, bAtTheNode);
	}
	GetIPv4Ctrl()->GetIPv4Val(&(((CDNS_A_Record*)m_pTempDNSRecord)->m_ipAddress));
	GetTTLCtrl()->GetTTL(&(m_pTempDNSRecord->m_dwTtlSeconds));

	if (GetPTRCheckCtrl()->GetCheck())
	{
		m_pTempDNSRecord->m_dwFlags |= DNS_RPC_RECORD_FLAG_CREATE_PTR;
  }

   if (GetSecurityCheckCtrl()->GetCheck())
   {
      m_pTempDNSRecord->m_dwFlags |= DNS_RPC_FLAG_OPEN_ACL;
   }

  CDNSRootData* pRootData = dynamic_cast<CDNSRootData*>(m_pComponentData->GetRootData());
  if (pRootData != NULL)
  {
    pRootData->SetCreatePTRWithHost(GetPTRCheckCtrl()->GetCheck());
  }
  return 0;
}


void CNewHostDialog::OnAddHost()
{
	CDNSRecordNodeBase* pRecordNode = CreateRecordNode();
	ASSERT(pRecordNode != NULL);
	ASSERT(m_pTempDNSRecord != NULL);

  //
	// get data from the UI
  // Don't need to handle a failure here because the name is 
  //
	DNS_STATUS dwErr = GetUIData(pRecordNode);
  ASSERT(dwErr == 0);

  DWORD dwNameChecking = m_pParentDomainNode->GetServerNode()->GetNameCheckFlag();

  if (!pRecordNode->IsAtTheNode())
  {
    LPCWSTR lpszHostName = pRecordNode->GetTrueRecordName();
    DNS_STATUS errName = ValidateRecordName(lpszHostName, dwNameChecking);
    if (errName != 0)
    {
      //
      // Bring up an error for an invalid name
      //
      CString szFmt, szMsg;
      szFmt.LoadString(IDS_MSG_RECORD_CREATE_HOST_NAME_FAILED);
      szMsg.Format((LPCWSTR)szFmt, lpszHostName);
      if (DNSMessageBox(szMsg, MB_YESNO) != IDYES)
      {
        return;
      }
    }
  }

  //
  // See if a child of that name already exists
  //
  RECORD_SEARCH recordSearch = RECORD_NOT_FOUND;

  CDNSDomainNode* pNewParentDomain = NULL;
  CString szFullRecordName;
  pRecordNode->GetFullName(szFullRecordName);
  CString szNonExistentDomain;
  CDNSRecordNodeBase* pExistingRecordNode = 0;

  recordSearch = m_pParentDomainNode->GetZoneNode()->DoesContain(szFullRecordName, 
                                                                  m_pComponentData,
                                                                  &pNewParentDomain,
                                                                  &pExistingRecordNode,
                                                                  szNonExistentDomain,
                                                                  TRUE);

  if ((recordSearch == RECORD_NOT_FOUND || pRecordNode->IsAtTheNode() || recordSearch == RECORD_NOT_FOUND_AT_THE_NODE) && 
      pNewParentDomain != NULL)
  {
    //
    // write record to server
    //
	  BOOL bUseDefaultTTL = TRUE;
    if (pNewParentDomain != NULL)
    {
      bUseDefaultTTL = (m_pTempDNSRecord->m_dwTtlSeconds == pNewParentDomain->GetDefaultTTL());
    }
    else
    {
      bUseDefaultTTL = (m_pTempDNSRecord->m_dwTtlSeconds == m_pParentDomainNode->GetDefaultTTL());
    }
	  DNS_STATUS err = pRecordNode->Update(m_pTempDNSRecord, bUseDefaultTTL);

    CString szFmt;
    CString szMsg;

    BOOL bNeedToggle = TRUE;
	  if (err == 0 || err == DNS_WARNING_PTR_CREATE_FAILED)
	  {
      //
		  // add the node to the UI
      //
      if (pNewParentDomain != NULL)
      {
        //
        // Set the container to the found domain and alter the record name to reflect this
        //
        pRecordNode->SetContainer(pNewParentDomain);
        CString szSingleLabel;

        int iFindResult = szFullRecordName.Find(L'.');
        if (iFindResult != -1)
        {
          szSingleLabel = szFullRecordName.Left(iFindResult);
        }

        if (recordSearch == RECORD_NOT_FOUND)
        {
          pRecordNode->SetRecordName(szSingleLabel, pRecordNode->IsAtTheNode());
        }
        else
        {
          pRecordNode->SetRecordName(szSingleLabel, TRUE);
        }

        VERIFY(pNewParentDomain->AddChildToListAndUI(pRecordNode, m_pComponentData));
        m_pComponentData->SetDescriptionBarText(pNewParentDomain);
      }
		  SetUIData(FALSE);
    
      if (err == DNS_WARNING_PTR_CREATE_FAILED)
	    {
		    DNSMessageBox(IDS_MSG_RECORD_WARNING_CREATE_PTR);
      }
      else
      {
        szFmt.LoadString(IDS_MSG_RECORD_CREATE_HOST_SUCCESS);
        szMsg.Format((LPCWSTR)szFmt, (LPCWSTR)szFullRecordName);
        DNSMessageBox(szMsg, MB_ICONINFORMATION | MB_OK);
      }
	  }
	  else
	  {
		  szFmt.LoadString(IDS_MSG_RECORD_CREATE_HOST_FAIL);
      szMsg.Format((LPCWSTR)szFmt, (LPCWSTR)szFullRecordName);
      DNSErrorDialog(err, szMsg);

      delete pRecordNode; // discarded on failure
      bNeedToggle = FALSE;
	  }

    //
	  // reset fields of temporary record
    //
	  m_pTempDNSRecord->m_dwFlags = DNS_RPC_RECORD_FLAG_DEFAULT;

    //
    // toggle the Cancel/Done button label
    //
    if (bNeedToggle && m_bFirstCreation)
    {
	    m_bFirstCreation = FALSE;
	    m_cancelDoneTextHelper.SetToggleState(m_bFirstCreation);
    }

    //
    // Set the focus back to the name field
    //
    GetDlgItem(IDC_RR_NAME_EDIT)->SetFocus();
  }
  else if (recordSearch == NON_EXISTENT_SUBDOMAIN && pNewParentDomain != NULL)
  {
    //
    // Create the record and then search for it so that we expand the newly
    // created domains on the way down
    //
	  BOOL bUseDefaultTTL = TRUE;
    if (pNewParentDomain != NULL)
    {
      bUseDefaultTTL = (m_pTempDNSRecord->m_dwTtlSeconds == pNewParentDomain->GetDefaultTTL());
    }
    else
    {
      bUseDefaultTTL = (m_pTempDNSRecord->m_dwTtlSeconds == m_pParentDomainNode->GetDefaultTTL());
    }
	  DNS_STATUS err = pRecordNode->Update(m_pTempDNSRecord, bUseDefaultTTL);

    CString szFmt;
    CString szMsg;

    BOOL bNeedToggle = TRUE;
	  if (err == 0 || err == DNS_WARNING_PTR_CREATE_FAILED)
	  {
      //
		  // add the node to the UI
      //
      if (pNewParentDomain != NULL)
      {
        //
        // Set the container to the found domain and alter the record name to reflect this
        //
        pRecordNode->SetContainer(pNewParentDomain);
        CString szSingleLabel;
        int iFindResult = szFullRecordName.Find(L'.');
        if (iFindResult != -1)
        {
          szSingleLabel = szFullRecordName.Left(iFindResult);
          pRecordNode->SetRecordName(szSingleLabel, pRecordNode->IsAtTheNode());
        }

        ASSERT(!szNonExistentDomain.IsEmpty());
        if (!szNonExistentDomain.IsEmpty())
        {
          //
          // Create the first subdomain because the current domain is already enumerated
          // so we have to start the remaining enumeration at the new subdomain that is needed
          //
	        CDNSDomainNode* pSubdomainNode = pNewParentDomain->CreateSubdomainNode();
	        ASSERT(pSubdomainNode != NULL);
	        CDNSRootData* pRootData = (CDNSRootData*)m_pComponentData->GetRootData();
	        pNewParentDomain->SetSubdomainName(pSubdomainNode, szNonExistentDomain, pRootData->IsAdvancedView());

          VERIFY(pNewParentDomain->AddChildToListAndUISorted(pSubdomainNode, m_pComponentData));
          m_pComponentData->SetDescriptionBarText(pNewParentDomain);

          //
          // I don't care what the results of this are, I am just using it 
          // to do the expansion to the new record
          //
          recordSearch = pSubdomainNode->GetZoneNode()->DoesContain(szFullRecordName, 
                                                                     m_pComponentData,
                                                                     &pNewParentDomain,
                                                                     &pExistingRecordNode,
                                                                     szNonExistentDomain,
                                                                     TRUE);
        }
      }
  	  SetUIData(FALSE);

      if (err == DNS_WARNING_PTR_CREATE_FAILED)
	    {
		    DNSMessageBox(IDS_MSG_RECORD_WARNING_CREATE_PTR);
      }
      else
      {
        szFmt.LoadString(IDS_MSG_RECORD_CREATE_HOST_SUCCESS);
        szMsg.Format((LPCWSTR)szFmt, (LPCWSTR)szFullRecordName);
        DNSMessageBox(szMsg, MB_ICONINFORMATION | MB_OK);
      }
    }
	  else
	  {
		  szFmt.LoadString(IDS_MSG_RECORD_CREATE_HOST_FAIL);
      szMsg.Format((LPCWSTR)szFmt, (LPCWSTR)szFullRecordName);
      DNSErrorDialog(err, szMsg);

      delete pRecordNode; // discarded on failure
      bNeedToggle = FALSE;
	  }

    //
	  // reset fields of temporary record
    //
	  m_pTempDNSRecord->m_dwFlags = DNS_RPC_RECORD_FLAG_DEFAULT;

    //
    // toggle the Cancel/Done button label
    //
    if (bNeedToggle && m_bFirstCreation)
    {
	    m_bFirstCreation = FALSE;
	    m_cancelDoneTextHelper.SetToggleState(m_bFirstCreation);
    }

    //
    // Set the focus back to the name field
    //
    GetDlgItem(IDC_RR_NAME_EDIT)->SetFocus();
  }
  else
  {
    //
    // write record to server
    //
	  BOOL bUseDefaultTTL = TRUE;
    if (pNewParentDomain != NULL)
    {
      bUseDefaultTTL = (m_pTempDNSRecord->m_dwTtlSeconds == pNewParentDomain->GetDefaultTTL());
    }
    else
    {
      bUseDefaultTTL = (m_pTempDNSRecord->m_dwTtlSeconds == m_pParentDomainNode->GetDefaultTTL());
    }
	  DNS_STATUS err = pRecordNode->Update(m_pTempDNSRecord, bUseDefaultTTL);

    CString szFmt;
    CString szMsg;

    BOOL bNeedToggle = TRUE;
	  if (err == 0 || err == DNS_WARNING_PTR_CREATE_FAILED)
	  {
      if (pNewParentDomain != NULL)
      {
        //
        // Set the container to the found domain and alter the record name to reflect this
        //
        pRecordNode->SetContainer(pNewParentDomain);
        CString szSingleLabel;
        int iFindResult = szFullRecordName.Find(L'.');
        if (iFindResult != -1)
        {
          szSingleLabel = szFullRecordName.Left(iFindResult);
          pRecordNode->SetRecordName(szSingleLabel, pRecordNode->IsAtTheNode());
        }

		    VERIFY(pNewParentDomain->AddChildToListAndUI(pRecordNode, m_pComponentData));
        m_pComponentData->SetDescriptionBarText(pNewParentDomain);
      }
		  SetUIData(FALSE);
  
      if (err == DNS_WARNING_PTR_CREATE_FAILED)
	    {
		    DNSMessageBox(IDS_MSG_RECORD_WARNING_CREATE_PTR);
      }
      else
      {
        szFmt.LoadString(IDS_MSG_RECORD_CREATE_HOST_SUCCESS);
        szMsg.Format((LPCWSTR)szFmt, (LPCWSTR)szFullRecordName);
        DNSMessageBox(szMsg, MB_ICONINFORMATION | MB_OK);
      }
    }
    else
    {
		  szFmt.LoadString(IDS_MSG_RECORD_CREATE_HOST_FAIL);
      szMsg.Format((LPCWSTR)szFmt, (LPCWSTR)szFullRecordName);
      DNSErrorDialog(err, szMsg);

      delete pRecordNode; // discarded on failure
      bNeedToggle = FALSE;
    }
    //
	  // reset fields of temporary record
    //
	  m_pTempDNSRecord->m_dwFlags = DNS_RPC_RECORD_FLAG_DEFAULT;

    //
    // toggle the Cancel/Done button label
    //
    if (bNeedToggle && m_bFirstCreation)
    {
	    m_bFirstCreation = FALSE;
	    m_cancelDoneTextHelper.SetToggleState(m_bFirstCreation);
    }

    //
    // Set the focus back to the name field
    //
    GetDlgItem(IDC_RR_NAME_EDIT)->SetFocus();
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\server.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       server.h
//
//--------------------------------------------------------------------------


#ifndef _SERVER_H
#define _SERVER_H

#include "dnsutil.h"

///////////////////////////////////////////////////////////////////////////////
// GLOBAL FUNCTIONS

DNS_STATUS ServerHasCache(LPCWSTR lpszServerName, BOOL* pbRes);
DNS_STATUS ServerHasRootZone(LPCWSTR lpszServerName, BOOL* pbRes);

extern LPCWSTR DNS_EVT_COMMAND_LINE;
extern LPCWSTR MMC_APP;

///////////////////////////////////////////////////////////////////////////////
// FORWARD DECLARATIONS

class CDNSMTContainerNode;
class CDNSServerNode;
class CDNSZoneNode;
class CDNSDomainNode;
class CCathegoryFolderNode;
class CDNSRootHintsNode;
class CDNSServer_TestPropertyPage;
class CDNSQueryFilter;

///////////////////////////////////////////////////////////////////////////////
// defines for server test intervals

#define MIN_SERVER_TEST_INTERVAL		30	// seconds
#define MAX_SERVER_TEST_INTERVAL		3600 // seconds in 1 hour
#define DEFAULT_SERVER_TEST_INTERVAL	60	// seconds


///////////////////////////////////////////////////////////////////////////////
// defines for server sheet messages

#define SHEET_MSG_SERVER_TEST_DATA (1)
#define SHEET_MSG_SELECT_PAGE		(2)

///////////////////////////////////////////////////////////////////////////////
// CZoneInfoHolder : simple memory manager for arrays of zone info handles

class CZoneInfoHolder
{
public:
	CZoneInfoHolder();
	~CZoneInfoHolder();
	BOOL Grow();

	PDNS_ZONE_INFO* m_zoneInfoArray;
	DWORD m_dwArrSize;
	DWORD m_dwZoneCount;

private:
	void AllocateMemory(DWORD dwArrSize);
	void FreeMemory();
};


///////////////////////////////////////////////////////////////////////////////
// CDNSMTContainerNode
// base class from which all the MT nodes derive from

class CDNSMTContainerNode : public CMTContainerNode
{
public:
	// enumeration for node states, to handle icon changes
	typedef enum
	{
		notLoaded = 0, // initial state, valid only if server never contacted
		loading,
		loaded,
		unableToLoad,
		accessDenied
	} nodeStateType;


	CDNSMTContainerNode();

	void SetServerNode(CDNSServerNode* pServerNode)
		{ ASSERT(pServerNode != NULL); m_pServerNode = pServerNode; }
	CDNSServerNode* GetServerNode()
		{ ASSERT( m_pServerNode != NULL); return m_pServerNode; }

  virtual HRESULT OnSetToolbarVerbState(IToolbar* pToolbar, CNodeList* pNodeList);

	virtual int GetImageIndex(BOOL bOpenImage);

  virtual CColumnSet* GetColumnSet() 
  { 
    if (m_pColumnSet == NULL)
    {
      CDNSRootData* pRoot = (CDNSRootData*)GetRootContainer();
      m_pColumnSet = ((CDNSComponentDataObjectBase*)pRoot->GetComponentDataObject())->GetColumnSet(L"---Default Column Set---");
    }
    return m_pColumnSet;
  }
  virtual LPCWSTR GetColumnID() { return GetColumnSet()->GetColumnID(); }
  virtual LPWSTR GetDescriptionBarText();

protected:
	virtual BOOL CanCloseSheets();
	virtual void OnChangeState(CComponentDataObject* pComponentDataObject);
	virtual void OnHaveData(CObjBase* pObj, CComponentDataObject* pComponentDataObject);
  virtual void OnError(DWORD dwErr);

  CColumnSet* m_pColumnSet;
  CString m_szDescriptionBar;
private:
  CDNSServerNode* m_pServerNode;
};




///////////////////////////////////////////////////////////////////////////////
// CDNSQueryObj : general purpose base class

class CDNSQueryObj : public CQueryObj
{
public:
	CDNSQueryObj(BOOL bAdvancedView, DWORD dwServerVersion)
	{
		m_dwServerVersion = dwServerVersion;
		m_bAdvancedView = bAdvancedView;

    // internal state variables
    m_nObjectCount = 0;
    m_nMaxObjectCount = DNS_QUERY_OBJ_COUNT_MAX;
    m_bGetAll = TRUE;
    m_nFilterOption = DNS_QUERY_FILTER_DISABLED;
	}
	CString m_szServerName;
	DWORD m_dwServerVersion;
	BOOL m_bAdvancedView;

public:
  virtual BOOL AddQueryResult(CObjBase* pObj)
  {
    BOOL bRet = CQueryObj::AddQueryResult(pObj);
    if (bRet)
      m_nObjectCount++;
    return bRet;
  }
  void SetFilterOptions(CDNSQueryFilter* pFilter);
  BOOL TooMuchData();

protected:
  ULONG m_nMaxObjectCount;          // max number of objects in a query
  BOOL m_bGetAll;
  ULONG m_nObjectCount;             // number of objects queried so far

  UINT m_nFilterOption;
  CString m_szFilterString1;
  int m_nFilterStringLen1;       // cached value

  CString m_szFilterString2;
  int m_nFilterStringLen2;       // cached value


protected:
  BOOL MatchName(LPCWSTR lpszName);
};

/////////////////////////////////////////////////////////////////////////
// CCathegoryFolderNode

class CCathegoryFolderQueryObj : public CDNSQueryObj
{
public:
	CCathegoryFolderQueryObj(BOOL bAdvancedView, DWORD dwServerVersion)
		: CDNSQueryObj(bAdvancedView, dwServerVersion)
  {
  }
	virtual BOOL Enumerate();
	typedef enum { unk, cache, fwdAuthoritated, revAuthoritated, domainForwarders } queryType;
	void SetType(queryType type) { m_type = type;}

protected:
	queryType m_type;
	BOOL CanAddZone(PDNS_RPC_ZONE pZoneInfo);
};


class CCathegoryFolderNode : public CDNSMTContainerNode
{
public:
	CCathegoryFolderNode()
	{
		m_type = CCathegoryFolderQueryObj::unk;
	}

	virtual HRESULT OnCommand(long nCommandID, 
                            DATA_OBJECT_TYPES type, 
                            CComponentDataObject* pComponentData,
                            CNodeList* pNodeList);
	virtual void OnDelete(CComponentDataObject*,
                        CNodeList*)
		{ ASSERT(FALSE);}
	virtual BOOL OnSetRefreshVerbState(DATA_OBJECT_TYPES type, 
                                     BOOL* pbHide,
                                     CNodeList* pNodeList);
	virtual LPCWSTR GetString(int nCol)
	{
		return (nCol == 0) ? GetDisplayName() : g_lpszNullString;
	}
	CCathegoryFolderQueryObj::queryType GetType() { return m_type;}

  virtual LPWSTR GetDescriptionBarText();

  virtual CColumnSet* GetColumnSet() 
  { 
    if (m_pColumnSet == NULL)
    {
      CDNSRootData* pRoot = (CDNSRootData*)GetRootContainer();
      m_pColumnSet = ((CDNSComponentDataObjectBase*)pRoot->GetComponentDataObject())->GetColumnSet(L"---Zone Column Set---");
    }
    return m_pColumnSet;
  }

  virtual BOOL CanExpandSync() { return FALSE; }

protected:
	virtual LPCONTEXTMENUITEM2 OnGetContextMenuItemTable()
				{ return CDNSCathegoryFolderHolder::GetContextMenuItem(); }
	virtual BOOL OnAddMenuItem(LPCONTEXTMENUITEM2 pContextMenuItem2,
								             long *pInsertionAllowed);

	virtual CQueryObj* OnCreateQuery();

	CCathegoryFolderQueryObj::queryType m_type;
};

/////////////////////////////////////////////////////////////////////////
// CDNSCacheNode
//
// * contains the root domain "."
// * can delete items underneath, but cannot add or modify

class CDNSCacheNode : public CCathegoryFolderNode
{
public:
	CDNSCacheNode();

  virtual HRESULT OnCommand(long nCommandID, 
                            DATA_OBJECT_TYPES type, 
                            CComponentDataObject* pComponentData,
                            CNodeList* pNodeList);

  void OnClearCache(CComponentDataObject* pComponentData);

  virtual BOOL CanExpandSync() { return FALSE; }

protected:
	virtual LPCONTEXTMENUITEM2 OnGetContextMenuItemTable()
				{ return CDNSCacheMenuHolder::GetContextMenuItem(); }
	virtual BOOL OnAddMenuItem(LPCONTEXTMENUITEM2 pContextMenuItem2,
								             long *pInsertionAllowed);
};

/////////////////////////////////////////////////////////////////////////
// CDNSDomainForwardersNode
//
// * contains the domain forwarders as zones
// * this node will always be hidden
//

class CDNSDomainForwardersNode : public CCathegoryFolderNode
{
public:
	CDNSDomainForwardersNode();

	virtual BOOL OnEnumerate(CComponentDataObject* pComponentData, BOOL bAsync = TRUE);
};


/////////////////////////////////////////////////////////////////////////
// CDNSAuthoritatedZonesNode
//
// * contains autoritated zones, both primary and secondary
// *  have one for FWD and one for REVERSE

class CDNSAuthoritatedZonesNode : public CCathegoryFolderNode
{
public:
	CDNSAuthoritatedZonesNode(BOOL bReverse, UINT nStringID);

	BOOL IsReverse() { return m_bReverse;}

	virtual HRESULT OnCommand(long nCommandID, 
                            DATA_OBJECT_TYPES type, 
                            CComponentDataObject* pComponentData,
                            CNodeList* pNodeList);
	virtual BOOL OnSetRefreshVerbState(DATA_OBJECT_TYPES type, 
                                     BOOL* pbHide,
                                     CNodeList* pNodeList);
  virtual HRESULT OnSetToolbarVerbState(IToolbar* pToolbar, 
                                        CNodeList* pNodeList);

  virtual BOOL CanExpandSync() { return FALSE; }

protected:
	virtual LPCONTEXTMENUITEM2 OnGetContextMenuItemTable()
				{ return CDNSAuthoritatedZonesMenuHolder::GetContextMenuItem(); }
	virtual BOOL OnAddMenuItem(LPCONTEXTMENUITEM2 pContextMenuItem2,
								             long *pInsertionAllowed);

private:
	// command handlers
	HRESULT OnNewZone(CComponentDataObject* pComponentData, CNodeList* pNodeList);

	// data
	BOOL m_bReverse;

  DECLARE_TOOLBAR_MAP()
};

/////////////////////////////////////////////////////////////////////////
// CDNSForwardZonesNode
class CDNSForwardZonesNode : public CDNSAuthoritatedZonesNode
{
public:
	CDNSForwardZonesNode();

  virtual HRESULT OnShow(LPCONSOLE lpConsole);
  virtual HRESULT GetResultViewType(CComponentDataObject* pComponentData, 
                                    LPOLESTR *ppViewType, 
                                    long *pViewOptions);

};

/////////////////////////////////////////////////////////////////////////
// CDNSReverseZonesNode
class CDNSReverseZonesNode : public CDNSAuthoritatedZonesNode
{
public:
	CDNSReverseZonesNode();
	virtual BOOL OnRefresh(CComponentDataObject* pComponentData,
                         CNodeList* pNodeList);
protected:
	virtual void OnHaveData(CObjBase* pObj, CComponentDataObject* pComponentDataObject);

	void ChangeViewOption(BOOL bAdvanced, CComponentDataObject* pComponentDataObject);
  virtual HRESULT OnShow(LPCONSOLE lpConsole);
  virtual HRESULT GetResultViewType(CComponentDataObject* pComponentData, 
                                    LPOLESTR *ppViewType, 
                                    long *pViewOptions);

private:
	// cached pointers to autocreated zones
	CDNSZoneNode* m_p0ZoneNode;
	CDNSZoneNode* m_p127ZoneNode;
	CDNSZoneNode* m_p255ZoneNode;

	friend class CDNSServerNode;
};


/////////////////////////////////////////////////////////////////////////
// CDNSServerTestOptions

class CDNSServerTestOptions
{
public:
	CDNSServerTestOptions();
	HRESULT Save(IStream* pStm);
	HRESULT Load(IStream* pStm);
	const CDNSServerTestOptions& operator=(const CDNSServerTestOptions& x);
	BOOL operator==(const CDNSServerTestOptions& x) const;

	BOOL	m_bEnabled;				// polling enabled
	DWORD	m_dwInterval;	// seconds
	// query types
	BOOL	m_bSimpleQuery;
	BOOL	m_bRecursiveQuery;
};

////////////////////////////////////////////////////////////////////////
// CDNSServerTestQueryResult

class CDNSServerTestQueryResult
{
public:
	CDNSServerTestQueryResult()
		{ memset(this, 0x0, sizeof(CDNSServerTestQueryResult));}
	const CDNSServerTestQueryResult& operator=(const CDNSServerTestQueryResult& x)
	{
		memcpy(this, &x, sizeof(CDNSServerTestQueryResult));
		return *this;
	}
	BOOL operator==(const CDNSServerTestQueryResult& x)
	{
		ASSERT(m_serverCookie == x.m_serverCookie); // always compare the same server
		// we do not compare the time
		// we do not compare the force logging flag
		// we want just to compare the query flags and the results
		return (m_dwQueryFlags == x.m_dwQueryFlags) &&
				(m_dwAddressResolutionResult == x.m_dwAddressResolutionResult) &&
				(m_dwPlainQueryResult == x.m_dwPlainQueryResult) &&
				(m_dwRecursiveQueryResult == x.m_dwRecursiveQueryResult);
	}
	BOOL Succeded()
	{
		return (m_dwAddressResolutionResult == 0) &&
				(m_dwPlainQueryResult == 0) &&
				(m_dwRecursiveQueryResult == 0);
	}
	static DWORD Pack(BOOL bPlainQuery, BOOL bRecursiveQuery)
	{
		DWORD dw = 0;
		if (bPlainQuery)
			dw |= 0x1;
		if (bRecursiveQuery)
			dw |= 0x2;
		return dw;
	}
	static void Unpack(DWORD dwQueryFlags, BOOL* pbPlainQuery, BOOL* pbRecursiveQuery)
	{
		*pbPlainQuery = (dwQueryFlags & 0x1);
		*pbRecursiveQuery = (dwQueryFlags & 0x2);
	}
// Data
	MMC_COOKIE  m_serverCookie;
	BOOL		m_bAsyncQuery;
	SYSTEMTIME	m_queryTime;
	DWORD		m_dwQueryFlags;
	DWORD		m_dwAddressResolutionResult;
	DWORD		m_dwPlainQueryResult;
	DWORD		m_dwRecursiveQueryResult;
};

////////////////////////////////////////////////////////////////////////
// CDNSServerTestQueryResultList

class CDNSServerTestQueryResultList : public
		CList< CDNSServerTestQueryResult*, CDNSServerTestQueryResult* >
{
public:
	typedef enum addAction { none = 0, changed, added, addedAndRemoved};

	CDNSServerTestQueryResultList()
	{
		m_nMaxCount = 50;
		ExceptionPropagatingInitializeCriticalSection(&m_cs);
	}
	~CDNSServerTestQueryResultList()
	{
		while (!IsEmpty())
			delete RemoveHead();
		::DeleteCriticalSection(&m_cs);
	}
public:
	void Lock() { ::EnterCriticalSection(&m_cs); }
	void Unlock() { ::LeaveCriticalSection(&m_cs); }

	addAction AddTestQueryResult(CDNSServerTestQueryResult* pTestResult)
	{
		addAction action = none;
		Lock();

		// determine if we have to add
		INT_PTR nCount = GetCount();
		CDNSServerTestQueryResult* pLastQueryResult = NULL;
		if (nCount > 0)
			pLastQueryResult = GetHead();
		if ((pTestResult->m_bAsyncQuery) ||
			(pLastQueryResult == NULL) ||
			!(*pLastQueryResult == *pTestResult))
		{
			// make sure we do not have too many items
			BOOL bRemoveLast = nCount > m_nMaxCount;
			if (bRemoveLast)
			{
				delete RemoveTail();
			}
			// add the item
			AddHead(pTestResult);
			action = bRemoveLast ? addedAndRemoved : added;
		}
		else
		{	
			// just just update the time stamp in the last message we have
			ASSERT(pLastQueryResult != NULL);
			memcpy(&(pLastQueryResult->m_queryTime), &(pTestResult->m_queryTime),
							sizeof(SYSTEMTIME));
			action = changed;
			delete pTestResult; // not added
		}
		Unlock();
		return action;
	}
	BOOL LastQuerySuceeded()
	{
		BOOL bRes = TRUE;
		Lock();
		if (GetCount() > 0)
			bRes = GetHead()->Succeded();
		Unlock();
		return bRes;
	}
	int GetMaxCount()
	{
		return m_nMaxCount;
	}

private:
	CRITICAL_SECTION m_cs;
	int m_nMaxCount;
};



/////////////////////////////////////////////////////////////////////////
// CDNSServerNode

class CDNSServerQueryObj : public CDNSQueryObj
{
public:
	CDNSServerQueryObj(BOOL bAdvancedView, DWORD dwServerVersion)
			: CDNSQueryObj(bAdvancedView, dwServerVersion){}
	virtual BOOL Enumerate();
private:
};


class CDNSServerNode : public CDNSMTContainerNode
{
public:
	CDNSServerNode(LPCTSTR lpszName, BOOL bIsLocalServer = FALSE);
	virtual ~CDNSServerNode();

	virtual void SetDisplayName(LPCWSTR lpszDisplayName);
  void SetLocalServer(BOOL bLocalServer) { m_bLocalServer = bLocalServer; }
  BOOL IsLocalServer() { return m_bLocalServer; }

	// node info
	DECLARE_NODE_GUID()
	virtual HRESULT GetDataHere(CLIPFORMAT cf, LPSTGMEDIUM lpMedium,
			CDataObject* pDataObject);
	virtual HRESULT GetData(CLIPFORMAT cf, LPSTGMEDIUM lpMedium,
			CDataObject* pDataObject);
  HRESULT RetrieveEventViewerLogs(LPSTGMEDIUM lpMedium, CDataObject* pDataObject);

  virtual CColumnSet* GetColumnSet() 
  { 
    if (m_pColumnSet == NULL)
    {
      CDNSRootData* pRoot = (CDNSRootData*)GetRootContainer();
      m_pColumnSet = ((CDNSComponentDataObjectBase*)pRoot->GetComponentDataObject())->GetColumnSet(L"---Server Column Set---");
    }
    return m_pColumnSet;
  }

	virtual HRESULT OnCommand(long nCommandID, 
                            DATA_OBJECT_TYPES type, 
                            CComponentDataObject* pComponentData,
                            CNodeList* pNodeList);
	virtual void OnDelete(CComponentDataObject* pComponentData,
                        CNodeList* pNodeList);
	virtual BOOL OnRefresh(CComponentDataObject* pComponentData,
                         CNodeList* pNodeList);

	virtual LPCWSTR GetString(int nCol)
	{
		return (nCol == 0) ? GetDisplayName() : g_lpszNullString;
	}

	virtual int GetImageIndex(BOOL bOpenImage);

	virtual BOOL HasPropertyPages(DATA_OBJECT_TYPES type, 
                                BOOL* pbHideVerb,
                                CNodeList* pNodeList);
	virtual HRESULT CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, 
                                      LONG_PTR handle,
                                      CNodeList* pNodeList);
   virtual HRESULT CreatePropertyPagesHelper(LPPROPERTYSHEETCALLBACK lpProvider, 
									                  LONG_PTR handle, 
                                             long nStartProppage);

  virtual void DecrementSheetLockCount();

  virtual BOOL CanExpandSync() { return TRUE; }

protected:
	virtual LPCONTEXTMENUITEM2 OnGetContextMenuItemTable()
				{ return CDNSServerMenuHolder::GetContextMenuItem(); }
	virtual BOOL OnAddMenuItem(LPCONTEXTMENUITEM2 pContextMenuItem2,
								             long *pInsertionAllowed);
	virtual BOOL OnSetDeleteVerbState(DATA_OBJECT_TYPES type, 
                                    BOOL* pbHide,
                                    CNodeList* pNodeList);
	virtual BOOL OnSetRefreshVerbState(DATA_OBJECT_TYPES type, 
                                     BOOL* pbHide,
                                     CNodeList* pNodeList);
  virtual HRESULT OnSetToolbarVerbState(IToolbar* pToolbar, 
                                        CNodeList* pNodeList);

  virtual HRESULT GetResultViewType(CComponentDataObject* pComponentData, 
                                    LPOLESTR *ppViewType, 
                                    long *pViewOptions);
  virtual HRESULT OnShow(LPCONSOLE lpConsole);

	virtual CQueryObj* OnCreateQuery();
	virtual void OnHaveData(CObjBase* pObj, CComponentDataObject* pComponentDataObject);

#ifdef USE_NDNC
  BOOL ContainsDefaultNDNCs();
#endif

  virtual void SetRecordAging();
  virtual void ScavengeRecords();

private:
	// folders mainipulation
	//CCathegoryFolderNode* GetCathegoryFolder(CCathegoryFolderQueryObj::queryType type);

	CDNSAuthoritatedZonesNode* GetAuthoritatedZoneFolder(BOOL bFwd);

	// command handlers
	HRESULT OnNewZone(CComponentDataObject* pComponentData, CNodeList* pNodeList);
	void OnUpdateDataFiles(CComponentDataObject* pComponentData);
  void OnClearCache(CComponentDataObject* pComponentData);
  void OnConfigureServer(CComponentDataObject* pComponentData);
  void OnLaunchNSLookup();

#ifdef USE_NDNC
  void OnCreateNDNC();
#endif

public:
	void ChangeViewOption(BOOL bAdvanced, CComponentDataObject* pComponentData);
	
	// serialization from/to stream
	static HRESULT CreateFromStream(IStream* pStm, CDNSServerNode** ppServerNode);
	HRESULT SaveToStream(IStream* pStm);

	// DNS specific helpers
#ifdef USE_NDNC
	DNS_STATUS CreatePrimaryZone(LPCTSTR lpszName, 
                               LPCTSTR lpszFileName, 
                               BOOL bLoadExisting,
							                 BOOL bFwd, 
                               BOOL bDSIntegrated, 
                               UINT nDynamicUpdate,
							                 CComponentDataObject* pComponentData,
                               ReplicationType replType,
                               PCWSTR pszPartitionName);
	DNS_STATUS CreateStubZone(LPCTSTR lpszName, 
                            LPCTSTR lpszFileName,
									          BOOL bLoadExisting, 
                            BOOL bDSIntegrated, 
                            BOOL bFwd,
									          DWORD* ipMastersArray, 
                            int nIPMastersCount,
                            BOOL bLocalListOfMasters,
									          CComponentDataObject* pComponentData,
                            ReplicationType replType,
                            PCWSTR pszPartitionName);
#else
	DNS_STATUS CreatePrimaryZone(LPCTSTR lpszName, LPCTSTR lpszFileName, BOOL bLoadExisting,
							BOOL bFwd, BOOL bDSIntegrated, UINT nDynamicUpdate,
							CComponentDataObject* pComponentData);
	DNS_STATUS CreateStubZone(LPCTSTR lpszName, LPCTSTR lpszFileName,
									BOOL bLoadExisting, BOOL bDSIntegrated, BOOL bFwd,
									DWORD* ipMastersArray, int nIPMastersCount,
                            BOOL bLocalListOfMasters,
									CComponentDataObject* pComponentData);
#endif // USE_NDNC

	DNS_STATUS CreateSecondaryZone(LPCTSTR lpszName, LPCTSTR lpszFileName,
									BOOL bLoadExisting, BOOL bFwd,
									DWORD* ipMastersArray, int nIPMastersCount,
									CComponentDataObject* pComponentData);
  DNS_STATUS CreateForwarderZone(LPCTSTR lpszName, 
				                         DWORD* ipMastersArray, 
                                 int nIPMastersCount,
                                 DWORD dwTimeout,
                                 DWORD fSlave,
                                 CComponentDataObject* pComponentData);

	DNS_STATUS EnumZoneInfo(CZoneInfoHolder* pZoneInfoHolder);

	static DNS_STATUS EnumZoneInfo(LPCTSTR lpszServerName, CZoneInfoHolder* pZoneInfoHolder);

  DNS_STATUS ClearCache();

	// name used for RPC calls
	LPCWSTR GetRPCName();

	// server info access functions
	BOOL HasServerInfo() { ASSERT(m_pServInfoEx != NULL); return m_pServInfoEx->HasData();}
	void AttachServerInfo(CDNSServerInfoEx* pNewInfo);

	BOOL CanUseADS();
	DWORD GetVersion();
	BYTE GetMajorVersion(){ return DNS_SRV_MAJOR_VERSION(GetVersion());}
	BYTE GetMinorVersion(){ return DNS_SRV_MINOR_VERSION(GetVersion());}
	WORD GetBuildNumber() { return DNS_SRV_BUILD_NUMBER(GetVersion());}

   DWORD GetForestVersion();
   DWORD GetDomainVersion();

	void CreateDsServerLdapPath(CString& sz);
  void CreateDsZoneLdapPath(CDNSZoneNode* pZoneNode, CString& sz);
	void CreateDsZoneName(CDNSZoneNode* pZoneNode, CString& sz);
	void CreateDsNodeLdapPath(CDNSZoneNode* pZoneNode, CDNSDomainNode* pDomainNode, CString& sz);
  void CreateLdapPathFromX500Name(LPCWSTR lpszX500Name, CString& szLdapPath);

  //
  // Server property accessors
  //
	DWORD      GetNameCheckFlag();
	DNS_STATUS ResetNameCheckFlag(DWORD dwNameCheckFlag);

	DWORD      GetLogLevelFlag();
	DNS_STATUS ResetLogLevelFlag(DWORD dwLogLevel);

  DWORD      GetEventLogLevelFlag();
  DNS_STATUS ResetEventLogLevelFlag(DWORD dwEventLogLevel);

  PIP_ARRAY  GetDebugLogFilterList();
  DNS_STATUS ResetDebugLogFilterList(PIP_ARRAY pIPArray);

  PCWSTR     GetDebugLogFileName();
  DNS_STATUS ResetDebugLogFileName(PCWSTR pszLogFileName);

  DWORD      GetDebugLogFileMaxSize();
  DNS_STATUS ResetDebugLogFileMaxSize(DWORD dwMaxSize);

  BOOL       DoesRecursion();

	void       GetAdvancedOptions(BOOL* bOptionsArray);
	DNS_STATUS ResetAdvancedOptions(BOOL* bOptionsArray, DNS_STATUS* dwRegKeyOptionsErrorArr);

  UCHAR      GetBootMethod();
  DNS_STATUS ResetBootMethod(UCHAR fBootMethod);

  BOOL       IsServerConfigured();
  DNS_STATUS SetServerConfigured();

  BOOL       GetScavengingState();

  DWORD      GetScavengingInterval();
  DNS_STATUS ResetScavengingInterval(DWORD dwScavengingInterval);

  DWORD      GetDefaultRefreshInterval();
  DNS_STATUS ResetDefaultRefreshInterval(DWORD dwRefreshInterval);

  DWORD      GetDefaultNoRefreshInterval();
  DNS_STATUS ResetDefaultNoRefreshInterval(DWORD dwNoRefreshInterval);

  DWORD      GetDefaultScavengingState();
  DNS_STATUS ResetDefaultScavengingState(DWORD bScavengingState);

#ifdef USE_NDNC
  PCSTR     GetDomainName();
  PCSTR     GetForestName();
#endif

  DNS_STATUS ResetListenAddresses(DWORD cAddrCount, PIP_ADDRESS pipAddrs);
	void GetListenAddressesInfo(DWORD* pcAddrCount, PIP_ADDRESS* ppipAddrs);
	void GetServerAddressesInfo(DWORD* pcAddrCount, PIP_ADDRESS* ppipAddrs);

	DNS_STATUS ResetForwarders(DWORD cForwardersCount, PIP_ADDRESS pipForwarders, DWORD dwForwardTimeout, DWORD fSlave);
	void GetForwardersInfo(DWORD* pcForwardersCount, PIP_ADDRESS* ppipForwarders, DWORD* pdwForwardTimeout, DWORD* pfSlave);

	// Root Hints management API's
	BOOL HasRootHints() { return m_pRootHintsNode != NULL;}
	CDNSRootHintsNode* GetRootHints();
  void AttachRootHints(CDNSRootHintsNode* pNewRootHints);

	// testing options
	void GetTestOptions(CDNSServerTestOptions* pOptions);
	void ResetTestOptions(CDNSServerTestOptions* pOptions);

	BOOL IsTestEnabled() { return m_testOptions.m_bEnabled;}
	DWORD GetTestInterval() { return m_testOptions.m_dwInterval;}
	BOOL IsTestSimpleQueryEnabled() { return m_testOptions.m_bSimpleQuery;}
	BOOL IsRecursiveQueryEnabled() { return m_testOptions.m_bRecursiveQuery;}

	// test result manipulation
	void AddTestQueryResult(CDNSServerTestQueryResult* pTestResult,
							CComponentDataObject* pComponentData);

  void SetProppageStart(int nStartPage) { m_nStartProppage = nStartPage; }

  CDNSDomainForwardersNode* GetDomainForwardersNode() { return m_pDomainForwardersFolderNode; }

private:
	DNS_STATUS WriteDirtyZones();
	CDNSZoneNode* GetNewZoneNode();

	// server info manipulation
	CDNSServerInfoEx* m_pServInfoEx;

	void FreeServInfo();		// free memory
	DNS_STATUS GetServInfo();	// read info from server

	// root hints info
	CDNSRootHintsNode*		m_pRootHintsNode;

	void FreeRootHints();

	// server test query info
	CDNSServerTestOptions			m_testOptions;
	DWORD							m_dwTestTime;
	CDNSServerTestQueryResultList	m_testResultList;
	BOOL							m_bTestQueryPending;
  BOOL              m_bShowMessages;
  BOOL              m_bPrevQuerySuccess;

  int m_nStartProppage;
  BOOL  m_bLocalServer;

	// cached pointer to cache folder
	CDNSCacheNode*					  m_pCacheFolderNode;
	CDNSForwardZonesNode*			m_pFwdZonesFolderNode;
	CDNSReverseZonesNode*			m_pRevZonesFolderNode;
  CDNSDomainForwardersNode* m_pDomainForwardersFolderNode;

	friend class CDNSRootData;
	friend class CDNSServer_TestPropertyPage;

  DECLARE_TOOLBAR_MAP()
};


/////////////////////////////////////////////////////////////////////////
// CDNSServerOptionNode
// 
// represents the root hints in the UI as leaf node of the server node
// It serves no other function but to give access to the Root Hints page
// of the server properties

class CDNSServerOptionNode : public CLeafNode
{
public:
   CDNSServerOptionNode(UINT nDisplayNameID, UINT startPageCode);

   virtual void OnDelete(CComponentDataObject*, CNodeList*) { ASSERT(false); } // no delete allowed

   virtual LPCWSTR GetString(int nCol);
   virtual int     GetImageIndex(BOOL bOpenImage);

   virtual HRESULT OnSetToolbarVerbState(IToolbar* pToolbar, CNodeList*);

   virtual BOOL HasPropertyPages(DATA_OBJECT_TYPES type, 
                                 BOOL* pbHideVerb,
                                 CNodeList* pNodeList);
   virtual HRESULT CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, 
                                       LONG_PTR handle,
                                       CNodeList* pNodeList);

   virtual BOOL DelegatesPPToContainer() { return TRUE; }

   virtual void ShowPageForNode(CComponentDataObject* pComponentDataObject);

private:
   UINT m_nStartPageCode;
};




#endif // _SERVER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\serverui.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       serverui.cpp
//
//--------------------------------------------------------------------------


#include "preDNSsn.h"
#include <SnapBase.h>

#include "resource.h"
#include "dnsutil.h"
#include "DNSSnap.h"
#include "snapdata.h"

#include "server.h"
#include "serverUI.h"
#include "servwiz.h"    // CRootHintsQueryThread
#include "domain.h"
#include "zone.h"

///////////////////////////////////////////////////////////////////////////////
// CDNSServer_InterfacesPropertyPage

BEGIN_MESSAGE_MAP(CDNSServer_InterfacesPropertyPage, CPropertyPageBase)
	ON_BN_CLICKED(IDC_LISTEN_ON_ALL_RADIO, OnListenOnAllAddresses)
	ON_BN_CLICKED(IDC_LISTEN_ON_SPECIFIED_RADIO, OnListenOnSpecifiedAddresses)
END_MESSAGE_MAP()


void CDNSServer_InterfacesPropertyPage::CListenAddressesIPEditor::OnChangeData()
{
	CDNSServer_InterfacesPropertyPage* pPage =  
				(CDNSServer_InterfacesPropertyPage*)GetParentWnd();
	pPage->SetDirty(TRUE);
	if (GetCount() == 0)
	{
		CButton* pListenAllButton = pPage->GetListenOnAllRadio();
		pListenAllButton->SetCheck(TRUE);
		pPage->GetListenOnSpecifiedRadio()->SetCheck(FALSE);
		pPage->SelectionHelper(TRUE);
		pListenAllButton->SetFocus();
	}
}


CDNSServer_InterfacesPropertyPage::CDNSServer_InterfacesPropertyPage() 
				: m_bAllWasPreviousSelection(FALSE),
          CPropertyPageBase(IDD_SERVER_INTERFACES_PAGE)
{
}


BOOL CDNSServer_InterfacesPropertyPage::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();

	CDNSServerPropertyPageHolder* pHolder = 
		(CDNSServerPropertyPageHolder*)GetHolder();
	CDNSServerNode* pServerNode = pHolder->GetServerNode();

	VERIFY(m_listenAddressesEditor.Initialize(this, 
                                            GetParent(),
                                            IDC_BUTTON_UP, 
                                            IDC_BUTTON_DOWN,
								                            IDC_BUTTON_ADD, 
                                            IDC_BUTTON_REMOVE, 
								                            IDC_IPEDIT, 
                                            IDC_LIST));
	
	if (!pServerNode->HasServerInfo())
	{
		EnableWindow(FALSE);
		return TRUE;
	}

	BOOL bListenAll = FALSE;
	DWORD cAddrCount;
	PIP_ADDRESS pipAddrs;
	pServerNode->GetListenAddressesInfo(&cAddrCount, &pipAddrs);
	if (cAddrCount == 0)
	{
		// listening on all addresses
		pServerNode->GetServerAddressesInfo(&cAddrCount, &pipAddrs);
		bListenAll = TRUE;
    m_bAllWasPreviousSelection = TRUE;
	}
	GetListenOnAllRadio()->SetCheck(bListenAll);
	GetListenOnSpecifiedRadio()->SetCheck(!bListenAll);
  if (cAddrCount > 0)
	{
	  m_listenAddressesEditor.AddAddresses(pipAddrs, cAddrCount); 
    m_bAllWasPreviousSelection = FALSE;
  }
	m_listenAddressesEditor.EnableUI(!bListenAll, TRUE);

	SetDirty(FALSE);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDNSServer_InterfacesPropertyPage::SelectionHelper(BOOL bListenAll)
{
	CDNSServerPropertyPageHolder* pHolder = 
		(CDNSServerPropertyPageHolder*)GetHolder();
	CDNSServerNode* pServerNode = pHolder->GetServerNode();

  if ((m_bAllWasPreviousSelection && !bListenAll) || bListenAll)
  {
	  m_listenAddressesEditor.Clear();
  }
	DWORD cAddrCount;
	PIP_ADDRESS pipAddrs;
	pServerNode->GetServerAddressesInfo(&cAddrCount, &pipAddrs);
  if (cAddrCount > 0)
	{
	  m_listenAddressesEditor.AddAddresses(pipAddrs, cAddrCount);
  }
  m_listenAddressesEditor.EnableUI(!bListenAll, TRUE);
  
  m_bAllWasPreviousSelection = bListenAll;
	SetDirty(TRUE);
}

void CDNSServer_InterfacesPropertyPage::OnListenOnSpecifiedAddresses()
{
	//ASSERT(!GetListenOnAllRadio()->GetCheck());
	//ASSERT(GetListenOnSpecifiedRadio()->GetCheck());

	SelectionHelper(FALSE);
}

void CDNSServer_InterfacesPropertyPage::OnListenOnAllAddresses()
{
	//ASSERT(GetListenOnAllRadio()->GetCheck());
	//ASSERT(!GetListenOnSpecifiedRadio()->GetCheck());
	SelectionHelper(TRUE);
}


BOOL CDNSServer_InterfacesPropertyPage::OnApply()
{
	CDNSServerPropertyPageHolder* pHolder = 
		(CDNSServerPropertyPageHolder*)GetHolder();
	CDNSServerNode* pServerNode = pHolder->GetServerNode();

	if (!IsDirty())
		return TRUE;

	int cAddrCount = 0;
	if (GetListenOnSpecifiedRadio()->GetCheck())
	{
		// get the data from the IP editor
		cAddrCount = m_listenAddressesEditor.GetCount();
	}

  BOOL bRet = TRUE;
	DWORD* pArr = (cAddrCount > 0) ? (DWORD*) malloc(sizeof(DWORD)*cAddrCount) : NULL;
	if (pArr != NULL && cAddrCount > 0)
	{
		int nFilled = 0;
		m_listenAddressesEditor.GetAddresses(pArr, cAddrCount, &nFilled);
		ASSERT(nFilled == cAddrCount);
	}

	// write to server
	DNS_STATUS err = pServerNode->ResetListenAddresses(cAddrCount, pArr);
	if (err != 0)
	{
		DNSErrorDialog(err, IDS_MSG_SERVER_INTERFACE_UPDATE_FAILED);
		bRet = FALSE;
	}

  if (pArr)
  {
    free(pArr);
    pArr = 0;
  }
	return bRet;
}


////////////////////////////////////////////////////////////////////////////////////
// CDomainForwardersEditInfo

CDomainForwardersEditInfo::CDomainForwardersEditInfo(
  CDNSZoneNode* pZoneNode, 
  BOOL bADIntegrated,
  BOOL bAllOthers) 
  : m_bADIntegrated(bADIntegrated),
    m_pZoneNode(pZoneNode)
{
  m_bAllOthersDomain = bAllOthers;
  m_actionItem  = nochange;

  if (pZoneNode != NULL)
  {
    m_bRPCData = TRUE;
    pZoneNode->GetMastersInfo(&m_cAddrCount, &m_pIPList);
    m_szDomainName = pZoneNode->GetDisplayName();
    m_szDomainName.TrimLeft(L' ');
    m_szDomainName.TrimRight(L' ');

    m_bSlave      = pZoneNode->IsForwarderSlave();
    m_dwTimeout   = pZoneNode->ForwarderTimeout();
  }
  else
  {
    m_bRPCData = FALSE;
    m_cAddrCount  = 0;
    m_pIPList     = NULL;
    m_szDomainName = L"";
    m_bSlave      = DNS_DEFAULT_SLAVE;
    m_dwTimeout   = DNS_DEFAULT_FORWARD_TIMEOUT;
  }
}

CDomainForwardersEditInfo::~CDomainForwardersEditInfo() 
{
  if (m_bAllOthersDomain && m_pAllOthers != NULL)
  {
    delete m_pAllOthers;
  }

  if (m_pIPList != NULL && 
      m_actionItem != nochange &&
      !m_bRPCData)
  {
    free(m_pIPList);
    m_pIPList = NULL;
  }
}

PIP_ADDRESS CopyIPAddresses(PIP_ADDRESS pipAddrs, DWORD AddrCount)
{
   if (!pipAddrs ||
       AddrCount < 1)
   {
      return 0;
   }

   int sizeofArray = AddrCount * sizeof(IP_ADDRESS);
   PIP_ADDRESS result = (PIP_ADDRESS)malloc(sizeofArray);
   
   if (!result)
   {
      return result;
   }

   memcpy(result, pipAddrs, sizeofArray);

   return result;
}
      
void CDomainForwardersEditInfo::SetAllOthersDomain(CAllOthersDomainInfo* pAllOthers)
{
  if (pAllOthers != NULL)
  {
    m_bAllOthersDomain = TRUE;
    m_pAllOthers = pAllOthers;
    m_cAddrCount = m_pAllOthers->m_cAddrCount;
    m_pIPList    = CopyIPAddresses(m_pAllOthers->m_pipAddrs, m_pAllOthers->m_cAddrCount);
    m_bSlave     = m_pAllOthers->m_fSlave;
    m_dwTimeout  = m_pAllOthers->m_dwForwardTimeout;
  }
}

void CDomainForwardersEditInfo::SetAction(ACTION_ITEM action)
{
  m_actionItem = action; 
}

BOOL CDomainForwardersEditInfo::Update(BOOL bSlave, DWORD dwTimeout, DWORD dwCount, PIP_ADDRESS pipArray)
{
  BOOL bUpdate = FALSE;

  if (bSlave != m_bSlave ||
      dwTimeout != m_dwTimeout)
  {
    bUpdate = TRUE;

    m_bSlave = bSlave;
    m_dwTimeout = dwTimeout;
  }

  if (dwCount != m_cAddrCount)
  {
    if (m_pIPList != NULL)
    {
      if (!m_bRPCData)
      {
        //
        // Free the memory if it isn't part of the RPC structure
        //
        free(m_pIPList);
        m_pIPList = NULL;
      }
    }
    m_bRPCData = FALSE;
    m_pIPList = pipArray;
    m_cAddrCount = dwCount;
    bUpdate = TRUE;
  }
  else
  {
    if (m_pIPList != NULL)
    {
      for (UINT nIndex = 0; nIndex < dwCount; nIndex++)
      {
        if (nIndex <= m_cAddrCount)
        {
          if (pipArray[nIndex] != m_pIPList[nIndex])
          {
            bUpdate = TRUE;
            if (!m_bRPCData)
            {
              free(m_pIPList);
              m_pIPList = NULL;
            }
            m_bRPCData = FALSE;
            m_pIPList = pipArray;
            m_cAddrCount = dwCount;
            break;
          }
        }
        else
        {
          bUpdate = TRUE;
          if (m_actionItem != nochange)
          {
            free(m_pIPList);
            m_pIPList = NULL;
          }
          m_pIPList = pipArray;
          m_cAddrCount = dwCount;
          break;
        }
      }
    }
    else if (m_pIPList != NULL && dwCount > 0)
    {
      bUpdate = TRUE;
      m_pIPList = pipArray;
      m_cAddrCount = dwCount;
    }
  }

  if (bUpdate)
  {
    switch (GetAction())
    {
      case nochange:
      case update:
        SetAction(update);
        break;
      case remove:
      case add:
      default:
        break;
    }
  }
  return bUpdate;
}

///////////////////////////////////////////////////////////////////////////////
// CDNSServer_AddDomainForwarderDialog

class CDNSServer_AddDomainForwarderDialog : public CHelpDialog
{
public:
  CDNSServer_AddDomainForwarderDialog(CDNSServerNode* pServerNode,
                                      CComponentDataObject* pComponentData) 
    : CHelpDialog(IDD_SERVER_NEW_DOMAIN_FORWARDER, pComponentData),
      m_pComponentData(pComponentData),
      m_pServerNode(pServerNode)
  {
    m_bOkable = FALSE;
    m_szDomainName = L"";
  }

  ~CDNSServer_AddDomainForwarderDialog() {}

  //
  // Public data
  //
  CString m_szDomainName;

  DECLARE_MESSAGE_MAP()

  virtual BOOL OnInitDialog();
  virtual void OnOK();
  afx_msg void OnDomainEdit();

private:
  BOOL    m_bOkable;
  CDNSServerNode* m_pServerNode;
  CComponentDataObject* m_pComponentData;
};

BEGIN_MESSAGE_MAP(CDNSServer_AddDomainForwarderDialog, CHelpDialog)
  ON_EN_CHANGE(IDC_DOMAIN_NAME_EDIT, OnDomainEdit)
END_MESSAGE_MAP()


BOOL CDNSServer_AddDomainForwarderDialog::OnInitDialog()
{
  CHelpDialog::OnInitDialog();
  
  GetDlgItem(IDOK)->EnableWindow(m_bOkable);
  SendDlgItemMessage(IDC_DOMAIN_NAME_EDIT, EM_SETLIMITTEXT, (WPARAM)254, 0);

  return TRUE;
}


void CDNSServer_AddDomainForwarderDialog::OnDomainEdit()
{
  GetDlgItemText(IDC_DOMAIN_NAME_EDIT, m_szDomainName);
  m_szDomainName.TrimLeft(L' ');
  m_szDomainName.TrimRight(L' ');
  m_bOkable = !m_szDomainName.IsEmpty();
  GetDlgItem(IDOK)->EnableWindow(m_bOkable);
}

void CDNSServer_AddDomainForwarderDialog::OnOK()
{
  DNS_STATUS err = ::ValidateDnsNameAgainstServerFlags(m_szDomainName, 
                                                       DnsNameDomain, 
                                                       m_pServerNode->GetNameCheckFlag());
  if (err != 0)
  {
    CString szFormatMsg;
    VERIFY(szFormatMsg.LoadString(IDS_MSG_DOMAIN_FORWARDER_ILLEGAL_NAME));
    CString szMessage;
    szMessage.Format(szFormatMsg, m_szDomainName);

    DNSErrorDialog(err, szMessage);
    return;
  }
  CHelpDialog::OnOK();
}
///////////////////////////////////////////////////////////////////////////////
// CDNSServer_DomainForwardersPropertyPage

void CDNSServer_DomainForwardersPropertyPage::CForwarderAddressesIPEditor::OnChangeData()
{
	CDNSServer_DomainForwardersPropertyPage* pPage =  
				(CDNSServer_DomainForwardersPropertyPage*)GetParentWnd();
	pPage->SetDirty(TRUE);
}


BEGIN_MESSAGE_MAP(CDNSServer_DomainForwardersPropertyPage, CPropertyPageBase)
  ON_LBN_SELCHANGE(IDC_DOMAIN_LIST, OnDomainSelChange)
  ON_BN_CLICKED(IDC_DOMAIN_ADD_BUTTON, OnAddDomain)
  ON_BN_CLICKED(IDC_DOMAIN_REMOVE_BUTTON, OnRemoveDomain)
	ON_BN_CLICKED(IDC_SLAVE_CHECK, OnSlaveCheckChange)
	ON_EN_CHANGE(IDC_FWD_TIMEOUT_EDIT, OnForwarderTimeoutChange)
END_MESSAGE_MAP()

CDNSServer_DomainForwardersPropertyPage::CDNSServer_DomainForwardersPropertyPage() 
				: m_pCurrentInfo(NULL),
              m_bPostApply(FALSE),
              m_bPageReadOnly(FALSE),
              m_bChangingSelection(FALSE),
              CPropertyPageBase(IDD_SERVER_DOMAIN_FORWARDERS_PAGE)
{
}

void CDNSServer_DomainForwardersPropertyPage::OnDomainSelChange()
{
	CDNSServerPropertyPageHolder* pHolder = 
		(CDNSServerPropertyPageHolder*)GetHolder();
	CDNSServerNode* pServerNode = pHolder->GetServerNode();

  // Set a flag so that we don't mark the page dirty when we are just
  // changing the selection

  m_bChangingSelection = TRUE;

  CListBox* pDomainList = (CListBox*)GetDlgItem(IDC_DOMAIN_LIST);
  if (pDomainList != NULL)
  {
    int iSel = pDomainList->GetCurSel();
    if (iSel != LB_ERR)
    {
      LRESULT lRes = pDomainList->GetItemData(iSel);
      if (lRes != LB_ERR)
      {
        //
        // Retrieve the edit info from the list box item
        //
        CDomainForwardersEditInfo* pInfo = reinterpret_cast<CDomainForwardersEditInfo*>(lRes);
        if (pInfo != NULL)
        {
          //
          // Store the previous selection's data before changing the UI.
          // This may be NULL during OnInitDialog so check before trying
          // to store the info.
          //
          if (m_pCurrentInfo != NULL)
          {
            BOOL bSlave = GetSlaveCheck()->GetCheck();
            DWORD dwTimeout = m_forwardTimeoutEdit.GetVal();

	          DWORD cAddrCount = m_forwarderAddressesEditor.GetCount();
            DWORD* pArr = (cAddrCount > 0) ? (DWORD*) malloc(sizeof(DWORD)*cAddrCount) : NULL;
            if (pArr != NULL)
            {
	            if (cAddrCount > 0)
	            {
		            int nFilled = 0;
		            m_forwarderAddressesEditor.GetAddresses(pArr, cAddrCount, &nFilled);
		            ASSERT(nFilled == (int)cAddrCount);
	            }
            }
            m_pCurrentInfo->Update(bSlave, dwTimeout, cAddrCount, pArr);
          }

          m_pCurrentInfo = pInfo;

          //
          // Enable the remove button according to the selection
          //
          if (pInfo->IsAllOthers())
          {
            GetDlgItem(IDC_DOMAIN_REMOVE_BUTTON)->EnableWindow(FALSE);
          }
          else
          {
            if (!m_bPageReadOnly)
            {
               GetDlgItem(IDC_DOMAIN_REMOVE_BUTTON)->EnableWindow(TRUE);
            }
          }

          if (pServerNode->GetBuildNumber() < DNS_SRV_BUILD_NUMBER_WHISTLER ||
              (pServerNode->GetMajorVersion() <= DNS_SRV_MAJOR_VERSION_NT_5 &&
               pServerNode->GetMinorVersion() < DNS_SRV_MINOR_VERSION_WHISTLER))
          {
            //
            // Domain forwarding not available on pre-Whistler servers
            //
            GetDlgItem(IDC_DOMAIN_ADD_BUTTON)->EnableWindow(FALSE);
            GetDlgItem(IDC_DOMAIN_REMOVE_BUTTON)->EnableWindow(FALSE);
          }

          //
          // load data into the controls
          //
          GetSlaveCheck()->SetCheck(pInfo->IsSlave());
          m_forwardTimeoutEdit.SetVal(pInfo->GetTimeout());

          //
          // Display the text of the forwarder is AD integrated
          //
          GetDlgItem(IDC_FORWARDER_ADINT_STATIC)->ShowWindow(pInfo->IsADIntegrated());

          //
          // Clear the IP Editor controls
          //
          m_forwarderAddressesEditor.Clear();

          DWORD cAddrCount = 0;
          PIP_ADDRESS pipAddrs = pInfo->GetIPList(&cAddrCount);
          if (cAddrCount > 0 && pipAddrs != NULL)
	        {
              BOOL bDirtyState = IsDirty();
		        m_forwarderAddressesEditor.AddAddresses(pipAddrs, cAddrCount); 
              SetDirty(bDirtyState);
	        }
        }
      }
    }

   // Set the horizontal extent of the listbox so that the horizontal scroll
   // bar will scroll to the longest string

   CString str;      
   int  dx = 0;
   CDC* pDC = pDomainList->GetDC();
   TEXTMETRIC tm;
   VERIFY(pDC->GetTextMetrics(&tm));
   for (int i = 0; i < pDomainList->GetCount(); ++i)
   {
      pDomainList->GetText(i, str);
      CSize sz = pDC->GetTextExtent(str);

      dx = max(sz.cx, dx);
   }
   pDomainList->ReleaseDC(pDC);
   pDomainList->SetHorizontalExtent(dx);
    
  }

  m_bChangingSelection = FALSE;
}

void CDNSServer_DomainForwardersPropertyPage::OnAddDomain()
{
   CThemeContextActivator activator;

	CDNSServerPropertyPageHolder* pHolder = 
		(CDNSServerPropertyPageHolder*)GetHolder();
	CDNSServerNode* pServerNode = pHolder->GetServerNode();

  CDNSServer_AddDomainForwarderDialog dlg(pServerNode, pHolder->GetComponentData());
  if (dlg.DoModal() == IDOK)
  {
    CListBox* pDomainList = (CListBox*)GetDlgItem(IDC_DOMAIN_LIST);

    //
    // Check to see if the name already exists
    //
    int iIndex = LB_ERR;
    int iFindIdx = pDomainList->FindStringExact(-1, dlg.m_szDomainName);
    if (iFindIdx == LB_ERR)
    {
      //
      // Add the name if it isn't already there
      //
      
      iIndex = pDomainList->InsertString(1, dlg.m_szDomainName);
    }
    else
    {
      //
      // If its there just point to it
      //
      iIndex = iFindIdx;
    }

    if (iIndex != LB_ERR)
    {
      CDomainForwardersEditInfo* pSearchInfo = m_EditList.DoesExist(dlg.m_szDomainName);
      if (pSearchInfo != NULL)
      {
        switch (pSearchInfo->GetAction())
        {
          case CDomainForwardersEditInfo::nochange:
          case CDomainForwardersEditInfo::update:
          case CDomainForwardersEditInfo::remove:
            pSearchInfo->SetAction(CDomainForwardersEditInfo::update);
            break;
          case CDomainForwardersEditInfo::add:
          default:
            break;
        }
        int iIdx = pDomainList->FindStringExact(-1, dlg.m_szDomainName);
        if (iIdx != LB_ERR)
        {
          pDomainList->SetCurSel(iIdx);
          pDomainList->SetItemData(iIdx, (LPARAM)pSearchInfo);

          OnDomainSelChange();
        }
      }
      else
      {
        //
        // Attach some data to keep track of whats being added or changed
        //
        CDomainForwardersEditInfo* pNewEditInfo = new CDomainForwardersEditInfo(NULL, FALSE);
        if (pNewEditInfo != NULL)
        {
          pNewEditInfo->SetDomainName(dlg.m_szDomainName);
          m_EditList.AddTail(pNewEditInfo);

          pDomainList->SetItemData(iIndex, (LPARAM)pNewEditInfo);


          switch (pNewEditInfo->GetAction())
          {
            case CDomainForwardersEditInfo::nochange:
              pNewEditInfo->SetAction(CDomainForwardersEditInfo::add);
              break;
            case CDomainForwardersEditInfo::update:
            case CDomainForwardersEditInfo::remove:
            case CDomainForwardersEditInfo::add:
            default:
              ASSERT(FALSE);
              break;
          }

          pDomainList->SetCurSel(iIndex);
          OnDomainSelChange();
        }
      }
    }
  }
  SetDirty(TRUE);
}

void CDNSServer_DomainForwardersPropertyPage::OnRemoveDomain()
{
  CListBox* pDomainList = (CListBox*)GetDlgItem(IDC_DOMAIN_LIST);
  if (pDomainList != NULL)
  {
    int iSel = pDomainList->GetCurSel();
    if (iSel != LB_ERR)
    {
      CDomainForwardersEditInfo* pEditInfo = reinterpret_cast<CDomainForwardersEditInfo*>(pDomainList->GetItemData(iSel));
      if (pEditInfo != NULL)
      {
        ASSERT(pEditInfo == m_pCurrentInfo);

        switch (pEditInfo->GetAction())
        {
          case CDomainForwardersEditInfo::nochange:
          case CDomainForwardersEditInfo::update:
          case CDomainForwardersEditInfo::remove:
            pEditInfo->SetAction(CDomainForwardersEditInfo::remove);
            break;
          case CDomainForwardersEditInfo::add:
            m_EditList.Remove(pEditInfo);
            delete pEditInfo;
            break;
          default:
            ASSERT(FALSE);
            break;
        }
      }
      pDomainList->DeleteString(iSel);
      m_pCurrentInfo = NULL;

      //
      // Set the selection to the previous entry or 0
      //
      int nextSel = iSel - 1;
      if (nextSel < 0)
      {
         nextSel = 0;
      }
      pDomainList->SetCurSel(nextSel);
      OnDomainSelChange();
    }
  }
  SetDirty(TRUE);
}

void CDNSServer_DomainForwardersPropertyPage::OnSlaveCheckChange()
{
   if (!m_bChangingSelection)
   {
	   SetDirty(TRUE);
   }
}

void CDNSServer_DomainForwardersPropertyPage::OnForwarderTimeoutChange()
{
   if (!m_bChangingSelection)
   {
	   SetDirty(TRUE);
   }
}


BOOL CDNSServer_DomainForwardersPropertyPage::OnInitDialog() 
{
  CPropertyPageBase::OnInitDialog();

  CDNSServerPropertyPageHolder* pHolder = 
		(CDNSServerPropertyPageHolder*)GetHolder();
  CDNSServerNode* pServerNode = pHolder->GetServerNode();

  //
  // initialize controls
  //
  VERIFY(m_forwarderAddressesEditor.Initialize(this, 
                                               GetParent(),
                                               IDC_BUTTON_UP, 
                                               IDC_BUTTON_DOWN,
                                               IDC_BUTTON_ADD, 
                                               IDC_BUTTON_REMOVE, 
                                               IDC_IPEDIT, 
                                               IDC_LIST));
	
  VERIFY(m_forwardTimeoutEdit.SubclassDlgItem(IDC_FWD_TIMEOUT_EDIT, this));
  m_forwardTimeoutEdit.SetRange(1,0xffff ); // DWORD
  m_forwardTimeoutEdit.SetLimitText(5); // 0 to 65535

  //
  // Disable IME support on the controls
  //
  ImmAssociateContext(m_forwardTimeoutEdit.GetSafeHwnd(), NULL);

  if (!pServerNode->HasServerInfo())
  {
    //
    // clear the root hints message text
    //
    SetDlgItemText(IDC_STATIC_MESSAGE, NULL);
    EnableWindow(FALSE);
    return TRUE;
  }

  //
  // Don't show the AD Integrated text unless the forwarder is
  // AD integrated (rare)
  //
  GetDlgItem(IDC_FORWARDER_ADINT_STATIC)->ShowWindow(FALSE);

  GetForwarderData();
  LoadUIData();

  SetDirty(FALSE);
  return TRUE;  // return TRUE unless you set the focus to a control
                // EXCEPTION: OCX Property Pages should return FALSE
}

void CDNSServer_DomainForwardersPropertyPage::GetForwarderData()
{
	CDNSServerPropertyPageHolder* pHolder = 
		(CDNSServerPropertyPageHolder*)GetHolder();
	CDNSServerNode* pServerNode = pHolder->GetServerNode();

   //
   // Get the domain forwarders info from hidden Category node
   //
   CDNSDomainForwardersNode* pDomainForwardersNode = pServerNode->GetDomainForwardersNode();
   if (pDomainForwardersNode)
   {
     CNodeList* pNodeList = pDomainForwardersNode->GetContainerChildList();
     POSITION pos = pNodeList->GetHeadPosition();
     while (pos != NULL)
     {
       CDNSZoneNode* pZoneNode = dynamic_cast<CDNSZoneNode*>(pNodeList->GetNext(pos));
       if (pZoneNode != NULL && pZoneNode->GetZoneType() == DNS_ZONE_TYPE_FORWARDER)
       {
         //
         // Create a temporary list that will last through the duration of the page for all
         // the forwarders
         //
         BOOL bADIntegrated = pZoneNode->IsDSIntegrated(); 

         CDomainForwardersEditInfo* pForwardersInfo = new CDomainForwardersEditInfo(
                                                             pZoneNode, 
                                                             bADIntegrated,
                                                             FALSE);
         if (pForwardersInfo != NULL)
         {
           m_EditList.AddTail(pForwardersInfo);

         }
       }
     }

     (void)CreateAllOthersDomainInfo(pServerNode);
   }
}

CDomainForwardersEditInfo* CDNSServer_DomainForwardersPropertyPage::CreateAllOthersDomainInfo(CDNSServerNode* pServerNode)
{
   CDomainForwardersEditInfo* pForwardersInfo = 0;

   if (!pServerNode)
   {
     return pForwardersInfo;
   }


   //
   // get data from server
   //
   DWORD cAddrCount;
   PIP_ADDRESS pipAddrs;
   DWORD dwForwardTimeout;
   DWORD fSlave;
   pServerNode->GetForwardersInfo(&cAddrCount, &pipAddrs, &dwForwardTimeout, &fSlave);

   //
   // Create an edit list for the "All other domains" item
   //
   CAllOthersDomainInfo* pAllOthers = new CAllOthersDomainInfo(cAddrCount,
                                                               pipAddrs,
                                                               dwForwardTimeout,
                                                               fSlave);
   if (pAllOthers != NULL)
   {
     pForwardersInfo = new CDomainForwardersEditInfo(NULL, FALSE);
     if (pForwardersInfo != NULL)
     {
       pForwardersInfo->SetAllOthersDomain(pAllOthers);
       pForwardersInfo->SetDataFromRPC(TRUE);
       m_EditList.AddTail(pForwardersInfo);

     }
     else
     {
        delete pAllOthers;
        pAllOthers = 0;
     }
   }

   return pForwardersInfo;
}

void CDNSServer_DomainForwardersPropertyPage::LoadUIData()
{
   POSITION pos = m_EditList.GetHeadPosition();
   while (pos)
   {
      CDomainForwardersEditInfo* pForwarder = m_EditList.GetNext(pos);
      if (!pForwarder)
      {
         continue;
      }

      if (pForwarder->IsAllOthers())
      {
         //
         // Load the "All other domains" string and add it at the beginning
         //
         CString szAllOthers;
         VERIFY(szAllOthers.LoadString(IDS_OTHER_DOMAINS));

         LRESULT lRes = 0;
         lRes = SendDlgItemMessage(IDC_DOMAIN_LIST, LB_INSERTSTRING, 0, (LPARAM)(LPCWSTR)szAllOthers);
         if (lRes != LB_ERR)
         {
           SendDlgItemMessage(IDC_DOMAIN_LIST, LB_SETITEMDATA, lRes, (LPARAM)pForwarder);
         }
      }
      else
      {
        //
        // Add the forwarder to the UI
        //
        CString domainName;
        pForwarder->GetDomainName(domainName);

        LRESULT lIndex = SendDlgItemMessage(IDC_DOMAIN_LIST, 
                                            LB_ADDSTRING, 
                                            0, 
                                            (LPARAM)(LPCWSTR)domainName);
        if (lIndex != LB_ERR)
        {
          SendDlgItemMessage(IDC_DOMAIN_LIST, LB_SETITEMDATA, lIndex, (LPARAM)pForwarder);
        }
      }
   }
}

void CDNSServer_DomainForwardersPropertyPage::SetPageReadOnly(BOOL bServerHasRoot,
                                                              BOOL bDoesRecursion)
{
   m_bPageReadOnly = TRUE;

   //
   // the server is a root server or doesn't do recursion
   //
   EnableDialogControls(m_hWnd, FALSE);

   CStatic* pStatic = (CStatic*)GetDlgItem(IDC_STATIC_ADD_FORWARDERS);
   if (pStatic != NULL)
   {
      pStatic->ShowWindow(FALSE);
   }

   pStatic = (CStatic*)GetDlgItem(IDC_STATIC_MESSAGE);
   if (pStatic != NULL)
   {
      if (bServerHasRoot)
      {
         pStatic->ShowWindow(TRUE);
      }
      else
      {
         pStatic->ShowWindow(FALSE);
      }
   }

   if (!bDoesRecursion)
   {
      CString szNoRecursionText;
      VERIFY(szNoRecursionText.LoadString(IDS_DISABLED_FWDS_NO_RECURSION));
      SetDlgItemText(IDC_STATIC_CAPTION, szNoRecursionText);
   }

   GetDlgItem(IDC_DOMAIN_LIST)->EnableWindow(FALSE);
   GetDlgItem(IDC_LIST)->EnableWindow(FALSE);
   GetDlgItem(IDC_DOMAIN_REMOVE_BUTTON)->EnableWindow(FALSE);

   m_forwarderAddressesEditor.EnableUI(FALSE);
}

BOOL CDNSServer_DomainForwardersPropertyPage::OnSetActive()
{
	CDNSServerPropertyPageHolder* pHolder = 
		(CDNSServerPropertyPageHolder*)GetHolder();
	CDNSServerNode* pServerNode = pHolder->GetServerNode();

  BOOL bWasDirty = IsDirty();

  BOOL bServerHasRoot = FALSE;
  DNS_STATUS err = ServerHasRootZone(pServerNode->GetRPCName(), &bServerHasRoot);
  if (err == ERROR_SUCCESS && (bServerHasRoot || !pServerNode->DoesRecursion()))
  {
    SetPageReadOnly(bServerHasRoot, pServerNode->DoesRecursion());
  }
  else
  {
    m_bPageReadOnly = FALSE;

    //
    // clear the root hints message text
    //
    SetDlgItemText(IDC_STATIC_MESSAGE, NULL);

    //
    // Enable all the controls
    //
    EnableWindow(TRUE);
    EnableDialogControls(m_hWnd, TRUE);

    //
    // Get the domain forwarders info from hidden Category node
    //
    CDNSDomainForwardersNode* pDomainForwardersNode = pServerNode->GetDomainForwardersNode();
    if (pDomainForwardersNode == NULL)
    {
      ASSERT(FALSE);

      //
      // Disable all controls
      //
      SetDlgItemText(IDC_STATIC_MESSAGE, NULL);
      EnableWindow(FALSE);
      EnableDialogControls(m_hWnd, FALSE);

      CStatic* pStatic = (CStatic*)GetDlgItem(IDC_STATIC_ADD_FORWARDERS);
      if (pStatic != NULL)
      {
        pStatic->ShowWindow(FALSE);
      }

      pStatic = (CStatic*)GetDlgItem(IDC_STATIC_MESSAGE);
      if (pStatic != NULL)
      {
        if (bServerHasRoot)
        {
          pStatic->ShowWindow(TRUE);
        }
        else
        {
          pStatic->ShowWindow(FALSE);
        }
      }
		  return TRUE;
    }

    CStatic* pStatic = (CStatic*)GetDlgItem(IDC_STATIC_MESSAGE);
    if (pStatic != NULL)
    {
      pStatic->EnableWindow(FALSE);
      pStatic->ShowWindow(FALSE);
    }

    pStatic = (CStatic*)GetDlgItem(IDC_STATIC_ADD_FORWARDERS);
    if (pStatic != NULL)
    {
      pStatic->EnableWindow(TRUE);
      pStatic->ShowWindow(TRUE);
    }

    if (!m_bPostApply)
    {
      LRESULT lSelection = SendDlgItemMessage(IDC_DOMAIN_LIST, LB_GETCURSEL, 0, 0);
      if (lSelection == LB_ERR)
      {
         //
         // Select the first item in the domain list
         //
         SendDlgItemMessage(IDC_DOMAIN_LIST, LB_SETCURSEL, 0, 0);
         OnDomainSelChange();
      }
    }
    m_forwarderAddressesEditor.EnableUI(TRUE);
  }

  if (pServerNode->GetBuildNumber() < DNS_SRV_BUILD_NUMBER_WHISTLER ||
      (pServerNode->GetMajorVersion() <= DNS_SRV_MAJOR_VERSION_NT_5 &&
       pServerNode->GetMinorVersion() < DNS_SRV_MINOR_VERSION_WHISTLER))
  {
    //
    // Domain forwarding not available on pre-Whistler servers
    //
    if (!bServerHasRoot && pServerNode->DoesRecursion())
    {
      CString szDownlevelServer;
      VERIFY(szDownlevelServer.LoadString(IDS_DISABLED_FWDS_DOWNLEVEL));
      SetDlgItemText(IDC_STATIC_CAPTION, szDownlevelServer);
    }

    GetDlgItem(IDC_DOMAIN_ADD_BUTTON)->EnableWindow(FALSE);
    GetDlgItem(IDC_DOMAIN_REMOVE_BUTTON)->EnableWindow(FALSE);
  }

  OnDomainSelChange();
  SetDirty(bWasDirty);
  return TRUE;
}

BOOL CDNSServer_DomainForwardersPropertyPage::OnKillActive()
{
  OnDomainSelChange();
  return TRUE;
}

BOOL CDNSServer_DomainForwardersPropertyPage::OnApply()
{
  USES_CONVERSION;

	CDNSServerPropertyPageHolder* pHolder = 
		(CDNSServerPropertyPageHolder*)GetHolder();
  CComponentDataObject* pComponentData = pHolder->GetComponentData();
	CDNSServerNode* pServerNode = pHolder->GetServerNode();

	if (!IsDirty())
  {
		return TRUE;
  }

  //
  // Retrieve the current UI info
  //
  CListBox* pDomainList = (CListBox*)GetDlgItem(IDC_DOMAIN_LIST);
  if (pDomainList != NULL)
  {
    int iSel = pDomainList->GetCurSel();
    if (iSel != LB_ERR)
    {
      LRESULT lRes = pDomainList->GetItemData(iSel);
      if (lRes != LB_ERR)
      {
        //
        // Retrieve the edit info from the list box item
        //
        CDomainForwardersEditInfo* pInfo = reinterpret_cast<CDomainForwardersEditInfo*>(lRes);
        if (pInfo != NULL)
        {
          //
          // Store the previous selection's data before changing the UI.
          // This may be NULL during OnInitDialog so check before trying
          // to store the info.
          //
          if (m_pCurrentInfo != NULL)
          {
            BOOL bSlave = GetSlaveCheck()->GetCheck();
            DWORD dwTimeout = m_forwardTimeoutEdit.GetVal();

	          DWORD cAddrCount = m_forwarderAddressesEditor.GetCount();
            DWORD* pArr = (cAddrCount > 0) ? (DWORD*) malloc(sizeof(DWORD)*cAddrCount) : NULL;
	          if (cAddrCount > 0 && pArr != NULL)
	          {
		          int nFilled = 0;
		          m_forwarderAddressesEditor.GetAddresses(pArr, cAddrCount, &nFilled);
		          ASSERT(nFilled == (int)cAddrCount);
	          }
            m_pCurrentInfo->Update(bSlave, dwTimeout, cAddrCount, pArr);
          }
        }
      }
    }
  }

  POSITION pos = m_EditList.GetHeadPosition();
  while (pos != NULL)
  {
    CDomainForwardersEditInfo* pInfo = m_EditList.GetNext(pos);
    if (pInfo != NULL)
    {
      DNS_STATUS err = 0;

      CString szName;
      pInfo->GetDomainName(szName);
      DWORD cAddrCount = 0;
      PIP_ADDRESS pipAddrs = pInfo->GetIPList(&cAddrCount);
      DWORD dwTimeout = pInfo->GetTimeout();
      BOOL bSlave = pInfo->IsSlave();

      switch (pInfo->GetAction())
      {
        case CDomainForwardersEditInfo::add:
          {
            //
            // Add the new domain forwarder as a zone
            //
            ASSERT(!pInfo->IsAllOthers());
            if (!pInfo->IsAllOthers())
            {
              // Every domain that is entered must contain at least
              // one IP address of a server to forward to

              if (cAddrCount < 1)
              {
                CString err; 
                err.Format(IDS_ERRMSG_SERVER_FORWARDER_NO_SERVER, szName);

                DNSMessageBox(err, MB_OK);
                return FALSE;
              }
              else
              {
                err = pServerNode->CreateForwarderZone(szName, 
	  	                                                 pipAddrs,
                                                       cAddrCount,
                                                       dwTimeout,
                                                       bSlave,
			                                              pComponentData);
              }

            }
          }
          break;
        case CDomainForwardersEditInfo::remove:
          {
            //
            // Delete the zone representing the domain forwarder
            //
            ASSERT(!pInfo->IsAllOthers());
            if (!pInfo->IsAllOthers())
            {
              BOOL bDeleteFromDS = FALSE;
              if (pInfo->GetZoneNode())
              {
                 if (pInfo->GetZoneNode()->GetZoneType() == DNS_ZONE_TYPE_FORWARDER &&
                     pInfo->IsADIntegrated())
                 {
                   if (pServerNode->GetBootMethod() == BOOT_METHOD_DIRECTORY)
                   {
                     // ask confirmation on delete from DS
                     int nRetVal = DNSMessageBox(IDS_MSG_FORWARDER_DELETE_FROM_DS_BOOT3, 
                                                 MB_YESNO | MB_DEFBUTTON2);
                     if (nRetVal == IDNO)
                     {
                       break;
                     }

                     bDeleteFromDS = TRUE;
                   }
                   else
                   {
                     // ask confirmation on delete from DS
                     int nRetVal = DNSMessageBox(IDS_MSG_FORWARDER_DELETE_FROM_DS, 
                                                 MB_YESNOCANCEL | MB_DEFBUTTON3);
                     if (nRetVal == IDCANCEL)
                     {
                       break;
                     }

                     bDeleteFromDS = (nRetVal == IDYES);
                   }
                 }
                 err = pInfo->GetZoneNode()->Delete(bDeleteFromDS);
              }
              else
              {
                // We don't have to worry about AD integrated forwarders
                // here because we cannot create them in the UI.  Any
                // forwarders that are AD integrated will have the zone
                // node pointer set

                err = ::DnssrvDeleteZone(pServerNode->GetRPCName(), 
		              				           W_TO_UTF8(szName));
              }
            }
          }
          break;
        case CDomainForwardersEditInfo::update:
          {
            //
            // Update the zone representing the domain forwarder
            //
            if (pInfo->IsAllOthers())
            {
              //
	      // write the default forwarder to the server
              //
	      err = pServerNode->ResetForwarders(cAddrCount, pipAddrs, dwTimeout, bSlave);

              // NTRAID#NTBUG9-726992-2002/10/22-JeffJon
              // The ResetForwarders call will update the ServerInfo which means that the existing
              // pInfo is no longer valid so recreate it from the server info.

	      m_EditList.Remove(pInfo);
              if (m_pCurrentInfo == pInfo)
              {
                m_pCurrentInfo = NULL;
              }

              delete pInfo;
              pInfo = 0;

              m_pCurrentInfo = CreateAllOthersDomainInfo(pServerNode);

              // Now update the domain list data with the new AllOthersDomain
              LRESULT currentSelection = pDomainList->GetCurSel();
              pDomainList->SetItemData(currentSelection, (LPARAM)m_pCurrentInfo);
            }
            else
            {
		err = ::DnssrvResetZoneMastersEx(pServerNode->GetRPCName(), // server name
                                                 W_TO_UTF8(szName),         // forwarder as zone name
                                                 cAddrCount, 
                                                 pipAddrs,
                                                 0);                        // global masters only

                DNS_STATUS err2 = ::DnssrvResetDwordProperty(pServerNode->GetRPCName(),
                                                             W_TO_UTF8(szName),
                                                             DNS_REGKEY_ZONE_FWD_TIMEOUT,
                                                             dwTimeout);

                DNS_STATUS err3 = ::DnssrvResetDwordProperty(pServerNode->GetRPCName(),
                                                             W_TO_UTF8(szName),
                                                             DNS_REGKEY_ZONE_FWD_SLAVE,
                                                             bSlave);
                if (!err && err2)
                {
                   err = err2;
                }

                if (!err && err3)
                {
                   err = err3;
                }
            }
          }
          break;
        case CDomainForwardersEditInfo::nochange:
        default:
          break;
      }

      if (err != 0)
      {
        if (err == DNS_ERROR_INVALID_ZONE_TYPE)
        {
          CString szFwdFailed;
          CString szFwdFailedFormat;
          VERIFY(szFwdFailedFormat.LoadString(IDS_MSG_FAIL_CREATE_DOMAIN_FORWARDER));
          szFwdFailed.Format(szFwdFailedFormat, szName);
          DNSMessageBox(szFwdFailed);
        }
        else
        {
		      DNSErrorDialog(err, IDS_MSG_SERVER_FORWARDER_UPDATE_FAILED);
        }
		    return FALSE;
      }

      if (pInfo)
      {
        pInfo->SetAction(CDomainForwardersEditInfo::nochange);
      }
    } 
  } // while

  m_bPostApply = TRUE;
  SetDirty(FALSE);
	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// CDNSServer_AdvancedPropertyPage

BEGIN_MESSAGE_MAP(CDNSServer_AdvancedPropertyPage, CPropertyPageBase)
	ON_CLBN_CHKCHANGE(IDC_ADVANCED_OPTIONS_LIST, OnAdvancedOptionsListChange)
	ON_CBN_SELCHANGE(IDC_NAME_CHECKING_COMBO, OnComboSelChange)
	ON_CBN_SELCHANGE(IDC_BOOT_METHOD_COMBO, OnComboSelChange)
	ON_BN_CLICKED(IDC_RESET_BUTTON, OnResetButton)
  ON_BN_CLICKED(IDC_CHECK_ENABLE_SCAVENGING, OnEnableScavenging)
END_MESSAGE_MAP()

#define ADVANCED_OPTIONS_LISTBOX_ENTRIES (SERVER_REGKEY_ARR_SIZE) 

// boot method constants
#define BOOT_METHOD_COMBO_ITEM_COUNT		    3 // # of options in the combo box

#define BOOT_METHOD_COMBO_FROM_REGISTRY		  0
#define BOOT_METHOD_COMBO_FROM_FILE			    1
#define BOOT_METHOD_COMBO_FROM_DIRECTORY		2



#define CHECK_NAMES_COMBO_ITEM_COUNT		4

CDNSServer_AdvancedPropertyPage::CDNSServer_AdvancedPropertyPage() 
				: CPropertyPageBase(IDD_SERVER_ADVANCED_PAGE),
				m_advancedOptionsListBox(ADVANCED_OPTIONS_LISTBOX_ENTRIES)
{
}


void CDNSServer_AdvancedPropertyPage::SetAdvancedOptionsListbox(BOOL* bRegKeyOptionsArr)
{
	m_advancedOptionsListBox.SetArrValue((DWORD*)bRegKeyOptionsArr, 
							ADVANCED_OPTIONS_LISTBOX_ENTRIES);
}

void CDNSServer_AdvancedPropertyPage::GetAdvancedOptionsListbox(BOOL* bRegKeyOptionsArr)
{
	m_advancedOptionsListBox.GetArrValue((DWORD*)bRegKeyOptionsArr, 
							ADVANCED_OPTIONS_LISTBOX_ENTRIES);
}

void CDNSServer_AdvancedPropertyPage::SetBootMethodComboVal(UCHAR fBootMethod)
{
  int nIndex = BOOT_METHOD_COMBO_FROM_DIRECTORY; // sensible default
  switch (fBootMethod)
  {
  case BOOT_METHOD_FILE:
    nIndex = BOOT_METHOD_COMBO_FROM_FILE;
    break;
  case BOOT_METHOD_REGISTRY:
    nIndex = BOOT_METHOD_COMBO_FROM_REGISTRY;
    break;
  case BOOT_METHOD_DIRECTORY:
    nIndex = BOOT_METHOD_COMBO_FROM_DIRECTORY;
    break;
  default:
    nIndex = BOOT_METHOD_COMBO_FROM_DIRECTORY;
    break;
  };
	VERIFY(CB_ERR != GetBootMethodCombo()->SetCurSel(nIndex));
}

UCHAR CDNSServer_AdvancedPropertyPage::GetBootMethodComboVal()
{
	int nIndex = BOOT_METHOD_COMBO_FROM_DIRECTORY;
  nIndex = GetBootMethodCombo()->GetCurSel();
	ASSERT(nIndex != CB_ERR);

  UCHAR fBootMethod = BOOT_METHOD_DIRECTORY; // sensible default
  switch (nIndex)
  {
  case BOOT_METHOD_COMBO_FROM_FILE:
    fBootMethod = BOOT_METHOD_FILE;
    break;
  case BOOT_METHOD_COMBO_FROM_REGISTRY:
    fBootMethod = BOOT_METHOD_REGISTRY;
    break;
  case BOOT_METHOD_COMBO_FROM_DIRECTORY:
    fBootMethod = BOOT_METHOD_DIRECTORY;
    break;
  default:
    ASSERT(FALSE);
  };

  return fBootMethod;
}

void CDNSServer_AdvancedPropertyPage::SetNameCheckingComboVal(DWORD dwNameChecking)
{
	int nIndex = DNS_DEFAULT_NAME_CHECK_FLAG;
	switch (dwNameChecking)
	{
	case DNS_ALLOW_RFC_NAMES_ONLY:
		nIndex = 0;
		break;
	case DNS_ALLOW_NONRFC_NAMES:
		nIndex = 1;
		break;
	case DNS_ALLOW_MULTIBYTE_NAMES:
		nIndex = 2;
		break;
	case DNS_ALLOW_ALL_NAMES:
    nIndex = 3;
    break;
	default:
		ASSERT(FALSE);
	}
	VERIFY(CB_ERR != GetNameCheckingCombo()->SetCurSel(nIndex));
}

DWORD CDNSServer_AdvancedPropertyPage::GetNameCheckingComboVal()
{
	int nIndex = 0;
  nIndex = GetNameCheckingCombo()->GetCurSel();
	ASSERT(nIndex != CB_ERR);
	DWORD dw = 0;
	switch (nIndex)
	{
	case 0:
		dw = DNS_ALLOW_RFC_NAMES_ONLY;
		break;
	case 1:
		dw = DNS_ALLOW_NONRFC_NAMES;
		break;
	case 2:
		dw = DNS_ALLOW_MULTIBYTE_NAMES;
		break;
  case 3:
    dw = DNS_ALLOW_ALL_NAMES;
    break;
	default:
		ASSERT(FALSE);
	}
	return dw;
}

void CDNSServer_AdvancedPropertyPage::OnEnableScavenging()
{
  GetDlgItem(IDC_STATIC_SCAVENGE)->EnableWindow(((CButton*)GetDlgItem(IDC_CHECK_ENABLE_SCAVENGING))->GetCheck());
  GetDlgItem(IDC_REFR_INT_EDIT)->EnableWindow(((CButton*)GetDlgItem(IDC_CHECK_ENABLE_SCAVENGING))->GetCheck());
  GetDlgItem(IDC_REFR_INT_COMBO)->EnableWindow(((CButton*)GetDlgItem(IDC_CHECK_ENABLE_SCAVENGING))->GetCheck());
  if (m_scavengingIntervalEditGroup.GetVal() == 0)
  {
    m_scavengingIntervalEditGroup.SetVal(DNS_DEFAULT_SCAVENGING_INTERVAL_ON);
  }

  SetDirty(TRUE);
}

void CDNSServer_AdvancedPropertyPage::SetUIData()
{
	CDNSServerPropertyPageHolder* pHolder = 
		(CDNSServerPropertyPageHolder*)GetHolder();
	CDNSServerNode* pServerNode = pHolder->GetServerNode();

	// set server version
	CEdit* pVersionEdit = (CEdit*)GetDlgItem(IDC_SERVER_VERSION_EDIT);
	WCHAR szBuffer[128];
	WORD wBuildNumber = pServerNode->GetBuildNumber();
	if (wBuildNumber == 0)
		wsprintf(szBuffer, _T("%d.%d"), pServerNode->GetMajorVersion(), 
							  pServerNode->GetMinorVersion());
	else
		wsprintf(szBuffer, _T("%d.%d %d (0x%x)"), pServerNode->GetMajorVersion(), 
							  pServerNode->GetMinorVersion(),
							  wBuildNumber, wBuildNumber);
	pVersionEdit->SetWindowText(szBuffer);

	// NOTICE: Assume ordering in the list is the same
	// as in the array. "Name check Flag" and "Boot method" are the last ones
	// in the array and are ignored (separate controls). 
	BOOL bRegKeyOptionsArr[SERVER_REGKEY_ARR_SIZE];
  
	pServerNode->GetAdvancedOptions(bRegKeyOptionsArr);
	SetAdvancedOptionsListbox(bRegKeyOptionsArr);

	SetBootMethodComboVal(pServerNode->GetBootMethod());
	SetNameCheckingComboVal(pServerNode->GetNameCheckFlag());
  ((CButton*)GetDlgItem(IDC_CHECK_ENABLE_SCAVENGING))->SetCheck(pServerNode->GetScavengingState());
  GetDlgItem(IDC_STATIC_SCAVENGE)->EnableWindow(pServerNode->GetScavengingState());
  GetDlgItem(IDC_REFR_INT_EDIT)->EnableWindow(pServerNode->GetScavengingState());
  GetDlgItem(IDC_REFR_INT_COMBO)->EnableWindow(pServerNode->GetScavengingState());
  m_scavengingIntervalEditGroup.SetVal(pServerNode->GetScavengingInterval());
}


BOOL CDNSServer_AdvancedPropertyPage::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();
	CDNSServerPropertyPageHolder* pHolder = 
		(CDNSServerPropertyPageHolder*)GetHolder();
	CDNSServerNode* pServerNode = pHolder->GetServerNode();

	VERIFY(m_advancedOptionsListBox.Initialize(IDC_ADVANCED_OPTIONS_LIST, 
												IDS_SERVER_ADV_PP_OPTIONS, 
												this));
	VERIFY(LoadStringsToComboBox(_Module.GetModuleInstance(),
									GetNameCheckingCombo(),
									IDS_SERVER_NAME_CHECKING_OPTIONS,
									256,
									CHECK_NAMES_COMBO_ITEM_COUNT));

   VERIFY(LoadStringsToComboBox(_Module.GetModuleInstance(),
									GetBootMethodCombo(),
									IDS_SERVER_BOOT_METHOD_OPTIONS,
									256,
									BOOT_METHOD_COMBO_ITEM_COUNT));
	if (!pServerNode->HasServerInfo())
	{
		EnableWindow(FALSE);
		return TRUE;
	}

  m_scavengingIntervalEditGroup.m_pPage2 = this;

	VERIFY(m_scavengingIntervalEditGroup.Initialize(this, 
				IDC_REFR_INT_EDIT, IDC_REFR_INT_COMBO,IDS_TIME_AGING_INTERVAL_UNITS));

	SetUIData();
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


BOOL _HandleAvancedOptionsErrors(DNS_STATUS* dwRegKeyOptionsErrorArr)
{
  BOOL bAllFine = TRUE;
  
  // check for errors in the array
  for (UINT iKey=0; iKey < SERVER_REGKEY_ARR_SIZE; iKey++)
  {
    if (dwRegKeyOptionsErrorArr[iKey] != 0)
    {
      bAllFine = FALSE;
      break;
    }
  }
  if (bAllFine)
    return TRUE; // no error condition

  // load the string array to get the option key name
	CString szBuf;
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  VERIFY(szBuf.LoadString(IDS_SERVER_ADV_PP_OPTIONS));
  LPWSTR* lpszArr = (LPWSTR*)malloc(sizeof(LPWSTR*)*SERVER_REGKEY_ARR_SIZE);
  if (!lpszArr)
  {
    return FALSE;
  }

	UINT nArrEntries;
	ParseNewLineSeparatedString(szBuf.GetBuffer(1),lpszArr, &nArrEntries);
	szBuf.ReleaseBuffer();
  ASSERT(nArrEntries == SERVER_REGKEY_ARR_SIZE);

  CString szFmt;
  szFmt.LoadString(IDS_MSG_SERVER_FAIL_ADV_PROP_FMT);
  CString szMsg;
  for (iKey=0; iKey < SERVER_REGKEY_ARR_SIZE; iKey++)
  {
    if (dwRegKeyOptionsErrorArr[iKey] != 0)
    {
      szMsg.Format((LPCWSTR)szFmt, lpszArr[iKey]); 
      DNSErrorDialog(dwRegKeyOptionsErrorArr[iKey], szMsg);
    }
  }

  if (lpszArr)
  {
    free(lpszArr);
    lpszArr = 0;
  }
  return FALSE; // we had an error condition
}

BOOL CDNSServer_AdvancedPropertyPage::OnApply()
{
	if (!IsDirty())
		return TRUE;

	CDNSServerPropertyPageHolder* pHolder = 
		(CDNSServerPropertyPageHolder*)GetHolder();
	CDNSServerNode* pServerNode = pHolder->GetServerNode();

  // get data from the UI
	BOOL bRegKeyOptionsArr[SERVER_REGKEY_ARR_SIZE];
  ZeroMemory(bRegKeyOptionsArr, sizeof(bRegKeyOptionsArr));

	GetAdvancedOptionsListbox(bRegKeyOptionsArr);
  UCHAR fBootMethod = GetBootMethodComboVal();
	DWORD dwNameCheckFlag = GetNameCheckingComboVal();
  BOOL bScavengingState = ((CButton*)GetDlgItem(IDC_CHECK_ENABLE_SCAVENGING))->GetCheck();
  DWORD dwScavengingInterval = m_scavengingIntervalEditGroup.GetVal();

  // write data to the server
  DNS_STATUS dwRegKeyOptionsErrorArr[SERVER_REGKEY_ARR_SIZE];
  ZeroMemory(dwRegKeyOptionsErrorArr, sizeof(dwRegKeyOptionsErrorArr));

	DNS_STATUS dwErr = pServerNode->ResetAdvancedOptions(bRegKeyOptionsArr, dwRegKeyOptionsErrorArr);
	if (dwErr != 0)
	{
		DNSErrorDialog(dwErr, IDS_MSG_SERVER_NO_ADVANCED_OPTIONS);
		return FALSE;
	}
  if (!_HandleAvancedOptionsErrors(dwRegKeyOptionsErrorArr))
    return FALSE;

  dwErr = pServerNode->ResetBootMethod(fBootMethod);
	if (dwErr != 0)
	{
		DNSErrorDialog(dwErr, IDS_MSG_SERVER_NO_BOOT_METHOD);
		return FALSE;
	}

	dwErr = pServerNode->ResetNameCheckFlag(dwNameCheckFlag);
	if (dwErr != 0)
	{
		DNSErrorDialog(dwErr, IDS_MSG_SERVER_NO_NAME_CHECKING);
		return FALSE;
	}

/*
  dwErr = pServerNode->ResetScavengingState(bScavengingState);
  if (dwErr != 0)
  {
    DNSErrorDialog(dwErr, IDS_MSG_SERVER_SCAVENGING_STATE);
    return FALSE;
  }
*/
  if (bScavengingState)
  {
    dwErr = pServerNode->ResetScavengingInterval(dwScavengingInterval);
  }
  else
  {
    dwErr = pServerNode->ResetScavengingInterval(0);
  }

  if (dwErr != 0)
  {
    DNSErrorDialog(dwErr, IDS_MSG_SERVER_SCAVENGING_INTERVAL);
    return FALSE;
  }

	// all is fine
	SetDirty(FALSE);
	return TRUE; 
}


void CDNSServer_AdvancedPropertyPage::OnResetButton()
{
	BOOL bRegKeyOptArrDef[SERVER_REGKEY_ARR_SIZE];

	bRegKeyOptArrDef[SERVER_REGKEY_ARR_INDEX_NO_RECURSION] = DNS_DEFAULT_NO_RECURSION;
	bRegKeyOptArrDef[SERVER_REGKEY_ARR_INDEX_BIND_SECONDARIES] = DNS_DEFAULT_BIND_SECONDARIES;
	bRegKeyOptArrDef[SERVER_REGKEY_ARR_INDEX_STRICT_FILE_PARSING] = DNS_DEFAULT_STRICT_FILE_PARSING;
	bRegKeyOptArrDef[SERVER_REGKEY_ARR_INDEX_ROUND_ROBIN] = DNS_DEFAULT_ROUND_ROBIN;
	bRegKeyOptArrDef[SERVER_REGKEY_ARR_LOCAL_NET_PRIORITY] = DNS_DEFAULT_LOCAL_NET_PRIORITY;
  bRegKeyOptArrDef[SERVER_REGKEY_ARR_CACHE_POLLUTION] = DNS_DEFAULT_SECURE_RESPONSES;

  UCHAR fBootMethod = BOOT_METHOD_DIRECTORY;

	SetAdvancedOptionsListbox(bRegKeyOptArrDef);
	SetBootMethodComboVal(fBootMethod);
	SetNameCheckingComboVal(DNS_DEFAULT_NAME_CHECK_FLAG);

  BOOL bDefaultScavengingState = DNS_DEFAULT_SCAVENGING_INTERVAL > 0;
  ((CButton*)GetDlgItem(IDC_CHECK_ENABLE_SCAVENGING))->SetCheck(bDefaultScavengingState);
  GetDlgItem(IDC_STATIC_SCAVENGE)->EnableWindow(bDefaultScavengingState);
  GetDlgItem(IDC_REFR_INT_EDIT)->EnableWindow(bDefaultScavengingState);
  GetDlgItem(IDC_REFR_INT_COMBO)->EnableWindow(bDefaultScavengingState);
  m_scavengingIntervalEditGroup.SetVal(DNS_DEFAULT_SCAVENGING_INTERVAL);

	SetDirty(TRUE);
}

///////////////////////////////////////////////////////////////////////////////
// CIPFilterDialog

class CIPFilterDialog : public CHelpDialog
{
public:
  CIPFilterDialog(PIP_ARRAY pIpArray, CComponentDataObject* pComponentData) 
    : CHelpDialog(IDD_IP_FILTER_DIALOG, pComponentData),
      m_pIPFilterList(pIpArray),
      m_pComponentData(pComponentData)
  {}

  ~CIPFilterDialog() {}

  virtual BOOL OnInitDialog();
  virtual void OnOK();

  PIP_ARRAY GetIPFilter() { return m_pIPFilterList; }
  virtual void SetDirty(BOOL bDirty = TRUE);

private:

	class CFilterAddressesIPEditor : public CIPEditor
	{
	public:
		CFilterAddressesIPEditor() : CIPEditor(TRUE) {}
		virtual void OnChangeData();
	};
	CFilterAddressesIPEditor m_filterAddressesEditor;
  PIP_ARRAY m_pIPFilterList;
  CComponentDataObject* m_pComponentData;
  DECLARE_MESSAGE_MAP()
};

void CIPFilterDialog::CFilterAddressesIPEditor::OnChangeData()
{
  //
  // Set the dialog dirty
  //
	CIPFilterDialog* pDialog = (CIPFilterDialog*)GetParentWnd();
	pDialog->SetDirty(TRUE);
}

BEGIN_MESSAGE_MAP(CIPFilterDialog, CHelpDialog)
END_MESSAGE_MAP()

BOOL CIPFilterDialog::OnInitDialog()
{
  CHelpDialog::OnInitDialog();

  //
	// initialize controls
  //
	VERIFY(m_filterAddressesEditor.Initialize(this, 
                                            this, 
                                            IDC_BUTTON_UP, 
                                            IDC_BUTTON_DOWN,
								                            IDC_BUTTON_ADD, 
                                            IDC_BUTTON_REMOVE, 
								                            IDC_IPEDIT, 
                                            IDC_LIST));

  if (m_pIPFilterList != NULL)
  {
    m_filterAddressesEditor.AddAddresses(m_pIPFilterList->AddrArray, m_pIPFilterList->AddrCount);
  }

  SetDirty(FALSE);
  return TRUE;
}

void CIPFilterDialog::SetDirty(BOOL bDirty)
{
  GetDlgItem(IDOK)->EnableWindow(bDirty);

  if (!bDirty)
  {
    // Set the default button to be the Cancel button
    SendMessage(DM_SETDEFID, (WPARAM)IDCANCEL, 0);
    SendDlgItemMessage(IDOK, BM_SETSTYLE, BS_PUSHBUTTON, MAKELPARAM(TRUE, 0));
    SendDlgItemMessage(IDCANCEL, BM_SETSTYLE, BS_DEFPUSHBUTTON, MAKELPARAM(TRUE, 0));
  }
}

void CIPFilterDialog::OnOK()
{
	ULONG cAddress = m_filterAddressesEditor.GetCount();
	PIP_ARRAY aipAddresses = (cAddress > 0) ? (PIP_ARRAY) malloc(sizeof(DWORD)*(cAddress + 1)) : NULL;
  if (aipAddresses != NULL && cAddress > 0)
	{
		int nFilled = 0;
    aipAddresses->AddrCount = cAddress;
		m_filterAddressesEditor.GetAddresses(aipAddresses->AddrArray, cAddress, &nFilled);
		ASSERT(nFilled == (int)cAddress);
	}
  m_pIPFilterList = aipAddresses;
  CHelpDialog::OnOK();
}

///////////////////////////////////////////////////////////////////////////////
// CDNSServer_DebugLoggingPropertyPage

BEGIN_MESSAGE_MAP(CDNSServer_DebugLoggingPropertyPage, CPropertyPageBase)
  ON_BN_CLICKED(IDC_DEBUG_LOGGING_CHECK, OnLoggingCheck)
  ON_BN_CLICKED(IDC_SEND_CHECK, OnSendCheck)
  ON_BN_CLICKED(IDC_RECEIVE_CHECK, OnReceiveCheck)
  ON_BN_CLICKED(IDC_QUERIES_CHECK, OnQueriesCheck)
  ON_BN_CLICKED(IDC_NOTIFIES_CHECK, OnNotifiesCheck)
  ON_BN_CLICKED(IDC_UPDATES_CHECK, OnUpdatesCheck)
  ON_BN_CLICKED(IDC_REQUEST_CHECK, OnRequestCheck)
  ON_BN_CLICKED(IDC_RESPONSE_CHECK, OnResponseCheck)
  ON_BN_CLICKED(IDC_UDP_CHECK, OnUDPCheck)
  ON_BN_CLICKED(IDC_TCP_CHECK, OnTCPCheck)
  ON_BN_CLICKED(IDC_DETAIL_CHECK, OnDetailCheck)
  ON_BN_CLICKED(IDC_FILTERING_CHECK, OnFilterCheck)
  ON_BN_CLICKED(IDC_FILTER_BUTTON, OnFilterButton)
  ON_EN_CHANGE(IDC_LOGFILE_EDIT, OnLogFileChange)
  ON_EN_CHANGE(IDC_MAX_SIZE_EDIT, OnMaxSizeChange)
END_MESSAGE_MAP()

CDNSServer_DebugLoggingPropertyPage::CDNSServer_DebugLoggingPropertyPage() 
				: CPropertyPageBase(IDD_SERVER_DEBUG_LOGGING_PAGE),
          m_dwLogLevel(0),
          m_pIPFilterList(NULL),
          m_dwMaxSize(0),
          m_bOnSetUIData(FALSE),
          m_bMaxSizeDirty(FALSE),
          m_bLogFileDirty(FALSE),
          m_bFilterDirty(FALSE),
          m_bOwnIPListMemory(FALSE),
          m_bNotWhistler(FALSE),
          m_bOptionsDirty(FALSE)
{
  m_szLogFileName = L"";
}

CDNSServer_DebugLoggingPropertyPage::~CDNSServer_DebugLoggingPropertyPage() 
{
  if (m_bOwnIPListMemory && m_pIPFilterList != NULL)
  {
    free(m_pIPFilterList);
    m_pIPFilterList = NULL;
  }
}

typedef struct _LoggingOption
{
  DWORD dwOption;
  UINT  nControlID;
} LOGGING_OPTION, *PLOGGING_OPTION;


//
// NOTE: if the resource IDs of the checkboxes are changed,
//       then the IDs in the table below need to be changed too.
//
LOGGING_OPTION g_loggingOptions[] = 
{
  { DNS_LOG_LEVEL_QUERY,        IDC_QUERIES_CHECK   },
  { DNS_LOG_LEVEL_NOTIFY,       IDC_NOTIFIES_CHECK  },
  { DNS_LOG_LEVEL_UPDATE,       IDC_UPDATES_CHECK   },
  { DNS_LOG_LEVEL_QUESTIONS,    IDC_REQUEST_CHECK   },
  { DNS_LOG_LEVEL_ANSWERS,      IDC_RESPONSE_CHECK  },
  { DNS_LOG_LEVEL_SEND,         IDC_SEND_CHECK      },
  { DNS_LOG_LEVEL_RECV,         IDC_RECEIVE_CHECK   },
  { DNS_LOG_LEVEL_UDP,          IDC_UDP_CHECK       },
  { DNS_LOG_LEVEL_TCP,          IDC_TCP_CHECK       },
  { DNS_LOG_LEVEL_FULL_PACKETS, IDC_DETAIL_CHECK    }
};

#define DEFAULT_LOGGING_OPTIONS (DNS_LOG_LEVEL_SEND   |     \
                                 DNS_LOG_LEVEL_RECV   |     \
                                 DNS_LOG_LEVEL_UDP    |     \
                                 DNS_LOG_LEVEL_TCP    |     \
                                 DNS_LOG_LEVEL_QUERY  |     \
                                 DNS_LOG_LEVEL_UPDATE |     \
                                 DNS_LOG_LEVEL_QUESTIONS |  \
                                 DNS_LOG_LEVEL_ANSWERS )

void CDNSServer_DebugLoggingPropertyPage::OnLoggingCheck()
{
  BOOL bLogging = SendDlgItemMessage(IDC_DEBUG_LOGGING_CHECK, BM_GETCHECK, 0, 0) == BST_CHECKED; 

  EnableLogging(bLogging);

  if (bLogging && 
      m_dwLogLevel == 0 &&
      !AreOptionsDirty())
  {
     ResetToDefaults();
  }

  SetDirty(TRUE);
}

void CDNSServer_DebugLoggingPropertyPage::OnSendCheck()
{
  BOOL bOutgoing = SendDlgItemMessage(IDC_SEND_CHECK, BM_GETCHECK, 0, 0) == BST_CHECKED;
  BOOL bIncoming = SendDlgItemMessage(IDC_RECEIVE_CHECK, BM_GETCHECK, 0, 0) == BST_CHECKED;

  if (!bOutgoing && !bIncoming)
  {
     SendDlgItemMessage(IDC_RECEIVE_CHECK, BM_SETCHECK, BST_CHECKED, 0);
     GetDlgItem(IDC_RECEIVE_CHECK)->SetFocus();
  }
  SetOptionsDirty();
  SetDirty(TRUE);
}

void CDNSServer_DebugLoggingPropertyPage::OnReceiveCheck()
{
  BOOL bOutgoing = SendDlgItemMessage(IDC_SEND_CHECK, BM_GETCHECK, 0, 0) == BST_CHECKED;
  BOOL bIncoming = SendDlgItemMessage(IDC_RECEIVE_CHECK, BM_GETCHECK, 0, 0) == BST_CHECKED;

  if (!bOutgoing && !bIncoming)
  {
     SendDlgItemMessage(IDC_SEND_CHECK, BM_SETCHECK, BST_CHECKED, 0);
     GetDlgItem(IDC_SEND_CHECK)->SetFocus();
  }
  SetOptionsDirty();
  SetDirty(TRUE);
}

void CDNSServer_DebugLoggingPropertyPage::OnQueriesCheck()
{
  BOOL bQueries = SendDlgItemMessage(IDC_QUERIES_CHECK, BM_GETCHECK, 0, 0) == BST_CHECKED;
  BOOL bNotifies = SendDlgItemMessage(IDC_NOTIFIES_CHECK, BM_GETCHECK, 0, 0) == BST_CHECKED;
  BOOL bUpdates =  SendDlgItemMessage(IDC_UPDATES_CHECK, BM_GETCHECK, 0, 0) == BST_CHECKED;

  if (!bQueries && !bNotifies && !bUpdates)
  {
     SendDlgItemMessage(IDC_UPDATES_CHECK, BM_SETCHECK, BST_CHECKED, 0);
     GetDlgItem(IDC_UPDATES_CHECK)->SetFocus();
  }
  SetOptionsDirty();
  SetDirty(TRUE);
}

void CDNSServer_DebugLoggingPropertyPage::OnUpdatesCheck()
{
  BOOL bQueries = SendDlgItemMessage(IDC_QUERIES_CHECK, BM_GETCHECK, 0, 0) == BST_CHECKED;
  BOOL bNotifies = SendDlgItemMessage(IDC_NOTIFIES_CHECK, BM_GETCHECK, 0, 0) == BST_CHECKED;
  BOOL bUpdates =  SendDlgItemMessage(IDC_UPDATES_CHECK, BM_GETCHECK, 0, 0) == BST_CHECKED;

  if (!bQueries && !bNotifies && !bUpdates)
  {
     SendDlgItemMessage(IDC_NOTIFIES_CHECK, BM_SETCHECK, BST_CHECKED, 0);
     GetDlgItem(IDC_NOTIFIES_CHECK)->SetFocus();
  }
  SetOptionsDirty();
  SetDirty(TRUE);
}

void CDNSServer_DebugLoggingPropertyPage::OnNotifiesCheck()
{
  BOOL bQueries = SendDlgItemMessage(IDC_QUERIES_CHECK, BM_GETCHECK, 0, 0) == BST_CHECKED;
  BOOL bNotifies = SendDlgItemMessage(IDC_NOTIFIES_CHECK, BM_GETCHECK, 0, 0) == BST_CHECKED;
  BOOL bUpdates =  SendDlgItemMessage(IDC_UPDATES_CHECK, BM_GETCHECK, 0, 0) == BST_CHECKED;

  if (!bQueries && !bNotifies && !bUpdates)
  {
     SendDlgItemMessage(IDC_QUERIES_CHECK, BM_SETCHECK, BST_CHECKED, 0);
     GetDlgItem(IDC_QUERIES_CHECK)->SetFocus();
  }
  SetOptionsDirty();
  SetDirty(TRUE);
}


void CDNSServer_DebugLoggingPropertyPage::OnRequestCheck()
{
  BOOL bRequest = SendDlgItemMessage(IDC_REQUEST_CHECK, BM_GETCHECK, 0, 0) == BST_CHECKED;
  BOOL bResponse = SendDlgItemMessage(IDC_RESPONSE_CHECK, BM_GETCHECK, 0, 0) == BST_CHECKED;

  if (!bRequest && !bResponse)
  {
     SendDlgItemMessage(IDC_RESPONSE_CHECK, BM_SETCHECK, BST_CHECKED, 0);
     GetDlgItem(IDC_RESPONSE_CHECK)->SetFocus();
  }
  SetOptionsDirty();
  SetDirty(TRUE);
}

void CDNSServer_DebugLoggingPropertyPage::OnResponseCheck()
{
  BOOL bRequest = SendDlgItemMessage(IDC_REQUEST_CHECK, BM_GETCHECK, 0, 0) == BST_CHECKED;
  BOOL bResponse = SendDlgItemMessage(IDC_RESPONSE_CHECK, BM_GETCHECK, 0, 0) == BST_CHECKED;

  if (!bRequest && !bResponse)
  {
     SendDlgItemMessage(IDC_REQUEST_CHECK, BM_SETCHECK, BST_CHECKED, 0);
     GetDlgItem(IDC_REQUEST_CHECK)->SetFocus();
  }
  SetOptionsDirty();
  SetDirty(TRUE);
}

void CDNSServer_DebugLoggingPropertyPage::OnUDPCheck()
{
  BOOL bUDP = SendDlgItemMessage(IDC_UDP_CHECK, BM_GETCHECK, 0, 0) == BST_CHECKED;
  BOOL bTCP = SendDlgItemMessage(IDC_TCP_CHECK, BM_GETCHECK, 0, 0) == BST_CHECKED;

  if (!bUDP && !bTCP)
  {
     SendDlgItemMessage(IDC_TCP_CHECK, BM_SETCHECK, BST_CHECKED, 0);
     GetDlgItem(IDC_TCP_CHECK)->SetFocus();
  }
  SetOptionsDirty();
  SetDirty(TRUE);
}

void CDNSServer_DebugLoggingPropertyPage::OnTCPCheck()
{
  BOOL bUDP = SendDlgItemMessage(IDC_UDP_CHECK, BM_GETCHECK, 0, 0) == BST_CHECKED;
  BOOL bTCP = SendDlgItemMessage(IDC_TCP_CHECK, BM_GETCHECK, 0, 0) == BST_CHECKED;

  if (!bUDP && !bTCP)
  {
     SendDlgItemMessage(IDC_UDP_CHECK, BM_SETCHECK, BST_CHECKED, 0);
     GetDlgItem(IDC_UDP_CHECK)->SetFocus();
  }
  SetOptionsDirty();
  SetDirty(TRUE);
}

void CDNSServer_DebugLoggingPropertyPage::OnDetailCheck()
{
  SetOptionsDirty();
  SetDirty(TRUE);
}

void CDNSServer_DebugLoggingPropertyPage::SetOptionsDirty(BOOL bDirty)
{
   m_bOptionsDirty = bDirty;
}

BOOL CDNSServer_DebugLoggingPropertyPage::AreOptionsDirty()
{
   return m_bOptionsDirty;
}
void CDNSServer_DebugLoggingPropertyPage::EnableLogging(BOOL bEnable)
{
  //
  // NOTE: the curly brace icons must be enabled before
  //       the other controls so that they get painted first
  //       and the other controls can paint over top of them
  //       If not, the text of the controls gets cut off
  //
  GetDlgItem(IDC_BRACE1_STATIC)->EnableWindow(bEnable);
  GetDlgItem(IDC_SELECT1_STATIC)->EnableWindow(bEnable);
  GetDlgItem(IDC_BRACE2_STATIC)->EnableWindow(bEnable);
  GetDlgItem(IDC_SELECT2_STATIC)->EnableWindow(bEnable);
  GetDlgItem(IDC_BRACE3_STATIC)->EnableWindow(bEnable);
  GetDlgItem(IDC_SELECT3_STATIC)->EnableWindow(bEnable);
  GetDlgItem(IDC_BRACE4_STATIC)->EnableWindow(bEnable);
  GetDlgItem(IDC_SELECT4_STATIC)->EnableWindow(bEnable);

  GetDlgItem(IDC_DIRECTION_STATIC)->EnableWindow(bEnable);
  GetDlgItem(IDC_SEND_CHECK)->EnableWindow(bEnable);
  GetDlgItem(IDC_RECEIVE_CHECK)->EnableWindow(bEnable);

  GetDlgItem(IDC_CONTENTS_STATIC)->EnableWindow(bEnable);
  GetDlgItem(IDC_QUERIES_CHECK)->EnableWindow(bEnable);
  GetDlgItem(IDC_NOTIFIES_CHECK)->EnableWindow(bEnable);
  GetDlgItem(IDC_UPDATES_CHECK)->EnableWindow(bEnable);

  GetDlgItem(IDC_TRANSPORT_STATIC)->EnableWindow(bEnable);
  GetDlgItem(IDC_UDP_CHECK)->EnableWindow(bEnable);
  GetDlgItem(IDC_TCP_CHECK)->EnableWindow(bEnable);

  GetDlgItem(IDC_TYPE_STATIC)->EnableWindow(bEnable);
  GetDlgItem(IDC_REQUEST_CHECK)->EnableWindow(bEnable);
  GetDlgItem(IDC_RESPONSE_CHECK)->EnableWindow(bEnable);

  GetDlgItem(IDC_OPTIONS_STATIC)->EnableWindow(bEnable);
  GetDlgItem(IDC_DETAIL_CHECK)->EnableWindow(bEnable);

  //
  // All controls after this point will be disabled no matter
  // what the input if we are not targetting a Whistler or greater
  // server
  //
  if (m_bNotWhistler)
  {
     bEnable = FALSE;
  }

  GetDlgItem(IDC_FILTERING_CHECK)->EnableWindow(bEnable);
  GetDlgItem(IDC_FILTER_BUTTON)->EnableWindow(
     SendDlgItemMessage(IDC_FILTERING_CHECK, BM_GETCHECK, 0, 0) == BST_CHECKED 
     && bEnable);

  GetDlgItem(IDC_LOG_STATIC)->EnableWindow(bEnable);
  GetDlgItem(IDC_FILENAME_STATIC)->EnableWindow(bEnable);
  GetDlgItem(IDC_LOGFILE_EDIT)->EnableWindow(bEnable);
  GetDlgItem(IDC_MAXSIZE_STATIC)->EnableWindow(bEnable);
  GetDlgItem(IDC_MAX_SIZE_EDIT)->EnableWindow(bEnable);

}

void CDNSServer_DebugLoggingPropertyPage::ResetToDefaults()
{
  SetUIFromOptions(DEFAULT_LOGGING_OPTIONS);
}

void CDNSServer_DebugLoggingPropertyPage::OnFilterCheck()
{
  LRESULT lRes = SendDlgItemMessage(IDC_FILTERING_CHECK, BM_GETCHECK, 0, 0);
  GetDlgItem(IDC_FILTER_BUTTON)->EnableWindow(lRes == BST_CHECKED);

  if (!m_bOnSetUIData)
  {
    m_bFilterDirty = TRUE;
    SetDirty(TRUE);
  }
}

void CDNSServer_DebugLoggingPropertyPage::OnFilterButton()
{
  CThemeContextActivator activator;

  CIPFilterDialog filterDialog(m_pIPFilterList, GetHolder()->GetComponentData());
  if (filterDialog.DoModal() == IDOK)
  {
    if (m_bOwnIPListMemory && m_pIPFilterList != NULL)
    {
      free(m_pIPFilterList);
      m_pIPFilterList = NULL;
    }
    m_pIPFilterList = filterDialog.GetIPFilter();
    m_bOwnIPListMemory = TRUE;
    m_bFilterDirty = TRUE;
    SetDirty(TRUE);
  }
}

void CDNSServer_DebugLoggingPropertyPage::OnLogFileChange()
{
  if (!m_bOnSetUIData)
  {
    m_bLogFileDirty = TRUE;
    SetDirty(TRUE);
  }
}

void CDNSServer_DebugLoggingPropertyPage::OnMaxSizeChange()
{
  if (!m_bOnSetUIData)
  {
    m_bMaxSizeDirty = TRUE;
    SetDirty(TRUE);
  }
}

void CDNSServer_DebugLoggingPropertyPage::SetUIData()
{
  m_bOnSetUIData = TRUE;

	CPropertyPageBase::OnInitDialog();
	CDNSServerPropertyPageHolder* pHolder = 
		(CDNSServerPropertyPageHolder*)GetHolder();
	CDNSServerNode* pServerNode = pHolder->GetServerNode();

  m_dwLogLevel = pServerNode->GetLogLevelFlag();
  m_dwMaxSize = pServerNode->GetDebugLogFileMaxSize();

  if (m_bOwnIPListMemory && m_pIPFilterList)
  {
    free(m_pIPFilterList);
    m_pIPFilterList = NULL;
    m_bOwnIPListMemory = FALSE;
  }
  m_pIPFilterList = pServerNode->GetDebugLogFilterList();
  m_szLogFileName = pServerNode->GetDebugLogFileName();


  if (m_dwLogLevel)
  {
    SendDlgItemMessage(IDC_DEBUG_LOGGING_CHECK, BM_SETCHECK, BST_CHECKED, 0);
    SetUIFromOptions(m_dwLogLevel);
  }
  else
  {
    SendDlgItemMessage(IDC_DEBUG_LOGGING_CHECK, BM_SETCHECK, BST_UNCHECKED, 0);
    ResetToDefaults();
  }

  //
  // Set log file name
  //
  SetDlgItemText(IDC_LOGFILE_EDIT, m_szLogFileName);

  //
  // Set max file size
  //
  SetDlgItemInt(IDC_MAX_SIZE_EDIT, m_dwMaxSize);

  //
  // Set filter check
  //
  if (m_pIPFilterList != NULL)
  {
    SendDlgItemMessage(IDC_FILTERING_CHECK, BM_SETCHECK, (WPARAM)BST_CHECKED, 0);
    GetDlgItem(IDC_FILTER_BUTTON)->EnableWindow(TRUE);
  }
  else
  {
    SendDlgItemMessage(IDC_FILTERING_CHECK, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
    GetDlgItem(IDC_FILTER_BUTTON)->EnableWindow(FALSE);
  }

  //
  // Now enable/disable the controls based on the options
  //
  EnableLogging(m_dwLogLevel > 0);

  m_bOnSetUIData = FALSE;
}

void CDNSServer_DebugLoggingPropertyPage::SetUIFromOptions(DWORD dwOptions)
{
  //
  // Set logging options
  //
  for (UINT idx = 0; idx < ARRAYLENGTH(g_loggingOptions); idx++)
  {
    if (g_loggingOptions[idx].dwOption & dwOptions)
    {
      SendDlgItemMessage(g_loggingOptions[idx].nControlID, BM_SETCHECK, (WPARAM)BST_CHECKED, 0);
    }
    else
    {
      SendDlgItemMessage(g_loggingOptions[idx].nControlID, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
    }
  }
}

void CDNSServer_DebugLoggingPropertyPage::GetUIData(BOOL)
{
  if (SendDlgItemMessage(IDC_DEBUG_LOGGING_CHECK, BM_GETCHECK, 0, 0) == BST_CHECKED)
  {
    //
    // Get logging options
    //
    for (UINT idx = 0; idx < ARRAYLENGTH(g_loggingOptions); idx++)
    {
      LRESULT lCheck = SendDlgItemMessage(g_loggingOptions[idx].nControlID, BM_GETCHECK, 0, 0);
      if (lCheck == BST_CHECKED)
      {
        m_dwLogLevel |= g_loggingOptions[idx].dwOption;
      }
      else
      {
        m_dwLogLevel &= ~(g_loggingOptions[idx].dwOption);
      }
    }

    //
    // Get log file name
    //
    GetDlgItemText(IDC_LOGFILE_EDIT, m_szLogFileName);

    //
    // Get max file size
    //
    BOOL bTrans = FALSE;
    m_dwMaxSize = GetDlgItemInt(IDC_MAX_SIZE_EDIT, &bTrans, FALSE);

    //
    // Note: the filter IP addresses will be set when returning from the filter dialog
    //
  }
  else
  {
    m_dwLogLevel = 0;
  }

}

BOOL CDNSServer_DebugLoggingPropertyPage::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();
	CDNSServerPropertyPageHolder* pHolder = 
		(CDNSServerPropertyPageHolder*)GetHolder();
	CDNSServerNode* pServerNode = pHolder->GetServerNode();

  //
  // Retrieve necessary data from server
  //
	if (!pServerNode->HasServerInfo())
	{
		EnableWindow(FALSE);
		return TRUE;
	}

  //
  // Limit the file size to 9 characters (MAX_INT is 9 characters)
  //
  SendDlgItemMessage(IDC_MAX_SIZE_EDIT, EM_SETLIMITTEXT, (WPARAM)9, 0);

	SetUIData();

  m_bMaxSizeDirty = FALSE;
  m_bLogFileDirty = FALSE;
  m_bFilterDirty  = FALSE;

  if (pServerNode->GetBuildNumber() < DNS_SRV_BUILD_NUMBER_WHISTLER ||
      (pServerNode->GetMajorVersion() <= DNS_SRV_MAJOR_VERSION_NT_5 &&
       pServerNode->GetMinorVersion() < DNS_SRV_MINOR_VERSION_WHISTLER))
  {
    //
    // These debug options are not available on pre-Whistler servers
    //
    m_bNotWhistler = TRUE;
    GetDlgItem(IDC_FILTERING_CHECK)->EnableWindow(FALSE);
    GetDlgItem(IDC_MAX_SIZE_EDIT)->EnableWindow(FALSE);
    GetDlgItem(IDC_LOGFILE_EDIT)->EnableWindow(FALSE);
    GetDlgItem(IDC_FILENAME_STATIC)->EnableWindow(FALSE);
    GetDlgItem(IDC_MAXSIZE_STATIC)->EnableWindow(FALSE);
  }

  SetDirty(FALSE);
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CDNSServer_DebugLoggingPropertyPage::OnApply()
{
	if (!IsDirty())
		return TRUE;

	CDNSServerPropertyPageHolder* pHolder = 
		(CDNSServerPropertyPageHolder*)GetHolder();
	CDNSServerNode* pServerNode = pHolder->GetServerNode();

  GetUIData(FALSE);

	DNS_STATUS dwErr = pServerNode->ResetLogLevelFlag(m_dwLogLevel);
	if (dwErr != 0)
	{
		DNSErrorDialog(dwErr, IDS_MSG_SERVER_LOG_LEVEL_OPTIONS_FAILED);
		return FALSE;
	}

  if (m_bMaxSizeDirty && !m_bNotWhistler)
  {
    dwErr = pServerNode->ResetDebugLogFileMaxSize(m_dwMaxSize);
    if (dwErr != 0)
    {
      DNSErrorDialog(dwErr, IDS_MSG_SERVER_LOG_MAX_SIZE_FAILED);
      return FALSE;
    }
  }

  if (m_bLogFileDirty && !m_bNotWhistler)
  {
    dwErr = pServerNode->ResetDebugLogFileName(m_szLogFileName);
    if (dwErr != 0)
    {
      DNSErrorDialog(dwErr, IDS_MSG_SERVER_LOG_FILE_NAME_FAILED);
      return FALSE;
    }
  }

  if (m_bFilterDirty && !m_bNotWhistler)
  {
    LRESULT lCheck = SendDlgItemMessage(IDC_FILTERING_CHECK, BM_GETCHECK, 0, 0);
    if (lCheck == BST_CHECKED)
    {
      dwErr = pServerNode->ResetDebugLogFilterList(m_pIPFilterList);
    }
    else
    {
      dwErr = pServerNode->ResetDebugLogFilterList(NULL);
    }
    if (dwErr != 0)
    {
      DNSErrorDialog(dwErr, IDS_MSG_SERVER_LOG_FILTER_LIST_FAILED);
      return FALSE;
    }
    m_bFilterDirty = FALSE;
  }
  
  //
	// all is fine
  //
  SetUIData();
	SetDirty(FALSE);
	return TRUE; 
}

///////////////////////////////////////////////////////////////////////////////
// CDNSServer_EventLoggingPropertyPage

BEGIN_MESSAGE_MAP(CDNSServer_EventLoggingPropertyPage, CPropertyPageBase)
	ON_BN_CLICKED(IDC_NO_EVENTS_RADIO, OnSetDirty)
	ON_BN_CLICKED(IDC_ERRORS_RADIO, OnSetDirty)
	ON_BN_CLICKED(IDC_ERRORS_WARNINGS_RADIO, OnSetDirty)
	ON_BN_CLICKED(IDC_ALL_RADIO, OnSetDirty)
END_MESSAGE_MAP()

CDNSServer_EventLoggingPropertyPage::CDNSServer_EventLoggingPropertyPage() 
				: CPropertyPageBase(IDD_SERVER_EVENT_LOGGING_PAGE),
          m_dwEventLogLevel(EVENTLOG_INFORMATION_TYPE)
{
}


void CDNSServer_EventLoggingPropertyPage::SetUIData()
{
  if (m_dwEventLogLevel == 0)
  {
    SendDlgItemMessage(IDC_NO_EVENTS_RADIO, BM_SETCHECK, (WPARAM)BST_CHECKED, 0);
  }
  else if (m_dwEventLogLevel == EVENTLOG_ERROR_TYPE)
  {
    SendDlgItemMessage(IDC_ERRORS_RADIO, BM_SETCHECK, (WPARAM)BST_CHECKED, 0);
  }
  else if (m_dwEventLogLevel == EVENTLOG_WARNING_TYPE)
  {
    SendDlgItemMessage(IDC_ERRORS_WARNINGS_RADIO, BM_SETCHECK, (WPARAM)BST_CHECKED, 0);
  }
  else
  {
    SendDlgItemMessage(IDC_ALL_RADIO, BM_SETCHECK, (WPARAM)BST_CHECKED, 0);
  }
}

void CDNSServer_EventLoggingPropertyPage::OnSetDirty()
{
  SetDirty(TRUE);
}

BOOL CDNSServer_EventLoggingPropertyPage::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();
	CDNSServerPropertyPageHolder* pHolder = 
		(CDNSServerPropertyPageHolder*)GetHolder();
	CDNSServerNode* pServerNode = pHolder->GetServerNode();

	if (!pServerNode->HasServerInfo())
	{
		EnableWindow(FALSE);
		return TRUE;
	}

  m_dwEventLogLevel = pServerNode->GetEventLogLevelFlag();

	SetUIData();
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CDNSServer_EventLoggingPropertyPage::OnApply()
{
	if (!IsDirty())
		return TRUE;

	CDNSServerPropertyPageHolder* pHolder = 
		(CDNSServerPropertyPageHolder*)GetHolder();
	CDNSServerNode* pServerNode = pHolder->GetServerNode();

  //
  // Retrieve UI data
  //
  LRESULT lNoEventsCheck = SendDlgItemMessage(IDC_NO_EVENTS_RADIO, BM_GETCHECK, 0, 0);
  LRESULT lErrorsCheck   = SendDlgItemMessage(IDC_ERRORS_RADIO, BM_GETCHECK, 0, 0);
  LRESULT lWarningsCheck = SendDlgItemMessage(IDC_ERRORS_WARNINGS_RADIO, BM_GETCHECK, 0, 0);
  LRESULT lAllCheck      = SendDlgItemMessage(IDC_ALL_RADIO, BM_GETCHECK, 0, 0);

  DWORD dwEventLogLevel = 0;
  if (lNoEventsCheck == BST_CHECKED)
  {
    dwEventLogLevel = 0;
  }

  if (lErrorsCheck == BST_CHECKED)
  {
    dwEventLogLevel = EVENTLOG_ERROR_TYPE;
  }

  if (lWarningsCheck == BST_CHECKED)
  {
    dwEventLogLevel = EVENTLOG_WARNING_TYPE;
  }

  if (lAllCheck == BST_CHECKED)
  {
    dwEventLogLevel = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE;
  }

  //
  // Set new event log level on server
  //
  DNS_STATUS err = 0;
  err = pServerNode->ResetEventLogLevelFlag(dwEventLogLevel);
  if (err != 0)
  {
    ::DNSErrorDialog(err, IDS_MSG_SERVER_FAILED_SET_EVENTLOGLEVEL);
    return FALSE;
  }

  //
	// all is fine
  //
	SetDirty(FALSE);
	return TRUE; 
}


///////////////////////////////////////////////////////////////////////////////
// CDNSServer_CopyRootHintsFromDialog

BEGIN_MESSAGE_MAP(CDNSServer_CopyRootHintsFromDialog, CHelpDialog)
  ON_EN_CHANGE(IDC_IPEDIT, OnIPv4CtrlChange)
END_MESSAGE_MAP()

CDNSServer_CopyRootHintsFromDialog::CDNSServer_CopyRootHintsFromDialog(CComponentDataObject* pComponentData)
  : CHelpDialog(IDD_COPY_ROOTHINTS_DIALOG, pComponentData),
    m_pComponentData(pComponentData)
{
  m_dwIPVal = 0;
}

void CDNSServer_CopyRootHintsFromDialog::OnIPv4CtrlChange()
{
  GetDlgItem(IDOK)->EnableWindow(!GetIPv4Ctrl()->IsEmpty());
}

void CDNSServer_CopyRootHintsFromDialog::OnOK()
{
  GetIPv4Ctrl()->GetIPv4Val(&m_dwIPVal);
  CDialog::OnOK();
}

///////////////////////////////////////////////////////////////////////////////
// CDNSServer_RootHintsPropertyPage

BEGIN_MESSAGE_MAP(CDNSServer_RootHintsPropertyPage, CDNSNameServersPropertyPage)
  ON_BN_CLICKED(IDC_COPY_FROM_BUTTON, OnCopyFrom)
END_MESSAGE_MAP()

CDNSServer_RootHintsPropertyPage::CDNSServer_RootHintsPropertyPage()
	: CDNSNameServersPropertyPage(IDD_NAME_SERVERS_PAGE, IDS_NSPAGE_ROOT_HINTS)
{
	m_bMeaningfulTTL = FALSE; // TTL for root hinst means nothing
}

BOOL CDNSServer_RootHintsPropertyPage::OnInitDialog()
{
  CDNSNameServersPropertyPage::OnInitDialog();
  
  if (m_bReadOnly)
  {
    GetDlgItem(IDC_COPY_FROM_BUTTON)->ShowWindow(TRUE);
    GetDlgItem(IDC_COPY_FROM_BUTTON)->EnableWindow(FALSE);
  }
  else
  {
    GetDlgItem(IDC_COPY_FROM_BUTTON)->ShowWindow(TRUE);
    GetDlgItem(IDC_COPY_FROM_BUTTON)->EnableWindow(TRUE);
  }
  GetDlgItem(IDC_DNSQUERY_STATIC)->ShowWindow(FALSE);
  GetDlgItem(IDC_DNSQUERY_STATIC)->EnableWindow(FALSE);

  return TRUE;
}

void CDNSServer_RootHintsPropertyPage::OnCopyFrom()
{
  CThemeContextActivator activator;

  BOOL bSuccess = FALSE;
  while (!bSuccess)
  {
    CDNSServer_CopyRootHintsFromDialog copydlg(GetHolder()->GetComponentData());
    if (copydlg.DoModal() == IDCANCEL)
    {
      return;
    }
    
    //
    // create a thread object and set the name of servers to query
    //
	  CRootHintsQueryThread* pThreadObj = new CRootHintsQueryThread;
    if (pThreadObj == NULL)
    {
      ASSERT(FALSE);
      return;
    }

    //
    // if IP address given, try it
    //
    pThreadObj->LoadIPAddresses(1, &(copydlg.m_dwIPVal));

    //
	  // create a dialog and attach the thread to it
    //
    CWnd* pParentWnd = CWnd::FromHandle(GetSafeHwnd());
    if (pParentWnd == NULL)
    {
      ASSERT(FALSE);
      return;
    }

	  CLongOperationDialog dlg(pThreadObj, pParentWnd, IDR_SEARCH_AVI);
	  VERIFY(dlg.LoadTitleString(IDS_MSG_SERVWIZ_COLLECTINFO));
    dlg.m_bExecuteNoUI = FALSE;

	  dlg.DoModal();
	  if (!dlg.m_bAbandoned)
	  {
		  if (pThreadObj->GetError() != 0)
		  {
  	    DNSMessageBox(IDS_MSG_SERVWIZ_FAIL_ROOT_HINTS);
		  }
		  else
		  {
        //
			  // success, get the root hints info to the UI
        //
			  PDNS_RECORD pRootHintsRecordList = pThreadObj->GetHintsRecordList();
        AddCopiedRootHintsToList(pRootHintsRecordList);
      }
		  bSuccess = pThreadObj->GetError() == 0;
	  }
  }
}

void CDNSServer_RootHintsPropertyPage::AddCopiedRootHintsToList(PDNS_RECORD pRootHintsRecordList)
{
  CDNSRecordNodeEditInfoList NSRecordList;
  CDNSRecordNodeEditInfoList ARecordList;

  //
	// walk through the list of root hints, 
	// convert to C++ format, 
	// write to server and add to the folder list (no UI, folder hidden)
  //
	PDNS_RECORD pCurrDnsQueryRecord = pRootHintsRecordList;
	while (pCurrDnsQueryRecord != NULL)
	{
		ASSERT( (pCurrDnsQueryRecord->wType == DNS_TYPE_A) ||
				(pCurrDnsQueryRecord->wType == DNS_TYPE_NS) );
    
    //
		// create a record node and read data from DnsQuery format
    //
		CDNSRecordNodeBase* pRecordNode = 
			CDNSRecordInfo::CreateRecordNode(pCurrDnsQueryRecord->wType);
		pRecordNode->CreateFromDnsQueryRecord(pCurrDnsQueryRecord, DNS_RPC_RECORD_FLAG_ZONE_ROOT); 

    //
	  // create new data
    //
	  CDNSRecordNodeEditInfo* pNewInfo = new CDNSRecordNodeEditInfo;
     if (!pNewInfo)
     {
        break;
     }

	  pNewInfo->m_action = CDNSRecordNodeEditInfo::add;
	  CDNSRootData* pRootData = (CDNSRootData*)(GetHolder()->GetComponentData()->GetRootData());
	  ASSERT(pRootData != NULL);

    //
		// create entry into the record info list
    //
    if (pCurrDnsQueryRecord->wType == DNS_TYPE_NS)
    {
       CDNS_NS_RecordNode* pNSRecord = new CDNS_NS_RecordNode;
       if (pNSRecord)
       {
  	      pNewInfo->CreateFromNewRecord(new CDNS_NS_RecordNode);

         //
         // set the record node name
         //
		   BOOL bAtTheNode = (pCurrDnsQueryRecord->wType == DNS_TYPE_NS);
		   pNewInfo->m_pRecordNode->SetRecordName(pCurrDnsQueryRecord->pName, bAtTheNode);

         //
         // Set the record
         //
         pNewInfo->m_pRecord->ReadDnsQueryData(pCurrDnsQueryRecord);

         //
         // Add to the NS record list
         //
         NSRecordList.AddTail(pNewInfo);
       }
    }
    else // DNS_TYPE_A
    {
       CDNS_A_RecordNode* pARecord = new CDNS_A_RecordNode;
       if (pARecord)
       {
         pNewInfo->CreateFromNewRecord(new CDNS_A_RecordNode);

         //
         // set the record node name
         //
         pNewInfo->m_pRecordNode->SetRecordName(pCurrDnsQueryRecord->pName, FALSE);

         //
         // Set the record
         //
         pNewInfo->m_pRecord->ReadDnsQueryData(pCurrDnsQueryRecord);

         ARecordList.AddTail(pNewInfo);
       }
    }

		pCurrDnsQueryRecord = pCurrDnsQueryRecord->pNext;
  }

  //
  // Match the A records to the NS records
  //
  POSITION Apos = ARecordList.GetHeadPosition();
  while (Apos != NULL)
  {
    CDNSRecordNodeEditInfo* pAInfo = ARecordList.GetNext(Apos);
    ASSERT(pAInfo != NULL);
    if (pAInfo == NULL)
    {
      continue;
    }

    CDNS_A_RecordNode* pARecordNode = reinterpret_cast<CDNS_A_RecordNode*>(pAInfo->m_pRecordNode);
    ASSERT(pARecordNode != NULL);
    if (pARecordNode == NULL)
    {
      continue;
    }

    POSITION NSpos = NSRecordList.GetHeadPosition();
    while (NSpos != NULL)
    {
      CDNSRecordNodeEditInfo* pNSInfo = NSRecordList.GetNext(NSpos);
      ASSERT(pNSInfo != NULL);
      if (pNSInfo == NULL)
      {
        continue;
      }

      CDNS_NS_Record* pNSRecord = reinterpret_cast<CDNS_NS_Record*>(pNSInfo->m_pRecord);
      ASSERT(pNSRecord != NULL);
      if (pNSRecord == NULL)
      {
        continue;
      }

      if (_match(pNSRecord->m_szNameNode, pARecordNode))
      {
        pNSInfo->m_pEditInfoList->AddTail(pAInfo);
      }
    }
  }

  //
  // Detach and add the NS records info to the UI
  //
  while (!NSRecordList.IsEmpty())
  {
    CDNSRecordNodeEditInfo* pNewInfo = reinterpret_cast<CDNSRecordNodeEditInfo*>(NSRecordList.RemoveTail());
    ASSERT(pNewInfo != NULL);
    if (pNewInfo == NULL)
    {
      continue;
    }

    //
		// add to the list view (at the end)
    //
		int nCount = m_listCtrl.GetItemCount();
		if (m_listCtrl.InsertNSRecordEntry(pNewInfo, nCount))
    {
      //
      // Add to the clone info list so that changes will be applied
      //
      m_pCloneInfoList->AddTail(pNewInfo);

      //
      // set selection and button state on the last inserted
      //
      m_listCtrl.SetSelection(nCount);
      EnableEditorButtons(nCount);
  
      //
		  // notify count change
      //
		  OnCountChange(nCount+1); // added one
    }

    //
		// set dirty flag, it is a new record
    //
		SetDirty(TRUE);

  }

  while (!ARecordList.IsEmpty())
  {
    ARecordList.RemoveTail();
  }
}

void CDNSServer_RootHintsPropertyPage::ReadRecordNodesList()
{
	ASSERT(m_pCloneInfoList != NULL);
	CDNSServerPropertyPageHolder* pHolder = (CDNSServerPropertyPageHolder*)GetHolder();
	CDNSServerNode* pServerNode = pHolder->GetServerNode();


  CString szBuffer;
  szBuffer.LoadString(IDS_ROOT_HINTS_DESCR);
  GetDescription()->EnableWindow(TRUE);
  GetDescription()->ShowWindow(TRUE);
  SetDescription(szBuffer);


  if (!pServerNode->HasServerInfo())
  {
    SetReadOnly();
    return;
  }

  BOOL bRoot = FALSE;
  DNS_STATUS err = ::ServerHasRootZone(pServerNode->GetRPCName(), &bRoot);
  if (err == 0 && bRoot)
  {
    //
    // it is a root server
    //
    szBuffer.LoadString(IDS_ROOT_HINTS_NO);
    SetMessage(szBuffer);
    SetReadOnly();
    EnableDialogControls(m_hWnd, FALSE);
  }
  else
  {
    if (pServerNode->HasRootHints())
    {
	    CDNSRootHintsNode* pRootHints = pServerNode->GetRootHints();
	    ASSERT(pRootHints != NULL);
	    SetDomainNode(pRootHints);
	    pRootHints->GetNSRecordNodesInfo(m_pCloneInfoList);
    }
    else
    {
      CDNSRootHintsNode* pRootHints = pServerNode->GetRootHints();
      if (pRootHints != NULL)
      {
        SetDomainNode(pRootHints);
        pRootHints->GetNSRecordNodesInfo(m_pCloneInfoList);
      }
    }
  }
}

BOOL CDNSServer_RootHintsPropertyPage::WriteNSRecordNodesList()
{
  // call base class
  BOOL bRetVal = CDNSNameServersPropertyPage::WriteNSRecordNodesList();
  CDNSServerPropertyPageHolder* pHolder = (CDNSServerPropertyPageHolder*)GetHolder();
	CDNSServerNode* pServerNode = pHolder->GetServerNode();
 	if (bRetVal && pServerNode->HasServerInfo())
  {
    DNS_STATUS err = CDNSZoneNode::WriteToDatabase(pServerNode->GetRPCName(), DNS_ZONE_ROOT_HINTS);
    if (err != 0)
    {
      //DNSErrorDialog(err, L"CDNSZoneNode::WriteToDatabase() failed");
      bRetVal = FALSE;
    }
  }

  return bRetVal;
}

BOOL CDNSServer_RootHintsPropertyPage::OnApply()
{
  BOOL bRet = TRUE;

  CDNSServerPropertyPageHolder* pHolder = (CDNSServerPropertyPageHolder*)GetHolder();
	CDNSServerNode* pServerNode = pHolder->GetServerNode();
  if (m_listCtrl.GetItemCount() == 0 && pServerNode->HasRootHints())
  {
    //
    // If there are no forwarders and no root zone then show an error message
    //
    BOOL bServerHasForwarders = FALSE;
    CDNSDomainForwardersNode* pDomainForwardersNode = pServerNode->GetDomainForwardersNode();
    if (pDomainForwardersNode)
    {
      CNodeList* pChildList = pDomainForwardersNode->GetContainerChildList();
      if (pChildList)
      {
        bServerHasForwarders = (pChildList->GetHeadPosition() != NULL);
      }
    }
    
    DWORD cAddrCount = 0;
    PIP_ADDRESS pipAddrs = 0;
    DWORD dwForwardTimeout = 0;
    DWORD fSlave = 0;
    pServerNode->GetForwardersInfo(&cAddrCount, &pipAddrs, &dwForwardTimeout, &fSlave);
    if (cAddrCount > 0)
    {
       bServerHasForwarders = TRUE;
    }

    BOOL bServerHasRoot = FALSE;
    DNS_STATUS err = ServerHasRootZone(pServerNode->GetRPCName(), &bServerHasRoot);
    if (err == 0 && !bServerHasRoot && !bServerHasForwarders)
    {
      if (IDNO == DNSMessageBox(IDS_NO_ROOTHINTS, MB_YESNO | MB_DEFBUTTON2))
      {
        return FALSE;
      }
    }
  }

  if (bRet)
  {
    bRet = CDNSNameServersPropertyPage::OnApply();
  }
  return bRet;
}
///////////////////////////////////////////////////////////////////////////////
// CDNSServerPropertyPageHolder

CDNSServerPropertyPageHolder::CDNSServerPropertyPageHolder(CDNSRootData* pRootDataNode, 
					   CDNSServerNode* pServerNode, CComponentDataObject* pComponentData)
		: CPropertyPageHolderBase(pRootDataNode, pServerNode, pComponentData)
{
	ASSERT(pRootDataNode == GetContainerNode());
	m_pAclEditorPage = NULL;

	m_bAutoDeletePages = FALSE; // we have the pages as embedded members

	if (pServerNode->HasServerInfo())
	{
		AddPageToList((CPropertyPageBase*)&m_interfacesPage);
    AddPageToList((CPropertyPageBase*)&m_newForwardersPage);
		AddPageToList((CPropertyPageBase*)&m_advancedPage);
		AddPageToList((CPropertyPageBase*)&m_rootHintsPage);
		AddPageToList((CPropertyPageBase*)&m_debugLoggingPage);
    AddPageToList((CPropertyPageBase*)&m_eventLoggingPage);

		// security page added only if needed
		{
			CString szPath;
			pServerNode->CreateDsServerLdapPath(szPath);
			if (!szPath.IsEmpty())
				m_pAclEditorPage = CAclEditorPage::CreateInstance(szPath, this);
		}
	}
	
	AddPageToList((CPropertyPageBase*)&m_testPage);
}

CDNSServerPropertyPageHolder::~CDNSServerPropertyPageHolder()
{
	if (m_pAclEditorPage != NULL)
		delete m_pAclEditorPage;
}

void CDNSServerPropertyPageHolder::OnSheetMessage(WPARAM wParam, LPARAM lParam)
{
	if (wParam == SHEET_MSG_SERVER_TEST_DATA)
	{
		m_testPage.OnHaveTestData(lParam);
	}
}


HRESULT CDNSServerPropertyPageHolder::OnAddPage(int nPage, CPropertyPageBase*)
{
	// add the ACL editor page after the last, if present
	if ( (nPage != -1) || (m_pAclEditorPage == NULL) )
		return S_OK; 

	// add the ACLU page 
	HPROPSHEETPAGE  hPage = m_pAclEditorPage->CreatePage();
	if (hPage == NULL)
		return E_FAIL;
	// add the raw HPROPSHEETPAGE to sheet, not in the list
	return AddPageToSheetRaw(hPage);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\server.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       server.cpp
//
//--------------------------------------------------------------------------


#include "preDNSsn.h"
#include <SnapBase.h>

#include "resource.h"
#include "dnsutil.h"
#include "DNSSnap.h"
#include "snapdata.h"

#include "server.h"
#include "serverui.h"
#include "servmon.h"
#include "servwiz.h"
#include "domain.h"
#include "record.h"
#include "zone.h"

#include "ZoneWiz.h"


#ifdef DEBUG_ALLOCATOR
	#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
	#endif
#endif

#define RR_ROOTHINTS_TAB 3
#define RR_FORWARDERS_TAB 1

///////////////////////////////////////////////////////////////////////////////
// GLOBAL FUNCTIONS

LPCWSTR DNS_EVT_COMMAND_LINE = L"\\system32\\msdssevt.msc /computer=";
LPCWSTR MMC_APP = L"\\system32\\mmc.exe";


DNS_STATUS ServerHasCache(LPCWSTR lpszServerName, BOOL* pbRes)
{
	USES_CONVERSION;
	*pbRes = FALSE;
	DWORD dwFilter = ZONE_REQUEST_CACHE;
	PDNS_RPC_ZONE_LIST pZoneList = NULL;
	DNS_STATUS err = ::DnssrvEnumZones(lpszServerName, 
										dwFilter, 
										NULL /*pszLastZone, unused for the moment */,
										&pZoneList);
	if (err == 0 &&
      pZoneList)
	{
		*pbRes = (pZoneList->dwZoneCount > 0);
		::DnssrvFreeZoneList(pZoneList);
  }
  else
  {
    ASSERT(pZoneList);
  }
	return err;
}

DNS_STATUS ServerHasRootZone(LPCWSTR lpszServerName, BOOL* pbRes)
{
	USES_CONVERSION;
	*pbRes = FALSE;
	DWORD dwFilter = ZONE_REQUEST_FORWARD | ZONE_REQUEST_PRIMARY | ZONE_REQUEST_SECONDARY;
	PDNS_RPC_ZONE_LIST pZoneList = NULL;
	DNS_STATUS err = ::DnssrvEnumZones(lpszServerName, 
										dwFilter, 
										NULL /*pszLastZone, unused for the moment */,
										&pZoneList);
	if (err == 0 && pZoneList)
	{
	  for (DWORD iZone = 0; iZone < pZoneList->dwZoneCount; iZone++)
	  {
      if (pZoneList->ZoneArray[iZone]->pszZoneName)
      {
        if (wcscmp(L".", pZoneList->ZoneArray[iZone]->pszZoneName) == 0)
        {
          *pbRes = TRUE;
          break;
        }
      }
	  }
	}
	if (pZoneList != NULL)
		::DnssrvFreeZoneList(pZoneList);
	return err;
}

///////////////////////////////////////////////////////////////////////////////
// CZoneInfoHolder : simple memory manager for arrays of zone info handles

#define DEFAULT_ZONE_INFO_ARRAY_SIZE (128) 
#define MAX_ZONE_INFO_ARRAY_SIZE (0xffff)

CZoneInfoHolder::CZoneInfoHolder()
{
	AllocateMemory(DEFAULT_ZONE_INFO_ARRAY_SIZE);
}

CZoneInfoHolder::~CZoneInfoHolder()
{
	FreeMemory();
}

void CZoneInfoHolder::AllocateMemory(DWORD dwArrSize)
{
	TRACE(_T("CZoneInfoHolder::AllocateMemory(dwArrSize = %d)\n"), dwArrSize);
	m_dwArrSize = dwArrSize;
	DWORD dwMemSize = 2*m_dwArrSize*sizeof(PDNS_ZONE_INFO);
	m_zoneInfoArray = (PDNS_ZONE_INFO*)malloc(dwMemSize);
  if (m_zoneInfoArray != NULL)
  {
	  ASSERT(m_zoneInfoArray != NULL);
	  memset(m_zoneInfoArray, 0x0, dwMemSize);
	  m_dwZoneCount = 0;
#ifdef _DEBUG
	  for (DWORD k=0; k< dwArrSize; k++)
		  ASSERT(m_zoneInfoArray[k] == NULL);
#endif
  }
}

void CZoneInfoHolder::FreeMemory()
{
	if (m_zoneInfoArray != NULL)
	{
		TRACE(_T("CZoneInfoHolder::FreeMemory() m_dwArrSize = %d\n"), m_dwArrSize);
		ASSERT(m_dwArrSize > 0);
		//ASSERT(m_dwZoneCount <= m_dwArrSize);
		for (DWORD k=0; k < m_dwArrSize; k++)
		{
			if (m_zoneInfoArray[k] != NULL)
			{
				TRACE(_T("CZoneInfoHolder::FreeMemory()  DnsFreeZoneInfo(m_zoneInfoArray[%d])\n"), k);
				::DnssrvFreeZoneInfo(m_zoneInfoArray[k]);
			}
		}
		free(m_zoneInfoArray);
		m_zoneInfoArray = NULL;
		m_dwZoneCount = 0;
		m_dwArrSize = 0;
	}
}

BOOL CZoneInfoHolder::Grow()
{
	TRACE(_T("CZoneInfoHolder::Grow()\n"));
	if (m_dwArrSize >= MAX_ZONE_INFO_ARRAY_SIZE)
		return FALSE;
	ASSERT(m_dwArrSize > 0);
	ASSERT(m_dwZoneCount > m_dwArrSize);
	DWORD dwNewSize = m_dwZoneCount;
	FreeMemory();
	AllocateMemory(dwNewSize);
	return TRUE;
}


/////////////////////////////////////////////////////////////////////////
// CDNSMTContainerNode

CDNSMTContainerNode::CDNSMTContainerNode()
{ 
	m_pServerNode = NULL; 
	m_nState = notLoaded; 
  m_szDescriptionBar = _T("");
  m_pColumnSet = NULL;
}

HRESULT CDNSMTContainerNode::OnSetToolbarVerbState(IToolbar* pToolbar, 
                                                   CNodeList*)
{
  HRESULT hr = S_OK;

  //
  // Set the button state for each button on the toolbar
  //
  hr = pToolbar->SetButtonState(toolbarNewServer, ENABLED, FALSE);
  hr = pToolbar->SetButtonState(toolbarNewZone, ENABLED, FALSE);
  hr = pToolbar->SetButtonState(toolbarNewRecord, ENABLED, FALSE);
  return hr;
}   

LPWSTR CDNSMTContainerNode::GetDescriptionBarText()
{
  static CString szFilterEnabled;

  if(((CDNSRootData*)GetRootContainer())->IsFilteringEnabled())
  {
    if (szFilterEnabled.IsEmpty())
    {
      szFilterEnabled.LoadString(IDS_FILTER_ENABLED);
    }
    m_szDescriptionBar = szFilterEnabled;
  }
  else
  {
    m_szDescriptionBar = _T("");
  }
  return (LPWSTR)(LPCWSTR)m_szDescriptionBar;
}

int CDNSMTContainerNode::GetImageIndex(BOOL) 
{
	int nIndex = 0;
	switch (m_nState)
	{
	case notLoaded:
		nIndex = FOLDER_IMAGE_NOT_LOADED;
		break;
	case loading:
		nIndex = FOLDER_IMAGE_LOADING;
		break;
	case loaded:
		nIndex = FOLDER_IMAGE_LOADED;
		break;
	case unableToLoad:
		nIndex = FOLDER_IMAGE_UNABLE_TO_LOAD;
		break;
	case accessDenied:
		nIndex = FOLDER_IMAGE_ACCESS_DENIED;
		break;
	default:
		ASSERT(FALSE);
	}
	return nIndex;
}

void CDNSMTContainerNode::OnChangeState(CComponentDataObject* pComponentDataObject)
{
	switch (m_nState)
	{
	case notLoaded:
	case loaded:
	case unableToLoad:
	case accessDenied:
		{
			m_nState = loading;
			m_dwErr = 0;
		}
		break;
	case loading:
		{
			if (m_dwErr == 0)
				m_nState = loaded;
			else if (m_dwErr == ERROR_ACCESS_DENIED)
				m_nState = accessDenied;
			else 
				m_nState = unableToLoad;
		}
		break;
	default:
		ASSERT(FALSE);
	}
	VERIFY(SUCCEEDED(pComponentDataObject->ChangeNode(this, CHANGE_RESULT_ITEM_ICON)));
	VERIFY(SUCCEEDED(pComponentDataObject->UpdateVerbState(this)));
  if (m_nState != loading)
  {
    pComponentDataObject->UpdateResultPaneView(this);
  }
}

BOOL CDNSMTContainerNode::CanCloseSheets()
{
   // NTRAID#NTBUG-594003-2002/04/11-JeffJon-Don't offer
   // to shutdown the sheets for the user because if the
   // sheet brought up a modal dialog we will deadlock
   // ourselves.

	DNSMessageBox(IDS_MSG_CONT_CLOSE_SHEET, MB_OK);
   return FALSE;
}

void CDNSMTContainerNode::OnHaveData(CObjBase* pObj, CComponentDataObject* pComponentDataObject)
{
	CDNSMTContainerNode* p = dynamic_cast<CDNSMTContainerNode*>(pObj);
	if (p != NULL)
	{
		p->SetServerNode(GetServerNode());
	   AddChildToListAndUI(p, pComponentDataObject);
	}
   else
   {
      CLeafNode* pLeaf = dynamic_cast<CLeafNode*>(pObj);
      if (pLeaf)
      {
         AddChildToListAndUI(pLeaf, pComponentDataObject);
      }
   }
  pComponentDataObject->SetDescriptionBarText(this);
}


void CDNSMTContainerNode::OnError(DWORD dwErr) 
{
  if (dwErr == ERROR_MORE_DATA)
  {
    // need to pop message
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CThemeContextActivator activator;

    CString szFmt;
    szFmt.LoadString(IDS_MSG_QUERY_TOO_MANY_ITEMS);
    CString szMsg;
    szMsg.Format(szFmt, GetDisplayName()); 
    AfxMessageBox(szMsg);
    // this is actually a warning, need to reset
    dwErr = 0;
  }
  m_dwErr = dwErr;
}

///////////////////////////////////////////////////////////////////////////////
// CDNSQueryObj : general purpose base class

void CDNSQueryObj::SetFilterOptions(CDNSQueryFilter* pFilter)
{
  // limits
  m_bGetAll = pFilter->GetAll();
  m_nMaxObjectCount = pFilter->GetMaxObjectCount();

  // filtering
  m_nFilterOption = pFilter->GetFilterOption();
  
  m_szFilterString1 = pFilter->GetFilterString();
  m_nFilterStringLen1 = m_szFilterString1.GetLength();

  m_szFilterString2 = pFilter->GetFilterStringRange();
  m_nFilterStringLen2 = m_szFilterString2.GetLength();

  if ((m_nFilterStringLen1 == 0) && (m_nFilterStringLen2 == 0))
    m_nFilterOption = DNS_QUERY_FILTER_NONE;
}


BOOL CDNSQueryObj::MatchName(LPCWSTR lpszName)
{
  if (m_nFilterOption == DNS_QUERY_FILTER_CONTAINS)
  {
    //
    // wcsstr is case sensitive so make the strings lower
    // case before trying to find the substring
    //
    CString szName = lpszName;
    CString szFilterString = m_szFilterString1;
    szName.MakeLower();
    szFilterString.MakeLower();

    LPWSTR lpsz = wcsstr((LPCWSTR)szName, (LPCWSTR)szFilterString);
    return (lpsz != NULL);
  }
  if (m_nFilterOption == DNS_QUERY_FILTER_STARTS)
  {
    // match at the beginning
    size_t nLen = wcslen(lpszName);
    if (static_cast<int>(nLen) < m_nFilterStringLen1)
      return FALSE; // too short
    return (_wcsnicmp(lpszName, (LPCWSTR)m_szFilterString1, m_nFilterStringLen1) == 0);
  }
  if (m_nFilterOption == DNS_QUERY_FILTER_RANGE)
  {
    // test lower limit
    if (m_nFilterStringLen1 > 0)
    {
      if (_wcsicmp(lpszName, (LPCWSTR)m_szFilterString1) < 0)
        return FALSE; // below range, no need to continue
    }
    
    // test upper limit
    if (m_nFilterStringLen2 > 0)
    {
      return _wcsnicmp(lpszName, (LPCWSTR)m_szFilterString2, m_nFilterStringLen2) <= 0;
    }
    return TRUE;
  }
  return TRUE;
}


BOOL CDNSQueryObj::TooMuchData()
{
  if (m_bGetAll || (m_nObjectCount <= m_nMaxObjectCount))
    return FALSE;

  TRACE(_T("TooMuchData() m_nObjectCount = %d "), m_nObjectCount);    
/*
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  CThemeContextActivator activator;
  
  CString szFmt;
  szFmt.LoadString(IDS_MSG_QUERY_TOO_MANY_ITEMS);
  CString szMsg;
  szMsg.Format(szFmt, lpszFolderName); 
  AfxMessageBox(szMsg);
*/
  return TRUE;
}

/////////////////////////////////////////////////////////////////////////
// CCathegoryFolderNode


BOOL CCathegoryFolderQueryObj::CanAddZone(PDNS_RPC_ZONE pZoneInfo)
{
  // no filtering if cache is selected
  if (m_type == cache)
    return TRUE;

  // no filtering on reverse lookup autocreated zones
  if ( (m_type == revAuthoritated) && (pZoneInfo->Flags.AutoCreated))
    return TRUE;

  // filter on name
  return MatchName(pZoneInfo->pszZoneName);
}

BOOL CCathegoryFolderQueryObj::Enumerate()
{
	USES_CONVERSION;

	DWORD dwFilter = 0;
	switch(m_type)
	{
		case cache:
			dwFilter = ZONE_REQUEST_CACHE;
      m_bGetAll = TRUE; // no limit on #, to be safe
			break;
		case fwdAuthoritated:
			dwFilter = ZONE_REQUEST_FORWARD   | 
                 ZONE_REQUEST_PRIMARY   | 
                 ZONE_REQUEST_SECONDARY | 
                 ZONE_REQUEST_STUB;
			break;
		case revAuthoritated:
			dwFilter = ZONE_REQUEST_REVERSE   | 
                 ZONE_REQUEST_PRIMARY   | 
                 ZONE_REQUEST_SECONDARY | 
                 ZONE_REQUEST_STUB      | 
                 ZONE_REQUEST_AUTO;
			break;
    case domainForwarders:
      dwFilter = ZONE_REQUEST_FORWARDER;
      break;
	}

	PDNS_RPC_ZONE_LIST pZoneList = NULL;
	DNS_STATUS err = ::DnssrvEnumZones(m_szServerName, 
										dwFilter, 
										NULL /*pszLastZone, unused for the moment */,
										&pZoneList);
	if (err != 0)
	{
		if (pZoneList != NULL)
			::DnssrvFreeZoneList(pZoneList);
		OnError(err);
		return FALSE;
	}
	
  if (!pZoneList)
  {
    ASSERT(pZoneList);
    return FALSE;
  }

	for (DWORD iZone = 0; iZone < pZoneList->dwZoneCount; iZone++)
	{
    if (pZoneList->ZoneArray[iZone]->Flags.AutoCreated)
    {
      // if the zone is autocreated, we cannot count it in the
      // filtering limit, because we need it anyway
      m_nMaxObjectCount++;
    }
    else
    {
      if (TooMuchData())
        break;
    }

    //
    // Don't filter the domain forwarders
    //
    if (m_type != domainForwarders)
    {
      if (CanAddZone(pZoneList->ZoneArray[iZone]))
      {
        TRACE(_T("%s\n"),pZoneList->ZoneArray[iZone]->pszZoneName);
		    CDNSZoneNode* pZoneNode = new CDNSZoneNode();
        if (pZoneNode != NULL)
        {
		      pZoneNode->InitializeFromRPCZoneInfo(pZoneList->ZoneArray[iZone], m_bAdvancedView);
		      VERIFY(AddQueryResult(pZoneNode));
        }
      }
    }
    else
    {
      TRACE(_T("%s\n"),pZoneList->ZoneArray[iZone]->pszZoneName);
		  CDNSZoneNode* pZoneNode = new CDNSZoneNode();
      if (pZoneNode != NULL)
      {
		    pZoneNode->InitializeFromRPCZoneInfo(pZoneList->ZoneArray[iZone], m_bAdvancedView);
		    VERIFY(AddQueryResult(pZoneNode));
      }
    }
	}
	::DnssrvFreeZoneList(pZoneList);		

	return FALSE;
}


CQueryObj* CCathegoryFolderNode::OnCreateQuery()
{
	CDNSRootData* pRootData = (CDNSRootData*)GetRootContainer();
	ASSERT(pRootData != NULL);
	ASSERT(m_type != CCathegoryFolderQueryObj::unk);
	CCathegoryFolderQueryObj* pQuery = 
		new CCathegoryFolderQueryObj(pRootData->IsAdvancedView(), 
                                GetServerNode()->GetVersion());

   if (pQuery)
   {
      pQuery->m_szServerName = GetServerNode()->GetRPCName();
      pQuery->SetType(m_type);
   }
	return pQuery;
}


HRESULT CCathegoryFolderNode::OnCommand(long nCommandID, 
                                        DATA_OBJECT_TYPES, 
								                        CComponentDataObject* pComponentData,
                                        CNodeList* pNodeList)
{
  if (pNodeList->GetCount() > 1) // multiple selection
  {
    return E_FAIL;
  }

	if (nCommandID == IDM_SNAPIN_ADVANCED_VIEW)
  {
    ((CDNSRootData*)pComponentData->GetRootData())->OnViewOptions(pComponentData);
    pComponentData->UpdateResultPaneView(this);
    return S_OK;
  }
  if (nCommandID == IDM_SNAPIN_FILTERING)
  {
    if(((CDNSRootData*)pComponentData->GetRootData())->OnFilteringOptions(pComponentData))
    {
      pComponentData->SetDescriptionBarText(this);
    }
    return S_OK;
  }

	return E_FAIL;
}


BOOL CCathegoryFolderNode::OnAddMenuItem(LPCONTEXTMENUITEM2 pContextMenuItem2,
										                     long*)
{
  if (pContextMenuItem2->lCommandID == IDM_SNAPIN_ADVANCED_VIEW)
  {
    pContextMenuItem2->fFlags = ((CDNSRootData*)GetRootContainer())->IsAdvancedView() ? MF_CHECKED : 0;
  }
	if (pContextMenuItem2->lCommandID == IDM_SNAPIN_FILTERING)
  {
		if (((CDNSRootData*)GetRootContainer())->IsFilteringEnabled())
		{
			pContextMenuItem2->fFlags = MF_CHECKED;
		}
		return TRUE;
  }
  return FALSE;
}

BOOL CCathegoryFolderNode::OnSetRefreshVerbState(DATA_OBJECT_TYPES, 
                                                 BOOL* pbHide,
                                                 CNodeList*)
{
	*pbHide = FALSE;
	return !IsThreadLocked();
}

LPWSTR CCathegoryFolderNode::GetDescriptionBarText()
{
  static CString szFilterEnabled;
  static CString szZonesFormat;

  INT_PTR nContainerCount = GetContainerChildList()->GetVisibleCount();
  INT_PTR nLeafCount = GetLeafChildList()->GetVisibleCount();

  //
  // If not already loaded, then load the format string L"%d record(s)"
  //
  if (szZonesFormat.IsEmpty())
  {
    szZonesFormat.LoadString(IDS_FORMAT_ZONES);
  }

  //
  // Format the child count into the description bar text
  //
  m_szDescriptionBar.Format(szZonesFormat, nContainerCount + nLeafCount);

  //
  // Add L"[Filter Activated]" if the filter is on
  //
  if(((CDNSRootData*)GetRootContainer())->IsFilteringEnabled())
  {
    //
    // If not already loaded, then load the L"[Filter Activated]" string
    //
    if (szFilterEnabled.IsEmpty())
    {
      szFilterEnabled.LoadString(IDS_FILTER_ENABLED);
    }
    m_szDescriptionBar += szFilterEnabled;
  }

  return (LPWSTR)(LPCWSTR)m_szDescriptionBar;
}

/////////////////////////////////////////////////////////////////////////
// CDNSCacheNode
CDNSCacheNode::CDNSCacheNode()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	m_type = CCathegoryFolderQueryObj::cache;
	m_dwNodeFlags |= TN_FLAG_NO_WRITE;
	m_szDisplayName.LoadString(IDS_CATHEGORY_FOLDER_CACHE);
}

BOOL CDNSCacheNode::OnAddMenuItem(LPCONTEXTMENUITEM2 pContextMenuItem2,
								                  long*)
{
  //we have only one menu item, so no checks
	if (IsThreadLocked())
	{
		pContextMenuItem2->fFlags |= MF_GRAYED;
	}
  return TRUE;
}

HRESULT CDNSCacheNode::OnCommand(long nCommandID, 
                                 DATA_OBJECT_TYPES, 
                                 CComponentDataObject* pComponentData,
                                 CNodeList* pNodeList)
{
  if (pNodeList->GetCount() > 1) // multiple selection
  {
    return E_FAIL;
  }

	switch (nCommandID)
	{
		case IDM_CACHE_FOLDER_CLEAR_CACHE:
			OnClearCache(pComponentData);
			break;
    default:
			ASSERT(FALSE); // Unknown command!
			return E_FAIL;
	}
  return S_OK;
}

void CDNSCacheNode::OnClearCache(CComponentDataObject* pComponentData)
{
  ASSERT((GetFlags() & TN_FLAG_HIDDEN) == 0); // must not be hidden

	// if there are sheets up, ask to close them down, because
  // we will need a refresh
	if (IsSheetLocked())
	{
		if (!CanCloseSheets())
			return;
		pComponentData->GetPropertyPageHolderTable()->DeleteSheetsOfNode(this);
	}

  DNS_STATUS err;
	{ // scope for the wait cursor
    CWaitCursor wait;
	  err = GetServerNode()->ClearCache();
  }

  if (err != 0)
  {
    // need to let the user know the operation failed
    DNSErrorDialog(err, IDS_MSG_SERVER_FAIL_CLEAR_CACHE);
    return;
  }

  CNodeList nodeList;
  nodeList.AddTail(this);

  // the cache has been cleared, cause a refresh to get new data
  VERIFY(OnRefresh(pComponentData, &nodeList));
}

/////////////////////////////////////////////////////////////////////////
// CDNSDomainForwardersNode
//
CDNSDomainForwardersNode::CDNSDomainForwardersNode()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	m_type = CCathegoryFolderQueryObj::domainForwarders;

  //
  // Always hide the domain forwarders node
  //
	m_dwNodeFlags |= TN_FLAG_HIDDEN;

	m_szDisplayName.LoadString(IDS_CATHEGORY_FOLDER_DOMAIN_FORWARDERS);
}

BOOL CDNSDomainForwardersNode::OnEnumerate(CComponentDataObject* pComponentData, BOOL)
{
	OnChangeState(pComponentData);
	VERIFY(StartBackgroundThread(pComponentData, FALSE));

  //
  // Now enumerate all the children
  //
  CNodeList* pContList = GetContainerChildList();
  if (pContList != NULL)
  {
    POSITION pos = pContList->GetHeadPosition();
    while (pos != NULL)
    {
      CDNSZoneNode* pZoneNode = reinterpret_cast<CDNSZoneNode*>(pContList->GetNext(pos));
      if (pZoneNode != NULL)
      {
        //
        // NTRAID#NTBUG9-757023-2003/01/06-JeffJon
        // Enumerate the zone synchronously so that we are sure
        // we have the forwarders information prior to any property
        // sheets being available.
        //
        pZoneNode->OnEnumerate(pComponentData, FALSE);
      }
    }
  }
  return FALSE;
}

/////////////////////////////////////////////////////////////////////////
// CDNSAuthoritatedZonesNode

BEGIN_TOOLBAR_MAP(CDNSAuthoritatedZonesNode)
  TOOLBAR_EVENT(toolbarNewZone, OnNewZone)
END_TOOLBAR_MAP()

CDNSAuthoritatedZonesNode::CDNSAuthoritatedZonesNode(BOOL bReverse, UINT nStringID)
{ 
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	m_szDisplayName.LoadString(nStringID);
	m_bReverse = bReverse;
	m_type = bReverse ? CCathegoryFolderQueryObj::revAuthoritated : 
						CCathegoryFolderQueryObj::fwdAuthoritated;
}

HRESULT CDNSAuthoritatedZonesNode::OnSetToolbarVerbState(IToolbar* pToolbar, 
                                              CNodeList* pNodeList)
{
  HRESULT hr = S_OK;

  //
  // Set the button state for each button on the toolbar
  //
  hr = pToolbar->SetButtonState(toolbarNewServer, ENABLED, FALSE);
  ASSERT(SUCCEEDED(hr));

  hr = pToolbar->SetButtonState(toolbarNewRecord, ENABLED, FALSE);
  ASSERT(SUCCEEDED(hr));

  if (pNodeList->GetCount() > 1) // multiple selection
  {
    hr = pToolbar->SetButtonState(toolbarNewZone, ENABLED, FALSE);
    ASSERT(SUCCEEDED(hr));
  }
  else if (pNodeList->GetCount() == 1) // single selection
  {
    hr = pToolbar->SetButtonState(toolbarNewZone, ENABLED, (m_nState == loaded));
    ASSERT(SUCCEEDED(hr));
  }
  return hr;
}  

HRESULT CDNSAuthoritatedZonesNode::OnCommand(long nCommandID, 
                                             DATA_OBJECT_TYPES, 
											                       CComponentDataObject* pComponentData,
                                             CNodeList* pNodeList)
{
  HRESULT hr = S_OK;
  if (pNodeList->GetCount() > 1) // multiple selection
  {
    return E_FAIL;
  }

	switch (nCommandID)
	{
		case IDM_SERVER_NEW_ZONE:
			hr = OnNewZone(pComponentData, pNodeList);
      pComponentData->UpdateResultPaneView(this);
			break;
		case IDM_SNAPIN_ADVANCED_VIEW:
			((CDNSRootData*)pComponentData->GetRootData())->OnViewOptions(pComponentData);
      pComponentData->UpdateResultPaneView(this);
			break;
		case IDM_SNAPIN_FILTERING:
      {
        if (((CDNSRootData*)pComponentData->GetRootData())->OnFilteringOptions(pComponentData))
        {
          pComponentData->SetDescriptionBarText(this);
        }
      }
			break;
    default:
			ASSERT(FALSE); // Unknown command!
			return E_FAIL;
	}
  return hr;
};


HRESULT CDNSAuthoritatedZonesNode::OnNewZone(CComponentDataObject* pComponentData, CNodeList*)
{
   CThemeContextActivator activator;

	ASSERT(pComponentData != NULL);
	CDNSServerNode* pServerNode = GetServerNode();
	ASSERT(pServerNode != NULL);

	CDNSZoneWizardHolder holder(pComponentData);
	
	holder.Initialize(pServerNode);
	holder.PreSetZoneLookupType(!m_bReverse);
	holder.DoModalWizard();
  return S_OK;
}

BOOL CDNSAuthoritatedZonesNode::OnAddMenuItem(LPCONTEXTMENUITEM2 pContextMenuItem2,
											                        long*)
{
	// gray out commands that need data from the server
	if ((m_nState != loaded) && (pContextMenuItem2->lCommandID == IDM_SERVER_NEW_ZONE))
	{
		pContextMenuItem2->fFlags |= MF_GRAYED;
	}
	// add toggle menu item for advanced view
	if (pContextMenuItem2->lCommandID == IDM_SNAPIN_ADVANCED_VIEW)
  {
    pContextMenuItem2->fFlags = ((CDNSRootData*)GetRootContainer())->IsAdvancedView() ? MF_CHECKED : 0;
  }
	if (pContextMenuItem2->lCommandID == IDM_SNAPIN_FILTERING)
  {
		if (((CDNSRootData*)GetRootContainer())->IsFilteringEnabled())
		{
			pContextMenuItem2->fFlags = MF_CHECKED;
		}
		return TRUE;
  }

  return TRUE;

};

BOOL CDNSAuthoritatedZonesNode::OnSetRefreshVerbState(DATA_OBJECT_TYPES, 
                                                      BOOL* pbHide,
                                                      CNodeList*)
{
	*pbHide = FALSE;
	return !IsThreadLocked();
}

/////////////////////////////////////////////////////////////////////////
// CDNSForwardZonesNode
CDNSForwardZonesNode::CDNSForwardZonesNode() : 
		CDNSAuthoritatedZonesNode(FALSE, IDS_CATHEGORY_FOLDER_FWD)
{
}

HRESULT CDNSForwardZonesNode::GetResultViewType(CComponentDataObject*,
                                                LPOLESTR *ppViewType, 
                                                long *pViewOptions)
{
  HRESULT hr = S_FALSE;

  if ((m_containerChildList.IsEmpty() && 
       m_leafChildList.IsEmpty())     || 
      m_nState == accessDenied        || 
      m_nState == unableToLoad        &&
      m_nState != loading             &&
      m_nState != notLoaded)
  {
    *pViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS;

    LPOLESTR psz = NULL;
    StringFromCLSID(CLSID_MessageView, &psz);

    USES_CONVERSION;

    if (psz != NULL)
    {
        *ppViewType = psz;
        hr = S_OK;
    }
  }
  else
  {
	  *pViewOptions = MMC_VIEW_OPTIONS_MULTISELECT;
	  *ppViewType = NULL;
    hr = S_FALSE;
  }
  return hr;
}

HRESULT CDNSForwardZonesNode::OnShow(LPCONSOLE lpConsole)
{
  CComPtr<IUnknown> spUnknown;
  CComPtr<IMessageView> spMessageView;

  HRESULT hr = lpConsole->QueryResultView(&spUnknown);
  if (FAILED(hr))
    return S_OK;

  hr = spUnknown->QueryInterface(IID_IMessageView, (PVOID*)&spMessageView);
  if (SUCCEEDED(hr))
  {
    CString szTitle, szMessage;
    IconIdentifier iconID;
    if (m_nState == accessDenied)
    {
      VERIFY(szTitle.LoadString(IDS_MESSAGE_VIEW_ACCESS_DENIED_TITLE));
      VERIFY(szMessage.LoadString(IDS_MESSAGE_VIEW_ACCESS_DENIED_MESSAGE));
      iconID = Icon_Error;
    }
    else if (m_nState == unableToLoad)
    {
      VERIFY(szTitle.LoadString(IDS_MESSAGE_VIEW_NOT_LOADED_TITLE));
      VERIFY(szMessage.LoadString(IDS_MESSAGE_VIEW_NOT_LOADED_MESSAGE));
      iconID = Icon_Error;
    }
    else
    {
      VERIFY(szTitle.LoadString(IDS_MESSAGE_VIEW_EMPTY_FOLDER_TITLE));
      VERIFY(szMessage.LoadString(IDS_MESSAGE_VIEW_EMPTY_FOLDER_MESSAGE));
      iconID = Icon_Information;
    }
    spMessageView->SetTitleText(szTitle);
    spMessageView->SetBodyText(szMessage);
    spMessageView->SetIcon(iconID);
  }
  
  return S_OK;
}

/////////////////////////////////////////////////////////////////////////
// CDNSReverseZonesNode

CDNSReverseZonesNode::CDNSReverseZonesNode() : 
		CDNSAuthoritatedZonesNode(TRUE, IDS_CATHEGORY_FOLDER_REV)
{
	m_p0ZoneNode = NULL;
	m_p127ZoneNode = NULL;
	m_p255ZoneNode = NULL;
}

BOOL CDNSReverseZonesNode::OnRefresh(CComponentDataObject* pComponentData,
                                     CNodeList* pNodeList)
{
  if (pNodeList->GetCount() > 1) // multiple selection
  {
    return FALSE;
  }

	if (CDNSAuthoritatedZonesNode::OnRefresh(pComponentData, pNodeList))
	{
		m_p0ZoneNode = NULL;
		m_p127ZoneNode = NULL;
		m_p255ZoneNode = NULL;
		return TRUE;
	}
	return FALSE;
}

void CDNSReverseZonesNode::OnHaveData(CObjBase* pObj, CComponentDataObject* pComponentDataObject)
{
	// the autocreated zone nodes can be shown or not, depending on the view options
	if ( (m_p0ZoneNode == NULL) || (m_p127ZoneNode == NULL) || (m_p255ZoneNode == NULL) &&
			IS_CLASS(*pObj, CDNSZoneNode))
	{
		CDNSZoneNode* pZoneNode = dynamic_cast<CDNSZoneNode*>(pObj);
		ASSERT(pZoneNode != NULL); // should never have anything below but zones!!!
    if (pZoneNode != NULL)
    {
		  CDNSRootData* pRootData = (CDNSRootData*)pComponentDataObject->GetRootData();
		  if (pZoneNode->IsAutocreated())
		  {
			  BOOL bCachedPointer = FALSE;
			  if (_wcsicmp(pZoneNode->GetFullName(), AUTOCREATED_0) == 0)
			  {
				  ASSERT(m_p0ZoneNode == NULL);
				  m_p0ZoneNode = pZoneNode;
				  bCachedPointer = TRUE;
			  }
			  else if (_wcsicmp(pZoneNode->GetFullName(), AUTOCREATED_127) == 0)
			  {
				  ASSERT(m_p127ZoneNode == NULL);
				  m_p127ZoneNode = pZoneNode;
				  bCachedPointer = TRUE;
			  }
			  else if (_wcsicmp(pZoneNode->GetFullName(), AUTOCREATED_255) == 0)
			  {
				  ASSERT(m_p255ZoneNode == NULL);
				  m_p255ZoneNode = pZoneNode;
				  bCachedPointer = TRUE;
			  }
			  if (bCachedPointer && !pRootData->IsAdvancedView())
			  {
				  pZoneNode->SetFlagsDown(TN_FLAG_HIDDEN,TRUE); // mark it hidden, will not be added to UI
			  }
		  }
    }
	}
	CDNSMTContainerNode::OnHaveData(pObj,pComponentDataObject);
}

void CDNSReverseZonesNode::ChangeViewOption(BOOL bAdvanced,
					CComponentDataObject* pComponentDataObject)
{
	POSITION pos;
	for( pos = m_containerChildList.GetHeadPosition(); pos != NULL; )
	{
		CTreeNode* pCurrentChild = m_containerChildList.GetNext(pos);
		CDNSZoneNode* pZoneNode = dynamic_cast<CDNSZoneNode*>(pCurrentChild);
		ASSERT(pZoneNode != NULL);
		pZoneNode->ChangeViewOption(bAdvanced, pComponentDataObject);
	}

	if (m_p0ZoneNode != NULL)
		m_p0ZoneNode->Show(bAdvanced,pComponentDataObject);
	if (m_p127ZoneNode != NULL)
		m_p127ZoneNode->Show(bAdvanced,pComponentDataObject);
	if (m_p255ZoneNode != NULL)
		m_p255ZoneNode->Show(bAdvanced,pComponentDataObject);

}

HRESULT CDNSReverseZonesNode::GetResultViewType(CComponentDataObject*,
                                                LPOLESTR *ppViewType, 
                                                long *pViewOptions)
{
  HRESULT hr = S_FALSE;

  // the 3 refers to the auto-created reverse lookup zones
  if ((m_containerChildList.IsEmpty() && 
       m_leafChildList.IsEmpty())     || 
      (!((CDNSRootData*)GetRootContainer())->IsAdvancedView() && m_containerChildList.GetCount() == 3) ||
      m_nState == accessDenied        || 
      m_nState == unableToLoad        &&
      m_nState != loading             &&
      m_nState != notLoaded)
  {
    *pViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS;

    LPOLESTR psz = NULL;
    StringFromCLSID(CLSID_MessageView, &psz);

    USES_CONVERSION;

    if (psz != NULL)
    {
        *ppViewType = psz;
        hr = S_OK;
    }
  }
  else
  {
	  *pViewOptions = MMC_VIEW_OPTIONS_MULTISELECT;
	  *ppViewType = NULL;
    hr = S_FALSE;
  }
  return hr;
}

HRESULT CDNSReverseZonesNode::OnShow(LPCONSOLE lpConsole)
{
  CComPtr<IUnknown> spUnknown;
  CComPtr<IMessageView> spMessageView;

  HRESULT hr = lpConsole->QueryResultView(&spUnknown);
  if (FAILED(hr))
    return S_OK;

  hr = spUnknown->QueryInterface(IID_IMessageView, (PVOID*)&spMessageView);
  if (SUCCEEDED(hr))
  {
    CString szTitle, szMessage;
    IconIdentifier iconID;
    if (m_nState == accessDenied)
    {
      VERIFY(szTitle.LoadString(IDS_MESSAGE_VIEW_ACCESS_DENIED_TITLE));
      VERIFY(szMessage.LoadString(IDS_MESSAGE_VIEW_ACCESS_DENIED_MESSAGE));
      iconID = Icon_Error;
    }
    else if (m_nState == unableToLoad)
    {
      VERIFY(szTitle.LoadString(IDS_MESSAGE_VIEW_NOT_LOADED_TITLE));
      VERIFY(szMessage.LoadString(IDS_MESSAGE_VIEW_NOT_LOADED_MESSAGE));
      iconID = Icon_Error;
    }
    else
    {
      VERIFY(szTitle.LoadString(IDS_MESSAGE_VIEW_EMPTY_FOLDER_TITLE));
      VERIFY(szMessage.LoadString(IDS_MESSAGE_VIEW_EMPTY_FOLDER_MESSAGE));
      iconID = Icon_Information;
    }
    spMessageView->SetTitleText(szTitle);
    spMessageView->SetBodyText(szMessage);
    spMessageView->SetIcon(iconID);
  }
  
  return S_OK;
}
/////////////////////////////////////////////////////////////////////////
// CDNSServerTestOptions

CDNSServerTestOptions::CDNSServerTestOptions()
{
	m_bEnabled = FALSE;
	m_dwInterval = DEFAULT_SERVER_TEST_INTERVAL;
	m_bSimpleQuery = FALSE;
	m_bRecursiveQuery = FALSE;
}

HRESULT CDNSServerTestOptions::Save(IStream* pStm)
{
	ULONG cbWrite;

	VERIFY(SUCCEEDED(pStm->Write((void*)&m_bEnabled, sizeof(BOOL),&cbWrite)));
	ASSERT(cbWrite == sizeof(BOOL));

	VERIFY(SUCCEEDED(pStm->Write((void*)&m_dwInterval, sizeof(DWORD),&cbWrite)));
	ASSERT(cbWrite == sizeof(DWORD));

	VERIFY(SUCCEEDED(pStm->Write((void*)&m_bSimpleQuery, sizeof(BOOL),&cbWrite)));
	ASSERT(cbWrite == sizeof(BOOL));

	VERIFY(SUCCEEDED(pStm->Write((void*)&m_bRecursiveQuery, sizeof(BOOL),&cbWrite)));
	ASSERT(cbWrite == sizeof(BOOL));

	return S_OK;
}

HRESULT CDNSServerTestOptions::Load(IStream* pStm)
{
	ULONG cbRead;

	VERIFY(SUCCEEDED(pStm->Read((void*)&m_bEnabled,sizeof(BOOL), &cbRead)));
	ASSERT(cbRead == sizeof(BOOL));

	VERIFY(SUCCEEDED(pStm->Read((void*)&m_dwInterval,sizeof(DWORD), &cbRead)));
	ASSERT(cbRead == sizeof(DWORD));

	VERIFY(SUCCEEDED(pStm->Read((void*)&m_bSimpleQuery,sizeof(BOOL), &cbRead)));
	ASSERT(cbRead == sizeof(BOOL));

	VERIFY(SUCCEEDED(pStm->Read((void*)&m_bRecursiveQuery,sizeof(BOOL), &cbRead)));
	ASSERT(cbRead == sizeof(BOOL));

	// force range on test interval
	if (m_dwInterval < MIN_SERVER_TEST_INTERVAL) 
		m_dwInterval = MIN_SERVER_TEST_INTERVAL;
	else if (m_dwInterval > MAX_SERVER_TEST_INTERVAL) 
		m_dwInterval = MAX_SERVER_TEST_INTERVAL;

	return S_OK;
}

const CDNSServerTestOptions& 
	CDNSServerTestOptions::operator=(const CDNSServerTestOptions& x)
{
	m_bEnabled = x.m_bEnabled;
	m_dwInterval = x.m_dwInterval;
	m_bSimpleQuery = x.m_bSimpleQuery;
	m_bRecursiveQuery = x.m_bRecursiveQuery;
	return *this;
}

BOOL CDNSServerTestOptions::operator==(const CDNSServerTestOptions& x) const
{
	if (m_bEnabled != x.m_bEnabled) return FALSE;
	if (m_dwInterval != x.m_dwInterval) return FALSE;
	if (m_bSimpleQuery != x.m_bSimpleQuery) return FALSE;
	if (m_bRecursiveQuery != x.m_bRecursiveQuery) return FALSE;
	return TRUE;
}


/////////////////////////////////////////////////////////////////////////
// CDNSServerNode

BEGIN_TOOLBAR_MAP(CDNSServerNode)
  TOOLBAR_EVENT(toolbarNewZone, OnNewZone)
END_TOOLBAR_MAP()

// {720132B8-44B2-11d1-B92F-00A0C9A06D2D}
const GUID CDNSServerNode::NodeTypeGUID = 
	{ 0x720132b8, 0x44b2, 0x11d1, { 0xb9, 0x2f, 0x0, 0xa0, 0xc9, 0xa0, 0x6d, 0x2d } };

CDNSServerNode::CDNSServerNode(LPCTSTR lpszName, BOOL bIsLocalServer) 
{
	SetServerNode(this);
	m_szDisplayName = lpszName;

	m_pServInfoEx = new CDNSServerInfoEx;

	m_pRootHintsNode = NULL;

	m_pCacheFolderNode = NULL;
	m_pFwdZonesFolderNode = NULL;
	m_pRevZonesFolderNode = NULL;
  m_pDomainForwardersFolderNode = NULL;

	m_dwTestTime = 0x0;
	m_bTestQueryPending = FALSE;
  m_bShowMessages = TRUE;
  m_bPrevQuerySuccess = TRUE;

  m_nStartProppage = -1;

  m_bLocalServer = bIsLocalServer;
}

CDNSServerNode::~CDNSServerNode()
{
	ASSERT(m_pServInfoEx != NULL);
	delete m_pServInfoEx;
	FreeRootHints();

	//TRACE(_T("~CDNSServerNode(), name <%s>\n"),GetDisplayName());
}

void CDNSServerNode::SetDisplayName(LPCWSTR lpszDisplayName) 
{ 
	m_szDisplayName = lpszDisplayName;
}

LPCWSTR CDNSServerNode::GetRPCName() 
{ 
	return GetDisplayName(); 
}

CLIPFORMAT g_cfMachineName = (CLIPFORMAT)RegisterClipboardFormat(L"MMC_SNAPIN_MACHINE_NAME");
CLIPFORMAT g_cfServiceName = (CLIPFORMAT)RegisterClipboardFormat(L"FILEMGMT_SNAPIN_SERVICE_NAME");
CLIPFORMAT g_cfServiceDisplayName = (CLIPFORMAT)RegisterClipboardFormat(L"FILEMGMT_SNAPIN_SERVICE_DISPLAYNAME");
CLIPFORMAT g_cfFramewrkDataObjectType = (CLIPFORMAT)RegisterClipboardFormat(L"FRAMEWRK_DATA_OBJECT_TYPE");
CLIPFORMAT g_cfEventViewer = (CLIPFORMAT)RegisterClipboardFormat(L"CF_EV_VIEWS");

HRESULT CDNSServerNode::GetDataHere(CLIPFORMAT cf, LPSTGMEDIUM lpMedium, 
									CDataObject* pDataObject) 
{
	ASSERT(pDataObject != NULL);
	HRESULT hr = DV_E_CLIPFORMAT;
	if (cf == g_cfMachineName)
	{
		LPCWSTR pwszMachineName = GetDisplayName();
		hr = pDataObject->Create(pwszMachineName, BYTE_MEM_LEN_W(pwszMachineName), lpMedium);
	}
	else if (cf == g_cfServiceName)
	{
		LPCWSTR pwszServiceName = _T("DNS");
		hr = pDataObject->Create(pwszServiceName, BYTE_MEM_LEN_W(pwszServiceName), lpMedium);
	}
	else if (cf == g_cfServiceDisplayName)
	{
		LPCWSTR pwszServiceDisplayName = _T("Microsoft DNS Server");
		hr = pDataObject->Create(pwszServiceDisplayName, BYTE_MEM_LEN_W(pwszServiceDisplayName), lpMedium);
	}
	else if (cf == g_cfFramewrkDataObjectType)
	{
		DATA_OBJECT_TYPES type = pDataObject->GetType();
		hr = pDataObject->Create(&type, sizeof(DATA_OBJECT_TYPES), lpMedium);
	}
	return hr;
}

HRESULT CDNSServerNode::GetData(CLIPFORMAT cf, LPSTGMEDIUM lpMedium, CDataObject* pDataObject) 
{
	ASSERT(pDataObject != NULL);
	HRESULT hr = DV_E_CLIPFORMAT;
	if (cf == g_cfEventViewer)
  {
    hr = RetrieveEventViewerLogs(lpMedium, pDataObject);
  }
	return hr;
}


//
// Macros and  #defines for event viewer clipformats 
//
#define ELT_SYSTEM            101
#define ELT_SECURITY          102
#define ELT_APPLICATION       103
#define ELT_CUSTOM            104

#define VIEWINFO_BACKUP       0x0001
#define VIEWINFO_FILTERED     0x0002
#define VIEWINFO_LOW_SPEED    0x0004
#define VIEWINFO_USER_CREATED 0x0008
#define VIEWINFO_ALLOW_DELETE 0x0100
#define VIEWINFO_DISABLED     0x0200
#define VIEWINFO_READ_ONLY    0x0400
#define VIEWINFO_DONT_PERSIST 0x0800

#define VIEWINFO_CUSTOM       ( VIEWINFO_FILTERED | VIEWINFO_DONT_PERSIST)

#define EV_ALL_ERRORS  (EVENTLOG_ERROR_TYPE       | EVENTLOG_WARNING_TYPE  | \
                        EVENTLOG_INFORMATION_TYPE | EVENTLOG_AUDIT_SUCCESS | \
                        EVENTLOG_AUDIT_FAILURE) 

#define ADD_TYPE(data, type) \
  {type x = data; \
   hr = spStm->Write(&x, sizeof(type), NULL); \
   if (FAILED(hr)) return hr; }

#define ADD_USHORT(us) ADD_TYPE(us, USHORT)
#define ADD_BOOL(b)    ADD_TYPE(b,  BOOL)
#define ADD_ULONG(ul)  ADD_TYPE(ul, ULONG)
#define ADD_STRING(str) \
  {strLength = (ULONG)wcslen((LPCWSTR)(str)) + 1; \
   ADD_USHORT((USHORT)strLength); \
   hr = spStm->Write(str, strLength * sizeof(WCHAR), NULL); \
   if (FAILED(hr)) return hr; }

HRESULT CDNSServerNode::RetrieveEventViewerLogs(LPSTGMEDIUM lpMedium, CDataObject*)
{
  HRESULT hr = S_OK;
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  //
  // Build the path to the event log
  //
  CString szDNSEventsLabel;
  szDNSEventsLabel.LoadString(IDS_DNS_EVENTS);

  CString szDNSEventPath;
  CString szConfigPath;
  CString szServerName = L"\\\\";
  szServerName += GetDisplayName();
  szConfigPath += szServerName;
  szConfigPath += L"\\Admin$\\System32\\config\\";
  szDNSEventPath = szConfigPath;
  szDNSEventPath += L"DNSEvent.Evt";

  ULONG strLength = 0;
  
  CComPtr<IStream> spStm;

  hr = CreateStreamOnHGlobal(NULL, FALSE, &spStm);

  if (FAILED(hr))
  {
     return hr;
  }

  //
  // Add header info
  //
  ADD_BOOL( TRUE ); // fOnlyTheseViews
  ADD_USHORT( 1 );  // cViews

  //
  // Add application log filtered for our services
  //
  ADD_ULONG( ELT_CUSTOM );      // Type; ELT_CUSTOM
  ADD_USHORT( VIEWINFO_CUSTOM );// flViewFlags: VIEWINFO_FILTERED
  PCWSTR pwz = GetDisplayName();
  ADD_STRING( pwz );            // ServerName
  pwz = L"DNS Server";          // SourceName
  ADD_STRING( pwz );
  ADD_STRING( szDNSEventPath ); // FileName
  ADD_STRING( szDNSEventsLabel ); // DisplayName

  ADD_ULONG( EV_ALL_ERRORS );   // flRecType (could filter warning, error, etc.)
  ADD_USHORT( 0 );              // usCategory
  ADD_BOOL( FALSE );            // fEventID
  ADD_ULONG( 0 );               // ulEventID
  pwz = L"";
  ADD_STRING( pwz );            // szSourceName
  ADD_STRING( pwz );            // szUser
  ADD_STRING( pwz );            // szComputer
  ADD_ULONG( 0 );               // ulFrom
  ADD_ULONG( 0 );               // ulTo

  HGLOBAL hMem = NULL;

  hr = GetHGlobalFromStream(spStm, &hMem);

  if (FAILED(hr) || !hMem)
  {
     return hr;
  }

  lpMedium->hGlobal        = hMem;       // StgMedium variables 
  lpMedium->tymed          = TYMED_HGLOBAL;
  lpMedium->pUnkForRelease = NULL;

  return hr;
}

void CDNSServerNode::ChangeViewOption(BOOL bAdvanced, CComponentDataObject* pComponentData)
{
  //
	// changes in record options
  //
	SetFlagsOnNonContainers(TN_FLAG_DNS_RECORD_FULL_NAME , !bAdvanced);

  //
	//pComponentData->RepaintResultPane(this);
  //
	pComponentData->RepaintSelectedFolderInResultPane();

  //
	// Cached Lookup Folder
  //
	if (m_pCacheFolderNode != NULL)
	{
		m_pCacheFolderNode->Show(bAdvanced,pComponentData);
	}

  //
	// Auto Created Zones
  //
	if (m_pRevZonesFolderNode != NULL)
	{
		m_pRevZonesFolderNode->ChangeViewOption(bAdvanced, pComponentData);
	}
}	

CDNSAuthoritatedZonesNode* CDNSServerNode::GetAuthoritatedZoneFolder(BOOL bFwd)
{
	return bFwd ? (CDNSAuthoritatedZonesNode*)m_pFwdZonesFolderNode : 
					(CDNSAuthoritatedZonesNode*)m_pRevZonesFolderNode;
}

HRESULT CDNSServerNode::OnSetToolbarVerbState(IToolbar* pToolbar, 
                                              CNodeList* pNodeList)
{
  HRESULT hr = S_OK;

  //
  // Set the button state for each button on the toolbar
  //
  hr = pToolbar->SetButtonState(toolbarNewServer, ENABLED, FALSE);
  ASSERT(SUCCEEDED(hr));

  hr = pToolbar->SetButtonState(toolbarNewRecord, ENABLED, FALSE);
  ASSERT(SUCCEEDED(hr));

  if (pNodeList->GetCount() > 1) // multiple selection
  {
    hr = pToolbar->SetButtonState(toolbarNewZone, ENABLED, FALSE);
    ASSERT(SUCCEEDED(hr));
  }
  else if (pNodeList->GetCount() == 1) // single selection
  {
    hr = pToolbar->SetButtonState(toolbarNewZone, ENABLED, (m_nState == loaded));
  }
  return hr;
}  

HRESULT CDNSServerNode::OnCommand(long nCommandID, 
                                  DATA_OBJECT_TYPES, 
								                  CComponentDataObject* pComponentData,
                                  CNodeList* pNodeList)
{
  HRESULT hr = S_OK;

  if (pNodeList->GetCount() == 1) // single selection
  {
	  switch (nCommandID)
	  {
		  case IDM_SERVER_NEW_ZONE:
			  hr = OnNewZone(pComponentData, pNodeList);
			  break;
		  case IDM_SERVER_UPDATE_DATA_FILES:
			  OnUpdateDataFiles(pComponentData);
			  break;
      case IDM_SERVER_CLEAR_CACHE:
			  OnClearCache(pComponentData);
			  break;
		  case IDM_SNAPIN_ADVANCED_VIEW:
			  ((CDNSRootData*)pComponentData->GetRootData())->OnViewOptions(pComponentData);
			  break;
      case IDM_SNAPIN_MESSAGE:
        m_bShowMessages = !m_bShowMessages;
        pComponentData->UpdateResultPaneView(this);
        break;
		  case IDM_SNAPIN_FILTERING:
        {
          if (((CDNSRootData*)pComponentData->GetRootData())->OnFilteringOptions(pComponentData))
          {
            pComponentData->SetDescriptionBarText(this);
          }
        }
			  break;
      case IDM_SERVER_SET_AGING:
        SetRecordAging();
        break;
      case IDM_SERVER_SCAVENGE:
        ScavengeRecords();
        break;
      case IDM_SERVER_CONFIGURE:
        OnConfigureServer(pComponentData);
        break;

#ifdef USE_NDNC
      case IDM_SERVER_CREATE_NDNC:
        OnCreateNDNC();
        break;
#endif 

      case IDM_SERVER_NSLOOKUP:
        OnLaunchNSLookup();
        break;

      default:
			  ASSERT(FALSE); // Unknown command!
			  hr = E_FAIL;
	  }
  }
  else
  {
    hr = E_FAIL;
  }
  return hr;
}

void CDNSServerNode::OnLaunchNSLookup()
{
  PROCESS_INFORMATION procInfo;
  memset(&procInfo, 0, sizeof(procInfo));

  STARTUPINFO startup;
  memset(&startup, 0, sizeof(startup));

  CString szSystemDir;

  // Try MAX_PATH and then increase if needed

  int bufferSizeInCharacters = MAX_PATH + 1;
  UINT result = 
     GetSystemDirectory(
        szSystemDir.GetBufferSetLength(bufferSizeInCharacters), 
        bufferSizeInCharacters);

  if (result > MAX_PATH+1)
  {
     // Try again with the correct buffer size

     szSystemDir.ReleaseBuffer();

     bufferSizeInCharacters = result;

     result = 
        GetSystemDirectory(
           szSystemDir.GetBufferSetLength(bufferSizeInCharacters), bufferSizeInCharacters);

     ASSERT(result <= bufferSizeInCharacters);
  }

  szSystemDir.ReleaseBuffer();

  CString szCmd = szSystemDir + L"\\cmd.exe";
  CString szNsLookupCmd = szSystemDir + L"\\cmd.exe /k \"" + szSystemDir + L"\\nslookup.exe - " + GetRPCName() + L"\"";
  
  TRACE(L"%s\n", szNsLookupCmd);

  if (CreateProcess(
            (PCWSTR)szCmd,
            (PWSTR)(PCWSTR)szNsLookupCmd,
            0,
            0,
            false,
            0,
            0,
            0,
            &startup,
            &procInfo))
  {
    CloseHandle(procInfo.hThread);
    CloseHandle(procInfo.hProcess);
  }
  else
  {
    HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
    TRACE(L"CreateProcess failed: hr = 0x%x\n", hr);
  }
}

#ifdef USE_NDNC
void CDNSServerNode::OnCreateNDNC()
{
  // First ask if they want to create the domain NDNC

  USES_CONVERSION;

  do
  {
     DNS_STATUS err = 0;

     CString szDomainNDNC;
     szDomainNDNC.Format(IDS_SERVER_CREATE_DOMAIN_NDNC_FORMAT, UTF8_TO_W(GetDomainName()));

     UINT nResult = DNSMessageBox(szDomainNDNC, MB_YESNOCANCEL | MB_ICONWARNING);
     if (IDCANCEL == nResult)
     {
        // don't do anything more
        break;
     }
     else if (IDYES == nResult)
     {
        // create the domain partition
        
        err = ::DnssrvSetupDefaultDirectoryPartitions(
                   GetRPCName(),
                   DNS_DP_OP_CREATE_DOMAIN);

        if (err != 0)
        {
           DNSErrorDialog(err, IDS_ERRMSG_CREATE_DOMAIN_NDNC);
           break;
        }
     }

     CString szForestNDNC;
     szForestNDNC.Format(IDS_SERVER_CREATE_FOREST_NDNC_FORMAT, UTF8_TO_W(GetForestName()));

     nResult = DNSMessageBox(szForestNDNC, MB_YESNO | MB_ICONWARNING);
     if (IDYES == nResult)
     {
        // create the forest partition
        
        err = ::DnssrvSetupDefaultDirectoryPartitions(
                   GetRPCName(),
                   DNS_DP_OP_CREATE_FOREST);

        if (err != 0)
        {
           DNSErrorDialog(err, IDS_ERRMSG_CREATE_FOREST_NDNC);
           break;
        }
     }

  } while (false);
}
#endif // USE_NDNC

void CDNSServerNode::OnConfigureServer(CComponentDataObject* pComponentData)
{
  CThemeContextActivator activator;

  CDNSServerWizardHolder holder((CDNSRootData*)GetRootContainer(), pComponentData, this);
  holder.DoModalWizard();
  pComponentData->UpdateResultPaneView(this);
}

void CDNSServerNode::SetRecordAging()
{
  CThemeContextActivator activator;

  CDNSZone_AgingDialog dlg(NULL, IDD_SERVER_AGING_DIALOG, ((CDNSRootData*)GetRootContainer())->GetComponentDataObject());

  dlg.m_dwRefreshInterval = GetDefaultRefreshInterval();
  dlg.m_dwNoRefreshInterval = GetDefaultNoRefreshInterval();
  dlg.m_fScavengingEnabled = GetDefaultScavengingState();
  dlg.m_dwDefaultRefreshInterval = GetDefaultRefreshInterval();
  dlg.m_dwDefaultNoRefreshInterval = GetDefaultNoRefreshInterval();
  dlg.m_bDefaultScavengingState = GetDefaultScavengingState();

  if (IDCANCEL == dlg.DoModal())
  {
    return;
  }

  DNS_STATUS dwErr;

  if (dlg.m_dwRefreshInterval != GetDefaultRefreshInterval())
  {
    dwErr = ResetDefaultRefreshInterval(dlg.m_dwRefreshInterval);
    if (dwErr != 0)
    {
      DNSErrorDialog(dwErr, IDS_MSG_SERVER_UPDATE_AGING);
      return;
    }
  }

  if (dlg.m_dwNoRefreshInterval != GetDefaultNoRefreshInterval())
  {
    dwErr = ResetDefaultNoRefreshInterval(dlg.m_dwNoRefreshInterval);
    if (dwErr != 0)
    {
      DNSErrorDialog(dwErr, IDS_MSG_SERVER_UPDATE_AGING);
      return;
    }
  }

  if (dlg.m_fScavengingEnabled != GetDefaultScavengingState())
  {
    DWORD dwScavengingState = DNS_AGING_OFF;
    if (dlg.m_fScavengingEnabled)
    {
      dwScavengingState = DNS_AGING_DS_ZONES;
    }
    dwErr = ResetDefaultScavengingState(dwScavengingState);
    if (dwErr != 0)
    {
      DNSErrorDialog(dwErr, IDS_MSG_SERVER_UPDATE_AGING);
      return;
    }
  }

  BOOL bApplyAll = dlg.m_bADApplyAll;
  if (bApplyAll)
  {
    DWORD dwContextFlags = ZONE_REQUEST_PRIMARY;
    dwContextFlags = dlg.m_bADApplyAll ? dwContextFlags | ZONE_REQUEST_DS : dwContextFlags;

    if (dlg.m_bNoRefreshDirty)
    {
      dwErr = ::DnssrvResetDwordPropertyWithContext(GetRPCName(),
                                                     DNS_ZONE_ALL,
                                                     dwContextFlags,
                                                     DNS_REGKEY_ZONE_NOREFRESH_INTERVAL,
                                                     dlg.m_dwNoRefreshInterval);
      if (dwErr != 0)
      {
        DNSErrorDialog(dwErr, IDS_MSG_SERVER_UPDATE_AGING);
        return;
      }
    }

    if (dlg.m_bRefreshDirty)
    {
      dwErr = ::DnssrvResetDwordPropertyWithContext(GetRPCName(),
                                                     DNS_ZONE_ALL,
                                                     dwContextFlags,
                                                     DNS_REGKEY_ZONE_REFRESH_INTERVAL,
                                                     dlg.m_dwRefreshInterval);
      if (dwErr != 0)
      {
        DNSErrorDialog(dwErr, IDS_MSG_SERVER_UPDATE_AGING);
        return;
      }
    }

    if (dlg.m_bScavengeDirty)
    {
      dwErr = ::DnssrvResetDwordPropertyWithContext(GetRPCName(),
                                                    DNS_ZONE_ALL,
                                                    dwContextFlags,
                                                    DNS_REGKEY_ZONE_AGING,
                                                    dlg.m_fScavengingEnabled);
      if (dwErr != 0)
      {
        DNSErrorDialog(dwErr, IDS_MSG_SERVER_UPDATE_AGING);
        return;
      }
    }
  }
}

void CDNSServerNode::ScavengeRecords()
{
  UINT nRet = DNSConfirmOperation(IDS_MSG_SERVER_CONFIRM_SCAVENGE, this);
  if(IDCANCEL == nRet ||
     IDNO == nRet)
  {
    return;
  }

  DNS_STATUS dwErr = ::DnssrvOperation(GetRPCName(),
                                       NULL,
                                       DNSSRV_OP_START_SCAVENGING,
                                       DNSSRV_TYPEID_NULL,
                                       NULL);
  if (dwErr != 0)
  {
    DNSErrorDialog(dwErr, IDS_MSG_ERROR_SCAVENGE_RECORDS);
    return;
  }
}

int CDNSServerNode::GetImageIndex(BOOL) 
{
	BOOL bSuccess = m_testResultList.LastQuerySuceeded();

	int nIndex = 0;
	switch (m_nState)
	{
	case notLoaded:
		nIndex = bSuccess ? SERVER_IMAGE_NOT_LOADED : SERVER_IMAGE_NOT_LOADED_TEST_FAIL;
		break;
	case loading:
		nIndex = bSuccess ? SERVER_IMAGE_LOADING : SERVER_IMAGE_LOADING_TEST_FAIL;
		break;
	case loaded:
		nIndex = bSuccess ? SERVER_IMAGE_LOADED : SERVER_IMAGE_LOADED_TEST_FAIL;
		break;
	case unableToLoad:
		nIndex = bSuccess ? SERVER_IMAGE_UNABLE_TO_LOAD : SERVER_IMAGE_UNABLE_TO_LOAD_TEST_FAIL;
		break;
	case accessDenied:
		nIndex = bSuccess ? SERVER_IMAGE_ACCESS_DENIED : SERVER_IMAGE_ACCESS_DENIED_TEST_FAIL;
		break;
	default:
		ASSERT(FALSE);
	}
	return nIndex;
}

void CDNSServerNode::OnDelete(CComponentDataObject* pComponentData,
                              CNodeList* pNodeList)
{
  if (pNodeList->GetCount() > 1) // multiple selection
  {
    return;
  }

  UINT nRet = DNSConfirmOperation(IDS_MSG_SERVER_DELETE, this);
	if (IDCANCEL == nRet ||
      IDNO == nRet)
  {
		return;
  }

	if (IsSheetLocked())
	{
		if (!CanCloseSheets())
			return;
		pComponentData->GetPropertyPageHolderTable()->DeleteSheetsOfNode(this);
	}
	ASSERT(!IsSheetLocked());

	// now remove from the UI and from the cache
	DeleteHelper(pComponentData);
	CDNSRootData* pSnapinData = (CDNSRootData*)GetRootContainer();
	pSnapinData->SetDirtyFlag(TRUE);
	pSnapinData->RemoveServerFromThreadList(this, pComponentData);
  pComponentData->UpdateResultPaneView(GetContainer());
	delete this; // gone
}


#define MAX_COMPUTER_DISPLAYNAME_LENGTH 256

HRESULT CDNSServerNode::CreateFromStream(IStream* pStm, CDNSServerNode** ppServerNode)
{
	WCHAR szBuffer[MAX_COMPUTER_DISPLAYNAME_LENGTH];
	ULONG nLen; // WCHAR counting NULL
	ULONG cbRead;

	VERIFY(SUCCEEDED(pStm->Read((void*)&nLen,sizeof(DWORD), &cbRead)));
	ASSERT(cbRead == sizeof(DWORD));
	VERIFY(SUCCEEDED(pStm->Read((void*)szBuffer,sizeof(WCHAR)*nLen, &cbRead)));
	ASSERT(cbRead == sizeof(WCHAR)*nLen);


  BOOL bIsLocalHost = (_wcsicmp(szBuffer, L"localhost.") == 0);
  if (bIsLocalHost)
  {
    //
    // Retrieve the local computer name
    //
    DWORD dwLen = MAX_COMPUTER_DISPLAYNAME_LENGTH;
    BOOL bRes = ::GetComputerName(szBuffer, &dwLen);
    ASSERT(bRes);
  }

	*ppServerNode = new CDNSServerNode(szBuffer, bIsLocalHost);
	if (*ppServerNode)
   {
	   VERIFY(SUCCEEDED((*ppServerNode)->m_testOptions.Load(pStm)));
   }
	return S_OK;
}

HRESULT CDNSServerNode::SaveToStream(IStream* pStm)
{
	// for each server name, write # of chars+NULL, and then the name
	DWORD cbWrite = 0;
	DWORD nLen = 0;
  static PCWSTR pszLocalHost = L"localhost.";

  if (IsLocalServer())
  {
    nLen = static_cast<DWORD>(wcslen(pszLocalHost) + 1);
	  VERIFY(SUCCEEDED(pStm->Write((void*)&nLen, sizeof(DWORD),&cbWrite)));
	  ASSERT(cbWrite == sizeof(DWORD));
	  VERIFY(SUCCEEDED(pStm->Write((void*)(pszLocalHost), sizeof(WCHAR)*nLen,&cbWrite)));
	  ASSERT(cbWrite == sizeof(WCHAR)*nLen);
  }
  else
  {
    nLen = static_cast<DWORD>(wcslen(GetDisplayName())+1); // WCHAR including NULL
	  VERIFY(SUCCEEDED(pStm->Write((void*)&nLen, sizeof(DWORD),&cbWrite)));
	  ASSERT(cbWrite == sizeof(DWORD));
	  VERIFY(SUCCEEDED(pStm->Write((void*)(GetDisplayName()), sizeof(WCHAR)*nLen,&cbWrite)));
	  ASSERT(cbWrite == sizeof(WCHAR)*nLen);
  }

	VERIFY(SUCCEEDED(m_testOptions.Save(pStm)));
	return S_OK;
}

HRESULT CDNSServerNode::OnNewZone(CComponentDataObject* pComponentData, CNodeList*)
{
   CThemeContextActivator activator;

	ASSERT(pComponentData != NULL);
	ASSERT(pComponentData != NULL);

	CDNSZoneWizardHolder holder(pComponentData);
	
	holder.Initialize(this);
	holder.DoModalWizard();
  return S_OK;
}

void CDNSServerNode::OnUpdateDataFiles(CComponentDataObject* pComponentData)
{
	// if there are sheets up, ask to close them down, because a
	// failure would "Red X" the server and remove all the children
	if (IsSheetLocked())
	{
		if (!CanCloseSheets())
			return;
		pComponentData->GetPropertyPageHolderTable()->DeleteSheetsOfNode(this);
	}

	OnChangeState(pComponentData); // move to loading
	m_dwErr = WriteDirtyZones();

	// if there is a failure, remove all children,
	// will need a refresh to get them back
	if (m_dwErr != 0)
	{
		RemoveAllChildrenHelper(pComponentData);
		ASSERT(!HasChildren());
	}
	OnChangeState(pComponentData); // move to loaded or unableToLoad
}


void CDNSServerNode::OnClearCache(CComponentDataObject* pComponentData)
{
  // if there is a cache folder and it is not hidden, delegate to it
  if ((m_pCacheFolderNode != NULL) && ((m_pCacheFolderNode->GetFlags() & TN_FLAG_HIDDEN) == 0))
  {
    m_pCacheFolderNode->OnClearCache(pComponentData);
    return;
  }

  // directly call into the server
  DNS_STATUS err;
  { // scope for wait cursor
    CWaitCursor wait;
	  err = ClearCache();
  }
  if (err != 0)
  {
    // need to let the user know the operation failed
    DNSErrorDialog(err, IDS_MSG_SERVER_FAIL_CLEAR_CACHE);
    return;
  }

  if (m_pCacheFolderNode != NULL)
  {
    ASSERT(m_pCacheFolderNode->GetFlags() & TN_FLAG_HIDDEN);
    // the cache folder is there, but hidden, so we just have
    // to call the API and remove its children
    m_pCacheFolderNode->RemoveAllChildrenFromList();
  }

}


BOOL CDNSServerNode::HasPropertyPages(DATA_OBJECT_TYPES, 
                                      BOOL* pbHideVerb,
                                      CNodeList* pNodeList)
{
  if (pNodeList->GetCount() > 1) // multiple selection
  {
    return FALSE;
  }

	*pbHideVerb = FALSE; // always show the verb
	// cannot have property pages  when in loading, notLoaded, or the thread lock state
	return (!IsThreadLocked() && (m_nState != notLoaded) && (m_nState != loading));
}



HRESULT CDNSServerNode::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, 
                                            LONG_PTR handle,
                                            CNodeList* pNodeList)
{
   ASSERT(pNodeList->GetCount() == 1); // multi-select not support
	ASSERT(m_nState != loading);

   return CreatePropertyPagesHelper(lpProvider, handle, m_nStartProppage);
}

HRESULT CDNSServerNode::CreatePropertyPagesHelper(LPPROPERTYSHEETCALLBACK lpProvider, 
									LONG_PTR handle, long nStartProppage)
{
   CWaitCursor wait;

	CComponentDataObject* pComponentDataObject = 
			((CRootData*)(GetContainer()->GetRootContainer()))->GetComponentDataObject();
	ASSERT(pComponentDataObject != NULL);

	if (GetSheetCount() > 0)
	{
		pComponentDataObject->GetPropertyPageHolderTable()->BroadcastSelectPage(this, nStartProppage);
		return S_OK;
   }	

   //
   // Refresh the domain forwarders node under the server so that it has current data,
   // but do it manually since we have to enumerate synchronously
   //
   CDNSDomainForwardersNode* pDomainForwardersNode = GetDomainForwardersNode();
   if (pDomainForwardersNode != NULL)
   {
      pDomainForwardersNode->RemoveAllChildrenHelper(pComponentDataObject);
      pDomainForwardersNode->OnEnumerate(pComponentDataObject, FALSE);
   }

   HRESULT hr = S_OK;

   CDNSServerPropertyPageHolder* pHolder = 
	   new CDNSServerPropertyPageHolder((CDNSRootData*)GetContainer(), this, pComponentDataObject);
   
   if (pHolder)
   {
      pHolder->SetStartPageCode(nStartProppage);
      pHolder->SetSheetTitle(IDS_PROP_SHEET_TITLE_FMT, this);
      hr = pHolder->CreateModelessSheet(lpProvider, handle);
   }
   else
   {
      hr = E_OUTOFMEMORY;
   }
   return hr;
}

void CDNSServerNode::DecrementSheetLockCount()
{
  CTreeNode::DecrementSheetLockCount();
  m_nStartProppage = -1;
}


BOOL CDNSServerQueryObj::Enumerate()
{
	// query the server to find out if it has a cache
  BOOL bHasRootZone = FALSE;
  DNS_STATUS err = ::ServerHasRootZone(m_szServerName, &bHasRootZone);

	if (err != 0)
	{
		OnError(err);
		return FALSE; // failed to get answer
	}

	CDNSRootHintsNode* pRootHintsNode = NULL;
	// if there is not a root zone, the server is not authoritated for the root
	// so create the root hints folder and ask it to query for NS and A records
	if (!bHasRootZone)
	{
		pRootHintsNode = new CDNSRootHintsNode;
      if (pRootHintsNode)
      {
         err = pRootHintsNode->QueryForRootHints(m_szServerName, m_dwServerVersion);
      }
      else
      {
         err = ERROR_OUTOFMEMORY;
      }

      if (err != 0)
      {
         //
         // NOTE: permissions are different for the Root Hints so we will
         //       fail this silently
         //
// 	   OnError(err);
			delete pRootHintsNode;
		   pRootHintsNode = NULL;
//			   return FALSE; // failed in the query, exit without putting folders
      }
	}

	// get server info
	CDNSServerInfoEx* pServerInfoEx = new CDNSServerInfoEx;

   if (!pServerInfoEx)
   {
      OnError(ERROR_OUTOFMEMORY);
      delete pRootHintsNode;

      return FALSE;
   }

	err = pServerInfoEx->Query(m_szServerName);
	if (err != 0)
	{
		OnError(err);
		delete pServerInfoEx;
		pServerInfoEx = NULL;
		if (pRootHintsNode != NULL)
		{
			delete pRootHintsNode;
			pRootHintsNode = NULL;
		}
		return FALSE; // stop if could not get server info
	}

	// all went well, finally send data
	VERIFY(AddQueryResult(pServerInfoEx)); // server info data

	
	if (!bHasRootZone)
	{
		ASSERT(pRootHintsNode != NULL);
		VERIFY(AddQueryResult(pRootHintsNode));
	}

  //
	// create cache data folder
  //
   CDNSCacheNode* pCache = new CDNSCacheNode;
   if (pCache)
   {
	   VERIFY(AddQueryResult(pCache));
   }

  //
	// create the fwd/rev lookup zones folders
  //
   CDNSForwardZonesNode* pForward = new CDNSForwardZonesNode;
   if (pForward)
   {
	   VERIFY(AddQueryResult(pForward));
   }

   CDNSReverseZonesNode* pRev = new CDNSReverseZonesNode;
   if (pRev)
   {
	   VERIFY(AddQueryResult(pRev));
   }

  //
  // Always add the domain forwarders folder here so that it can be enumerated immediately
  //
  CDNSDomainForwardersNode* pDomainForwarders = new CDNSDomainForwardersNode;
  if (pDomainForwarders)
  {
     VERIFY(AddQueryResult(pDomainForwarders));
  }

  // Create and add the visible leaves that represent the Root Hints and Forwarders

  CDNSServerOptionNode* pRootHintsOptionNode = new CDNSServerOptionNode(IDS_ROOT_HINTS_NODE_DISPLAY_NAME, RR_ROOTHINTS_TAB);
  if (pRootHintsOptionNode)
  {
     VERIFY(AddQueryResult(pRootHintsOptionNode));
  }

  CDNSServerOptionNode* pForwardersNode = new CDNSServerOptionNode(IDS_FORWARDERS_NODE_DISPLAY_NAME, RR_FORWARDERS_TAB);
  if (pForwardersNode)
  {
     VERIFY(AddQueryResult(pForwardersNode));
  }

	return FALSE; // end thread
}

HRESULT CDNSServerNode::GetResultViewType(CComponentDataObject*, 
                                          LPOLESTR *ppViewType, 
                                          long *pViewOptions)
{
  HRESULT hr = S_FALSE;

  if ((!IsServerConfigured()   || 
       m_nState == accessDenied || 
       m_nState == unableToLoad ||
       !m_testResultList.LastQuerySuceeded()) && 
      m_bShowMessages)
  {
    *pViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS;

    LPOLESTR psz = NULL;
    StringFromCLSID(CLSID_MessageView, &psz);

    USES_CONVERSION;

    if (psz != NULL)
    {
      *ppViewType = psz;
      hr = S_OK;
    }
  }
  else
  {
	  *pViewOptions = MMC_VIEW_OPTIONS_NONE;
	  *ppViewType = NULL;
    hr = S_FALSE;
  }
  return hr;
}

HRESULT CDNSServerNode::OnShow(LPCONSOLE lpConsole)
{
  CComPtr<IUnknown> spUnknown;
  CComPtr<IMessageView> spMessageView;

  HRESULT hr = lpConsole->QueryResultView(&spUnknown);
  if (FAILED(hr))
    return S_OK;

  hr = spUnknown->QueryInterface(IID_IMessageView, (PVOID*)&spMessageView);
  if (SUCCEEDED(hr))
  {
    CString szTitle, szMessage;
    IconIdentifier iconID;

    if (!IsServerConfigured())
    {
      VERIFY(szTitle.LoadString(IDS_MESSAGE_VIEW_CONFIG_SERVER_TITLE));
      VERIFY(szMessage.LoadString(IDS_MESSAGE_VIEW_CONFIG_SERVER_MESSAGE));
      iconID = Icon_Information;
    }
    else if (m_testResultList.LastQuerySuceeded())
    {
      if (m_nState == accessDenied)
      {
        VERIFY(szTitle.LoadString(IDS_MESSAGE_VIEW_ACCESS_DENIED_TITLE));
        VERIFY(szMessage.LoadString(IDS_MESSAGE_VIEW_ACCESS_DENIED_MESSAGE));
        iconID = Icon_Error;
      }
      else // Unable to load and other unknown errors
      {
        VERIFY(szTitle.LoadString(IDS_MESSAGE_VIEW_NOT_LOADED_TITLE));
        VERIFY(szMessage.LoadString(IDS_MESSAGE_VIEW_NOT_LOADED_MESSAGE));
        iconID = Icon_Error;
      }
    }
    else
    {
      VERIFY(szTitle.LoadString(IDS_MESSAGE_VIEW_QUERY_FAILED_TITLE));
      VERIFY(szMessage.LoadString(IDS_MESSAGE_VIEW_QUERY_FAILED_MESSAGE));
      iconID = Icon_Error;
    }
    spMessageView->SetTitleText(szTitle);
    spMessageView->SetBodyText(szMessage);
    spMessageView->SetIcon(iconID);
  }
  
  return S_OK;
}

CQueryObj* CDNSServerNode::OnCreateQuery()
{
	CDNSRootData* pRootData = (CDNSRootData*)GetRootContainer();
	ASSERT(pRootData != NULL);
	CDNSServerQueryObj* pQuery = 
		new CDNSServerQueryObj(pRootData->IsAdvancedView(), 0x0 /*version not known yet*/);

   if (pQuery)
   {
	   pQuery->m_szServerName = m_szDisplayName;
   }
	return pQuery;
}

BOOL CDNSServerNode::OnRefresh(CComponentDataObject* pComponentData,
                               CNodeList* pNodeList)
{
  if (pNodeList->GetCount() > 1) // multiple selection
  {
    BOOL bRet = TRUE;

    POSITION pos = pNodeList->GetHeadPosition();
    while (pos != NULL)
    {
      CTreeNode* pNode = pNodeList->GetNext(pos);
      ASSERT(pNode != NULL);

      CNodeList nodeList;
      nodeList.AddTail(pNode);
      if (!pNode->OnRefresh(pComponentData, &nodeList))
      {
        bRet = FALSE;
      }
    }
    return bRet;
  }

  //
  // Single selections
  //
	if (CMTContainerNode::OnRefresh(pComponentData, pNodeList))
	{
		m_pCacheFolderNode = NULL;
		m_pFwdZonesFolderNode = NULL;
		m_pRevZonesFolderNode = NULL;
      m_pDomainForwardersFolderNode = NULL;
		FreeRootHints();
		FreeServInfo();
		return TRUE;
	}
	return FALSE;
}



void CDNSServerNode::OnHaveData(CObjBase* pObj, CComponentDataObject* pComponentDataObject)
{
	// the first message coming should be server info struct, not kept in the list of children
	if (IS_CLASS(*pObj, CDNSServerInfoEx))
	{
		AttachServerInfo(dynamic_cast<CDNSServerInfoEx*>(pObj));
		return;
	}

	// the root hints node is special and not kept in the list of children
	if (IS_CLASS(*pObj, CDNSRootHintsNode))
	{
    CDNSRootHintsNode* pNewRootHints = dynamic_cast<CDNSRootHintsNode*>(pObj);
    if (pNewRootHints != NULL)
    {
      AttachRootHints(pNewRootHints);
    }
		ASSERT(m_pRootHintsNode != NULL);
		return;
	}

	// set cached pointers for fdw/rev zones folders
	if (IS_CLASS(*pObj, CDNSForwardZonesNode))
	{
		ASSERT(m_pFwdZonesFolderNode == NULL);
		m_pFwdZonesFolderNode = dynamic_cast<CDNSForwardZonesNode*>(pObj);
		ASSERT(m_pFwdZonesFolderNode != NULL);
	}
	else if (IS_CLASS(*pObj, CDNSReverseZonesNode))
	{
		ASSERT(m_pRevZonesFolderNode == NULL);
		m_pRevZonesFolderNode = dynamic_cast<CDNSReverseZonesNode*>(pObj);
		ASSERT(m_pRevZonesFolderNode != NULL);
	}
	else if (IS_CLASS(*pObj, CDNSCacheNode))
	{
    //
		// the cache folder node can be shown or not, depending on the view options
    //
		ASSERT(m_pCacheFolderNode == NULL);
		m_pCacheFolderNode = dynamic_cast<CDNSCacheNode*>(pObj);
		ASSERT(m_pCacheFolderNode != NULL);
		CDNSRootData* pRootData = (CDNSRootData*)pComponentDataObject->GetRootData();
		if (!pRootData->IsAdvancedView())
		{
			m_pCacheFolderNode->SetFlagsDown(TN_FLAG_HIDDEN,TRUE); // mark it hidden, will not be added to UI
		}
	}
  else if (IS_CLASS(*pObj, CDNSDomainForwardersNode))
  {
    //
    // The domain forwarders node should never be shown
    //
    ASSERT(m_pDomainForwardersFolderNode == NULL);
    m_pDomainForwardersFolderNode = dynamic_cast<CDNSDomainForwardersNode*>(pObj);
    ASSERT(m_pDomainForwardersFolderNode != NULL);

    //
    // Make sure its hidden in the UI
    //
    m_pDomainForwardersFolderNode->SetFlagsDown(TN_FLAG_HIDDEN, TRUE);
  }

	CDNSMTContainerNode::OnHaveData(pObj,pComponentDataObject);
}

BOOL CDNSServerNode::OnAddMenuItem(LPCONTEXTMENUITEM2 pContextMenuItem2,
								                   long*)
{
	// gray out commands that need data from the server
	if ((m_nState != loaded) && 
       ((pContextMenuItem2->lCommandID == IDM_SERVER_CONFIGURE) ||
        (pContextMenuItem2->lCommandID == IDM_SERVER_NEW_ZONE) ||
        (pContextMenuItem2->lCommandID == IDM_SERVER_UPDATE_DATA_FILES) ||
        (pContextMenuItem2->lCommandID == IDM_SERVER_CLEAR_CACHE) ||
        (pContextMenuItem2->lCommandID == IDM_SERVER_SET_AGING) ||
        (pContextMenuItem2->lCommandID == IDM_SERVER_SCAVENGE) 
#ifdef USE_NDNC
        ||(pContextMenuItem2->lCommandID == IDM_SERVER_CREATE_NDNC)
#endif
       ))
	{
		pContextMenuItem2->fFlags |= MF_GRAYED;
	}

#ifdef USE_NDNC
  if ((pContextMenuItem2->lCommandID == IDM_SERVER_CREATE_NDNC) &&
      (m_nState != loaded ||
       !CanUseADS() ||
       GetBuildNumber() < DNS_SRV_BUILD_NUMBER_WHISTLER ||
       (GetMajorVersion() <= DNS_SRV_MAJOR_VERSION_NT_5 &&
        GetMinorVersion() < DNS_SRV_MINOR_VERSION_WHISTLER)))
  {
    return FALSE;
  }
#endif

  // this command might cause a refresh
  if ( IsThreadLocked() && (pContextMenuItem2->lCommandID == IDM_SERVER_CLEAR_CACHE))
	{
		pContextMenuItem2->fFlags |= MF_GRAYED;
	}

  // add toggle menu item for advanced view
	if (pContextMenuItem2->lCommandID == IDM_SNAPIN_ADVANCED_VIEW)
  {
    pContextMenuItem2->fFlags = ((CDNSRootData*)GetRootContainer())->IsAdvancedView() ? MF_CHECKED : 0;
    return TRUE;
  }
  if (pContextMenuItem2->lCommandID == IDM_SNAPIN_FILTERING)
  {
		if (((CDNSRootData*)GetRootContainer())->IsFilteringEnabled())
		{
			pContextMenuItem2->fFlags = MF_CHECKED;
		}
		return TRUE;
  }

  if (pContextMenuItem2->lCommandID == IDM_SNAPIN_MESSAGE)
  {
    if (m_bShowMessages)
    {
      pContextMenuItem2->fFlags = MF_CHECKED;
    }
  }
	return TRUE;
}

BOOL CDNSServerNode::OnSetDeleteVerbState(DATA_OBJECT_TYPES, 
                                          BOOL* pbHide,
                                          CNodeList* pNodeList)
{
  if (pNodeList->GetCount() > 1) // multiple selection
  {
    *pbHide = TRUE;
    return FALSE;
  }

	if (((CDNSRootData*)GetRootContainer())->GetComponentDataObject()->IsExtensionSnapin())
	{
		// for extensions, remove the delete verb
		*pbHide = TRUE;
		return FALSE; // disable
	}

	*pbHide = FALSE;
	TRACE(_T("CDNSServerNode::OnSetDeleteVerbState() IsThreadLocked() == %d\n"),
		IsThreadLocked());
	return !IsThreadLocked();
}

BOOL CDNSServerNode::OnSetRefreshVerbState(DATA_OBJECT_TYPES, 
                                           BOOL* pbHide,
                                           CNodeList*)
{
	*pbHide = FALSE;
	return !IsThreadLocked();
}

CDNSZoneNode* CDNSServerNode::GetNewZoneNode()
{
	CDNSZoneNode* pZoneNode = new CDNSZoneNode();
	if (pZoneNode)
   {
	   pZoneNode->SetServerNode(this);
   }
	return pZoneNode;
}

#ifdef USE_NDNC
DNS_STATUS CDNSServerNode::CreatePrimaryZone(LPCTSTR lpszName, LPCTSTR lpszFileName,
											 BOOL bLoadExisting,
											 BOOL bFwd,
											 BOOL bDSIntegrated,
                       UINT nDynamicUpdate,
											 CComponentDataObject* pComponentData,
                       ReplicationType replType,
                       PCWSTR pszPartitionName)
{
	CDNSRootData* pRootData = (CDNSRootData*)pComponentData->GetRootData();
	ASSERT(pRootData != NULL);
	CDNSZoneNode* pZoneNode = GetNewZoneNode();
	pZoneNode->SetNames(TRUE /* isZone*/, !bFwd, pRootData->IsAdvancedView(), 
			lpszName, lpszName);
	
	DNS_STATUS err = 0;
  if (bDSIntegrated && !(replType == none || replType == w2k))
  {
    err = pZoneNode->CreatePrimaryInDirectoryPartition(bLoadExisting,
                                                       nDynamicUpdate,
                                                       replType,
                                                       pszPartitionName);
  }
  else
  {
    err = pZoneNode->CreatePrimary(lpszFileName, bLoadExisting, bDSIntegrated, nDynamicUpdate);
  }

	if (err != 0)
	{
		// fail
		delete pZoneNode;
		return err;
	}
	// succeeded, need to add to the UI, if possible
	if (IsExpanded())
	{
		CCathegoryFolderNode* pCathegoryFolder = GetAuthoritatedZoneFolder(bFwd);
		if ( (pCathegoryFolder != NULL) && pCathegoryFolder->IsEnumerated() )
    {
			VERIFY(pCathegoryFolder->AddChildToListAndUI(pZoneNode, pComponentData));
      pComponentData->SetDescriptionBarText(pCathegoryFolder);
    } 
		else
    {
			delete pZoneNode; // the enumeration will add it
    }
	}
	else
	{
		delete pZoneNode; // the expansion will get the zone from the RPC when expanding subfolders
	}
	return err;
}
#else
DNS_STATUS CDNSServerNode::CreatePrimaryZone(LPCTSTR lpszName, LPCTSTR lpszFileName,
											 BOOL bLoadExisting,
											 BOOL bFwd,
											 BOOL bDSIntegrated,
                       UINT nDynamicUpdate,
											 CComponentDataObject* pComponentData)
{
	CDNSRootData* pRootData = (CDNSRootData*)pComponentData->GetRootData();
	ASSERT(pRootData != NULL);
	CDNSZoneNode* pZoneNode = GetNewZoneNode();
	pZoneNode->SetNames(TRUE /* isZone*/, !bFwd, pRootData->IsAdvancedView(), 
			lpszName, lpszName);
	
	DNS_STATUS err = pZoneNode->CreatePrimary(lpszFileName, bLoadExisting, bDSIntegrated, nDynamicUpdate);
	if (err != 0)
	{
		// fail
		delete pZoneNode;
		return err;
	}
	// succeeded, need to add to the UI, if possible
	if (IsExpanded())
	{
		CCathegoryFolderNode* pCathegoryFolder = GetAuthoritatedZoneFolder(bFwd);
		if ( (pCathegoryFolder != NULL) && pCathegoryFolder->IsEnumerated() )
    {
			VERIFY(pCathegoryFolder->AddChildToListAndUI(pZoneNode, pComponentData));
      pComponentData->SetDescriptionBarText(pCathegoryFolder);
    } 
		else
    {
			delete pZoneNode; // the enumeration will add it
    }
	}
	else
	{
		delete pZoneNode; // the expansion will get the zone from the RPC when expanding subfolders
	}
	return err;
}
#endif //USE_NDNC

DNS_STATUS CDNSServerNode::CreateSecondaryZone(LPCTSTR lpszName, LPCTSTR lpszFileName, 
											   BOOL bLoadExisting, BOOL bFwd,
				DWORD* ipMastersArray, int nIPMastersCount, CComponentDataObject* pComponentData)
{
	CDNSRootData* pRootData = (CDNSRootData*)pComponentData->GetRootData();
	ASSERT(pRootData != NULL);
	CDNSZoneNode* pZoneNode = GetNewZoneNode();
	pZoneNode->SetNames(TRUE /* isZone*/, !bFwd, pRootData->IsAdvancedView(), 
			lpszName, lpszName);
	
	DNS_STATUS err = pZoneNode->CreateSecondary(ipMastersArray, nIPMastersCount, 
												lpszFileName, bLoadExisting);
	if (err != 0)
	{
		// fail
		delete pZoneNode;
		return err;
	}
	// succeeded, need to add to the UI, if possible
	if (IsExpanded())
	{
		CCathegoryFolderNode* pCathegoryFolder = GetAuthoritatedZoneFolder(bFwd);
		if ( (pCathegoryFolder != NULL) && pCathegoryFolder->IsEnumerated() )
    {
			VERIFY(pCathegoryFolder->AddChildToListAndUI(pZoneNode, pComponentData));
      pComponentData->SetDescriptionBarText(pCathegoryFolder);
    }
		else
    {
			delete pZoneNode; // the enumeration will add it
    }
	}
	else 
	{
		delete pZoneNode; // the expansion will get the zone from the RPC when expanding subfolders
	}
	return err;
}

#ifdef USE_NDNC
DNS_STATUS CDNSServerNode::CreateStubZone(LPCTSTR lpszName, 
                                          LPCTSTR lpszFileName, 
											                    BOOL bLoadExisting, 
                                          BOOL bDSIntegrated,
                                          BOOL bFwd,
				                                  DWORD* ipMastersArray, 
                                          int nIPMastersCount, 
                                          BOOL bLocalListOfMasters,
                                          CComponentDataObject* pComponentData,
                                          ReplicationType replType,
                                          PCWSTR pszPartitionName)
{
	CDNSRootData* pRootData = (CDNSRootData*)pComponentData->GetRootData();
	ASSERT(pRootData != NULL);
	CDNSZoneNode* pZoneNode = GetNewZoneNode();
	pZoneNode->SetNames(TRUE /* isZone*/, !bFwd, pRootData->IsAdvancedView(), 
			lpszName, lpszName);
	
  USES_CONVERSION;

	DNS_STATUS err = 0;
  if (bDSIntegrated && !(replType == none || replType == w2k))
  {
    err = pZoneNode->CreateStubInDirectoryPartition(ipMastersArray,
                                                    nIPMastersCount,
                                                    bLoadExisting,
                                                    replType,
                                                    pszPartitionName);
  }
  else
  {
    err = pZoneNode->CreateStub(ipMastersArray, 
                                nIPMastersCount, 
  										          lpszFileName, 
                                bLoadExisting, 
                                bDSIntegrated);
  }

	if (err != 0)
	{
		// fail
		delete pZoneNode;
		return err;
	}

	// succeeded, need to add to the UI, if possible
	if (IsExpanded())
	{
		CCathegoryFolderNode* pCathegoryFolder = GetAuthoritatedZoneFolder(bFwd);
		if ( (pCathegoryFolder != NULL) && pCathegoryFolder->IsEnumerated() )
    {
			VERIFY(pCathegoryFolder->AddChildToListAndUI(pZoneNode, pComponentData));
      pComponentData->SetDescriptionBarText(pCathegoryFolder);
    }
		else
    {
			delete pZoneNode; // the enumeration will add it
    }
	}
	else 
	{
		delete pZoneNode; // the expansion will get the zone from the RPC when expanding subfolders
	}

  //
  // Change to the local list of masters after the zone has been created
  //
  if (bLocalListOfMasters)
  {
    err = ::DnssrvResetZoneMastersEx(GetRPCName(),	  // Server name
                                     W_TO_UTF8(pZoneNode->GetFullName()),				// Zone name
                                     nIPMastersCount,
                                     ipMastersArray,
                                     TRUE);           // LocalListOfMasters
    if (err != 0)
      return err;
  }
  else
  {
    /*
    err = ::DnssrvResetZoneMastersEx(GetRPCName(),	  // Server name
                                     W_TO_UTF8(pZoneNode->GetFullName()),				// Zone name
                                     0,
                                     NULL,
                                     TRUE);           // LocalListOfMasters
    if (err != 0)
      return err;
      */
  }

  return err;
}
#else
DNS_STATUS CDNSServerNode::CreateStubZone(LPCTSTR lpszName, 
                                          LPCTSTR lpszFileName, 
											                    BOOL bLoadExisting, 
                                          BOOL bDSIntegrated,
                                          BOOL bFwd,
				                                  DWORD* ipMastersArray, 
                                          int nIPMastersCount, 
                                          BOOL bLocalListOfMasters,
                                          CComponentDataObject* pComponentData)
{
	CDNSRootData* pRootData = (CDNSRootData*)pComponentData->GetRootData();
	ASSERT(pRootData != NULL);
	CDNSZoneNode* pZoneNode = GetNewZoneNode();
	pZoneNode->SetNames(TRUE /* isZone*/, !bFwd, pRootData->IsAdvancedView(), 
			lpszName, lpszName);
	
  USES_CONVERSION;

	DNS_STATUS err = pZoneNode->CreateStub(ipMastersArray, 
                                nIPMastersCount, 
  										          lpszFileName, 
                                bLoadExisting, 
                                bDSIntegrated);
	if (err != 0)
	{
		// fail
		delete pZoneNode;
		return err;
	}

	// succeeded, need to add to the UI, if possible
	if (IsExpanded())
	{
		CCathegoryFolderNode* pCathegoryFolder = GetAuthoritatedZoneFolder(bFwd);
		if ( (pCathegoryFolder != NULL) && pCathegoryFolder->IsEnumerated() )
    {
			VERIFY(pCathegoryFolder->AddChildToListAndUI(pZoneNode, pComponentData));
      pComponentData->SetDescriptionBarText(pCathegoryFolder);
    }
		else
    {
			delete pZoneNode; // the enumeration will add it
    }
	}
	else 
	{
		delete pZoneNode; // the expansion will get the zone from the RPC when expanding subfolders
	}

  //
  // Change to the local list of masters after the zone has been created
  //
  if (bLocalListOfMasters)
  {
    err = ::DnssrvResetZoneMastersEx(GetRPCName(),	  // Server name
                                     W_TO_UTF8(pZoneNode->GetFullName()),				// Zone name
                                     nIPMastersCount,
                                     ipMastersArray,
                                     TRUE);           // LocalListOfMasters
    if (err != 0)
      return err;
  }
  else
  {
    /*
    err = ::DnssrvResetZoneMastersEx(GetRPCName(),	  // Server name
                                     W_TO_UTF8(pZoneNode->GetFullName()),				// Zone name
                                     0,
                                     NULL,
                                     TRUE);           // LocalListOfMasters
    if (err != 0)
      return err;
      */
  }

  return err;
}
#endif // USE_NDNC

DNS_STATUS CDNSServerNode::CreateForwarderZone(LPCTSTR lpszName, 
				                                       DWORD* ipMastersArray, 
                                               int nIPMastersCount, 
                                               DWORD dwTimeout,
                                               DWORD fSlave,
                                               CComponentDataObject* pComponentData)
{
	CDNSRootData* pRootData = (CDNSRootData*)pComponentData->GetRootData();
	ASSERT(pRootData != NULL);
	CDNSZoneNode* pZoneNode = GetNewZoneNode();
	pZoneNode->SetNames(TRUE /* isZone*/, 
                      TRUE, 
                      pRootData->IsAdvancedView(), 
			                lpszName, 
                      lpszName);
	
	DNS_STATUS err = pZoneNode->CreateForwarder(ipMastersArray, 
                                              nIPMastersCount,
                                              dwTimeout,
                                              fSlave);
	if (err != 0)
	{
    //
		// fail
    //
		delete pZoneNode;
		return err;
	}

  //
	// succeeded, need to add to the UI, if possible
  //
	if (IsExpanded())
	{
		CCathegoryFolderNode* pCathegoryFolder = GetDomainForwardersNode();
		if ( (pCathegoryFolder != NULL) && pCathegoryFolder->IsEnumerated() )
    {
			VERIFY(pCathegoryFolder->AddChildToListAndUI(pZoneNode, pComponentData));
      pComponentData->SetDescriptionBarText(pCathegoryFolder);
    }
		else
    {
			delete pZoneNode; // the enumeration will add it
    }
	}
	else 
	{
		delete pZoneNode; // the expansion will get the zone from the RPC when expanding subfolders
	}
	return err;
}


DNS_STATUS CDNSServerNode::WriteDirtyZones()
{
	USES_CONVERSION;
	return ::DnssrvWriteDirtyZones(GetServerNode()->GetRPCName());
}

BOOL CDNSServerNode::CanUseADS()
{
	ASSERT(m_pServInfoEx->m_pServInfo != NULL);
	if (GetMajorVersion() <= DNS_SRV_MAJOR_VERSION_NT_4)
		return FALSE;
	return m_pServInfoEx->m_pServInfo->fDsAvailable;
}

DWORD CDNSServerNode::GetVersion()
{
	ASSERT(m_pServInfoEx->m_pServInfo != NULL);
  if (m_pServInfoEx->m_pServInfo != NULL)
  {
	  return m_pServInfoEx->m_pServInfo->dwVersion;
  }
  return (DWORD)-1;
}

DWORD CDNSServerNode::GetForestVersion()
{
   if (m_pServInfoEx &&
       m_pServInfoEx->m_pServInfo)
   {
      return m_pServInfoEx->m_pServInfo->dwDsForestVersion;
   }

   return 0;
}

DWORD CDNSServerNode::GetDomainVersion()
{
   if (m_pServInfoEx &&
       m_pServInfoEx->m_pServInfo)
   {
      return m_pServInfoEx->m_pServInfo->dwDsDomainVersion;
   }

   return 0;
}

void _CopyStringAndFree(CString& sz, LPWSTR lpsz)
{
	sz = lpsz;
	if (lpsz)
		::DnssrvFreeRpcBuffer((PDNS_RPC_BUFFER)lpsz);
}

void _LdapPathFromX500(CString& szLdap, PDNS_RPC_SERVER_INFO pInfo, LPCWSTR lpszX500Name)
{
  ASSERT(pInfo != NULL);
  ASSERT(pInfo->pszServerName != NULL);
  USES_CONVERSION;
  LPCWSTR lpszServerName = UTF8_TO_W(pInfo->pszServerName);
  szLdap.Format(L"LDAP://%s/%s", lpszServerName, lpszX500Name);
}


void CDNSServerNode::CreateDsServerLdapPath(CString& sz)
{
	ASSERT(m_pServInfoEx != NULL);
	ASSERT(m_pServInfoEx->m_pServInfo != NULL);
	if (m_pServInfoEx->m_pServInfo != NULL)
	{
    CString szX500;
		_CopyStringAndFree(szX500,::DnssrvCreateDsServerName(m_pServInfoEx->m_pServInfo));
    CreateLdapPathFromX500Name(szX500, sz);
	}
	else 
		sz.Empty();
}

void CDNSServerNode::CreateDsZoneLdapPath(CDNSZoneNode* pZoneNode, CString& sz)
{
   sz.Empty();

   CString temp;
   CreateDsZoneName(pZoneNode, temp);

   if (!temp.IsEmpty())
   {
      CreateLdapPathFromX500Name(temp, sz);
   }
}

void CDNSServerNode::CreateDsZoneName(CDNSZoneNode* pZoneNode, CString& sz)
{
  PCWSTR pszDN = pZoneNode->GetDN();

   if (!pszDN)
   {

	   ASSERT(m_pServInfoEx != NULL);
	   ASSERT(m_pServInfoEx->m_pServInfo != NULL);
	   if (m_pServInfoEx->m_pServInfo != NULL)
	   {
		   _CopyStringAndFree(sz, ::DnssrvCreateDsZoneName(m_pServInfoEx->m_pServInfo,
								   (LPWSTR)pZoneNode->GetFullName()));
	   }
	   else 
      {
		   sz.Empty();
      }
   }
   else
   {
      sz = pszDN;
   }

}


void CDNSServerNode::CreateDsNodeLdapPath(CDNSZoneNode* pZoneNode, CDNSDomainNode* pDomainNode, CString& sz)
{
	ASSERT(m_pServInfoEx != NULL);
	ASSERT(m_pServInfoEx->m_pServInfo != NULL);
	if (m_pServInfoEx->m_pServInfo != NULL)
	{
    // need to get the relative path of the node wrt the zone
    size_t nZoneLen = wcslen(pZoneNode->GetFullName());
    size_t nDomainLen = wcslen(pDomainNode->GetFullName());
    size_t nRelativeNameLen = nDomainLen - nZoneLen - 1; // remove a dot

    CString szRelativeName(pDomainNode->GetFullName(), static_cast<int>(nRelativeNameLen));

    CString szX500;
		_CopyStringAndFree(szX500, ::DnssrvCreateDsNodeName(m_pServInfoEx->m_pServInfo,
													(LPWSTR)pZoneNode->GetFullName(),
													(LPWSTR)(LPCWSTR)szRelativeName));
    CreateLdapPathFromX500Name(szX500, sz);
	}
	else 
		sz.Empty();
}

void CDNSServerNode::CreateLdapPathFromX500Name(LPCWSTR lpszX500Name, CString& szLdapPath)
{
	ASSERT(m_pServInfoEx != NULL);
	ASSERT(m_pServInfoEx->m_pServInfo != NULL);
	if (m_pServInfoEx->m_pServInfo != NULL)
	{
    _LdapPathFromX500(szLdapPath, m_pServInfoEx->m_pServInfo, lpszX500Name);
	}
	else 
		szLdapPath.Empty();
}

BOOL CDNSServerNode::DoesRecursion()
{
  if (m_pServInfoEx == NULL || m_pServInfoEx->m_pServInfo == NULL)
  {
    ASSERT(FALSE);
    return TRUE;
  }
  return !m_pServInfoEx->m_pServInfo->fNoRecursion;
}

void CDNSServerNode::GetAdvancedOptions(BOOL* bOptionsArray)
{
	ASSERT(m_pServInfoEx != NULL);
	ASSERT(m_pServInfoEx->m_pServInfo != NULL);

	bOptionsArray[SERVER_REGKEY_ARR_INDEX_NO_RECURSION] = m_pServInfoEx->m_pServInfo->fNoRecursion;
	bOptionsArray[SERVER_REGKEY_ARR_INDEX_BIND_SECONDARIES] = m_pServInfoEx->m_pServInfo->fBindSecondaries;
	bOptionsArray[SERVER_REGKEY_ARR_INDEX_STRICT_FILE_PARSING] = m_pServInfoEx->m_pServInfo->fStrictFileParsing;
	bOptionsArray[SERVER_REGKEY_ARR_INDEX_ROUND_ROBIN] = m_pServInfoEx->m_pServInfo->fRoundRobin;
	bOptionsArray[SERVER_REGKEY_ARR_LOCAL_NET_PRIORITY] = m_pServInfoEx->m_pServInfo->fLocalNetPriority;
	bOptionsArray[SERVER_REGKEY_ARR_CACHE_POLLUTION] = m_pServInfoEx->m_pServInfo->fSecureResponses;
}


DNS_STATUS CDNSServerNode::ResetAdvancedOptions(BOOL* bOptionsArray, DNS_STATUS* dwRegKeyOptionsErrorArr)
{
	ASSERT(m_pServInfoEx != NULL);
	DNS_STATUS err = 0;
	BOOL bChanged = FALSE;

  ZeroMemory(dwRegKeyOptionsErrorArr, sizeof(DNS_STATUS )*SERVER_REGKEY_ARR_SIZE);

	for (UINT iKey=0; iKey < SERVER_REGKEY_ARR_SIZE; iKey++)
	{
		BOOL bDirty = FALSE;
		switch (iKey)
		{
		case SERVER_REGKEY_ARR_INDEX_NO_RECURSION:
			bDirty = (bOptionsArray[iKey] != m_pServInfoEx->m_pServInfo->fNoRecursion);
			break;
		case SERVER_REGKEY_ARR_INDEX_BIND_SECONDARIES:
			bDirty = (bOptionsArray[iKey] != m_pServInfoEx->m_pServInfo->fBindSecondaries);
			break;
		case SERVER_REGKEY_ARR_INDEX_STRICT_FILE_PARSING:
			bDirty = (bOptionsArray[iKey] != m_pServInfoEx->m_pServInfo->fStrictFileParsing);
			break;
		case SERVER_REGKEY_ARR_INDEX_ROUND_ROBIN:
			bDirty = (bOptionsArray[iKey] != m_pServInfoEx->m_pServInfo->fRoundRobin);
			break;
		case SERVER_REGKEY_ARR_LOCAL_NET_PRIORITY:
			bDirty = (bOptionsArray[iKey] != m_pServInfoEx->m_pServInfo->fLocalNetPriority);
			break;
		case SERVER_REGKEY_ARR_CACHE_POLLUTION:
			bDirty = (bOptionsArray[iKey] != m_pServInfoEx->m_pServInfo->fSecureResponses);
			break;
		default:
			ASSERT(FALSE);
		}
		if (bDirty)
		{
			dwRegKeyOptionsErrorArr[iKey] = ::DnssrvResetDwordProperty(
                                        GetServerNode()->GetRPCName(), // server name
                                        NULL,
                                        _DnsServerRegkeyStringArr[iKey],
                                        bOptionsArray[iKey]);
			if (dwRegKeyOptionsErrorArr[iKey] == 0)
  			bChanged = TRUE;
		}
	}

	if (bChanged)
		err = GetServInfo(); // update the info
	return err;
}


UCHAR CDNSServerNode::GetBootMethod()
{
	ASSERT(m_pServInfoEx != NULL);
	ASSERT(m_pServInfoEx->m_pServInfo != NULL);

	return m_pServInfoEx->m_pServInfo->fBootMethod;
}

DNS_STATUS CDNSServerNode::ResetBootMethod(UCHAR fBootMethod)
{
  ASSERT(m_pServInfoEx != NULL);
	ASSERT(m_pServInfoEx->m_pServInfo != NULL);

  DWORD err = 0;
  if(fBootMethod != m_pServInfoEx->m_pServInfo->fBootMethod)
	{
		err = ::DnssrvResetDwordProperty(GetServerNode()->GetRPCName(), // server name
						NULL,
						DNS_REGKEY_BOOT_METHOD,
						fBootMethod);
		if (err != 0)
			return err;
    // all fine, update the info
		err = GetServInfo(); 
	}
	return err;
}

BOOL CDNSServerNode::ContainsDefaultNDNCs()
{
  //
  // Enumerate the available directory partitions
  //
  BOOL result = FALSE;
  PDNS_RPC_DP_LIST pDirectoryPartitions = NULL;
  DWORD dwErr = ::DnssrvEnumDirectoryPartitions(GetRPCName(),
                                                DNS_DP_ENLISTED,
                                                &pDirectoryPartitions);

  //
  // Don't show an error if we are not able to get the available directory partitions
  // We can still continue on and the user can type in the directory partition they need
  //
  if (dwErr == 0 && pDirectoryPartitions)
  {
    for (DWORD dwIdx = 0; dwIdx < pDirectoryPartitions->dwDpCount; dwIdx++)
    {
      PDNS_RPC_DP_INFO pDirectoryPartition = 0;
      dwErr = ::DnssrvDirectoryPartitionInfo(GetRPCName(),
                                             pDirectoryPartitions->DpArray[dwIdx]->pszDpFqdn,
                                             &pDirectoryPartition);
      if (dwErr == 0 &&
          pDirectoryPartition)
      {
        //
        // Check to see if it was an autocreated partition
        //
        if (pDirectoryPartition->dwFlags & DNS_DP_AUTOCREATED)
        {
          result = TRUE;
          ::DnssrvFreeDirectoryPartitionInfo(pDirectoryPartition);
          break;
        }
        ::DnssrvFreeDirectoryPartitionInfo(pDirectoryPartition);
      }
    }

    ::DnssrvFreeDirectoryPartitionList(pDirectoryPartitions);
  }

  return result;
}

BOOL CDNSServerNode::IsServerConfigured()
{
  ASSERT(m_pServInfoEx != NULL);

  if (m_pServInfoEx != NULL && m_pServInfoEx->m_pServInfo != NULL)
  {
    return m_pServInfoEx->m_pServInfo->fAdminConfigured;
  }
  return TRUE;
}

DNS_STATUS CDNSServerNode::SetServerConfigured()
{
	ASSERT(m_pServInfoEx != NULL);
	ASSERT(m_pServInfoEx->m_pServInfo != NULL);

  DWORD err = 0;
  if (TRUE != m_pServInfoEx->m_pServInfo->fAdminConfigured)
  {
    err = ::DnssrvResetDwordProperty(GetRPCName(),
                                      NULL,
                                      DNS_REGKEY_ADMIN_CONFIGURED,
                                      TRUE);
    if (err != 0)
      return err;

    err = GetServInfo();
  }

  return err;
}

BOOL CDNSServerNode::GetScavengingState()
{
	ASSERT(m_pServInfoEx != NULL);
	ASSERT(m_pServInfoEx->m_pServInfo != NULL);

  return m_pServInfoEx->m_pServInfo->dwScavengingInterval > 0;
}

DWORD CDNSServerNode::GetScavengingInterval()
{
	ASSERT(m_pServInfoEx != NULL);
	ASSERT(m_pServInfoEx->m_pServInfo != NULL);

  return m_pServInfoEx->m_pServInfo->dwScavengingInterval;
}

DNS_STATUS CDNSServerNode::ResetScavengingInterval(DWORD dwScavengingInterval)
{
  ASSERT(m_pServInfoEx != NULL);
	ASSERT(m_pServInfoEx->m_pServInfo != NULL);

  DWORD err = 0;
  if (dwScavengingInterval != m_pServInfoEx->m_pServInfo->dwScavengingInterval)
  {
    DNS_RPC_NAME_AND_PARAM  param;

    param.dwParam = dwScavengingInterval;
    param.pszNodeName = DNS_REGKEY_SCAVENGING_INTERVAL;

    err = ::DnssrvOperation(
                GetRPCName(),
                NULL,
                DNSSRV_OP_RESET_DWORD_PROPERTY,
                DNSSRV_TYPEID_NAME_AND_PARAM,
                & param
                );
    if (err != 0)
      return err;

    err = GetServInfo();
  }
  return err;
}

DWORD CDNSServerNode::GetDefaultRefreshInterval()
{
	ASSERT(m_pServInfoEx != NULL);
	ASSERT(m_pServInfoEx->m_pServInfo != NULL);

  return m_pServInfoEx->m_pServInfo->dwDefaultRefreshInterval;

}

DNS_STATUS CDNSServerNode::ResetDefaultRefreshInterval(DWORD dwRefreshInterval)
{
  ASSERT(m_pServInfoEx != NULL);
	ASSERT(m_pServInfoEx->m_pServInfo != NULL);

  DWORD err = 0;
  if (dwRefreshInterval != m_pServInfoEx->m_pServInfo->dwDefaultRefreshInterval)
  {
    DNS_RPC_NAME_AND_PARAM  param;

    param.dwParam = dwRefreshInterval;
    param.pszNodeName = DNS_REGKEY_DEFAULT_REFRESH_INTERVAL;

    err = ::DnssrvOperation(
                GetRPCName(),
                NULL,
                DNSSRV_OP_RESET_DWORD_PROPERTY,
                DNSSRV_TYPEID_NAME_AND_PARAM,
                & param
                );
    if (err != 0)
      return err;

    err = GetServInfo();
  }
  return err;

}

DWORD CDNSServerNode::GetDefaultNoRefreshInterval()
{
	ASSERT(m_pServInfoEx != NULL);
	ASSERT(m_pServInfoEx->m_pServInfo != NULL);

  return m_pServInfoEx->m_pServInfo->dwDefaultNoRefreshInterval;

}

DNS_STATUS CDNSServerNode::ResetDefaultNoRefreshInterval(DWORD dwNoRefreshInterval)
{
  ASSERT(m_pServInfoEx != NULL);
	ASSERT(m_pServInfoEx->m_pServInfo != NULL);

  DWORD err = 0;
  if (dwNoRefreshInterval != m_pServInfoEx->m_pServInfo->dwDefaultNoRefreshInterval)
  {
    DNS_RPC_NAME_AND_PARAM  param;

    param.dwParam = dwNoRefreshInterval;
    param.pszNodeName = DNS_REGKEY_DEFAULT_NOREFRESH_INTERVAL;

    err = ::DnssrvOperation(
                GetRPCName(),
                NULL,
                DNSSRV_OP_RESET_DWORD_PROPERTY,
                DNSSRV_TYPEID_NAME_AND_PARAM,
                & param
                );
    if (err != 0)
      return err;

    err = GetServInfo();
  }
  return err;

}

#ifdef USE_NDNC
PCSTR CDNSServerNode::GetDomainName()
{
   ASSERT(m_pServInfoEx != NULL);
   ASSERT(m_pServInfoEx->m_pServInfo);

   return m_pServInfoEx->m_pServInfo->pszDomainName;
}

PCSTR CDNSServerNode::GetForestName()
{
   ASSERT(m_pServInfoEx != NULL);
   ASSERT(m_pServInfoEx->m_pServInfo);

   return m_pServInfoEx->m_pServInfo->pszForestName;
}
#endif

DWORD CDNSServerNode::GetDefaultScavengingState()
{
	ASSERT(m_pServInfoEx != NULL);
	ASSERT(m_pServInfoEx->m_pServInfo != NULL);

  return m_pServInfoEx->m_pServInfo->fDefaultAgingState;

}

DNS_STATUS CDNSServerNode::ResetDefaultScavengingState(DWORD dwScavengingState)
{
  ASSERT(m_pServInfoEx != NULL);
	ASSERT(m_pServInfoEx->m_pServInfo != NULL);

  DWORD err = 0;
  if (dwScavengingState != m_pServInfoEx->m_pServInfo->fDefaultAgingState)
  {
    DNS_RPC_NAME_AND_PARAM  param;

    param.dwParam = dwScavengingState;
    param.pszNodeName = DNS_REGKEY_DEFAULT_AGING_STATE;

    err = ::DnssrvOperation(
                GetRPCName(),
                NULL,
                DNSSRV_OP_RESET_DWORD_PROPERTY,
                DNSSRV_TYPEID_NAME_AND_PARAM,
                & param
                );
    if (err != 0)
      return err;

    err = GetServInfo();
  }
  return err;
}


DWORD CDNSServerNode::GetNameCheckFlag()
{
	ASSERT(m_pServInfoEx->m_pServInfo != NULL);
	return m_pServInfoEx->m_pServInfo->dwNameCheckFlag;
}

DNS_STATUS CDNSServerNode::ResetNameCheckFlag(DWORD dwNameCheckFlag)
{
	ASSERT(m_pServInfoEx->m_pServInfo != NULL);
	DNS_STATUS err = 0;
	// call only if the info is dirty
	if (m_pServInfoEx->m_pServInfo->dwNameCheckFlag != dwNameCheckFlag)
	{
		USES_CONVERSION;
		err = ::DnssrvResetDwordProperty(GetServerNode()->GetRPCName(), // server name
										NULL,
										DNS_REGKEY_NAME_CHECK_FLAG,
										dwNameCheckFlag);
		if (err != 0)
			return err;
		err = GetServInfo(); // update the info
	}
	return err;
}

PIP_ARRAY CDNSServerNode::GetDebugLogFilterList()
{
	ASSERT(m_pServInfoEx->m_pServInfo != NULL);
	return m_pServInfoEx->m_pServInfo->aipLogFilter;
}

DNS_STATUS CDNSServerNode::ResetDebugLogFilterList(PIP_ARRAY pIPArray)
{
  DNS_STATUS err = 0;

  err = ::DnssrvResetIPListProperty(GetServerNode()->GetRPCName(), // server name
                                    NULL,
                                    DNS_REGKEY_LOG_IP_FILTER_LIST,
                                    pIPArray,
                                    0); // dwFlags
	if (err != 0)
		return err;
	err = GetServInfo(); // update the info
	return err;
}

PCWSTR CDNSServerNode::GetDebugLogFileName()
{
	ASSERT(m_pServInfoEx->m_pServInfo != NULL);
	return m_pServInfoEx->m_pServInfo->pwszLogFilePath;
}

DNS_STATUS CDNSServerNode::ResetDebugLogFileName(PCWSTR pszLogFileName)
{
  ASSERT(m_pServInfoEx->m_pServInfo != NULL);
  DNS_STATUS err = 0;

	if (m_pServInfoEx->m_pServInfo->pwszLogFilePath == NULL ||
      _wcsicmp(m_pServInfoEx->m_pServInfo->pwszLogFilePath, pszLogFileName) != 0)
	{
    err = ::DnssrvResetStringProperty(GetServerNode()->GetRPCName(), // server name
                                      NULL,
                                      DNS_REGKEY_LOG_FILE_PATH,
                                      pszLogFileName,
                                      0); // dwFlags
		if (err != 0)
			return err;
		err = GetServInfo(); // update the info
	}
	return err;
}

DWORD CDNSServerNode::GetDebugLogFileMaxSize()
{
	ASSERT(m_pServInfoEx->m_pServInfo != NULL);
	return m_pServInfoEx->m_pServInfo->dwLogFileMaxSize;
}

DNS_STATUS CDNSServerNode::ResetDebugLogFileMaxSize(DWORD dwMaxSize)
{
  ASSERT(m_pServInfoEx->m_pServInfo != NULL);
  DNS_STATUS err = 0;

	if (m_pServInfoEx->m_pServInfo->dwLogFileMaxSize != dwMaxSize)
	{
    err = ::DnssrvResetDwordProperty(GetServerNode()->GetRPCName(), // server name
                                     NULL,
                                     DNS_REGKEY_LOG_FILE_MAX_SIZE,
                                     dwMaxSize);

		if (err != 0)
			return err;
		err = GetServInfo(); // update the info
	}
	return err;
}

DWORD CDNSServerNode::GetLogLevelFlag()
{
	ASSERT(m_pServInfoEx->m_pServInfo != NULL);
	return m_pServInfoEx->m_pServInfo->dwLogLevel;
}

DNS_STATUS CDNSServerNode::ResetLogLevelFlag(DWORD dwLogLevel)
{
	ASSERT(m_pServInfoEx->m_pServInfo != NULL);
	DNS_STATUS err = 0;
	// call only if the info is dirty
	if (m_pServInfoEx->m_pServInfo->dwLogLevel != dwLogLevel)
	{
		USES_CONVERSION;
		err = ::DnssrvResetDwordProperty(GetServerNode()->GetRPCName(), // server name
										NULL,
										DNS_REGKEY_LOG_LEVEL,
										dwLogLevel);
		if (err != 0)
			return err;
		err = GetServInfo(); // update the info
	}
	return err;
}

DWORD CDNSServerNode::GetEventLogLevelFlag()
{
	ASSERT(m_pServInfoEx->m_pServInfo != NULL);
	return m_pServInfoEx->m_pServInfo->dwEventLogLevel;
}

DNS_STATUS CDNSServerNode::ResetEventLogLevelFlag(DWORD dwEventLogLevel)
{
  ASSERT(m_pServInfoEx->m_pServInfo != NULL);
  DNS_STATUS err = 0;

	if (m_pServInfoEx->m_pServInfo->dwEventLogLevel != dwEventLogLevel)
	{

	  USES_CONVERSION;
	  err = ::DnssrvResetDwordProperty(GetServerNode()->GetRPCName(), // server name
									  NULL,
									  DNS_REGKEY_EVENTLOG_LEVEL,
									  dwEventLogLevel);
		if (err != 0)
			return err;
		err = GetServInfo(); // update the info
	}
	return err;
}


DNS_STATUS CDNSServerNode::ResetListenAddresses(DWORD cAddrCount, PIP_ADDRESS pipAddrs)
{
	ASSERT(m_pServInfoEx->m_pServInfo != NULL);
	USES_CONVERSION;

	// make the call only if the data is dirty
	DNS_STATUS err = 0;
	if  (!(m_pServInfoEx->m_pServInfo->aipListenAddrs == NULL && cAddrCount == 0) && // if still no addresses, skip
			((m_pServInfoEx->m_pServInfo->aipListenAddrs == NULL && cAddrCount > 0) || // no addr --> more than one
			 (m_pServInfoEx->m_pServInfo->aipListenAddrs->AddrCount != cAddrCount) || // change the # of addresses
			 (memcmp(pipAddrs, m_pServInfoEx->m_pServInfo->aipListenAddrs->AddrArray, sizeof(IP_ADDRESS)*cAddrCount) != 0) 
			)
		)
	{
		IP_ADDRESS dummy;
		if (pipAddrs == NULL)
		{
			ASSERT(cAddrCount == 0);
			pipAddrs = &dummy; // RPC wants non null ip array
		}
		err = ::DnssrvResetServerListenAddresses(GetRPCName(), cAddrCount, pipAddrs);
	}
	if (err != 0)
		return err;
	return GetServInfo(); // update the info
}

void CDNSServerNode::GetListenAddressesInfo(DWORD* pcAddrCount, PIP_ADDRESS* ppipAddrs)
{
	ASSERT(m_pServInfoEx->m_pServInfo != NULL);
	ASSERT(pcAddrCount != NULL);
	ASSERT(ppipAddrs != NULL);
	// return pointers to struct fields, caller has to copy data elsewhere
	if (m_pServInfoEx->m_pServInfo->aipListenAddrs == NULL)
	{
		*pcAddrCount = 0;
		*ppipAddrs = NULL;
	}
	else
	{
		*pcAddrCount = m_pServInfoEx->m_pServInfo->aipListenAddrs->AddrCount;
		*ppipAddrs = m_pServInfoEx->m_pServInfo->aipListenAddrs->AddrArray;
	}
}

void CDNSServerNode::GetServerAddressesInfo(DWORD* pcAddrCount, PIP_ADDRESS* ppipAddrs)
{
  //
  // Validate parameters
  //
	ASSERT(pcAddrCount != NULL);
	ASSERT(ppipAddrs != NULL);
  if (pcAddrCount == NULL ||
      ppipAddrs == NULL)
  {
    return;
  }

  if (!m_pServInfoEx->HasData())
  {
    DNS_STATUS err = GetServInfo();
    if (err != 0)
    {
		  *pcAddrCount = 0;
		  *ppipAddrs = NULL;
      return;
    }
  }

	ASSERT(m_pServInfoEx->m_pServInfo != NULL);
	// return pointers to struct fields, caller has to copy data elsewhere
	if (m_pServInfoEx->m_pServInfo->aipServerAddrs == NULL)
	{
		*pcAddrCount = 0;
		*ppipAddrs = NULL;
	}
	else
	{
		*pcAddrCount = m_pServInfoEx->m_pServInfo->aipServerAddrs->AddrCount;
		*ppipAddrs = m_pServInfoEx->m_pServInfo->aipServerAddrs->AddrArray;
	}
}

DNS_STATUS CDNSServerNode::ResetForwarders(DWORD cForwardersCount, PIP_ADDRESS aipForwarders, 
										   DWORD dwForwardTimeout, DWORD fSlave)
{
	ASSERT(m_pServInfoEx->m_pServInfo != NULL);
	// make the call only if the data is dirty

	DNS_STATUS err = 0;
	if (m_pServInfoEx->m_pServInfo->aipForwarders == NULL && cForwardersCount == 0)
		return err; // there are no addresses
	
	BOOL bDirty = (m_pServInfoEx->m_pServInfo->fSlave != fSlave) || (m_pServInfoEx->m_pServInfo->dwForwardTimeout != dwForwardTimeout) ||
		(m_pServInfoEx->m_pServInfo->aipForwarders == NULL && cForwardersCount > 0) || // no addr --> more than one
		(m_pServInfoEx->m_pServInfo->aipForwarders != NULL && cForwardersCount == 0) || // some addr --> no addr
		(m_pServInfoEx->m_pServInfo->aipForwarders->AddrCount != cForwardersCount) || // change the # of addresses
		(memcmp(aipForwarders, m_pServInfoEx->m_pServInfo->aipForwarders->AddrArray, sizeof(IP_ADDRESS)*cForwardersCount) != 0);

	if (bDirty)
	{
		IP_ADDRESS dummy;
		if (aipForwarders == NULL)
		{
			ASSERT(cForwardersCount == 0);
			aipForwarders = &dummy; // RPC wants non null ip array
		}
		USES_CONVERSION;
		err = ::DnssrvResetForwarders(GetRPCName(), 
					cForwardersCount, aipForwarders, dwForwardTimeout, fSlave);
		if (err == 0)
			err = GetServInfo(); // update the info
	}
	return err;
}

void CDNSServerNode::GetForwardersInfo(DWORD* pcForwardersCount, PIP_ADDRESS* paipForwarders, 
									   DWORD* pdwForwardTimeout, DWORD* pfSlave)
{
	ASSERT(m_pServInfoEx->m_pServInfo != NULL);
	// return pointers to struct fields, caller has to copy data elsewhere

	*pdwForwardTimeout = m_pServInfoEx->m_pServInfo->dwForwardTimeout;
	*pfSlave = m_pServInfoEx->m_pServInfo->fSlave;
	if (m_pServInfoEx->m_pServInfo->aipForwarders == NULL)
	{
		*pcForwardersCount = 0;
		*paipForwarders = NULL;
	}
	else
	{
		*pcForwardersCount = m_pServInfoEx->m_pServInfo->aipForwarders->AddrCount;
		*paipForwarders = m_pServInfoEx->m_pServInfo->aipForwarders->AddrArray;
	}
	
}

CDNSRootHintsNode* CDNSServerNode::GetRootHints()
{ 
	if (m_pRootHintsNode == NULL)
	{
		m_pRootHintsNode = new CDNSRootHintsNode;
		if (m_pRootHintsNode)
      {
		   m_pRootHintsNode->SetServerNode(GetServerNode());
      }
	}
	return m_pRootHintsNode;
}

void CDNSServerNode::GetTestOptions(CDNSServerTestOptions* pOptions)
{
	ASSERT(pOptions != NULL);
	*pOptions = m_testOptions;
}

void CDNSServerNode::ResetTestOptions(CDNSServerTestOptions* pOptions)
{
	ASSERT(pOptions != NULL);
	m_testOptions = *pOptions;
	CDNSRootData* pSnapinData = (CDNSRootData*)GetRootContainer();
	pSnapinData->SetDirtyFlag(TRUE);
}

void CDNSServerNode::AddTestQueryResult(CDNSServerTestQueryResult* pTestResult,
										CComponentDataObject* pComponentData)
{
//	TRACE(_T("m_testResultList.GetCount() == %d\n"), m_testResultList.GetCount());

	if (!pTestResult->m_bAsyncQuery)
		m_bTestQueryPending = FALSE;

	CDNSServerTestQueryResultList::addAction  action = 
		m_testResultList.AddTestQueryResult(pTestResult);

	// change icon, if necessary (GetImageIndex() will switch from/to alternative server icon set
	if (action == CDNSServerTestQueryResultList::added ||
		action == CDNSServerTestQueryResultList::addedAndRemoved)
	{
		ASSERT(IsVisible());
		VERIFY(SUCCEEDED(pComponentData->ChangeNode(this, CHANGE_RESULT_ITEM_ICON)));	

    if (m_bPrevQuerySuccess != m_testResultList.LastQuerySuceeded())
    {
      pComponentData->UpdateResultPaneView(this);
    }
    m_bPrevQuerySuccess = m_testResultList.LastQuerySuceeded();
	}

	pComponentData->GetPropertyPageHolderTable()->BroadcastMessageToSheets(
						this, SHEET_MSG_SERVER_TEST_DATA, 
						(LPARAM)action);
}


/////////////////////////////////////////////////////////////////////////////
///////// LOW LEVEL DNS UTILITIES ///////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

DNS_STATUS CDNSServerNode::EnumZoneInfo(CZoneInfoHolder* pZoneInfoHolder)
{
	return EnumZoneInfo(m_szDisplayName, pZoneInfoHolder);
}

DNS_STATUS CDNSServerNode::EnumZoneInfo(LPCTSTR, CZoneInfoHolder* pZoneInfoHolder)
{
	ASSERT(pZoneInfoHolder != NULL);
	USES_CONVERSION;
	DNS_STATUS err = 0;
	do
	{
		ASSERT(pZoneInfoHolder->m_dwArrSize > 0);
		ASSERT(pZoneInfoHolder->m_dwZoneCount == 0);
		ASSERT(pZoneInfoHolder->m_zoneInfoArray != NULL);
		if ((err == 0) || (err != ERROR_MORE_DATA))
    {
			break; // success or no need to retry
    }

		if (!pZoneInfoHolder->Grow())
    {
			break; // reached the limit for growth
    }
	}	while (TRUE);
	return err;

}


DNS_STATUS CDNSServerNode::ClearCache()
{
	USES_CONVERSION;
	
  return ::DnssrvOperation(GetRPCName(), // server name
												NULL, // zone name, just pass null
												DNSSRV_OP_CLEAR_CACHE,
                        DNSSRV_TYPEID_NULL,
												NULL);
}

void CDNSServerNode::FreeServInfo()
{
	ASSERT(m_pServInfoEx != NULL);
	m_pServInfoEx->FreeInfo();
}

DNS_STATUS CDNSServerNode::GetServInfo()
{
	ASSERT(m_pServInfoEx != NULL);
	return m_pServInfoEx->Query(GetDisplayName());

}

void CDNSServerNode::AttachServerInfo(CDNSServerInfoEx* pNewInfo)
{
	ASSERT(pNewInfo != NULL);
	ASSERT(m_pServInfoEx != NULL);
	delete m_pServInfoEx;
	m_pServInfoEx = pNewInfo;
}

void CDNSServerNode::FreeRootHints()
{
	if (m_pRootHintsNode != NULL)
	{
		//CNodeList* pChildList = m_pRootHintsNode->GetChildList();
		//int n = pChildList->GetCount();
		delete m_pRootHintsNode;
		m_pRootHintsNode = NULL;
	}
}

void CDNSServerNode::AttachRootHints(CDNSRootHintsNode* pNewRootHints)
{
  ASSERT(pNewRootHints != NULL);
  FreeRootHints();
  m_pRootHintsNode = pNewRootHints;
  // the display and full names were set already in the constructor
  m_pRootHintsNode->SetServerNode(GetServerNode());
}


/////////////////////////////////////////////////////////////////////

CDNSServerOptionNode::CDNSServerOptionNode(UINT nDisplayNameID, UINT startPageCode) 
   : m_nStartPageCode(startPageCode)
{
   CString szDisplayName;
   szDisplayName.LoadString(nDisplayNameID);
   SetDisplayName(szDisplayName);
}

LPCWSTR CDNSServerOptionNode::GetString(int nCol)
{
   return (nCol == 0) ? GetDisplayName() : g_lpszNullString;
}

int CDNSServerOptionNode::GetImageIndex(BOOL /*bOpenImage*/)
{
   return SERVER_OPTIONS_IMAGE;
}

HRESULT CDNSServerOptionNode::OnSetToolbarVerbState(IToolbar* pToolbar, 
                                                    CNodeList*)
{
  HRESULT hr = S_OK;

  //
  // Set the button state for each button on the toolbar
  //
  hr = pToolbar->SetButtonState(toolbarNewServer, ENABLED, FALSE);
  hr = pToolbar->SetButtonState(toolbarNewZone, ENABLED, FALSE);
  hr = pToolbar->SetButtonState(toolbarNewRecord, ENABLED, FALSE);
  return hr;
}   

BOOL CDNSServerOptionNode::HasPropertyPages(DATA_OBJECT_TYPES, 
                                            BOOL* pbHideVerb,
                                            CNodeList* pNodeList)
{
  if (pNodeList->GetCount() > 1) // multiple selection
  {
    *pbHideVerb = TRUE;
    return FALSE;
  }

	*pbHideVerb = FALSE; // always show the verb
	return TRUE;
}

HRESULT CDNSServerOptionNode::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, 
                                                  LONG_PTR handle,
                                                  CNodeList* pNodeList)
{
   ASSERT(pNodeList->GetCount() == 1); // multi-select not supported

   CContainerNode* pCont = GetContainer();
   ASSERT(pCont != NULL);

   return pCont->CreatePropertyPagesHelper(lpProvider, handle, m_nStartPageCode);
}

void CDNSServerOptionNode::ShowPageForNode(CComponentDataObject* pComponentDataObject)
{
   CContainerNode* pCont = GetContainer();
   ASSERT(pCont != NULL);

   if (pCont->GetSheetCount() > 0)
   {
      // bring up the sheet of the container
      ASSERT(pComponentDataObject != NULL);
      pComponentDataObject->GetPropertyPageHolderTable()->BroadcastSelectPage(pCont, m_nStartPageCode);
   }	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\serverui.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       serverui.h
//
//--------------------------------------------------------------------------

#ifndef _SERVERUI_H
#define _SERVERUI_H

#include "uiutil.h"
#include "ipeditor.h"

#include "nspage.h"
#include "aclpage.h"


///////////////////////////////////////////////////////////////////////////////
// FORWARD DECLARATIONS

class CDNSServerNode;

///////////////////////////////////////////////////////////////////////////////
// CDNSServer_InterfacesPropertyPage

class CDNSServer_InterfacesPropertyPage : public CPropertyPageBase
{

// Construction
public:
	CDNSServer_InterfacesPropertyPage();

// Implementation
protected:

	// Generated message map functions
	virtual BOOL OnInitDialog();
	virtual BOOL OnApply();

	afx_msg void OnListenOnSpecifiedAddresses();
	afx_msg void OnListenOnAllAddresses();

private:
	class CListenAddressesIPEditor : public CIPEditor
	{
	public:
		CListenAddressesIPEditor() : CIPEditor(TRUE) {}
		virtual void OnChangeData();
	};
	CListenAddressesIPEditor m_listenAddressesEditor;

	CButton* GetListenOnAllRadio() 
		{ return (CButton*)GetDlgItem(IDC_LISTEN_ON_ALL_RADIO);}
	CButton* GetListenOnSpecifiedRadio() 
		{ return (CButton*)GetDlgItem(IDC_LISTEN_ON_SPECIFIED_RADIO);}

	void SelectionHelper(BOOL bListenAll);
	friend class CListenAddressesIPEditor;

  BOOL m_bAllWasPreviousSelection;

	DECLARE_MESSAGE_MAP()
};

///////////////////////////////////////////////////////////////////////////////
// CDNSServer_ForwardersPropertyPage

class CDNSServer_ForwardersPropertyPage : public CPropertyPageBase
{

// Construction
public:
	CDNSServer_ForwardersPropertyPage();

	// Implementation
protected:
	afx_msg void OnForwardersCheck();
	afx_msg void OnSlaveCheckChange();
	afx_msg void OnForwarderTimeoutChange();

	virtual BOOL OnInitDialog();
	virtual BOOL OnApply();
	virtual BOOL OnKillActive();

private:
	void EnableForwardersUI(BOOL bUseForwaders);
	CButton* GetForwardersCheck() { return (CButton*)GetDlgItem(IDC_USE_FORWARDERS_CHECK);}
	CButton* GetSlaveCheck() { return (CButton*)GetDlgItem(IDC_SLAVE_CHECK);}
	CStatic* GetForwardersStatic() { return (CStatic*)GetDlgItem(IDC_STATIC_ADD_FORWARDERS);}

	CDNSUnsignedIntEdit m_forwardTimeoutEdit;

	class CForwarderAddressesIPEditor : public CIPEditor
	{
	public:
		virtual void OnChangeData();
	};
	CForwarderAddressesIPEditor m_forwarderAddressesEditor;
	friend class CForwarderAddressesIPEditor;

	DECLARE_MESSAGE_MAP()
};

///////////////////////////////////////////////////////////////////////////////
// CAllOthersDomainInfo

class CAllOthersDomainInfo
{
public:
  CAllOthersDomainInfo(DWORD cAddrCount, PIP_ADDRESS pipAddrs, DWORD dwForwardTimeout, DWORD fSlave)
  {
    m_cAddrCount = cAddrCount;
    m_pipAddrs   = pipAddrs;
    m_dwForwardTimeout = dwForwardTimeout;
    m_fSlave     = fSlave;
  }

  DWORD         m_cAddrCount;
  PIP_ADDRESS   m_pipAddrs;
  DWORD         m_dwForwardTimeout;
  DWORD         m_fSlave;
};

///////////////////////////////////////////////////////////////////////////////
// CDomainForwardersEditInfo

class CDomainForwardersEditInfo
{
public:
  CDomainForwardersEditInfo(CDNSZoneNode* pZoneNode, BOOL bADIntegrated, BOOL bAllOthers = FALSE);
  ~CDomainForwardersEditInfo();

  typedef enum
  {
    nochange = 0,
    update,
    add,
    remove
  } ACTION_ITEM;

  void SetAllOthersDomain(CAllOthersDomainInfo* pAllOthers);
  BOOL IsAllOthers() { return m_bAllOthersDomain; }

  void SetAction(ACTION_ITEM action);
  ACTION_ITEM GetAction() { return m_actionItem; }

  void SetSlave(BOOL bSlave) { m_bSlave = bSlave; }
  BOOL IsSlave() { return m_bSlave; }

  void SetTimeout(DWORD dwTimeout) { m_dwTimeout = dwTimeout; }
  DWORD GetTimeout() { return m_dwTimeout; }

  BOOL IsADIntegrated() { return m_bADIntegrated; }

  void SetIPList(DWORD dwCount, PIP_ADDRESS pipArray)
  {
    m_cAddrCount = dwCount;
    m_pIPList = pipArray;
  }
  PIP_ADDRESS GetIPList(DWORD* pdwCount)
  {
    *pdwCount = m_cAddrCount;
    return m_pIPList;
  }

  void SetDomainName(PCWSTR pszDomainName)
  {
      m_szDomainName = pszDomainName;
      m_szDomainName.TrimLeft(L' ');
      m_szDomainName.TrimRight(L' ');
  }
  
  void GetDomainName(CString& szDomainName) { szDomainName = m_szDomainName; }

  void SetDataFromRPC(BOOL bRPCData) { m_bRPCData = bRPCData; }
  BOOL IsDataFromRPC() { return m_bRPCData; }

  BOOL Update(BOOL bSlave, DWORD dwTimeout, DWORD dwCount, PIP_ADDRESS pipArray);

  CDNSZoneNode* GetZoneNode() { return m_pZoneNode; }

private:
  BOOL          m_bADIntegrated;
  BOOL          m_bAllOthersDomain;
  ACTION_ITEM   m_actionItem;

  CDNSZoneNode* m_pZoneNode;
  CAllOthersDomainInfo* m_pAllOthers;

  BOOL          m_bRPCData;
  CString       m_szDomainName;
  BOOL          m_bSlave;
  DWORD         m_dwTimeout;
  DWORD         m_cAddrCount;
  PIP_ADDRESS   m_pIPList;
};

///////////////////////////////////////////////////////////////////////////////
// CDomainForwardersEditList
class CDomainForwardersEditList : public CList<CDomainForwardersEditInfo*, CDomainForwardersEditInfo*>
{
public:
  ~CDomainForwardersEditList()
  {
    DeleteAll();
  }

  void DeleteAll()
  {
    while (!IsEmpty())
    {
      delete RemoveTail();
    }
  }

  void Remove(CDomainForwardersEditInfo* pInfo)
  {
    POSITION pos = GetHeadPosition();
    while (pos != NULL)
    {
      CDomainForwardersEditInfo* pListInfo = reinterpret_cast<CDomainForwardersEditInfo*>(GetAt(pos));
      if (pListInfo == pInfo)
      {
        RemoveAt(pos);
        break;
      }
      GetNext(pos);
    }
  }

  CDomainForwardersEditInfo* DoesExist(PCWSTR pszDomainName)
  {
    POSITION pos = GetHeadPosition();
    while (pos != NULL)
    {
      CDomainForwardersEditInfo* pListInfo = reinterpret_cast<CDomainForwardersEditInfo*>(GetNext(pos));
      if (pListInfo != NULL)
      {
        CString szName;
        pListInfo->GetDomainName(szName);
        if (szName == pszDomainName)
        {
          return pListInfo;
        }
      }
    }
    return NULL;
  }

};

///////////////////////////////////////////////////////////////////////////////
// CDNSServer_DomainForwardersPropertyPage

class CDNSServer_DomainForwardersPropertyPage : public CPropertyPageBase
{

// Construction
public:
	CDNSServer_DomainForwardersPropertyPage();

	// Implementation
protected:
  afx_msg void OnDomainSelChange();
  afx_msg void OnAddDomain();
  afx_msg void OnRemoveDomain();
  afx_msg void OnSlaveCheckChange();
  afx_msg void OnForwarderTimeoutChange();

  virtual BOOL OnInitDialog();
  virtual BOOL OnApply();
  virtual BOOL OnSetActive();
  virtual BOOL OnKillActive();

private:
  CButton* GetSlaveCheck() { return (CButton*)GetDlgItem(IDC_SLAVE_CHECK);}
  CStatic* GetForwardersStatic() { return (CStatic*)GetDlgItem(IDC_STATIC_ADD_FORWARDERS);}

  void SetPageReadOnly(BOOL bServerHasRoot, BOOL bDoesRecursion);
  void LoadUIData();
  void GetForwarderData();
  CDomainForwardersEditInfo* CreateAllOthersDomainInfo(CDNSServerNode* pServerNode);

  CDNSUnsignedIntEdit m_forwardTimeoutEdit;

  class CForwarderAddressesIPEditor : public CIPEditor
  {
    public:
      virtual void OnChangeData();
  };

  CForwarderAddressesIPEditor m_forwarderAddressesEditor;
  friend class CForwarderAddressesIPEditor;

  DECLARE_MESSAGE_MAP()

private:
  CDomainForwardersEditList m_EditList;
  CDomainForwardersEditInfo* m_pCurrentInfo;

  BOOL m_bPostApply;
  BOOL m_bPageReadOnly;
  BOOL m_bChangingSelection;
};

///////////////////////////////////////////////////////////////////////////////
// CDNSServer_AdvancedPropertyPage

class CDNSServer_AdvancedPropertyPage : public CPropertyPageBase
{

// Construction
public:
	CDNSServer_AdvancedPropertyPage();

  virtual void SetDirty(BOOL bDirty) { CPropertyPageBase::SetDirty(bDirty); }

	// Implementation
protected:
	afx_msg void OnAdvancedOptionsListChange()	{ SetDirty(TRUE);}
	afx_msg void OnComboSelChange()	{ SetDirty(TRUE);}
	afx_msg void OnResetButton();
  afx_msg void OnEnableScavenging();

// Overrides
protected:

// Implementation
protected:
	virtual void SetUIData();
	
	// Generated message map functions
	virtual BOOL OnInitDialog();
	virtual BOOL OnApply();

private:
	CArrayCheckListBox	m_advancedOptionsListBox;

	// set/get helpers
	void SetAdvancedOptionsListbox(BOOL* bRegKeyOptionsArr);
	void GetAdvancedOptionsListbox(BOOL* RegKeyOptionsArr);
	void SetBootMethodComboVal(UCHAR fBootMethod);
	UCHAR GetBootMethodComboVal();
	void SetNameCheckingComboVal(DWORD dwNameChecking);
	DWORD GetNameCheckingComboVal();

	CComboBox* GetNameCheckingCombo()
		{ return (CComboBox*)GetDlgItem(IDC_NAME_CHECKING_COMBO);}
	CComboBox* GetBootMethodCombo()
		{ return (CComboBox*)GetDlgItem(IDC_BOOT_METHOD_COMBO);}

	DECLARE_MESSAGE_MAP()

  CDNS_SERVER_AGING_TimeIntervalEditGroup m_scavengingIntervalEditGroup;
};



///////////////////////////////////////////////////////////////////////////////
// CDNSServer_DebugLoggingPropertyPage

class CDNSServer_DebugLoggingPropertyPage : public CPropertyPageBase
{
// Construction
public:
	CDNSServer_DebugLoggingPropertyPage();
  ~CDNSServer_DebugLoggingPropertyPage();

	// Implementation
protected:

// Overrides
protected:
  afx_msg void OnLoggingCheck();
  afx_msg void OnSendCheck();
  afx_msg void OnReceiveCheck();
  afx_msg void OnQueriesCheck();
  afx_msg void OnNotifiesCheck();
  afx_msg void OnUpdatesCheck();
  afx_msg void OnRequestCheck();
  afx_msg void OnResponseCheck();
  afx_msg void OnUDPCheck();
  afx_msg void OnTCPCheck();
  afx_msg void OnDetailCheck();
  afx_msg void OnFilterCheck();
  afx_msg void OnFilterButton();
  afx_msg void OnLogFileChange();
  afx_msg void OnMaxSizeChange();

// Implementation
protected:
  void EnableLogging(BOOL bLogging = TRUE);
  void ResetToDefaults();
  void SetUIFromOptions(DWORD dwOptions);

  void SetOptionsDirty(BOOL bDirty = TRUE);
  BOOL AreOptionsDirty();

  virtual void SetUIData();
  virtual void GetUIData(BOOL bSilent = TRUE);
	
  // Generated message map functions
  virtual BOOL OnInitDialog();
  virtual BOOL OnApply();

private:
  DWORD m_dwLogLevel;
  DWORD m_dwMaxSize;
  CString m_szLogFileName;
  PIP_ARRAY m_pIPFilterList;

  BOOL  m_bOnSetUIData;

  BOOL  m_bMaxSizeDirty;
  BOOL  m_bLogFileDirty;
  BOOL  m_bFilterDirty;
  BOOL  m_bOwnIPListMemory;

  BOOL  m_bNotWhistler;
  BOOL  m_bOptionsDirty;

  DECLARE_MESSAGE_MAP()
};

///////////////////////////////////////////////////////////////////////////////
// CDNSServer_EventLoggingPropertyPage

class CDNSServer_EventLoggingPropertyPage : public CPropertyPageBase
{
// Construction
public:
	CDNSServer_EventLoggingPropertyPage();

	// Implementation
protected:
  afx_msg void OnSetDirty();

// Overrides
protected:

// Implementation
protected:
	virtual void SetUIData();
	
	// Generated message map functions
	virtual BOOL OnInitDialog();
	virtual BOOL OnApply();

private:
  DWORD m_dwEventLogLevel;
	DECLARE_MESSAGE_MAP()
};

///////////////////////////////////////////////////////////////////////////////
// CDNSServer_CopyRootHintsFromDialog

class CDNSServer_CopyRootHintsFromDialog : public CHelpDialog
{
public:
  CDNSServer_CopyRootHintsFromDialog(CComponentDataObject* pComponentData);

  virtual void OnOK();
  afx_msg void OnIPv4CtrlChange();

  DWORD   m_dwIPVal;
protected:
 	CDNSIPv4Control* GetIPv4Ctrl() { return (CDNSIPv4Control*)GetDlgItem(IDC_IPEDIT);}

  CComponentDataObject* m_pComponentData;
  DECLARE_MESSAGE_MAP()
};


///////////////////////////////////////////////////////////////////////////////
// CDNSServer_RootHintsPropertyPage


class CDNSServer_RootHintsPropertyPage : public CDNSNameServersPropertyPage
{
public:
	CDNSServer_RootHintsPropertyPage();

  virtual BOOL OnInitDialog();
  virtual BOOL OnApply();

  afx_msg void OnCopyFrom();

protected:
	virtual void ReadRecordNodesList();
  virtual BOOL WriteNSRecordNodesList();
  void AddCopiedRootHintsToList(PDNS_RECORD pRootHintsRecordList);

  DECLARE_MESSAGE_MAP()
};

#include "servmon.h"

///////////////////////////////////////////////////////////////////////////////
// CDNSServerPropertyPageHolder
// page holder to contain DNS Server property pages

class CDNSServerPropertyPageHolder : public CPropertyPageHolderBase
{
public:
	CDNSServerPropertyPageHolder(CDNSRootData* pRootDataNode, CDNSServerNode* pServerNode,
				CComponentDataObject* pComponentData);
	
	~CDNSServerPropertyPageHolder();

	CDNSServerNode* GetServerNode() { return (CDNSServerNode*)GetTreeNode();}


protected:
	virtual void OnSheetMessage(WPARAM wParam, LPARAM lParam);
	virtual HRESULT OnAddPage(int nPage, CPropertyPageBase* pPage);
	virtual int OnSelectPageMessage(long nPageCode) { return nPageCode;}

private:
	CDNSServer_InterfacesPropertyPage	m_interfacesPage;
  CDNSServer_DomainForwardersPropertyPage m_newForwardersPage;
	CDNSServer_AdvancedPropertyPage		m_advancedPage;
	CDNSServer_RootHintsPropertyPage	m_rootHintsPage;

	CDNSServer_TestPropertyPage			  m_testPage;
	CDNSServer_DebugLoggingPropertyPage m_debugLoggingPage;
  CDNSServer_EventLoggingPropertyPage m_eventLoggingPage;

	// optional security page
	CAclEditorPage*					m_pAclEditorPage;
};


#endif // _SERVERUI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\servmon.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       servmon.cpp
//
//--------------------------------------------------------------------------


#include "preDNSsn.h"
#include <SnapBase.h>

#include "resource.h"
#include "dnsutil.h"
#include "DNSSnap.h"
#include "snapdata.h"

#include "server.h"
#include "serverui.h"

#ifdef DEBUG_ALLOCATOR
        #ifdef _DEBUG
        #define new DEBUG_NEW
        #undef THIS_FILE
        static char THIS_FILE[] = __FILE__;
        #endif
#endif

#define CDNSServerMonitoringPageHolder CDNSServerPropertyPageHolder

#define MAX_STATISTICS_LINE_LEN 256


/////////////////////////////////////////////////////////////////////////////

int FormatDate(SYSTEMTIME* p, LPWSTR lpsz, int nCharMax)
{
    return ::GetDateFormat(LOCALE_USER_DEFAULT,
                        DATE_SHORTDATE,
                        p,
                        NULL,
                        lpsz,
                        nCharMax);
}

int FormatTime(SYSTEMTIME* p, LPWSTR lpsz, int nCharMax)
{
    return ::GetTimeFormat(LOCALE_USER_DEFAULT,
                        0,
                        p,
                        NULL,
                        lpsz,
                        nCharMax);
}

UINT LoadLabelsBlock(UINT nStringID, CString& szLabels, LPWSTR* szLabelArray)
{
        UINT nLabelCount = 0;
        if (szLabels.LoadString(nStringID))
        {
                ParseNewLineSeparatedString(szLabels.GetBuffer(1),szLabelArray, &nLabelCount);
                szLabels.ReleaseBuffer();
        }
        return nLabelCount;
}


///////////////////////////////////////////////////////////////////////////////
// CDNSServer_TestPropertyPage

CDNSServer_PollingIntervalEditGroup::
                CDNSServer_PollingIntervalEditGroup(UINT nMinVal, UINT nMaxVal)
                : CDNSTimeIntervalEditGroup(nMinVal, nMaxVal)
{
}


void CDNSServer_PollingIntervalEditGroup::OnEditChange()
{
        m_pPage->SetDirty(TRUE);
}

void CTestResultsListCtrl::Initialize()
{
   // get size of control to help set the column widths
   CRect controlRect;
   GetClientRect(controlRect);

   // get width of control, width of potential scrollbar, width needed for sub-item
   // string
   int controlWidth = controlRect.Width();
   int scrollThumbWidth = ::GetSystemMetrics(SM_CXHTHUMB);

   // clean net width
   int nNetControlWidth = controlWidth - scrollThumbWidth  - 12 * ::GetSystemMetrics(SM_CXBORDER);

   // fields widths
   int nWidth = nNetControlWidth/SVR_TEST_RESULT_LISTVIEW_NCOLS;

   // set up columns
   CString szHeaders;

   {
      AFX_MANAGE_STATE(AfxGetStaticModuleState());
      szHeaders.LoadString(IDS_TEST_LISTVIEW_HEADERS);
   }
   ASSERT(!szHeaders.IsEmpty());
   LPWSTR lpszArr[SVR_TEST_RESULT_LISTVIEW_NCOLS];
   UINT n;
   ParseNewLineSeparatedString(szHeaders.GetBuffer(1), lpszArr, &n);
   szHeaders.ReleaseBuffer();
   ASSERT(n == SVR_TEST_RESULT_LISTVIEW_NCOLS);

   for (int k=0; k<SVR_TEST_RESULT_LISTVIEW_NCOLS; k++)
   {
      InsertColumn(k+1, lpszArr[k], LVCFMT_LEFT, nWidth, k+1);
   }

   // Set full row select
   ListView_SetExtendedListViewStyle(GetSafeHwnd(), LVS_EX_FULLROWSELECT);

}

void CTestResultsListCtrl::InsertEntry(CDNSServerTestQueryResult* pTestResult,
                                                                           int nItemIndex)
{
        WCHAR szDate[256];
        WCHAR szTime[256];
        FormatDate(pTestResult, szDate, 256);
        FormatTime(pTestResult, szTime, 256);

        BOOL bPlainQuery, bRecursiveQuery;
        CDNSServerTestQueryResult::Unpack(pTestResult->m_dwQueryFlags, &bPlainQuery, &bRecursiveQuery);

        UINT nState = 0;
        if (nItemIndex == 0 )
                nState = LVIS_SELECTED | LVIS_FOCUSED; // have at least one item, select it
        VERIFY(-1 != InsertItem(LVIF_TEXT , nItemIndex,
                        szDate,
                        nState, 0, 0, NULL));

        SetItemText(nItemIndex, 1, szTime); // TIME

        {
                AFX_MANAGE_STATE(AfxGetStaticModuleState());
                if (pTestResult->m_dwAddressResolutionResult != 0)
                {
                        CString szFailedOnNameResolution;
                        szFailedOnNameResolution.LoadString(IDS_SERVER_TEST_RESULT_FAIL_ON_NAME_RES);
                        if (bPlainQuery)
                                SetItemText(nItemIndex, 2, szFailedOnNameResolution);
                        if (bRecursiveQuery)
                                SetItemText(nItemIndex, 3, szFailedOnNameResolution);
                }
                else
                {
                        CString szFail;
                        szFail.LoadString(IDS_SERVER_TEST_RESULT_FAIL);
                        CString szPass;
                        szPass.LoadString(IDS_SERVER_TEST_RESULT_PASS);
                        if (bPlainQuery)
                                SetItemText(nItemIndex, 2,
                                        (pTestResult->m_dwPlainQueryResult == 0)? szPass : szFail);
                        if (bRecursiveQuery)
                                SetItemText(nItemIndex, 3,
                                        (pTestResult->m_dwRecursiveQueryResult == 0)? szPass : szFail);
                        }
        }
}

void CTestResultsListCtrl::UpdateEntry(CDNSServerTestQueryResult* pTestResult,
                                                                           int nItemIndex)
{
        // have to update DATE and TIME

        WCHAR szDate[256];
        WCHAR szTime[256];
        FormatDate(pTestResult, szDate, 256);
        FormatTime(pTestResult, szTime, 256);

        VERIFY(SetItem(nItemIndex, // nItem
                                        0,      // nSubItem
                                        LVIF_TEXT, // nMask
                                        szDate, // lpszItem
                                        0, // nImage
                                        0, // nState
                                        0, // nStateMask
                                        NULL // lParam
                                        ));
        CString szTemp;
        SetItemText(nItemIndex, 1, szTime);
}

void CTestResultsListCtrl::FormatDate(CDNSServerTestQueryResult* pTestResult,
                                                                          LPWSTR lpsz, int nCharMax)
{
    VERIFY( nCharMax > ::FormatDate(
                        &(pTestResult->m_queryTime),
                        lpsz,
                        nCharMax));
}

void CTestResultsListCtrl::FormatTime(CDNSServerTestQueryResult* pTestResult,
                                                                          LPWSTR lpsz, int nCharMax)
{
    VERIFY( nCharMax > ::FormatTime(
                        &(pTestResult->m_queryTime),
                        lpsz,
                        nCharMax));
}


BEGIN_MESSAGE_MAP(CDNSServer_TestPropertyPage, CPropertyPageBase)
        ON_BN_CLICKED(IDC_ENABLE_TESTING_CHECK, OnEnableTestingCheck)
        ON_BN_CLICKED(IDC_SIMPLE_QUERY_CHECK, OnQueryCheck)
        ON_BN_CLICKED(IDC_RECURSIVE_QUERY_CHECK, OnQueryCheck)
        ON_BN_CLICKED(IDC_TEST_NOW_BUTTON, OnTestNow)
END_MESSAGE_MAP()


CDNSServer_TestPropertyPage::CDNSServer_TestPropertyPage()
                                : CPropertyPageBase(IDD_SERVMON_TEST_PAGE),
                                m_pollingIntervalEditGroup(MIN_SERVER_TEST_INTERVAL, MAX_SERVER_TEST_INTERVAL)
{
}


BOOL CDNSServer_TestPropertyPage::OnInitDialog()
{
  CPropertyPageBase::OnInitDialog();

  m_pollingIntervalEditGroup.m_pPage = this;
  VERIFY(m_pollingIntervalEditGroup.Initialize(this,
                  IDC_POLLING_INT_EDIT, IDC_POLLING_INT_COMBO,IDS_TIME_INTERVAL_UNITS));

  HWND hWnd = ::GetDlgItem(GetSafeHwnd(), IDC_POLLING_INT_EDIT);

  // Disable IME support on the controls
  ImmAssociateContext(hWnd, NULL);

  VERIFY(m_listCtrl.SubclassDlgItem(IDC_RESULTS_LIST, this));
  m_listCtrl.Initialize();

  SetUIData();

  return TRUE;
}


void CDNSServer_TestPropertyPage::SetUIData()
{
  CDNSServerMonitoringPageHolder* pHolder = (CDNSServerMonitoringPageHolder*)GetHolder();
  CDNSServerNode* pServerNode = pHolder->GetServerNode();

  pServerNode->GetTestOptions(&m_testOptions);

  GetSimpleQueryCheck()->SetCheck(m_testOptions.m_bSimpleQuery);
  GetRecursiveQueryCheck()->SetCheck(m_testOptions.m_bRecursiveQuery);

  //
  // Check to see if this is a root server
  //
  BOOL bRoot = FALSE;
  DNS_STATUS err = ::ServerHasRootZone(pServerNode->GetRPCName(), &bRoot);
  if (err == 0 && bRoot)
  {
    //
    // Disable recursive queries on root server
    //
    GetRecursiveQueryCheck()->EnableWindow(FALSE);
    GetRecursiveQueryCheck()->SetCheck(FALSE);
  }

  CButton* pEnableTestingCheck = GetEnableTestingCheck();
  if (!(m_testOptions.m_bSimpleQuery || m_testOptions.m_bRecursiveQuery))
  {
    GetTestNowButton()->EnableWindow(FALSE);
    pEnableTestingCheck->EnableWindow(FALSE);
    pEnableTestingCheck->SetCheck(FALSE);
    m_pollingIntervalEditGroup.EnableUI(FALSE);
  }
  else
  {
    pEnableTestingCheck->SetCheck(m_testOptions.m_bEnabled);
  }

  m_pollingIntervalEditGroup.SetVal(m_testOptions.m_dwInterval);

  EnableControlsHelper(m_testOptions.m_bEnabled);

  PopulateList();
}

void CDNSServer_TestPropertyPage::EnableControlsHelper(BOOL bEnable)
{
        //GetSimpleQueryCheck()->EnableWindow(bEnable);
        //GetRecursiveQueryCheck()->EnableWindow(bEnable);
        m_pollingIntervalEditGroup.EnableUI(bEnable);
}

BOOL CDNSServer_TestPropertyPage::OnApply()
{
        if (!IsDirty())
                return TRUE;

        CDNSServerTestOptions newTestOptions;

        newTestOptions.m_bEnabled = GetEnableTestingCheck()->GetCheck();
        newTestOptions.m_bSimpleQuery = GetSimpleQueryCheck()->GetCheck();
        newTestOptions.m_bRecursiveQuery = GetRecursiveQueryCheck()->GetCheck();
        newTestOptions.m_dwInterval = m_pollingIntervalEditGroup.GetVal();


        if (newTestOptions == m_testOptions)
                return TRUE; // no need to update

        m_testOptions = newTestOptions;
        DNS_STATUS err = GetHolder()->NotifyConsole(this);
        if (err != 0)
        {
                DNSErrorDialog(err, IDS_MSG_SERVER_TEST_OPTIONS_UPDATE_FAILED);
                return FALSE;
        }
        else
        {
                SetDirty(FALSE);
        }
        return TRUE;
}

BOOL CDNSServer_TestPropertyPage::OnPropertyChange(BOOL, long*)
{
        CDNSServerMonitoringPageHolder* pHolder = (CDNSServerMonitoringPageHolder*)GetHolder();
        CDNSServerNode* pServerNode = pHolder->GetServerNode();
        pServerNode->ResetTestOptions(&m_testOptions);

        //if (err != 0)
        //      pHolder->SetError(err);
        //return (err == 0);

        return FALSE; // no need to UI changes on this
}

void CDNSServer_TestPropertyPage::OnEnableTestingCheck()
{
        SetDirty(TRUE);
        EnableControlsHelper(GetEnableTestingCheck()->GetCheck());
}

void CDNSServer_TestPropertyPage::OnQueryCheck()
{
  SetDirty(TRUE);
  BOOL bCanQuery = GetSimpleQueryCheck()->GetCheck() ||
                   GetRecursiveQueryCheck()->GetCheck();
  GetTestNowButton()->EnableWindow(bCanQuery);
  CButton* pEnableTestingCheck = GetEnableTestingCheck();
  pEnableTestingCheck->EnableWindow(bCanQuery);
  if (!bCanQuery)
  {
    GetTestNowButton()->EnableWindow(FALSE);
    pEnableTestingCheck->EnableWindow(FALSE);
    pEnableTestingCheck->SetCheck(FALSE);
    m_pollingIntervalEditGroup.EnableUI(FALSE);
  }
}

void CDNSServer_TestPropertyPage::OnTestNow()
{
        CDNSServerMonitoringPageHolder* pHolder = (CDNSServerMonitoringPageHolder*)GetHolder();
        CDNSServerNode* pServerNode = pHolder->GetServerNode();

        BOOL bSimpleQuery = GetSimpleQueryCheck()->GetCheck();
        BOOL bRecursiveQuery = GetRecursiveQueryCheck()->GetCheck();
        pHolder->GetComponentData()->PostMessageToTimerThread(
                                                                        WM_TIMER_THREAD_SEND_QUERY_TEST_NOW,
                                                                        (WPARAM)pServerNode,
                                                                        CDNSServerTestQueryResult::Pack(bSimpleQuery, bRecursiveQuery));
}

void CDNSServer_TestPropertyPage::OnHaveTestData(LPARAM lParam)
{
        TRACE(_T("CDNSServer_TestPropertyPage::OnHaveTestData(LPARAM lParam = %d)\n"), lParam);
        if (m_hWnd == NULL)
                return; // not page not created yet
        AddEntryToList((CDNSServerTestQueryResultList::addAction)lParam);
        SetFocus();
}


void CDNSServer_TestPropertyPage::AddEntryToList(CDNSServerTestQueryResultList::addAction action)
{
        CDNSServerMonitoringPageHolder* pHolder = (CDNSServerMonitoringPageHolder*)GetHolder();
        CDNSServerNode* pServerNode = pHolder->GetServerNode();
        CDNSServerTestQueryResultList* pResultList = &(pServerNode->m_testResultList);
        int nCount = m_listCtrl.GetItemCount();

        switch (action)
        {
        case CDNSServerTestQueryResultList::added:
        case CDNSServerTestQueryResultList::addedAndRemoved:
                {
                        if (action == CDNSServerTestQueryResultList::addedAndRemoved)
                        {
                                ASSERT(nCount > 0);
                                m_listCtrl.DeleteItem(nCount-1);
                        }

                        pResultList->Lock();

                        CDNSServerTestQueryResult* pTestResult = pResultList->GetHead();
                        m_listCtrl.InsertEntry(pTestResult, 0);

                        pResultList->Unlock();

                }
                break;
        case CDNSServerTestQueryResultList::changed:
                {
                        ASSERT(nCount > 0);
                        // for the moment just remove and add again
                        pResultList->Lock();

                        CDNSServerTestQueryResult* pTestResult = pResultList->GetHead();
                        m_listCtrl.UpdateEntry(pTestResult, 0);

                        pResultList->Unlock();
                }
                break;
        };

}

void CDNSServer_TestPropertyPage::PopulateList()
{
        m_listCtrl.DeleteAllItems();

        CDNSServerMonitoringPageHolder* pHolder = (CDNSServerMonitoringPageHolder*)GetHolder();
        CDNSServerNode* pServerNode = pHolder->GetServerNode();
        CDNSServerTestQueryResultList* pResultList = &(pServerNode->m_testResultList);

        pResultList->Lock();
        int k = 0;
        POSITION pos;
        for( pos = pResultList->GetHeadPosition(); pos != NULL; )
        {
                CDNSServerTestQueryResult* pTestResult = pResultList->GetNext(pos);
                m_listCtrl.InsertEntry(pTestResult, k++);
        }
        pResultList->Unlock();
}


/*
///////////////////////////////////////////////////////////////////////////////
// CDNSServerMonitoringPageHolder

CDNSServerMonitoringPageHolder::CDNSServerMonitoringPageHolder(CDNSRootData* pRootDataNode,
                                           CDNSServerNode* pServerNode, CComponentDataObject* pComponentData)
                : CPropertyPageHolderBase(pRootDataNode, pServerNode, pComponentData)
{
        ASSERT(pRootDataNode == GetContainerNode());

        m_bAutoDeletePages = FALSE; // we have the pages as embedded members
        AddPageToList((CPropertyPageBase*)&m_statisticsPage);
        AddPageToList((CPropertyPageBase*)&m_testPage);
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\servmon.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       servmon.h
//
//--------------------------------------------------------------------------


#ifndef _SERVMON_H
#define _SERVMON_H

#include "serverui.h"
#include "ipeditor.h"

///////////////////////////////////////////////////////////////////////////////
// FORWARD DECLARATIONS

class CDNSServerNode;


///////////////////////////////////////////////////////////////////////////////
// CDNSServer_TestPropertyPage

class CDNSServer_TestPropertyPage; // fwd decl

class CDNSServer_PollingIntervalEditGroup : public CDNSTimeIntervalEditGroup
{
public:
        CDNSServer_PollingIntervalEditGroup(UINT nMinVal, UINT nMaxVal);
        virtual void OnEditChange();
private:
        CDNSServer_TestPropertyPage* m_pPage;
        friend class CDNSServer_TestPropertyPage;
};


#define SVR_TEST_RESULT_LISTVIEW_NCOLS          4

class CTestResultsListCtrl : public CListCtrl
{
public:
        void Initialize();
        void InsertEntry(CDNSServerTestQueryResult* pTestResult, int nItemIndex);
        void UpdateEntry(CDNSServerTestQueryResult* pTestResult, int nItemIndex);

private:
        void FormatDate(CDNSServerTestQueryResult* pTestResult, LPWSTR lpsz, int nCharMax);
        void FormatTime(CDNSServerTestQueryResult* pTestResult, LPWSTR lpsz, int nCharMax);
};


class CDNSServer_TestPropertyPage : public CPropertyPageBase
{

// Construction
public:
        CDNSServer_TestPropertyPage();

        virtual BOOL OnPropertyChange(BOOL bScopePane, long* pChangeMask);

        void OnHaveTestData(LPARAM lParam);

// Implementation
protected:
        virtual void SetUIData();

        // Generated message map functions
        virtual BOOL OnInitDialog();
        virtual BOOL OnApply();

        afx_msg void OnTestNow();
        afx_msg void OnEnableTestingCheck();
        afx_msg void OnQueryCheck();

private:
        CDNSServer_PollingIntervalEditGroup m_pollingIntervalEditGroup;
        CTestResultsListCtrl                            m_listCtrl;


        CButton* GetTestNowButton()
                { return (CButton*)GetDlgItem(IDC_TEST_NOW_BUTTON);}

        CButton* GetEnableTestingCheck()
                { return (CButton*)GetDlgItem(IDC_ENABLE_TESTING_CHECK);}
        CButton* GetSimpleQueryCheck()
                { return (CButton*)GetDlgItem(IDC_SIMPLE_QUERY_CHECK);}
        CButton* GetRecursiveQueryCheck()
                { return (CButton*)GetDlgItem(IDC_RECURSIVE_QUERY_CHECK);}

        void EnableControlsHelper(BOOL bEnable);

        CDNSServerTestOptions m_testOptions;

        void AddEntryToList(CDNSServerTestQueryResultList::addAction action);
        void PopulateList();


        DECLARE_MESSAGE_MAP()

        friend class CDNSServer_PollingIntervalEditGroup;
};

///////////////////////////////////////////////////////////////////////////////
// CDNSServerMonitoringPageHolder
// page holder to contain DNS Server Monitoring property pages

/*
class CDNSServerMonitoringPageHolder : public CPropertyPageHolderBase
{
public:
        CDNSServerMonitoringPageHolder(CDNSRootData* pRootDataNode, CDNSServerNode* pServerNode,
                                CComponentDataObject* pComponentData);

        CDNSServerNode* GetServerNode() { return (CDNSServerNode*)GetTreeNode();}

private:
        CDNSServer_StatisticsPropertyPage       m_statisticsPage;
        CDNSServer_TestPropertyPage                     m_testPage;
};
*/
#endif // _SERVMON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\servwiz.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       servwiz.cpp
//
//--------------------------------------------------------------------------



#include "preDNSsn.h"
#include <SnapBase.h>

#include "resource.h"
#include "dnsutil.h"
#include "DNSSnap.h"

#include "snapdata.h"
#include "server.h"
#include "domain.h"
#include "servwiz.h"
#include "zone.h"
#include "dnsmgr.h"

#ifdef DEBUG_ALLOCATOR
    #ifdef _DEBUG
    #define new DEBUG_NEW
    #undef THIS_FILE
    static char THIS_FILE[] = __FILE__;
    #endif
#endif


//////////////////////////////////////////////////////////////////////
// export function to be called from DC Promo 

STDAPI DnsSetup(LPCWSTR lpszFwdZoneName,
                 LPCWSTR lpszFwdZoneFileName,
                 LPCWSTR lpszRevZoneName, 
                 LPCWSTR lpszRevZoneFileName, 
                 DWORD dwFlags)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  HRESULT hr = S_OK;
  IComponentData* pICD = NULL;

  //
  // create a dummy component data object:
  // need to have a proper contruction and destruction, so we behave
  // as a class factory would
  //
  CComObject<CDNSComponentDataObject>* pComponentData = NULL;
  CComObject<CDNSComponentDataObject>::CreateInstance(&pComponentData);

  //
  // Scoping so that the Log file will write exit function before
  // KillInstance is called
  //
  {
    TRACE_FUNCTION(DnsSetup);

    if (lpszFwdZoneName)
    {
      TRACE_LOGFILE(L"Forward Zone Name: %ws", lpszFwdZoneName);
    }
    else
    {
      TRACE_LOGFILE(L"Forward Zone Name: (null)");
    }

    if (lpszFwdZoneFileName)
    {
      TRACE_LOGFILE(L"Forward Zone File Name: %ws", lpszFwdZoneFileName);
    }
    else
    {
      TRACE_LOGFILE(L"Forward Zone File Name: (null)");
    }

    if (lpszRevZoneName)
    {
      TRACE_LOGFILE(L"Reverse Zone Name: %ws", lpszRevZoneName);
    }
    else
    {
      TRACE_LOGFILE(L"Reverse Zone Name: (null)");
    }

    if (lpszRevZoneFileName)
    {
      TRACE_LOGFILE(L"Reverse Zone File Name: %ws", lpszRevZoneFileName);
    }
    else
    {
      TRACE_LOGFILE(L"Reverse Zone File Name: (null)");
    }

    TRACE_LOGFILE(L"Flags: %d", dwFlags);


    ASSERT(pComponentData != NULL);
    if (pComponentData == NULL)
    {
      TRACE_LOGFILE(L"Failed to create and instance of CDNSComponentDataObject.");
      return E_OUTOFMEMORY;
    }

    hr = pComponentData->QueryInterface(IID_IComponentData, (void**)&pICD);
    if (FAILED(hr))
    {
      TRACE_LOGFILE(L"Failed QI on pComponentData for IID_IComponentData. return hr = 0x%x", hr);
      return hr;
    }
    ASSERT(pICD != NULL);

    //
    // get the root data node
    //
    CDNSRootData* pRootData = (CDNSRootData*)pComponentData->GetRootData();
    if (pRootData == NULL)
    {
      TRACE_LOGFILE(L"Failed to retrieve root data.");
      return E_FAIL;
    }
    ASSERT(pRootData != NULL);

    //
    // run the wizard
    //
    CDNSServerWizardHolder wiz(pRootData, pComponentData, NULL, /*bHideUI*/ TRUE);

    hr = wiz.DnsSetup(lpszFwdZoneName, 
                      lpszFwdZoneFileName,
                      lpszRevZoneName, 
                      lpszRevZoneFileName,
                      dwFlags);

    if (SUCCEEDED(hr))
    {
      TRACE_LOGFILE(L"DnsSetup completed successfully.");
    }
    else
    {
      TRACE_LOGFILE(L"An error occurred in DnsSetup, returning hr = 0x%x", hr);
    }
  }

  // final destruction
  pICD->Release();
  return hr;
}



//////////////////////////////////////////////////////////////////////
void TraceRootHints(PDNS_RECORD pList)
{
    PDNS_RECORD pCurrRec = pList;
    while (pCurrRec)
    {
        TRACE(_T("owner %s, type %d "), pCurrRec->pName, pCurrRec->wType);
        if (pCurrRec->wType == DNS_TYPE_NS)
            TRACE(_T("NS, host %s\n"), pCurrRec->Data.NS.pNameHost);
        else if (pCurrRec->wType == DNS_TYPE_A)
        {
            CString szTemp;
      FormatIpAddress(szTemp, pCurrRec->Data.A.IpAddress);
            TRACE(_T("A, IP %s\n"), (LPCTSTR)szTemp);
        }
        else 
            TRACE(_T("\n"));
        pCurrRec = pCurrRec->pNext;
    }
}

////////////////////////////////////////////////////////////////////////
// CNewDialog

class CNewServerDialog : public CHelpDialog
{
// Construction
public:
    CNewServerDialog(CDNSServerWizardHolder* pHolder, CWnd* pParentWnd);   

    BOOL m_bLocalMachine;
    BOOL m_bConfigure;

// Dialog Data
    enum { IDD = IDD_CHOOSER_CHOOSE_MACHINE };
    CEdit       m_serverNameCtrl;
    CString     m_szServerName;

// Implementation
protected:

    // Generated message map functions
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    afx_msg void OnEditChange();
    afx_msg void OnLocalMachineRadio();
    afx_msg void OnSpecificMachineRadio();

    DECLARE_MESSAGE_MAP()
private:
    CDNSServerWizardHolder* m_pHolder;

};

BEGIN_MESSAGE_MAP(CNewServerDialog, CHelpDialog)
    ON_BN_CLICKED(IDC_CHOOSER_RADIO_LOCAL_MACHINE, OnLocalMachineRadio) 
    ON_BN_CLICKED(IDC_CHOOSER_RADIO_SPECIFIC_MACHINE, OnSpecificMachineRadio)
    ON_EN_CHANGE(IDC_CHOOSER_EDIT_MACHINE_NAME,OnEditChange)
END_MESSAGE_MAP()

CNewServerDialog::CNewServerDialog(CDNSServerWizardHolder* pHolder, CWnd* pParentWnd)
    : CHelpDialog(CNewServerDialog::IDD, pParentWnd, pHolder->GetComponentData())
{
    ASSERT(m_pHolder != NULL);
    m_pHolder = pHolder;
    m_bConfigure = TRUE;
    m_bLocalMachine = TRUE;
}

BOOL CNewServerDialog::OnInitDialog() 
{
    CHelpDialog::OnInitDialog();
    VERIFY(m_serverNameCtrl.SubclassDlgItem(IDC_CHOOSER_EDIT_MACHINE_NAME, this));
    CButton* pContactCheck = (CButton*)GetDlgItem(IDC_CHOOSER_CHECK_CONTACT);
    pContactCheck->SetCheck(m_bConfigure);

  //
  // Limit is actually 255 bytes but we will let 255 characters just to be safe
  //
  m_serverNameCtrl.SetLimitText(255);
    if (m_bLocalMachine)
    {
        ((CButton*)GetDlgItem(IDC_CHOOSER_RADIO_LOCAL_MACHINE))->SetCheck(TRUE);
        m_serverNameCtrl.EnableWindow(FALSE);
    }
    else
    {
        ((CButton*)GetDlgItem(IDC_CHOOSER_RADIO_SPECIFIC_MACHINE))->SetCheck(TRUE);
        GetDlgItem(IDOK)->EnableWindow(FALSE);
    }
    return TRUE;  // return TRUE unless you set the focus to a control
}

void CNewServerDialog::OnLocalMachineRadio()
{
    m_bLocalMachine = TRUE;
    m_serverNameCtrl.EnableWindow(FALSE);
    GetDlgItem(IDOK)->EnableWindow(TRUE);
    m_szServerName.Empty();
}

void CNewServerDialog::OnSpecificMachineRadio()
{
    m_bLocalMachine = FALSE;
    m_serverNameCtrl.EnableWindow(TRUE);
    OnEditChange();
}

void CNewServerDialog::OnEditChange()
{
  //
    // just check to be sure the editbox is not empty:
    // 
    m_serverNameCtrl.GetWindowText(m_szServerName);
    m_szServerName.TrimLeft();
    m_szServerName.TrimRight();
    GetDlgItem(IDOK)->EnableWindow(!m_szServerName.IsEmpty());
}

void CNewServerDialog::OnOK()
{
    CButton* pContactCheck = (CButton*)GetDlgItem(IDC_CHOOSER_CHECK_CONTACT);
    m_bConfigure = pContactCheck->GetCheck();

  BOOL bLocalHost = FALSE;
    if (m_bLocalMachine)
    {
        DWORD dwLen = MAX_COMPUTERNAME_LENGTH+1;
        BOOL bRes = ::GetComputerName(m_szServerName.GetBuffer(dwLen),
                                        &dwLen);
        ASSERT(dwLen <= MAX_COMPUTERNAME_LENGTH);
        m_szServerName.ReleaseBuffer();
        if (!bRes)
    {
            m_szServerName = _T("localhost.");
    }

    bLocalHost = TRUE;
    }
    else
    {
        m_serverNameCtrl.GetWindowText(m_szServerName);
    }
    CDNSRootData* pRootData = (CDNSRootData*)m_pHolder->GetRootData();
    if (!pRootData->VerifyServerName(m_szServerName))
    {
        // illegal name, warn the user and prompt again
        DNSMessageBox(IDS_DUPLICATE_SERVER, MB_OK | MB_ICONERROR);
        m_serverNameCtrl.SetSel(0,-1);
        m_serverNameCtrl.SetFocus();
        return;
    }

    m_pHolder->m_pServerNode->SetDisplayName(m_szServerName);
  m_pHolder->m_pServerNode->SetLocalServer(bLocalHost);
    
  if (m_bConfigure)
  {
    // try to contact server
    BOOL bAlreadyConfigured = FALSE;
    DWORD dwErr = m_pHolder->GetServerInfo(&bAlreadyConfigured, GetSafeHwnd());
    if (dwErr != 0)
    {
      CString szMessageFmt, szError, szMsg;
      szMessageFmt.LoadString(IDS_MSG_SERVWIZ_FAIL_CONTACT_ADD);
      if (dwErr == RPC_S_UNKNOWN_IF || dwErr == EPT_S_NOT_REGISTERED)
      {
        CString szResourceString;
        szResourceString.LoadString(IDS_MSG_SERVWIZ_NOT_NT5);
        szMsg.Format(szMessageFmt, szResourceString);
      }
      else
      {
        if (!CDNSErrorInfo::GetErrorString(dwErr, szError))
        {
           szError.Format(_T("Error 0x%x"), dwErr);
        }

        //
        // NTRAID#Windows Bugs-340841-2001/03/12-jeffjon : if the error
        // message already ends in a period we should remove it so that
        // the dialog only shows one
        //
        CString szPeriod;
        szPeriod.LoadString(IDS_PERIOD);

        if (szError.GetAt(szError.GetLength() - 1) == szPeriod)
        {
           szError.SetAt(szError.GetLength() - 1, L'\0');
        }
        szMsg.Format(szMessageFmt, (LPCTSTR)szError);
      }
      if (IDYES == DNSMessageBox(szMsg, MB_YESNO))
      {
        m_bConfigure = FALSE;
      }
      else
      {
          m_serverNameCtrl.SetSel(0,-1);
        m_serverNameCtrl.SetFocus();
        
        return;  // maybe the user wants to change name...
      }
    }
    else
    {
      m_bConfigure = FALSE;
    }
  }
    
    if (!m_bConfigure)
    {
        m_pHolder->InsertServerIntoUI();
    }
    CHelpDialog::OnOK();
}


///////////////////////////////////////////////////////////////////////////////
// CDNSServerWiz_StartPropertyPage

BEGIN_MESSAGE_MAP(CDNSServerWiz_StartPropertyPage, CPropertyPageBase)
   ON_BN_CLICKED(IDC_HELP_BUTTON, OnChecklist)
END_MESSAGE_MAP()

CDNSServerWiz_StartPropertyPage::CDNSServerWiz_StartPropertyPage() 
        : CPropertyPageBase(CDNSServerWiz_StartPropertyPage::IDD)
{
    InitWiz97(TRUE,0,0, true);
}

void CDNSServerWiz_StartPropertyPage::OnWizardHelp()
{
  CComPtr<IDisplayHelp> spHelp;
  HRESULT hr = GetHolder()->GetComponentData()->GetConsole()->QueryInterface(IID_IDisplayHelp, (void **)&spHelp);
  if (SUCCEEDED(hr)) 
    spHelp->ShowTopic(L"DNSConcepts.chm::/sag_DNS_CYDNS_01.htm");
}

void CDNSServerWiz_StartPropertyPage::OnChecklist()
{
  CComPtr<IDisplayHelp> spHelp;
  HRESULT hr = GetHolder()->GetComponentData()->GetConsole()->QueryInterface(IID_IDisplayHelp, (void **)&spHelp);
  if (SUCCEEDED(hr)) 
    spHelp->ShowTopic(L"DNSConcepts.chm::/sag_DNSChkConfig.htm");
}

BOOL CDNSServerWiz_StartPropertyPage::OnInitDialog()
{
  CPropertyPageBase::OnInitDialog();
  SetBigBoldFont(m_hWnd, IDC_STATIC_WELCOME);
    return TRUE;
}

BOOL CDNSServerWiz_StartPropertyPage::OnSetActive()
{
    GetHolder()->SetWizardButtonsFirst(TRUE);
    return TRUE;
}

LRESULT CDNSServerWiz_StartPropertyPage::OnWizardNext()
{
    CDNSServerWizardHolder* pHolder = (CDNSServerWizardHolder*)GetHolder();

    UINT nNextPage = IDD;  // default do not advance
  nNextPage = CDNSServerWiz_ScenarioPropertyPage::IDD;
  pHolder->m_pScenarioPage->m_nPrevPageID = IDD;
  return nNextPage;
}

///////////////////////////////////////////////////////////////////////////////
// CDNSServerWiz_ScenarioPropertyPage

CDNSServerWiz_ScenarioPropertyPage::CDNSServerWiz_ScenarioPropertyPage() 
        : CPropertyPageBase(CDNSServerWiz_ScenarioPropertyPage::IDD)
{
    InitWiz97(FALSE,IDS_SERVWIZ_SCENARIO_TITLE,IDS_SERVWIZ_SCENARIO_SUBTITLE, true);
}

void CDNSServerWiz_ScenarioPropertyPage::OnWizardHelp()
{
  CComPtr<IDisplayHelp> spHelp;
  HRESULT hr = GetHolder()->GetComponentData()->GetConsole()->QueryInterface(IID_IDisplayHelp, (void **)&spHelp);
  if (SUCCEEDED(hr)) 
    spHelp->ShowTopic(L"DNSConcepts.chm::/sag_DNS_CYDNS_02.htm");
}

BOOL CDNSServerWiz_ScenarioPropertyPage::OnInitDialog()
{
  CPropertyPageBase::OnInitDialog();
  SendDlgItemMessage(IDC_SMALL_RADIO, BM_SETCHECK, BST_CHECKED, 0);
    return TRUE;
}

BOOL CDNSServerWiz_ScenarioPropertyPage::OnSetActive()
{
    GetHolder()->SetWizardButtonsMiddle(TRUE);
    return TRUE;
}

LRESULT CDNSServerWiz_ScenarioPropertyPage::OnWizardNext()
{
    CDNSServerWizardHolder* pHolder = (CDNSServerWizardHolder*)GetHolder();

  LRESULT lSmallRadioCheck = SendDlgItemMessage(IDC_SMALL_RADIO, BM_GETCHECK, 0, 0);
  LRESULT lMediumRadioCheck = SendDlgItemMessage(IDC_MEDIUM_RADIO, BM_GETCHECK, 0, 0);
  LRESULT lManuallyRadioCheck = SendDlgItemMessage(IDC_MANUALLY_RADIO, BM_GETCHECK, 0, 0);

  LRESULT nNextPage = 0;
  if (lSmallRadioCheck == BST_CHECKED)
  {
    nNextPage = CDNSServerWiz_SmallZoneTypePropertyPage::IDD;
    pHolder->m_pSmallZoneTypePage->m_nPrevPageID = IDD;
    pHolder->SetScenario(CDNSServerWizardHolder::SmallBusiness);
  }
  else if (lMediumRadioCheck == BST_CHECKED)
  {
    nNextPage = CDNSServerWiz_ConfigFwdZonePropertyPage::IDD;
    pHolder->m_pFwdZonePage->m_nPrevPageID = IDD;
    pHolder->SetScenario(CDNSServerWizardHolder::MediumBusiness);
  }
  else if (lManuallyRadioCheck == BST_CHECKED)
  {
    if (pHolder->QueryForRootServerRecords(NULL))
    {
      pHolder->m_bAddRootHints = TRUE;
    }
    nNextPage = CDNSServerWiz_FinishPropertyPage::IDD;
    pHolder->m_pFinishPage->m_nPrevPageID = IDD;
    pHolder->SetScenario(CDNSServerWizardHolder::Manually);
  }
  else
  {
    //
    // This shouldn't happen, don't change the page if it does
    //
    nNextPage = IDD;
  }

  return nNextPage;
}

LRESULT CDNSServerWiz_ScenarioPropertyPage::OnWizardBack()
{
    return (LRESULT)m_nPrevPageID;
}

///////////////////////////////////////////////////////////////////////////////
// CDNSServerWiz_ForwardersPropertyPage

BEGIN_MESSAGE_MAP(CDNSServerWiz_ForwardersPropertyPage, CPropertyPageBase)
   ON_BN_CLICKED(IDC_FORWARD_RADIO, OnChangeRadio)
   ON_BN_CLICKED(IDC_NO_FORWARDERS_RADIO, OnChangeRadio)
   ON_EN_CHANGE(IDC_IPEDIT, OnChangeRadio)
END_MESSAGE_MAP()

CDNSServerWiz_ForwardersPropertyPage::CDNSServerWiz_ForwardersPropertyPage() 
        : CPropertyPageBase(CDNSServerWiz_ForwardersPropertyPage::IDD)
{
    InitWiz97(FALSE,IDS_SERVWIZ_FORWARDERS_TITLE,IDS_SERVWIZ_FORWARDERS_SUBTITLE, true);
}

void CDNSServerWiz_ForwardersPropertyPage::OnWizardHelp()
{
  CComPtr<IDisplayHelp> spHelp;
  HRESULT hr = GetHolder()->GetComponentData()->GetConsole()->QueryInterface(IID_IDisplayHelp, (void **)&spHelp);
  if (SUCCEEDED(hr)) 
    spHelp->ShowTopic(L"DNSConcepts.chm::/sag_DNS_CYDNS_07.htm");
}

BOOL CDNSServerWiz_ForwardersPropertyPage::OnInitDialog()
{
  CPropertyPageBase::OnInitDialog();
    CDNSServerWizardHolder* pHolder = (CDNSServerWizardHolder*)GetHolder();
  if (pHolder != NULL)
  {
    UINT nScenario = pHolder->GetScenario();
    if (nScenario == CDNSServerWizardHolder::SmallBusiness)
    {
      SendDlgItemMessage(IDC_FORWARD_RADIO, BM_SETCHECK, BST_CHECKED, 0);
      SendDlgItemMessage(IDC_NO_FORWARDERS_RADIO, BM_SETCHECK, BST_UNCHECKED, 0);
    }
    else
    {
      SendDlgItemMessage(IDC_NO_FORWARDERS_RADIO, BM_SETCHECK, BST_CHECKED, 0);
      SendDlgItemMessage(IDC_FORWARD_RADIO, BM_SETCHECK, BST_UNCHECKED, 0);
    }
  }
  else
  {
    SendDlgItemMessage(IDC_FORWARD_RADIO, BM_SETCHECK, BST_CHECKED, 0);
    SendDlgItemMessage(IDC_NO_FORWARDERS_RADIO, BM_SETCHECK, BST_UNCHECKED, 0);
  }
    return TRUE;
}

void CDNSServerWiz_ForwardersPropertyPage::OnChangeRadio()
{
   LRESULT lForwarderRadio = SendDlgItemMessage(IDC_FORWARD_RADIO, BM_GETCHECK, 0, 0);
   if (lForwarderRadio == BST_CHECKED)
   {
      GetDlgItem(IDC_IPEDIT)->EnableWindow(TRUE);
      GetDlgItem(IDC_IPEDIT2)->EnableWindow(TRUE);

      CDNSIPv4Control* pForwarderCtrl = (CDNSIPv4Control*)GetDlgItem(IDC_IPEDIT);
      if (pForwarderCtrl->IsEmpty())
      {
         GetHolder()->SetWizardButtonsMiddle(FALSE);
      }
      else
      {
         GetHolder()->SetWizardButtonsMiddle(TRUE);
      }
   }
   else
   {
      GetDlgItem(IDC_IPEDIT)->EnableWindow(FALSE);
      GetDlgItem(IDC_IPEDIT2)->EnableWindow(FALSE);
      GetHolder()->SetWizardButtonsMiddle(TRUE);
   }
}

BOOL CDNSServerWiz_ForwardersPropertyPage::OnSetActive()
{
   GetHolder()->SetWizardButtonsMiddle(TRUE);
   OnChangeRadio();
   return TRUE;
}

LRESULT CDNSServerWiz_ForwardersPropertyPage::OnWizardNext()
{
    CDNSServerWizardHolder* pHolder = (CDNSServerWizardHolder*)GetHolder();

  LRESULT nNextPage = -1;

  LRESULT lCheck = SendDlgItemMessage(IDC_FORWARD_RADIO, BM_GETCHECK, 0, 0);
  if (lCheck == BST_CHECKED)
  {
    pHolder->m_bAddForwarder = TRUE;
  }
  else
  {
    pHolder->m_bAddForwarder = FALSE;
  }

  //
  // Try to load the root hints
  //
  if (pHolder->QueryForRootServerRecords(NULL))
  {
    nNextPage = CDNSServerWiz_FinishPropertyPage::IDD;
    pHolder->m_pFinishPage->m_nPrevPageID = IDD;
    pHolder->m_bAddRootHints = TRUE;
  }
  else
  {
    //
    // If they provided a forwarder then we don't care if root hints failed
    //
    nNextPage = CDNSServerWiz_FinishPropertyPage::IDD;
    pHolder->m_pFinishPage->m_nPrevPageID = IDD;
  }

  return nNextPage;
}

LRESULT CDNSServerWiz_ForwardersPropertyPage::OnWizardBack()
{
    CDNSServerWizardHolder* pHolder = (CDNSServerWizardHolder*)GetHolder();

  UINT nPrevPage = static_cast<UINT>(-1);

  //
    // if we did not add a FWD zone, we skipped the reverse one too
  //
  UINT nScenario = pHolder->GetScenario();
  if (nScenario == CDNSServerWizardHolder::SmallBusiness)
  {
    if (pHolder->m_bAddFwdZone)
    {
          nPrevPage = pHolder->m_pZoneWiz->GetLastEntryPointPageID();
    }
    else
    {
      nPrevPage = m_nPrevPageID;
    }
  }
  else if (nScenario == CDNSServerWizardHolder::MediumBusiness)
  {
      if (!pHolder->m_bAddFwdZone)
    {
          nPrevPage = CDNSServerWiz_ConfigFwdZonePropertyPage::IDD;
    }
      else if (pHolder->m_bAddRevZone)
    {
          nPrevPage = pHolder->m_pZoneWiz->GetLastEntryPointPageID();
    }
      else
    {
          nPrevPage = CDNSServerWiz_ConfigRevZonePropertyPage::IDD;
    }
  }
  else
  {
    //
    // We should never get here
    //
    ASSERT(FALSE);
    nPrevPage = IDD;
  }
  return (LRESULT)nPrevPage;
}

void CDNSServerWiz_ForwardersPropertyPage::GetForwarder(CString& strref)
{
 CDNSIPv4Control* pIPEdit = (CDNSIPv4Control*)GetDlgItem(IDC_IPEDIT);
 if (pIPEdit != NULL)
 {
   DWORD dwIPVal = 0;
   pIPEdit->GetIPv4Val(&dwIPVal);
   strref.Format(L"%d.%d.%d.%d", dwIPVal & 0xff,
                                 (dwIPVal >> 8) & 0xff,
                                 (dwIPVal >> 16) & 0xff,
                                 (dwIPVal >> 24) & 0xff);
 }

 CDNSIPv4Control* pIPEdit2 = (CDNSIPv4Control*)GetDlgItem(IDC_IPEDIT2);
 if (pIPEdit2 != NULL)
 {
   DWORD dwIPVal = 0;
   pIPEdit2->GetIPv4Val(&dwIPVal);

   if (dwIPVal != 0)
   {
      CString optionalValue;
      optionalValue.Format(L" %d.%d.%d.%d", dwIPVal & 0xff,
                                            (dwIPVal >> 8) & 0xff,
                                            (dwIPVal >> 16) & 0xff,
                                            (dwIPVal >> 24) & 0xff);

      strref += optionalValue;
   }
 }
}

BOOL CDNSServerWiz_ForwardersPropertyPage::OnApply()
{
  LRESULT lCheck = SendDlgItemMessage(IDC_FORWARD_RADIO, BM_GETCHECK, 0, 0);
  if (lCheck == BST_CHECKED)
  {
    //
    // Set the forwarders IP address on the server
    //
    CPropertyPageHolderBase* pHolder = GetHolder();
    CTreeNode* pTreeNode = pHolder->GetTreeNode();

    CDNSServerNode* pServerNode = dynamic_cast<CDNSServerNode*>(pTreeNode);
    if (pServerNode != NULL)
    {
      DWORD dwCount = 0;
      DWORD dwIPArray[2];
      ZeroMemory(dwIPArray, sizeof(DWORD) * 2);

      CDNSIPv4Control* pIPEdit = (CDNSIPv4Control*)GetDlgItem(IDC_IPEDIT);
      if (pIPEdit != NULL)
      {
        DWORD dwIP = 0;
        pIPEdit->GetIPv4Val(&dwIP);

        if (dwIP != 0)
        {
          dwIPArray[0] = dwIP;
          ++dwCount;
        }
      }

      CDNSIPv4Control* pIPEdit2 = (CDNSIPv4Control*)GetDlgItem(IDC_IPEDIT2);
      if (pIPEdit2 != NULL)
      {
        DWORD dwIP = 0;
        pIPEdit2->GetIPv4Val(&dwIP);

        if (dwIP != 0)
        {
          dwIPArray[dwCount] = dwIP;
          ++dwCount;
        }
      }


      if (dwCount)
      {
        DNS_STATUS err = pServerNode->ResetForwarders(dwCount, 
                                                      dwIPArray, 
                                                      DNS_DEFAULT_FORWARD_TIMEOUT, 
                                                      DNS_DEFAULT_SLAVE);
        if (err != 0)
        {
          ::SetLastError(err);
          return FALSE;
        }
      }
    }
  }

  return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// CDNSServerWiz_SmallZoneTypePropertyPage


void CDNSServerWiz_SmallZoneTypePropertyPage::OnWizardHelp()
{
  CComPtr<IDisplayHelp> spHelp;
  HRESULT hr = GetHolder()->GetComponentData()->GetConsole()->QueryInterface(IID_IDisplayHelp, (void **)&spHelp);
  if (SUCCEEDED(hr)) 
    spHelp->ShowTopic(L"DNSConcepts.chm::/sag_DNS_CYDNS_03.htm");
}

CDNSServerWiz_SmallZoneTypePropertyPage::CDNSServerWiz_SmallZoneTypePropertyPage() 
        : CPropertyPageBase(CDNSServerWiz_SmallZoneTypePropertyPage::IDD)
{
    InitWiz97(FALSE,IDS_SERVWIZ_SMALL_ZONE_TYPE_TITLE,IDS_SERVWIZ_SMALL_ZONE_TYPE_SUBTITLE, true);
}

BOOL CDNSServerWiz_SmallZoneTypePropertyPage::OnInitDialog()
{
  CPropertyPageBase::OnInitDialog();
  SendDlgItemMessage(IDC_PRIMARY_RADIO, BM_SETCHECK, BST_CHECKED, 0);
    return TRUE;
}

BOOL CDNSServerWiz_SmallZoneTypePropertyPage::OnSetActive()
{
    GetHolder()->SetWizardButtonsMiddle(TRUE);
    return TRUE;
}

LRESULT CDNSServerWiz_SmallZoneTypePropertyPage::OnWizardNext()
{
    CDNSServerWizardHolder* pHolder = (CDNSServerWizardHolder*)GetHolder();

    UINT nNextPage = 0;

  LRESULT lPrimaryCheck = SendDlgItemMessage(IDC_PRIMARY_RADIO, BM_GETCHECK, 0, 0);
  LRESULT lSecondaryCheck = SendDlgItemMessage(IDC_SECONDARY_RADIO, BM_GETCHECK, 0, 0);
  if (lPrimaryCheck == BST_CHECKED)
  {
    //
    // Set the state of the zone wizard
    //
      pHolder->m_bAddFwdZone = TRUE;

        nNextPage = pHolder->SetZoneWizardContextEx(TRUE,   
                                                DNS_ZONE_TYPE_PRIMARY, 
                                                pHolder->GetServerNode()->CanUseADS(),
                                                CDNSServerWiz_ForwardersPropertyPage::IDD, // next after wiz
                                                          CDNSServerWiz_SmallZoneTypePropertyPage::IDD); // prev from wiz
  }
  else if (lSecondaryCheck == BST_CHECKED)
  {
    //
    // Set the state of the zone wizard
    //
      pHolder->m_bAddFwdZone = TRUE;

        nNextPage = pHolder->SetZoneWizardContextEx(TRUE,   
                                                DNS_ZONE_TYPE_SECONDARY,
                                                FALSE,
                                                CDNSServerWiz_ForwardersPropertyPage::IDD, // next after wiz
                                                          CDNSServerWiz_SmallZoneTypePropertyPage::IDD); // prev from wiz
  }
  else
  {
    nNextPage = IDD;
  }

  return (LRESULT)nNextPage;
}

LRESULT CDNSServerWiz_SmallZoneTypePropertyPage::OnWizardBack()
{
    return (LRESULT)m_nPrevPageID;
}

///////////////////////////////////////////////////////////////////////////////
// CDNSServerWiz_NamePropertyPage

BEGIN_MESSAGE_MAP(CDNSServerWiz_NamePropertyPage, CPropertyPageBase)
    ON_EN_CHANGE(IDC_EDIT_DNSSERVER, OnServerNameChange)
END_MESSAGE_MAP()

CDNSServerWiz_NamePropertyPage::CDNSServerWiz_NamePropertyPage() 
        : CPropertyPageBase(CDNSServerWiz_NamePropertyPage::IDD)
{
    InitWiz97(FALSE,IDS_SERVWIZ_NAME_TITLE,IDS_SERVWIZ_NAME_SUBTITLE, true);
}

void CDNSServerWiz_NamePropertyPage::OnWizardHelp()
{
  CComPtr<IDisplayHelp> spHelp;
  HRESULT hr = GetHolder()->GetComponentData()->GetConsole()->QueryInterface(IID_IDisplayHelp, (void **)&spHelp);
  if (SUCCEEDED(hr)) 
    spHelp->ShowTopic(L"DNSConcepts.chm::/sag_DNS_CYDNS_04.htm");
}


void CDNSServerWiz_NamePropertyPage::OnServerNameChange()
{
    CDNSServerWizardHolder* pHolder = (CDNSServerWizardHolder*)GetHolder();

  //
  // just check to be sure the editbox is not empty:
    // 
    GetServerNameEdit()->GetWindowText(m_szServerName);
    m_szServerName.TrimLeft();
    m_szServerName.TrimRight();
    pHolder->SetWizardButtonsFirst(IsValidServerName(m_szServerName));
}


BOOL CDNSServerWiz_NamePropertyPage::OnSetActive()
{
    CDNSServerWizardHolder* pHolder = (CDNSServerWizardHolder*)GetHolder();
    pHolder->SetWizardButtonsMiddle(IsValidServerName(m_szServerName));
    return TRUE;
}


LRESULT CDNSServerWiz_NamePropertyPage::OnWizardNext()
{
    CDNSServerWizardHolder* pHolder = (CDNSServerWizardHolder*)GetHolder();
    pHolder->m_pServerNode->SetDisplayName(m_szServerName);

  UINT nNextPage = IDD;  // default do not advance

  if (pHolder->QueryForRootServerRecords(NULL))
  {
    pHolder->m_bAddRootHints = TRUE;
  }

  // go to configure zones
  nNextPage = CDNSServerWiz_ConfigFwdZonePropertyPage::IDD;
  pHolder->m_pFwdZonePage->m_nPrevPageID = IDD;

  return nNextPage;
}


LRESULT CDNSServerWiz_NamePropertyPage::OnWizardBack()
{
    return (LRESULT)m_nPrevPageID;
}


///////////////////////////////////////////////////////////////////////////////
// CDNSServerWiz_ConfigFwdZonePropertyPage

void CDNSServerWiz_ConfigFwdZonePropertyPage::OnWizardHelp()
{
  CComPtr<IDisplayHelp> spHelp;
  HRESULT hr = GetHolder()->GetComponentData()->GetConsole()->QueryInterface(IID_IDisplayHelp, (void **)&spHelp);
  if (SUCCEEDED(hr)) 
    spHelp->ShowTopic(L"DNSConcepts.chm::/sag_DNS_CYDNS_11.htm");
}

CDNSServerWiz_ConfigFwdZonePropertyPage::CDNSServerWiz_ConfigFwdZonePropertyPage() 
        : CPropertyPageBase(CDNSServerWiz_ConfigFwdZonePropertyPage::IDD)
{
    InitWiz97(FALSE,IDS_SERVWIZ_FWD_ZONE_TITLE,IDS_SERVWIZ_FWD_ZONE_SUBTITLE, true);
}

BOOL CDNSServerWiz_ConfigFwdZonePropertyPage::OnInitDialog()
{
    CPropertyPageBase::OnInitDialog();

    BOOL bAddFwdZone = TRUE; // default in the UI
    CheckRadioButton(IDC_ZONE_RADIO, IDC_NO_ZONE_RADIO,
        bAddFwdZone ? IDC_ZONE_RADIO : IDC_NO_ZONE_RADIO);

    return TRUE;
}


BOOL CDNSServerWiz_ConfigFwdZonePropertyPage::OnSetActive()
{
    GetHolder()->SetWizardButtonsMiddle(TRUE);
    return TRUE;
}

LRESULT CDNSServerWiz_ConfigFwdZonePropertyPage::OnWizardNext()
{
    CDNSServerWizardHolder* pHolder = (CDNSServerWizardHolder*)GetHolder();

    pHolder->m_bAddFwdZone = 
        (GetCheckedRadioButton(IDC_ZONE_RADIO, IDC_NO_ZONE_RADIO) == 
        IDC_ZONE_RADIO);

    UINT nNextPage = static_cast<UINT>(-1); 
    if (pHolder->m_bAddFwdZone) 
    {
        // move to reverse zone creation page
        nNextPage = pHolder->SetZoneWizardContext(TRUE,
                                              CDNSServerWiz_ConfigRevZonePropertyPage::IDD, // next after wiz
                                              CDNSServerWiz_ConfigFwdZonePropertyPage::IDD); // prev from wiz
    }
    else
    {
        pHolder->m_bAddRevZone = FALSE;
        // move to the finish page 
        pHolder->m_pFinishPage->m_nPrevPageID = IDD;

    if (pHolder->GetScenario() == CDNSServerWizardHolder::MediumBusiness)
    {
          nNextPage = CDNSServerWiz_ForwardersPropertyPage::IDD;
    }
    else
    {
      nNextPage = CDNSServerWiz_FinishPropertyPage::IDD;
    }
    }
    return (LRESULT) nNextPage;
}

LRESULT CDNSServerWiz_ConfigFwdZonePropertyPage::OnWizardBack()
{
    return (LRESULT)m_nPrevPageID;
}


///////////////////////////////////////////////////////////////////////////////
// CDNSServerWiz_ConfigRevZonePropertyPage

void CDNSServerWiz_ConfigRevZonePropertyPage::OnWizardHelp()
{
  CComPtr<IDisplayHelp> spHelp;
  HRESULT hr = GetHolder()->GetComponentData()->GetConsole()->QueryInterface(IID_IDisplayHelp, (void **)&spHelp);
  if (SUCCEEDED(hr)) 
    spHelp->ShowTopic(L"DNSConcepts.chm::/sag_DNS_CYDNS_16.htm");
}

CDNSServerWiz_ConfigRevZonePropertyPage::CDNSServerWiz_ConfigRevZonePropertyPage() 
        : CPropertyPageBase(CDNSServerWiz_ConfigRevZonePropertyPage::IDD)
{
    InitWiz97(FALSE,IDS_SERVWIZ_REV_ZONE_TITLE, IDS_SERVWIZ_REV_ZONE_SUBTITLE, true);
}

BOOL CDNSServerWiz_ConfigRevZonePropertyPage::OnInitDialog()
{
    CPropertyPageBase::OnInitDialog();

    BOOL bAddRevZone = TRUE; // default in the UI
    CheckRadioButton(IDC_ZONE_RADIO, IDC_NO_ZONE_RADIO,
        bAddRevZone ? IDC_ZONE_RADIO : IDC_NO_ZONE_RADIO);

    return TRUE;
}

BOOL CDNSServerWiz_ConfigRevZonePropertyPage::OnSetActive()
{
    GetHolder()->SetWizardButtonsMiddle(TRUE);
    return TRUE;
}

LRESULT CDNSServerWiz_ConfigRevZonePropertyPage::OnWizardNext()
{
    CDNSServerWizardHolder* pHolder = (CDNSServerWizardHolder*)GetHolder();

    pHolder->m_bAddRevZone = 
        (GetCheckedRadioButton(IDC_ZONE_RADIO, IDC_NO_ZONE_RADIO) == 
        IDC_ZONE_RADIO);

    UINT nNextPage = static_cast<UINT>(-1);
    if (pHolder->m_bAddRevZone) 
    {
    if (pHolder->GetScenario() == CDNSServerWizardHolder::MediumBusiness)
    {
          nNextPage = pHolder->SetZoneWizardContext(FALSE,
                                                CDNSServerWiz_ForwardersPropertyPage::IDD, // next after wiz
                                                      CDNSServerWiz_ConfigRevZonePropertyPage::IDD); // prev from wiz
    }
    else
    {
          nNextPage = pHolder->SetZoneWizardContextEx(FALSE,
                                                    DNS_ZONE_TYPE_PRIMARY,
                                                    pHolder->GetServerNode()->CanUseADS(),
                                                     CDNSServerWiz_FinishPropertyPage::IDD, // next after wiz
                                                       CDNSServerWiz_ConfigRevZonePropertyPage::IDD); // prev from wiz
    }
    }
    else
    {
        pHolder->m_pFinishPage->m_nPrevPageID = IDD;
    if (pHolder->GetScenario() == CDNSServerWizardHolder::MediumBusiness)
    {
          nNextPage = CDNSServerWiz_ForwardersPropertyPage::IDD;
    }
    else
    {
      nNextPage = CDNSServerWiz_FinishPropertyPage::IDD;
    }
    }
    return (LRESULT) nNextPage;
}


LRESULT CDNSServerWiz_ConfigRevZonePropertyPage::OnWizardBack()
{
    CDNSServerWizardHolder* pHolder = (CDNSServerWizardHolder*)GetHolder();
    if (pHolder->m_bAddFwdZone)
    {
        pHolder->SetZoneWizardContext(TRUE,
                                  CDNSServerWiz_ConfigRevZonePropertyPage::IDD, // next after wiz
                                            CDNSServerWiz_ConfigFwdZonePropertyPage::IDD); // prev from wiz
    //
    // fwd settings
    //
        return (LRESULT)pHolder->m_pZoneWiz->GetLastEntryPointPageID();
    }
    else
  {
        return (LRESULT)CDNSServerWiz_ConfigFwdZonePropertyPage::IDD;
  }
}

///////////////////////////////////////////////////////////////////////////////
// CDNSServerWiz_FinishPropertyPage

void CDNSServerWiz_FinishPropertyPage::OnWizardHelp()
{
  CComPtr<IDisplayHelp> spHelp;
  HRESULT hr = GetHolder()->GetComponentData()->GetConsole()->QueryInterface(IID_IDisplayHelp, (void **)&spHelp);
  if (SUCCEEDED(hr)) 
    spHelp->ShowTopic(L"DNSConcepts.chm::/sag_DNS_CYDNS_08.htm");
}

CDNSServerWiz_FinishPropertyPage::CDNSServerWiz_FinishPropertyPage() 
        : CPropertyPageBase(CDNSServerWiz_FinishPropertyPage::IDD)
{
    InitWiz97(TRUE,0,0, true);
}

BOOL CDNSServerWiz_FinishPropertyPage::OnInitDialog()
{
  CPropertyPageBase::OnInitDialog();
  SetBigBoldFont(m_hWnd, IDC_STATIC_COMPLETE);
  return TRUE;
}

BOOL CDNSServerWiz_FinishPropertyPage::OnSetActive()
{
  CDNSServerWizardHolder* pHolder = (CDNSServerWizardHolder*)GetHolder();
  pHolder->SetWizardButtonsLast(TRUE);
  DisplaySummaryInfo(pHolder);

  // NTRAID#NTBUG9-451182-2001/09/12-lucios
  // NTRAID#NTBUG9-605428-2002/04/19-artm
  // I'm leaving old code here (but commented out) b/c design
  // might decide at later date to reenable different messages.
  // I want to leave the framework readily available.
  // 
  // Note that to save localization work I've removed the strings 
  // from the string table.  What the messages were is included inline
  // below.

  CStatic* pStatic = (CStatic*)GetDlgItem(IDC_FINISH_STATIC);
  ASSERT(pStatic!=NULL);
  CString preamble, suffix;
  BOOL success;

  // Load the string to use for all wizard scenarios.
  success = preamble.LoadString(IDS_SERVWIZ_FINISH_NOTE_PREAMBLE);
  ASSERT(success != FALSE);

  //
  // Load any suffix strings that depend on the wizard scenario.
  //

  // If we are creating a new primary lookup zone (reverse or forward), 
  // we need to tell the user a little bit more.
  if ( (pHolder->m_bAddFwdZone && pHolder->m_pFwdZoneInfo->m_bPrimary) ||
      (pHolder->m_bAddRevZone && pHolder->m_pRevZoneInfo->m_bPrimary) )
  {
      success = suffix.LoadString(IDS_SERVWIZ_FINISH_NOTE_PRIMARY_SUFFIX);
      ASSERT(success != FALSE);
  }


  pStatic->SetWindowText(preamble + suffix);

  //switch(pHolder->GetScenario())
  //{
  //   case CDNSServerWizardHolder::SmallBusiness:
  //       ASSERT(note.LoadString(IDS_SMALL_OPTION_NOTE)!=0);
  //       note.LoadString(IDS_SMALL_OPTION_NOTE);
  //       pStatic->SetWindowText(note);
  //   // String was: "Note: You should now add records to the zone or ensure that records are updated dynamically. Also, ensure DNS clients use this server as their preferred DNS server and then verify name resolution using nslookup."
  //   break;
  //   case CDNSServerWizardHolder::MediumBusiness:
  //       ASSERT(note.LoadString(IDS_MEDIUM_OPTION_NOTE)!=0);
  //       note.LoadString(IDS_MEDIUM_OPTION_NOTE);
  //       pStatic->SetWindowText(note);
  //   // String was: "Note: You should now add records to the zones or ensure that records are updated dynamically. You might want to configure DNS clients to use this server as their preferred DNS server. You can then verify name resolution using nslookup."
  //   break;
  //   case CDNSServerWizardHolder::Manually:
  //       ASSERT(note.LoadString(IDS_MANUAL_OPTION_NOTE)!=0);
  //       note.LoadString(IDS_MANUAL_OPTION_NOTE);
  //       pStatic->SetWindowText(note);
  //   // String was: "Note: You might want to configure DNS clients to use this server as their preferred DNS server."
  //   break;
  //   default:
  //       // Unexpected. Leave original resource message 
  //       // that will be perceived as a bug
  //       ASSERT
  //       (
  //         (pHolder->GetScenario()!=CDNSServerWizardHolder::SmallBusiness) &&
  //         (pHolder->GetScenario()!=CDNSServerWizardHolder::MediumBusiness) &&
  //         (pHolder->GetScenario()!=CDNSServerWizardHolder::Manually)
  //       );
  //}

  return TRUE;
}

LRESULT CDNSServerWiz_FinishPropertyPage::OnWizardBack()
{
    CDNSServerWizardHolder* pHolder = (CDNSServerWizardHolder*)GetHolder();

  if (pHolder->GetScenario() == CDNSServerWizardHolder::SmallBusiness)
  {
    //
    // Small business scenario
    //
    return (LRESULT)m_nPrevPageID;

  }
  else if (pHolder->GetScenario() == CDNSServerWizardHolder::MediumBusiness)
  {
    //
    // Medium business scenario
    //
    return (LRESULT)m_nPrevPageID;
  }
  else
  {
    //
    // Configure manually
    //
    return CDNSServerWiz_ScenarioPropertyPage::IDD;
  }
  return CDNSServerWiz_ScenarioPropertyPage::IDD;
}

BOOL CDNSServerWiz_FinishPropertyPage::OnWizardFinish()
{
    CDNSServerWizardHolder* pHolder = (CDNSServerWizardHolder*)GetHolder();
    pHolder->OnFinish(); // it might return T/F, 
  return TRUE; // we do put up error messages, but the wizard gets dismissed
}


void CDNSServerWiz_FinishPropertyPage::DisplaySummaryInfo(CDNSServerWizardHolder* pHolder)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CStatic* pStatic = (CStatic*)GetDlgItem(IDC_SUMMARY_STATIC);

    // NOTICE-2002/04/11-artm  Rewrote to use string functions
    // in favor of wsprintf() (flagged by prefast and dangerous fctn
    // to boot).
    CString summary, buffer;
    CString szFmt;

    szFmt.LoadString(IDS_MSG_SERVWIZ_FINISH_NAME);
    summary.Format(
        static_cast<LPCTSTR>(szFmt),
        static_cast<LPCTSTR>(pHolder->m_pServerNode->GetDisplayName()));

  if (pHolder->m_bRootServer)
  {
    szFmt.LoadString(IDS_MSG_SERVWIZ_FINISH_ROOT_SERVER);
    summary += szFmt;
  }

  if (pHolder->GetScenario() != CDNSServerWizardHolder::Manually)
  {
    if (pHolder->m_bAddFwdZone) 
    {
      szFmt.LoadString(IDS_MSG_SERVWIZ_FINISH_FWD_ZONE);
      buffer.Format(
        static_cast<LPCTSTR>(szFmt),
        static_cast<LPCTSTR>(pHolder->m_pFwdZoneInfo->m_szZoneName));
      summary += buffer;
    }
    if (pHolder->m_bAddRevZone) 
    {
      szFmt.LoadString(IDS_MSG_SERVWIZ_FINISH_REV_ZONE);
      buffer.Format(
        static_cast<LPCTSTR>(szFmt),
        static_cast<LPCTSTR>(pHolder->m_pRevZoneInfo->m_szZoneName));
      summary += buffer;
    }

    if (pHolder->m_bAddForwarder)
    {
      CString szForwarder;
      pHolder->m_pForwardersPage->GetForwarder(szForwarder);

      if (!szForwarder.IsEmpty())
      {
        szFmt.LoadString(IDS_MSG_SERVWIZ_FINISH_FORWARDER);
        buffer.Format(
            static_cast<LPCTSTR>(szFmt),
            static_cast<LPCTSTR>(szForwarder));
        summary += buffer;
      }
    }
  }

   pStatic->SetWindowText(summary);
}


///////////////////////////////////////////////////////////////////////////////
// CDNSServerWizardHolder

CDNSServerWizardHolder::CDNSServerWizardHolder(CDNSRootData* pRootData, 
                                               CComponentDataObject* pComponentData, CDNSServerNode* pServerNode, BOOL bHideUI)
                : CPropertyPageHolderBase(pRootData, pServerNode, pComponentData)
{
    m_bWizardMode = TRUE;

    // assume this object will have to be destroyed from the autside
    m_bAutoDelete = FALSE; 

  m_forceContextHelpButton = forceOff;

    ASSERT(pRootData != NULL);
    ASSERT(pComponentData != NULL);

    m_bSkipNamePage = FALSE;
  m_bHideUI = bHideUI;
  m_dwDnsSetupFlags = 0;

    // initialize options settings (by default do nothing)
    m_bRootServer   = FALSE;
  m_bHasRootZone  = FALSE;
    m_bAddFwdZone   = FALSE;
    m_bAddRevZone   = FALSE;
  m_bAddRootHints = FALSE;
  m_bAddForwarder = FALSE;

  m_nScenario     = SmallBusiness;

    // execution state and error codes 
  if (pServerNode == NULL)
  {
    m_pServerNode = new CDNSServerNode(NULL);
    m_bServerNodeExists = FALSE;
  }
  else
  {
    m_pServerNode = pServerNode;
    m_bSkipNamePage = TRUE;
    m_bServerNodeExists = TRUE;
  }

    m_bServerNodeAdded = FALSE;
    m_bRootHintsAdded = FALSE;
    m_bRootZoneAdded = FALSE;
    m_bFwdZoneAdded = FALSE;
    m_bRevZoneAdded = FALSE;

  // always create
  m_pFwdZoneInfo = new CDNSCreateZoneInfo;
  m_pRevZoneInfo = new CDNSCreateZoneInfo;
 
  if (m_pServerNode &&
      m_pServerNode->GetDomainVersion() > DS_BEHAVIOR_WIN2000)
  {
     m_pFwdZoneInfo->m_replType = domain;
    m_pRevZoneInfo->m_replType = domain;
  }
  else
  {
     m_pFwdZoneInfo->m_replType = w2k;
    m_pRevZoneInfo->m_replType = w2k;
  }


    // embedded zone wizards hookup
  if (m_bHideUI)
  {
    m_pZoneWiz = NULL;
  }
  else
  {
    m_pZoneWiz = new CDNSZoneWizardHolder(pComponentData);
      m_pZoneWiz->SetServerNode(m_pServerNode);
      m_pZoneWiz->Initialize(NULL, FALSE); 
      m_pZoneWiz->Attach(this);
  }
    m_pRootHintsRecordList = NULL;

   // property pages insertion
   if (m_bHideUI)
   {
      m_pStartPage = NULL;
      m_pScenarioPage = NULL;
      m_pSmallZoneTypePage = NULL;
      m_pNamePage = NULL;
      m_pFwdZonePage = NULL;
      m_pRevZonePage = NULL;
      m_pFinishPage = NULL;
   }
   else
   {
      m_pStartPage = new CDNSServerWiz_StartPropertyPage;
      if (m_pStartPage)
      {
         AddPageToList((CPropertyPageBase*)m_pStartPage);
      }

      m_pScenarioPage = new CDNSServerWiz_ScenarioPropertyPage;
      if (m_pScenarioPage)
      {
         AddPageToList((CPropertyPageBase*)m_pScenarioPage);
      }

      m_pForwardersPage = new CDNSServerWiz_ForwardersPropertyPage;
      if (m_pForwardersPage)
      {
         AddPageToList((CPropertyPageBase*)m_pForwardersPage);
      }

      m_pSmallZoneTypePage = new CDNSServerWiz_SmallZoneTypePropertyPage;
      if (m_pSmallZoneTypePage)
      {
         AddPageToList((CPropertyPageBase*)m_pSmallZoneTypePage);
      }

      m_pNamePage = new CDNSServerWiz_NamePropertyPage;
      if (m_pNamePage)
      {
         AddPageToList((CPropertyPageBase*)m_pNamePage);
      }

      m_pFwdZonePage = new CDNSServerWiz_ConfigFwdZonePropertyPage;
      if (m_pFwdZonePage)
      {
         AddPageToList((CPropertyPageBase*)m_pFwdZonePage);
      }

      m_pRevZonePage = new CDNSServerWiz_ConfigRevZonePropertyPage;
      if (m_pRevZonePage)
      {
         AddPageToList((CPropertyPageBase*)m_pRevZonePage);
      }

      m_pFinishPage = new CDNSServerWiz_FinishPropertyPage;
      if (m_pFinishPage)
      {
         AddPageToList((CPropertyPageBase*)m_pFinishPage);
      }
   }
}

CDNSServerWizardHolder::~CDNSServerWizardHolder()
{
    delete m_pZoneWiz;
    SetRootHintsRecordList(NULL);
    if ( (m_pServerNode != NULL) && !m_bServerNodeAdded && !m_bServerNodeExists)
        delete m_pServerNode;
}


void CDNSServerWizardHolder::DoModalConnect()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
   CThemeContextActivator activator;

  HWND hWnd = GetMainWindow();
  CWnd* pParentWnd = CWnd::FromHandle(hWnd);
    CNewServerDialog dlg(this, pParentWnd);
    if (IDOK != dlg.DoModal())
        return; // canceled
    if (!dlg.m_bConfigure)
        return; // already added

    // we have to configure, call the wizard
    m_bSkipNamePage = TRUE;
    DoModalWizard();
  GetComponentData()->GetRootData()->SetDirtyFlag(TRUE);
}

void CDNSServerWizardHolder::DoModalConnectOnLocalComputer()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    // get the name of the local machine
    DWORD dwLen = MAX_COMPUTERNAME_LENGTH+1;
    CString szServerName;
    BOOL bRes = ::GetComputerName(szServerName.GetBuffer(dwLen),
                                    &dwLen);
    ASSERT(dwLen <= MAX_COMPUTERNAME_LENGTH);
    szServerName.ReleaseBuffer();
    if (!bRes)
  {
        szServerName = _T("localhost.");
  }

    m_pServerNode->SetDisplayName(szServerName);
  m_pServerNode->SetLocalServer(TRUE);
    
    // try to contact server
    BOOL bAlreadyConfigured = FALSE;
   HWND hWnd = GetMainWindow();

    if (0 != GetServerInfo(&bAlreadyConfigured, hWnd))
    {
        // failed to contact local server, just call the 
        // normal "connect to" dialog and wizard
        DoModalConnect();
    }
    else
    {
        // server successfully contacted
        if (bAlreadyConfigured)
        {
            // server is already setup, just insert in the UI
            InsertServerIntoUI();
        }
        else
        {
            // need to configure, invoke wizard proper
            m_bSkipNamePage = TRUE;
            InsertServerIntoUI();
        }
    }
}

UINT CDNSServerWizardHolder::SetZoneWizardContext(BOOL bForward, 
                                                  UINT nNextPage, 
                                                  UINT nPrevPage)
{
  ASSERT(m_pFwdZoneInfo != NULL);
  ASSERT(m_pRevZoneInfo != NULL);

    TRACE(_T("SetZoneWizardContext(%d)\n"),bForward);
    if (bForward)
    {
        m_pZoneWiz->SetZoneInfoPtr(m_pFwdZoneInfo);
        m_pZoneWiz->SetContextPages(nNextPage, nPrevPage);
    }
    else
    {
        m_pZoneWiz->SetZoneInfoPtr(m_pRevZoneInfo);
        m_pZoneWiz->SetContextPages(nNextPage, nPrevPage);
    }

    m_pZoneWiz->PreSetZoneLookupType(bForward);
    return m_pZoneWiz->GetFirstEntryPointPageID();
}


UINT CDNSServerWizardHolder::SetZoneWizardContextEx(BOOL bForward, 
                                                    UINT nZoneType, 
                                                    BOOL bADIntegrated,
                                                    UINT nNextPage, 
                                                    UINT nPrevPage)
{
  ASSERT(m_pFwdZoneInfo != NULL);
  ASSERT(m_pRevZoneInfo != NULL);

    TRACE(_T("SetZoneWizardContext(%d)\n"),bForward);
    if (bForward)
    {
        m_pZoneWiz->SetZoneInfoPtr(m_pFwdZoneInfo);
        m_pZoneWiz->SetContextPages(nNextPage, nPrevPage);
    }
    else
    {
        m_pZoneWiz->SetZoneInfoPtr(m_pRevZoneInfo);
        m_pZoneWiz->SetContextPages(nNextPage, nPrevPage);
    }

    m_pZoneWiz->PreSetZoneLookupTypeEx(bForward, nZoneType, bADIntegrated);
    return m_pZoneWiz->GetFirstEntryPointPageID();
}

HRESULT CDNSServerWizardHolder::OnAddPage(int, CPropertyPageBase* pPage)
{
    if (pPage != NULL)
    {
        UINT_PTR nPageID = (UINT_PTR)pPage->m_psp.pszTemplate;
        if (nPageID == CDNSServerWiz_ConfigFwdZonePropertyPage::IDD)
        {
            ASSERT(m_pZoneWiz != NULL);
            VERIFY(SUCCEEDED(m_pZoneWiz->AddAllPagesToSheet()));
        }
    }
    return S_OK;
}

DWORD CDNSServerWizardHolder::GetServerInfo(BOOL* pbAlreadyConfigured, HWND parentHwnd)
{
   TRACE_FUNCTION_IF_NO_UI(m_bHideUI, CDNSServerWizardHolder::GetServerInfo);
   CThemeContextActivator activator;


   CContactServerThread* pThreadObj = 
      new CContactServerThread(
         m_pServerNode->GetRPCName(), 
         (pbAlreadyConfigured != NULL));

   if (!pThreadObj)
   {
      return ERROR_OUTOFMEMORY;
   }

   CWnd* pParentWnd = CWnd::FromHandle(parentHwnd);

   TRACE_LOGFILE_IF_NO_UI(m_bHideUI, L"Contacting server...");
   CLongOperationDialog dlg(pThreadObj, pParentWnd, IDR_SEARCH_AVI);
   VERIFY(dlg.LoadTitleString(IDS_MSG_SERVWIZ_CONTACT));
   dlg.m_bExecuteNoUI = m_bHideUI;

   dlg.DoModal();
   DWORD dwErr = 0;
   if (!dlg.m_bAbandoned)
   {
      dwErr = pThreadObj->GetError();
      if (dwErr == 0)
      {
         CDNSServerInfoEx* pInfoEx = pThreadObj->DetachInfo();
         ASSERT(pInfoEx != NULL);
         m_pServerNode->AttachServerInfo(pInfoEx);

         CDNSRootHintsNode* pNewRootHints = pThreadObj->DetachRootHintsNode();
         if (pNewRootHints != NULL)
         {
            // root hints can be null on a root server
            m_pServerNode->AttachRootHints(pNewRootHints);
            TRACE_LOGFILE_IF_NO_UI(m_bHideUI, L"Attaching root hints...");
         }

         if (pbAlreadyConfigured != NULL)
         {
            *pbAlreadyConfigured = pThreadObj->IsAlreadyConfigured();
         }
      }
   }
   return dwErr;
}


BOOL CDNSServerWizardHolder::QueryForRootServerRecords(IP_ADDRESS* pIpAddr)
{
   CThemeContextActivator activator;

   // clear the current list of root hint info
   SetRootHintsRecordList(NULL);

   // create a thread object and set the name of servers to query
   CRootHintsQueryThread* pThreadObj = new CRootHintsQueryThread;
   if (pThreadObj == NULL)
   {
      ASSERT(FALSE);
      return FALSE;
   }

  if (pIpAddr == NULL)
  {
    CRootData* pRootData = GetRootData();
      if (!pRootData->HasChildren() && (m_pServerNode == NULL))
          return FALSE;
    VERIFY(pThreadObj->LoadServerNames(pRootData, m_pServerNode));
  }
  else
  {
    // if IP address given, try it
    pThreadObj->LoadIPAddresses(1, pIpAddr);
  }

    // create a dialog and attach the thread to it
  HWND hWnd = GetMainWindow();
  CWnd* pParentWnd = CWnd::FromHandle(hWnd);

    CLongOperationDialog dlg(pThreadObj, pParentWnd, IDR_SEARCH_AVI);
    VERIFY(dlg.LoadTitleString(IDS_MSG_SERVWIZ_COLLECTINFO));
  dlg.m_bExecuteNoUI = m_bHideUI;

    dlg.DoModal();
    if (!dlg.m_bAbandoned)
    {
        if (pThreadObj->GetError() != 0)
        {
      if (!m_bHideUI && (pIpAddr != NULL))
              DNSMessageBox(IDS_MSG_SERVWIZ_FAIL_ROOT_HINTS);
        }
        else
        {
            // success, get the root hints info to the holder
            SetRootHintsRecordList(pThreadObj->GetHintsRecordList());
            TraceRootHints(m_pRootHintsRecordList);
        }
        return (pThreadObj->GetError() == 0);
    }
    return FALSE;
}


void CDNSServerWizardHolder::InsertServerIntoUI()
{
  ASSERT(!m_bHideUI);
    // insert the server in the UI
    ASSERT(m_pServerNode != NULL);
    if (!m_bServerNodeAdded)
    {
        GetRootData()->AddServer(m_pServerNode,GetComponentData());
        m_bServerNodeAdded = TRUE;
    }
}

BOOL CDNSServerWizardHolder::OnFinish()
{
  USES_CONVERSION;

  CString szLastErrorMessage;
    BOOL bRet = TRUE;
    DNS_STATUS dwErr = 0;

  TRACE_FUNCTION_IF_NO_UI(m_bHideUI, CDNSServerWizardHolder::OnFinish);

  do // false loop
  {
    if (m_bHideUI)
    {
      //
      // insert into list of servers, but not in the UI
      //
      GetRootData()->AddChildToList(m_pServerNode);
      m_bServerNodeAdded = TRUE;
    }
    else
    {
      //  
        // force the node to expand and wait for completion
        // only if not called from the empty snapin scenario (auto insertion)
      //
        if (m_pServerNode->IsExpanded() && !m_bServerNodeExists)
      {
            EnumerateMTNodeHelper(m_pServerNode, GetComponentData());
      }
    }

    if (m_bAddRootHints && m_pRootHintsRecordList != NULL)
    {
      //
      // Root hints were detected automatically.  Add them now.
      //
          dwErr = InitializeRootHintsList();
      TRACE_LOGFILE_IF_NO_UI(m_bHideUI, L"InitializeRootHintsList() returned dwErr = 0x%x", dwErr);
          if (dwErr == 0)
          {
              m_bRootHintsAdded = TRUE;
          }
          else
          {
              bRet = FALSE;
        if (!m_bHideUI)
        {
                  DNSErrorDialog(dwErr, IDS_MSG_SERVWIZ_FAIL_UPDATE_ROOT_HINTS);
        }
        else
        {
          ::SetLastError(dwErr);
        }
        DNSCreateErrorMessage(dwErr, IDS_MSG_SERVWIZ_FAIL_UPDATE_ROOT_HINTS, szLastErrorMessage);
        break; // false loop
          }
    }
    else
    {
       if (!m_bHideUI)
       {
          DNSMessageBox(IDS_ERR_PRIME_ROOT_HINTS, MB_OK | MB_ICONERROR);
       }
    }

    //
      // zone creation: root
    //
      if (m_bRootServer && !m_bRootZoneAdded && !m_bHideUI)
      {
      //
          // for a root server, need to create a root zone
      //
      CDNSCreateZoneInfo    rootZoneInfo;
          rootZoneInfo.m_bPrimary = TRUE;
          rootZoneInfo.m_bForward = TRUE;
          rootZoneInfo.m_szZoneName = _T(".");
          rootZoneInfo.m_szZoneStorage = _T("root.dns");
          rootZoneInfo.m_storageType = CDNSCreateZoneInfo::newFile;
  
      //
      // dynamic turned off for security reasons...
      //
      rootZoneInfo.m_nDynamicUpdate = ZONE_UPDATE_OFF;

        dwErr = CDNSZoneWizardHolder::CreateZoneHelper(m_pServerNode, 
                                                    &rootZoneInfo, 
                                                    GetComponentData());

      TRACE_LOGFILE_IF_NO_UI(m_bHideUI, L"Root Zone creation returned dwErr = 0x%x", dwErr);
          if (dwErr != 0)
          {
              bRet = FALSE;
        if (!m_bHideUI)
        {
                DNSErrorDialog(dwErr, IDS_MSG_SERVWIZ_FAIL_ADD_ROOT_ZONE);
        }
        else
        {
          ::SetLastError(dwErr);
        }
        DNSCreateErrorMessage(dwErr, IDS_MSG_SERVWIZ_FAIL_ADD_ROOT_ZONE, szLastErrorMessage);
        break; // false loop
          }
          else
          {
              m_bRootZoneAdded = TRUE;
          }
      }

      // zone creation: forward lookup zone
      if (m_bAddFwdZone && 
         !m_bFwdZoneAdded &&
         GetScenario() != CDNSServerWizardHolder::Manually)
      {
      if (m_bHideUI)
      {
        // Add a DCPromo zone
        TRACE_LOGFILE(L"Creating forward lookup zone for DCPromo.");
        dwErr =
         ::DnssrvCreateZoneForDcPromoEx(
            m_pServerNode->GetRPCName(),
            W_TO_UTF8(m_pFwdZoneInfo->m_szZoneName),
            W_TO_UTF8(m_pFwdZoneInfo->m_szZoneStorage),
            DNS_ZONE_CREATE_FOR_DCPROMO);

        // NTRAID#NTBUG9-359894-2001/06/09-sburns
        
        if (dwErr == 0 && (m_dwDnsSetupFlags & DNS_SETUP_ZONE_CREATE_FOR_DCPROMO_FOREST))
        {
          // need to make string instances because the l_a_m_e W_TO_UTF8 macro
          // can't take an expression as a parameter.
          
          CString zone(L"_msdcs." + m_pFwdZoneInfo->m_szZoneName);
          CString stor(L"_msdcs." + m_pFwdZoneInfo->m_szZoneStorage);
           dwErr =
            ::DnssrvCreateZoneForDcPromoEx(
               m_pServerNode->GetRPCName(),
               W_TO_UTF8(zone),
               W_TO_UTF8(stor),
               DNS_ZONE_CREATE_FOR_DCPROMO_FOREST);
        }

        if (m_dwDnsSetupFlags & DNS_SETUP_AUTOCONFIG_CLIENT)
        {
          // NTRAID#NTBUG9-489252-2001/11/08-sburns

          DWORD dwflags = DNS_RPC_AUTOCONFIG_ALL;

          dwErr =
            ::DnssrvOperation(
               m_pServerNode->GetRPCName(),
               NULL,
               DNSSRV_OP_AUTO_CONFIGURE,
               DNSSRV_TYPEID_DWORD,
               (PVOID) (DWORD_PTR) dwflags);
        }
      }
      else
      {
            dwErr = CDNSZoneWizardHolder::CreateZoneHelper(m_pServerNode, 
                                                        m_pFwdZoneInfo, 
                                                        GetComponentData());
      }
      TRACE_LOGFILE_IF_NO_UI(m_bHideUI, L"FWD Zone creation returned dwErr = 0x%x", dwErr);
          if (dwErr != 0)
          {
              bRet = FALSE;
        if (!m_bHideUI)
        {
                DNSErrorDialog(dwErr, IDS_MSG_SERVWIZ_FAIL_ADD_FWD_ZONE);
        }
        else
        {
          ::SetLastError(dwErr);
        }
        DNSCreateErrorMessage(dwErr, IDS_MSG_SERVWIZ_FAIL_ADD_FWD_ZONE, szLastErrorMessage);
        break; // false loop
          }
          else
          {
              m_bFwdZoneAdded = TRUE;
          }
      }
      // zone creation: reverse lookup zone (only if FWD creation)
      if (m_bAddRevZone && 
         !m_bRevZoneAdded  &&
         GetScenario() != CDNSServerWizardHolder::Manually)
      {
      if (m_bHideUI)
      {
        // Add a DCPromo zone
        TRACE_LOGFILE(L"Creating reverse lookup zone for DCPromo.");
        dwErr =
         ::DnssrvCreateZoneForDcPromoEx(
            m_pServerNode->GetRPCName(),
            W_TO_UTF8(m_pRevZoneInfo->m_szZoneName),
            W_TO_UTF8(m_pRevZoneInfo->m_szZoneStorage),
            0);
      }
      else
      {
            dwErr = CDNSZoneWizardHolder::CreateZoneHelper(m_pServerNode, 
                                                        m_pRevZoneInfo, 
                                                        GetComponentData());
      }
      TRACE_LOGFILE_IF_NO_UI(m_bHideUI, L"REV Zone creation returned dwErr = 0x%x", dwErr);
          if (dwErr != 0)
          {
              bRet = FALSE;
        if (!m_bHideUI)
        {
                DNSErrorDialog(dwErr, IDS_MSG_SERVWIZ_FAIL_ADD_REV_ZONE);
        }
        else
        {
          ::SetLastError(dwErr);
        }
        DNSCreateErrorMessage(dwErr, IDS_MSG_SERVWIZ_FAIL_ADD_REV_ZONE, szLastErrorMessage);
        break; // false loop
          }
          else
          {
              m_bRevZoneAdded = TRUE;
          }
      }

    //
    // Depending on the scenario we might need to add forwarders
    //
    if (!m_bHideUI)
    {
      switch (GetScenario())
      {
        case SmallBusiness:
        case MediumBusiness:
          {
            if (m_pForwardersPage != NULL)
            {
              if (!m_pForwardersPage->OnApply())
              {
                bRet = FALSE;
                dwErr = ::GetLastError();
                if (dwErr != 0)
                {
                  DNSErrorDialog(dwErr, IDS_MSG_SERVWIZ_FAIL_FORWARDERS);
                  DNSCreateErrorMessage(dwErr, IDS_MSG_SERVWIZ_FAIL_FORWARDERS, szLastErrorMessage);
                }
              }
            }
          }
          break;
      
        case Manually:
        default:
          break;
      }
    }

    //
    // Have the server set the regkey that says we are configured
    //
    dwErr = m_pServerNode->SetServerConfigured();
    if (dwErr != 0)
    {
      bRet = FALSE;
      if (!m_bHideUI)
      {
        DNSErrorDialog(dwErr, IDS_MSG_SERVWIZ_FAIL_SERVER_CONFIGURED);
      }
      else
      {
        ::SetLastError(dwErr);
      }
      DNSCreateErrorMessage(dwErr, IDS_MSG_SERVWIZ_FAIL_SERVER_CONFIGURED, szLastErrorMessage);
      break; // false loop
    }
  } while (false);

  //
  // Now update the regkey with the error message if we failed
  //
  if (!bRet && !szLastErrorMessage.IsEmpty())
  {
    dwErr = WriteResultsToRegkeyForCYS(szLastErrorMessage);
    ASSERT(dwErr == 0);
  }

  // Now refresh the server node so that we pick up all the changes

  if (!m_bHideUI)
  {
     CNodeList nodeList;
     nodeList.AddTail(m_pServerNode);
     m_pServerNode->OnRefresh(
        GetComponentData(),
        &nodeList);
  }

  return bRet;
}

#define CYS_KEY L"Software\\Microsoft\\Windows NT\\CurrentVersion\\srvWiz"
#define DNSWIZ_KEY L"DnsWizResult"

LONG CDNSServerWizardHolder::WriteResultsToRegkeyForCYS(PCWSTR pszLastErrorMessage)
{
    CRegKey regkeysrvWiz;
    LONG lRes = regkeysrvWiz.Open(HKEY_LOCAL_MACHINE, CYS_KEY);
    if (lRes == ERROR_SUCCESS)
  {
    lRes = regkeysrvWiz.SetValue(pszLastErrorMessage, DNSWIZ_KEY);
  }
  return lRes;
}

DNS_STATUS CDNSServerWizardHolder::InitializeRootHintsList()
{
    ASSERT(m_pServerNode != NULL);
    ASSERT(m_pRootHintsRecordList != NULL);

    CDNSRootHintsNode* pRootHintsNode = m_pServerNode->GetRootHints();
    ASSERT(pRootHintsNode != NULL);
    if (pRootHintsNode == NULL)
  {
        return -1; // bogus ret code
  }

    return pRootHintsNode->InitializeFromDnsQueryData(m_pRootHintsRecordList);
}


HRESULT CDNSServerWizardHolder::DnsSetup(LPCWSTR lpszFwdZoneName,
                                         LPCWSTR lpszFwdZoneFileName,
                                         LPCWSTR lpszRevZoneName, 
                                         LPCWSTR lpszRevZoneFileName, 
                                         DWORD dwFlags)
{
  TRACE_FUNCTION(CDNSServerWizardHolder::DnsSetup);

  TRACE(L"CDNSServerWizardHolder::DnsSetup(\n%s,\n%s,\n%s,\n%s,\n0x%x)\n",
                                         lpszFwdZoneName,
                                         lpszFwdZoneFileName,
                                         lpszRevZoneName, 
                                         lpszRevZoneFileName, 
                                         dwFlags);
                                         
  // Save the flags for later use in OnFinish
  
  m_dwDnsSetupFlags = dwFlags;
  
  ASSERT(m_bHideUI);

  // set the name of the server to configure to the local host
  m_pServerNode->SetDisplayName(_T("127.0.0.1"));

  // if needed, add forward lookup zone
  if ((lpszFwdZoneName != NULL) && (lpszFwdZoneFileName != NULL))
  {
    TRACE_LOGFILE(L"Setting FWD lookup Zone Info");
    m_pFwdZoneInfo->m_szZoneName = lpszFwdZoneName;
    m_pFwdZoneInfo->m_szZoneStorage = lpszFwdZoneFileName;
    m_pFwdZoneInfo->m_nDynamicUpdate = ZONE_UPDATE_UNSECURE;
    m_bAddFwdZone = TRUE;
  }
  // if needed, add a reverse lookup zone
  if ((lpszRevZoneName != NULL) && (lpszRevZoneFileName != NULL))
  {
    TRACE_LOGFILE(L"Setting REV lookup Zone Info");
    m_pRevZoneInfo->m_bForward = FALSE;
    m_pRevZoneInfo->m_szZoneName = lpszRevZoneName;
    m_pRevZoneInfo->m_szZoneStorage = lpszRevZoneFileName;
    m_pRevZoneInfo->m_nDynamicUpdate = ZONE_UPDATE_UNSECURE;
    m_bAddRevZone = TRUE;
  }

    // try to contact server
    BOOL bAlreadyConfigured = FALSE;
  TRACE(L"calling GetServerInfo()\n");
  HWND hWnd = GetMainWindow();
  DWORD dwErr = GetServerInfo(&bAlreadyConfigured, hWnd);

  if (0 != dwErr)
    {
    TRACE_LOGFILE(L"GetServerInfo() failed, dwErr = 0x%x", dwErr);
        return HRESULT_FROM_WIN32(dwErr); // something is wrong, cannot contact
    }

  //
  // Check to see if this is a root server
  //
  dwErr = ServerHasRootZone(m_pServerNode->GetRPCName(), &m_bHasRootZone);
  if (m_bHasRootZone)
  {
    TRACE_LOGFILE(L"Has root zone: m_bHasRootZone = 0x%x", m_bHasRootZone);
    m_bRootServer = FALSE;
  }
  else
  {
    TRACE_LOGFILE(L"Does not have root zone: m_bHasRootZone = 0x%x", m_bHasRootZone);
    // need to configure server
    // 1. try to find the root hints
    BOOL bRootHints = QueryForRootServerRecords(NULL);
    // if root hints not found, make it a root server
    if (!bRootHints)
    {
      TRACE_LOGFILE(L"root hints not found");
      TRACE_LOGFILE(L"Server needs root zone: m_bHasRootZone = 0x%x", m_bHasRootZone);
      m_bRootServer = TRUE; 
    }
    else
    {
      m_bAddRootHints = TRUE;
    }
  }

  BOOL bFinish = OnFinish();
  HRESULT hr = S_OK;
  if (!bFinish)
  {
    dwErr = ::GetLastError();
    TRACE_LOGFILE(L"OnFinish failed with error: 0x%x", dwErr);
    hr = HRESULT_FROM_WIN32(dwErr);
  }
  return hr;
}


//////////////////////////////////////////////////////////////////////
// CContactServerThread

CContactServerThread::CContactServerThread(LPCTSTR lpszServerName,
                                           BOOL bCheckConfigured)
{
    ASSERT(lpszServerName != NULL);
    m_szServerName = lpszServerName;
    m_bCheckConfigured = bCheckConfigured;
  m_bAlreadyConfigured = FALSE;
  m_pServerInfoEx = new CDNSServerInfoEx;
  m_pRootHintsNode = NULL;
}

CContactServerThread::~CContactServerThread()
{
    if (m_pServerInfoEx != NULL)
        delete m_pServerInfoEx;
  if (m_pRootHintsNode != NULL)
    delete m_pRootHintsNode;
}

CDNSServerInfoEx* CContactServerThread::DetachInfo()
{
    CDNSServerInfoEx* pInfo = m_pServerInfoEx;
    m_pServerInfoEx = NULL;
    return pInfo;
}

CDNSRootHintsNode* CContactServerThread::DetachRootHintsNode()
{
  CDNSRootHintsNode* pRootHints = m_pRootHintsNode;
  m_pRootHintsNode = NULL;
  return pRootHints;
}

void CContactServerThread::OnDoAction()
{
   USES_CONVERSION;

   // query the server to find out if it has a root zone
   BOOL bHasRootZone = FALSE;
   m_dwErr = ::ServerHasRootZone(m_szServerName, &bHasRootZone);

   if (m_dwErr != 0)
      return;

   // if there is not a root zone, the server is not authoritated for the root
   // so create the root hints folder and ask it to query for NS and A records
   if (!bHasRootZone)
   {
      CDNSRootHintsNode* pRootHintsNode = new CDNSRootHintsNode;
      if (pRootHintsNode)
      {
         m_dwErr = pRootHintsNode->QueryForRootHints(m_szServerName, 0x0 /*version not known yet*/);
      }
      else
      {
         m_dwErr = ERROR_OUTOFMEMORY;
      }

      if (m_dwErr != 0)
      {
         delete pRootHintsNode;
         return;
      }
      m_pRootHintsNode = pRootHintsNode;
   }

   // get server info
   m_dwErr = m_pServerInfoEx->Query(m_szServerName);

   if (m_dwErr != 0)
      return;

   // if needed verify if the server has been configured
   if (!m_bCheckConfigured)
      return;

   DWORD dwFilter = ZONE_REQUEST_FORWARD | ZONE_REQUEST_REVERSE | 
                     ZONE_REQUEST_PRIMARY | ZONE_REQUEST_SECONDARY;

   PDNS_RPC_ZONE_LIST pZoneList = NULL;
   m_dwErr = ::DnssrvEnumZones(
                m_szServerName, 
                dwFilter, 
                NULL /*pszLastZone, unused for the moment */,
                &pZoneList);
   if (m_dwErr == 0)
   {
      if (pZoneList != NULL)
      {
         m_bAlreadyConfigured = pZoneList->dwZoneCount > 0;
         ::DnssrvFreeZoneList(pZoneList);
      }
   }
}



//////////////////////////////////////////////////////////////////////
// CRootHintsQueryThread

CRootHintsQueryThread::CRootHintsQueryThread() 
{ 
    m_pRootHintsRecordList = NULL; 
    m_pServerNamesArr = NULL;
    m_nServerNames = 0;
    m_nIPCount = 0; 
    m_ipArray = NULL; 
}

CRootHintsQueryThread::~CRootHintsQueryThread() 
{
    if (m_pServerNamesArr != NULL)
        delete[] m_pServerNamesArr;
    if (m_ipArray != NULL)
        free(m_ipArray);
    if (m_pRootHintsRecordList != NULL) 
        DnsRecordListFree(m_pRootHintsRecordList, DnsFreeRecordListDeep);
}


BOOL CRootHintsQueryThread::LoadServerNames(CRootData* pRootData, 
                                            CDNSServerNode* pServerNode)
{
   ASSERT(pRootData != NULL);
   ASSERT(pServerNode != NULL);
   CNodeList* pServerList = pRootData->GetContainerChildList();
   INT_PTR nCount = pServerList->GetCount();

   POSITION pos;
   CNodeList* pChildList = pRootData->GetContainerChildList();

   // look if the server node has been already added
   BOOL bAddServer = TRUE;
   for (pos = pChildList->GetHeadPosition(); pos != NULL; )
   {
      CDNSServerNode* pCurrServerNode = (CDNSServerNode*)pChildList->GetNext(pos);
      if (pCurrServerNode == pServerNode)
      {
         bAddServer = FALSE;
         break;
      }
   }
   if (bAddServer)
      nCount++;

   if (nCount == 0)
      return FALSE;

   m_nServerNames = static_cast<DWORD>(nCount);
   m_pServerNamesArr = new CString[nCount];

   if (!m_pServerNamesArr)
   {
      return FALSE;
   }
    
   int k = 0;
   // fill in the array of server names
   for (pos = pChildList->GetHeadPosition(); pos != NULL; )
   {
      CDNSServerNode* pCurrServerNode = (CDNSServerNode*)pChildList->GetNext(pos);
      m_pServerNamesArr[k] = pCurrServerNode->GetDisplayName();
      k++;
   }
  
   if (bAddServer)
      m_pServerNamesArr[m_nServerNames-1] = pServerNode->GetDisplayName();

   return TRUE;
}

void CRootHintsQueryThread::LoadIPAddresses(DWORD cCount, PIP_ADDRESS ipArr)
{
    ASSERT(cCount > 0);
    ASSERT(ipArr != NULL);
    ASSERT(m_nIPCount == 0);
    ASSERT(m_ipArray == NULL);

    m_nIPCount = cCount;
    m_ipArray = (IP_ADDRESS*)malloc(m_nIPCount*sizeof(IP_ADDRESS));
  if (m_ipArray != NULL)
  {
      memcpy(m_ipArray, ipArr, m_nIPCount*sizeof(IP_ADDRESS));
  }
}

PDNS_RECORD CRootHintsQueryThread::GetHintsRecordList()
{
    PDNS_RECORD pList = m_pRootHintsRecordList;
    if (m_pRootHintsRecordList != NULL)
    {
        m_pRootHintsRecordList = NULL; // tansfer ownership
    }
    return pList;
}


void CRootHintsQueryThread::OnDoAction()
{
  if (m_ipArray != NULL)
    QueryServersOnIPArray();
  else
  {
    // try first the default server on the wire
    QueryAllServers();
    if (m_dwErr != 0)
    {
      // try the list of servers provided
      ASSERT(m_pRootHintsRecordList == NULL);
      if (m_pServerNamesArr != NULL)
        QueryServersOnServerNames();
    }
  }
}

void CRootHintsQueryThread::QueryAllServers()
{
    m_dwErr = ::DnsQuery(_T("."), DNS_TYPE_NS, DNS_QUERY_STANDARD, NULL, &m_pRootHintsRecordList, NULL);
}

void CRootHintsQueryThread::QueryServersOnServerNames()
{
    ASSERT(m_nIPCount == 0);
    ASSERT(m_ipArray == NULL);
    ASSERT(m_pServerNamesArr != NULL);
    ASSERT(m_nServerNames > 0);
    DNS_STATUS dwLastErr = 0;

    // allocate array of A record lists
    PDNS_RECORD* pHostRecordsArr = (PDNS_RECORD*)malloc(m_nServerNames*sizeof(PDNS_RECORD));
  if (!pHostRecordsArr)
  {
    return;
  }
    memset(pHostRecordsArr, 0x0,m_nServerNames*sizeof(PDNS_RECORD));
    
    // allocate an array of IP addresses possibly coming from server names
    PIP_ADDRESS ipArrayFromNames = (PIP_ADDRESS)malloc(m_nServerNames*sizeof(IP_ADDRESS));
  if (!ipArrayFromNames)
  {
    return;
  }

  do // false loop
  {
      DWORD nIPCountFromNames = 0;

      // loop thru the list of names in the array
      for (DWORD k = 0; k < m_nServerNames; k++)
      {
          IP_ADDRESS ipAddr = IPStringToAddr(m_pServerNamesArr[k]);
          if (ipAddr == INADDR_NONE)
          {
              // host name, build a list of A records by calling DNSQuery()
              dwLastErr = ::DnsQuery((LPTSTR)(LPCTSTR)m_pServerNamesArr[k], DNS_TYPE_A, 
                          DNS_QUERY_STANDARD, NULL, &pHostRecordsArr[k], NULL);
          }
          else
          {
              // IP address, add to the list
              ipArrayFromNames[nIPCountFromNames++] = ipAddr;
          }
      }

      // count the # of IP Addresses we have in the A record list
      DWORD nIPCountFromARec = 0;
      for (k=0; k < m_nServerNames; k++)
      {
          PDNS_RECORD pTemp = pHostRecordsArr[k];
          while (pTemp != NULL)
          {
              nIPCountFromARec++;
              pTemp = pTemp->pNext;
          }
      }
      m_nIPCount = nIPCountFromARec + nIPCountFromNames;
      if (m_nIPCount == 0)
      {
          ASSERT(m_ipArray == NULL);
          ASSERT(dwLastErr != 0);
          m_dwErr = (DWORD)dwLastErr;
          break; // we did not get any address to query with
      }

      // build an array of IP addresses to pass to DnsQuery()
      m_ipArray = (IP_ADDRESS*)malloc(m_nIPCount*sizeof(IP_ADDRESS));
    if (m_ipArray != NULL)
    {
        memset(m_ipArray, 0x0, m_nIPCount*sizeof(IP_ADDRESS));
    }
    else
    {
      break;
    }

      //scan the array of lists of A records we just found
      PIP_ADDRESS pCurrAddr = m_ipArray;
      for (k=0; k < m_nServerNames; k++)
      {
          PDNS_RECORD pTemp = pHostRecordsArr[k];
          while (pTemp != NULL)
          {
              CString szTemp;
        FormatIpAddress(szTemp, pTemp->Data.A.IpAddress);
              TRACE(_T("found address[%d] = %s\n"), k, (LPCTSTR)szTemp);

              *pCurrAddr = pTemp->Data.A.IpAddress;
              pTemp = pTemp->pNext;
              pCurrAddr++;
          }
      }
      // if any, attach the original IP addresses from names
      for (k=0; k < nIPCountFromNames; k++)
      {
          *pCurrAddr = ipArrayFromNames[k];
          pCurrAddr++;
      }
      ASSERT(pCurrAddr == m_ipArray+m_nIPCount);

      // free up the lists of A records
      for (k=0; k < m_nServerNames; k++)
      {
          if (pHostRecordsArr[k] != NULL)
              ::DnsRecordListFree(pHostRecordsArr[k], DnsFreeRecordListDeep);
      }
      // finally can query on IP array just created
      QueryServersOnIPArray();
  } while (false);

  if (pHostRecordsArr)
  {
    free(pHostRecordsArr);
    pHostRecordsArr = 0;
  }

  if (ipArrayFromNames)
  {
    free(ipArrayFromNames);
    ipArrayFromNames = 0;
  }
}

void CRootHintsQueryThread::QueryServersOnIPArray()
{
    ASSERT(m_nIPCount > 0);
    ASSERT(m_ipArray != NULL);

    CString szTemp;
    for(DWORD k = 0; k < m_nIPCount; k++)
    {
    FormatIpAddress(szTemp, m_ipArray[k]);
        TRACE(_T("m_ipArray[%d] = %s\n"), k, (LPCTSTR)szTemp);
    }

    // have to syntesize an IP_ARRAY (hack)
    PIP_ARRAY pipArr = (PIP_ARRAY)malloc(sizeof(DWORD)+sizeof(IP_ADDRESS)*m_nIPCount);
  if (pipArr)
  {
      pipArr->AddrCount = m_nIPCount;
      memcpy(pipArr->AddrArray, m_ipArray, sizeof(IP_ADDRESS)*m_nIPCount);
      m_dwErr = ::DnsQuery(_T("."), DNS_TYPE_NS, DNS_QUERY_BYPASS_CACHE, pipArr, &m_pRootHintsRecordList, NULL);

    free(pipArr);
    pipArr = 0;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\servwiz.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       servwiz.h
//
//--------------------------------------------------------------------------


#ifndef _SERVWIZ_H
#define _SERVWIZ_H

#include "zonewiz.h"
#include "nspage.h"

///////////////////////////////////////////////////////////////////////////////
// FORWARD DECLARATIONS

class CDNSRootData;
class CDNSServerNode;
class CDNSServerWizardHolder;
class CNewServerDialog;

///////////////////////////////////////////////////////////////////////////////
// CDNSServerWiz_StartPropertyPage

class CDNSServerWiz_StartPropertyPage : public CPropertyPageBase
{
// Construction
public:
	CDNSServerWiz_StartPropertyPage();
	enum { IDD = IDD_SERVWIZ_START };

  virtual void OnWizardHelp();

// Overrides
public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
protected:
	virtual BOOL OnInitDialog();

   void OnChecklist();

   DECLARE_MESSAGE_MAP();
// Dialog Data

};

///////////////////////////////////////////////////////////////////////////////
// CDNSServerWiz_ScenarioPropertyPage

class CDNSServerWiz_ScenarioPropertyPage : public CPropertyPageBase
{
// Construction
public:
	CDNSServerWiz_ScenarioPropertyPage();
	enum { IDD = IDD_SERVWIZ_SCENARIO_PAGE };

// Overrides
public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
  virtual LRESULT OnWizardBack();

  virtual void OnWizardHelp();

protected:
	virtual BOOL OnInitDialog();

// Dialog Data

};

///////////////////////////////////////////////////////////////////////////////
// CDNSServerWiz_ForwardersPropertyPage

class CDNSServerWiz_ForwardersPropertyPage : public CPropertyPageBase
{
// Construction
public:
	CDNSServerWiz_ForwardersPropertyPage();
	enum { IDD = IDD_SERVWIZ_SM_FORWARDERS_PAGE };

// Overrides
public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
  virtual LRESULT OnWizardBack();
  virtual BOOL OnApply();

  virtual void OnWizardHelp();

  void    GetForwarder(CString& strref);
protected:
	virtual BOOL OnInitDialog();

  afx_msg void OnChangeRadio();
// Dialog Data
  DECLARE_MESSAGE_MAP()
};


///////////////////////////////////////////////////////////////////////////////
// CDNSServerWiz_SmallZoneTypePropertyPage

class CDNSServerWiz_SmallZoneTypePropertyPage : public CPropertyPageBase
{
// Construction
public:
	CDNSServerWiz_SmallZoneTypePropertyPage();
	enum { IDD = IDD_SERVWIZ_SM_ZONE_TYPE_PAGE };

// Overrides
public:
  virtual void OnWizardHelp();

	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
  virtual LRESULT OnWizardBack();
protected:

	virtual BOOL OnInitDialog();

// Dialog Data

};

///////////////////////////////////////////////////////////////////////////////
// CDNSServerWiz_NamePropertyPage

class CDNSServerWiz_NamePropertyPage : public CPropertyPageBase
{
// Construction
public:
	CDNSServerWiz_NamePropertyPage();

// Overrides
public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
  virtual LRESULT OnWizardBack();

// Dialog Data
	enum { IDD = IDD_SERVWIZ_NAME };

  virtual void OnWizardHelp();

protected:
	afx_msg void OnServerNameChange();

	DECLARE_MESSAGE_MAP()
private:
	CString m_szServerName;
	BOOL IsValidServerName(CString& s) { return !s.IsEmpty();}
	CEdit* GetServerNameEdit() { return (CEdit*)GetDlgItem(IDC_EDIT_DNSSERVER);}
};



///////////////////////////////////////////////////////////////////////////////
// CDNSServerWiz_ConfigFwdZonePropertyPage

class CDNSServerWiz_ConfigFwdZonePropertyPage : public CPropertyPageBase
{
// Construction
public:
	CDNSServerWiz_ConfigFwdZonePropertyPage();

// Dialog Data
	enum { IDD = IDD_SERVWIZ_FWD_ZONE };

// Overrides
public:
  virtual void OnWizardHelp();

	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
protected:

	virtual BOOL OnInitDialog();
};


///////////////////////////////////////////////////////////////////////////////
// CDNSServerWiz_ConfigRevZonePropertyPage

class CDNSServerWiz_ConfigRevZonePropertyPage : public CPropertyPageBase
{
// Construction
public:
	CDNSServerWiz_ConfigRevZonePropertyPage();

// Dialog Data
	enum { IDD = IDD_SERVWIZ_REV_ZONE };

// Overrides
public:
  virtual void OnWizardHelp();

	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
protected:

	virtual BOOL OnInitDialog();
};




///////////////////////////////////////////////////////////////////////////////
// CDNSServerWiz_FinishPropertyPage

class CDNSServerWiz_FinishPropertyPage : public CPropertyPageBase
{
// Construction
public:
	CDNSServerWiz_FinishPropertyPage();

// Dialog Data
	enum { IDD = IDD_SERVWIZ_FINISH };

// Overrides
public:
  virtual void OnWizardHelp();

	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnWizardFinish();

protected:
  virtual BOOL OnInitDialog();


private:
	void DisplaySummaryInfo(CDNSServerWizardHolder* pHolder);
};



///////////////////////////////////////////////////////////////////////////////
// CDNSServerWizardHolder
// page holder to contain DNS server wizard property pages

class CDNSServerWizardHolder : public CPropertyPageHolderBase
{
public:
	CDNSServerWizardHolder(CDNSRootData* pRootData, 
                          CComponentDataObject* pComponentData,
                          CDNSServerNode* pServerNode,
                          BOOL bHideUI = FALSE);
	~CDNSServerWizardHolder();

  // run UI less, for DC Promo
  HRESULT DnsSetup(LPCWSTR lpszFwdZoneName,
                   LPCWSTR lpszFwdZoneFileName,
                   LPCWSTR lpszRevZoneName, 
                   LPCWSTR lpszRevZoneFileName, 
                   DWORD dwFlags); 

	void DoModalConnect();
	void DoModalConnectOnLocalComputer();

  CDNSServerNode* GetServerNode() { return m_pServerNode; }

protected:
	virtual HRESULT OnAddPage(int nPage, CPropertyPageBase* pPage);

  enum
  {
    SmallBusiness = 0,
    MediumBusiness,
    Manually
  };

  void SetScenario(UINT nScenario) { m_nScenario = nScenario; }
  UINT GetScenario() { return m_nScenario; }

private:
  DNS_STATUS WriteResultsToRegkeyForCYS(PCWSTR pszLastErrorMessage);

	CDNSRootData* GetRootData() { return (CDNSRootData*)GetContainerNode();}
  UINT SetZoneWizardContextEx(BOOL bForward, 
                              UINT nZoneType, 
                              BOOL bADIntegrated = FALSE,
                              UINT nNextPage = -1, 
                              UINT nPrevPage = -1);

  UINT SetZoneWizardContext(BOOL bForward, 
                            UINT nNextPage = -1, 
                            UINT nPrevPage = -1);

	void SetRootHintsRecordList(PDNS_RECORD pRootHints)
	{
		if(m_pRootHintsRecordList != NULL)
		{
      ::DnsRecordListFree(m_pRootHintsRecordList, DnsFreeRecordListDeep);
			m_pRootHintsRecordList = NULL;
		}
		m_pRootHintsRecordList = pRootHints;
	}

	DWORD GetServerInfo(BOOL* pbAlreadyConfigured, HWND parentHwnd);
	BOOL QueryForRootServerRecords(IP_ADDRESS* pIpAddr);
	void InsertServerIntoUI();

	BOOL OnFinish();	// do the work
	DNS_STATUS InitializeRootHintsList();

	// flag to skip the name page when server name obtained from dialog
	BOOL m_bSkipNamePage;
  // flag to run the wizard object programmatically (DC Promo)
  BOOL m_bHideUI;

  // to hold flags param passed to DnsSetup.
  
  DWORD m_dwDnsSetupFlags;

	// Wizard options and collected data
	BOOL m_bRootServer;
  BOOL m_bHasRootZone;

	// zone creation info
	BOOL m_bAddFwdZone;
	BOOL m_bAddRevZone;
	CDNSCreateZoneInfo*   m_pFwdZoneInfo;
	CDNSCreateZoneInfo*   m_pRevZoneInfo;

	// root hints info (NS and A records)
	PDNS_RECORD m_pRootHintsRecordList;

	// server node to add
	CDNSServerNode*	m_pServerNode;

	// execution state and error codes
	BOOL m_bServerNodeAdded;		// added server node (UI)
	BOOL m_bRootHintsAdded;			// true if we succeded once in adding root hints to server
	BOOL m_bRootZoneAdded;
	BOOL m_bFwdZoneAdded;
	BOOL m_bRevZoneAdded;
  BOOL m_bAddRootHints;
  BOOL m_bAddForwarder;

  UINT m_nScenario;

  BOOL m_bServerNodeExists;

	// embedded zone wizard instance
	CDNSZoneWizardHolder*					m_pZoneWiz;

	// property page objects
	CDNSServerWiz_StartPropertyPage*			    m_pStartPage;
  CDNSServerWiz_ScenarioPropertyPage*       m_pScenarioPage;
  CDNSServerWiz_ForwardersPropertyPage*     m_pForwardersPage;
  CDNSServerWiz_SmallZoneTypePropertyPage*  m_pSmallZoneTypePage;
	CDNSServerWiz_NamePropertyPage*			      m_pNamePage;
	CDNSServerWiz_ConfigFwdZonePropertyPage*	m_pFwdZonePage;
	CDNSServerWiz_ConfigRevZonePropertyPage*	m_pRevZonePage;
	CDNSServerWiz_FinishPropertyPage*		      m_pFinishPage;

	friend class CNewServerDialog;

	friend class CDNSServerWiz_StartPropertyPage;
  friend class CDNSServerWiz_ScenarioPropertyPage;
  friend class CDNSServerWiz_ForwardersPropertyPage;
  friend class CDNSServerWiz_SmallZoneTypePropertyPage;
	friend class CDNSServerWiz_NamePropertyPage;
	friend class CDNSServerWiz_ConfigFwdZonePropertyPage;
	friend class CDNSServerWiz_ConfigRevZonePropertyPage;
	friend class CDNSServerWiz_FinishPropertyPage;
};


/////////////////////////////////////////////////////////////////////////////////
// HELPER CLASSES
/////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// CContactServerThread

class CContactServerThread : public CDlgWorkerThread
{
public:
	CContactServerThread(LPCTSTR lpszServerName, BOOL bCheckConfigured);
	~CContactServerThread();

	CDNSServerInfoEx* DetachInfo();
  CDNSRootHintsNode* DetachRootHintsNode();
	BOOL IsAlreadyConfigured() { return m_bAlreadyConfigured;}

private:
	CString m_szServerName;
	CDNSServerInfoEx* m_pServerInfoEx;
  CDNSRootHintsNode* m_pRootHintsNode;
	BOOL m_bAlreadyConfigured;
	BOOL m_bCheckConfigured;

protected:
	virtual void OnDoAction();
};



///////////////////////////////////////////////////////////////////////////////
// CRootHintsQueryThread

class CRootHintsQueryThread : public CDlgWorkerThread
{
public:
	CRootHintsQueryThread();
	virtual ~CRootHintsQueryThread();

	// setup
	BOOL LoadServerNames(CRootData* pRootData, CDNSServerNode* pServerNode);
	void LoadIPAddresses(DWORD cCount, PIP_ADDRESS ipArr);

	// return data
	PDNS_RECORD GetHintsRecordList();

protected:
	virtual void OnDoAction();

private:
	// array of server names
	CString* m_pServerNamesArr;
	DWORD	m_nServerNames;

	// array of IP addresses
	PIP_ADDRESS m_ipArray;
	DWORD m_nIPCount;

	// output data
	PDNS_RECORD m_pRootHintsRecordList;

	void QueryAllServers();
	void QueryServersOnServerNames();
	void QueryServersOnIPArray();
};


#endif // _SERVWIZ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\snapbase.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       snapbase.cpp
//
//--------------------------------------------------------------------------


// SNAPBASE.CPP
#include "preDNSsn.h"
#include <snapbase.h>

#ifdef DEBUG_ALLOCATOR
	#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
	#endif
#endif

#include <dbg_.cpp>

#include <stdabou_.cpp>

#include <compbas_.cpp>
#include <proppag_.cpp>
#include <dataobj_.cpp>
#include <treedat_.cpp>


//////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\snapdata.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       snapdata.cpp
//
//--------------------------------------------------------------------------


#include "preDNSsn.h"
#include <SnapBase.h>

#include "resource.h"
#include "DNSSnap.h"

#include "dnsutil.h"
#include "snapdata.h"
#include "server.h"
#include "servwiz.h"

#include <prsht.h>
#include <svcguid.h>

#ifdef DEBUG_ALLOCATOR
	#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
	#endif
#endif



///////////////////////////////////////////////////////////////////////////////
// GLOBAL FUNCTIONS

HRESULT SaveStringHelper(LPCWSTR pwsz, IStream* pStm)
{
	ASSERT(pStm);
	ULONG nBytesWritten;
	HRESULT hr;

	DWORD nLen = static_cast<DWORD>(wcslen(pwsz)+1); // WCHAR including NULL
	hr = pStm->Write((void*)&nLen, sizeof(DWORD),&nBytesWritten);
	ASSERT(nBytesWritten == sizeof(DWORD));
	if (FAILED(hr))
		return hr;
	
	hr = pStm->Write((void*)pwsz, sizeof(WCHAR)*nLen,&nBytesWritten);
	ASSERT(nBytesWritten == sizeof(WCHAR)*nLen);
	TRACE(_T("SaveStringHelper(<%s> nLen = %d\n"),pwsz,nLen);
	return hr;
}

HRESULT LoadStringHelper(CString& sz, IStream* pStm)
{
	ASSERT(pStm);
	HRESULT hr;
	ULONG nBytesRead;
	DWORD nLen = 0;

	hr = pStm->Read((void*)&nLen,sizeof(DWORD), &nBytesRead);
	ASSERT(nBytesRead == sizeof(DWORD));
	if (FAILED(hr) || (nBytesRead != sizeof(DWORD)))
		return hr;

	hr = pStm->Read((void*)sz.GetBuffer(nLen),sizeof(WCHAR)*nLen, &nBytesRead);
	ASSERT(nBytesRead == sizeof(WCHAR)*nLen);
	sz.ReleaseBuffer();
	TRACE(_T("LoadStringHelper(<%s> nLen = %d\n"),(LPCTSTR)sz,nLen);
	
	return hr;
}

HRESULT SaveDWordHelper(IStream* pStm, DWORD dw)
{
	ULONG nBytesWritten;
	HRESULT hr = pStm->Write((void*)&dw, sizeof(DWORD),&nBytesWritten);
	if (nBytesWritten < sizeof(DWORD))
		hr = STG_E_CANTSAVE;
	return hr;
}

HRESULT LoadDWordHelper(IStream* pStm, DWORD* pdw)
{
	ULONG nBytesRead;
	HRESULT hr = pStm->Read((void*)pdw,sizeof(DWORD), &nBytesRead);
	ASSERT(nBytesRead == sizeof(DWORD));
	return hr;
}



//////////////////////////////////////////////////////////////////////
// CDNSQueryFilterPageBase

class CDNSQueryFilterSheet; // fwd decl

class CDNSQueryFilterPageBase : public CPropertyPage
{
public:
  CDNSQueryFilterPageBase(UINT nIDD, CDNSQueryFilterSheet* pSheet)
     		: CPropertyPage(nIDD)
  {
    m_pSheet = pSheet;
    m_bDirty = FALSE;
    m_bInit = FALSE;
  }
protected:
  CDNSQueryFilterSheet* m_pSheet;

  void SetDirty();
  void Init();
  BOOL IsDirty() { return m_bDirty;}

  virtual BOOL OnInitDialog();

  afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnWhatsThis();
  afx_msg BOOL OnHelp(WPARAM wParam, LPARAM lParam);

private:
  BOOL m_bInit;
  BOOL m_bDirty;

  HWND  m_hWndWhatsThis;  // hwnd of right click "What's this" help

  DECLARE_MESSAGE_MAP()
};



//////////////////////////////////////////////////////////////////////
// CDNSQueryFilterNamePage

class CDNSQueryFilterNamePage : public CDNSQueryFilterPageBase
{
public:
  CDNSQueryFilterNamePage(CDNSQueryFilterSheet* pSheet)
     		: CDNSQueryFilterPageBase(IDD_FILTERING_NAME, pSheet)
  {
  }

protected:
	virtual BOOL OnInitDialog();
	virtual BOOL OnApply();

  afx_msg void OnRadioClicked();
  afx_msg void OnEditChange();

private:
  CEdit* GetStartsStringEdit() { return (CEdit*)GetDlgItem(IDC_EDIT_FILTER_STARTS);}
  CEdit* GetContainsStringEdit() { return (CEdit*)GetDlgItem(IDC_EDIT_FILTER_CONTAINS);}
  CEdit* GetRangeFromStringEdit() { return (CEdit*)GetDlgItem(IDC_EDIT_FILTER_RANGE_FROM);}
  CEdit* GetRangeToStringEdit() { return (CEdit*)GetDlgItem(IDC_EDIT_FILTER_RANGE_TO);}

  CButton* GetRadioNone() { return (CButton*)GetDlgItem(IDC_RADIO_FILTER_NONE);}
  CButton* GetRadioStarts() { return (CButton*)GetDlgItem(IDC_RADIO_FILTER_STARTS);}
  CButton* GetRadioContains() { return (CButton*)GetDlgItem(IDC_RADIO_FILTER_CONTAINS);}
  CButton* GetRadioRange() { return (CButton*)GetDlgItem(IDC_RADIO_FILTER_RANGE);}

  // utility methods
  UINT GetSelectedRadioButtonID();
  void SyncControls(UINT nRadioID);
  void GetEditText(UINT nID, CString& s);

  DECLARE_MESSAGE_MAP()
};

//////////////////////////////////////////////////////////////////////
// CDNSQueryFilterAdvancedPage

class CDNSQueryFilterAdvancedPage : public CDNSQueryFilterPageBase
{
public:
  CDNSQueryFilterAdvancedPage(CDNSQueryFilterSheet* pSheet)
     		: CDNSQueryFilterPageBase(IDD_FILTERING_LIMITS, pSheet)
  {
  }

protected:
	virtual BOOL OnInitDialog();
	virtual BOOL OnApply();

  afx_msg void OnCountEditChange();

  CDNSUnsignedIntEdit m_maxCountEdit;

  DECLARE_MESSAGE_MAP()
};


//////////////////////////////////////////////////////////////////////
// CDNSQueryFilterSheet

class CDNSQueryFilterSheet : public CPropertySheet
{
public:
  CDNSQueryFilterSheet(CDNSQueryFilter* pQueryFilter, CComponentDataObject* pComponentData)
    : CPropertySheet(IDS_SNAPIN_FILTERING_TITLE),
      m_namePage(this), m_advancedPage(this), m_pComponentData(pComponentData)
  {
    m_psh.dwFlags |= PSH_NOAPPLYNOW;
    m_pQueryFilter = pQueryFilter;
    AddPage(&m_namePage);
    AddPage(&m_advancedPage);
    m_bInit = FALSE;
  }

  CDNSQueryFilter* GetQueryFilter() { return m_pQueryFilter;}
  CComponentDataObject* GetComponentData() { return m_pComponentData; }

  void SetSheetStyle()
  {
    DWORD dwStyle = ::GetWindowLong(GetSafeHwnd(), GWL_EXSTYLE);
    dwStyle |= WS_EX_CONTEXTHELP; // force the [?] button
    ::SetWindowLong(GetSafeHwnd(), GWL_EXSTYLE, dwStyle);
  }

private:
  void Init()
  {
    if (m_bInit)
      return;
    m_bInit = TRUE;
    CWnd* p = GetDlgItem(IDOK);
    if (p)
      p->EnableWindow(FALSE);
  }

  void SetDirty()
  {
    if (!m_bInit)
      return;
    GetDlgItem(IDOK)->EnableWindow(TRUE);
  }

  BOOL m_bInit;
  CComponentDataObject* m_pComponentData;
  CDNSQueryFilter* m_pQueryFilter;
  CDNSQueryFilterNamePage m_namePage;
  CDNSQueryFilterAdvancedPage m_advancedPage;

  friend class CDNSQueryFilterPageBase;
  friend class CDNSQueryFilterNamePage;
  friend class CDNSQueryFilterAdvancedPage;

};


//////////////////////////////////////////////////////////////////////
// CDNSQueryFilterPageBase IMPLEMENTATION

BOOL CDNSQueryFilterPageBase::OnInitDialog()
{
  BOOL bRet = CPropertyPage::OnInitDialog();

  m_pSheet->SetSheetStyle();

  return bRet;
}

void CDNSQueryFilterPageBase::SetDirty()
{
  if (!m_bInit)
    return;
  m_bDirty = TRUE;
  m_pSheet->SetDirty();
}


void CDNSQueryFilterPageBase::Init()
{
  m_bInit = TRUE;
  m_pSheet->Init();
}

BEGIN_MESSAGE_MAP(CDNSQueryFilterPageBase, CPropertyPage)
	ON_WM_CONTEXTMENU()
  ON_MESSAGE(WM_HELP, OnHelp)
  ON_COMMAND(IDM_WHATS_THIS, OnWhatsThis)
END_MESSAGE_MAP()


void CDNSQueryFilterPageBase::OnWhatsThis()
{
  //
  // Display context help for a control
  //
  if ( m_hWndWhatsThis )
  {
    //
    // Build our own HELPINFO struct to pass to the underlying
    // CS help functions built into the framework
    //
    int iCtrlID = ::GetDlgCtrlID(m_hWndWhatsThis);
    HELPINFO helpInfo;
    ZeroMemory(&helpInfo, sizeof(HELPINFO));
    helpInfo.cbSize = sizeof(HELPINFO);
    helpInfo.hItemHandle = m_hWndWhatsThis;
    helpInfo.iCtrlId = iCtrlID;

	  m_pSheet->GetComponentData()->OnDialogContextHelp(m_nIDHelp, &helpInfo);
  }
}

BOOL CDNSQueryFilterPageBase::OnHelp(WPARAM /*wParam*/, LPARAM lParam)
{
  const LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;

  if (pHelpInfo && pHelpInfo->iContextType == HELPINFO_WINDOW)
  {
    //
    // Display context help for a control
    //
	  m_pSheet->GetComponentData()->OnDialogContextHelp(m_nIDHelp, pHelpInfo);
  }

  return TRUE;
}

void CDNSQueryFilterPageBase::OnContextMenu(CWnd* /*pWnd*/, CPoint point) 
{
  //
  // point is in screen coordinates
  //

  CMenu bar;
	if ( bar.LoadMenu(IDR_WHATS_THIS_CONTEXT_MENU1) )
	{
		CMenu& popup = *bar.GetSubMenu (0);
		ASSERT(popup.m_hMenu);

		if ( popup.TrackPopupMenu (TPM_RIGHTBUTTON | TPM_LEFTBUTTON,
			   point.x,     // in screen coordinates
				 point.y,     // in screen coordinates
			   this) )      // route commands through main window
		{
			m_hWndWhatsThis = 0;
			ScreenToClient (&point);
			CWnd* pChild = ChildWindowFromPoint (point,  // in client coordinates
					                                 CWP_SKIPINVISIBLE | CWP_SKIPTRANSPARENT);
			if ( pChild )
      {
				m_hWndWhatsThis = pChild->m_hWnd;
      }
	  }
	}
}

//////////////////////////////////////////////////////////////////////
// CDNSQueryFilterNamePage IMPLEMENTATION

BEGIN_MESSAGE_MAP(CDNSQueryFilterNamePage, CDNSQueryFilterPageBase)
	ON_BN_CLICKED(IDC_RADIO_FILTER_NONE, OnRadioClicked)
	ON_BN_CLICKED(IDC_RADIO_FILTER_STARTS, OnRadioClicked)
  ON_BN_CLICKED(IDC_RADIO_FILTER_CONTAINS, OnRadioClicked)
  ON_BN_CLICKED(IDC_RADIO_FILTER_RANGE, OnRadioClicked)

  ON_EN_CHANGE(IDC_EDIT_FILTER_STARTS, OnEditChange)
  ON_EN_CHANGE(IDC_EDIT_FILTER_CONTAINS, OnEditChange)
  ON_EN_CHANGE(IDC_EDIT_FILTER_RANGE_FROM, OnEditChange)
  ON_EN_CHANGE(IDC_EDIT_FILTER_RANGE_TO, OnEditChange)
END_MESSAGE_MAP()


UINT CDNSQueryFilterNamePage::GetSelectedRadioButtonID()
{
  return GetCheckedRadioButton(IDC_RADIO_FILTER_NONE, IDC_RADIO_FILTER_RANGE);
}



void CDNSQueryFilterNamePage::OnRadioClicked()
{
  UINT nRadioID = GetSelectedRadioButtonID();
  SyncControls(nRadioID);
}

void CDNSQueryFilterNamePage::SyncControls(UINT nRadioID)
{
  BOOL bStartsStringEditEnabled = FALSE;
  BOOL bContainsStringEditEnabled = FALSE;
  BOOL bRangeEnabled = FALSE;

  if (nRadioID == IDC_RADIO_FILTER_STARTS)
  {
    bStartsStringEditEnabled = TRUE;
  }
  else if (nRadioID == IDC_RADIO_FILTER_CONTAINS)
  {
    bContainsStringEditEnabled = TRUE;
  }
  else if (nRadioID == IDC_RADIO_FILTER_RANGE)
  {
    bRangeEnabled = TRUE;
  }
  GetStartsStringEdit()->SetReadOnly(!bStartsStringEditEnabled);
  GetContainsStringEdit()->SetReadOnly(!bContainsStringEditEnabled);
  GetRangeFromStringEdit()->SetReadOnly(!bRangeEnabled);
  GetRangeToStringEdit()->SetReadOnly(!bRangeEnabled);

  SetDirty();
}

void CDNSQueryFilterNamePage::GetEditText(UINT nID, CString& s)
{
  GetDlgItemText(nID, s);
  s.TrimLeft();
  s.TrimRight();
}

void CDNSQueryFilterNamePage::OnEditChange()
{
  SetDirty();
}



BOOL CDNSQueryFilterNamePage::OnInitDialog()
{
	CDNSQueryFilterPageBase::OnInitDialog();

  // write data to edit fields
  SetDlgItemText(IDC_EDIT_FILTER_STARTS, m_pSheet->m_pQueryFilter->m_szStartsString);
  SetDlgItemText(IDC_EDIT_FILTER_CONTAINS, m_pSheet->m_pQueryFilter->m_szContainsString);
  SetDlgItemText(IDC_EDIT_FILTER_RANGE_FROM, m_pSheet->m_pQueryFilter->m_szRangeFrom);
  SetDlgItemText(IDC_EDIT_FILTER_RANGE_TO, m_pSheet->m_pQueryFilter->m_szRangeTo);

  // set the radio buttons
  UINT nRadioID = IDC_RADIO_FILTER_NONE;
  switch(m_pSheet->m_pQueryFilter->m_nFilterOption)
  {
  case DNS_QUERY_FILTER_NONE:
    {
      GetRadioNone()->SetCheck(TRUE);
      nRadioID = IDC_RADIO_FILTER_NONE;
    }
    break;
  case DNS_QUERY_FILTER_STARTS:
    {
      GetRadioStarts()->SetCheck(TRUE);
      nRadioID = IDC_RADIO_FILTER_STARTS;
    }
    break;
  case DNS_QUERY_FILTER_CONTAINS:
    {
      GetRadioContains()->SetCheck(TRUE);
      nRadioID = IDC_RADIO_FILTER_CONTAINS;
    }
    break;
  case DNS_QUERY_FILTER_RANGE:
    {
      GetRadioRange()->SetCheck(TRUE);
      nRadioID = IDC_RADIO_FILTER_RANGE;
    }
    break;

  default:
    ASSERT(FALSE);
  }

  // enable/disable the edit fields
  SyncControls(nRadioID);

  Init();

	return TRUE;  // return TRUE unless you set the focus to a control
}

BOOL CDNSQueryFilterNamePage::OnApply()
{
  if (!IsDirty())
    return TRUE;

  UINT nRadioID = GetSelectedRadioButtonID();

  // get data from edit controls
  GetEditText(IDC_EDIT_FILTER_STARTS, m_pSheet->m_pQueryFilter->m_szStartsString);
  GetEditText(IDC_EDIT_FILTER_CONTAINS, m_pSheet->m_pQueryFilter->m_szContainsString);
  GetEditText(IDC_EDIT_FILTER_RANGE_FROM, m_pSheet->m_pQueryFilter->m_szRangeFrom);
  GetEditText(IDC_EDIT_FILTER_RANGE_TO, m_pSheet->m_pQueryFilter->m_szRangeTo);

  // get radio button selection
  switch(nRadioID)
  {
  case IDC_RADIO_FILTER_NONE:
    {
      m_pSheet->m_pQueryFilter->m_nFilterOption = DNS_QUERY_FILTER_NONE;
    }
    break;
  case IDC_RADIO_FILTER_STARTS:
    {
      if (m_pSheet->m_pQueryFilter->m_szStartsString.IsEmpty())
        m_pSheet->m_pQueryFilter->m_nFilterOption = DNS_QUERY_FILTER_NONE;
      else
        m_pSheet->m_pQueryFilter->m_nFilterOption = DNS_QUERY_FILTER_STARTS;
    }
    break;
  case IDC_RADIO_FILTER_CONTAINS:
    {
      if (m_pSheet->m_pQueryFilter->m_szContainsString.IsEmpty())
        m_pSheet->m_pQueryFilter->m_nFilterOption = DNS_QUERY_FILTER_NONE;
      else
        m_pSheet->m_pQueryFilter->m_nFilterOption = DNS_QUERY_FILTER_CONTAINS;
    }
    break;
  case IDC_RADIO_FILTER_RANGE:
    {
      if (m_pSheet->m_pQueryFilter->m_szRangeFrom.IsEmpty() &&
          m_pSheet->m_pQueryFilter->m_szRangeTo.IsEmpty() )
        m_pSheet->m_pQueryFilter->m_nFilterOption = DNS_QUERY_FILTER_NONE;
      else
        m_pSheet->m_pQueryFilter->m_nFilterOption = DNS_QUERY_FILTER_RANGE;
    }
    break;
  default:
    ASSERT(FALSE);
  }

  return TRUE;
}



//////////////////////////////////////////////////////////////////////
// CDNSQueryFilterAdvancedPage IMPLEMENTATION

BEGIN_MESSAGE_MAP(CDNSQueryFilterAdvancedPage, CDNSQueryFilterPageBase)
  ON_EN_CHANGE(IDC_EDIT_COUNT, OnCountEditChange)
END_MESSAGE_MAP()

void CDNSQueryFilterAdvancedPage::OnCountEditChange()
{
  SetDirty();
}

BOOL CDNSQueryFilterAdvancedPage::OnInitDialog()
{
  CDNSQueryFilterPageBase::OnInitDialog();

  // set the range of the edit control for range validation
  VERIFY(m_maxCountEdit.SubclassDlgItem(IDC_EDIT_COUNT, this));
  m_maxCountEdit.SetRange(DNS_QUERY_OBJ_COUNT_MIN, DNS_QUERY_OBJ_COUNT_MAX);

  // Disable IME support on the control
  ImmAssociateContext(m_maxCountEdit.GetSafeHwnd(), NULL);

  // set limit on the # of digits based on the max value
  CString s;
  s.Format(_T("%u"), DNS_QUERY_OBJ_COUNT_MAX);
  m_maxCountEdit.LimitText(s.GetLength());

  // set the value
  m_maxCountEdit.SetVal(m_pSheet->m_pQueryFilter->m_nMaxObjectCount);

  Init();

  return TRUE;
}

BOOL CDNSQueryFilterAdvancedPage::OnApply()
{
  if (!IsDirty())
    return TRUE;

  m_pSheet->m_pQueryFilter->m_nMaxObjectCount = m_maxCountEdit.GetVal();

  return TRUE;
}

//////////////////////////////////////////////////////////////////////
// CDNSQueryFilter

BOOL CDNSQueryFilter::EditFilteringOptions(CComponentDataObject* pComponentData)
{
  CThemeContextActivator activator;

  CDNSQueryFilterSheet dlg(this, pComponentData);
  return IDOK == dlg.DoModal();
}

HRESULT CDNSQueryFilter::Load(IStream* pStm)
{
  HRESULT hr;
  // name filtering
  if (FAILED(hr = LoadDWordHelper(pStm, (DWORD*)(&m_nFilterOption))))
    return hr;

  if (FAILED(hr = LoadStringHelper(m_szStartsString, pStm)))
    return hr;
  if (FAILED(hr = LoadStringHelper(m_szContainsString, pStm)))
    return hr;
  if (FAILED(hr = LoadStringHelper(m_szRangeFrom, pStm)))
    return hr;
  if (FAILED(hr = LoadStringHelper(m_szRangeTo, pStm)))
    return hr;

  // query limit
  if (FAILED(hr = LoadDWordHelper(pStm, (DWORD*)(&m_nMaxObjectCount))))
    return hr;
  return LoadDWordHelper(pStm, (DWORD*)(&m_bGetAll));
}

HRESULT CDNSQueryFilter::Save(IStream* pStm)
{
  HRESULT hr;

  // name filtering
  if (FAILED(hr = SaveDWordHelper(pStm, (DWORD)m_nFilterOption)))
    return hr;

  if (FAILED(hr = SaveStringHelper(m_szStartsString, pStm)))
    return hr;
  if (FAILED(hr = SaveStringHelper(m_szContainsString, pStm)))
    return hr;
  if (FAILED(hr = SaveStringHelper(m_szRangeFrom, pStm)))
    return hr;
  if (FAILED(hr = SaveStringHelper(m_szRangeTo, pStm)))
    return hr;

  // query limit
  if (FAILED(hr = SaveDWordHelper(pStm, (DWORD)(m_nMaxObjectCount))))
    return hr;
  return SaveDWordHelper(pStm, (DWORD)(m_bGetAll));

}


//////////////////////////////////////////////////////////////////////
// CDNSRootData

const GUID CDNSRootData::NodeTypeGUID =
{ 0x2faebfa3, 0x3f1a, 0x11d0, { 0x8c, 0x65, 0x0, 0xc0, 0x4f, 0xd8, 0xfe, 0xcb } };

BEGIN_TOOLBAR_MAP(CDNSRootData)
  TOOLBAR_EVENT(toolbarNewServer, OnConnectToServer)
END_TOOLBAR_MAP()

CDNSRootData::CDNSRootData(CComponentDataObject* pComponentData) : CRootData(pComponentData)
{
	m_bAdvancedView = FALSE;
  m_pColumnSet = NULL;
  m_szDescriptionBar = _T("");
  m_bCreatePTRWithHost = FALSE;
}

CDNSRootData::~CDNSRootData()
{
	TRACE(_T("~CDNSRootData(), name <%s>\n"),GetDisplayName());
}



STDAPI DnsSetup(LPCWSTR lpszFwdZoneName,
                 LPCWSTR lpszFwdZoneFileName,
                 LPCWSTR lpszRevZoneName,
                 LPCWSTR lpszRevZoneFileName,
                 DWORD dwFlags);

BOOL CDNSRootData::OnAddMenuItem(LPCONTEXTMENUITEM2 pContextMenuItem2, 
                                 long*)
{
	CComponentDataObject* pComponentData = GetComponentDataObject();
	if (pContextMenuItem2->lCommandID == IDM_SNAPIN_CONNECT_TO_SERVER)
	{
		ASSERT(pComponentData != NULL);

		if (pComponentData->IsExtensionSnapin())
			return FALSE; // extensions do not have this menu item
		
		return TRUE;
	}
	// add toggle menu item for advanced view
	if (pContextMenuItem2->lCommandID == IDM_SNAPIN_ADVANCED_VIEW)
  {
    pContextMenuItem2->fFlags = IsAdvancedView() ? MF_CHECKED : 0;
  }
  if (pContextMenuItem2->lCommandID == IDM_SNAPIN_FILTERING)
  {
		if (IsFilteringEnabled())
		{
			pContextMenuItem2->fFlags = MF_CHECKED;
		}
		return TRUE;
  }
	return TRUE;
}

HRESULT CDNSRootData::GetResultViewType(CComponentDataObject*, 
                                        LPOLESTR *ppViewType, 
                                        long *pViewOptions)
{
  HRESULT hr = S_FALSE;

  if (m_containerChildList.IsEmpty() && m_leafChildList.IsEmpty())
  {
    *pViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS;

    LPOLESTR psz = NULL;
    StringFromCLSID(CLSID_MessageView, &psz);

    USES_CONVERSION;

    if (psz != NULL)
    {
        *ppViewType = psz;
        hr = S_OK;
    }
  }
  else
  {
	  *pViewOptions = MMC_VIEW_OPTIONS_NONE;
	  *ppViewType = NULL;
    hr = S_FALSE;
  }
  return hr;
}

HRESULT CDNSRootData::OnShow(LPCONSOLE lpConsole)
{
  CComPtr<IUnknown> spUnknown;
  CComPtr<IMessageView> spMessageView;

  HRESULT hr = lpConsole->QueryResultView(&spUnknown);
  if (FAILED(hr))
    return S_OK;

  hr = spUnknown->QueryInterface(IID_IMessageView, (PVOID*)&spMessageView);
  if (SUCCEEDED(hr))
  {
    // Load and set the title text of the message view
    CString szTitle;
    VERIFY(szTitle.LoadString(IDS_MESSAGE_VIEW_NO_SERVER_TITLE));
    spMessageView->SetTitleText(szTitle);

    // Load and set the body text of the message view
    CString szMessage;
    VERIFY(szMessage.LoadString(IDS_MESSAGE_VIEW_NO_SERVER_MESSAGE));
    spMessageView->SetBodyText(szMessage);

    // Use the standard information icon
    spMessageView->SetIcon(Icon_Information);
  }
  
  return S_OK;
}

BOOL CDNSRootData::IsFilteringEnabled()
{
	UINT nFilterOption = GetFilter()->GetFilterOption();
	if (nFilterOption == DNS_QUERY_FILTER_DISABLED || nFilterOption == DNS_QUERY_FILTER_NONE)
	{
		return FALSE;
	}
	return TRUE;
}

BOOL CDNSRootData::OnSetRefreshVerbState(DATA_OBJECT_TYPES, 
                                         BOOL* pbHide,
                                         CNodeList*)
{
	*pbHide = FALSE;
	return !IsThreadLocked();
}

HRESULT CDNSRootData::OnSetToolbarVerbState(IToolbar* pToolbar, 
                                              CNodeList*)
{
  HRESULT hr = S_OK;

  //
  // Set the button state for each button on the toolbar
  //
  hr = pToolbar->SetButtonState(toolbarNewServer, ENABLED, TRUE);
  ASSERT(SUCCEEDED(hr));

  hr = pToolbar->SetButtonState(toolbarNewRecord, ENABLED, FALSE);
  ASSERT(SUCCEEDED(hr));

  hr = pToolbar->SetButtonState(toolbarNewZone, ENABLED, FALSE);
  ASSERT(SUCCEEDED(hr));

  return hr;
}  

HRESULT CDNSRootData::OnCommand(long nCommandID, 
                                DATA_OBJECT_TYPES,
								                CComponentDataObject* pComponentData,
                                CNodeList* pNodeList)
{
  if (pNodeList->GetCount() > 1) // multiple selection
  {
    return E_FAIL;
  }

	switch (nCommandID)
	{
		case IDM_SNAPIN_CONNECT_TO_SERVER:
			OnConnectToServer(pComponentData, pNodeList);
			break;
		case IDM_SNAPIN_ADVANCED_VIEW:
			OnViewOptions(pComponentData);
			break;
		case IDM_SNAPIN_FILTERING:
      {
        if (OnFilteringOptions(pComponentData))
        {
          pComponentData->SetDescriptionBarText(this);
        }
      }
      break;
		default:
			ASSERT(FALSE); // Unknown command!
			return E_FAIL;
	}
    return S_OK;
}


BOOL CDNSRootData::OnEnumerate(CComponentDataObject* pComponentData, BOOL)
{
	if (m_containerChildList.IsEmpty())
	{
		// the list is empty, need to add
		ASSERT(pComponentData != NULL);
		// create a modal dialog + possibly the wizard proper
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
		CDNSServerWizardHolder holder(this, pComponentData, NULL);
		holder.DoModalConnectOnLocalComputer();
		return FALSE;
	}
	return TRUE; // there are already children, add them to the UI now
}


#define DNS_STREAM_VERSION_W2K ((DWORD)0x06)
#define DNS_STREAM_VERSION     ((DWORD)0x07)

// IStream manipulation helpers overrides
HRESULT CDNSRootData::Load(IStream* pStm)
{
	// assume never get multiple loads
	if(!m_containerChildList.IsEmpty() || !m_leafChildList.IsEmpty())
		return E_FAIL;

	WCHAR szBuffer[256];
	ULONG nLen; // WCHAR counting NULL

	UINT nCount;
	ULONG cbRead;
	// read the version ##
	DWORD dwVersion;
	VERIFY(SUCCEEDED(pStm->Read((void*)&dwVersion,sizeof(DWORD), &cbRead)));
	ASSERT(cbRead == sizeof(DWORD));
	if (dwVersion != DNS_STREAM_VERSION && dwVersion != DNS_STREAM_VERSION_W2K)
		return E_FAIL;

  // load filtering options
  VERIFY(SUCCEEDED(m_filterObj.Load(pStm)));

	// load view option
	VERIFY(SUCCEEDED(pStm->Read((void*)&m_bAdvancedView,sizeof(BOOL), &cbRead)));
	ASSERT(cbRead == sizeof(BOOL));

  //
  // load the Create PTR record with host flag
  //
  if (dwVersion > DNS_STREAM_VERSION_W2K)
  {
	  VERIFY(SUCCEEDED(pStm->Read((void*)&m_bCreatePTRWithHost,sizeof(BOOL), &cbRead)));
	  ASSERT(cbRead == sizeof(BOOL));
  }

	// load the name of the snapin root display string
	VERIFY(SUCCEEDED(pStm->Read((void*)&nLen,sizeof(DWORD), &cbRead)));
	ASSERT(cbRead == sizeof(UINT));
	VERIFY(SUCCEEDED(pStm->Read((void*)szBuffer,sizeof(WCHAR)*nLen, &cbRead)));
	ASSERT(cbRead == sizeof(WCHAR)*nLen);
	SetDisplayName(szBuffer);
	
	// load the list of servers
	VERIFY(SUCCEEDED(pStm->Read((void*)&nCount,sizeof(DWORD), &cbRead)));
	ASSERT(cbRead == sizeof(UINT));

	CComponentDataObject* pComponentData = GetComponentDataObject();
	for (int k=0; k< (int)nCount; k++)
	{
		CDNSServerNode* p = NULL;
		VERIFY(SUCCEEDED(CDNSServerNode::CreateFromStream(pStm, &p)));
		ASSERT(p != NULL);
		VERIFY(AddChildToList(p));
		AddServerToThreadList(p, pComponentData);
	}
	if (nCount > 0)
		MarkEnumerated();
	ASSERT(m_containerChildList.GetCount() == (int)nCount);

	return S_OK;
}

HRESULT CDNSRootData::Save(IStream* pStm, BOOL fClearDirty)
{
	DWORD nCount = 0;
	ULONG cbWrite = 0;

	// write the version ##
	DWORD dwVersion = DNS_STREAM_VERSION;
	VERIFY(SUCCEEDED(pStm->Write((void*)&dwVersion, sizeof(DWORD),&cbWrite)));
	ASSERT(cbWrite == sizeof(DWORD));

  // save filtering options
  VERIFY(SUCCEEDED(m_filterObj.Save(pStm)));

	// save view options
	VERIFY(SUCCEEDED(pStm->Write((void*)&m_bAdvancedView, sizeof(BOOL),&cbWrite)));
	ASSERT(cbWrite == sizeof(BOOL));

  //
  // save the create PTR record with host flag
  //
	VERIFY(SUCCEEDED(pStm->Write((void*)&m_bCreatePTRWithHost, sizeof(BOOL),&cbWrite)));
	ASSERT(cbWrite == sizeof(BOOL));

	// save the name of the snapin root display string
	DWORD nLen = static_cast<DWORD>(wcslen(GetDisplayName())+1); // WCHAR including NULL
	VERIFY(SUCCEEDED(pStm->Write((void*)&nLen, sizeof(DWORD),&cbWrite)));
	ASSERT(cbWrite == sizeof(DWORD));
	VERIFY(SUCCEEDED(pStm->Write((void*)(GetDisplayName()), sizeof(WCHAR)*nLen,&cbWrite)));
	ASSERT(cbWrite == sizeof(WCHAR)*nLen);

	// write # of servers
	nCount = (DWORD)m_containerChildList.GetCount();
	VERIFY(SUCCEEDED(pStm->Write((void*)&nCount, sizeof(DWORD),&cbWrite)));
	ASSERT(cbWrite == sizeof(DWORD));

	// loop through the list of servers and serialize them
	POSITION pos;
	for (pos = m_containerChildList.GetHeadPosition(); pos != NULL; )
	{
		CDNSServerNode* pServerNode = (CDNSServerNode*)m_containerChildList.GetNext(pos);
		VERIFY(SUCCEEDED(pServerNode->SaveToStream(pStm)));
	}

	if (fClearDirty)
		SetDirtyFlag(FALSE);
	return S_OK;
}


HRESULT CDNSRootData::IsDirty()
{
  return CRootData::IsDirty();
}


HRESULT CDNSRootData::OnConnectToServer(CComponentDataObject* pComponentData,
                                        CNodeList*)
{
	ASSERT(pComponentData != NULL);
	// create a modal dialog + possibly the wizard proper
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	CDNSServerWizardHolder holder(this, pComponentData, NULL);
	holder.DoModalConnect();
  pComponentData->UpdateResultPaneView(this);
	return S_OK;
}

void CDNSRootData::AddServer(CDNSServerNode* p, CComponentDataObject* pComponentData)
{
	ASSERT(p != NULL);
	AddChildToListAndUISorted(p, pComponentData);
	AddServerToThreadList(p, pComponentData);
  pComponentData->UpdateResultPaneView(this);
  pComponentData->SetDescriptionBarText(this);
}


BOOL CDNSRootData::VerifyServerName(LPCTSTR lpszServerName)
{
	POSITION pos;
	for (pos = m_containerChildList.GetHeadPosition(); pos != NULL; )
	{
		CTreeNode* pNode = m_containerChildList.GetNext(pos);
		ASSERT(pNode->IsContainer());

    //
		// case insensitive compare
    //
		if (_wcsicmp(pNode->GetDisplayName(), lpszServerName) == 0)
    {
			return FALSE;
    }
	}
	return TRUE;
}


BOOL CDNSRootData::OnViewOptions(CComponentDataObject* pComponentData)
{

	// make sure there are not property sheets up: we do this because:
	// a) some folders might be removed and might have sheets up
	// b) some RR property pages (PTR) might not be switchable
	//    on the fly between view types
	if (IsSheetLocked())
	{
		if (!CanCloseSheets())
			return TRUE;
		pComponentData->GetPropertyPageHolderTable()->DeleteSheetsOfNode(this);
	}
	ASSERT(!IsSheetLocked());
	
	// toggle the view state
	m_bAdvancedView = !m_bAdvancedView;

	// loop through the servers
	POSITION pos;
	for (pos = m_containerChildList.GetHeadPosition(); pos != NULL; )
	{
		CTreeNode* pNode = m_containerChildList.GetNext(pos);
		ASSERT(pNode->IsContainer());
		CDNSServerNode* pServerNode = (CDNSServerNode*)pNode;
		// pass the new view option
		pServerNode->ChangeViewOption(m_bAdvancedView, pComponentData);
	}
	// dirty the MMC document
	SetDirtyFlag(TRUE);
	return TRUE;
}



BOOL CDNSRootData::OnFilteringOptions(CComponentDataObject* pComponentData)
{
  BOOL bRet = m_filterObj.EditFilteringOptions(pComponentData);
  if (bRet)
  {
    SetDirtyFlag(TRUE);
  }
  return bRet;
}


BOOL CDNSRootData::CanCloseSheets()
{
   // NTRAID#NTBUG-594003-2002/04/11-JeffJon-Don't offer
   // to shutdown the sheets for the user because if the
   // sheet brought up a modal dialog we will deadlock
   // ourselves.

	DNSMessageBox(IDS_MSG_CONT_CLOSE_SHEET, MB_OK);
   return FALSE;
}

BOOL CDNSRootData::OnRefresh(CComponentDataObject* pComponentData,
                             CNodeList* pNodeList)
{
  if (pNodeList->GetCount() > 1) // multiple selection
  {
    BOOL bRet = TRUE;

    POSITION pos = pNodeList->GetHeadPosition();
    while (pos != NULL)
    {
      CTreeNode* pNode = pNodeList->GetNext(pos);
      ASSERT(pNode != NULL);

      CNodeList nodeList;
      nodeList.AddTail(pNode);
      if (!pNode->OnRefresh(pComponentData, &nodeList))
      {
        bRet = FALSE;
      }
    }
    return bRet;
  }

	if (IsSheetLocked())
	{
		if (!CanCloseSheets())
			return FALSE;
		pComponentData->GetPropertyPageHolderTable()->DeleteSheetsOfNode(this);
	}
	ASSERT(!IsSheetLocked());

	POSITION pos;
	for (pos = m_containerChildList.GetHeadPosition(); pos != NULL; )
	{
		CTreeNode* pNode = m_containerChildList.GetNext(pos);
		ASSERT(pNode->IsContainer());

    CNodeList nodeList;
    nodeList.AddTail(pNode);
		((CDNSServerNode*)pNode)->OnRefresh(pComponentData, &nodeList);
	}
	return TRUE;
}

LPWSTR CDNSRootData::GetDescriptionBarText()
{
  static CString szFilterEnabled;
  static CString szServersFormat;

  INT_PTR nContainerCount = GetContainerChildList()->GetCount();
  INT_PTR nLeafCount = GetLeafChildList()->GetCount();

  //
  // If not already loaded, then load the format string L"%d record(s)"
  //
  if (szServersFormat.IsEmpty())
  {
    szServersFormat.LoadString(IDS_FORMAT_SERVERS);
  }

  //
  // Format the child count into the description bar text
  //
  m_szDescriptionBar.Format(szServersFormat, nContainerCount + nLeafCount);

  //
  // Add L"[Filter Activated]" if the filter is on
  //
  if(IsFilteringEnabled())
  {
    //
    // If not already loaded, then load the L"[Filter Activated]" string
    //
    if (szFilterEnabled.IsEmpty())
    {
      szFilterEnabled.LoadString(IDS_FILTER_ENABLED);
    }
    m_szDescriptionBar += szFilterEnabled;
  }
  return (LPWSTR)(LPCWSTR)m_szDescriptionBar;
}

void CDNSRootData::TestServers(DWORD dwCurrTime, DWORD dwTimeInterval,
							   CComponentDataObject* pComponentData)
{
	//TRACE(_T("CDNSRootData::TestServers()\n"));
	POSITION pos;
	for (pos = m_containerChildList.GetHeadPosition(); pos != NULL; )
	{
		CTreeNode* pNode = m_containerChildList.GetNext(pos);
		ASSERT(pNode->IsContainer());
		CDNSServerNode* pServerNode = (CDNSServerNode*)pNode;
		if (pServerNode->IsTestEnabled() && !pServerNode->m_bTestQueryPending
							&& (pServerNode->m_dwTestTime <= dwCurrTime))
		{
			DWORD dwQueryFlags =
				CDNSServerTestQueryResult::Pack(pServerNode->IsTestSimpleQueryEnabled(),
												pServerNode->IsRecursiveQueryEnabled());
			pComponentData->PostMessageToTimerThread(WM_TIMER_THREAD_SEND_QUERY,
													(WPARAM)pServerNode,
													(WPARAM)dwQueryFlags);
			pServerNode->m_dwTestTime = dwCurrTime + pServerNode->GetTestInterval();
		}
	}

	// check if the time counter has wrapped (it should be very unlikely, because
	// the timeline is on a DWORD in seconds (about 47000 days) from the console startup.
	if ((dwCurrTime + dwTimeInterval) < dwCurrTime)
	{
		// just reset the whole set of server times (not accurate, but acceptable)
		for (pos = m_containerChildList.GetHeadPosition(); pos != NULL; )
		{
			CTreeNode* pNode = m_containerChildList.GetNext(pos);
			ASSERT(pNode->IsContainer());
			CDNSServerNode* pServerNode = (CDNSServerNode*)pNode;
			pServerNode->m_dwTestTime = 0;
		}
	}
}

void CDNSRootData::OnServerTestData(WPARAM wParam, LPARAM lParam, CComponentDataObject* pComponentData)
{
	ASSERT(lParam == 0);
	CDNSServerTestQueryResult* pTestResult = (CDNSServerTestQueryResult*)wParam;
	ASSERT(pTestResult != NULL);

	// loop through the list of servers to find where it belongs
	POSITION pos;
	for (pos = m_containerChildList.GetHeadPosition(); pos != NULL; )
	{
		CTreeNode* pNode = m_containerChildList.GetNext(pos);
		ASSERT(pNode->IsContainer());
		CDNSServerNode* pServerNode = (CDNSServerNode*)pNode;
		if ( (CDNSServerNode*)(pTestResult->m_serverCookie) == pServerNode)
		{
			pServerNode->AddTestQueryResult(pTestResult, pComponentData);
			return;
		}
	}
}

void CDNSRootData::AddServerToThreadList(CDNSServerNode* pServerNode,
										 CComponentDataObject* pComponentData)
{
	CDNSServerTestQueryInfo* pInfo = new CDNSServerTestQueryInfo;
  if (pInfo)
  {
	  pInfo->m_szServerName = pServerNode->GetDisplayName();
	  pInfo->m_serverCookie = (MMC_COOKIE)pServerNode;
	  pComponentData->PostMessageToTimerThread(WM_TIMER_THREAD_ADD_SERVER, (WPARAM)pInfo,0);
  }
}

void CDNSRootData::RemoveServerFromThreadList(CDNSServerNode* pServerNode,
											  CComponentDataObject* pComponentData)
{
	WPARAM serverCookie = (WPARAM)pServerNode;
	pComponentData->PostMessageToTimerThread(WM_TIMER_THREAD_REMOVE_SERVER, serverCookie,0);
}


///////////////////////////////////////////////////////////////////
// CDNSServerTestTimerThread

int CDNSServerTestTimerThread::Run()
{
	MSG msg;
	// initialize the message pump
	::PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);
	
	// get let the main thread know we are entering the loop
	// (0,0) means just acknowkedge
	PostMessageToWnd(0,0);
	while(::GetMessage(&msg, NULL, 0, 0))
	{
		switch(msg.message)
		{
		case WM_TIMER_THREAD_SEND_QUERY:
		case WM_TIMER_THREAD_SEND_QUERY_TEST_NOW:
			{
				MMC_COOKIE serverCookie = (MMC_COOKIE)msg.wParam;
				ASSERT(serverCookie != NULL);
				POSITION pos;
				for (pos = m_serverInfoList.GetHeadPosition(); pos != NULL; )
				{
					CDNSServerTestQueryInfo* pCurrInfo =
								(CDNSServerTestQueryInfo*)m_serverInfoList.GetNext(pos);
					if (serverCookie == pCurrInfo->m_serverCookie)
					{
						OnExecuteQuery(pCurrInfo, (DWORD)msg.lParam,
							(msg.message == WM_TIMER_THREAD_SEND_QUERY_TEST_NOW));
						break;
					}
				}
			}				
			break;
		case WM_TIMER_THREAD_ADD_SERVER:
			{
				CDNSServerTestQueryInfo* pInfo = (CDNSServerTestQueryInfo*)msg.wParam;
				ASSERT(pInfo != NULL);
				m_serverInfoList.AddTail(pInfo);
			}
			break;
		case WM_TIMER_THREAD_REMOVE_SERVER:
			{
				MMC_COOKIE serverCookie = (MMC_COOKIE)msg.wParam;
				ASSERT(serverCookie != NULL);
				POSITION pos;
				POSITION posDel = NULL;
				CDNSServerTestQueryInfo* pInfo = NULL;
				for (pos = m_serverInfoList.GetHeadPosition(); pos != NULL; )
				{
					posDel = pos;
					CDNSServerTestQueryInfo* pCurrInfo =
								(CDNSServerTestQueryInfo*)m_serverInfoList.GetNext(pos);
					if (serverCookie == pCurrInfo->m_serverCookie)
					{
						pInfo = pCurrInfo;
						break;
					}
				}
				if (pInfo != NULL)
				{
					ASSERT(posDel != NULL);
					m_serverInfoList.RemoveAt(posDel);
					delete pInfo;
				}
			}
			break;
		//default:
			//ASSERT(FALSE);
		}
	}
	return 0;
}


void CDNSServerTestTimerThread::OnExecuteQuery(CDNSServerTestQueryInfo* pInfo,
											   DWORD dwQueryFlags,
											   BOOL bAsyncQuery)
{
	// initialize a query result object
	CDNSServerTestQueryResult* pTestResult = new CDNSServerTestQueryResult;
  if (!pTestResult)
  {
    return;
  }

	pTestResult->m_serverCookie = pInfo->m_serverCookie;
	pTestResult->m_dwQueryFlags = dwQueryFlags;
	pTestResult->m_bAsyncQuery = bAsyncQuery;
	::GetLocalTime(&(pTestResult->m_queryTime));

	// execute query
	BOOL bPlainQuery, bRecursiveQuery;
	CDNSServerTestQueryResult::Unpack(dwQueryFlags, &bPlainQuery, &bRecursiveQuery);

	IP_ADDRESS* ipArray;
	int nIPCount;
	pTestResult->m_dwAddressResolutionResult = FindIP(pInfo->m_szServerName, &ipArray, &nIPCount);

	if (pTestResult->m_dwAddressResolutionResult == 0)
	{
		ASSERT(ipArray != NULL);
		ASSERT(nIPCount > 0);
      PIP_ARRAY pipArr = (PIP_ARRAY)malloc(sizeof(DWORD)+sizeof(IP_ADDRESS)*nIPCount);
      if (pipArr && ipArray)
	  {
		  pipArr->AddrCount = nIPCount;
		  memcpy(pipArr->AddrArray, ipArray, sizeof(IP_ADDRESS)*nIPCount);

		  if (bPlainQuery)
		  {
			  pTestResult->m_dwPlainQueryResult = DoNothingQuery(pipArr, TRUE);
		  }
		  if (bRecursiveQuery)
		  {
			  pTestResult->m_dwRecursiveQueryResult = DoNothingQuery(pipArr, FALSE);
		  }
        free(pipArr);
        pipArr = 0;
	  }
	}

	if (!PostMessageToWnd((WPARAM)pTestResult, 0))
			delete pTestResult; // could not deliver

	if (ipArray != NULL)
		free(ipArray);
}

DNS_STATUS CDNSServerTestTimerThread::FindIP(LPCTSTR lpszServerName, IP_ADDRESS** pipArray, int* pnIPCount)
{
	DNS_STATUS dwErr = 0;
	*pipArray = NULL;
	*pnIPCount = 0;
	// try to see if the name is already an IP address
	IP_ADDRESS ipAddr = IPStringToAddr(lpszServerName);
	if (ipAddr != INADDR_NONE)
	{
		*pnIPCount = 1;
		*pipArray = (IP_ADDRESS*)malloc((*pnIPCount)*sizeof(IP_ADDRESS));
    if (*pipArray != NULL)
    {
		  *pipArray[0] = ipAddr;
    }
	}
	else
	{

    //
    // Originally we were doing a DnsQuery() to retrieve the IP address of the server so that we
    // could perform a query to that server to monitor its response.  The problem with this is that
    // if the user enters a single label hostname as the server and they are administering remotely
    // and the two machines have different domain suffixes, then the DnsQuery() to get the IP address
    // of the server would fail.  DnsQuery() appends the name of the Domain suffix to the single label
    // host name and then tries to resolve the using that FQDN which is incorrect.  So instead of 
    // performing a DnsQuery() to get the IP address, the following uses WSALookupServiceBegin(),
    // Next(), and End() to get the IP address.  This has a better chance of resolving the name because
    // it uses DNS, WINS, etc.  I am leaving in the old stuff just in case we run into some problems.
    //
	  HANDLE			  hLookup;
	  WSAQUERYSET 	qsQuery;
	  DWORD			    dwBufLen = 0;
	  GUID			 	  gHostAddrByName = SVCID_INET_HOSTADDRBYNAME;
    WSAQUERYSET*  pBuffer = NULL;

    //
    // Initialize the query structure
    //
	  memset(&qsQuery, 0, sizeof(WSAQUERYSET));
	  qsQuery.dwSize = sizeof(WSAQUERYSET);   // the dwSize field has to be initialised like this
	  qsQuery.dwNameSpace = NS_ALL;
	  qsQuery.lpServiceClassId = &gHostAddrByName;  // this is the GUID to perform forward name resolution (name to IP)
    qsQuery.lpszServiceInstanceName = (LPWSTR)lpszServerName; // this is the name queried for.

    hLookup = NULL;

    //
    // Get the handle for the query
    //
    int iStartupRet = 0;
	  int iResult = WSALookupServiceBegin(&qsQuery,LUP_RETURN_ALL,&hLookup);
    if (iResult != 0)
    {
      //
      // Find out what socket error it was
      //
      int iErrorRet = WSAGetLastError();

      //
      // If the service wasn't started try starting it
      //
      if (iErrorRet == WSANOTINITIALISED)
      {
        WSADATA wsaData;
        WORD wVersion = MAKEWORD(2,0);
        iStartupRet = WSAStartup(wVersion, &wsaData);
        if (iStartupRet == 0)
        {
          //
          // Startup succeeded, lets try to begin again
          //
          iResult = WSALookupServiceBegin(&qsQuery,LUP_RETURN_ALL,&hLookup);
        }
      }


      //
      // Clear the error
      //
      WSASetLastError(0);
    }

	  if(0 == iResult)
	  {
      //
      // Get the size of the first data block from the query
      //
		  iResult = WSALookupServiceNext(hLookup, LUP_RETURN_ALL | LUP_FLUSHCACHE, &dwBufLen,
												  pBuffer);

      //
      // Allocate the required space for the query data
      //
      pBuffer = (WSAQUERYSET*)malloc(dwBufLen);
      ASSERT(pBuffer != NULL);

      if (pBuffer == NULL)
      {
        return E_OUTOFMEMORY;
      }
      else
      {
        //
        // Get the first data block from the query
        //
        iResult = WSALookupServiceNext(hLookup, LUP_RETURN_ALL | LUP_FLUSHCACHE, &dwBufLen,
										  pBuffer);

        //
        // Loop through all the data in the query but stop if we get a valid IP address
        // for the remote machine.
        //
        while(0 == iResult)
		  {
          if (pBuffer != NULL &&
              pBuffer->lpcsaBuffer != NULL && 
              pBuffer->lpcsaBuffer->RemoteAddr.lpSockaddr != NULL)
          {
            //
            // We are only interested in the socket address so get a pointer to the sockaddr structure
            //
            sockaddr_in* pSockAddr = (sockaddr_in*)pBuffer->lpcsaBuffer->RemoteAddr.lpSockaddr;
            ASSERT(pSockAddr != NULL);

            //
            // Pull the IP address of the remote machine and pack it into a DWORD
            //
            DWORD dwIP = 0;
            dwIP = pSockAddr->sin_addr.S_un.S_un_b.s_b1;
            dwIP |= pSockAddr->sin_addr.S_un.S_un_b.s_b2 << 8;
            dwIP |= pSockAddr->sin_addr.S_un.S_un_b.s_b3 << 16;
            dwIP |= pSockAddr->sin_addr.S_un.S_un_b.s_b4 << 24;

            //
            // Increment the IP count and allocate space for the address
            //
            (*pnIPCount)++;
       		  *pipArray = (IP_ADDRESS*)malloc((*pnIPCount)*sizeof(IP_ADDRESS));
            if (*pipArray != NULL)
            {

              //
              // Copy the IP address into the IP array
              //
      		    PIP_ADDRESS pCurrAddr = *pipArray;
              *pCurrAddr = dwIP;
            }

            //
            // Break since we were able to obtain an IP address
            //
            break;
          }

          //
          // Free the buffer if it is still there
          //
          if (pBuffer != NULL)
          {
            free(pBuffer);
            pBuffer = NULL;
            dwBufLen = 0;
          }

          //
          // Get the size of the next data block from the query
          //
          iResult = WSALookupServiceNext(hLookup, LUP_RETURN_ALL | LUP_FLUSHCACHE, &dwBufLen,
										  pBuffer);

          //
          // Allocate enough space for the next data block from the query
          //
          pBuffer = (WSAQUERYSET*)malloc(dwBufLen);
          ASSERT(pBuffer != NULL);

          if (pBuffer)
          {
            //
            // Get the next data block from the query
            //
            iResult = WSALookupServiceNext(hLookup, LUP_RETURN_ALL, &dwBufLen,
										      pBuffer);
          }
          else
          {
             // NTRAID#NTBUG9-666458-2002/07/18-JeffJon
             // If the buffer is NULL at this point we have to act like we were
             // unable to obtain an IP address due to memory constraints

             break;
          }
		  }

        //
        // Free the buffer if it hasn't already been freed
        //
        if (pBuffer != NULL)
        {
          free(pBuffer);
          pBuffer = NULL;
        }
	    }

      //
      // Close the handle to the query
      //
      iResult = WSALookupServiceEnd(hLookup);
      ASSERT(iResult == 0);

      //
      // If we didn't get an IP address return an error
      //
      dwErr = (*pnIPCount < 1) ? -1 : 0;

	  }
  }
	return dwErr;
}

DNS_STATUS CDNSServerTestTimerThread::DoNothingQuery(PIP_ARRAY pipArr, BOOL bSimple)
{
	PDNS_RECORD pRecordList = NULL;
	DNS_STATUS dwErr = 0;
	if (bSimple)
	{
		dwErr = ::DnsQuery(_T("1.0.0.127.in-addr.arpa"),
					DNS_TYPE_PTR,
					DNS_QUERY_NO_RECURSION | DNS_QUERY_BYPASS_CACHE | DNS_QUERY_ACCEPT_PARTIAL_UDP | DNS_QUERY_WIRE_ONLY,
					pipArr, &pRecordList, NULL);
	}
	else
	{
		dwErr = ::DnsQuery(_T("."),
					DNS_TYPE_NS,
					DNS_QUERY_STANDARD | DNS_QUERY_BYPASS_CACHE | DNS_QUERY_ACCEPT_PARTIAL_UDP,
					pipArr, &pRecordList, NULL);
	}
	if (pRecordList != NULL)
		::DnsRecordListFree(pRecordList, DnsFreeRecordListDeep);
	return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\snapdata.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       snapdata.h
//
//--------------------------------------------------------------------------

#ifndef _SNAPDATA_H
#define _SNAPDATA_H

////////////////////////////////////////////////////////////////////////
// defines for test thread messages

#define WM_TIMER_THREAD_ADD_SERVER			(WM_USER + 1)
#define WM_TIMER_THREAD_REMOVE_SERVER		(WM_USER + 2)
#define WM_TIMER_THREAD_SEND_QUERY			(WM_USER + 3)
#define WM_TIMER_THREAD_SEND_QUERY_TEST_NOW	(WM_USER + 4)


/////////////////////////////////////////////////////////////////////////
// defines for filtering

// filtering options

#define DNS_QUERY_FILTER_DISABLED   0
#define DNS_QUERY_FILTER_NONE       1
#define DNS_QUERY_FILTER_STARTS     2
#define DNS_QUERY_FILTER_CONTAINS   3
#define DNS_QUERY_FILTER_RANGE      4

//  # of items per folder: must be >=0  and <= 0xFFFFFFFF (DWORD) to serialize
#define DNS_QUERY_OBJ_COUNT_DEFAULT 10000   // default value
#define DNS_QUERY_OBJ_COUNT_MIN 10      // min value
#define DNS_QUERY_OBJ_COUNT_MAX 999999  // max value

///////////////////////////////////////////////////////////////////////////////
// GLOBAL FUNCTIONS

HRESULT SaveStringHelper(LPCWSTR pwsz, IStream* pStm);
HRESULT LoadStringHelper(CString& sz, IStream* pStm);

HRESULT SaveDWordHelper(IStream* pStm, DWORD dw);
HRESULT LoadDWordHelper(IStream* pStm, DWORD* pdw);


///////////////////////////////////////////////////////////////////////////////
// FORWARD DECLARATIONS

class CDNSServerNode;
class CNewServerDialog;
class CDNSServerWizardHolder;
class CDNSServerTestQueryResult;
class CDNSComponentDataObjectEx;

class CDNSQueryFilterNamePage;
class CDNSQueryFilterAdvancedPage;


//////////////////////////////////////////////////////////////////////
// CDNSQueryFilter

class CDNSQueryFilter
{
public:
  CDNSQueryFilter()
  {
    m_nFilterOption = DNS_QUERY_FILTER_NONE;
    m_nMaxObjectCount = DNS_QUERY_OBJ_COUNT_DEFAULT;
    m_bGetAll = FALSE;
  }
  ~CDNSQueryFilter(){}
  BOOL EditFilteringOptions(CComponentDataObject* pComponentData);

  // accessor methods
  UINT GetFilterOption()
  { return m_nFilterOption;}
  LPCWSTR GetFilterString()
  {
    if (m_nFilterOption == DNS_QUERY_FILTER_STARTS)
      return m_szStartsString;
    else if (m_nFilterOption == DNS_QUERY_FILTER_CONTAINS)
      return m_szContainsString;
    else if (m_nFilterOption == DNS_QUERY_FILTER_RANGE)
      return m_szRangeFrom;
    return NULL;
  }
  LPCWSTR GetFilterStringRange()
  {
    if (m_nFilterOption == DNS_QUERY_FILTER_RANGE)
      return m_szRangeTo;
    return NULL;
  }
  ULONG GetMaxObjectCount() { return m_nMaxObjectCount;}
  BOOL GetAll() { return m_bGetAll;}

  // serialization
 	HRESULT Load(IStream* pStm);
	HRESULT Save(IStream* pStm);

private:
  // name filtering
  UINT m_nFilterOption;
  CString m_szStartsString;
  CString m_szContainsString;
  CString m_szRangeFrom;
  CString m_szRangeTo;

  // query limit
  ULONG m_nMaxObjectCount;
  BOOL m_bGetAll;

  friend class CDNSQueryFilterNamePage;
  friend class CDNSQueryFilterAdvancedPage;
};



///////////////////////////////////////////////////////////////////
// CDNSRootData

class CDNSRootData : public CRootData
{
public:
	CDNSRootData(CComponentDataObject* pComponentData);
	virtual ~CDNSRootData();

	// node info
	DECLARE_NODE_GUID()

	virtual HRESULT OnCommand(long nCommandID, 
                            DATA_OBJECT_TYPES type, 
                            CComponentDataObject* pComponentData,
                            CNodeList* pNodeList);
	virtual void OnDelete(CComponentDataObject*,
                        CNodeList*)
		{ ASSERT(FALSE);}
	virtual BOOL OnRefresh(CComponentDataObject* pComponentData,
                         CNodeList* pNodeList);
	virtual BOOL OnSetRefreshVerbState(DATA_OBJECT_TYPES type, 
                                     BOOL* pbHide,
                                     CNodeList* pNodeList);

	virtual int GetImageIndex(BOOL) { return ROOT_IMAGE;}
  virtual LPWSTR GetDescriptionBarText();

  // filtering
	BOOL IsAdvancedView() { return m_bAdvancedView; }
  CDNSQueryFilter* GetFilter() { return &m_filterObj;}

	virtual BOOL OnEnumerate(CComponentDataObject* pComponentData, BOOL bAsync = TRUE);

	// IStream manipulation helpers overrides
  virtual HRESULT IsDirty();
	virtual HRESULT Load(IStream* pStm);
	virtual HRESULT Save(IStream* pStm, BOOL fClearDirty);

  virtual CColumnSet* GetColumnSet()
  {
    if (m_pColumnSet == NULL)
    {
      m_pColumnSet = ((CDNSComponentDataObjectBase*)GetComponentDataObject())->GetColumnSet(L"---Server Column Set---");
    }
    return m_pColumnSet;
  }
  virtual LPCWSTR GetColumnID() { return GetColumnSet()->GetColumnID(); }

  HRESULT GetResultViewType(CComponentDataObject* pComponentData, 
                            LPOLESTR *ppViewType, 
                            long *pViewOptions);
  HRESULT OnShow(LPCONSOLE lpConsole);

  virtual BOOL CanExpandSync() { return TRUE; }

  virtual HRESULT OnSetToolbarVerbState(IToolbar* pToolbar, CNodeList* pNodeList);

  DECLARE_TOOLBAR_MAP()
protected:
	virtual BOOL CanCloseSheets();
	virtual LPCONTEXTMENUITEM2 OnGetContextMenuItemTable()
				{ return CDNSRootDataMenuHolder::GetContextMenuItem(); }
	virtual BOOL OnAddMenuItem(LPCONTEXTMENUITEM2 pContextMenuItem2,
								             long *pInsertionAllowed);
// server testing
public:
	void TestServers(DWORD dwCurrTime, DWORD dwTimeInterval,CComponentDataObject* pComponentData);
	void OnServerTestData(WPARAM wParam, LPARAM lParam, CComponentDataObject* pComponentData);
private:
	void AddServerToThreadList(CDNSServerNode* pServerNode, CComponentDataObject* pComponentData);
	void RemoveServerFromThreadList(CDNSServerNode* pServerNode, CComponentDataObject* pComponentData);

private:
	BOOL m_bAdvancedView;	// view option toggle
  CDNSQueryFilter m_filterObj;

	// menu message handlers
	HRESULT OnConnectToServer(CComponentDataObject* pComponentData, CNodeList* pNodeList = NULL);
public:
  BOOL OnViewOptions(CComponentDataObject* pComponentData);
  BOOL OnFilteringOptions(CComponentDataObject* pComponentData);

  BOOL IsFilteringEnabled();

  void SetCreatePTRWithHost(BOOL bCreate = FALSE) { m_bCreatePTRWithHost = bCreate; }
  BOOL GetCreatePTRWithHost() { return m_bCreatePTRWithHost; }

private:
	BOOL VerifyServerName(LPCTSTR lpszServerName);
	void AddServer(CDNSServerNode* p, CComponentDataObject* pComponentData);

	friend class CDNSServerWizardHolder;
	friend class CNewServerDialog;
	friend class CDNSServerNode;
	friend class CDNSComponentDataObjectEx;

  CString m_szDescriptionBar;
  CColumnSet* m_pColumnSet;

  BOOL m_bCreatePTRWithHost;
};

////////////////////////////////////////////////////////////////////////
// CDNSServerTestQueryInfo

class CDNSServerTestQueryInfo
{
public:
	CDNSServerTestQueryInfo() { m_serverCookie = 0; }
// data
	CString m_szServerName;
	MMC_COOKIE m_serverCookie;
};

////////////////////////////////////////////////////////////////////////
// CDNSServerTestQueryInfoList

class CDNSServerTestQueryInfoList : public
		CList< CDNSServerTestQueryInfo*, CDNSServerTestQueryInfo*>
{
public:
	~CDNSServerTestQueryInfoList()
	{
		while (!IsEmpty())
			delete RemoveHead();
	}
};

///////////////////////////////////////////////////////////////////
// CDNSServerTestTimerThread

class CDNSServerTestTimerThread : public CTimerThread
{
public:
	virtual int Run();
private:
	// message handlers
	void OnExecuteQuery(CDNSServerTestQueryInfo* pInfo, DWORD dwQueryFlags,
						BOOL bAsyncQuery);
	DNS_STATUS FindIP(LPCTSTR lpszServerName, IP_ADDRESS** pipArray, int* pnIPCount);
	DNS_STATUS DoNothingQuery(PIP_ARRAY pipArr, BOOL bSimple);
	CDNSServerTestQueryInfoList m_serverInfoList;
};


#endif // _SNAPDATA_H


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\uiutil.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       uiutil.cpp
//
//--------------------------------------------------------------------------



#include "preDNSsn.h"
#include <SnapBase.h>

#include "resource.h"
#include "dnsutil.h"
#include "DNSSnap.h"

#include "snapdata.h"
#include "server.h"
#include "domain.h"
#include "zone.h"
#include "serverui.h"

#include "uiutil.h"
#include <errno.h>

#ifdef DEBUG_ALLOCATOR
	#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
	#endif
#endif

////////////////////////////////////////////////////////////////////////////
// CDNSNameTokenizer

CDNSNameTokenizer::CDNSNameTokenizer(PCWSTR pszDNSName)
{
  ASSERT(pszDNSName != NULL);
  m_szDNSName = pszDNSName;
}

CDNSNameTokenizer::~CDNSNameTokenizer()
{

}

BOOL CDNSNameTokenizer::Tokenize(const wchar_t* wcToken)
{
  BOOL bRet = TRUE;

  PWSTR pszToken = new WCHAR[m_szDNSName.GetLength() + 1];
  if (pszToken != NULL)
  {
    wcscpy(pszToken, m_szDNSName);

    PWSTR pszNextToken = wcstok(pszToken, wcToken);
    while (pszNextToken != NULL)
    {
      AddTail(pszNextToken);
      pszNextToken = wcstok(NULL, wcToken);
    }
    delete[] pszToken;
    pszToken = NULL;
  }
  else
  {
    bRet = FALSE;
  }

  return bRet;
}

void CDNSNameTokenizer::RemoveMatchingFromTail(CDNSNameTokenizer& refTokenizer)
{
  //
  // Removes matching tokens from the tail until one of the tokenizers is empty
  // or we come across mismatched tokens
  //
  while (GetCount() > 0 && refTokenizer.GetCount() > 0)
  {
    if (GetTail() == refTokenizer.GetTail())
    {
      RemoveTail();
      refTokenizer.RemoveTail();
    }
    else
    {
      break;
    }
  }
}

void CDNSNameTokenizer::GetRemaining(CString& strrefRemaining, const wchar_t* wcToken)
{
  //
  // Copies the remaining tokens into a string delimited by the token passed in
  //
  strrefRemaining.Empty();

  POSITION pos = GetHeadPosition();
  while (pos != NULL)
  {
    strrefRemaining += GetNext(pos);
    if (pos != NULL)
    {
      strrefRemaining += wcToken;
    }
  }
}

////////////////////////////////////////////////////////////////////////////
// Global functions

BOOL LoadStringsToComboBox(HINSTANCE hInstance, CComboBox* pCombo,
						   UINT nStringID, UINT nMaxLen, UINT nMaxAddCount)
{
	pCombo->ResetContent();
	ASSERT(hInstance != NULL);
	WCHAR* szBuf = (WCHAR*)malloc(sizeof(WCHAR)*nMaxLen);
  if (!szBuf)
  {
    return FALSE;
  }

  BOOL bRet = TRUE;
  LPWSTR* lpszArr = 0;
  do // false loop
  {
	  if ( ::LoadString(hInstance, nStringID, szBuf, nMaxLen) == 0)
    {
      bRet = FALSE;
		  break;
    }

	  lpszArr = (LPWSTR*)malloc(sizeof(LPWSTR*)*nMaxLen);
    if (!lpszArr)
    {
      bRet = FALSE;
      break;
    }

	  UINT nArrEntries;
	  ParseNewLineSeparatedString(szBuf,lpszArr, &nArrEntries);
	  
	  if (nMaxAddCount < nArrEntries) nArrEntries = nMaxAddCount;
	  for (UINT k=0; k<nArrEntries; k++)
		  pCombo->AddString(lpszArr[k]);
  } while (false);

  if (szBuf)
  {
    free(szBuf);
    szBuf = 0;
  }

  if (lpszArr)
  {
    free(lpszArr);
    lpszArr = 0;
  }
	return bRet;
}

void ParseNewLineSeparatedString(LPWSTR lpsz,
								 LPWSTR* lpszArr,
								 UINT* pnArrEntries)
{
	static WCHAR lpszSep[] = L"\n";
	*pnArrEntries = 0;
	int k = 0;
	lpszArr[k] = wcstok(lpsz, lpszSep);
	if (lpszArr[k] == NULL)
		return;

	while (TRUE)
	{
		WCHAR* lpszToken = wcstok(NULL, lpszSep);
		if (lpszToken != NULL)
			lpszArr[++k] = lpszToken;
		else
			break;
	}
	*pnArrEntries = k+1;
}

void LoadStringArrayFromResource(LPWSTR* lpszArr,
											UINT* nStringIDs,
											int nArrEntries,
											int* pnSuccessEntries)
{
	CString szTemp;
	
	*pnSuccessEntries = 0;
	for (int k = 0;k < nArrEntries; k++)
	{
		if (!szTemp.LoadString(nStringIDs[k]))
		{
			lpszArr[k] = NULL;
			continue;
		}
		
		int iLength = szTemp.GetLength() + 1;
		lpszArr[k] = (LPWSTR)malloc(sizeof(WCHAR)*iLength);
		if (lpszArr[k] != NULL)
		{
			wcscpy(lpszArr[k], (LPWSTR)(LPCWSTR)szTemp);
			(*pnSuccessEntries)++;
		}
	}
}

	
	

void EnumerateMTNodeHelper(CMTContainerNode* pNode,
							 CComponentDataObject* pComponentData)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   CThemeContextActivator activator;


   //TRACE(_T("before CLongOperationDialog::DoModal()\n"));
   HWND hWnd = NULL;
   HRESULT hr = pComponentData->GetConsole()->GetMainWindow(&hWnd);
   ASSERT(SUCCEEDED(hr));

   CWnd* pParentWnd = CWnd::FromHandle(hWnd);

   CNodeEnumerationThread* pNodeEnumThread = new CNodeEnumerationThread(pComponentData,pNode);

   if (pNodeEnumThread)
   {
      CLongOperationDialog dlg(
         pNodeEnumThread,
         pParentWnd,
         IDR_SEARCH_AVI);

	   dlg.DoModal();
   }
	//TRACE(_T("after CLongOperationDialog::DoModal()\n"));
}

void _EnableEditableControlHelper(HWND hWnd, BOOL bEnable)
{
   static const int BufferSizeInCharacters = 256;

   WCHAR* szBuf = new WCHAR[BufferSizeInCharacters];
   if (szBuf)
   {
      ZeroMemory(szBuf, sizeof(WCHAR) * BufferSizeInCharacters);

	   int result = ::GetClassName(hWnd, szBuf, 256);

      // ignore truncation because we only care about the first 6 characters
      // anyway

	   if (result &&
          wcsncmp(szBuf, TEXT("Static"), BufferSizeInCharacters) != 0)
      {
         ::EnableWindow(hWnd, bEnable);
      }

      delete[] szBuf;
   }
}

void EnableDialogControls(HWND hWnd, BOOL bEnable)
{
	HWND hWndCurr = ::GetWindow(hWnd, GW_CHILD);
	if (hWndCurr != NULL)
	{
		_EnableEditableControlHelper(hWndCurr, bEnable);
    hWndCurr = ::GetNextWindow(hWndCurr, GW_HWNDNEXT);
		while (hWndCurr)
    {
			_EnableEditableControlHelper(hWndCurr, bEnable);
      hWndCurr = ::GetNextWindow(hWndCurr, GW_HWNDNEXT);
    }
	}
}


BOOL LoadFontInfoFromResource(IN UINT nFontNameID, 
                              IN UINT nFontSizeID,
                              OUT LPWSTR lpFontName, IN int nFontNameMaxchar,
                              OUT int& nFontSize,
                              IN LPCWSTR lpszDefaultFont, IN int nDefaultFontSize)
{
  BOOL bRes = FALSE;
  if (0 == ::LoadString(_Module.GetResourceInstance(), nFontNameID,
              lpFontName, nFontNameMaxchar))
  {
    wcscpy(lpFontName, lpszDefaultFont); 
  }
  else
  {
    bRes = TRUE;
  }

  WCHAR szFontSize[128];
  if (0 != ::LoadString(_Module.GetResourceInstance(), nFontSizeID,
              szFontSize, sizeof(szFontSize)/sizeof(WCHAR)))
  {
    nFontSize = _wtoi(szFontSize);
    if (nFontSize == 0)
      nFontSize = nDefaultFontSize;
    else
      bRes = TRUE;
  }
  else
  {
    nFontSize = nDefaultFontSize;
  }
  return bRes;
}

void InitBigBoldFont(HWND hWnd, HFONT& hFont)
{
  ASSERT(::IsWindow(hWnd));

  NONCLIENTMETRICS ncm;
  memset(&ncm, 0, sizeof(ncm));
  ncm.cbSize = sizeof(ncm);
  ::SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

  LOGFONT boldLogFont = ncm.lfMessageFont;
  boldLogFont.lfWeight = FW_BOLD;

  int nFontSize = 0;
  VERIFY(LoadFontInfoFromResource(IDS_BIG_BOLD_FONT_NAME,
                                  IDS_BIG_BOLD_FONT_SIZE,
                                  boldLogFont.lfFaceName, LF_FACESIZE,
                                  nFontSize,
                                  L"Verdana Bold", 12 // default if something goes wrong
                                  ));

  HDC hdc = ::GetDC(hWnd);

  if (hdc != NULL)
  {
    boldLogFont.lfHeight = 0 - (::GetDeviceCaps(hdc, LOGPIXELSY) * nFontSize / 72);
    hFont = ::CreateFontIndirect((const LOGFONT*)(&boldLogFont));

    ::ReleaseDC(hWnd, hdc);
  }
}


void SetBigBoldFont(HWND hWndDialog, int nControlID)
{
   ASSERT(::IsWindow(hWndDialog));
   ASSERT(nControlID);

   static HFONT boldLogFont = 0;
   if (boldLogFont == 0)
   {
      InitBigBoldFont(hWndDialog, boldLogFont);
   }

   HWND hWndControl = ::GetDlgItem(hWndDialog, nControlID);

   if (hWndControl)
   {
     ::SendMessage(hWndControl, WM_SETFONT, (WPARAM)boldLogFont, MAKELPARAM(TRUE, 0));
   }
}


int GetCheckedRadioButtonHelper(HWND hDlg, int nCount, int* nRadioArr, int nRadioDefault)
{
  ASSERT(::IsWindow(hDlg));
  ASSERT(nCount > 0);
  for (int k=0; k<nCount; k++)
  {
    HWND hRadio = ::GetDlgItem(hDlg, nRadioArr[k]);
    ASSERT(hRadio != NULL);
    if ((hRadio != NULL) && (BST_CHECKED == ::SendMessage(hRadio, BM_GETCHECK, 0, 0)))
      return nRadioArr[k];
  }
  ASSERT(FALSE);
  return nRadioDefault;
}

////////////////////////////////////////////////////////////////////////////
// CMultiselectErrorDialog
BEGIN_MESSAGE_MAP(CMultiselectErrorDialog, CDialog)
END_MESSAGE_MAP()

HRESULT CMultiselectErrorDialog::Initialize(CNodeList* pNodeList,
                                            DNS_STATUS* pErrorArray,
                                            UINT nErrorCount,
                                            PCWSTR pszTitle, 
                                            PCWSTR pszCaption,
                                            PCWSTR pszColumnHeader)
{
  ASSERT(pNodeList != NULL);
  ASSERT(pErrorArray != NULL);
  ASSERT(pszTitle != NULL);
  ASSERT(pszCaption != NULL);
  ASSERT(pszColumnHeader != NULL);

  if (pNodeList == NULL ||
      pErrorArray == NULL ||
      pszTitle == NULL ||
      pszCaption == NULL ||
      pszColumnHeader == NULL)
  {
    return E_POINTER;
  }

  m_pNodeList = pNodeList;
  m_pErrorArray = pErrorArray;
  m_nErrorCount = nErrorCount;
  m_szTitle = pszTitle;
  m_szCaption = pszCaption;
  m_szColumnHeader = pszColumnHeader;

  return S_OK;
}

const int OBJ_LIST_NAME_COL_WIDTH = 100;
const int IDX_NAME_COL = 0;
const int IDX_ERR_COL = 1;

BOOL CMultiselectErrorDialog::OnInitDialog()
{
  CDialog::OnInitDialog();
  
  SetWindowText(m_szTitle);
  SetDlgItemText(IDC_STATIC_MESSAGE, m_szCaption);

  HWND hList = GetDlgItem(IDC_ERROR_LIST)->GetSafeHwnd();
  ListView_SetExtendedListViewStyle(hList, LVS_EX_FULLROWSELECT);

  //
  // Set the column headings.
  //
  RECT rect;
  ::GetClientRect(hList, &rect);

  LV_COLUMN lvc = {0};
  lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
  lvc.fmt = LVCFMT_LEFT;
  lvc.cx = OBJ_LIST_NAME_COL_WIDTH;
  lvc.pszText = (PWSTR)(PCWSTR)m_szColumnHeader;
  lvc.iSubItem = IDX_NAME_COL;

  ListView_InsertColumn(hList, IDX_NAME_COL, &lvc);

  CString szError;
  VERIFY(szError.LoadString(IDS_ERROR));

  lvc.cx = rect.right - OBJ_LIST_NAME_COL_WIDTH;
  lvc.pszText = (PWSTR)(PCWSTR)szError;
  lvc.iSubItem = IDX_ERR_COL;

  ListView_InsertColumn(hList, IDX_ERR_COL, &lvc);

  //
  // Insert the errors
  //
  ASSERT(m_pErrorArray != NULL && m_pNodeList != NULL);

  UINT nIdx = 0;
  POSITION pos = m_pNodeList->GetHeadPosition();
  while (pos != NULL)
  {
    CTreeNode* pNode = m_pNodeList->GetNext(pos);
    if (pNode != NULL)
    {
      if (nIdx < m_nErrorCount && m_pErrorArray[nIdx] != 0)
      {
        //
        // Create the list view item
        //
        LV_ITEM lvi = {0};
        lvi.mask = LVIF_TEXT | LVIF_PARAM;
        lvi.iSubItem = IDX_NAME_COL;

        lvi.lParam = (LPARAM)pNode->GetDisplayName();
        lvi.pszText = (PWSTR)pNode->GetDisplayName();
        lvi.iItem = nIdx;

        //
        // Insert the new item
        //
        int NewIndex = ListView_InsertItem(hList, &lvi);
        ASSERT(NewIndex != -1);
        if (NewIndex == -1)
        {
          continue;
        }

        //
        // Get the error message
        //
        CString szErrorMessage;
      	if (CDNSErrorInfo::GetErrorString(m_pErrorArray[nIdx],szErrorMessage))
	      {
          ListView_SetItemText(hList, NewIndex, IDX_ERR_COL, (PWSTR)(PCWSTR)szErrorMessage);
        }
      }
    }
  }
  return TRUE;
}



////////////////////////////////////////////////////////////////////////////
// CDNSMaskCtrl

// static alert function
int CDNSMaskCtrl::AlertFunc(HWND, DWORD dwCurrent, DWORD dwLow, DWORD dwHigh)
{
 	AFX_MANAGE_STATE(AfxGetStaticModuleState());
   CThemeContextActivator activator;
  CString szFormat;
	szFormat.LoadString(IDS_MASK_ALERT);

	CString s;
	s.Format((LPCWSTR)szFormat, dwCurrent, dwLow, dwHigh);
	AfxMessageBox(s);
	return 0;
}



BOOL CDNSMaskCtrl::IsBlank()
{
	return static_cast<BOOL>(SendMessage(DNS_MASK_CTRL_ISBLANK, 0, 0));
}

void CDNSMaskCtrl::SetFocusField(DWORD dwField)
{
	SendMessage(DNS_MASK_CTRL_SETFOCUS, dwField, 0);
}

void CDNSMaskCtrl::SetFieldRange(DWORD dwField, DWORD dwMin, DWORD dwMax)
{
	SendMessage(DNS_MASK_CTRL_SET_LOW_RANGE, dwField, dwMin);
	SendMessage(DNS_MASK_CTRL_SET_HI_RANGE, dwField, dwMax);
}

void CDNSMaskCtrl::SetArray(DWORD* pArray, UINT nFields)
{
	SendMessage(DNS_MASK_CTRL_SET, (WPARAM)pArray, (LPARAM)nFields);
}

void CDNSMaskCtrl::GetArray(DWORD* pArray, UINT nFields)
{
	SendMessage(DNS_MASK_CTRL_GET, (WPARAM)pArray, (LPARAM)nFields);
}

void CDNSMaskCtrl::Clear(int nField)
{
	SendMessage(DNS_MASK_CTRL_CLEAR, (WPARAM)nField, 0);
}

void CDNSMaskCtrl::SetAlertFunction( int (*lpfnAlert)(HWND, DWORD, DWORD, DWORD) )
{
	SendMessage(DNS_MASK_CTRL_SET_ALERT, (WPARAM)lpfnAlert, 0);
}

void CDNSMaskCtrl::EnableField(int nField, BOOL bEnable)
{
	SendMessage(DNS_MASK_CTRL_ENABLE_FIELD, (WPARAM)nField, (LPARAM)bEnable);
}

////////////////////////////////////////////////////////////////////////////
// CDNSIPv4Control



void CDNSIPv4Control::SetIPv4Val(DWORD x)
{
	DWORD dwArr[4];
	dwArr[3] = FIRST_IPADDRESS(x);
	dwArr[2] = SECOND_IPADDRESS(x);
	dwArr[1] = THIRD_IPADDRESS(x);
	dwArr[0] = FOURTH_IPADDRESS(x);
	SetArray(dwArr,4);
}

#define IP_FIELD_VALUE(x) ((x == FIELD_EMPTY) ? 0 : x)

void CDNSIPv4Control::GetIPv4Val(DWORD* pX)
{
	DWORD dwArr[4];
	GetArray(dwArr,4);
	// got an array of DWORDS, if a field has value FIELD_EMPTY,
	// need to assign a value of 0
	*pX = static_cast<DWORD>(MAKEIPADDRESS(IP_FIELD_VALUE(dwArr[3]),
						                             IP_FIELD_VALUE(dwArr[2]),
						                             IP_FIELD_VALUE(dwArr[1]),
						                             IP_FIELD_VALUE(dwArr[0])));
}

BOOL CDNSIPv4Control::IsEmpty()
{
	DWORD dwArr[4];
	GetArray(dwArr,4);
	return ((dwArr[0] == FIELD_EMPTY) && (dwArr[1] == FIELD_EMPTY) &&
			(dwArr[2] == FIELD_EMPTY) && (dwArr[3] == FIELD_EMPTY));
}

////////////////////////////////////////////////////////////////////////////
// CDNSIPv6Control

// REVIEW_MARCOC: need to do the same as the IPv4, with FIELD_EMPTY ==> zero

void CDNSIPv6Control::SetIPv6Val(IPV6_ADDRESS* pIpv6Address)
{
	// assume the format is a WORD[8] array
	DWORD dwArr[8]; // internal format, unpack
	for(int k=0; k<8; k++)
	{
		dwArr[k] = 0x0000FFFF & REVERSE_WORD_BYTES(pIpv6Address->IP6Word[k]);
	}

	SetArray(dwArr,8);
}

void CDNSIPv6Control::GetIPv6Val(IPV6_ADDRESS* pIpv6Address)
{
	// assume the format is a WORD[8] array
	DWORD dwArr[8]; // internal format
	GetArray(dwArr,8);
	// got an array of DWORDS, to move into WORD[8]
	// if a field has value FIELD_EMPTY, need to assign a value of 0
	for(int k=0; k<8; k++)
	{
		if (dwArr[k] == FIELD_EMPTY)
			pIpv6Address->IP6Word[k] = (WORD)0;
		else
		{
			ASSERT(HIWORD(dwArr[k]) == 0x0);
			pIpv6Address->IP6Word[k] = REVERSE_WORD_BYTES(LOWORD(dwArr[k]));
		}
	}
}


////////////////////////////////////////////////////////////////////////////
// CDNSTTLControl
void CDNSTTLControl::SetTTL(DWORD x)
{
	DWORD dwArr[4];
	// have to change from seconds into DDD:HH:MM:SS	
	DWORD dwMin = x/60;
	dwArr[3] = x - dwMin*60; // # of seconds left

	DWORD dwHours = dwMin/60;
	dwArr[2] = dwMin - dwHours*60; // # of minutes left

	DWORD dwDays = dwHours/24;
	dwArr[1] = dwHours - dwDays*24; // # of hours left

	dwArr[0] = dwDays; // # of days left

	SetArray(dwArr,4);
}

void CDNSTTLControl::GetTTL(DWORD* pX)
{
	// REVIEW_MARCOC: how do we deal with an empty field?
	// do we force zero on it? Should we do it in the UI when exiting a field?
	DWORD dwArr[4];
	GetArray(dwArr,4);
	// treat empty field as zero
	for(int j=0; j<4;j++)
		if (dwArr[j] == FIELD_EMPTY)
			dwArr[j] = 0;

	// have to convert back into seconds from DDD:HH:MM:SS
	*pX = dwArr[0]*3600*24		// days
			+  dwArr[1]*3600	// hours
			+ dwArr[2]*60		// minutes
			+ dwArr[3];			// seconds

	// the max value is FFFFFFFF, that is 49710 days, 6 hours, 28 minutes and 15 seconds
	// field validation allows to get to 49710 days, 23 hours, 59 minutes and 59 seconds
	// causing wraparound
	if (*pX < dwArr[0]*3600*24)  // wrapped around
		*pX = 0xFFFFFFFF; // max value
}


///////////////////////////////////////////////////////////////////////
// CDNSUnsignedIntEdit

BEGIN_MESSAGE_MAP(CDNSUnsignedIntEdit, CEdit)
	ON_CONTROL_REFLECT(EN_KILLFOCUS, OnKillFocus)
END_MESSAGE_MAP()



UINT _StrToUint(LPCTSTR sz)
{
   UINT result = 0;

   do 
   {
      PWSTR endptr = 0;
      errno = 0;
      unsigned long ul = wcstoul(sz, &endptr, 10);   // base 10 radix

      if (errno == ERANGE)
      {
         // overflow is the only possible range error for an unsigned type.
         
         result = 0;
         break;
      }
      
      if (sz == endptr)
      {
         // no valid characters found

         result = 0;
         break;
      }

      if (ul > UINT_MAX)
      {
         result = UINT_MAX;
         break;
      }

      result = (UINT) ul;
   }
   while (0);
   
	return result;
}

UINT _ForceToRange(UINT nVal, UINT nMin, UINT nMax)
{
	if (nVal < nMin)
		nVal = nMin;
	else if( nVal > nMax)
		nVal = nMax;
	return nVal;
}
BOOL CDNSUnsignedIntEdit::SetVal(UINT nVal)
{
	UINT n = _ForceToRange(nVal, m_nMin, m_nMax);

   // A UINT can never have more than 128 characters

   TCHAR szBuf[128] = {0};
	wsprintf(szBuf, _T("%u"), n);
	
   SetWindowText(szBuf);
	return (nVal == n);
}

UINT CDNSUnsignedIntEdit::GetVal()
{
   TCHAR szBuf[128] = {0};
   UINT result = 0;
   
   if (GetWindowText(szBuf,128) < 128)
   {
      result = _StrToUint(szBuf);
   }

   return result;
}

void CDNSUnsignedIntEdit::OnKillFocus()
{
	UINT nVal = GetVal();
	UINT n = _ForceToRange(nVal, m_nMin, m_nMax);
	if ( (n != nVal) || (nVal == (UINT)-1) )
		SetVal(n);
}


///////////////////////////////////////////////////////////////////////
// CDNSUpDownUnsignedIntEdit

BEGIN_MESSAGE_MAP(CDNSUpDownUnsignedIntEdit, CDNSUnsignedIntEdit)
	ON_CONTROL_REFLECT(EN_KILLFOCUS, OnKillFocus)
	ON_CONTROL_REFLECT(EN_CHANGE, OnChange)
END_MESSAGE_MAP()

void CDNSUpDownUnsignedIntEdit::OnKillFocus()
{
	CDNSUnsignedIntEdit::OnKillFocus();
	m_pEditGroup->SetButtonsState();
}

void CDNSUpDownUnsignedIntEdit::OnChange()
{
	m_pEditGroup->OnEditChange();
}

///////////////////////////////////////////////////////////////////////
// CDNSUpDownButton

BEGIN_MESSAGE_MAP(CDNSUpDownButton, CButton)
	ON_CONTROL_REFLECT(BN_CLICKED, OnClicked)
END_MESSAGE_MAP()

void CDNSUpDownButton::OnClicked()
{
	m_pEditGroup->OnClicked(m_bUp);
}


///////////////////////////////////////////////////////////////////////
// CDNSUpDownUnsignedIntEditGroup

void CDNSUpDownUnsignedIntEditGroup::SetVal(UINT nVal)
{
	m_edit.SetVal(nVal);
	SetButtonsState();
}

UINT CDNSUpDownUnsignedIntEditGroup::GetVal()
{
	return m_edit.GetVal();
}



void CDNSUpDownUnsignedIntEditGroup::OnClicked(BOOL bUp)
{
	UINT n = m_edit.GetVal();
	if (bUp)
	{
		m_edit.SetVal(++n);
	}
	else
	{
		m_edit.SetVal(--n);
	}
	SetButtonsState();
}



BOOL CDNSUpDownUnsignedIntEditGroup::Initialize(CWnd* pParentWnd, UINT nIDEdit,
				UINT nIDBtnUp, UINT nIDBtnDown)
{
	ASSERT(pParentWnd != NULL);
	if (pParentWnd == NULL)
		return FALSE;

	m_edit.Set(this);
	m_upBtn.Set(this,TRUE);
	m_downBtn.Set(this,FALSE);

	BOOL bRes = m_upBtn.SubclassDlgItem(nIDBtnUp, pParentWnd);
	ASSERT(bRes);
	bRes = m_downBtn.SubclassDlgItem(nIDBtnDown, pParentWnd);
	ASSERT(bRes);
	if (!bRes) return FALSE;
	bRes = m_edit.SubclassDlgItem(nIDEdit, pParentWnd);
	ASSERT(bRes);

	// the longest UINT is 10 digits
	
	m_edit.LimitText(10);
	   


	return bRes;
}

void CDNSUpDownUnsignedIntEditGroup::SetButtonsState()
{
   // NTRAID#NTBUG9-471611-2001/10/05-sburns
}


/////////////////////////////////////////////////////////////////////////
// CDNSTimeIntervalEdit

BEGIN_MESSAGE_MAP(CDNSTimeIntervalEdit, CDNSUnsignedIntEdit)
	ON_CONTROL_REFLECT(EN_KILLFOCUS, OnKillFocus)
	ON_CONTROL_REFLECT(EN_CHANGE, OnChange)
END_MESSAGE_MAP()

void CDNSTimeIntervalEdit::OnKillFocus()
{
  m_pEditGroup->OnEditKillFocus();
}

void CDNSTimeIntervalEdit::OnChange()
{
	m_pEditGroup->OnEditChange();
}

/////////////////////////////////////////////////////////////////////////
// CDNSTimeUnitComboBox

BEGIN_MESSAGE_MAP(CDNSTimeUnitComboBox, CComboBox)
	ON_CONTROL_REFLECT(CBN_SELCHANGE, OnSelChange)
END_MESSAGE_MAP()

void CDNSTimeUnitComboBox::OnSelChange()
{
	m_pEditGroup->OnComboSelChange();
}

void CDNSTimeUnitComboBox::SetUnit(unitType u)
{
	ASSERT((u >= sec) || (u <= days));
  if (GetCount() - 1 < u)
    SetCurSel(u - 2);
  else
	  SetCurSel(u);
}

CDNSTimeUnitComboBox::unitType CDNSTimeUnitComboBox::GetUnit()
{
	int n = GetCurSel();
	unitType u = (unitType)n;
	ASSERT((u >= sec) || (u <= days));
	return u;
}

BOOL CDNSTimeUnitComboBox::LoadStrings(UINT nIDUnitsString, UINT nMaxAddCount)
{
	return LoadStringsToComboBox(_Module.GetModuleInstance(),
								this, nIDUnitsString, 256, nMaxAddCount);
}

//////////////////////////////////////////////////////////////////////////
// CDNSTimeIntervalEditGroup

CDNSTimeIntervalEditGroup::CDNSTimeIntervalEditGroup(UINT nMinVal, UINT nMaxVal)
{
	m_nMinVal = nMinVal;
	m_nMaxVal = nMaxVal;
	InitRangeInfo();
}

void CDNSTimeIntervalEditGroup::InitRangeInfo()
{
	static UINT _secondsCount[4] =
			{ 1, 60, 3600, 3600*24 }; // # of secods in a sec, min, hour, day
	for (UINT k=0; k<4; k++)
	{
		if (m_nMinVal == 0)
		{
			m_rangeInfoArr[k].m_nMinVal = 0;
		}
		else
		{
			m_rangeInfoArr[k].m_nMinVal = m_nMinVal/_secondsCount[k];
			if (k > 0)
				m_rangeInfoArr[k].m_nMinVal++;
		}
		m_rangeInfoArr[k].m_nMaxVal = m_nMaxVal/_secondsCount[k];
		if (m_rangeInfoArr[k].m_nMaxVal >= m_rangeInfoArr[k].m_nMinVal)
			m_nRangeCount = k + 1;
	}
}


BOOL CDNSTimeIntervalEditGroup::Initialize(CWnd* pParentWnd, UINT nIDEdit,
				UINT nIDCombo, UINT nIDComboUnitsString)
{
	ASSERT(pParentWnd != NULL);
	if (pParentWnd == NULL)
		return FALSE;

	m_edit.Set(this);
	m_timeUnitCombo.Set(this);

	BOOL bRes = m_edit.SubclassDlgItem(nIDEdit, pParentWnd);
	ASSERT(bRes);
	if (!bRes) return FALSE;
	bRes = m_timeUnitCombo.SubclassDlgItem(nIDCombo, pParentWnd);
	ASSERT(bRes);
	if (!bRes) return FALSE;
	bRes = m_timeUnitCombo.LoadStrings(nIDComboUnitsString, m_nRangeCount);
	return bRes;
}

void CDNSTimeIntervalEditGroup::SetVal(UINT nVal)
{
	// set default values
	nVal = _ForceToRange(nVal, m_nMinVal, m_nMaxVal);
	UINT nMax = (UINT)-1;
	CDNSTimeUnitComboBox::unitType u = CDNSTimeUnitComboBox::sec;

	// select the best unit of measurement (i.e. no truncation)
	if ((nVal/60)*60 == nVal)
	{
		// can promote to minutes
		u = CDNSTimeUnitComboBox::min;
		nMax = nMax/60;
		nVal = nVal/60;
		if ((nVal/60)*60 == nVal)
		{
			// can promote to hours
			u = CDNSTimeUnitComboBox::hrs;
			nMax = nMax/60;
			nVal = nVal/60;
			if ((nVal/24)*24 == nVal)
			{
				// can promote to days
				u = CDNSTimeUnitComboBox::days;
				nMax = nMax/24;
				nVal = nVal/24;
			}
		}
	}

	m_timeUnitCombo.SetUnit(u);
	m_edit.SetRange(0,nMax);
	m_edit.SetVal(nVal);
}


UINT CDNSTimeIntervalEditGroup::GetVal()
{
	UINT nVal = m_edit.GetVal();
	CDNSTimeUnitComboBox::unitType  u = m_timeUnitCombo.GetUnit();

  //
	// the value must always to be in seconds
  //
	if (u != CDNSTimeUnitComboBox::sec)
	{
		switch(u)
		{
		case CDNSTimeUnitComboBox::min:
			nVal *= 60;
			break;
		case CDNSTimeUnitComboBox::hrs:
			nVal *= 3600;
			break;
		case CDNSTimeUnitComboBox::days:
			nVal *= (3600*24);
			break;
		default:
			ASSERT(FALSE);
		}
	}

  if (nVal < m_nMinVal ||
      nVal > m_nMaxVal)
  {
   	UINT nRangeVal = _ForceToRange(nVal, m_nMinVal, m_nMaxVal);
    SetVal(nRangeVal);
    nVal = nRangeVal;
  }

  ASSERT(nVal >= m_nMinVal && nVal <= m_nMaxVal);
	return nVal;
}

void CDNSTimeIntervalEditGroup::OnEditKillFocus()
{
	UINT nVal = m_edit.GetVal();
	CDNSTimeUnitComboBox::unitType  u = m_timeUnitCombo.GetUnit();

  //
	// the value must always to be in seconds
  //
	if (u != CDNSTimeUnitComboBox::sec)
	{
		switch(u)
		{
		case CDNSTimeUnitComboBox::min:
			nVal *= 60;
			break;
		case CDNSTimeUnitComboBox::hrs:
			nVal *= 3600;
			break;
		case CDNSTimeUnitComboBox::days:
			nVal *= (3600*24);
			break;
		default:
			ASSERT(FALSE);
		}
	}
	UINT nRangeVal = _ForceToRange(nVal, m_nMinVal, m_nMaxVal);
  if (nRangeVal != nVal)
  {
    SetVal(nRangeVal);
  }
}

void CDNSTimeIntervalEditGroup::OnComboSelChange()
{
	CDNSTimeUnitComboBox::unitType  u = m_timeUnitCombo.GetUnit();
	// have to adjust the range
	UINT nVal = m_edit.GetVal();
	UINT nMax = (UINT)-1;

	// have to adjust the range
	switch(u)
	{
	case CDNSTimeUnitComboBox::sec:
		break;
	case CDNSTimeUnitComboBox::min:
		nMax /= 60;
		break;
	case CDNSTimeUnitComboBox::hrs:
		nMax /= 3600;
		break;
	case CDNSTimeUnitComboBox::days:
		nMax /= (3600*24);
		break;
	default:
		ASSERT(FALSE);
	}
	//m_edit.SetRange(0,nMax);
	UINT k = (UINT)u;
	m_edit.SetRange(m_rangeInfoArr[k].m_nMinVal, m_rangeInfoArr[k].m_nMaxVal);
	nVal = _ForceToRange(nVal, m_rangeInfoArr[k].m_nMinVal, m_rangeInfoArr[k].m_nMaxVal);
	m_edit.SetVal(nVal);
	OnEditChange();
}

void CDNSTimeIntervalEditGroup::EnableUI(BOOL bEnable)
{
	m_edit.EnableWindow(bEnable);
	m_timeUnitCombo.EnableWindow(bEnable);
}

//////////////////////////////////////////////////////////////////////////
// CDNSManageControlTextHelper

CDNSManageControlTextHelper::CDNSManageControlTextHelper(int nStates)
{
	m_nID = 0;
	m_pParentWnd = NULL;
	ASSERT(nStates > 1);
	m_nStates = nStates;
	m_lpszText = NULL;
	m_lpszArr = (LPWSTR*)malloc(sizeof(LPWSTR*)*m_nStates);
  if (m_lpszArr != NULL)
  {
	  memset(m_lpszArr, 0x0, sizeof(LPWSTR*)*m_nStates);
  }
}

CDNSManageControlTextHelper::~CDNSManageControlTextHelper()
{
	free(m_lpszArr);
	if (m_lpszText != NULL)
		free(m_lpszText);
}

BOOL CDNSManageControlTextHelper::Init(CWnd* pParentWnd, UINT nID, UINT* nStrArray)
{
	ASSERT(m_pParentWnd == NULL);
	ASSERT(pParentWnd != NULL);
	m_pParentWnd = pParentWnd;
	m_nID = nID;

	CWnd* pWnd = m_pParentWnd->GetDlgItem(m_nID);
	if (pWnd == NULL)
		return FALSE;

	// get the text out of the window
	int nLen = pWnd->GetWindowTextLength();
	ASSERT(m_lpszText == NULL);
	m_lpszText = (WCHAR*)malloc(sizeof(WCHAR)*(nLen+1));
  if (m_lpszText != NULL)
  {
	  pWnd->GetWindowText(m_lpszText, nLen+1);
  }
  else
  {
    return FALSE;
  }
	ASSERT(m_lpszText != NULL);

  //
	// get the text for the window
  //
	int nSuccessEntries;
	LoadStringArrayFromResource(m_lpszArr, nStrArray, m_nStates, &nSuccessEntries);
	ASSERT(nSuccessEntries == m_nStates);

	return TRUE;
}

BOOL CDNSManageControlTextHelper::Init(CWnd* pParentWnd, UINT nID)
{
	ASSERT(m_pParentWnd == NULL);
	ASSERT(pParentWnd != NULL);
	m_pParentWnd = pParentWnd;
	m_nID = nID;

	CWnd* pWnd = m_pParentWnd->GetDlgItem(m_nID);
	if (pWnd == NULL)
		return FALSE;

  //
	// get the text out of the window
  //
	int nLen = pWnd->GetWindowTextLength();
	ASSERT(m_lpszText == NULL);
	m_lpszText = (WCHAR*)malloc(sizeof(WCHAR)*(nLen+1));
  if (m_lpszText != NULL)
  {
	  pWnd->GetWindowText(m_lpszText, nLen+1);
  }
  else
  {
    return FALSE;
  }
	ASSERT(m_lpszText != NULL);

  //
	// get the text for the window
  //
	UINT nSuccessEntries;
	ParseNewLineSeparatedString(m_lpszText, m_lpszArr, &nSuccessEntries);
	ASSERT(nSuccessEntries == (UINT)m_nStates);

	return TRUE;
}

void CDNSManageControlTextHelper::SetStateX(int nIndex)
{
	CWnd* pWnd = m_pParentWnd->GetDlgItem(m_nID);
	ASSERT(pWnd != NULL);
	ASSERT( (nIndex >0) || (nIndex < m_nStates));
	pWnd->SetWindowText(m_lpszArr[nIndex]);
}


//////////////////////////////////////////////////////////////////////////
// CDNSToggleTextControlHelper

CDNSToggleTextControlHelper::CDNSToggleTextControlHelper()
		: CDNSManageControlTextHelper(2)
{
}


///////////////////////////////////////////////////////////////////////////
// CDNSManageButtonTextHelper

CDNSManageButtonTextHelper::CDNSManageButtonTextHelper(int nStates) 
{
	m_nID = 0;
	m_pParentWnd = NULL;
	m_nStates = nStates;
	m_lpszText = NULL;
	m_lpszArr = (LPWSTR*)malloc(sizeof(LPWSTR*)*m_nStates);

  if (m_lpszArr != NULL)
  {
	  memset(m_lpszArr, 0x0, sizeof(LPWSTR*)*m_nStates);
  }
}

CDNSManageButtonTextHelper::~CDNSManageButtonTextHelper()
{
	for (int k = 0; k < m_nStates; k++)
	{
		if (m_lpszArr[k] != NULL)
			free(m_lpszArr[k]);
	}

	free(m_lpszArr);
}

void CDNSManageButtonTextHelper::SetStateX(int nIndex)
{
	CWnd* pWnd = m_pParentWnd->GetDlgItem(m_nID);
	ASSERT(pWnd != NULL);
	ASSERT( (nIndex >0) || (nIndex < m_nStates));
	pWnd->SetWindowText(m_lpszArr[nIndex]);
}

BOOL CDNSManageButtonTextHelper::Init(CWnd* pParentWnd, UINT nButtonID, UINT* nStrArray)
{
	ASSERT(m_pParentWnd == NULL);
	ASSERT(pParentWnd != NULL);
	m_pParentWnd = pParentWnd;
	m_nID = nButtonID;

	CWnd* pWnd = m_pParentWnd->GetDlgItem(m_nID);
	if (pWnd == NULL)
		return FALSE;

	// get the text for the window
	int nSuccessEntries;
	LoadStringArrayFromResource(m_lpszArr, nStrArray, m_nStates, &nSuccessEntries);
	ASSERT(nSuccessEntries == m_nStates);

	return TRUE;
}


///////////////////////////////////////////////////////////////////////////
// CDNSButtonToggleTextHelper

CDNSButtonToggleTextHelper::CDNSButtonToggleTextHelper()
		: CDNSManageButtonTextHelper(2)
{
}

/////////////////////////////////////////////////////////////////////////////
// CDlgWorkerThread

CDlgWorkerThread::CDlgWorkerThread()
{
	m_dwErr = 0x0;
}


BOOL CDlgWorkerThread::Start(CLongOperationDialog* pDlg)
{
	ASSERT(pDlg != NULL);
	HWND hWnd = pDlg->GetSafeHwnd();
	return CWorkerThread::Start(hWnd);
}

BOOL CDlgWorkerThread::PostMessageToDlg()
{
	return PostMessageToWnd(CLongOperationDialog::s_nNotificationMessage,
							(WPARAM)0, (LPARAM)0);
}


int CDlgWorkerThread::Run()
{
	// do the stuff
	OnDoAction();
	VERIFY(PostMessageToDlg());
	WaitForExitAcknowledge();
	//TRACE(_T("exiting\n"));
	return 0;

}


/////////////////////////////////////////////////////////////////////////////
// CLongOperationDialog dialog

UINT CLongOperationDialog::s_nNotificationMessage = WM_USER + 100;

CLongOperationDialog::CLongOperationDialog(CDlgWorkerThread* pThreadObj,
                      CWnd* pParentWnd,
										   UINT nAviID)
	: CDialog(IDD_SEARCHING_DIALOG, pParentWnd)
{
	ASSERT(pThreadObj != NULL);
	m_bAbandoned = TRUE;
	m_pThreadObj = pThreadObj;
	m_nAviID = nAviID;
  m_bExecuteNoUI = FALSE;
}

CLongOperationDialog::~CLongOperationDialog()
{
	if(m_pThreadObj != NULL)
	{
		delete m_pThreadObj;
		m_pThreadObj = NULL;
	}
}

BOOL CLongOperationDialog::LoadTitleString(UINT nID)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return m_szTitle.LoadString(nID);
}

BEGIN_MESSAGE_MAP(CLongOperationDialog, CDialog)
	ON_MESSAGE( CLongOperationDialog::s_nNotificationMessage, OnNotificationMessage )
END_MESSAGE_MAP()


afx_msg LONG CLongOperationDialog::OnNotificationMessage( WPARAM, LPARAM)
{
	TRACE(_T("CLongOperationDialog::OnNotificationMessage()\n"));

	ASSERT(m_pThreadObj != NULL);
	if (m_pThreadObj != NULL)
	{
		m_pThreadObj->AcknowledgeExiting();
		VERIFY(WAIT_OBJECT_0 == ::WaitForSingleObject(m_pThreadObj->m_hThread,INFINITE));
		m_bAbandoned = FALSE;
		PostMessage(WM_CLOSE,0,0);
	}
	return 0;
}

BOOL CLongOperationDialog::OnInitDialog()
{
	TRACE(_T("CLongOperationDialog::OnInitDialog()\n"));

	CDialog::OnInitDialog();
	
	if (!m_szTitle.IsEmpty())
		SetWindowText(m_szTitle);

	// load auto play AVI file if needed
	if (m_nAviID != -1)
	{
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
		CAnimateCtrl* pAnimate = (CAnimateCtrl*)GetDlgItem(IDC_SEARCH_ANIMATE);
		VERIFY(pAnimate->Open(m_nAviID));
	}
	
	// spawn worker thread
	GetThreadObj()->Start(this);
	
	return TRUE;
}

void CLongOperationDialog::OnCancel()
{
	TRACE(_T("CLongOperationDialog::OnCancel()\n"));
	if (m_bAbandoned)
	{
		m_pThreadObj->Abandon();
		m_pThreadObj = NULL;
	}
	CDialog::OnCancel();
}


//////////////////////////////////////////////////////////
// CNodeEnumerationThread

CNodeEnumerationThread::CNodeEnumerationThread(CComponentDataObject* pComponentDataObject,
							CMTContainerNode* pNode)
{
	m_pSink = new CNotificationSinkEvent;
	ASSERT(m_pSink != NULL);

	m_pNode = pNode;
	m_pComponentDataObject = pComponentDataObject;
	m_pComponentDataObject->GetNotificationSinkTable()->Advise(m_pSink);
}

CNodeEnumerationThread::~CNodeEnumerationThread()
{
	if (m_pComponentDataObject != NULL)
		m_pComponentDataObject->GetNotificationSinkTable()->Unadvise(m_pSink);
	delete m_pSink;
}

void CNodeEnumerationThread::OnDoAction()
{
	TRACE(_T("CNodeEnumerationThread::OnDoAction() before Wait\n"));
	ASSERT(m_pSink != NULL);

	VERIFY(m_pComponentDataObject->PostForceEnumeration(m_pNode));
	m_pSink->Wait();
	TRACE(_T("CNodeEnumerationThread::OnDoAction() after Wait\n"));
}

void CNodeEnumerationThread::OnAbandon()
{
	ASSERT(m_pComponentDataObject != NULL);
	m_pComponentDataObject->GetNotificationSinkTable()->Unadvise(m_pSink);
	m_pComponentDataObject = NULL;
}


//////////////////////////////////////////////////////////
// CArrayCheckListBox

BOOL CArrayCheckListBox::Initialize(UINT nCtrlID, UINT nStringID, CWnd* pParentWnd)
{
	if (!SubclassDlgItem(nCtrlID, pParentWnd))
		return FALSE;
	SetCheckStyle(BS_AUTOCHECKBOX);
	CString szBuf;
	{
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
		if (!szBuf.LoadString(nStringID))
			return FALSE;
	}
	LPWSTR* lpszArr = (LPWSTR*)malloc(sizeof(LPWSTR*)*m_nArrSize);
  if (!lpszArr)
  {
    return FALSE;
  }

	UINT nArrEntries;
	ParseNewLineSeparatedString(szBuf.GetBuffer(1),lpszArr, &nArrEntries);
	szBuf.ReleaseBuffer();
	ASSERT(nArrEntries == m_nArrSize);
	for (UINT k=0; k<nArrEntries; k++)
		AddString(lpszArr[k]);

  if (lpszArr)
  {
    free(lpszArr);
    lpszArr = 0;
  }
	return TRUE;
}

void CArrayCheckListBox::SetValue(DWORD dw)
{
	for (UINT i=0; i< m_nArrSize; i++)
		SetCheck(i, (dw & m_dwMaskArr[i]) != 0);
}

DWORD CArrayCheckListBox::GetValue()
{
	DWORD dw = 0;
	for (UINT i=0; i< m_nArrSize; i++)
		dw |= GetCheck(i) ? m_dwMaskArr[i] : 0;
	return dw;
}

void CArrayCheckListBox::SetArrValue(DWORD* dwArr, UINT nArrSize)
{
	ASSERT(nArrSize <= m_nArrSize);
	for (UINT i=0; i< nArrSize; i++)
		SetCheck(i, dwArr[i] != 0);
}

void CArrayCheckListBox::GetArrValue(DWORD* dwArr, UINT nArrSize)
{
	ASSERT(nArrSize <= m_nArrSize);
	for (UINT i=0; i< m_nArrSize; i++)
		dwArr[i] = GetCheck(i) != 0;
}

/*
//////////////////////////////////////////////////////////
// CDNSNameEditField

void CDNSNameEditField::SetReadOnly(BOOL bReadOnly)
{
  // toggle the tabstop flag
  LONG currStyle = ::GetWindowLong(m_edit.m_hWnd, GWL_STYLE);
  LONG newStyle = currStyle;
  if (bReadOnly)
    newStyle &= ~WS_TABSTOP;
  else
    newStyle |= WS_TABSTOP;
  if (newStyle != currStyle) {
    ::SetWindowLong(m_edit.m_hWnd, GWL_STYLE, newStyle);
  }

  // toggle the read only state
  m_edit.SetReadOnly(bReadOnly);
}


//////////////////////////////////////////////////////////
// CDNSNameEditField::CDNSNameEditBox


BEGIN_MESSAGE_MAP(CDNSNameEditField::CDNSNameEditBox, CEdit)
  ON_CONTROL_REFLECT(EN_UPDATE, CDNSNameEditField::CDNSNameEditBox::OnUpdate)
END_MESSAGE_MAP()

void CDNSNameEditField::CDNSNameEditBox::OnUpdate()
{
  if (m_bUpdatePending)
    return; // avoid infinite loop

  GetWindowText(m_szScratchBuffer);
  TRACE(_T("OnUpdate() Text = <%s>\n"), (LPCWSTR)m_szScratchBuffer);

  DNS_STATUS errName = 0;
  int nScratchBufferLen = m_szScratchBuffer.GetLength();
  int nScratchBufferUTF8Len = UTF8StringLen(m_szScratchBuffer);

  // validate max length
  if ((m_nTextLimit >= 0) && (nScratchBufferUTF8Len > m_nTextLimit))
  {
    errName = -1;
  }

  // validate no dots
  if ((errName == 0) && (m_dwFlags & DNS_NAME_EDIT_FIELD_NODOTS))
  {
    errName = m_szScratchBuffer.Find(L'.') != -1;
  }

  if ((errName == 0) && ((m_dwFlags & DNS_NAME_EDIT_FIELD_NOVALIDATE) == 0))
  {
    errName = Validate(nScratchBufferLen);
  }

  if (errName != 0)
  {
    // bad stuff
    m_bUpdatePending = TRUE;
    int nStartChar, nEndChar;
    GetSel(nStartChar,nEndChar);
    SetWindowText(m_szCurrText);
    SetSel(nStartChar-1,nEndChar-1);
    m_bUpdatePending = FALSE;
  }
  else
  {
    // good stuff
    m_szCurrText = m_szScratchBuffer;
    m_nCurrTextLen = nScratchBufferLen;
    m_nCurrUTF8TextLen = nScratchBufferUTF8Len;
  }

}

DNS_STATUS CDNSNameEditField::CDNSNameEditBox::Validate(int nScratchBufferLen)
{
  DNS_STATUS errName = 0;

  if ((errName == 0) && (nScratchBufferLen > 0))
  {
    // check for wildcards records
    int nFirstAsterisk = m_szScratchBuffer.Find(L'*');
    if (m_dwFlags & DNS_NAME_EDIT_FIELD_NOWILDCARDS)
    {
      // wildcards not accepted
      errName = (nFirstAsterisk != -1);
    }
    else
    {
      if (nFirstAsterisk >= 0) // found at least one
      {
        // string must be "*"
        errName = !((nScratchBufferLen == 1) && (nFirstAsterisk == 0));
      }
    }

    // validate name against RFC
    LPCWSTR lpszName = (LPCWSTR)m_szScratchBuffer;
    if ( (errName == 0) && (m_dwFlags & (DNS_NAME_EDIT_FIELD_NORFC | DNS_NAME_EDIT_FIELD_RFC)) )
    {
      errName = ::DnsValidateName_W(lpszName, DnsNameDomain);
      TRACE(_T("::DnsValidateName_W(%ws) return %d.\n"), lpszName, errName);
      if ((m_dwFlags & DNS_NAME_EDIT_FIELD_NORFC) && (errName == DNS_ERROR_NON_RFC_NAME))
      {
        // we relax RFC compliance
        errName = 0;
      }
      else if ( (m_dwFlags & DNS_NAME_EDIT_FIELD_ALLOWNUMBERS) )
      {
        // Assume the name failed because it is all digits
        BOOL bAllDigits = TRUE;
        LPWSTR lpszBuf = (LPWSTR)(LPCWSTR)m_szScratchBuffer;
        for (int idx = 0; idx < nScratchBufferLen; idx++)
        {
          if (!iswdigit(lpszBuf[idx]))
          {
            // If we run across something that isn't a digit then thats not why we failed.
            bAllDigits = FALSE;
            TRACE(_T("Not all the characters are digits but something is still wrong.\n"));
          }
        }
        if (bAllDigits)
        {
          errName = 0;
        }
      }
    }
  }
  TRACE(_T("CDNSNameEditField::CDNSNameEditBox::Validate returns %d.\n"), errName);
  return errName;
}
*/
////////////////////////////////////////////////////////////////////////////
// CDNSZone_AgingDialog

BEGIN_MESSAGE_MAP(CDNSZone_AgingDialog, CHelpDialog)
  ON_BN_CLICKED(IDC_SCAVENGING_ENABLED, OnCheckScavenge)
END_MESSAGE_MAP()

CDNSZone_AgingDialog::CDNSZone_AgingDialog(CPropertyPageHolderBase* pHolder, UINT nID, CComponentDataObject* pComponentData) 
      : CHelpDialog(nID, pComponentData)
{
  m_pHolder = pHolder;
  m_bDirty = FALSE;
  m_bAdvancedView = FALSE;
  m_bScavengeDirty = FALSE;
  m_bNoRefreshDirty = FALSE;
  m_bRefreshDirty = FALSE;
//  m_bApplyAll = FALSE;
  m_bADApplyAll = FALSE;
//  m_bStandardApplyAll = FALSE;
  m_dwDefaultRefreshInterval = 0;
  m_dwDefaultNoRefreshInterval = 0;
  m_bDefaultScavengingState = FALSE;

  if (pComponentData != NULL)
  {
    m_pComponentData = pComponentData;
  }
  else
  {
    m_pComponentData = pHolder->GetComponentData();
  }
}

BOOL CDNSZone_AgingDialog::OnInitDialog()
{
  CHelpDialog::OnInitDialog();
  if (m_pHolder != NULL)
    m_pHolder->PushDialogHWnd(GetSafeHwnd());

  m_refreshIntervalEditGroup.m_pPage = this;
  m_norefreshIntervalEditGroup.m_pPage = this;

	VERIFY(m_refreshIntervalEditGroup.Initialize(this, 
				IDC_REFR_INT_EDIT1, IDC_REFR_INT_COMBO1,IDS_TIME_AGING_INTERVAL_UNITS));
	VERIFY(m_norefreshIntervalEditGroup.Initialize(this, 
				IDC_REFR_INT_EDIT2, IDC_REFR_INT_COMBO2,IDS_TIME_AGING_INTERVAL_UNITS));
  
  SendDlgItemMessage(IDC_REFR_INT_EDIT1, EM_SETLIMITTEXT, (WPARAM)10, 0);
  SendDlgItemMessage(IDC_REFR_INT_EDIT2, EM_SETLIMITTEXT, (WPARAM)10, 0);

  SetUIData();
  return TRUE;
}

void CDNSZone_AgingDialog::SetUIData()
{
  m_refreshIntervalEditGroup.SetVal(m_dwRefreshInterval);
  m_norefreshIntervalEditGroup.SetVal(m_dwNoRefreshInterval);

  ((CButton*)GetDlgItem(IDC_SCAVENGING_ENABLED))->SetCheck(m_fScavengingEnabled);

  // Enable the time stamp if we are in advanced view and got here through the zone property pages
  if (m_bAdvancedView && m_pHolder != NULL)
  {
    GetDlgItem(IDC_TIME_STAMP_STATIC1)->EnableWindow(TRUE);
	  GetDlgItem(IDC_TIME_STAMP_STATIC2)->EnableWindow(TRUE);
    GetDlgItem(IDC_TIME_STAMP)->EnableWindow(TRUE);
    GetDlgItem(IDC_TIME_STAMP_STATIC1)->ShowWindow(TRUE);
	  GetDlgItem(IDC_TIME_STAMP_STATIC2)->ShowWindow(TRUE);
    GetDlgItem(IDC_TIME_STAMP)->ShowWindow(TRUE);

    CString cstrDate;
    GetTimeStampString(cstrDate);
    GetDlgItem(IDC_TIME_STAMP)->SetWindowText(cstrDate);
  }
  else if (!m_bAdvancedView && m_pHolder != NULL)
  {
    GetDlgItem(IDC_TIME_STAMP_STATIC1)->EnableWindow(FALSE);
    GetDlgItem(IDC_TIME_STAMP_STATIC2)->EnableWindow(FALSE);
    GetDlgItem(IDC_TIME_STAMP)->EnableWindow(FALSE);
    GetDlgItem(IDC_TIME_STAMP_STATIC1)->ShowWindow(FALSE);
    GetDlgItem(IDC_TIME_STAMP_STATIC2)->ShowWindow(FALSE);
    GetDlgItem(IDC_TIME_STAMP)->ShowWindow(FALSE);
    ((CButton*)GetDlgItem(IDC_SCAVENGING_ENABLED))->SetCheck(m_fScavengingEnabled);
  }

}

void CDNSZone_AgingDialog::OnCheckScavenge()
{
  m_bScavengeDirty = TRUE;
  GetDlgItem(IDOK)->EnableWindow(TRUE);
}

void CDNSZone_AgingDialog::SetDirty()
{ 
  m_bDirty = TRUE; 
  GetDlgItem(IDOK)->EnableWindow(TRUE);
}

void CDNSZone_AgingDialog::GetTimeStampString(CString& strref)
{
  SYSTEMTIME sysUTimeStamp, sysLTimeStamp;
  VERIFY(SUCCEEDED(Dns_SystemHrToSystemTime(m_dwScavengingStart, &sysUTimeStamp)));

  if (!::SystemTimeToTzSpecificLocalTime(NULL, &sysUTimeStamp, &sysLTimeStamp))
    return;

  // Format the string with respect to locale
  PTSTR ptszDate = NULL;
  int cchDate = 0;
  cchDate = GetDateFormat(LOCALE_USER_DEFAULT, 0 , 
                          &sysLTimeStamp, NULL, 
                          ptszDate, 0);
  ptszDate = (PTSTR)malloc(sizeof(TCHAR) * cchDate);
  if (ptszDate == NULL)
  {
    strref = L"";
    return;
  }

  if (GetDateFormat(LOCALE_USER_DEFAULT, 0, 
                  &sysLTimeStamp, NULL, 
                  ptszDate, cchDate))
  {
  	strref = ptszDate;
  }
  else
  {
    strref = L"";
  }
  free(ptszDate);

  PTSTR ptszTime = NULL;

  cchDate = GetTimeFormat(LOCALE_USER_DEFAULT, 0 , 
                          &sysLTimeStamp, NULL, 
                          ptszTime, 0);
  ptszTime = (PTSTR)malloc(sizeof(TCHAR) * cchDate);
  if (!ptszTime)
  {
     return;
  }

  if (GetTimeFormat(LOCALE_USER_DEFAULT, 0, 
                  &sysLTimeStamp, NULL, 
                  ptszTime, cchDate))
  {
    strref += _T(" ") + CString(ptszTime);
  }
  else
  {
    strref += _T("");
  }
  free(ptszTime);
}


void CDNSZone_AgingDialog::OnOK()
{
  CThemeContextActivator activator;

  if (m_pHolder != NULL)
		m_pHolder->PopDialogHWnd();

  if (m_pHolder == NULL)
  {
    if (0 != m_refreshIntervalEditGroup.GetVal())
    {
      if (m_dwRefreshInterval != m_refreshIntervalEditGroup.GetVal())
      {
        m_dwRefreshInterval = m_refreshIntervalEditGroup.GetVal();
        m_bRefreshDirty = TRUE;
      }
      else
      {
        m_bRefreshDirty = FALSE;
      }
    }
    else
    {
      DNSMessageBox(IDS_MSG_INVALID_REFRESH_INTERVAL);
      return;
    }

    if (0 != m_norefreshIntervalEditGroup.GetVal())
    {
      if (m_dwNoRefreshInterval != m_norefreshIntervalEditGroup.GetVal())
      {
        m_dwNoRefreshInterval = m_norefreshIntervalEditGroup.GetVal();
        m_bNoRefreshDirty = TRUE;
      }
      else
      {
        m_bNoRefreshDirty = FALSE;
      }
    }
    else
    {
      DNSMessageBox(IDS_MSG_INVALID_NOREFRESH_INTERVAL);
      return;
    }

    if (m_fScavengingEnabled != static_cast<DWORD>(((CButton*)GetDlgItem(IDC_SCAVENGING_ENABLED))->GetCheck()))
    {
      m_fScavengingEnabled = ((CButton*)GetDlgItem(IDC_SCAVENGING_ENABLED))->GetCheck();
      m_bScavengeDirty = TRUE;
    }
    else
    {
      m_bScavengeDirty = FALSE;
    }

    CDNSServer_AgingConfirm dlg(this);
    if (IDOK == dlg.DoModal())
    {
      CHelpDialog::OnOK();
    }
    else
    {
      m_bRefreshDirty = FALSE;
      m_bNoRefreshDirty = FALSE;
      m_bScavengeDirty = FALSE;

      m_dwRefreshInterval = m_dwDefaultRefreshInterval;
      m_dwNoRefreshInterval = m_dwDefaultNoRefreshInterval;
      m_fScavengingEnabled = m_bDefaultScavengingState;

      SetUIData();
    }      
  }
  else
  {
    BOOL bContinue = TRUE;
    if (!((CDNSZoneNode*)m_pHolder->GetTreeNode())->IsDSIntegrated() && 
        ((CButton*)GetDlgItem(IDC_SCAVENGING_ENABLED))->GetCheck() &&
        !m_fScavengingEnabled)
    {
      if (DNSMessageBox(IDS_MSG_FILE_WARNING_ZONE, MB_YESNO) == IDNO)
      {
        bContinue = FALSE;
      }
    }
    if (bContinue)
    {

      if (0 != m_refreshIntervalEditGroup.GetVal())
      {
        if (m_dwRefreshInterval != m_refreshIntervalEditGroup.GetVal())
        {
          m_dwRefreshInterval = m_refreshIntervalEditGroup.GetVal();
          m_bRefreshDirty = TRUE;
        }
        else
        {
          m_bRefreshDirty = FALSE;
        }
      }
      else
      {
        DNSMessageBox(IDS_MSG_INVALID_REFRESH_INTERVAL);
        return;
      }

      if (0 != m_norefreshIntervalEditGroup.GetVal())
      {
        if (m_dwNoRefreshInterval != m_norefreshIntervalEditGroup.GetVal())
        {
          m_dwNoRefreshInterval = m_norefreshIntervalEditGroup.GetVal();
          m_bNoRefreshDirty = TRUE;
        }
        else
        {
          m_bNoRefreshDirty = FALSE;
        }
      }
      else
      {
        DNSMessageBox(IDS_MSG_INVALID_NOREFRESH_INTERVAL);
        return;
      }

      if (m_fScavengingEnabled != static_cast<DWORD>(((CButton*)GetDlgItem(IDC_SCAVENGING_ENABLED))->GetCheck()))
      {
        m_fScavengingEnabled = ((CButton*)GetDlgItem(IDC_SCAVENGING_ENABLED))->GetCheck();
        m_bScavengeDirty = TRUE;
      }
      else
      {
        m_bScavengeDirty = FALSE;
      }
    }
    CHelpDialog::OnOK();
  }

}

void CDNSZone_AgingDialog::OnCancel()
{
  if (m_pHolder != NULL)
		m_pHolder->PopDialogHWnd();
  CHelpDialog::OnCancel();
}

////////////////////////////////////////////////////////////////////////////
// CDNS_AGING_TimeIntervalEditGroup

void CDNS_AGING_TimeIntervalEditGroup::OnEditChange()
{
  if (m_pPage != NULL)
    m_pPage->SetDirty();
}

// REVIEW_JEFFJON : Both of these functions are some serious hacks and need to be fixed
//                  These hacks were put in to deal with a combo box that only has hours
//                  and days, instead of seconds, minutes, hours, and days.
void CDNS_AGING_TimeIntervalEditGroup::SetVal(UINT nVal)
{
	// set default values
	nVal = _ForceToRange(nVal, m_nMinVal, m_nMaxVal);
	UINT nMax = (UINT)-1;
	CDNSTimeUnitComboBox::unitType u = CDNSTimeUnitComboBox::hrs;

	if ((nVal/24)*24 == nVal)
	{
		// can promote to days
		u = CDNSTimeUnitComboBox::days;
		nMax = nMax/24;
		nVal = nVal/24;
	}

	m_timeUnitCombo.SetUnit(u);
	m_edit.SetRange(0,nMax);
	m_edit.SetVal(nVal);
}


UINT CDNS_AGING_TimeIntervalEditGroup::GetVal()
{
  CDNSTimeUnitComboBox::unitType  u = m_timeUnitCombo.GetUnit();
	UINT nVal = m_edit.GetVal();
	// the value must always to be in hours
	if (u != CDNSTimeUnitComboBox::sec)
	{
		switch(u)
		{
		case CDNSTimeUnitComboBox::min:
			nVal *= 24;
			break;
		default:
			ASSERT(FALSE);
		}
	}
	ASSERT(nVal >= m_nMinVal && nVal <= m_nMaxVal);
	return nVal;
}

void CDNS_AGING_TimeIntervalEditGroup::InitRangeInfo()
{
	static UINT _secondsCount[2] =
			{ 1, 24 }; // # of hours in a hour, day
	for (UINT k=0; k<2; k++)
	{
		if (m_nMinVal == 0)
		{
			m_rangeInfoArr[k].m_nMinVal = 0;
		}
		else
		{
			m_rangeInfoArr[k].m_nMinVal = m_nMinVal/_secondsCount[k];
			if (k > 0)
				m_rangeInfoArr[k].m_nMinVal++;
		}
		m_rangeInfoArr[k].m_nMaxVal = m_nMaxVal/_secondsCount[k];
		if (m_rangeInfoArr[k].m_nMaxVal >= m_rangeInfoArr[k].m_nMinVal)
			m_nRangeCount = k + 1;
	}
}

void CDNS_SERVER_AGING_TimeIntervalEditGroup::OnEditChange()
{
  if (m_pPage2 != NULL)
    m_pPage2->SetDirty(TRUE);
}

////////////////////////////////////////////////////////////////////////////////////
// CDNSServer_AgingConfirm

BOOL CDNSServer_AgingConfirm::OnInitDialog()
{
  CHelpDialog::OnInitDialog();

  // Removed because we didn't want to expose the defaults for file based zones
//  ((CButton*)GetDlgItem(IDC_CHECK_AD))->SetCheck(TRUE);
//  ((CButton*)GetDlgItem(IDC_CHECK_AD))->EnableWindow(FALSE);
  SetAgingUpdateValues();
  return FALSE;
}

void CDNSServer_AgingConfirm::SetAgingUpdateValues()
{
  CEdit* pcAgingProps = (CEdit*)GetDlgItem(IDC_EDIT_NEW_DEFAULTS);
  ASSERT(pcAgingProps != NULL);

  CString szScavengeFormat, szScavengeValue,
          szRefreshFormat, szRefreshValue,
          szNoRefreshFormat, szNoRefreshValue,
          szTotalString;

  if (m_pAgingDialog->m_bScavengeDirty)
  {
    CString szEnabled;
    VERIFY(szScavengeFormat.LoadString(IDS_SERVER_SCAVENGE_FORMAT));
    if (m_pAgingDialog->m_fScavengingEnabled)
    {
      VERIFY(szEnabled.LoadString(IDS_ENABLED));
    }
    else
    {
      VERIFY(szEnabled.LoadString(IDS_DISABLED));
    }
    szScavengeValue.Format(szScavengeFormat, szEnabled);
    szTotalString += szScavengeValue + _T("\r\n");
  }

  if (m_pAgingDialog->m_bNoRefreshDirty)
  {
    CString szUnit;
    VERIFY(szNoRefreshFormat.LoadString(IDS_SERVER_NO_REFRESH_FORMAT));

    DWORD nVal = 0;
    if (m_pAgingDialog->m_dwNoRefreshInterval % 24 == 0)
    {
      szUnit.LoadString(IDS_DAYS);
      nVal = m_pAgingDialog->m_dwNoRefreshInterval / 24;
    }
    else
    {
      szUnit.LoadString(IDS_HOURS);
      nVal = m_pAgingDialog->m_dwNoRefreshInterval;
    }

    szNoRefreshValue.Format(szNoRefreshFormat, nVal, szUnit);
    szTotalString += szNoRefreshValue + _T("\r\n");
  }

  if (m_pAgingDialog->m_bRefreshDirty)
  {
    CString szUnit;
    VERIFY(szRefreshFormat.LoadString(IDS_SERVER_REFRESH_FORMAT));

    DWORD nVal = 0;
    if (m_pAgingDialog->m_dwRefreshInterval % 24 == 0)
    {
      szUnit.LoadString(IDS_DAYS);
      nVal = m_pAgingDialog->m_dwRefreshInterval / 24;
    }
    else
    {
      szUnit.LoadString(IDS_HOURS);
      nVal = m_pAgingDialog->m_dwRefreshInterval;
    }

    szRefreshValue.Format(szRefreshFormat, nVal, szUnit);
    szTotalString += szRefreshValue;
  }

  pcAgingProps->SetWindowText(szTotalString);
}

void CDNSServer_AgingConfirm::OnOK()
{
  // Removed because we didn't want to expose the defaults for file based zones
/*  if (((CButton*)GetDlgItem(IDC_CHECK_STANDARD))->GetCheck() && m_pAgingDialog->m_fScavengingEnabled)
  {
    if (DNSMessageBox(IDS_MSG_FILE_WARNING, MB_YESNO) == IDNO)
    {
      return;
    }
  }
*/
  m_pAgingDialog->m_bADApplyAll = ((CButton*)GetDlgItem(IDC_CHECK_AD_APPLY_ALL))->GetCheck();
  // Removed because we didn't want to expose the defaults for file based zones
//  m_pAgingDialog->m_bADApplyAll = ((CButton*)GetDlgItem(IDC_CHECK_AD))->GetCheck();
//  m_pAgingDialog->m_bStandardApplyAll = ((CButton*)GetDlgItem(IDC_CHECK_STANDARD))->GetCheck();
  CHelpDialog::OnOK();
}

///////////////////////////////////////////////////////////////////////////////
BOOL
WINAPI
DNSTzSpecificLocalTimeToSystemTime(
    LPTIME_ZONE_INFORMATION lpTimeZoneInformation,
    LPSYSTEMTIME lpLocalTime,
    LPSYSTEMTIME lpUniversalTime
    )
{

    TIME_ZONE_INFORMATION TziData;
    LPTIME_ZONE_INFORMATION Tzi;
    RTL_TIME_ZONE_INFORMATION tzi;
    LARGE_INTEGER TimeZoneBias;
    LARGE_INTEGER NewTimeZoneBias;
    LARGE_INTEGER LocalCustomBias;
    LARGE_INTEGER StandardTime;
    LARGE_INTEGER DaylightTime;
    LARGE_INTEGER CurrentLocalTime;
    LARGE_INTEGER ComputedUniversalTime;
    ULONG CurrentTimeZoneId = 0xffffffff;

    //
    // Get the timezone information into a useful format
    //
    if ( !ARGUMENT_PRESENT(lpTimeZoneInformation) ) {

        //
        // Convert universal time to local time using current timezone info
        //
        if (GetTimeZoneInformation(&TziData) == TIME_ZONE_ID_INVALID) {
            return FALSE;
            }
        Tzi = &TziData;
    }
    else {
        Tzi = lpTimeZoneInformation;
    }

    tzi.Bias            = Tzi->Bias;
    tzi.StandardBias    = Tzi->StandardBias;
    tzi.DaylightBias    = Tzi->DaylightBias;

    RtlMoveMemory(&tzi.StandardName,&Tzi->StandardName,sizeof(tzi.StandardName));
    RtlMoveMemory(&tzi.DaylightName,&Tzi->DaylightName,sizeof(tzi.DaylightName));

    tzi.StandardStart.Year         = Tzi->StandardDate.wYear        ;
    tzi.StandardStart.Month        = Tzi->StandardDate.wMonth       ;
    tzi.StandardStart.Weekday      = Tzi->StandardDate.wDayOfWeek   ;
    tzi.StandardStart.Day          = Tzi->StandardDate.wDay         ;
    tzi.StandardStart.Hour         = Tzi->StandardDate.wHour        ;
    tzi.StandardStart.Minute       = Tzi->StandardDate.wMinute      ;
    tzi.StandardStart.Second       = Tzi->StandardDate.wSecond      ;
    tzi.StandardStart.Milliseconds = Tzi->StandardDate.wMilliseconds;

    tzi.DaylightStart.Year         = Tzi->DaylightDate.wYear        ;
    tzi.DaylightStart.Month        = Tzi->DaylightDate.wMonth       ;
    tzi.DaylightStart.Weekday      = Tzi->DaylightDate.wDayOfWeek   ;
    tzi.DaylightStart.Day          = Tzi->DaylightDate.wDay         ;
    tzi.DaylightStart.Hour         = Tzi->DaylightDate.wHour        ;
    tzi.DaylightStart.Minute       = Tzi->DaylightDate.wMinute      ;
    tzi.DaylightStart.Second       = Tzi->DaylightDate.wSecond      ;
    tzi.DaylightStart.Milliseconds = Tzi->DaylightDate.wMilliseconds;

    //
    // convert the input local time to NT style time
    //
    if ( !SystemTimeToFileTime(lpLocalTime,(LPFILETIME)&CurrentLocalTime) ) {
        return FALSE;
    }

    //
    // Get the new timezone bias
    //

    NewTimeZoneBias.QuadPart = Int32x32To64(tzi.Bias*60, 10000000);

    //
    // Now see if we have stored cutover times
    //

    if ( tzi.StandardStart.Month && tzi.DaylightStart.Month ) {

        //
        // We have timezone cutover information. Compute the
        // cutover dates and compute what our current bias
        // is
        //

        if ( !RtlCutoverTimeToSystemTime(
                &tzi.StandardStart,
                &StandardTime,
                &CurrentLocalTime,
                TRUE
                ) ) {
            return FALSE;
        }

        if ( !RtlCutoverTimeToSystemTime(
                &tzi.DaylightStart,
                &DaylightTime,
                &CurrentLocalTime,
                TRUE
                ) ) {
            return FALSE;
        }


        //
        // If daylight < standard, then time >= daylight and
        // less than standard is daylight
        //

        if ( DaylightTime.QuadPart < StandardTime.QuadPart ) {

            //
            // If today is >= DaylightTime and < StandardTime, then
            // We are in daylight savings time
            //

            if ( (CurrentLocalTime.QuadPart >= DaylightTime.QuadPart) &&
                 (CurrentLocalTime.QuadPart <  StandardTime.QuadPart) ) {

                CurrentTimeZoneId = TIME_ZONE_ID_DAYLIGHT;
            }
            else {
                CurrentTimeZoneId = TIME_ZONE_ID_STANDARD;
            }
        }
        else {

            //
            // If today is >= StandardTime and < DaylightTime, then
            // We are in standard time
            //

            if ( (CurrentLocalTime.QuadPart >= StandardTime.QuadPart ) &&
                 (CurrentLocalTime.QuadPart <  DaylightTime.QuadPart ) ) {

                CurrentTimeZoneId = TIME_ZONE_ID_STANDARD;
            }
            else {
                CurrentTimeZoneId = TIME_ZONE_ID_DAYLIGHT;
            }
        }

        //
        // At this point, we know our current timezone and the
        // local time of the next cutover.
        //

        LocalCustomBias.QuadPart = Int32x32To64(
                            CurrentTimeZoneId == TIME_ZONE_ID_DAYLIGHT ?
                                tzi.DaylightBias*60 :
                                tzi.StandardBias*60,                // Bias in seconds
                            10000000
                            );

        TimeZoneBias.QuadPart = NewTimeZoneBias.QuadPart + LocalCustomBias.QuadPart;

    }
    else {
        TimeZoneBias = NewTimeZoneBias;
    }

    ComputedUniversalTime.QuadPart = CurrentLocalTime.QuadPart + TimeZoneBias.QuadPart;

    if ( !FileTimeToSystemTime((LPFILETIME)&ComputedUniversalTime,lpUniversalTime) ) {
        return FALSE;
    } 

    return TRUE;
}

LONGLONG
GetSystemTime64(
    SYSTEMTIME* pSysTime
    )
/*++
Function   : GetLongSystemTime
Description:
Parameters :
Return     : 0 on error, GetLastError for more
Remarks    :
--*/
{
    LONGLONG    llTime=0;
    LONGLONG    llHigh=0;
    FILETIME    fileTime;

    //
    // No return checking cause we return 0 on error
    //

    SystemTimeToFileTime( pSysTime, &fileTime );

    llTime = (LONGLONG) fileTime.dwLowDateTime;
    llHigh = (LONGLONG) fileTime.dwHighDateTime;
    llTime |= (llHigh << 32);

    // this is 100ns blocks since 1601. Now convert to seconds

    llTime = llTime / (10*1000*1000L);

    return llTime;
}

/////////////////////////////////////////////////////////////////////////

BOOL LoadComboBoxFromTable(CComboBox* pComboBox, PCOMBOBOX_TABLE_ENTRY pTable)
{
  BOOL bRet = TRUE;
  if (pComboBox == NULL ||
      pTable == NULL)
  {
    return FALSE;
  }

  PCOMBOBOX_TABLE_ENTRY pTableEntry = pTable;
  while (pTableEntry->nComboStringID != 0)
  {
    CString szComboString;
    if (!szComboString.LoadString(pTableEntry->nComboStringID))
    {
      bRet = FALSE;
      break;
    }

    int idx = pComboBox->AddString(szComboString);
    if (idx != CB_ERR)
    {
      pComboBox->SetItemData(idx, pTableEntry->dwComboData);
    }
    else
    {
      bRet = FALSE;
      break;
    }
    pTableEntry++;
  }
  return bRet;
}

BOOL SetComboSelByData(CComboBox* pComboBox, DWORD dwData)
{
  BOOL bRet = FALSE;
  int iCount = pComboBox->GetCount();
  for (int idx = 0; idx < iCount; idx++)
  {
    if (pComboBox->GetItemData(idx) == dwData)
    {
      pComboBox->SetCurSel(idx);
      bRet = TRUE;
      break;
    }
  }
  return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\uiutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       uiutil.h
//
//--------------------------------------------------------------------------

#ifndef __UIUTIL_H
#define __UIUTIL_H

#include "resource.h"

extern "C"
    {
#include "maskctrl.h"
}

#include <shfusion.h>

///////////////////////////////////////////////////////////////////////////////
// FORWARD DECLARATIONS

class CComponentDataObject;
class CMTContainerNode;
class CNotificationSinkEvent;

/////////////////////////////////////////////////////////////////////////////

typedef enum
{
  RECORD_FOUND,
  RECORD_NOT_FOUND,
  RECORD_NOT_FOUND_AT_THE_NODE,
  DOMAIN_NOT_ENUMERATED,
  NON_EXISTENT_SUBDOMAIN
} RECORD_SEARCH;

#define ARRAYLENGTH(x)  (sizeof(x)/sizeof((x)[0]))

////////////////////////////////////////////////////////////////////////////
// CDNSNameTokenizer

class CDNSNameTokenizer : public CStringList
{
public:
  CDNSNameTokenizer(PCWSTR pszDNSName);
  ~CDNSNameTokenizer();

  BOOL Tokenize(const wchar_t* wcToken);
  void RemoveMatchingFromTail(CDNSNameTokenizer& refTokenizer);
  void GetRemaining(CString& strrefRemaining, const wchar_t* wcToken);

private:
  CDNSNameTokenizer(const CDNSNameTokenizer&) {}
  CDNSNameTokenizer& operator=(const CDNSNameTokenizer&) {}

  CString m_szDNSName;
};

////////////////////////////////////////////////////////////////////////////
// Global functions

BOOL LoadStringsToComboBox(HINSTANCE hInstance, CComboBox* pCombo,
						   UINT nStringID, UINT nMaxLen, UINT nMaxAddCount);

void ParseNewLineSeparatedString(LPWSTR lpsz,
								 LPWSTR* lpszArr,
								 UINT* pnArrEntries);

void LoadStringArrayFromResource(LPWSTR* lpszArr,
											UINT* nStringIDs,
											int nArrEntries,
											int* pnSuccessEntries);

void EnumerateMTNodeHelper(CMTContainerNode* pNode,
							 CComponentDataObject* pComponentData);


void EnableDialogControls(HWND hWnd, BOOL bEnable);


BOOL LoadFontInfoFromResource(IN UINT nFontNameID, 
                              IN UINT nFontSizeID,
                              OUT LPWSTR lpFontName, IN int nFontNameMaxchar,
                              OUT int& nFontSize,
                              IN LPCWSTR lpszDefaultFont, IN int nDefaultFontSize);

void SetBigBoldFont(HWND hWndDialog, int nControlID);

int GetCheckedRadioButtonHelper(HWND hDlg, int nCount, int* nRadioArr, int nRadioDefault);

UINT _ForceToRange(UINT nVal, UINT nMin, UINT nMax);

BOOL
WINAPI
DNSTzSpecificLocalTimeToSystemTime(
    LPTIME_ZONE_INFORMATION lpTimeZoneInformation,
    LPSYSTEMTIME lpLocalTime,
    LPSYSTEMTIME lpUniversalTime
    );

LONGLONG
GetSystemTime64(
    SYSTEMTIME* pSysTime
    );

////////////////////////////////////////////////////////////////////////////
// CMultiselectErrorDialog
class CMultiselectErrorDialog : public CDialog
{
public:
  CMultiselectErrorDialog() : m_pErrorArray(NULL), CDialog(IDD_MULTISELECT_ERROR_DIALOG) {}
  ~CMultiselectErrorDialog() {}

  HRESULT Initialize(CNodeList* pNodeList, 
                     DNS_STATUS* pErrorArray, 
                     UINT nErrorCount, 
                     PCWSTR pszTitle, 
                     PCWSTR pszCaption,
                     PCWSTR pszHeader);
private:
  CMultiselectErrorDialog(const CMultiselectErrorDialog&) {}
  CMultiselectErrorDialog& operator=(const CMultiselectErrorDialog&) {}

public:
  virtual BOOL OnInitDialog();

  DECLARE_MESSAGE_MAP()

private:
  CNodeList*  m_pNodeList;
  DNS_STATUS* m_pErrorArray;
  UINT        m_nErrorCount;
  CString     m_szTitle;
  CString     m_szCaption;
  CString     m_szColumnHeader;
};

////////////////////////////////////////////////////////////////////////////
// CDNSMaskCtrl

class CDNSMaskCtrl : public CWnd
{
public:
	CDNSMaskCtrl() { }
	virtual ~CDNSMaskCtrl() {}
public:

  BOOL IsBlank();
  void SetFocusField(DWORD dwField);
  void SetFieldRange(DWORD dwField, DWORD dwMin, DWORD dwMax);
	void SetArray(DWORD* pArray, UINT nFields);
	void GetArray(DWORD* pArray, UINT nFields);
  void Clear(int nField = -1);
	void SetAlertFunction( int (*lpfnAlert)(HWND, DWORD, DWORD, DWORD) );
	void EnableField(int nField, BOOL bEnable);

	static int AlertFunc(HWND hwndParent, DWORD dwCurrent, DWORD dwLow, DWORD dwHigh);

};

////////////////////////////////////////////////////////////////////////////
// CDNSIPv4Control
class CDNSIPv4Control : public CDNSMaskCtrl
{
public:
	CDNSIPv4Control()
	{
	}
	~CDNSIPv4Control()
	{
	}
	void SetIPv4Val(DWORD x);
	void GetIPv4Val(DWORD* pX);
	BOOL IsEmpty();
};

////////////////////////////////////////////////////////////////////////////
// CDNSIPv6Control
class CDNSIPv6Control : public CDNSMaskCtrl
{
public:
	// assume the format is a WORD[8] array
	void SetIPv6Val(IPV6_ADDRESS* pIpv6Address);
	void GetIPv6Val(IPV6_ADDRESS* pIpv6Address);
};


////////////////////////////////////////////////////////////////////////////
// CDNSTTLControl
class CDNSTTLControl : public CDNSMaskCtrl
{
public:
	void SetTTL(DWORD x);
	void GetTTL(DWORD* pX);
};


///////////////////////////////////////////////////////////////////////
// CDNSUnsignedIntEdit
// NOTE: the resource must be an editbox with Numeric Style

class CDNSUnsignedIntEdit : public CEdit
{
public:
	CDNSUnsignedIntEdit() {}

	BOOL SetVal(UINT nVal);
	UINT GetVal();
	void SetRange(UINT nMin, UINT nMax)
		{ m_nMin = nMin; m_nMax = nMax;}
	UINT GetMax() { return m_nMax;}
	UINT GetMin() { return m_nMin;}

protected:
	afx_msg void OnKillFocus();

private:
	UINT m_nMin;
	UINT m_nMax;

	DECLARE_MESSAGE_MAP()
};


///////////////////////////////////////////////////////////////////////
// CDNSUpDownUnsignedIntEdit

class CDNSUpDownUnsignedIntEditGroup; // fwd decl

class CDNSUpDownUnsignedIntEdit : public CDNSUnsignedIntEdit
{
public:
	CDNSUpDownUnsignedIntEdit() { m_pEditGroup = NULL; }
	void Set(CDNSUpDownUnsignedIntEditGroup* pEditGroup) { m_pEditGroup = pEditGroup;}

protected:
	afx_msg void OnKillFocus();
	afx_msg void OnChange();

private:
	CDNSUpDownUnsignedIntEditGroup* m_pEditGroup;

	DECLARE_MESSAGE_MAP()
};

//////////////////////////////////////////////////////////////////////////
// CDNSUpDownButton

class CDNSUpDownButton : public CButton
{
public:
	CDNSUpDownButton() { m_pEditGroup = NULL;  m_bUp = TRUE; }
	void Set(CDNSUpDownUnsignedIntEditGroup* pEditGroup, BOOL bUp)
		{ m_pEditGroup = pEditGroup; m_bUp = bUp; }
protected:
	afx_msg void OnClicked();

private:
	CDNSUpDownUnsignedIntEditGroup* m_pEditGroup;
	BOOL m_bUp;

	DECLARE_MESSAGE_MAP()
};

//////////////////////////////////////////////////////////////////////////
// CDNSUpDownUnsignedIntEditGroup

class CDNSUpDownUnsignedIntEditGroup
{
public:
	CDNSUpDownUnsignedIntEditGroup() {}
	BOOL Initialize(CWnd* pParentWnd, UINT nIDEdit,
				UINT nIDBtnUp, UINT nIDBtnDown);
	void SetRange(UINT nMin, UINT nMax)
		{ m_edit.SetRange(nMin, nMax); }

	void SetVal(UINT nVal);
	UINT GetVal();

protected:
	virtual void OnEditChange() {}

private:
	CDNSUpDownUnsignedIntEdit m_edit;
	CDNSUpDownButton m_downBtn;
	CDNSUpDownButton m_upBtn;

	void SetButtonsState();

	void OnClicked(BOOL bUp);

	friend class CDNSUpDownButton;
	friend class CDNSUpDownUnsignedIntEdit;

};

/////////////////////////////////////////////////////////////////////////
// CDNSTimeIntervalEdit

class CDNSTimeIntervalEditGroup; // fwd decl

class CDNSTimeIntervalEdit : public CDNSUnsignedIntEdit
{
public:
	CDNSTimeIntervalEdit() { m_pEditGroup = NULL; }
	void Set(CDNSTimeIntervalEditGroup* pEditGroup)
		{ m_pEditGroup = pEditGroup; }

protected:
	afx_msg void OnChange();
  afx_msg void OnKillFocus();
private:
	CDNSTimeIntervalEditGroup* m_pEditGroup;

	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////
// CDNSTimeUnitComboBox

class CDNSTimeUnitComboBox : public CComboBox
{
public:
	typedef enum { sec=0, min, hrs, days} unitType;
	CDNSTimeUnitComboBox() { m_pEditGroup = NULL;}
	void Set(CDNSTimeIntervalEditGroup* pEditGroup)
		{ m_pEditGroup = pEditGroup; }

	BOOL LoadStrings(UINT nIDUnitsString, UINT nMaxAddCount);
	void SetUnit(unitType u);
	unitType GetUnit();

protected:
	afx_msg void OnSelChange();

private:
	CDNSTimeIntervalEditGroup* m_pEditGroup;

	DECLARE_MESSAGE_MAP()
};



//////////////////////////////////////////////////////////////////////////
// CDNSTimeIntervalEditGroup

class CDNSTimeIntervalEditGroup
{
public:
	CDNSTimeIntervalEditGroup(UINT nMinVal = 0 , UINT nMaxVal = (UINT)-1);

	BOOL Initialize(CWnd* pParentWnd, UINT nIDEdit,
				UINT nIDCombo, UINT nIDComboUnitsString);

	void SetVal(UINT nVal);
	UINT GetVal();

	void EnableUI(BOOL bEnable);

protected:
	virtual void OnEditChange() {}

	struct RANGE_INFO
	{
		RANGE_INFO()
			{ memset(this, 0x0, sizeof(RANGE_INFO));}
		UINT m_nMinVal;
		UINT m_nMaxVal;
	};

 	CDNSTimeIntervalEdit	m_edit;
	CDNSTimeUnitComboBox	m_timeUnitCombo;
	RANGE_INFO				m_rangeInfoArr[4]; // for sec, min, hrs, days
	UINT					m_nRangeCount;

	UINT m_nMaxVal;
	UINT m_nMinVal;

private:

	virtual void InitRangeInfo();

	void OnComboSelChange();
  void OnEditKillFocus();


	friend class CDNSTimeIntervalEdit;
	friend class CDNSTimeUnitComboBox;
};

//////////////////////////////////////////////////////////////////////////
// CDNSManageControlTextHelper

class CDNSManageControlTextHelper
{
public:
	CDNSManageControlTextHelper(int nStates);
	~CDNSManageControlTextHelper();

	BOOL Init(CWnd* pParentWnd, UINT nID, UINT* pnStrArray);
  BOOL Init(CWnd* pParentWnd, UINT nID);
	void SetStateX(int nIndex);

private:
	CWnd* m_pParentWnd;
	UINT m_nID;
	WCHAR* m_lpszText;

	int m_nStates;
	LPWSTR* m_lpszArr;
};


//////////////////////////////////////////////////////////////////////////
// CDNSToggleTextControlHelper

class CDNSToggleTextControlHelper : public CDNSManageControlTextHelper
{
public:
	CDNSToggleTextControlHelper();
	void SetToggleState(BOOL bFirst) { SetStateX(bFirst ? 0 : 1);}
};

///////////////////////////////////////////////////////////////////////////
// CDNSManageButtonTextHelper

class CDNSManageButtonTextHelper
{
public:
	CDNSManageButtonTextHelper(int nStates);
	~CDNSManageButtonTextHelper();

	BOOL Init(CWnd* pParentWnd, UINT nButtonID, UINT* nStrArray);
	void SetStateX(int nIndex);

private:
	CWnd* m_pParentWnd;
	UINT m_nID;
	WCHAR* m_lpszText;

	int m_nStates;
	LPWSTR* m_lpszArr;
};

///////////////////////////////////////////////////////////////////////////
// CDNSButtonToggleTextHelper

class CDNSButtonToggleTextHelper : public CDNSManageButtonTextHelper
{
public:
	CDNSButtonToggleTextHelper();

	void SetToggleState(BOOL bFirst) { SetStateX(bFirst ? 0 : 1); }
};


/////////////////////////////////////////////////////////////////////////////
// CDlgWorkerThread

class CLongOperationDialog; // fwd decl

class CDlgWorkerThread : public CWorkerThread
{
public:
	CDlgWorkerThread();

	BOOL Start(CLongOperationDialog* pDlg);
	virtual int Run();								// MFC override

	DWORD GetError() { return m_dwErr;}

protected:
	virtual void OnDoAction() = 0;

	DWORD m_dwErr;

private:
	BOOL PostMessageToDlg();

  friend CLongOperationDialog;
};


/////////////////////////////////////////////////////////////////////////////
// CLongOperationDialog dialog

class CLongOperationDialog : public CDialog
{
// Construction
public:
	static UINT s_nNotificationMessage;
	CLongOperationDialog(CDlgWorkerThread* pThreadObj, CWnd* pParentWnd, UINT nAviID = -1);
	virtual ~CLongOperationDialog();

  virtual INT_PTR DoModal()
  {
    if (m_bExecuteNoUI)
    {
      GetThreadObj()->OnDoAction();
      m_bAbandoned = FALSE;
      return IDOK;
    }
    return CDialog::DoModal();
  }

	BOOL LoadTitleString(UINT nID);

	CDlgWorkerThread* GetThreadObj()
	{
		ASSERT(m_pThreadObj != NULL);
		return m_pThreadObj;
	}

	UINT m_nAviID;
	CString m_szTitle;
	BOOL m_bAbandoned;
  BOOL m_bExecuteNoUI;

	afx_msg LONG OnNotificationMessage( WPARAM wParam, LPARAM lParam);
// Implementation
protected:
	// Generated message map functions
	virtual BOOL OnInitDialog();
	virtual void OnCancel();
	DECLARE_MESSAGE_MAP()

private:
	CDlgWorkerThread* m_pThreadObj;
};

//////////////////////////////////////////////////////////
// CNodeEnumerationThread

class CNodeEnumerationThread : public CDlgWorkerThread
{
public:
	CNodeEnumerationThread(CComponentDataObject* pComponentDataObject,
								CMTContainerNode* pNode);
	~CNodeEnumerationThread();

protected:
	virtual void OnDoAction();
	void OnAbandon();
private:
	CComponentDataObject* m_pComponentDataObject;
	CNotificationSinkEvent* m_pSink;
	CMTContainerNode* m_pNode;
};

//////////////////////////////////////////////////////////
// CArrayCheckListBox

class CArrayCheckListBox : public CCheckListBox
{
public:
	CArrayCheckListBox(UINT nArrSize, DWORD* dwMaskArr = NULL)
		{ m_nArrSize = nArrSize; m_dwMaskArr = dwMaskArr; }	
	BOOL Initialize(UINT nCtrlID, UINT nStringID, CWnd* pParentWnd);

	void SetValue(DWORD dw);
	DWORD GetValue();
	void SetArrValue(DWORD* dwArr, UINT nArrSize);
	void GetArrValue(DWORD* dwArr, UINT nArrSize);
private:
	DWORD* m_dwMaskArr;
	UINT m_nArrSize;
};


////////////////////////////////////////////////////////////////////////////
// CDNS_AGING_TimeIntervalEditGroup

class CDNSZone_AgingDialog; // Foward declaration
class CDNSServer_AdvancedPropertyPage; // Fwd declaration

class CDNS_AGING_TimeIntervalEditGroup : public CDNSTimeIntervalEditGroup
{
public:
  CDNS_AGING_TimeIntervalEditGroup(UINT nMinVal = 0 , UINT nMaxVal = (UINT)0x7fffffff) 
    : CDNSTimeIntervalEditGroup(nMinVal, nMaxVal)
  {
    m_pPage = NULL;
  }
	virtual void OnEditChange();
  virtual void SetVal(UINT nVal);
  virtual UINT GetVal();
	virtual void InitRangeInfo();

protected:
	CDNSZone_AgingDialog* m_pPage;
	friend class CDNSZone_AgingDialog;
};

class CDNS_SERVER_AGING_TimeIntervalEditGroup : public CDNS_AGING_TimeIntervalEditGroup
{
public:
  CDNS_SERVER_AGING_TimeIntervalEditGroup(UINT nMinVal = 0 , UINT nMaxVal = (UINT)0x7fffffff) 
    : CDNS_AGING_TimeIntervalEditGroup(nMinVal, nMaxVal)
  {
    m_pPage2 = NULL;
  }

 	virtual void OnEditChange();

protected:
  CDNSServer_AdvancedPropertyPage* m_pPage2;
  friend class CDNSServer_AdvancedPropertyPage;
};

////////////////////////////////////////////////////////////////////////////
// CDNSZone_AgingDialog

class CDNSZone_AgingDialog : public CHelpDialog
{
public:
  CDNSZone_AgingDialog(CPropertyPageHolderBase* pHolder, UINT nID, CComponentDataObject* pComponentData);

  // IN/OUT
  DWORD m_dwRefreshInterval;
  DWORD m_dwNoRefreshInterval;
  DWORD m_dwScavengingStart;
  DWORD m_fScavengingEnabled;
  BOOL m_bAdvancedView;
  BOOL m_bScavengeDirty;
  BOOL m_bNoRefreshDirty;
  BOOL m_bRefreshDirty;
  BOOL m_bApplyAll;
  BOOL m_bADApplyAll;
  BOOL m_bStandardApplyAll;

  DWORD m_dwDefaultRefreshInterval;
  DWORD m_dwDefaultNoRefreshInterval;
  BOOL m_bDefaultScavengingState;

  virtual void SetDirty();
  BOOL IsDirty() { return m_bDirty; }

  CComponentDataObject* GetComponentData() { return m_pComponentData; }

protected:
  virtual BOOL OnInitDialog();
  virtual void OnOK();
  virtual void OnCancel();

  afx_msg void OnCheckScavenge();
  afx_msg void OnEditNoRefresh();
  afx_msg void OnEditRefresh();

  void GetTimeStampString(CString& cstrDate);
  void SetUIData();

  DECLARE_MESSAGE_MAP()

  CPropertyPageHolderBase* m_pHolder;
	CDNS_AGING_TimeIntervalEditGroup			m_refreshIntervalEditGroup;
	CDNS_AGING_TimeIntervalEditGroup			m_norefreshIntervalEditGroup;

  CComponentDataObject* m_pComponentData;

  BOOL m_bDirty;
};

////////////////////////////////////////////////////////////////////////////////////
// CDNSServer_AgingConfirm

class CDNSServer_AgingConfirm : public CHelpDialog
{
public:
  CDNSServer_AgingConfirm(CDNSZone_AgingDialog* pAgingDialog)
    : CHelpDialog(IDD_SERVER_AGING_CONFIRMATION, pAgingDialog->GetComponentData())
  {
    ASSERT(pAgingDialog != NULL);
    m_pAgingDialog = pAgingDialog;
  }

protected:
  virtual BOOL OnInitDialog();
  virtual void OnOK();

  void SetAgingUpdateValues();

private:
  CDNSZone_AgingDialog* m_pAgingDialog;
};

/////////////////////////////////////////////////////////////////////////////////////

typedef struct _COMBOBOX_TABLE_ENTRY
{
  UINT    nComboStringID;
  DWORD   dwComboData;
} COMBOBOX_TABLE_ENTRY, *PCOMBOBOX_TABLE_ENTRY;

BOOL LoadComboBoxFromTable(CComboBox* pComboBox, PCOMBOBOX_TABLE_ENTRY pTable);
BOOL SetComboSelByData(CComboBox* pComboBox, DWORD dwData);

////////////////////////////////////////////////////////////////////////////////////
// Theme support

class CThemeContextActivator
{
public:
    CThemeContextActivator() : m_ulActivationCookie(0)
        { SHActivateContext (&m_ulActivationCookie); }

    ~CThemeContextActivator()
        { SHDeactivateContext (m_ulActivationCookie); }

private:
    ULONG_PTR m_ulActivationCookie;
};

#endif // __UIUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\zone.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       zone.h
//
//--------------------------------------------------------------------------

#ifndef _ZONE_H
#define _ZONE_H

#include "dnsutil.h"

#include "ZoneUI.h"


#define ASSERT_VALID_ZONE_INFO() \
	ASSERT((m_pZoneInfoEx != NULL) && (m_pZoneInfoEx->HasData()) )


#define DNS_ZONE_FLAG_REVERSE (0x0)

#define DNS_ZONE_Paused				0x1
#define DNS_ZONE_Shutdown			0x2
#define DNS_ZONE_Reverse			0x4
#define DNS_ZONE_AutoCreated		0x8
#define DNS_ZONE_DsIntegrated		0x10
#define DNS_ZONE_Unicode			0x20


/////////////////////////////////////////////////////////////////////////
// CDNSZoneNode

class CDNSZoneNode : public CDNSDomainNode
{
public:
	CDNSZoneNode();
	virtual ~CDNSZoneNode();

	// node info
	DECLARE_NODE_GUID()

	void InitializeFromRPCZoneInfo(PDNS_RPC_ZONE pZoneInfo, BOOL bAdvancedView);

  BOOL IsRootZone()
  {
    USES_CONVERSION;
    ASSERT(m_pZoneInfoEx != NULL);
    return (_wcsicmp(GetFullName(), _T(".")) == 0);
  }

	BOOL IsReverse() 
	{ 
		ASSERT(m_pZoneInfoEx != NULL);
		return (m_pZoneInfoEx->HasData()) ? m_pZoneInfoEx->m_pZoneInfo->fReverse : 
										((m_dwZoneFlags & DNS_ZONE_Reverse) != 0);
	}
	BOOL IsAutocreated() 
	{ 
		ASSERT(m_pZoneInfoEx != NULL);
		return (m_pZoneInfoEx->HasData()) ? m_pZoneInfoEx->m_pZoneInfo->fAutoCreated : 
										((m_dwZoneFlags & DNS_ZONE_AutoCreated) != 0);
	}
	DWORD GetZoneType() 
	{ 
		ASSERT(m_pZoneInfoEx != NULL);
		return (m_pZoneInfoEx->HasData()) ? m_pZoneInfoEx->m_pZoneInfo->dwZoneType : m_wZoneType;
	}

	DWORD GetSOARecordMinTTL()
	{
		ASSERT(m_pSOARecordNode != NULL);
		return m_pSOARecordNode->GetMinTTL();
	}

  // Aging/Scavenging Data Accessors
  DWORD GetAgingNoRefreshInterval()
  {
    ASSERT(m_pZoneInfoEx != NULL);
    return (m_pZoneInfoEx->HasData()) ? m_pZoneInfoEx->m_pZoneInfo->dwNoRefreshInterval : DNS_DEFAULT_NOREFRESH_INTERVAL;
  }

  DWORD GetAgingRefreshInterval()
  {
    ASSERT(m_pZoneInfoEx != NULL);
    return (m_pZoneInfoEx->HasData()) ? m_pZoneInfoEx->m_pZoneInfo->dwRefreshInterval : DNS_DEFAULT_REFRESH_INTERVAL;
  }

  DWORD GetScavengingStart()
  {
    ASSERT(m_pZoneInfoEx != NULL);
    return (m_pZoneInfoEx->HasData()) ? m_pZoneInfoEx->m_pZoneInfo->dwAvailForScavengeTime : DNS_DEFAULT_SCAVENGING_INTERVAL;
  }

  BOOL IsScavengingEnabled()
  {
    ASSERT(m_pZoneInfoEx != NULL);
    return (m_pZoneInfoEx->HasData()) ? m_pZoneInfoEx->m_pZoneInfo->fAging : DNS_DEFAULT_AGING_STATE;
  }

#ifdef USE_NDNC
  DWORD GetDirectoryPartitionFlags()
  {
    ASSERT(m_pZoneInfoEx != NULL);
    return (m_pZoneInfoEx->HasData()) ? m_pZoneInfoEx->m_pZoneInfo->dwDpFlags : 0;
  }

  ReplicationType GetDirectoryPartitionFlagsAsReplType();
  PCWSTR GetCustomPartitionName();
  DNS_STATUS ChangeDirectoryPartitionType(ReplicationType type, PCWSTR pszCustomPartition);
#endif 

  DNS_STATUS SetAgingNoRefreshInterval(DWORD dwNoRefreshInterval);
  DNS_STATUS SetAgingRefreshInterval(DWORD dwRefreshInterval);
  DNS_STATUS SetScavengingEnabled(BOOL bEnable);

  BOOL IsForwarderSlave()
  {
    ASSERT(m_pZoneInfoEx != NULL);
    return (m_pZoneInfoEx->HasData()) ? m_pZoneInfoEx->m_pZoneInfo->fForwarderSlave : DNS_DEFAULT_SLAVE;
  }

  DWORD ForwarderTimeout()
  {
    ASSERT(m_pZoneInfoEx != NULL);
    return (m_pZoneInfoEx->HasData()) ? m_pZoneInfoEx->m_pZoneInfo->dwForwarderTimeout : DNS_DEFAULT_FORWARD_TIMEOUT;
  }

 	virtual LPCWSTR GetString(int nCol);

	void ChangeViewOption(BOOL bAdvanced, CComponentDataObject* pComponentDataObject);
	static void SetZoneNormalViewHelper(CString& szDisplayName);

	virtual int GetImageIndex(BOOL bOpenImage);

	virtual HRESULT OnCommand(long nCommandID, 
                            DATA_OBJECT_TYPES type, 
                            CComponentDataObject* pComponentData,
                            CNodeList* pNodeList);
	virtual void OnDelete(CComponentDataObject* pComponentData,
                        CNodeList* pNodeList);
	virtual BOOL OnRefresh(CComponentDataObject* pComponentData,
                         CNodeList* pNodeList);

	virtual BOOL HasPropertyPages(DATA_OBJECT_TYPES type, 
                                BOOL* pbHideVerb,
                                CNodeList* pNodeList);
	virtual HRESULT CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, 
                                      LONG_PTR handle,
                                      CNodeList* pNodeList);
	virtual HRESULT CreatePropertyPagesHelper(LPPROPERTYSHEETCALLBACK lpProvider, 
		LONG_PTR handle, long nStartPageCode);

  virtual void Show(BOOL bShow, CComponentDataObject* pComponentData);
  virtual HRESULT GetResultViewType(CComponentDataObject* pComponentData, 
                                    LPOLESTR *ppViewType, 
                                    long *pViewOptions);
	virtual HRESULT OnShow(LPCONSOLE lpConsole);

  virtual void ShowPageForNode(CComponentDataObject* pComponentDataObject)
  {
    if (GetSheetCount() > 0)
		{
      // bring up the sheet of the container
			ASSERT(pComponentDataObject != NULL);
			pComponentDataObject->GetPropertyPageHolderTable()->BroadcastSelectPage(this, ZONE_HOLDER_GEN);
		}	
  }

  virtual BOOL OnSetRenameVerbState(DATA_OBJECT_TYPES type, 
                                    BOOL* pbHide, 
                                    CNodeList* pNodeList);
  virtual HRESULT OnRename(CComponentDataObject* pComponentData,
                           LPWSTR lpszNewName);

  virtual BOOL CanExpandSync() { return FALSE; }

protected:
	virtual LPCONTEXTMENUITEM2 OnGetContextMenuItemTable() 
				{ return CDNSZoneMenuHolder::GetContextMenuItem(); }
	virtual BOOL OnAddMenuItem(LPCONTEXTMENUITEM2 pContextMenuItem2,
								             long *pInsertionAllowed);


private:
	// command handlers
	void OnUpdateDataFile(CComponentDataObject* pComponentData);
  void OnReload(CComponentDataObject* pComponentData);
  void OnTransferFromMaster(CComponentDataObject* pComponentData);
  void OnReloadFromMaster(CComponentDataObject* pComponentData);

// DNS specific data
	// cached pointers to special record types
	CDNS_SOA_RecordNode*		m_pSOARecordNode;
	CDNSRecordNodeBase*			m_pWINSRecordNode;	// can be a WINS or an NBSTAT record

// DNS specific helpers
public:

	// creation
	DNS_STATUS CreatePrimary(LPCTSTR lpszDBName, 
                            BOOL bLoadExisting, 
                            BOOL bDSIntegrated,
                            UINT nDynamicUpdate);
	DNS_STATUS CreateSecondary(DWORD* ipMastersArray, int nIPMastersCount, 
								LPCTSTR lpszDBName, BOOL bLoadExisting);
	DNS_STATUS CreateStub(DWORD* ipMastersArray, 
                        int nIPMastersCount, 
								        LPCTSTR lpszDBName, 
                        BOOL bLoadExisting, 
                        BOOL bDSIntegrated);
  DNS_STATUS CreateForwarder(DWORD* ipMastersArray, 
                             int nIPMastersCount,
                             DWORD dwTimeout,
                             DWORD fSlave);
#ifdef USE_NDNC
  DNS_STATUS CreatePrimaryInDirectoryPartition(BOOL bLoadExisting, 
                                               UINT nDynamicUpdate,
                                               ReplicationType replType,
                                               PCWSTR pszPartitionName);
  DNS_STATUS CreateStubInDirectoryPartition(DWORD* ipMastersArray, 
                                            int nIPMastersCount,
                                            BOOL bLoadExisting,
                                            ReplicationType replType,
                                            PCWSTR pszPartitionName);
#endif

  //
	// change zone type
  //
  DNS_STATUS SetStub(DWORD cMasters, 
                     PIP_ADDRESS aipMasters, 
                     DWORD dwLoadOptions, 
                     BOOL bDSIntegrated,
                     LPCTSTR lpszDataFile,
                     BOOL bLocalListOfMasters);
	DNS_STATUS SetSecondary(DWORD cMasters, 
                          PIP_ADDRESS aipMasters,
								          DWORD dwLoadOptions, 
                          LPCTSTR lpszDataFile);
	DNS_STATUS SetPrimary(DWORD dwLoadOptions, 
                        BOOL bDSIntegrated,
										    LPCTSTR lpszDataFile);

	// pause/expire 
	DNS_STATUS TogglePauseHelper(CComponentDataObject* pComponentData);
	BOOL IsPaused();
	BOOL IsExpired();

   // Update the result view
   void ToggleView(CComponentDataObject* pComponentData);

	// database operations
	BOOL IsDSIntegrated();
	void GetDataFile(CString& szName);
	LPCSTR GetDataFile();
	DNS_STATUS ResetDatabase(BOOL bDSIntegrated, LPCTSTR lpszDataFile);
  DNS_STATUS WriteToDatabase();
  static DNS_STATUS WriteToDatabase(LPCWSTR lpszServer, LPCWSTR lpszZone);
  static DNS_STATUS WriteToDatabase(LPCWSTR lpszServer, LPCSTR lpszZone);
	DNS_STATUS IncrementVersion();
  DNS_STATUS Reload();
  DNS_STATUS TransferFromMaster();
  DNS_STATUS ReloadFromMaster();
  PCWSTR GetDN();

	// dynamic update (primary only)
	UINT GetDynamicUpdate();
	DNS_STATUS SetDynamicUpdate(UINT nDynamic);

	// primary/secondary zone secondaries manipulation
	DNS_STATUS ResetSecondaries(DWORD fSecureSecondaries, 
                              DWORD cSecondaries, PIP_ADDRESS aipSecondaries,
                              DWORD fNotifyLevel,
                              DWORD cNotify, PIP_ADDRESS aipNotify);
	void GetSecondariesInfo(DWORD* pfSecureSecondaries, 
                          DWORD* cSecondaries, PIP_ADDRESS* paipSecondaries,
                          DWORD* pfNotifyLevel,
                          DWORD* pcNotify, PIP_ADDRESS* paipNotify);

	// secondary zone masters manipulation
	DNS_STATUS ResetMasters(DWORD cMasters, PIP_ADDRESS aipMasters, BOOL bLocalMasters = FALSE);
	void GetMastersInfo(DWORD* pcAddrCount, PIP_ADDRESS* ppipAddrs);
  void GetLocalListOfMasters(DWORD* pcAddrCount, PIP_ADDRESS* ppipAddrs);

	// editing API's for special record types

	// SOA record (edit only, cannot delete or create)
	BOOL				HasSOARecord() { return m_pSOARecordNode != NULL; }
	CDNS_SOA_Record*	GetSOARecordCopy();
	DNS_STATUS			UpdateSOARecord(CDNS_SOA_Record* pNewRecord,
							CComponentDataObject* pComponentData);

	// WINS record
	BOOL				HasWinsRecord() { return (m_pWINSRecordNode != NULL);}
	CDNSRecord*			GetWINSRecordCopy();
	
	DNS_STATUS			CreateWINSRecord(CDNSRecord* pNewWINSRecord,
										CComponentDataObject* pComponentData);
	DNS_STATUS			UpdateWINSRecord(CDNSRecord* pNewWINSRecord,
										CComponentDataObject* pComponentData);
	DNS_STATUS			DeleteWINSRecord(CComponentDataObject* pComponentData);

	DNS_STATUS Delete(BOOL bDeleteFromDs);

protected:
	virtual void OnHaveData(CObjBase* pObj, CComponentDataObject* pComponentDataObject);
	// called by OnHaveData() to set cached RR ptrs and generally preprocess RR's
	virtual void OnHaveRecord(CDNSRecordNodeBase* pRecordNode,
								CComponentDataObject* pComponentDataObject); 

private:
	void NullCachedPointers();
	DNS_STATUS TogglePause();

	void FreeZoneInfo();
	DNS_STATUS GetZoneInfo();
	void AttachZoneInfo(CDNSZoneInfoEx* pNewInfo);

	CDNSZoneInfoEx* m_pZoneInfoEx;
	// following members valid only when m_pZoneInfoEx->HasInfo() is FALSE
	DWORD	m_dwZoneFlags;
	WORD	m_wZoneType;

#ifdef USE_NDNC
  CString m_szPartitionName;
#endif
};

#endif // _ZONE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\zoneui.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       zoneui.cpp
//
//--------------------------------------------------------------------------


#include "preDNSsn.h"
#include <SnapBase.h>

#include "resource.h"
#include "dnsutil.h"
#include "DNSSnap.h"
#include "snapdata.h"

#include "server.h"
#include "domain.h"
#include "record.h"
#include "zone.h"

#include "ZoneUI.h"

#include "browser.h"


#ifdef DEBUG_ALLOCATOR
    #ifdef _DEBUG
    #define new DEBUG_NEW
    #undef THIS_FILE
    static char THIS_FILE[] = __FILE__;
    #endif
#endif

#ifdef USE_NDNC
///////////////////////////////////////////////////////////////////////////////
// CDNSZoneChangeReplicationScopeDialog

class CDNSZoneChangeReplicationScopeDialog : public CHelpDialog
{
public:
    CDNSZoneChangeReplicationScopeDialog(CPropertyPageHolderBase* pHolder, 
                                       ReplicationType replType,
                                       PCWSTR pszCustomScope,
                                       DWORD dwServerVersion);
  ReplicationType m_newReplType; // IN/OUT
  CString m_szCustomScope;       // IN/OUT

protected:
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    virtual void OnCancel();

  afx_msg void OnRadioChange();
  afx_msg void OnCustomComboSelChange();

  DECLARE_MESSAGE_MAP()

private:
  void SyncRadioButtons();

    ReplicationType m_replType;
  BOOL m_dwServerVersion;

    CPropertyPageHolderBase* m_pHolder;

};


CDNSZoneChangeReplicationScopeDialog::CDNSZoneChangeReplicationScopeDialog(CPropertyPageHolderBase* pHolder,
                                                                           ReplicationType replType,
                                                   PCWSTR pszCustomScope,
                                                   DWORD dwServerVersion)
            : m_pHolder(pHolder),
        m_replType(replType),
        m_newReplType(replType),
        m_szCustomScope(pszCustomScope),
        m_dwServerVersion(dwServerVersion),
        CHelpDialog(IDD_ZONE_GENERAL_CHANGE_REPLICATION, pHolder->GetComponentData())
{
    ASSERT(pHolder != NULL);
}

BEGIN_MESSAGE_MAP(CDNSZoneChangeReplicationScopeDialog, CHelpDialog)
  ON_BN_CLICKED(IDC_FOREST_RADIO, OnRadioChange)
  ON_BN_CLICKED(IDC_DOMAIN_RADIO, OnRadioChange)
  ON_BN_CLICKED(IDC_DOMAIN_DC_RADIO, OnRadioChange)
  ON_BN_CLICKED(IDC_CUSTOM_RADIO, OnRadioChange)
  ON_CBN_EDITCHANGE(IDC_CUSTOM_COMBO, OnRadioChange)
  ON_CBN_SELCHANGE(IDC_CUSTOM_COMBO, OnCustomComboSelChange)
END_MESSAGE_MAP()

void CDNSZoneChangeReplicationScopeDialog::OnRadioChange()
{
  if (SendDlgItemMessage(IDC_FOREST_RADIO, BM_GETCHECK, 0, 0) == BST_CHECKED)
  {
    m_newReplType = forest;
  }
  else if (SendDlgItemMessage(IDC_DOMAIN_RADIO, BM_GETCHECK, 0, 0) == BST_CHECKED)
  {
    m_newReplType = domain;
  }
  else if (SendDlgItemMessage(IDC_DOMAIN_DC_RADIO, BM_GETCHECK, 0, 0) == BST_CHECKED)
  {
    m_newReplType = w2k;
  }
  else if (SendDlgItemMessage(IDC_CUSTOM_RADIO, BM_GETCHECK, 0, 0) == BST_CHECKED)
  {
    m_newReplType = custom;
    LRESULT iSel = SendDlgItemMessage(IDC_CUSTOM_COMBO, CB_GETCURSEL, 0, 0);
    if (CB_ERR != iSel)
    {
      CString szTemp;
      CComboBox* pComboBox = reinterpret_cast<CComboBox*>(GetDlgItem(IDC_CUSTOM_COMBO));
      ASSERT(pComboBox);

      pComboBox->GetLBText(static_cast<int>(iSel), m_szCustomScope);
    }
  }
  else
  {
    // one of the radio buttons must be selected
    ASSERT(FALSE);
  }

  SyncRadioButtons();
}

void CDNSZoneChangeReplicationScopeDialog::SyncRadioButtons()
{
  switch (m_newReplType)
  {
  case forest:
    SendDlgItemMessage(IDC_FOREST_RADIO, BM_SETCHECK, (WPARAM)BST_CHECKED, 0);
    SendDlgItemMessage(IDC_DOMAIN_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
    SendDlgItemMessage(IDC_DOMAIN_DC_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
    SendDlgItemMessage(IDC_CUSTOM_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);

    GetDlgItem(IDC_CUSTOM_COMBO)->EnableWindow(FALSE);
    GetDlgItem(IDC_CUSTOM_STATIC)->EnableWindow(FALSE);
    break;

  case domain:
    SendDlgItemMessage(IDC_DOMAIN_RADIO, BM_SETCHECK, (WPARAM)BST_CHECKED, 0);
    SendDlgItemMessage(IDC_FOREST_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
    SendDlgItemMessage(IDC_DOMAIN_DC_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
    SendDlgItemMessage(IDC_CUSTOM_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);

    GetDlgItem(IDC_CUSTOM_COMBO)->EnableWindow(FALSE);
    GetDlgItem(IDC_CUSTOM_STATIC)->EnableWindow(FALSE);
    break;

  case w2k:
    SendDlgItemMessage(IDC_DOMAIN_DC_RADIO, BM_SETCHECK, (WPARAM)BST_CHECKED, 0);
    SendDlgItemMessage(IDC_FOREST_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
    SendDlgItemMessage(IDC_DOMAIN_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
    SendDlgItemMessage(IDC_CUSTOM_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);

    GetDlgItem(IDC_CUSTOM_COMBO)->EnableWindow(FALSE);
    GetDlgItem(IDC_CUSTOM_STATIC)->EnableWindow(FALSE);
    break;

  case custom:
    SendDlgItemMessage(IDC_CUSTOM_RADIO, BM_SETCHECK, (WPARAM)BST_CHECKED, 0);
    SendDlgItemMessage(IDC_FOREST_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
    SendDlgItemMessage(IDC_DOMAIN_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
    SendDlgItemMessage(IDC_DOMAIN_DC_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
 
    GetDlgItem(IDC_CUSTOM_COMBO)->EnableWindow(TRUE);
    GetDlgItem(IDC_CUSTOM_STATIC)->EnableWindow(TRUE);
   break;

  default:
    SendDlgItemMessage(IDC_DOMAIN_RADIO, BM_SETCHECK, (WPARAM)BST_CHECKED, 0);
    SendDlgItemMessage(IDC_FOREST_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
    SendDlgItemMessage(IDC_DOMAIN_DC_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
    SendDlgItemMessage(IDC_CUSTOM_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);

    GetDlgItem(IDC_CUSTOM_COMBO)->EnableWindow(FALSE);
    GetDlgItem(IDC_CUSTOM_STATIC)->EnableWindow(FALSE);
    break;
  }

  if (BST_CHECKED == SendDlgItemMessage(IDC_CUSTOM_RADIO, BM_GETCHECK, 0, 0))
  {
    CString szTemp;
    GetDlgItemText(IDC_CUSTOM_COMBO, szTemp);
    GetDlgItem(IDOK)->EnableWindow(!szTemp.IsEmpty());
  }
  else
  {
    GetDlgItem(IDOK)->EnableWindow(TRUE);
  }
}

void CDNSZoneChangeReplicationScopeDialog::OnCustomComboSelChange()
{
  LRESULT iSel = SendDlgItemMessage(IDC_CUSTOM_COMBO, CB_GETCURSEL, 0, 0);
  if (CB_ERR != iSel)
  {
    CComboBox* pComboBox = reinterpret_cast<CComboBox*>(GetDlgItem(IDC_CUSTOM_COMBO));
    ASSERT(pComboBox);

    pComboBox->GetLBText(static_cast<int>(iSel), m_szCustomScope);
    GetDlgItem(IDOK)->EnableWindow(!m_szCustomScope.IsEmpty());
  }
  else
  {
    GetDlgItem(IDOK)->EnableWindow(FALSE);
  }
}

BOOL CDNSZoneChangeReplicationScopeDialog::OnInitDialog()
{
    CHelpDialog::OnInitDialog();
    m_pHolder->PushDialogHWnd(GetSafeHwnd());

    CDNSZonePropertyPageHolder* pHolder = (CDNSZonePropertyPageHolder*)m_pHolder;
  CDNSServerNode* pServerNode = pHolder->GetZoneNode()->GetServerNode();

  //
  // We should only reach this dialog if we are on a Whistler or greater server
  //
  ASSERT(DNS_SRV_BUILD_NUMBER(m_dwServerVersion) >= DNS_SRV_BUILD_NUMBER_WHISTLER &&
         (DNS_SRV_MAJOR_VERSION(m_dwServerVersion) > DNS_SRV_MAJOR_VERSION_NT_5 ||
          DNS_SRV_MINOR_VERSION(m_dwServerVersion) >= DNS_SRV_MINOR_VERSION_WHISTLER));

  USES_CONVERSION;

  //
  // Get the forest and domain names and format them into the UI
  //

  PCWSTR pszDomainName = UTF8_TO_W(pServerNode->GetDomainName());
  PCWSTR pszForestName = UTF8_TO_W(pServerNode->GetForestName());

  ASSERT(pszDomainName);
  ASSERT(pszForestName);

  CString szWin2KReplText;
  szWin2KReplText.Format(IDS_ZWIZ_AD_REPL_FORMAT, pszDomainName);
  SetDlgItemText(IDC_DOMAIN_DC_RADIO, szWin2KReplText);

  CString szDNSDomainText;
  szDNSDomainText.Format(IDS_ZWIZ_AD_DOMAIN_FORMAT, pszDomainName);
  SetDlgItemText(IDC_DOMAIN_RADIO, szDNSDomainText);

  CString szDNSForestText;
  szDNSForestText.Format(IDS_ZWIZ_AD_FOREST_FORMAT, pszForestName);
  SetDlgItemText(IDC_FOREST_RADIO, szDNSForestText);

  //
  // Enumerate the available directory partitions
  //
  PDNS_RPC_DP_LIST pDirectoryPartitions = NULL;
  DWORD dwErr = ::DnssrvEnumDirectoryPartitions(pServerNode->GetRPCName(),
                                                DNS_DP_ENLISTED,
                                                &pDirectoryPartitions);

  //
  // Don't show an error if we are not able to get the available directory partitions
  // We can still continue on and the user can type in the directory partition they need
  //
  bool bCustomPartitionAdded = false;

  if (dwErr == 0 && pDirectoryPartitions)
  {
    for (DWORD dwIdx = 0; dwIdx < pDirectoryPartitions->dwDpCount; dwIdx++)
    {
      PDNS_RPC_DP_INFO pDirectoryPartition = 0;
      dwErr = ::DnssrvDirectoryPartitionInfo(pServerNode->GetRPCName(),
                                             pDirectoryPartitions->DpArray[dwIdx]->pszDpFqdn,
                                             &pDirectoryPartition);
      if (dwErr == 0 &&
          pDirectoryPartition)
      {
        //
        // Only add the partition if it is not one of the autocreated ones
        // and the DNS server is enlisted in the partition
        //
        if (!(pDirectoryPartition->dwFlags & DNS_DP_AUTOCREATED) &&
            (pDirectoryPartition->dwFlags & DNS_DP_ENLISTED))
        {
          SendDlgItemMessage(IDC_CUSTOM_COMBO, 
                             CB_ADDSTRING, 
                             0, 
                             (LPARAM)UTF8_TO_W(pDirectoryPartition->pszDpFqdn));

          bCustomPartitionAdded = true;
        }
        ::DnssrvFreeDirectoryPartitionInfo(pDirectoryPartition);
      }
    }

    ::DnssrvFreeDirectoryPartitionList(pDirectoryPartitions);
  }

  if (!bCustomPartitionAdded)
  {
     GetDlgItem(IDC_CUSTOM_RADIO)->EnableWindow(FALSE);
  }

  //
  // Select the correct partition if we are using a custom partition
  //
  if (m_replType == custom)
  {
    LRESULT lIdx = SendDlgItemMessage(IDC_CUSTOM_COMBO, 
                                      CB_FINDSTRINGEXACT, 
                                      (WPARAM)-1, 
                                      (LPARAM)(PCWSTR)m_szCustomScope);
    if (lIdx != CB_ERR)
    {
      SendDlgItemMessage(IDC_CUSTOM_COMBO,
                         CB_SETCURSEL,
                         (WPARAM)lIdx,
                         0);
    }
    else
    {
      //
      // Add the partition
      //
      SendDlgItemMessage(IDC_CUSTOM_COMBO, 
                         CB_ADDSTRING, 
                         0, 
                         (LPARAM)(PCWSTR)m_szCustomScope);
    }
  }

  SyncRadioButtons();
    return TRUE;
}

void CDNSZoneChangeReplicationScopeDialog::OnCancel()
{
    if (m_pHolder != NULL)
  {
        m_pHolder->PopDialogHWnd();
  }
    CHelpDialog::OnCancel();
}

void CDNSZoneChangeReplicationScopeDialog::OnOK()
{
    if (m_pHolder != NULL)
  {
        m_pHolder->PopDialogHWnd();
  }
    CHelpDialog::OnOK();
}
#endif // USE_NDNC

///////////////////////////////////////////////////////////////////////////////
// CDNSZoneChangeTypeDialog

class CDNSZoneChangeTypeDialog : public CHelpDialog
{
public:
    CDNSZoneChangeTypeDialog(CPropertyPageHolderBase* pHolder, 
                           BOOL bServerADSEnabled,
                           DWORD dwServerVersion);
    BOOL m_bIsPrimary;       // IN/OUT
    BOOL m_bDSIntegrated;    // IN/OUT
  BOOL m_bIsStub;        // IN/OUT

protected:
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    virtual void OnCancel();

  afx_msg void OnRadioChange();

  DECLARE_MESSAGE_MAP()

private:
    BOOL m_bServerADSEnabled;
  BOOL m_dwServerVersion;

    CPropertyPageHolderBase* m_pHolder;

};


CDNSZoneChangeTypeDialog::CDNSZoneChangeTypeDialog(CPropertyPageHolderBase* pHolder,
                                                                           BOOL bServerADSEnabled,
                                                   DWORD dwServerVersion)
            : CHelpDialog(IDD_ZONE_GENERAL_CHANGE_TYPE, pHolder->GetComponentData())
{
    ASSERT(pHolder != NULL);
    m_pHolder = pHolder;
    m_bServerADSEnabled = bServerADSEnabled;
  m_dwServerVersion = dwServerVersion;
}

BEGIN_MESSAGE_MAP(CDNSZoneChangeTypeDialog, CHelpDialog)
  ON_BN_CLICKED(IDC_RADIO_ZONE_PRIMARY, OnRadioChange)
  ON_BN_CLICKED(IDC_RADIO_ZONE_SECONDARY, OnRadioChange)
  ON_BN_CLICKED(IDC_RADIO_ZONE_STUB, OnRadioChange)
END_MESSAGE_MAP()

void CDNSZoneChangeTypeDialog::OnRadioChange()
{
  if (SendDlgItemMessage(IDC_RADIO_ZONE_SECONDARY, BM_GETCHECK, 0, 0) == BST_CHECKED)
  {
    SendDlgItemMessage(IDC_ADINT_CHECK, BM_SETCHECK, BST_UNCHECKED, 0);
    GetDlgItem(IDC_ADINT_CHECK)->EnableWindow(FALSE);
  }
  else
  {
    if (m_bServerADSEnabled)
    {
      GetDlgItem(IDC_ADINT_CHECK)->EnableWindow(TRUE);
    }
    else
    {
      GetDlgItem(IDC_ADINT_CHECK)->EnableWindow(FALSE);
    }
  }
}

BOOL CDNSZoneChangeTypeDialog::OnInitDialog()
{
    CHelpDialog::OnInitDialog();
    m_pHolder->PushDialogHWnd(GetSafeHwnd());

    GetDlgItem(IDC_ADINT_CHECK)->EnableWindow(m_bServerADSEnabled);

    int nIDCheckButton;
    if (m_bIsPrimary)
  {
    nIDCheckButton = IDC_RADIO_ZONE_PRIMARY;
  }
    else
    {
    if (m_bIsStub)
    {
      nIDCheckButton = IDC_RADIO_ZONE_STUB;
    }
    else
    {
        nIDCheckButton = IDC_RADIO_ZONE_SECONDARY;
      GetDlgItem(IDC_ADINT_CHECK)->EnableWindow(FALSE);
    }
    }
    CheckRadioButton(IDC_RADIO_ZONE_PRIMARY, IDC_RADIO_ZONE_STUB, nIDCheckButton);
  SendDlgItemMessage(IDC_ADINT_CHECK, BM_SETCHECK, m_bDSIntegrated, 0);

  if (DNS_SRV_BUILD_NUMBER(m_dwServerVersion) < DNS_SRV_BUILD_NUMBER_WHISTLER ||
      (DNS_SRV_MAJOR_VERSION(m_dwServerVersion) <= DNS_SRV_MAJOR_VERSION_NT_5 &&
       DNS_SRV_MINOR_VERSION(m_dwServerVersion) < DNS_SRV_MINOR_VERSION_WHISTLER))
  {
    //
    // Stub zones not available on pre-Whistler servers
    //
    GetDlgItem(IDC_RADIO_ZONE_STUB)->EnableWindow(FALSE);
    GetDlgItem(IDC_STUB_STATIC)->EnableWindow(FALSE);
  }
    return TRUE;
}

void CDNSZoneChangeTypeDialog::OnCancel()
{
    if (m_pHolder != NULL)
  {
        m_pHolder->PopDialogHWnd();
  }
    CHelpDialog::OnCancel();
}

void CDNSZoneChangeTypeDialog::OnOK()
{
    BOOL bIsPrimary = TRUE;
    BOOL bDSIntegrated = TRUE;
  BOOL bIsStub = FALSE;

    int nIDCheckButton = GetCheckedRadioButton(IDC_RADIO_ZONE_PRIMARY, IDC_RADIO_ZONE_STUB);
    switch (nIDCheckButton)
    {
      case IDC_RADIO_ZONE_PRIMARY:
          bIsPrimary    = TRUE;
      bIsStub       = FALSE;
          break;
      case IDC_RADIO_ZONE_SECONDARY:
          bIsPrimary    = FALSE;
      bIsStub       = FALSE;
          break;
    case IDC_RADIO_ZONE_STUB:
      bIsPrimary    = FALSE;
      bIsStub       = TRUE;
      break;
      default:
          ASSERT(FALSE);
      break;
    }

  bDSIntegrated = static_cast<BOOL>(SendDlgItemMessage(IDC_ADINT_CHECK, BM_GETCHECK, 0, 0));
  //
    // warnings on special transitions
  //
    if (m_bDSIntegrated && !bDSIntegrated)
    {
    //
    // warning changing from DS integrated to something else
    //
        if (IDYES != DNSMessageBox(IDS_MSG_ZONE_WARNING_CHANGE_TYPE_FROM_DS,MB_YESNO))
    {
            return;
    }
  } 
  else if (!m_bDSIntegrated && bDSIntegrated)
    {
    //
    // warning changing from primary to DS integrated primary
    //
        if (IDYES != DNSMessageBox(IDS_MSG_ZONE_WARNING_CHANGE_TYPE_TO_DS,MB_YESNO))
    {
            return;
    }
    }

    m_bIsPrimary    = bIsPrimary;
    m_bDSIntegrated = bDSIntegrated;
  m_bIsStub       = bIsStub;

    if (m_pHolder != NULL)
  {
        m_pHolder->PopDialogHWnd();
  }
    CHelpDialog::OnOK();
}

///////////////////////////////////////////////////////////////////////////////
// CDNSZoneChangeTypeDataConflict

class CDNSZoneChangeTypeDataConflict : public CHelpDialog
{
public:
    CDNSZoneChangeTypeDataConflict(CPropertyPageHolderBase* pHolder);
    BOOL m_bUseDsData;       // IN/OUT
protected:
    virtual BOOL OnInitDialog();
    virtual void OnOK();
  virtual void OnCancel();

private:
  CPropertyPageHolderBase* m_pHolder;
};


CDNSZoneChangeTypeDataConflict::CDNSZoneChangeTypeDataConflict(
                                CPropertyPageHolderBase* pHolder)
            : CHelpDialog(IDD_ZONE_GENERAL_CHANGE_TYPE_DATA_CONFLICT, pHolder->GetComponentData())
{
  m_pHolder = pHolder;
  m_bUseDsData = FALSE;
}

BOOL CDNSZoneChangeTypeDataConflict::OnInitDialog()
{
    CHelpDialog::OnInitDialog();
    m_pHolder->PushDialogHWnd(GetSafeHwnd());

    CheckRadioButton(IDC_RADIO_USE_DS_DATA, IDC_RADIO_USE_MEM_DATA, 
        m_bUseDsData ? IDC_RADIO_USE_DS_DATA : IDC_RADIO_USE_MEM_DATA);

    return TRUE;
}

void CDNSZoneChangeTypeDataConflict::OnCancel()
{
    if (m_pHolder != NULL)
        m_pHolder->PopDialogHWnd();
    CHelpDialog::OnCancel();
}

void CDNSZoneChangeTypeDataConflict::OnOK()
{
    int nIDCheckButton = GetCheckedRadioButton(
              IDC_RADIO_USE_DS_DATA, IDC_RADIO_USE_MEM_DATA);
    m_bUseDsData =  (nIDCheckButton == IDC_RADIO_USE_DS_DATA);

  if (m_pHolder != NULL)
        m_pHolder->PopDialogHWnd();
    CHelpDialog::OnOK();
}



///////////////////////////////////////////////////////////////////////////////
// CDNSZoneNotifyDialog

class CDNSZoneNotifyDialog : public CHelpDialog
{
public:
    CDNSZoneNotifyDialog(CDNSZone_ZoneTransferPropertyPage* pPage, BOOL bSecondaryZone, 
                       CComponentDataObject* pComponentData);

protected:
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    virtual void OnCancel();

  afx_msg void OnRadioNotifyOff() { SyncUIRadioHelper(IDC_CHECK_AUTO_NOTIFY);}
  afx_msg void OnRadioNotifyAll() { SyncUIRadioHelper(IDC_RADIO_NOTIFY_ALL);}
  afx_msg void OnRadioNotifyList() { SyncUIRadioHelper(IDC_RADIO_NOTIFY_LIST);}

  DECLARE_MESSAGE_MAP()

private:
  void SyncUIRadioHelper(UINT nRadio);
  int SetRadioState(DWORD fNotifyFlag);
  DWORD GetRadioState();
  
  CDNSZone_ZoneTransferPropertyPage* m_pPage;
  BOOL m_bSecondaryZone;

    class CDNSNotifyIPEditor : public CIPEditor
    {
    public:
        CDNSNotifyIPEditor() : CIPEditor(TRUE) {} // no up/down buttons
        virtual void OnChangeData();
    };
    CDNSNotifyIPEditor m_notifyListEditor;
    friend class CDNSNotifyIPEditor;

  CComponentDataObject* m_pComponentData;
};


BEGIN_MESSAGE_MAP(CDNSZoneNotifyDialog, CHelpDialog)
  ON_BN_CLICKED(IDC_CHECK_AUTO_NOTIFY, OnRadioNotifyOff)
  ON_BN_CLICKED(IDC_RADIO_NOTIFY_ALL, OnRadioNotifyAll)
  ON_BN_CLICKED(IDC_RADIO_NOTIFY_LIST, OnRadioNotifyList)
END_MESSAGE_MAP()

void CDNSZoneNotifyDialog::CDNSNotifyIPEditor::OnChangeData()
{
  CWnd* pWnd = GetParentWnd();
  pWnd->GetDlgItem(IDOK)->EnableWindow(TRUE); // it is dirty now
}



CDNSZoneNotifyDialog::CDNSZoneNotifyDialog(CDNSZone_ZoneTransferPropertyPage* pPage,
                                           BOOL bSecondaryZone,
                                           CComponentDataObject* pComponentData)
            : CHelpDialog(IDD_ZONE_NOTIFY_SUBDIALOG, pComponentData)
{
  m_pPage = pPage;
  m_bSecondaryZone = bSecondaryZone;
  m_pComponentData = pComponentData;
}

BOOL CDNSZoneNotifyDialog::OnInitDialog()
{
    CHelpDialog::OnInitDialog();
    m_pPage->GetHolder()->PushDialogHWnd(GetSafeHwnd());

    VERIFY(m_notifyListEditor.Initialize(this, 
                                       this,
                                       IDC_BUTTON_UP, 
                                       IDC_BUTTON_DOWN,
                                                           IDC_BUTTON_ADD, 
                                       IDC_BUTTON_REMOVE, 
                                                           IDC_IPEDIT, 
                                       IDC_LIST));

  if (m_bSecondaryZone)
  {
    ASSERT(m_pPage->m_fNotifyLevel != ZONE_NOTIFY_ALL);
    GetDlgItem(IDC_RADIO_NOTIFY_ALL)->EnableWindow(FALSE);
  }

  // read the state and set the UI
    if ( (ZONE_NOTIFY_LIST == m_pPage->m_fNotifyLevel) && (m_pPage->m_cNotify > 0) )
    {
        m_notifyListEditor.AddAddresses(m_pPage->m_aipNotify, m_pPage->m_cNotify); 
    }

  SyncUIRadioHelper(SetRadioState(m_pPage->m_fNotifyLevel));

  GetDlgItem(IDOK)->EnableWindow(FALSE); // not dirty

  BOOL bListState = ((CButton*)GetDlgItem(IDC_RADIO_NOTIFY_LIST))->GetCheck();
  BOOL bAllState = ((CButton*)GetDlgItem(IDC_RADIO_NOTIFY_ALL))->GetCheck();
  if (!bAllState && !bListState)
  {
    ((CButton*)GetDlgItem(IDC_RADIO_NOTIFY_LIST))->SetCheck(TRUE);
  }
    return TRUE;
}


void CDNSZoneNotifyDialog::OnCancel()
{
    if (m_pPage->GetHolder() != NULL)
        m_pPage->GetHolder()->PopDialogHWnd();
    CHelpDialog::OnCancel();
}

void CDNSZoneNotifyDialog::OnOK()
{
  // read the data back to the main page storage

  m_pPage->m_fNotifyLevel = GetRadioState();

  m_pPage->m_cNotify = 0;
  if (m_pPage->m_aipNotify != NULL)
  {
    free(m_pPage->m_aipNotify);
    m_pPage->m_aipNotify = NULL;
  }

  if (m_pPage->m_fNotifyLevel == ZONE_NOTIFY_LIST)
  {
      m_pPage->m_cNotify = m_notifyListEditor.GetCount();
      if (m_pPage->m_cNotify > 0)
      {
      m_pPage->m_aipNotify = (DWORD*) malloc(sizeof(DWORD)*m_pPage->m_cNotify);
          int nFilled = 0;
      if (m_pPage->m_aipNotify != NULL)
      {
            m_notifyListEditor.GetAddresses(m_pPage->m_aipNotify, m_pPage->m_cNotify, &nFilled);
      }
          ASSERT(nFilled == (int)m_pPage->m_cNotify);
      }
  }

  // dismiss dialog, all cool
    if (m_pPage->GetHolder())
        m_pPage->GetHolder()->PopDialogHWnd();
    CHelpDialog::OnOK();
}


void CDNSZoneNotifyDialog::SyncUIRadioHelper(UINT nRadio)
{
  m_notifyListEditor.EnableUI(IDC_RADIO_NOTIFY_LIST == nRadio, TRUE);
//  if (IDC_RADIO_NOTIFY_LIST != nRadio)
//    m_notifyListEditor.Clear();

  GetDlgItem(IDOK)->EnableWindow(TRUE); //  dirty

  if (IDC_CHECK_AUTO_NOTIFY == nRadio)
  {
    BOOL bState = ((CButton*)GetDlgItem(IDC_CHECK_AUTO_NOTIFY))->GetCheck();
    ((CButton*)GetDlgItem(IDC_RADIO_NOTIFY_LIST))->EnableWindow(bState);
    ((CButton*)GetDlgItem(IDC_RADIO_NOTIFY_ALL))->EnableWindow(bState);
    BOOL bRadioState = ((CButton*)GetDlgItem(IDC_RADIO_NOTIFY_LIST))->GetCheck();
    m_notifyListEditor.EnableUI(bRadioState && bState, TRUE);
  } 
}

int CDNSZoneNotifyDialog::SetRadioState(DWORD fNotifyLevel)
{
  int nRadio = 0;
  switch (fNotifyLevel)
  {
    case ZONE_NOTIFY_OFF:
      nRadio = IDC_CHECK_AUTO_NOTIFY;
      ((CButton*)GetDlgItem(IDC_CHECK_AUTO_NOTIFY))->SetCheck(FALSE);
      break;
    case ZONE_NOTIFY_LIST:
      nRadio = IDC_RADIO_NOTIFY_LIST;
      ((CButton*)GetDlgItem(nRadio))->SetCheck(TRUE);
      ((CButton*)GetDlgItem(IDC_CHECK_AUTO_NOTIFY))->SetCheck(TRUE);
      break;
    case ZONE_NOTIFY_ALL:
      nRadio = IDC_RADIO_NOTIFY_ALL;
      ((CButton*)GetDlgItem(nRadio))->SetCheck(TRUE);
      ((CButton*)GetDlgItem(IDC_CHECK_AUTO_NOTIFY))->SetCheck(TRUE);
      break;
  }
  ASSERT(nRadio != 0);
  return nRadio;
}

DWORD CDNSZoneNotifyDialog::GetRadioState()
{
  static int nRadioArr[] =
  {
    IDC_RADIO_NOTIFY_OFF,
    IDC_RADIO_NOTIFY_LIST,
    IDC_RADIO_NOTIFY_ALL
  };

  int nRadio = 0;
  if (!((CButton*)GetDlgItem(IDC_CHECK_AUTO_NOTIFY))->GetCheck())
  {
    nRadio = IDC_CHECK_AUTO_NOTIFY;
  }
  else
  {
    if (((CButton*)GetDlgItem(IDC_RADIO_NOTIFY_LIST))->GetCheck())
    {
      nRadio = IDC_RADIO_NOTIFY_LIST;
    }
    else if (((CButton*)GetDlgItem(IDC_RADIO_NOTIFY_ALL))->GetCheck())
    {
      nRadio = IDC_RADIO_NOTIFY_ALL;
    }
  }

//  int nRadio = ::GetCheckedRadioButtonHelper(m_hWnd, 3, nRadioArr, IDC_RADIO_NOTIFY_OFF);
  ASSERT(nRadio != 0);
  DWORD fNotifyLevel = (DWORD)-1;
  switch (nRadio)
  {
    case IDC_CHECK_AUTO_NOTIFY:
      fNotifyLevel = ZONE_NOTIFY_OFF;
      break;
    case IDC_RADIO_NOTIFY_LIST:
      fNotifyLevel = ZONE_NOTIFY_LIST;
      break;
    case IDC_RADIO_NOTIFY_ALL:
      fNotifyLevel = ZONE_NOTIFY_ALL;
      break;
  }
  ASSERT(fNotifyLevel != (DWORD)-1);
  return fNotifyLevel;
}

///////////////////////////////////////////////////////////////////////////////
// CDNSZone_GeneralPropertyPage

//
// defines for the status text string positions (matching the RC file)
//
#define N_ZONE_STATES                 3
#define N_ZONE_STATUS_RUNNING     0
#define N_ZONE_STATUS_PAUSED      1
#define N_ZONE_STATUS_EXPIRED     2

#define N_ZONE_TYPES                  4
#define N_ZONE_TYPES_PRIMARY      0
#define N_ZONE_TYPES_DS_PRIMARY 1
#define N_ZONE_TYPES_SECONDARY  2
#define N_ZONE_TYPES_STUB       3


void CDNSZone_GeneralIPEditor::OnChangeData()
{
    if (m_bNoUpdateNow)
  {
        return;
  }
    ((CDNSZone_GeneralPropertyPage*)GetParentWnd())->OnChangeIPEditorData();
}

void CDNSZone_GeneralIPEditor::FindMastersNames()
{
    m_bNoUpdateNow = TRUE;
    FindNames();
    m_bNoUpdateNow = FALSE;
}


BEGIN_MESSAGE_MAP(CDNSZone_GeneralPropertyPage, CPropertyPageBase)
    ON_BN_CLICKED(IDC_CHANGE_TYPE_BUTTON, OnChangeTypeButton)
#ifdef USE_NDNC
  ON_BN_CLICKED(IDC_CHANGE_REPL_BUTTON, OnChangeReplButton)
#endif // USE_NDNC
    ON_BN_CLICKED(IDC_PAUSE_START_BUTTON, OnPauseStartButton)
    ON_EN_CHANGE(IDC_FILE_NAME_EDIT, OnChangePrimaryFileNameEdit)
    ON_CBN_SELCHANGE(IDC_PRIMARY_DYN_UPD_COMBO, OnChangePrimaryDynamicUpdateCombo)
    ON_BN_CLICKED(IDC_BROWSE_MASTERS_BUTTON, OnBrowseMasters)
    ON_BN_CLICKED(IDC_FIND_MASTERS_NAMES_BUTTON, OnFindMastersNames)
  ON_BN_CLICKED(IDC_AGING_BUTTON, OnAging)
  ON_BN_CLICKED(IDC_LOCAL_LIST_CHECK, OnLocalCheck)
END_MESSAGE_MAP()


CDNSZone_GeneralPropertyPage::CDNSZone_GeneralPropertyPage() 
                : CPropertyPageBase(CDNSZone_GeneralPropertyPage::IDD),
                m_statusHelper(N_ZONE_STATES), m_typeStaticHelper(N_ZONE_TYPES)

{
    // actual values will be set when loading UI data
    m_bIsPrimary          = TRUE;
    m_bIsPaused           = FALSE;
    m_bIsExpired          = FALSE;
    m_bDSIntegrated       = FALSE;
  m_bIsStub             = FALSE;
    m_bServerADSEnabled   = FALSE; 
  m_bScavengingEnabled  = FALSE;
  m_dwRefreshInterval   = 0;
  m_dwNoRefreshInterval = 0;
    m_nAllowsDynamicUpdate = ZONE_UPDATE_OFF;

  m_bDiscardUIState     = FALSE;
  m_bDiscardUIStateShowMessage = FALSE;
#ifdef USE_NDNC
  m_replType            = none;
#endif // USE_NDNC
}

void CDNSZone_GeneralPropertyPage::OnChangeIPEditorData()
{
    ASSERT(!m_bIsPrimary);
    SetDirty(TRUE);
    GetFindMastersNamesButton()->EnableWindow(m_mastersEditor.GetCount()>0);
}

BOOL CDNSZone_GeneralPropertyPage::OnPropertyChange(BOOL, long*)
{
    CDNSZonePropertyPageHolder* pHolder = (CDNSZonePropertyPageHolder*)GetHolder();
    CDNSZoneNode* pZoneNode = pHolder->GetZoneNode();

    // need to apply the pause/start zone command ?
    BOOL bWasPaused = pZoneNode->IsPaused();
    if (bWasPaused != m_bIsPaused)
    {
        DNS_STATUS err = pZoneNode->TogglePauseHelper(pHolder->GetComponentData());
        if (err != 0)
            pHolder->SetError(err);
    }

    if (pZoneNode->GetZoneType() == DNS_ZONE_TYPE_SECONDARY ||
        pZoneNode->GetZoneType() == DNS_ZONE_TYPE_STUB)
    {
       // NTRAID#NTBUG9-762897-2003/01/16-JeffJon
       // Need to update the result pane view because changing stub
       // and secondary zones can easily put the zone in an expired
       // state which requires us to show the message view instead
       // of the normal result pane.

       pZoneNode->ToggleView(pHolder->GetComponentData());
    }
    return TRUE;
}


void CDNSZone_GeneralPropertyPage::SetUIData()
{
    CDNSZonePropertyPageHolder* pHolder = (CDNSZonePropertyPageHolder*)GetHolder();
    CDNSZoneNode* pZoneNode = pHolder->GetZoneNode();
  CDNSServerNode* pServerNode = pZoneNode->GetServerNode();

  //
    // get zone type
  //
    DWORD dwZoneType = pZoneNode->GetZoneType();
    ASSERT((dwZoneType == DNS_ZONE_TYPE_PRIMARY)  || 
               (dwZoneType == DNS_ZONE_TYPE_SECONDARY)||
         (dwZoneType == DNS_ZONE_TYPE_STUB));
    m_bIsPrimary = (dwZoneType == DNS_ZONE_TYPE_PRIMARY);
  m_bIsStub    = (dwZoneType == DNS_ZONE_TYPE_STUB);

    m_bDSIntegrated = pZoneNode->IsDSIntegrated();
    m_bIsPaused = pZoneNode->IsPaused();
    m_bIsExpired = pZoneNode->IsExpired();
  m_bScavengingEnabled = pZoneNode->IsScavengingEnabled();
    m_dwRefreshInterval = pZoneNode->GetAgingRefreshInterval();
  m_dwNoRefreshInterval = pZoneNode->GetAgingNoRefreshInterval();
  m_dwScavengingStart = pZoneNode->GetScavengingStart();
  
#ifdef USE_NDNC
  m_replType = pZoneNode->GetDirectoryPartitionFlagsAsReplType();
  m_szCustomScope = pZoneNode->GetCustomPartitionName();

  //
  // Enable the replication scope button only for AD integrated zones
  //
  if (m_bDSIntegrated &&
      (DNS_SRV_BUILD_NUMBER(pServerNode->GetVersion()) >= DNS_SRV_BUILD_NUMBER_WHISTLER &&
       (DNS_SRV_MAJOR_VERSION(pServerNode->GetVersion()) > DNS_SRV_MAJOR_VERSION_NT_5 ||
        DNS_SRV_MINOR_VERSION(pServerNode->GetVersion()) >= DNS_SRV_MINOR_VERSION_WHISTLER)))
  {
    GetDlgItem(IDC_CHANGE_REPL_BUTTON)->EnableWindow(TRUE);
    GetDlgItem(IDC_REPL_LABEL_STATIC)->EnableWindow(TRUE);
    GetDlgItem(IDC_REPLICATION_STATIC)->EnableWindow(TRUE);
  }
  else
  {
    GetDlgItem(IDC_CHANGE_REPL_BUTTON)->EnableWindow(FALSE);
    GetDlgItem(IDC_REPL_LABEL_STATIC)->EnableWindow(FALSE);
    GetDlgItem(IDC_REPLICATION_STATIC)->EnableWindow(FALSE);
  }
#endif // USE_NDNC

  //
  // change the controls to the zone type
  //
    ChangeUIControls();

    USES_CONVERSION;

  //
    // set the file name control
  //
    CString szZoneStorage;
    szZoneStorage = UTF8_TO_W(pZoneNode->GetDataFile());
    
    if (m_bIsPrimary)
    {
        m_nAllowsDynamicUpdate = pZoneNode->GetDynamicUpdate();
  }
    else // secondary
    {
        DWORD cAddrCount;
        PIP_ADDRESS pipMasters;

    if (m_bIsStub)
    {
      pZoneNode->GetLocalListOfMasters(&cAddrCount, &pipMasters);
      if (cAddrCount > 0 && pipMasters != NULL)
      {
        m_mastersEditor.AddAddresses(pipMasters, cAddrCount);
        SendDlgItemMessage(IDC_LOCAL_LIST_CHECK, BM_SETCHECK, (WPARAM)BST_CHECKED, 0);
      }
      else
      {
            pZoneNode->GetMastersInfo(&cAddrCount, &pipMasters);
            if (cAddrCount > 0)
            {
                m_mastersEditor.AddAddresses(pipMasters, cAddrCount); 
            }
        SendDlgItemMessage(IDC_LOCAL_LIST_CHECK, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
      }
    }
    else
    {
          pZoneNode->GetMastersInfo(&cAddrCount, &pipMasters);
          if (cAddrCount > 0)
          {
              m_mastersEditor.AddAddresses(pipMasters, cAddrCount); 
          }
    }        
    }

  if (m_bDSIntegrated && !m_bIsStub)
  {
    GetDlgItem(IDC_AGING_STATIC)->EnableWindow(TRUE);
    GetDlgItem(IDC_AGING_STATIC)->ShowWindow(TRUE);
    GetDlgItem(IDC_AGING_BUTTON)->EnableWindow(TRUE);
    GetDlgItem(IDC_AGING_BUTTON)->ShowWindow(TRUE);
  }

  //
  // we set also the database name of the "other" zone type, just
    // in case the user promotes or demotes
  //
    GetFileNameEdit()->SetWindowText(szZoneStorage);
  SetPrimaryDynamicUpdateComboVal(m_nAllowsDynamicUpdate);
    
    if (m_bIsExpired)
    {
    //
        // hide the start/stop button
    //
        CButton* pBtn = GetPauseStartButton();
        pBtn->ShowWindow(FALSE);
        pBtn->EnableWindow(FALSE);

    //
        // change the text to "expired"
    //
        m_statusHelper.SetStateX(N_ZONE_STATUS_EXPIRED);
    }
    else
    {
    m_statusHelper.SetStateX(m_bIsPaused ? N_ZONE_STATUS_PAUSED : N_ZONE_STATUS_RUNNING);
        m_pauseStartHelper.SetToggleState(!m_bIsPaused);
    }
}

#define PRIMARY_DYN_UPD_COMBO_ITEM_COUNT        3


void _MoveChildWindowY(CWnd* pChild, CWnd* pParent, int nY)
{
    CRect r;
    pChild->GetWindowRect(r);
    pParent->ScreenToClient(r);
  int nDy = r.bottom - r.top;
    r.top = nY; 
    r.bottom = nY + nDy;
    pChild->MoveWindow(r, TRUE);
}



BOOL CDNSZone_GeneralPropertyPage::OnInitDialog() 
{
    CPropertyPageBase::OnInitDialog();

  CDNSZonePropertyPageHolder* pHolder = (CDNSZonePropertyPageHolder*)GetHolder();
    m_bServerADSEnabled = pHolder->GetZoneNode()->GetServerNode()->CanUseADS();

    VERIFY(m_mastersEditor.Initialize(this, 
                                    GetParent(),
                                    IDC_MASTERS_BUTTON_UP, 
                                    IDC_MASTERS_BUTTON_DOWN,
                                                        IDC_MASTERS_BUTTON_ADD, 
                                    IDC_MASTERS_BUTTON_REMOVE, 
                                                        IDC_MASTERS_IPEDIT, 
                                    IDC_MASTERS_IP_LIST));

    UINT pnButtonStringIDs[2] = { IDS_BUTTON_TEXT_PAUSE_BUTTON, IDS_BUTTON_TEXT_START_BUTTON };
    VERIFY(m_pauseStartHelper.Init(this, IDC_PAUSE_START_BUTTON, pnButtonStringIDs));
    VERIFY(m_typeStaticHelper.Init(this, IDC_TYPE_STATIC));
    VERIFY(m_statusHelper.Init(this, IDC_STATUS_STATIC));   
    VERIFY(m_zoneStorageStaticHelper.Init(this, IDC_STORAGE_STATIC));

  SendDlgItemMessage(IDC_FILE_NAME_EDIT, EM_SETLIMITTEXT, (WPARAM)_MAX_FNAME, 0);

  // initial positioning (in the resource these controls are at the bottom of the screen)
  // move relative the file name exit box
  CRect fileNameEditRect;
  GetDlgItem(IDC_FILE_NAME_EDIT)->GetWindowRect(fileNameEditRect);
  ScreenToClient(fileNameEditRect);

  // move below the edit box, with with separation equal of 6 (DBU)
  // height of the edit box.
  int nYPos = fileNameEditRect.bottom + 6;
  
    CComboBox* pDynamicUpdateCombo = GetPrimaryDynamicUpdateCombo();
  // The static control needs to be 2 lower
    _MoveChildWindowY(GetPrimaryDynamicUpdateStatic(), this, nYPos + 2);
    _MoveChildWindowY(pDynamicUpdateCombo, this, nYPos);

    // initialize the state of the page
    SetUIData();

#ifdef USE_NDNC
   SetTextForReplicationScope();
#endif

    SetDirty(FALSE);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


BOOL CDNSZone_GeneralPropertyPage::OnApply()
{
  if (m_bDiscardUIState)
  {
    // if we get called from other pages, we have to make them fail
    if (m_bDiscardUIStateShowMessage)
    {
      DNSMessageBox(IDS_ZONE_LOADED_FROM_DS_WARNING);
      m_bDiscardUIStateShowMessage = FALSE;
    }
    return FALSE;
  }

    if (!IsDirty())
        return TRUE;

    CDNSZonePropertyPageHolder* pHolder = (CDNSZonePropertyPageHolder*)GetHolder();
    CDNSZoneNode* pZoneNode = pHolder->GetZoneNode();
   CDNSServerNode* pServerNode = pZoneNode->GetServerNode();

  //
    // changed from primary to secondary or vice versa?
  //
    DWORD dwZoneType = pZoneNode->GetZoneType();
    ASSERT((dwZoneType == DNS_ZONE_TYPE_PRIMARY)  || 
               (dwZoneType == DNS_ZONE_TYPE_SECONDARY)||
         (dwZoneType == DNS_ZONE_TYPE_STUB));
    BOOL bWasPrimary = (dwZoneType == DNS_ZONE_TYPE_PRIMARY);

    DNS_STATUS dwErr = 0;

  USES_CONVERSION;

  CString szDataStorageName;
    GetStorageName(szDataStorageName);

    DWORD dwLoadOptions; 
    if (m_bIsPrimary)
    {
    dwLoadOptions = 0x0;
    
    PWSTR pszZoneFile = UTF8_TO_W(pZoneNode->GetDataFile());
    //
    // Check to see if this was primary before if so only submit changes if the storage changed
    //
    if (!bWasPrimary ||
        (bWasPrimary && 
        ((pZoneNode->IsDSIntegrated() && !m_bDSIntegrated) ||
         (!pZoneNode->IsDSIntegrated() && m_bDSIntegrated))) ||
        (pszZoneFile && szDataStorageName.CompareNoCase(pszZoneFile)))
    {
      dwErr = pZoneNode->SetPrimary(dwLoadOptions, m_bDSIntegrated, szDataStorageName);
      if (m_bDSIntegrated && (dwErr == DNS_ERROR_DS_ZONE_ALREADY_EXISTS)) 
      {
        FIX_THREAD_STATE_MFC_BUG();
        CThemeContextActivator activator;

        CDNSZoneChangeTypeDataConflict dlg(pHolder);

        //
        // if the zone was a primary, use in memory data
        // otherwise, use DS data
        //
        dlg.m_bUseDsData = bWasPrimary ? FALSE : TRUE;
        if (IDOK == dlg.DoModal())
        {
          //
          // try again, getting options from dialog
          //
          dwLoadOptions = dlg.m_bUseDsData ? DNS_ZONE_LOAD_OVERWRITE_MEMORY : DNS_ZONE_LOAD_OVERWRITE_DS;
            dwErr = pZoneNode->SetPrimary(dwLoadOptions, m_bDSIntegrated, szDataStorageName); 
          if ((dwErr == 0) && dlg.m_bUseDsData)
          {
            //
            // we loaded from the DS, we will have to discard all the other
            // changes the user has made.
            //
            m_bDiscardUIState = TRUE;

            //
            // tell the user to bail out
            //
            m_bDiscardUIStateShowMessage = FALSE;
            DNSMessageBox(IDS_ZONE_LOADED_FROM_DS_WARNING);
            SetDirty(FALSE);
            return TRUE;
          }
        }
        else
        {
          //
          // user canceled the operation, just stop here
          //
          return FALSE;
        }
      }
    }

        if (dwErr == 0)
        {
            // update dynamic update flag, if changed
            m_nAllowsDynamicUpdate = GetPrimaryDynamicUpdateComboVal();
            UINT nWasDynamicUpdate = pZoneNode->GetDynamicUpdate();
            if ( (dwErr == 0) && (m_nAllowsDynamicUpdate != nWasDynamicUpdate) )
            {
                dwErr = pZoneNode->SetDynamicUpdate(m_nAllowsDynamicUpdate);
                if (dwErr != 0)
                    DNSErrorDialog(dwErr, IDS_ERROR_ZONE_DYN_UPD);
            }
        }       
        else
        {
            DNSErrorDialog(dwErr, IDS_ERROR_ZONE_PRIMARY);
        }

    if (dwErr == 0 && m_bIsPrimary)
    {
      dwErr = pZoneNode->SetAgingNoRefreshInterval(m_dwNoRefreshInterval);
      if (dwErr != 0)
      {
        DNSErrorDialog(dwErr, IDS_MSG_ERROR_NO_REFRESH_INTERVAL);
        return FALSE;
      }

      dwErr = pZoneNode->SetAgingRefreshInterval(m_dwRefreshInterval);
      if (dwErr != 0)
      {
        DNSErrorDialog(dwErr, IDS_MSG_ERROR_REFRESH_INTERVAL);
        return FALSE;
      }

      dwErr = pZoneNode->SetScavengingEnabled(m_bScavengingEnabled);
      if (dwErr != 0)
      {
        DNSErrorDialog(dwErr, IDS_MSG_ERROR_SCAVENGING_ENABLED);
        return FALSE;
      }
    }
  }
  else // it is a secondary or stub
  {
        //
        // get data from the IP editor
        //
        DWORD cAddrCount = m_mastersEditor.GetCount();
        // NTRAID#NTBUG9-655784-2002/07/05-artm
        // Initialize the array.
        DWORD* pArr = (cAddrCount > 0) ? (DWORD*) calloc(cAddrCount, sizeof(DWORD)) : NULL;

        if (cAddrCount > 0)
        {
            int nFilled = 0;

            // NTRAID#NTBUG9-653630-2002/07/05-artm

            if (pArr)
            {
                m_mastersEditor.GetAddresses(pArr, cAddrCount, &nFilled);
                ASSERT(nFilled == (int)cAddrCount);
            }
            else
            {
                // Out of memory!  Try to tell the user, and abort the operation.
                dwErr = ERROR_OUTOFMEMORY;
                DNSDisplaySystemError(dwErr);
                return FALSE;
            }
        }
        dwLoadOptions = 0x0;

        if (m_bIsStub)
        {
            LRESULT lLocalListOfMasters = SendDlgItemMessage(IDC_LOCAL_LIST_CHECK, BM_GETCHECK, 0, 0);
            BOOL bLocalListOfMasters = (lLocalListOfMasters == BST_CHECKED);
            dwErr = pZoneNode->SetStub(cAddrCount, 
                                        pArr, 
                                        dwLoadOptions, 
                                        m_bDSIntegrated, 
                                        szDataStorageName, 
                                        bLocalListOfMasters);
            if (dwErr != 0)
            {
                DNSErrorDialog(dwErr, IDS_ERROR_ZONE_STUB);
            }
        }
        else
        {
            dwErr = pZoneNode->SetSecondary(cAddrCount, pArr, dwLoadOptions, szDataStorageName);
            if (dwErr != 0)
            {
                DNSErrorDialog(dwErr, IDS_ERROR_ZONE_SECONDARY);
            }
        }
        if (pArr)
        {
            free(pArr);
            pArr = 0;
        }
  }

#ifdef USE_NDNC
  if ((DNS_SRV_BUILD_NUMBER(pServerNode->GetVersion()) >= DNS_SRV_BUILD_NUMBER_WHISTLER &&
        (DNS_SRV_MAJOR_VERSION(pServerNode->GetVersion()) > DNS_SRV_MAJOR_VERSION_NT_5 ||
            DNS_SRV_MINOR_VERSION(pServerNode->GetVersion()) >= DNS_SRV_MINOR_VERSION_WHISTLER)) &&
      (m_replType != pZoneNode->GetDirectoryPartitionFlagsAsReplType() ||
       _wcsicmp(m_szCustomScope, pZoneNode->GetCustomPartitionName()) != 0) &&
      m_bDSIntegrated)
  {
    dwErr = pZoneNode->ChangeDirectoryPartitionType(m_replType, m_szCustomScope);
    if (dwErr != 0)
    {
      DNSErrorDialog(dwErr, IDS_ERROR_ZONE_REPLTYPE);
    }
  }
#endif

  // if promoted or demoted, have to change icon
  // if paused/started, have to apply the command
  BOOL bWasPaused = pZoneNode->IsPaused();
  DNS_STATUS dwPauseStopErr = 0;
  if ((bWasPrimary != m_bIsPrimary) || (bWasPaused != m_bIsPaused))
  {
    dwPauseStopErr = pHolder->NotifyConsole(this);
    if (dwPauseStopErr != 0)
    {
      if (m_bIsPaused)
        DNSErrorDialog(dwPauseStopErr, IDS_ERROR_ZONE_PAUSE);
      else
        DNSErrorDialog(dwPauseStopErr, IDS_ERROR_ZONE_START);
    }
  }

  if ( (dwErr != 0) || (dwPauseStopErr != 0) )
    return FALSE; // something went wrong, already got error messages

  // NTRAID#NTBUG9-762897-2003/01/16-JeffJon
  // Need to update the result pane view because changing stub
  // and secondary zones can easily put the zone in an expired
  // state which requires us to show the message view instead
  // of the normal result pane.

  pHolder->NotifyConsole(this);

  SetDirty(FALSE);
  return TRUE; 
}

void CDNSZone_GeneralPropertyPage::OnAging()
{
   CThemeContextActivator activator;

    CDNSZonePropertyPageHolder* pHolder = 
        (CDNSZonePropertyPageHolder*)GetHolder();

  CDNSZone_AgingDialog dlg(pHolder, IDD_ZONE_AGING_DIALOG, pHolder->GetComponentData());

  dlg.m_dwRefreshInterval = m_dwRefreshInterval;
  dlg.m_dwNoRefreshInterval = m_dwNoRefreshInterval;
  dlg.m_dwScavengingStart = m_dwScavengingStart;
  dlg.m_fScavengingEnabled = m_bScavengingEnabled;
  dlg.m_bAdvancedView = pHolder->IsAdvancedView();

  if (IDCANCEL == dlg.DoModal())
  {
    return;
  }

  m_dwRefreshInterval = dlg.m_dwRefreshInterval;
  m_dwNoRefreshInterval = dlg.m_dwNoRefreshInterval;
  m_bScavengingEnabled = dlg.m_fScavengingEnabled;
  SetDirty(TRUE);
}

void CDNSZone_GeneralPropertyPage::OnLocalCheck()
{
  SetDirty(TRUE);
}

#ifdef USE_NDNC
void CDNSZone_GeneralPropertyPage::OnChangeReplButton()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
  FIX_THREAD_STATE_MFC_BUG();
   CThemeContextActivator activator;


    CDNSZonePropertyPageHolder* pHolder = (CDNSZonePropertyPageHolder*)GetHolder();
    CDNSZoneNode* pZoneNode = pHolder->GetZoneNode();

    CDNSZoneChangeReplicationScopeDialog dlg(GetHolder(), 
                                           m_replType,
                                           m_szCustomScope,
                                           pZoneNode->GetServerNode()->GetVersion());

    if (IDCANCEL == dlg.DoModal())
  {
        return; 
  }

    BOOL bDirty = (m_replType != dlg.m_newReplType) ||
                (m_szCustomScope != dlg.m_szCustomScope);
    if (!bDirty)
  {
        return;
  }

  m_replType = dlg.m_newReplType;
  m_szCustomScope = dlg.m_szCustomScope;

  SetTextForReplicationScope();

  SetDirty(TRUE);
}

void CDNSZone_GeneralPropertyPage::SetTextForReplicationScope()
{
   CDNSZonePropertyPageHolder* pHolder = (CDNSZonePropertyPageHolder*)GetHolder();
   CDNSZoneNode* pZoneNode = pHolder->GetZoneNode();
   CDNSServerNode* pServerNode = pZoneNode->GetServerNode();
  
   UINT nStringID = 0;

  CString szReplText;
  if (m_bDSIntegrated)
  {
    switch(m_replType)
    {
      case domain :
        nStringID = IDS_ZONE_REPLICATION_DOMAIN_TEXT;
        break;

      case forest :
        nStringID = IDS_ZONE_REPLICATION_FOREST_TEXT;
        break;

      case custom :
        nStringID = IDS_ZONE_REPLICATION_CUSTOM_TEXT;
        break;

      default :
        nStringID = IDS_ZONE_REPLICATION_W2K_TEXT;
        break;
    }

    if (m_bDSIntegrated &&
        (DNS_SRV_BUILD_NUMBER(pServerNode->GetVersion()) >= DNS_SRV_BUILD_NUMBER_WHISTLER &&
        (DNS_SRV_MAJOR_VERSION(pServerNode->GetVersion()) > DNS_SRV_MAJOR_VERSION_NT_5 ||
            DNS_SRV_MINOR_VERSION(pServerNode->GetVersion()) >= DNS_SRV_MINOR_VERSION_WHISTLER)))
    {
        GetDlgItem(IDC_CHANGE_REPL_BUTTON)->EnableWindow(TRUE);
        GetDlgItem(IDC_REPL_LABEL_STATIC)->EnableWindow(TRUE);
        GetDlgItem(IDC_REPLICATION_STATIC)->EnableWindow(TRUE);
    }
  }
  else
  {
    nStringID = IDS_ZONE_REPLICATION_NONDS_TEXT;
    GetDlgItem(IDC_CHANGE_REPL_BUTTON)->EnableWindow(FALSE);
    GetDlgItem(IDC_REPL_LABEL_STATIC)->EnableWindow(FALSE);
    GetDlgItem(IDC_REPLICATION_STATIC)->EnableWindow(FALSE);
  }

  szReplText.LoadString(nStringID);
  SetDlgItemText(IDC_REPLICATION_STATIC, szReplText);
}
#endif // USE_NDNC

void CDNSZone_GeneralPropertyPage::OnChangeTypeButton()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
  FIX_THREAD_STATE_MFC_BUG();
   CThemeContextActivator activator;


    CDNSZonePropertyPageHolder* pHolder = (CDNSZonePropertyPageHolder*)GetHolder();
    CDNSZoneNode* pZoneNode = pHolder->GetZoneNode();

    CDNSZoneChangeTypeDialog dlg(GetHolder(), 
                               m_bServerADSEnabled, 
                               pZoneNode->GetServerNode()->GetVersion());

    dlg.m_bIsPrimary    = m_bIsPrimary;
  dlg.m_bIsStub       = m_bIsStub;
    dlg.m_bDSIntegrated = m_bDSIntegrated;

    if (IDCANCEL == dlg.DoModal())
  {
        return; 
  }

    BOOL bDirty = (m_bIsPrimary != dlg.m_bIsPrimary)        || 
                          (m_bDSIntegrated != dlg.m_bDSIntegrated)  ||
                (m_bIsStub != dlg.m_bIsStub);
    if (!bDirty)
  {
        return;
  }


    CString szZoneStorage;
    GetFileNameEdit()->GetWindowText(szZoneStorage);

    if (dlg.m_bDSIntegrated == FALSE  && 
          m_bDSIntegrated == TRUE       &&
          szZoneStorage.IsEmpty())
    {
    //
        // we have no file name, synthesize one
    //
        CString szZoneName = pZoneNode->GetDisplayName();
        int nLen = szZoneName.GetLength();
        if (nLen == 0)
        {
            szZoneStorage.Empty();
        }
        else if (nLen == 1 && szZoneName[0] == TEXT('.'))
        {
            szZoneStorage = _T("root.dns");
        }
        else
        {
            LPCTSTR lpszFmt = ( TEXT('.') == szZoneName.GetAt(nLen-1)) 
                    ? _T("%sdns") : _T("%s.dns");
            szZoneStorage.Format(lpszFmt, (LPCTSTR)szZoneName);
        }
        GetFileNameEdit()->SetWindowText(szZoneStorage);
    }
   else if (dlg.m_bDSIntegrated == TRUE &&
            m_bDSIntegrated == FALSE)
   {
      //
      // Set the default replication
      // if the zone was previously file based
      //
      if (pZoneNode->GetServerNode()->GetDomainVersion() > DS_BEHAVIOR_WIN2000)
      {
         m_replType = domain;
      }
      else
      {
         m_replType = w2k;
      }
   }

    m_bIsPrimary    = dlg.m_bIsPrimary;
    m_bDSIntegrated = dlg.m_bDSIntegrated;
  m_bIsStub       = dlg.m_bIsStub;

    SetDirty(TRUE);
    ChangeUIControls();

#ifdef USE_NDNC
   SetTextForReplicationScope();
#endif
}

void CDNSZone_GeneralPropertyPage::OnPauseStartButton()
{
    ASSERT(!m_bIsExpired); // the button should not be enabled
    SetDirty(TRUE);
    m_bIsPaused = !m_bIsPaused;
    m_pauseStartHelper.SetToggleState(!m_bIsPaused);
    m_statusHelper.SetStateX(m_bIsPaused ? N_ZONE_STATUS_PAUSED : N_ZONE_STATUS_RUNNING);
}

void CDNSZone_GeneralPropertyPage::OnBrowseMasters()
{
    ASSERT(!m_bIsPrimary);
    CDNSZonePropertyPageHolder* pZoneHolder = (CDNSZonePropertyPageHolder*)GetHolder();

    if (!m_mastersEditor.BrowseFromDNSNamespace(pZoneHolder->GetComponentData(), 
                            pZoneHolder, 
                            TRUE,
                            pZoneHolder->GetZoneNode()->GetServerNode()->GetDisplayName()))
    {
        DNSMessageBox(IDS_MSG_ZONE_MASTERS_BROWSE_FAIL);
    }
}

void CDNSZone_GeneralPropertyPage::OnFindMastersNames()
{
    m_mastersEditor.FindMastersNames();
}

void CDNSZone_GeneralPropertyPage::SetPrimaryDynamicUpdateComboVal(UINT nAllowsDynamicUpdate)
{
    int nIndex = 0;
    switch (nAllowsDynamicUpdate)
    {
    case ZONE_UPDATE_OFF:
        nIndex = 0;
        break;
    case ZONE_UPDATE_UNSECURE:
        nIndex = 1;
        break;
    case ZONE_UPDATE_SECURE:
        nIndex = 2;
        break;
    default:
        ASSERT(FALSE);
    }
    VERIFY(CB_ERR != GetPrimaryDynamicUpdateCombo()->SetCurSel(nIndex));

}

UINT CDNSZone_GeneralPropertyPage::GetPrimaryDynamicUpdateComboVal()
{
    int nIndex = GetPrimaryDynamicUpdateCombo()->GetCurSel();
    ASSERT(nIndex != CB_ERR);
    UINT nVal = 0;
    switch (nIndex)
    {
    case 0:
        nVal = ZONE_UPDATE_OFF;
        break;
    case 1:
        nVal = ZONE_UPDATE_UNSECURE;
        break;
    case 2:
        nVal = ZONE_UPDATE_SECURE;
        break;
    default:
        ASSERT(FALSE);
    }
    return nVal;
}



void CDNSZone_GeneralPropertyPage::ChangeUIControlHelper(CWnd* pChild, BOOL bEnable)
{
    pChild->EnableWindow(bEnable);
    pChild->ShowWindow(bEnable);
}

void CDNSZone_GeneralPropertyPage::ChangeUIControls()
{
    // change button label
    int nType;
    if (m_bIsPrimary)
  {
        nType = m_bDSIntegrated ? N_ZONE_TYPES_DS_PRIMARY : N_ZONE_TYPES_PRIMARY;
  }
    else
  {
    if (m_bIsStub)
    {
      nType = N_ZONE_TYPES_STUB;
    }
    else
    {
          nType = N_ZONE_TYPES_SECONDARY;
    }
  }
    m_typeStaticHelper.SetStateX(nType);

  //
    // file name controls (show for secondary and for non DS integrated primary and stub)
  //
    BOOL bNotDSIntegrated = (!m_bIsPrimary && !m_bIsStub) || 
                          (m_bIsPrimary  && !m_bDSIntegrated) ||
                          (m_bIsStub     && !m_bDSIntegrated);
    m_zoneStorageStaticHelper.SetToggleState(bNotDSIntegrated); // bNotDSIntegrated == bShowEdit
    ChangeUIControlHelper(GetFileNameEdit(), bNotDSIntegrated); // bNotDSIntegrated == bShowEdit

  //
    // change primary zone controls
  CComboBox* pPrimaryDynamicUpdateCombo = GetPrimaryDynamicUpdateCombo();

  //
  // see if the combo box had a selection in it and save it
  //
  UINT nAllowsDynamicUpdateSaved = ZONE_UPDATE_OFF;
  if (pPrimaryDynamicUpdateCombo->GetCurSel() != CB_ERR)
  {
    nAllowsDynamicUpdateSaved = GetPrimaryDynamicUpdateComboVal();
  }

  //
  // set strings in the combo box
  //
  UINT nMaxAddCount = PRIMARY_DYN_UPD_COMBO_ITEM_COUNT;

  //
  // the last item in the combo box would be the "secure dynamic udate"
  // which is valid only for DS integrated primaries
  //
  if (bNotDSIntegrated)
  {
    nMaxAddCount--; // remove the last one
  }

    VERIFY(LoadStringsToComboBox(_Module.GetModuleInstance(),
                                    pPrimaryDynamicUpdateCombo,
                                    IDS_ZONE_PRIMARY_DYN_UPD_OPTIONS,
                                    256, nMaxAddCount));

  //
  // reset selection
  //
  if (bNotDSIntegrated && (nAllowsDynamicUpdateSaved == ZONE_UPDATE_SECURE))
  {
    //
    // the selected secure update otion is gone, so turn off secure update
    //
    nAllowsDynamicUpdateSaved = ZONE_UPDATE_OFF;
  }
  SetPrimaryDynamicUpdateComboVal(nAllowsDynamicUpdateSaved);

  ChangeUIControlHelper(GetPrimaryDynamicUpdateStatic(), m_bIsPrimary);
  ChangeUIControlHelper(GetPrimaryDynamicUpdateCombo(), m_bIsPrimary);
  ChangeUIControlHelper(GetPrimaryDynamicWarningText(), m_bIsPrimary);
  ChangeUIControlHelper(GetPrimaryDynamicWarningIcon(), m_bIsPrimary);

  //
    // change secondary zone controls
  //
    GetIPLabel()->ShowWindow(!m_bIsPrimary);
  GetIPLabel()->EnableWindow(!m_bIsPrimary);
    
    m_mastersEditor.ShowUI(!m_bIsPrimary);
    CButton* pBrowseButton = GetMastersBrowseButton();
    pBrowseButton->ShowWindow(!m_bIsPrimary);
    pBrowseButton->EnableWindow(!m_bIsPrimary);
    CButton* pFindMastersNamesButton = GetFindMastersNamesButton();
    pFindMastersNamesButton->ShowWindow(!m_bIsPrimary);
    pFindMastersNamesButton->EnableWindow(!m_bIsPrimary && m_mastersEditor.GetCount()>0);

  GetDlgItem(IDC_LOCAL_LIST_CHECK)->EnableWindow(m_bIsStub && !bNotDSIntegrated);
  GetDlgItem(IDC_LOCAL_LIST_CHECK)->ShowWindow(m_bIsStub && !bNotDSIntegrated);

  GetDlgItem(IDC_AGING_STATIC)->EnableWindow(m_bIsPrimary);
  GetDlgItem(IDC_AGING_STATIC)->ShowWindow(m_bIsPrimary);
  GetDlgItem(IDC_AGING_BUTTON)->EnableWindow(m_bIsPrimary);
  GetDlgItem(IDC_AGING_BUTTON)->ShowWindow(m_bIsPrimary);
}


void CDNSZone_GeneralPropertyPage::GetStorageName(CString& szDataStorageName)
{
  //
    // only for secondary ad for non DS integrated primary)
  //
    GetFileNameEdit()->GetWindowText(szDataStorageName);
    szDataStorageName.TrimLeft();
    szDataStorageName.TrimRight();
}



///////////////////////////////////////////////////////////////////////////////
// CDNSZone_ZoneTransferPropertyPage

void CDNSZone_ZoneTransferPropertyPage::CDNSSecondariesIPEditor::OnChangeData()
{
    CDNSZone_ZoneTransferPropertyPage* pPage =  (CDNSZone_ZoneTransferPropertyPage*)GetParentWnd();
    pPage->SetDirty(TRUE);
}

BEGIN_MESSAGE_MAP(CDNSZone_ZoneTransferPropertyPage, CPropertyPageBase)
  ON_BN_CLICKED(IDC_CHECK_ALLOW_TRANSFERS, OnRadioSecSecureNone)
  ON_BN_CLICKED(IDC_RADIO_SECSECURE_OFF, OnRadioSecSecureOff)
  ON_BN_CLICKED(IDC_RADIO_SECSECURE_NS, OnRadioSecSecureNS)
  ON_BN_CLICKED(IDC_RADIO_SECSECURE_LIST, OnRadioSecSecureList)
    ON_BN_CLICKED(IDC_BUTTON_NOTIFY, OnButtonNotify)
END_MESSAGE_MAP()


CDNSZone_ZoneTransferPropertyPage::CDNSZone_ZoneTransferPropertyPage() 
                : CPropertyPageBase(IDD_ZONE_ZONE_TRANSFER_PAGE)
{
  m_fNotifyLevel = (DWORD)-1;
  m_cNotify = 0;
  m_aipNotify = NULL;
  m_bStub = FALSE;
}

CDNSZone_ZoneTransferPropertyPage::~CDNSZone_ZoneTransferPropertyPage()
{
  if (m_aipNotify != NULL)
    free(m_aipNotify);
}

BOOL CDNSZone_ZoneTransferPropertyPage::OnSetActive()
{
    CDNSZonePropertyPageHolder* pHolder = 
        (CDNSZonePropertyPageHolder*)GetHolder();

  m_bStub = pHolder->IsStubZoneUI();
  GetDlgItem(IDC_CHECK_ALLOW_TRANSFERS)->EnableWindow(!m_bStub);
  return CPropertyPageBase::OnSetActive();
}

void CDNSZone_ZoneTransferPropertyPage::OnButtonNotify()
{
    CDNSZonePropertyPageHolder* pHolder = 
        (CDNSZonePropertyPageHolder*)GetHolder();
    CDNSZoneNode* pZoneNode = pHolder->GetZoneNode();

  FIX_THREAD_STATE_MFC_BUG();
   CThemeContextActivator activator;

  CDNSZoneNotifyDialog dlg(this, pZoneNode->GetZoneType() == DNS_ZONE_TYPE_SECONDARY,
                            pHolder->GetComponentData());

  if (IDOK == dlg.DoModal())
  {
    //
    // the dialog already updated the notify data
    //
      SetDirty(TRUE);
  }
}

void CDNSZone_ZoneTransferPropertyPage::SyncUIRadioHelper(UINT nRadio)
{
  BOOL bState = ((CButton*)GetDlgItem(IDC_CHECK_ALLOW_TRANSFERS))->GetCheck();
  GetNotifyButton()->EnableWindow(bState);

  m_secondariesListEditor.EnableUI(IDC_RADIO_SECSECURE_LIST == nRadio, TRUE);
  if (IDC_RADIO_SECSECURE_LIST != nRadio)
    m_secondariesListEditor.Clear();
  SetDirty(TRUE);

  if (IDC_CHECK_ALLOW_TRANSFERS == nRadio)
  {
    ((CButton*)GetDlgItem(IDC_RADIO_SECSECURE_LIST))->EnableWindow(bState);
    ((CButton*)GetDlgItem(IDC_RADIO_SECSECURE_OFF))->EnableWindow(bState);
    ((CButton*)GetDlgItem(IDC_RADIO_SECSECURE_NS))->EnableWindow(bState);
    BOOL bRadioState = ((CButton*)GetDlgItem(IDC_RADIO_SECSECURE_LIST))->GetCheck();
    m_secondariesListEditor.EnableUI(bRadioState && bState, TRUE);
  } 
}

int CDNSZone_ZoneTransferPropertyPage::SetRadioState(DWORD fSecureSecondaries)
{
  int nRadio = 0;
  switch (fSecureSecondaries)
  {
    case ZONE_SECSECURE_NONE:
      nRadio = IDC_CHECK_ALLOW_TRANSFERS;
      ((CButton*)GetDlgItem(IDC_CHECK_ALLOW_TRANSFERS))->SetCheck(FALSE);
      break;
    case ZONE_SECSECURE_LIST:
      nRadio = IDC_RADIO_SECSECURE_LIST;
      ((CButton*)GetDlgItem(IDC_RADIO_SECSECURE_LIST))->SetCheck(TRUE);
      ((CButton*)GetDlgItem(IDC_CHECK_ALLOW_TRANSFERS))->SetCheck(TRUE);
      break;
    case ZONE_SECSECURE_OFF:
      nRadio = IDC_RADIO_SECSECURE_OFF;
      ((CButton*)GetDlgItem(IDC_RADIO_SECSECURE_OFF))->SetCheck(TRUE);
      ((CButton*)GetDlgItem(IDC_CHECK_ALLOW_TRANSFERS))->SetCheck(TRUE);
      break;
    case ZONE_SECSECURE_NS:
      nRadio = IDC_RADIO_SECSECURE_NS;
      ((CButton*)GetDlgItem(IDC_RADIO_SECSECURE_NS))->SetCheck(TRUE);
      ((CButton*)GetDlgItem(IDC_CHECK_ALLOW_TRANSFERS))->SetCheck(TRUE);
      break;
  }
  ASSERT(nRadio != 0);
  return nRadio;
}

DWORD CDNSZone_ZoneTransferPropertyPage::GetRadioState()
{
  int nRadio = 0;
  if (!((CButton*)GetDlgItem(IDC_CHECK_ALLOW_TRANSFERS))->GetCheck())
  {
    nRadio = IDC_CHECK_ALLOW_TRANSFERS;
  }
  else
  {
    if (((CButton*)GetDlgItem(IDC_RADIO_SECSECURE_OFF))->GetCheck())
    {
      nRadio = IDC_RADIO_SECSECURE_OFF;
    }
    else if (((CButton*)GetDlgItem(IDC_RADIO_SECSECURE_LIST))->GetCheck())
    {
      nRadio = IDC_RADIO_SECSECURE_LIST;
    }
    else if (((CButton*)GetDlgItem(IDC_RADIO_SECSECURE_NS))->GetCheck())
    {
      nRadio = IDC_RADIO_SECSECURE_NS;
    }
  }

  ASSERT(nRadio != 0);
  DWORD fSecureSecondaries = (DWORD)-1;
  switch (nRadio)
  {
  case IDC_CHECK_ALLOW_TRANSFERS:
      fSecureSecondaries =  ZONE_SECSECURE_NONE;
      break;
    case IDC_RADIO_SECSECURE_LIST:
      fSecureSecondaries = ZONE_SECSECURE_LIST;
      break;
    case IDC_RADIO_SECSECURE_OFF:
      fSecureSecondaries = ZONE_SECSECURE_OFF;
      break;
    case IDC_RADIO_SECSECURE_NS:
      fSecureSecondaries = ZONE_SECSECURE_NS;
      break;
  }
  ASSERT(fSecureSecondaries != (DWORD)-1);
  return fSecureSecondaries;
}




BOOL CDNSZone_ZoneTransferPropertyPage::OnInitDialog() 
{
  //
  // NOTE: this control has to be initialized before the
  //       base class OnInitDialog is called because the
  //       base class OnInitDialog calls SetUIData() in 
  //       this derived class which uses this control
  //
    VERIFY(m_secondariesListEditor.Initialize(this, 
                                            GetParent(),
                                            IDC_BUTTON_UP, 
                                            IDC_BUTTON_DOWN,
                                                                IDC_BUTTON_ADD, 
                                            IDC_BUTTON_REMOVE, 
                                                                IDC_IPEDIT, 
                                            IDC_LIST));

    CPropertyPageBase::OnInitDialog();

    CDNSZonePropertyPageHolder* pHolder = (CDNSZonePropertyPageHolder*)GetHolder();
    CDNSZoneNode* pZoneNode = pHolder->GetZoneNode();

  DWORD fSecureSecondaries;
    DWORD cSecondaries;
    PIP_ADDRESS aipSecondaries;

  ASSERT(m_fNotifyLevel == (DWORD)-1);
  ASSERT(m_cNotify == 0);
  ASSERT(m_aipNotify == NULL);

    pZoneNode->GetSecondariesInfo(&fSecureSecondaries, &cSecondaries, &aipSecondaries, 
                                &m_fNotifyLevel, &m_cNotify, &m_aipNotify);


  BOOL bSecondaryZone = pZoneNode->GetZoneType() == DNS_ZONE_TYPE_SECONDARY ||
                        pZoneNode->GetZoneType() == DNS_ZONE_TYPE_STUB;
  if (bSecondaryZone)
  {
    //
    // just to make sure here...
    //
    ASSERT(m_fNotifyLevel != ZONE_NOTIFY_ALL);
    if (m_fNotifyLevel == ZONE_NOTIFY_ALL)
    {
      m_fNotifyLevel = ZONE_NOTIFY_OFF;
    }
  }

  if ( (m_cNotify > 0) && (m_aipNotify != NULL) )
  {
    //
    // make a deep copy
    //
    PIP_ADDRESS aipNotifyTemp = (DWORD*) malloc(sizeof(DWORD)*m_cNotify);
    if (aipNotifyTemp != NULL)
    {
      memcpy(aipNotifyTemp, m_aipNotify, sizeof(DWORD)*m_cNotify);
      m_aipNotify = aipNotifyTemp;
    }
  }

    if ( (ZONE_SECSECURE_LIST == fSecureSecondaries) && (cSecondaries > 0) )
    {
        m_secondariesListEditor.AddAddresses(aipSecondaries, cSecondaries); 
    }

  SyncUIRadioHelper(SetRadioState(fSecureSecondaries));

  BOOL bListState = ((CButton*)GetDlgItem(IDC_RADIO_SECSECURE_LIST))->GetCheck();
  BOOL bAllState = ((CButton*)GetDlgItem(IDC_RADIO_SECSECURE_OFF))->GetCheck();
  BOOL bNSState = ((CButton*)GetDlgItem(IDC_RADIO_SECSECURE_NS))->GetCheck();
  if (!bAllState && !bListState && !bNSState)
  {
    ((CButton*)GetDlgItem(IDC_RADIO_SECSECURE_OFF))->SetCheck(TRUE);
  }

    SetDirty(FALSE);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CDNSZone_ZoneTransferPropertyPage::OnApply()
{
    CDNSZonePropertyPageHolder* pHolder = 
        (CDNSZonePropertyPageHolder*)GetHolder();
    CDNSZoneNode* pZoneNode = pHolder->GetZoneNode();

  // first commit possible zone type transition changes
  if (!pHolder->ApplyGeneralPageChanges())
    return FALSE;

    if (!IsDirty())
        return TRUE;

  DWORD fSecureSecondaries = GetRadioState();

  DWORD cSecondaries = 0;
  DWORD* aipSecondaries = NULL;
  if (fSecureSecondaries == ZONE_SECSECURE_LIST)
  {
      cSecondaries = m_secondariesListEditor.GetCount();
      aipSecondaries = (cSecondaries > 0) ? (DWORD*) malloc(sizeof(DWORD)*cSecondaries) : NULL;
    if (aipSecondaries != NULL && cSecondaries > 0)
      {
          int nFilled = 0;
          m_secondariesListEditor.GetAddresses(aipSecondaries, cSecondaries, &nFilled);
          ASSERT(nFilled == (int)cSecondaries);
      }
  }

  BOOL bRet = TRUE;
    // write to server
    DNS_STATUS err = pZoneNode->ResetSecondaries(fSecureSecondaries, cSecondaries, aipSecondaries, 
                                              m_fNotifyLevel, m_cNotify, m_aipNotify);
    if (err != 0)
    {
        DNSErrorDialog(err, IDS_MSG_ZONE_FAIL_UPDATE_ZONE_TRANSFERS);
        bRet = FALSE;
    }

  if (aipSecondaries)
  {
    free (aipSecondaries);
    aipSecondaries = 0;
  }
  // all went fine
  if (bRet)
  {
      SetDirty(FALSE);
  }
    return bRet;
}

////////////////////////////////////////////////////////////////////////////
// CDNSZone_SOA_PropertyPage

void CDNS_SOA_SerialNumberEditGroup::OnEditChange()
{
    m_pPage->SetDirty(TRUE);
}

void CDNS_SOA_TimeIntervalEditGroup::OnEditChange()
{
    m_pPage->SetDirty(TRUE);
}


BEGIN_MESSAGE_MAP(CDNSZone_SOA_PropertyPage, CDNSRecordPropertyPage)
    ON_EN_CHANGE(IDC_PRIMARY_SERV_EDIT, OnPrimaryServerChange)
    ON_EN_CHANGE(IDC_RESP_PARTY_EDIT, OnResponsiblePartyChange)
    ON_EN_CHANGE(IDC_MIN_TTLEDIT, OnMinTTLChange)
    ON_BN_CLICKED(IDC_BROWSE_SERV_BUTTON, OnBrowseServer)
    ON_BN_CLICKED(IDC_BROWSE_PARTY_BUTTON, OnBrowseResponsibleParty)
END_MESSAGE_MAP()


CDNSZone_SOA_PropertyPage::CDNSZone_SOA_PropertyPage(BOOL bZoneRoot) 
                : CDNSRecordPropertyPage(IDD_RR_SOA)
{
    m_pTempSOARecord = NULL;
  m_bZoneRoot = bZoneRoot;
}

CDNSZone_SOA_PropertyPage::~CDNSZone_SOA_PropertyPage() 
{
    if (m_bZoneRoot && (m_pTempSOARecord != NULL))
        delete m_pTempSOARecord;
}



void _DisableDialogControls(HWND hWnd)
{
    HWND hWndCurr = ::GetWindow(hWnd, GW_CHILD);
    if (hWndCurr != NULL)
    {
    ::ShowWindow(hWndCurr,FALSE);
    ::EnableWindow(hWndCurr,FALSE);
    hWndCurr = ::GetNextWindow(hWndCurr, GW_HWNDNEXT);
        while (hWndCurr)
    {
      ::ShowWindow(hWndCurr,FALSE);
      ::EnableWindow(hWndCurr,FALSE);
      hWndCurr = ::GetNextWindow(hWndCurr, GW_HWNDNEXT);
    }
    }
}

void CDNSZone_SOA_PropertyPage::ShowErrorUI()
{
  _DisableDialogControls(m_hWnd);
  CStatic* pErrorStatic = GetErrorStatic();
  // need to move the error control to the center

  CRect r;
  pErrorStatic->GetWindowRect(&r);
  ScreenToClient(r);
  int dx = r.right - r.left;
  int dy = r.bottom - r.top;

  CRect rThis;
  GetClientRect(rThis);
  int x = ((rThis.right - rThis.left) - dx)/2;
  int y = 4*dy;
  
  r.top = y;
  r.bottom = y + dy;
  r.left = x;
  r.right = x + dx;
  pErrorStatic->MoveWindow(r, TRUE);

  pErrorStatic->EnableWindow(TRUE);
  pErrorStatic->ShowWindow(TRUE);
}


BOOL CDNSZone_SOA_PropertyPage::OnInitDialog()
{
  CPropertyPageBase::OnInitDialog();

    ASSERT(m_pTempSOARecord == NULL);

  // create temporary record
  if (m_bZoneRoot)
  {
    CDNSZonePropertyPageHolder* pHolder = (CDNSZonePropertyPageHolder*)GetHolder();
    CDNSZoneNode* pZoneNode = pHolder->GetZoneNode();
    if (pZoneNode->HasSOARecord())
    {
        m_pTempSOARecord = pZoneNode->GetSOARecordCopy();
    }
    else
    {
      // something is wrong, need to disable
      ShowErrorUI();
      }
  }
  else
  {
    // we are in the cache here...
    CDNSRecordPropertyPageHolder* pHolder = (CDNSRecordPropertyPageHolder*)GetHolder();
    m_pTempSOARecord = (CDNS_SOA_Record*)pHolder->GetTempDNSRecord();
  }

  // initialize controls
    m_serialNumberEditGroup.m_pPage = this;
    VERIFY(m_serialNumberEditGroup.Initialize(this,
                IDC_SERIAL_NUMBER_EDIT,IDC_SERIAL_UP, IDC_SERIAL_DOWN));
    m_serialNumberEditGroup.SetRange(0,(UINT)-1);

    m_refreshIntervalEditGroup.m_pPage = this;
    m_retryIntervalEditGroup.m_pPage = this;
    m_expireIntervalEditGroup.m_pPage = this;
  m_minTTLIntervalEditGroup.m_pPage = this;

    VERIFY(m_refreshIntervalEditGroup.Initialize(this, 
                IDC_REFR_INT_EDIT, IDC_REFR_INT_COMBO,IDS_TIME_INTERVAL_UNITS));
    VERIFY(m_retryIntervalEditGroup.Initialize(this, 
                IDC_RETRY_INT_EDIT, IDC_RETRY_INT_COMBO,IDS_TIME_INTERVAL_UNITS));
    VERIFY(m_expireIntervalEditGroup.Initialize(this, 
                IDC_EXP_INT_EDIT, IDC_EXP_INT_COMBO,IDS_TIME_INTERVAL_UNITS));
  VERIFY(m_minTTLIntervalEditGroup.Initialize(this,
        IDC_MINTTL_INT_EDIT, IDC_MINTTL_INT_COMBO, IDS_TIME_INTERVAL_UNITS));

  HWND dialogHwnd = GetSafeHwnd();

  // Disable IME support on the controls
  ImmAssociateContext(::GetDlgItem(dialogHwnd, IDC_REFR_INT_EDIT), NULL);
  ImmAssociateContext(::GetDlgItem(dialogHwnd, IDC_RETRY_INT_EDIT), NULL);
  ImmAssociateContext(::GetDlgItem(dialogHwnd, IDC_EXP_INT_EDIT), NULL);
  ImmAssociateContext(::GetDlgItem(dialogHwnd, IDC_MINTTL_INT_EDIT), NULL);
  ImmAssociateContext(::GetDlgItem(dialogHwnd, IDC_SERIAL_NUMBER_EDIT), NULL);

  // load data
  SetUIData();

  if (!m_bZoneRoot)
  {
    // we are in the cache here...
    EnableDialogControls(m_hWnd, FALSE);
  }

  SetDirty(FALSE);
    return TRUE;
}


BOOL CDNSZone_SOA_PropertyPage::OnApply()
{
  if (!IsDirty())
  {
    return TRUE;
  }
  
  DNS_STATUS err = 0;
  if (m_bZoneRoot)
  {
    //
    // we are in a real zone
    //
      CDNSZonePropertyPageHolder* pHolder = (CDNSZonePropertyPageHolder*)GetHolder();
      ASSERT(!pHolder->IsWizardMode());

    //
    // first commit possible zone type transition changes
    //
    if (!pHolder->ApplyGeneralPageChanges())
    {
      return FALSE;
    }

      if ((m_pTempSOARecord == NULL) || !IsDirty() || !pHolder->IsPrimaryZoneUI())
    {
          return TRUE; 
    }

    //
    // No need to verify success here because we don't return anything that isn't valid
    //
      err = GetUIDataEx(FALSE);
    if (err != 0)
    {
      return FALSE;
    }

      err = pHolder->NotifyConsole(this);
  }
  else
  {
    //
    // we are in the cache, that is read only...
    //
    return TRUE; 
  }

    if (err != 0)
    {
        DNSErrorDialog(err,IDS_MSG_ZONE_SOA_UPDATE_FAILED);
        return FALSE;
    }
    else
    {
    SetUIData();
        SetDirty(FALSE);
    }
    return TRUE; // all is cool
}

BOOL CDNSZone_SOA_PropertyPage::OnPropertyChange(BOOL, long*)
{
    ASSERT(m_pTempSOARecord != NULL);
    if (m_pTempSOARecord == NULL)
        return FALSE;
  
  DNS_STATUS err = 0;
  if (m_bZoneRoot)
  {
    CDNSZonePropertyPageHolder* pHolder = (CDNSZonePropertyPageHolder*)GetHolder();
      err = pHolder->GetZoneNode()->UpdateSOARecord(m_pTempSOARecord, NULL);
  }
  else
  {
    ASSERT(FALSE);
  }
    if (err != 0)
        GetHolder()->SetError(err);
    return (err == 0);
}


void CDNSZone_SOA_PropertyPage::SetUIData()
{
    CDNS_SOA_Record* pRecord = m_pTempSOARecord;

    if (pRecord == NULL)
    return;

    GetPrimaryServerEdit()->SetWindowText(pRecord->m_szNamePrimaryServer);
    GetResponsiblePartyEdit()->SetWindowText(pRecord->m_szResponsibleParty);

    m_serialNumberEditGroup.SetVal(pRecord->m_dwSerialNo);

    m_refreshIntervalEditGroup.SetVal(pRecord->m_dwRefresh);
    m_retryIntervalEditGroup.SetVal(pRecord->m_dwRetry);
    m_expireIntervalEditGroup.SetVal(pRecord->m_dwExpire);
  m_minTTLIntervalEditGroup.SetVal(pRecord->m_dwMinimumTtl);

    GetTTLCtrl()->SetTTL(pRecord->m_dwTtlSeconds);
  
  if (m_bZoneRoot)
  {
    CDNSZonePropertyPageHolder* pHolder = (CDNSZonePropertyPageHolder*)GetHolder();
      EnableDialogControls(m_hWnd, pHolder->IsPrimaryZoneUI());
  }
}

DNS_STATUS CDNSZone_SOA_PropertyPage::GetUIDataEx(BOOL)
{
  DNS_STATUS err = 0;
    CDNS_SOA_Record* pRecord = m_pTempSOARecord;
  if (pRecord == NULL)
    return err;

    GetPrimaryServerEdit()->GetWindowText(pRecord->m_szNamePrimaryServer);
    GetResponsiblePartyEdit()->GetWindowText(pRecord->m_szResponsibleParty);

  //
  // Check to see if the Responsible Party field contains an '@'
  //
  if (-1 != pRecord->m_szResponsibleParty.Find(L'@'))
  {
    UINT nResult = DNSMessageBox(IDS_MSG_RESPONSIBLE_PARTY_CONTAINS_AT, MB_YESNOCANCEL | MB_ICONWARNING);
    if (IDYES == nResult)
    {
      //
      // Replace '@' with '.'
      //
      pRecord->m_szResponsibleParty.Replace(L'@', L'.');
    }
    else if (IDCANCEL == nResult)
    {
      //
      // Don't make any changes but don't let the apply continue
      //
      err = DNS_ERROR_INVALID_NAME_CHAR;
    }
    else
    {
      //
      // We will allow IDNO to continue to set the responsible party with the '@'
      //
      err = 0;
    }
  }
    
    pRecord->m_dwSerialNo = m_serialNumberEditGroup.GetVal();
    
    pRecord->m_dwRefresh = m_refreshIntervalEditGroup.GetVal();
    pRecord->m_dwRetry = m_retryIntervalEditGroup.GetVal();
    pRecord->m_dwExpire = m_expireIntervalEditGroup.GetVal();
  pRecord->m_dwMinimumTtl = m_minTTLIntervalEditGroup.GetVal();

    GetTTLCtrl()->GetTTL(&(pRecord->m_dwTtlSeconds));
  return err;
}

void  CDNSZone_SOA_PropertyPage::OnPrimaryServerChange()
{
    SetDirty(TRUE);
}

void  CDNSZone_SOA_PropertyPage::OnResponsiblePartyChange()
{
    SetDirty(TRUE);

}

void CDNSZone_SOA_PropertyPage::OnMinTTLChange()
{
    SetDirty(TRUE);
}

void CDNSZone_SOA_PropertyPage::OnBrowseServer()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
  FIX_THREAD_STATE_MFC_BUG();
   CThemeContextActivator activator;


    CDNSBrowserDlg dlg(GetHolder()->GetComponentData(), GetHolder(), RECORD_A_AND_CNAME);
    if (IDOK == dlg.DoModal())
    {
        CEdit* pEdit = GetPrimaryServerEdit();
        pEdit->SetWindowText(dlg.GetSelectionString());
    }
}

void CDNSZone_SOA_PropertyPage::OnBrowseResponsibleParty()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
  FIX_THREAD_STATE_MFC_BUG();
   CThemeContextActivator activator;


    CDNSBrowserDlg dlg(GetHolder()->GetComponentData(), GetHolder(), RECORD_RP);
    if (IDOK == dlg.DoModal())
    {
        CEdit* pEdit = GetResponsiblePartyEdit();
        pEdit->SetWindowText(dlg.GetSelectionString());
    }
}

////////////////////////////////////////////////////////////////////////////
// CWinsAdvancedDialog

class CWinsAdvancedDialog : public CHelpDialog
{
public:
    CWinsAdvancedDialog(CPropertyPageHolderBase* pHolder, BOOL bReverse);

    // data 
    BOOL m_bNetBios;
    DWORD m_dwLookupTimeout;
    DWORD m_dwCacheTimeout;

protected:
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    virtual void OnCancel();

  DECLARE_MESSAGE_MAP()
private:
    CPropertyPageHolderBase* m_pHolder;
    BOOL m_bReverse;

    CButton* GetNetBiosCheck() 
            { return (CButton*)GetDlgItem(IDC_NETBIOS_CHECK);}

    CDNSTTLControl* GetCacheTimeoutTTLCtrl() 
            { return (CDNSTTLControl*)GetDlgItem(IDC_CACHE_TIMEOUT_TTLEDIT);}
    CDNSTTLControl* GetLookupTimeoutTTLCtrl() 
            { return (CDNSTTLControl*)GetDlgItem(IDC_LOOKUP_TIMEOUT_TTLEDIT);}

};

BEGIN_MESSAGE_MAP(CWinsAdvancedDialog, CHelpDialog)
END_MESSAGE_MAP()

CWinsAdvancedDialog::CWinsAdvancedDialog(CPropertyPageHolderBase* pHolder, 
                                         BOOL bReverse)
        : CHelpDialog(IDD_ZONE_WINS_ADVANCED, pHolder->GetComponentData())
{
    ASSERT(pHolder != NULL);
    m_pHolder = pHolder;
    m_bReverse = bReverse;
    m_bNetBios = FALSE;
    m_dwLookupTimeout = 0x0;
    m_dwCacheTimeout = 0x0;
}

BOOL CWinsAdvancedDialog::OnInitDialog() 
{
    CHelpDialog::OnInitDialog();
    m_pHolder->PushDialogHWnd(GetSafeHwnd());

    if (m_bReverse)
    {
        GetNetBiosCheck()->SetCheck(m_bNetBios);
    }
    else
    {
        GetNetBiosCheck()->EnableWindow(FALSE);
        GetNetBiosCheck()->ShowWindow(FALSE);
    }
    GetCacheTimeoutTTLCtrl()->SetTTL(m_dwCacheTimeout);
    GetLookupTimeoutTTLCtrl()->SetTTL(m_dwLookupTimeout);

    return TRUE;  // return TRUE unless you set the focus to a control
}

void CWinsAdvancedDialog::OnCancel()
{
    ASSERT(m_pHolder != NULL);
    m_pHolder->PopDialogHWnd();
    CHelpDialog::OnCancel();
}

void CWinsAdvancedDialog::OnOK()
{
    if (m_bReverse)
    {
        m_bNetBios = GetNetBiosCheck()->GetCheck();
    }
    GetCacheTimeoutTTLCtrl()->GetTTL(&m_dwCacheTimeout);
    GetLookupTimeoutTTLCtrl()->GetTTL(&m_dwLookupTimeout);

    ASSERT(m_pHolder != NULL);
    m_pHolder->PopDialogHWnd();
    CHelpDialog::OnOK();
}


////////////////////////////////////////////////////////////////////////////
// CDNSZone_WINSBase_PropertyPage

BEGIN_MESSAGE_MAP(CDNSZone_WINSBase_PropertyPage, CDNSRecordPropertyPage)
    ON_BN_CLICKED(IDC_USE_WINS_RES_CHECK, OnUseWinsResolutionChange)
    ON_BN_CLICKED(IDC_NOT_REPL_CHECK, OnDoNotReplicateChange)
END_MESSAGE_MAP()


CDNSZone_WINSBase_PropertyPage::CDNSZone_WINSBase_PropertyPage(UINT nIDTemplate)
                        : CDNSRecordPropertyPage(nIDTemplate)
{
    m_pTempRecord = NULL;
    m_action = none;
    m_iWINSMsg = 0;
}

CDNSZone_WINSBase_PropertyPage::~CDNSZone_WINSBase_PropertyPage()
{
    if (m_pTempRecord != NULL)
        delete m_pTempRecord;
}

BOOL CDNSZone_WINSBase_PropertyPage::OnPropertyChange(BOOL, long*)
{
    ASSERT(m_action != none);
    ASSERT(m_pTempRecord != NULL);
    if (m_pTempRecord == NULL)
        return FALSE;

    CComponentDataObject* pComponentData = GetZoneHolder()->GetComponentData();
    DNS_STATUS err = 0;

  if (IsValidTempRecord())
  {
      switch(m_action)
      {
      case remove:
          err = GetZoneNode()->DeleteWINSRecord(pComponentData);
          break;
      case add:
          err = GetZoneNode()->CreateWINSRecord(m_pTempRecord, pComponentData);
          break;
      case edit:
          err = GetZoneNode()->UpdateWINSRecord(m_pTempRecord, pComponentData);
          break;
      }
  }
  else
  {
    if (m_action == remove)
    {
      err = GetZoneNode()->DeleteWINSRecord(pComponentData);
    }
    else
    {
      err = ERROR_INVALID_DATA;
    }
  }
    if (err != 0)
        GetZoneHolder()->SetError(err);
    return (err == 0);
}


CDNSZoneNode* CDNSZone_WINSBase_PropertyPage::GetZoneNode() 
{ 
    return GetZoneHolder()->GetZoneNode();
}


BOOL CDNSZone_WINSBase_PropertyPage::OnInitDialog()
{
  CPropertyPageBase::OnInitDialog();

  CDNSRootData* pRootData = (CDNSRootData*)GetHolder()->GetComponentData()->GetRootData();
    ASSERT(pRootData != NULL);
    EnableTTLCtrl(pRootData->IsAdvancedView());

    BOOL bUseWins = GetZoneNode()->HasWinsRecord();
    // unabe disable the WINS checkbox
    GetUseWinsCheck()->SetCheck(bUseWins);
    // get new temporary record
    if (bUseWins)
        m_pTempRecord = GetZoneNode()->GetWINSRecordCopy();
    else
        m_pTempRecord = GetZoneNode()->IsReverse() ? 
                (CDNSRecord*)(new CDNS_NBSTAT_Record) : (CDNSRecord*)(new CDNS_WINS_Record);
    ASSERT(m_pTempRecord != NULL);

    SetUIData();
    SetDirty(FALSE);
//  EnableUI(bUseWins);

    return TRUE;
}


BOOL CDNSZone_WINSBase_PropertyPage::OnSetActive()
{
  BOOL bRet = CDNSRecordPropertyPage::OnSetActive();
  if (bRet)
  {
    CDNSZonePropertyPageHolder* pHolder = (CDNSZonePropertyPageHolder*)GetHolder();
    m_bPrimaryZone = pHolder->IsPrimaryZoneUI();
    m_bStub = pHolder->IsStubZoneUI();
    CDNS_WINS_Record* pRecord = (CDNS_WINS_Record*)m_pTempRecord;

    if (pRecord)
    {
      m_bLocalRecord = (pRecord->m_dwMappingFlag & DNS_WINS_FLAG_LOCAL);
    }

    BOOL bUseWins = GetZoneNode()->HasWinsRecord();

    if (bUseWins && m_bLocalRecord)
    {
      m_nState = wins_local_state;
    }
    else if (bUseWins && !m_bLocalRecord)
    {
      m_nState = wins_not_local_state;
    }
    else    // (!bUseWins && !m_bLocalRecord) || (!bUseWins && m_bLocalRecord)
    {
      m_nState = no_wins_state;
    }

    EnableUI();

    CString szCheckText;
    if (m_bPrimaryZone)
    {
      m_nReplCheckTextID = IDS_CHECK_TEXT_NOT_REPLICATE;
    }
    szCheckText.LoadString(m_nReplCheckTextID);
    GetDoNotReplicateCheck()->SetWindowText((LPWSTR)(LPCWSTR)szCheckText);
  }
  return bRet;
}

BOOL CDNSZone_WINSBase_PropertyPage::OnApply()
{
  CDNSZonePropertyPageHolder* pHolder = 
    (CDNSZonePropertyPageHolder*)GetHolder();
  // first commit possible zone type transition changes
  if (!pHolder->ApplyGeneralPageChanges())
    return FALSE;

    BOOL bUseWins = GetZoneNode()->HasWinsRecord(); // current state in the zone
    BOOL bNewUseWins = GetUseWinsCheck()->GetCheck();   // current state in the UI 

    if (bUseWins && !bNewUseWins)
    {
        m_action = remove;
    } 
    else if (!bUseWins && bNewUseWins)
    {
        m_action = add;
    }
    else if (bUseWins && bNewUseWins && IsDirty())
    {
        m_action = edit;
    }
    
    if (m_action == none)
        return TRUE;

  // No need to verify the return value here because we don't return anything except success
    DNS_STATUS err = GetUIDataEx(FALSE);
  if (err != 0)
  {
    ASSERT(FALSE);
    return (err == 0);
  }

    err = GetZoneHolder()->NotifyConsole(this);
    if (err != 0)
    {
        DNSErrorDialog(err, m_iWINSMsg);
    }
    else
    {
        // reset dirty flag!!!
    }
    m_action = none;    
    return (err == 0);
}


void CDNSZone_WINSBase_PropertyPage::OnUseWinsResolutionChange()
{
    SetDirty(TRUE);

    if (m_bPrimaryZone)
    {
        EnableUI(GetUseWinsCheck()->GetCheck());
    }
    else
    {
        switch (m_nState)
        {
            case wins_local_state :
                #ifdef DBG
                    ASSERT(!GetUseWinsCheck()->GetCheck());
                    ASSERT(GetUseWinsCheck()->IsWindowEnabled());
                    ASSERT(GetDoNotReplicateCheck()->GetCheck());
                    ASSERT(!GetDoNotReplicateCheck()->IsWindowEnabled());
                #endif
                m_nState = no_wins_state;
                break;
            case wins_not_local_state : // should never happen
                #ifdef DBG
                    ASSERT(FALSE);
                #endif
                break;
            case no_wins_state :
                #ifdef DBG
                    ASSERT(GetUseWinsCheck()->GetCheck());
                    ASSERT(GetUseWinsCheck()->IsWindowEnabled());
                    ASSERT(GetDoNotReplicateCheck()->GetCheck());
                    ASSERT(!GetDoNotReplicateCheck()->IsWindowEnabled());
                #endif
                m_nState = wins_local_state;
                break;
            default :   // illegal state
                #ifdef DBG
                    ASSERT(FALSE);
                #endif
                break;
        }
        EnableUI();
    }
}

void CDNSZone_WINSBase_PropertyPage::OnDoNotReplicateChange()
{
    SetDirty(TRUE);
    if (!m_bPrimaryZone)
    {
        switch (m_nState)
        {
            case wins_local_state : // should never happen
                #ifdef DBG
                    ASSERT(FALSE);
                #endif
                break;
            case wins_not_local_state :
                #ifdef DBG
                    ASSERT(GetUseWinsCheck()->GetCheck());
                    ASSERT(!GetUseWinsCheck()->IsWindowEnabled());
                    ASSERT(GetDoNotReplicateCheck()->GetCheck());
                    ASSERT(GetDoNotReplicateCheck()->IsWindowEnabled());
                #endif
                m_nState = wins_local_state;
                break;
            case no_wins_state :        // should never happen
                #ifdef DBG
                    ASSERT(FALSE);
                #endif
                break;
            default :   // illegal state
                #ifdef DBG
                    ASSERT(FALSE);
                #endif
                break;
        }
        EnableUI();
    }
}

void CDNSZone_WINSBase_PropertyPage::EnableUI(BOOL bEnable)
{
    GetDoNotReplicateCheck()->EnableWindow(bEnable);
    GetAdvancedButton()->EnableWindow(bEnable);
    GetTTLCtrl()->EnableWindow(bEnable);
}

void CDNSZone_WINSBase_PropertyPage::EnableUI()
{
    if (m_bPrimaryZone)
    {
    GetDlgItem(IDC_USE_WINS_RES_CHECK)->EnableWindow(TRUE);
    if (!IsDirty())
    {
          EnableUI(GetZoneNode()->HasWinsRecord());
    }
    }
  else if (m_bStub)
  {
    GetDlgItem(IDC_USE_WINS_RES_CHECK)->EnableWindow(FALSE);
    EnableUI(FALSE);
  }
    else    //secondary
    {
    GetDlgItem(IDC_USE_WINS_RES_CHECK)->EnableWindow(TRUE);
        switch (m_nState)
        {
            case wins_local_state :
                GetDoNotReplicateCheck()->SetCheck(TRUE);
                GetDoNotReplicateCheck()->EnableWindow(FALSE);
                GetUseWinsCheck()->SetCheck(TRUE);
                GetUseWinsCheck()->EnableWindow(TRUE);
                GetTTLCtrl()->EnableWindow(TRUE);
                GetAdvancedButton()->EnableWindow(TRUE);
                break;
            case wins_not_local_state :
                GetDoNotReplicateCheck()->SetCheck(FALSE);
                GetDoNotReplicateCheck()->EnableWindow(TRUE);
                GetUseWinsCheck()->SetCheck(TRUE);
                GetUseWinsCheck()->EnableWindow(FALSE);
                GetTTLCtrl()->EnableWindow(FALSE);
                GetAdvancedButton()->EnableWindow(FALSE);
                break;
            case no_wins_state :
                GetDoNotReplicateCheck()->SetCheck(TRUE);
                GetDoNotReplicateCheck()->EnableWindow(FALSE);
                GetUseWinsCheck()->SetCheck(FALSE);
                GetUseWinsCheck()->EnableWindow(TRUE);
                GetTTLCtrl()->EnableWindow(FALSE);
                GetAdvancedButton()->EnableWindow(FALSE);
                break;
            default :   // Illegal state
                break;
        }
    }
}

void CDNSZone_WINSBase_PropertyPage::SetUIData()
{
    GetTTLCtrl()->SetTTL(m_pTempRecord->m_dwTtlSeconds);
}

DNS_STATUS CDNSZone_WINSBase_PropertyPage::GetUIDataEx(BOOL)
{
    GetTTLCtrl()->GetTTL(&(m_pTempRecord->m_dwTtlSeconds));
  return 0;
}


////////////////////////////////////////////////////////////////////////////
// CDNSZone_WINS_PropertyPage

void CDNSZone_WINS_WinsServersIPEditor::OnChangeData()
{
    CDNSZone_WINS_PropertyPage* pPage =  
                (CDNSZone_WINS_PropertyPage*)GetParentWnd();
    pPage->SetDirty(TRUE);
}



BEGIN_MESSAGE_MAP(CDNSZone_WINS_PropertyPage, CDNSZone_WINSBase_PropertyPage)
    ON_BN_CLICKED(IDC_ADVANCED_BUTTON, OnAdvancedButton)    
END_MESSAGE_MAP()


CDNSZone_WINS_PropertyPage::CDNSZone_WINS_PropertyPage() 
                : CDNSZone_WINSBase_PropertyPage(IDD_ZONE_WINS_PAGE)
{
    m_iWINSMsg = IDS_MSG_ZONE_WINS_FAILED;
    m_nReplCheckTextID = IDS_CHECK_TEXT_USE_LOCAL_WINS;
  m_bStub = FALSE;
}


BOOL CDNSZone_WINS_PropertyPage::OnInitDialog()
{
  //
  // NOTE: this control has to be initialized before the
  //       base class OnInitDialog is called because the
  //       base class OnInitDialog calls SetUIData() in 
  //       this derived class which uses this control
  //
  VERIFY(m_winsServersEditor.Initialize(this, 
                                        GetParent(),
                                        IDC_BUTTON_UP, 
                                        IDC_BUTTON_DOWN,
                                                        IDC_BUTTON_ADD, 
                                        IDC_BUTTON_REMOVE, 
                                                        IDC_IPEDIT, 
                                        IDC_LIST));

  CDNSZone_WINSBase_PropertyPage::OnInitDialog();
    return TRUE;
}

void CDNSZone_WINS_PropertyPage::EnableUI(BOOL bEnable)
{
    CDNSZone_WINSBase_PropertyPage::EnableUI(bEnable);
    m_winsServersEditor.EnableUI(bEnable);
   GetDlgItem(IDC_IP_STATIC)->EnableWindow(bEnable);
}

void CDNSZone_WINS_PropertyPage::EnableUI()
{
    CDNSZone_WINSBase_PropertyPage::EnableUI();

    if (m_bPrimaryZone)
    {
    if (!IsDirty())
    {
          m_winsServersEditor.EnableUI(GetZoneNode()->HasWinsRecord());
        GetDlgItem(IDC_IP_STATIC)->EnableWindow(GetZoneNode()->HasWinsRecord());
    }
    }
    else    // secondary zone
    {
        switch (m_nState)
        {
            case wins_local_state :
                m_winsServersEditor.EnableUI(TRUE);
            GetDlgItem(IDC_IP_STATIC)->EnableWindow(FALSE);
                break;
            case wins_not_local_state :
            case no_wins_state :
                m_winsServersEditor.EnableUI(FALSE);
            GetDlgItem(IDC_IP_STATIC)->EnableWindow(FALSE);
                break;

            default :   // Illegal state
                break;
        }
    }       
}


BOOL CDNSZone_WINS_PropertyPage::IsValidTempRecord()
{
  CDNS_WINS_Record* pRecord = (CDNS_WINS_Record*)m_pTempRecord;
  return (pRecord->m_nWinsServerCount > 0);
}

void CDNSZone_WINS_PropertyPage::SetUIData()
{
   CDNSZone_WINSBase_PropertyPage::SetUIData();
   CDNS_WINS_Record* pRecord = (CDNS_WINS_Record*)m_pTempRecord;
   GetDoNotReplicateCheck()->SetCheck(pRecord->m_dwMappingFlag & DNS_WINS_FLAG_LOCAL);

   m_winsServersEditor.Clear();
   if (pRecord->m_nWinsServerCount > 0)
   {
      DWORD* pTemp = (DWORD*)malloc(sizeof(DWORD)*pRecord->m_nWinsServerCount);
      if (pTemp)
      {
         for (int k=0; k< pRecord->m_nWinsServerCount; k++)
         {
            pTemp[k] = pRecord->m_ipWinsServersArray[k];
         }
         m_winsServersEditor.AddAddresses(pTemp, pRecord->m_nWinsServerCount);
         free(pTemp);
         pTemp = 0;
      }
   }
}

DNS_STATUS CDNSZone_WINS_PropertyPage::GetUIDataEx(BOOL bSilent)
{
    DNS_STATUS err = CDNSZone_WINSBase_PropertyPage::GetUIDataEx(bSilent);
    CDNS_WINS_Record* pRecord = (CDNS_WINS_Record*)m_pTempRecord;
    pRecord->m_dwMappingFlag = GetDoNotReplicateCheck()->GetCheck() ?
        pRecord->m_dwMappingFlag |= DNS_WINS_FLAG_LOCAL :
        pRecord->m_dwMappingFlag &= ~DNS_WINS_FLAG_LOCAL;

    pRecord->m_nWinsServerCount = m_winsServersEditor.GetCount();
    if (pRecord->m_nWinsServerCount > 0)
    {
        DWORD* pTemp = (DWORD*)malloc(sizeof(DWORD)*pRecord->m_nWinsServerCount);
    if (pTemp)
    {
          int nFilled;
          m_winsServersEditor.GetAddresses(pTemp, pRecord->m_nWinsServerCount, &nFilled);
          ASSERT(nFilled == pRecord->m_nWinsServerCount);
          for (int k=0; k<nFilled; k++)
              pRecord->m_ipWinsServersArray.SetAtGrow(k, pTemp[k]);

      free(pTemp);
      pTemp = 0;
    }
    else
    {
      err = ERROR_OUTOFMEMORY;
    }
    }
  return err;
}

void CDNSZone_WINS_PropertyPage::OnAdvancedButton()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
  FIX_THREAD_STATE_MFC_BUG();
   CThemeContextActivator activator;


    CDNS_WINS_Record* pRecord = (CDNS_WINS_Record*)m_pTempRecord;
    CWinsAdvancedDialog dlg(GetHolder(), FALSE);
    dlg.m_dwLookupTimeout = pRecord->m_dwLookupTimeout;
    dlg.m_dwCacheTimeout = pRecord->m_dwCacheTimeout;
    if (IDOK == dlg.DoModal() )
    {
        pRecord->m_dwLookupTimeout = dlg.m_dwLookupTimeout;
        pRecord->m_dwCacheTimeout = dlg.m_dwCacheTimeout;
        SetDirty(TRUE);
    }
}


////////////////////////////////////////////////////////////////////////////
// CDNSZone_NBSTAT_PropertyPage

BEGIN_MESSAGE_MAP(CDNSZone_NBSTAT_PropertyPage, CDNSZone_WINSBase_PropertyPage)
    ON_EN_CHANGE(IDC_DOMAIN_NAME_EDIT, OnDomainNameEditChange)
    ON_BN_CLICKED(IDC_ADVANCED_BUTTON, OnAdvancedButton)
END_MESSAGE_MAP()


CDNSZone_NBSTAT_PropertyPage::CDNSZone_NBSTAT_PropertyPage() 
                : CDNSZone_WINSBase_PropertyPage(IDD_ZONE_NBSTAT_PAGE)
{
    m_iWINSMsg = IDS_MSG_ZONE_NBSTAT_FAILED;
    m_nReplCheckTextID = IDS_CHECK_TEXT_USE_LOCAL_WINSR;
}

void CDNSZone_NBSTAT_PropertyPage::OnDomainNameEditChange()
{
    SetDirty(TRUE);
}

void CDNSZone_NBSTAT_PropertyPage::EnableUI(BOOL bEnable)
{
    CDNSZone_WINSBase_PropertyPage::EnableUI(bEnable);
    GetDomainNameEdit()->EnableWindow(bEnable);
}

void CDNSZone_NBSTAT_PropertyPage::EnableUI()
{
    CDNSZone_WINSBase_PropertyPage::EnableUI();

    if (m_bPrimaryZone)
    {
    GetDlgItem(IDC_USE_WINS_RES_CHECK)->EnableWindow(TRUE);
        GetDomainNameEdit()->EnableWindow(GetZoneNode()->HasWinsRecord());
    }
  else if (m_bStub)
  {
    GetDlgItem(IDC_USE_WINS_RES_CHECK)->EnableWindow(FALSE);
    EnableUI(FALSE);
  }
    else    // secondary zone
    {
    GetDlgItem(IDC_USE_WINS_RES_CHECK)->EnableWindow(TRUE);
        switch (m_nState)
        {
            case wins_local_state :
                GetDomainNameEdit()->EnableWindow(TRUE);
                break;
            case wins_not_local_state :
                GetDomainNameEdit()->EnableWindow(FALSE);
                break;
            case no_wins_state :
                GetDomainNameEdit()->EnableWindow(FALSE);
                break;
            default :   // Illegal state
                break;
        }
    }       
}

BOOL CDNSZone_NBSTAT_PropertyPage::IsValidTempRecord()
{
  CDNS_NBSTAT_Record* pRecord = (CDNS_NBSTAT_Record*)m_pTempRecord;
  CString szTemp = pRecord->m_szNameResultDomain;
  szTemp.TrimLeft();
  szTemp.TrimRight();
  return (!szTemp.IsEmpty());
}


void CDNSZone_NBSTAT_PropertyPage::SetUIData()
{
    CDNSZone_WINSBase_PropertyPage::SetUIData();
    CDNS_NBSTAT_Record* pRecord = (CDNS_NBSTAT_Record*)m_pTempRecord;
    GetDoNotReplicateCheck()->SetCheck(pRecord->m_dwMappingFlag & DNS_WINS_FLAG_LOCAL);

    // strip out the "in-addr.arpa" suffix
    CString szTemp = pRecord->m_szNameResultDomain;
    //VERIFY(RemoveInAddrArpaSuffix(szTemp.GetBuffer(1)));
    //szTemp.ReleaseBuffer();
    GetDomainNameEdit()->SetWindowText(szTemp);
}

DNS_STATUS CDNSZone_NBSTAT_PropertyPage::GetUIDataEx(BOOL bSilent)
{
    DNS_STATUS err = CDNSZone_WINSBase_PropertyPage::GetUIDataEx(bSilent);
    CDNS_NBSTAT_Record* pRecord = (CDNS_NBSTAT_Record*)m_pTempRecord;
    pRecord->m_dwMappingFlag = GetDoNotReplicateCheck()->GetCheck() ?
        pRecord->m_dwMappingFlag |= DNS_WINS_FLAG_LOCAL :
        pRecord->m_dwMappingFlag &= ~DNS_WINS_FLAG_LOCAL;

    GetDomainNameEdit()->GetWindowText(pRecord->m_szNameResultDomain);
  return err;
}

void CDNSZone_NBSTAT_PropertyPage::OnAdvancedButton()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
  FIX_THREAD_STATE_MFC_BUG();
   CThemeContextActivator activator;


    CDNS_NBSTAT_Record* pRecord = (CDNS_NBSTAT_Record*)m_pTempRecord;
    CWinsAdvancedDialog dlg(GetHolder(), TRUE);
    dlg.m_dwLookupTimeout = pRecord->m_dwLookupTimeout;
    dlg.m_dwCacheTimeout = pRecord->m_dwCacheTimeout;
    dlg.m_bNetBios = pRecord->m_dwMappingFlag & DNS_WINS_FLAG_SCOPE;
    
    if (IDOK == dlg.DoModal())
    {
        pRecord->m_dwLookupTimeout = dlg.m_dwLookupTimeout;
        pRecord->m_dwCacheTimeout = dlg.m_dwCacheTimeout;
        pRecord->m_dwMappingFlag = dlg.m_bNetBios ?
                    pRecord->m_dwMappingFlag |= DNS_WINS_FLAG_SCOPE :
                    pRecord->m_dwMappingFlag &= ~DNS_WINS_FLAG_SCOPE;
        SetDirty(TRUE);

    }
}

///////////////////////////////////////////////////////////////////////////////
// CDNSZoneNameServersPropertyPage


BOOL CDNSZoneNameServersPropertyPage::OnSetActive()
{
  BOOL bRet = CDNSNameServersPropertyPage::OnSetActive();
  if (bRet)
  {
    CDNSZonePropertyPageHolder* pHolder = (CDNSZonePropertyPageHolder*)GetHolder();
    BOOL bReadOnly = !pHolder->IsPrimaryZoneUI();
    if (m_bReadOnly != bReadOnly)
    {
      m_bReadOnly = bReadOnly;
      EnableButtons(!m_bReadOnly);
    }
  }
  return bRet;
}

void CDNSZoneNameServersPropertyPage::ReadRecordNodesList()
{
    ASSERT(m_pCloneInfoList != NULL);
    CDNSZonePropertyPageHolder* pHolder = (CDNSZonePropertyPageHolder*)GetHolder();
    CDNSZoneNode* pDomainNode = pHolder->GetZoneNode();
    SetDomainNode(pDomainNode);
    pDomainNode->GetNSRecordNodesInfo(m_pCloneInfoList);
}


BOOL CDNSZoneNameServersPropertyPage::WriteNSRecordNodesList()
{
    ASSERT(m_pCloneInfoList != NULL);
    CDNSZonePropertyPageHolder* pHolder = (CDNSZonePropertyPageHolder*)GetHolder();
    CDNSZoneNode* pDomainNode = pHolder->GetZoneNode();
    return pDomainNode->UpdateNSRecordNodesInfo(m_pCloneInfoList, pHolder->GetComponentData());
}


///////////////////////////////////////////////////////////////////////////////
// CDNSZonePropertyPageHolder

CDNSZonePropertyPageHolder::CDNSZonePropertyPageHolder(CCathegoryFolderNode* pFolderNode, 
                                CDNSZoneNode* pZoneNode, CComponentDataObject* pComponentData)
        : CPropertyPageHolderBase(pFolderNode, pZoneNode, pComponentData)
{
    ASSERT(pComponentData != NULL);
    ASSERT(pFolderNode != NULL);
    ASSERT(pFolderNode == GetContainerNode());
    ASSERT(pZoneNode != NULL);
    ASSERT(pZoneNode == GetZoneNode());

    m_bAutoDeletePages = FALSE; // we have the pages as embedded members

    int nCurrPage = 0;
    m_nGenPage = -1;
    m_nSOAPage = -1;
    m_nWINSorWINSRPage = -1;
    m_nNSPage  = -1;

    // add pages
    m_nGenPage = nCurrPage;
    AddPageToList((CPropertyPageBase*)&m_generalPage);
    nCurrPage++;

  m_nSOAPage = nCurrPage;
    AddPageToList((CPropertyPageBase*)&m_SOARecordPage);
    nCurrPage++;
    
    m_nNSPage = nCurrPage;
    AddPageToList((CPropertyPageBase*)&m_nameServersPage);
    nCurrPage++;

    if (pZoneNode->IsReverse())
    {
        m_nWINSorWINSRPage = nCurrPage;
        AddPageToList((CPropertyPageBase*)&m_NBSTATRecordPage);
        nCurrPage++;
    }
    else
    {
        m_nWINSorWINSRPage = nCurrPage;
        AddPageToList((CPropertyPageBase*)&m_WINSRecordPage);
        nCurrPage++;
    }

    AddPageToList((CPropertyPageBase*)&m_zoneTransferPage);

    // security page added only if needed
    m_pAclEditorPage = NULL;
    if (pZoneNode->IsDSIntegrated())
    {
        CString szPath;
        pZoneNode->GetServerNode()->CreateDsZoneLdapPath(pZoneNode, szPath);
        if (!szPath.IsEmpty())
            m_pAclEditorPage = CAclEditorPage::CreateInstance(szPath, this);
    }

    // determine if we need/can have advanced view
    CDNSRootData* pRootData = (CDNSRootData*)pComponentData->GetRootData();
    ASSERT(pRootData != NULL);
    m_bAdvancedView = pRootData->IsAdvancedView();

}

CDNSZonePropertyPageHolder::~CDNSZonePropertyPageHolder()
{
    if (m_pAclEditorPage != NULL)
        delete m_pAclEditorPage;
}

int CDNSZonePropertyPageHolder::OnSelectPageMessage(long nPageCode)
{
    TRACE(_T("CDNSZonePropertyPageHolder::OnSelectPageMessage()\n"));

    switch (nPageCode)
    {
    case ZONE_HOLDER_GEN:
        return m_nGenPage;
    case ZONE_HOLDER_SOA:
        return m_nSOAPage;
    case ZONE_HOLDER_NS:
        return m_nNSPage;
    case ZONE_HOLDER_WINS:
        return m_nWINSorWINSRPage;
    }
    return -1;
}

HRESULT CDNSZonePropertyPageHolder::OnAddPage(int nPage, CPropertyPageBase*)
{
    // add the ACL editor page after the last, if present
    if ( (nPage != -1) || (m_pAclEditorPage == NULL) )
        return S_OK; 

    // add the ACLU page 
    HPROPSHEETPAGE  hPage = m_pAclEditorPage->CreatePage();
    if (hPage == NULL)
        return E_FAIL;
    // add the raw HPROPSHEETPAGE to sheet, not in the list
    return AddPageToSheetRaw(hPage);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\zone.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       zone.cpp
//
//--------------------------------------------------------------------------


#include "preDNSsn.h"
#include <SnapBase.h>

#include "resource.h"
#include "dnsutil.h"
#include "DNSSnap.h"
#include "snapdata.h"

#include "server.h"
#include "domain.h"
#include "record.h"
#include "zone.h"

#ifdef DEBUG_ALLOCATOR
	#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
	#endif
#endif


////////////////////////////////////////////////////////////////////////////
// CDNSZoneNode

// {720132B9-44B2-11d1-B92F-00A0C9A06D2D}
const GUID CDNSZoneNode::NodeTypeGUID = 
{ 0x720132b9, 0x44b2, 0x11d1, { 0xb9, 0x2f, 0x0, 0xa0, 0xc9, 0xa0, 0x6d, 0x2d } };


extern ZONE_TYPE_MAP _ZoneTypeStrings[];

CDNSZoneNode::CDNSZoneNode()
{
  ASSERT(!IsDelegation());
	m_pZoneNode = this; // the zone is us
	m_pZoneInfoEx = new CDNSZoneInfoEx; // empty object with no data inside

	// data valid when zone info not available
	m_dwZoneFlags = 0x0;
	m_wZoneType = 0x0;

	NullCachedPointers();

}

CDNSZoneNode::~CDNSZoneNode()
{
	TRACE(_T("~CDNSZoneNode(), name <%s>\n"),GetDisplayName());
	if (m_pZoneInfoEx != NULL)
		delete m_pZoneInfoEx;
}

#ifdef USE_NDNC
ReplicationType CDNSZoneNode::GetDirectoryPartitionFlagsAsReplType()
{
  ReplicationType replReturn = w2k;

  DWORD dwFlags = GetDirectoryPartitionFlags();
  if (dwFlags & DNS_DP_DOMAIN_DEFAULT)
  {
    replReturn = domain;
  }
  else if (dwFlags & DNS_DP_FOREST_DEFAULT)
  {
    replReturn = forest;
  }
  else
  {
    if (dwFlags & DNS_DP_LEGACY)
    {
      replReturn = w2k;
    }
    else
    {
      replReturn = custom;
    }
  }
  return replReturn;  
}

PCWSTR CDNSZoneNode::GetCustomPartitionName()
{
  USES_CONVERSION;

  if (m_pZoneInfoEx &&
      m_pZoneInfoEx->HasData())
  {
    m_szPartitionName = UTF8_TO_W(m_pZoneInfoEx->m_pZoneInfo->pszDpFqdn);
  }
  return m_szPartitionName;
}

DNS_STATUS CDNSZoneNode::ChangeDirectoryPartitionType(ReplicationType type, PCWSTR pszCustomPartition)
{
  USES_CONVERSION;

  PSTR pszReplScope = 0;
  switch (type)
  {
    case domain :
      pszReplScope = DNS_DP_DOMAIN_STR;
      break;

    case forest :
      pszReplScope = DNS_DP_FOREST_STR;
      break;

    case w2k :
      pszReplScope = DNS_DP_LEGACY_STR;
      break;

    default :
      pszReplScope = W_TO_UTF8(pszCustomPartition);
      break;
  }

  DNS_STATUS dwErr = ::DnssrvChangeZoneDirectoryPartition(GetServerNode()->GetRPCName(),
                                                          W_TO_UTF8(GetFullName()),
                                                          pszReplScope);

  if (dwErr == 0)
  {
     GetZoneInfo();
  }
  return dwErr;
}
#endif // USE_NDNC

LPCWSTR CDNSZoneNode::GetString(int nCol)
{
	switch (nCol)
	{
	case 0:
    //
    // Zone name
    //
    return GetDisplayName();

	case 1:
    //
    // Zone type
    //
		{
			if (GetZoneType() == DNS_ZONE_TYPE_PRIMARY && IsDSIntegrated())
      {
        return _ZoneTypeStrings[0].szBuffer;
      }

      if (GetZoneType() == DNS_ZONE_TYPE_SECONDARY)
      {
        return _ZoneTypeStrings[2].szBuffer;
      }

      if (GetZoneType() == DNS_ZONE_TYPE_STUB)
      {
        if (IsDSIntegrated())
        {
          return _ZoneTypeStrings[6].szBuffer;
        }
        else
        {
          return _ZoneTypeStrings[5].szBuffer;
        }
      }

      //
      // Standard primary
      //
      return _ZoneTypeStrings[1].szBuffer;
		}
/*  case 2:
    //
    // Directory Partition Name
    //
    {
      CDNSServerNode* pServerNode = GetServerNode();
      if (!IsDSIntegrated() ||
          pServerNode->GetBuildNumber() < DNS_SRV_BUILD_NUMBER_WHISTLER ||
          (pServerNode->GetMajorVersion() <= DNS_SRV_MAJOR_VERSION_NT_5 &&
           pServerNode->GetMinorVersion() < DNS_SRV_MINOR_VERSION_WHISTLER))
      {
        //
        // The zone is not DS integrated
        // or
        // this is a pre-Whistler server, no Application Directory Partition support
        //
        return g_lpszNullString;
      }

      DWORD dwDpFlags = GetDirectoryPartitionFlags();
      if (dwDpFlags == 0 ||
          dwDpFlags & DNS_DP_LEGACY)
      {
        //
        // To all DCs in the domain
        //

        // REVIEW_JEFFJON : todo!!!
        return g_lpszNullString;
      }
      else if (dwDpFlags & DNS_DP_DOMAIN_DEFAULT)
      {
        //
        // To all DNS servers in the domain
        //

        // REVIEW_JEFFJON : todo!!!
        return g_lpszNullString;
      }
      else if (dwDpFlags & DNS_DP_ENTERPRISE_DEFAULT)
      {
        //
        // To all DNS servers in the forest
        //

        // REVIEW_JEFFJON : todo!!!
        return g_lpszNullString;
      }
      else if (dwDpFlags & DNS_DP_ENLISTED)
      {
        //
        // To all DCs in the application directory partition
        //
        return GetCustomPartitionName();
      }
    }
    break;
*/
	case 2:
    //
    // Status
    //
    {
      if (IsPaused())
      {
        return _ZoneTypeStrings[4].szBuffer;
      }
      return _ZoneTypeStrings[3].szBuffer;
    }
	}
	return g_lpszNullString;
}
 

void CDNSZoneNode::InitializeFromRPCZoneInfo(PDNS_RPC_ZONE pZoneInfo, BOOL bAdvancedView)
{
	USES_CONVERSION;
	ASSERT(m_pZoneInfoEx != NULL);
	ASSERT(!m_pZoneInfoEx->HasData());
	ASSERT(pZoneInfo != NULL);

	m_dwZoneFlags = 0x0;
	if (pZoneInfo->Flags.Paused) m_dwZoneFlags |= DNS_ZONE_Paused;
	if (pZoneInfo->Flags.Shutdown) m_dwZoneFlags |= DNS_ZONE_Shutdown;
	if (pZoneInfo->Flags.Reverse) m_dwZoneFlags |= DNS_ZONE_Reverse;
	if (pZoneInfo->Flags.AutoCreated) m_dwZoneFlags |= DNS_ZONE_AutoCreated;
	if (pZoneInfo->Flags.DsIntegrated) m_dwZoneFlags |= DNS_ZONE_DsIntegrated;

	m_wZoneType = pZoneInfo->ZoneType;
	SetNames(IsZone(), pZoneInfo->Flags.Reverse, bAdvancedView, 
		pZoneInfo->pszZoneName, pZoneInfo->pszZoneName);
}



void CDNSZoneNode::FreeZoneInfo()
{
	if (m_pZoneInfoEx)
   {
	   m_pZoneInfoEx->FreeInfo();
   }
}

DNS_STATUS CDNSZoneNode::GetZoneInfo()
{
	ASSERT(m_pZoneInfoEx != NULL);
	CDNSServerNode* pServerNode = GetServerNode();
	ASSERT(pServerNode != NULL);
	return m_pZoneInfoEx->Query(pServerNode->GetRPCName(),
								GetFullName(),
								pServerNode->GetVersion());
}

void CDNSZoneNode::AttachZoneInfo(CDNSZoneInfoEx* pNewInfo)
{
	ASSERT(pNewInfo != NULL);
	if (m_pZoneInfoEx != NULL)
		delete m_pZoneInfoEx;
	m_pZoneInfoEx = pNewInfo;
}





void CDNSZoneNode::SetZoneNormalViewHelper(CString& szDisplayName)
{
	// the display name is stripped of the "in-addr.arpa" suffix
	// e.g. from "127.in-addr.arpa" to "127"
	// e.g. from "55.157.in-addr.arpa" to "55.157"
	BOOL bArpa = RemoveInAddrArpaSuffix(szDisplayName.GetBuffer(1));
	szDisplayName.ReleaseBuffer();
	if (!bArpa)
		return;

	LPWSTR lpsz1 = szDisplayName.GetBuffer(1);
	int nOctects = ReverseIPString(lpsz1);
	//ASSERT(nOctects > 0 && nOctects < 4);
	szDisplayName.ReleaseBuffer(); // got "157.80"
	switch(nOctects)
	{
	case 1:
		szDisplayName += _T(".x.x.x Subnet");
		break;
	case 2:
		szDisplayName += _T(".x.x Subnet");
		break;
	case 3:
		szDisplayName += _T(".x Subnet");
		break;
	}
}


void CDNSZoneNode::ChangeViewOption(BOOL bAdvanced,
					CComponentDataObject* pComponentDataObject)
{
	ASSERT(IsReverse());
	if (!IsReverse())
		return;

	// change the display name
	m_szDisplayName = GetFullName();
	if (!bAdvanced)
	{
		SetZoneNormalViewHelper(m_szDisplayName);
	}
	if(IsVisible())
		VERIFY(SUCCEEDED(pComponentDataObject->ChangeNode(this, CHANGE_RESULT_ITEM_DATA)));

	// change the display name for all PTR records in the tree
	ChangePTRRecordsViewOption(bAdvanced, pComponentDataObject);
}



BOOL CDNSZoneNode::OnAddMenuItem(LPCONTEXTMENUITEM2 pContextMenuItem2, 
                                 long *pInsertionAllowed)
{ 
  DWORD dwType = GetZoneType();

  //
  // call this before the base class because it filters it out
  //
  if (pContextMenuItem2->lCommandID == IDM_ZONE_TRANSFER ||
      pContextMenuItem2->lCommandID == IDM_ZONE_RELOAD_FROM_MASTER)
  {
    //
    // if it is not a secondary, just bail out
    //
		if ( (dwType != DNS_ZONE_TYPE_SECONDARY) && (dwType != DNS_ZONE_TYPE_STUB))
    {
			return FALSE;
    }

    //
		// have the menu item added. but it might be grayed out...
    //
		if (IsThreadLocked() || (m_nState == notLoaded) || (m_nState == loading))
		{
      //
			// thread locked or not loaded state
      //
			pContextMenuItem2->fFlags |= MF_GRAYED;
		}
    return TRUE;
  }

	if (pContextMenuItem2->lCommandID == IDM_ZONE_UPDATE_DATA_FILE)
	{
    //
		// cannot update data file on secondary zones, the cache or autocreated zones
    //
		if ( (dwType != DNS_ZONE_TYPE_PRIMARY) || IsAutocreated() )
    {
			return FALSE;
    }

    //
		// have the menu item added. but it might be grayed out...
    //
		if (m_nState != loaded)
		{
      //
			// not loaded state
      //
			pContextMenuItem2->fFlags |= MF_GRAYED;
		}
		else if ( (dwType == DNS_ZONE_TYPE_PRIMARY) && IsDSIntegrated() )
		{
      //
			// primaries DS integrated
      //
			pContextMenuItem2->fFlags |= MF_GRAYED;
		}
    return TRUE;
	}

  if (pContextMenuItem2->lCommandID == IDM_ZONE_RELOAD)
	{
    //
		// cannot reload the cache or autocreated zones
    //
		if ( (dwType == DNS_ZONE_TYPE_CACHE) || IsAutocreated() )
    {
			return FALSE;
    }

    //
		// have the menu item added. but it might be grayed out...
    //
		if (IsThreadLocked() || (m_nState != loaded))
		{
			// not loaded state
			pContextMenuItem2->fFlags |= MF_GRAYED;
		}
    return TRUE;
	}

  //
	// NOTE: the base class knows about the derived class, so must call like this
  //
	if (!CDNSDomainNode::OnAddMenuItem(pContextMenuItem2,pInsertionAllowed))
  {
		return FALSE;
  }

	return TRUE;
}


BOOL CDNSZoneNode::OnSetRenameVerbState(DATA_OBJECT_TYPES, 
                                        BOOL* pbHide, 
                                        CNodeList*) 
{ 
// REVIEW_JEFFJON : removed from Whistler release
  //*pbHide = FALSE; 
  //return TRUE; 
  *pbHide = TRUE;
  return FALSE;
}

HRESULT CDNSZoneNode::OnRename(CComponentDataObject*,
                               LPWSTR lpszNewName)
{
  TRACE(_T("CDNSZoneNode::OnRename() : new name = %ws\n"), lpszNewName);
  return S_FALSE;
}

HRESULT CDNSZoneNode::GetResultViewType(CComponentDataObject*, 
                                        LPOLESTR *ppViewType, 
                                        long *pViewOptions)
{
  HRESULT hr = S_FALSE;
  BOOL bUseMessageView = FALSE;

  DWORD dwType = GetZoneType();

	// special case for paused/expired zones
	switch (m_nState)
	{
	case loaded:
		{
			if (dwType == DNS_ZONE_TYPE_CACHE)
			{
				bUseMessageView = FALSE;
			}
			else	// authoritated zone
			{
				if (IsPaused())
					bUseMessageView = FALSE;
				else if (IsExpired())
					bUseMessageView = TRUE;
				else
					bUseMessageView = FALSE;
			}
		}
		break;
	case unableToLoad:
	case accessDenied:
		bUseMessageView = TRUE;
		break;
	default:
		bUseMessageView = FALSE;
	}

  if (bUseMessageView)
  {
    *pViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS;

    LPOLESTR psz = NULL;
    StringFromCLSID(CLSID_MessageView, &psz);

    USES_CONVERSION;

    if (psz != NULL)
    {
        *ppViewType = psz;
        hr = S_OK;
    }
  }
  else
  {
	  *pViewOptions = MMC_VIEW_OPTIONS_MULTISELECT;
	  *ppViewType = NULL;
    hr = S_FALSE;
  }
  return hr;
}

HRESULT CDNSZoneNode::OnShow(LPCONSOLE lpConsole)
{
  CComPtr<IUnknown> spUnknown;
  CComPtr<IMessageView> spMessageView;

  HRESULT hr = lpConsole->QueryResultView(&spUnknown);
  if (FAILED(hr))
    return S_OK;

  hr = spUnknown->QueryInterface(IID_IMessageView, (PVOID*)&spMessageView);
  if (SUCCEEDED(hr))
  {
    CString szTitle, szMessage;
    IconIdentifier iconID;

    DWORD dwType = GetZoneType();
    if ((dwType == DNS_ZONE_TYPE_PRIMARY) && IsDSIntegrated())
    {
      VERIFY(szTitle.LoadString(IDS_MESSAGE_VIEW_ZONE_NOT_LOADED_TITLE));
      VERIFY(szMessage.LoadString(IDS_MESSAGE_VIEW_ZONE_NOT_LOADED_DS_MESSAGE));
      iconID = Icon_Error;
    }
    else if ((dwType == DNS_ZONE_TYPE_PRIMARY) && !IsDSIntegrated())
    {
      VERIFY(szTitle.LoadString(IDS_MESSAGE_VIEW_ZONE_NOT_LOADED_TITLE));
      VERIFY(szMessage.LoadString(IDS_MESSAGE_VIEW_ZONE_NOT_LOADED_PRIMARY_MESSAGE));
      iconID = Icon_Error;
    }
    else
    {
      VERIFY(szTitle.LoadString(IDS_MESSAGE_VIEW_ZONE_NOT_LOADED_TITLE));
      VERIFY(szMessage.LoadString(IDS_MESSAGE_VIEW_ZONE_NOT_LOADED_SECONDARY_MESSAGE));
      iconID = Icon_Error;
    }
    spMessageView->SetTitleText(szTitle);
    spMessageView->SetBodyText(szMessage);
    spMessageView->SetIcon(iconID);
  }
  
  return S_OK;
}


int CDNSZoneNode::GetImageIndex(BOOL) 
{
	DWORD dwType = GetZoneType();
	BOOL bPrimary = (dwType == DNS_ZONE_TYPE_PRIMARY);

	// special case for paused/expired zones
	int nIndex = -1;
	switch (m_nState)
	{
	case notLoaded:
		nIndex = (bPrimary) ? ZONE_IMAGE_NOT_LOADED_1 : ZONE_IMAGE_NOT_LOADED_2;
		break;
	case loading:
		nIndex = (bPrimary) ? ZONE_IMAGE_LOADING_1 : ZONE_IMAGE_LOADING_2;
		break;
	case loaded:
		{
			if (dwType == DNS_ZONE_TYPE_CACHE)
			{
				nIndex = (bPrimary) ? ZONE_IMAGE_LOADED_1 : ZONE_IMAGE_LOADED_2;
			}
			else	// authoritated zone
			{
				if (IsPaused())
					nIndex = (bPrimary) ? ZONE_IMAGE_PAUSED_1 : ZONE_IMAGE_PAUSED_2;
				else if (IsExpired())
					nIndex = (bPrimary) ? ZONE_IMAGE_EXPIRED_1 : ZONE_IMAGE_EXPIRED_2;
				else
					nIndex = (bPrimary) ? ZONE_IMAGE_LOADED_1 : ZONE_IMAGE_LOADED_2;
			}
		}
		break;
	case unableToLoad:
		nIndex = (bPrimary) ? ZONE_IMAGE_UNABLE_TO_LOAD_1 : ZONE_IMAGE_UNABLE_TO_LOAD_2;
		break;
	case accessDenied:
		nIndex = (bPrimary) ? ZONE_IMAGE_ACCESS_DENIED_1 : ZONE_IMAGE_ACCESS_DENIED_2;
		break;
	default:
		ASSERT(FALSE);
	}
	ASSERT(nIndex > 0);
	return nIndex;
}



HRESULT CDNSZoneNode::OnCommand(long nCommandID, 
                                DATA_OBJECT_TYPES, 
								                CComponentDataObject* pComponentData,
                                CNodeList* pNodeList)
{
  if (pNodeList->GetCount() > 1) // multiple selection
  {
    return E_FAIL;
  }

	switch (nCommandID)
	{
		case IDM_DOMAIN_NEW_DOMAIN:
			OnNewDomain(pComponentData);
			break;
		case IDM_DOMAIN_NEW_DELEGATION:
			OnNewDelegation(pComponentData);
			break;
		case IDM_DOMAIN_NEW_RECORD:
			OnNewRecord(pComponentData, pNodeList);
			break;
		case IDM_DOMAIN_NEW_HOST:
			OnNewHost(pComponentData);
			break;
		case IDM_DOMAIN_NEW_ALIAS:
			OnNewAlias(pComponentData);
			break;
		case IDM_DOMAIN_NEW_MX:
			OnNewMailExchanger(pComponentData);
			break;
		case IDM_DOMAIN_NEW_PTR:
			OnNewPointer(pComponentData);
			break;

		case IDM_ZONE_UPDATE_DATA_FILE:
			OnUpdateDataFile(pComponentData);
			break;
		case IDM_ZONE_RELOAD:
			OnReload(pComponentData);
			break;
		case IDM_ZONE_TRANSFER:
			OnTransferFromMaster(pComponentData);
			break;
    case IDM_ZONE_RELOAD_FROM_MASTER:
      OnReloadFromMaster(pComponentData);
      break;

		case IDM_SNAPIN_ADVANCED_VIEW:
			((CDNSRootData*)pComponentData->GetRootData())->OnViewOptions(pComponentData);
			break;
		case IDM_SNAPIN_FILTERING:
      {
        if (((CDNSRootData*)pComponentData->GetRootData())->OnFilteringOptions(pComponentData))
        {
          pComponentData->SetDescriptionBarText(this);
        }
      }
			break;
    default:
			ASSERT(FALSE); // Unknown command!
			return E_FAIL;
	}
    return S_OK;
}

void CDNSZoneNode::OnUpdateDataFile(CComponentDataObject* pComponentData)
{
	// if there are sheets up, ask to close them down, because a
	// failure would "Red X" the server and remove all the children
	if (IsSheetLocked())
	{
		if (!CanCloseSheets())
			return;
		pComponentData->GetPropertyPageHolderTable()->DeleteSheetsOfNode(this);
	}

	ASSERT(m_nState == loaded);
	OnChangeState(pComponentData); // move to loading

  { // scope for the wait cursor
    CWaitCursor wait;
	  m_dwErr = WriteToDatabase();
  }

	// if there is a failure, remove all children,
	// will need a refresh to get them back
	if (m_dwErr != 0)
	{
		RemoveAllChildrenHelper(pComponentData);
		ASSERT(!HasChildren());
	}
	OnChangeState(pComponentData); // move to loaded or unableToLoad
}

void CDNSZoneNode::OnReload(CComponentDataObject* pComponentData)
{
  UINT nRet = DNSConfirmOperation(IDS_MSG_ZONE_RELOAD, this);
 	if (IDCANCEL == nRet ||
      IDNO == nRet)
  {
		return;
  }

	// if there are sheets up, ask to close them down, because
  // we will need a refresh
	if (IsSheetLocked())
	{
		if (!CanCloseSheets())
			return;
		pComponentData->GetPropertyPageHolderTable()->DeleteSheetsOfNode(this);
	}

	ASSERT(m_nState == loaded);

  DNS_STATUS err;
	{ // scope for the wait cursor
    CWaitCursor wait;
	  err = Reload();
  }

  if (err != 0)
  {
    // need to let the user know the operation failed
    DNSErrorDialog(err, IDS_MSG_ZONE_FAIL_RELOAD);
    return;
  }

  CNodeList nodeList;
  nodeList.AddTail(this);

  // the zone has been reloaded cause a refresh to get new data
  VERIFY(OnRefresh(pComponentData, &nodeList));
}


void CDNSZoneNode::OnTransferFromMaster(CComponentDataObject* pComponentData)
{
	// if there are sheets up, ask to close them down, because
  // we will need a refresh
	if (IsSheetLocked())
	{
		if (!CanCloseSheets())
			return;
		pComponentData->GetPropertyPageHolderTable()->DeleteSheetsOfNode(this);
	}

	ASSERT(m_nState != notLoaded);
	ASSERT(m_nState != loading);

  DNS_STATUS err;
	{ // scope for the wait cursor
    CWaitCursor wait;
	  err = TransferFromMaster();
  }

  if (err != 0)
  {
    // need to let the user know the operation failed
    DNSErrorDialog(err, IDS_MSG_ZONE_FAIL_TRANSFER);
    return;
  }

  CNodeList nodeList;
  nodeList.AddTail(this);

  // the zone has been reloaded cause a refresh to get new data
  VERIFY(OnRefresh(pComponentData, &nodeList));
}

void CDNSZoneNode::OnReloadFromMaster(CComponentDataObject* pComponentData)
{
	// if there are sheets up, ask to close them down, because
  // we will need a refresh
	if (IsSheetLocked())
	{
		if (!CanCloseSheets())
			return;
		pComponentData->GetPropertyPageHolderTable()->DeleteSheetsOfNode(this);
	}

	ASSERT(m_nState != notLoaded);
	ASSERT(m_nState != loading);

  DNS_STATUS err;
	{ // scope for the wait cursor
    CWaitCursor wait;
	  err = ReloadFromMaster();
  }

  if (err != 0)
  {
    // need to let the user know the operation failed
    DNSErrorDialog(err, IDS_MSG_ZONE_FAIL_RELOAD_FROM_MASTER);
    return;
  }

  CNodeList nodeList;
  nodeList.AddTail(this);

  // the zone has been reloaded cause a refresh to get new data
  VERIFY(OnRefresh(pComponentData, &nodeList));
}

void CDNSZoneNode::OnDelete(CComponentDataObject* pComponentData,
                            CNodeList* pNodeList)
{
  if (pNodeList->GetCount() > 1) // multiple selection
  {
    OnMultiselectDelete(pComponentData, pNodeList);
    return;
  }

  UINT nRet = DNSConfirmOperation(IDS_MSG_ZONE_DELETE, this);
	if (IDCANCEL == nRet ||
      IDNO == nRet)
  {
		return;
  }

  BOOL bDeleteFromDS = FALSE;
  if (((GetZoneType() == DNS_ZONE_TYPE_PRIMARY) || (GetZoneType() == DNS_ZONE_TYPE_STUB)) && 
      IsDSIntegrated())
  {
    if (GetServerNode()->GetBootMethod() == BOOT_METHOD_DIRECTORY)
    {
      // ask confirmation on delete from DS
      int nRetVal = DNSMessageBox(IDS_MSG_ZONE_DELETE_FROM_DS_BOOT3, 
                                  MB_YESNO | MB_DEFBUTTON2);
      if (IDNO == nRetVal)
        return;
      bDeleteFromDS = TRUE;
    }
    else
    {
      // ask confirmation on delete from DS
      int nRetVal = DNSMessageBox(IDS_MSG_ZONE_DELETE_FROM_DS, 
                                  MB_YESNOCANCEL | MB_DEFBUTTON3);
      if (IDCANCEL == nRetVal)
        return;
      bDeleteFromDS = (nRetVal == IDYES);
    }
  }


	if (IsSheetLocked())
	{
      // NTRAID#NTBUG-594003-2002/04/11-JeffJon-Don't offer
      // to shutdown the sheets for the user because if the
      // sheet brought up a modal dialog we will deadlock
      // ourselves.

		DNSMessageBox(IDS_ZONE_WARNING_SHEETS_UP, MB_OK);
		return;
	}

	DNS_STATUS err = Delete(bDeleteFromDS);
	if (err != 0)
	{
		DNSErrorDialog(err, IDS_MSG_ZONE_FAIL_DELETE);
		return;
	}


	// now remove from the UI and from the cache
	DeleteHelper(pComponentData);
  pComponentData->UpdateResultPaneView(GetContainer());

  if (IsRootZone())
  {
    if (DNSMessageBox(IDS_MSG_ZONE_DELETE_ROOT, MB_YESNO) == IDYES)
    {
      GetServerNode()->SetProppageStart(3); // 3 signifies the Root Hints page

      if (GetServerNode()->GetSheetCount() > 0)
      {
         GetServerNode()->GetRootHints()->ShowPageForNode(pComponentData);
      }
      else
      {
         pComponentData->CreatePropertySheet(
            GetServerNode(), 
            NULL, 
            GetServerNode()->GetDisplayName());
      }
    }
  }

	delete this; // gone
}

BOOL CDNSZoneNode::HasPropertyPages(DATA_OBJECT_TYPES, 
                                    BOOL* pbHideVerb,
                                    CNodeList* pNodeList)
{
  if (pNodeList->GetCount() > 1) // multiple selection
  {
    return FALSE;
  }

	*pbHideVerb = FALSE; // always show the verb

  if (!m_bHasDataForPropPages)
    return FALSE;

	// cannot have property pages only in loaded state
//	if (m_nState != loaded)
	//	return FALSE;

	ASSERT(m_pZoneInfoEx != NULL);
	if ( (!m_pZoneInfoEx->HasData()) || 
			( (GetZoneType() == DNS_ZONE_TYPE_CACHE) || IsAutocreated() ) )
  {
		return FALSE;
  }
	return TRUE;
}

HRESULT CDNSZoneNode::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, 
                                          LONG_PTR handle,
                                          CNodeList* pNodeList)
{
  ASSERT(pNodeList->GetCount() == 1); // multi-select not supported
	ASSERT(m_bHasDataForPropPages);
	if (GetSheetCount() > 0)
	{
		CComponentDataObject* pComponentDataObject = 
				((CRootData*)(GetContainer()->GetRootContainer()))->GetComponentDataObject();
		ASSERT(pComponentDataObject != NULL);
		pComponentDataObject->GetPropertyPageHolderTable()->BroadcastSelectPage(this, ZONE_HOLDER_GEN);
		return S_OK;
	}
	return CreatePropertyPagesHelper(lpProvider, handle, ZONE_HOLDER_GEN);
}

HRESULT CDNSZoneNode::CreatePropertyPagesHelper(LPPROPERTYSHEETCALLBACK lpProvider, 
									LONG_PTR handle, long nStartPageCode)
{
   CComponentDataObject* pComponentDataObject = 
		   ((CRootData*)(GetContainer()->GetRootContainer()))->GetComponentDataObject();
   ASSERT(pComponentDataObject != NULL);
	
   HRESULT hr = S_OK;

   CDNSZonePropertyPageHolder* pHolder = 
		   new CDNSZonePropertyPageHolder((CCathegoryFolderNode*)GetContainer(), this, pComponentDataObject);
	
   if (pHolder)
   {
      pHolder->SetStartPageCode(nStartPageCode);
      pHolder->SetSheetTitle(IDS_PROP_SHEET_TITLE_FMT, this);
	   hr = pHolder->CreateModelessSheet(lpProvider, handle);
   }
   else
   {
      hr = E_OUTOFMEMORY;
   }

   return hr;
}

void CDNSZoneNode::Show(BOOL bShow, CComponentDataObject* pComponentData)
{
  CDNSDomainNode::Show(bShow, pComponentData);
  if (!bShow)
    NullCachedPointers();
}

void CDNSZoneNode::NullCachedPointers()
{
	m_pSOARecordNode = NULL;
	m_pWINSRecordNode = NULL;
}


BOOL CDNSZoneNode::OnRefresh(CComponentDataObject* pComponentData,
                             CNodeList* pNodeList)
{
  if (pNodeList->GetCount() > 1) // multiple selection
  {
    BOOL bRet = TRUE;

    POSITION pos = pNodeList->GetHeadPosition();
    while (pos != NULL)
    {
      CTreeNode* pNode = pNodeList->GetNext(pos);
      ASSERT(pNode != NULL);

      CNodeList nodeList;
      nodeList.AddTail(pNode);

      if (!pNode->OnRefresh(pComponentData, &nodeList))
      {
        bRet = FALSE;
      }
    }
    return bRet;
  }

  CNodeList nodeList;
  nodeList.AddTail(this);
	if (CDNSDomainNode::OnRefresh(pComponentData, &nodeList))
	{
		FreeZoneInfo();
		NullCachedPointers();
		return TRUE;
	}
	return FALSE;
}

void CDNSZoneNode::OnHaveData(CObjBase* pObj, CComponentDataObject* pComponentDataObject)
{
	// if we get the zone info, just set it and bail out (no UI)
	if (IS_CLASS(*pObj, CDNSZoneInfoEx))
	{
		ASSERT(!HasChildren()); // must be the first one coming from the thread
		AttachZoneInfo(dynamic_cast<CDNSZoneInfoEx*>(pObj));
		return;
	}
	CDNSDomainNode::OnHaveData(pObj, pComponentDataObject);
}

void CDNSZoneNode::OnHaveRecord(CDNSRecordNodeBase* pRecordNode, 
								CComponentDataObject* pComponentDataObject)
{
	CDNSDomainNode::OnHaveRecord(pRecordNode, pComponentDataObject);
	if ((pRecordNode->GetType() == DNS_TYPE_SOA) && pRecordNode->IsAtTheNode())
	{
		ASSERT(m_pSOARecordNode == NULL);
		m_pSOARecordNode = (CDNS_SOA_RecordNode*)pRecordNode;
	}
	else if ( ( (pRecordNode->GetType() == DNS_TYPE_WINS) || 
		        (pRecordNode->GetType() == DNS_TYPE_NBSTAT) ) && pRecordNode->IsAtTheNode() )
	{
		ASSERT(m_pWINSRecordNode == NULL);
		ASSERT( (IsReverse() && pRecordNode->GetType() == DNS_TYPE_NBSTAT) ||
				(!IsReverse() && pRecordNode->GetType() == DNS_TYPE_WINS ) );
		m_pWINSRecordNode = pRecordNode;
	}
}



//////////////////////////////////////////////////////////////////////////////////

DNS_STATUS CDNSZoneNode::CreatePrimary(LPCTSTR lpszDBName, 
                                       BOOL bLoadExisting, 
                                       BOOL bDSIntegrated,
                                       UINT nDynamicUpdate)
{
	USES_CONVERSION;
	DWORD dwZoneType = DNS_ZONE_TYPE_PRIMARY;
	IP_ADDRESS adwIpAddressDummy = 0;

  LPCWSTR lpszServerName = GetServerNode()->GetRPCName();
  LPCSTR lpszAnsiZoneName = W_TO_UTF8(GetFullName()); 
  // create the zone
  DNS_STATUS err = ::DnssrvCreateZone(
          lpszServerName,	
          lpszAnsiZoneName,
          dwZoneType,										// Zone type
          NULL,                         // RNAME field should be NULL according to bug 135245
          0,												    // Number of masters, NA for primary
          &adwIpAddressDummy,						// Array of masters, dummy for primary
      		bLoadExisting,
          bDSIntegrated,	
          bDSIntegrated ? NULL : W_TO_UTF8(lpszDBName), // Database file
          0,
          0);	
	if (err != 0)
		return err;

  // set the dynamic update flag
  err = ::DnssrvResetDwordProperty(lpszServerName, lpszAnsiZoneName,
          													DNS_REGKEY_ZONE_ALLOW_UPDATE, nDynamicUpdate);
	if (err != 0)
		return err;

	ASSERT(m_pZoneInfoEx != NULL);
	return GetZoneInfo();
}

#ifdef USE_NDNC
DNS_STATUS CDNSZoneNode::CreatePrimaryInDirectoryPartition(BOOL bLoadExisting, 
                                                           UINT nDynamicUpdate,
                                                           ReplicationType replType,
                                                           PCWSTR pszPartitionName)
{
	USES_CONVERSION;
	DWORD dwZoneType = DNS_ZONE_TYPE_PRIMARY;
	IP_ADDRESS adwIpAddressDummy = 0;

  DWORD dwPartitionFlags = 0;
  switch (replType)
  {
  case forest:
    dwPartitionFlags |= DNS_DP_FOREST_DEFAULT;
    break;
    
  case domain:
    dwPartitionFlags |= DNS_DP_DOMAIN_DEFAULT;
    break;

  case w2k:
    dwPartitionFlags |= DNS_DP_LEGACY;
    break;

  case custom:
    dwPartitionFlags = 0;
    break;

  case none:
  default:
    ASSERT(FALSE);
    break;
  }

  LPCWSTR lpszServerName = GetServerNode()->GetRPCName();
  LPCSTR lpszAnsiZoneName = W_TO_UTF8(GetFullName()); 
  LPCSTR lpszUTF8PartitionName = W_TO_UTF8(pszPartitionName);

  // create the zone
  DNS_STATUS err = ::DnssrvCreateZoneInDirectoryPartition(
          lpszServerName,	
          lpszAnsiZoneName,
          dwZoneType,										// Zone type
          NULL,                         // RNAME field should be NULL according to bug 135245
          0,												    // Number of masters, NA for primary
          &adwIpAddressDummy,						// Array of masters, dummy for primary
      		bLoadExisting,
          0,                            // dwTimeout
          0,                            // fSlave
          dwPartitionFlags,	
          (replType == custom) ? lpszUTF8PartitionName : NULL);	
	if (err != 0)
		return err;

  // set the dynamic update flag
  err = ::DnssrvResetDwordProperty(lpszServerName, lpszAnsiZoneName,
          													DNS_REGKEY_ZONE_ALLOW_UPDATE, nDynamicUpdate);
	if (err != 0)
		return err;

	ASSERT(m_pZoneInfoEx != NULL);
	return GetZoneInfo();
}

DNS_STATUS CDNSZoneNode::CreateStubInDirectoryPartition(DWORD* ipMastersArray, 
                                                        int nIPMastersCount,
                                                        BOOL bLoadExisting,
                                                        ReplicationType replType,
                                                        PCWSTR pszPartitionName)
{
	USES_CONVERSION;
	DWORD dwZoneType = DNS_ZONE_TYPE_STUB;

  DWORD dwPartitionFlags = 0;
  switch (replType)
  {
  case forest:
    dwPartitionFlags |= DNS_DP_FOREST_DEFAULT;
    break;
    
  case domain:
    dwPartitionFlags |= DNS_DP_DOMAIN_DEFAULT;
    break;

  case w2k:
    dwPartitionFlags |= DNS_DP_LEGACY;
    break;

  case custom:
    dwPartitionFlags = 0;
    break;

  case none:
  default:
    ASSERT(FALSE);
    break;
  }


	ASSERT(ipMastersArray != NULL);
	ASSERT(nIPMastersCount > 0);

  LPCWSTR lpszServerName = GetServerNode()->GetRPCName();
  LPCSTR lpszAnsiZoneName = W_TO_UTF8(GetFullName()); 
  LPCSTR lpszUTF8PartitionName = W_TO_UTF8(pszPartitionName);

  // create the zone
  DNS_STATUS err = ::DnssrvCreateZoneInDirectoryPartition(
          lpszServerName,	
          lpszAnsiZoneName,
          dwZoneType,										// Zone type
          NULL,                         // RNAME field should be NULL according to bug 135245
          nIPMastersCount,   				    // Number of masters, NA for primary
          ipMastersArray,	  					  // Array of masters, dummy for primary
      		bLoadExisting,
          0,                            // dwTimeout
          0,                            // fSlave
          dwPartitionFlags,	
          (replType == custom) ? lpszUTF8PartitionName : NULL);	
	if (err != 0)
		return err;

	ASSERT(m_pZoneInfoEx != NULL);
	return GetZoneInfo();
}
#endif // USE_NDNC

DNS_STATUS CDNSZoneNode::CreateSecondary(DWORD* ipMastersArray, int nIPMastersCount,
										 LPCTSTR lpszDBName, BOOL bLoadExisting)
{
	USES_CONVERSION;
	DWORD dwZoneType = DNS_ZONE_TYPE_SECONDARY;

	ASSERT(ipMastersArray != NULL);
	ASSERT(nIPMastersCount > 0);

    DNS_STATUS err = ::DnssrvCreateZone(
            GetServerNode()->GetRPCName(),	// Server name
            W_TO_UTF8(GetFullName()),				// Zone name
            dwZoneType,										  // Zone type
            NULL,                           // RNAME field should be NULL according to bug 135245
            (DWORD)nIPMastersCount,					// Number of masters
            ipMastersArray,								  // Array of masters
			      bLoadExisting,
            FALSE,				      						// fDSIntegrated (secondaries are not in the DS)
            W_TO_UTF8(lpszDBName),					// Database file
            0,
            0);
	if (err != 0)
		return err;

	ASSERT(m_pZoneInfoEx != NULL);
	return GetZoneInfo();
}

DNS_STATUS CDNSZoneNode::CreateStub(DWORD* ipMastersArray, 
                                    int nIPMastersCount,
										                LPCTSTR lpszDBName, 
                                    BOOL bLoadExisting, 
                                    BOOL bDSIntegrated)
{
	USES_CONVERSION;
	DWORD dwZoneType = DNS_ZONE_TYPE_STUB;

	ASSERT(ipMastersArray != NULL);
	ASSERT(nIPMastersCount > 0);

  DNS_STATUS err = ::DnssrvCreateZone(
                                      GetServerNode()->GetRPCName(),	  // Server name
                                      W_TO_UTF8(GetFullName()),				  // Zone name
                                      dwZoneType,										    // Zone type
                                      NULL,                             // RNAME field should be NULL according to bug 135245
                                      (DWORD)nIPMastersCount,						// Number of masters
                                      ipMastersArray,								    // Array of masters
			                                bLoadExisting,
                                      bDSIntegrated,
                                      (bDSIntegrated) ? NULL : W_TO_UTF8(lpszDBName),						// Database file
                                      0,
                                      0);
	if (err != 0)
		return err;

	ASSERT(m_pZoneInfoEx != NULL);
	return GetZoneInfo();
}



DNS_STATUS CDNSZoneNode::CreateForwarder(DWORD* ipMastersArray, 
                                         int nIPMastersCount,
                                         DWORD dwTimeout,
                                         DWORD fSlave)
{
	USES_CONVERSION;
	DWORD dwZoneType = DNS_ZONE_TYPE_FORWARDER;

  DNS_STATUS err = ::DnssrvCreateZone(
            GetServerNode()->GetRPCName(),	    // Server name
            W_TO_UTF8(GetFullName()),						// Zone name
            dwZoneType,										      // Zone type
            NULL,                               // RNAME field should be NULL according to bug 135245
            (DWORD)nIPMastersCount,							// Number of masters
            ipMastersArray,								      // Array of masters
			      FALSE,                              // Load existing?
            FALSE,										          // fDSIntegrated (secondaries are not in the DS)
            NULL,						                    // Database file
            dwTimeout,                          // Time out
            fSlave);                            // Slave?
	if (err != 0)
		return err;

	ASSERT(m_pZoneInfoEx != NULL);
	return GetZoneInfo();
}


DNS_STATUS CDNSZoneNode::SetSecondary(DWORD cMasters, PIP_ADDRESS aipMasters,
										   DWORD dwLoadOptions, LPCTSTR lpszDataFile)
{
	USES_CONVERSION;
	ASSERT_VALID_ZONE_INFO();

	if (cMasters == 0)
		return DNS_ERROR_SECONDARY_REQUIRES_MASTER_IP;


	DNS_STATUS err = 0;
	IP_ADDRESS dummy;
	if (aipMasters == NULL)
	{
		ASSERT(cMasters == 0);
		aipMasters = &dummy; // RPC wants non null ip array
	}
	err = ::DnssrvResetZoneTypeEx(GetServerNode()->GetRPCName(), // server name
								W_TO_UTF8(GetFullName()),	// zone name
								DNS_ZONE_TYPE_SECONDARY,
								cMasters, 
								aipMasters,
								dwLoadOptions,
								FALSE,						// bDSIntegrated
								W_TO_UTF8(lpszDataFile),
                                0,                          // DP flags
                                NULL);                      // DP FQDN

	if (err == 0)
		err = GetZoneInfo();
	return err;
}

DNS_STATUS CDNSZoneNode::SetStub(DWORD cMasters, 
                                 PIP_ADDRESS aipMasters,
										             DWORD dwLoadOptions, 
                                 BOOL bDSIntegrated,
                                 LPCTSTR lpszDataFile,
                                 BOOL bLocalListOfMasters)
{
	USES_CONVERSION;
	ASSERT_VALID_ZONE_INFO();

	if (cMasters == 0)
		return DNS_ERROR_SECONDARY_REQUIRES_MASTER_IP;


	DNS_STATUS err = 0;
	IP_ADDRESS dummy;
	if (aipMasters == NULL)
	{
		ASSERT(cMasters == 0);
		aipMasters = &dummy; // RPC wants non null ip array
	}
	err = ::DnssrvResetZoneTypeEx(GetServerNode()->GetRPCName(), // server name
								W_TO_UTF8(GetFullName()),	// zone name
								DNS_ZONE_TYPE_STUB,
								cMasters, 
								aipMasters,
								dwLoadOptions,
								bDSIntegrated,
                (bDSIntegrated) ? NULL : W_TO_UTF8(lpszDataFile),
                                0,                          // DP flags
                                NULL);                      // DP FQDN

	if (err != 0)
    return err;

  if (bLocalListOfMasters)
  {
    err = ::DnssrvResetZoneMastersEx(GetServerNode()->GetRPCName(),
                                     W_TO_UTF8(GetFullName()),
                                     cMasters,
                                     aipMasters,
                                     TRUE);     // LocalListOfMasters
  }
  else
  {
    err = ::DnssrvResetZoneMastersEx(GetServerNode()->GetRPCName(),
                                     W_TO_UTF8(GetFullName()),
                                     0,
                                     NULL,
                                     TRUE);     // LocalListOfMasters
  }

  if (err == 0)
		err = GetZoneInfo();
	return err;
}

DNS_STATUS CDNSZoneNode::SetPrimary(DWORD dwLoadOptions, BOOL bDSIntegrated,
										  LPCTSTR lpszDataFile)
{
	USES_CONVERSION;
	ASSERT_VALID_ZONE_INFO();
	
	DWORD cDummyMasters = 0; // dummy
	DWORD dwDummyArr = 0;
	DNS_STATUS err = ::DnssrvResetZoneTypeEx(GetServerNode()->GetRPCName(), // server name
										W_TO_UTF8(GetFullName()), // zone name
										DNS_ZONE_TYPE_PRIMARY,
										cDummyMasters, // not neeeded, but have to pass valid RPC val 
										&dwDummyArr,
										dwLoadOptions,
										bDSIntegrated,
										bDSIntegrated ? "" : W_TO_UTF8(lpszDataFile),
                                        0,                          // DP flags
                                        NULL);                      // DP FQDN
	if (err == 0)
		err = GetZoneInfo();
	return err;
}

DNS_STATUS CDNSZoneNode::SetAgingNoRefreshInterval(DWORD dwNoRefreshInterval)
{
   ASSERT_VALID_ZONE_INFO();
   USES_CONVERSION;

   DNS_STATUS dwErr = ::DnssrvResetDwordProperty(GetServerNode()->GetRPCName(),
                                                W_TO_UTF8(GetFullName()),
                                                DNS_REGKEY_ZONE_NOREFRESH_INTERVAL,
                                                dwNoRefreshInterval);
   if (dwErr == 0 &&
       m_pZoneInfoEx)
   {
      m_pZoneInfoEx->m_pZoneInfo->dwNoRefreshInterval = dwNoRefreshInterval;
   }
   return dwErr;
}

DNS_STATUS CDNSZoneNode::SetAgingRefreshInterval(DWORD dwRefreshInterval)
{
   ASSERT_VALID_ZONE_INFO();
   USES_CONVERSION;
   DNS_STATUS dwErr =  ::DnssrvResetDwordProperty(GetServerNode()->GetRPCName(),
                                                W_TO_UTF8(GetFullName()),
                                                DNS_REGKEY_ZONE_REFRESH_INTERVAL,
                                                dwRefreshInterval);

   if (dwErr == 0 &&
       m_pZoneInfoEx)
   {
      m_pZoneInfoEx->m_pZoneInfo->dwRefreshInterval = dwRefreshInterval;
   }
   return dwErr;
}

DNS_STATUS CDNSZoneNode::SetScavengingEnabled(BOOL bEnable)
{
   ASSERT_VALID_ZONE_INFO();
   USES_CONVERSION;
   DNS_STATUS dwErr = ::DnssrvResetDwordProperty(GetServerNode()->GetRPCName(),
                                                W_TO_UTF8(GetFullName()),
                                                DNS_REGKEY_ZONE_AGING,
                                                bEnable);
  if (dwErr == 0 &&
      m_pZoneInfoEx)
  {
      m_pZoneInfoEx->m_pZoneInfo->fAging = bEnable;
  }
  return dwErr;
}


DNS_STATUS CDNSZoneNode::Delete(BOOL bDeleteFromDs)
{
	ASSERT(m_pZoneInfoEx != NULL);
	USES_CONVERSION;
	
  if (((GetZoneType() == DNS_ZONE_TYPE_PRIMARY) || 
       (GetZoneType() == DNS_ZONE_TYPE_STUB)    ||
       (GetZoneType() == DNS_ZONE_TYPE_FORWARDER)) && 
       IsDSIntegrated() && bDeleteFromDs)
  {
    return ::DnssrvOperation(GetServerNode()->GetRPCName(), // server name
                             W_TO_UTF8(GetFullName()),
                             DNSSRV_OP_ZONE_DELETE_FROM_DS,
                             DNSSRV_TYPEID_NULL,
                             NULL);
  }
  else
  {
    return ::DnssrvDeleteZone(GetServerNode()->GetRPCName(), 
		              				   W_TO_UTF8(GetFullName()));
  }
}



DNS_STATUS CDNSZoneNode::IncrementVersion()
{
	ASSERT(GetZoneType() ==  DNS_ZONE_TYPE_PRIMARY);
	ASSERT(!IsAutocreated());

	ASSERT(m_pZoneInfoEx != NULL);
	USES_CONVERSION;
	DNS_STATUS err = ::DnssrvIncrementZoneVersion(GetServerNode()->GetRPCName(), 
						   W_TO_UTF8(GetFullName()));
	// refresh Zone Info if already present
	if ((err == 0) && m_pZoneInfoEx->HasData())
		err = GetZoneInfo();
	return err;
}


DNS_STATUS CDNSZoneNode::Reload()
{
	ASSERT(GetZoneType() ==  DNS_ZONE_TYPE_PRIMARY);
	ASSERT(!IsAutocreated());

	ASSERT(m_pZoneInfoEx != NULL);
	USES_CONVERSION;
	
  return ::DnssrvOperation(GetServerNode()->GetRPCName(), // server name
												W_TO_UTF8(GetFullName()),
												DNSSRV_OP_ZONE_RELOAD,
                        DNSSRV_TYPEID_NULL,
												NULL);
}

DNS_STATUS CDNSZoneNode::TransferFromMaster()
{
	ASSERT(GetZoneType() ==  DNS_ZONE_TYPE_SECONDARY || GetZoneType() == DNS_ZONE_TYPE_STUB);
	ASSERT(!IsAutocreated());

	ASSERT(m_pZoneInfoEx != NULL);
	USES_CONVERSION;
	
  return ::DnssrvOperation(GetServerNode()->GetRPCName(), // server name
												W_TO_UTF8(GetFullName()),
												DNSSRV_OP_ZONE_REFRESH,
                        DNSSRV_TYPEID_NULL,
												NULL);
}

DNS_STATUS CDNSZoneNode::ReloadFromMaster()
{
	ASSERT(GetZoneType() ==  DNS_ZONE_TYPE_SECONDARY || GetZoneType() == DNS_ZONE_TYPE_STUB);
	ASSERT(!IsAutocreated());

	ASSERT(m_pZoneInfoEx != NULL);
	USES_CONVERSION;
	
  return ::DnssrvOperation(GetServerNode()->GetRPCName(), // server name
												W_TO_UTF8(GetFullName()),
												DNSSRV_OP_ZONE_EXPIRE,
                        DNSSRV_TYPEID_NULL,
												NULL);
}

PCWSTR CDNSZoneNode::GetDN()
{
   ASSERT(IsDSIntegrated());
   ASSERT(m_pZoneInfoEx);
   ASSERT(m_pZoneInfoEx->HasData());

   if (m_pZoneInfoEx &&
       m_pZoneInfoEx->HasData())
   {
      return m_pZoneInfoEx->m_pZoneInfo->pwszZoneDn;
   }
   return L"";
}

BOOL CDNSZoneNode::IsDSIntegrated()
{
   if (GetZoneType() == DNS_ZONE_TYPE_CACHE)
      return FALSE;

   BOOL result = FALSE;

   if (m_pZoneInfoEx)
   {
      result =  (m_pZoneInfoEx->HasData()) ? 
                           (m_pZoneInfoEx->m_pZoneInfo->fUseDatabase ? TRUE : FALSE): 
										      ((m_dwZoneFlags & DNS_ZONE_DsIntegrated) != 0);
   }
   return result;
}

//sz = _T("LDAP://DC=uidev-one,DC=ntdev,DC=Microsoft,DC=Com,O=Internet");


void CDNSZoneNode::GetDataFile(CString& szName)
{
	ASSERT_VALID_ZONE_INFO();
	USES_CONVERSION;
  if (m_pZoneInfoEx == NULL || m_pZoneInfoEx->m_pZoneInfo == NULL)
  {
    szName = L"";
  }
  else
  {
	  szName = UTF8_TO_W(m_pZoneInfoEx->m_pZoneInfo->pszDataFile);
  }
}

LPCSTR CDNSZoneNode::GetDataFile()
{
	ASSERT_VALID_ZONE_INFO();
  if (m_pZoneInfoEx == NULL || m_pZoneInfoEx->m_pZoneInfo == NULL)
  {
    return "";
  }
	return m_pZoneInfoEx->m_pZoneInfo->pszDataFile;
}

DNS_STATUS CDNSZoneNode::ResetDatabase(BOOL bDSIntegrated, LPCTSTR lpszDataFile)
{
	ASSERT_VALID_ZONE_INFO();
	USES_CONVERSION;

	DNS_STATUS err = ::DnssrvResetZoneDatabase(GetServerNode()->GetRPCName(), // server name
										W_TO_UTF8(GetFullName()), // zone name
										bDSIntegrated,
										W_TO_UTF8(lpszDataFile));
	if (err == 0)
		err = GetZoneInfo();
	return err;
}



DNS_STATUS CDNSZoneNode::WriteToDatabase()
{
	ASSERT_VALID_ZONE_INFO();
  return CDNSZoneNode::WriteToDatabase(GetServerNode()->GetRPCName(), // server name
										                    GetFullName()); // zone name
}

DNS_STATUS CDNSZoneNode::WriteToDatabase(LPCWSTR lpszServer, LPCWSTR lpszZone)
{
	USES_CONVERSION;
	return ::DnssrvOperation(lpszServer, W_TO_UTF8(lpszZone),
										DNSSRV_OP_ZONE_WRITE_BACK_FILE,
                    DNSSRV_TYPEID_NULL,
                    NULL);
}

DNS_STATUS CDNSZoneNode::WriteToDatabase(LPCWSTR lpszServer, LPCSTR lpszZone)
{
	return ::DnssrvOperation(lpszServer, lpszZone,
										DNSSRV_OP_ZONE_WRITE_BACK_FILE,
                    DNSSRV_TYPEID_NULL,
                    NULL);
}

UINT CDNSZoneNode::GetDynamicUpdate()
{
	ASSERT_VALID_ZONE_INFO();

   UINT result = 0;

   if (m_pZoneInfoEx &&
       m_pZoneInfoEx->HasData())
   {
	   result = m_pZoneInfoEx->m_pZoneInfo->fAllowUpdate;
   }
   return result;
}

DNS_STATUS CDNSZoneNode::SetDynamicUpdate(UINT nDynamic)
{
	ASSERT_VALID_ZONE_INFO();
	DNS_STATUS err = 0;
	// call only if the info is dirty
	if (GetDynamicUpdate() != nDynamic)
	{
		USES_CONVERSION;
		err = ::DnssrvResetDwordProperty(GetServerNode()->GetRPCName(), // server name
													m_pZoneInfoEx->m_pZoneInfo->pszZoneName,
													DNS_REGKEY_ZONE_ALLOW_UPDATE,
													nDynamic);
		if (err != 0)
			return err;
		err = GetZoneInfo();
	}
	return err;
}



DNS_STATUS CDNSZoneNode::ResetSecondaries(DWORD fSecureSecondaries, 
                                          DWORD cSecondaries, PIP_ADDRESS aipSecondaries,
                                          DWORD fNotifyLevel,
                                          DWORD cNotify, PIP_ADDRESS aipNotify)
{
	ASSERT_VALID_ZONE_INFO();

	DNS_STATUS err = 0;

	BOOL bSecondariesDirty = (m_pZoneInfoEx->m_pZoneInfo->fSecureSecondaries != fSecureSecondaries) ||
                (m_pZoneInfoEx->m_pZoneInfo->fNotifyLevel != fNotifyLevel) ||
		(!(m_pZoneInfoEx->m_pZoneInfo->aipSecondaries == NULL && cSecondaries == 0) &&
			(
				(m_pZoneInfoEx->m_pZoneInfo->aipSecondaries == NULL && cSecondaries > 0) || // no addr --> more than one
				(m_pZoneInfoEx->m_pZoneInfo->aipSecondaries->AddrCount != cSecondaries) || // change the # of addresses
				(memcmp(aipSecondaries, m_pZoneInfoEx->m_pZoneInfo->aipSecondaries->AddrArray, sizeof(IP_ADDRESS)*cSecondaries) != 0)
			)
		);
  
  BOOL bNotifyDirty =
 		(!(m_pZoneInfoEx->m_pZoneInfo->aipNotify == NULL && cNotify == 0) &&
			(
				(m_pZoneInfoEx->m_pZoneInfo->aipNotify == NULL && cNotify > 0) || // no addr --> more than one
				(m_pZoneInfoEx->m_pZoneInfo->aipNotify->AddrCount != cNotify) || // change the # of addresses
				(memcmp(aipNotify, m_pZoneInfoEx->m_pZoneInfo->aipNotify->AddrArray, sizeof(IP_ADDRESS)*cNotify) != 0)
			)
		);

	if (bSecondariesDirty || bNotifyDirty)
	{
		USES_CONVERSION;
		err = ::DnssrvResetZoneSecondaries(GetServerNode()->GetRPCName(), // server name
											W_TO_UTF8(GetFullName()), // zone name
                      fSecureSecondaries,
											cSecondaries,
											aipSecondaries,
                      fNotifyLevel,
                      cNotify,
                      aipNotify
                      );
	}
	if (err == 0)
		err = GetZoneInfo();
	return err;
}

void CDNSZoneNode::GetSecondariesInfo(DWORD* pfSecureSecondaries, 
									  DWORD* pcSecondaries, PIP_ADDRESS* paipSecondaries,
                    DWORD* pfNotifyLevel,
                    DWORD* pcNotify, PIP_ADDRESS* paipNotify)
{
	ASSERT_VALID_ZONE_INFO();
	
	ASSERT(pfSecureSecondaries != NULL);
	ASSERT(pcSecondaries != NULL);
	ASSERT(paipSecondaries != NULL);

	ASSERT(pfNotifyLevel != NULL);
	ASSERT(pcNotify != NULL);
	ASSERT(paipNotify != NULL);


	*pfSecureSecondaries = m_pZoneInfoEx->m_pZoneInfo->fSecureSecondaries;
	// return pointers to struct fields, caller has to copy data elsewhere
	if (m_pZoneInfoEx->m_pZoneInfo->aipSecondaries == NULL)
	{
		*pcSecondaries = 0;
		*paipSecondaries = NULL;
	}
	else
	{
		*pcSecondaries = m_pZoneInfoEx->m_pZoneInfo->aipSecondaries->AddrCount;
		*paipSecondaries = m_pZoneInfoEx->m_pZoneInfo->aipSecondaries->AddrArray;
	}

  *pfNotifyLevel = m_pZoneInfoEx->m_pZoneInfo->fNotifyLevel;
  // return pointers to struct fields, caller has to copy data elsewhere
	if (m_pZoneInfoEx->m_pZoneInfo->aipNotify == NULL)
	{
		*pcNotify = 0;
		*paipNotify = NULL;
	}
	else
	{
		*pcNotify = m_pZoneInfoEx->m_pZoneInfo->aipNotify->AddrCount;
		*paipNotify = m_pZoneInfoEx->m_pZoneInfo->aipNotify->AddrArray;
	}
}

DNS_STATUS CDNSZoneNode::ResetMasters(DWORD cMasters, PIP_ADDRESS aipMasters, BOOL bLocalMasters)
{
	ASSERT_VALID_ZONE_INFO();
	
	if (cMasters == 0)
		return DNS_ERROR_SECONDARY_REQUIRES_MASTER_IP;

	USES_CONVERSION;

	// make the call only if the data is dirty
	DNS_STATUS err = 0;
	if ((m_pZoneInfoEx->m_pZoneInfo->aipMasters == NULL && cMasters > 0) || // no addr --> more than one
		(m_pZoneInfoEx->m_pZoneInfo->aipMasters->AddrCount != cMasters) || // change the # of addresses
		(memcmp(aipMasters, m_pZoneInfoEx->m_pZoneInfo->aipMasters->AddrArray, sizeof(IP_ADDRESS)*cMasters) != 0) )
	{
		IP_ADDRESS dummy;
		if (aipMasters == NULL)
		{
			ASSERT(cMasters == 0);
			aipMasters = &dummy; // RPC wants non null ip array
		}
		err = ::DnssrvResetZoneMastersEx(GetServerNode()->GetRPCName(), // server name
										                 W_TO_UTF8(GetFullName()), // zone name
										                 cMasters, 
                                     aipMasters,
                                     bLocalMasters);
    if (!bLocalMasters)
    {
      //
      // Reset local list of masters
      //
      err = ::DnssrvResetZoneMastersEx(GetServerNode()->GetRPCName(), // server name
										                   W_TO_UTF8(GetFullName()), // zone name
										                   0, 
                                       NULL,
                                       TRUE);     // LocalListOfMasters
      if (err != 0)
        return err;
    }
	}
	if (err == 0)
		err = GetZoneInfo();
	return err;
}

void CDNSZoneNode::GetMastersInfo(DWORD* pcAddrCount, PIP_ADDRESS* ppipAddrs)
{
	ASSERT_VALID_ZONE_INFO();	
	ASSERT(pcAddrCount != NULL);
	ASSERT(ppipAddrs != NULL);

	// return pointers to struct fields, caller has to copy data elsewhere
	if (m_pZoneInfoEx == NULL ||
            m_pZoneInfoEx->m_pZoneInfo == NULL ||
            m_pZoneInfoEx->m_pZoneInfo->aipMasters == NULL)
	{
		*pcAddrCount = 0;
		*ppipAddrs = NULL;
	}
	else
	{
		*pcAddrCount = m_pZoneInfoEx->m_pZoneInfo->aipMasters->AddrCount;
		*ppipAddrs = m_pZoneInfoEx->m_pZoneInfo->aipMasters->AddrArray;
	}
}

void CDNSZoneNode::GetLocalListOfMasters(DWORD* pcAddrCount, PIP_ADDRESS* ppipAddrs)
{
	ASSERT_VALID_ZONE_INFO();	
	ASSERT(pcAddrCount != NULL);
	ASSERT(ppipAddrs != NULL);

	// return pointers to struct fields, caller has to copy data elsewhere
	if (m_pZoneInfoEx->m_pZoneInfo->aipLocalMasters == NULL)
	{
		*pcAddrCount = 0;
		*ppipAddrs = NULL;
	}
	else
	{
		*pcAddrCount = m_pZoneInfoEx->m_pZoneInfo->aipLocalMasters->AddrCount;
		*ppipAddrs = m_pZoneInfoEx->m_pZoneInfo->aipLocalMasters->AddrArray;
	}
}

DNS_STATUS CDNSZoneNode::TogglePauseHelper(CComponentDataObject* pComponentData)
{
	ASSERT(m_nState == loaded);
	OnChangeState(pComponentData); // move to loading
	m_dwErr = TogglePause();

	OnChangeState(pComponentData); // move to loaded or unableToLoad
	return (DNS_STATUS)m_dwErr;
}

DNS_STATUS CDNSZoneNode::TogglePause()
{
	ASSERT_VALID_ZONE_INFO();	

	USES_CONVERSION;
	DNS_STATUS err;
	if (IsPaused())
		err = ::DnssrvResumeZone(GetServerNode()->GetRPCName(), 
						   W_TO_UTF8(GetFullName()) // zone name
						   );
	else
		err =  ::DnssrvPauseZone(GetServerNode()->GetRPCName(), 
						   W_TO_UTF8(GetFullName()) // zone name
						   );
	if (err != 0)
		return err;
	err = GetZoneInfo();
	ASSERT(err == 0);
	return err;
}

void CDNSZoneNode::ToggleView(CComponentDataObject* pComponentData)
{
   if (pComponentData)
   {
      pComponentData->UpdateResultPaneView(this);
   }
}

BOOL CDNSZoneNode::IsPaused()
{
	if (m_pZoneInfoEx != NULL && m_pZoneInfoEx->HasData()) 
	{
		ASSERT_VALID_ZONE_INFO();
		return m_pZoneInfoEx->m_pZoneInfo->fPaused;
	}
	return ((m_dwZoneFlags & DNS_ZONE_Paused) != 0);
}

 
BOOL CDNSZoneNode::IsExpired()
{

	ASSERT(m_pZoneInfoEx != NULL);
	return (m_pZoneInfoEx->HasData()) ? m_pZoneInfoEx->m_pZoneInfo->fShutdown : 
									((m_dwZoneFlags & DNS_ZONE_Shutdown) != 0);
}



//////////////////////////////////////////////////////////////////////////
// editing API's for special record types


CDNS_SOA_Record* CDNSZoneNode::GetSOARecordCopy()
{
	ASSERT(m_pSOARecordNode != NULL);
	if (m_pSOARecordNode == NULL)
		return NULL;
	return (CDNS_SOA_Record*)m_pSOARecordNode->CreateCloneRecord();
}

DNS_STATUS CDNSZoneNode::UpdateSOARecord(CDNS_SOA_Record* pNewRecord,
											CComponentDataObject* pComponentData)
{
	ASSERT(m_pSOARecordNode != NULL);
	if (m_pSOARecordNode == NULL)
  {
    return -1;
  }

	DNS_STATUS err = m_pSOARecordNode->Update(pNewRecord, FALSE /*bUseDefaultTTL*/);
	if ( (err == 0) && (pComponentData != NULL) )
  {
		VERIFY(SUCCEEDED(pComponentData->ChangeNode(m_pSOARecordNode, CHANGE_RESULT_ITEM)));
  }
	return err;
}


CDNSRecord* CDNSZoneNode::GetWINSRecordCopy()
{
	ASSERT(m_pWINSRecordNode != NULL);
	if (m_pWINSRecordNode == NULL)
		return NULL;
	return m_pWINSRecordNode->CreateCloneRecord();
}

DNS_STATUS	CDNSZoneNode::CreateWINSRecord(CDNSRecord* pNewWINSRecord,
										   CComponentDataObject* pComponentData)
{
	TRACE(_T("CDNSZoneNode::CreateWINSRecord()\n"));
	ASSERT(pNewWINSRecord != NULL);

	if (m_pWINSRecordNode != NULL)
  {
    //
    // should never happen
    //
  	ASSERT(FALSE && m_pWINSRecordNode == NULL);
		return -1; 
  }

  //
	// create a new record node object
  //
	if (IsReverse())
  {
		m_pWINSRecordNode = CDNSRecordInfo::CreateRecordNode(DNS_TYPE_NBSTAT);
  }
	else
  {
		m_pWINSRecordNode = CDNSRecordInfo::CreateRecordNode(DNS_TYPE_WINS);
  }

  //
	// hook up container and set name of node (same as the zone)
  //
	m_pWINSRecordNode->SetContainer(this);
	m_pWINSRecordNode->SetRecordName(GetDisplayName(), TRUE /*bAtTheNode */);
  CDNSRootData* pRootData = (CDNSRootData*)(pComponentData->GetRootData());
  ASSERT(pRootData != NULL);
  m_pWINSRecordNode->SetFlagsDown(TN_FLAG_DNS_RECORD_FULL_NAME, !pRootData->IsAdvancedView());
	
  //
	// write on server
  //
	DNS_STATUS err = m_pWINSRecordNode->Update(pNewWINSRecord, TRUE /*bUseDefaultTTL*/);
	if (err == 0)
  {
		VERIFY(AddChildToListAndUI(m_pWINSRecordNode, pComponentData));
    pComponentData->SetDescriptionBarText(this);
  }
	else
	{
		delete m_pWINSRecordNode;
		m_pWINSRecordNode = NULL;
	}
	TRACE(_T("EXIT\n"));
	return err;
}

DNS_STATUS	CDNSZoneNode::UpdateWINSRecord(CDNSRecord* pNewWINSRecord,
										   CComponentDataObject* pComponentData)
{
	TRACE(_T("CDNSZoneNode::UpdateWINSRecord()\n"));
	ASSERT(pNewWINSRecord != NULL);
	ASSERT(m_pWINSRecordNode != NULL);
	if (m_pWINSRecordNode == NULL)
  {
		return -1; // Bogus error code
  }

	ASSERT( 
			(IsReverse() && pNewWINSRecord->GetType() == DNS_TYPE_NBSTAT 
						&& m_pWINSRecordNode->GetType() == DNS_TYPE_NBSTAT) ||
			(!IsReverse() && pNewWINSRecord->GetType() == DNS_TYPE_WINS 
						&& m_pWINSRecordNode->GetType() == DNS_TYPE_WINS)
		  );

	DNS_STATUS err = m_pWINSRecordNode->Update(pNewWINSRecord, TRUE /*bUseDefaultTTL*/);
	if (err == 0)
  {
		VERIFY(SUCCEEDED(pComponentData->ChangeNode(m_pWINSRecordNode, CHANGE_RESULT_ITEM)));
  }
	TRACE(_T("EXIT\n"));
	return err;
}

DNS_STATUS	CDNSZoneNode::DeleteWINSRecord(CComponentDataObject* pComponentData)
{
	TRACE(_T("CDNSZoneNode::DeleteWINSRecord()\n"));
	ASSERT(m_pWINSRecordNode != NULL);
	if (m_pWINSRecordNode == NULL)
  {
		return -1; // bogus error code
  }
	DNS_STATUS err = m_pWINSRecordNode->DeleteOnServerAndUI(pComponentData);
	if (err == 0)
	{
		delete m_pWINSRecordNode;
		m_pWINSRecordNode = NULL;
	}
	TRACE(_T("EXIT\n"));
	return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\zoneui.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       zoneui.h
//
//--------------------------------------------------------------------------

#ifndef _ZONEUI_H
#define _ZONEUI_H

#include "ipeditor.h"

#include "nspage.h"
#include "aclpage.h"


///////////////////////////////////////////////////////////////////////////////
// FORWARD DECLARATIONS

class CCathegoryFolderNode;
class CDNSZoneNode;
class CDNSZonePropertyPageHolder;


///////////////////////////////////////////////////////////////////////////////
// CDNSZone_GeneralPropertyPage

class CDNSZone_GeneralIPEditor : public CIPEditor
{
public:
	CDNSZone_GeneralIPEditor()
	{
		m_bNoUpdateNow = FALSE;
	}
	virtual void OnChangeData(); // override from base class

	void FindMastersNames();

private:
	BOOL m_bNoUpdateNow;
};



class CDNSZone_GeneralPropertyPage : public CPropertyPageBase
{

// Construction
public:
	CDNSZone_GeneralPropertyPage();

	virtual BOOL OnPropertyChange(BOOL bScopePane, long* pChangeMask);

// Dialog Data
protected:
#ifdef USE_NDNC
	enum { IDD = IDD_ZONE_GENERAL_PAGE_NDNC };
#else
	enum { IDD = IDD_ZONE_GENERAL_PAGE };
#endif // USE_NDNC

// Overrides
public:

// Implementation
protected:
#ifdef USE_NDNC
  afx_msg void OnChangeReplButton();
#endif // USE_NDNC
	afx_msg void OnChangeTypeButton();
	afx_msg void OnPauseStartButton();
	afx_msg void OnChangePrimaryStorageRadio();
	afx_msg void OnChangePrimaryFileNameEdit() { SetDirty(TRUE);}
	//afx_msg void OnChangePrimaryStoreADSEdit() { SetDirty(TRUE);}
	afx_msg void OnChangePrimaryDynamicUpdateCombo() { SetDirty(TRUE);}
	afx_msg void OnChangeSecondaryFileNameEdit() { SetDirty(TRUE);}
	afx_msg void OnBrowseMasters();
	afx_msg void OnFindMastersNames();
  afx_msg void OnAging();
  afx_msg void OnLocalCheck();

	virtual void SetUIData();

	virtual BOOL OnInitDialog();
	virtual BOOL OnApply();

	DECLARE_MESSAGE_MAP()

public:
  BOOL IsPrimaryZoneUI() { return m_bIsPrimary;}
  BOOL IsStubZoneUI() { return m_bIsStub; }
  BOOL ApplyChanges() { return OnApply();}

private:
	// common controls
	CButton* GetPauseStartButton() 
			{ return (CButton*)GetDlgItem(IDC_PAUSE_START_BUTTON);}
	CDNSButtonToggleTextHelper m_pauseStartHelper;
	CDNSManageControlTextHelper m_typeStaticHelper;
	CDNSToggleTextControlHelper m_zoneStorageStaticHelper;

	CDNSManageControlTextHelper m_statusHelper;

	// common to primary and secondary
	CStatic* GetFileNameEdit() 
			{ return (CStatic*)GetDlgItem(IDC_FILE_NAME_EDIT);}

	// primary zone
	CStatic* GetPrimaryDynamicUpdateStatic() 
			{ return (CStatic*)GetDlgItem(IDC_PRIMARY_DYN_UPD_STATIC);}
	CComboBox* GetPrimaryDynamicUpdateCombo() 
			{ return (CComboBox*)GetDlgItem(IDC_PRIMARY_DYN_UPD_COMBO);}
	
   CStatic* GetPrimaryDynamicWarningText()
         { return (CStatic*)GetDlgItem(IDC_WARNING_TEXT_STATIC); }

   CWnd* GetPrimaryDynamicWarningIcon()
         { return GetDlgItem(IDC_WARNING_ICON_STATIC); }

   // secondary zone
	CDNSZone_GeneralIPEditor	m_mastersEditor;
	CButton* GetMastersBrowseButton() 
			{ return (CButton*)GetDlgItem(IDC_BROWSE_MASTERS_BUTTON);}
	CButton* GetFindMastersNamesButton() 
			{ return (CButton*)GetDlgItem(IDC_FIND_MASTERS_NAMES_BUTTON);}
	CStatic* GetIPLabel() 
			{ return (CStatic*)GetDlgItem(IDC_STATIC_IP);}

	// set/get helpers
	void SetPrimaryDynamicUpdateComboVal(UINT nAllowsDynamicUpdate);
	UINT GetPrimaryDynamicUpdateComboVal();

	// UI manipulation and helpers
	void ChangeUIControls();
	void ChangeUIControlHelper(CWnd* pChild, BOOL bEnable);


	void GetStorageName(CString& szDataStorageName);

	void OnChangeIPEditorData();

#ifdef USE_NDNC
  void SetTextForReplicationScope();

  ReplicationType m_replType;
  CString m_szCustomScope;
#endif // USE_NDNC

	BOOL m_bIsPrimary;
  BOOL m_bIsStub;
	BOOL m_bIsPaused;
	BOOL m_bIsExpired;
	BOOL m_bDSIntegrated;
	BOOL m_bServerADSEnabled;
  BOOL m_bScavengingEnabled;
  DWORD m_dwRefreshInterval;
  DWORD m_dwNoRefreshInterval;
  DWORD m_dwScavengingStart;
	UINT m_nAllowsDynamicUpdate;

  BOOL m_bDiscardUIState;
  BOOL m_bDiscardUIStateShowMessage;

	friend class CDNSZone_GeneralIPEditor;
};


///////////////////////////////////////////////////////////////////////////////
// CDNSZone_ZoneTransferPropertyPage

class CDNSZoneNotifyDialog; //fwd decl

class CDNSZone_ZoneTransferPropertyPage : public CPropertyPageBase
{

// Construction
public:
	CDNSZone_ZoneTransferPropertyPage();
  ~CDNSZone_ZoneTransferPropertyPage();

// Implementation
protected:
	// Generated message map functions
  afx_msg void OnRadioSecSecureOff() { SyncUIRadioHelper(IDC_RADIO_SECSECURE_OFF);}
  afx_msg void OnRadioSecSecureNone() { SyncUIRadioHelper(IDC_CHECK_ALLOW_TRANSFERS);}
  afx_msg void OnRadioSecSecureNS() { SyncUIRadioHelper(IDC_RADIO_SECSECURE_NS);}
  afx_msg void OnRadioSecSecureList() { SyncUIRadioHelper(IDC_RADIO_SECSECURE_LIST);}

	afx_msg void OnButtonNotify();

	virtual BOOL OnInitDialog();
	virtual BOOL OnApply();
  virtual BOOL OnSetActive();

	DECLARE_MESSAGE_MAP()

private:

  // state for the subdialog
  DWORD m_fNotifyLevel;
  DWORD m_cNotify;
  PIP_ADDRESS m_aipNotify;

  BOOL m_bStub;


  void SyncUIRadioHelper(UINT nRadio);
  int SetRadioState(DWORD fSecureSecondaries);
  DWORD GetRadioState();

	CButton* GetNotifyButton() 
			{ return (CButton*)GetDlgItem(IDC_BUTTON_NOTIFY);}

	class CDNSSecondariesIPEditor : public CIPEditor
	{
	public:
		CDNSSecondariesIPEditor() : CIPEditor(TRUE) {} // no up/down buttons
		virtual void OnChangeData();
	};
	CDNSSecondariesIPEditor m_secondariesListEditor;
	friend class CDNSSecondariesIPEditor;

  friend class CDNSZoneNotifyDialog;
};


////////////////////////////////////////////////////////////////////////////
// CDNSZone_SOA_PropertyPage

class CDNSZone_SOA_PropertyPage; // fwd decl

class CDNS_SOA_SerialNumberEditGroup : public CDNSUpDownUnsignedIntEditGroup
{
protected:
	virtual void OnEditChange();
private:
	CDNSZone_SOA_PropertyPage* m_pPage;
	friend class CDNSZone_SOA_PropertyPage;
};

//
// From winnt.h
//
#define MAXDWORD    0xffffffff  

class CDNS_SOA_TimeIntervalEditGroup : public CDNSTimeIntervalEditGroup
{
public:
  CDNS_SOA_TimeIntervalEditGroup() : CDNSTimeIntervalEditGroup(0, MAXDWORD) {}
	virtual void OnEditChange();
private:
	CDNSZone_SOA_PropertyPage* m_pPage;
	friend class CDNSZone_SOA_PropertyPage;
};



class CDNSZone_SOA_PropertyPage : public CDNSRecordPropertyPage
{
public:
	CDNSZone_SOA_PropertyPage(BOOL bZoneRoot = TRUE);
	~CDNSZone_SOA_PropertyPage();

public:
	virtual BOOL OnPropertyChange(BOOL bScopePane, long* pChangeMask);

protected:
	virtual void SetUIData();
	virtual DNS_STATUS GetUIDataEx(BOOL bSilent = TRUE);
	virtual BOOL OnInitDialog();
	virtual BOOL OnApply();

private:
  BOOL m_bZoneRoot;
	CDNS_SOA_Record* m_pTempSOARecord;

	afx_msg void  OnPrimaryServerChange();
	afx_msg void  OnResponsiblePartyChange();
	afx_msg void  OnMinTTLChange();

	afx_msg void OnBrowseServer();
	afx_msg void OnBrowseResponsibleParty();

private:

	CDNS_SOA_SerialNumberEditGroup			m_serialNumberEditGroup;
	CDNS_SOA_TimeIntervalEditGroup			m_refreshIntervalEditGroup;
	CDNS_SOA_TimeIntervalEditGroup			m_retryIntervalEditGroup;
	CDNS_SOA_TimeIntervalEditGroup			m_expireIntervalEditGroup;
  CDNS_SOA_TimeIntervalEditGroup      m_minTTLIntervalEditGroup;

	CEdit* GetPrimaryServerEdit() { return (CEdit*)GetDlgItem(IDC_PRIMARY_SERV_EDIT);}
	CEdit* GetResponsiblePartyEdit() { return (CEdit*)GetDlgItem(IDC_RESP_PARTY_EDIT);}
  
  CStatic* GetErrorStatic() { return (CStatic*)GetDlgItem(IDC_STATIC_ERROR);}
  
  void ShowErrorUI();

	DECLARE_MESSAGE_MAP()

	friend class CDNS_SOA_SerialNumberEditGroup;
	friend class CDNS_SOA_TimeIntervalEditGroup;

};


////////////////////////////////////////////////////////////////////////////
// CDNSZone_WINSBase_PropertyPage

class CDNSZone_WINSBase_PropertyPage : public CDNSRecordPropertyPage
{
public:
	enum WINS_STATE
	{
		wins_local_state = 1,
		wins_not_local_state,
		no_wins_state
	};

	CDNSZone_WINSBase_PropertyPage(UINT nIDTemplate);
	~CDNSZone_WINSBase_PropertyPage();

  virtual BOOL OnSetActive();

	virtual BOOL OnPropertyChange(BOOL bScopePane, long* pChangeMask);

protected:
	virtual void SetUIData();
	virtual DNS_STATUS GetUIDataEx(BOOL bSilent = TRUE);
	virtual BOOL OnInitDialog();
	virtual BOOL OnApply();


	afx_msg void OnUseWinsResolutionChange();
	afx_msg void OnDoNotReplicateChange();

	CButton* GetUseWinsCheck() { return (CButton*)GetDlgItem(IDC_USE_WINS_RES_CHECK); } 
	CButton* GetDoNotReplicateCheck() { return (CButton*)GetDlgItem(IDC_NOT_REPL_CHECK); }
	CButton* GetAdvancedButton() { return (CButton*)GetDlgItem(IDC_ADVANCED_BUTTON); }
	
	// cast helpers
	CDNSZonePropertyPageHolder* GetZoneHolder() { return (CDNSZonePropertyPageHolder*)GetHolder(); }
	CDNSZoneNode* GetZoneNode();

	virtual void EnableUI(BOOL bEnable);
	virtual void EnableUI();

  virtual BOOL IsValidTempRecord()=0;

	// data
	CDNSRecord* m_pTempRecord;
	UINT m_iWINSMsg;
	UINT m_nReplCheckTextID;
	BOOL m_bPrimaryZone;
  BOOL m_bStub;
	BOOL m_bLocalRecord;
	WINS_STATE m_nState;

	DECLARE_MESSAGE_MAP()

private:
	enum { none, add, remove, edit } m_action; // to communicate across threads when hitting Apply()
};

////////////////////////////////////////////////////////////////////////////
// CDNSZone_WINS_PropertyPage

class CDNSZone_WINS_WinsServersIPEditor : public CIPEditor
{
public:
	virtual void OnChangeData();
};



class CDNSZone_WINS_PropertyPage : public CDNSZone_WINSBase_PropertyPage
{
public:
	CDNSZone_WINS_PropertyPage();
protected:
	virtual void SetUIData();
	virtual DNS_STATUS GetUIDataEx(BOOL bSilent = TRUE);
	virtual BOOL OnInitDialog();

	virtual void EnableUI(BOOL bEnable);
	virtual void EnableUI();
  virtual BOOL IsValidTempRecord();

	afx_msg void OnAdvancedButton();

private:
	CDNSZone_WINS_WinsServersIPEditor m_winsServersEditor;

	DECLARE_MESSAGE_MAP()

	friend class CDNSZone_WINS_WinsServersIPEditor;
};


////////////////////////////////////////////////////////////////////////////
// CDNSZone_NBSTAT_PropertyPage

class CDNSZone_NBSTAT_PropertyPage : public CDNSZone_WINSBase_PropertyPage
{
public:
	CDNSZone_NBSTAT_PropertyPage();
protected:
	virtual void SetUIData();
	virtual DNS_STATUS GetUIDataEx(BOOL bSilent = TRUE);
//	virtual BOOL OnInitDialog();

	afx_msg void OnDomainNameEditChange();

	CEdit* GetDomainNameEdit() { return (CEdit*)GetDlgItem(IDC_DOMAIN_NAME_EDIT); }

	virtual void EnableUI(BOOL bEnable);
	virtual void EnableUI();
  virtual BOOL IsValidTempRecord();

	afx_msg void OnAdvancedButton();

private:
	DECLARE_MESSAGE_MAP()

};



///////////////////////////////////////////////////////////////////////////////
// CDNSZoneNameServersPropertyPage

class CDNSZoneNameServersPropertyPage : public CDNSNameServersPropertyPage
{
public:
  virtual BOOL OnSetActive();
protected:
	virtual void ReadRecordNodesList();
	virtual BOOL WriteNSRecordNodesList();
};

///////////////////////////////////////////////////////////////////////////////
// CDNSZonePropertyPageHolder
// page holder to contain DNS Zone property pages


#define ZONE_HOLDER_SOA		RR_HOLDER_SOA
#define ZONE_HOLDER_NS		RR_HOLDER_NS
#define ZONE_HOLDER_WINS	RR_HOLDER_WINS
#define ZONE_HOLDER_GEN		(RR_HOLDER_WINS +1)

class CDNSZonePropertyPageHolder : public CPropertyPageHolderBase
{
public:
	CDNSZonePropertyPageHolder(CCathegoryFolderNode* pFolderNode, CDNSZoneNode* pZoneNode,
				CComponentDataObject* pComponentData);
	virtual ~CDNSZonePropertyPageHolder();

	CDNSZoneNode* GetZoneNode() { return (CDNSZoneNode*)GetTreeNode();}
  BOOL IsPrimaryZoneUI() { return m_generalPage.IsPrimaryZoneUI();}
  BOOL IsStubZoneUI() { return m_generalPage.IsStubZoneUI(); }
  BOOL ApplyGeneralPageChanges() { return m_generalPage.ApplyChanges();}

  BOOL IsAdvancedView() { return m_bAdvancedView; }
protected:
	virtual int OnSelectPageMessage(long nPageCode);
	virtual HRESULT OnAddPage(int nPage, CPropertyPageBase* pPage);

private:
	CDNSZone_GeneralPropertyPage	m_generalPage;
	CDNSZone_ZoneTransferPropertyPage		m_zoneTransferPage;
	CDNSZoneNameServersPropertyPage	m_nameServersPage;

	// special record property pages
	CDNSZone_SOA_PropertyPage		  m_SOARecordPage;	// for all zones
	CDNSZone_WINS_PropertyPage		m_WINSRecordPage;	// fwd lookup zones only
	CDNSZone_NBSTAT_PropertyPage	m_NBSTATRecordPage;	// reverse lookup zones only

	// optional security page
	CAclEditorPage*					m_pAclEditorPage;

	// page #'s of pages we want to select
	int m_nGenPage;
	int m_nSOAPage;
	int m_nWINSorWINSRPage;
	int m_nNSPage;

  BOOL m_bAdvancedView;
};


#endif // _ZONEUI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\zonewiz.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       zonewiz.cpp
//
//--------------------------------------------------------------------------


#include "preDNSsn.h"
#include <SnapBase.h>

#include "resource.h"
#include "dnsutil.h"
#include "DNSSnap.h"
#include "snapdata.h"

#include "server.h"
#include "domain.h"
#include "record.h"
#include "zone.h"

#include "ZoneWiz.h"

#include "browser.h"

#ifdef DEBUG_ALLOCATOR
	#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
	#endif
#endif

#define N_ZONEWIZ_TYPES				      4
#define N_ZONEWIZ_TYPES_PRIMARY		  0
#define N_ZONEWIZ_TYPES_DS_PRIMARY	1
#define N_ZONEWIZ_TYPES_SECONDARY	  2
#define N_ZONEWIZ_TYPES_STUB        3

///////////////////////////////////////////////////////////////////////////////
// CDNSCreateZoneInfo

CDNSCreateZoneInfo::CDNSCreateZoneInfo()
{
	m_bPrimary = TRUE;
	m_bForward = m_bWasForward = TRUE;
  m_bIsStub  = FALSE;
	m_storageType = useADS;
	m_ipMastersArray = NULL;
	m_nMastersCount = 0;
  m_bLocalListOfMasters = FALSE;
  m_nDynamicUpdate = ZONE_UPDATE_OFF;
#ifdef USE_NDNC
  m_replType = none;
#endif
}

CDNSCreateZoneInfo::~CDNSCreateZoneInfo()
{
	ResetIpArr();
}

void CDNSCreateZoneInfo::ResetIpArr()
{
	if (m_ipMastersArray != NULL)
	{
		ASSERT(m_nMastersCount > 0);
		delete[] m_ipMastersArray;
		m_ipMastersArray = NULL;
		m_nMastersCount = 0;
	}
}

void CDNSCreateZoneInfo::SetIpArr(PIP_ADDRESS ipMastersArray, DWORD nMastersCount)
{
	ResetIpArr();
	m_nMastersCount = nMastersCount;
	if (m_nMastersCount > 0)
	{
		ASSERT(ipMastersArray != NULL);
		m_ipMastersArray = new IP_ADDRESS[m_nMastersCount];
      if (m_ipMastersArray)
      {
		   memcpy(m_ipMastersArray, ipMastersArray, sizeof(IP_ADDRESS)*nMastersCount);
      }
	}
}


const CDNSCreateZoneInfo& CDNSCreateZoneInfo::operator=(const CDNSCreateZoneInfo& info)
{
	m_bPrimary = info.m_bPrimary;
	m_bForward = info.m_bForward;
  m_bIsStub  = info.m_bIsStub;
	m_szZoneName = info.m_szZoneName;
	m_szZoneStorage = info.m_szZoneStorage;
	m_storageType = info.m_storageType;
	SetIpArr(info.m_ipMastersArray, info.m_nMastersCount);
  m_bLocalListOfMasters = info.m_bLocalListOfMasters;

	m_bWasForward = info.m_bWasForward;
  m_nDynamicUpdate = info.m_nDynamicUpdate;

	return *this;
}

///////////////////////////////////////////////////////////////////////////////
// CDNSZoneWizardHolder

CDNSZoneWizardHolder::CDNSZoneWizardHolder(CComponentDataObject* pComponentData)
		: CPropertyPageHolderBase(NULL, NULL, pComponentData)
{
	m_bAutoDelete = FALSE; // use on the stack or embedded

  m_forceContextHelpButton = forceOff;

	m_pZoneInfo = &m_zoneInfo;

	// default settings for zone creation
	m_bKnowZoneLookupType = FALSE;
  m_bKnowZoneLookupTypeEx = FALSE;
	m_bFinishPage = TRUE;

	m_nNextToPage = 0;
	m_nBackToPage = 0;
}

void CDNSZoneWizardHolder::Initialize(CDNSServerNode* pServerNode, // might be null,
									           BOOL bFinishPage)
{
	m_bFinishPage = bFinishPage;

	if (pServerNode != NULL)
		SetServerNode(pServerNode);
	// page creation

	// add start page only if not embedded in other wizard
	if (pServerNode != NULL)
	{
		m_pStartPage = new CDNSZoneWiz_StartPropertyPage;
		
      if (m_pStartPage)
      {
		   AddPageToList((CPropertyPageBase*)m_pStartPage); 
      }
	}

	// add the page to select primary or secondary zone
	m_pReplicationTypePage = new CDNSZoneWiz_ZoneTypePropertyPage;
	if (m_pReplicationTypePage)
   {
	   AddPageToList((CPropertyPageBase*)m_pReplicationTypePage);
   }

	// page for lookup type (fwd/rev) on primary only
	m_pZoneLookupPage = new CDNSZoneWiz_ZoneLookupPropertyPage;
	if (m_pZoneLookupPage)
   {
	   AddPageToList((CPropertyPageBase*)m_pZoneLookupPage);
   }

	// pages for zone name on primary only
	m_pFwdZoneNamePage = new CDNSZoneWiz_FwdZoneNamePropertyPage;
	if (m_pFwdZoneNamePage)
   {
	   AddPageToList((CPropertyPageBase*)m_pFwdZoneNamePage);
   }

	m_pRevZoneNamePage = new CDNSZoneWiz_RevZoneNamePropertyPage;
	if (m_pRevZoneNamePage)
   {
	   AddPageToList((CPropertyPageBase*)m_pRevZoneNamePage);
   }

	// page for masters on secondary only
	m_pMastersPage = new CDNSZoneWiz_MastersPropertyPage;
   if (m_pMastersPage)
   {
	   AddPageToList((CPropertyPageBase*)m_pMastersPage);
   }

   //
   // page for dynamic update on primary only
   //
   m_pDynamicPage = new CDNSZoneWiz_DynamicPropertyPage;
   if (m_pDynamicPage)
   {
      AddPageToList((CPropertyPageBase*)m_pDynamicPage);
   }

	// storage page, common
	m_pStoragePage = new CDNSZoneWiz_StoragePropertyPage;
	if (m_pStoragePage)
   {
	   AddPageToList((CPropertyPageBase*)m_pStoragePage);
   }

#ifdef USE_NDNC
   // AD replication page, only for Whistler servers
   m_pADReplPage = new CDNSZoneWiz_ADReplicationPropertyPage;
   if (m_pADReplPage)
   {
      AddPageToList((CPropertyPageBase*)m_pADReplPage);
   }
#endif // USE_NDNC

	// finish page, common
	if (m_bFinishPage)
	{
		m_pFinishPage = new CDNSZoneWiz_FinishPropertyPage;
		if (m_pFinishPage)
      {
		   AddPageToList((CPropertyPageBase*)m_pFinishPage);
      }
	}
}


void CDNSZoneWizardHolder::PreSetZoneLookupType(BOOL bForward)
{
	m_bKnowZoneLookupType = TRUE;
  m_bKnowZoneLookupTypeEx = FALSE;
	m_pZoneInfo->m_bForward = bForward;
}

void CDNSZoneWizardHolder::PreSetZoneLookupTypeEx(BOOL bForward, UINT nZoneType, BOOL bADIntegrated)
{
	m_bKnowZoneLookupTypeEx = TRUE;
	m_pZoneInfo->m_bForward = bForward;

  if (bADIntegrated)
  {
    m_pZoneInfo->m_storageType = CDNSCreateZoneInfo::useADS;
  }
  else
  {
    m_pZoneInfo->m_storageType = CDNSCreateZoneInfo::newFile;
  }

  if (nZoneType != (UINT)-1)
  {
    switch (nZoneType)
    {
      case DNS_ZONE_TYPE_PRIMARY:
        m_pZoneInfo->m_bPrimary = TRUE;
        m_pZoneInfo->m_bIsStub = FALSE;
        break;
      case DNS_ZONE_TYPE_SECONDARY:
        m_pZoneInfo->m_bPrimary = FALSE;
        m_pZoneInfo->m_bIsStub  = FALSE;
        break;
      case DNS_ZONE_TYPE_STUB:
        m_pZoneInfo->m_bPrimary = FALSE;
        m_pZoneInfo->m_bIsStub = TRUE;
        break;
      default:
        ASSERT(FALSE);
        break;
    }
  }
}

void CDNSZoneWizardHolder::SetContextPages(UINT nNextToPage, UINT nBackToPage)
{
	m_nNextToPage = nNextToPage;
	m_nBackToPage = nBackToPage;
}


UINT CDNSZoneWizardHolder::GetFirstEntryPointPageID()
{
  if (m_bKnowZoneLookupTypeEx)
  {
    if (m_pZoneInfo->m_bForward)
    {
      return CDNSZoneWiz_FwdZoneNamePropertyPage::IDD;
    }
    else
    {
      return CDNSZoneWiz_RevZoneNamePropertyPage::IDD;
    }
  }
	return CDNSZoneWiz_ZoneTypePropertyPage::IDD;
}

UINT CDNSZoneWizardHolder::GetLastEntryPointPageID()
{
	if (m_pZoneInfo->m_storageType == CDNSCreateZoneInfo::useADS)
	{
    //
		// if DS primary or secondary, skip storage page
    //
    if (m_pZoneInfo->m_bIsStub)
    {
      //
      // AD-integrated Stub zone
      //
      return CDNSZoneWiz_MastersPropertyPage::IDD;
    }
    else
    {
		  if (m_pZoneInfo->m_bForward)
      {
        //
        // AD-integrated Fwd lookup zone
        //
			  return CDNSZoneWiz_DynamicPropertyPage::IDD;
      }
		  else
      {
        //
        // AD-integrated Rev lookup zone
        //
			  return CDNSZoneWiz_DynamicPropertyPage::IDD;
      }
    }
	}
	else 
	{
    //
    // File based zones
    //
    if (m_pZoneInfo->m_bIsStub)
    {
      //
      // File based stub zone
      //
      return CDNSZoneWiz_MastersPropertyPage::IDD;
    }
    else if (m_pZoneInfo->m_bPrimary)
    {
      //
      // standard primary
      //
      return CDNSZoneWiz_DynamicPropertyPage::IDD;
    }
    else
    {
      //
      // Secondary zone
      //
      return CDNSZoneWiz_MastersPropertyPage::IDD;
    }
	}
  return CDNSZoneWiz_StoragePropertyPage::IDD;
}


DNS_STATUS CDNSZoneWizardHolder::CreateZoneHelper(CDNSServerNode* pServerNode, 
													CDNSCreateZoneInfo* pZoneInfo, 
													CComponentDataObject* pComponentData)
{
	ASSERT(pServerNode != NULL);
	ASSERT(pZoneInfo != NULL);
	ASSERT(pComponentData != NULL);
	BOOL bLoadExisting = TRUE;

	if (pZoneInfo->m_bPrimary)
	{
		BOOL bUseADS = pZoneInfo->m_storageType == CDNSCreateZoneInfo::useADS;
		if (!bUseADS)
			bLoadExisting = pZoneInfo->m_storageType == CDNSCreateZoneInfo::importFile;

    UINT nDynamicUpdate = pZoneInfo->m_nDynamicUpdate;

#ifdef USE_NDNC
		return pServerNode->CreatePrimaryZone(
				pZoneInfo->m_szZoneName, 
				pZoneInfo->m_szZoneStorage, 
				bLoadExisting,
				pZoneInfo->m_bForward,
				bUseADS,
        nDynamicUpdate,
				pComponentData,
        pZoneInfo->m_replType,
        pZoneInfo->m_szCustomReplName);
#else
		return pServerNode->CreatePrimaryZone(
				pZoneInfo->m_szZoneName, 
				pZoneInfo->m_szZoneStorage, 
				bLoadExisting,
				pZoneInfo->m_bForward,
				bUseADS,
        nDynamicUpdate,
				pComponentData);
#endif // USE_NDNC
	}
	else if (pZoneInfo->m_bIsStub)
  {
		BOOL bUseADS = pZoneInfo->m_storageType == CDNSCreateZoneInfo::useADS;
		if (!bUseADS)
    {
			bLoadExisting = pZoneInfo->m_storageType == CDNSCreateZoneInfo::importFile;
    }
#ifdef USE_NDNC
    return pServerNode->CreateStubZone(pZoneInfo->m_szZoneName,
                                       pZoneInfo->m_szZoneStorage,
                                       bLoadExisting,
                                       bUseADS,
                                       pZoneInfo->m_bForward,
                                       pZoneInfo->m_ipMastersArray,
                                       pZoneInfo->m_nMastersCount,
                                       pZoneInfo->m_bLocalListOfMasters,
                                       pComponentData,
                                       pZoneInfo->m_replType,
                                       pZoneInfo->m_szCustomReplName);
#else
    return pServerNode->CreateStubZone(pZoneInfo->m_szZoneName,
                                       pZoneInfo->m_szZoneStorage,
                                       bLoadExisting,
                                       bUseADS,
                                       pZoneInfo->m_bForward,
                                       pZoneInfo->m_ipMastersArray,
                                       pZoneInfo->m_nMastersCount,
                                       pZoneInfo->m_bLocalListOfMasters,
                                       pComponentData);
#endif // USE_NDNC
  }
  else // secondary
	{
		ASSERT(pZoneInfo->m_storageType != CDNSCreateZoneInfo::useADS);
		bLoadExisting = pZoneInfo->m_storageType == CDNSCreateZoneInfo::importFile;
		return pServerNode->CreateSecondaryZone(
				pZoneInfo->m_szZoneName, 
				pZoneInfo->m_szZoneStorage,
				bLoadExisting,
				pZoneInfo->m_bForward, 
				pZoneInfo->m_ipMastersArray, 
				pZoneInfo->m_nMastersCount, 
				pComponentData);
	}
}

BOOL CDNSZoneWizardHolder::CreateZone()
{	
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	CDNSServerNode* pServerNode = GetServerNode();
	ASSERT(pServerNode != NULL);
	ASSERT(GetComponentData() != NULL);
	
   USES_CONVERSION;

	DNS_STATUS err = CreateZoneHelper(pServerNode, m_pZoneInfo, GetComponentData());
	
	if (err != 0)
	{
      if (err == DNS_ERROR_DP_NOT_ENLISTED ||
          err == DNS_ERROR_DP_DOES_NOT_EXIST)
      {
         CString szErr;

         if (m_pZoneInfo->m_replType == domain)
         {
            szErr.Format(IDS_ERRMSG_NO_NDNC_DOMAIN_FORMAT, UTF8_TO_W(pServerNode->GetDomainName()));
         }
         else if (m_pZoneInfo->m_replType == forest)
         {
            szErr.Format(IDS_ERRMSG_NO_NDNC_FOREST_FORMAT, UTF8_TO_W(pServerNode->GetForestName()));
         }
         else
         {
            ASSERT(FALSE);
         }
         DNSMessageBox(szErr, MB_OK | MB_ICONERROR);
      }
      else
      {
		   DNSErrorDialog(err, IDS_MSG_ZWIZ_FAIL);
	   }
   }
/*	else
	{
		CString szMsg, szFmt;
		szFmt.LoadString(IDS_MSG_ZWIZ_SUCCESS);
		szMsg.Format((LPCTSTR)szFmt, (LPCTSTR)m_pZoneInfo->m_szZoneName);
		DNSMessageBox(szMsg);
	}
*/	
	return err == 0;
}


///////////////////////////////////////////////////////////////////////////////
// CDNSZoneWiz_StartPropertyPage

CDNSZoneWiz_StartPropertyPage::CDNSZoneWiz_StartPropertyPage() 
		: CPropertyPageBase(CDNSZoneWiz_StartPropertyPage::IDD)
{
	InitWiz97(TRUE,0,0, true);
}


BOOL CDNSZoneWiz_StartPropertyPage::OnInitDialog()
{
  CPropertyPageBase::OnInitDialog();

  SetBigBoldFont(m_hWnd, IDC_STATIC_WELCOME);
	return TRUE;
}


BOOL CDNSZoneWiz_StartPropertyPage::OnSetActive()
{
	GetHolder()->SetWizardButtonsFirst(TRUE);
	return TRUE;
}

void CDNSZoneWiz_StartPropertyPage::OnWizardHelp()
{
  CComPtr<IDisplayHelp> spHelp;
  HRESULT hr = GetHolder()->GetComponentData()->GetConsole()->QueryInterface(IID_IDisplayHelp, (void **)&spHelp);
  if (SUCCEEDED(hr)) 
    spHelp->ShowTopic(L"DNSConcepts.chm::/sag_DNS_NZWIZ_01.htm");
}

//////////////////////////////////////////////////////////////////////////
// CDNSZoneWiz_ZoneTypePropertyPage

CDNSZoneWiz_ZoneTypePropertyPage::CDNSZoneWiz_ZoneTypePropertyPage() 
				: CPropertyPageBase(CDNSZoneWiz_ZoneTypePropertyPage::IDD)
{
	InitWiz97(FALSE,IDS_ZWIZ_ZONE_TYPE_TITLE,IDS_ZWIZ_ZONE_TYPE_SUBTITLE, true);
}


BEGIN_MESSAGE_MAP(CDNSZoneWiz_ZoneTypePropertyPage, CPropertyPageBase)
  ON_BN_CLICKED(IDC_RADIO_PRIMARY_ZONE, OnRadioChange)
  ON_BN_CLICKED(IDC_RADIO_STUB,    OnRadioChange)
  ON_BN_CLICKED(IDC_RADIO_SECONDARY,OnRadioChange)
  ON_BN_CLICKED(IDC_ADINT_CHECK, OnRadioChange)
END_MESSAGE_MAP()

void CDNSZoneWiz_ZoneTypePropertyPage::OnWizardHelp()
{
  CComPtr<IDisplayHelp> spHelp;
  HRESULT hr = GetHolder()->GetComponentData()->GetConsole()->QueryInterface(IID_IDisplayHelp, (void **)&spHelp);
  if (SUCCEEDED(hr)) 
    spHelp->ShowTopic(L"DNSConcepts.chm::/sag_DNS_CYDNS_12.htm");
}

void CDNSZoneWiz_ZoneTypePropertyPage::OnRadioChange()
{
  if (SendDlgItemMessage(IDC_RADIO_SECONDARY, BM_GETCHECK, 0, 0) == BST_CHECKED)
  {
    SendDlgItemMessage(IDC_ADINT_CHECK, BM_SETCHECK, BST_UNCHECKED, 0);
    GetDlgItem(IDC_ADINT_CHECK)->EnableWindow(FALSE);
  }
  else
  {
	  CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
	  CDNSServerNode* pServerNode = pHolder->GetServerNode();
	  if (pServerNode->CanUseADS())
    {
      GetDlgItem(IDC_ADINT_CHECK)->EnableWindow(TRUE);
    }
  }
}

BOOL CDNSZoneWiz_ZoneTypePropertyPage::OnSetActive() 
{
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
	pHolder->SetWizardButtonsMiddle(TRUE);
	SetUIState();
	return CPropertyPageBase::OnSetActive();
}

#ifdef USE_NDNC
LRESULT CDNSZoneWiz_ZoneTypePropertyPage::OnWizardNext() 
{
	GetUIState();
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
  CDNSServerNode* pServerNode = pHolder->GetServerNode();

	UINT nextPage = static_cast<UINT>(-1);
  if (pHolder->m_pZoneInfo->m_storageType != CDNSCreateZoneInfo::useADS ||
      pServerNode->GetBuildNumber() < DNS_SRV_BUILD_NUMBER_WHISTLER ||
      (pServerNode->GetMajorVersion() <= DNS_SRV_MAJOR_VERSION_NT_5 &&
       pServerNode->GetMinorVersion() < DNS_SRV_MINOR_VERSION_WHISTLER))
  {
    if (pHolder->m_bKnowZoneLookupType)
    {
  	  if (pHolder->m_pZoneInfo->m_bForward)
      {
	  	  nextPage = CDNSZoneWiz_FwdZoneNamePropertyPage::IDD;
      }
		  else
      {
			  nextPage = CDNSZoneWiz_RevZoneNamePropertyPage::IDD;
      }
    }
    else
    {
      nextPage = CDNSZoneWiz_ZoneLookupPropertyPage::IDD;
    }
  }
  else
  {
    nextPage = CDNSZoneWiz_ADReplicationPropertyPage::IDD;
  }

	return (LRESULT)nextPage;
}
#else
LRESULT CDNSZoneWiz_ZoneTypePropertyPage::OnWizardNext() 
{
	GetUIState();
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();

	UINT nextPage = static_cast<UINT>(-1);
    if (pHolder->m_bKnowZoneLookupType)
    {
  	  if (pHolder->m_pZoneInfo->m_bForward)
	  	  nextPage = CDNSZoneWiz_FwdZoneNamePropertyPage::IDD;
		  else
			  nextPage = CDNSZoneWiz_RevZoneNamePropertyPage::IDD;
      }
    else
      nextPage = CDNSZoneWiz_ZoneLookupPropertyPage::IDD;

	return (LRESULT)nextPage;
}
#endif // USE_NDNC

LRESULT CDNSZoneWiz_ZoneTypePropertyPage::OnWizardBack() 
{
	UINT nPrevPage = static_cast<UINT>(-1); // first page by default

  GetUIState();

	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
   if (pHolder->m_nBackToPage > 0)
		nPrevPage = pHolder->m_nBackToPage;
	else
		nPrevPage = CDNSZoneWiz_StartPropertyPage::IDD;

	return nPrevPage;
}


BOOL CDNSZoneWiz_ZoneTypePropertyPage::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
	CDNSServerNode* pServerNode = pHolder->GetServerNode();
	if (!pServerNode->CanUseADS())
	{
    SendDlgItemMessage(IDC_ADINT_CHECK, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
		GetDlgItem(IDC_ADINT_CHECK)->EnableWindow(FALSE);
    pHolder->m_pZoneInfo->m_storageType = CDNSCreateZoneInfo::newFile;
	}
  SendDlgItemMessage(IDC_RADIO_PRIMARY_ZONE, BM_SETCHECK, BST_CHECKED, 0);

  if (pServerNode->GetBuildNumber() < DNS_SRV_BUILD_NUMBER_WHISTLER ||
      pServerNode->GetMajorVersion() <= DNS_SRV_MAJOR_VERSION_NT_5 &&
      pServerNode->GetMinorVersion() < DNS_SRV_MINOR_VERSION_WHISTLER)
  {
    //
    // Disable Stub zones for pre-Whistler servers
    //
    GetDlgItem(IDC_RADIO_STUB)->EnableWindow(FALSE);
    GetDlgItem(IDC_STUB_STATIC)->EnableWindow(FALSE);
  }
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CDNSZoneWiz_ZoneTypePropertyPage::OnKillActive() 
{
	return CPropertyPage::OnKillActive();
}


void CDNSZoneWiz_ZoneTypePropertyPage::SetUIState()
{
  CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
  CButton* pPrimaryButton = (CButton*)GetDlgItem(IDC_RADIO_PRIMARY_ZONE);
  CButton* pStubButton = (CButton*)GetDlgItem(IDC_RADIO_STUB);
  CButton* pSecondaryButton = (CButton*)GetDlgItem(IDC_RADIO_SECONDARY);
  CButton* pADIntCheck = (CButton*)GetDlgItem(IDC_ADINT_CHECK);

  CDNSServerNode* pServerNode = pHolder->GetServerNode();

  if (pHolder->m_pZoneInfo->m_bPrimary)
  {
    if (pServerNode->CanUseADS())
    {
      pADIntCheck->EnableWindow(TRUE);
    }
    else
    {
      pADIntCheck->EnableWindow(FALSE);
      pADIntCheck->SetCheck(FALSE);
      pHolder->m_pZoneInfo->m_storageType = CDNSCreateZoneInfo::newFile;
    }

    if (pHolder->m_pZoneInfo->m_storageType == CDNSCreateZoneInfo::useADS)
    {
      //
      // primary DS integrated
      //
      pPrimaryButton->SetCheck(TRUE);
      pStubButton->SetCheck(FALSE);
      pSecondaryButton->SetCheck(FALSE);
      pADIntCheck->SetCheck(TRUE);
    }
    else
    {
      // primary standard
      pPrimaryButton->SetCheck(TRUE);
      pStubButton->SetCheck(FALSE);
      pSecondaryButton->SetCheck(FALSE);
      pADIntCheck->SetCheck(FALSE);
    }
  }
  else
  {
    if (pHolder->m_pZoneInfo->m_bIsStub)
    {
      //
      // Stub zone
      //
      pPrimaryButton->SetCheck(FALSE);
      pStubButton->SetCheck(TRUE);
      pSecondaryButton->SetCheck(FALSE);

      if (pServerNode->CanUseADS())
      {
        pADIntCheck->EnableWindow(TRUE);
      }
      if (pHolder->m_pZoneInfo->m_storageType == CDNSCreateZoneInfo::useADS)
      {
        pADIntCheck->SetCheck(TRUE);
      }
      else
      {
        pADIntCheck->SetCheck(FALSE);
      }
    }
    else
    {
      //
      // Secondary
      //
      pPrimaryButton->SetCheck(FALSE);
      pStubButton->SetCheck(FALSE);
      pSecondaryButton->SetCheck(TRUE);
      pADIntCheck->EnableWindow(FALSE);
      pADIntCheck->SetCheck(FALSE);
    }
  }
}

void CDNSZoneWiz_ZoneTypePropertyPage::GetUIState()
{
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
  CDNSServerNode* pServerNode = pHolder->GetServerNode();
	
	if ( ((CButton*)GetDlgItem(IDC_RADIO_SECONDARY))->GetCheck() )
	{
    pHolder->m_pZoneInfo->m_bIsStub = FALSE;

    // we were primary, need to pick a storage
		pHolder->m_pZoneInfo->m_bPrimary = FALSE;
		pHolder->m_pZoneInfo->m_storageType = CDNSCreateZoneInfo::newFile;
	}
	else if ( ((CButton*)GetDlgItem(IDC_RADIO_PRIMARY_ZONE))->GetCheck() )
	{
		pHolder->m_pZoneInfo->m_bPrimary = TRUE;
    pHolder->m_pZoneInfo->m_bIsStub = FALSE;
    if (((CButton*)GetDlgItem(IDC_ADINT_CHECK))->GetCheck())
    {
      //
      // AD integrated primary
      //
		  pHolder->m_pZoneInfo->m_storageType = CDNSCreateZoneInfo::useADS;
    }
    else
		{
      //
			// Standard primary
      //
			pHolder->m_pZoneInfo->m_storageType = CDNSCreateZoneInfo::newFile;
		}
	}
	else if (((CButton*)GetDlgItem(IDC_RADIO_STUB))->GetCheck())
	{
    //
    // Stub zone
    //

    //
    // Should not happen for pre-Whistler server
    //
    ASSERT(pServerNode->GetBuildNumber() >= DNS_SRV_BUILD_NUMBER_WHISTLER ||
           pServerNode->GetMajorVersion() >= DNS_SRV_MAJOR_VERSION_NT_5 &&
           pServerNode->GetMinorVersion() >= DNS_SRV_MINOR_VERSION_WHISTLER);

		pHolder->m_pZoneInfo->m_bPrimary = FALSE;
    pHolder->m_pZoneInfo->m_bIsStub  = TRUE;
    if (((CButton*)GetDlgItem(IDC_ADINT_CHECK))->GetCheck())
    {
      //
      // AD integrated Stub zone
      //
		  pHolder->m_pZoneInfo->m_storageType = CDNSCreateZoneInfo::useADS;
    }
    else
    {
      //
      // Standard Stub zone
      //
		  pHolder->m_pZoneInfo->m_storageType = CDNSCreateZoneInfo::newFile;
    }
  }
}


//////////////////////////////////////////////////////////////////////////
// CDNSZoneWiz_ZoneLookupPropertyPage

CDNSZoneWiz_ZoneLookupPropertyPage::CDNSZoneWiz_ZoneLookupPropertyPage() 
				: CPropertyPageBase(CDNSZoneWiz_ZoneLookupPropertyPage::IDD)
{
	InitWiz97(FALSE,IDS_ZWIZ_ZONE_LOOKUP_TITLE,IDS_ZWIZ_ZONE_LOOKUP_SUBTITLE, true);
}

BOOL CDNSZoneWiz_ZoneLookupPropertyPage::OnSetActive() 
{
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
	pHolder->SetWizardButtonsMiddle(TRUE);
	return TRUE;
}

void CDNSZoneWiz_ZoneLookupPropertyPage::OnWizardHelp()
{
  CComPtr<IDisplayHelp> spHelp;
  HRESULT hr = GetHolder()->GetComponentData()->GetConsole()->QueryInterface(IID_IDisplayHelp, (void **)&spHelp);
  if (SUCCEEDED(hr)) 
    spHelp->ShowTopic(L"DNSConcepts.chm::/sag_DNS_NZWIZ_03.htm");
}

#ifdef USE_NDNC
LRESULT CDNSZoneWiz_ZoneLookupPropertyPage::OnWizardNext() 
{
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
	
	// save the old setting
	pHolder->m_pZoneInfo->m_bWasForward = pHolder->m_pZoneInfo->m_bForward;

	// get the new setting
	pHolder->m_pZoneInfo->m_bForward = 
		(GetCheckedRadioButton(IDC_RADIO_FWD, IDC_RADIO_REV) == 
		IDC_RADIO_FWD);

  if (pHolder->m_pZoneInfo->m_bForward)
  {
    return CDNSZoneWiz_FwdZoneNamePropertyPage::IDD;
  }
  return CDNSZoneWiz_RevZoneNamePropertyPage::IDD;
}

LRESULT CDNSZoneWiz_ZoneLookupPropertyPage::OnWizardBack() 
{
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
  CDNSServerNode* pServerNode = pHolder->GetServerNode();

  if (pHolder->m_pZoneInfo->m_storageType != CDNSCreateZoneInfo::useADS ||
      pServerNode->GetBuildNumber() < DNS_SRV_BUILD_NUMBER_WHISTLER ||
      (pServerNode->GetMajorVersion() <= DNS_SRV_MAJOR_VERSION_NT_5 &&
       pServerNode->GetMinorVersion() < DNS_SRV_MINOR_VERSION_WHISTLER))
  {
	  return CDNSZoneWiz_ZoneTypePropertyPage::IDD;
  }
  return CDNSZoneWiz_ADReplicationPropertyPage::IDD;
}

#else

LRESULT CDNSZoneWiz_ZoneLookupPropertyPage::OnWizardNext() 
{
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
	
	// save the old setting
	pHolder->m_pZoneInfo->m_bWasForward = pHolder->m_pZoneInfo->m_bForward;

	// get the new setting
	pHolder->m_pZoneInfo->m_bForward = 
		(GetCheckedRadioButton(IDC_RADIO_FWD, IDC_RADIO_REV) == 
		IDC_RADIO_FWD);

  if (pHolder->m_pZoneInfo->m_bForward)
    return CDNSZoneWiz_FwdZoneNamePropertyPage::IDD;
  // This was an else but the sundown build didn't like having a control path not return a value
  return CDNSZoneWiz_RevZoneNamePropertyPage::IDD;
}

LRESULT CDNSZoneWiz_ZoneLookupPropertyPage::OnWizardBack() 
{
	  return CDNSZoneWiz_ZoneTypePropertyPage::IDD;
}

#endif // USE_NDNC


BOOL CDNSZoneWiz_ZoneLookupPropertyPage::OnInitDialog()
{
	CPropertyPageBase::OnInitDialog();
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();

	CheckRadioButton(IDC_RADIO_FWD, IDC_RADIO_REV,
		pHolder->m_pZoneInfo->m_bForward ? IDC_RADIO_FWD : IDC_RADIO_REV);

	return TRUE;
}



//////////////////////////////////////////////////////////////////////////
// CDNSZoneWiz_ZoneNamePropertyPageBase

BEGIN_MESSAGE_MAP(CDNSZoneWiz_ZoneNamePropertyPageBase, CPropertyPageBase)
	ON_EN_CHANGE(IDC_EDIT_ZONE_NAME, OnChangeEditZoneName)
	ON_BN_CLICKED(IDC_BROWSE_BUTTON, OnBrowse)
END_MESSAGE_MAP()

CDNSZoneWiz_ZoneNamePropertyPageBase::CDNSZoneWiz_ZoneNamePropertyPageBase(UINT nIDD)
				: CPropertyPageBase(nIDD)
{
	
}

void CDNSZoneWiz_ZoneNamePropertyPageBase::OnWizardHelp()
{
  CComPtr<IDisplayHelp> spHelp;
  HRESULT hr = GetHolder()->GetComponentData()->GetConsole()->QueryInterface(IID_IDisplayHelp, (void **)&spHelp);
  if (SUCCEEDED(hr)) 
    spHelp->ShowTopic(L"DNSConcepts.chm::/sag_DNS_CYDNS_04.htm");
}

BOOL CDNSZoneWiz_ZoneNamePropertyPageBase::OnSetActive() 
{
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
	
	// enable and show browse button only if secondary
   // and connected to multiple servers
   // NTRAID#NTBUG9-472636-2001/10/17-sburns

   INT_PTR count =
      pHolder->GetServerNode()->GetRootContainer()->GetContainerChildList()->GetCount();

   bool enable = (count >= 2) && !pHolder->m_pZoneInfo->m_bPrimary;

	CButton* pBrowseButton = GetBrowseButton();
	pBrowseButton->EnableWindow(enable);
	pBrowseButton->ShowWindow(enable);

  //
  // Limit the zone name to MAX_DNS_NAME_LEN characters
  //
  SendDlgItemMessage(IDC_EDIT_ZONE_NAME, EM_LIMITTEXT, (WPARAM)MAX_DNS_NAME_LEN, 0);

	pHolder->SetWizardButtonsMiddle(FALSE);
	SetUIState();
	return CPropertyPageBase::OnSetActive();
}

#ifdef USE_NDNC
LRESULT CDNSZoneWiz_ZoneNamePropertyPageBase::OnWizardNext() 
{
	GetUIState();

  CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
  CDNSServerNode* pServerNode = pHolder->GetServerNode();
  DNS_STATUS err = ::ValidateDnsNameAgainstServerFlags(pHolder->m_pZoneInfo->m_szZoneName, 
                                                       DnsNameDomain, 
                                                       pServerNode->GetNameCheckFlag());
  if (err != 0)
  {
    //
    // Bring up an error for an invalid name
    //
    CString szFmt, szMsg;
    szFmt.LoadString(IDS_MSG_ZONE_INVALID_NAME);
    szMsg.Format((LPCWSTR)szFmt, pHolder->m_pZoneInfo->m_szZoneName);
    if (DNSMessageBox(szMsg, MB_YESNO) == IDYES)
    {
      err = 0;
    }
  }

  if (err == 0)
  {
	  if (pHolder->m_pZoneInfo->m_bPrimary)
	  {
		  if (pHolder->m_pZoneInfo->m_storageType == CDNSCreateZoneInfo::useADS)
      {
		    return CDNSZoneWiz_DynamicPropertyPage::IDD; 
      }
		  else
      {
			  return CDNSZoneWiz_StoragePropertyPage::IDD;
      }
	  }
    else
    {
      if (pHolder->m_pZoneInfo->m_bIsStub &&
          pHolder->m_pZoneInfo->m_storageType != CDNSCreateZoneInfo::useADS)
      {
        return CDNSZoneWiz_StoragePropertyPage::IDD;
      }
      else
      {
        return CDNSZoneWiz_MastersPropertyPage::IDD;
      }
    }
  }

  return -1;
}

LRESULT CDNSZoneWiz_ZoneNamePropertyPageBase::OnWizardBack() 
{
	GetUIState();

  LRESULT nPrevPage = -1;

	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
  CDNSServerNode* pServerNode = pHolder->GetServerNode();

  if (pHolder->m_pZoneInfo->m_storageType != CDNSCreateZoneInfo::useADS ||
      pServerNode->GetBuildNumber() < DNS_SRV_BUILD_NUMBER_WHISTLER ||
      (pServerNode->GetMajorVersion() <= DNS_SRV_MAJOR_VERSION_NT_5 &&
       pServerNode->GetMinorVersion() < DNS_SRV_MINOR_VERSION_WHISTLER))
  {
	  if (pHolder->m_bKnowZoneLookupType && !pHolder->m_bKnowZoneLookupTypeEx)
    {
		  nPrevPage = (LRESULT)CDNSZoneWiz_ZoneTypePropertyPage::IDD;
    }
    else if (pHolder->m_bKnowZoneLookupTypeEx && 	pHolder->m_nBackToPage > 0)
    {
		  nPrevPage = pHolder->m_nBackToPage;
    }
    else
    {
      nPrevPage = CDNSZoneWiz_ZoneLookupPropertyPage::IDD;
    }
  }
  else
  {
	  if (pHolder->m_bKnowZoneLookupType && !pHolder->m_bKnowZoneLookupTypeEx)
    {
		  nPrevPage = (LRESULT)CDNSZoneWiz_ADReplicationPropertyPage::IDD;
    }
    else if (pHolder->m_bKnowZoneLookupTypeEx && 	pHolder->m_nBackToPage > 0)
    {
		  nPrevPage = pHolder->m_nBackToPage;
    }
    else
    {
      nPrevPage = CDNSZoneWiz_ZoneLookupPropertyPage::IDD;
    }
  }

  return nPrevPage;
}

#else

LRESULT CDNSZoneWiz_ZoneNamePropertyPageBase::OnWizardNext() 
{
	GetUIState();

  CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
  DNS_STATUS err = ::ValidateDnsNameAgainstServerFlags(pHolder->m_pZoneInfo->m_szZoneName, 
                                                       DnsNameDomain, 
                                                       pHolder->GetServerNode()->GetNameCheckFlag());
  if (err != 0)
  {
    //
    // Bring up an error for an invalid name
    //
    CString szFmt, szMsg;
    szFmt.LoadString(IDS_MSG_ZONE_INVALID_NAME);
    szMsg.Format((LPCWSTR)szFmt, pHolder->m_pZoneInfo->m_szZoneName);
    if (DNSMessageBox(szMsg, MB_YESNO) == IDYES)
    {
      err = 0;
    }
  }

  if (err == 0)
  {
	  if (pHolder->m_pZoneInfo->m_bPrimary)
	  {
		  if (pHolder->m_pZoneInfo->m_storageType == CDNSCreateZoneInfo::useADS)
      {
		    return CDNSZoneWiz_DynamicPropertyPage::IDD; 
      }
		  else
      {
			  return CDNSZoneWiz_StoragePropertyPage::IDD;
      }
	  }
    else
    {
      if (pHolder->m_pZoneInfo->m_bIsStub &&
          pHolder->m_pZoneInfo->m_storageType != CDNSCreateZoneInfo::useADS)
      {
        return CDNSZoneWiz_StoragePropertyPage::IDD;
      }
        return CDNSZoneWiz_MastersPropertyPage::IDD;
    }
  }

  return -1;
}

LRESULT CDNSZoneWiz_ZoneNamePropertyPageBase::OnWizardBack() 
{
	GetUIState();

  LRESULT nPrevPage = -1;

	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
	  if (pHolder->m_bKnowZoneLookupType && !pHolder->m_bKnowZoneLookupTypeEx)
    {
		  nPrevPage = (LRESULT)CDNSZoneWiz_ZoneTypePropertyPage::IDD;
    }
    else if (pHolder->m_bKnowZoneLookupTypeEx && 	pHolder->m_nBackToPage > 0)
    {
		  nPrevPage = pHolder->m_nBackToPage;
    }
    else
    {
      nPrevPage = CDNSZoneWiz_ZoneLookupPropertyPage::IDD;
    }
  return nPrevPage;
}

#endif // USE_NDNC


void CDNSZoneWiz_ZoneNamePropertyPageBase::OnChangeEditZoneName()
{
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();

	CString sz;
	GetZoneNameEdit()->GetWindowText(sz);
	sz.TrimLeft();
	sz.TrimRight();

   // Only do the validation if we are not in Advanced View

   bool validationAttempted = false;
   bool rootDataRetrieved = false;

   CComponentDataObject* pComponentData = pHolder->GetComponentData();
   ASSERT(pComponentData);

   if (pComponentData)
   {
      CRootData* pRootData = pComponentData->GetRootData();
      ASSERT(pRootData);

      if (pRootData)
      {
         CDNSRootData* pDNSRootData = dynamic_cast<CDNSRootData*>(pRootData);
         ASSERT(pDNSRootData);

         if (pDNSRootData)
         {
            rootDataRetrieved = true;

            if (!pDNSRootData->IsAdvancedView())
            {
	            pHolder->SetWizardButtonsMiddle(
		            IsValidDnsZoneName(sz, pHolder->m_pZoneInfo->m_bForward));

               validationAttempted = true;
            }
         }
      }
   }

   if ((rootDataRetrieved &&
        !validationAttempted) ||
       !rootDataRetrieved)
   {
      // Either we are in advanced view or we failed to even try due to 
      // all the pointer casting and dereferencing so set the Next button
      // to enabled just in case.  The server will handle any bad syntax
      // or names

      pHolder->SetWizardButtonsMiddle(TRUE);
   }
}

void CDNSZoneWiz_ZoneNamePropertyPageBase::OnBrowse()
{
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();

	AFX_MANAGE_STATE(AfxGetStaticModuleState());
   CThemeContextActivator activator;

	CComponentDataObject* pComponentDataObject = 
				GetHolder()->GetComponentData();
	CDNSServerNode* pServerNode = pHolder->GetServerNode();
	ASSERT(pServerNode != NULL);
	CDNSBrowserDlg dlg(pComponentDataObject, pHolder,
		pHolder->m_pZoneInfo->m_bForward ? ZONE_FWD : ZONE_REV,
		FALSE /* bEnableEdit */, pServerNode->GetDisplayName() );
	if (IDOK == dlg.DoModal())
	{
		CEdit* pEdit = GetZoneNameEdit();
		pEdit->SetWindowText(dlg.GetSelectionString());
	}
}

void CDNSZoneWiz_ZoneNamePropertyPageBase::SetUIState()
{
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();

	// if we changed zone lookup type, need to clear zone name
	if (pHolder->m_pZoneInfo->m_bWasForward != pHolder->m_pZoneInfo->m_bForward)
	{
		pHolder->m_pZoneInfo->m_szZoneName.Empty();
		pHolder->m_pZoneInfo->m_bWasForward = pHolder->m_pZoneInfo->m_bForward;
	}
	GetZoneNameEdit()->SetWindowText(pHolder->m_pZoneInfo->m_szZoneName);
}

void CDNSZoneWiz_ZoneNamePropertyPageBase::GetUIState()
{
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();

	CString szZoneName;
	GetZoneNameEdit()->GetWindowText(szZoneName);
	// need to trim blanks
	szZoneName.TrimLeft();
	szZoneName.TrimRight();
	// provide a suggested file name
	if (pHolder->m_pZoneInfo->m_szZoneName != szZoneName)
	{
		pHolder->m_pZoneInfo->m_szZoneName = szZoneName;
		int nLen = szZoneName.GetLength();
		if (nLen == 0)
		{
			pHolder->m_pZoneInfo->m_szZoneStorage.Empty();
		}
		else if (nLen == 1 && szZoneName[0] == TEXT('.'))
		{
			pHolder->m_pZoneInfo->m_szZoneStorage = _T("root.dns");
		}
		else
		{
			LPCTSTR lpszFmt = ( TEXT('.') == szZoneName.GetAt(nLen-1)) 
					? _T("%sdns") : _T("%s.dns");
			pHolder->m_pZoneInfo->m_szZoneStorage.Format(lpszFmt, (LPCTSTR)pHolder->m_pZoneInfo->m_szZoneName);

      //
			// Added by JEFFJON 2/11/99 - changes any illegal file name characters (\/:*?"<>|) to '_'
      // and truncates any filename to _MAX_FNAME length
      //
			LPCWSTR lpszZoneStorage = (LPCWSTR)pHolder->m_pZoneInfo->m_szZoneStorage;
			int iCount = pHolder->m_pZoneInfo->m_szZoneStorage.GetLength();
      if (iCount > _MAX_FNAME)
      {
        pHolder->m_pZoneInfo->m_szZoneStorage = pHolder->m_pZoneInfo->m_szZoneStorage.Left(_MAX_FNAME - 4);
        pHolder->m_pZoneInfo->m_szZoneStorage += L".dns";
      }

			for (int idx = 0; idx < iCount + 1; idx++)
			{
				if (lpszZoneStorage[0] == L'\\' || 
					 lpszZoneStorage[0] == L'/' ||
					 lpszZoneStorage[0] == L':' ||
					 lpszZoneStorage[0] == L'*' ||
					 lpszZoneStorage[0] == L'?' ||
					 lpszZoneStorage[0] == L'"' ||
					 lpszZoneStorage[0] == L'<' ||
					 lpszZoneStorage[0] == L'>' ||
					 lpszZoneStorage[0] == L'|')
				{
					pHolder->m_pZoneInfo->m_szZoneStorage.SetAt(idx, L'_');
				}
				lpszZoneStorage++;
			}
		}
	}
}

//////////////////////////////////////////////////////////////////////////
// CDNSZoneWiz_FwdZoneNamePropertyPage


CDNSZoneWiz_FwdZoneNamePropertyPage::CDNSZoneWiz_FwdZoneNamePropertyPage() 
	: CDNSZoneWiz_ZoneNamePropertyPageBase(CDNSZoneWiz_FwdZoneNamePropertyPage::IDD)
{
	InitWiz97(FALSE,IDS_ZWIZ_FWD_ZONE_NAME_TITLE,IDS_ZWIZ_FWD_ZONE_NAME_SUBTITLE, true);
}

// NOTICE-NTRAID#NTBUG9-2002/04/22-artm  Requested long static text set in code.
// When this page is made active we need to load an extra long string
// from the string table and set the static control in code.
BOOL CDNSZoneWiz_FwdZoneNamePropertyPage::OnInitDialog()
{
    BOOL success = TRUE;
    CDNSZoneWiz_ZoneNamePropertyPageBase::OnInitDialog();

    // Get a pointer to the control on the page.
    CStatic* pStatic = (CStatic*)GetDlgItem(IDC_ZONENAME_INFO);
    ASSERT(pStatic!=NULL);
    CString note;

    // Load the string from resources.
    success = note.LoadString(IDS_ZONENAME_INFO);
    ASSERT(success != FALSE);

    pStatic->SetWindowText(note);

    // Get the base class to do the rest of the work.
    return success;
}


//////////////////////////////////////////////////////////////////////////
// CDNSZoneWiz_RevZoneNamePropertyPage

BEGIN_MESSAGE_MAP(CDNSZoneWiz_RevZoneNamePropertyPage, CDNSZoneWiz_ZoneNamePropertyPageBase)
	ON_EN_CHANGE(IDC_SUBNET_IPEDIT, OnChangeSubnetIPv4Ctrl)
//	ON_EN_CHANGE(IDC_MASK_IPEDIT, OnChangeMaskIPv4Ctrl)
  ON_BN_CLICKED(IDC_HELP_BUTTON, OnHelpButton)
	ON_BN_CLICKED(IDC_USE_IP_RADIO, OnChangeUseIPRadio)
	ON_BN_CLICKED(IDC_USE_EDIT_RADIO, OnChangeUseEditRadio)
END_MESSAGE_MAP()


CDNSZoneWiz_RevZoneNamePropertyPage::CDNSZoneWiz_RevZoneNamePropertyPage() 
	: CDNSZoneWiz_ZoneNamePropertyPageBase(CDNSZoneWiz_RevZoneNamePropertyPage::IDD)
{
	InitWiz97(FALSE,IDS_ZWIZ_REV_ZONE_NAME_TITLE,IDS_ZWIZ_REV_ZONE_NAME_SUBTITLE, true);
	m_bUseIP = TRUE; // default is to use IP ctrl for input
}


BOOL CDNSZoneWiz_RevZoneNamePropertyPage::OnInitDialog()
{
	CPropertyPageBase::OnInitDialog();
	ResetIPEditAndNameValue();
	SyncRadioButtons(m_bUseIP);
	return TRUE;
}

BOOL CDNSZoneWiz_RevZoneNamePropertyPage::OnSetActive()
{
	if (!CDNSZoneWiz_ZoneNamePropertyPageBase::OnSetActive())
		return FALSE;

	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();

  if (m_bUseIP)
  {
	  OnChangeSubnetIPv4Ctrl();
  }

	if (pHolder->m_pZoneInfo->m_szZoneName.IsEmpty())
		ResetIPEditAndNameValue();
	return TRUE;
}


INT
_fastcall
DnsGetDefaultClassNetworkOctetCountFromFirstOctect(
    IN      WORD   dwFirstOctect
    )
/*++

Routine Description:

    Gets count of octets in network portion IP address.
    Note, this is standard IP network class for given,
    obviously subnetting is unknown.

Arguments:

    dwFirstOctect -- first octet expressed as DWORD

Return Value:

    Count of network address octets.

--*/
{
    if ( dwFirstOctect > 255 )
    {
        // huh?
        return( 0 );
    }

    //  note addresses are in netbyte order
    //  which we are treating as byte flipped and hence
    //  test the high bits in the low byte

    //  class A?

    if ( ! (0x80 & dwFirstOctect) )
    {
        return( 1 );
    }

    //  class B?

    if ( ! (0x40 & dwFirstOctect) )
    {
        return( 2 );
    }

    //  then class C
    //  yes, there's some multicast BS out there, I don't
    //  believe it requires any special handling

    return( 3 );
}


int _ValidFields(DWORD* dwArr)
{
	// we count contiguous non empty fields
	ASSERT(dwArr[3] == (DWORD)-1); // last field must be zero (disabled)
	int nFields = 0;
	if (dwArr[3] == (DWORD)-1) 
	{
		if ( (dwArr[0] != (DWORD)-1) && (dwArr[1] == (DWORD)-1) && (dwArr[2] == (DWORD)-1) )
			nFields = 1;
		else if ( (dwArr[0] != (DWORD)-1) && (dwArr[1] != (DWORD)-1) && (dwArr[2] == (DWORD)-1) )
			nFields = 2;
		else if ( (dwArr[0] != (DWORD)-1) && (dwArr[1] != (DWORD)-1) && (dwArr[2] != (DWORD)-1) )
			nFields = 3;
	}
	return nFields;
}

int _ValidMaskFields(DWORD* dwArr)
{
	int nFields = _ValidFields(dwArr);
	if (nFields == 0)
		return nFields;

	// REVIEW_MARCOC: should ask for contiguous octects....
	// we currently check for non zero
	for (int k=0; k<nFields; k++)
	{
		if (dwArr[k] == 0)
			return k;
	}
	return nFields;
}

int _NumericFieldCount(DWORD* dwArr)
{
	ASSERT(dwArr[3] == 0);
	// assume [3] is always zero, check [2],[1],[0]
	for (int k=2; k>=0; k--)
	{
		if ( (dwArr[k] > 0) && (dwArr[k] <= 255) )
			return k+1;
	}
	return 0;
}

BOOL CDNSZoneWiz_RevZoneNamePropertyPage::BuildZoneName(DWORD* dwSubnetArr /*, DWORD* dwMaskArr*/)
{
	int nSubnetFields = _ValidFields(dwSubnetArr);

	WCHAR szBuf[128];
	szBuf[0] = NULL; // clear edit field

	// count the number of non zero/empty fields in the mask
/*	int nMaskFields = 0;
	if (nSubnetFields > 0)
		nMaskFields = _ValidMaskFields(dwMaskArr);

	if (nMaskFields > nSubnetFields)
	{
		// mask extends into blank subnet fields, torn them into zeroes
		for (int k=nSubnetFields; k< nMaskFields; k++)
			dwSubnetArr[k] = (DWORD)0;
	}
*/
	// format the zone name
//	switch (nMaskFields)
  switch (nSubnetFields)
	{
	case 0:
		wsprintf(szBuf, L"???%s", INADDR_ARPA_SUFFIX);
		break;
	case 1:
		ASSERT(dwSubnetArr[0] != (DWORD)-1);
		wsprintf(szBuf, L"%d%s", dwSubnetArr[0], INADDR_ARPA_SUFFIX);
		break;
	case 2:
		ASSERT(dwSubnetArr[0] != (DWORD)-1);
		ASSERT(dwSubnetArr[1] != (DWORD)-1);
		wsprintf(szBuf, L"%d.%d%s", dwSubnetArr[1], dwSubnetArr[0], INADDR_ARPA_SUFFIX);
		break;
	case 3:
		ASSERT(dwSubnetArr[0] != (DWORD)-1);
		ASSERT(dwSubnetArr[1] != (DWORD)-1);
		ASSERT(dwSubnetArr[2] != (DWORD)-1);
		wsprintf(szBuf, L"%d.%d.%d%s", dwSubnetArr[2], dwSubnetArr[1], dwSubnetArr[0], INADDR_ARPA_SUFFIX);
		break;
	};
	
	GetZoneNameEdit()->SetWindowText(szBuf);
//	return (nMaskFields > 0);
  return (nSubnetFields > 0);
}

void CDNSZoneWiz_RevZoneNamePropertyPage::OnHelpButton()
{
  CComPtr<IDisplayHelp> spHelp;
  HRESULT hr = GetHolder()->GetComponentData()->GetConsole()->QueryInterface(IID_IDisplayHelp, (void **)&spHelp);
  if (SUCCEEDED(hr)) 
    spHelp->ShowTopic(L"DNSConcepts.chm::/sag_DNS_und_ReverseLookup.htm");
}

void CDNSZoneWiz_RevZoneNamePropertyPage::OnWizardHelp()
{
  CComPtr<IDisplayHelp> spHelp;
  HRESULT hr = GetHolder()->GetComponentData()->GetConsole()->QueryInterface(IID_IDisplayHelp, (void **)&spHelp);
  if (SUCCEEDED(hr)) 
    spHelp->ShowTopic(L"DNSconcepts.chm::/sag_DNS_CYDNS_18.htm");
}

void CDNSZoneWiz_RevZoneNamePropertyPage::OnChangeSubnetIPv4Ctrl()
{
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
	BOOL bEnableNext = FALSE;

	// retrieve subnet IP ctrl value
  DWORD dwSubnetArr[4] = {0};
	GetSubnetIPv4Ctrl()->GetArray(dwSubnetArr,4);
	ASSERT(dwSubnetArr[3] == (DWORD)-1); // last field must be zero (disabled)

	// determine address class
	// if the first field is empty or zero, invalid class
	int nSubnetValidFields = _ValidFields(dwSubnetArr);
	int nClass;
	if ( (dwSubnetArr[0] == (DWORD)-1) || (dwSubnetArr[0] == 0) )
		nClass = 0;
	else
	{
		if (nSubnetValidFields > 0)
			nClass = DnsGetDefaultClassNetworkOctetCountFromFirstOctect(LOWORD(dwSubnetArr[0]));
		else
			nClass = 0; // bad format
	}
	ASSERT( (nClass >= 0) && (nClass <= 3) );

	// set the default mask value to all zeroes
	// look if the subnet extends beyond mask
/*	DWORD dwMaskArr[4];
	dwMaskArr[0] = dwMaskArr[1] = dwMaskArr[2] = dwMaskArr[3] = (DWORD)0;
	if ((nSubnetValidFields > 0) && (nClass >0))
	{
		// look for last nonzero field
		int nNumericCount = _NumericFieldCount(dwSubnetArr);
		int j = nClass;
		if (nNumericCount > nClass)
			j = nNumericCount;
		ASSERT((j>0) && (j<=3));
		for (int i=0; i<j; i++)
			dwMaskArr[i] = (DWORD)255;
	}

	// set the mask IP control
	GetMaskIPv4Ctrl()->SetArray(dwMaskArr,4);
*/
	// rebuild the zone name
	bEnableNext = BuildZoneName(dwSubnetArr /*,dwMaskArr*/);
	pHolder->SetWizardButtonsMiddle(bEnableNext);
}
/*
void CDNSZoneWiz_RevZoneNamePropertyPage::OnChangeMaskIPv4Ctrl()
{
	ASSERT(m_bUseIP);

	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
	BOOL bEnableNext = FALSE;

	// retrieve subnet IP ctrl value
	DWORD dwSubnetArr[4];
	GetSubnetIPv4Ctrl()->GetArray(dwSubnetArr,4);
	ASSERT(dwSubnetArr[3] == 0); // last field must be zero (disabled)

	// retrieve mask IP ctrl value
	DWORD dwMaskArr[4];
	GetMaskIPv4Ctrl()->GetArray(dwMaskArr,4);

	// rebuild the zone name
	bEnableNext = BuildZoneName(dwSubnetArr,dwMaskArr);
	pHolder->SetWizardButtonsMiddle(bEnableNext);
}
*/
/*
void CDNSZoneWiz_RevZoneNamePropertyPage::OnChangeSubnetIPv4Ctrl()
{
	ASSERT(m_bUseIP);

	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
	BOOL bEnable = FALSE;

	// retrieve IP ctrl value
	DWORD dwArr[4];
	GetSubnetIPv4Ctrl()->GetArray(dwArr,4);

	int nFields = -1;
	WCHAR szBuf[128];
	szBuf[0] = NULL; // clear edit field

	ASSERT(dwArr[3] == 0); // last field must be zero (disabled)
	
	if (dwArr[3] == 0) 
	{
		if ( (dwArr[0] != (DWORD)-1) && (dwArr[1] == (DWORD)-1) && (dwArr[2] == (DWORD)-1) )
			nFields = 1;
		else if ( (dwArr[0] != (DWORD)-1) && (dwArr[1] != (DWORD)-1) && (dwArr[2] == (DWORD)-1) )
			nFields = 2;
		else if ( (dwArr[0] != (DWORD)-1) && (dwArr[1] != (DWORD)-1) && (dwArr[2] != (DWORD)-1) )
			nFields = 3;
		// convert to text, reverse and insert 
		// into the edit control
		// do not consider trailing zeroes
		int nValidOctect = DnsGetDefaultClassNetworkOctetCountFromFirstOctect(LOWORD(dwArr[0]));
		while ((dwArr[nFields-1] == 0) && (nFields > nValidOctect) )
		{
			nFields--;
		}
		
		switch (nFields)
		{
		case 1:
			wsprintf(szBuf, L"%d%s", dwArr[0], INADDR_ARPA_SUFFIX);
			break;
		case 2:
			wsprintf(szBuf, L"%d.%d%s", dwArr[1], dwArr[0], INADDR_ARPA_SUFFIX);
			break;
		case 3:
			wsprintf(szBuf, L"%d.%d.%d%s", dwArr[2], dwArr[1], dwArr[0], INADDR_ARPA_SUFFIX);
			break;
		};
	}
	GetZoneNameEdit()->SetWindowText(szBuf);
	pHolder->SetWizardButtonsMiddle(nFields != -1);	
}
*/

void CDNSZoneWiz_RevZoneNamePropertyPage::OnChangeUseIPRadio()
{
	BOOL bPrevUseIP = m_bUseIP;
	m_bUseIP = !m_bUseIP;
	SyncRadioButtons(bPrevUseIP);
}

void CDNSZoneWiz_RevZoneNamePropertyPage::OnChangeUseEditRadio()
{
	BOOL bPrevUseIP = m_bUseIP;
	m_bUseIP = !m_bUseIP;
	SyncRadioButtons(bPrevUseIP);
}

void CDNSZoneWiz_RevZoneNamePropertyPage::ResetIPEditAndNameValue()
{
	DWORD dwArr[4];
	dwArr[0] = (DWORD)-1;
	dwArr[1] = dwArr[2] = dwArr[3] = (DWORD)-1;
	GetSubnetIPv4Ctrl()->SetArray(dwArr, 4);
	GetZoneNameEdit()->SetWindowText(NULL);
}

void CDNSZoneWiz_RevZoneNamePropertyPage::SyncRadioButtons(BOOL bPrevUseIP)
{
	CButton* pUseIPRadio = GetUseIPRadio();
	CButton* pUseEditRadio = GetUseEditRadio();
	CDNSIPv4Control* pSubnetIPv4Ctrl = GetSubnetIPv4Ctrl();
//	CDNSIPv4Control* pMaskIPv4Ctrl = GetMaskIPv4Ctrl();

	// change selection
	pUseIPRadio->SetCheck(m_bUseIP);
	pUseEditRadio->SetCheck(!m_bUseIP);

	GetZoneNameEdit()->EnableWindow(!m_bUseIP);
	pSubnetIPv4Ctrl->EnableWindow(m_bUseIP);
	pSubnetIPv4Ctrl->EnableField(3, FALSE);	// always keep the last field disabled
//	pMaskIPv4Ctrl->EnableWindow(m_bUseIP);
//	pMaskIPv4Ctrl->EnableField(3, FALSE);	// always keep the last field disabled

	if (bPrevUseIP && !m_bUseIP)
	{
		// we are moving from editbox to IP control
		// need to set values all over again
    CString szZoneText;
    GetZoneNameEdit()->GetWindowText(szZoneText);

		DWORD dwArr[4];
		dwArr[0] = (DWORD)-1;
		dwArr[1] = dwArr[2] = dwArr[3] = (DWORD)-1;
		pSubnetIPv4Ctrl->SetArray(dwArr, 4);
//		dwArr[1] = dwArr[2] = (DWORD)-1;
//		pMaskIPv4Ctrl->SetArray(dwArr, 4);

    GetZoneNameEdit()->SetWindowText(szZoneText);
	}
	else
	{
		GetZoneNameEdit()->SetWindowText(NULL);
	}
}


//////////////////////////////////////////////////////////////////////////
// CDNSZoneWiz_MastersPropertyPage

void CZoneWiz_MastersIPEditor::OnChangeData()
{
	CDNSZoneWiz_MastersPropertyPage* pPage =  
				(CDNSZoneWiz_MastersPropertyPage*)GetParentWnd();
	pPage->SetValidIPArray(GetCount() > 0);
}


CDNSZoneWiz_MastersPropertyPage::CDNSZoneWiz_MastersPropertyPage() 
				: CPropertyPageBase(CDNSZoneWiz_MastersPropertyPage::IDD)
{
	InitWiz97(FALSE,IDS_ZWIZ_MASTERS_TITLE,IDS_ZWIZ_MASTERS_SUBTITLE, true);
	m_bValidIPArray = FALSE;
}


BEGIN_MESSAGE_MAP(CDNSZoneWiz_MastersPropertyPage, CPropertyPageBase)
	ON_BN_CLICKED(IDC_BROWSE_BUTTON, OnBrowse)
END_MESSAGE_MAP()

void CDNSZoneWiz_MastersPropertyPage::OnWizardHelp()
{
  CComPtr<IDisplayHelp> spHelp;
  HRESULT hr = GetHolder()->GetComponentData()->GetConsole()->QueryInterface(IID_IDisplayHelp, (void **)&spHelp);
  if (SUCCEEDED(hr)) 
    spHelp->ShowTopic(L"DNSConcepts.chm::/sag_DNS_NZWIZ_04.htm");
}

BOOL CDNSZoneWiz_MastersPropertyPage::OnSetActive() 
{
	// this page has to appear only for secondary zone
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
	ASSERT(!pHolder->m_pZoneInfo->m_bPrimary);
	SetUIState();

	// hide browse unless connected to multiple servers
	// NTRAID#NTBUG9-472636-2001/10/17-sburns

	INT_PTR count =
	   pHolder->GetServerNode()->GetRootContainer()->GetContainerChildList()->GetCount();

	bool enable = (count >= 2);

	CButton* pBrowseButton = (CButton*) GetDlgItem(IDC_BROWSE_BUTTON);
	pBrowseButton->EnableWindow(enable);
	pBrowseButton->ShowWindow(enable);
   
	pHolder->SetWizardButtonsMiddle(m_bValidIPArray);
	return CPropertyPageBase::OnSetActive();
}

LRESULT CDNSZoneWiz_MastersPropertyPage::OnWizardNext() 
{
	GetUIState();
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
	// skip storage page for a secondary zone
	if (pHolder->m_bFinishPage)
		return CDNSZoneWiz_FinishPropertyPage::IDD; 

  // This was an else but the sundown build did not like having a control path not return a value
	ASSERT(pHolder->m_nNextToPage != 0);
	return pHolder->m_nNextToPage;
}

#ifdef USE_NDNC
LRESULT CDNSZoneWiz_MastersPropertyPage::OnWizardBack() 
{
	GetUIState();
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();

  if (pHolder->m_pZoneInfo->m_bIsStub &&
      pHolder->m_pZoneInfo->m_storageType != CDNSCreateZoneInfo::useADS)
  {
    return (LRESULT)CDNSZoneWiz_StoragePropertyPage::IDD;
  }

  if (pHolder->m_pZoneInfo->m_bIsStub &&
      pHolder->m_pZoneInfo->m_storageType == CDNSCreateZoneInfo::useADS)
  {
    //
    // If its a pre-Whistler server then go back to the name page
    //
		if (pHolder->m_pZoneInfo->m_bForward)
    {
			return (LRESULT)CDNSZoneWiz_FwdZoneNamePropertyPage::IDD;
    }
		else
    {
			return (LRESULT)CDNSZoneWiz_RevZoneNamePropertyPage::IDD;
    }
  }

	if (pHolder->m_pZoneInfo->m_bForward)
  {
		return (LRESULT)CDNSZoneWiz_FwdZoneNamePropertyPage::IDD;
  }
  return (LRESULT)CDNSZoneWiz_RevZoneNamePropertyPage::IDD;
}

#else

LRESULT CDNSZoneWiz_MastersPropertyPage::OnWizardBack() 
{
	GetUIState();
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();

  if (pHolder->m_pZoneInfo->m_bIsStub &&
      pHolder->m_pZoneInfo->m_storageType != CDNSCreateZoneInfo::useADS)
  {
    return (LRESULT)CDNSZoneWiz_StoragePropertyPage::IDD;
  }

		if (pHolder->m_pZoneInfo->m_bForward)
			return (LRESULT)CDNSZoneWiz_FwdZoneNamePropertyPage::IDD;

  // This was an else but the sundown build did not like having a control path not return a value
  return (LRESULT)CDNSZoneWiz_RevZoneNamePropertyPage::IDD;
}

#endif // USE_NDNC

BOOL CDNSZoneWiz_MastersPropertyPage::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();
	VERIFY(m_editor.Initialize(this, 
                             GetParent(),
                             IDC_BUTTON_UP, 
                             IDC_BUTTON_DOWN,
								             IDC_BUTTON_ADD, 
                             IDC_BUTTON_REMOVE, 
								             IDC_IPEDIT, 
                             IDC_LIST));
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDNSZoneWiz_MastersPropertyPage::SetValidIPArray(BOOL b)
{
	m_bValidIPArray = b;
	GetHolder()->SetWizardButtonsMiddle(m_bValidIPArray);
}


void CDNSZoneWiz_MastersPropertyPage::SetUIState()
{
	m_editor.Clear();
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
	if ( pHolder->m_pZoneInfo->m_ipMastersArray != NULL)  
	{
		ASSERT(pHolder->m_pZoneInfo->m_nMastersCount > 0);
		m_editor.AddAddresses(pHolder->m_pZoneInfo->m_ipMastersArray, pHolder->m_pZoneInfo->m_nMastersCount);
	}

  if ( pHolder->m_pZoneInfo->m_bIsStub && 
       pHolder->m_pZoneInfo->m_storageType == CDNSCreateZoneInfo::useADS)
  {
    GetDlgItem(IDC_LOCAL_LIST_CHECK)->EnableWindow(TRUE);
    GetDlgItem(IDC_LOCAL_LIST_CHECK)->ShowWindow(TRUE);
  }
  else
  {
    GetDlgItem(IDC_LOCAL_LIST_CHECK)->EnableWindow(FALSE);
    GetDlgItem(IDC_LOCAL_LIST_CHECK)->ShowWindow(FALSE);
  }
}

void CDNSZoneWiz_MastersPropertyPage::GetUIState()
{
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();

	pHolder->m_pZoneInfo->ResetIpArr();
	pHolder->m_pZoneInfo->m_nMastersCount = m_editor.GetCount();

	if (pHolder->m_pZoneInfo->m_nMastersCount > 0)
	{
		pHolder->m_pZoneInfo->m_ipMastersArray = new IP_ADDRESS[pHolder->m_pZoneInfo->m_nMastersCount];

      if (pHolder->m_pZoneInfo->m_ipMastersArray)
      {
		   int nFilled = 0;
		   m_editor.GetAddresses(pHolder->m_pZoneInfo->m_ipMastersArray, pHolder->m_pZoneInfo->m_nMastersCount, &nFilled);
		   ASSERT(nFilled == (int)(pHolder->m_pZoneInfo->m_nMastersCount));
      }

      LRESULT lLocalList = SendDlgItemMessage(IDC_LOCAL_LIST_CHECK, BM_GETCHECK, 0, 0);
      pHolder->m_pZoneInfo->m_bLocalListOfMasters = (lLocalList == BST_CHECKED);
	}
}

void CDNSZoneWiz_MastersPropertyPage::OnBrowse()
{
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
	if (!m_editor.BrowseFromDNSNamespace(pHolder->GetComponentData(), 
										pHolder, 
										TRUE,
										pHolder->GetServerNode()->GetDisplayName()))
	{
		DNSMessageBox(IDS_MSG_ZONE_MASTERS_BROWSE_FAIL);
	}
}


//////////////////////////////////////////////////////////////////////////
// CDNSZoneWiz_DynamicPropertyPage

CDNSZoneWiz_DynamicPropertyPage::CDNSZoneWiz_DynamicPropertyPage() 
				: CPropertyPageBase(CDNSZoneWiz_DynamicPropertyPage::IDD)
{
	InitWiz97(FALSE,IDS_ZWIZ_DYNAMIC_TITLE,IDS_ZWIZ_DYNAMIC_SUBTITLE, true);
}


BEGIN_MESSAGE_MAP(CDNSZoneWiz_DynamicPropertyPage, CPropertyPageBase)
END_MESSAGE_MAP()

void CDNSZoneWiz_DynamicPropertyPage::OnWizardHelp()
{
  CComPtr<IDisplayHelp> spHelp;
  HRESULT hr = GetHolder()->GetComponentData()->GetConsole()->QueryInterface(IID_IDisplayHelp, (void **)&spHelp);
  if (SUCCEEDED(hr)) 
    spHelp->ShowTopic(L"DNSConcepts.chm::/sag_DNS_CYDNS_06.htm");
}

BOOL CDNSZoneWiz_DynamicPropertyPage::OnSetActive() 
{
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
	SetUIState();

	pHolder->SetWizardButtonsMiddle(TRUE);
	return CPropertyPageBase::OnSetActive();
}

LRESULT CDNSZoneWiz_DynamicPropertyPage::OnWizardNext() 
{
	GetUIState();
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();

  //
  // skip storage page for a secondary zone
  //
	if (pHolder->m_bFinishPage)
  {
		return CDNSZoneWiz_FinishPropertyPage::IDD; 
  }

  //
  // This was an else but the sundown build did not like having a control path not return a value
  //
	ASSERT(pHolder->m_nNextToPage != 0);
	return pHolder->m_nNextToPage;
}

#ifdef USE_NDNC
LRESULT CDNSZoneWiz_DynamicPropertyPage::OnWizardBack() 
{
	GetUIState();
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
  LRESULT nIDD = 0;

	if (pHolder->m_pZoneInfo->m_bPrimary)
  {
    if (pHolder->m_pZoneInfo->m_storageType == CDNSCreateZoneInfo::useADS)
    {
      //
      // If its a pre-Whistler server then go back to the name page
      //
		  if (pHolder->m_pZoneInfo->m_bForward)
      {
			  nIDD = (LRESULT)CDNSZoneWiz_FwdZoneNamePropertyPage::IDD;
      }
		  else
      {
			  nIDD = (LRESULT)CDNSZoneWiz_RevZoneNamePropertyPage::IDD;
      }
    }
    else
    {
		  nIDD = (LRESULT)CDNSZoneWiz_StoragePropertyPage::IDD;
    }
  }
  else
  {
    nIDD = (LRESULT)CDNSZoneWiz_MastersPropertyPage::IDD;
  }
  return nIDD;
}

#else

LRESULT CDNSZoneWiz_DynamicPropertyPage::OnWizardBack() 
{
	GetUIState();
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
  LRESULT nIDD = 0;

	if (pHolder->m_pZoneInfo->m_bPrimary)
  {
    if (pHolder->m_pZoneInfo->m_storageType == CDNSCreateZoneInfo::useADS)
    {
		  if (pHolder->m_pZoneInfo->m_bForward)
      {
			  nIDD = (LRESULT)CDNSZoneWiz_FwdZoneNamePropertyPage::IDD;
      }
		  else
      {
			  nIDD = (LRESULT)CDNSZoneWiz_RevZoneNamePropertyPage::IDD;
      }
    }
    else
    {
		  nIDD = (LRESULT)CDNSZoneWiz_StoragePropertyPage::IDD;
    }
  }
  else
  {
    nIDD = (LRESULT)CDNSZoneWiz_MastersPropertyPage::IDD;
  }
  return nIDD;
}
#endif // USE_NDNC

BOOL CDNSZoneWiz_DynamicPropertyPage::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();

  CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
  
  //
  // Set the default dynamic update depending on zone type
  //
  if (pHolder->m_pZoneInfo->m_bPrimary && 
      pHolder->m_pZoneInfo->m_storageType == CDNSCreateZoneInfo::useADS)
  {
    pHolder->m_pZoneInfo->m_nDynamicUpdate = ZONE_UPDATE_SECURE;
  }
  else
  {
    pHolder->m_pZoneInfo->m_nDynamicUpdate = ZONE_UPDATE_OFF;
  }

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDNSZoneWiz_DynamicPropertyPage::SetUIState()
{
  CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
  
  BOOL bSecureOK = (pHolder->m_pZoneInfo->m_storageType == CDNSCreateZoneInfo::useADS);
  GetDlgItem(IDC_SECURE_DYNAMIC_RADIO)->EnableWindow(bSecureOK);
  SendDlgItemMessage(IDC_SECURE_DYNAMIC_RADIO, BM_SETCHECK, BST_UNCHECKED, 0);

  //
  // If we are not allowing secure updates (standard primary) and
  // the radio was checked before, change the flag so that we check
  // the do not allow dynamic updates radio instead
  //
  UINT nDynamicUpdate = pHolder->m_pZoneInfo->m_nDynamicUpdate;
  if (!bSecureOK && nDynamicUpdate == ZONE_UPDATE_SECURE)
  {
    nDynamicUpdate = ZONE_UPDATE_OFF;
    pHolder->m_pZoneInfo->m_nDynamicUpdate = nDynamicUpdate;
  }

  //
  // Set the radio buttons according to the zone info
  //
  if (nDynamicUpdate == ZONE_UPDATE_OFF)
  {
    SendDlgItemMessage(IDC_DENY_DYNAMIC_RADIO, BM_SETCHECK, BST_CHECKED, 0);
    SendDlgItemMessage(IDC_ALLOW_DYNAMIC_RADIO, BM_SETCHECK, BST_UNCHECKED, 0);
    SendDlgItemMessage(IDC_SECURE_DYNAMIC_RADIO, BM_SETCHECK, BST_UNCHECKED, 0);
  }
  else if (nDynamicUpdate == ZONE_UPDATE_UNSECURE)
  {
    SendDlgItemMessage(IDC_DENY_DYNAMIC_RADIO, BM_SETCHECK, BST_UNCHECKED, 0);
    SendDlgItemMessage(IDC_ALLOW_DYNAMIC_RADIO, BM_SETCHECK, BST_CHECKED, 0);
    SendDlgItemMessage(IDC_SECURE_DYNAMIC_RADIO, BM_SETCHECK, BST_UNCHECKED, 0);
  }
  else
  {
    SendDlgItemMessage(IDC_DENY_DYNAMIC_RADIO, BM_SETCHECK, BST_UNCHECKED, 0);
    SendDlgItemMessage(IDC_ALLOW_DYNAMIC_RADIO, BM_SETCHECK, BST_UNCHECKED, 0);
    SendDlgItemMessage(IDC_SECURE_DYNAMIC_RADIO, BM_SETCHECK, BST_CHECKED, 0);
  }
}

void CDNSZoneWiz_DynamicPropertyPage::GetUIState()
{
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();

  UINT nDynamicUpdate = 0;
  if (SendDlgItemMessage(IDC_DENY_DYNAMIC_RADIO, BM_GETCHECK, 0, 0) == BST_CHECKED)
  {
    nDynamicUpdate = ZONE_UPDATE_OFF;
  }
  else if (SendDlgItemMessage(IDC_ALLOW_DYNAMIC_RADIO, BM_GETCHECK, 0, 0) == BST_CHECKED)
  {
    nDynamicUpdate = ZONE_UPDATE_UNSECURE;
  }
  else
  {
    nDynamicUpdate = ZONE_UPDATE_SECURE;
  }
  pHolder->m_pZoneInfo->m_nDynamicUpdate = nDynamicUpdate;
}

//////////////////////////////////////////////////////////////////////////
// CDNSZoneWiz_StoragePropertyPage


CDNSZoneWiz_StoragePropertyPage::CDNSZoneWiz_StoragePropertyPage() 
				: CPropertyPageBase(CDNSZoneWiz_StoragePropertyPage::IDD)
{
	InitWiz97(FALSE,IDS_ZWIZ_STORAGE_TITLE,IDS_ZWIZ_STORAGE_SUBTITLE, true);
}

BEGIN_MESSAGE_MAP(CDNSZoneWiz_StoragePropertyPage, CPropertyPageBase)
	ON_EN_CHANGE(IDC_EDIT_NEW_FILE, OnChangeNewFileZoneName)
	ON_EN_CHANGE(IDC_EDIT_IMPORT_FILE, OnChangeImportFileZoneName)
	ON_BN_CLICKED(IDC_RADIO_CREATE_NEW_FILE, OnChangeRadioCreateNewFile)
	ON_BN_CLICKED(IDC_RADIO_IMPORT_FILE, OnChangeRadioImportFile)
END_MESSAGE_MAP()

void CDNSZoneWiz_StoragePropertyPage::OnWizardHelp()
{
  CComPtr<IDisplayHelp> spHelp;
  HRESULT hr = GetHolder()->GetComponentData()->GetConsole()->QueryInterface(IID_IDisplayHelp, (void **)&spHelp);
  if (SUCCEEDED(hr)) 
    spHelp->ShowTopic(L"DNSConcepts.chm::/sag_DNS_CYDNS_05.htm");
}

BOOL CDNSZoneWiz_StoragePropertyPage::OnSetActive() 
{
	GetHolder()->SetWizardButtonsMiddle(FALSE);
	SetUIState();
	return CPropertyPageBase::OnSetActive();
}

LRESULT CDNSZoneWiz_StoragePropertyPage::OnWizardNext()
{
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
	GetUIState();

  if (pHolder->m_pZoneInfo->m_bPrimary)
  {
    return CDNSZoneWiz_DynamicPropertyPage::IDD;
  }

  if (pHolder->m_pZoneInfo->m_bIsStub)
  {
    return CDNSZoneWiz_MastersPropertyPage::IDD;
  }

	if (pHolder->m_bFinishPage)
  {
    return CDNSZoneWiz_FinishPropertyPage::IDD; 
  }

  // This was an else but the sundown build did not like having a control path not return a value
	ASSERT(pHolder->m_nNextToPage != 0);
	return pHolder->m_nNextToPage;
}


LRESULT CDNSZoneWiz_StoragePropertyPage::OnWizardBack() 
{
	GetUIState();
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();

	LRESULT nextPage = -1;
	if (pHolder->m_pZoneInfo->m_bPrimary || pHolder->m_pZoneInfo->m_bIsStub)
	{
		if (pHolder->m_pZoneInfo->m_bForward)
			nextPage = (LRESULT)CDNSZoneWiz_FwdZoneNamePropertyPage::IDD;
		else
			nextPage = (LRESULT)CDNSZoneWiz_RevZoneNamePropertyPage::IDD;
	}
	else
	{
		nextPage = (LRESULT)CDNSZoneWiz_MastersPropertyPage::IDD;
	}
	return nextPage;
}


BOOL CDNSZoneWiz_StoragePropertyPage::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();

  SendDlgItemMessage(IDC_EDIT_NEW_FILE, EM_SETLIMITTEXT, (WPARAM)_MAX_FNAME, 0);
  SendDlgItemMessage(IDC_EDIT_IMPORT_FILE, EM_SETLIMITTEXT, (WPARAM)_MAX_FNAME, 0);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CDNSZoneWiz_StoragePropertyPage::OnKillActive() 
{
	// TODO
	return CPropertyPage::OnKillActive();
}

void CDNSZoneWiz_StoragePropertyPage::SetUIState()
{
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
	ASSERT(pHolder->m_pZoneInfo->m_storageType != CDNSCreateZoneInfo::useADS);

	CButton* pNewFileButton = (CButton*)GetDlgItem(IDC_RADIO_CREATE_NEW_FILE);
	CButton* pImportFileButton = (CButton*)GetDlgItem(IDC_RADIO_IMPORT_FILE);

	CEdit* pNewFileEdit = (CEdit*)GetDlgItem(IDC_EDIT_NEW_FILE);
	CEdit* pImportFileEdit = (CEdit*)GetDlgItem(IDC_EDIT_IMPORT_FILE);

	pNewFileEdit->SetWindowText(_T(""));
	pImportFileEdit->SetWindowText(_T(""));

	if (pHolder->m_pZoneInfo->m_bPrimary)
	{
		// all options are avalable, need to 
		pNewFileButton->EnableWindow(TRUE);
		pNewFileButton->SetCheck(pHolder->m_pZoneInfo->m_storageType == CDNSCreateZoneInfo::newFile);
		pNewFileEdit->EnableWindow(pHolder->m_pZoneInfo->m_storageType == CDNSCreateZoneInfo::newFile);

		pImportFileButton->EnableWindow(TRUE);
		pImportFileButton->SetCheck(pHolder->m_pZoneInfo->m_storageType == CDNSCreateZoneInfo::importFile);
		pImportFileEdit->EnableWindow(pHolder->m_pZoneInfo->m_storageType == CDNSCreateZoneInfo::importFile);

		if (pHolder->m_pZoneInfo->m_storageType == CDNSCreateZoneInfo::newFile)
		{
			m_nCurrRadio = IDC_RADIO_CREATE_NEW_FILE;
			pNewFileEdit->SetWindowText(pHolder->m_pZoneInfo->m_szZoneStorage);
		}
		else if (pHolder->m_pZoneInfo->m_storageType == CDNSCreateZoneInfo::importFile)
		{
			m_nCurrRadio = IDC_RADIO_IMPORT_FILE;
			pImportFileEdit->SetWindowText(pHolder->m_pZoneInfo->m_szZoneStorage);
		}
	}
	else
	{
		// only new file available
		pNewFileButton->EnableWindow(TRUE);
		pNewFileButton->SetCheck(TRUE);
		pNewFileEdit->SetWindowText(pHolder->m_pZoneInfo->m_szZoneStorage);
		pNewFileEdit->EnableWindow(TRUE);

		pImportFileButton->EnableWindow(FALSE);
		pImportFileButton->SetCheck(FALSE);
		pImportFileEdit->EnableWindow(FALSE);

		m_nCurrRadio = IDC_RADIO_CREATE_NEW_FILE;
	}
}


BOOL CDNSZoneWiz_StoragePropertyPage::ValidateEditBoxString(UINT nID)
{
	CEdit* pEdit = (CEdit*)GetDlgItem(nID);
	ASSERT(pEdit != NULL);
	CString sz;
	pEdit->GetWindowText(sz);
	sz.TrimLeft();
	sz.TrimRight();
	return !sz.IsEmpty();
}


void CDNSZoneWiz_StoragePropertyPage::OnChangeNewFileZoneName()
{
	GetHolder()->SetWizardButtonsMiddle(ValidateEditBoxString(IDC_EDIT_NEW_FILE));	
}

void CDNSZoneWiz_StoragePropertyPage::OnChangeImportFileZoneName()
{
	GetHolder()->SetWizardButtonsMiddle(ValidateEditBoxString(IDC_EDIT_IMPORT_FILE));	
}


void CDNSZoneWiz_StoragePropertyPage::SyncRadioButtons(UINT nID)
{
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
	ASSERT(pHolder->m_pZoneInfo->m_storageType != CDNSCreateZoneInfo::useADS);
	
	CButton* pNewFileButton = (CButton*)GetDlgItem(IDC_RADIO_CREATE_NEW_FILE);
	CButton* pImportFileButton = (CButton*)GetDlgItem(IDC_RADIO_IMPORT_FILE);
	
	CEdit* pNewFileEdit = (CEdit*)GetDlgItem(IDC_EDIT_NEW_FILE);
	CEdit* pImportFileEdit = (CEdit*)GetDlgItem(IDC_EDIT_IMPORT_FILE);

	if (m_nCurrRadio == IDC_RADIO_CREATE_NEW_FILE)
	{
		pNewFileEdit->GetWindowText(pHolder->m_pZoneInfo->m_szZoneStorage);
	}
	else if(m_nCurrRadio == IDC_RADIO_IMPORT_FILE)
	{	
		pImportFileEdit->GetWindowText(pHolder->m_pZoneInfo->m_szZoneStorage);
	}

	switch (nID)
	{
	case IDC_RADIO_CREATE_NEW_FILE:
		{
			pImportFileEdit->SetWindowText(_T(""));
			pNewFileEdit->SetWindowText(pHolder->m_pZoneInfo->m_szZoneStorage);

			pNewFileEdit->EnableWindow(TRUE);
			pImportFileEdit->EnableWindow(FALSE);

			pImportFileButton->SetCheck(FALSE);
		}
		break;
	case IDC_RADIO_IMPORT_FILE:
		{
			pNewFileEdit->SetWindowText(_T(""));
			pImportFileEdit->SetWindowText(pHolder->m_pZoneInfo->m_szZoneStorage);

			pNewFileEdit->EnableWindow(FALSE);
			pImportFileEdit->EnableWindow(TRUE);

			pNewFileButton->SetCheck(FALSE);
		}
		break;
	}
	m_nCurrRadio = nID;
}


void CDNSZoneWiz_StoragePropertyPage::OnChangeRadioCreateNewFile()
{
	SyncRadioButtons(IDC_RADIO_CREATE_NEW_FILE);	
}

void CDNSZoneWiz_StoragePropertyPage::OnChangeRadioImportFile()
{
	SyncRadioButtons(IDC_RADIO_IMPORT_FILE);
}

void CDNSZoneWiz_StoragePropertyPage::GetUIState()
{
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
	ASSERT(pHolder->m_pZoneInfo->m_storageType != CDNSCreateZoneInfo::useADS);

	CButton* pNewFileButton = (CButton*)GetDlgItem(IDC_RADIO_CREATE_NEW_FILE);
	CButton* pImportFileButton = (CButton*)GetDlgItem(IDC_RADIO_IMPORT_FILE);

	CEdit* pNewFileEdit = (CEdit*)GetDlgItem(IDC_EDIT_NEW_FILE);
	CEdit* pImportFileEdit = (CEdit*)GetDlgItem(IDC_EDIT_IMPORT_FILE);

	if (pHolder->m_pZoneInfo->m_bPrimary)
	{
		// find the radio selection
		if (pNewFileButton->GetCheck())
		{
			pHolder->m_pZoneInfo->m_storageType = CDNSCreateZoneInfo::newFile;
			pNewFileEdit->GetWindowText(pHolder->m_pZoneInfo->m_szZoneStorage);
		}
		else if (pImportFileButton->GetCheck())
		{
			pHolder->m_pZoneInfo->m_storageType = CDNSCreateZoneInfo::importFile;
			pImportFileEdit->GetWindowText(pHolder->m_pZoneInfo->m_szZoneStorage);
		}
	}
	else
	{
		pNewFileEdit->GetWindowText(pHolder->m_pZoneInfo->m_szZoneStorage);
	}

}

#ifdef USE_NDNC
//////////////////////////////////////////////////////////////////////////
// CDNSZoneWiz_ADReplicationPropertyPage


CDNSZoneWiz_ADReplicationPropertyPage::CDNSZoneWiz_ADReplicationPropertyPage() 
				: CPropertyPageBase(CDNSZoneWiz_ADReplicationPropertyPage::IDD)
{
	InitWiz97(FALSE,IDS_ZWIZ_ADREPLICATION_TITLE,IDS_ZWIZ_ADREPLICATION_SUBTITLE, true);
}

BEGIN_MESSAGE_MAP(CDNSZoneWiz_ADReplicationPropertyPage, CPropertyPageBase)
  ON_BN_CLICKED(IDC_FOREST_RADIO, OnRadioChange)
  ON_BN_CLICKED(IDC_DOMAIN_RADIO, OnRadioChange)
  ON_BN_CLICKED(IDC_DOMAIN_DC_RADIO, OnRadioChange)
  ON_BN_CLICKED(IDC_CUSTOM_RADIO, OnRadioChange)
  ON_CBN_EDITCHANGE(IDC_CUSTOM_COMBO, OnRadioChange)
  ON_CBN_SELCHANGE(IDC_CUSTOM_COMBO, OnCustomComboSelChange)
END_MESSAGE_MAP()

void CDNSZoneWiz_ADReplicationPropertyPage::OnWizardHelp()
{
  CComPtr<IDisplayHelp> spHelp;
  HRESULT hr = GetHolder()->GetComponentData()->GetConsole()->QueryInterface(IID_IDisplayHelp, (void **)&spHelp);
  if (SUCCEEDED(hr)) 
    spHelp->ShowTopic(L"DNSConcepts.chm::/sag_DNS_NZWIZ_05.htm");
}

BOOL CDNSZoneWiz_ADReplicationPropertyPage::OnSetActive() 
{
	GetHolder()->SetWizardButtonsMiddle(TRUE);
	SetUIState();
	return CPropertyPageBase::OnSetActive();
}

LRESULT CDNSZoneWiz_ADReplicationPropertyPage::OnWizardNext()
{
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
	GetUIState();

	if (pHolder->m_bKnowZoneLookupType && !pHolder->m_bKnowZoneLookupTypeEx)
	{
		if (pHolder->m_pZoneInfo->m_bForward)
			return CDNSZoneWiz_FwdZoneNamePropertyPage::IDD;
		else
			return CDNSZoneWiz_RevZoneNamePropertyPage::IDD;
	}
  return CDNSZoneWiz_ZoneLookupPropertyPage::IDD;
}


LRESULT CDNSZoneWiz_ADReplicationPropertyPage::OnWizardBack() 
{
	GetUIState();
  return CDNSZoneWiz_ZoneTypePropertyPage::IDD;
}


BOOL CDNSZoneWiz_ADReplicationPropertyPage::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();

	USES_CONVERSION;

  CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
  CDNSServerNode* pServerNode = pHolder->GetServerNode();

  //
  // Set the replication scope default dependent on domain version
  //
  if (pServerNode->GetDomainVersion() > DS_BEHAVIOR_WIN2000)
  {
     pHolder->GetZoneInfoPtr()->m_replType = domain;
  }
  else
  {
     pHolder->GetZoneInfoPtr()->m_replType = w2k;
  }

  //
  // Get the forest and domain names and format them into the UI
  //

  PCWSTR pszDomainName = UTF8_TO_W(pServerNode->GetDomainName());
  PCWSTR pszForestName = UTF8_TO_W(pServerNode->GetForestName());

  ASSERT(pszDomainName);
  ASSERT(pszForestName);

  CString szWin2KReplText;
  szWin2KReplText.Format(IDS_ZWIZ_AD_REPL_FORMAT, pszDomainName);
  SetDlgItemText(IDC_DOMAIN_DC_RADIO, szWin2KReplText);

  CString szDNSDomainText;
  szDNSDomainText.Format(IDS_ZWIZ_AD_DOMAIN_FORMAT, pszDomainName);
  SetDlgItemText(IDC_DOMAIN_RADIO, szDNSDomainText);

  CString szDNSForestText;
  szDNSForestText.Format(IDS_ZWIZ_AD_FOREST_FORMAT, pszForestName);
  SetDlgItemText(IDC_FOREST_RADIO, szDNSForestText);

  //
  // Enumerate the NDNCs available for storage
  //
  PDNS_RPC_DP_LIST pDirectoryPartitions = NULL;
  DWORD dwErr = ::DnssrvEnumDirectoryPartitions(pServerNode->GetRPCName(),
                                                DNS_DP_ENLISTED,
                                                &pDirectoryPartitions);

  //
  // Don't show an error if we are not able to get the available directory partitions
  // We can still continue on and the user can type in the directory partition they need
  //
  if (dwErr == 0 && pDirectoryPartitions)
  {
    for (DWORD dwIdx = 0; dwIdx < pDirectoryPartitions->dwDpCount; dwIdx++)
    {
      PDNS_RPC_DP_INFO pDirectoryPartition = 0;
      dwErr = ::DnssrvDirectoryPartitionInfo(pServerNode->GetRPCName(),
                                             pDirectoryPartitions->DpArray[dwIdx]->pszDpFqdn,
                                             &pDirectoryPartition);
      if (dwErr == 0 && pDirectoryPartition)
      {
        //
        // Only add the partition if it is not one of the autocreated ones
        // and the DNS server is enlisted in the partition
        //
        if (!(pDirectoryPartition->dwFlags & DNS_DP_AUTOCREATED) &&
            (pDirectoryPartition->dwFlags & DNS_DP_ENLISTED))
        {
          SendDlgItemMessage(IDC_CUSTOM_COMBO, 
                             CB_ADDSTRING, 
                             0, 
                             (LPARAM)UTF8_TO_W(pDirectoryPartition->pszDpFqdn));
        }
        ::DnssrvFreeDirectoryPartitionInfo(pDirectoryPartition);
      }
    }
    ::DnssrvFreeDirectoryPartitionList(pDirectoryPartitions);

    // Select the first item in the combo list.
    // NTRAID#NTBUG9-475091-2001/10/17-sburns
    
    SendDlgItemMessage(IDC_CUSTOM_COMBO, CB_SETCURSEL, 0, 0);
  }
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CDNSZoneWiz_ADReplicationPropertyPage::OnKillActive() 
{
	// TODO
	return CPropertyPage::OnKillActive();
}

void CDNSZoneWiz_ADReplicationPropertyPage::SetUIState()
{
  SyncRadioButtons();
}

void CDNSZoneWiz_ADReplicationPropertyPage::OnRadioChange()
{
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();

  if (SendDlgItemMessage(IDC_FOREST_RADIO, BM_GETCHECK, 0, 0) == BST_CHECKED)
  {
    pHolder->m_pZoneInfo->m_replType = forest;
  }
  else if (SendDlgItemMessage(IDC_DOMAIN_RADIO, BM_GETCHECK, 0, 0) == BST_CHECKED)
  {
    pHolder->m_pZoneInfo->m_replType = domain;
  }
  else if (SendDlgItemMessage(IDC_DOMAIN_DC_RADIO, BM_GETCHECK, 0, 0) == BST_CHECKED)
  {
    pHolder->m_pZoneInfo->m_replType = w2k;
  }
  else if (SendDlgItemMessage(IDC_CUSTOM_RADIO, BM_GETCHECK, 0, 0) == BST_CHECKED)
  {
    pHolder->m_pZoneInfo->m_replType = custom;
  }
  else
  {
    // at least one radio button must be selected
    ASSERT(FALSE);
  }
  SyncRadioButtons();
}

void CDNSZoneWiz_ADReplicationPropertyPage::SyncRadioButtons()
{
  CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();

  CComboBox* pCustomCombo = reinterpret_cast<CComboBox*>(GetDlgItem(IDC_CUSTOM_COMBO));
  ASSERT(pCustomCombo);

  bool bCustomAvailable = pCustomCombo->GetCount() > 0;

  switch (pHolder->m_pZoneInfo->m_replType)
  {
  case forest:
    SendDlgItemMessage(IDC_FOREST_RADIO, BM_SETCHECK, (WPARAM)BST_CHECKED, 0);
    SendDlgItemMessage(IDC_DOMAIN_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
    SendDlgItemMessage(IDC_DOMAIN_DC_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
    SendDlgItemMessage(IDC_CUSTOM_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);

    GetDlgItem(IDC_CUSTOM_RADIO)->EnableWindow(bCustomAvailable);
    GetDlgItem(IDC_CUSTOM_COMBO)->EnableWindow(FALSE);
    //GetDlgItem(IDC_CUSTOM_STATIC)->EnableWindow(FALSE);
    break;

  case domain:
    SendDlgItemMessage(IDC_DOMAIN_RADIO, BM_SETCHECK, (WPARAM)BST_CHECKED, 0);
    SendDlgItemMessage(IDC_FOREST_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
    SendDlgItemMessage(IDC_DOMAIN_DC_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
    SendDlgItemMessage(IDC_CUSTOM_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);

    GetDlgItem(IDC_CUSTOM_RADIO)->EnableWindow(bCustomAvailable);
    GetDlgItem(IDC_CUSTOM_COMBO)->EnableWindow(FALSE);
    //GetDlgItem(IDC_CUSTOM_STATIC)->EnableWindow(FALSE);
    break;

  case w2k:
    SendDlgItemMessage(IDC_DOMAIN_DC_RADIO, BM_SETCHECK, (WPARAM)BST_CHECKED, 0);
    SendDlgItemMessage(IDC_FOREST_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
    SendDlgItemMessage(IDC_DOMAIN_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
    SendDlgItemMessage(IDC_CUSTOM_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);

    GetDlgItem(IDC_CUSTOM_RADIO)->EnableWindow(bCustomAvailable);
    GetDlgItem(IDC_CUSTOM_COMBO)->EnableWindow(FALSE);
    //GetDlgItem(IDC_CUSTOM_STATIC)->EnableWindow(FALSE);
    break;

  case custom:
    SendDlgItemMessage(IDC_CUSTOM_RADIO, BM_SETCHECK, (WPARAM)BST_CHECKED, 0);
    SendDlgItemMessage(IDC_FOREST_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
    SendDlgItemMessage(IDC_DOMAIN_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
    SendDlgItemMessage(IDC_DOMAIN_DC_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
 
    GetDlgItem(IDC_CUSTOM_RADIO)->EnableWindow(TRUE);
    GetDlgItem(IDC_CUSTOM_COMBO)->EnableWindow(TRUE);
    //GetDlgItem(IDC_CUSTOM_STATIC)->EnableWindow(TRUE);
   break;

  default:
    SendDlgItemMessage(IDC_DOMAIN_RADIO, BM_SETCHECK, (WPARAM)BST_CHECKED, 0);
    SendDlgItemMessage(IDC_FOREST_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
    SendDlgItemMessage(IDC_DOMAIN_DC_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
    SendDlgItemMessage(IDC_CUSTOM_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);

    GetDlgItem(IDC_CUSTOM_RADIO)->EnableWindow(bCustomAvailable);
    GetDlgItem(IDC_CUSTOM_COMBO)->EnableWindow(FALSE);
    //GetDlgItem(IDC_CUSTOM_STATIC)->EnableWindow(FALSE);
    break;
  }
   
  if (BST_CHECKED == SendDlgItemMessage(IDC_CUSTOM_RADIO, BM_GETCHECK, 0, 0))
  {
    CString szTemp;
    GetDlgItemText(IDC_CUSTOM_COMBO, szTemp);
    pHolder->SetWizardButtonsMiddle(!szTemp.IsEmpty());
  }
  else
  {
    pHolder->SetWizardButtonsMiddle(TRUE);
  }
}

void CDNSZoneWiz_ADReplicationPropertyPage::OnCustomComboSelChange()
{
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();

  LRESULT iSel = SendDlgItemMessage(IDC_CUSTOM_COMBO, CB_GETCURSEL, 0, 0);
  if (CB_ERR != iSel)
  {
    CString szTemp;
    CComboBox* pComboBox = reinterpret_cast<CComboBox*>(GetDlgItem(IDC_CUSTOM_COMBO));
    ASSERT(pComboBox);

    pComboBox->GetLBText(static_cast<int>(iSel), szTemp);
    pHolder->SetWizardButtonsMiddle(!szTemp.IsEmpty());
  }
  else
  {
    pHolder->SetWizardButtonsMiddle(FALSE);
  }
}

void CDNSZoneWiz_ADReplicationPropertyPage::GetUIState()
{
  CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();

  if (SendDlgItemMessage(IDC_FOREST_RADIO, BM_GETCHECK, 0, 0) == BST_CHECKED)
  {
    pHolder->m_pZoneInfo->m_replType = forest;
  }
  else if (SendDlgItemMessage(IDC_DOMAIN_RADIO, BM_GETCHECK, 0, 0) == BST_CHECKED)
  {
    pHolder->m_pZoneInfo->m_replType = domain;
  }
  else if (SendDlgItemMessage(IDC_DOMAIN_DC_RADIO, BM_GETCHECK, 0, 0) == BST_CHECKED)
  {
    pHolder->m_pZoneInfo->m_replType = w2k;
  }
  else if (SendDlgItemMessage(IDC_CUSTOM_RADIO, BM_GETCHECK, 0, 0) == BST_CHECKED)
  {
    pHolder->m_pZoneInfo->m_replType = custom;
  }
  else
  {
    // at least one radio button must be checked
    ASSERT(FALSE);
  }
  SyncRadioButtons();

  CComboBox* pCustomCombo = reinterpret_cast<CComboBox*>(GetDlgItem(IDC_CUSTOM_COMBO));
  ASSERT(pCustomCombo);

  int iSel = pCustomCombo->GetCurSel();
  if (iSel != CB_ERR)
  {
    pCustomCombo->GetLBText(iSel, pHolder->m_pZoneInfo->m_szCustomReplName);
  }
  else
  {
    pCustomCombo->GetWindowText(pHolder->m_pZoneInfo->m_szCustomReplName);
  }
}
#endif // USE_NDNC

//////////////////////////////////////////////////////////////////////////
// CDNSZoneWiz_FinishPropertyPage

CDNSZoneWiz_FinishPropertyPage::CDNSZoneWiz_FinishPropertyPage() 
				: CPropertyPageBase(CDNSZoneWiz_FinishPropertyPage::IDD),
				m_typeText(N_ZONEWIZ_TYPES)
{
	InitWiz97(TRUE,0,0, true);
}


BOOL CDNSZoneWiz_FinishPropertyPage::OnInitDialog()
{
  CPropertyPageBase::OnInitDialog();

  SetBigBoldFont(m_hWnd, IDC_STATIC_COMPLETE);

	VERIFY(m_typeText.Init(this,IDC_TYPE_STATIC));
	VERIFY(m_lookupText.Init(this,IDC_LOOKUP_STATIC));
	return TRUE;
}

void CDNSZoneWiz_FinishPropertyPage::OnWizardHelp()
{
  CComPtr<IDisplayHelp> spHelp;
  HRESULT hr = GetHolder()->GetComponentData()->GetConsole()->QueryInterface(IID_IDisplayHelp, (void **)&spHelp);
  if (SUCCEEDED(hr)) 
    spHelp->ShowTopic(L"DNSConcepts.chm::/sag_DNS_NZWIZ_06.htm");
}

LRESULT CDNSZoneWiz_FinishPropertyPage::OnWizardBack()
{
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
	if (pHolder->m_pZoneInfo->m_bPrimary)
	{
		return (LRESULT)CDNSZoneWiz_DynamicPropertyPage::IDD;
	}

  // This was an else but the sundown build did not like having a control path not return a value
	return (LRESULT)CDNSZoneWiz_MastersPropertyPage::IDD; // secondary
}

BOOL CDNSZoneWiz_FinishPropertyPage::OnWizardFinish()
{
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
	return pHolder->CreateZone();
}

BOOL CDNSZoneWiz_FinishPropertyPage::OnSetActive() 
{
	GetHolder()->SetWizardButtonsLast(TRUE);

	DisplaySummaryInfo();
	
	return CPropertyPageBase::OnSetActive();
}

void CDNSZoneWiz_FinishPropertyPage::DisplaySummaryInfo()
{
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();

	GetDlgItem(IDC_NAME_STATIC)->SetWindowText(pHolder->m_pZoneInfo->m_szZoneName);
	BOOL bUseADS = pHolder->m_pZoneInfo->m_storageType == CDNSCreateZoneInfo::useADS;
	
	int nType;
	if (pHolder->m_pZoneInfo->m_bPrimary)
  {
		nType = bUseADS ? N_ZONEWIZ_TYPES_DS_PRIMARY : N_ZONEWIZ_TYPES_PRIMARY;
  }
	else
  {
		if (pHolder->m_pZoneInfo->m_bIsStub)
    {
      nType = N_ZONEWIZ_TYPES_STUB;
    }
    else
    {
      nType = N_ZONEWIZ_TYPES_SECONDARY;
    }
  }
	m_typeText.SetStateX(nType);
	
	m_lookupText.SetToggleState(pHolder->m_pZoneInfo->m_bForward);
	
	GetDlgItem(IDC_STORAGE_TYPE_STATIC)->ShowWindow(!bUseADS);

	CStatic* pStorageNameStatic = (CStatic*)GetDlgItem(IDC_STORAGE_NAME_STATIC);
	pStorageNameStatic->ShowWindow(!bUseADS);
	LPCTSTR lpszText = bUseADS ? NULL : (LPCTSTR)(pHolder->m_pZoneInfo->m_szZoneStorage);
	pStorageNameStatic->SetWindowText(lpszText);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\zonewiz.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       zonewiz.h
//
//--------------------------------------------------------------------------



#ifndef _ZONEWIZ_H
#define _ZONEWIZ_H

#include "ipeditor.h"

///////////////////////////////////////////////////////////////////////////////
// FORWARD DECLARATIONS

class CDNSServerNode;
class CDNSZoneNode;

class CDNSZoneWiz_StartPropertyPage;
class CDNSZoneWiz_ZoneTypePropertyPage;
class CDNSZoneWiz_ZoneLookupPropertyPage;
class CDNSZoneWiz_ZoneNamePropertyPageBase;
class CDNSZoneWiz_FwdZoneNamePropertyPage;
class CDNSZoneWiz_DynamicPropertyPage;
class CDNSZoneWiz_RevZoneNamePropertyPage;
class CDNSZoneWiz_MastersPropertyPage;
class CDNSZoneWiz_StoragePropertyPage;
#ifdef USE_NDNC
class CDNSZoneWiz_ADReplicationPropertyPage;
#endif // USE_NDNC
class CDNSZoneWiz_FinishPropertyPage;


///////////////////////////////////////////////////////////////////////////////
// CDNSCreateZoneInfo
// information gathered by the Zone Wizard

class CDNSCreateZoneInfo
{
public:
	CDNSCreateZoneInfo();
	~CDNSCreateZoneInfo();

	void ResetIpArr();
	void SetIpArr(PIP_ADDRESS ipMastersArray, DWORD nMastersCount);
	const CDNSCreateZoneInfo& operator=(const CDNSCreateZoneInfo& info);

	typedef enum { newFile = 0 , importFile, useADS} storageType;

	BOOL m_bPrimary;
	BOOL m_bForward;
  BOOL m_bIsStub;
	CString m_szZoneName;
	CString m_szZoneStorage;
	storageType m_storageType;
#ifdef USE_NDNC
  ReplicationType m_replType;
  CString m_szCustomReplName;
#endif // USE_NDNC

	PIP_ADDRESS m_ipMastersArray;
	DWORD m_nMastersCount;
  BOOL  m_bLocalListOfMasters;
  UINT m_nDynamicUpdate;

	// UI session specific info (not used for actual creation)
	BOOL m_bWasForward;
};


///////////////////////////////////////////////////////////////////////////////
// CDNSZoneWizardHolder
// page holder to contain DNS zone wizard property pages

class CDNSZoneWizardHolder : public CPropertyPageHolderBase
{
public:
	CDNSZoneWizardHolder(CComponentDataObject* pComponentData);

	// simple cast helpers
	CDNSServerNode* GetServerNode() { return (CDNSServerNode*)GetContainerNode();}
	void SetServerNode(CDNSServerNode* pServerNode) { SetContainerNode((CDNSServerNode*) pServerNode);}

	void SetZoneNode(CDNSZoneNode* pZoneNode) { SetTreeNode((CTreeNode*)pZoneNode); }
	CDNSZoneNode* GetZoneNode() { return (CDNSZoneNode*)GetTreeNode();}

	void Initialize(CDNSServerNode* pServerNode, // might be null,
						 BOOL bFinishPage = TRUE);

	void PreSetZoneLookupType(BOOL bForward);
  void PreSetZoneLookupTypeEx(BOOL bForward, UINT nZoneType, BOOL bADIntegrated);
	void SetContextPages(UINT nNextToPage, UINT nBackToPage);
	UINT GetFirstEntryPointPageID();
	UINT GetLastEntryPointPageID();

	CDNSCreateZoneInfo* GetZoneInfoPtr() { return m_pZoneInfo;}
	void SetZoneInfoPtr(CDNSCreateZoneInfo* pZoneInfo)
	{
		m_pZoneInfo = (pZoneInfo != NULL) ? pZoneInfo : NULL;
	}

	static DNS_STATUS CDNSZoneWizardHolder::CreateZoneHelper(CDNSServerNode* pServerNode, 
													CDNSCreateZoneInfo* pZoneInfo, 
													CComponentDataObject* pComponentData);

private:
	// data for zone creation
	CDNSCreateZoneInfo m_zoneInfo;
	CDNSCreateZoneInfo* m_pZoneInfo;

	BOOL CreateZone();

	// cached pointers to property pages
	CDNSZoneWiz_StartPropertyPage*				  m_pStartPage;
	CDNSZoneWiz_ZoneTypePropertyPage*			  m_pReplicationTypePage;
	CDNSZoneWiz_ZoneLookupPropertyPage*			m_pZoneLookupPage;
	CDNSZoneWiz_FwdZoneNamePropertyPage*		m_pFwdZoneNamePage;
  CDNSZoneWiz_DynamicPropertyPage*        m_pDynamicPage;
	CDNSZoneWiz_RevZoneNamePropertyPage*		m_pRevZoneNamePage;
	CDNSZoneWiz_MastersPropertyPage*			  m_pMastersPage;
	CDNSZoneWiz_StoragePropertyPage*			  m_pStoragePage;	
#ifdef USE_NDNC
  CDNSZoneWiz_ADReplicationPropertyPage*  m_pADReplPage;
#endif // USE_NDNC
	CDNSZoneWiz_FinishPropertyPage*				  m_pFinishPage;

	BOOL m_bKnowZoneLookupType;			// already know Fwd/Rev type
  BOOL m_bKnowZoneLookupTypeEx;   // already know Fwd/Rev, AD-integrated, and zone type
	BOOL m_bFinishPage;
	UINT m_nNextToPage;
	UINT m_nBackToPage;

	// helper functions


	// to access data in the holder
	friend class CDNSZoneWiz_StartPropertyPage;
	friend class CDNSZoneWiz_ZoneTypePropertyPage;
	friend class CDNSZoneWiz_ZoneLookupPropertyPage;
	friend class CDNSZoneWiz_ZoneNamePropertyPageBase;
	friend class CDNSZoneWiz_FwdZoneNamePropertyPage;
  friend class CDNSZoneWiz_DynamicPropertyPage;
	friend class CDNSZoneWiz_RevZoneNamePropertyPage;
	friend class CDNSZoneWiz_MastersPropertyPage;
	friend class CDNSZoneWiz_StoragePropertyPage;
#ifdef USE_NDNC
  friend class CDNSZoneWiz_ADReplicationPropertyPage;
#endif USE_NDNC
	friend class CDNSZoneWiz_FinishPropertyPage;

};

//////////////////////////////////////////////////////////////////////////
// CDNSZoneWiz_StartPropertyPage

class CDNSZoneWiz_StartPropertyPage : public CPropertyPageBase
{
// Construction
public:
	CDNSZoneWiz_StartPropertyPage();

// Overrides
public:
	virtual BOOL OnSetActive();

protected:
	virtual BOOL OnInitDialog();
   virtual void OnWizardHelp();

public:
// Dialog Data
	enum { IDD = IDD_ZWIZ_START };

};


//////////////////////////////////////////////////////////////////////////
// CDNSZoneWiz_ZoneTypePropertyPage

class CDNSZoneWiz_ZoneTypePropertyPage : public CPropertyPageBase
{

// Construction
public:
	CDNSZoneWiz_ZoneTypePropertyPage();

// Dialog Data
	enum { IDD = IDD_ZWIZ_ZONE_TYPE };

// Overrides
public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnKillActive();
   virtual void OnWizardHelp();

protected:

// Implementation
protected:
	// Generated message map functions
	virtual BOOL OnInitDialog();
  afx_msg void OnRadioChange();

	DECLARE_MESSAGE_MAP()

private:
	void SetUIState();
	void GetUIState();
};

//////////////////////////////////////////////////////////////////////////
// CDNSZoneWiz_ZoneLookupPropertyPage

class CDNSZoneWiz_ZoneLookupPropertyPage : public CPropertyPageBase
{
// Construction
public:
	CDNSZoneWiz_ZoneLookupPropertyPage();

// Dialog Data
	enum { IDD = IDD_ZWIZ_ZONE_LOOKUP };

// Overrides
public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
   virtual void OnWizardHelp();


// Implementation
protected:
	// Generated message map functions
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeEditZoneName();

private:
};


//////////////////////////////////////////////////////////////////////////
// CDNSZoneWiz_ZoneNamePropertyPageBase

class CDNSZoneWiz_ZoneNamePropertyPageBase : public CPropertyPageBase
{
// Construction
public:
	CDNSZoneWiz_ZoneNamePropertyPageBase(UINT nIDD);

// Overrides
public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
   virtual void OnWizardHelp();

protected:

// Implementation
protected:
	// Generated message map functions
	afx_msg void OnBrowse();
	afx_msg void OnChangeEditZoneName();

	DECLARE_MESSAGE_MAP()
protected:
	CButton* GetBrowseButton() { return (CButton*)GetDlgItem(IDC_BROWSE_BUTTON);}
	CEdit* GetZoneNameEdit() { return (CEdit*)GetDlgItem(IDC_EDIT_ZONE_NAME);}
	void SetUIState();
	void GetUIState();
};


//////////////////////////////////////////////////////////////////////////
// CDNSZoneWiz_FwdZoneNamePropertyPage

class CDNSZoneWiz_FwdZoneNamePropertyPage : 
			public CDNSZoneWiz_ZoneNamePropertyPageBase
{
// Construction
public:
	CDNSZoneWiz_FwdZoneNamePropertyPage();

// Dialog Data
	enum { IDD = IDD_ZWIZ_FWD_ZONE_NAME };

    // Override virtual function in base class.
    virtual BOOL OnInitDialog();
};

//////////////////////////////////////////////////////////////////////////
// CDNSZoneWiz_RevZoneNamePropertyPage

class CDNSZoneWiz_RevZoneNamePropertyPage : 
		public CDNSZoneWiz_ZoneNamePropertyPageBase
{
// Construction
public:
	CDNSZoneWiz_RevZoneNamePropertyPage();

// Dialog Data
	enum { IDD = IDD_ZWIZ_REV_ZONE_NAME };

// Overrides
public:
	virtual BOOL OnSetActive();

protected:

// Implementation
protected:
	// Generated message map functions
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeSubnetIPv4Ctrl();
//	afx_msg void OnChangeMaskIPv4Ctrl();
	afx_msg void OnChangeUseIPRadio();
	afx_msg	void OnChangeUseEditRadio();
  afx_msg void OnHelpButton();
  virtual void OnWizardHelp();

	DECLARE_MESSAGE_MAP()
private:

	BOOL m_bUseIP;	// flags to tell wich entry method we use

	CButton* GetUseIPRadio() { return (CButton*)GetDlgItem(IDC_USE_IP_RADIO);}
	CButton* GetUseEditRadio() { return (CButton*)GetDlgItem(IDC_USE_EDIT_RADIO);}
	CDNSIPv4Control* GetSubnetIPv4Ctrl() 
			{ return (CDNSIPv4Control*)GetDlgItem(IDC_SUBNET_IPEDIT);}
/*	CDNSIPv4Control* GetMaskIPv4Ctrl() 
			{ return (CDNSIPv4Control*)GetDlgItem(IDC_MASK_IPEDIT);}
*/
	void SyncRadioButtons(BOOL bPrevUseIP);
	void ResetIPEditAndNameValue();
	BOOL BuildZoneName(DWORD* dwSubnetArr /*, DWORD* dwMaskArr*/);
};

//////////////////////////////////////////////////////////////////////////
// CDNSZoneWiz_MastersPropertyPage

class CZoneWiz_MastersIPEditor : public CIPEditor
{
public:
	virtual void OnChangeData();
};

class CDNSZoneWiz_MastersPropertyPage : public CPropertyPageBase
{
// Construction
public:
	CDNSZoneWiz_MastersPropertyPage();

// Dialog Data
	enum { IDD = IDD_ZWIZ_MASTERS };

// Overrides
public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
   virtual void OnWizardHelp();

protected:

// Implementation
protected:
	// Generated message map functions
	virtual BOOL OnInitDialog();
	afx_msg void OnBrowse();

	DECLARE_MESSAGE_MAP()
private:
	CZoneWiz_MastersIPEditor m_editor;

	void SetValidIPArray(BOOL b);

	BOOL m_bValidIPArray;

	void SetUIState();
	void GetUIState();

	friend class CZoneWiz_MastersIPEditor;
};

//////////////////////////////////////////////////////////////////////////
// CDNSZoneWiz_DynamicPropertyPage

class CDNSZoneWiz_DynamicPropertyPage : public CPropertyPageBase
{
// Construction
public:
	CDNSZoneWiz_DynamicPropertyPage();
	~CDNSZoneWiz_DynamicPropertyPage()
	{
	}

// Dialog Data
	enum { IDD = IDD_ZWIZ_DYNAMIC_UPDATE };

  // Overrides
public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
   virtual void OnWizardHelp();


// Implementation
protected:
	// Generated message map functions
	virtual BOOL OnInitDialog();

	DECLARE_MESSAGE_MAP()

private:	
  void SetUIState();
	void GetUIState();
};

//////////////////////////////////////////////////////////////////////////
// CDNSZoneWiz_StoragePropertyPage

class CDNSZoneWiz_StoragePropertyPage : public CPropertyPageBase
{
// Construction
public:
	CDNSZoneWiz_StoragePropertyPage();
	~CDNSZoneWiz_StoragePropertyPage()
	{
	}

// Dialog Data
	enum { IDD = IDD_ZWIZ_STORAGE };

// Overrides
public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnKillActive();
   virtual void OnWizardHelp();


protected:

// Implementation
protected:
	// Generated message map functions
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeNewFileZoneName();
	afx_msg void OnChangeImportFileZoneName();
	afx_msg void OnChangeRadioCreateNewFile();
	afx_msg void OnChangeRadioImportFile();

	DECLARE_MESSAGE_MAP()
private:
	UINT m_nCurrRadio;
	BOOL ValidateEditBoxString(UINT nID);
	void SyncRadioButtons(UINT nID);
	void SetUIState();
	void GetUIState();

};

#ifdef USE_NDNC
//////////////////////////////////////////////////////////////////////////
// CDNSZoneWiz_ADReplicationPropertyPage

class CDNSZoneWiz_ADReplicationPropertyPage : public CPropertyPageBase
{
// Construction
public:
	CDNSZoneWiz_ADReplicationPropertyPage();
	~CDNSZoneWiz_ADReplicationPropertyPage()
	{
	}

// Dialog Data
	enum { IDD = IDD_ZWIZ_AD_REPLICATION };

// Overrides
public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnKillActive();
   virtual void OnWizardHelp();


protected:

// Implementation
protected:
	// Generated message map functions
	virtual BOOL OnInitDialog();

  afx_msg void OnRadioChange();
  afx_msg void OnCustomComboSelChange();

	DECLARE_MESSAGE_MAP()
private:
  void SyncRadioButtons();
	void SetUIState();
	void GetUIState();
};
#endif // USE_NDNC

//////////////////////////////////////////////////////////////////////////
// CDNSZoneWiz_FinishPropertyPage

class CDNSZoneWiz_FinishPropertyPage : public CPropertyPageBase
{
// Construction
public:
	CDNSZoneWiz_FinishPropertyPage();

// Dialog Data
	enum { IDD = IDD_ZWIZ_FINISH };

// Overrides
public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnWizardFinish();
   virtual void OnWizardHelp();


protected:
	virtual BOOL OnInitDialog();

private:
	CDNSManageControlTextHelper		m_typeText;	
	CDNSToggleTextControlHelper		m_lookupText;

	void DisplaySummaryInfo();
};

#endif // _ZONEWIZ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\test\pch.cpp ===
// pch.cpp : source file that includes just the standard includes
//	dscrobj.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "pch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\test\main.cpp ===
#include "pch.h"

extern "C" int __cdecl wmain(const UINT argc,const WCHAR* argv[]);


typedef HRESULT (WINAPI * PFNDNSETUP)(LPCWSTR lpszFwdZoneName,
                 LPCWSTR lpszFwdZoneFileName,
                 LPCWSTR lpszRevZoneName, 
                 LPCWSTR lpszRevZoneFileName, 
                 DWORD dwFlags);


HRESULT DnsSetup(LPCWSTR lpszFwdZoneName,
                 LPCWSTR lpszFwdZoneFileName,
                 LPCWSTR lpszRevZoneName, 
                 LPCWSTR lpszRevZoneFileName, 
                 DWORD dwFlags)
{

  HMODULE hLibrary = ::LoadLibrary(L"dnsmgr.dll");
  if (NULL == hLibrary)
  {
    // The library is not present
    wprintf(L"LoadLibrary() failed\n");
    return E_INVALIDARG;
  }

  FARPROC pfFunction = ::GetProcAddress(hLibrary, "DnsSetup" );
  if ( NULL == pfFunction )
  {
    // The library is present but does not have the entry point
    wprintf(L"GetProcAddress() failed\n");
    ::FreeLibrary( hLibrary );
    return E_INVALIDARG;
  }


  wprintf(L"calling function\n");

  HRESULT hr = ((PFNDNSETUP)pfFunction)
           (lpszFwdZoneName ,lpszFwdZoneFileName, lpszRevZoneName, lpszRevZoneFileName, dwFlags);


  wprintf(L"function returned hr = 0x%x\n", hr);

  ::FreeLibrary( hLibrary );

  return hr;
}




int __cdecl wmain(const UINT argc,const WCHAR* argv[])
{
 
  LPCWSTR lpszFwdZoneName = NULL;
  LPCWSTR lpszFwdZoneFileName = NULL;
  LPCWSTR lpszRevZoneName = NULL; 
  LPCWSTR lpszRevZoneFileName = NULL;


  if ((argc != 3) && (argc != 5))
  {
    wprintf(L"usage:\n");
    wprintf(L"dnssetup fdwzonename fwzzonefilename [revzonename revzonefilename]\n");
    return -1;
  }

  lpszFwdZoneName = argv[1];
  lpszFwdZoneFileName = argv[2];

  if (argc == 5)
  {
    LPCWSTR lpszRevZoneName = argv[3]; 
    LPCWSTR lpszRevZoneFileName = argv[4];
  }

  wprintf(L"Starting\n");


  HRESULT hr = DnsSetup(lpszFwdZoneName, lpszFwdZoneFileName, lpszRevZoneName, lpszRevZoneFileName, 0x0);



  wprintf(L"\nDone\n");
  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\domain\dbg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dbg.h
//
//--------------------------------------------------------------------------



/////////////////////////////////////////////////////////////////////
// debug helpers

#if defined(_USE_DSA_TRACE)
  #if defined(TRACE)
    #undef TRACE
    void  DSATrace(LPCWSTR, ...);
    #define TRACE DSATrace
  #endif // defined(TRACE)
#endif // defined(_USE_DSA_TRACE)


#if defined(_USE_DSA_ASSERT)
#undef ASSERT
#undef VERIFY
#undef THIS_FILE
#define THIS_FILE          __FILE__
BOOL DSAAssertFailedLine(LPCSTR lpszFileName, int nLine);
#define ASSERT(f) \
	do \
	{ \
	if (!(f) && DSAAssertFailedLine(THIS_FILE, __LINE__)) \
		::DebugBreak(); \
	} while (0) \

#define VERIFY(f)          ASSERT(f)

#endif // _USE_DSA_ASSERT

#if defined (_USE_DSA_TIMER)

void DSATimer(LPCWSTR, ...);
#define TIMER DSATimer

#else

#define TIMER

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dnsmgr\test\pch.h ===
// pch.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__91968750_1121_11D2_97B7_00A0C9A06D2D__INCLUDED_)
#define AFX_STDAFX_H__91968750_1121_11D2_97B7_00A0C9A06D2D__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers


//////////////////////////////////////////////
// CRT and C++ headers

#pragma warning( disable : 4530) // REVIEW_MARCOC: need to get the -GX flag to work 

#include <stdio.h>
#include <xstring>
#include <list>
#include <vector>
#include <deque>
#include <algorithm>


using namespace std;

//////////////////////////////////////////////
// Windows and ATL headers

#include <windows.h>

#include <setupapi.h> // to read the .INF file
#include <accctrl.h>



//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__91968750_1121_11D2_97B7_00A0C9A06D2D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\domain\cdomain.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       cdomain.cpp
//
//--------------------------------------------------------------------------



#include "stdafx.h"
//#include "afxdlgs.h"
#include <lm.h>
#include "activeds.h"
#include <dnsapi.h>  // for DnsFlushResolverCache()

#include "domobj.h"
#include "Cdomain.h"
#include "DataObj.h"
#include "notify.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define DOMADMIN_LINKED_HELP_FILE L"ADconcepts.chm"
#define DOMADMIN_SNAPIN_HELP_FILE L"domadmin.chm"

int _MessageBox(HWND hWnd,          // handle to owner window
                LPCTSTR lpText,     // pointer to text in message box
                UINT uType);        // style of message box

/////////////////////////////////////////////////////////////////////////////
// macros

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

/////////////////////////////////////////////////////////////////////////////
// constants


// {19B9A3F8-F975-11d1-97AD-00A0C9A06D2D}
static const GUID CLSID_DomainSnapinAbout =
{ 0x19b9a3f8, 0xf975, 0x11d1, { 0x97, 0xad, 0x0, 0xa0, 0xc9, 0xa0, 0x6d, 0x2d } };


const CLSID CLSID_DomainAdmin = { /* ebc53a38-a23f-11d0-b09b-00c04fd8dca6 */
    0xebc53a38,
    0xa23f,
    0x11d0,
    {0xb0, 0x9b, 0x00, 0xc0, 0x4f, 0xd8, 0xdc, 0xa6}
  };

const GUID cDefaultNodeType = { /* 4c06495e-a241-11d0-b09b-00c04fd8dca6 */
    0x4c06495e,
    0xa241,
    0x11d0,
    {0xb0, 0x9b, 0x00, 0xc0, 0x4f, 0xd8, 0xdc, 0xa6}
  };

const wchar_t* cszDefaultNodeType = _T("4c06495e-a241-11d0-b09b-00c04fd8dca6");


// Internal private format
const wchar_t* CCF_DS_DOMAIN_TREE_SNAPIN_INTERNAL = L"DS_DOMAIN_TREE_SNAPIN_INTERNAL";





/////////////////////////////////////////////////////////////////////////////
// global functions

//forward decl
void PrintColumn(
                 PADS_SEARCH_COLUMN pColumn,
                 LPWSTR pszColumnName
                 );

BOOL IsMMCMultiSelectDataObject(IDataObject* pDataObject)
{
    if (pDataObject == NULL)
        return FALSE;

    static UINT s_cf = 0;
    if (s_cf == 0)
    {
        USES_CONVERSION;
        s_cf = RegisterClipboardFormat(W2T(CCF_MMC_MULTISELECT_DATAOBJECT));
    }

    FORMATETC fmt = {(CLIPFORMAT)s_cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    return (pDataObject->QueryGetData(&fmt) == S_OK);
}


#define NEXT_HELP_TABLE_ENTRY(p) ((p)+2)
#define TABLE_ENTRY_CTRL_ID(p) (*p)
#define TABLE_ENTRY_HELP_ID(p) (*(p+1))
#define IS_LAST_TABLE_ENTRY(p) (TABLE_ENTRY_CTRL_ID(p) == 0)


BOOL FindDialogContextTopic(/*IN*/ DWORD* pTable, 
                            /*IN*/ HELPINFO* pHelpInfo,
                            /*OUT*/ ULONG* pnContextTopic)
{
	ASSERT(pHelpInfo != NULL);
  *pnContextTopic = 0;

	// look inside the table
	while (!IS_LAST_TABLE_ENTRY(pTable))
	{
		if (TABLE_ENTRY_CTRL_ID(pTable) == (DWORD)pHelpInfo->iCtrlId) 
    {
			*pnContextTopic = TABLE_ENTRY_HELP_ID(pTable);
      return TRUE;
    }
		pTable = NEXT_HELP_TABLE_ENTRY(pTable); 
	}
	return FALSE;
}


void DialogContextHelp(DWORD* pTable, HELPINFO* pHelpInfo)
{
	ULONG nContextTopic;
  if (FindDialogContextTopic(pTable, pHelpInfo, &nContextTopic))
  {
	  CString szHelpFilePath;
	  LPTSTR lpszBuffer = szHelpFilePath.GetBuffer(2*MAX_PATH+1);
	  UINT nLen = ::GetSystemWindowsDirectory(lpszBuffer, 2*MAX_PATH);
	  if (nLen == 0)
		  return;
     // NOTICE-2002/03/07-ericb - SecurityPush: using wcsncpy now. GetBuffer above null terminates the buffer.
	  wcsncpy(&lpszBuffer[nLen], L"\\HELP\\DOMADMIN.HLP", 2*MAX_PATH - nLen);
	  szHelpFilePath.ReleaseBuffer();
	  ::WinHelp((HWND) pHelpInfo->hItemHandle, 
            szHelpFilePath, HELP_CONTEXTPOPUP, nContextTopic);
  }	 
}


LPCWSTR GetServerNameFromCommandLine()
{
  const WCHAR szOverrideSrvCommandLine[] = L"/Server=";	// Not subject to localization
  const int cchOverrideSrvCommandLine = (sizeof(szOverrideSrvCommandLine)/sizeof(WCHAR)) - 1; 
    
  static CString g_strOverrideServerName;

  // retrieve the command line arguments
  LPCWSTR* lpServiceArgVectors;		// Array of pointers to string
  int cArgs = 0;						// Count of arguments

  lpServiceArgVectors = (LPCWSTR *)CommandLineToArgvW(GetCommandLineW(), OUT &cArgs);
  if (lpServiceArgVectors == NULL)
  {
    return NULL;
  }

  CString str;
  for (int i = 1; i < cArgs; i++)
  {
    ASSERT(lpServiceArgVectors[i] != NULL);
    str = lpServiceArgVectors[i];	// Copy the string
    TRACE (_T("command line arg: %s\n"), lpServiceArgVectors[i]);
    str = str.Left(cchOverrideSrvCommandLine);
    if (str.CompareNoCase(szOverrideSrvCommandLine) == 0) 
    {
      g_strOverrideServerName = lpServiceArgVectors[i] + cchOverrideSrvCommandLine;
      break;
    } 

  } // for
  LocalFree(lpServiceArgVectors);
  
  TRACE(L"GetServerNameFromCommandLine() returning <%s>\n", (LPCWSTR)g_strOverrideServerName);
  return g_strOverrideServerName.IsEmpty() ? NULL : (LPCWSTR)g_strOverrideServerName;
}



/////////////////////////////////////////////////////////////////////////////
// CInternalFormatCracker

BOOL CInternalFormatCracker::Extract(LPDATAOBJECT lpDataObject)
{
	if (m_pInternalFormat != NULL)
	{
		FREE_INTERNAL(m_pInternalFormat);
	    m_pInternalFormat = NULL;
	}
	if (lpDataObject == NULL)
		return FALSE;

    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
    FORMATETC formatetc = { (CLIPFORMAT)CDataObject::m_cfInternal, NULL,
                            DVASPECT_CONTENT, -1, TYMED_HGLOBAL
                          };

    // Allocate memory for the stream
    stgmedium.hGlobal = ::GlobalAlloc(GMEM_SHARE, sizeof(INTERNAL));

    // Attempt to get data from the object
    do
    {
        if (stgmedium.hGlobal == NULL)
            break;

        if (FAILED(lpDataObject->GetDataHere(&formatetc, &stgmedium)))
            break;

        m_pInternalFormat = reinterpret_cast<INTERNAL*>(stgmedium.hGlobal);
        if (m_pInternalFormat == NULL)
            return FALSE;

    } while (FALSE);

    return TRUE;
}

BOOL CInternalFormatCracker::GetContext(LPDATAOBJECT pDataObject, // input
								CFolderObject** ppFolderObject, // output
								DATA_OBJECT_TYPES* pType		// output
								)
{
	*ppFolderObject = NULL;
	*pType = CCT_UNINITIALIZED;

	BOOL bRet = FALSE;
	if (!Extract(pDataObject))
		return bRet;
	
	// have to figure out which kind of cookie we have
	if ( (GetInternal()->m_type == CCT_RESULT) || (GetInternal()->m_type == CCT_SCOPE) )
	{
    if (GetInternal()->m_cookie == 0)
    {
      // this is the root
      *ppFolderObject = m_pCD->GetRootFolder();
      bRet = TRUE;
    }
    else
    {
      // regular cookie (scope or result pane)
		  *ppFolderObject = reinterpret_cast<CFolderObject*>(GetInternal()->m_cookie);
      _ASSERTE(*ppFolderObject != NULL);
		  *pType = GetInternal()->m_type;
		  bRet = TRUE;
    }
	}
	else if (GetInternal()->m_type == CCT_UNINITIALIZED)
	{
		// no data in the object, just ignore
		if(GetInternal()->m_cookie == -1)
    {
		  bRet = TRUE;
    }
    else
    {
      // secondary page cookie
      *ppFolderObject = reinterpret_cast<CFolderObject*>(GetInternal()->m_cookie);
      bRet = TRUE;
    }
	}
	else //CCT_SNAPIN_MANAGER
	{
		ASSERT(GetInternal()->m_type == CCT_SNAPIN_MANAGER);
		bRet = TRUE;
		*pType = GetInternal()->m_type;
	}
	return bRet;
}


///////////////////////////////////////////////////////////////////////////////
////////////////////////// CComponentDataImpl (i.e. scope pane side) //////////
///////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////
// IComponentData implementation

DEBUG_DECLARE_INSTANCE_COUNTER(CComponentDataImpl);

CComponentDataImpl::CComponentDataImpl() : m_rootFolder(this)
{
  DEBUG_INCREMENT_INSTANCE_COUNTER(CComponentDataImpl);

  m_bInitSuccess = FALSE;

	m_hDomainIcon = NULL;
  m_pConsoleNameSpace = NULL;
  m_pConsole = NULL;

  /* HACK WARNING: this is a gross hack to get around a blunder
     in dsuiext.dll. in order to see get DS extension information,
     we MUST have USERDNSDOMAIN set in the environment
     */
  {
    WCHAR * pszUDD = NULL;

    pszUDD = _wgetenv (L"USERDNSDOMAIN");
    if (pszUDD == NULL) {
      _wputenv (L"USERDNSDOMAIN=not-present");
    }
  }

}

HRESULT CComponentDataImpl::FinalConstruct()
{
	// create and initialize hidden window
  m_pHiddenWnd = new CHiddenWnd(this);

  ASSERT(m_pHiddenWnd);
  if (!m_pHiddenWnd->Create())
  {
    TRACE(_T("Failed to create hidden window\n"));
    ASSERT(FALSE);
  }
  return S_OK;
}

CComponentDataImpl::~CComponentDataImpl()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CComponentDataImpl);

    ASSERT(m_pConsoleNameSpace == NULL);
}

void CComponentDataImpl::FinalRelease()
{
   _DeleteHiddenWnd();
}

STDMETHODIMP CComponentDataImpl::Initialize(LPUNKNOWN pUnknown)
{
    ASSERT(pUnknown != NULL);
    HRESULT hr;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // MMC should only call ::Initialize once!
    ASSERT(m_pConsoleNameSpace == NULL);
    pUnknown->QueryInterface(IID_IConsoleNameSpace,
                    reinterpret_cast<void**>(&m_pConsoleNameSpace));

    // add the images for the scope tree
    CBitmap bmp16x16;
    LPIMAGELIST lpScopeImage;

    hr = pUnknown->QueryInterface(IID_IConsole, reinterpret_cast<void**>(&m_pConsole));
    ASSERT(hr == S_OK);
    if (FAILED(hr))
    {
      return hr;
    }

    hr = m_pConsole->QueryScopeImageList(&lpScopeImage);

    ASSERT(hr == S_OK);
    if (FAILED(hr))
    {
      return hr;
    }

    // Load the bitmaps from the dll
    bmp16x16.LoadBitmap(IDB_DOMAIN_SMALL);

    // Set the images
    lpScopeImage->ImageListSetStrip(reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp16x16)),
                      reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp16x16)),
                       0, RGB(128, 0, 0));

    lpScopeImage->Release();

    // bind to the path info
    hr = GetBasePathsInfo()->InitFromName(GetServerNameFromCommandLine());
    m_bInitSuccess = SUCCEEDED(hr);
    
    if (FAILED(hr))
    {
      HWND hWndParent;
      GetMainWindow(&hWndParent);
			ReportError(hWndParent, IDS_CANT_GET_PARTITIONS_INFORMATION, hr);
      // TODO: error handling, change icon
    }

    return S_OK;
}

HWND CComponentDataImpl::GetHiddenWindow() 
{ 
  ASSERT(m_pHiddenWnd != NULL);
  ASSERT(::IsWindow(m_pHiddenWnd->m_hWnd)); 
  return m_pHiddenWnd->m_hWnd;
}

void CComponentDataImpl::_DeleteHiddenWnd()
{
  if (m_pHiddenWnd == NULL)
    return;
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
	if (m_pHiddenWnd->m_hWnd != NULL)
	{
		VERIFY(m_pHiddenWnd->DestroyWindow()); 
	}
  delete m_pHiddenWnd;
  m_pHiddenWnd = NULL;
}

STDMETHODIMP CComponentDataImpl::CreateComponent(LPCOMPONENT* ppComponent)
{
    ASSERT(ppComponent != NULL);

    CComObject<CComponentImpl>* pObject;
    HRESULT hr = CComObject<CComponentImpl>::CreateInstance(&pObject);

    if (FAILED(hr))
    {
        ASSERT(FALSE && "CComObject<CComponentImpl>::CreateInstance(&pObject) failed");
        return hr;
    }

    ASSERT(pObject != NULL);

    // Store IComponentData
    pObject->SetIComponentData(this);

    return  pObject->QueryInterface(IID_IComponent,
                    reinterpret_cast<void**>(ppComponent));
}

STDMETHODIMP CComponentDataImpl::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    ASSERT(m_pConsoleNameSpace != NULL);
    HRESULT hr = S_OK;

    // Since it's my folder it has an internal format.
    // Design Note: for extension.  I can use the fact, that the data object doesn't have
    // my internal format and I should look at the node type and see how to extend it.
    if (event == MMCN_PROPERTY_CHANGE)
    {
        hr = OnPropertyChange(param);
    }
    else
    {
		if (lpDataObject == NULL)
			return S_OK;

        CFolderObject* pFolderObject = NULL;
        DATA_OBJECT_TYPES type;
        CInternalFormatCracker dobjCracker(this);
        if (!dobjCracker.GetContext(lpDataObject, &pFolderObject, &type))
        {
            // Extensions not supported.
            ASSERT(FALSE);
            return S_OK;
        }

        switch(event)
        {
        case MMCN_EXPAND:
            hr = OnExpand(pFolderObject, arg, param);
            break;
		case MMCN_REFRESH:
			OnRefreshVerbHandler(pFolderObject, NULL);
			break;
        default:
            break;
        }

    }

    return hr;
}

STDMETHODIMP CComponentDataImpl::Destroy()
{

    SAFE_RELEASE(m_pConsoleNameSpace);
    SAFE_RELEASE(m_pConsole);

    return S_OK;
}

STDMETHODIMP CComponentDataImpl::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject)
{
    ASSERT(ppDataObject != NULL);
	if (ppDataObject == NULL)
		return E_INVALIDARG;

	// create data object
    CComObject<CDataObject>* pObject = NULL;
    CComObject<CDataObject>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);
    if ( !pObject )
        return E_OUTOFMEMORY;

    // Save cookie and type for delayed rendering
    pObject->SetType(type);
    pObject->SetCookie(cookie);
	// set pointer to IComponentData
	pObject->SetIComponentData(this);

    if (cookie != NULL)
	{
		// object is not the root
		CDomainObject * pDomain = (CDomainObject *)cookie;
		pObject->SetClass( pDomain->GetClass());
    }

    return  pObject->QueryInterface(IID_IDataObject,
                    reinterpret_cast<void**>(ppDataObject));
}

///////////////////////////////////////////////////////////////////////////////
//// Notify handlers for IComponentData


HRESULT CComponentDataImpl::OnExpand(CFolderObject* pFolderObject, LPARAM arg, LPARAM param)
{
  if (arg == TRUE)
    {
      // Did Initialize get called?
      ASSERT(m_pConsoleNameSpace != NULL);
      EnumerateScopePane(pFolderObject,
                         param);
    }

  return S_OK;
}


HRESULT CComponentDataImpl::OnPropertyChange(LPARAM param)
{
    return S_OK;
}




void CComponentDataImpl::EnumerateScopePane(CFolderObject* pFolderObject, HSCOPEITEM pParent)
{
	ASSERT(m_pConsoleNameSpace != NULL); // make sure we QI'ed for the interface

	HRESULT hr = S_OK;
	
  HWND hWndParent;
  GetMainWindow(&hWndParent);

	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	CWaitCursor cWait;

	CRootFolderObject* pRootFolder = GetRootFolder();
	if (pFolderObject == pRootFolder) // asked to enumerate the root
	{
		pRootFolder->SetScopeID(pParent);
		if (m_bInitSuccess && (!pRootFolder->HasData()))
		{
      hr = GetDsDisplaySpecOptionsCFHolder()->Init(GetBasePathsInfo());
      ASSERT(SUCCEEDED(hr));
      hr = pRootFolder->Bind();
      if (FAILED(hr))
      {
				ReportError(hWndParent, IDS_CANT_GET_PARTITIONS_INFORMATION, hr);
      // TODO: error handling, change icon
        return;
      }

			hr = pRootFolder->GetData();
			if (FAILED(hr))
      {
				ReportError(hWndParent, IDS_CANT_GET_PARTITIONS_INFORMATION, hr);
        return;
      }
		}
		pRootFolder->EnumerateRootFolder(this);
	}
	else // asked to enumerate a subfolder of the root
	{
		if (pRootFolder->HasData())
		{
			pRootFolder->EnumerateFolder(pFolderObject, pParent, this);
		}
	}
}

STDMETHODIMP CComponentDataImpl::GetDisplayInfo(SCOPEDATAITEM* pScopeDataItem)
{
    ASSERT(pScopeDataItem != NULL);
    if (pScopeDataItem == NULL)
        return E_POINTER;

    CDomainObject* pDomain = reinterpret_cast<CDomainObject*>(pScopeDataItem->lParam);

    ASSERT(pScopeDataItem->mask & SDI_STR);
    pScopeDataItem->displayname = (LPWSTR)pDomain->GetDisplayString(0);

    ASSERT(pScopeDataItem->displayname != NULL);

    return S_OK;
}


class CCompareDomainObjectByDN
{
public:
  CCompareDomainObjectByDN(LPCWSTR lpszDN) { m_lpszDN = lpszDN;}

  bool operator()(CDomainObject* p)
  {
    // NOTICE-2002/03/07-ericb - SecurityPush: checking both strings for null before dereferencing.
    if (!m_lpszDN || !p || !p->GetNCName())
    {
      ASSERT(m_lpszDN);
      ASSERT(p);
      ASSERT(p->GetNCName());
      return false;
    }
    return (_wcsicmp(m_lpszDN, p->GetNCName()) == 0);
  }
private:
  LPCWSTR m_lpszDN;
};



STDMETHODIMP CComponentDataImpl::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
  if (lpDataObjectA == NULL || lpDataObjectB == NULL)
      return E_POINTER;

   CFolderObject *pFolderObjectA, *pFolderObjectB;
   DATA_OBJECT_TYPES typeA, typeB;
   CInternalFormatCracker dobjCrackerA(this), dobjCrackerB(this);
   if ( (!dobjCrackerA.GetContext(lpDataObjectA, &pFolderObjectA, &typeA)) ||
       (!dobjCrackerB.GetContext(lpDataObjectB, &pFolderObjectB, &typeB)) )
      return E_INVALIDARG; // something went wrong


  // must have valid cookies
  if ( (pFolderObjectA == NULL) || (pFolderObjectB == NULL) )
  {
    return S_FALSE;
  }
    
  if (pFolderObjectA == pFolderObjectB)
  {
    // same pointer, they are the same (either both from real nodes
    // or both from secondary pages)
    return S_OK;
  }

  // the two cookies are different, but one of them might be from a secondary property page
  // and another from a real node
  CDomainObject* pA = dynamic_cast<CDomainObject*>(pFolderObjectA);
  CDomainObject* pB = dynamic_cast<CDomainObject*>(pFolderObjectB);

  if ((pA == NULL) || (pB == NULL))
  {
    return S_FALSE;
  }

  BOOL bSecondaryA = m_secondaryPagesManager.IsCookiePresent(pA);
  BOOL bSecondaryB = m_secondaryPagesManager.IsCookiePresent(pB);

  BOOL bTheSame = FALSE;
  if (bSecondaryA && !bSecondaryB)
  {
    bTheSame = m_secondaryPagesManager.FindCookie(CCompareDomainObjectByDN(pB->GetNCName())) != NULL;
  }
  else if (!bSecondaryA && bSecondaryB)
  {
    bTheSame = m_secondaryPagesManager.FindCookie(CCompareDomainObjectByDN(pA->GetNCName())) != NULL;
  }

  return bTheSame ? S_OK : S_FALSE;
}

HRESULT CComponentDataImpl::AddFolder(CFolderObject* pFolderObject,
									  HSCOPEITEM pParentScopeItem,
									  BOOL bHasChildren)
{
  TRACE(L"CComponentDataImpl::AddFolder(%s)\n", pFolderObject->GetDisplayString(0));

  SCOPEDATAITEM scopeItem;
  // NOTICE-2002/03/07-ericb - SecurityPush: zeroing a struct.
  memset(&scopeItem, 0, sizeof(SCOPEDATAITEM));

	// set parent scope item
	scopeItem.mask |= SDI_PARENT;
	scopeItem.relativeID = pParentScopeItem;

	// Add node name, we implement callback
	scopeItem.mask |= SDI_STR;
	scopeItem.displayname = MMC_CALLBACK;

	// Add the lParam
	scopeItem.mask |= SDI_PARAM;
	scopeItem.lParam = reinterpret_cast<LPARAM>(pFolderObject);
	
	// Add close image
	scopeItem.mask |= SDI_IMAGE;
	scopeItem.nImage = pFolderObject->GetImageIndex();

	// Add open image
	scopeItem.mask |= SDI_OPENIMAGE;
	scopeItem.nOpenImage = pFolderObject->GetImageIndex();

	// Add button to node if the folder has children
	if (bHasChildren == TRUE)
	{
		scopeItem.mask |= SDI_CHILDREN;
		scopeItem.cChildren = 1;
	}

	pFolderObject->SetScopeID(0);
	HRESULT	hr = m_pConsoleNameSpace->InsertItem(&scopeItem);
	if (SUCCEEDED(hr))
		pFolderObject->SetScopeID(scopeItem.ID);

	return hr;
}

HRESULT CComponentDataImpl::AddDomainIcon()
{
	if (m_hDomainIcon != NULL)
		return S_OK;

  m_hDomainIcon = GetBasePathsInfo()->GetIcon(L"domainDNS",
                                  DSGIF_ISNORMAL | DSGIF_GETDEFAULTICON,
                                  0, 0);
	if (m_hDomainIcon == NULL)
		return S_OK;

	LPIMAGELIST lpScopeImage;
    HRESULT hr = m_pConsole->QueryScopeImageList(&lpScopeImage);
    ASSERT(SUCCEEDED(hr));
	if (FAILED(hr))
		return hr;
    // Set the images
    hr = lpScopeImage->ImageListSetIcon((LONG_PTR*)m_hDomainIcon,DOMAIN_IMAGE_IDX);
	lpScopeImage->Release();
	return hr;
}

HRESULT CComponentDataImpl::AddDomainIconToResultPane(LPIMAGELIST lpImageList)
{
	if (m_hDomainIcon == NULL)
		return S_OK;
	return lpImageList->ImageListSetIcon((LONG_PTR*)m_hDomainIcon,DOMAIN_IMAGE_IDX);
}


int CComponentDataImpl::GetDomainImageIndex()
{
	return (m_hDomainIcon != NULL) ? DOMAIN_IMAGE_IDX : DOMAIN_IMAGE_DEFAULT_IDX;
}

/////////////////////////////////////////////////////////////////////////////
// IExtendPropertySheet Implementation
//+----------------------------------------------------------------------------
//
//  Function:   AddPageProc
//
//  Synopsis:   The IShellPropSheetExt->AddPages callback.
//
//-----------------------------------------------------------------------------
BOOL CALLBACK
AddPageProc(HPROPSHEETPAGE hPage, LPARAM pCall)
{
    TRACE(_T("xx.%03x> AddPageProc()\n"), GetCurrentThreadId());

    HRESULT hr;

    hr = ((LPPROPERTYSHEETCALLBACK)pCall)->AddPage(hPage);

    return hr == S_OK;
}
STDMETHODIMP CComponentDataImpl::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                    LONG_PTR handle,
                    LPDATAOBJECT lpIDataObject)
{
    TRACE(_T("xx.%03x> CComponentDataImpl::CreatePropertyPages()\n"),
          GetCurrentThreadId());

    // Validate Inputs
    if (lpProvider == NULL)
    {
        return E_INVALIDARG;
    }

    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;
    CWaitCursor wait;

    CFolderObject* pFolderObject = NULL;
    DATA_OBJECT_TYPES type;
    CInternalFormatCracker dobjCracker(this);
    if ( (!dobjCracker.GetContext(lpIDataObject, &pFolderObject, &type)) ||
            (pFolderObject == NULL))
    return E_NOTIMPL; // unknown format

    // special case the root
    if (pFolderObject == GetRootFolder())
    {
      return GetRootFolder()->OnAddPages(lpProvider, handle);
    }

    // See if a sheet is already up for this object.
    //
    if (IsSheetAlreadyUp(lpIDataObject))
    {
        return S_OK;
    }

    if (pFolderObject->GetParentFolder() == GetRootFolder())
    {
       TRACE(L"\t!!!!! This is the root domain\n");
    }

   // See if a PDC is available.
   //
   CDomainObject * pDomainObject = (CDomainObject *)pFolderObject;

   PCWSTR wzDomain = pDomainObject->GetDomainName();

   // If the domain name is null, then launching a secondary page. The domain
   // object properties have already been set in _OnSheetCreate.
   //
   if (wzDomain && *wzDomain)
   {
      TRACE(L"Calling DsGetDcName on %s\n", wzDomain);
      CString strCachedPDC;
      PDOMAIN_CONTROLLER_INFOW pDCInfo = NULL;

      // Get the cached PDC name for display later if the PDC can't be contacted.
      //
      DWORD dwRet = DsGetDcNameW(NULL, wzDomain, NULL, NULL, DS_PDC_REQUIRED, &pDCInfo);

      int nID = IDS_NO_PDC_MSG;

      if (ERROR_SUCCESS == dwRet)
      {
         strCachedPDC = pDCInfo->DomainControllerName + 2;
         NetApiBufferFree(pDCInfo);
      }

      // Now do a NetLogon cache update (with the force flag) to see if the PDC
      // is actually available.
      //
      dwRet = DsGetDcNameW(NULL, wzDomain, NULL, NULL, 
                           DS_PDC_REQUIRED | DS_FORCE_REDISCOVERY, &pDCInfo);

      if (ERROR_SUCCESS == dwRet)
      {
         CString strPDC;

         strPDC = pDCInfo->DomainControllerName + 2; // skip the UNC backslashes.

         NetApiBufferFree(pDCInfo);

         TRACE(L"PDC: %s\n", (PCWSTR)strPDC);

         if (strPDC.IsEmpty())
         {
            return E_OUTOFMEMORY;
         }

         pDomainObject->SetPDC(strPDC);

         pDomainObject->SetPdcAvailable(true);
      }
      else
      {
         pDomainObject->SetPdcAvailable(false);

         CString strMsg;

         if (strCachedPDC.IsEmpty())
         {
            strMsg.LoadString(IDS_UNKNOWN_PDC_MSG);
         }
         else
         {
            strMsg.Format(IDS_NO_PDC_MSG, strCachedPDC);
         }
         HWND hWndParent;
         GetMainWindow(&hWndParent);
         _MessageBox(hWndParent, strMsg, MB_OK | MB_ICONEXCLAMATION);
      }
   }

    //
    // Pass the Notify Handle to the data object.
    //
    PROPSHEETCFG SheetCfg = {handle};
    FORMATETC fe = {CDataObject::m_cfGetIPropSheetCfg, NULL, DVASPECT_CONTENT,
                    -1, TYMED_HGLOBAL};
    STGMEDIUM sm = {TYMED_HGLOBAL, NULL, NULL};
    sm.hGlobal = (HGLOBAL)&SheetCfg;

    lpIDataObject->SetData(&fe, &sm, FALSE);

    //
    // Initialize and create the pages.
    //
    // Bind to the property sheet COM object at startup and hold its pointer
    // until shutdown so that its cache can live as long as us.
    //
    CComPtr<IShellExtInit> spShlInit;
    hr = CoCreateInstance(CLSID_DsPropertyPages, NULL, CLSCTX_INPROC_SERVER,
                          IID_IShellExtInit, (void **)&spShlInit);
    if (FAILED(hr))
    {
        TRACE(TEXT("CoCreateInstance on CLSID_DsPropertyPages failed, hr: 0x%x\n "), hr);
        return hr;
    }

    hr = spShlInit->Initialize(NULL, lpIDataObject, 0);

    if (FAILED(hr))
    {
        TRACE(TEXT("spShlInit->Initialize failed, hr: 0x%x\n"), hr);
        return hr;
    }

    CComPtr<IShellPropSheetExt> spSPSE;

    hr = spShlInit->QueryInterface(IID_IShellPropSheetExt, (void **)&spSPSE);

    if (FAILED(hr))
    {
        TRACE(TEXT("spShlInit->QI for IID_IShellPropSheetExt failed, hr: 0x%x\n"), hr);
        return hr;
    }

    hr = spSPSE->AddPages(AddPageProc, (LONG_PTR)lpProvider);

    if (FAILED(hr))
    {
        TRACE(TEXT("pSPSE->AddPages failed, hr: 0x%x\n"), hr);
        return hr;
    }

    _SheetLockCookie(pFolderObject);

    return hr;
}


// Sheet locking and unlocking add by JEFFJON 1/26/99
//
void CComponentDataImpl::_OnSheetClose(CFolderObject* pCookie)
{
  ASSERT(pCookie != NULL);
  _SheetUnlockCookie(pCookie);

  CDomainObject* pDomObj = dynamic_cast<CDomainObject*>(pCookie);
  if (pDomObj != NULL)
    m_secondaryPagesManager.OnSheetClose(pDomObj);
}


void CComponentDataImpl::_OnSheetCreate(PDSA_SEC_PAGE_INFO pDsaSecondaryPageInfo,
                                        PWSTR pwzDC)
{
  ASSERT(pDsaSecondaryPageInfo != NULL);

  // get the info from the packed structure
  HWND hwndParent = pDsaSecondaryPageInfo->hwndParentSheet;

  LPCWSTR lpszTitle = (LPCWSTR)((BYTE*)pDsaSecondaryPageInfo + pDsaSecondaryPageInfo->offsetTitle);
  DSOBJECTNAMES* pDsObjectNames = &(pDsaSecondaryPageInfo->dsObjectNames);

  ASSERT(pDsObjectNames->cItems == 1);
  DSOBJECT* pDsObject = &(pDsObjectNames->aObjects[0]);

  LPCWSTR lpszName = (LPCWSTR)((BYTE*)pDsObject + pDsObject->offsetName);
  LPCWSTR lpszClass = (LPCWSTR)((BYTE*)pDsObject + pDsObject->offsetClass);
    
  // with the given info, create a cookie and set it
  CDomainObject* pNewCookie = new CDomainObject(); 
  pNewCookie->InitializeForSecondaryPage(lpszName, lpszClass, GetDomainImageIndex());

   // The parent sheet will be in read-only mode if a PDC is not available.
   pNewCookie->SetPdcAvailable(!(pDsObject->dwFlags & DSOBJECT_READONLYPAGES));

   if (pwzDC && !IsBadReadPtr(pwzDC, sizeof(PWSTR)))
   {
      pNewCookie->SetPDC(pwzDC);
   }

    // with the cookie, can call into ourselves to get a data object
  CComPtr<IDataObject> spDataObject;
  MMC_COOKIE cookie = reinterpret_cast<MMC_COOKIE>(pNewCookie);
  HRESULT hr = QueryDataObject(cookie, CCT_UNINITIALIZED, &spDataObject);

  if (FAILED(hr) || (spDataObject == NULL) || IsSheetAlreadyUp(spDataObject))
  {
    // we failed to create a data object (rare)
    // or the sheet is already up
    delete pNewCookie;
    return;
  }

  //
  // Pass the parent sheet handle to the data object.
  //
  PROPSHEETCFG SheetCfg = {0};
  SheetCfg.hwndParentSheet = hwndParent;
  FORMATETC fe = {CDataObject::m_cfGetIPropSheetCfg, NULL, DVASPECT_CONTENT,
                  -1, TYMED_HGLOBAL};
  STGMEDIUM sm = {TYMED_HGLOBAL, NULL, NULL};
  sm.hGlobal = (HGLOBAL)&SheetCfg;

  hr = spDataObject->SetData(&fe, &sm, FALSE);

  ASSERT(SUCCEEDED(hr));

  // with the data object, call into MMC to get the sheet 
  hr = m_secondaryPagesManager.CreateSheet(GetHiddenWindow(), 
                                      m_pConsole, 
                                      GetUnknown(),
                                      pNewCookie,
                                      spDataObject,
                                      lpszTitle);

  // if failed, the cookie can be discarded, 
  // if succeeded, the cookie has been inserted into
  // the secondary pages manager cookie list
  if (FAILED(hr))
  {
    delete pNewCookie;
  }

}





void  CComponentDataImpl::_SheetLockCookie(CFolderObject* pCookie)
{
  pCookie->IncrementSheetLockCount();
  m_sheetCookieTable.Add(pCookie);
}

void  CComponentDataImpl::_SheetUnlockCookie(CFolderObject* pCookie)
{
  pCookie->DecrementSheetLockCount();
  m_sheetCookieTable.Remove(pCookie);
}

STDMETHODIMP CComponentDataImpl::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
	CFolderObject* pFolderObject;
	DATA_OBJECT_TYPES type;
	CInternalFormatCracker dobjCracker(this);
	if (!dobjCracker.GetContext(lpDataObject, &pFolderObject, &type))
  {
    // not internal format, not ours
		return S_FALSE;
  }

  // this is the MMC snzpin wizard, we do not have one
  if (type == CCT_SNAPIN_MANAGER)
  {
    return S_FALSE;
  }

  // if NULL no pages
  if (pFolderObject == NULL)
  {
    return S_FALSE;
  }

  // secondary pages data objects have to be checked first,
  // because they look like the root (no parents, but they
  // have CCT_UNINITIALIZED 
  if ( (pFolderObject->GetParentFolder() == NULL) || (type == CCT_UNINITIALIZED) )
  {
    return S_OK;
  }

  // check if this is the root
  if (GetRootFolder() == pFolderObject)
  {
    // this is the root
    ASSERT(type == CCT_SCOPE);
    return S_OK;
  }

  // default case, have DSPROP property pages
  return S_OK;
}

BOOL CComponentDataImpl::IsScopePaneNode(LPDATAOBJECT lpDataObject)
{
	CFolderObject* pFolderObject;
	DATA_OBJECT_TYPES type;
	CInternalFormatCracker dobjCracker(this);
	if (!dobjCracker.GetContext(lpDataObject, &pFolderObject, &type))
		return FALSE;
  return (dobjCracker.GetInternal()->m_type == CCT_SCOPE);
}

///////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu implementation
//
STDMETHODIMP CComponentDataImpl::AddMenuItems(LPDATAOBJECT pDataObject,
                                              LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                              long *pInsertionAllowed)
{
  HRESULT hr = S_OK;

	CFolderObject* pFolderObject;
	DATA_OBJECT_TYPES type;
	CInternalFormatCracker dobjCracker(this);
	if (!dobjCracker.GetContext(pDataObject, &pFolderObject, &type))
        return E_FAIL;

    return pFolderObject->OnAddMenuItems(pContextMenuCallback, pInsertionAllowed);
}


STDMETHODIMP CComponentDataImpl::Command(long nCommandID, LPDATAOBJECT pDataObject)
{
  // Note - snap-ins need to look at the data object and determine
  // in what context the command is being called.

	CFolderObject* pFolderObject;
	DATA_OBJECT_TYPES type;
	CInternalFormatCracker dobjCracker(this);
	if (!dobjCracker.GetContext(pDataObject, &pFolderObject, &type))
        return E_FAIL;

    return pFolderObject->OnCommand(this, nCommandID);
}

/////////////////////////////////////////////////////////////////////////////
// CComponentDataImpl::ISnapinHelp2 members

STDMETHODIMP CComponentDataImpl::GetHelpTopic(LPOLESTR* lpCompiledHelpFile)
{
  if (lpCompiledHelpFile == NULL)
  {
    return E_INVALIDARG;
  }

  CString szHelpFilePath;
  LPTSTR lpszBuffer = szHelpFilePath.GetBuffer(2*MAX_PATH);
  UINT nLen = ::GetSystemWindowsDirectory(lpszBuffer, 2*MAX_PATH);
  if (nLen == 0)
  {
    return E_FAIL;
  }
  szHelpFilePath.ReleaseBuffer();
  szHelpFilePath += L"\\help\\";
  szHelpFilePath += DOMADMIN_SNAPIN_HELP_FILE;

  UINT nBytes = (szHelpFilePath.GetLength()+1) * sizeof(WCHAR);
  *lpCompiledHelpFile = (LPOLESTR)::CoTaskMemAlloc(nBytes);

  if (NULL == *lpCompiledHelpFile)
  {
    return E_OUTOFMEMORY;
  }

  // NOTICE-2002/03/07-ericb - SecurityPush: reviewed, usage is safe.
  memcpy(*lpCompiledHelpFile, (LPCWSTR)szHelpFilePath, nBytes);

  return S_OK;
}

// CODEWORK-2002/03/07-ericb - use a common helper for these two functions.
STDMETHODIMP CComponentDataImpl::GetLinkedTopics(LPOLESTR* lpCompiledHelpFile)
{
  if (lpCompiledHelpFile == NULL)
  {
    return E_INVALIDARG;
  }

  CString szHelpFilePath;
  LPTSTR lpszBuffer = szHelpFilePath.GetBuffer(2*MAX_PATH);
  UINT nLen = ::GetSystemWindowsDirectory(lpszBuffer, 2*MAX_PATH);
  if (nLen == 0)
  {
    return E_FAIL;
  }
  szHelpFilePath.ReleaseBuffer();
  szHelpFilePath += L"\\help\\";
  szHelpFilePath += DOMADMIN_LINKED_HELP_FILE;

  UINT nBytes = (szHelpFilePath.GetLength()+1) * sizeof(WCHAR);
  *lpCompiledHelpFile = (LPOLESTR)::CoTaskMemAlloc(nBytes);

  if (NULL == *lpCompiledHelpFile)
  {
    return E_OUTOFMEMORY;
  }

  // NOTICE-2002/03/07-ericb - SecurityPush: reviewed, usage is safe.
  memcpy(*lpCompiledHelpFile, (LPCWSTR)szHelpFilePath, nBytes);

  return S_OK;
}
/////////////////////////////////////////////////////////////////////

void CComponentDataImpl::HandleStandardVerbsHelper(CComponentImpl* pComponentImpl,
									LPCONSOLEVERB pConsoleVerb,
									BOOL bScope, BOOL bSelect,
									CFolderObject* pFolderObject,
                                    DATA_OBJECT_TYPES type)
{
    // You should crack the data object and enable/disable/hide standard
    // commands appropriately.  The standard commands are reset everytime you get
    // called. So you must reset them back.

	ASSERT(pConsoleVerb != NULL);
	ASSERT(pComponentImpl != NULL);
	ASSERT(pFolderObject != NULL);

	// reset the selection
	pComponentImpl->SetSelection(NULL, CCT_UNINITIALIZED);


	if (bSelect)
	{
    // special case the root
    BOOL bIsRoot = (pFolderObject == GetRootFolder());

		// setting the selection, if any
		pComponentImpl->SetSelection(pFolderObject, type);

		// the default just disables all the non implemented verbs
		pConsoleVerb->SetVerbState(MMC_VERB_COPY, HIDDEN, TRUE);
		pConsoleVerb->SetVerbState(MMC_VERB_COPY, ENABLED, FALSE);

		pConsoleVerb->SetVerbState(MMC_VERB_PASTE, HIDDEN, TRUE);
		pConsoleVerb->SetVerbState(MMC_VERB_PASTE, ENABLED, FALSE);

		pConsoleVerb->SetVerbState(MMC_VERB_RENAME, HIDDEN, TRUE);
		pConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, FALSE);

		pConsoleVerb->SetVerbState(MMC_VERB_PRINT, HIDDEN, TRUE);
		pConsoleVerb->SetVerbState(MMC_VERB_PRINT, ENABLED, FALSE);

		// handling of standard verbs

		// MMC_VERB_DELETE (always disabled)
		pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, FALSE);
		pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, TRUE);

		// MMC_VERB_REFRESH (enabled only for root)
    if (bIsRoot)
    {
      pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);
		  pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, FALSE);
    }
    else
    {
		  pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, FALSE);
		  pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, TRUE);
    }

		// MMC_VERB_PROPERTIES
    // passing NULL pFolderObject means multiple selection
    BOOL bHasProperties = (pFolderObject != NULL);
		BOOL bHideProperties = !bHasProperties;
		pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, bHasProperties);
		pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, bHideProperties);
		
		// SET DEFAULT VERB
		// assume only folders: only one default verb (i.e. will not have MMC_VERB_PROPERTIES)
		pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);

	}
}

void CComponentDataImpl::OnRefreshVerbHandler(CFolderObject* pFolderObject, 
                                              CComponentImpl* pComponentImpl,
                                              BOOL bBindAgain)
{
  TRACE(L"CComponentDataImpl::OnRefreshVerbHandler(...,..., %d)\n", bBindAgain);
	if (pFolderObject->_WarningOnSheetsUp(this))
		return;

  // make sure the DNS cache is flushed, in case a somain was added.
  VERIFY(::DnsFlushResolverCache());

  // NOTICE: only the root folder allows refresh
  ASSERT(pFolderObject == GetRootFolder());

	// remove all the children of the root from the UI
  m_pConsoleNameSpace->DeleteItem(m_rootFolder.GetScopeID(), /*fDeleteThis*/ FALSE);

  HRESULT hr = S_OK;
  if (bBindAgain)
  {
    // the server name has changed
    hr = m_rootFolder.Bind();
    TRACE(L"m_rootFolder.Bind() returned hr = 0x%x\n", hr);
  }
  
  if (SUCCEEDED(hr))
  {
	  // refresh the data from the server
	  hr = m_rootFolder.GetData();
    TRACE(L"m_rootFolder.GetData() returned hr = 0x%x\n", hr);
  }

	if (FAILED(hr))
	{
    HWND hWndParent;
    GetMainWindow(&hWndParent);
		ReportError(hWndParent, IDS_CANT_GET_PARTITIONS_INFORMATION, hr);
	}

  if (FAILED(hr))
    return;

	// re-enumerate
	m_rootFolder.EnumerateRootFolder(this);
}

//+---------------------------------------------------------------------------
//
//  Function:   LocaleStrCmp
//
//  Synopsis:   Do a case insensitive string compare that is safe for any
//              locale.
//
//  Arguments:  [ptsz1] - strings to compare
//              [ptsz2]
//
//  Returns:    -1, 0, or 1 just like lstrcmpi
//
//  History:    10-28-96   DavidMun   Created
//
//  Notes:      This is slower than lstrcmpi, but will work when sorting
//              strings even in Japanese.
//
//----------------------------------------------------------------------------
int
LocaleStrCmp(LPCTSTR ptsz1, LPCTSTR ptsz2)
{
    int iRet = 0;

    iRet = CompareString(LOCALE_USER_DEFAULT,
                         NORM_IGNORECASE        |
                           NORM_IGNOREKANATYPE  |
                           NORM_IGNOREWIDTH,
                         ptsz1,
                         -1,
                         ptsz2,
                         -1);

    if (iRet)
    {
        iRet -= 2;  // convert to lstrcmpi-style return -1, 0, or 1

        if ( 0 == iRet )
        {
            UNICODE_STRING unistr1;
            unistr1.Length = (USHORT)(::lstrlen(ptsz1)*sizeof(WCHAR));
            unistr1.MaximumLength = unistr1.Length;
            unistr1.Buffer = (LPWSTR)ptsz1;
            UNICODE_STRING unistr2;
            unistr2.Length = (USHORT)(::lstrlen(ptsz2)*sizeof(WCHAR));
            unistr2.MaximumLength = unistr2.Length;
            unistr2.Buffer = (LPWSTR)ptsz2;
            iRet = ::RtlCompareUnicodeString(
                &unistr1,
                &unistr2,
                FALSE );
        }
    }
    else
    {
        DWORD   dwErr = GetLastError ();
        if (dwErr != 0)
        {
            TRACE(L"CompareString (%s, %s) failed: 0x%x\n", ptsz1, ptsz2, dwErr);
        }
    }
    return iRet;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////// CComponentImpl (i.e. result pane side) //////////////////
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CComponentImpl::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    return S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:  CComponentImpl::IResultDataCompareEx::Compare
//
//  Synopsis:  This compare is used to sort the item's in the listview
//
//  Note:      Assume sort is ascending when comparing.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CComponentImpl::Compare(RDCOMPARE* prdc, int* pnResult)
{
   if (pnResult == NULL)
   {
      ASSERT(FALSE);
      return E_POINTER;
   }
   if (prdc == NULL)
   {
      ASSERT(FALSE);
      return E_POINTER;
   }

   *pnResult = 0;

   LPCTSTR szStringA;
   LPCTSTR szStringB;

   CDomainObject* pDataA = reinterpret_cast<CDomainObject*>(prdc->prdch1->cookie);
   CDomainObject* pDataB = reinterpret_cast<CDomainObject*>(prdc->prdch2->cookie);

   ASSERT(pDataA != NULL && pDataB != NULL);

   // Currently DomAdmin has just two columns, Name and Type. The value of
   // the type column is always "DomainDNS", so there is nothing to compare
   // for that column and the default *pnResult, set to zero above, is
   // returned.

   if (0 == prdc->nColumn)
   {
      szStringA = pDataA->GetDomainName();
      szStringB = pDataB->GetDomainName();

      ASSERT(szStringA != NULL);
      ASSERT(szStringB != NULL);

      *pnResult = LocaleStrCmp(szStringA, szStringB);
   }

   return S_OK;
}


void CComponentImpl::HandleStandardVerbs(BOOL bScope, BOOL bSelect,
                                         CFolderObject* pFolderObject, DATA_OBJECT_TYPES type)
{
    // delegate it to the IComponentData helper function
    ASSERT(m_pCD != NULL);
	m_pCD->HandleStandardVerbsHelper(
		this, m_pConsoleVerb, bScope, bSelect, pFolderObject, type);
}

void CComponentImpl::Refresh(CFolderObject* pFolderObject)
{
	ASSERT(m_pComponentData != NULL);
	// delegate it to the IComponentData helper function
	((CComponentDataImpl*)m_pComponentData)->OnRefreshVerbHandler(pFolderObject, this);
}



//                   utility routines
////////////////////////////////////////////////////////////////////
//
// Print the data depending on its type.
//

#ifdef DBG
void
PrintColumn(
    PADS_SEARCH_COLUMN pColumn,
    LPWSTR pszColumnName
    )
{

    ULONG i, j, k;

    if (!pColumn) {
        return;
    }

    TRACE(_T(
        "%s = "),
        pszColumnName
        );

    for (k=0; k < pColumn->dwNumValues; k++) {
        if (k > 0)
            TRACE(_T("#  "));

        switch(pColumn->dwADsType) {
        case ADSTYPE_DN_STRING         :
            TRACE(_T(
                "%s  "),
                (LPWSTR) pColumn->pADsValues[k].DNString
                );
            break;
        case ADSTYPE_CASE_EXACT_STRING :
            TRACE(_T(
                "%s  "),
                (LPWSTR) pColumn->pADsValues[k].CaseExactString
                );
            break;
        case ADSTYPE_CASE_IGNORE_STRING:
            TRACE(_T(
                "%s  "),
                (LPWSTR) pColumn->pADsValues[k].CaseIgnoreString
                );
            break;
        case ADSTYPE_PRINTABLE_STRING  :
            TRACE(_T(
                "%s  "),
                (LPWSTR) pColumn->pADsValues[k].PrintableString
                );
            break;
        case ADSTYPE_NUMERIC_STRING    :
            TRACE(_T(
                "%s  "),
                (LPWSTR) pColumn->pADsValues[k].NumericString
                );
            break;

        case ADSTYPE_BOOLEAN           :
            TRACE(_T(
                "%s  "),
                (DWORD) pColumn->pADsValues[k].Boolean ?
                L"TRUE" : L"FALSE"
                );
            break;

        case ADSTYPE_INTEGER           :
            TRACE(_T(
                "%d  "),
                (DWORD) pColumn->pADsValues[k].Integer
                );
            break;

        case ADSTYPE_OCTET_STRING      :
            for (j=0; j<pColumn->pADsValues[k].OctetString.dwLength; j++) {
                TRACE(_T(
                    "%02x"),
                    ((BYTE *)pColumn->pADsValues[k].OctetString.lpValue)[j]
                    );
            }
            break;

        case ADSTYPE_LARGE_INTEGER     :
            TRACE(_T(
                "%e = "),
                (double) pColumn->pADsValues[k].Integer
                );
            break;

        case ADSTYPE_UTC_TIME          :
            TRACE(_T(
                "(date value) "
                ));
            break;
        case ADSTYPE_PROV_SPECIFIC     :
            TRACE(_T(
                "(provider specific value) "
                ));
            break;

        }
    }

    TRACE(_T("\n"));
}

#endif

/////////////////////////////////////////////////////////////////////////////
// Return TRUE if we are enumerating our main folder

BOOL CComponentImpl::IsEnumerating(LPDATAOBJECT lpDataObject)
{
    BOOL bResult = FALSE;

    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
    FORMATETC formatetc = { (CLIPFORMAT)CDataObject::m_cfNodeType, NULL,
                            DVASPECT_CONTENT, -1, TYMED_HGLOBAL
                          };

    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, sizeof(GUID));

    // Attempt to get data from the object
    do
    {
        if (stgmedium.hGlobal == NULL)
            break;

        if (FAILED(lpDataObject->GetDataHere(&formatetc, &stgmedium)))
            break;

        GUID* nodeType = reinterpret_cast<GUID*>(stgmedium.hGlobal);

        if (nodeType == NULL)
            break;

        // Is this my main node (static folder node type)
        if (*nodeType == cDefaultNodeType)
            bResult = TRUE;

    } while (FALSE);


    // Free resources
    if (stgmedium.hGlobal != NULL)
        GlobalFree(stgmedium.hGlobal);

    return bResult;
}

/////////////////////////////////////////////////////////////////////////////
// CComponentImpl's IComponent implementation

STDMETHODIMP CComponentImpl::GetResultViewType(MMC_COOKIE cookie,  LPOLESTR* ppViewType,
                                        long *pViewOptions)
{
  // Use default view
  *pViewOptions = 0;
  return S_FALSE;
}

STDMETHODIMP CComponentImpl::Initialize(LPCONSOLE lpConsole)
{
    ASSERT(lpConsole != NULL);

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Save the IConsole pointer
    m_pConsole = lpConsole;
    m_pConsole->AddRef();

    // Load resource strings
    LoadResources();

    // QI for a IHeaderCtrl
    HRESULT hr = m_pConsole->QueryInterface(IID_IHeaderCtrl,
                        reinterpret_cast<void**>(&m_pHeader));

    // Give the console the header control interface pointer
    if (SUCCEEDED(hr))
        m_pConsole->SetHeader(m_pHeader);

    m_pConsole->QueryInterface(IID_IResultData,
                        reinterpret_cast<void**>(&m_pResult));

    hr = m_pConsole->QueryResultImageList(&m_pImageResult);
    ASSERT(hr == S_OK);

    hr = m_pConsole->QueryConsoleVerb(&m_pConsoleVerb);
    ASSERT(hr == S_OK);

    //InitializeHeaders(NULL);
    //InitializeBitmaps(NULL);
    return S_OK;
}

STDMETHODIMP CComponentImpl::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (event == MMCN_PROPERTY_CHANGE)
    {
        hr = OnPropertyChange(lpDataObject);
    }
    else if (event == MMCN_VIEW_CHANGE)
    {
        hr = OnUpdateView(lpDataObject);
    }
    else if (event == MMCN_CONTEXTHELP)
    {
        CComPtr<IDisplayHelp> spHelp;
        hr = m_pConsole->QueryInterface(IID_IDisplayHelp, (void **)&spHelp);
        ASSERT(SUCCEEDED(hr));
        if (SUCCEEDED(hr))
        {
            TRACE(L"Setting the help topic to adconcepts.chm::/domadmin_top.htm\n");
            spHelp->ShowTopic(L"adconcepts.chm::/domadmin_top.htm");
        }
    }
    else
    {
        if (lpDataObject == NULL)
            return S_OK;

        CFolderObject* pFolderObject = NULL;
        DATA_OBJECT_TYPES type;
        CInternalFormatCracker dobjCracker(m_pCD);
        if (!dobjCracker.GetContext(lpDataObject, &pFolderObject, &type))
        {
            // Extensions not supported.
            ASSERT(FALSE);
            return S_OK;
        }
        ASSERT(pFolderObject != NULL);

        switch(event)
        {
        case MMCN_SHOW:
            hr = OnShow(pFolderObject, arg, param);
            break;

        case MMCN_ADD_IMAGES:
            hr = OnAddImages(pFolderObject, arg, param);
            break;

        case MMCN_SELECT:
            if (IsMMCMultiSelectDataObject(lpDataObject) == TRUE)
                pFolderObject = NULL;
            HandleStandardVerbs( (BOOL) LOWORD(arg)/*bScope*/,
                                 (BOOL) HIWORD(arg)/*bSelect*/, pFolderObject, type);
            break;

        case MMCN_REFRESH:
            Refresh(pFolderObject);
            break;

        default:
            break;
        } // switch
    } // else

    if (m_pResult)
    {
      // should put something here, someday?
      ;
    }

    return hr;
}

STDMETHODIMP CComponentImpl::Destroy(MMC_COOKIE cookie)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Release the interfaces that we QI'ed
    if (m_pConsole != NULL)
    {
        // Tell the console to release the header control interface
        m_pConsole->SetHeader(NULL);
        SAFE_RELEASE(m_pHeader);

        SAFE_RELEASE(m_pResult);
        SAFE_RELEASE(m_pImageResult);

        // Release the IConsole interface last
        SAFE_RELEASE(m_pConsole);
        SAFE_RELEASE(m_pComponentData); // QI'ed in IComponentDataImpl::CreateComponent

        SAFE_RELEASE(m_pConsoleVerb);
    }

    return S_OK;
}

STDMETHODIMP CComponentImpl::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                        LPDATAOBJECT* ppDataObject)
{
    // Delegate it to the IComponentData
    ASSERT(m_pComponentData != NULL);
    return m_pComponentData->QueryDataObject(cookie, type, ppDataObject);
}

/////////////////////////////////////////////////////////////////////////////
// CComponentImpl's implementation specific members

DEBUG_DECLARE_INSTANCE_COUNTER(CComponentImpl);

CComponentImpl::CComponentImpl()
{
  DEBUG_INCREMENT_INSTANCE_COUNTER(CComponentImpl);
  Construct();
}

CComponentImpl::~CComponentImpl()
{
#if DBG==1
    ASSERT(dbg_cRef == 0);
#endif

    DEBUG_DECREMENT_INSTANCE_COUNTER(CComponentImpl);

    // Make sure the interfaces have been released
    ASSERT(m_pConsole == NULL);
    ASSERT(m_pHeader == NULL);
    Construct();
}

void CComponentImpl::Construct()
{
#if DBG==1
    dbg_cRef = 0;
#endif

    m_pConsole = NULL;
    m_pHeader = NULL;

    m_pResult = NULL;
    m_pImageResult = NULL;
    m_pComponentData = NULL;
    m_pCD = NULL;
    m_pConsoleVerb = NULL;

	m_selectedType = CCT_UNINITIALIZED;
	m_pSelectedFolderObject = NULL;

}

void CComponentImpl::LoadResources()
{
    // Load strings from resources
    m_column1.LoadString(IDS_NAME);
    m_column2.LoadString(IDS_TYPE);
}

HRESULT CComponentImpl::InitializeHeaders(CFolderObject* pFolderObject)
{
    HRESULT hr = S_OK;
    ASSERT(m_pHeader);

	// NOTICE: we ignore the cookie, keep always the same columns
    m_pHeader->InsertColumn(0, m_column1, LVCFMT_LEFT, 200);     // Name
    m_pHeader->InsertColumn(1, m_column2, LVCFMT_LEFT, 80);     // Type

    return hr;
}

HRESULT CComponentImpl::InitializeBitmaps(CFolderObject* pFolderObject)
{
    ASSERT(m_pImageResult != NULL);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CBitmap bmp16x16;
    CBitmap bmp32x32;

    // Load the bitmaps from the dll
    VERIFY(bmp16x16.LoadBitmap(IDB_DOMAIN_SMALL));
    VERIFY(bmp32x32.LoadBitmap(IDB_DOMAIN_LARGE));

    // Set the images
    HRESULT hr = m_pImageResult->ImageListSetStrip(reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp16x16)),
                      reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp32x32)),
                       0, RGB(128, 0, 0));
	if (FAILED(hr))
		return hr;
	return ((CComponentDataImpl*)m_pComponentData)->AddDomainIconToResultPane(m_pImageResult);
}


STDMETHODIMP CComponentImpl::GetDisplayInfo(LPRESULTDATAITEM pResult)
{
  ASSERT(pResult != NULL);

  CDomainObject* pDomain = reinterpret_cast<CDomainObject*>(pResult->lParam);
  if ( (pDomain != NULL) && (pResult->mask & RDI_STR) )
	{
		pResult->str = (LPWSTR)pDomain->GetDisplayString(pResult->nCol);
    TRACE(L"pResult->str = %s\n", pResult->str);
	}
	if ((pResult->mask & RDI_IMAGE) && (pResult->nCol == 0))
	{
		pResult->nImage = pDomain->GetImageIndex();
	}

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu Implementation


STDMETHODIMP CComponentImpl::AddMenuItems(LPDATAOBJECT pDataObject,
                                    LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                   long * pInsertionAllowed)
{
    return dynamic_cast<CComponentDataImpl*>(m_pComponentData)->
            AddMenuItems(pDataObject, pContextMenuCallback, pInsertionAllowed);
}

STDMETHODIMP CComponentImpl::Command(long nCommandID, LPDATAOBJECT pDataObject)
{
    return dynamic_cast<CComponentDataImpl*>(m_pComponentData)->
            Command(nCommandID, pDataObject);
}


HRESULT CComponentImpl::OnShow(CFolderObject* pFolderObject, LPARAM arg, LPARAM param)
{
    // Note - arg is TRUE when it is time to enumerate
    if (arg == TRUE)
    {
         // Show the headers for this nodetype
        InitializeHeaders(pFolderObject);
        Enumerate(pFolderObject, param);
    }
    return S_OK;
}

HRESULT CComponentImpl::OnAddImages(CFolderObject* pFolderObject, LPARAM arg, LPARAM param)
{
	return InitializeBitmaps(pFolderObject);
}


HRESULT CComponentImpl::OnPropertyChange(LPDATAOBJECT lpDataObject)
{
    return S_OK;
}

HRESULT CComponentImpl::OnUpdateView(LPDATAOBJECT lpDataObject)
{
    return S_OK;
}

void CComponentImpl::Enumerate(CFolderObject* pFolderObject, HSCOPEITEM pParent)
{
}



//////////////////////////////////////////////////////////////////////////
// CDomainSnapinAbout

CDomainSnapinAbout::CDomainSnapinAbout():
                        CSnapinAbout(IDS_SNAPINABOUT_DESCRIPTION,
									 IDI_DOMAIN,
									 IDB_DOMAIN_SMALL,
									 IDB_DOMAIN_SMALL,
									 IDB_DOMAIN_LARGE,
									 RGB(255,0,255))
						
{
}

////////////////////////////////////////////////////////////////////
// CHiddenWnd

const UINT CHiddenWnd::s_SheetCloseNotificationMessage =    WM_DSA_SHEET_CLOSE_NOTIFY;
const UINT CHiddenWnd::s_SheetCreateNotificationMessage =   WM_DSA_SHEET_CREATE_NOTIFY;

BOOL CHiddenWnd::Create()
{
  RECT rcPos;
  // NOTICE-2002/03/07-ericb - SecurityPush: zeroing a struct
  ZeroMemory(&rcPos, sizeof(RECT));
  HWND hWnd = CWindowImpl<CHiddenWnd>::Create( NULL, //HWND hWndParent, 
                      rcPos, //RECT& rcPos, 
                      NULL,  //LPCTSTR szWindowName = NULL, 
                      WS_POPUP,   //DWORD dwStyle = WS_CHILD | WS_VISIBLE, 
                      0x0,   //DWORD dwExStyle = 0, 
                      0      //UINT nID = 0 
                      );
  if (!hWnd)
  {
     TRACE(L"Hidden Window creation failed with error %d\n", GetLastError());
     return FALSE;
  }
  return TRUE;
}


LRESULT CHiddenWnd::OnSheetCloseNotification(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
  ASSERT(m_pCD != NULL);
  CFolderObject* pCookie = reinterpret_cast<CFolderObject*>(wParam);
  m_pCD->_OnSheetClose(pCookie);
  return 1;
}

LRESULT CHiddenWnd::OnSheetCreateNotification(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
  ASSERT(m_pCD != NULL);
  PDSA_SEC_PAGE_INFO pDsaSecondaryPageInfo = reinterpret_cast<PDSA_SEC_PAGE_INFO>(wParam);
  ASSERT(pDsaSecondaryPageInfo != NULL);
  PWSTR pwzDC = (PWSTR)lParam;

  m_pCD->_OnSheetCreate(pDsaSecondaryPageInfo, pwzDC);

  ::LocalFree(pDsaSecondaryPageInfo);

   if (pwzDC && !IsBadReadPtr(pwzDC, sizeof(PWSTR)))
   {
      ::LocalFree(pwzDC);
   }

  return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\domain\cdomain.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       cdomain.h
//
//--------------------------------------------------------------------------


#ifndef _CDOMAIN_H
#define _CDOMAIN_H

#include "resource.h"       // main symbols

extern const CLSID CLSID_DomainSnapinAbout;

extern const CLSID CLSID_DomainAdmin;    // In-Proc server GUID
extern const GUID cDefaultNodeType;        // Main NodeType GUID on numeric format
extern const wchar_t*  cszDefaultNodeType; // Main NodeType GUID on string format

extern const wchar_t* CCF_DS_DOMAIN_TREE_SNAPIN_INTERNAL;

/////////////////////////////////////////////////////////////////////////////
// macros

#define FREE_INTERNAL(pInternal) \
    ASSERT(pInternal != NULL); \
    do { if (pInternal != NULL) \
        GlobalFree(pInternal); } \
    while(0);

/////////////////////////////////////////////////////////////////////////////
// forward declarations
class CDomainObject;
class CComponentImpl;
class CComponentDataImpl;
class CHiddenWnd;
class CDataObject;

/////////////////////////////////////////////////////////////////////////////
// constants

// Note - This is the offset in my image list that represents the folder
const DOMAIN_IMAGE_DEFAULT_IDX = 0;
const DOMAIN_IMAGE_IDX = 1;

/////////////////////////////////////////////////////////////////////////////
// global functions

void DialogContextHelp(DWORD* pTable, HELPINFO* pHelpInfo);


/////////////////////////////////////////////////////////////////////////////
// CInternalFormatCracker

class CInternalFormatCracker
{
public:
	CInternalFormatCracker(CComponentDataImpl* pCD)
	{
        m_pCD = pCD;
		m_pInternalFormat = NULL;
	}
	~CInternalFormatCracker()
	{
		if (m_pInternalFormat != NULL)
			FREE_INTERNAL(m_pInternalFormat);
	}

	BOOL Extract(LPDATAOBJECT lpDataObject);
	BOOL GetContext(LPDATAOBJECT pDataObject, // input
					CFolderObject** ppFolderObject, // output
					DATA_OBJECT_TYPES* pType		// output
					);
	INTERNAL* GetInternal()
	{
		return m_pInternalFormat;
	}

private:
	INTERNAL* m_pInternalFormat;
    CComponentDataImpl*		m_pCD;
};



/////////////////////////////////////////////////////////////////////////////
// CComponentDataImpl (i.e. scope pane side)

class CRootFolderObject; // fwd decl

class CComponentDataImpl:
    public IComponentData,
    public IExtendPropertySheet,
    public IExtendContextMenu,
    public ISnapinHelp2,
    public CComObjectRoot,
    public CComCoClass<CComponentDataImpl, &CLSID_DomainAdmin>
{

	friend class CComponentImpl;

BEGIN_COM_MAP(CComponentDataImpl)
	COM_INTERFACE_ENTRY(IComponentData)
	COM_INTERFACE_ENTRY(IExtendPropertySheet)
	COM_INTERFACE_ENTRY(IExtendContextMenu)
  COM_INTERFACE_ENTRY(ISnapinHelp2)
END_COM_MAP()

  DECLARE_REGISTRY_CLSID()

  friend class CComponentImpl;
	friend class CDataObject;

	CComponentDataImpl();
	HRESULT FinalConstruct();
	~CComponentDataImpl();
	void FinalRelease();	

public:
	// IComponentData interface members
	STDMETHOD(Initialize)(LPUNKNOWN pUnknown);
	STDMETHOD(CreateComponent)(LPCOMPONENT* ppComponent);
	STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
	STDMETHOD(Destroy)();
	STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
	STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM* pScopeDataItem);
	STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

	// IExtendPropertySheet interface
public:
	STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
								 LONG_PTR handle,
								 LPDATAOBJECT lpIDataObject);
	STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);

	// IExtendContextMenu
public:
	STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject,
						  LPCONTEXTMENUCALLBACK pCallbackUnknown,
						  long *pInsertionAllowed);
	STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);

  // ISnapinHelp2 interface members
  STDMETHOD(GetHelpTopic)(LPOLESTR* lpCompiledHelpFile);
  STDMETHOD(GetLinkedTopics)(LPOLESTR* lpCompiledHelpFile);

	// Notify handler declarations
private:
	HRESULT OnExpand(CFolderObject* pFolderObject, LPARAM arg, LPARAM param);
	HRESULT OnPropertyChange(LPARAM param);

#if DBG==1
public:
	ULONG InternalAddRef()
	{
	  return CComObjectRoot::InternalAddRef();
	}
	ULONG InternalRelease()
	{
	  return CComObjectRoot::InternalRelease();
	}
#endif // DBG==1

public:
  MyBasePathsInfo* GetBasePathsInfo() { return &m_basePathsInfo;}
	CRootFolderObject*		GetRootFolder() { return &m_rootFolder;}
  CDsDisplaySpecOptionsCFHolder* GetDsDisplaySpecOptionsCFHolder()
          { return &m_DsDisplaySpecOptionsCFHolder;}

	HRESULT AddFolder(CFolderObject* pFolderObject,
									  HSCOPEITEM pParentScopeItem,
									  BOOL bHasChildren);
	HRESULT AddDomainIcon();
	HRESULT AddDomainIconToResultPane(LPIMAGELIST lpImageList);
	int GetDomainImageIndex();

  HRESULT GetMainWindow(HWND* phWnd) { return m_pConsole->GetMainWindow(phWnd);}

	// Scope item creation helpers
private:
	void EnumerateScopePane(CFolderObject* pFolderObject, HSCOPEITEM pParent);
	BOOL IsScopePaneNode(LPDATAOBJECT lpDataObject);

private:
	LPCONSOLENAMESPACE      m_pConsoleNameSpace;
	LPCONSOLE               m_pConsole;

	void HandleStandardVerbsHelper(CComponentImpl* pComponentImpl,
									LPCONSOLEVERB pConsoleVerb,
									BOOL bScope, BOOL bSelect,
									CFolderObject* pFolderObject,
                                    DATA_OBJECT_TYPES type);
	void OnRefreshVerbHandler(CFolderObject* pFolderObject, 
                            CComponentImpl* pComponentImpl,
                            BOOL bBindAgain=FALSE);


	void _OnSheetClose(CFolderObject* pCookie);
  void _OnSheetCreate(PDSA_SEC_PAGE_INFO pDsaSecondaryPageInfo, PWSTR pwzDC);

  // sheet API's
  void _SheetLockCookie(CFolderObject* pCookie);
  void _SheetUnlockCookie(CFolderObject* pCookie);

public:
  HWND GetHiddenWindow();

  CCookieSheetTable* GetCookieSheet() { return &m_sheetCookieTable; }
  void SetInit() { m_bInitSuccess = TRUE; }

protected:
  void _DeleteHiddenWnd();
  CHiddenWnd*      m_pHiddenWnd;

private:

  friend class CHiddenWnd;      // to access thread notification handlers

private:
	CRootFolderObject		m_rootFolder;		// root folder
  MyBasePathsInfo    m_basePathsInfo; // container of base path info
  CDsDisplaySpecOptionsCFHolder m_DsDisplaySpecOptionsCFHolder;  // cached clipbard format.

	HICON				m_hDomainIcon;
  BOOL        m_bInitSuccess;

  friend class CRootFolderObject;
 	CCookieSheetTable m_sheetCookieTable; // table of cookies having a sheet up
  CSecondaryPagesManager<CDomainObject> m_secondaryPagesManager;
};



/////////////////////////////////////////////////////////////////////////////
// CComponentImpl (i.e. result pane side)

class CComponentImpl :
    public IComponent,
    public IExtendContextMenu,
    public IResultDataCompareEx,
    public CComObjectRoot
{
public:
    CComponentImpl();
    ~CComponentImpl();

BEGIN_COM_MAP(CComponentImpl)
    COM_INTERFACE_ENTRY(IComponent)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IResultDataCompareEx)
END_COM_MAP()

    friend class CDataObject;

// IComponent interface members
public:
	STDMETHOD(Initialize)(LPCONSOLE lpConsole);
	STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
	STDMETHOD(Destroy)(MMC_COOKIE cookie);
	STDMETHOD(GetResultViewType)(MMC_COOKIE cookie,  LPOLESTR* ppViewType,
							   long *pViewOptions);
	STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
						LPDATAOBJECT* ppDataObject);

	STDMETHOD(GetDisplayInfo)(RESULTDATAITEM*  pResultDataItem);
	STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

// IResultDataCompareEx
	STDMETHOD(Compare)(RDCOMPARE* prdc, int* pnResult);

// Helpers for CComponentImpl
public:
    void SetIComponentData(CComponentDataImpl* pData);
	void SetSelection(CFolderObject* pSelectedFolderObject, DATA_OBJECT_TYPES selectedType)
	{
		m_pSelectedFolderObject = pSelectedFolderObject;
		m_selectedType = selectedType;
	}

#if DBG==1
public:
    int dbg_cRef;
    ULONG InternalAddRef()
    {
        ++dbg_cRef;
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        --dbg_cRef;
        return CComObjectRoot::InternalRelease();
    }
#endif // DBG==1

// Notify event handlers
protected:
    HRESULT OnShow(CFolderObject* pFolderObject, LPARAM arg, LPARAM param);
	HRESULT OnAddImages(CFolderObject* pFolderObject, LPARAM arg, LPARAM param);
    HRESULT OnPropertyChange(LPDATAOBJECT lpDataObject);
    HRESULT OnUpdateView(LPDATAOBJECT lpDataObject);

// IExtendContextMenu
public:
	STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject,
							LPCONTEXTMENUCALLBACK pCallbackUnknown,
							long *pInsertionAllowed);
	STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);

// Helper functions
protected:
    BOOL IsEnumerating(LPDATAOBJECT lpDataObject);
    void Construct();
    void LoadResources();
    HRESULT InitializeHeaders(CFolderObject* pFolderObject);

    void Enumerate(CFolderObject* pFolderObject, HSCOPEITEM pParent);
	void Refresh(CFolderObject* pFolderObject);

// Result pane helpers
    HRESULT InitializeBitmaps(CFolderObject* pFolderObject);

// UI Helpers
    void HandleStandardVerbs(BOOL bScope, BOOL bSelect,
                            CFolderObject* pFolderObject, DATA_OBJECT_TYPES type);

// Interface pointers
protected:
    LPCONSOLE           m_pConsole;   // Console's IFrame interface
    LPHEADERCTRL        m_pHeader;  // Result pane's header control interface
    LPCOMPONENTDATA     m_pComponentData;
    CComponentDataImpl* m_pCD;
    LPRESULTDATA        m_pResult;      // My interface pointer to the result pane
    LPIMAGELIST         m_pImageResult; // My interface pointer to the result pane image list
    LPCONSOLEVERB       m_pConsoleVerb; // pointer the console verb

// Header titles for each nodetype(s)
protected:
    CString m_column1;      // Name
    CString m_column2;      // Type

// state variables for this window
	CFolderObject*		m_pSelectedFolderObject;	// item selection (MMC_SELECT)
	DATA_OBJECT_TYPES	m_selectedType;				// matching m_pSelectedNode
};

inline void CComponentImpl::SetIComponentData(CComponentDataImpl* pData)
{
    ASSERT(pData);
    ASSERT(m_pCD == NULL);
    ASSERT(m_pComponentData == NULL);
    m_pCD = pData;
    LPUNKNOWN pUnk = pData->GetUnknown();
    HRESULT hr;

    hr = pUnk->QueryInterface(IID_IComponentData, reinterpret_cast<void**>(&m_pComponentData));

    ASSERT(hr == S_OK);
}


//////////////////////////////////////////////////////////////////////////
// CDomainSnapinAbout

class CDomainSnapinAbout :
	public CSnapinAbout,
	public CComCoClass<CDomainSnapinAbout, &CLSID_DomainSnapinAbout>

{
public:
  DECLARE_REGISTRY_CLSID()
    CDomainSnapinAbout();
};

////////////////////////////////////////////////////////////////////
// CHiddenWnd

class CHiddenWnd : public CWindowImpl<CHiddenWnd>
{
public:
  DECLARE_WND_CLASS(L"DSAHiddenWindow")

  static const UINT s_SheetCloseNotificationMessage;
  static const UINT s_SheetCreateNotificationMessage;

  CHiddenWnd(CComponentDataImpl* pCD)
  {
    ASSERT(pCD != NULL);
    m_pCD = pCD;
  }

	BOOL Create(); 	
	
  // message handlers
  LRESULT OnSheetCloseNotification(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnSheetCreateNotification(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);


  BEGIN_MSG_MAP(CHiddenWnd)
    MESSAGE_HANDLER( CHiddenWnd::s_SheetCloseNotificationMessage, OnSheetCloseNotification )
    MESSAGE_HANDLER( CHiddenWnd::s_SheetCreateNotificationMessage, OnSheetCreateNotification )
  END_MSG_MAP()

private:
  CComponentDataImpl* m_pCD;
};


#endif // _CDOMAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\domain\dataobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dataobj.h
//
//--------------------------------------------------------------------------


#ifndef _DATAOBJ_H
#define _DATAOBJ_H


class CDataObject : public IDataObject, public CComObjectRoot
{
public:
// ATL Maps
DECLARE_NOT_AGGREGATABLE(CDataObject)
BEGIN_COM_MAP(CDataObject)
	COM_INTERFACE_ENTRY(IDataObject)
END_COM_MAP()

// Construction/Destruction
    CDataObject() : m_lNotifyHandle(0), m_hwndParentSheet(NULL)
	{
		m_pComponentData = NULL;
	};

    ~CDataObject()
	{
		if (m_pComponentData != NULL)
		{
			m_pComponentData->Release();
			m_pComponentData = NULL;
		}
	};

	void SetIComponentData(CComponentDataImpl* pData)
	{
		ASSERT(pData);
		ASSERT(m_pComponentData == NULL);
		LPUNKNOWN pUnk = pData->GetUnknown();
		HRESULT hr;

		hr = pUnk->QueryInterface(IID_IComponentData, reinterpret_cast<void**>(&m_pComponentData));

		ASSERT(hr == S_OK);
	}

public:
	// Clipboard formats that are required by the console
    static CLIPFORMAT    m_cfNodeType;
    static CLIPFORMAT    m_cfNodeTypeString;
    static CLIPFORMAT    m_cfDisplayName;
    static CLIPFORMAT    m_cfCoClass;
	// internal clipboard format
    static CLIPFORMAT    m_cfInternal;

    // Property Page Clipboard formats
    static CLIPFORMAT m_cfDsObjectNames;
    static CLIPFORMAT m_cfDsDisplayOptions;
    static CLIPFORMAT m_cfGetIPropSheetCfg;


// Standard IDataObject methods
public:
// Implemented
    STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium);
    STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);
    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc);

    ULONG InternalAddRef()
    {
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        return CComObjectRoot::InternalRelease();
    }

// Not Implemented
private:
    STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc)
    { return E_NOTIMPL; };

    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };

    STDMETHOD(SetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease);

    STDMETHOD(DAdvise)(LPFORMATETC lpFormatetc, DWORD advf,
                LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(DUnadvise)(DWORD dwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };

// Implementation
public:
    void SetType(DATA_OBJECT_TYPES type)
    { ASSERT(m_internal.m_type == CCT_UNINITIALIZED); m_internal.m_type = type; }

    void SetCookie(MMC_COOKIE cookie) { m_internal.m_cookie = cookie; }
    void SetString(LPCTSTR lpString) { m_internal.m_string = lpString; }
    void SetClass(LPCTSTR lpString) { m_internal.m_class = lpString; }

private:
    HRESULT CreateNodeTypeData(LPSTGMEDIUM lpMedium);
    HRESULT CreateNodeTypeStringData(LPSTGMEDIUM lpMedium);
    HRESULT CreateDisplayName(LPSTGMEDIUM lpMedium);
    HRESULT CreateInternal(LPSTGMEDIUM lpMedium);
    HRESULT CreateCoClassID(LPSTGMEDIUM lpMedium);

    HRESULT Create(const void* pBuffer, int len, LPSTGMEDIUM lpMedium);

    INTERNAL m_internal;

	LPCOMPONENTDATA     m_pComponentData;   // pointer to the IComponetData object

    LONG_PTR m_lNotifyHandle;
    HWND     m_hwndParentSheet;
};


#endif // _DATAOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\domain\dbg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dbg.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////
// debug helpers

#if defined(_USE_DSA_TRACE) || defined(_USE_DSA_ASSERT) || defined(_USE_DSA_TIMER)

UINT GetInfoFromIniFile(LPCWSTR lpszKey, INT nDefault = 0)
{
  LPCWSTR lpszFile = L"\\system32\\domadmin.ini";

  WCHAR szFilePath[2*MAX_PATH];
  UINT nLen = ::GetSystemWindowsDirectory(szFilePath, 2*MAX_PATH);
  if (nLen == 0)
    return nDefault;

  // NOTICE-2002/03/07-ericb - SecurityPush: reviewed, usage is safe.
  wcscat(szFilePath, lpszFile);
  return ::GetPrivateProfileInt(L"Debug", lpszKey, nDefault, szFilePath);
}
#endif


#if defined(_USE_DSA_TRACE)

#ifdef DEBUG_DSA
DWORD g_dwTrace = 0x1;
#else
DWORD g_dwTrace = ::GetInfoFromIniFile(L"Trace");
#endif

void DSATrace(LPCTSTR lpszFormat, ...)
{
  if (g_dwTrace == 0)
    return;

  if (!lpszFormat)
  {
     ::OutputDebugString(L"null pointer passed to DSATrace!\n");
     return;
  }

  va_list args;
  va_start(args, lpszFormat);

  int nBuf;
  WCHAR szBuffer[512] = {0};

    // NOTICE-2002/03/07-ericb - SecurityPush: reviewed
  nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer)/sizeof(WCHAR)-1, lpszFormat, args);

  // was there an error? was the expanded string too long?
  ASSERT(nBuf >= 0);
  ::OutputDebugString(szBuffer);

  va_end(args);
}

#endif // defined(_USE_DSA_TRACE)

#if defined(_USE_DSA_ASSERT)

DWORD g_dwAssert = ::GetInfoFromIniFile(L"Assert");

BOOL DSAAssertFailedLine(LPCSTR lpszFileName, int nLine)
{
  if (g_dwAssert == 0)
    return FALSE;

  if (!lpszFileName)
  {
     ::OutputDebugString(L"null pointer passed to DSAAssertFailedLine!\n");
     return FALSE;
  }

  WCHAR szMessage[_MAX_PATH*2];

  // assume the debugger or auxiliary port
  // NOTICE-2002/03/07-ericb - SecurityPush: reviewed, usage is safe.
  wsprintf(szMessage, _T("Assertion Failed: File %hs, Line %d\n"),
           lpszFileName, nLine);
  OutputDebugString(szMessage);

  // display the assert
  int nCode = ::MessageBox(NULL, szMessage, _T("Assertion Failed!"),
                           MB_TASKMODAL|MB_ICONHAND|MB_ABORTRETRYIGNORE|MB_SETFOREGROUND);

  OutputDebugString(L"after message box\n");
  if (nCode == IDIGNORE)
  {
    return FALSE;   // ignore
  }

  if (nCode == IDRETRY)
  {
    return TRUE;    // will cause DebugBreak
  }

  abort();     // should not return 
  return TRUE;

}
#endif // _USE_DSA_ASSERT

#if defined(_USE_DSA_TIMER)

#ifdef TIMER_DSA
DWORD g_dwTimer = 0x1;
#else
DWORD g_dwTimer = ::GetInfoFromIniFile(L"Timer");
#endif

DWORD StartTicks = ::GetTickCount();
DWORD LastTicks = 0;

void DSATimer(LPCTSTR lpszFormat, ...)
{
   if (g_dwTimer == 0)
      return;
   if (!lpszFormat)
   {
      ::OutputDebugString(L"null pointer passed to DSATimer!\n");
      return;
   }

   va_list args;
   va_start(args, lpszFormat);

   int nBuf;
   WCHAR szBuffer[512] = {0}, szBuffer2[512];

   DWORD CurrentTicks = GetTickCount() - StartTicks;
   DWORD Interval = CurrentTicks - LastTicks;
   LastTicks = CurrentTicks;

   nBuf = swprintf(szBuffer2,
                   L"%d, (%d): %ws", CurrentTicks,
                   Interval, lpszFormat);
   nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer)/sizeof(WCHAR)-1, 
                          szBuffer2, 
                          args);

   // was there an error? was the expanded string too long?
   ASSERT(nBuf >= 0);
   ::OutputDebugString(szBuffer);

   va_end(args);
}
#endif // _USE_DSA_TIMER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\domain\dataobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dataobj.cpp
//
//--------------------------------------------------------------------------



#include "stdafx.h"
#include "domobj.h" 
#include "cdomain.h"
#include "dataobj.h"

#include <dsgetdc.h>
#include <lm.h>

extern "C" 
{
#include <lmapibuf.h>
}


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////////
// Sample code to show how to Create DataObjects
// Minimal error checking for clarity

///////////////////////////////////////////////////////////////////////////////
// Snap-in NodeType in both GUID format and string format
// Note - Typically there is a node type for each different object, sample
// only uses one node type.

// Clipboard formats that are required by the console
CLIPFORMAT CDataObject::m_cfNodeType       = (CLIPFORMAT)RegisterClipboardFormat(CCF_NODETYPE);
CLIPFORMAT CDataObject::m_cfNodeTypeString = (CLIPFORMAT)RegisterClipboardFormat(CCF_SZNODETYPE);  
CLIPFORMAT CDataObject::m_cfDisplayName    = (CLIPFORMAT)(CLIPFORMAT)RegisterClipboardFormat(CCF_DISPLAY_NAME); 
CLIPFORMAT CDataObject::m_cfCoClass        = (CLIPFORMAT)RegisterClipboardFormat(CCF_SNAPIN_CLASSID);

// internal clipboard format
CLIPFORMAT CDataObject::m_cfInternal       = (CLIPFORMAT)RegisterClipboardFormat(CCF_DS_DOMAIN_TREE_SNAPIN_INTERNAL); 

// Property Page Clipboard formats
CLIPFORMAT CDataObject::m_cfDsObjectNames = 
                                (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DSOBJECTNAMES);
CLIPFORMAT CDataObject::m_cfDsDisplayOptions =
                        (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DS_DISPLAY_SPEC_OPTIONS);
CLIPFORMAT CDataObject::m_cfGetIPropSheetCfg =
                        (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DS_PROPSHEETCONFIG);

/////////////////////////////////////////////////////////////////////////////
// CDataObject implementations


STDMETHODIMP CDataObject::GetDataHere(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_CLIPFORMAT;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Based on the CLIPFORMAT write data to the stream
    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    if(cf == m_cfNodeType)
    {
        hr = CreateNodeTypeData(lpMedium);
    }
    else if(cf == m_cfNodeTypeString) 
    {
        hr = CreateNodeTypeStringData(lpMedium);
    }
    else if (cf == m_cfDisplayName)
    {
        hr = CreateDisplayName(lpMedium);
    }
    else if (cf == m_cfInternal)
    {
        hr = CreateInternal(lpMedium);
    }
    else if (cf == m_cfCoClass)
    {
        hr = CreateCoClassID(lpMedium);
    }

	return hr;
}

STDMETHODIMP CDataObject::GetData(LPFORMATETC pFormatEtc, LPSTGMEDIUM pMedium)
{
  if (IsBadWritePtr(pMedium, sizeof(STGMEDIUM)))
  {
    return E_INVALIDARG;
  }
  if (!(pFormatEtc->tymed & TYMED_HGLOBAL))
  {
    return DV_E_TYMED;
  }

  CComponentDataImpl* pCD = dynamic_cast<CComponentDataImpl*>(m_pComponentData);
  if (pCD == NULL)
  {
    return E_FAIL;
  }

  if (pFormatEtc->cfFormat == m_cfDsObjectNames)
  {
    // Return the object name and class.
    CDomainObject* pDomainObject = reinterpret_cast<CDomainObject*>(m_internal.m_cookie);
    if (pDomainObject == NULL)
    {
      return E_INVALIDARG;
    }

    LPCWSTR lpszNamingContext = pDomainObject->GetNCName();
    LPCWSTR lpszClass = pDomainObject->GetClass();

    // build an LDAP path out of the DN
    CString strPath;
    if (pDomainObject->PdcAvailable())
    {
       strPath = L"LDAP://";
       strPath += pDomainObject->GetPDC();
       strPath += L"/";
       strPath += lpszNamingContext;
       TRACE(L"DomAdmin::CDataObject::GetData domain path: %s\n", (PCWSTR)strPath);
    }
    else
    {
      pCD->GetBasePathsInfo()->ComposeADsIPath(strPath, lpszNamingContext);
    }

    int cbPath  = sizeof(TCHAR) * (_tcslen(strPath) + 1);
    int cbClass = sizeof(TCHAR) * (_tcslen(lpszClass) + 1);
    int cbStruct = sizeof(DSOBJECTNAMES);

    LPDSOBJECTNAMES pDSObj;

    pDSObj = (LPDSOBJECTNAMES)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
                                          cbStruct + cbPath + cbClass);

    if (pDSObj == NULL)
    {
      return STG_E_MEDIUMFULL;
    }

    pDSObj->clsidNamespace = CLSID_DomainAdmin;
    pDSObj->cItems = 1;
    pDSObj->aObjects[0].dwFlags = pDomainObject->PdcAvailable() ? 0 : DSOBJECT_READONLYPAGES;
    pDSObj->aObjects[0].dwProviderFlags = 0;
    pDSObj->aObjects[0].offsetName = cbStruct;
    pDSObj->aObjects[0].offsetClass = cbStruct + cbPath;

    // NOTICE-2002/03/07-ericb - SecurityPush: reviewed, usage is safe.
    _tcscpy((LPTSTR)((BYTE *)pDSObj + cbStruct), strPath);
    _tcscpy((LPTSTR)((BYTE *)pDSObj + cbStruct + cbPath), lpszClass);

    pMedium->hGlobal = (HGLOBAL)pDSObj;
  }
  else if (pFormatEtc->cfFormat == m_cfDsDisplayOptions)
  {
    // Get the DSDISPLAYSPECOPTIONS structure.
    // Use the value cached in the component data.
    if (pCD != NULL)
    {
      PDSDISPLAYSPECOPTIONS pDsDisplaySpecOptions = 
          pCD->GetDsDisplaySpecOptionsCFHolder()->Get();
      pMedium->hGlobal = (HGLOBAL)pDsDisplaySpecOptions;
      if (pDsDisplaySpecOptions == NULL)
        return E_OUTOFMEMORY;
    }
    else
    {
      return E_FAIL;
    }
  }
  else if (pFormatEtc->cfFormat == m_cfGetIPropSheetCfg)
  {
	  // Added by JEFFJON 1/26/99
		PPROPSHEETCFG pSheetCfg;

		pSheetCfg = (PPROPSHEETCFG)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
															sizeof(PROPSHEETCFG));
		if (pSheetCfg == NULL)
		  {
			 return STG_E_MEDIUMFULL;
		  }

		pSheetCfg->lNotifyHandle = m_lNotifyHandle;
		pSheetCfg->hwndParentSheet = m_hwndParentSheet;
		pSheetCfg->hwndHidden = pCD->GetHiddenWindow();

		CFolderObject* pFolderObject = reinterpret_cast<CFolderObject*>(m_internal.m_cookie);
		pSheetCfg->wParamSheetClose = reinterpret_cast<WPARAM>(pFolderObject);

		pMedium->hGlobal = (HGLOBAL)pSheetCfg;
	}

  else
  {
      return DV_E_FORMATETC;
  }

  pMedium->tymed = TYMED_HGLOBAL;
  pMedium->pUnkForRelease = NULL;

  return S_OK;
}
    
STDMETHODIMP
CDataObject::SetData(FORMATETC * pFormatEtc, STGMEDIUM * pMedium,
                       BOOL fRelease)
{
    if (pFormatEtc->cfFormat == m_cfGetIPropSheetCfg)
    {
        if (!(pFormatEtc->tymed & TYMED_HGLOBAL))
        {
            return DV_E_TYMED;
        }

        PPROPSHEETCFG pSheetCfg = (PPROPSHEETCFG)pMedium->hGlobal;

        // don't overwrite existing data.

        if (0 == m_lNotifyHandle)
        {
          m_lNotifyHandle = pSheetCfg->lNotifyHandle;
        }

        if (NULL == m_hwndParentSheet)
        {
          m_hwndParentSheet = pSheetCfg->hwndParentSheet;
        }

        if (fRelease)
        {
            GlobalFree(pMedium->hGlobal);
        }
        return S_OK;
    }
    else
    {
        return DV_E_FORMATETC;
    }
}


STDMETHODIMP CDataObject::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
{
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CDataObject creation members

HRESULT CDataObject::Create(const void* pBuffer, int len, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_TYMED;

    // Do some simple validation
    if (pBuffer == NULL || lpMedium == NULL)
        return E_POINTER;

    // Make sure the type medium is HGLOBAL
    if (lpMedium->tymed == TYMED_HGLOBAL)
    {
        // Create the stream on the hGlobal passed in
        LPSTREAM lpStream;
        hr = CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream);

        if (SUCCEEDED(hr))
        {
            // Write to the stream the number of bytes
            unsigned long written;
		    hr = lpStream->Write(pBuffer, len, &written);

            // Because we told CreateStreamOnHGlobal with 'FALSE', 
            // only the stream is released here.
            // Note - the caller (i.e. snap-in, object) will free the HGLOBAL 
            // at the correct time.  This is according to the IDataObject specification.
            lpStream->Release();
        }
    }

    return hr;
}

HRESULT CDataObject::CreateNodeTypeData(LPSTGMEDIUM lpMedium)
{
    // Create the node type object in GUID format
    return Create(reinterpret_cast<const void*>(&cDefaultNodeType), sizeof(GUID), lpMedium);
}

HRESULT CDataObject::CreateNodeTypeStringData(LPSTGMEDIUM lpMedium)
{
    // Create the node type object in GUID string format
    // NOTICE-2002/03/07-ericb - SecurityPush: cszDefaultNodeType is a static string.
    return Create(cszDefaultNodeType, ((wcslen(cszDefaultNodeType)+1) * sizeof(wchar_t)), lpMedium);
}

HRESULT CDataObject::CreateDisplayName(LPSTGMEDIUM lpMedium)
{
    // This is the display named used in the scope pane and snap-in manager

    // Load the name from resource
    // Note - if this is not provided, the console will used the snap-in name

    CString szDispName;
    szDispName.LoadString(IDS_NODENAME);

    return Create(szDispName, ((szDispName.GetLength()+1) * sizeof(wchar_t)), lpMedium);
}

HRESULT CDataObject::CreateInternal(LPSTGMEDIUM lpMedium)
{

    return Create(&m_internal, sizeof(INTERNAL), lpMedium);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDSDataObject::CreateCoClassID
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
HRESULT
CDataObject::CreateCoClassID(LPSTGMEDIUM lpMedium)
{
  CLSID CoClassID;
  CoClassID = CLSID_DomainAdmin;
  return Create(&CoClassID, sizeof(CLSID), lpMedium);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\domain\domain.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       domain.h
//
//--------------------------------------------------------------------------


#ifndef _DOMAIN_H
#define _DOMAIN_H

///////////////////////////////////////////////////////////////////////
// CDsUiWizDLL

class CDsUiWizDLL
{
public:
	CDsUiWizDLL();
	~CDsUiWizDLL();
	
	BOOL Load();

	HRESULT TrustWizard(HWND hWndParent = NULL, LPCWSTR lpsz = NULL);

private:
	HMODULE m_hLibrary;
	FARPROC m_pfFunction;

};

#endif // _DOMAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\domain\domobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       domobj.cpp
//
//--------------------------------------------------------------------------



#include "stdafx.h"
#include "domobj.h"
#include "domobjui.h"
#include "cdomain.h"
#include "domain.h"
#include "proppage.h"
#include "notify.h"





#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


///////////////////////////////////////////////////////////////////////
// global helper functions




int _MessageBox(HWND hWnd,          // handle to owner window
                LPCTSTR lpText,     // pointer to text in message box
                UINT uType)         // style of message box
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  CString szCaption;
  szCaption.LoadString(AFX_IDS_APP_TITLE);
  return ::MessageBox(hWnd, lpText, szCaption, uType);
}
 






void ReportError(HWND hWnd, UINT nMsgID, HRESULT hr)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  LPTSTR ptzSysMsg = NULL;
  int cch = 0;
  int retval = MB_OK;

  // load message for this HRESULT
  cch = cchLoadHrMsg( hr, &ptzSysMsg, TRUE );
  
  CString szError;
  if (cch == 0)
  {
    // could not get a message string, format the raw hr value
    CString s;
    s.LoadString(IDS_FAILURE_UNK);
    szError.Format((LPCWSTR)s, hr);
  }
  else
  {
    szError = ptzSysMsg;
  }

  // format message string with
  CString szFmt;
  szFmt.LoadString(nMsgID);
  CString szMsg;
  szMsg.Format((LPCWSTR)szFmt, (LPCWSTR)szError);
  _MessageBox(hWnd, szMsg, MB_OK|MB_ICONERROR);

  // cleanup
  if (NULL != ptzSysMsg)
      LocalFree(ptzSysMsg);
}



///////////////////////////////////////////////////////////////////////

//CDsUiWizDLL g_dsUiWizDLL;

enum
{
    // Identifiers for each of the commands to be inserted into the context menu.
    IDM_MANAGE,
    IDM_TRUST_WIZ,
    IDM_RETARGET,
    IDM_EDIT_FSMO,
    IDM_DOMAIN_VERSION,
    IDM_FOREST_VERSION
};


HRESULT _AddMenuItemHelper(IContextMenuCallback* pIContextMenuCallback,
                     UINT nResourceID, // contains text and status text seperated by '\n'
                     long lCommandID,
                     long lInsertionPointID,
                     long fFlags = 0,
                     long fSpecialFlags = 0)
{
    ASSERT( pIContextMenuCallback != NULL );

    // load the resource
    CString strText;
    strText.LoadString(nResourceID);
    ASSERT( !strText.IsEmpty() );

    // split the resource into the menu text and status text
    CString strStatusText;
    int iSeparator = strText.Find(_T('\n'));
    if (0 > iSeparator)
    {
        ASSERT( FALSE );
        strStatusText = strText;
    }
    else
    {
        strStatusText = strText.Right( strText.GetLength()-(iSeparator+1) );
        strText = strText.Left( iSeparator );
    }

    // add the menu item
    USES_CONVERSION;
    CONTEXTMENUITEM contextmenuitem;
    ::ZeroMemory( &contextmenuitem, sizeof(contextmenuitem) );
    contextmenuitem.strName = T2OLE(const_cast<LPTSTR>((LPCTSTR)strText));
    contextmenuitem.strStatusBarText = T2OLE(const_cast<LPTSTR>((LPCTSTR)strStatusText));
    contextmenuitem.lCommandID = lCommandID;
    contextmenuitem.lInsertionPointID = lInsertionPointID;
    contextmenuitem.fFlags = fFlags;
    contextmenuitem.fSpecialFlags = fSpecialFlags;
    HRESULT hr = pIContextMenuCallback->AddItem( &contextmenuitem );
    ASSERT(hr == S_OK);
  
  return hr;
}


///////////////////////////////////////////////////////////////////////
// CDomainTreeBrowser

HRESULT CDomainTreeBrowser::Bind(MyBasePathsInfo* pInfo)
{
  TRACE(L"CDomainTreeBrowser::Bind()\n");

  ASSERT(pInfo != NULL);

  _Reset();
  HRESULT hr = S_OK;

  // create a browse object
  hr = ::CoCreateInstance(CLSID_DsDomainTreeBrowser,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IDsBrowseDomainTree,
            (LPVOID*)&m_spIDsBrowseDomainTree);
  if (FAILED(hr))
  {
    TRACE(L"CoCreateInstance(CLSID_DsDomainTreeBrowser, ...) failed with hr = 0x%x\n");
     goto error;
  }

  // set the target computer
  hr = m_spIDsBrowseDomainTree->SetComputer(pInfo->GetServerName(), NULL, NULL);
  TRACE(L"m_spIDsBrowseDomainTree->SetComputer(%s, NULL, NULL) returned hr = 0x%x\n", 
                    pInfo->GetServerName(), hr);

  if (FAILED(hr))
     goto error;

  ASSERT(SUCCEEDED(hr));
  return hr; // all was fine

error:
  // things went wrong, clear all
  _Reset();
  return hr;
}


HRESULT CDomainTreeBrowser::GetData()
{
  ASSERT(m_spIDsBrowseDomainTree != NULL);

   HRESULT hr = S_OK;

   PDOMAIN_TREE pNewDomains = NULL;
   m_spIDsBrowseDomainTree->FlushCachedDomains();
   DWORD dwFlags = DBDTF_RETURNFQDN;
   hr = m_spIDsBrowseDomainTree->GetDomains(&pNewDomains, dwFlags);
   TRACE(L"m_spIDsBrowseDomainTree->GetDomains(...) returned hr = 0x%x\n", hr);

   if (SUCCEEDED(hr) && (pNewDomains != NULL))
   {
      _FreeDomains();
      m_pDomains = pNewDomains;
   }
   return hr;
}


///////////////////////////////////////////////////////////////////////
// CFolderObject

CFolderObject::~CFolderObject()
{
   RemoveAllChildren();
}


BOOL CFolderObject::AddChild(CFolderObject* pChildFolderObject)
{
   return (m_childList.AddTail(pChildFolderObject) != NULL);
}

void CFolderObject::RemoveAllChildren()
{
   while (!m_childList.IsEmpty())
      delete m_childList.RemoveHead();
}

void CFolderObject::IncrementSheetLockCount() 
{
   ++m_nSheetLockCount;
   if (m_pParentFolder != NULL)
      m_pParentFolder->IncrementSheetLockCount();
}

void CFolderObject::DecrementSheetLockCount() 
{
  ASSERT(m_nSheetLockCount > 0);
   --m_nSheetLockCount; 
   if (m_pParentFolder != NULL) 
      m_pParentFolder->DecrementSheetLockCount();
}

BOOL CFolderObject::_WarningOnSheetsUp(CComponentDataImpl* pCD)
{
   if (!IsSheetLocked()) 
      return FALSE; // no warning, all is cool

   // warning to user that oeration cannot be performed
   CThemeContextActivator activator;
   AfxMessageBox(IDS_SHEETS_UP_DELETE, MB_OK);
      ASSERT(FALSE);

   // need to bring sheets on the foreground
   pCD->GetCookieSheet()->BringToForeground(this, pCD);

   return TRUE;
}



///////////////////////////////////////////////////////////////////////
// CRootFolderObject

CRootFolderObject::CRootFolderObject(CComponentDataImpl* pCD) :
   m_pEnterpriseRoot(NULL)
{
	m_pCD = pCD;
}


HRESULT CRootFolderObject::Bind() 
{ 
  return m_domainTreeBrowser.Bind(m_pCD->GetBasePathsInfo()); 
}



HRESULT CRootFolderObject::GetData()
{
   HRESULT hr = m_domainTreeBrowser.GetData();
   if (FAILED(hr))
      return hr;

   // firs time, try to load the domain icon
   VERIFY(SUCCEEDED(m_pCD->AddDomainIcon()));

   RemoveAllChildren(); // clear the UI structures
   return hr;
}


HRESULT CRootFolderObject::EnumerateRootFolder(CComponentDataImpl* pComponentData)
{
   TRACE(L"CRootFolderObject::EnumerateRootFolder()\n");
   if (!m_domainTreeBrowser.HasData())
   {
      TRACE(L"m_domainTreeBrowser.HasData() == FALSE \n");
      return S_OK;
   }

   HRESULT hr = S_OK;
   MyBasePathsInfo * pBPI;

   //
   // Get the enterprise root domain DN from the RootDSE.
   //
   pBPI = pComponentData->GetBasePathsInfo();
   if (!pBPI)
   {
      ASSERT(FALSE);
      return E_FAIL;
   }

   PCWSTR pwzRoot = pBPI->GetRootDomainNamingContext();

   TRACE(L"Root path: %ws\n", pwzRoot);
   PDOMAIN_DESC pRootDomain = NULL;

   //
   // Insert the root nodes. First insert the enterprise root.
   //
   for (pRootDomain = m_domainTreeBrowser.GetDomainTree()->aDomains; pRootDomain; 
        pRootDomain = pRootDomain->pdNextSibling)
   {
      if (_wcsicmp(pwzRoot, pRootDomain->pszNCName) == 0)
      {
         TRACE(L"Enterprise root found!\n");
         CDomainObject* pDomain = new CDomainObject;
         if (!pDomain)
         {
            ASSERT(FALSE);
            return E_OUTOFMEMORY;
         }
         pDomain->Initialize(pRootDomain, m_pCD->GetDomainImageIndex());
         AddChild(pDomain);
         pDomain->SetParentFolder(this);

         hr = pComponentData->AddFolder(pDomain, GetScopeID(), TRUE); // has children
         if (FAILED(hr))
         {
            return hr;
         }
         //
         // Create a non-refcounted reference to the enterprise root domain node.
         // Do NOT call delete on the m_pEnterpriseRoot pointer!
         //
         m_pEnterpriseRoot = pDomain;

         break;
      }
   }

   //
   // Now insert the rest of the root nodes.
   //
   for (pRootDomain = m_domainTreeBrowser.GetDomainTree()->aDomains; pRootDomain; 
        pRootDomain = pRootDomain->pdNextSibling)
   {
      if (_wcsicmp(pwzRoot, pRootDomain->pszNCName) == 0)
      {
         // Root already inserted.
         continue;
      }
      CDomainObject* pDomain = new CDomainObject;
      if (!pDomain)
      {
         ASSERT(FALSE);
         return E_OUTOFMEMORY;
      }
      pDomain->Initialize(pRootDomain, m_pCD->GetDomainImageIndex());
      AddChild(pDomain);
      pDomain->SetParentFolder(this);

      hr = pComponentData->AddFolder(pDomain, GetScopeID(), TRUE); // has children
      if (FAILED(hr))
      {
         break;
      }
   }

   return hr;
}

HRESULT
CRootFolderObject::EnumerateFolder(CFolderObject* pFolderObject, 
                                   HSCOPEITEM pParent,
                                   CComponentDataImpl* pComponentData)
{
	HRESULT hr = E_FAIL;
	if (!m_domainTreeBrowser.HasData())
		return hr;
				
	ASSERT(pFolderObject != NULL);
	ASSERT(pFolderObject->GetScopeID() == pParent);

	CDomainObject* pDomainObject = dynamic_cast<CDomainObject*>(pFolderObject);
	if (pDomainObject == NULL)
		return hr;

	DOMAIN_DESC* pDomainDesc = pDomainObject->GetDescriptionPtr();

	if (pDomainDesc == NULL)
		return hr;

	if (pDomainDesc->pdChildList == NULL)
		return S_OK;

	for (DOMAIN_DESC* pChild = pDomainDesc->pdChildList; pChild; 
						pChild = pChild->pdNextSibling)
	{
		CDomainObject* pDomain = new CDomainObject;
		pDomain->Initialize(pChild,
					   m_pCD->GetDomainImageIndex());
		hr = pComponentData->AddFolder(pDomain, pDomainObject->GetScopeID(), 
								TRUE); // has children
		pFolderObject->AddChild(pDomain);
		pDomain->SetParentFolder(pFolderObject);

		if (FAILED(hr))
		  break;
	} // for
	return hr;
}


HRESULT CRootFolderObject::OnAddMenuItems(LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                              long *pInsertionAllowed)
{
  HRESULT hr = S_OK;
  if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
  {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
/*
    if (g_dsUiWizDLL.Load())
    {
        return _AddMenuItemHelper(pContextMenuCallback, IDS_COMMAND_TRUST_WIZ, IDM_TRUST_WIZ, CCM_INSERTIONPOINTID_PRIMARY_TOP);
    }
*/
    _AddMenuItemHelper(pContextMenuCallback, IDS_COMMAND_RETARGET, IDM_RETARGET, CCM_INSERTIONPOINTID_PRIMARY_TOP);
    _AddMenuItemHelper(pContextMenuCallback, IDS_COMMAND_EDIT_FSMO, IDM_EDIT_FSMO, CCM_INSERTIONPOINTID_PRIMARY_TOP);
    _AddMenuItemHelper(pContextMenuCallback, IDS_COMMAND_FOREST_VER, IDM_FOREST_VERSION, CCM_INSERTIONPOINTID_PRIMARY_TOP);
  }
  return hr;
}



HRESULT CRootFolderObject::OnCommand(CComponentDataImpl* pCD, long nCommandID)
{
    HRESULT hr = S_OK;
    CString strConfig, strPartitions, strSchema;

    switch (nCommandID)
    {
    //case IDM_TRUST_WIZ:
    //    OnDomainTrustWizard();
    //    break;
    case IDM_RETARGET:
        OnRetarget();
        break;
    case IDM_EDIT_FSMO:
        OnEditFSMO();
        break;
    case IDM_FOREST_VERSION:
        MyBasePathsInfo * pBPI;
        pBPI = pCD->GetBasePathsInfo();
        if (!pBPI)
        {
           ASSERT(FALSE);
           return E_FAIL;
        }
        pBPI->GetConfigPath(strConfig);
        pBPI->GetPartitionsPath(strPartitions);
        pBPI->GetSchemaPath(strSchema);
        HWND hWndParent;
        pCD->GetMainWindow(&hWndParent);
        CDomainObject* pRoot;
        pRoot = GetEnterpriseRootNode();
        if (!pRoot)
        {
           ASSERT(FALSE);
           return E_FAIL;
        }
        DSPROP_ForestVersionDlg(strConfig, strPartitions, strSchema,
                                pRoot->GetDomainName(), hWndParent);
        break;
    default:
      ASSERT(FALSE); // Unknown command!
      hr = E_FAIL;
    }
    return hr;  
}


//void CRootFolderObject::OnDomainTrustWizard()
//{
    //g_dsUiWizDLL.TrustWizard();
//}


void CRootFolderObject::OnRetarget()
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  if (_WarningOnSheetsUp(m_pCD))
		return;

  HWND hWndParent;
  m_pCD->GetMainWindow(&hWndParent);

  CComPtr<IDsAdminChooseDC> spIDsAdminChooseDC;

  CComBSTR bstrSelectedDC;

  HRESULT hr = ::CoCreateInstance(CLSID_DsAdminChooseDCObj,
                        NULL,
                        CLSCTX_INPROC_SERVER,
                        IID_IDsAdminChooseDC,
                        (void **) &spIDsAdminChooseDC);
  if (FAILED(hr))
  {
    ::ReportError(hWndParent, IDS_CANT_GET_PARTITIONS_INFORMATION, hr);
    return;
  }

  // invoke the dialog
  CThemeContextActivator activator;
  hr = spIDsAdminChooseDC->InvokeDialog(hWndParent,
                                        m_pCD->GetBasePathsInfo()->GetDomainName(),
                                        m_pCD->GetBasePathsInfo()->GetServerName(),
                                        0x0,
                                        &bstrSelectedDC);
  
  if (SUCCEEDED(hr) && (hr != S_FALSE))
  {
    
    TRACE(L"CChangeDCDialog returned IDOK, with dlg.GetNewDCName() = %s\n", bstrSelectedDC);

    // attempt to bind
    MyBasePathsInfo tempBasePathsInfo;

    {
      CWaitCursor wait;
      hr = tempBasePathsInfo.InitFromName(bstrSelectedDC);
    }
    TRACE(L"tempBasePathsInfo.GetServerName() == %s\n", tempBasePathsInfo.GetServerName());
    if (FAILED(hr))
    {
      TRACE(L"tempBasePathsInfo.InitFromName(bstrSelectedDC) failed with hr = 0x%x\n", hr);
			ReportError(hWndParent, IDS_CANT_GET_PARTITIONS_INFORMATION, hr);
      // TODO: error handling, change icon
    }
    else
    {
      m_pCD->GetBasePathsInfo()->InitFromInfo(&tempBasePathsInfo);
      m_pCD->SetInit();
      TRACE(L"m_pCD->GetBasePathsInfo()->GetServerName() == %s\n", m_pCD->GetBasePathsInfo()->GetServerName());
      hr = m_pCD->GetDsDisplaySpecOptionsCFHolder()->Init(m_pCD->GetBasePathsInfo());
      ASSERT(SUCCEEDED(hr));

      {
        CWaitCursor wait;
        m_pCD->OnRefreshVerbHandler(this, NULL, TRUE /*bBindAgain */);
      }

    } // if
  } // if

}



void CRootFolderObject::OnEditFSMO()
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  HWND hWndParent;
  m_pCD->GetMainWindow(&hWndParent);

  CComPtr<IDisplayHelp> spIDisplayHelp;
  HRESULT hr = m_pCD->m_pConsole->QueryInterface (IID_IDisplayHelp, 
                            (void **)&spIDisplayHelp);
  ASSERT(spIDisplayHelp != NULL);

  CEditFsmoDialog dlg(m_pCD->GetBasePathsInfo(), hWndParent, spIDisplayHelp);
  CThemeContextActivator activator;
  dlg.DoModal();
}



HRESULT
CRootFolderObject::OnAddPages(LPPROPERTYSHEETCALLBACK lpProvider, 
                              LONG_PTR handle) 
{ 
   MyBasePathsInfo * pBPI;
   //
   // Get the enterprise partition path from the RootDSE.
   //
   pBPI = m_pCD->GetBasePathsInfo();

   if (!pBPI)
   {
      ASSERT(FALSE);
      return E_FAIL;
   }

   CString strPartitions;

   pBPI->GetPartitionsPath(strPartitions);

   if (strPartitions.IsEmpty())
   {
      return E_OUTOFMEMORY;
   }

   CUpnSuffixPropertyPage* pPage = new CUpnSuffixPropertyPage(strPartitions);

   if (!pPage)
   {
      return E_OUTOFMEMORY;
   }

   // Theming changes
   PROPSHEETPAGEW_V3 pspv3 = {0};
   CopyMemory(&pspv3, &pPage->m_psp, pPage->m_psp.dwSize);
   pspv3.dwSize = sizeof(pspv3);

   HPROPSHEETPAGE hPage = ::CreatePropertySheetPage(&pspv3);

   if (!hPage)
   {
      DWORD dwErr = GetLastError();
      TRACE(L"CreatePropertySheetPage failed with error %d\n", dwErr);
      delete pPage;
      return HRESULT_FROM_WIN32(dwErr);
   }

   return lpProvider->AddPage(hPage);
}


///////////////////////////////////////////////////////////////////////
// CDomainObject


CDomainObject::~CDomainObject()
{
  if (m_bSecondary)
  {
    ASSERT(m_pDomainDescription != NULL);
    ::free(m_pDomainDescription);
  }
}


LPCTSTR CDomainObject::GetDisplayString(int nCol)
{
	switch (nCol)
	{
	case 0:
		return GetDomainName();
	case 1:
		return GetClass();
	default:
		ASSERT(FALSE);
	} // switch
	return _T("");
}



void CDomainObject::Initialize(DOMAIN_DESC* pDomainDescription,
                           int nImage,
                           BOOL bHasChildren)
{
	SetImageIndex(nImage);

  // save pointer to domain description in DOMAIN_TREE
  m_pDomainDescription = pDomainDescription;
}


void CDomainObject::InitializeForSecondaryPage(LPCWSTR pszNCName,
                                  LPCWSTR pszObjectClass,
                                  int nImage)
{
  ASSERT(pszNCName != NULL);
  ASSERT(pszObjectClass != NULL);

  SetImageIndex(nImage);

  // standalone node, need to build a dummy DOMAIN_DESC
  m_bSecondary = TRUE;

  // allocate and zero memory
  int nNCNameLen = lstrlen(pszNCName)+1;
  int nObjectClassLen = lstrlen(pszObjectClass)+1;

  int nByteLen = sizeof(DOMAIN_DESC) + sizeof(WCHAR)*(nNCNameLen + nObjectClassLen);

  m_pDomainDescription = (DOMAIN_DESC*)::malloc(nByteLen);
  ASSERT(m_pDomainDescription);
  if (!m_pDomainDescription)
  {
    return;
  }
  ::ZeroMemory(m_pDomainDescription, nByteLen);

  // copy the strings
  m_pDomainDescription->pszNCName = (WCHAR*) (((BYTE*)m_pDomainDescription) + sizeof(DOMAIN_DESC));
  wcscpy(m_pDomainDescription->pszNCName, pszNCName); 

  m_pDomainDescription->pszObjectClass = (WCHAR*) (((BYTE*)m_pDomainDescription->pszNCName) + sizeof(WCHAR)*nNCNameLen);
  wcscpy(m_pDomainDescription->pszObjectClass, pszObjectClass); 
}




HRESULT CDomainObject::OnAddMenuItems(LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                              long *pInsertionAllowed)
{
  HRESULT hr = S_OK;
  if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
  {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    hr = _AddMenuItemHelper(pContextMenuCallback, IDS_COMMAND_MANAGE, IDM_MANAGE, CCM_INSERTIONPOINTID_PRIMARY_TOP);
    if (FAILED(hr))
        return hr;
    hr = _AddMenuItemHelper(pContextMenuCallback, IDS_COMMAND_DOMAIN_VER, IDM_DOMAIN_VERSION, CCM_INSERTIONPOINTID_PRIMARY_TOP);
    if (FAILED(hr))
        return hr;
  }
  return hr;
}



HRESULT CDomainObject::OnCommand(CComponentDataImpl* pCD, long nCommandID)
{
    HRESULT hr = S_OK;
    CString strPath;

    switch (nCommandID)
    {
    case IDM_MANAGE:
        OnManage(pCD);
        break;
    //case IDM_TRUST_WIZ:
    //    OnDomainTrustWizard(pCD);
    //    break;
    case IDM_DOMAIN_VERSION:
        HWND hWndParent;
        MyBasePathsInfo * pBPI;
        pBPI = pCD->GetBasePathsInfo();
        if (!pBPI)
        {
           ASSERT(FALSE);
           return E_FAIL;
        }
        pCD->GetMainWindow(&hWndParent);
        // build an LDAP path out of the DN
        if (PdcAvailable())
        {
            strPath = L"LDAP://";
            strPath += GetPDC();
            strPath += L"/";
            strPath += GetNCName();
        }
        else
        {
            pBPI->ComposeADsIPath(strPath, GetNCName());
        }
        DSPROP_DomainVersionDlg(strPath, GetDomainName(), hWndParent);
        break;
    default:
      ASSERT(FALSE); // Unknown command!
      hr = E_FAIL;
    }
    return hr;  
}

void CDomainObject::OnManage(CComponentDataImpl* pCD)
{
  static LPCWSTR lpszSearchArr[] =
  {
    L"%userprofile%\\Application Data\\Microsoft\\AdminTools\\dsa.msc",
    L"%systemroot%\\system32\\dsa.msc",
    NULL
  };

  WCHAR szParamString[MAX_PATH+1] = {0};

  wcscpy (szParamString, L" /Domain=");
  wcsncat (szParamString, (LPWSTR)(GetDomainName()), MAX_PATH - wcslen(szParamString));

  SHELLEXECUTEINFO seiManage = {0};
	seiManage.fMask = SEE_MASK_DOENVSUBST | SEE_MASK_FLAG_NO_UI;
  seiManage.cbSize = sizeof (SHELLEXECUTEINFO);
  seiManage.lpParameters = szParamString;
  seiManage.nShow = SW_SHOW;

  BOOL bExecuted = FALSE;
  DWORD dwErr = 0;
  for (int k=0; lpszSearchArr[k] != NULL; k++)
  {
    CWaitCursor cWait;

    seiManage.lpFile = (LPCWSTR)lpszSearchArr[k];
    if (!ShellExecuteEx(&seiManage))
    {
      dwErr = ::GetLastError();
    }
    else
    {
      bExecuted = TRUE;
      break;
    }
  }
  if (!bExecuted)
  {
    HWND hWndParent;
    pCD->GetMainWindow(&hWndParent);
    ReportError(hWndParent, IDS_ERROR_MANAGE, HRESULT_FROM_WIN32(dwErr));
  }
}

//void CDomainObject::OnDomainTrustWizard(CComponentDataImpl* pCD)
//{
    //g_dsUiWizDLL.TrustWizard();
//}

void CDomainObject::SetPdcAvailable(bool fAvail)
{
   _fPdcAvailable = fAvail;
}

////////////////////////////////////////////////////////////////////
// CCookieTableBase

#define NUMBER_OF_COOKIE_TABLE_ENTRIES 4 // default count, expandable at run time

CCookieTableBase::CCookieTableBase() :
    m_pCookieArr(NULL)
{
  m_nEntries = NUMBER_OF_COOKIE_TABLE_ENTRIES;
  m_pCookieArr =(CFolderObject**)malloc(m_nEntries*sizeof(CFolderObject*));

  ASSERT(m_pCookieArr);

  if (m_pCookieArr)
  {
    ZeroMemory(m_pCookieArr, m_nEntries*sizeof(CFolderObject*));
  }
}

CCookieTableBase::~CCookieTableBase()
{
  if (m_pCookieArr)
  {
    free(m_pCookieArr);
  }
}

void CCookieTableBase::Add(CFolderObject* pCookie)
{
  ASSERT(!IsPresent(pCookie)); 
  if (!m_pCookieArr)
  {
    return;
  }
  for (UINT k=0; k<m_nEntries; k++)
  {
    if (m_pCookieArr[k] == NULL)
    {
      m_pCookieArr[k] = pCookie;
      return;
    }
  }
  // no space left, need to allocate
  int nAlloc = m_nEntries*2;
  CFolderObject** pCookieArrTemp = NULL;
  pCookieArrTemp = (CFolderObject**)realloc(m_pCookieArr, sizeof(CFolderObject*)*nAlloc);
  ASSERT(pCookieArrTemp);
  if (pCookieArrTemp)
  {
    m_pCookieArr = pCookieArrTemp;
    ::ZeroMemory(&m_pCookieArr[m_nEntries], sizeof(CFolderObject*)*m_nEntries);
    m_pCookieArr[m_nEntries] = pCookie;
    m_nEntries = nAlloc;
  }
}

BOOL CCookieTableBase::Remove(CFolderObject* pCookie)
{
  if (!m_pCookieArr)
  {
    return FALSE;
  }
  for (UINT k=0; k<m_nEntries; k++)
  {
    if (m_pCookieArr[k] == pCookie)
    {
      m_pCookieArr[k] = NULL;
      return TRUE; // found
    }
  }
  return FALSE; // not found
}


BOOL CCookieTableBase::IsPresent(CFolderObject* pCookie)
{
  if (!m_pCookieArr)
  {
    return FALSE;
  }
  for (UINT k=0; k<m_nEntries; k++)
  {
    if (m_pCookieArr[k] == pCookie)
      return TRUE;
  }
  return FALSE;
}

void CCookieTableBase::Reset()
{
  if (!m_pCookieArr)
  {
    return;
  }
  for (UINT k=0; k<m_nEntries; k++)
  {
    m_pCookieArr[k] = NULL;
  }
 
}

UINT CCookieTableBase::GetCount()
{
  if (!m_pCookieArr)
  {
    return 0;
  }
  UINT nCount = 0;
  for (UINT k=0; k<m_nEntries; k++)
  {
    if (m_pCookieArr[k] != NULL)
      nCount++;
  }
  return nCount;
}



////////////////////////////////////////////////////////////////////
// CDSCookieSheetTable

void CCookieSheetTable::BringToForeground(CFolderObject* pCookie, CComponentDataImpl* pCD)
{
  ASSERT(pCD != NULL);
  ASSERT(pCookie != NULL);
  if (!m_pCookieArr)
  {
    return;
  }
  // look for the cookie itself and for all the cookies that have the 
  // given cookie as parent or ancestor
  BOOL bActivate = TRUE;
  for (UINT k=0; k<m_nEntries; k++)
  {
    if (m_pCookieArr[k] != NULL)
    {
      CFolderObject* pAncestorCookie = m_pCookieArr[k];
      while (pAncestorCookie != NULL)
      {
        if (pAncestorCookie == pCookie)
        {
          CString szADSIPath;
		    LPCWSTR lpszNamingContext = ((CDomainObject *)m_pCookieArr[k])->GetNCName();
		    pCD->GetBasePathsInfo()->ComposeADsIPath(szADSIPath, lpszNamingContext);

          // the first one will be also activated
          VERIFY(BringSheetToForeground((LPWSTR)(LPCWSTR)szADSIPath, bActivate));
          if (bActivate)
            bActivate = !bActivate;
        }
        pAncestorCookie = pAncestorCookie->GetParentFolder();
      }	// while
    } // if
  } // for

}


///////////////////////////////////////////////////////////////////////
// CDsUiWizDLL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\domain\domain.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       domain.cpp
//
//--------------------------------------------------------------------------



#include "stdafx.h"

#include <atlimpl.cpp> // include only once ont in PCH

// this redefines the DEFINE_GUID() macro to do allocation.
#include "initguid.h"
#include <dsclient.h>
#include <dsadminp.h>

#include "resource.h"
#include "domain.h"

#include "domobj.h" 
#include "cdomain.h"



HRESULT WINAPI CDomainAdminModule::UpdateRegistryCLSID(const CLSID& clsid, BOOL bRegister)
{
   static const WCHAR szIPS32[] = _T("InprocServer32");
   static const WCHAR szCLSID[] = _T("CLSID");

   HRESULT hRes = S_OK;

   LPOLESTR lpOleStrCLSIDValue;
   ::StringFromCLSID(clsid, &lpOleStrCLSIDValue);

   CRegKey key;
   if (bRegister)
   {
      LONG lRes = key.Open(HKEY_CLASSES_ROOT, szCLSID);
      if (lRes == ERROR_SUCCESS)
      {
         lRes = key.Create(key, lpOleStrCLSIDValue);
         if (lRes == ERROR_SUCCESS)
         {
            WCHAR szModule[_MAX_PATH+1] = {0};
            ::GetModuleFileName(m_hInst, szModule, _MAX_PATH);
            key.SetKeyValue(szIPS32, szModule);
         }
      }
      if (lRes != ERROR_SUCCESS)
         hRes = HRESULT_FROM_WIN32(lRes);
   }
   else
   {
      key.Attach(HKEY_CLASSES_ROOT);
      if (key.Open(key, szCLSID) == ERROR_SUCCESS)
         key.RecurseDeleteKey(lpOleStrCLSIDValue);
   }
   ::CoTaskMemFree(lpOleStrCLSIDValue);
   return hRes;
}





CDomainAdminModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_DomainAdmin, CComponentDataImpl)
  OBJECT_ENTRY(CLSID_DomainSnapinAbout, CDomainSnapinAbout)
END_OBJECT_MAP()


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
  static char THIS_FILE[] = __FILE__;
#endif

class CDomainApp : public CWinApp
{
public:
  virtual BOOL InitInstance();
  virtual int ExitInstance();
};

CDomainApp theApp;

BOOL CDomainApp::InitInstance()
{
  _Module.Init(ObjectMap, m_hInstance);
  SHFusionInitializeFromModule(m_hInstance);
  return CWinApp::InitInstance();
}

int CDomainApp::ExitInstance()
{
  _Module.Term();

  DEBUG_VERIFY_INSTANCE_COUNT(CComponentImpl);
  DEBUG_VERIFY_INSTANCE_COUNT(CComponentDataImpl);

  SHFusionUninitialize();

  return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
  return _Module.GetClassObject(rclsid, riid, ppv);
}

LPCTSTR g_cszBasePath	= _T("Software\\Microsoft\\MMC\\SnapIns");
LPCTSTR g_cszNameString	= _T("NameString");
LPCTSTR g_cszNameStringIndirect = _T("NameStringIndirect");
LPCTSTR g_cszProvider	= _T("Provider");
LPCTSTR g_cszVersion	= _T("Version");
LPCTSTR g_cszAbout		= _T("About");
LPCTSTR g_cszStandAlone	= _T("StandAlone");
LPCTSTR g_cszNodeTypes	= _T("NodeTypes");

LPCTSTR GUIDToCString(REFGUID guid, CString & str)
{
  USES_CONVERSION;
	
  OLECHAR lpszGUID[128];
  int nChars = ::StringFromGUID2(guid, lpszGUID, 128);
  LPTSTR lpString = OLE2T(lpszGUID);

  LPTSTR lpGUID = str.GetBuffer(nChars);
  if (lpGUID)
    {
      // NOTICE-2002/03/07-ericb - SecurityPush: reviewed safe.
      CopyMemory(lpGUID, lpString, nChars*sizeof(TCHAR));
      str.ReleaseBuffer();
    }

  return str;
}

HRESULT RegisterSnapin()
{
  HRESULT hr = S_OK;
  CString strKey;
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  
  try
    {
      CString str;
      
      CRegKey rkBase;
      rkBase.Open(HKEY_LOCAL_MACHINE, g_cszBasePath);

      // Create snapin GUID key and set properties
      CRegKey rkCLSID;
      rkCLSID.Create(rkBase, GUIDToCString(CLSID_DomainAdmin, str));
      str.LoadString(IDS_DESCRIPTION);
      //        str = _T("MSFT Domain Tree Manager");
      rkCLSID.SetValue(str, g_cszNameString);

      {
        WCHAR szModule[_MAX_PATH+1] = {0};
        ::GetModuleFileName(AfxGetInstanceHandle(), szModule, _MAX_PATH);
        str.Format(_T("@%s,-%d"), szModule, IDS_DESCRIPTION);
        rkCLSID.SetValue(str, g_cszNameStringIndirect);
      }

      rkCLSID.SetValue(STR_SNAPIN_COMPANY, g_cszProvider);
      str.Format(TEXT("%hs"), STR_SNAPIN_VERSION); // this is a concatenation of ANSI strings, hence this conversion to UNICODE.
      rkCLSID.SetValue(str, g_cszVersion);

      rkCLSID.SetValue(GUIDToCString(CLSID_DomainSnapinAbout, str), g_cszAbout);
        
      // Create "StandAlone" key
      CRegKey rkStandAlone;
      rkStandAlone.Create(rkCLSID, g_cszStandAlone);
                
      // Create "NodeTypes" key
      CRegKey rkNodeTypes;
      rkNodeTypes.Create(rkCLSID,  g_cszNodeTypes);

      // NodeTypes guids
      CRegKey rkN1;
      rkN1.Create(rkNodeTypes, GUIDToCString(cDefaultNodeType, str));
    }
  catch(CMemoryException * e)
    {
      e->Delete();
      hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }
  catch(COleException * e)
    {
      e->Delete();
      hr = SELFREG_E_CLASS;
    }
	
  return hr;
}

HRESULT UnregisterSnapin()
{
  HRESULT hr = S_OK;
	
  try
    {
      CRegKey rkBase;
      rkBase.Open(HKEY_LOCAL_MACHINE, g_cszBasePath);

      CString str;
      rkBase.RecurseDeleteKey(GUIDToCString(CLSID_DomainAdmin, str));
    }
  catch(CException * e)
    {
      DWORD err = ::GetLastError();
      hr = HRESULT_FROM_WIN32(err);
      e->Delete();
    }

  return hr;
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	HRESULT hRes = _Module.RegisterServer(/* bRegTypeLib */ FALSE);
	if (FAILED(hRes))
		return SELFREG_E_CLASS;

	return RegisterSnapin();
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return UnregisterSnapin();
}


///////////////////////////////////////////////////////////////////////
// CDsUiWizDLL

CDsUiWizDLL::CDsUiWizDLL()
{
	m_hLibrary = NULL;
	m_pfFunction = NULL;
}


CDsUiWizDLL::~CDsUiWizDLL()
{
	if (m_hLibrary != NULL)
	{
		::FreeLibrary(m_hLibrary);
		m_hLibrary = NULL;
	}
}

BOOL CDsUiWizDLL::Load()
{
	if (m_hLibrary != NULL)
        return TRUE; // already loaded
    // NOTICE-2002/03/07-ericb - SecurityPush: reviewed safe.
	m_hLibrary = ::LoadLibrary(_T("dsuiwiz.dll"));
	if (NULL == m_hLibrary)
	{
		// The library is not present
		return FALSE;
	}
	m_pfFunction = ::GetProcAddress(m_hLibrary, "TrustWizard" );
	if ( NULL == m_pfFunction )
	{
		// The library is present but does not have the entry point
		::FreeLibrary( m_hLibrary );
		m_hLibrary = NULL;
		return FALSE;
	}
	ASSERT(m_hLibrary != NULL);
	ASSERT(m_pfFunction != NULL);
	return TRUE;
}


typedef HRESULT (*TRUST_WIZARD_PROC) (HWND, LPCWSTR);

HRESULT CDsUiWizDLL::TrustWizard(HWND hWndParent, LPCWSTR lpsz)
{
	ASSERT(m_hLibrary != NULL);
	ASSERT(m_pfFunction != NULL);
	return ((TRUST_WIZARD_PROC)m_pfFunction) (hWndParent, lpsz);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\domain\domobjui.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       domobjui.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "domobj.h"
#include "cdomain.h"
#include "domain.h"
#include "cdomain.h"

#include "domobjui.h"

#include "helparr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////
// CMoreInfoMessageBox

class CMoreInfoMessageBox : public CDialog
{
public:
  CMoreInfoMessageBox(HWND hWndParent, IDisplayHelp* pIDisplayHelp) 
    : CDialog(IDD_MSGBOX_OK_MOREINFO, CWnd::FromHandle(hWndParent)),
    m_spIDisplayHelp(pIDisplayHelp)
  {
  }

  void SetURL(LPCWSTR lpszURL) { m_szURL = lpszURL;}
  void SetMessage(LPCWSTR lpsz)
  {
    m_szMessage = lpsz;
  }

	// message handlers and MFC overrides
	virtual BOOL OnInitDialog()
  {
    SetDlgItemText(IDC_STATIC_MESSAGE, m_szMessage);
    return TRUE;
  }

	afx_msg void OnMoreInfo()
  {
    TRACE(L"ShowTopic(%s)\n", (LPCWSTR)m_szURL);
    m_spIDisplayHelp->ShowTopic((LPWSTR)(LPCWSTR)m_szURL);
  }

  DECLARE_MESSAGE_MAP()
private:
  CComPtr<IDisplayHelp> m_spIDisplayHelp;
  CString m_szMessage;
  CString m_szURL;
};

BEGIN_MESSAGE_MAP(CMoreInfoMessageBox, CDialog)
	ON_BN_CLICKED(ID_BUTTON_MORE_INFO, OnMoreInfo)
END_MESSAGE_MAP()



///////////////////////////////////////////////////////////////////////
// CEditFsmoDialog


BEGIN_MESSAGE_MAP(CEditFsmoDialog, CDialog)
	ON_BN_CLICKED(IDC_CHANGE_FSMO, OnChange)
  ON_WM_HELPINFO()
END_MESSAGE_MAP()

CEditFsmoDialog::CEditFsmoDialog(MyBasePathsInfo* pInfo, HWND hWndParent, IDisplayHelp* pIDisplayHelp) :
  CDialog(IDD_EDIT_FSMO, CWnd::FromHandle(hWndParent)) 
{
  m_pInfo = pInfo;
  m_spIDisplayHelp = pIDisplayHelp;
}


BOOL CEditFsmoDialog::OnInitDialog() 
{
	CDialog::OnInitDialog();

  // init the status (online/offline) control)
  m_fsmoServerState.Init(::GetDlgItem(m_hWnd, IDC_STATIC_FSMO_STATUS));

  SetDlgItemText(IDC_EDIT_CURRENT_DC, m_pInfo->GetServerName());

  HRESULT hr;
  MyBasePathsInfo fsmoOwnerInfo;
  {
    CWaitCursor wait;

    PWSTR pszFsmoOwner = 0;
    hr = FindFsmoOwner(m_pInfo, DOMAIN_NAMING_FSMO, &fsmoOwnerInfo, &pszFsmoOwner);


    if (pszFsmoOwner)
    {
      m_szFsmoOwnerServerName = pszFsmoOwner;
      delete[] pszFsmoOwner;
      pszFsmoOwner = 0;
    }
  }

  BOOL bOnLine = SUCCEEDED(hr);
  _SetFsmoServerStatus(bOnLine);

  if (bOnLine)
  {
    // set the focus on change button
    GetDlgItem(IDC_CHANGE_FSMO)->SetFocus();
  }
  else
  {
    // set the focus on close button
    GetDlgItem(IDCANCEL)->SetFocus();
  }

  return FALSE; // we set the focus
}

void CEditFsmoDialog::OnChange()
{
  CThemeContextActivator activator;
  // verify we have different servers
  if (m_szFsmoOwnerServerName.CompareNoCase(m_pInfo->GetServerName()) == 0)
  {
    AfxMessageBox(IDS_WARNING_CHANGE_FOCUS, MB_OK);
    return;
  }

  // make sure the user wants to do it
  if (AfxMessageBox(IDS_CHANGE_FSMO_CONFIRMATION, MB_YESNO|MB_DEFBUTTON2) != IDYES)
    return;

  HRESULT hr = S_OK;
  // try a graceful transfer
  {
    CWaitCursor wait;
    hr = GracefulFsmoOwnerTransfer(m_pInfo, DOMAIN_NAMING_FSMO);
  }
  if (FAILED(hr))
  {
    CString szFmt, szMsg;
    PWSTR pszError = 0;
    StringErrorFromHr(hr, &pszError);

    szFmt.LoadString(IDS_ERROR_CHANGE_FSMO_OWNER);
    szMsg.Format(szFmt, pszError);

    CMoreInfoMessageBox dlg(m_hWnd, m_spIDisplayHelp);
    dlg.SetMessage(szMsg);
    dlg.SetURL(L"ADconcepts.chm::/FSMO_DOMAIN_NAMING_ForcefulSeizure.htm");
    dlg.DoModal();
  }
  else
  {
    m_szFsmoOwnerServerName = m_pInfo->GetServerName();
    _SetFsmoServerStatus(TRUE);
    AfxMessageBox(IDS_CHANGE_FSMO_SUCCESS, MB_OK);
  }
}

void CEditFsmoDialog::_SetFsmoServerStatus(BOOL bOnLine)
{
  // set the FSMO owner server name
  if (m_szFsmoOwnerServerName.IsEmpty())
  {
    CString szError;
    szError.LoadString(IDS_FSMO_SERVER_ERROR);
    SetDlgItemText(IDC_EDIT_CURRENT_FSMO_DC, szError);
  }
  else
  {
    SetDlgItemText(IDC_EDIT_CURRENT_FSMO_DC, m_szFsmoOwnerServerName);
  }

  // set the status of the FSMO owner server
  m_fsmoServerState.SetToggleState(bOnLine);

  // enable disable the change button
  GetDlgItem(IDC_CHANGE_FSMO)->EnableWindow(bOnLine);
}


BOOL CEditFsmoDialog::OnHelpInfo(HELPINFO* pHelpInfo) 
{
  DialogContextHelp((DWORD*)&g_aHelpIDs_TREE_IDD_EDIT_FSMO, pHelpInfo);
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\domain\domobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       domobj.h
//
//--------------------------------------------------------------------------



#ifndef _DOMOBJ_H
#define _DOMOBJ_H

///////////////////////////////////////////////////////////////////////
// global helper functions

void ReportError(HWND hWnd, UINT nMsgID, HRESULT hr);

///////////////////////////////////////////////////////////////////////
// Forward declarations

class CComponentDataImpl;
class CFolderObject;
class CCookieSheetTable;
class CDomainObject;

///////////////////////////////////////////////////////////////////////
// CDomainTreeBrowser

class CDomainTreeBrowser
{
public:
  CDomainTreeBrowser()
  {
    m_pDomains = NULL;
  }
  ~CDomainTreeBrowser()
  {
    _Reset();
  }

  BOOL HasData() { return m_pDomains != NULL; }
  HRESULT Bind(MyBasePathsInfo* pInfo);
	HRESULT GetData();

  PDOMAIN_TREE	GetDomainTree()
  {
    ASSERT(m_pDomains != NULL);
    return m_pDomains;
  }


private:
	CComPtr<IDsBrowseDomainTree>	m_spIDsBrowseDomainTree; // interface pointer for browsing
  CComPtr<IDirectorySearch>   m_spIDirectorySearch; //

	PDOMAIN_TREE			m_pDomains;			// pointer to the domain info to from backend


  void _Reset()
  {
    _FreeDomains();
    m_spIDsBrowseDomainTree = NULL;
    m_spIDirectorySearch = NULL;
  }
  void _FreeDomains()
  {
    if (m_pDomains == NULL)
      return;
    if (m_spIDsBrowseDomainTree != NULL)
      m_spIDsBrowseDomainTree->FreeDomains(&m_pDomains);
    else
      ::LocalFree(m_pDomains);
    m_pDomains = NULL;
  }

};


////////////////////////////////////////////////////////////////////
// CCookieTableBase

class CCookieTableBase
{
public:
  CCookieTableBase();
  ~CCookieTableBase();

  void Add(CFolderObject* pCookie);
  BOOL Remove(CFolderObject* pCookie);
  BOOL IsPresent(CFolderObject* pCookie);
  void Reset();
  UINT GetCount();

protected:
  UINT m_nEntries;
  CFolderObject** m_pCookieArr;
};

////////////////////////////////////////////////////////////////////
// CCookieSheetTable

class CCookieSheetTable : public CCookieTableBase
{
public:
  void BringToForeground(CFolderObject* pCookie, CComponentDataImpl* pCD);
};




///////////////////////////////////////////////////////////////////////
// CFolderObject

typedef CList<CFolderObject*, CFolderObject*> CFolderObjectList;

class CFolderObject
{
public:
	CFolderObject()
	{
		m_nImage = 0;
		m_ID = 0;
		m_pParentFolder = NULL;
		m_nSheetLockCount = 0;
	}
	virtual ~CFolderObject();

	void SetScopeID(HSCOPEITEM ID) { m_ID = ID; }
	HSCOPEITEM GetScopeID() { return m_ID; }
	void SetImageIndex(int nImage) { m_nImage = nImage;}
	int GetImageIndex() { return m_nImage;}
	virtual LPCTSTR GetDisplayString(int nIndex) { return L"";}
  virtual HRESULT OnCommand(CComponentDataImpl* pCD, long nCommandID) { return S_OK;}
  virtual HRESULT OnAddMenuItems(LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                              long *pInsertionAllowed) { return S_OK;}
	BOOL AddChild(CFolderObject* pChildFolderObject);
	void RemoveAllChildren();

	void SetParentFolder(CFolderObject* pParentFolder) { m_pParentFolder = pParentFolder; }
	CFolderObject* GetParentFolder() { return m_pParentFolder; }

	void IncrementSheetLockCount();
	void DecrementSheetLockCount();
	BOOL IsSheetLocked() { return (m_nSheetLockCount > 0); }

	BOOL _WarningOnSheetsUp(CComponentDataImpl* pCD);

private:
	HSCOPEITEM m_ID;				// scope item ID for this folder
	int m_nImage;					// index if the image for folder
	CFolderObjectList m_childList;  // list of children

	CFolderObject* m_pParentFolder;
	
	LONG m_nSheetLockCount; // keeps track if a node has been locked by a property sheet  

};


///////////////////////////////////////////////////////////////////////
// CRootFolderObject

class CRootFolderObject : public CFolderObject
{
public:
	CRootFolderObject(CComponentDataImpl* pCD);
	virtual ~CRootFolderObject()  { }

	BOOL HasData() { return m_domainTreeBrowser.HasData(); }
  HRESULT Bind();
  HRESULT GetData();

	HRESULT EnumerateRootFolder(CComponentDataImpl* pComponentData);
	HRESULT EnumerateFolder(CFolderObject* pFolderObject,
							HSCOPEITEM pParent,
							CComponentDataImpl* pComponentData);
  virtual HRESULT OnCommand(CComponentDataImpl* pCD, long nCommandID);
  virtual HRESULT OnAddMenuItems(LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                            long *pInsertionAllowed);

  HRESULT OnAddPages(LPPROPERTYSHEETCALLBACK lpProvider,
                    LONG_PTR handle);

  CDomainObject* GetEnterpriseRootNode(void) {return m_pEnterpriseRoot;};

private:
  //void OnDomainTrustWizard();
  void OnRetarget();
  void OnEditFSMO();

	CComponentDataImpl*		m_pCD;					// back pointer to snapin
  CDomainTreeBrowser  m_domainTreeBrowser;
  CDomainObject*  m_pEnterpriseRoot;
};



///////////////////////////////////////////////////////////////////////
// CDomainObject

class CDomainObject : public CFolderObject
{
  friend class CRootFolderObject;

public:
  CDomainObject() : m_pDomainDescription(NULL), _fPdcAvailable(false)
  {
    TRACE(L"CDomainObject CTOR (0x%08x)\n", this);
    m_bSecondary = FALSE;
  };

  virtual ~CDomainObject();
  virtual LPCTSTR GetDisplayString(int nIndex);
  virtual HRESULT OnCommand(CComponentDataImpl* pCD, long nCommandID);
  virtual HRESULT OnAddMenuItems(LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                 long *pInsertionAllowed);

  // Interface
public:

  // string access functions
  LPCWSTR GetDomainName() { return GetDescriptionPtr()->pszName; };
  LPCWSTR GetNCName() { return GetDescriptionPtr()->pszNCName; };
  LPCWSTR GetClass () { return GetDescriptionPtr()->pszObjectClass; };

  DOMAIN_DESC* GetDescriptionPtr()
        { ASSERT(m_pDomainDescription != NULL); return m_pDomainDescription; };

  void InitializeForSecondaryPage(LPCWSTR pszNCName,
                                  LPCWSTR pszObjectClass,
                                  int nImage);

  void   SetPDC(PCWSTR pwzPDC) {_strPDC = pwzPDC;};
  PCWSTR GetPDC(void) {return _strPDC;};
  void   SetPdcAvailable(bool fAvail);
  bool   PdcAvailable(void) {return _fPdcAvailable;};

  // Implementation
private:
  void Initialize(DOMAIN_DESC* pDomainDescription,
                  int nImage,
                  BOOL bHasChildren = FALSE);

  void OnManage(CComponentDataImpl* pCD);
  void OnDomainTrustWizard(CComponentDataImpl* pCD);

  // Attributes
private:

  DOMAIN_DESC * m_pDomainDescription; // pointer to the data in the blob
  BOOL m_bSecondary;  // from a secondary page
  CString _strPDC;
  bool    _fPdcAvailable;
};


#endif // _DOMOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\domain\helparr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       helparr.h
//
//--------------------------------------------------------------------------

#define	IDH_ADD_BTN	20001077
#define	IDH_CHANGE_FSMO_TREE	20001052
#define	IDH_DELETE_BTN	20001078
#define	IDH_EDIT	20001075
#define	IDH_EDIT_CURRENT_DC_TREE	20001025
#define	IDH_EDIT_CURRENT_DC_TREE2	20001050
#define	IDH_EDIT_CURRENT_FSMO_DC_TREE	20001051
#define	IDH_EDIT_DC_TREE	20001028
#define	IDH_LIST	20001076
#define	IDH_RADIO_ANY_TREE	20001026
#define	IDH_RADIO_SPECIFY_TREE	20001027


const DWORD g_aHelpIDs_IDD_UPN_SUFFIX[]=
{
	IDC_DELETE_BTN,IDH_DELETE_BTN,
	IDC_ADD_BTN,IDH_ADD_BTN,
	IDC_LIST,IDH_LIST,
	IDC_EDIT,IDH_EDIT,
	0,0
};


/*
REVIEW_MARCOC: obsolete, need to remove from the HELP ID's

const DWORD g_aHelpIDs_TREE_IDD_CHANGE_DC[]=
{
	IDC_EDIT_DC,IDH_EDIT_DC_TREE,
	IDC_RADIO_SPECIFY,IDH_RADIO_SPECIFY_TREE,
	IDC_RADIO_ANY,IDH_RADIO_ANY_TREE,
	IDC_EDIT_CURRENT_DC,IDH_EDIT_CURRENT_DC_TREE,
	0, 0
};
*/

const DWORD g_aHelpIDs_TREE_IDD_EDIT_FSMO[]=
{
	IDC_CHANGE_FSMO,IDH_CHANGE_FSMO_TREE,
	IDC_EDIT_CURRENT_FSMO_DC,IDH_EDIT_CURRENT_FSMO_DC_TREE,
	IDC_EDIT_CURRENT_DC,IDH_EDIT_CURRENT_DC_TREE2,	
	0, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\domain\domobjui.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       domobjui.h
//
//--------------------------------------------------------------------------

#ifndef _DOMOBJUI_H
#define _DOMOBJUI_H


///////////////////////////////////////////////////////////////////////
// fwd declarations
class CDSBasePathsInfo;


///////////////////////////////////////////////////////////////////////
// CEditFsmoDialog

class CEditFsmoDialog : public CDialog
{
public:
  CEditFsmoDialog(MyBasePathsInfo* pInfo, HWND hWndParent, IDisplayHelp* pIDisplayHelp);
  
private:

	virtual BOOL OnInitDialog();

  afx_msg void OnChange();
  afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);

  void _SetFsmoServerStatus(BOOL bOnLine);

  MyBasePathsInfo* m_pInfo;        // info about the current focus
  CComPtr<IDisplayHelp> m_spIDisplayHelp;
  CString m_szFsmoOwnerServerName; 
  CToggleTextControlHelper m_fsmoServerState;

  DECLARE_MESSAGE_MAP()
};


#endif // _DOMOBJUI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\domain\mybasepathsinfo.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      MyBasePathsInfo.h
//
//  Contents:  Thin wrapper around dsadminlib CDSBasePathsInfo class
//             to deal with memory management of strings
//
//  History:   04/02/2001 jeffjon    Created
//
//--------------------------------------------------------------------------

#include "stdafx.h"


void MyBasePathsInfo::ComposeADsIPath(CString& szPath, IN LPCWSTR lpszNamingContext)
{
  int result = 0;
  szPath.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::ComposeADsIPath(&pszPath, lpszNamingContext);
  
  if (pszPath && result)
  {
     szPath = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

void MyBasePathsInfo::GetSchemaPath(CString& s)
{
  int result = 0;
  s.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::GetSchemaPath(&pszPath);
  
  if (pszPath && result)
  {
     s = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

void MyBasePathsInfo::GetConfigPath(CString& s)
{
  int result = 0;
  s.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::GetConfigPath(&pszPath);
  
  if (pszPath && result)
  {
     s = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

void MyBasePathsInfo::GetDefaultRootPath(CString& s)
{
  int result = 0;
  s.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::GetDefaultRootPath(&pszPath);
  
  if (pszPath && result)
  {
     s = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

void MyBasePathsInfo::GetRootDSEPath(CString& s)
{
  int result = 0;
  s.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::GetRootDSEPath(&pszPath);
  
  if (pszPath && result)
  {
     s = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

void MyBasePathsInfo::GetAbstractSchemaPath(CString& s)
{
  int result = 0;
  s.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::GetAbstractSchemaPath(&pszPath);
  
  if (pszPath && result)
  {
     s = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

void MyBasePathsInfo::GetPartitionsPath(CString& s)
{
  int result = 0;
  s.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::GetPartitionsPath(&pszPath);
  
  if (pszPath && result)
  {
     s = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

void MyBasePathsInfo::GetSchemaObjectPath(IN LPCWSTR lpszObjClass, CString& s)
{
  int result = 0;
  s.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::GetSchemaObjectPath(lpszObjClass, &pszPath);
  
  if (pszPath && result)
  {
     s = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

void MyBasePathsInfo::GetInfrastructureObjectPath(CString& s)
{
  int result = 0;
  s.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::GetInfrastructureObjectPath(&pszPath);
  
  if (pszPath && result)
  {
     s = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

HRESULT GetADSIServerName(CString& szServer, IN IUnknown* pUnk)
{
  PWSTR pszServer = 0;
  HRESULT hr = GetADSIServerName(&pszServer, pUnk);
  if (SUCCEEDED(hr) && pszServer)
  {
    szServer = pszServer;

    delete[] pszServer;
    pszServer = 0;
  }

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\domain\mybasepathsinfo.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      MyBasePathsInfo.h
//
//  Contents:  Thin wrapper around dsadminlib CDSBasePathsInfo class
//             to deal with memory management of strings
//
//  History:   04/02/2001 jeffjon    Created
//
//--------------------------------------------------------------------------

class MyBasePathsInfo : public CDSBasePathsInfo
{
public:
  // Functions from the base class that are wrapped to take references to 
  // CStrings

  void ComposeADsIPath(CString& szPath, IN LPCWSTR lpszNamingContext);

  void GetSchemaPath(CString& s);
  void GetConfigPath(CString& s);
  void GetDefaultRootPath(CString& s);
  void GetRootDSEPath(CString& s);
  void GetAbstractSchemaPath(CString& s);
  void GetPartitionsPath(CString& s);
  void GetSchemaObjectPath(IN LPCWSTR lpszObjClass, CString& s);
  void GetInfrastructureObjectPath(CString& s);
};

HRESULT GetADSIServerName(CString& szServer, IN IUnknown* pUnk);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\domain\proppage.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       proppage.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "resource.h"
#include "proppage.h"
#include "domobj.h"
#include "cdomain.h"

#include "helparr.h"

////////////////////////////////////////////////////////////////////////////////
// CUpnSuffixPropertyPage


// hook the property sheet callback to allow
// C++ object destruction

// static callback override function
UINT CALLBACK CUpnSuffixPropertyPage::PropSheetPageProc(
    HWND hwnd,	
    UINT uMsg,	
    LPPROPSHEETPAGE ppsp)
{
  CUpnSuffixPropertyPage* pPage = (CUpnSuffixPropertyPage*)(ppsp->lParam);
  ASSERT(pPage != NULL);

  UINT nResult = (*(pPage->m_pfnOldPropCallback))(hwnd, uMsg, ppsp);
  if (uMsg == PSPCB_RELEASE)
  {
    delete pPage;
  }
  return nResult;
}


BEGIN_MESSAGE_MAP(CUpnSuffixPropertyPage, CPropertyPage)
	ON_BN_CLICKED(IDC_ADD_BTN, OnAddButton)
  ON_BN_CLICKED(IDC_DELETE_BTN, OnDeleteButton)
  ON_EN_CHANGE(IDC_EDIT, OnEditChange)
  ON_WM_HELPINFO()
END_MESSAGE_MAP()


CUpnSuffixPropertyPage::CUpnSuffixPropertyPage(CString & strPartitions) :
    CPropertyPage(IDD_UPN_SUFFIX),
    m_nPreviousDefaultButtonID(0),
    _strPartitions(strPartitions)
{
  m_pfnOldPropCallback = m_psp.pfnCallback;
  m_psp.pfnCallback = PropSheetPageProc;
  m_bDirty = FALSE;
  m_pIADsPartitionsCont = NULL;
}

CUpnSuffixPropertyPage::~CUpnSuffixPropertyPage()
{
  if (m_pIADsPartitionsCont != NULL)
  {
    m_pIADsPartitionsCont->Release();
    m_pIADsPartitionsCont = NULL;
  }
}

BOOL CUpnSuffixPropertyPage::OnInitDialog()
{
  CPropertyPage::OnInitDialog();

  VERIFY(m_listBox.SubclassDlgItem(IDC_LIST, this));
  ((CEdit*)GetDlgItem(IDC_EDIT))->SetLimitText(MAX_UPN_SUFFIX_LEN);

  HRESULT hr = _GetPartitionsContainer();
  if (SUCCEEDED(hr))
  {
    _Read();
    GetDlgItem(IDC_ADD_BTN)->EnableWindow(FALSE);
  }
  else
  {
    // failed to contact DC, disable the whole UI
    GetDlgItem(IDC_ADD_BTN)->EnableWindow(FALSE);
    GetDlgItem(IDC_DELETE_BTN)->EnableWindow(FALSE);
    GetDlgItem(IDC_LIST)->EnableWindow(FALSE);
    GetDlgItem(IDC_EDIT)->EnableWindow(FALSE);
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    ReportError(::GetParent(m_hWnd), IDS_CANT_GET_PARTITIONS_INFORMATION, hr);
  }
  
  LRESULT lDefID = ::SendMessage(GetParent()->GetSafeHwnd(), DM_GETDEFID, 0, 0);
  if (lDefID != 0)
  {
    m_nPreviousDefaultButtonID = LOWORD(lDefID);
  }

  _SetDirty(FALSE);
  return TRUE;
}

BOOL CUpnSuffixPropertyPage::OnApply()
{
  if (!_IsDirty())
    return TRUE;

  HRESULT hr = _Write();
  if (SUCCEEDED(hr))
  {
    _SetDirty(FALSE);
    return TRUE;
  }
  ReportError(::GetParent(m_hWnd),IDS_ERROR_WRITE_UPN_SUFFIXES, hr);
  return FALSE;
}


void CUpnSuffixPropertyPage::OnEditChange()
{
  GetDlgItemText(IDC_EDIT, m_szEditText);
  m_szEditText.TrimRight();
  m_szEditText.TrimLeft();
  
  BOOL bEnable = !m_szEditText.IsEmpty();
  CWnd* pWndFocus = CWnd::GetFocus();
  CWnd* pAddBtnWnd = GetDlgItem(IDC_ADD_BTN);

  if (!bEnable && (pAddBtnWnd == pWndFocus) )
  {
    GetDlgItem(IDC_EDIT)->SetFocus();
  }

  GetDlgItem(IDC_ADD_BTN)->EnableWindow(bEnable);
  if (bEnable)
  {
    //
    // Set the add button as the default button
    //
    ::SendMessage(GetParent()->GetSafeHwnd(), DM_SETDEFID, (WPARAM)IDC_ADD_BTN, 0);

    //
    // Force the Add button to redraw itself
    //
    ::SendDlgItemMessage(GetSafeHwnd(),
                         IDC_ADD_BTN,
                         BM_SETSTYLE,
                         BS_DEFPUSHBUTTON,
                         MAKELPARAM(TRUE, 0));
                       
    //
    // Force the previous default button to redraw itself
    //
    ::SendDlgItemMessage(GetParent()->GetSafeHwnd(),
                         m_nPreviousDefaultButtonID,
                         BM_SETSTYLE,
                         BS_PUSHBUTTON,
                         MAKELPARAM(TRUE, 0));
    
  }
  else
  {
    //
    // Set the previous button as the default button
    //
    ::SendMessage(GetParent()->GetSafeHwnd(), DM_SETDEFID, (WPARAM)m_nPreviousDefaultButtonID, 0);

    //
    // Force the previous default button to redraw itself
    //
    ::SendDlgItemMessage(GetParent()->GetSafeHwnd(),
                         m_nPreviousDefaultButtonID,
                         BM_SETSTYLE,
                         BS_DEFPUSHBUTTON,
                         MAKELPARAM(TRUE, 0));

    //
    // Force the Add button to redraw itself
    //
    ::SendDlgItemMessage(GetParent()->GetSafeHwnd(),
                         IDC_ADD_BTN,
                         BM_SETSTYLE,
                         BS_PUSHBUTTON,
                         MAKELPARAM(TRUE, 0));
                      
  }
}

void CUpnSuffixPropertyPage::OnAddButton()
{
  // cannot add duplicated items
  int nCount = m_listBox.GetCount();
  CString szItem;
  for (int i=0; i<nCount; i++)
  {
    m_listBox.GetItem(i, szItem);
    if (szItem.IsEmpty() || m_szEditText.IsEmpty())
    {
      ASSERT(!szItem.IsEmpty());
      ASSERT(!m_szEditText.IsEmpty());
      return;
    }
    if (_wcsicmp((LPCWSTR)szItem, (LPCWSTR)m_szEditText) == 0)
    {
      AFX_MANAGE_STATE(AfxGetStaticModuleState());
      CThemeContextActivator activator;
      AfxMessageBox(IDS_ERROR_ADD_UPN_NO_DUPLICATE, MB_OK|MB_ICONINFORMATION);
      return;
    }
  }

  m_listBox.AddItem(m_szEditText);
  m_listBox.UpdateHorizontalExtent();
  SetDlgItemText(IDC_EDIT, NULL);

  if (1 == m_listBox.GetCount())
  {
    // we did not have any item in the list
    // need to set the selection on the first one
    VERIFY(m_listBox.SetSelection(0));
    // need to enable buttons
    GetDlgItem(IDC_DELETE_BTN)->EnableWindow(TRUE);
  }
  _SetDirty(TRUE);
}

void CUpnSuffixPropertyPage::OnDeleteButton()
{
  int nCount = m_listBox.GetCount();
  int nSel = m_listBox.GetSelection();
  ASSERT(nCount > 0);
  ASSERT((nSel >= 0) && (nSel < nCount));

  // ask the user for confirmation
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  CThemeContextActivator activator;
  if (IDNO == AfxMessageBox(IDS_WARNING_DELETE_UPN_SUFFIX, MB_YESNO|MB_ICONQUESTION))
    return;

  // save the value and put it back in the edit control
  CString szText;
  m_listBox.GetItem(nSel, szText);
  GetDlgItem(IDC_EDIT)->SetWindowText(szText);

  // delete the item in the list
  VERIFY(m_listBox.DeleteItem(nSel));
  m_listBox.UpdateHorizontalExtent();

  // handle UI changes
  if (nCount == 1)
  {
    // removed the last one, lost the selection
    CWnd* pWndFocus = CWnd::GetFocus();
    CWnd* pDelBtnWnd = GetDlgItem(IDC_DELETE_BTN);

    if (pDelBtnWnd == pWndFocus)
    {
      GetDlgItem(IDC_EDIT)->SetFocus();
    }
    GetDlgItem(IDC_DELETE_BTN)->EnableWindow(FALSE);
  }
  else 
  {
    // need to select again: is it the last one or not
    int nNewSel = (nSel == nCount-1) ? nSel-1 : nSel;
    VERIFY(m_listBox.SetSelection(nNewSel));
    ASSERT(m_listBox.GetSelection() == nNewSel);
  }
  
  _SetDirty(TRUE);
}

BOOL CUpnSuffixPropertyPage::OnHelpInfo(HELPINFO* pHelpInfo) 
{
  DialogContextHelp((DWORD*)&g_aHelpIDs_IDD_UPN_SUFFIX, pHelpInfo);
	return TRUE;
}

//////////////////////////////////////////////////////////
// CUpnSuffixPropertyPage internal implementation methods 


LPWSTR g_lpszUpnSuffixes = L"uPNSuffixes";

HRESULT CUpnSuffixPropertyPage::_GetPartitionsContainer()
{
   if (!_strPartitions)
   {
      ASSERT(FALSE);
      return E_FAIL;
   }

   if (m_pIADsPartitionsCont != NULL)
   {
      m_pIADsPartitionsCont->Release();
      m_pIADsPartitionsCont = NULL;
   }

   HRESULT hr = S_OK;

   hr = DSAdminOpenObject(_strPartitions,
                        IID_IDirectoryObject, 
                        (void **)&m_pIADsPartitionsCont,
                        TRUE
                        );

   if (hr == E_INVALIDARG )
   {
      // Trying again without the ADS_SERVER_BIND flag
      //
      hr = DSAdminOpenObject(_strPartitions,
                           IID_IDirectoryObject, 
                           (void **)&m_pIADsPartitionsCont);
   }

   return hr;
}


void CUpnSuffixPropertyPage::_Read()
{
  ASSERT(m_pIADsPartitionsCont != NULL);

  PADS_ATTR_INFO pAttrs = NULL;
  LPWSTR lpszArr[1];
  DWORD cAttrs;

  BOOL bHaveItems = FALSE;

  HRESULT hr = m_pIADsPartitionsCont->GetObjectAttributes(
                &g_lpszUpnSuffixes, 1, &pAttrs, &cAttrs);

  if (SUCCEEDED(hr) && (pAttrs != NULL) && (cAttrs == 1) )
  {
    ASSERT(pAttrs->dwADsType == ADSTYPE_CASE_IGNORE_STRING);
    ASSERT(cAttrs == 1);
    for (DWORD i=0; i<pAttrs->dwNumValues; i++)
    {
      m_listBox.AddItem(pAttrs->pADsValues[i].CaseIgnoreString);
      //TRACE(_T("i=%d, %s\n"), i, pAttrs->pADsValues[i].CaseIgnoreString);
    }
    bHaveItems = pAttrs->dwNumValues > 0;
  }

  if (bHaveItems)
  {
    m_listBox.UpdateHorizontalExtent();
    VERIFY(m_listBox.SetSelection(0));
  }
  GetDlgItem(IDC_DELETE_BTN)->EnableWindow(bHaveItems);

  if (pAttrs != NULL)
  {
    ::FreeADsMem(pAttrs);
  }

}


HRESULT CUpnSuffixPropertyPage::_Write()
{
  ASSERT(m_pIADsPartitionsCont != NULL);
  DWORD cModified;
  CString* pStringArr = NULL;
  ADSVALUE* pValues = NULL;

  // set the update struct
  ADS_ATTR_INFO info;
  info.pszAttrName = g_lpszUpnSuffixes;
  info.dwADsType = ADSTYPE_CASE_IGNORE_STRING;
  info.dwControlCode = ADS_ATTR_CLEAR;
  info.pADsValues = NULL;
  info.dwNumValues = 0;

  int nCount = m_listBox.GetCount();

  if (nCount > 0)
  {
    info.dwControlCode = ADS_ATTR_UPDATE;
    info.dwNumValues = (DWORD)nCount;
    
    pStringArr = new CString[nCount];
    pValues = new ADSVALUE[nCount];
    info.pADsValues = pValues;

    for (int i=0; i<nCount; i++)
    {
      m_listBox.GetItem(i,pStringArr[i]);
      pValues[i].dwType = ADSTYPE_CASE_IGNORE_STRING;
      pValues[i].CaseIgnoreString = (LPWSTR)(LPCWSTR)pStringArr[i];
    }
    
  }

  HRESULT hr = m_pIADsPartitionsCont->SetObjectAttributes(
                &info, 1, &cModified);

  if (pStringArr != NULL)
    delete[] pStringArr;

  if (pValues != NULL)
    delete[] pValues;
  
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\domain\stdabout.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       stdabout.h
//
//--------------------------------------------------------------------------

#ifndef __STDABOUT_H_INCLUDED__
#define __STDABOUT_H_INCLUDED__


class CSnapinAbout :
   public ISnapinAbout,
   public CComObjectRoot
{
BEGIN_COM_MAP(CSnapinAbout)
   COM_INTERFACE_ENTRY(ISnapinAbout)
END_COM_MAP()
public:
   CSnapinAbout(UINT uIdStrDestription,
				UINT uIdIconImage,			// Resource Id for the icon/image of the snapin
				UINT uIdBitmapSmallImage,
				UINT uIdBitmapSmallImageOpen,
				UINT uIdBitmapLargeImage,
				COLORREF crImageMask);
   virtual ~CSnapinAbout ();

// ISnapinAbout
   STDMETHOD(GetSnapinDescription)(OUT LPOLESTR __RPC_FAR *lpDescription);
   STDMETHOD(GetProvider)(OUT LPOLESTR __RPC_FAR *lpName);
   STDMETHOD(GetSnapinVersion)(OUT LPOLESTR __RPC_FAR *lpVersion);
   STDMETHOD(GetSnapinImage)(OUT HICON __RPC_FAR *hAppIcon);
   STDMETHOD(GetStaticFolderImage)(
            OUT HBITMAP __RPC_FAR *hSmallImage,
            OUT HBITMAP __RPC_FAR *hSmallImageOpen,
            OUT HBITMAP __RPC_FAR *hLargeImage,
            OUT COLORREF __RPC_FAR *crMask);
protected:
   // The following data members MUST be initialized by the constructor
   // of the derived class.
   UINT m_uIdStrDestription;		// Resource Id of the description
   UINT m_uIdIconImage;			// Resource Id for the icon/image of the snapin
   UINT m_uIdBitmapSmallImage;
   UINT m_uIdBitmapSmallImageOpen;
   UINT m_uIdBitmapLargeImage;
   COLORREF m_crImageMask;
   HBITMAP m_hSmallImage;          // cached bitmap for GetStaticFolderImage
   HBITMAP m_hSmallImageOpen;      // cached bitmap for GetStaticFolderImage
   HBITMAP m_hLargeImage;          // cached bitmap for GetStaticFolderImage
}; // CSnapinAbout()

#endif // ~__STDABOUT_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\domain\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by domain.rc
//
#define IDS_NAME                        2
#define ID_BUTTON_MORE_INFO             3
#define IDS_TYPE                        4
#define IDS_NODENAME                    5
#define IDS_CANT_GET_PARTITIONS_INFORMATION 6
#define IDS_FAILURE_UNK                 7
#define IDS_DESCRIPTION                 8
#define IDS_COMPANY                     9
#define IDS_SNAPIN_VERSION              10
#define IDS_SNAPINABOUT_DESCRIPTION     11
#define IDS_FSMO_SERVER_ERROR           14
#define IDS_SHEETS_UP_DELETE            40
#define IDS_COMMAND_MANAGE              100
#define IDS_COMMAND_RETARGET            102
#define IDS_COMMAND_EDIT_FSMO           103
#define IDS_COMMAND_DOMAIN_VER          104
#define IDS_COMMAND_FOREST_VER          105
#define IDC_ADD_BTN                     149
#define IDS_WARNING_DELETE_UPN_SUFFIX   200
#define IDS_ERROR_WRITE_UPN_SUFFIXES    201
#define IDC_LIST                        202
#define IDS_ERROR_ADD_UPN_NO_DUPLICATE  202
#define IDC_EDIT_CURRENT_DC             203
#define IDS_ERROR_CHANGE_FSMO_OWNER     203
#define IDS_ERROR_MANAGE                204
#define IDS_WARNING_CHANGE_FOCUS        205
#define IDS_CHANGE_FSMO_CONFIRMATION    206
#define IDC_EDIT_CURRENT_FSMO_DC        207
#define IDS_CHANGE_FSMO_CONFIRMATION_FORCED 207
#define IDC_CHANGE_FSMO                 208
#define IDS_CHANGE_FSMO_SUCCESS         208
#define IDC_STATIC_FSMO_STATUS          210
#define IDB_DOMAIN_SMALL                212
#define IDB_DOMAIN_LARGE                213
#define IDD_UPN_SUFFIX                  214
#define IDI_DOMAIN                      215
#define IDD_EDIT_FSMO                   217
#define IDC_STATIC_MESSAGE              258
#define IDC_EDIT                        361
#define IDD_MSGBOX_OK_MOREINFO          426
#define IDC_DELETE_BTN                  1045
#define IDS_NO_PDC_MSG                  57345
#define IDS_UNKNOWN_PDC_MSG             57346

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        219
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         211
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\domain\stdabout.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       stdabout.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"

HRESULT
HrLoadOleString(
   UINT uStringId,                  // IN: String Id to load from the resource
   OUT LPOLESTR * ppaszOleString)   // OUT: Pointer to pointer to allocated OLE string
{
   if (ppaszOleString == NULL)
   {
      TRACE0("HrLoadOleString() - ppaszOleString is NULL.\n");
      return E_POINTER;
   }
   CString strT;		// Temporary string
   AFX_MANAGE_STATE(AfxGetStaticModuleState());	// Needed for LoadString()
   VERIFY( strT.LoadString(uStringId) );
   *ppaszOleString = reinterpret_cast<LPOLESTR>
      (CoTaskMemAlloc((strT.GetLength() + 1)* sizeof(wchar_t)));
   if (*ppaszOleString == NULL)
      return E_OUTOFMEMORY;
   USES_CONVERSION;
   wcscpy(OUT *ppaszOleString, T2OLE((LPTSTR)(LPCTSTR)strT));
   return S_OK;
} // HrLoadOleString()

CSnapinAbout::CSnapinAbout(UINT uIdStrDestription,
						   UINT uIdIconImage,			// Resource Id for the icon/image of the snapin
						   UINT uIdBitmapSmallImage,
						   UINT uIdBitmapSmallImageOpen,
					       UINT uIdBitmapLargeImage,
						   COLORREF crImageMask):
                                m_uIdStrDestription(uIdStrDestription),
								m_uIdIconImage(uIdIconImage),
								m_uIdBitmapSmallImage(uIdBitmapSmallImage),
								m_uIdBitmapSmallImageOpen(uIdBitmapSmallImageOpen),
								m_uIdBitmapLargeImage(uIdBitmapLargeImage),
								m_crImageMask(crImageMask),
								m_hSmallImage(0),
								m_hSmallImageOpen(0),
							    m_hLargeImage(0)
{
}						   


CSnapinAbout::~CSnapinAbout()
{
   if ( m_hSmallImage )
      ::DeleteObject (m_hSmallImage);

   if ( m_hSmallImageOpen )
      ::DeleteObject (m_hSmallImageOpen);

   if ( m_hLargeImage )
      ::DeleteObject (m_hLargeImage);
}

STDMETHODIMP CSnapinAbout::GetSnapinDescription(OUT LPOLESTR __RPC_FAR *lpDescription)
{
   return HrLoadOleString(m_uIdStrDestription, OUT lpDescription);
}

STDMETHODIMP CSnapinAbout::GetProvider(OUT LPOLESTR __RPC_FAR *lpName)
{
   if (lpName == NULL)
   {
      TRACE0("CSnapinAbout::GetProvider() - lpName is NULL.\n");
      return E_POINTER;
   }
   *lpName = reinterpret_cast<LPOLESTR>
      (CoTaskMemAlloc((wcslen(STR_SNAPIN_COMPANY) + 1) * sizeof(wchar_t)));
   if (*lpName == NULL)
      return E_OUTOFMEMORY;
   USES_CONVERSION;
   wcscpy(*lpName, T2OLE(STR_SNAPIN_COMPANY));

   return S_OK;
}

STDMETHODIMP CSnapinAbout::GetSnapinVersion(OUT LPOLESTR __RPC_FAR *lpVersion)
{
   if (lpVersion == NULL)
   {
      TRACE0("CSnapinAbout::GetSnapinVersion() - lpVersion is NULL.\n");
      return E_POINTER;
   }
   CString str;

   str.Format(TEXT("%hs"), STR_SNAPIN_VERSION); // this is a concatenation of ANSI strings, hence this conversion to UNICODE.

   *lpVersion = reinterpret_cast<LPOLESTR>
      (CoTaskMemAlloc((str.GetLength() + 1) * sizeof(wchar_t)));
   if (*lpVersion == NULL)
      return E_OUTOFMEMORY;
   USES_CONVERSION;
   wcscpy(*lpVersion, T2OLE((LPTSTR)(LPCTSTR)str));

   return S_OK;
}

STDMETHODIMP CSnapinAbout::GetSnapinImage(OUT HICON __RPC_FAR *hAppIcon)
{
   if (hAppIcon == NULL)
      return E_POINTER;
   AFX_MANAGE_STATE(AfxGetStaticModuleState());	// Required for AfxGetInstanceHandle()
   *hAppIcon = ::LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(m_uIdIconImage));
   if (*hAppIcon == NULL)
   {
      ASSERT(FALSE && "Unable to load icon");
      return E_FAIL;
   }
   return S_OK;
}

STDMETHODIMP CSnapinAbout::GetStaticFolderImage(
            OUT HBITMAP __RPC_FAR *hSmallImage,
            OUT HBITMAP __RPC_FAR *hSmallImageOpen,
            OUT HBITMAP __RPC_FAR *hLargeImage,
            OUT COLORREF __RPC_FAR *crMask)
{
   ASSERT(hSmallImage != NULL);
   ASSERT(hSmallImageOpen != NULL);
   ASSERT(hLargeImage != NULL);
   ASSERT(crMask != NULL);
   AFX_MANAGE_STATE(AfxGetStaticModuleState());	// Required for AfxGetInstanceHandle()
   HINSTANCE hInstance = AfxGetInstanceHandle();

   if ( !m_hSmallImage )
      m_hSmallImage = ::LoadBitmap(hInstance, MAKEINTRESOURCE(m_uIdBitmapSmallImage));
   if ( !m_hSmallImageOpen )
      m_hSmallImageOpen = ::LoadBitmap(hInstance, MAKEINTRESOURCE(m_uIdBitmapSmallImageOpen));
   if ( !m_hLargeImage )
      m_hLargeImage = ::LoadBitmap(hInstance, MAKEINTRESOURCE(m_uIdBitmapLargeImage));

   *hSmallImage = m_hSmallImage;
   *hSmallImageOpen = m_hSmallImageOpen;
   *hLargeImage = m_hLargeImage;
   
   *crMask = m_crImageMask;
   #ifdef _DEBUG
   if (NULL == *hSmallImage || NULL == *hSmallImageOpen || NULL == *hLargeImage)
   {
      TRACE0("WRN: CSnapinAbout::GetStaticFolderImage() - Unable to load all the bitmaps.\n");
      return E_FAIL;
   }
   #endif
   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\domain\proppage.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       proppage.h
//
//--------------------------------------------------------------------------


#ifndef _PROPPAGE_H
#define _PROPPAGE_H

#include "afxdlgs.h"


#define MAX_UPN_SUFFIX_LEN 256


////////////////////////////////////////////////////////////////////////////////
// CUpnSuffixPropertyPage


class CUpnSuffixListBox : public CListBox
{
public:
  int AddItem(LPCTSTR lpszText)
    { return AddString(lpszText);}
  void GetItem(int iItem, CString& szText)
    { GetText(iItem, szText);}
  
  BOOL DeleteItem(int iItem)
    { return DeleteString(iItem) != LB_ERR;}

  int GetSelection() 
    { return GetCurSel();}
  BOOL SetSelection(int nSel)
    { return SetCurSel(nSel) != LB_ERR; }

  void UpdateHorizontalExtent()
  {
	  int nHorzExtent = 0;
	  CClientDC dc(this);
	  int nItems = GetCount();
	  for	(int i=0; i < nItems; i++)
	  {
		  TEXTMETRIC tm;
		  VERIFY(dc.GetTextMetrics(&tm));
		  CString szBuffer;
		  GetText(i, szBuffer);
		  CSize ext = dc.GetTextExtent(szBuffer,szBuffer.GetLength());
		  nHorzExtent = max(ext.cx ,nHorzExtent); 
	  }
	  SetHorizontalExtent(nHorzExtent);
  }

};


class CUpnSuffixPropertyPage : public CPropertyPage
{
public:
  CUpnSuffixPropertyPage(CString & pwzPartitions);
  virtual ~CUpnSuffixPropertyPage();

  virtual BOOL OnInitDialog();
  virtual BOOL OnApply();

private:
  afx_msg void OnAddButton();
  afx_msg void OnDeleteButton();
  afx_msg void OnEditChange();
  afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);

private:
  void _SetDirty(BOOL bDirty)
  { 
	  SetModified(bDirty); 
	  m_bDirty = bDirty;
  }	
  BOOL _IsDirty() { return m_bDirty;}

  HRESULT _GetPartitionsContainer();
  void _Read();
  HRESULT _Write();

  BOOL m_bDirty;
  IDirectoryObject* m_pIADsPartitionsCont;
  CUpnSuffixListBox m_listBox;
  CString m_szEditText;
  CString _strPartitions;

  UINT m_nPreviousDefaultButtonID;

  // hook up the callback for C++ object destruction
  LPFNPSPCALLBACK m_pfnOldPropCallback;
  static UINT CALLBACK PropSheetPageProc(
    HWND hwnd,	
    UINT uMsg,	
    LPPROPSHEETPAGE ppsp);	

  DECLARE_MESSAGE_MAP()
};

#endif // _PROPPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\domain\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       stdafx.cpp
//
//--------------------------------------------------------------------------



#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\domain\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#if defined (ASSERT) // NT's ASSERTs conflict with MFC's ASSERTS
#  undef ASSERT
#endif

#include <afxwin.h>
#include <afxdisp.h>

///////////////////////////////////////////
// ASSERT's and TRACE's without debug CRT's
#if defined (DBG)
  #if !defined (_DEBUG)
    #define _USE_DSA_TRACE
    #define _USE_DSA_ASSERT
    #define _USE_DSA_TIMER
  #endif
#endif

#include "dbg.h"
///////////////////////////////////////////

#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module


class CDomainAdminModule : public CComModule
{
public:
	HRESULT WINAPI UpdateRegistryCLSID(const CLSID& clsid, BOOL bRegister);
};

#define DECLARE_REGISTRY_CLSID() \
static HRESULT WINAPI UpdateRegistry(BOOL bRegister) \
{ \
		return _Module.UpdateRegistryCLSID(GetObjectCLSID(), bRegister); \
}

extern CDomainAdminModule _Module;

#include <atlcom.h>
#include <atlwin.h>
#include <mmc.h>
#include <afxcmn.h>
#include <afxtempl.h>
#include <dsgetdc.h>
#include <shlobj.h> // needed for dsclient.h
#include <dsclient.h>

#include <dspropp.h>
#include "propcfg.h"

#include <dscmn.h>
#include <dsadminp.h> // DS Admin utilities

#include <ntverp.h>
#include <common.ver>
#define STR_SNAPIN_COMPANY TEXT(VER_COMPANYNAME_STR)
#define STR_SNAPIN_VERSION VER_PRODUCTVERSION_STR // this is a concatenation of ANSI strings

const long UNINITIALIZED = -1;

// For theming
#include <shfusion.h>

/////////////////////////////////////////////////////////////////////////////
// Helper functions

template<class TYPE>
inline void SAFE_RELEASE(TYPE*& pObj)
{
    if (pObj != NULL)
    {
        pObj->Release();
        pObj = NULL;
    }
    else
    {
        TRACE(_T("Release called on NULL interface ptr\n"));
    }
}

struct INTERNAL
{
    INTERNAL() { m_type = CCT_UNINITIALIZED; m_cookie = -1;};
    ~INTERNAL() {}

    DATA_OBJECT_TYPES   m_type;     // What context is the data object.
    MMC_COOKIE          m_cookie;   // What object the cookie represents
    CString             m_string;
    CString             m_class;

    INTERNAL & operator=(const INTERNAL& rhs)
    {
        if (&rhs == this)
            return *this;

        m_type = rhs.m_type;
        m_cookie = rhs.m_cookie;
        m_string = rhs.m_string;

        return *this;
    }

    BOOL operator==(const INTERNAL& rhs)
    {
        return rhs.m_string == m_string;
    }
};

class CThemeContextActivator
{
public:
    CThemeContextActivator() : m_ulActivationCookie(0)
        { SHActivateContext (&m_ulActivationCookie); }

    ~CThemeContextActivator()
        { SHDeactivateContext (m_ulActivationCookie); }

private:
    ULONG_PTR m_ulActivationCookie;
};

// Debug instance counter
#ifdef _DEBUG

inline void DbgInstanceRemaining(char * pszClassName, int cInstRem)
{
    char buf[100];
    wsprintfA(buf, "%s has %d instances left over.", pszClassName, cInstRem);
    ::MessageBoxA(NULL, buf, "Memory Leak!!!", MB_OK);
}
    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)      extern int s_cInst_##cls = 0;
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)    ++(s_cInst_##cls);
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)    --(s_cInst_##cls);
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)    \
        extern int s_cInst_##cls; \
        if (s_cInst_##cls) DbgInstanceRemaining(#cls, s_cInst_##cls);
#else
    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)
#endif

/////////////////////////////////////////////////////////////////////

#include "stdabout.h"
#include "MyBasePathsInfo.h"
#include <secondaryProppages.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dsadmin\cert.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2002
//
//  File:       cert.cpp
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
//	Cert.cpp
//
//	This file is the implementation of the CCertificate object.
//
//	GLOSSARY
//	- BLOB		Binary Large Object
//	- DER		Distinguished Encoding Rules
//	- RDN		Relative Distinguished Names
//
//	HISTORY
//	19-Jun-97	t-danm		Creation.
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "common.h"
#include "cert.h"


/////////////////////////////////////////////////////////////////////
CCertificate::CCertificate()
{
	m_paCertContext = NULL;
	m_blobCertData.pbData = NULL;
}

CCertificate::~CCertificate()
{
	// Free the certificate
	::CertFreeCertificateContext(m_paCertContext);
	delete m_blobCertData.pbData;
}


void DisplaySystemError (HWND hParent, DWORD dwErr)
{
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    CThemeContextActivator activator;

	LPVOID	lpMsgBuf = 0;
		
	FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,    
			NULL,
			dwErr,
			MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
			 (LPTSTR) &lpMsgBuf,    0,    NULL);
		
	// Display the string.
	CString	caption;
	//NTRAID#NTBUG9-571300-2002/03/10-jmessec   LoadString can fail...
	VERIFY (caption.LoadString (IDS_ADD_CERTIFICATE_MAPPING));
	::MessageBox (hParent, (LPWSTR) lpMsgBuf, (LPCTSTR) caption, MB_OK | MB_ICONINFORMATION);
	// Free the buffer.
	LocalFree (lpMsgBuf);
}

// This code copied from CertMgr project - LOCATE.C  
BOOL CCertificate::FLoadCertificate (LPCTSTR szFile)
{
  CThemeContextActivator activator;

	ASSERT (szFile);
	if ( !szFile )
		return FALSE;

	BOOL			bReturn = FALSE;
    PVOID			FileNameVoidP = (PVOID) szFile;
    PCCERT_CONTEXT  pCertContext = NULL;
    DWORD			dwEncodingType = 0;
    DWORD			dwContentType = 0;
    DWORD			dwFormatType = 0;

	// NB.  It's possible to read in a serialized store at this point, too.
	// We've have to add the UI to display the certs in the file so the
	// user could pick one.  Use CryptUIDlgSelectCertificate ().
    bReturn = ::CryptQueryObject (
			CERT_QUERY_OBJECT_FILE,
			FileNameVoidP,
			CERT_QUERY_CONTENT_FLAG_ALL, //CERT_QUERY_CONTENT_CERT | CERT_QUERY_CONTENT_SERIALIZED_CERT,
			CERT_QUERY_FORMAT_FLAG_ALL,
			0,
			&dwEncodingType,
			&dwContentType,
			&dwFormatType,
			NULL,
			NULL,
			(const void **)&pCertContext);

	ASSERT (bReturn);
    if ( bReturn ) 
	{
        //
        // Success. See what we get back.
        //

		if ( (dwContentType != CERT_QUERY_CONTENT_CERT) || !pCertContext ) 
		{
            //
            // Not a valid cert file.
            //
            if  ( pCertContext )
                ::CertFreeCertificateContext (pCertContext);

            CString text;
			CString	caption;

            VERIFY (text.LoadString (IDS_CERTFILEFORMATERR));
			VERIFY (caption.LoadString (IDS_ADD_CERTIFICATE_MAPPING));
            MessageBox (NULL, text, caption, MB_OK | MB_ICONINFORMATION);
            bReturn = FALSE;
        }
		else
		{
			// Cert context is valid - let's save it to the global handle
			m_paCertContext = pCertContext;
		}
	}
	else
	{
		DWORD	dwErr = GetLastError ();

		DisplaySystemError (NULL, dwErr);
	}

	return bReturn;
}


/////////////////////////////////////////////////////////////////////
//	This routine is a wrapper to API ::CertNameToStr() automatically
//	calculating the length of the output string and returning the data
//	into the CString object.
void CCertificate::CertNameToCString(
	IN DWORD dwCertEncodingType,
	IN CERT_NAME_BLOB * pName,
	OUT CString * pstrData)
{
	ASSERT(pstrData != NULL);
	// Calculate how many characters are needed
	int cch = ::CertNameToStr(
        IN dwCertEncodingType,
		IN pName,
		IN c_dwCertNameStrType,
		NULL, 0);
	TCHAR * pchT = pstrData->GetBuffer(cch);
	ASSERT(pchT != NULL);
	ASSERT(lstrlen(pchT) == 0);
	(void)::CertNameToStr(
		IN dwCertEncodingType,
		IN pName,
		IN c_dwCertNameStrType,
		OUT pchT, IN cch);
	pstrData->ReleaseBuffer();
} // CCertificate::CertNameToCString()


/////////////////////////////////////////////////////////////////////
void CCertificate::GetIssuer(OUT CString * pstrName)
{
	ASSERT(pstrName != NULL);
	ASSERT(m_paCertContext != NULL);
	ASSERT(m_paCertContext->pCertInfo != NULL);

	CERT_INFO * pCertInfo = m_paCertContext->pCertInfo;

	BOOL fSelfIssued = CertCompareCertificateName(
			m_paCertContext->dwCertEncodingType,
			&pCertInfo->Subject,
			&pCertInfo->Issuer);
	if (fSelfIssued)
	{
		// Self issued certificate
		GetSubject(OUT pstrName);
		return;
	}
	// Get the issuer
	CertNameToCString(
		IN m_paCertContext->dwCertEncodingType,
		IN &pCertInfo->Issuer,
		OUT pstrName);
} // CCertificate::GetIssuer()


/////////////////////////////////////////////////////////////////////
void CCertificate::GetSubject(OUT CString * pstrName)
{
	ASSERT(pstrName != NULL);
	ASSERT(m_paCertContext != NULL);
	ASSERT(m_paCertContext->pCertInfo != NULL);

	CertNameToCString(
		IN m_paCertContext->dwCertEncodingType,
		IN &m_paCertContext->pCertInfo->Subject,
		OUT pstrName);
} // CCertificate::GetSubject()


/////////////////////////////////////////////////////////////////////
void CCertificate::GetAltSubject(OUT CString * pstrName)
{
	ASSERT(pstrName != NULL);
	ASSERT(m_paCertContext != NULL);
	ASSERT(m_paCertContext->pCertInfo != NULL);

	pstrName->Empty();
	CERT_INFO * pCertInfo = m_paCertContext->pCertInfo;
	CERT_EXTENSION * pCertExtension;

	// Search for the AltSubject in the extensions
	pCertExtension = ::CertFindExtension(
		IN szOID_SUBJECT_ALT_NAME, // Same as X509_ALTERNATE_NAME
		IN pCertInfo->cExtension,
		IN pCertInfo->rgExtension);
	if (pCertExtension == NULL)
		return;		// No AltSubject

	DWORD dwErr = ERROR_SUCCESS;
	BOOL fSuccess;
	DWORD cbData = 0;
	// Find out how many bytes are needed for AltSubject
	fSuccess = ::CryptDecodeObject(
		m_paCertContext->dwCertEncodingType,
		X509_ALTERNATE_NAME,
		IN pCertExtension->Value.pbData,
		IN pCertExtension->Value.cbData,
		0,	// dwFlags
		NULL,
		INOUT &cbData);
	if (!fSuccess)
	{
		dwErr = ::GetLastError();
		TRACE1("CryptDecodeObject() returned error %u", dwErr);
		return;
	}
	ASSERT(cbData > 0);
	BYTE * pbDataT = new BYTE[cbData];

	// Decode the AltSubject name
	fSuccess = ::CryptDecodeObject(
		m_paCertContext->dwCertEncodingType,
		X509_ALTERNATE_NAME,
		IN pCertExtension->Value.pbData,
		IN pCertExtension->Value.cbData,
		0,	// dwFlags
		OUT pbDataT,
		INOUT &cbData);
	if (!fSuccess)
	{
		dwErr = ::GetLastError();
		TRACE1("CryptDecodeObject() returned error %u", dwErr);
	}
	else
	{
		CERT_ALT_NAME_INFO * pCertAltNameInfo = (CERT_ALT_NAME_INFO *)pbDataT;
		CERT_ALT_NAME_ENTRY * pEntry = pCertAltNameInfo->rgAltEntry;
		ASSERT(pEntry != NULL);
		for (UINT i = 0; i < pCertAltNameInfo->cAltEntry; i++, pEntry++)
		{
			if (pEntry->dwAltNameChoice == CERT_ALT_NAME_DNS_NAME)
			{
				*pstrName = pEntry->pwszDNSName;
				break;
			}

		} // for
	} // if...else
	delete [] pbDataT;
} // CCertificate::GetAltSubject()

/////////////////////////////////////////////////////////////////////
void CCertificate::GetSimString(OUT CString * pstrData)
{
	ASSERT(pstrData != NULL);

	CString strIssuer;
	CString strSubject;
	CString strAltSubject;
	GetIssuer(OUT &strIssuer);
	GetSubject(OUT &strSubject);
	GetAltSubject(OUT &strAltSubject);

	LPTSTR * pargzpszIssuer = ParseSimString(strIssuer);
	LPTSTR * pargzpszSubject = ParseSimString(strSubject);
	LPTSTR * pargzpszAltSubject = ParseSimString(strAltSubject);

	// Make a "X509" string
	UnsplitX509String(OUT pstrData, pargzpszIssuer, pargzpszSubject, pargzpszAltSubject);
	
	delete pargzpszIssuer;
	delete pargzpszSubject;
	delete pargzpszAltSubject;
} // CCertificate::GetSimString()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dsadmin\common.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       common.h
//
//--------------------------------------------------------------------------

//	Common.h
//
//	Include files that are used frequently into the project.
//

#ifndef _COMMON_H_INCLUDED
#define _COMMON_H_INCLUDED


#ifdef _DEBUG
	#define DEBUG
#endif

// Generic Includes
#include "DbgUtil.h"
#include "uiutil.h"

// Private Includes
#include "resource.h"
#include "SimRc.h"
#include "SimUtil.h"
#include "SimData.h"
#include "SimProp.h"
#include "SimProp1.h"
#include "SimProp2.h"
#include "SimProp3.h"
#include "SimCert.h"

#endif // ~_COMMON_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dsadmin\cert.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       cert.h
//
//--------------------------------------------------------------------------

//	Cert.h

#ifndef __CERT_H_INCLUDED__
#define __CERT_H_INCLUDED__

#include "util.h"	// structure TBLOB

class CCertificate
{
protected:
	PCCERT_CONTEXT m_paCertContext;		// Pointer to allocated certificate
	TBLOB m_blobCertData;				// Raw data read from the file

	// Default flag for CertNameToStr()
	enum { c_dwCertNameStrType = CERT_X500_NAME_STR };

public:
	CCertificate();
	~CCertificate();

	BOOL FLoadCertificate(LPCTSTR szFile);
	
	void CertNameToCString(
		IN DWORD dwCertEncodingType,
		IN CERT_NAME_BLOB * pName,
		OUT CString * pstrData);

	void GetIssuer(OUT CString * pstrName);
	void GetSubject(OUT CString * pstrName);
	void GetAltSubject(OUT CString * pstrName);
	void GetSimString(OUT CString * pstrData);

}; // CCertificate

// Those strings are not subject to localization
const TCHAR szX509[]			= _T("X509:");
const TCHAR szKerberos[]		= _T("Kerberos:");

#define cchX509					(ARRAYLEN(szX509) - 1)
#define cchKerberos				(ARRAYLEN(szKerberos) - 1)

// Strings with angle brackets
const TCHAR szSimIssuer[]		= _T("<I>");
const TCHAR szSimSubject[]		= _T("<S>");
const TCHAR szSimAltSubject[]	= _T("<AS>");

#endif // ~__CERT_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dsadmin\contextmenu.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ContextMenu.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"

#include "dsutil.h"

#include "ContextMenu.h"
#include "dsfilter.h"
#include "resource.h"
#include "query.h"


/////////////////////////////////////////////////////////////////////
// Language independent IDs for known context menu items
// WARNING : these should NEVER be changed 
//           the whole point of having these is so that other
//           developers can rely on them being the same no matter
//           what language or version they use.  The context menus
//           can change but their IDs should not
//
//
#define CMID_GEN_TASK_SELECT_FOREST     L"_DSADMIN_SELECT_FOREST"
#define CMID_GEN_TASK_SELECT_DOMAIN     L"_DSADMIN_SELECT_DOMAIN"
#define CMID_GEN_TASK_SELECT_DC         L"_DSADMIN_SELECT_DC"
#define CMID_GEN_TASK_EDIT_FSMO         L"_DSADMIN_EDIT_FSMO"
#define CMID_GEN_TASK_RAISE_VERSION     L"_DSADMIN_GEN_RAISE_VERSION"
#define CMID_VIEW_SERVICES_NODE         L"_DSADMIN_VIEW_SERVICES"
#define CMID_VIEW_COMPUTER_HACK         L"_DSADMIN_VIEW_COMPUTERS_AS_CONTAINERS"
#define CMID_VIEW_ADVANCED              L"_DSADMIN_VIEW_ADVANCED"
#define CMID_IMPORT_QUERY               L"_DSADMIN_IMPORT_QUERY"
#define CMID_NEW_QUERY_FOLDER           L"_DSADMIN_NEW_QUERY"
#define CMID_NEW_FAVORITES_FOLDER       L"_DSADMIN_NEW_FAVORITES"
#define CMID_EDIT_QUERY                 L"_DSADMIN_EDIT_QUERY"
#define CMID_EXPORT_QUERY               L"_DSADMIN_EXPORT_QUERY"
#define CMID_VIEW_FILTER_OPTIONS        L"_DSADMIN_VIEW_FILTER"
#define CMID_DS_OBJECT_FIND             L"_DSADMIN_FIND"
#define CMID_GEN_TASK_RUN_KCC           L"_DSADMIN_RUN_KCC"
#define CMID_GEN_TASK_MOVE              L"_DSADMIN_MOVE"


// Schema version containing the adminMultiselectPropertyPages attribute

#define SCHEMA_VERSION_WITH_MULTISELECT_PROPPAGES 15

void CContextMenuVerbs::LoadStandardVerbs(IConsoleVerb* pConsoleVerb, 
                                          BOOL bScope, 
                                          BOOL bSelect, 
                                          CUINode* pUINode,
                                          CInternalFormatCracker& ifc,
                                          LPDATAOBJECT pDataObject) 
{
  if (!bSelect || pUINode == NULL)
  {
    return;
  }

  if (pConsoleVerb)
  {

    if (bScope)
    {
      //
      // Item is in scope pane. Therefore it is a container.
      //
      pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);
    }
    else
    {
      //
      // Item is in result pane. Make properties the default verb.
      //
      pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);
    }

    //
    // Verbs supported by all items, except root
    //
    if (pDataObject != NULL && ifc.GetCookieCount() > 1) 
    {
      //
      // multiple selection
      //
      pConsoleVerb->SetVerbState(MMC_VERB_RENAME, HIDDEN, TRUE);
      pConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, FALSE);
      pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, TRUE);
      pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, FALSE);

      if (pUINode->IsSnapinRoot() ||
          (pUINode->GetParent() && pUINode->GetParent()->IsSnapinRoot()))
      {
         // Everything should be disabled if we are looking at children of
         // the root

         pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, TRUE);
         pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, FALSE);
         pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, TRUE);
         pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, FALSE);
         pConsoleVerb->SetVerbState(MMC_VERB_CUT, HIDDEN, TRUE);
         pConsoleVerb->SetVerbState(MMC_VERB_CUT, ENABLED, FALSE);
         pConsoleVerb->SetVerbState(MMC_VERB_COPY, HIDDEN, TRUE);
         pConsoleVerb->SetVerbState(MMC_VERB_COPY, ENABLED, FALSE);

      }
      else
      {
         //
         // Can delete
         //
         pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, FALSE);
         pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE);

         //
         // Properties - multiselect properties are only available for
         //              schema version 15 or greater
         //

         UINT schemaVersion = m_pComponentData->GetBasePathsInfo()->GetSchemaVersion();
         TRACE(L"Schema version = %d\n", schemaVersion);
         if (schemaVersion >= SCHEMA_VERSION_WITH_MULTISELECT_PROPPAGES)
         {
            pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, FALSE);
            pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
         }
         else
         {
            pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, TRUE);
            pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, FALSE);
         }

         //
         // Can cut
         //
         // NOTICE: we use the same logic as the delete verb: we
         // always allow cut, even though the single items in the
         // multiple selection might have Cut turned off.
         pConsoleVerb->SetVerbState(MMC_VERB_CUT, HIDDEN, FALSE);
         pConsoleVerb->SetVerbState(MMC_VERB_CUT, ENABLED, TRUE);

         //
         // Can copy
         //
         pConsoleVerb->SetVerbState(MMC_VERB_COPY, HIDDEN, TRUE);
         pConsoleVerb->SetVerbState(MMC_VERB_COPY, ENABLED, FALSE);

      }
    }
    else  // single selection
    {
      BOOL bEnable = FALSE;
      BOOL bHide = TRUE;

      //
      // Properties
      //
      bEnable = pUINode->ArePropertiesAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, bEnable);

      //
      // Rename
      //
      bEnable = pUINode->IsRenameAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_RENAME, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, bEnable);

      //
      // Delete
      //
      bEnable = pUINode->IsDeleteAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, bEnable);

      //
      // Refresh
      //
      bEnable = pUINode->IsRefreshAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, bEnable);

      //
      // Cut
      //

      bEnable = pUINode->IsCutAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_CUT, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_CUT, ENABLED, bEnable);
      
      //
      // Copy
      //
      bEnable = pUINode->IsCopyAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_COPY, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_COPY, ENABLED, bEnable);
      
      //
      // Paste
      //
      bEnable = pUINode->IsPasteAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PASTE, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PASTE, ENABLED, bEnable);

      //
      // Print
      //
      bEnable = pUINode->IsPrintAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PRINT, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PRINT, ENABLED, bEnable);
    }
  }
}

HRESULT CContextMenuVerbs::DSLoadAndAddMenuItem(IContextMenuCallback2* pIContextMenuCallback,
                                                  UINT nResourceID, // contains text and status text seperated by '\n'
                                                  long lCommandID,
                                                  long lInsertionPointID,
                                                  long fFlags,
                                                  PCWSTR pszLanguageIndependentID,
                                                  long fSpecialFlags)
{
  ASSERT( pIContextMenuCallback != NULL );

  // load the resource
  CString strText;
  strText.LoadString( nResourceID );
  ASSERT( !strText.IsEmpty() );

  // split the resource into the menu text and status text
  CString strStatusText;
  int iSeparator = strText.Find(_T('\n'));
  if (0 > iSeparator)
  {
    ASSERT( FALSE );
    strStatusText = strText;
  }
  else
  {
    strStatusText = strText.Right( strText.GetLength()-(iSeparator+1) );
    strText = strText.Left( iSeparator );
  }

  // add the menu item
  USES_CONVERSION;
  CONTEXTMENUITEM2 contextmenuitem;
  ::ZeroMemory( &contextmenuitem, sizeof(contextmenuitem) );
  contextmenuitem.strName = T2OLE(const_cast<LPTSTR>((LPCTSTR)strText));
  contextmenuitem.strStatusBarText = T2OLE(const_cast<LPTSTR>((LPCTSTR)strStatusText));
  contextmenuitem.lCommandID = lCommandID;
  contextmenuitem.lInsertionPointID = lInsertionPointID;
  contextmenuitem.fFlags = fFlags;
  contextmenuitem.fSpecialFlags = ((fFlags & MF_POPUP) ? CCM_SPECIAL_SUBMENU : 0L) | fSpecialFlags;
  contextmenuitem.strLanguageIndependentName = const_cast<PWSTR>(pszLanguageIndependentID);
  HRESULT hr = pIContextMenuCallback->AddItem( &contextmenuitem );
  ASSERT(hr == S_OK);
  
  return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CSnapinRootMenuVerbs
//

HRESULT CSnapinRootMenuVerbs::LoadTopMenu(IContextMenuCallback2* pContextMenuCallback, 
                                          CUINode*) 
{
  TRACE(_T("CSnapinRootMenuVerbs::LoadTopMenu()\n"));
  HRESULT hr = S_OK;
  UINT nMenuItem = 0;
  PCWSTR pszLIID = NULL;

  if (m_pComponentData->QuerySnapinType() == SNAPINTYPE_SITE)
  {
    nMenuItem = IDM_GEN_TASK_SELECT_FOREST;
    pszLIID = CMID_GEN_TASK_SELECT_FOREST;
  }
  else
  {
    nMenuItem = IDM_GEN_TASK_SELECT_DOMAIN;
    pszLIID = CMID_GEN_TASK_SELECT_DOMAIN;
  }

  hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                             nMenuItem,
                             nMenuItem,
                             CCM_INSERTIONPOINTID_PRIMARY_TOP,
                             0,
                             pszLIID);
  ASSERT(SUCCEEDED(hr));

  hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                             IDM_GEN_TASK_SELECT_DC,
                             IDM_GEN_TASK_SELECT_DC,
                             CCM_INSERTIONPOINTID_PRIMARY_TOP,
                             0,
                             pszLIID);
  ASSERT(SUCCEEDED(hr));

  return hr;
}

HRESULT CSnapinRootMenuVerbs::LoadTaskMenu(IContextMenuCallback2* pContextMenuCallback,
                                           CUINode*) 
{
  TRACE(_T("CSnapinRootMenuVerbs::LoadTaskMenu()\n"));
  HRESULT hr = S_OK;
  UINT nMenuItem = 0;
  PWSTR pszLIID = NULL;

  if (m_pComponentData->QuerySnapinType() == SNAPINTYPE_SITE)
  {
    nMenuItem = IDM_GEN_TASK_SELECT_FOREST;
    pszLIID = CMID_GEN_TASK_SELECT_FOREST;
  }
  else
  {
    nMenuItem = IDM_GEN_TASK_SELECT_DOMAIN;
    pszLIID = CMID_GEN_TASK_SELECT_DOMAIN;
  }

  hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                             nMenuItem,
                             nMenuItem,
                             CCM_INSERTIONPOINTID_PRIMARY_TASK,
                             0,
                             pszLIID);
  ASSERT(SUCCEEDED(hr));

  hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                             IDM_GEN_TASK_SELECT_DC,
                             IDM_GEN_TASK_SELECT_DC,
                             CCM_INSERTIONPOINTID_PRIMARY_TASK,
                             0,
                             pszLIID);
  ASSERT(SUCCEEDED(hr));

  if (m_pComponentData->QuerySnapinType() != SNAPINTYPE_SITE &&
      m_pComponentData->GetBasePathsInfo()->IsInitialized())
  {
    //
    // Load Operations Masters... menu
    //
    hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                               IDM_GEN_TASK_EDIT_FSMO,
                               IDM_GEN_TASK_EDIT_FSMO,
                               CCM_INSERTIONPOINTID_PRIMARY_TASK,
                               0,
                               CMID_GEN_TASK_EDIT_FSMO);
    ASSERT(SUCCEEDED(hr));

    //
    // Load Raise Domain Version... menu item.
    //
    hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                               IDM_GEN_TASK_RAISE_VERSION,
                               IDM_GEN_TASK_RAISE_VERSION,
                               CCM_INSERTIONPOINTID_PRIMARY_TASK,
                               0,
                               CMID_GEN_TASK_RAISE_VERSION);
    ASSERT(SUCCEEDED(hr));
  }

  return hr;
}

HRESULT CSnapinRootMenuVerbs::LoadViewMenu(IContextMenuCallback2* pContextMenuCallback, 
                                           CUINode*) 
{
  HRESULT hr = S_OK;

  if (m_pComponentData->QuerySnapinType() == SNAPINTYPE_SITE)
  {
    hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                               IDM_VIEW_SERVICES_NODE,
                               IDM_VIEW_SERVICES_NODE,
                               CCM_INSERTIONPOINTID_PRIMARY_VIEW,
                               m_pComponentData->ViewServicesNode()? MF_CHECKED : 0,
                               CMID_VIEW_SERVICES_NODE);
    ASSERT(SUCCEEDED(hr));
  }
  else
  {
    //
    // AD U&G
    //
    hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                           IDM_VIEW_COMPUTER_HACK,
                           IDM_VIEW_COMPUTER_HACK,
                           CCM_INSERTIONPOINTID_PRIMARY_VIEW,
                           m_pComponentData->ExpandComputers()? MF_CHECKED : 0,
                           CMID_VIEW_COMPUTER_HACK);
    ASSERT(SUCCEEDED(hr));

    hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                               IDM_VIEW_ADVANCED,
                               IDM_VIEW_ADVANCED,
                               CCM_INSERTIONPOINTID_PRIMARY_VIEW,
                               m_pComponentData->GetQueryFilter()->IsAdvancedView()? MF_CHECKED : 0,
                               CMID_VIEW_ADVANCED);
    ASSERT(SUCCEEDED(hr));

   if (m_pComponentData->QuerySnapinType() != SNAPINTYPE_SITE &&
         m_pComponentData->GetBasePathsInfo()->IsInitialized())
   {
      //
      // Load Raise Domain Version... menu item.
      //
      hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                                 IDM_GEN_TASK_RAISE_VERSION,
                                 IDM_GEN_TASK_RAISE_VERSION,
                                 CCM_INSERTIONPOINTID_PRIMARY_VIEW,
                                 0,
                                 CMID_GEN_TASK_RAISE_VERSION);
      ASSERT(SUCCEEDED(hr));
   }

   if (m_pComponentData->IsPrimarySnapin())
   {
      //
      // Insert these if running as a primary snapin and not an extension
      //
      hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                                 IDM_VIEW_FILTER_OPTIONS,
                                 IDM_VIEW_FILTER_OPTIONS,
                                 CCM_INSERTIONPOINTID_PRIMARY_VIEW,
                                 0,
                                 CMID_VIEW_FILTER_OPTIONS);
      ASSERT(SUCCEEDED(hr));
   }
  }

  return hr;
} 

/////////////////////////////////////////////////////////////////////////////
// CFavoritesFolderMenuVerbs
//

void CFavoritesFolderMenuVerbs::LoadStandardVerbs(IConsoleVerb* pConsoleVerb, 
                                                  BOOL bScope, 
                                                  BOOL bSelect, 
                                                  CUINode* pUINode,
                                                  CInternalFormatCracker& ifc,
                                                  LPDATAOBJECT pDataObject) 
{
  if (!bSelect || pUINode == NULL)
  {
    return;
  }

  if (pConsoleVerb)
  {

    if (bScope)
    {
      //
      // Item is in scope pane. Therefore it is a container.
      //
      pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);
    }
    else
    {
      //
      // Item is in result pane. Make properties the default verb.
      //
      pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);
    }

    //
    // Verbs supported by all items, except root
    //
    if (pDataObject != NULL && ifc.GetCookieCount() > 1) 
    {
      //
      // multiple selection
      //
      if (pUINode->IsSnapinRoot() ||
          (pUINode->GetParent() && pUINode->GetParent()->IsSnapinRoot()))
      {
         // Everything should be disabled if we are looking at children of
         // the root

         pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, TRUE);
         pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, FALSE);
         pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, TRUE);
         pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, FALSE);
         pConsoleVerb->SetVerbState(MMC_VERB_CUT, HIDDEN, TRUE);
         pConsoleVerb->SetVerbState(MMC_VERB_CUT, ENABLED, FALSE);
         pConsoleVerb->SetVerbState(MMC_VERB_COPY, HIDDEN, TRUE);
         pConsoleVerb->SetVerbState(MMC_VERB_COPY, ENABLED, FALSE);

      }
      else
      {
         pConsoleVerb->SetVerbState(MMC_VERB_RENAME, HIDDEN, TRUE);
         pConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, FALSE);
         pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, TRUE);
         pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, FALSE);

         //
         // Can delete
         //
         pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, FALSE);
         pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE);

         //
         // Properties
         //
         pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, TRUE);
         pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, FALSE);

         //
         // Can cut
         //
         // NOTICE: we use the same logic as the delete verb: we
         // always allow cut, even though the single items in the
         // multiple selection might have Cut turned off.
         pConsoleVerb->SetVerbState(MMC_VERB_CUT, HIDDEN, FALSE);
         pConsoleVerb->SetVerbState(MMC_VERB_CUT, ENABLED, TRUE);

         //
         // Can copy
         //
         pConsoleVerb->SetVerbState(MMC_VERB_COPY, HIDDEN, FALSE);
         pConsoleVerb->SetVerbState(MMC_VERB_COPY, ENABLED, TRUE);

      }
    }
    else  // single selection
    {
      BOOL bEnable = FALSE;
      BOOL bHide = TRUE;

      //
      // Properties
      //
      bEnable = pUINode->ArePropertiesAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, bEnable);

      //
      // Rename
      //
      bEnable = pUINode->IsRenameAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_RENAME, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, bEnable);

      //
      // Delete
      //
      bEnable = pUINode->IsDeleteAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, bEnable);

      //
      // Refresh
      //
      bEnable = pUINode->IsRefreshAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, bEnable);
      
      //
      // Paste
      //
      bEnable = pUINode->IsPasteAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PASTE, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PASTE, ENABLED, bEnable);

      //
      // Cut
      //
      bEnable = pUINode->IsCutAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_CUT, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_CUT, ENABLED, bEnable);
      
      //
      // Copy
      //
      bEnable = pUINode->IsCopyAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_COPY, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_COPY, ENABLED, bEnable);

      //
      // Print
      //
      bEnable = pUINode->IsPrintAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PRINT, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PRINT, ENABLED, bEnable);
    }
  }
}


HRESULT CFavoritesFolderMenuVerbs::LoadTopMenu(IContextMenuCallback2* pContextMenuCallback, 
                                               CUINode*) 
{
  HRESULT hr = S_OK;

  long flags = 0;
  if (!m_pComponentData->GetBasePathsInfo()->IsInitialized())
  {
     flags |= MF_GRAYED;
  }
  hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                             IDM_IMPORT_QUERY,
                             IDM_IMPORT_QUERY,
                             CCM_INSERTIONPOINTID_PRIMARY_TOP,
                             flags,
                             CMID_IMPORT_QUERY);
  ASSERT(SUCCEEDED(hr));
  return hr;
}

HRESULT CFavoritesFolderMenuVerbs::LoadTaskMenu(IContextMenuCallback2* pContextMenuCallback,
                                                CUINode*) 
{
  HRESULT hr = S_OK;

  long flags = 0;
  if (!m_pComponentData->GetBasePathsInfo()->IsInitialized())
  {
     flags |= MF_GRAYED;
  }
  hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                             IDM_IMPORT_QUERY,
                             IDM_IMPORT_QUERY,
                             CCM_INSERTIONPOINTID_PRIMARY_TASK,
                             flags,
                             CMID_IMPORT_QUERY);
  ASSERT(SUCCEEDED(hr));
  return hr;
}

HRESULT CFavoritesFolderMenuVerbs::LoadNewMenu(IContextMenuCallback2* pContextMenuCallback,
                                               IShellExtInit*,
                                               LPDATAOBJECT,
                                               CUINode*,
                                               long*) 
{
  HRESULT hr = S_OK;

  long flags = 0;
  if (!m_pComponentData->GetBasePathsInfo()->IsInitialized())
  {
     flags |= MF_GRAYED;
  }
  hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                             IDM_NEW_QUERY_FOLDER,
                             IDM_NEW_QUERY_FOLDER,
                             CCM_INSERTIONPOINTID_PRIMARY_NEW,
                             flags,
                             CMID_NEW_QUERY_FOLDER);


  hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                             IDM_NEW_FAVORITES_FOLDER,
                             IDM_NEW_FAVORITES_FOLDER,
                             CCM_INSERTIONPOINTID_PRIMARY_NEW,
                             0,
                             CMID_NEW_FAVORITES_FOLDER);
  return hr;
}

HRESULT CFavoritesFolderMenuVerbs::LoadViewMenu(IContextMenuCallback2* pContextMenuCallback, 
                                           CUINode*) 
{
  HRESULT hr = S_OK;

  hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                             IDM_VIEW_ADVANCED,
                             IDM_VIEW_ADVANCED,
                             CCM_INSERTIONPOINTID_PRIMARY_VIEW,
                             m_pComponentData->GetQueryFilter()->IsAdvancedView()? MF_CHECKED : 0,
                             CMID_VIEW_ADVANCED);
  ASSERT(SUCCEEDED(hr));

  return hr;
} 



/////////////////////////////////////////////////////////////////////////////
// CSavedQueryMenuVerbs
//

void CSavedQueryMenuVerbs::LoadStandardVerbs(IConsoleVerb* pConsoleVerb, 
                                             BOOL bScope, 
                                             BOOL bSelect, 
                                             CUINode* pUINode,
                                             CInternalFormatCracker& ifc,
                                             LPDATAOBJECT pDataObject) 
{
  if (!bSelect || pUINode == NULL)
  {
    return;
  }

  if (pConsoleVerb)
  {

    if (bScope)
    {
      //
      // Item is in scope pane. Therefore it is a container.
      //
      pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);
    }
    else
    {
      //
      // Item is in result pane. Make properties the default verb.
      //
      pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);
    }

    //
    // Verbs supported by all items, except root
    //
    if (pDataObject != NULL && ifc.GetCookieCount() > 1) 
    {
      //
      // multiple selection
      //
      pConsoleVerb->SetVerbState(MMC_VERB_RENAME, HIDDEN, TRUE);
      pConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, FALSE);
      pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, TRUE);
      pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, FALSE);

      //
      // Can delete
      //
      pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, FALSE);
      pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE);

      //
      // Properties
      //
      pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, TRUE);
      pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, FALSE);

      //
      // Can cut
      //
      // NOTICE: we use the same logic as the delete verb: we
      // always allow cut, even though the single items in the
      // multiple selection might have Cut turned off.
      pConsoleVerb->SetVerbState(MMC_VERB_CUT, HIDDEN, FALSE);
      pConsoleVerb->SetVerbState(MMC_VERB_CUT, ENABLED, TRUE);

      //
      // Can copy
      //
      pConsoleVerb->SetVerbState(MMC_VERB_COPY, HIDDEN, FALSE);
      pConsoleVerb->SetVerbState(MMC_VERB_COPY, ENABLED, TRUE);


    }
    else  // single selection
    {
      BOOL bEnable = FALSE;
      BOOL bHide = TRUE;

      //
      // Properties
      //
      bEnable = pUINode->ArePropertiesAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, bEnable);

      //
      // Rename
      //
      bEnable = pUINode->IsRenameAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_RENAME, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, bEnable);

      //
      // Delete
      //
      bEnable = pUINode->IsDeleteAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, bEnable);

      //
      // Refresh
      //
      bEnable = pUINode->IsRefreshAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, bEnable);

      //
      // Cut
      //

      bEnable = pUINode->IsCutAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_CUT, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_CUT, ENABLED, bEnable);
      
      //
      // Copy
      //
      bEnable = pUINode->IsCopyAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_COPY, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_COPY, ENABLED, bEnable);
      
      //
      // Paste
      //
      bEnable = pUINode->IsPasteAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PASTE, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PASTE, ENABLED, bEnable);

      //
      // Cut
      //
      bEnable = pUINode->IsCutAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_CUT, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_CUT, ENABLED, bEnable);
      
      //
      // Print
      //
      bEnable = pUINode->IsPrintAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PRINT, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PRINT, ENABLED, bEnable);
    }
  }
}

HRESULT CSavedQueryMenuVerbs::LoadTopMenu(IContextMenuCallback2* pContextMenuCallback, 
                                          CUINode*) 
{
  HRESULT hr = S_OK;

  hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                             IDM_EDIT_QUERY,
                             IDM_EDIT_QUERY,
                             CCM_INSERTIONPOINTID_PRIMARY_TOP,
                             0,
                             CMID_EDIT_QUERY);
  ASSERT(SUCCEEDED(hr));

  hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                             IDM_EXPORT_QUERY,
                             IDM_EXPORT_QUERY,
                             CCM_INSERTIONPOINTID_PRIMARY_TOP,
                             0,
                             CMID_EXPORT_QUERY);
  ASSERT(SUCCEEDED(hr));
  return hr;
}

HRESULT CSavedQueryMenuVerbs::LoadTaskMenu(IContextMenuCallback2* pContextMenuCallback,
                                           CUINode*) 
{
  HRESULT hr = S_OK;

  hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                             IDM_EDIT_QUERY,
                             IDM_EDIT_QUERY,
                             CCM_INSERTIONPOINTID_PRIMARY_TASK,
                             0,
                             CMID_EDIT_QUERY);
  ASSERT(SUCCEEDED(hr));

  hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                             IDM_EXPORT_QUERY,
                             IDM_EXPORT_QUERY,
                             CCM_INSERTIONPOINTID_PRIMARY_TASK,
                             0,
                             CMID_EXPORT_QUERY);
  ASSERT(SUCCEEDED(hr));
  return hr;
}

HRESULT CSavedQueryMenuVerbs::LoadViewMenu(IContextMenuCallback2* pContextMenuCallback, 
                                           CUINode*) 
{
  HRESULT hr = S_OK;

  hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                             IDM_VIEW_ADVANCED,
                             IDM_VIEW_ADVANCED,
                             CCM_INSERTIONPOINTID_PRIMARY_VIEW,
                             m_pComponentData->GetQueryFilter()->IsAdvancedView()? MF_CHECKED : 0,
                             CMID_VIEW_ADVANCED);
  ASSERT(SUCCEEDED(hr));

  return hr;
} 

/////////////////////////////////////////////////////////////////////////////
// CDSContextMenuVerbs
//

HRESULT CDSContextMenuVerbs::LoadNewMenu(IContextMenuCallback2* pContextMenuCallback,
                                         IShellExtInit* pShlInit,
                                         LPDATAOBJECT pDataObject,
                                         CUINode* pUINode,
                                         long *pInsertionAllowed) 
{
  HRESULT hr = S_OK;
  UINT cChildCount = 0;
  UINT index;

  if (pUINode == NULL) 
  {
    ASSERT(FALSE);
    return E_INVALIDARG;
  }

  CDSCookie* pCookie = NULL;
  ASSERT(IS_CLASS(pUINode, DS_UI_NODE));
  pCookie = GetDSCookieFromUINode(pUINode);
  ASSERT(pCookie != NULL);

  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  TRACE(_T("CDSComponentData::_LoadNewMenu (on %s)\n"), pCookie->GetName());
  CWaitCursor cwait;

  WCHAR ** ppChildren;
  ppChildren = pCookie->GetChildList();
  if (ppChildren == NULL) 
  {
    m_pComponentData->FillInChildList (pCookie);
    ppChildren = pCookie->GetChildList();
  }
  

  ///////////////////////////////////////////////////////////
  // get common menu items from DS and merge.
  //
  HMENU hDSMenu = CreatePopupMenu();
  if (hDSMenu == NULL)
  {
    TRACE(_T("Failed to CreatePopupMenu() in CDSContextMenuVerbs::LoadNewMenu()"));
    ASSERT(FALSE);
    return GetLastError();
  }

  BOOL fRet = TRUE;
  hr = pShlInit->Initialize(NULL, pDataObject, 0);
  if (FAILED(hr)) 
  {
    TRACE(TEXT("pShlInit->Initialize failed, hr: 0x%x\n"), hr);
  } 
  else 
  {
    IContextMenu * pICM= NULL;
    hr = pShlInit->QueryInterface(IID_IContextMenu, (void **)&pICM);
    
    if (FAILED(hr)) 
    {
      TRACE(TEXT("pShlInit->QI for IID_IContextMenu failed, hr: 0x%x\n"), hr);
    } 
    else 
    {
      //
      // NOTE: QueryContextMenu returns with the HRESULT with the severity set as normal
      //       for success and failure but the facility is zero and the code is the 
      //       count of the menu items added
      //
      hr = pICM->QueryContextMenu (hDSMenu, 0, MENU_MERGE_BASE, MENU_MERGE_LIMIT, NULL);
      if ((SUCCEEDED(hr)) && (HRESULT_CODE(hr) > 0)) 
      {
        UINT cItems = GetMenuItemCount (hDSMenu);
        MENUITEMINFO miiItem;
        miiItem.cbSize = sizeof(MENUITEMINFO);
        WCHAR szBuffer[MAX_PATH];

        for (index = 0; index < cItems; index++) 
        {
          miiItem.fMask = MIIM_TYPE | MIIM_DATA | MIIM_ID | MIIM_SUBMENU | MIIM_STATE;
          WCHAR * pszString = new WCHAR[MAX_PATH];
          miiItem.dwTypeData = pszString;
          miiItem.cch = MAX_PATH;
          fRet = GetMenuItemInfo (hDSMenu, index, TRUE, &miiItem);
          if (fRet) 
          {
            //
            // got item back, add it to MMC context menu
            //
            CONTEXTMENUITEM2 ctiItem;
            ::ZeroMemory( &ctiItem, sizeof(CONTEXTMENUITEM2) );

            hr = pICM->GetCommandString (miiItem.wID - MENU_MERGE_BASE, 
                                         GCS_HELPTEXT,
                                         NULL, 
                                         (char *)szBuffer, 
                                         MAX_PATH);

            ctiItem.strName = miiItem.dwTypeData;
            ctiItem.strStatusBarText = szBuffer;
            ctiItem.lCommandID = miiItem.wID;
            if (miiItem.fState == MFS_GRAYED) 
            {
              ctiItem.fFlags = MF_GRAYED;
            } 
            else 
            {
              ctiItem.fFlags = 0;
            }
            ctiItem.fSpecialFlags = 0;
            
            //
            // Now try to get a language independent identifier
            //
            WCHAR szLanguageIndependentID[MAX_PATH];
            ::ZeroMemory( szLanguageIndependentID, sizeof(WCHAR) * MAX_PATH);
            hr = pICM->GetCommandString(miiItem.wID - MENU_MERGE_BASE,
                                        GCS_VERBW,
                                        NULL,
                                        (char*)szLanguageIndependentID,
                                        MAX_PATH);
            if (SUCCEEDED(hr) && 
                szLanguageIndependentID && 
                szLanguageIndependentID[0] != 0)
            {
              ctiItem.strLanguageIndependentName = szLanguageIndependentID;

              //
              // Add the menu item to the Top of the MMC menu
              //
              if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
              {
                ctiItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
                hr = pContextMenuCallback->AddItem( &ctiItem );
                ASSERT(SUCCEEDED(hr));
              }

              if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK)
              {
                ctiItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
                hr = pContextMenuCallback->AddItem(&ctiItem );
                ASSERT(SUCCEEDED(hr));
              }
            }
            else
            {
              CComPtr<IContextMenuCallback> spOldCallback;
              hr = pContextMenuCallback->QueryInterface(IID_IContextMenuCallback, (void**)&spOldCallback);
              if (SUCCEEDED(hr))
              {
                if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK)
                {
                  ctiItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
                  hr = spOldCallback->AddItem((CONTEXTMENUITEM*)&ctiItem);
                  ASSERT(SUCCEEDED(hr));
                }

                if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
                {
                  ctiItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
                  hr = spOldCallback->AddItem((CONTEXTMENUITEM*)&ctiItem);
                  ASSERT(SUCCEEDED(hr));
                }
              }
            }
          }
          delete[] pszString;
        }
      }
    }
    if (pICM) 
    {
      pICM->Release();
    }
  }
  DestroyMenu(hDSMenu);

  ///////////////////////////////////////////////////////////
  // Insert the New menu items

  cChildCount = pCookie->GetChildCount();
  if (cChildCount != 0) 
  {
    for (index = 0; index < cChildCount; index++) 
    {
      CString strItem, strStatus;
      strItem = ppChildren[index];
      strStatus.LoadString(IDS_CREATEOBJ);
      
      UINT fFlags = 0;
      CONTEXTMENUITEM2 contextmenuitem;
      WCHAR wszFriendlyName[120];

      //
      // get localized name for class
      //
      hr = m_pComponentData->GetBasePathsInfo()->GetFriendlyClassName(ppChildren[index],
                                                                      wszFriendlyName, 
                                                                      sizeof(wszFriendlyName)/sizeof(WCHAR));
      if (SUCCEEDED(hr)) 
      {
        strItem = (CString)wszFriendlyName;
      } 
      else 
      {
        strItem = ppChildren[index];
      }
      
      ::ZeroMemory( &contextmenuitem, sizeof(contextmenuitem) );
      contextmenuitem.strName = T2OLE(const_cast<LPTSTR>((LPCTSTR)strItem));
      contextmenuitem.strStatusBarText = T2OLE(const_cast<LPTSTR>((LPCTSTR)strStatus));
      contextmenuitem.lCommandID = IDM_NEW_OBJECT_BASE + index;
      contextmenuitem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_NEW;
      contextmenuitem.fFlags = fFlags;
      contextmenuitem.fSpecialFlags = ((fFlags & MF_POPUP) ? CCM_SPECIAL_SUBMENU : 0L);
      contextmenuitem.strLanguageIndependentName = ppChildren[index];
      
      if (*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW)
      {
        hr = pContextMenuCallback->AddItem( &contextmenuitem );
        ASSERT(SUCCEEDED(hr));
      }

      if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
      {
        int nID = InsertAtTopContextMenu(pCookie->GetClass(), ppChildren[index]);
        if (0 != nID)
        {
          CString cstrNewObject;
          cstrNewObject.LoadString(nID);
          contextmenuitem.strName = T2OLE(const_cast<LPTSTR>((LPCTSTR)cstrNewObject));
          contextmenuitem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
          hr = pContextMenuCallback->AddItem( &contextmenuitem );
          ASSERT(SUCCEEDED(hr));
        }
      }
    }
  }
  
  return hr;
}

int CDSContextMenuVerbs::InsertAtTopContextMenu(LPCWSTR pwszParentClass, LPCWSTR pwszChildClass)
{
  int nID = 0;

  if (!wcscmp(pwszParentClass, L"subnetContainer"))
  {

    if (!wcscmp(pwszChildClass, L"subnet"))
    {
      nID = IDS_NEW_SUBNET;
    }

  } 
  else if (!wcscmp(pwszParentClass, L"nTDSDSA")) 
  {

    if (!wcscmp(pwszChildClass, L"nTDSConnection"))
    {
      nID = IDS_NEW_NTDSCONNECTION;
    }
  } 
  else if (!wcscmp(pwszParentClass, L"interSiteTransport"))
  {

    if (!wcscmp(pwszChildClass, L"siteLink"))
    {
      nID = IDS_NEW_SITELINK;
    }
    else if (!wcscmp(pwszChildClass, L"siteLinkBridge"))
    {
      nID = IDS_NEW_SITELINKBRIDGE;
    }
  } 
  else if (!wcscmp(pwszParentClass, L"sitesContainer"))
  {
    if (!wcscmp(pwszChildClass, L"site"))
    {
      nID = IDS_NEW_SITE;
    }
  }

  return nID;
}

HRESULT CDSContextMenuVerbs::LoadViewMenu(IContextMenuCallback2* pContextMenuCallback, 
                                          CUINode*) 
{
  HRESULT hr = S_OK;

  if ( m_pComponentData->IsPrimarySnapin())
  {
    //
    // Insert these if running as a primary snapin and not an extension
    //
    hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                               IDM_VIEW_FILTER_OPTIONS,
                               IDM_VIEW_FILTER_OPTIONS,
                               CCM_INSERTIONPOINTID_PRIMARY_VIEW,
                               0,
                               CMID_VIEW_FILTER_OPTIONS);
  }

  return hr;
}

HRESULT CDSContextMenuVerbs::LoadMenuExtensions(IContextMenuCallback2* piCMenuCallback,
                                                IShellExtInit* pShlInit,
                                                LPDATAOBJECT pDataObject,
                                                CUINode*) 
{
  UINT index = 0;
  HRESULT hr = S_OK;
  
  ///////////////////////////////////////////////////////////
  // get common menu items from DS and merge.
  HMENU hDSMenu = CreatePopupMenu();
  if (hDSMenu == NULL)
  {
    TRACE(_T("Failed to CreatePopupMenu() in CDSContextMenuVerbs::LoadMenuExtensions()"));
    ASSERT(FALSE);
    return GetLastError();
  }

  BOOL fRet = TRUE;
  CInternalFormatCracker ObjCracker;
  LPDATAOBJECT pDO = NULL;

  pDO = ObjCracker.ExtractMultiSelect (pDataObject);
  if (pDO == NULL) 
  {
    pDO = pDataObject;
  }

  hr = pShlInit->Initialize(NULL, pDO, 0);
  if (FAILED(hr)) 
  {
    TRACE(TEXT("pShlInit->Initialize failed, hr: 0x%x\n"), hr);
  } 
  else 
  {
    IContextMenu * pICM= NULL;
    hr = pShlInit->QueryInterface(IID_IContextMenu, (void **)&pICM);
    
    if (FAILED(hr)) 
    {
      TRACE(TEXT("pShlInit->QI for IID_IContextMenu failed, hr: 0x%x\n"), hr);
    } 
    else 
    {
      //
      // NOTE: QueryContextMenu returns with the HRESULT with the severity set as normal
      //       for success and failure but the facility is zero and the code is the 
      //       count of the menu items added
      //
      hr = pICM->QueryContextMenu (hDSMenu, 0, MENU_MERGE_BASE, MENU_MERGE_LIMIT, NULL);
      if ((SUCCEEDED(hr)) && (HRESULT_CODE(hr) > 0)) 
      {
        UINT cItems = GetMenuItemCount (hDSMenu);
        MENUITEMINFO miiItem;
        miiItem.cbSize = sizeof(MENUITEMINFO);
        WCHAR szBuffer[MAX_PATH];

        for (index = 0; index < cItems; index++) 
        {
          miiItem.fMask = MIIM_TYPE | MIIM_ID | MIIM_STATE;
          WCHAR * pszString = new WCHAR[MAX_PATH];
          miiItem.dwTypeData = pszString;
          miiItem.cch = MAX_PATH;
          fRet = GetMenuItemInfo (hDSMenu, index, TRUE, &miiItem);
          if (fRet) 
          {
            // got item back, add it to MMC context menu
            CONTEXTMENUITEM2 ctiItem;
            ::ZeroMemory( &ctiItem, sizeof(CONTEXTMENUITEM2) );

            hr = pICM->GetCommandString (miiItem.wID - MENU_MERGE_BASE, 
                                         GCS_HELPTEXT,
                                         NULL, 
                                         (char *)szBuffer, 
                                         MAX_PATH);

            ctiItem.strName = miiItem.dwTypeData;
            ctiItem.strStatusBarText = szBuffer;
            ctiItem.lCommandID = miiItem.wID;
            ctiItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
            if (miiItem.fState == MF_GRAYED) 
            {
              ctiItem.fFlags = MF_GRAYED;
            } 
            else 
            {
              ctiItem.fFlags = 0;
            }
            ctiItem.fSpecialFlags = 0;
            
            //
            // Now try to retrieve the language independent ID
            //
            WCHAR szLanguageIndependentID[MAX_PATH];
            ::ZeroMemory( szLanguageIndependentID, sizeof(WCHAR) * MAX_PATH);
            hr = pICM->GetCommandString(miiItem.wID - MENU_MERGE_BASE,
                                        GCS_VERBW,
                                        NULL,
                                        (char*)szLanguageIndependentID,
                                        MAX_PATH);
            if (SUCCEEDED(hr) && 
                szLanguageIndependentID &&
                szLanguageIndependentID[0] != 0)
            {
              ctiItem.strLanguageIndependentName = szLanguageIndependentID;

              hr = piCMenuCallback->AddItem( &ctiItem );
              ASSERT(SUCCEEDED(hr));
              ctiItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
              hr = piCMenuCallback->AddItem( &ctiItem );
            }
            else
            {
              CComPtr<IContextMenuCallback> spOldCallback;
              hr = piCMenuCallback->QueryInterface(IID_IContextMenuCallback, (void**)&spOldCallback);
              if (SUCCEEDED(hr))
              {
                hr = spOldCallback->AddItem( (CONTEXTMENUITEM*)&ctiItem );
                ASSERT(SUCCEEDED(hr));
                ctiItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
                hr = spOldCallback->AddItem( (CONTEXTMENUITEM*)&ctiItem );
              }
              ASSERT(SUCCEEDED(hr));
            }
          }
          delete[] pszString;
        }
      }
    }
    if (pICM) 
    {
      pICM->Release();
    }
  }
  DestroyMenu(hDSMenu);

  ///////////////////////////////////////////////////////////

  return hr;
  
}


///////////////////////////////////////////////////////////////////
// CDSAdminContextMenuVerbs
//

void CDSAdminContextMenuVerbs::LoadStandardVerbs(IConsoleVerb* pConsoleVerb, 
                                                 BOOL bScope, 
                                                 BOOL bSelect, 
                                                 CUINode* pUINode,
                                                 CInternalFormatCracker& ifc,
                                                 LPDATAOBJECT pDataObject) 
{
  CContextMenuVerbs::LoadStandardVerbs(pConsoleVerb, bScope, bSelect, pUINode, ifc, pDataObject);

}

HRESULT CDSAdminContextMenuVerbs::LoadTopMenu(IContextMenuCallback2* pContextMenuCallback, 
                                              CUINode* pUINode) 
{
  HRESULT hr = S_OK;

  hr = LoadTopTaskHelper(pContextMenuCallback, pUINode, CCM_INSERTIONPOINTID_PRIMARY_TOP);
  return hr;
}

HRESULT CDSAdminContextMenuVerbs::LoadTaskMenu(IContextMenuCallback2* pContextMenuCallback,
                                               CUINode* pUINode)
{
  HRESULT hr = S_OK;

  hr = LoadTopTaskHelper(pContextMenuCallback, pUINode, CCM_INSERTIONPOINTID_PRIMARY_TASK);
  return hr;
}

HRESULT CDSAdminContextMenuVerbs::LoadTopTaskHelper(IContextMenuCallback2* pContextMenuCallback, 
                                                    CUINode* pUINode,
                                                    int insertionPoint)
{
  TRACE(_T("CDSAdminContextMenuVerbs::LoadTopTaskHelper()\n"));
  HRESULT hr = S_OK;
  ASSERT(IS_CLASS(pUINode, DS_UI_NODE));

  if (pUINode->IsContainer())
  {
    //
    // Load Find menu
    //
    hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                               IDM_DS_OBJECT_FIND,
                               IDM_DS_OBJECT_FIND,
                               insertionPoint,
                               0,
                               CMID_DS_OBJECT_FIND);
    ASSERT(SUCCEEDED(hr));
  }


  CDSCookie* pCookie = NULL;
  pCookie = GetDSCookieFromUINode(pUINode);
  if (pCookie == NULL)
  {
    ASSERT(FALSE);
    return E_FAIL;
  }

  CString szClass;
  szClass = pCookie->GetClass();

  if (szClass == L"domainDNS")
  {
    //
    // Load Connect to Domain... menu
    //
    hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                               IDM_GEN_TASK_SELECT_DOMAIN,
                               IDM_GEN_TASK_SELECT_DOMAIN,
                               insertionPoint,
                               0,
                               CMID_GEN_TASK_SELECT_DOMAIN);
    ASSERT( SUCCEEDED(hr) );

    //
    // Load Connect to Domain Controller... menu
    //
    hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                               IDM_GEN_TASK_SELECT_DC,
                               IDM_GEN_TASK_SELECT_DC,
                               insertionPoint,
                               0,
                               CMID_GEN_TASK_SELECT_DC);
    ASSERT( SUCCEEDED(hr) );

    //
    // Load Raise Domain Version... menu item.
    //
    hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                               IDM_GEN_TASK_RAISE_VERSION,
                               IDM_GEN_TASK_RAISE_VERSION,
                               insertionPoint,
                               0,
                               CMID_GEN_TASK_RAISE_VERSION);
    ASSERT(SUCCEEDED(hr));

    if (m_pComponentData->GetBasePathsInfo()->IsInitialized())
    {
       //
       // Load Operations Masters... menu
       //
       hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                                  IDM_GEN_TASK_EDIT_FSMO,
                                  IDM_GEN_TASK_EDIT_FSMO,
                                  insertionPoint,
                                  0,
                                  CMID_GEN_TASK_EDIT_FSMO);
       ASSERT(SUCCEEDED(hr));
    }
  }
  return hr;
}

HRESULT CDSAdminContextMenuVerbs::LoadViewMenu(IContextMenuCallback2* pContextMenuCallback, 
                                               CUINode* pUINode) 
{
  HRESULT hr = S_OK;
  
  hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                             IDM_VIEW_COMPUTER_HACK,
                             IDM_VIEW_COMPUTER_HACK,
                             CCM_INSERTIONPOINTID_PRIMARY_VIEW,
                             m_pComponentData->ExpandComputers()? MF_CHECKED : 0,
                             CMID_VIEW_COMPUTER_HACK);
  ASSERT(SUCCEEDED(hr));

  hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                             IDM_VIEW_ADVANCED,
                             IDM_VIEW_ADVANCED,
                             CCM_INSERTIONPOINTID_PRIMARY_VIEW,
                             m_pComponentData->GetQueryFilter()->IsAdvancedView()? MF_CHECKED : 0,
                             CMID_VIEW_ADVANCED);
  ASSERT(SUCCEEDED(hr));

  hr = CDSContextMenuVerbs::LoadViewMenu(pContextMenuCallback, pUINode);
  ASSERT(SUCCEEDED(hr));

  return hr;
}

///////////////////////////////////////////////////////////////////
// CSARContextMenuVerbs
//

void CSARContextMenuVerbs::LoadStandardVerbs(IConsoleVerb* pConsoleVerb, 
                                             BOOL bScope, 
                                             BOOL bSelect, 
                                             CUINode* pUINode,
                                             CInternalFormatCracker& ifc,
                                             LPDATAOBJECT pDataObject) 
{
  ASSERT(IS_CLASS(pUINode, DS_UI_NODE));
  CDSCookie* pCookie = NULL;
  pCookie = GetDSCookieFromUINode(pUINode);

  CString szClass;
  szClass = pCookie->GetClass();

  if (!bSelect || pUINode == NULL)
  {
    return;
  }

  if (pConsoleVerb)
  {

    if (bScope)
    {
      //
      // Item is in scope pane. Therefore it is a container.
      //
      pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);
    }
    else
    {
      //
      // Item is in result pane. Make properties the default verb.
      //
      pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);
    }

    //
    // Verbs supported by all items, except root
    //
    if (pDataObject != NULL && ifc.GetCookieCount() > 1) 
    {
      //
      // multiple selection
      //
      pConsoleVerb->SetVerbState(MMC_VERB_RENAME, HIDDEN, TRUE);
      pConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, FALSE);
      pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, TRUE);
      pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, FALSE);

      //
      // Can delete
      //
      pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, FALSE);
      pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE);

      //
      // Properties - multiselect properties are only available for
      //              schema version 15 or greater
      //

      UINT schemaVersion = m_pComponentData->GetBasePathsInfo()->GetSchemaVersion();
      TRACE(L"Schema version = %d\n", schemaVersion);
      if (schemaVersion >= SCHEMA_VERSION_WITH_MULTISELECT_PROPPAGES)
      {
        pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, FALSE);
        pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
      }
      else
      {
        pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, TRUE);
        pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, FALSE);
      }

      //
      // Can cut
      //
      // NOTICE: we are only allowing servers to be moved and since
      // servers are the only things in a serversContainer we enable
      // cut on multiselect only if the parent is a serversContainer
      //
      if (szClass.CompareNoCase(L"server"))
      {
        pConsoleVerb->SetVerbState(MMC_VERB_CUT, HIDDEN, TRUE);
        pConsoleVerb->SetVerbState(MMC_VERB_CUT, ENABLED, FALSE);
      }
      else
      {
        pConsoleVerb->SetVerbState(MMC_VERB_CUT, HIDDEN, FALSE);
        pConsoleVerb->SetVerbState(MMC_VERB_CUT, ENABLED, TRUE);
      }

      //
      // Can copy
      //
      pConsoleVerb->SetVerbState(MMC_VERB_COPY, HIDDEN, TRUE);
      pConsoleVerb->SetVerbState(MMC_VERB_COPY, ENABLED, FALSE);


    }
    else  // single selection
    {
      BOOL bEnable = FALSE;
      BOOL bHide = TRUE;

      //
      // Properties
      //
      bEnable = pUINode->ArePropertiesAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, bEnable);

      //
      // Rename
      //
      bEnable = pUINode->IsRenameAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_RENAME, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, bEnable);

      //
      // Delete
      //
      bEnable = pUINode->IsDeleteAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, bEnable);

      //
      // Refresh
      //
      bEnable = pUINode->IsRefreshAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, bEnable);

      //
      // Cut
      //

      bEnable = pUINode->IsCutAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_CUT, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_CUT, ENABLED, bEnable);
      
      //
      // Copy
      //
      bEnable = pUINode->IsCopyAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_COPY, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_COPY, ENABLED, bEnable);
      
      //
      // Paste
      //
      bEnable = pUINode->IsPasteAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PASTE, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PASTE, ENABLED, bEnable);

      //
      // Print
      //
      bEnable = pUINode->IsPrintAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PRINT, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PRINT, ENABLED, bEnable);
    }
  }

}

HRESULT CSARContextMenuVerbs::LoadTopMenu(IContextMenuCallback2* pContextMenuCallback, 
                                          CUINode* pUINode) 
{
  HRESULT hr = S_OK;

  hr = CDSContextMenuVerbs::LoadTopMenu(pContextMenuCallback, pUINode);
  ASSERT(SUCCEEDED(hr));

  hr = LoadTopTaskHelper(pContextMenuCallback, pUINode, CCM_INSERTIONPOINTID_PRIMARY_TOP);
  return hr;
}

HRESULT CSARContextMenuVerbs::LoadTaskMenu(IContextMenuCallback2* pContextMenuCallback, 
                                           CUINode* pUINode) 
{
  HRESULT hr = S_OK;

  hr = CDSContextMenuVerbs::LoadTaskMenu(pContextMenuCallback, pUINode);
  ASSERT(SUCCEEDED(hr));

  hr = LoadTopTaskHelper(pContextMenuCallback, pUINode, CCM_INSERTIONPOINTID_PRIMARY_TASK);
  ASSERT(SUCCEEDED(hr));

  ASSERT(IS_CLASS(pUINode, DS_UI_NODE));
  CDSCookie* pCookie = NULL;
  pCookie = GetDSCookieFromUINode(pUINode);

  CString szClass;
  szClass = pCookie->GetClass();

  if (szClass == L"nTDSDSA")
  {
    hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                               IDM_GEN_TASK_RUN_KCC,
                               IDM_GEN_TASK_RUN_KCC,
                               CCM_INSERTIONPOINTID_PRIMARY_TASK,
                               0,
                               CMID_GEN_TASK_RUN_KCC);
    ASSERT(SUCCEEDED(hr));
  }
  
  return hr;
}

HRESULT CSARContextMenuVerbs::LoadTopTaskHelper(IContextMenuCallback2* pContextMenuCallback, 
                                                CUINode* pUINode,
                                                int insertionPoint)
{
  HRESULT hr = S_OK;

  CDSCookie* pCookie = NULL;
  ASSERT(IS_CLASS(pUINode, DS_UI_NODE));
  pCookie = GetDSCookieFromUINode(pUINode);
  if (pCookie == NULL)
  {
    ASSERT(FALSE);
    return E_FAIL;
  }

  CString szClass;
  szClass = pCookie->GetClass();

  if ((szClass == L"domainOrganizationalUnit") ||
      (szClass == L"domainLocality"))
  {
    hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                               IDM_GEN_TASK_SELECT_FOREST,
                               IDM_GEN_TASK_SELECT_FOREST,
                               insertionPoint,
                               0,
                               CMID_GEN_TASK_SELECT_FOREST);
    ASSERT(SUCCEEDED(hr));

    hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                               IDM_GEN_TASK_SELECT_DC,
                               IDM_GEN_TASK_SELECT_DC,
                               insertionPoint,
                               0,
                               CMID_GEN_TASK_SELECT_DC);
    ASSERT( SUCCEEDED(hr) );
  }

  int iSystemFlags = pCookie->GetSystemFlags();
  if ( iSystemFlags & (FLAG_CONFIG_ALLOW_MOVE | FLAG_CONFIG_ALLOW_LIMITED_MOVE) ) 
  {
    hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                               IDM_GEN_TASK_MOVE,
                               IDM_GEN_TASK_MOVE,
                               insertionPoint,
                               0,
                               CMID_GEN_TASK_MOVE);
    ASSERT( SUCCEEDED(hr) );
  }

  return hr;
}

HRESULT CSARContextMenuVerbs::LoadViewMenu(IContextMenuCallback2* pContextMenuCallback, 
                                           CUINode* pUINode) 
{
  HRESULT hr = S_OK;

  hr = CDSContextMenuVerbs::LoadViewMenu(pContextMenuCallback, pUINode);
  ASSERT(SUCCEEDED(hr));

  /* View->Services Node should only be on the root
  hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                             IDM_VIEW_SERVICES_NODE,
                             IDM_VIEW_SERVICES_NODE,
                             CCM_INSERTIONPOINTID_PRIMARY_VIEW,
                             m_pComponentData->ViewServicesNode()? MF_CHECKED : 0,
                             CMID_VIEW_SERVICES_NODE);
  ASSERT(SUCCEEDED(hr));
*/
  return hr;
} 

HRESULT CSARContextMenuVerbs::LoadMainMenu(IContextMenuCallback2* piCMenuCallback,
                                          LPDATAOBJECT,
                                          CUINode* pUINode) 
{
  HRESULT hr = S_OK;

  ASSERT(IS_CLASS(pUINode, DS_UI_NODE));
  CDSCookie* pCookie = GetDSCookieFromUINode(pUINode);
  ASSERT(pCookie != NULL);

  int iSystemFlags = pCookie->GetSystemFlags();

  if ( iSystemFlags & (FLAG_CONFIG_ALLOW_MOVE | FLAG_CONFIG_ALLOW_LIMITED_MOVE) ) 
  {
    hr = DSLoadAndAddMenuItem( piCMenuCallback,
                               IDM_GEN_TASK_MOVE,
                               IDM_GEN_TASK_MOVE,
                               CCM_INSERTIONPOINTID_PRIMARY_TOP,
                               0,
                               CMID_GEN_TASK_MOVE);
  }
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dsadmin\copyobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       copyobj.cpp
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
//	copyobj.cpp
//
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"

#include "util.h"
#include "dsutil.h"

#include "newobj.h"
#include "copyobj.h"
#include "querysup.h"


// attributes for "intelligent" copy user
static const PWSTR g_szProfilePath  = L"profilePath";
static const PWSTR g_szHomeDir      = L"homeDirectory";


/////////////////////////////////////////////////////////////////////
// global functions





//+----------------------------------------------------------------------------
//
//  Function:   _GetDomainScope
//
//  Synopsis:   Returns the full LDAP DN of the domain of the given object.
//
//-----------------------------------------------------------------------------

HRESULT _GetDomainScope(IADs* pIADs, CString& szDomainLDAPPath)
{
  // get the DN of the current object
  // get the SID of the object
  CComVariant varObjectDistinguishedName;
  HRESULT hr = pIADs->Get(CComBSTR(L"distinguishedName"), &varObjectDistinguishedName);
  if (FAILED(hr))
  {
    TRACE(L"pIADs->Get(distinguishedName,...) failed with hr = 0x%x\n", hr);
    return hr;
  }

  TRACE(L"Retrieved distinguishedName = <%s>\n", varObjectDistinguishedName.bstrVal);

  // obtain the FQDN of the domain the object is in
  LPWSTR pwzDomainDN = NULL;
  hr = CrackName(varObjectDistinguishedName.bstrVal, &pwzDomainDN, GET_FQDN_DOMAIN_NAME);
  if (FAILED(hr))
  {
    TRACE(L"CrackName(%s) failed with hr = 0x%x\n", varObjectDistinguishedName.bstrVal, hr);
    return hr;
  }

  TRACE(L"CrackName(%s) returned <%s>\n", varObjectDistinguishedName.bstrVal, pwzDomainDN);
  
  // retrieve the server name the object is bound to
  CString szServer;
  hr = GetADSIServerName(OUT szServer, IN pIADs);
  if (FAILED(hr))
  {
    TRACE(L"GetADSIServerName() failed with hr = 0x%x\n", hr);
    return hr;
  }

  TRACE(L"GetADSIServerName() returned <%s>\n", (LPCWSTR)szServer);

  // build the full LDAP path of the domain
  CPathCracker pathCracker;
  hr = pathCracker.SetDisplayType(ADS_DISPLAY_FULL);
  hr = pathCracker.Set(CComBSTR(szServer), ADS_SETTYPE_SERVER);
  hr = pathCracker.Set(CComBSTR(pwzDomainDN), ADS_SETTYPE_DN);
  LocalFreeStringW(&pwzDomainDN);
  CComBSTR bstrDomainPath;
  hr = pathCracker.Retrieve(ADS_FORMAT_X500, &bstrDomainPath);
  if (FAILED(hr))
  {
    TRACE(L"PathCracker() failed to build LDAP path. hr = 0x%x\n", hr);
    return hr;
  }

  szDomainLDAPPath = bstrDomainPath;

  TRACE(L"Object's domain is: <%s>\n", (LPCWSTR)szDomainLDAPPath);

  return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Method:     _ConvertRIDtoName
//
//  Synopsis:   Convert the RID to the object DN.
//
//-----------------------------------------------------------------------------
HRESULT _ConvertRIDtoName(IN LPCWSTR lpszDomainLDAPPath,
                          IN PSID pObjSID, 
                          IN DWORD priGroupRID, 
                          OUT CString& szGroupPath)
{
  PWSTR g_wzADsPath = L"ADsPath";

  if ((pObjSID == NULL) || (priGroupRID == 0))
  {
    return E_INVALIDARG;
  }

  HRESULT hr = S_OK;
  UCHAR * psaCount, i;
  PSID pSID = NULL;
  PSID_IDENTIFIER_AUTHORITY psia;
  DWORD rgRid[8];

  psaCount = GetSidSubAuthorityCount(pObjSID);

  if (psaCount == NULL)
  {
    hr = HRESULT_FROM_WIN32(GetLastError());
    TRACE(L"GetSidSubAuthorityCount() failed, hr = 0x%x\n", hr);
    return hr;
  }

  ASSERT(*psaCount <= 8);
  if (*psaCount > 8)
  {
      return E_FAIL;
  }

  for (i = 0; i < (*psaCount - 1); i++)
  {
    PDWORD pRid = GetSidSubAuthority(pObjSID, (DWORD)i);
    if (pRid == NULL)
    {
      hr = HRESULT_FROM_WIN32(GetLastError());
      TRACE(L"GetSidSubAuthority() failed, hr = 0x%x\n", hr);
      return hr;
    }
    rgRid[i] = *pRid;
  }

  rgRid[*psaCount - 1] = priGroupRID;

  for (i = *psaCount; i < 8; i++)
  {
      rgRid[i] = 0;
  }

  psia = GetSidIdentifierAuthority(pObjSID);

  if (psia == NULL)
  {
    hr = HRESULT_FROM_WIN32(GetLastError());
    TRACE(L"GetSidIdentifierAuthority() failed, hr = 0x%x\n", hr);
    return hr;
  }

  if (!AllocateAndInitializeSid(psia, *psaCount, rgRid[0], rgRid[1],
                                rgRid[2], rgRid[3], rgRid[4],
                                rgRid[5], rgRid[6], rgRid[7], &pSID))
  {
    hr = HRESULT_FROM_WIN32(GetLastError());
    TRACE(L"AllocateAndInitializeSid() failed, hr = 0x%x\n", hr);
    return hr;
  }

  PWSTR rgpwzAttrNames[] = {g_wzADsPath};
  const WCHAR wzSearchFormat[] = L"(&(objectCategory=group)(objectSid=%s))";
  PWSTR pwzSID;
  CString strSearchFilter;

  hr = ADsEncodeBinaryData((PBYTE)pSID, GetLengthSid(pSID), &pwzSID);
  if (FAILED(hr))
  {
    TRACE(L"ADsEncodeBinaryData() failed, hr = 0x%x\n", hr);
    return hr;
  }

  strSearchFilter.Format(wzSearchFormat, pwzSID);
  FreeADsMem(pwzSID);


  CDSSearch Search;
  hr = Search.Init(lpszDomainLDAPPath);
  if (FAILED(hr))
  {
    TRACE(L"Search.Init(%s) failed, hr = 0x%x\n", lpszDomainLDAPPath, hr);
    return hr;
  }

  Search.SetFilterString(const_cast<LPWSTR>((LPCTSTR)strSearchFilter));

  Search.SetAttributeList(rgpwzAttrNames, 1);
  Search.SetSearchScope(ADS_SCOPE_SUBTREE);

  hr = Search.DoQuery();
  if (FAILED(hr))
  {
    TRACE(L"Search.DoQuery() failed, hr = 0x%x\n", hr);
    return hr;
  }

  hr = Search.GetNextRow();

  if (hr == S_ADS_NOMORE_ROWS)
  {
    hr = S_OK;
    szGroupPath = L"";
    TRACE(L"Search. returned S_ADS_NOMORE_ROWS, we failed to find the primary group object, hr = 0x%x\n", hr);
    return hr;
  }

  if (FAILED(hr))
  {
    TRACE(L"Search.GetNextRow() failed, hr = 0x%x\n", hr);
    return hr;
  }


  ADS_SEARCH_COLUMN Column;
  hr = Search.GetColumn(g_wzADsPath, &Column);
  if (FAILED(hr))
  {
    TRACE(L"Search.GetColumn(%s) failed, hr = 0x%x\n", g_wzADsPath, hr);
    return hr;
  }

  szGroupPath = Column.pADsValues->CaseIgnoreString;
  Search.FreeColumn(&Column);

  return hr;
}



/////////////////////////////////////////////////////////////////////
// CCopyableAttributesHolder


HRESULT CCopyableAttributesHolder::LoadFromSchema(MyBasePathsInfo* pBasePathsInfo)
{
  TRACE(L"CCopyableAttributesHolder::LoadFromSchema()\n");

	// build the LDAP path for the schema class
  LPCWSTR lpszPhysicalSchemaNamingContext = pBasePathsInfo->GetSchemaNamingContext();

  CString szPhysicalSchemaPath;
  pBasePathsInfo->ComposeADsIPath(szPhysicalSchemaPath,lpszPhysicalSchemaNamingContext);

  CDSSearch search;
  HRESULT hr = search.Init(szPhysicalSchemaPath);
  if (FAILED(hr))
  {
    TRACE(L"search.Init(%s) failed with hr = 0x%x\n", (LPCWSTR)szPhysicalSchemaPath, hr);
    return hr;
  }

  // the query string filters out the attribute classes that have the
  // "searchFlags" attribute with the 5th bit set (16 == 2^4)
  static LPCWSTR lpszFilterFormat = 
    L"(&(objectCategory=CN=Attribute-Schema,%s)(searchFlags:1.2.840.113556.1.4.803:=16))";

  int nFmtLen = lstrlen(lpszFilterFormat);
  int nSchemaContextLen = lstrlen(lpszPhysicalSchemaNamingContext);

  WCHAR* pszFilter = new WCHAR[nFmtLen+nSchemaContextLen+1];
  if (!pszFilter)
  {
    TRACE(L"Could not allocate enough space for filter string\n");
    return E_OUTOFMEMORY;
  }
  wsprintf(pszFilter, lpszFilterFormat, lpszPhysicalSchemaNamingContext);

  static const int cAttrs = 1;
  static LPCWSTR pszAttribsArr[cAttrs] = 
  {
    L"lDAPDisplayName", // e.g. "accountExpires"
  }; 

  search.SetFilterString(pszFilter);
  search.SetSearchScope(ADS_SCOPE_ONELEVEL);
  search.SetAttributeList((LPWSTR*)pszAttribsArr, cAttrs);

  hr = search.DoQuery();
  if (FAILED(hr))
  {
    TRACE(L"search.DoQuery() failed with hr = 0x%x\n", hr);
    return hr;
  }

  TRACE(L"\n*** Query Results BEGIN ***\n\n");

  ADS_SEARCH_COLUMN Column;
  hr = search.GetNextRow();
  while (hr != S_ADS_NOMORE_ROWS)
  {
    if (FAILED(hr))
    {
      continue;
    }

    HRESULT hr0 = search.GetColumn((LPWSTR)pszAttribsArr[0], &Column);
    if (FAILED(hr0))
    {
      continue;
    }

    LPCWSTR lpszAttr = Column.pADsValues->CaseIgnoreString;
    TRACE(L"Attribute = %s", lpszAttr);

    // screen against attributes we want to skip anyway
    if (!_FindInNotCopyableHardwiredList(lpszAttr))
    {
      TRACE(L" can be copied");
      m_attributeNameList.AddTail(lpszAttr);
    }
    TRACE(L"\n");

    search.FreeColumn(&Column);

    hr = search.GetNextRow(); 
  } // while

  TRACE(L"\n*** Query Results END ***\n\n");

  if (pszFilter)
  {
    delete[] pszFilter;
    pszFilter = 0;
  }

  return hr;
}

BOOL CCopyableAttributesHolder::CanCopy(LPCWSTR lpszAttributeName)
{
  for (POSITION pos = m_attributeNameList.GetHeadPosition(); pos != NULL; )
  {
    CString& strRef = m_attributeNameList.GetNext(pos);
    if (_wcsicmp(lpszAttributeName, strRef) == 0)
      return TRUE;
  }
  return FALSE;
}


// function to screen out attributes that will not
// be copied (or not copied in bulk) no matter what the 
// schema setting are

BOOL CCopyableAttributesHolder::_FindInNotCopyableHardwiredList(LPCWSTR lpszAttributeName)
{
  static LPCWSTR _lpszNoCopyArr[] =
  {
    // we skip the toxic waste dump, no matter what
    L"userParameters",

    // userAccountControl handled separately after commit
    L"userAccountControl",

    // group membership (to be handled after commit)
    L"primaryGroupID",
    L"memberOf",

    NULL // end of table marker
  };


  for (int k = 0; _lpszNoCopyArr[k] != NULL; k++)
  {
    if (_wcsicmp(lpszAttributeName, _lpszNoCopyArr[k]) == 0)
      return TRUE;
  }
  return FALSE;
}






/////////////////////////////////////////////////////////////////////
// CCopyObjectHandlerBase


/////////////////////////////////////////////////////////////////////
// CSid

HRESULT CSid::Init(IADs* pIADs)
{
  static LPWSTR g_wzObjectSID = L"objectSID";
  CComPtr<IDirectoryObject> spDirObj;

  HRESULT hr = pIADs->QueryInterface(IID_IDirectoryObject, (void**)&spDirObj);
  if (FAILED(hr))
  {
    return hr;
  }

  PWSTR rgpwzAttrNames[] = {g_wzObjectSID};
  DWORD cAttrs = 1;
  Smart_PADS_ATTR_INFO spAttrs;

  hr = spDirObj->GetObjectAttributes(rgpwzAttrNames, cAttrs, &spAttrs, &cAttrs);
  if (FAILED(hr))
  {
    return hr;
  }
  if (_wcsicmp(spAttrs[0].pszAttrName, g_wzObjectSID) != 0)
  {
    return E_FAIL;
  }

  if (!Init(spAttrs[0].pADsValues->OctetString.dwLength,
            spAttrs[0].pADsValues->OctetString.lpValue))
  {
    return E_OUTOFMEMORY;
  }
  return S_OK;

}

/////////////////////////////////////////////////////////////////////
// CGroupMembershipHolder

HRESULT CGroupMembershipHolder::Read(IADs* pIADs)
{
  if (pIADs == NULL)
    return E_INVALIDARG;

  // hang on to the ADSI pointer
  m_spIADs = pIADs;

  // get the SID of the object
  HRESULT hr = m_objectSid.Init(m_spIADs);
  if (FAILED(hr))
  {
    TRACE(L"Failed to retrieve object SID, hr = 0x%x\n", hr);
    return hr;
  }

  // get the info about the domain we are in
  hr = _GetDomainScope(m_spIADs, m_szDomainLDAPPath);
  if (FAILED(hr))
  {
    TRACE(L"_GetDomainScope() failed, hr = 0x%x\n", hr);
    return hr;
  }

  hr = _ReadPrimaryGroupInfo();
  if (FAILED(hr))
  {
    TRACE(L"_ReadPrimaryGroupInfo() failed, hr = 0x%x\n", hr);
    return hr;
  }

  hr = _ReadNonPrimaryGroupInfo();
  if (FAILED(hr))
  {
    TRACE(L"_ReadNonPrimaryGroupInfo() failed, hr = 0x%x\n", hr);
    return hr;
  }

#ifdef DBG
  m_entryList.Trace(L"Group Membership List:");
#endif // DBG

  return hr;
}


HRESULT CGroupMembershipHolder::CopyFrom(CGroupMembershipHolder* pSource)
{
  // Add all the elements that are in the source 
  // but not yet in the destination
  CGroupMembershipEntryList* pSourceList = &(pSource->m_entryList);

  //
  // Copy the state of the primary group
  //
  m_bPrimaryGroupFound = pSource->m_bPrimaryGroupFound;

  CGroupMembershipEntryList additionsEntryList;


  for (POSITION pos = pSourceList->GetHeadPosition(); pos != NULL; )
  {
    CGroupMembershipEntry* pCurrSourceEntry = pSourceList->GetNext(pos);

    // look if the the source item is already in the current list
    CGroupMembershipEntry* pEntry = m_entryList.FindByDN(pCurrSourceEntry->GetDN());

    if (pEntry == NULL)
    {
      if (_wcsicmp(pCurrSourceEntry->GetDN(), L"") != 0)
      {
        // not found in the entry list, need to add
        pEntry = new CGroupMembershipEntry(pCurrSourceEntry->GetRID(), pCurrSourceEntry->GetDN());
        pEntry->MarkAdd();
        additionsEntryList.AddTail(pEntry);

        TRACE(L"add: RID %d, DN = <%s>\n", pEntry->GetRID(), pEntry->GetDN());
      }
    }
  } // for


  // find all the elements that are in the destination
  // but not in the source (slated for deletion)
  for (pos = m_entryList.GetHeadPosition(); pos != NULL; )
  {
    CGroupMembershipEntry* pCurrDestEntry = m_entryList.GetNext(pos);

    // look if the the source item is in the source list

    CGroupMembershipEntry* pEntry = pSourceList->FindByDN(pCurrDestEntry->GetDN());

    if (pEntry == NULL)
    {
      // not found in the entry list, need to mark for deletion
      pCurrDestEntry->MarkRemove();
      TRACE(L"remove: RID %d, DN = <%s>\n", pCurrDestEntry->GetRID(), pCurrDestEntry->GetDN());
    }
  } // for

  // catenate the list of additions to the entry list
  m_entryList.Merge(&additionsEntryList);

  return S_OK;
}



HRESULT _EditGroupMembership(LPCWSTR lpszServer, LPCWSTR lpszUserPath, LPCWSTR lpszGroupDN, BOOL bAdd)
{
  // build the full LDAP path of the domain
  CPathCracker pathCracker;
  HRESULT hr = pathCracker.Set(CComBSTR(lpszServer), ADS_SETTYPE_SERVER);
  hr = pathCracker.Set(CComBSTR(lpszGroupDN), ADS_SETTYPE_DN);
  
  CComBSTR bstrGroupPath;
  hr = pathCracker.Retrieve(ADS_FORMAT_X500, &bstrGroupPath);
  if (FAILED(hr))
  {
    TRACE(L"PathCrack