r CDirectory::ILSListUsers(LPCTSTR szILSServer, CObList* pUserList)
{
   //CStringList sTest;
   //LDAPListNames(szILSServer,TEXT("CN=Users,DC=apt,DC=ActiveVoice,DC=com"),sTest);

   DirectoryErr err= DIRERR_UNKNOWNFAILURE;
   LDAP* pLDAP;
   PLDAPMessage pResults= NULL;

   // MS now has a well known port of 1002.  Let's try this now
   // Try 3269 first, then the well-known port
   // 3269 is the port used by Domain Controllers
   if (((pLDAP= LDAPBind(szILSServer, 1002)) == NULL) &&
       ((pLDAP= LDAPBind(szILSServer, 3269)) == NULL) &&
       ((pLDAP= LDAPBind(szILSServer, LDAP_PORT)) == NULL))
   {
      err= DIRERR_NOTFOUND;
   }
   else
   {
      ldap_search_s(pLDAP, _T("o=intranet,ou=dynamic"), 2, _T("objectClass=RTPerson"), NULL,  0, &pResults);
      //ldap_search_s(pLDAP, "o=intranet,ou=dynamic", 2, "objectClass=OTUser", NULL,  0, &pResults);
      
      if (pResults != NULL)
      {
         PLDAPMessage pEntry= ldap_first_entry(pLDAP, pResults);

         if (ldap_count_entries(pLDAP, pResults) > 0)
         {
            err= DIRERR_SUCCESS;
         }

         while (pEntry != NULL)
         {
            CString sFullAddress;
            TCHAR** pszPropertyValue;

            pszPropertyValue= ldap_get_values(pLDAP, pEntry, TEXT("cn"));

            if (pszPropertyValue != NULL)
            {
               CILSUser* pILSUser= new CILSUser;

               //
               // We should verify the allocation of CILSUser object
               //
               if( pILSUser )
               {
                    int nIndex;

                    sFullAddress= pszPropertyValue[0];

                    if ((nIndex= sFullAddress.Find('@')) != -1)
                    {
                        pILSUser->m_sUserName= sFullAddress.Left(nIndex);
                        sFullAddress= sFullAddress.Mid(nIndex+1);

                        TCHAR** pszIPValue= ldap_get_values(pLDAP, pEntry, TEXT("ipAddress"));
                        if (pszIPValue != NULL)
                        {
                            CString sIPAddress= pszIPValue[0];
                            DWORD dwIPAddress = _ttol(sIPAddress);
                            sIPAddress.Format(_T("%.8x"),dwIPAddress);
                            if (sIPAddress.GetLength() == 8)
                            {
                                pILSUser->m_sIPAddress.Format(_T("%d.%d.%d.%d"),
                                _tcstoul(sIPAddress.Mid(6,2),NULL,16),
                                _tcstoul(sIPAddress.Mid(4,2),NULL,16),
                                _tcstoul(sIPAddress.Mid(2,2),NULL,16),
                                _tcstoul(sIPAddress.Mid(0,2),NULL,16));
                            }
                            ldap_value_free(pszIPValue);
                        }

                        //if ((nIndex= sFullAddress.Find(':')) != -1)
                        //{
                        //   pILSUser->m_sIPAddress= sFullAddress.Left(nIndex);
                        //   pILSUser->m_uTCPPort= _ttoi(sFullAddress.Mid(nIndex+1));
                        //}

                        pUserList->AddTail(pILSUser);
                    }
                    ldap_value_free(pszPropertyValue);
               }
            }

            pEntry= ldap_next_entry(pLDAP, pEntry);
         }

         ldap_msgfree(pResults);
      }

      ldap_unbind(pLDAP);
   }

   return err;
}

//
// ADSI Functions
//


//
//
//

DirectoryErr CDirectory::ADSIDefaultPath(CString& sDefaultPath)
{
   DirectoryErr err= DIRERR_UNKNOWNFAILURE;
   CString sName, sDomain;

   CurrentUserInfo(sName, sDomain);

   if (!sDomain.IsEmpty())
   {
      sDefaultPath= "WinNT://" + sDomain;
      err= DIRERR_SUCCESS;
   }

   return err;
}


//
//
//

DirectoryErr CDirectory::ADSIListObjects(LPCTSTR szAdsPath, CStringList& slistObjects)
{
   DirectoryErr err= DIRERR_UNKNOWNFAILURE;
   HRESULT hResult;
   IADsContainer* pADsContainer=  NULL;
   WCHAR* wcPath;
   USES_CONVERSION;

   slistObjects.RemoveAll();
   
   wcPath= T2W((LPTSTR)szAdsPath);

   if ((hResult= ADsGetObject(wcPath, IID_IADsContainer, (void **) &pADsContainer)) ==
      S_OK)
   {
      IEnumVARIANT* pEnumVariant= NULL;
   
      if ((hResult= ADsBuildEnumerator(pADsContainer, &pEnumVariant)) == S_OK)
      {
#define MAX_ADS_ENUM 100
         VARIANT VariantArray[MAX_ADS_ENUM];
         ULONG cElementsFetched= 0L;
         bool fContinue= true;
      
         while (fContinue) 
         {
            IADs *pObject ;

            hResult= ADsEnumerateNext(pEnumVariant, MAX_ADS_ENUM, VariantArray, &cElementsFetched);

            if (hResult == S_FALSE) 
            {
               fContinue = FALSE;
            }

            for (ULONG ulCount= 0; ulCount < cElementsFetched; ulCount++ ) 
            {
               IDispatch *pDispatch = NULL;

               pDispatch= VariantArray[ulCount].pdispVal;

               if ((hResult= pDispatch->QueryInterface(IID_IADs, (VOID **) &pObject)) == S_OK)
               {
                  BSTR bstrName= NULL;
                  CString sFullName;

                  sFullName= szAdsPath;
                  sFullName += "/";

                  hResult= pObject->get_Name(&bstrName);

                  if (bstrName) 
                  {
#ifdef UNICODE
                     sFullName += bstrName;
#else
                     char szName[512];
                     WideCharToMultiByte(CP_ACP, 0, bstrName, -1, szName, 512, NULL, NULL);
                     sFullName += szName;
#endif

                     slistObjects.AddTail(sFullName);

                     SysFreeString(bstrName);
                  }
               }

               pObject->Release();
               pDispatch->Release();
            }
         
            memset(VariantArray, '\0', sizeof(VARIANT)*MAX_ADS_ENUM);
         }
      }
   }

   return err;
}

//
//
//

inline HRESULT
GetPropertyList(
 IADs * pADs,
 VARIANT * pvar )
{
 HRESULT hr= S_OK;
 BSTR bstrSchemaPath = NULL;
IADsClass * pADsClass = NULL;

 hr = pADs->get_Schema(&bstrSchemaPath);

 hr = ADsGetObject(
             bstrSchemaPath,
             IID_IADsClass,
             (void **)&pADsClass);

//Put SafeArray of bstr's into input variant struct
hr = pADsClass->get_MandatoryProperties(pvar);

 if (bstrSchemaPath) {
     SysFreeString(bstrSchemaPath);
 }

 if (pADsClass) {
     pADsClass->Release();
 }

 return(hr);
}


DirectoryErr CDirectory::ADSIGetProperty(LPCTSTR szAdsPath, 
                                         LPCTSTR szProperty, 
                                         VARIANT* pvarValue)
{
   DirectoryErr err= DIRERR_UNKNOWNFAILURE;
   HRESULT hResult;
   WCHAR* wcPath;
   IADs *pObject ;
   USES_CONVERSION;

   wcPath= T2W((LPTSTR)szAdsPath);

   if ((hResult= ADsGetObject(wcPath, IID_IADs, (void **) &pObject)) ==
      S_OK)
   {
      
      if ((hResult= pObject->Get(T2BSTR(szProperty), pvarValue)) == S_OK)
      {
         err= DIRERR_SUCCESS;
      }
   }

   return err;
}


//
// LDAP Functions
//


//
//
//

//szServer = "" is default DS
DirectoryErr CDirectory::LDAPListNames(LPCTSTR szServer, LPCTSTR szSearch, CObList& slistReturn)
{
   DirectoryErr err= DIRERR_UNKNOWNFAILURE;
   LDAP* pLDAP;

   //
   // We should connect to LDAP_GC_PORT port, not to LDAP_PORT
   //

   if (!m_fInitialized)
   {
      err= DIRERR_NOTINITIALIZED;
   }
   else if ((pLDAP= LDAPBind(szServer, LDAP_GC_PORT)) != NULL)
   {

      //get default naming context for server
      //CString sSearch,sNamingContext;;
      //HRESULT hr = GetNamingContext(pLDAP,sNamingContext);
      
       //use the base as the root
       //sSearch = sNamingContext;
       //get users
      //sSearch.Format(_T("CN=Users,%s"),sNamingContext);

       //
       // Search on all forest
       //
       CString sSearch = "";

      //all attributes -> LPTSTR attrs[2]= {NULL, NULL};
       LPTSTR attrs[] = {_T("distinguishedName"),_T("name"),_T("telephoneNumber"),_T("ipPhone"),NULL};

      //try doing paging search
      CAvLdapSearch Search(pLDAP,(LPTSTR)(LPCTSTR)sSearch,LDAP_SCOPE_SUBTREE,(LPTSTR)szSearch,attrs);

      //we will only grab one page.  If there is more than one page then reject.  We will only handle
      //queries up to one page length
      PLDAPMessage pResults = NULL;
       ULONG iRet = Search.NextPage(&pResults, 0);
       if ( iRet == 0 )
       {
         //check if more than one page received
         PLDAPMessage pAddtlPageResults = NULL;
           iRet = Search.NextPage(&pAddtlPageResults);
         if (iRet == 0)
         {
            ldap_msgfree(pAddtlPageResults);
            ldap_msgfree(pResults);
            ldap_unbind(pLDAP);
            return DIRERR_QUERYTOLARGE;
         }
       }

      //ldap_search_s(pLDAP,(LPTSTR)(LPCTSTR)sSearch,LDAP_SCOPE_SUBTREE,(LPTSTR)szSearch,attrs,0,&pResults);
      //ldap_search_s(pLDAP,(LPTSTR)(LPCTSTR)sSearch,LDAP_SCOPE_SUBTREE,TEXT("(objectClass=person)"),attrs,0,&pResults);
      //ldap_search_s(pLDAP,(LPTSTR)(LPCTSTR)sSearch,LDAP_SCOPE_SUBTREE,TEXT("(objectClass=*)"),attrs,0,&pResults);
      //ldap_search_s(pLDAP, (LPTSTR) szSearch, LDAP_SCOPE_SUBTREE, TEXT("(cn=*)"),attrs, 0, &pResults);

        if (pResults != NULL)
        {
            PLDAPMessage pEntry= ldap_first_entry(pLDAP, pResults);

            if ( ldap_count_entries(pLDAP, pResults) > 0 )
                err = DIRERR_SUCCESS;
            else if ( pEntry == NULL )
                err = DIRERR_NOTFOUND;

            while ( pEntry )
            {
                TCHAR* szDN= ldap_get_dn(pLDAP, pEntry);
                if (szDN != NULL)
                {
                    TCHAR** szName = ldap_get_values(pLDAP,pEntry, attrs[1] );
//                    TCHAR** szTele = ldap_get_values(pLDAP,pEntry, attrs[2] );
//                    TCHAR** szIPPhone = ldap_get_values(pLDAP,pEntry, attrs[3] );

                    CLDAPUser* pUser = new CLDAPUser;
                    pUser->m_sServer = szServer;
                    pUser->m_sDN = szDN;
                    if (szName) pUser->m_sUserName = *szName;
//                    if (szTele) pUser->m_sPhoneNumber = *szTele;
//                    if (szIPPhone) pUser->m_sIPAddress = *szIPPhone;
                    slistReturn.AddTail(pUser);

                    ldap_value_free(szName);
//                    ldap_value_free(szTele);
//                    ldap_value_free(szIPPhone);
                    ldap_memfree(szDN);
                }
                pEntry= ldap_next_entry(pLDAP, pEntry);
            }
            ldap_msgfree(pResults);
        }
        ldap_unbind(pLDAP);
    }

    return err;
}


//
//
//

DirectoryErr CDirectory::LDAPGetStringProperty(LPCTSTR szServer, LPCTSTR szDistinguishedName,DirectoryProperty dpProperty,CString& sValue)
{
   DirectoryErr err= DIRERR_UNKNOWNFAILURE;
   //LDAP* pLDAP;
   ULONG ulError;

   //if change in server then cache new connection
   if ( (m_sCacheLDAPServer.CompareNoCase(szServer) != 0) || (m_ldCacheLDAPServer == NULL) )
   {
      m_sCacheLDAPServer = szServer;
      m_ldCacheLDAPServer = NULL;
   }

   if (!m_fInitialized)
   {
      err= DIRERR_NOTINITIALIZED;
   }
   else if ( (m_ldCacheLDAPServer) || ((m_ldCacheLDAPServer = LDAPBind(szServer)) != NULL) )
   {
      PLDAPMessage pResults= NULL;
      //TCHAR* attrs[2]= {NULL, NULL};
      //***only ask for the one prop no all.  need to figure out how to pack in string array
      //LPTSTR attrs[] = {"distinguishedName","name","telephoneNumber","ipPhone","mail",NULL};

      CString sProperty;
      LoadPropertyName(dpProperty,sProperty);
      
      int nNumAttributes = 1;
      LPTSTR* dynattrs = new LPTSTR[nNumAttributes+1];
      if( dynattrs == NULL )
      {
          return err;
      }

      dynattrs[0] = new TCHAR[_MAX_PATH];
      if( dynattrs[0] == NULL )
      {
          delete dynattrs;
          return err;
      }
      _tcsncpy(dynattrs[0],sProperty,_MAX_PATH);
      dynattrs[1] = NULL;

      CString sDN;
      //sDN.Format(_T("(distinguishedName=%s)"),szDistinguishedName);
      //sDN.Format(_T("(dn=%s)"),szDistinguishedName);
      sDN = _T("ObjectClass=user");

      ulError= ldap_search_s(m_ldCacheLDAPServer, (LPTSTR)szDistinguishedName, LDAP_SCOPE_SUBTREE, 
         (LPTSTR)(LPCTSTR)sDN, dynattrs, 0, &pResults);

      if (pResults != NULL)
      {
         PLDAPMessage pMessage= ldap_first_entry(m_ldCacheLDAPServer, pResults);

         ULONG ulCount= ldap_count_entries(m_ldCacheLDAPServer, pResults);

         if (pMessage != NULL)
         {
            TCHAR** pszPropertyValue = ldap_get_values(m_ldCacheLDAPServer,pMessage,(LPTSTR)(LPCTSTR)sProperty);
            if (pszPropertyValue != NULL)
            {
               sValue= pszPropertyValue[0];
               err= DIRERR_SUCCESS;
               ldap_value_free(pszPropertyValue);
            }
         }
         ldap_msgfree(pResults);
      }

      //delete attribute array
      for ( int i=0;i<=nNumAttributes;i++)
      {
         if (dynattrs[i])
            delete dynattrs[i];
      }
      delete dynattrs;
   }
   return err;
}


//
//
//

LDAP* CDirectory::LDAPBind(LPCTSTR szServer, UINT uTCPPort)
{
   LDAP* pLDAP= NULL;
   ULONG ulError;

   if (!m_fInitialized)
   {
      return NULL;
   }
   
   //if empty string then make szServer NULL.  This signifies we want default DS
   if (szServer[0] == '\0')
   {
      szServer = NULL;

      //if NULL let's try getting the global catalog server.  This server will be a better
      //source of info than passing NULL to ldap_open.  
      TCHAR* szCatServer = NULL;
      HRESULT hr = GetGlobalCatalogName(&szCatServer);
      if ( (SUCCEEDED(hr)) && (szCatServer) )
      {

         //try to init
          pLDAP = ldap_init((LPTSTR)szCatServer,uTCPPort);
         delete szCatServer;

         ////////////////////////////////////
          // Change version to v3
          ////////////////////////////////////
          UINT iVersion =    LDAP_VERSION3;
          ulError = ldap_set_option( pLDAP, LDAP_OPT_PROTOCOL_VERSION, &iVersion ); // Local wldap32.dll call

         if ((ulError= ldap_bind_s(pLDAP, NULL, NULL, LDAP_AUTH_SSPI/*LDAP_AUTH_SIMPLE*/)) == LDAP_SUCCESS) // also try SSPI
         {
            return pLDAP;
         }

         if (pLDAP)
         {
            ldap_unbind(pLDAP);
            pLDAP = NULL;
         }
      }
   }

    ////////////////////////////////////
    // init
    ////////////////////////////////////
    if ( (pLDAP) || (pLDAP = ldap_init((LPTSTR)szServer,uTCPPort)) )
   {
      ////////////////////////////////////
       // Change version to v3
       ////////////////////////////////////
       UINT iVersion =    LDAP_VERSION3;
       ulError = ldap_set_option( pLDAP, LDAP_OPT_PROTOCOL_VERSION, &iVersion ); // Local wldap32.dll call

      if ((ulError= ldap_bind_s(pLDAP, NULL, NULL, LDAP_AUTH_SSPI /*LDAP_AUTH_SIMPLE*/)) == LDAP_SUCCESS) // also try SSPI
      {
         return pLDAP;
      }
   }
   return NULL;
}

/////////////////////////////////////////////////////////////////////////////////////////
DirectoryErr CDirectory::LoadPropertyName(DirectoryProperty DirProp,CString& sName)
{
   DirectoryErr err= DIRERR_UNKNOWNFAILURE;

   if (!m_fInitialized)
   {
      err= DIRERR_NOTINITIALIZED;
   }
   else if ((DIRPROP_UNKNOWN < DirProp) && (DirProp < DIRPROP_LAST))
   {
      sName = LDAPDirProps[DirProp];
      err= DIRERR_SUCCESS;
   }
   return err;
}

/////////////////////////////////////////////////////////////////////////////////////////
DirectoryErr CDirectory::WABTopLevelEntry(CWABEntry*& pWABEntry)
{
   DirectoryErr err= DIRERR_UNKNOWNFAILURE;
   HRESULT hResult;
   ULONG cbEID;
   LPENTRYID pEID= NULL;

   // Get the entryid of the root PAB container
   //
   if (!m_fInitialized)
   {
      err= DIRERR_NOTINITIALIZED;
   }
   else if ((hResult= m_pAddrBook->GetPAB( &cbEID, &pEID)) == S_OK)
   {
      pWABEntry= new CWABEntry(cbEID, pEID);

      err= DIRERR_SUCCESS;

      m_pWABObject->FreeBuffer(pEID);
   }

   return err;
}

/////////////////////////////////////////////////////////////////////////////////////////
DirectoryErr CDirectory::WABListMembers(const CWABEntry* pWABEntry, CObList* pWABList)
{
   DirectoryErr err= DIRERR_UNKNOWNFAILURE;

   if (!m_fInitialized)
   {
      err= DIRERR_NOTINITIALIZED;
   }
   else if (IsContainer(pWABEntry))
   {
      HRESULT hResult;
      LPMAPITABLE pAB=  NULL;
      int cNumRows= 0;
      ULONG ulObjType= 0;
      LPABCONT pContainer= NULL;

      if (((hResult= m_pAddrBook->OpenEntry(pWABEntry->m_cbEntryID, (LPENTRYID) pWABEntry->m_pEntryID, 
               /*&IID_IABContainer*/ NULL, 0, &ulObjType, (LPUNKNOWN *)&pContainer)) == S_OK))
      {
         if ((hResult= pContainer->GetContentsTable(0, &pAB)) == S_OK)
         {
            // Order the columns in the ContentsTable to conform to the
            // ones we want - which are mainly DisplayName, EntryID and
            // ObjectType
            // The table is gauranteed to set the columns in the order 
            // requested
            //
            // Then reset the index to the first row.
            if (((hResult= pAB->SetColumns((LPSPropTagArray)&ptaEid, 0 )) == S_OK) &&
                ((hResult= pAB->SeekRow(BOOKMARK_BEGINNING, 0, NULL)) == S_OK))
            {
               LPSRowSet pRowAB = NULL;
               err= DIRERR_SUCCESS;

               // Read all the rows of the table one by one
               //
               do 
               {
                  if ((hResult= pAB->QueryRows(1, 0, &pRowAB)) == S_OK)
                  {
                     cNumRows= pRowAB->cRows;

                     if(pRowAB != NULL && (cNumRows > 0))
                     {
                        LPTSTR szDisplayName= pRowAB->aRow[0].lpProps[ieidPR_DISPLAY_NAME].Value.LPSZ;
                        LPENTRYID pEID= (LPENTRYID) pRowAB->aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.lpb;
                        ULONG cbEID= pRowAB->aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.cb;

                        // We will now take the entry-id of each object and add it
                        // to the WABEntry representing that object. This enables
                        // us to uniquely identify the object later if we need to
                        //
                        CWABEntry* pWABEntry= new CWABEntry(cbEID, pEID);

                        pWABList->AddTail(pWABEntry);

                        FreeProws(pRowAB );        
                     }
                  }
               }
               while (SUCCEEDED(hResult) && (cNumRows > 0) && (pRowAB != NULL));
            }

            pAB->Release();
         }

         pContainer->Release();
      }
   }
   else if (IsDistributionList(pWABEntry))
   {
      HRESULT hResult;
      LPMAPITABLE pAB=  NULL;
      int cNumRows= 0;
      ULONG ulObjType= 0;
      LPDISTLIST pDistList= NULL;

      if (((hResult= m_pAddrBook->OpenEntry(pWABEntry->m_cbEntryID, (LPENTRYID) pWABEntry->m_pEntryID, 
               /*&IID_IDistList*/ NULL, 0, &ulObjType, (LPUNKNOWN *)&pDistList)) == S_OK))
      {
         if ((hResult= pDistList->GetContentsTable(0, &pAB)) == S_OK)
         {
            // Order the columns in the ContentsTable to conform to the
            // ones we want - which are mainly DisplayName, EntryID and
            // ObjectType
            // The table is gauranteed to set the columns in the order 
            // requested
            //
            // Then reset the index to the first row.
            if (((hResult= pAB->SetColumns((LPSPropTagArray)&ptaEid, 0 )) == S_OK) &&
                ((hResult= pAB->SeekRow(BOOKMARK_BEGINNING, 0, NULL)) == S_OK))
            {
               LPSRowSet pRowAB = NULL;
               err= DIRERR_SUCCESS;

               // Read all the rows of the table one by one
               //
               do 
               {
                  if ((hResult= pAB->QueryRows(1, 0, &pRowAB)) == S_OK)
                  {
                     cNumRows= pRowAB->cRows;

                     if(pRowAB != NULL && (cNumRows > 0))
                     {
                        LPTSTR szDisplayName= pRowAB->aRow[0].lpProps[ieidPR_DISPLAY_NAME].Value.LPSZ;
                        LPENTRYID pEID= (LPENTRYID) pRowAB->aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.lpb;
                        ULONG cbEID= pRowAB->aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.cb;

                        // We will now take the entry-id of each object and add it
                        // to the WABEntry representing that object. This enables
                        // us to uniquely identify the object later if we need to
                        //
                        CWABEntry* pWABEntry= new CWABEntry(cbEID, pEID);

                        pWABList->AddTail(pWABEntry);

                        FreeProws(pRowAB );        
                     }
                  }
               }
               while (SUCCEEDED(hResult) && (cNumRows > 0) && (pRowAB != NULL));
            }

            pAB->Release();
         }

         pDistList->Release();
      }
   }
   else
   {
      err= DIRERR_INVALIDPARAMETERS;
   }

   return err;
}

//
//
//

DirectoryErr CDirectory::WABGetProperty(const CWABEntry* pWABEntry, 
                                        UINT uProperty, 
                                        CString* pString,
                                        CStringList* pStringList, 
                                        INT* piValue,
                                        UINT* pcBinary,
                                        BYTE** ppBinary)
{
   DirectoryErr err= DIRERR_UNKNOWNFAILURE;
   HRESULT hResult;
   LPMAILUSER pMailUser= NULL;
   ULONG ulObjType= 0;

   if (!m_fInitialized)
   {
      err= DIRERR_NOTINITIALIZED;
   }
   else if(!(
      ((PROP_TYPE(uProperty) == PT_TSTRING) && (pString != NULL))|| 
      ((PROP_TYPE(uProperty) == PT_MV_TSTRING) && (pStringList != NULL)) || 
      ((PROP_TYPE(uProperty) == PT_LONG) && (piValue != NULL)))
      )
   {
      err= DIRERR_INVALIDPARAMETERS;
   }
   else if ((hResult= m_pAddrBook->OpenEntry(pWABEntry->m_cbEntryID, (ENTRYID*) pWABEntry->m_pEntryID,
      NULL, 0, &ulObjType, (LPUNKNOWN *)&pMailUser)) == 0)
   {
      if (pMailUser != NULL)
      {
         SPropTagArray PropsToFind;
         LPSPropValue pPropArray;
         ULONG ulcValues;

         PropsToFind.cValues= 1;
         PropsToFind.aulPropTag[0]= uProperty;

         pMailUser->GetProps(&PropsToFind, 0, &ulcValues, &pPropArray);

         if (pPropArray != NULL)
         {
            if (pPropArray[0].ulPropTag == uProperty)
            {
               if ((PROP_TYPE(uProperty) == PT_TSTRING) && (pString != NULL))
               {
                  *pString= pPropArray[0].Value.LPSZ;
                  err= DIRERR_SUCCESS;
               }
               else if ((PROP_TYPE(uProperty) == PT_MV_TSTRING) && (pStringList != NULL))
               {
                  for (ULONG j=0; j<pPropArray[0].Value.MVSZ.cValues; j++)
                  {
                     pStringList->AddTail(pPropArray[0].Value.MVSZ.LPPSZ[j]);
                  }

                  err= DIRERR_SUCCESS;
               }
               else if ((PROP_TYPE(uProperty) == PT_LONG) && (piValue != NULL))
               {
                  *piValue= pPropArray[0].Value.l;
                  err= DIRERR_SUCCESS;
               }
               else if ((PROP_TYPE(uProperty) == PT_BINARY) && (pcBinary != NULL) &&
                  (ppBinary != NULL))
               {
                  *pcBinary= pPropArray[0].Value.bin.cb;
                  *ppBinary= new BYTE[*pcBinary];
                  memcpy(*ppBinary, pPropArray[0].Value.bin.lpb, *pcBinary);

                  err= DIRERR_SUCCESS;
               }
            }
            
            m_pWABObject->FreeBuffer(pPropArray);
         }

         pMailUser->Release();
      }
   }

   if (err != DIRERR_SUCCESS)
   {
      // Init the variables on failure
      if ((PROP_TYPE(uProperty) == PT_TSTRING) && (pString != NULL))
      {
         pString->Empty();
      }
      else if ((PROP_TYPE(uProperty) == PT_LONG) && (piValue != NULL))
      {
         *piValue= 0;
      }
   }

   return err;
}

//
//
//

DirectoryErr CDirectory::WABSearchByStringProperty(UINT uProperty, LPCTSTR szValue, 
                                                   CObList* pWABList)
{
   DirectoryErr err= DIRERR_UNKNOWNFAILURE;

   if (!m_fInitialized)
   {
      err= DIRERR_NOTINITIALIZED;
   }
   else
   {
      CObList list;
      CWABEntry* pWABEntry;

      WABGetTopLevelContainer(&list);

      while (!list.IsEmpty())
      {
         pWABEntry= (CWABEntry*) list.RemoveHead();

         if (IsPerson(pWABEntry) && WABStringPropertyMatch(pWABEntry, uProperty, szValue))
         {
            pWABList->AddTail(pWABEntry);
         }
         else
         {
            delete pWABEntry;
         }
      }
   }
   
   if (pWABList->IsEmpty())
   {
      err= DIRERR_NOTFOUND;
   }
   else
   {
      err= DIRERR_SUCCESS;
   }

   return err;
}

//
//
//

DirectoryErr CDirectory::WABVCardCreate(const CWABEntry* pWABEntry, LPCTSTR szFileName)
{
   DirectoryErr err= DIRERR_UNKNOWNFAILURE;
/*
   HRESULT hResult;
   LPMAILUSER pMailUser= NULL;
   ULONG ulObjType= 0;

   if (!m_fInitialized)
   {
      err= DIRERR_NOTINITIALIZED;
   }
   else if ((hResult= m_pAddrBook->OpenEntry(pWABEntry->m_cbEntryID, (ENTRYID*) pWABEntry->m_pEntryID,
      NULL, 0, &ulObjType, (LPUNKNOWN *)&pMailUser)) == 0)
   {
      if (pMailUser != NULL)
      {
#ifdef WAB_VCARD_FILE
         if ((hResult= m_pWABObject->VCardCreate(m_pAddrBook,WAB_VCARD_FILE, szFileName, pMailUser)) ==
#else
         if ((hResult= m_pWABObject->VCardCreate(m_pAddrBook,(LPTSTR) szFileName, pMailUser)) ==
#endif
            S_OK)
         {
            err= DIRERR_SUCCESS;
         }
      }
   }
*/
   return err;
}

//
//
//

DirectoryErr CDirectory::WABVCardAddToWAB(LPCTSTR szFileName, CWABEntry*& pWABEntry)
{
   DirectoryErr err= DIRERR_UNKNOWNFAILURE;
/*
   HRESULT hResult;
   LPMAILUSER pMailUser= NULL;
   ULONG ulObjType= 0;

   pWABEntry= NULL;

   if (!m_fInitialized)
   {
      err= DIRERR_NOTINITIALIZED;
   }
#ifdef WAB_VCARD_FILE
   else if ((hResult= m_pWABObject->VCardRetrieve(m_pAddrBook, WAB_VCARD_FILE, (LPTSTR) szFileName, &pMailUser)) ==
#else
   else if ((hResult= m_pWABObject->VCardRetrieve(m_pAddrBook,  (LPTSTR) szFileName, &pMailUser)) ==
#endif
      S_OK)
   {
      SPropTagArray PropsToFind;
      LPSPropValue pPropArray;
      ULONG ulcValues;

      PropsToFind.cValues= 1;
      PropsToFind.aulPropTag[0]= PR_ENTRYID;

      pMailUser->GetProps(&PropsToFind, 0, &ulcValues, &pPropArray);

      // Grab the ENTRYID property to create a new CWABEntry
      if (pPropArray != NULL)
      {
         if (pPropArray[0].ulPropTag == PR_ENTRYID) 
         {
            pWABEntry= new CWABEntry(pPropArray[0].Value.bin.cb, 
               (ENTRYID*) pPropArray[0].Value.bin.lpb);

            err= DIRERR_SUCCESS;
         }
         m_pWABObject->FreeBuffer(pPropArray);
      }
      pMailUser->Release();
   }
*/
   return err;
}

//
//
//

bool CDirectory::WABStringPropertyMatch(CWABEntry* pWABEntry, UINT uProperty, LPCTSTR szMatch)
{
   bool fMatch= false;
   CString sValue;

   if(WABGetStringProperty(pWABEntry, uProperty, sValue) == DIRERR_SUCCESS)
   {
      if (_tcsicmp(szMatch, sValue) == 0)
      {
         fMatch= true;
      }
   }

   return fMatch;
}

//
//
//

bool CDirectory::WABIntPropertyMatch(CWABEntry* pWABEntry, UINT uProperty, int iMatch)
{
   bool fMatch= false;
   int iValue;

   if(WABGetIntProperty(pWABEntry, uProperty, iValue) == DIRERR_SUCCESS)
   {
      if (iMatch == iValue)
      {
         fMatch= true;
      }
   }

   return fMatch;
}

//
//
//

DirectoryErr CDirectory::WABShowDetails(HWND hWndParent, const CWABEntry* pWABEntry)
{
   DirectoryErr err= DIRERR_UNKNOWNFAILURE;
   HRESULT hResult;

   if (!m_fInitialized)
   {
      err= DIRERR_NOTINITIALIZED;
   }
   else if ((hResult= m_pAddrBook->Details((ULONG*) &hWndParent, NULL, NULL, pWABEntry->m_cbEntryID, 
      (ENTRYID*) pWABEntry->m_pEntryID, NULL, NULL, NULL, 0)) == S_OK)
   {
      err= DIRERR_SUCCESS;
   }

   return err;
}


//
//
//

DirectoryErr CDirectory::WABNewEntry(HWND hWndParent, CWABEntry* pWABEntry)
{
   DirectoryErr err= DIRERR_UNKNOWNFAILURE;
   HRESULT hResult;
   ENTRYID* pEntryID;

   if (!m_fInitialized)
   {
      err= DIRERR_NOTINITIALIZED;
   }
   else if ((hResult= m_pAddrBook->NewEntry(HandleToUlong(hWndParent), 0, 0, NULL, 0, NULL, 
      (ULONG*) &(pWABEntry->m_cbEntryID), (ENTRYID**) &pEntryID)) == S_OK)
   {
      err= DIRERR_SUCCESS;

      pWABEntry->m_pEntryID= new BYTE[pWABEntry->m_cbEntryID];

      memcpy(pWABEntry->m_pEntryID, pEntryID, pWABEntry->m_cbEntryID);

      m_pWABObject->FreeBuffer(pEntryID);
   }

   return err;
}

//
//
//

DirectoryErr CDirectory::WABAddMember(const CWABEntry* pContainer, const CWABEntry* pMember)
{
   DirectoryErr err= DIRERR_UNKNOWNFAILURE;

   if (!m_fInitialized)
   {
      err= DIRERR_NOTINITIALIZED;
   }
   else if (IsContainer(pContainer))
   {
      ULONG ulObjectType;
      LPABCONT pWABCont= NULL;
      HRESULT hResult;

      if ((hResult= m_pAddrBook->OpenEntry(pContainer->m_cbEntryID, 
         (ENTRYID*) pContainer->m_pEntryID, 
         /*&IID_IABContainer*/ NULL, 0, &ulObjectType, (LPUNKNOWN *) &pWABCont)) == S_OK)
      {
         LPMAPIPROP pMapiProp;

         if ((hResult= pWABCont->CreateEntry(pMember->m_cbEntryID, 
            (ENTRYID*) pMember->m_pEntryID, 0, &pMapiProp)) == S_OK)
         {
            err= DIRERR_SUCCESS;

            pMapiProp->Release();
         }

         pWABCont->Release();
      }
   }
   else if (IsDistributionList(pContainer))
   {
      ULONG ulObjectType;
      LPDISTLIST pDistList= NULL;
      HRESULT hResult;

      if ((hResult= m_pAddrBook->OpenEntry(pContainer->m_cbEntryID, 
         (ENTRYID*) pContainer->m_pEntryID, 
         /*&IID_IDistList*/ NULL, 0, &ulObjectType, (LPUNKNOWN *) &pDistList)) == S_OK)
      {
         LPMAPIPROP pMapiProp;

         if ((hResult= pDistList->CreateEntry(pMember->m_cbEntryID, 
            (ENTRYID*) pMember->m_pEntryID, CREATE_REPLACE, &pMapiProp)) == S_OK)
         {
            err= DIRERR_SUCCESS;

            pMapiProp->Release();
         }

         pDistList->Release();
      }
   }
   else
   {
      err= DIRERR_INVALIDPARAMETERS;
   }

   return err;
}


//
//
//

DirectoryErr CDirectory::WABRemoveMember(const CWABEntry* pContainer, const CWABEntry* pWABEntry)
{
   DirectoryErr err= DIRERR_UNKNOWNFAILURE;

   if (!m_fInitialized)
   {
      err= DIRERR_NOTINITIALIZED;
   }
   else if (IsContainer(pContainer))
   {
      ULONG ulObjectType;
      LPABCONT pWABCont= NULL;
      HRESULT hResult;

      if ((hResult= m_pAddrBook->OpenEntry(pContainer->m_cbEntryID, 
         (ENTRYID*) pContainer->m_pEntryID, 
         NULL, 0, &ulObjectType, (LPUNKNOWN *) &pWABCont)) == S_OK)
      {
         SBinaryArray SBA;
         SBinary SB;

         SB.cb= pWABEntry->m_cbEntryID;
         SB.lpb= pWABEntry->m_pEntryID;

         SBA.cValues= 1;
         SBA.lpbin= &SB;
         if ((hResult= pWABCont->DeleteEntries((LPENTRYLIST) &SBA, 0)) == S_OK)
         {
            err= DIRERR_SUCCESS;
         }

         pWABCont->Release();
      }
   }
   else if (IsDistributionList(pContainer))
   {
      ULONG ulObjectType;
      LPDISTLIST pDistList= NULL;
      HRESULT hResult;

      if ((hResult= m_pAddrBook->OpenEntry(pContainer->m_cbEntryID, 
         (ENTRYID*) pContainer->m_pEntryID, 
         NULL, 0, &ulObjectType, (LPUNKNOWN *) &pDistList)) == S_OK)
      {
         SBinaryArray SBA;
         SBinary SB;

         SB.cb= pWABEntry->m_cbEntryID;
         SB.lpb= pWABEntry->m_pEntryID;

         SBA.cValues= 1;
         SBA.lpbin= &SB;
         if ((hResult= pDistList->DeleteEntries((LPENTRYLIST) &SBA, 0)) == S_OK)
         {
            err= DIRERR_SUCCESS;
         }

         pDistList->Release();
      }
   }
   else
   {
      err= DIRERR_INVALIDPARAMETERS;
   }

   return err;
}


//
//
//

DirectoryErr CDirectory::WABFind(HWND hWndParent)
{
   DirectoryErr err= DIRERR_UNKNOWNFAILURE;
   HRESULT hResult;

   if (!m_fInitialized)
   {
      err= DIRERR_NOTINITIALIZED;
   }
   else if ((hResult= m_pWABObject->Find(m_pAddrBook, hWndParent)) == S_OK)
   {
      err= DIRERR_SUCCESS;
   }

   return err; 
}


//
//
//

void CDirectory::FreeProws(LPSRowSet prows)
{
    ULONG        irow;
    
   if (prows != NULL)
   {
       for (irow = 0; irow < prows->cRows; ++irow)
      {
           m_pWABObject->FreeBuffer(prows->aRow[irow].lpProps);
      }

       m_pWABObject->FreeBuffer(prows);
   }
}

/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
//New Rendevous Support
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////
ITRendezvous* CDirectory::GetRendevous()
{
    // If it doesn't exist, try to create it
    if (m_pRend == NULL)
    {
      //we will finally release this object in the destructor
        HRESULT hr = CoCreateInstance( CLSID_Rendezvous,
                               NULL,
                               CLSCTX_INPROC_SERVER,
                               IID_ITRendezvous,
                               (void **) &m_pRend );

   }
   if (m_pRend)
   {
      m_pRend->AddRef();
   }
   return m_pRend;
}

/////////////////////////////////////////////////////////////////////////////////////////
DirectoryErr CDirectory::DirListServers(CStringList* pServerList,DirectoryType dirtype)
{
   ITRendezvous* pRend = GetRendevous();
   if (pRend == NULL) return DIRERR_NOTINITIALIZED;

    IEnumDirectory *pEnum = NULL;
    if ( SUCCEEDED(pRend->EnumerateDefaultDirectories(&pEnum)) && pEnum )
    {
        ITDirectory *pDir = NULL;
        while ( (pEnum->Next(1, &pDir, NULL) == S_OK) && pDir )
        {
            // Look for ILS or DS servers
            DIRECTORY_TYPE nDirType;
         DIRECTORY_TYPE nDirTypeToFind = DT_ILS;
         if (dirtype == DIRTYPE_ILS)
            nDirTypeToFind = DT_ILS;
         else if (dirtype == DIRTYPE_DS)
            nDirTypeToFind = DT_NTDS;

            if ( (SUCCEEDED(pDir->get_DirectoryType(&nDirType))) && (nDirType == nDirTypeToFind) )
            {
                BSTR bstrName = NULL;
                pDir->get_DisplayName( &bstrName );
                if ( bstrName && SysStringLen(bstrName) )
            {
               USES_CONVERSION;
               CString sName = OLE2CT( bstrName );
               pServerList->AddTail(sName);
               SysFreeString(bstrName);
            }
            }
            pDir->Release();
            pDir = NULL;
        }
        pEnum->Release();
    }
    pRend->Release();

   return DIRERR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////////////////
//Helper to get BaseDN for LDAP server
HRESULT GetNamingContext(LDAP* pLDAP,CString& sNamingContext)
{
   DirectoryErr err = DIRERR_UNKNOWNFAILURE;
   PLDAPMessage pResults = NULL;

    // send a search (base level, base dn = "", filter = "objectclass=*")
    // ask only for the defaultNamingContext attribute
   LPTSTR attrs[] = {_T("defaultNamingContext"),NULL};

   ULONG res = ldap_search_s(pLDAP, _T(""), LDAP_SCOPE_BASE, TEXT("(objectClass=*)"), 
      attrs, 0, &pResults);

   if (pResults != NULL)
   {
      PLDAPMessage pEntry= ldap_first_entry(pLDAP, pResults);

      if (ldap_count_entries(pLDAP, pResults) > 0)
      {
         err= DIRERR_SUCCESS;
      }

      while (pEntry != NULL)
      {
         // look for the value for the namingContexts attribute
         TCHAR** NamingContext = ldap_get_values(pLDAP,pEntry,_T("defaultNamingContext"));

         //***should we allocate our own mem here and copy???
         if (NamingContext)
         {
            sNamingContext = NamingContext[0];
            ldap_value_free(NamingContext);
            return S_OK;
         }
         pEntry= ldap_next_entry(pLDAP, pEntry);
      }
      ldap_msgfree(pResults);
   }

/*
    // associate the ldap handle with the search message holder, so that the
    // search message may be released when the instance goes out of scope
    CLdapMsgPtr MessageHolder(SearchResult);

    TCHAR **NamingContext;

    LDAPMessage    *EntryMessage = ldap_first_entry(hLdap, SearchResult);
    while ( NULL != EntryMessage )
    {
        // look for the value for the namingContexts attribute
        NamingContext = ldap_get_values(
            hLdap, 
            EntryMessage, 
            (WCHAR *)DEFAULT_NAMING_CONTEXT
            );

        // the first entry contains the naming context and its a single
        // value(null terminated) if a value is found, create memory for
        // the directory path, set the dir path length
        if ( (NULL != NamingContext)    &&
             (NULL != NamingContext[0]) &&
             (NULL == NamingContext[1])  )
        {
            // the naming context value is released when the ValueHolder
            // instance goes out of scope
            CLdapValuePtr  ValueHolder(NamingContext);

            *ppNamingContext = new TCHAR [lstrlen(NamingContext[0]) + 1];

            BAIL_IF_NULL(*ppNamingContext, E_OUTOFMEMORY);

            lstrcpy(*ppNamingContext, NamingContext[0]);

            // return success
            return S_OK;
        }

        // Get next entry.
        EntryMessage = ldap_next_entry(hLdap, EntryMessage);
    }
*/
    // none found, return error
    return HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);
}

/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////
CAvLdapSearch::CAvLdapSearch( 
        LDAP *ld, 
        LPTSTR szObject,
        LONG lScope,
        LPTSTR szFilter,
        LPTSTR aAttributes[],
        ULONG lServerTimeLimit)
{
    m_ld = ld;

     // Local wldap32.dll call
    m_hSearch = ldap_search_init_page(
                    m_ld,
                    szObject,
                    lScope, 
                    szFilter, 
                    aAttributes,
                    0,
                    NULL,                        // Server Controls
                    NULL,                        // Client Controls
                    lServerTimeLimit,            // TimeLimit in seconds
                    0,                    
                    NULL );                        // Sort keys

    m_clDefaultPageSize = LDAP_PAGE_SIZE;
    m_clMaxPageSize = m_clDefaultPageSize;
};

CAvLdapSearch::~CAvLdapSearch()
{
    if( m_hSearch )
    {
        ldap_search_abandon_page(m_ld, m_hSearch ); // Local wldap32.dll call
        m_hSearch = NULL;
    }
};

////////////////////////////////////////////////////////////////////////
//  @Method:  NextPage
//  @Class:   CAvLdapSearch
//  @Access:  public
//  
//  @Arg:     LDAPMessage **pldres - ldap buffer for data.  Pass in NULL for the 
//                                   first time and then free it only after completly
//                                   finished.
//  @Arg:     ULONG clEntries - number of entries you want back
//  @Arg:     ULONG lClientTimeLimit - how long your willing to wait before timeout
//
//  @Returns: ULONG - ldap return code for ldap_get_next_page_s
//
//  @Desc: This gets the next clEntries items in the search
////////////////////////////////////////////////////////////////////////
ULONG CAvLdapSearch::NextPage( 
            LDAPMessage **pldres,                       // returned items
            ULONG clEntries,                               // max number of entries 
            ULONG lClientTimeLimit)                   // max time the wldap32 client waits
{
    ULONG iRet = LDAP_NO_RESULTS_RETURNED;
    if( m_hSearch && pldres )
    {
        // if the entries are 0, they want the default
        // If they ask for more than possible, just for the max possible.
        if( clEntries == 0 || clEntries > (ULONG)m_clMaxPageSize )
            clEntries = m_clDefaultPageSize;

        ULONG TotalCount_NotSupported;
        struct l_timeval  timeout;
        timeout.tv_sec = lClientTimeLimit;
        timeout.tv_usec= 0;

        iRet = ldap_get_next_page_s( // Hits Server
                    m_ld,
                    m_hSearch,
                    &timeout,            // TimeLimit
                    clEntries,            // Max Entries you want back at a time
                    &TotalCount_NotSupported,
                    pldres);
    }
    return iRet;
};

//////////////////////////////////////////////////////////////////////
void TestingEntries( LDAP *ld, LDAPMessage *ldres )
{
    int iEnts = 0;
    LDAPMessage *ldEntry = NULL;

    iEnts = ldap_count_entries( ld, ldres );                    // Local wldap32.dll call

    if( iEnts )
    {
        int i=0;

        for( i=0, ldEntry = ldap_first_entry( ld, ldres );        // Local wldap32.dll call
            i<iEnts;
            i++, ldEntry = ldap_next_entry( ld, ldEntry ) )        // Local wldap32.dll call
        {
            LPTSTR pBuff;

            if( NULL == (pBuff = ldap_get_dn( ld, ldEntry ) ) )    // Local wldap32.dll call
                break;
            else
            {
                //wprintf(L"DN: %s\n", pBuff );
                //attr( ld, ldEntry );
                ldap_memfree( pBuff );                            // Local wldap32.dll call
                pBuff=NULL;
            }
//            wprintf(L"\n");
        }
    }
    if( ldEntry )
        ldap_msgfree(ldEntry);
}

/*
//#include <dsgetdc.h>
//#include <objbase.h>
//#include <lmcons.h>
//#include <lmapibuf.h>
*/

////////////////////////////////////////////////////////////////////////////
//
// GetGlobalCatalogName (static local funcion)
//
// This function asks the domain controller for the name of a server with a
// Global Catalog. That's the server we actually do ldap_open() on below
// in CNTDirectory::Connect().
//
// Argument: receives a pointer to a new'ed string containing the name
//           of the global catalog. This is a fully qualified domain name in
//           the format "foo.bar.com.", NOT "\\foo.bar.com.".
//
// Returns an HRESULT:
//      S_OK          : it worked
//      E_OUTOFMEMORY : not enough memory to allocate the string
//      other         : reason for failure of ::DsGetDcName()
//
////////////////////////////////////////////////////////////////////////////
//

HRESULT GetGlobalCatalogName(TCHAR** ppszGlobalCatalogName)
{
    // We are a helper function, so we only assert...
    _ASSERTE( ! IsBadWritePtr( ppszGlobalCatalogName, sizeof(TCHAR *) ) );

    //
    // Ask the system for the location of the GC (Global Catalog).
    //

    DWORD dwCode;
    DOMAIN_CONTROLLER_INFO * pDcInfo = NULL;
    dwCode = DsGetDcName(
            NULL, // LPCWSTR computername, (default: this one)
            NULL, // LPCWSTR domainname,   (default: this one)
            NULL, // guid * domainguid,    (default: this one)
            NULL, // LPCWSTR sitename,     (default: this one)
            DS_GC_SERVER_REQUIRED,  // ULONG Flags, (what do we want)
            &pDcInfo                // receives pointer to output structure
        );

    if ( (dwCode != NO_ERROR) || (pDcInfo == NULL) )
    {
        return S_FALSE;//HRESULT_FROM_ERROR_CODE(dwCode);
    }

    //
    // Do a quick sanity check in debug builds. If we get the wrong name we
    // will fail right after this, so this is only useful for debugging.
    //

    // In case we find we need to use the address instead of the name:
    // _ASSERTE( pDcInfo->DomainControllerAddressType == DS_INET_ADDRESS );
    ASSERT(pDcInfo->Flags & DS_GC_FLAG);

    //
    // If we've got something like "\\foo.bar.com.", skip the "\\".
    //

    TCHAR* pszName = pDcInfo->DomainControllerName;

    while (pszName[0] == '\\')
    {
        pszName++;
    }

    //
    // Allocate and copy the output string.
    //

    *ppszGlobalCatalogName = new TCHAR[_tcslen(pszName) + 1];
 
    if ( (*ppszGlobalCatalogName) == NULL)
    {
        //DBGOUT((FAIL, _T("GetGlobalCatalogName: out of memory in string allocation")));
        NetApiBufferFree(pDcInfo);
        return E_OUTOFMEMORY;
    }

    _tcscpy(*ppszGlobalCatalogName, pszName);

    //
    // Release the DOMAIN_CONTROLLER_INFO structure.
    //

    NetApiBufferFree(pDcInfo);

    //
    // All done.
    //

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\directory.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////
// directory.h
/////////////////////////////////////////////////////////////////////////////////////////

#ifndef _DIRECTORY_H_
#define _DIRECTORY_H_

#include "ds.h"
#include <activeds.h>
#include <winldap.h>
#include <mapix.h>
#include <wab.h>

/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
//Defines
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

typedef enum
{
   DIRPROP_UNKNOWN=0,
   DIRPROP_DISPLAYNAME,
   DIRPROP_IPPHONE,
   DIRPROP_TELEPHONENUMBER,
   DIRPROP_EMAILADDRESS,

   DIRPROP_LAST
} DirectoryProperty;   

typedef enum
{
   DIRERR_SUCCESS=0,
   DIRERR_NOTINITIALIZED,
   DIRERR_INVALIDPROPERTY,
   DIRERR_INVALIDPARAMETERS,
   DIRERR_NOTFOUND,
   DIRERR_UNKNOWNFAILURE,
   DIRERR_QUERYTOLARGE,
} DirectoryErr;

typedef enum
{
   DIRTYPE_DS=0,
   DIRTYPE_ILS,
} DirectoryType;

/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
//CDirectory
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

interface ITRendezvous;

class CDirectory : public CObject
{
//New Rendevous support
protected:
   ITRendezvous*  m_pRend;
protected:
   ITRendezvous*  GetRendevous();
public:
   DirectoryErr   DirListServers(CStringList* pServerList,DirectoryType dirtype);

protected:
   bool           m_fInitialized;
   IAddrBook*     m_pAddrBook;
   IWABObject*    m_pWABObject;

   CString        m_sCacheLDAPServer;
   LDAP*          m_ldCacheLDAPServer;

protected:
   LDAP*          LDAPBind(LPCTSTR szServer, UINT uTCPPort= LDAP_PORT);
   DirectoryErr   LoadPropertyName(DirectoryProperty DirProp,CString& sName);

   bool           WABStringPropertyMatch(CWABEntry* pWABEntry, UINT uProperty, LPCTSTR szMatch);
   bool           WABIntPropertyMatch(CWABEntry* pWABEntry, UINT uProperty, int iMatch);
   
   DirectoryErr   InitWAB();
   void           FreeProws(LPSRowSet prows);

   DirectoryErr   WABGetProperty(const CWABEntry* pWABEntry, 
                                           UINT uProperty, 
                                           CString* pString,
                                           CStringList* pStringList, 
                                           INT* piValue,
                                           UINT* pcBinary,
                                           BYTE** ppBinary);


public:
   CDirectory();
   ~CDirectory();
   DirectoryErr Initialize();

   //
   //
   //
   DirectoryErr CurrentUserInfo(CString& sName, CString& sDomain);

   //
   // ILS Functions
   //

   // Returns a list of CILSUser which is all of the registered TAPI
   // users at this ILS Server.
   DirectoryErr ILSListUsers(LPCTSTR szILSServer, CObList* pUserList);

   //
   // ADSI Functions
   //
   DirectoryErr ADSIDefaultPath(CString& sDefaultPath);
   DirectoryErr ADSIListObjects(LPCTSTR szADsPath, CStringList& strlistObjects);
   DirectoryErr ADSIGetProperty(LPCTSTR szAdsPath, 
                                LPCTSTR szProperty, 
                                VARIANT* pvarValue);
   
   //
   // LDAP Functions
   //

   DirectoryErr LDAPListNames(LPCTSTR szServer, LPCTSTR szSearch, CObList& slistReturn);

   DirectoryErr LDAPGetStringProperty(LPCTSTR szServer, LPCTSTR szDistinguishedName, 
      DirectoryProperty dpProperty,CString& sValue);


   //
   // WAB Functions
   //

   // Get the WAB Entry of the top level container.
   // caller is responible for deleting pWABEntry
   DirectoryErr WABTopLevelEntry(CWABEntry*& pWABEntry);

   // Pop up window edit box for this user
   DirectoryErr WABShowDetails(HWND hWndParent, const CWABEntry* pWABEntry);

   // Add a new user with pop up edit box.
   DirectoryErr WABNewEntry(HWND hWndParent, CWABEntry* pWABEntry);

   // List the members of a container or Distribution List.
   DirectoryErr WABListMembers(const CWABEntry* pWABEntry, CObList* pWABList);

   // Add a member to a container of distribution list.
   DirectoryErr WABAddMember(const CWABEntry* pContainer, const CWABEntry* pMember);
   
   // Remove a member from a container or distribution list
   DirectoryErr WABRemoveMember(const CWABEntry* pContainer, const CWABEntry* pWABEntry);

   // Pop up box for finding and adding to the WAB1
   DirectoryErr WABFind(HWND hWndParent);

   // Search by any string property. property values are listed in mapitags.h
   DirectoryErr WABSearchByStringProperty(UINT uProperty, LPCTSTR szValue, CObList* pWABList);

   // Create a VCARD for this user
   DirectoryErr WABVCardCreate(const CWABEntry* pWABEntry, LPCTSTR szFileName);

   // Create an entry for this VCARD
   DirectoryErr WABVCardAddToWAB(LPCTSTR szFileName, CWABEntry*& pWABEntry);

   //
   // inline members
   // 

   inline DirectoryErr WABGetTopLevelContainer(CObList* pWABList)
   {
      DirectoryErr err= DIRERR_UNKNOWNFAILURE;
      CWABEntry* pTopLevel;

      // Get the entryid of the root PAB container
      //
      if (WABTopLevelEntry(pTopLevel) == DIRERR_SUCCESS)
      {
         err= WABListMembers(pTopLevel, pWABList);
         delete pTopLevel;
      }

      return err;
   }


   // Remove entry from top level container
   inline DirectoryErr WABRemove(const CWABEntry* pWABEntry)
   {
      DirectoryErr err= DIRERR_UNKNOWNFAILURE;
      CWABEntry* pTopLevel;

      // Get the entryid of the root PAB container
      //
      if (WABTopLevelEntry(pTopLevel) == DIRERR_SUCCESS)
      {
         err= WABRemoveMember(pTopLevel, pWABEntry);
         delete pTopLevel;
      }

      return err;
   }


   // Get properties of a WAB entry.  the values for uProperty are specified in mapitags.h
   inline DirectoryErr WABGetStringProperty(const CWABEntry* pWABEntry, UINT uProperty, CString& sValue)
   {
      return WABGetProperty(pWABEntry, uProperty, &sValue, NULL, NULL, NULL, NULL);
   }

   inline DirectoryErr WABGetStringListProperty(const CWABEntry* pWABEntry, UINT uProperty, CStringList& slistValue)
   {
      return WABGetProperty(pWABEntry, uProperty, NULL, &slistValue, NULL, NULL, NULL);
   }

   inline DirectoryErr WABGetIntProperty(const CWABEntry* pWABEntry, UINT uProperty, INT& iValue)
   {
      return WABGetProperty(pWABEntry, uProperty, NULL, NULL, &iValue, NULL, NULL);
   }

   inline DirectoryErr WABGetBinaryProperty(const CWABEntry* pWABEntry, UINT uProperty, 
      UINT& cData, BYTE*& pData)
   {
      return WABGetProperty(pWABEntry, uProperty, NULL, NULL, NULL, &cData, &pData);
   }

   inline bool IsPerson(const CWABEntry* pWABEntry) 
   {
      bool fIsPerson= false;
      int iType;

      if (WABGetIntProperty(pWABEntry, PR_OBJECT_TYPE, iType) == DIRERR_SUCCESS)
      {
         if (iType == MAPI_MAILUSER)
         {
            fIsPerson= true;
         }
      }

      return fIsPerson;
   };

   inline bool IsDistributionList(const CWABEntry* pWABEntry) 
   {
      bool fIsList= false;
      int iType;

      if (WABGetIntProperty(pWABEntry, PR_OBJECT_TYPE, iType) == DIRERR_SUCCESS)
      {
         if (iType == MAPI_DISTLIST)
         {
            fIsList= true;
         }
      }

      return fIsList;
   };

   inline bool IsContainer(const CWABEntry* pWABEntry) 
   {
      bool fIsCont= false;
      int iType;

      if (WABGetIntProperty(pWABEntry, PR_OBJECT_TYPE, iType) == DIRERR_SUCCESS)
      {
         if (iType == MAPI_ABCONT)
         {
            fIsCont= true;
         }
      }

      return fIsCont;
   };

   inline bool Exists(const CWABEntry* pWABEntry)
   {
      bool fExists= false;
      int iType;

      if (WABGetIntProperty(pWABEntry, PR_OBJECT_TYPE, iType) == DIRERR_SUCCESS)
      {
         fExists= true;
      }

      return fExists;
   }
};

// Time limit in seconds of how long to wait for the search before failing
#define DEFAULT_TIME_LIMIT	15

class CAvLdapSearch  
{
public:
// Construction/Destruction
	CAvLdapSearch( 
		LDAP *ld, 
		LPTSTR szObject,
		LONG lScope,
		LPTSTR szFilter,
		LPTSTR aAttributes[] = NULL,
		ULONG lServerTimeLimit = DEFAULT_TIME_LIMIT);
	virtual ~CAvLdapSearch();

	ULONG NextPage( 
			LDAPMessage **pldres = NULL,					      // returned items
			ULONG clEntries = 0,							         // max number of entries 
			ULONG lClientTimeLimit = DEFAULT_TIME_LIMIT);   // max time the wldap32 client waits

private:
	LDAP		*m_ld;
	PLDAPSearch	m_hSearch;
	LONG		m_clDefaultPageSize;		// default number of entries
	LONG		m_clMaxPageSize;			// Max can ever be used
};

#endif //_DIRECTORY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\ds.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////
// ds.h : interface of the CActiveDialerView class

#ifndef _DS_H_
#define _DS_H_

#include "dialreg.h"
#include <mapix.h>

class CActiveDialerDoc;
class CDirectory;

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Class CDSUser
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class CDSUser : public CObject
{
	DECLARE_DYNCREATE(CDSUser)
public:
//construction
   CDSUser() {};
public:
   CString     m_sUserName;
   CString     m_sIPAddress;
   CString     m_sPhoneNumber;
public:
   const CDSUser& operator=(const CDSUser* pUser)
   {
      m_sUserName= pUser->m_sUserName;
      m_sIPAddress= pUser->m_sIPAddress;
      m_sPhoneNumber= pUser->m_sPhoneNumber;
      return *this;
   }
   const BOOL operator==(const CDSUser* pUser)
   {
      if ( (m_sUserName == pUser->m_sUserName) && 
           (m_sIPAddress == pUser->m_sIPAddress) )
        return TRUE;
      else
         return FALSE;
   }
   void Dial(CActiveDialerDoc* pDoc);  //Dial using preferred device
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Class CILSUser
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class CILSUser : public CObject
{
	DECLARE_DYNCREATE(CILSUser)

// Members
public:
   CString		m_sUserName;
   CString		m_sIPAddress;
   CString		m_sComputer;

// Attributes
public:
	void		GetCallerInfo( CString &strInfo );
// Operators
public:
   const CILSUser& operator=(const CILSUser* pUser);
   const BOOL operator==(const CILSUser* pUser)
   {
      if ( (m_sUserName == pUser->m_sUserName) && 
           (m_sIPAddress == pUser->m_sIPAddress) &&
			(m_sComputer == pUser->m_sComputer) )
        return TRUE;
      else
         return FALSE;
   }

   void Dial(CActiveDialerDoc* pDoc);  //Dial using preferred device
   void DesktopPage(CActiveDialerDoc *pDoc);
   bool AddSpeedDial();
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Class CWABEntry
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class CWABEntry : public CObject
{
public:
   UINT  m_cbEntryID;
   BYTE* m_pEntryID;

public:
   CWABEntry();
   CWABEntry(UINT cbEntryID, ENTRYID* pEntryID);
   ~CWABEntry();

   const CWABEntry& operator=(const CWABEntry* pEntry);
   bool operator==(const CWABEntry* pEntry) const;
   void Dial(CActiveDialerDoc* pDoc,CDirectory* pDir);  //Dial using preferred device
   BOOL CreateCall(CActiveDialerDoc* pDoc,CDirectory* pDir,UINT attrib,long lAddressType,DialerMediaType nType);
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Class CLDAPUser
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class CLDAPUser : public CObject
{
	DECLARE_SERIAL(CLDAPUser)
public:
//construction
   CLDAPUser();
   ~CLDAPUser();

public:
	CString     m_sServer;
	CString     m_sDN;
	CString     m_sUserName;
	CString     m_sPhoneNumber;
	CString     m_sIPAddress;
	CString     m_sEmail1;

protected:
	long		m_lRef;

public:
	static void CALLBACK ExternalReleaseProc( void *pThis );

	long			AddRef();
	long			Release();

	virtual void   Serialize(CArchive& ar);

	int Compare( const CLDAPUser *pUser )
	{
		int nRet = m_sServer.Compare( pUser->m_sServer );
		if ( nRet == 0 )
			nRet = m_sDN.Compare( pUser->m_sDN );

		return nRet;
	}

   void Dial(CActiveDialerDoc* pDoc);  //Dial using preferred device
   bool AddSpeedDial();

protected:
	void FinalRelease();
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#endif //_DS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\explwnd.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// explwnd.cpp : implementation file
//

#include "stdafx.h"
#include "avDialerDoc.h"
#include "avDialerVw.h"
#include "ds.h"
#include "MainFrm.h"
#include "explwnd.h"
#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Defines
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#define NUMTABS                     2
#define BUTTONHEIGHT                24//18
#define EXPLORERWINDOW_SLIDE_TIME   100

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CExplorerWnd
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
CExplorerWnd::CExplorerWnd()
{
	m_bInitialize = false;
	m_bPostTapiInit = false;
	m_bPostAVTapiInit = false;

	m_pActiveMainWnd = NULL;
	m_pParentWnd = NULL;

	InitializeCriticalSection( &m_csThis );
}

CExplorerWnd::~CExplorerWnd()
{
	DeleteCriticalSection( &m_csThis );
}

BEGIN_MESSAGE_MAP(CExplorerWnd, CWnd)
	//{{AFX_MSG_MAP(CExplorerWnd)
	ON_WM_SIZE()
	ON_COMMAND(ID_NEXT_PANE, OnNextPane)
	ON_COMMAND(ID_PREV_PANE, OnPrevPane)
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_POSTTAPIINIT, OnPostTapiInit)
	ON_MESSAGE(WM_POSTAVTAPIINIT, OnPostAVTapiInit)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Initialization Methods
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
void CExplorerWnd::Init(CActiveDialerView* pParentWnd)
{          
	ASSERT(pParentWnd);
	m_pParentWnd = pParentWnd;


	m_wndMainDirectories.Init(m_pParentWnd);
	m_wndMainDirectories.Create(NULL,NULL,WS_VISIBLE|WS_CHILD,CRect(0,0,0,0),this,IDC_EXPLORER_MAINWND_DIRECTORIES);

	m_wndMainConfServices.Create(NULL,NULL,WS_VISIBLE|WS_CHILD,CRect(0,0,0,0),this,IDC_EXPLORER_MAINWND_CONFERENCESERVICES);
	m_wndMainConfRoom.Create(NULL,NULL,WS_VISIBLE|WS_CHILD,CRect(0,0,0,0),this,IDC_EXPLORER_MAINWND_CONFERENCEROOM);

	m_wndMainConfServices.Init(m_pParentWnd);
	m_wndMainConfRoom.Init(m_pParentWnd);	

	m_pActiveMainWnd = &m_wndMainDirectories;
	m_pActiveMainWnd = &m_wndMainConfRoom;

	// Initialization completed
	EnterCriticalSection( &m_csThis );
	m_bInitialize = true;
	LeaveCriticalSection( &m_csThis );

	PostTapiInit( true );
	PostAVTapiInit();
}

LRESULT CExplorerWnd::OnPostTapiInit(WPARAM wParam, LPARAM lParam)
{
	EnterCriticalSection( &m_csThis );
	m_bPostTapiInit = true;
	LeaveCriticalSection( &m_csThis );

	PostTapiInit( false );
	return 0;
}

LRESULT CExplorerWnd::OnPostAVTapiInit(WPARAM wParam, LPARAM lParam)
{
	EnterCriticalSection( &m_csThis );
	m_bPostAVTapiInit = true;
	LeaveCriticalSection( &m_csThis );

	PostAVTapiInit();
	return 0;
}


bool CExplorerWnd::PostTapiInit( bool bAutoArrange )
{
	EnterCriticalSection( &m_csThis );
	bool bInit = m_bInitialize && m_bPostTapiInit;
	LeaveCriticalSection( &m_csThis );

	if ( bAutoArrange )
		AutoArrange();

	if ( bInit )
	{
		try
		{
			m_wndMainDirectories.PostTapiInit();
			m_wndMainConfServices.PostTapiInit();
			AfxGetMainWnd()->Invalidate();
		}
		catch (...) {}
	}

	return bInit;
}

void CExplorerWnd::PostAVTapiInit()
{
	EnterCriticalSection( &m_csThis );
	bool bInit = m_bInitialize && m_bPostAVTapiInit;
	LeaveCriticalSection( &m_csThis );

	if ( bInit )
		m_wndMainConfRoom.PostTapiInit();
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Window Management
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
void CExplorerWnd::AutoArrange(int nNewActiveTab,BOOL bClearToolBars,BOOL bSlide)
{
	EnterCriticalSection( &m_csThis );
	bool bInit = m_bInitialize;
	LeaveCriticalSection( &m_csThis );

	if ( !bInit ) return;

	CRect rect;
	GetClientRect(rect);

	m_wndMainConfServices.MoveWindow(0,0,0,0);
	m_wndMainConfRoom.MoveWindow(0,0,0,0);

	m_wndMainDirectories.MoveWindow( 0, 0, rect.right, rect.bottom );
	m_pActiveMainWnd = &m_wndMainDirectories;
	m_pActiveMainWnd->Refresh();
}

/////////////////////////////////////////////////////////////////////////////
void CExplorerWnd::OnSize(UINT nType, int cx, int cy) 
{
	CWnd::OnSize(nType, cx, cy);
	AutoArrange();
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Command Routing
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

BOOL CExplorerWnd::OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo) 
{
   //route the message to the current explorer window
   if ( !CWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo) )
      if ( (m_pActiveMainWnd) && (::IsWindow(m_pActiveMainWnd->GetSafeHwnd())) )
         return m_pActiveMainWnd->OnCmdMsg(nID,nCode,pExtra,pHandlerInfo);

   return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Notification of changes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
void CExplorerWnd::ExplorerShowItem(CallClientActions cca)
{
	switch (cca)
	{
		case CC_ACTIONS_SHOWADDRESSBOOK:
			break;

		case CC_ACTIONS_SHOWCONFSERVICES:
			break;

		case CC_ACTIONS_SHOWCONFROOM:
			if ( m_wndMainDirectories.m_pConfRoomTreeItem )
				m_wndMainDirectories.m_treeCtrl.SelectItem( m_wndMainDirectories.m_pConfRoomTreeItem->GetTreeItemHandle() );
			break;

	}
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//DS User Methods
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
void CExplorerWnd::DSClearUserList()
{

   if (::IsWindow(m_wndMainDirectories.GetSafeHwnd()))
   {
      m_wndMainDirectories.DSClearUserList(); 
   }
}

/////////////////////////////////////////////////////////////////////////////
void CExplorerWnd::DSAddUser(CDSUser* pDSUser)
{
   /*
   if (::IsWindow(m_wndMainDirectories.GetSafeHwnd()))
   {
      m_wndMainDirectories.DSAddUser(pDSUser); 
   }*/
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

void CExplorerWnd::OnNextPane() 
{
	CWnd *pWnd = GetFocus();
	if ( pWnd->GetSafeHwnd() != m_wndMainDirectories.m_treeCtrl.GetSafeHwnd() )
	{
		m_wndMainDirectories.m_treeCtrl.SetFocus();
	}
	else
	{
		if ( m_wndMainDirectories.m_pDisplayWindow )
			m_wndMainDirectories.m_pDisplayWindow->SetFocus();
	}
}

void CExplorerWnd::OnPrevPane() 
{
	OnNextPane();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\dirwnd.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// MainExplorerWndDir.h : header file
/////////////////////////////////////////////////////////////////////////////
#if !defined(AFX_MAINEXPLORERWNDDIR_H__6CED3922_41BF_11D1_B6E5_0800170982BA__INCLUDED_)
#define AFX_MAINEXPLORERWNDDIR_H__6CED3922_41BF_11D1_B6E5_0800170982BA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "tapidialer.h"
#include "MainExpWnd.h"
#include "dirasynch.h"
#include "aexpltre.h"
#include "ILSList.h"
#include "PerGrpLst.h"
#include "CallEntLst.h"                                  //CCallEntryListCtrl

#define WM_NOTIFYSITESERVERSTATECHANGE		(WM_USER + 2300)
#define WM_ADDSITESERVER					(WM_USER + 2301)
#define WM_REMOVESITESERVER					(WM_USER + 2302)
#define WM_UPDATECONFROOTITEM				(WM_USER + 2303)
#define WM_UPDATECONFPARTICIPANT_ADD		(WM_USER + 2304)
#define WM_UPDATECONFPARTICIPANT_REMOVE		(WM_USER + 2305)
#define WM_UPDATECONFPARTICIPANT_MODIFY		(WM_USER + 2306)
#define WM_DELETEALLCONFPARTICIPANTS		(WM_USER + 2307)
#define WM_SELECTCONFPARTICIPANT			(WM_USER + 2308)
#define WM_MYONSELCHANGED					(WM_USER + 2309)

//For Context menu
typedef enum tagMenuType_t
{
	CNTXMENU_NONE = -1,
	CNTXMENU_ILS_SERVER_GROUP,
	CNTXMENU_ILS_SERVER,
	CNTXMENU_ILS_USER,
	CNTXMENU_DSENT_GROUP,
	CNTXMENU_DSENT_USER,
	CNTXMENU_SPEEDDIAL_GROUP,
	CNTXMENU_SPEEDDIAL_PERSON,
	CNTXMENU_CONFROOM,
} MenuType_t;

extern MenuType_t GetMenuFromType( TREEOBJECT nType );


///////////////////////////////////
// Persist information
//
#define ILS_OPEN			0x001
#define DS_OPEN				0x010
#define SPEEDDIAL_OPEN		0x100

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CMainExplorerWndDirectoriesTree window
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class CMainExplorerWndDirectoriesTree : public CExplorerTreeCtrl
{
//Construction
public:
   CMainExplorerWndDirectoriesTree()   {};

//Methods
public:
   virtual void   OnSetDisplayText(CAVTreeItem* _pItem,LPTSTR text,BOOL dir,int nBufSize);
   virtual int    OnCompareTreeItems(CAVTreeItem* pItem1,CAVTreeItem* pItem2);
   virtual void   OnRightClick(CExplorerTreeItem* pItem,CPoint& pt);
   void           SelectTopItem();
   void           SetDisplayObject(CWABEntry* pWABEntry);
   void           SetDisplayObjectDS(CObject* pObject);
};
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CMainExplorerWndDirectories window
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class CDSUser;

class CMainExplorerWndDirectories : public CMainExplorerWndBase
{
// Construction
public:
	CMainExplorerWndDirectories();

// Attributes
public:
	CMainExplorerWndDirectoriesTree  m_treeCtrl;

	CExplorerTreeItem			*m_pRootItem;
	CExplorerTreeItem			*m_pILSParentTreeItem;
	CExplorerTreeItem			*m_pILSEnterpriseParentTreeItem;
	CExplorerTreeItem			*m_pDSParentTreeItem;
	CExplorerTreeItem			*m_pSpeedTreeItem;
	CExplorerTreeItem			*m_pConfRoomTreeItem;

	CPersonGroupListCtrl	m_lstPersonGroup;
	CPersonListCtrl			m_lstPerson;
	CCallEntryListCtrl		m_lstSpeedDial;

	CWnd*					m_pDisplayWindow;

protected:
	IConfExplorer				*m_pConfExplorer;
	IConfExplorerDetailsView	*m_pConfDetailsView;
	IConfExplorerTreeView		*m_pConfTreeView;

	CWnd					m_wndEmpty;

	CRITICAL_SECTION		m_csDataLock;              //Sync on data
	UINT					m_nPersistInfo;

// Operations
public:
   static void CALLBACK		DirListServersCallBackEntry(bool bRet, void* pContext,CStringList& ServerList,DirectoryType dirtype);
   void						DirListServersCallBack(bool bRet,CStringList& ServerList,DirectoryType dirtype);

   //DS User Methods
   void						DSClearUserList();
   void						DSAddUser(CLDAPUser* pUser,BOOL bAddToBuddyList);
   virtual void				Refresh();
   virtual void				PostTapiInit();

protected:
   void						GetTreeObjectsFromType(int nType,TREEOBJECT& tobj,TREEIMAGE& tim);
   void						AddSpeedDial();

#ifndef _MSLITE
   void						AddWAB();
   void						AddWABGroup(CObList* pWABPtrList,CExplorerTreeItem* pTreeItem);
#endif //_MSLITE

	void						AddILS();
	void						RefreshILS(CExplorerTreeItem* pParentTreeItem);

	void						AddDS();
	void						AddConfRoom();

	void						OnUpdateConfMeItem( CExplorerTreeItem *pItem );
	void						RedrawTreeItem( CExplorerTreeItem *pItem );

public:
   HRESULT					AddSiteServer( CExplorerTreeItem *pItem, BSTR bstrName );
   HRESULT					RemoveSiteServer( CExplorerTreeItem *pItem, BSTR bstrName );
   HRESULT					NotifySiteServerStateChange( CExplorerTreeItem *pItem, BSTR bstrName, ServerState nState );
   void						RepopulateSpeedDialList( bool bObeyPersistSettings );
   void						UpdateData( bool bSaveAndValidate );

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainExplorerWndDirectories)
	public:
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainExplorerWndDirectories();

	// Generated message map functions
protected:
	//{{AFX_MSG(CMainExplorerWndDirectories)
	afx_msg void OnButtonPlacecall();
	afx_msg void OnSelChanged();
	afx_msg void OnProperties();
	afx_msg void OnUpdateProperties(CCmdUI* pCmdUI);
	afx_msg LRESULT OnPersonGroupViewLButtonDblClick(WPARAM wParam,LPARAM lParam);
	afx_msg void OnViewSortAscending();
	afx_msg void OnUpdateViewSortAscending(CCmdUI* pCmdUI);
	afx_msg void OnViewSortDescending();
	afx_msg void OnUpdateViewSortDescending(CCmdUI* pCmdUI);
	afx_msg void OnButtonDirectoryRefresh();
	afx_msg void OnUpdateButtonDirectoryRefresh(CCmdUI* pCmdUI);
	afx_msg void OnButtonSpeeddialAdd();
	afx_msg void OnUpdateButtonSpeeddialAdd(CCmdUI* pCmdUI);
	afx_msg void OnUpdateButtonMakecall(CCmdUI* pCmdUI);
	afx_msg void OnEditDirectoriesAdduser();
	afx_msg void OnUpdateEditDirectoriesAdduser(CCmdUI* pCmdUI);
	afx_msg void OnDelete();
	afx_msg void OnUpdateDelete(CCmdUI* pCmdUI);
	afx_msg LRESULT OnAddSiteServer(WPARAM wParam, LPARAM lParam );
	afx_msg LRESULT OnRemoveSiteServer(WPARAM wParam, LPARAM lParam );
	afx_msg LRESULT OnNotifySiteServerStateChange(WPARAM wParam, LPARAM lParam);
	afx_msg void OnButtonDirectoryServicesAddserver();
	afx_msg void OnUpdateButtonDirectoryServicesAddserver(CCmdUI* pCmdUI);
	afx_msg void OnListWndDblClk(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnButtonConferenceCreate();
	afx_msg void OnButtonConferenceJoin();
	afx_msg void OnButtonConferenceDelete();
	afx_msg void OnUpdateButtonConferenceCreate(CCmdUI* pCmdUI);
	afx_msg void OnUpdateButtonConferenceJoin(CCmdUI* pCmdUI);
	afx_msg void OnUpdateButtonConferenceDelete(CCmdUI* pCmdUI);
	afx_msg void OnViewSortConfName();
	afx_msg void OnViewSortConfDescription();
	afx_msg void OnViewSortConfStart();
	afx_msg void OnViewSortConfStop();
	afx_msg void OnViewSortConfOwner();
	afx_msg void OnUpdateViewSortConfName(CCmdUI* pCmdUI);
	afx_msg void OnUpdateViewSortConfDescription(CCmdUI* pCmdUI);
	afx_msg void OnUpdateViewSortConfStart(CCmdUI* pCmdUI);
	afx_msg void OnUpdateViewSortConfStop(CCmdUI* pCmdUI);
	afx_msg void OnUpdateViewSortConfOwner(CCmdUI* pCmdUI);
	afx_msg void OnButtonSpeeddialEdit();
	afx_msg LRESULT OnMainTreeDblClk(WPARAM wParam, LPARAM lParam);
	afx_msg void OnDesktopPage();
	afx_msg void OnDestroy();
	afx_msg LRESULT OnUpdateConfRootItem(WPARAM wParam, LPARAM lParam );
	afx_msg LRESULT OnUpdateConfParticipant_Add(WPARAM wParam, LPARAM lParam );
	afx_msg LRESULT OnUpdateConfParticipant_Remove(WPARAM wParam, LPARAM lParam );
	afx_msg LRESULT OnUpdateConfParticipant_Modify(WPARAM wParam, LPARAM lParam );
	afx_msg LRESULT OnDeleteAllConfParticipants(WPARAM wParam, LPARAM lParam );
	afx_msg LRESULT OnSelectConfParticipant(WPARAM wParam, LPARAM lParam );
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnConfgroupFullsizevideo();
	afx_msg void OnConfgroupShownames();
	afx_msg void OnButtonRoomDisconnect();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg LRESULT MyOnSelChanged(WPARAM wParam, LPARAM lParam );
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINEXPLORERWNDDIR_H__6CED3922_41BF_11D1_B6E5_0800170982BA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\explwnd.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// explwnd.h : header file
//

#ifndef _EXPLWND_H_
#define _EXPLWND_H_ 

// FWD define
class CExplorerWnd;

#include "tapidialer.h"
#include "avDialerVw.h"
#include "MainExpWnd.h"                      //CMainExplorerWndBase
#include "DirWnd.h"                          //CMainExplorerWndDirectories
#include "ConfServWnd.h"                     //CMainExplorerWndConfServices
#include "ConfRoomWnd.h"                     //CMainExplorerWndConfRoom

#define WM_POSTTAPIINIT		(WM_USER + 25137)
#define WM_POSTAVTAPIINIT	(WM_USER + 25138)


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CExplorerWnd
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class CDSUser;

class CExplorerWnd : public CWnd
{
// Construction
public:
	CExplorerWnd();
	~CExplorerWnd();

// Attributes
public:
   CMainExplorerWndDirectories     m_wndMainDirectories;
   CMainExplorerWndConfServices    m_wndMainConfServices;
   CMainExplorerWndConfRoom        m_wndMainConfRoom;

protected:
	CRITICAL_SECTION			m_csThis;
	CActiveDialerView*			m_pParentWnd;   

	bool						m_bInitialize;
	bool						m_bPostTapiInit;
	bool						m_bPostAVTapiInit;
	CMainExplorerWndBase*		m_pActiveMainWnd;

// Operations
public:
   void                       Init(CActiveDialerView* pParentWnd);
   
   void                       ExplorerShowItem(CallClientActions cca);

   //DS User Methods
   void                       DSClearUserList();
   void                       DSAddUser(CDSUser* pDSUser);

protected:
   void						AutoArrange(int nNewActiveTab=-1,BOOL bClearToolBars=FALSE,BOOL bSlide=FALSE);
   bool						PostTapiInit( bool bAutoArrange );
   void						PostAVTapiInit();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CExplorerWnd)
	public:
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
	//}}AFX_VIRTUAL

// Implementation
public:
	// Generated message map functions
	//{{AFX_MSG(CExplorerWnd)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnNextPane();
	afx_msg void OnPrevPane();
	//}}AFX_MSG
	afx_msg LRESULT OnPostTapiInit(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnPostAVTapiInit(WPARAM wParam, LPARAM lParam);
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif //_EXPLWND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\dirwnd.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
// 
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// MainExplorerWndDir.cpp : implementation file
//

#include "stdafx.h"
#include "tapi3.h"
#include "avDialer.h"
#include "ds.h"
#include "mainfrm.h"
#include "resolver.h"
#include "DirWnd.h"
#include "DialReg.h"
#include "DirDlgs.h"
#include "FndUserDlg.h"
#include "SpeedDlgs.h"
#include "util.h"
#include "avtrace.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

enum
{
   CONFSERVICES_MENU_COLUMN_CONFERENCENAME = 0,
   CONFSERVICES_MENU_COLUMN_DESCRIPTION,
   CONFSERVICES_MENU_COLUMN_START,
   CONFSERVICES_MENU_COLUMN_STOP,
   CONFSERVICES_MENU_COLUMN_OWNER,
};


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Defines 
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

MenuType_t GetMenuFromType( TREEOBJECT nType )
{
    switch ( nType )
    {
        case TOBJ_DIRECTORY_ILS_SERVER_GROUP:
            return CNTXMENU_ILS_SERVER_GROUP;

        case TOBJ_DIRECTORY_ILS_SERVER:
        case TOBJ_DIRECTORY_ILS_SERVER_PEOPLE:
        case TOBJ_DIRECTORY_ILS_SERVER_CONF:
            return CNTXMENU_ILS_SERVER;

        case TOBJ_DIRECTORY_ILS_USER:
            return CNTXMENU_ILS_USER;
        
        case TOBJ_DIRECTORY_DSENT_GROUP:
            return CNTXMENU_DSENT_GROUP;

        case TOBJ_DIRECTORY_DSENT_USER:
            return CNTXMENU_DSENT_USER;

        case TOBJ_DIRECTORY_SPEEDDIAL_GROUP:
            return CNTXMENU_SPEEDDIAL_GROUP;

        case TOBJ_DIRECTORY_SPEEDDIAL_PERSON:
            return CNTXMENU_SPEEDDIAL_PERSON;

        case TOBJ_DIRECTORY_CONFROOM_GROUP:
        case TOBJ_DIRECTORY_CONFROOM_ME:
        case TOBJ_DIRECTORY_CONFROOM_PERSON:
            return CNTXMENU_CONFROOM;
    }

    return CNTXMENU_NONE;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CMainExplorerWndDirectories
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
BEGIN_MESSAGE_MAP(CMainExplorerWndDirectories, CMainExplorerWndBase)
    //{{AFX_MSG_MAP(CMainExplorerWndDirectories)
    ON_COMMAND(ID_BUTTON_MAKECALL, OnButtonPlacecall)
    ON_CONTROL(TVN_SELCHANGED, IDC_DIRECTORIES_TREECTRL_MAIN, OnSelChanged)
    ON_COMMAND(ID_FILE_PROPERTIES, OnProperties)
    ON_UPDATE_COMMAND_UI(ID_FILE_PROPERTIES, OnUpdateProperties)
    ON_MESSAGE(PERSONGROUPVIEWMSG_LBUTTONDBLCLK,OnPersonGroupViewLButtonDblClick)
    ON_COMMAND(ID_VIEW_SORT_ASCENDING, OnViewSortAscending)
    ON_UPDATE_COMMAND_UI(ID_VIEW_SORT_ASCENDING, OnUpdateViewSortAscending)
    ON_COMMAND(ID_VIEW_SORT_DESCENDING, OnViewSortDescending)
    ON_UPDATE_COMMAND_UI(ID_VIEW_SORT_DESCENDING, OnUpdateViewSortDescending)
    ON_COMMAND(ID_BUTTON_REFRESH, OnButtonDirectoryRefresh)
    ON_UPDATE_COMMAND_UI(ID_BUTTON_REFRESH, OnUpdateButtonDirectoryRefresh)
    ON_COMMAND(ID_BUTTON_SPEEDDIAL_ADD, OnButtonSpeeddialAdd)
    ON_UPDATE_COMMAND_UI(ID_BUTTON_SPEEDDIAL_ADD, OnUpdateButtonSpeeddialAdd)
    ON_UPDATE_COMMAND_UI(ID_BUTTON_MAKECALL, OnUpdateButtonMakecall)
    ON_COMMAND(ID_EDIT_DIRECTORIES_ADDUSER, OnEditDirectoriesAdduser)
    ON_UPDATE_COMMAND_UI(ID_EDIT_DIRECTORIES_ADDUSER, OnUpdateEditDirectoriesAdduser)
    ON_COMMAND(ID_EDIT_DELETE, OnDelete)
    ON_UPDATE_COMMAND_UI(ID_EDIT_DELETE, OnUpdateDelete)
    ON_MESSAGE(WM_ADDSITESERVER, OnAddSiteServer)
    ON_MESSAGE(WM_REMOVESITESERVER, OnRemoveSiteServer)
    ON_MESSAGE(WM_NOTIFYSITESERVERSTATECHANGE, OnNotifySiteServerStateChange)
    ON_COMMAND(ID_BUTTON_DIRECTORY_SERVICES_ADDSERVER, OnButtonDirectoryServicesAddserver)
    ON_UPDATE_COMMAND_UI(ID_BUTTON_DIRECTORY_SERVICES_ADDSERVER, OnUpdateButtonDirectoryServicesAddserver)
    ON_NOTIFY(NM_DBLCLK, IDC_CONFERENCESERVICES_VIEWCTRL_DETAILS, OnListWndDblClk)
    ON_COMMAND(ID_BUTTON_CONFERENCE_CREATE, OnButtonConferenceCreate)
    ON_COMMAND(ID_BUTTON_CONFERENCE_JOIN, OnButtonConferenceJoin)
    ON_COMMAND(ID_BUTTON_CONFERENCE_DELETE, OnButtonConferenceDelete)
    ON_UPDATE_COMMAND_UI(ID_BUTTON_CONFERENCE_CREATE, OnUpdateButtonConferenceCreate)
    ON_UPDATE_COMMAND_UI(ID_BUTTON_CONFERENCE_JOIN, OnUpdateButtonConferenceJoin)
    ON_UPDATE_COMMAND_UI(ID_BUTTON_CONFERENCE_DELETE, OnUpdateButtonConferenceDelete)
    ON_COMMAND(ID_VIEW_SORT_CONF_NAME, OnViewSortConfName)
    ON_COMMAND(ID_VIEW_SORT_CONF_DESCRIPTION, OnViewSortConfDescription)
    ON_COMMAND(ID_VIEW_SORT_CONF_START, OnViewSortConfStart)
    ON_COMMAND(ID_VIEW_SORT_CONF_STOP, OnViewSortConfStop)
    ON_COMMAND(ID_VIEW_SORT_CONF_OWNER, OnViewSortConfOwner)
    ON_UPDATE_COMMAND_UI(ID_VIEW_SORT_CONF_NAME, OnUpdateViewSortConfName)
    ON_UPDATE_COMMAND_UI(ID_VIEW_SORT_CONF_DESCRIPTION, OnUpdateViewSortConfDescription)
    ON_UPDATE_COMMAND_UI(ID_VIEW_SORT_CONF_START, OnUpdateViewSortConfStart)
    ON_UPDATE_COMMAND_UI(ID_VIEW_SORT_CONF_STOP, OnUpdateViewSortConfStop)
    ON_UPDATE_COMMAND_UI(ID_VIEW_SORT_CONF_OWNER, OnUpdateViewSortConfOwner)
    ON_COMMAND(ID_BUTTON_SPEEDDIAL_EDIT, OnButtonSpeeddialEdit)
    ON_NOTIFY(NM_DBLCLK, IDC_DIRECTORIES_TREECTRL_MAIN, OnMainTreeDblClk)
    ON_COMMAND(ID_DESKTOP_PAGE, OnDesktopPage)
    ON_WM_DESTROY()
    ON_MESSAGE(WM_UPDATECONFROOTITEM, OnUpdateConfRootItem)
    ON_MESSAGE(WM_UPDATECONFPARTICIPANT_ADD, OnUpdateConfParticipant_Add)
    ON_MESSAGE(WM_UPDATECONFPARTICIPANT_REMOVE, OnUpdateConfParticipant_Remove)
    ON_MESSAGE(WM_UPDATECONFPARTICIPANT_MODIFY, OnUpdateConfParticipant_Modify)
    ON_MESSAGE(WM_DELETEALLCONFPARTICIPANTS, OnDeleteAllConfParticipants)
    ON_MESSAGE(WM_SELECTCONFPARTICIPANT, OnSelectConfParticipant)
    ON_WM_SIZE()
    ON_COMMAND(ID_CONFGROUP_FULLSIZEVIDEO, OnConfgroupFullsizevideo)
    ON_COMMAND(ID_CONFGROUP_SHOWNAMES, OnConfgroupShownames)
    ON_COMMAND(ID_BUTTON_ROOM_DISCONNECT, OnButtonRoomDisconnect)
    ON_WM_CREATE()
    ON_MESSAGE(WM_MYONSELCHANGED, MyOnSelChanged)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
CMainExplorerWndDirectories::CMainExplorerWndDirectories()
{
   m_pDisplayWindow = NULL;
   m_pILSParentTreeItem = NULL;
   m_pDSParentTreeItem = NULL;
   m_pILSEnterpriseParentTreeItem = NULL;
   m_pSpeedTreeItem = NULL;
   m_pConfRoomTreeItem = NULL;

   m_pConfExplorer= NULL;
   m_pConfDetailsView = NULL;
   m_pConfTreeView = NULL;
   
   InitializeCriticalSection(&m_csDataLock);
}

/////////////////////////////////////////////////////////////////////////////
CMainExplorerWndDirectories::~CMainExplorerWndDirectories()
{
    DeleteCriticalSection(&m_csDataLock);

    // Clean up conference room pointers
    RELEASE( m_pConfDetailsView );
    RELEASE( m_pConfTreeView );
    RELEASE( m_pConfExplorer );
}

void CMainExplorerWndDirectories::PostTapiInit()
{
    //Get Tapi object and register out tree control
    IAVTapi* pTapi;
    if ( SUCCEEDED(get_Tapi(&pTapi)) )
    {
        if ( (SUCCEEDED(pTapi->get_ConfExplorer(&m_pConfExplorer))) && (m_pConfExplorer) )
        {
            //give parent of treectrl and listctrl to conf explorer
            //it will find appropriate children
            m_pConfExplorer->get_DetailsView( &m_pConfDetailsView );
            m_pConfExplorer->get_TreeView( &m_pConfTreeView );
        }

        pTapi->Release();
    }
}


/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectories::Refresh()
{
   if (m_pParentWnd)
      m_pParentWnd->SetDetailWindow(m_pDisplayWindow);
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectories::OnButtonPlacecall() 
{
    ASSERT(m_pParentWnd);

    if ( (m_pParentWnd->IsWindowVisible()) && (m_pDisplayWindow == GetFocus()) )
    {
        //route message to display window to see if it can handle the place call
        //only routed if window is visible and has focus
        BOOL bHandled = m_pDisplayWindow->OnCmdMsg(ID_BUTTON_MAKECALL,0,NULL,NULL);
        if ( bHandled ) return;
    }

    //
    // We have to verify AfxGetMainWnd() returned value
    //

    CWnd* pMainWnd = AfxGetMainWnd();

    if ( !pMainWnd || !((CMainFrame*) pMainWnd)->GetDocument() ) return;

    CActiveDialerDoc* pDoc = ((CMainFrame*) pMainWnd)->GetDocument();
    if (pDoc == NULL) return;

    //Get object that is selected
    switch (m_treeCtrl.GetSelectedObject())
    {
        case TOBJ_DIRECTORY_ILS_USER:
            {
                CILSUser* pILSUser = (CILSUser*)m_treeCtrl.GetDisplayObject();
                if ( pILSUser )
                    pILSUser->Dial( pDoc );
            }
            break;

        case TOBJ_DIRECTORY_DSENT_USER:
            {
                CLDAPUser* pUser = (CLDAPUser*) m_treeCtrl.GetDisplayObject();
                if ( pUser )
                    pUser->Dial( pDoc );
            }
            break;

        case TOBJ_DIRECTORY_SPEEDDIAL_PERSON:
            {
                CCallEntry *pCallEntry = (CCallEntry *) m_treeCtrl.GetDisplayObject();
                if ( pCallEntry )
                    pCallEntry->Dial( pDoc );
            }
            break;

        default:
            pDoc->Dial(_T(""),_T(""),LINEADDRESSTYPE_IPADDRESS,DIALER_MEDIATYPE_UNKNOWN, true );
    }
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectories::OnUpdateButtonMakecall(CCmdUI* pCmdUI) 
{
    //
    // We have to verify AfxGetMainWnd() returned value
    //

    CWnd* pMainWnd = AfxGetMainWnd();

    bool bEnable = (bool) (pMainWnd && ((CMainFrame *) pMainWnd)->GetDocument() &&
                          ((CMainFrame *) pMainWnd)->GetDocument()->m_bInitDialer );

    pCmdUI->Enable( bEnable );
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Directory Services Methods
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectories::GetTreeObjectsFromType(int nType,TREEOBJECT& tobj,TREEIMAGE& tim)
{
   //supply only valid objects
   switch (nType)
   {
      case 3:     tobj = TOBJ_DIRECTORY_ILS_SERVER;   tim = TIM_DIRECTORY_DOMAIN;      break;
   }
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//SpeedDial Methods
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectories::AddSpeedDial()
{
    //Add Parent Root Item
    CString sLabel;
    sLabel.LoadString(IDS_DIRECTORIES_SPEEDDIAL);
    m_pSpeedTreeItem = m_treeCtrl.AddObject(sLabel,m_pRootItem,TOBJ_DIRECTORY_SPEEDDIAL_GROUP,TIM_DIRECTORY_SPEEDDIAL_GROUP);

    RepopulateSpeedDialList( true );
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Button Handlers
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectories::OnButtonDirectoryRefresh() 
{
    TREEOBJECT nObject = m_treeCtrl.GetSelectedObject();
    bool bSelChange = true;

    switch ( nObject )
    {
        //////////////////////////////////////////////////////////////
        case TOBJ_DIRECTORY_ILS_SERVER_PEOPLE:
        case TOBJ_DIRECTORY_ILS_SERVER_CONF:
        case TOBJ_DIRECTORY_ILS_SERVER:
            bSelChange = false;
            {
                CString strServer;
                if ( nObject == TOBJ_DIRECTORY_ILS_SERVER )
                    m_treeCtrl.GetSelectedItemText( strServer );
                else
                    m_treeCtrl.GetSelectedItemParentText( strServer );

                BSTR bstrServer = strServer.AllocSysString();
                IAVTapi *pTapi;
                if ( SUCCEEDED(get_Tapi(&pTapi)) )
                {
                    IConfExplorer *pConfExplorer;
                    if ( SUCCEEDED(pTapi->get_ConfExplorer(&pConfExplorer)) )
                    {
                        IConfExplorerTreeView *pTree;
                        if ( SUCCEEDED(pConfExplorer->get_TreeView(&pTree)) )
                        {
                            pTree->Select( bstrServer );
                            pConfExplorer->Refresh();
                            pTree->Release();
                        }
                        pConfExplorer->Release();
                    }
                    pTapi->Release();
                }
                SysFreeString( bstrServer );
            }
            break;

        case TOBJ_DIRECTORY_DSENT_GROUP:
            break;

        ///////////////////////////////////////////////////////////////
        case TOBJ_DIRECTORY_SPEEDDIAL_GROUP:
            //clear the list
            if (::IsWindow(m_lstSpeedDial.GetSafeHwnd()))
                m_lstSpeedDial.ClearList();
            break;
    }

    if ( bSelChange )
        OnSelChanged();
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectories::OnUpdateButtonDirectoryRefresh(CCmdUI* pCmdUI) 
{
    bool bEnable = false;

    //Get object that is selected
    switch ( m_treeCtrl.GetSelectedObject() )
    {
        case TOBJ_DIRECTORY_ILS_SERVER:
        case TOBJ_DIRECTORY_ILS_SERVER_PEOPLE:
        case TOBJ_DIRECTORY_ILS_SERVER_CONF:
        case TOBJ_DIRECTORY_DSENT_GROUP:
        case TOBJ_DIRECTORY_DSENT_USER:
        case TOBJ_DIRECTORY_WAB_GROUP:
        case TOBJ_DIRECTORY_SPEEDDIAL_GROUP:
            bEnable = true;
    }

    pCmdUI->Enable( bEnable );
}

/*
/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectories::OnButtonDirectoryNewcontact() 
{
#ifdef _MSLITE
   return;
#endif //_MSLITE

   CWABEntry* pWABEntry = new CWABEntry;
   if (m_pDirectory->WABNewEntry(GetSafeHwnd(),pWABEntry) == DIRERR_SUCCESS)
   {
      //Get object that is selected
      TREEOBJECT TreeObject = m_treeCtrl.GetSelectedObject();
      
      if (TreeObject == TOBJ_DIRECTORY_WAB_PERSON)
      {
         //if another person, than add to parent of selected
         m_treeCtrl.AddObjectToParent(pWABEntry,TOBJ_DIRECTORY_WAB_PERSON,TIM_DIRECTORY_PERSON,TRUE);
      }
      else if (TreeObject == TOBJ_DIRECTORY_WAB_GROUP)
      {
         //Add to current group
         CWABEntry* pContainerWABEntry = (CWABEntry*)m_treeCtrl.GetDisplayObject();
         if (pContainerWABEntry)
         {
            //first add to group in WAB
            if (m_pDirectory->WABAddMember(pContainerWABEntry,pWABEntry) == DIRERR_SUCCESS)
            {
               //next add to tree using current selection as parent
               m_treeCtrl.AddObject(pWABEntry,TOBJ_DIRECTORY_WAB_PERSON,TIM_DIRECTORY_PERSON,TRUE);
            }
            else
            {
               delete pWABEntry;
            }
         }
      }
   }
   else
   {
      delete pWABEntry;
   }
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectories::OnUpdateButtonDirectoryNewcontact(CCmdUI* pCmdUI) 
{
#ifndef _MSLITE
   //Get object that is selected
   TREEOBJECT TreeObject = m_treeCtrl.GetSelectedObject();
   if ( (TreeObject == TOBJ_DIRECTORY_WAB_PERSON) ||
        (TreeObject == TOBJ_DIRECTORY_WAB_GROUP) )
      pCmdUI->Enable(TRUE);
   else
      pCmdUI->Enable(FALSE);
#endif //_MSLITE
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectories::OnButtonDirectoryDeletecontact() 
{
#ifdef _MSLITE
   return;
#endif //_MSLITE

   //Get object that is selected
   TREEOBJECT TreeObject = m_treeCtrl.GetSelectedObject();
   if (TreeObject == TOBJ_DIRECTORY_WAB_PERSON)
   {
      //Create media view for person and set details view
      CWABEntry* pWABEntry = (CWABEntry*)m_treeCtrl.GetDisplayObject();
      if (pWABEntry)
      {
         //should we ask to delete this contact
         CWinApp* pApp = AfxGetApp();
         CString sRegKey,sBaseKey;
         sBaseKey.LoadString(IDN_REGISTRY_CONFIRM_BASEKEY);
         sRegKey.LoadString(IDN_REGISTRY_CONFIRM_DELETE_CONTACT);
         int nRet = IDYES;
         if (pApp->GetProfileInt(sBaseKey,sRegKey,TRUE))
         {
            nRet = AfxMessageBox(IDS_CONFIRM_CONTACT_DELETE,MB_YESNO|MB_ICONQUESTION);
         }
         if (nRet == IDYES)
         {
            //Delete out of WAB
            m_pDirectory->WABRemove(pWABEntry);
            //Delete out of tree (this will delete pWABEntry)
            m_treeCtrl.DeleteSelectedObject();
         }
      }
   }
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectories::OnUpdateButtonDirectoryDeletecontact(CCmdUI* pCmdUI) 
{
#ifndef _MSLITE
   //Get object that is selected
   TREEOBJECT TreeObject = m_treeCtrl.GetSelectedObject();
   if (TreeObject == TOBJ_DIRECTORY_WAB_PERSON)
      pCmdUI->Enable(TRUE);
   else
      pCmdUI->Enable(FALSE);
#endif //_MSLITE
}
*/


/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectories::OnProperties() 
{
    switch ( m_treeCtrl.GetSelectedObject() )
    {
        case TOBJ_DIRECTORY_ILS_SERVER_CONF:
            if (m_pConfExplorer) m_pConfExplorer->Edit(NULL);
            break;
    }
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectories::OnUpdateProperties(CCmdUI* pCmdUI) 
{
#ifndef _MSLITE
   //Get object that is selected
   TREEOBJECT TreeObject = m_treeCtrl.GetSelectedObject();
   if ( (TreeObject == TOBJ_DIRECTORY_WAB_PERSON) ||
        (TreeObject == TOBJ_DIRECTORY_WAB_GROUP) )
      pCmdUI->Enable(TRUE);
   else
      pCmdUI->Enable(FALSE);
#endif //_MSLITE
    
    bool bEnable = false;

    switch ( m_treeCtrl.GetSelectedObject() )
    {
        case TOBJ_DIRECTORY_ILS_SERVER_CONF:
            if ( m_pConfExplorer )
            {
                IConfExplorerDetailsView *pView;
                if ( SUCCEEDED(m_pConfExplorer->get_DetailsView(&pView)) )
                {
                    if ( pView->IsConferenceSelected() == S_OK )
                        bEnable = true;

                    pView->Release();
                }
            }
    }

    pCmdUI->Enable( bEnable );
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectories::OnSelChanged()
{
    if ( !m_pParentWnd )
        return; 

    // Reset display window setting
    m_pDisplayWindow = &m_wndEmpty;

    //Get object that is selected
    USES_CONVERSION;
    TREEOBJECT TreeObject = m_treeCtrl.GetSelectedObject();

    //Decide what to do with the object
    switch (TreeObject)
    {
        ///////////////////////////////////
        // Topmost Item
        case TOBJ_DIRECTORY_ROOT:
            if (::IsWindow(m_lstPersonGroup.GetSafeHwnd()))
            {
                m_lstPersonGroup.ClearList();
                m_lstPersonGroup.Init( NULL, CPersonGroupListCtrl::STYLE_ROOT );
            }

            m_pDisplayWindow = &m_lstPersonGroup;
            break;

        /////////////////////////////////
        // Big book that's open
        case TOBJ_DIRECTORY_DSENT_GROUP:
            {
                m_lstPersonGroup.Init( NULL, CPersonGroupListCtrl::STYLE_DS );

                //Get all CLDAPUser objects from tree (they are siblings) and give to listctrl
                CObList PersonGroupList;
                m_treeCtrl.GetAllChildren( &PersonGroupList );
                m_lstPersonGroup.InsertList( &PersonGroupList );
                PersonGroupList.RemoveAll();

                // Show stuff on window
                m_pDisplayWindow = &m_lstPersonGroup;
            }
            break;

      case TOBJ_DIRECTORY_DSENT_USER:
      {
        m_lstPersonGroup.Init( NULL, CPersonGroupListCtrl::STYLE_DS );

         //Create media view for person and set details view
         CLDAPUser* pUser = (CLDAPUser *) m_treeCtrl.GetDisplayObject();
         if (pUser)
         {
            m_pDisplayWindow = &m_lstPerson;

            // copy CLDAPUser object (list will delete the object)
            pUser->AddRef();
            if ( !m_lstPerson.InsertObject(pUser) )
                pUser->Release();
         }
         break;
      }

        //////////////////////////////////////////////////////////
        // This is the image of the book with the World on it
        case TOBJ_DIRECTORY_ILS_SERVER_GROUP:
            if (::IsWindow(m_lstPersonGroup.GetSafeHwnd()))
            {
                m_lstPersonGroup.ClearList();
                m_lstPersonGroup.Init( NULL, CPersonGroupListCtrl::STYLE_ILS_ROOT );
            }

            m_pDisplayWindow = &m_lstPersonGroup;
            break;

        ////////////////////////////////////////////////////////////
        // This is the Image with the cloud
        case TOBJ_DIRECTORY_ILS_SERVER:
            if (::IsWindow(m_lstPersonGroup.GetSafeHwnd()))
            {
                m_lstPersonGroup.ClearList();
                m_lstPersonGroup.Init( NULL, CPersonGroupListCtrl::STYLE_INFO );
            }

            {
                CObList objList;
                UINT nIDS[2] = { IDS_DIRECTORIES_PEOPLE, IDS_DIRECTORIES_CONFERENCES };

                for ( int i = 0; i < 2; i ++ )
                {
                    CILSUser *pNewUser = new CILSUser;
                    pNewUser->m_sUserName.LoadString( nIDS[i] );
                    objList.AddHead( pNewUser );
                }

                m_lstPersonGroup.InsertList( &objList );
                objList.RemoveAll();
            }

            //Listctrl will delete list and objects within
            m_pDisplayWindow = &m_lstPersonGroup;
            break;


        //////////////////////////////////////////////////////////////
        // This is a folder that says "Conferences"
        case TOBJ_DIRECTORY_ILS_SERVER_CONF:
            {
                IAVTapi *pTapi;
                if ( SUCCEEDED(get_Tapi(&pTapi)) )
                {
                    IConfExplorer *pConfExplorer;
                    if ( SUCCEEDED(pTapi->get_ConfExplorer(&pConfExplorer)) )
                    {
                        IConfExplorerTreeView *pTreeView;
                        if ( SUCCEEDED(pConfExplorer->get_TreeView(&pTreeView)) )
                        {
                            CString strTemp;
                            m_treeCtrl.GetSelectedItemParentText( strTemp );
                            BSTR bstrTemp = strTemp.AllocSysString();

                            // Select a different server
                            pTreeView->Select( bstrTemp );

                            // Clean up
                            SysFreeString( bstrTemp );
                            pTreeView->Release();
                        }
                        pConfExplorer->Release();
                    }
                    pTapi->Release();
                }
            }
            m_pDisplayWindow = &m_pParentWnd->m_wndExplorer.m_wndMainConfServices.m_listCtrl;
            break;

        /////////////////////////////////////////////////////////////
        // This is a folder that says "People"
        case TOBJ_DIRECTORY_ILS_SERVER_PEOPLE:
        {
            if (::IsWindow(m_lstPersonGroup.GetSafeHwnd()))
            {
                m_lstPersonGroup.ClearList();
                m_lstPersonGroup.Init( NULL, CPersonGroupListCtrl::STYLE_ILS );
            }
            
            IAVTapi *pTapi;
            if ( SUCCEEDED(get_Tapi(&pTapi)) )
            {
                IConfExplorer *pConfExplorer;
                if ( SUCCEEDED(pTapi->get_ConfExplorer(&pConfExplorer)) )
                {
                    // Get the name of the server
                    CString strDefault, strServer;
                    m_treeCtrl.GetSelectedItemParentText(strServer);
                    strDefault.LoadString( IDS_DIRECTORIES_MYNETWORK );

                    IEnumSiteServer *pEnum;
                    BSTR bstrServer = strDefault.Compare(strServer) ? SysAllocString( strServer ) : NULL;
                    if ( SUCCEEDED(pConfExplorer->EnumSiteServer(bstrServer, &pEnum)) )
                    {
                        //Get all CILSUser objects from tree (they are siblings) and give to listctrl
                        CObList objList;

                        ISiteUser *pUser;
                        while ( pEnum->Next(&pUser) == S_OK )
                        {
                            // Extract info on user
                            BSTR bstrName = NULL, bstrAddress = NULL, bstrComputer = NULL;
                            pUser->get_bstrName( &bstrName );
                            pUser->get_bstrAddress( &bstrAddress );
                            pUser->get_bstrComputer( &bstrComputer );
                            pUser->Release();

                            CILSUser *pNewUser = new CILSUser;
                            pNewUser->m_sUserName = bstrName;
                            pNewUser->m_sIPAddress = bstrAddress;
                            pNewUser->m_sComputer = bstrComputer;
                            objList.AddTail( pNewUser );

                            SysFreeString( bstrName );
                            SysFreeString( bstrAddress );
                            SysFreeString( bstrComputer );
                        }
                        pEnum->Release();

                        //Listctrl will delete list and objects within
                        m_lstPersonGroup.InsertList( &objList );
                        objList.RemoveAll();
                        m_pDisplayWindow = &m_lstPersonGroup;
                    }
                    // Clean up
                    SysFreeString( bstrServer );
                    pConfExplorer->Release();
                }
                pTapi->Release();
            }
            break;
        }

        ////////////////////////////////////////////////////////////////////////////////
        case TOBJ_DIRECTORY_SPEEDDIAL_GROUP:
            {
                //don't delete pCallEntryList.  ListCtrl will delete it
                CObList CallEntryList;
                int nIndex = 1;
                while (1)
                {
                    //get all call entries for speeddial
                    CCallEntry* pCallEntry = new CCallEntry;
                    if (CDialerRegistry::GetCallEntry(nIndex,FALSE,*pCallEntry))
                    {
                        CallEntryList.AddTail(pCallEntry);
                    }
                    else
                    {
                        delete pCallEntry;
                        break;
                    }
                    nIndex++;
                }

                //Listctrl will delete list and objects within
                m_lstSpeedDial.ClearList();
                m_lstSpeedDial.SetColumns( CCallEntryListCtrl::STYLE_GROUP );

                m_lstSpeedDial.InsertList( &CallEntryList );
                CallEntryList.RemoveAll();
                m_pDisplayWindow = &m_lstSpeedDial;
            }
            break;
        
        //////////////////////////////////////////    
        // Speed dial item is selected
        case TOBJ_DIRECTORY_SPEEDDIAL_PERSON:
            m_lstSpeedDial.ClearList();
            m_lstSpeedDial.SetColumns( CCallEntryListCtrl::STYLE_ITEM );
            {
                CCallEntry *pCallEntry = (CCallEntry *) m_treeCtrl.GetDisplayObject();
                if ( pCallEntry )
                {
                    CObList CallEntryList;
                    CCallEntry *pNewEntry = new CCallEntry;

                    *pNewEntry = *pCallEntry;
                    CallEntryList.AddTail( pNewEntry );
                    m_lstSpeedDial.InsertList( &CallEntryList );

                    CallEntryList.RemoveAll();
                }


                m_pDisplayWindow = &m_lstSpeedDial;
            }
            break;

        //////////////////////////////////////////////////////////////
        // This is the folder that shows the conference room itself
        case TOBJ_DIRECTORY_CONFROOM_ME:
        case TOBJ_DIRECTORY_CONFROOM_PERSON:
            {
                CExplorerTreeItem *pItem = m_treeCtrl.GetSelectedTreeItem();
                if ( pItem )
                {
                    IAVTapi *pTapi;
                    if ( SUCCEEDED(get_Tapi(&pTapi)) )
                    {
                        IConfRoom *pConfRoom;
                        if ( SUCCEEDED(pTapi->get_ConfRoom(&pConfRoom)) )
                        {
                            ITParticipant *pParticipant = NULL;
                            if ( pItem->m_pUnknown )
                                ((IParticipant *) pItem->m_pUnknown)->get_ITParticipant( &pParticipant );

                            pConfRoom->SelectTalker( pParticipant, false );
                            RELEASE( pParticipant );
                            pConfRoom->Release();
                        }
                        pTapi->Release();
                    }
                }
            }
            // *** NO BREAK, DROP THROUGH PLEASE ***
        case TOBJ_DIRECTORY_CONFROOM_GROUP:
            m_pDisplayWindow = m_pParentWnd->m_wndExplorer.m_wndMainConfRoom.m_pDetailsWnd;
            break;
    }


    // Only update if it's actually changed
    m_pParentWnd->SetDetailWindow( m_pDisplayWindow );
}

/////////////////////////////////////////////////////////////////////////////
LRESULT CMainExplorerWndDirectories::OnPersonGroupViewLButtonDblClick(WPARAM wParam,LPARAM lParam)
{
    if (::IsWindow(m_lstPersonGroup.GetSafeHwnd()))
    {
        CObject* pObject = m_lstPersonGroup.GetSelObject();
        if (pObject)
        {
            //set the display object if it can
            m_treeCtrl.SetDisplayObjectDS(pObject);

            //we don't need the WABEntry anymore
            if ( pObject->IsKindOf(RUNTIME_CLASS(CLDAPUser)) )
                ((CLDAPUser *) pObject)->Release();
            else
                delete pObject;
        }
    }
    return 0;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//ILS Methods
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectories::AddILS()
{
    //Add Parent Root Item (this represents all ILS Servers)
    CString sLabel;
    sLabel.LoadString( IDS_DIRECTORIES_ILSSERVERS );
    m_pILSParentTreeItem = m_treeCtrl.AddObject( sLabel, m_pRootItem, TOBJ_DIRECTORY_ILS_SERVER_GROUP, TIM_DIRECTORY_GROUP );
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectories::OnDelete()
{
    //
    // We have to verify AfxGetMainWnd() returned value
    //

    CWnd* pMainWnd = AfxGetMainWnd();

    if ( !pMainWnd || !((CMainFrame*) pMainWnd)->GetDocument() ) return;
    CActiveDialerDoc* pDoc = ((CMainFrame*) pMainWnd)->GetDocument();

    IAVTapi *pTapi;
    CString sServer, sMyNetwork;
    TREEOBJECT nObject = m_treeCtrl.GetSelectedObject();

    switch ( nObject )
    {
        case TOBJ_DIRECTORY_ILS_SERVER_CONF:
            if ( SUCCEEDED(get_Tapi(&pTapi)) )
            {
                IConfExplorer *pExplorer;
                if ( SUCCEEDED(pTapi->get_ConfExplorer(&pExplorer)) )
                {
                    IConfExplorerDetailsView *pDetails;
                    if ( SUCCEEDED(pExplorer->get_DetailsView(&pDetails)) )
                    {
                        DATE dateStart, dateEnd;
                        BSTR bstrTemp = NULL;

                        // Either delete the whole server, or the selected conference
                        if ( FAILED(pDetails->get_Selection(&dateStart, &dateEnd, &bstrTemp)) )
                            m_treeCtrl.GetSelectedItemParentText( sServer );
                        else
                            pExplorer->Delete( NULL );

                        SysFreeString( bstrTemp );
                        pDetails->Release();
                    }
                    pExplorer->Release();
                }
                pTapi->Release();
            }
            break;

        case TOBJ_DIRECTORY_ILS_SERVER_PEOPLE:
            m_treeCtrl.GetSelectedItemParentText( sServer );
            break;
        
        case TOBJ_DIRECTORY_ILS_SERVER:
            m_treeCtrl.GetSelectedItemText( sServer );
            break;

        case TOBJ_DIRECTORY_DSENT_USER:
            {
                //find user to delete
                CLDAPUser* pUser = (CLDAPUser*) m_treeCtrl.GetDisplayObject();
                pDoc->DeleteBuddy(pUser);

                //remove from tree
                m_treeCtrl.DeleteSelectedObject();
            }
            return;
            break;

        case TOBJ_DIRECTORY_SPEEDDIAL_GROUP:
            if ( m_lstSpeedDial.GetSelItem() >= 0 )
            {
                CCallEntry *pEntry = (CCallEntry *) ((CCallEntryListItem *) m_lstSpeedDial.GetItem( m_lstSpeedDial.GetSelItem()))->GetObject();
                CDialerRegistry::DeleteCallEntry( FALSE, *pEntry );
            }
            break;

        case TOBJ_DIRECTORY_SPEEDDIAL_PERSON:
            if ( m_treeCtrl.GetDisplayObject() )
                CDialerRegistry::DeleteCallEntry( FALSE, *((CCallEntry *) m_treeCtrl.GetDisplayObject()) );
            break;
    }

    //////////////////////////////////////
    // ILS Objects....
    if ( !sServer.IsEmpty() )
    {
        sMyNetwork.LoadString( IDS_DIRECTORIES_MYNETWORK );
        if ( sServer.Compare(sMyNetwork) )
        {
            if ( SUCCEEDED(get_Tapi(&pTapi)) )
            {
                IConfExplorer *pExplorer;
                if ( SUCCEEDED(pTapi->get_ConfExplorer(&pExplorer)) )
                {
                    IConfExplorerTreeView *pTree;
                    if ( SUCCEEDED(pExplorer->get_TreeView(&pTree)) )
                    {
                        // Remove the server from the list
                        BSTR bstrTemp = sServer.AllocSysString();
                        pTree->RemoveServer( NULL, bstrTemp );
                        SysFreeString( bstrTemp );

                        pTree->Release();
                    }
                    pExplorer->Release();
                }
                pTapi->Release();
            }
        }
    }

        
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectories::OnUpdateDelete(CCmdUI* pCmdUI) 
{
    //Get object that is selected
    bool bEnable = false;
    CString sServer, sMyNetwork;

    switch ( m_treeCtrl.GetSelectedObject() )
    {
        case TOBJ_DIRECTORY_ILS_SERVER_CONF:
            {
                IAVTapi *pTapi;
                if ( SUCCEEDED(get_Tapi(&pTapi)) )
                {
                    IConfExplorer *pExplorer;
                    if ( SUCCEEDED(pTapi->get_ConfExplorer(&pExplorer)) )
                    {
                        IConfExplorerDetailsView *pDetails;
                        if ( SUCCEEDED(pExplorer->get_DetailsView(&pDetails)) )
                        {
                            DATE dateStart, dateEnd;
                            BSTR bstrTemp = NULL;

                            // Either delete the whole server, or the selected conference
                            if ( FAILED(pDetails->get_Selection(&dateStart, &dateEnd, &bstrTemp)) )
                                m_treeCtrl.GetSelectedItemParentText( sServer );
                            else
                                bEnable = true;

                            SysFreeString( bstrTemp );
                            pDetails->Release();
                        }
                        pExplorer->Release();
                    }
                    pTapi->Release();
                }
            }
            break;

        case TOBJ_DIRECTORY_ILS_SERVER_PEOPLE:
            m_treeCtrl.GetSelectedItemParentText( sServer );
            break;
        
        case TOBJ_DIRECTORY_ILS_SERVER:
            m_treeCtrl.GetSelectedItemText( sServer );
            break;

        case TOBJ_DIRECTORY_DSENT_USER:
        case TOBJ_DIRECTORY_SPEEDDIAL_PERSON:
            bEnable = true;
            break;
        
        case TOBJ_DIRECTORY_SPEEDDIAL_GROUP:
            if ( m_lstSpeedDial.GetSelItem() >= 0 )
                bEnable = true;
            break;
    }

    // Do we have a valid tree item?
    if ( !sServer.IsEmpty() )
    {
        sMyNetwork.LoadString( IDS_DIRECTORIES_MYNETWORK );
        if ( sServer.Compare(sMyNetwork) )
            bEnable = true;
    }

    pCmdUI->Enable( bEnable );
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectories::RefreshILS(CExplorerTreeItem* pParentTreeItem)
{
    // $FIXUP -- fill this in with something
}

/////////////////////////////////////////////////////////////////////////////
//static entry
void CALLBACK CMainExplorerWndDirectories::DirListServersCallBackEntry(bool bRet, void* pContext,CStringList& ServerList,DirectoryType dirtype)
{
   ASSERT(pContext);
   try
   {
      ((CMainExplorerWndDirectories*) pContext)->DirListServersCallBack(bRet,ServerList,dirtype);
   }
   catch (...)
   {
   
   }
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectories::DirListServersCallBack(bool bRet,CStringList& ServerList,DirectoryType dirtype)
{
    CString sServer;
    POSITION pos = ServerList.GetHeadPosition();

    if (dirtype == DIRTYPE_DS)
    {
        //if we actually have an DS server to show.  For DS we are only looking for one.
        //we don't actually care of the return here.  We just care if there is one or not.
        if (pos)
        {
            //
            // We have to verify AfxGetMainWnd() returned value
            //

            CWnd* pMainWnd = AfxGetMainWnd();

            //get buddy list from doc and see if any items need to be added 
            if ( !pMainWnd || !((CMainFrame*) pMainWnd)->GetDocument() ) return;

            CActiveDialerDoc* pDoc = ((CMainFrame*) pMainWnd)->GetDocument();
            if (pDoc)
            {
                //we must delete the received list
                CObList buddylist;
                pDoc->GetBuddiesList(&buddylist);
                POSITION pos = buddylist.GetHeadPosition();
                while (pos)
                {
                    CLDAPUser* pUser = (CLDAPUser*)buddylist.GetNext(pos);
                    DSAddUser(pUser,FALSE);

                    pUser->Release();
                }

                buddylist.RemoveAll();
            }
        }

        if ( m_pDSParentTreeItem )
            m_treeCtrl.ExpandItem( m_pDSParentTreeItem, TVE_EXPAND );
    }
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//WAB Group List Button Handlers
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectories::OnViewSortAscending() 
{
    // For conference listings...
    if ( (m_pDisplayWindow == &m_pParentWnd->m_wndExplorer.m_wndMainConfServices.m_listCtrl) && m_pConfDetailsView )
    {
        VARIANT_BOOL bSortAscending = TRUE;
        if (SUCCEEDED(m_pConfDetailsView->get_bSortAscending(&bSortAscending)))
        {
            //Make sure we are really switching
            if (bSortAscending == FALSE)
            {
                long nSortColumn=0;
                if (SUCCEEDED(m_pConfDetailsView->get_nSortColumn(&nSortColumn)))
                    m_pConfDetailsView->OnColumnClicked(nSortColumn);
            }
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectories::OnUpdateViewSortAscending(CCmdUI* pCmdUI) 
{
    // Force conference listings...
       if ( (m_pDisplayWindow == &m_pParentWnd->m_wndExplorer.m_wndMainConfServices.m_listCtrl) && m_pConfDetailsView )
    {
        VARIANT_BOOL bSortAscending = TRUE;
        if (SUCCEEDED(m_pConfDetailsView->get_bSortAscending(&bSortAscending)))
            pCmdUI->SetRadio( (BOOL) (bSortAscending == TRUE) );
    }
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectories::OnViewSortDescending() 
{
   // For conferences, toggle the column
   if ( (m_pDisplayWindow == &m_pParentWnd->m_wndExplorer.m_wndMainConfServices.m_listCtrl) && m_pConfDetailsView )
   {
      VARIANT_BOOL bSortAscending = TRUE;
      if (SUCCEEDED(m_pConfDetailsView->get_bSortAscending(&bSortAscending)))
      {
         //Make sure we are really switching
         if (bSortAscending == TRUE)
         {
            long nSortColumn=0;
            if (SUCCEEDED(m_pConfDetailsView->get_nSortColumn(&nSortColumn)))
               m_pConfDetailsView->OnColumnClicked(nSortColumn);
         }
      }
   }

}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectories::OnUpdateViewSortDescending(CCmdUI* pCmdUI) 
{
    // For conference services view
    if ( (m_pDisplayWindow == &m_pParentWnd->m_wndExplorer.m_wndMainConfServices.m_listCtrl) && m_pConfDetailsView )
    {
        VARIANT_BOOL bSortAscending = TRUE;
        if (SUCCEEDED(m_pConfDetailsView->get_bSortAscending(&bSortAscending)))
        pCmdUI->SetRadio( (BOOL) (bSortAscending == FALSE) );
    }
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Speeddial support
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectories::OnButtonSpeeddialAdd() 
{
    bool bShowDefaultDialog = false;

    TREEOBJECT nObject = m_treeCtrl.GetSelectedObject();
    switch ( nObject )
    {
        // Directory user
        case TOBJ_DIRECTORY_DSENT_USER:
            {
                CLDAPUser *pUser = (CLDAPUser *) m_treeCtrl.GetDisplayObject();
                if ( pUser )
                {
                    ASSERT( pUser->IsKindOf(RUNTIME_CLASS(CLDAPUser)) );
                    pUser->AddSpeedDial();
                }
            }
            break;

        // ILS user
        case TOBJ_DIRECTORY_ILS_SERVER_PEOPLE:
            {
                int nSel = m_lstPersonGroup.GetSelItem();
                if ( nSel >= 0 )
                {
                    CILSUser *pUser = (CILSUser *) m_lstPersonGroup.GetSelObject();
                    if ( pUser )
                    {
                        ASSERT( pUser->IsKindOf(RUNTIME_CLASS(CILSUser)) );
                        pUser->AddSpeedDial();
                        delete pUser;
                    }
                }
                else
                {
                    bShowDefaultDialog = true;
                }
            }
            break;

        // ILS conference
        case TOBJ_DIRECTORY_ILS_SERVER_CONF:
            {
                IAVTapi *pTapi;
                if ( SUCCEEDED(get_Tapi(&pTapi)) )
                {
                    IConfExplorer *pConfExp;
                    if ( SUCCEEDED(pTapi->get_ConfExplorer(&pConfExp)) )
                    {
                        pConfExp->AddSpeedDial( NULL );
                        pConfExp->Release();
                    }
                    pTapi->Release();
                }
            }
            break;

        default:
            bShowDefaultDialog = true;
            break;
    }

    // Show the stock Add SpeedDial dialog
    if ( bShowDefaultDialog )
    {
        CSpeedDialAddDlg dlg;
        if ( dlg.DoModal() == IDOK )
            CDialerRegistry::AddCallEntry( FALSE, dlg.m_CallEntry );
    }
}


/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectories::OnUpdateButtonSpeeddialAdd(CCmdUI* pCmdUI) 
{
    pCmdUI->Enable( true );
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//DS User Methods
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectories::AddDS()
{
    //Add Parent Root Item for Enterprise DS
    CString sLabel;
    sLabel.LoadString(IDS_DIRECTORIES_ENTERPRISEDS);
    m_pDSParentTreeItem = m_treeCtrl.AddObject(sLabel,m_pRootItem,TOBJ_DIRECTORY_DSENT_GROUP,TIM_DIRECTORY_BOOK);

    //
    // We have to verify AfxGetMainWnd() returned value
    //

    CWnd* pMainWnd = AfxGetMainWnd();

    // Failure conditions
    if ( !m_pDSParentTreeItem || !pMainWnd || !((CMainFrame*) pMainWnd)->GetDocument() )
    {
        AVTRACE(_T(".error.CMainExplorerWndDirectories::AddDS() -- failed creating DS parent item, no DS shown!") );
        return;
    }

    // Display buddy list for user...
    CActiveDialerDoc* pDoc = ((CMainFrame*) pMainWnd)->GetDocument();
    if ( pDoc )
    {
        //we must delete the received list
        CObList buddylist;
        pDoc->GetBuddiesList(&buddylist);
        POSITION pos = buddylist.GetHeadPosition();
        while (pos)
        {
            CLDAPUser* pUser = (CLDAPUser*)buddylist.GetNext(pos);
            DSAddUser(pUser,FALSE);
            pUser->Release();
        }

        buddylist.RemoveAll();

        if ( m_pDSParentTreeItem )
            m_treeCtrl.ExpandItem( m_pDSParentTreeItem, TVE_EXPAND );
    }

/*
    if ( pDoc && pDoc->m_dir.m_bInitialized )
        pDoc->m_dir.DirListServers( &DirListServersCallBackEntry, this, DIRTYPE_DS );
*/
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectories::DSClearUserList()
{
   //Get object that is selected
   TREEOBJECT TreeObject = m_treeCtrl.GetSelectedObject();
   if (TreeObject == TOBJ_DIRECTORY_DSENT_GROUP)
   {
      //delete all children items
      m_treeCtrl.DeleteAllChildren();

      //if we are looking at the correct list
      if ( (m_treeCtrl.GetSelectedTreeItem() == m_pDSParentTreeItem) &&
           (::IsWindow(m_lstPersonGroup.GetSafeHwnd())) )
      {
         m_lstPersonGroup.ClearList();
      }

      CExplorerTreeItem* pTreeItem = m_treeCtrl.GetSelectedTreeItem();
   }
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectories::DSAddUser(CLDAPUser* pUser,BOOL bAddToBuddyList)
{
    ASSERT(m_pDSParentTreeItem);
    ASSERT(::IsWindow(m_lstPersonGroup.GetSafeHwnd()));

    if ( !m_pDSParentTreeItem || !::IsWindow(m_lstPersonGroup.GetSafeHwnd()) )
        return;

    if (bAddToBuddyList)
    {
        //
        // We have to verify AfxGetMainWnd() returned value
        //

        CWnd* pMainWnd = AfxGetMainWnd();

        if ( !pMainWnd || !((CMainFrame*) pMainWnd)->GetDocument() ) return;
        
        CActiveDialerDoc* pDoc = ((CMainFrame*) pMainWnd)->GetDocument();
        if (pDoc)
        {
            //create another user and add to buddies list in document
            if ( pDoc->AddToBuddiesList(pUser) == FALSE )
                return;
        }
    }

    
   //Add to tree.  Tree will delete object
    CExplorerTreeItem *pItem = m_treeCtrl.AddObject(pUser,m_pDSParentTreeItem,TOBJ_DIRECTORY_DSENT_USER,TIM_DIRECTORY_PERSON,TRUE);
    if ( pItem )
    {
        pUser->AddRef();
        pItem->m_pfnRelease = &CLDAPUser::ExternalReleaseProc;
        pItem->m_bDeleteObject = false;
    }
   
   
   //if we are currently showing the list of members in our details view
   TREEOBJECT TreeObject = m_treeCtrl.GetSelectedObject();
   if (TreeObject == TOBJ_DIRECTORY_DSENT_GROUP)
   {
      // Add user to person list
      m_lstPersonGroup.InsertObjectToList(pUser);
   }
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Class CMainExplorerWndDirectoriesTree
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
int CMainExplorerWndDirectoriesTree::OnCompareTreeItems(CAVTreeItem* _pItem1,CAVTreeItem* _pItem2)
{
    int ret = 0;
    CExplorerTreeItem* pItem1 = (CExplorerTreeItem*)_pItem1;
    CExplorerTreeItem* pItem2 = (CExplorerTreeItem*)_pItem2;

    switch (pItem1->GetType())
    {
        case  TOBJ_DIRECTORY_DSENT_USER:
            {
                CLDAPUser* pUser1 = (CLDAPUser*)pItem1->GetObject();
                CLDAPUser* pUser2 = (CLDAPUser*)pItem2->GetObject();
                return (_tcsicmp(pUser1->m_sUserName,pUser2->m_sUserName) <= 0)?-1:1;
                break;
            }
        case  TOBJ_DIRECTORY_ILS_USER:
            {
                CILSUser* pILSUser1 = (CILSUser*)pItem1->GetObject();
                CILSUser* pILSUser2 = (CILSUser*)pItem2->GetObject();
                ret = (_tcsicmp(pILSUser1->m_sUserName,pILSUser2->m_sUserName) <= 0)?-1:1;
                break;
            }
/*
        case  TOBJ_DIRECTORY_WAB_PERSON:
            {
                CWABEntry* pWABEntry1 = (CWABEntry*)pItem1->GetObject();
                CWABEntry* pWABEntry2 = (CWABEntry*)pItem2->GetObject();
                if ( (pWABEntry1) && (pWABEntry2) )
                {
                    CString sText1,sText2;
                    if ( (m_pDirectory->WABGetStringProperty(pWABEntry1, PR_DISPLAY_NAME, sText1) == DIRERR_SUCCESS) &&
                         (m_pDirectory->WABGetStringProperty(pWABEntry2, PR_DISPLAY_NAME, sText2) == DIRERR_SUCCESS) )
                    {
                        ret = (_tcsicmp(sText1,sText2) <= 0)?-1:1;
                    }
                }
                break;
            }
*/

        // Me is always first participant
        case TOBJ_DIRECTORY_CONFROOM_ME:
            return -1;
            break;

        // Sort conf participants by name
        case TOBJ_DIRECTORY_CONFROOM_PERSON:
            if ( !pItem2->m_pUnknown )
                return 1;        // Me is always the first participant
            else
            {
                TRACE(_T(".comparing.%s to %s = %d.\n"), pItem1->m_sText, pItem2->m_sText, max(-1, min(1, pItem1->m_sText.CompareNoCase(pItem2->m_sText))) );
                return max(-1, min(1, pItem1->m_sText.CompareNoCase(pItem2->m_sText)));
            }
            break;
    }

    return ret;
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectoriesTree::OnRightClick(CExplorerTreeItem* pItem,CPoint& pt)
{
    int cxmenu = GetMenuFromType( pItem->GetType() );
    if ( cxmenu != CNTXMENU_NONE )
    {
        CMenu ContextMenu;
        if ( ContextMenu.LoadMenu(IDR_CONTEXT_DIRECTORIES) )
        {
            CMenu* pSubMenu = ContextMenu.GetSubMenu(cxmenu);
            if ( pSubMenu )
            {
                bool bEnable;

                // Make sure we enable things accordingly
                switch ( cxmenu )
                {
                    // ILS Server -- can't delete "My Network"
                    case CNTXMENU_ILS_SERVER:
                        {
                            CString sServer, sMyNetwork;
                            TREEOBJECT nObject = GetSelectedObject();
                            if ( (nObject == TOBJ_DIRECTORY_ILS_SERVER) )
                                GetSelectedItemText( sServer );
                            else
                                GetSelectedItemParentText( sServer );

                            sMyNetwork.LoadString( IDS_DIRECTORIES_MYNETWORK );

                            bEnable = (bool) (sServer.Compare(sMyNetwork) != 0);
                            pSubMenu->EnableMenuItem( ID_EDIT_DELETE, (bEnable) ? MF_ENABLED : MF_GRAYED );
                        }
                        break;

                    case CNTXMENU_CONFROOM:
                        {
                        //
                        // We have to verify AfxGetMainWnd() returned value
                        //

                        CWnd* pMainWnd = AfxGetMainWnd();

                        if( NULL == pMainWnd )
                        {
                            break;
                        }

                        pSubMenu->EnableMenuItem( ID_BUTTON_CONFERENCE_JOIN, (((CMainFrame *) pMainWnd)->CanJoinConference()) ? MF_ENABLED : MF_GRAYED );
                        pSubMenu->EnableMenuItem( ID_BUTTON_ROOM_DISCONNECT, (((CMainFrame *) pMainWnd)->CanLeaveConference()) ? MF_ENABLED : MF_GRAYED );

                        {
                            BOOL bEnable, bCheck;
                            ((CMainFrame *) pMainWnd)->CanConfRoomShowNames( bEnable, bCheck );
                            pSubMenu->EnableMenuItem( ID_CONFGROUP_SHOWNAMES, (bEnable) ? MF_ENABLED : MF_GRAYED );
                            pSubMenu->CheckMenuItem( ID_CONFGROUP_SHOWNAMES,  (bCheck) ? MF_CHECKED : MF_UNCHECKED);

                            ((CMainFrame *) pMainWnd)->CanConfRoomShowFullSizeVideo( bEnable, bCheck );
                            pSubMenu->EnableMenuItem( ID_CONFGROUP_FULLSIZEVIDEO, (bEnable) ? MF_ENABLED : MF_GRAYED );
                            pSubMenu->CheckMenuItem( ID_CONFGROUP_FULLSIZEVIDEO,  (bCheck) ? MF_CHECKED : MF_UNCHECKED);
                        }
                        }
                        break;
                }

                pSubMenu->TrackPopupMenu( TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                                          pt.x,pt.y, GetParent() );
            }
        }
    }
}


/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectoriesTree::OnSetDisplayText(CAVTreeItem* _pItem,LPTSTR text,BOOL dir,int nBufSize)
{
   try
   {
      CExplorerTreeItem* pItem = (CExplorerTreeItem*)_pItem;
      switch (pItem->GetType())
      {
/*
         case TOBJ_DIRECTORY_WAB_PERSON:
         case TOBJ_DIRECTORY_WAB_GROUP:
         {
            if (m_pDirectory == NULL) return;

            //WABEntries may come back blank (e.g. top most wab folder)
            CWABEntry* pWABEntry = (CWABEntry*)pItem->GetObject();
            if (pWABEntry)
            {  
               if (!dir)
               {
                  CString sText;
                  if (m_pDirectory->WABGetStringProperty(pWABEntry, PR_DISPLAY_NAME, sText) == DIRERR_SUCCESS)
                  {
                               _tcsncpy(text,sText,nBufSize-1);            
                     text[nBufSize-1] = '\0';                            //make sure we are null terminated
                  }
               }
            }
            break;
         }
*/
         case TOBJ_DIRECTORY_ILS_USER:
         {
            CObject* pObject = pItem->GetObject();
            CILSUser* pILSUser = (CILSUser*)pItem->GetObject();
            ASSERT(pILSUser);
            if (!dir)
            {
                       _tcsncpy(text,pILSUser->m_sUserName,nBufSize-1);            
               text[nBufSize-1] = '\0';                            //make sure we are null terminated
            }
            break;
         }
         case TOBJ_DIRECTORY_DSENT_USER:
         {
            CObject* pObject = pItem->GetObject();
            CLDAPUser* pUser = (CLDAPUser*)pItem->GetObject();
            ASSERT(pUser);
            if (!dir)
            {
                       _tcsncpy(text,pUser->m_sUserName,nBufSize-1);            
               text[nBufSize-1] = '\0';                            //make sure we are null terminated
            }
            break;
         }
      }
   }
   catch (...)
   {

   }
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectoriesTree::SelectTopItem()
{
   SelectItem(GetNextItem(NULL,TVGN_FIRSTVISIBLE));
}

/////////////////////////////////////////////////////////////////////////////
//Only works with first level children of the currently displayed object.  
void CMainExplorerWndDirectoriesTree::SetDisplayObject(CWABEntry* pWABEntry)
{
   HTREEITEM hItem;
   if (hItem = CAVTreeCtrl::GetSelectedItem())
   {
      CExplorerTreeItem* pChildItem;
      HTREEITEM hChildItem = CAVTreeCtrl::GetChildItem(hItem);
      while (hChildItem)
      {
         pChildItem = (CExplorerTreeItem*)CAVTreeCtrl::GetItemData(hChildItem);

         if (*pWABEntry == (CWABEntry*)pChildItem->GetObject())
         {
            CAVTreeCtrl::Select(hChildItem,TVGN_CARET);
            break;
         }
         hChildItem = CAVTreeCtrl::GetNextSiblingItem(hChildItem);
      }
   }
}

/////////////////////////////////////////////////////////////////////////////
//Only works with first level children of the currently displayed object.  
void CMainExplorerWndDirectoriesTree::SetDisplayObjectDS(CObject* pObject)
{
    HTREEITEM hItem;
    if (hItem = CAVTreeCtrl::GetSelectedItem())
    {
        CExplorerTreeItem* pChildItem;
        HTREEITEM hChildItem = CAVTreeCtrl::GetChildItem(hItem);

        // Are we double clicking an item that has no children?
        if ( !hChildItem )
        {
            if ( pObject->IsKindOf(RUNTIME_CLASS(CILSUser)) )
            {
                if ( !((CILSUser *) pObject)->m_sIPAddress.IsEmpty() )
                    ((CILSUser *) pObject)->Dial( NULL );
            }
        }
        else
        {
            // Go through all children looking for a match
            while (hChildItem)
            {
                pChildItem = (CExplorerTreeItem*)CAVTreeCtrl::GetItemData(hChildItem);

                // Look for a match by name
                if ( pObject->IsKindOf(RUNTIME_CLASS(CILSUser)) )
                {
                    // Select item from list
                    TCHAR szText[255];
                    TV_ITEM tvi;
                    tvi.hItem = hChildItem;
                    tvi.mask = TVIF_HANDLE | TVIF_TEXT;
                    tvi.pszText = szText;
                    tvi.cchTextMax = 254;

                    if ( GetItem(&tvi) )
                    {
                        if ( ((CILSUser *) pObject)->m_sUserName.Compare(tvi.pszText) == 0 )
                        {
                            CAVTreeCtrl::Select(hChildItem,TVGN_CARET);
                            break;
                        }
                    }
                }
                else if ( (pObject->IsKindOf(RUNTIME_CLASS(CDSUser))) && 
                          (*(CDSUser*)pObject == (CDSUser*)pChildItem->GetObject()) )
                {
                    CAVTreeCtrl::Select(hChildItem,TVGN_CARET);
                    break;
                }
                else if ( (pObject->IsKindOf(RUNTIME_CLASS(CLDAPUser))) && 
                          (((CLDAPUser *)pObject)->Compare((CLDAPUser *) pChildItem->GetObject()) == 0) )
                {
                    CAVTreeCtrl::Select(hChildItem,TVGN_CARET);
                    break;
                }

                hChildItem = CAVTreeCtrl::GetNextSiblingItem(hChildItem);
            }
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//User Buddy List Management
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectories::OnEditDirectoriesAdduser() 
{
   CDirectoriesFindUser dlg;
   if ( (dlg.DoModal() == IDOK) && (dlg.m_pSelectedUser) )
   {
      DSAddUser(dlg.m_pSelectedUser,TRUE);      
   }
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectories::OnUpdateEditDirectoriesAdduser(CCmdUI* pCmdUI) 
{
   //Get object that is selected
   TREEOBJECT TreeObject = m_treeCtrl.GetSelectedObject();
   if ( (TreeObject == TOBJ_DIRECTORY_DSENT_GROUP) ||
        (TreeObject == TOBJ_DIRECTORY_DSENT_USER) )
      pCmdUI->Enable(TRUE);
   else
      pCmdUI->Enable(FALSE);
}



HRESULT    CMainExplorerWndDirectories::AddSiteServer( CExplorerTreeItem *pItem, BSTR bstrName )
{
    CString sLabel;
    TREEOBJECT nTreeObject = TOBJ_DIRECTORY_ILS_SERVER;
    CExplorerTreeItem *pItemAdded = NULL, *pItemPeople = NULL;

    // Either we're adding a specific server or we're adding "My Network".
    if ( bstrName )
    {
        pItemAdded = m_treeCtrl.AddObject( bstrName, pItem, nTreeObject, TIM_DIRECTORY_DOMAIN, TIM_IMAGE_BAD, SERVER_UNKNOWN, TVI_SORT );
    }
    else
    {
        sLabel.LoadString(IDS_DIRECTORIES_MYNETWORK);
        pItemAdded = m_treeCtrl.AddObject( sLabel, pItem, nTreeObject, TIM_DIRECTORY_WORKSTATION, TIM_IMAGE_BAD, SERVER_UNKNOWN, TVI_FIRST );
    }

    // Add person and conference folders
    if ( pItemAdded )
    {
        sLabel.LoadString( IDS_DIRECTORIES_PEOPLE );
        pItemPeople = m_treeCtrl.AddObject( sLabel, pItemAdded, TOBJ_DIRECTORY_ILS_SERVER_PEOPLE, TIM_DIRECTORY_FOLDER, TIM_DIRECTORY_FOLDER_OPEN );

        sLabel.LoadString( IDS_DIRECTORIES_CONFERENCES );
        pItemAdded = m_treeCtrl.AddObject( sLabel, pItemAdded, TOBJ_DIRECTORY_ILS_SERVER_CONF, TIM_DIRECTORY_FOLDER, TIM_DIRECTORY_FOLDER_OPEN );
    }

    // Expand the tree view since it has objects in it now
    if ( pItemAdded )
    {
        m_treeCtrl.EnsureVisible( pItemAdded->GetTreeItemHandle() );

        // Force selection if it is the default network
        if ( !bstrName && pItemPeople )
            m_treeCtrl.SelectItem( pItemPeople->GetTreeItemHandle() );
    }
    

    return S_OK;
}

#define TEXT_SIZE    255

HRESULT    CMainExplorerWndDirectories::RemoveSiteServer( CExplorerTreeItem *pItem, BSTR bstrName )
{
    ASSERT( bstrName );
    if ( !bstrName ) return E_POINTER;

    // Look for an item that has text as specified
    USES_CONVERSION;
    if ( pItem )
    {
        TV_ITEM tvi = { 0 };
        tvi.mask = TVIF_HANDLE | TVIF_PARAM;

        HTREEITEM hItem = m_treeCtrl.GetChildItem( pItem->GetTreeItemHandle() );
        while ( hItem )
        {
            tvi.hItem = hItem;

            // Get next item now (before deleting!)
            hItem = m_treeCtrl.GetNextSiblingItem( hItem );

            if ( m_treeCtrl.GetItem(&tvi) )
            {
                CExplorerTreeItem* pItem = (CExplorerTreeItem *) tvi.lParam;
                if ( pItem && !pItem->m_sText.Compare(OLE2CT(bstrName)) )
                    m_treeCtrl.DeleteItem( pItem );
            }

        }
    }


    return S_OK;
}

HRESULT    CMainExplorerWndDirectories::NotifySiteServerStateChange( CExplorerTreeItem *pItem, BSTR bstrName, ServerState nState )
{
    // Look for an item that has text as specified
    USES_CONVERSION;
    if ( pItem )
    {
        // Resolve to the actual name for the conference
        BSTR bstrActualName = NULL;
        if ( !bstrName )
        {
            CString strTemp;
            strTemp.LoadString( IDS_DIRECTORIES_MYNETWORK );
            bstrActualName = strTemp.AllocSysString();
        }
        else
        {
            bstrActualName = SysAllocString( bstrName );
        }

        TV_ITEM tvi = { 0 };
        tvi.mask = TVIF_HANDLE | TVIF_PARAM;

        HTREEITEM hItem = m_treeCtrl.GetChildItem( pItem->GetTreeItemHandle() );
        while ( hItem )
        {
            tvi.hItem = hItem;
            if ( m_treeCtrl.GetItem(&tvi) )
            {
                CExplorerTreeItem* pItem = (CExplorerTreeItem *) tvi.lParam;
                if ( pItem && !pItem->m_sText.Compare(OLE2CT(bstrActualName)) )
                {
                    pItem->m_nState = nState;

                    TV_ITEM tvi = { 0 };
                    tvi.hItem = hItem;
                    tvi.mask = TVIF_HANDLE | TVIF_STATE;
                    tvi.stateMask = TVIS_OVERLAYMASK;
                    tvi.state = INDEXTOOVERLAYMASK(pItem->m_nState);
            
                    m_treeCtrl.SetItem( &tvi );

                    // Repaint if necessary
                    TREEOBJECT nObject = m_treeCtrl.GetSelectedObject();
                    if ( (m_treeCtrl.GetSelectedItem() == hItem) ||
                         (((nObject == TOBJ_DIRECTORY_ILS_SERVER_PEOPLE) || (nObject == TOBJ_DIRECTORY_ILS_SERVER_CONF)) &&
                         (hItem == m_treeCtrl.GetParentItem(m_treeCtrl.GetSelectedItem()))) )
                    {
                        OnSelChanged();
                    }
                }
            }

            // Continue through tree list
            hItem = m_treeCtrl.GetNextSiblingItem( hItem );
        }

        SysFreeString( bstrActualName );
    }

    return S_OK;
}


LRESULT CMainExplorerWndDirectories::OnAddSiteServer(WPARAM wParam, LPARAM lParam )
{
    AddSiteServer( m_pILSParentTreeItem, (BSTR) lParam );
    SysFreeString( (BSTR) lParam );

    return 0;
}

LRESULT CMainExplorerWndDirectories::OnRemoveSiteServer(WPARAM wParam, LPARAM lParam )
{
    RemoveSiteServer( m_pILSParentTreeItem, (BSTR) lParam );
    SysFreeString( (BSTR) lParam );

    return 0;
}

LRESULT CMainExplorerWndDirectories::OnNotifySiteServerStateChange(WPARAM wParam, LPARAM lParam)
{
    NotifySiteServerStateChange( m_pILSParentTreeItem, (BSTR) lParam, (ServerState) wParam );
    SysFreeString( (BSTR) lParam );

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

void CMainExplorerWndDirectories::OnButtonDirectoryServicesAddserver() 
{
    CMainFrame *pFrame = (CMainFrame *) AfxGetMainWnd();
    if ( pFrame )
        pFrame->OnButtonDirectoryAddilsserver();
}

void CMainExplorerWndDirectories::OnUpdateButtonDirectoryServicesAddserver(CCmdUI* pCmdUI) 
{
    CMainFrame *pFrame = (CMainFrame *) AfxGetMainWnd();
    if ( pFrame )
        pFrame->OnUpdateButtonDirectoryAddilsserver( pCmdUI );
}


//////////////////////////////////////////////////////////////
// Conference services stuff
//
/////////////////////////////////////////////////////////////////////////////
// Conference menu items
//
void CMainExplorerWndDirectories::OnButtonConferenceCreate() 
{
   if (m_pConfExplorer) m_pConfExplorer->Create(NULL);
}

void CMainExplorerWndDirectories::OnButtonConferenceJoin() 
{
   if (m_pConfExplorer) m_pConfExplorer->Join(NULL);
}

void CMainExplorerWndDirectories::OnButtonConferenceDelete() 
{
    if ( m_pConfExplorer) m_pConfExplorer->Delete( NULL );    
}

// update handlers
void CMainExplorerWndDirectories::OnUpdateButtonConferenceCreate(CCmdUI* pCmdUI) 
{
    //
    // We have to verify AfxGetMainWnd() returned value
    //

    CWnd* pMainWnd = AfxGetMainWnd();

    bool bEnable = (bool) (pMainWnd && ((CMainFrame *) pMainWnd)->GetDocument() &&
                          ((CMainFrame *) pMainWnd)->GetDocument()->m_bInitDialer );

    pCmdUI->Enable( bEnable );
}

void CMainExplorerWndDirectories::OnUpdateButtonConferenceJoin(CCmdUI* pCmdUI) 
{
    //
    // We have to verify AfxGetMainWnd() returned value
    //

    CWnd* pMainWnd = AfxGetMainWnd();

    if(pMainWnd)
        pCmdUI->Enable( ((CMainFrame *) pMainWnd)->CanJoinConference() );
}

void CMainExplorerWndDirectories::OnUpdateButtonConferenceDelete(CCmdUI* pCmdUI) 
{
   //Make sure we have a selection
   pCmdUI->Enable( ( (m_pConfDetailsView) && (m_pConfDetailsView->IsConferenceSelected() == S_OK) ) ? TRUE : FALSE );
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectories::OnListWndDblClk(NMHDR* pNMHDR, LRESULT* pResult)
{
    if ( m_pDisplayWindow )
        m_pDisplayWindow->SendMessage( WM_NOTIFY, (WPARAM) pNMHDR->idFrom, (LPARAM) pNMHDR );
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Column Support
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

void ColumnCMDUI( IConfExplorerDetailsView *pDetails, CCmdUI* pCmdUI, long col)
{
    if ( pDetails )
    {
        long nSortColumn=0;
        if ( SUCCEEDED(pDetails->get_nSortColumn(&nSortColumn)) )
            pCmdUI->SetRadio( (BOOL) (nSortColumn == col) );
    }
}


/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectories::OnViewSortConfName() 
{
   if (m_pConfDetailsView) m_pConfDetailsView->OnColumnClicked(CONFSERVICES_MENU_COLUMN_CONFERENCENAME);
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectories::OnUpdateViewSortConfName(CCmdUI* pCmdUI) 
{
   ColumnCMDUI( m_pConfDetailsView, pCmdUI, CONFSERVICES_MENU_COLUMN_CONFERENCENAME );
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectories::OnViewSortConfDescription() 
{
   if (m_pConfDetailsView) m_pConfDetailsView->OnColumnClicked(CONFSERVICES_MENU_COLUMN_DESCRIPTION);
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectories::OnUpdateViewSortConfDescription(CCmdUI* pCmdUI) 
{
   ColumnCMDUI(m_pConfDetailsView, pCmdUI, CONFSERVICES_MENU_COLUMN_DESCRIPTION);
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectories::OnViewSortConfStart() 
{
   if (m_pConfDetailsView) m_pConfDetailsView->OnColumnClicked(CONFSERVICES_MENU_COLUMN_START);
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectories::OnUpdateViewSortConfStart(CCmdUI* pCmdUI) 
{
   ColumnCMDUI(m_pConfDetailsView, pCmdUI, CONFSERVICES_MENU_COLUMN_START);
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectories::OnViewSortConfStop() 
{
   if (m_pConfDetailsView) m_pConfDetailsView->OnColumnClicked(CONFSERVICES_MENU_COLUMN_STOP);
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectories::OnUpdateViewSortConfStop(CCmdUI* pCmdUI) 
{
   ColumnCMDUI(m_pConfDetailsView, pCmdUI, CONFSERVICES_MENU_COLUMN_STOP);
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectories::OnViewSortConfOwner() 
{
   if (m_pConfDetailsView) m_pConfDetailsView->OnColumnClicked(CONFSERVICES_MENU_COLUMN_OWNER);
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndDirectories::OnUpdateViewSortConfOwner(CCmdUI* pCmdUI) 
{
   ColumnCMDUI(m_pConfDetailsView, pCmdUI, CONFSERVICES_MENU_COLUMN_OWNER);
}

void CMainExplorerWndDirectories::OnButtonSpeeddialEdit() 
{
    //
    // We have to verify AfxGetMainWnd() returned value
    //

    CWnd* pMainWnd = AfxGetMainWnd();

    // Pass along to the parent list
    if ( pMainWnd )
        ((CMainFrame *) pMainWnd)->OnButtonSpeeddialEdit();
}

LRESULT CMainExplorerWndDirectories::OnMainTreeDblClk(WPARAM wParam, LPARAM lParam)
{
    BOOL bRet = TRUE;

    switch ( m_treeCtrl.GetSelectedObject() )
    {
        case TOBJ_DIRECTORY_DSENT_USER:
        case TOBJ_DIRECTORY_SPEEDDIAL_PERSON:
            OnButtonPlacecall();
            bRet = FALSE;
            break;
    }

    return bRet;
}

void CMainExplorerWndDirectories::RepopulateSpeedDialList( bool bObeyPersistSettings )
{
    if ( m_pSpeedTreeItem )
    {    
        // Clean out children first
        if ( m_pSpeedTreeItem->GetTreeItemHandle() )
            m_treeCtrl.DeleteAllChildren( m_pSpeedTreeItem->GetTreeItemHandle() );

        BOOL bContinue = TRUE;
        int nIndex = 1;
        while (bContinue)
        {
            //get all call entries for speeddial
            CCallEntry *pCallEntry = new CCallEntry;
            bContinue = CDialerRegistry::GetCallEntry( nIndex, FALSE, *pCallEntry );
             if ( bContinue )
            {
                CExplorerTreeItem *pItem =m_treeCtrl.AddObject( (CObject *) pCallEntry, 
                                                                m_pSpeedTreeItem,
                                                                TOBJ_DIRECTORY_SPEEDDIAL_PERSON,
                                                                (TREEIMAGE) (TIM_DIRECTORY_SPEED_PHONE + (pCallEntry->m_MediaType - 1)),
                                                                TRUE );
                // Set the name for the display item...
                if ( pItem )
                    pItem->SetText( pCallEntry->m_sDisplayName );
                else
                    delete pCallEntry;
            }
            else
            {
                delete pCallEntry;
            }

            nIndex++;
        }

        bool bExpand = (bool) (!bObeyPersistSettings || ((m_nPersistInfo & SPEEDDIAL_OPEN) != 0));

        m_treeCtrl.ExpandItem( m_pSpeedTreeItem, (bExpand) ? TVE_EXPAND : TVE_COLLAPSE );

        // Force refresh of speed dial list if it's selected
        if ( m_treeCtrl.GetSelectedObject() == TOBJ_DIRECTORY_SPEEDDIAL_GROUP )
            OnSelChanged();
    }
}

void CMainExplorerWndDirectories::OnDesktopPage()
{
    //
    // We have to verify AfxGetMainWnd() returned value
    //

    CWnd* pMainWnd = AfxGetMainWnd();

    if( NULL == pMainWnd )
    {
        return;
    }

    CActiveDialerDoc* pDoc = ((CMainFrame*) pMainWnd)->GetDocument();
    if (pDoc == NULL) return;

    int nSel = m_lstPersonGroup.GetSelItem();
    if ( nSel >= 0 )
    {
        CILSUser *pUser = (CILSUser *) m_lstPersonGroup.GetSelObject();
        if ( pUser )
        {
            ASSERT( pUser->IsKindOf(RUNTIME_CLASS(CILSUser)) );
            pUser->DesktopPage( pDoc );
            delete pUser;
        }
    }
}

void CMainExplorerWndDirectories::UpdateData( bool bSaveAndValidate )
{
    CString strTemp;
    strTemp.LoadString( IDN_REGISTRY_FOLDERS );

    if ( bSaveAndValidate )
    {
        // Write information out to the registry
        m_nPersistInfo = ILS_OPEN | DS_OPEN | SPEEDDIAL_OPEN;


        TV_ITEM tvi;
        tvi.mask = TVIF_HANDLE | TVIF_STATE;
        tvi.stateMask = TVIS_EXPANDED;

        // Is speed dial list open or closed?
        if ( m_pSpeedTreeItem )
        {
            tvi.hItem = m_pSpeedTreeItem->GetTreeItemHandle();
            if ( m_treeCtrl.GetItem(&tvi) && ((tvi.state & TVIS_EXPANDED) == 0) )
                m_nPersistInfo &= ~(SPEEDDIAL_OPEN);
        }

        AfxGetApp()->WriteProfileInt( _T(""), strTemp, m_nPersistInfo );
    }
    else
    {
        m_nPersistInfo = AfxGetApp()->GetProfileInt( _T(""), strTemp, ILS_OPEN | DS_OPEN | SPEEDDIAL_OPEN );
    }
}

void CMainExplorerWndDirectories::OnDestroy() 
{
    UpdateData( true );

    // Persist and clean out lists
    m_lstSpeedDial.SaveOrLoadColumnSettings( true );
    m_lstPersonGroup.SaveOrLoadColumnSettings( true );

    m_lstSpeedDial.ClearList();
    m_lstPersonGroup.ClearList();
    m_lstPerson.ClearList();

    CMainExplorerWndBase::OnDestroy();
}

void CMainExplorerWndDirectories::AddConfRoom()
{
    //Add Parent Root Item
    CString sLabel;
    sLabel.LoadString(IDS_DIRECTORIES_CONFROOM);
    m_pConfRoomTreeItem = m_treeCtrl.AddObject( sLabel, NULL, TOBJ_DIRECTORY_CONFROOM_GROUP, TIM_DIRECTORY_CONFROOM_GROUP );
}

LRESULT CMainExplorerWndDirectories::MyOnSelChanged(WPARAM wParam, LPARAM lParam )
{
    OnSelChanged();
    return 0;
}


LRESULT CMainExplorerWndDirectories::OnUpdateConfRootItem(WPARAM wParam, LPARAM lParam )
{
    // If we have a conference room item, set accordingly
    if ( m_pConfRoomTreeItem )
    {
        if ( lParam )
        {
            m_pConfRoomTreeItem->SetText( OLE2CT((BSTR) lParam) );
        }
        else
        {
            CString sLabel;
            sLabel.LoadString(IDS_DIRECTORIES_CONFROOM);
            m_pConfRoomTreeItem->SetText( sLabel );
        }
        
        RedrawTreeItem( m_pConfRoomTreeItem );
    }

    // Clean up
    if ( lParam )
        SysFreeString( (BSTR) lParam );

    return 0;
}

void CMainExplorerWndDirectories::OnUpdateConfMeItem( CExplorerTreeItem *pItem )
{
    ASSERT( pItem );

    TREEIMAGE tImage = TIM_DIRECTORY_CONFROOM_ME_NOVIDEO;
    IAVTapi* pTapi;
    if ( SUCCEEDED(get_Tapi(&pTapi)) )
    {
        IConfRoom *pConfRoom;
        if ( (SUCCEEDED(pTapi->get_ConfRoom(&pConfRoom))) && pConfRoom )
        {
            IAVTapiCall *pAVCall;
            if ( SUCCEEDED(pConfRoom->get_IAVTapiCall(&pAVCall)) )
            {
                IDispatch *pVideoPreview;
                if ( SUCCEEDED(pAVCall->get_IVideoWindowPreview((IDispatch **) &pVideoPreview)) )
                {
                    tImage = TIM_DIRECTORY_CONFROOM_ME;

                    // Is there a problem with the QOS?
                    if ( pAVCall->IsPreviewStreaming() == S_FALSE  )
                        tImage = TIM_DIRECTORY_CONFROOM_ME_BROKEN;

                    pVideoPreview->Release();
                }
                pAVCall->Release();
            }
            pConfRoom->Release();
        }
        pTapi->Release();
    }

    // Set Image for tree item
    pItem->SetImage( tImage );
}


LRESULT CMainExplorerWndDirectories::OnUpdateConfParticipant_Add(WPARAM wParam, LPARAM lParam )
{
    CExplorerTreeItem *pItem = NULL;

    if ( m_pConfRoomTreeItem && lParam )
    {
        // Add either the participant or Me
        if ( wParam )
        {
            VARIANT_BOOL bStreaming = FALSE;
            ((IParticipant *) wParam)->get_bStreamingVideo( &bStreaming );

            pItem = m_treeCtrl.AddObject( (BSTR) lParam, m_pConfRoomTreeItem,
                                          TOBJ_DIRECTORY_CONFROOM_PERSON,
                                          (bStreaming) ? TIM_DIRECTORY_CONFROOM_PERSON : TIM_DIRECTORY_CONFROOM_PERSON_NOVIDEO,
                                          TIM_IMAGE_BAD,
                                          0,
                                          TVI_SORT );
            if ( pItem )
            {
                pItem->DeleteObjectOnClose( TRUE );
                ((IUnknown *) wParam)->QueryInterface( IID_IParticipant, (void **) &pItem->m_pUnknown );
            }
        }
        else
        {
            pItem = m_treeCtrl.AddObject( (BSTR) lParam, m_pConfRoomTreeItem,
                                          TOBJ_DIRECTORY_CONFROOM_ME,
                                          TIM_DIRECTORY_CONFROOM_ME,
                                          TIM_IMAGE_BAD,
                                          0,
                                          TVI_FIRST );
            if ( pItem )
                OnUpdateConfMeItem( pItem );
        }

        if ( pItem )
        {
            m_treeCtrl.ExpandItem( m_pConfRoomTreeItem, TVE_EXPAND );
            m_treeCtrl.SetScrollPos( SB_HORZ, 0, TRUE );
        }

    }

    // Basic clean up
    if ( lParam )
        SysFreeString( (BSTR) lParam );

    if ( wParam )
    {
        DWORD dwCount;
        dwCount = ((IUnknown *) wParam)->Release();
        TRACE(_T("ParticipantAdd() RefCount = %p @ %ld.\n"), wParam, dwCount );
    }

    return (LRESULT) pItem;
}

LRESULT CMainExplorerWndDirectories::OnUpdateConfParticipant_Remove(WPARAM wParam, LPARAM lParam )
{
    if ( m_pConfRoomTreeItem )
    {
        CExplorerTreeItem *pItem = m_treeCtrl.GetChildItemWithIUnknown( m_pConfRoomTreeItem->GetTreeItemHandle(), (IUnknown *) wParam );
        if ( pItem )
            m_treeCtrl.DeleteItem( pItem );
    }

    // Basic clean up
    if ( lParam )
        SysFreeString( (BSTR) lParam );

    if ( wParam )
    {
        DWORD dwCount;
        dwCount = ((IUnknown *) wParam)->Release();
        TRACE(_T("ParticipantRemove() RefCount = %p @ %ld.\n"), wParam, dwCount );
    }

    return 0;
}

LRESULT CMainExplorerWndDirectories::OnUpdateConfParticipant_Modify(WPARAM wParam, LPARAM lParam )
{
    USES_CONVERSION;
    // Conference participant information has been modified
    if ( m_pConfRoomTreeItem )
    {
        CExplorerTreeItem *pItem = m_treeCtrl.GetChildItemWithIUnknown( m_pConfRoomTreeItem->GetTreeItemHandle(), (IUnknown *) wParam );
        if ( pItem )
        {
            if ( wParam )
            {
                // Add either the participant or Me
                VARIANT_BOOL bStreaming = FALSE;
                ((IParticipant *) wParam)->get_bStreamingVideo( &bStreaming );

                pItem->SetImage( (bStreaming) ? TIM_DIRECTORY_CONFROOM_PERSON : TIM_DIRECTORY_CONFROOM_PERSON_NOVIDEO );
                pItem->SetText( (lParam) ? OLE2CT((BSTR) lParam) : _T("") );
            }
            else
            {
                OnUpdateConfMeItem( pItem );
            }

            // Update tree list
            RedrawTreeItem( pItem );
//            m_treeCtrl.SortChildren( m_pConfRoomTreeItem->GetTreeItemHandle() );
        }
    }

    // Basic clean up
    if ( lParam )
        SysFreeString( (BSTR) lParam );

    if ( wParam )
    {
        DWORD dwCount;
        dwCount = ((IUnknown *) wParam)->Release();
        TRACE(_T("ParticipantModify() RefCount = %p @ %ld.\n"), wParam, dwCount );
    }

    return 0;
}

LRESULT CMainExplorerWndDirectories::OnDeleteAllConfParticipants(WPARAM wParam, LPARAM lParam )
{
    if ( m_pConfRoomTreeItem )
    {
        m_treeCtrl.SelectItem( m_pConfRoomTreeItem->GetTreeItemHandle() );
        m_treeCtrl.DeleteAllChildren( m_pConfRoomTreeItem->GetTreeItemHandle() );
    }

    return 0;
}

LRESULT CMainExplorerWndDirectories::OnSelectConfParticipant(WPARAM wParam, LPARAM lParam )
{
    TRACE(_T("ParticipantSelect().\n"));
    if ( m_pConfRoomTreeItem )
    {
        CExplorerTreeItem *pItem = m_treeCtrl.GetChildItemWithIUnknown( m_pConfRoomTreeItem->GetTreeItemHandle(), (IUnknown *) wParam );
        if ( pItem )
            m_treeCtrl.SelectItem( pItem->GetTreeItemHandle() );
    }

    // Clean up
    if ( wParam )
        ((IUnknown *) wParam)->Release();

    return 0;
}

void CMainExplorerWndDirectories::RedrawTreeItem( CExplorerTreeItem *pItem )
{
    // Re-draw item
    RECT rect, rectClient;
    m_treeCtrl.GetItemRect( pItem->GetTreeItemHandle(), &rect, FALSE );
    m_treeCtrl.GetClientRect( &rectClient );
    rect.right = rectClient.right;
    m_treeCtrl.InvalidateRect( &rect );
}

void CMainExplorerWndDirectories::OnSize(UINT nType, int cx, int cy) 
{
    CMainExplorerWndBase::OnSize(nType, cx, cy);

    if ( m_treeCtrl.GetSafeHwnd() )
    {
        //set size of tree control to full parent window rect
        CRect rect;
        GetClientRect(rect);
        m_treeCtrl.SetWindowPos(NULL,rect.left,rect.top,rect.Width(),rect.Height(),SWP_NOOWNERZORDER|SWP_SHOWWINDOW);
    }
}

void CMainExplorerWndDirectories::OnConfgroupFullsizevideo() 
{
    //
    // We have to verify AfxGetMainWnd() returned value
    //

    CWnd* pMainWnd = AfxGetMainWnd();

    if( pMainWnd)
    {
        ((CMainFrame *) pMainWnd)->OnConfgroupFullsizevideo();
    }
}

void CMainExplorerWndDirectories::OnConfgroupShownames() 
{
    //
    // We have to verify AfxGetMainWnd() returned value
    //

    CWnd* pMainWnd = AfxGetMainWnd();

    if( pMainWnd )
    {
        ((CMainFrame *) pMainWnd)->OnConfgroupShownames();
    }
}


void CMainExplorerWndDirectories::OnButtonRoomDisconnect() 
{
    //
    // We have to verify AfxGetMainWnd() returned value
    //

    CWnd* pMainWnd = AfxGetMainWnd();

    if( pMainWnd )
    {
        ((CMainFrame *) pMainWnd)->OnButtonRoomDisconnect();
    }
}

int CMainExplorerWndDirectories::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
    if (CMainExplorerWndBase::OnCreate(lpCreateStruct) == -1)
        return -1;

    UpdateData( false );
    
    //Create tree control and make full window size
    m_treeCtrl.Create(    WS_VISIBLE | WS_CHILD,
                        CRect(0,0,0,0), this, IDC_DIRECTORIES_TREECTRL_MAIN );

    m_lstPerson.Create(WS_CHILD|WS_VISIBLE|LVS_ICON|LVS_AUTOARRANGE|LVS_ALIGNTOP|LVS_SINGLESEL,CRect(0,0,0,0),m_pParentWnd,IDC_DIRECTORIES_VIEWCTRL_PERSONDETAILS);

    m_lstPersonGroup.Create(WS_CHILD|WS_VISIBLE,CRect(0,0,0,0),m_pParentWnd,1);
    m_lstPersonGroup.Init(this, CPersonGroupListCtrl::STYLE_ILS);

    m_lstSpeedDial.Create(WS_CHILD|WS_VISIBLE,CRect(0,0,0,0),m_pParentWnd,2);
    m_lstSpeedDial.Init(this);

    m_wndEmpty.Create(NULL,NULL,WS_VISIBLE|WS_CHILD,CRect(0,0,0,0),m_pParentWnd,IDC_DIRECTORIES_VIEWCTRL_EMTPY);
    m_pDisplayWindow = &m_wndEmpty;

    // Include the overlay images
    m_treeCtrl.Init(IDB_TREE_DIRECTORIES, TIM_MAX, 3);

    // Add the root item
    CString sLabel;
    sLabel.LoadString(IDS_DIRECTORIES_ROOT);
    m_pRootItem = m_treeCtrl.AddObject(sLabel,NULL,TOBJ_DIRECTORY_ROOT,TIM_DIRECTORY_ROOT);

    AddILS();
    AddDS();
    AddSpeedDial();
    AddConfRoom();

    if ( m_pRootItem && (m_nPersistInfo & SPEEDDIAL_OPEN) )
    m_treeCtrl.ExpandItem( m_pRootItem, TVE_EXPAND );

    m_treeCtrl.SelectTopItem();
    m_pParentWnd->SetDetailWindow(&m_wndEmpty);
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\ds.cpp ===
////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// ds.cpp : implementation of the CDSUser class
//
#include "stdafx.h"
#include "AVDialer.h"
#include "ds.h"
#include "mainfrm.h"
#include "avDialerDoc.h"
#include "SpeedDlgs.h"
#include "AboutDlg.h"
#include "avtrace.h"

IMPLEMENT_DYNCREATE(CDSUser, CObject)

/////////////////////////////////////////////////////////////////////////////////////////
//Dial using preferred device
void CDSUser::Dial(CActiveDialerDoc* pDoc)
{
   IAVTapi* pTapi = pDoc->GetTapi();
   if (pTapi)
   {
      CString sAddress = (!m_sIPAddress.IsEmpty())?m_sIPAddress:m_sPhoneNumber;
      DialerMediaType dmtType = DIALER_MEDIATYPE_UNKNOWN;
      DWORD dwAddressType = LINEADDRESSTYPE_IPADDRESS;
      if (SUCCEEDED(pTapi->get_dwPreferredMedia(&dwAddressType)))
      {
         switch (dwAddressType)
         {
            case LINEADDRESSTYPE_PHONENUMBER:
            {
               sAddress = m_sPhoneNumber;
               dmtType = DIALER_MEDIATYPE_POTS;
               break;
            }
            default:
            {
               if (!m_sIPAddress.IsEmpty())
               {
                  sAddress = m_sIPAddress;
                  dmtType = DIALER_MEDIATYPE_INTERNET;
                  dwAddressType = LINEADDRESSTYPE_IPADDRESS;
               }
               else if (!m_sPhoneNumber.IsEmpty())
               {
                  sAddress = m_sPhoneNumber;
                  dmtType = DIALER_MEDIATYPE_POTS;
                  dwAddressType = LINEADDRESSTYPE_PHONENUMBER;
               }
               break;
            }
         }
      }
      pDoc->Dial(m_sUserName,sAddress,dwAddressType,dmtType, false);
      pTapi->Release();
   }
}

/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
// Class CWABEntry
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////
CWABEntry::CWABEntry()
{
   m_cbEntryID= 0;
   m_pEntryID= NULL;
}

/////////////////////////////////////////////////////////////////////////////////////////
CWABEntry::CWABEntry(UINT cbEntryID, ENTRYID* pEntryID)
{
   m_cbEntryID= cbEntryID; 
   m_pEntryID= new BYTE[m_cbEntryID];

   memcpy(m_pEntryID, pEntryID, m_cbEntryID);
}

/////////////////////////////////////////////////////////////////////////////////////////
CWABEntry::~CWABEntry()
{
   if (m_pEntryID != NULL)
   {
      delete m_pEntryID;
   }
}

/////////////////////////////////////////////////////////////////////////////////////////
const CWABEntry& CWABEntry::operator=(const CWABEntry* pEntry)
{
   if (m_pEntryID != NULL)
   {
      delete m_pEntryID;
   }

   m_cbEntryID= pEntry->m_cbEntryID;
   m_pEntryID= new BYTE[m_cbEntryID];

   memcpy(m_pEntryID, pEntry->m_pEntryID, m_cbEntryID);

   return *this;
}

/////////////////////////////////////////////////////////////////////////////////////////
bool CWABEntry::operator==(const CWABEntry* pEntry) const
{
   return ((m_cbEntryID == pEntry->m_cbEntryID) && 
      (memcmp(m_pEntryID, pEntry->m_pEntryID, m_cbEntryID) == 0));
}

/////////////////////////////////////////////////////////////////////////////
BOOL CWABEntry::CreateCall(CActiveDialerDoc* pDoc,CDirectory* pDir,UINT attrib,long lAddressType,DialerMediaType nType)
{
   CString sAddress,sName;
   pDir->WABGetStringProperty(this, attrib, sAddress);
   pDir->WABGetStringProperty(this, PR_DISPLAY_NAME, sName);
   pDoc->Dial( sName, sAddress, lAddressType, nType, true );
   return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////////////
//Dial using preferred device
void CWABEntry::Dial(CActiveDialerDoc* pDoc,CDirectory* pDir)
{
   IAVTapi* pTapi = pDoc->GetTapi();
   if (pTapi)
   {
      DWORD dwAddressType = LINEADDRESSTYPE_IPADDRESS;
      pTapi->get_dwPreferredMedia(&dwAddressType);
      switch (dwAddressType)
      {
         case LINEADDRESSTYPE_PHONENUMBER:
         {
            CreateCall(pDoc,
                       pDir,
                       PR_BUSINESS_TELEPHONE_NUMBER,
                       LINEADDRESSTYPE_PHONENUMBER,
                       DIALER_MEDIATYPE_POTS);
            break;
         }
         default:
         {
            CreateCall(pDoc,
                       pDir,
                       PR_EMAIL_ADDRESS,
                       LINEADDRESSTYPE_EMAILNAME,
                       DIALER_MEDIATYPE_INTERNET);
            break;
         }
      }
      pTapi->Release();
   }
}

/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
// Class CILSUser
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DYNCREATE(CILSUser, CObject)

/////////////////////////////////////////////////////////////////////////////////////////
const CILSUser& CILSUser::operator=(const CILSUser* pUser)
{
   m_sUserName= pUser->m_sUserName;
   m_sIPAddress= pUser->m_sIPAddress;
   m_sComputer = pUser->m_sComputer;

   return *this;
}

/////////////////////////////////////////////////////////////////////////////////////////
//Dial using preferred device
void CILSUser::Dial(CActiveDialerDoc* pDoc)
{
    // Get a valid document to start things off!
    if ( !pDoc )
    {
        CMainFrame *pFrame = (CMainFrame *) AfxGetMainWnd();
        if ( pFrame && pFrame->GetActiveView() )
            pDoc = (CActiveDialerDoc *) pFrame->GetActiveView()->GetDocument();
    }
    if ( !pDoc ) return;

    IAVTapi* pTapi = pDoc->GetTapi();
    if (pTapi)
    {
        DialerMediaType dmtType = DIALER_MEDIATYPE_INTERNET;
        DWORD dwAddressType = LINEADDRESSTYPE_IPADDRESS;
        pDoc->Dial( m_sUserName, m_sIPAddress, dwAddressType, dmtType, false );

        pTapi->Release();
    }
}

void CILSUser::GetCallerInfo( CString &strInfo )
{
    // Format to name/address
    strInfo = m_sUserName;

    if ( !strInfo.IsEmpty() ) strInfo += _T("\n");
    if ( !m_sComputer.IsEmpty() )
        strInfo += m_sComputer;
    else
        strInfo += m_sIPAddress;
}

void CILSUser::DesktopPage(CActiveDialerDoc *pDoc )
{
    CPageDlg dlg;
    GetCallerInfo( dlg.m_strTo );

    if ( dlg.DoModal() == IDOK )
    {
        MyUserUserInfo info;
        info.lSchema = MAGIC_NUMBER_USERUSER;
        wcsncpy( info.szWelcome, dlg.m_strWelcome, ARRAYSIZE(info.szWelcome) );
        wcsncpy( info.szUrl, dlg.m_strUrl, ARRAYSIZE(info.szUrl) );

        CCallEntry callEntry;
        callEntry.m_sAddress = (m_sComputer.IsEmpty()) ? m_sIPAddress : m_sComputer;
        pDoc->CreateDataCall( &callEntry, (BYTE *) &info, sizeof(info) );
    }
}


bool CILSUser::AddSpeedDial()
{
    //
    // We should intialize local variable
    //
    bool bRet = false;

    //Get data from selected item and object
    CSpeedDialAddDlg dlg;

    // Setup dialog data
    dlg.m_CallEntry.m_MediaType = DIALER_MEDIATYPE_INTERNET;
    dlg.m_CallEntry.m_sDisplayName = m_sUserName;
    dlg.m_CallEntry.m_lAddressType = LINEADDRESSTYPE_IPADDRESS;
    dlg.m_CallEntry.m_sAddress = m_sComputer.IsEmpty() ? m_sIPAddress : m_sComputer;

    // Show the dialog and add if user says is okay
    if ( dlg.DoModal() == IDOK )
        bRet = (bool) (CDialerRegistry::AddCallEntry(FALSE, dlg.m_CallEntry) == TRUE);

    return bRet;
}



/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
// Class CLDAPUser
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
IMPLEMENT_SERIAL(CLDAPUser, CObject, 1)

CLDAPUser::CLDAPUser()
{
    m_lRef = 0;
}

CLDAPUser::~CLDAPUser()
{
    ASSERT( m_lRef == 0 );
}

void CLDAPUser::FinalRelease()
{
    AVTRACE(_T("CLDAPUser::FinalRelease() %s."), m_sUserName );
    delete this;
}

long CLDAPUser::AddRef()
{
    return InterlockedIncrement( &m_lRef );
}

long CLDAPUser::Release()
{
    long lRef = InterlockedDecrement( &m_lRef );
    ASSERT( lRef >= 0 );
    if ( lRef == 0 )
        FinalRelease();

    return lRef;
}

/////////////////////////////////////////////////////////////////////////////////////////
//Dial using preferred device
void CLDAPUser::Dial(CActiveDialerDoc* pDoc)
{
   IAVTapi* pTapi = pDoc->GetTapi();
   if (pTapi)
   {
      DialerMediaType dmtType = DIALER_MEDIATYPE_INTERNET;
      DWORD dwAddressType = LINEADDRESSTYPE_IPADDRESS;
      pDoc->Dial(m_sUserName, m_sIPAddress,dwAddressType,dmtType, false);

      pTapi->Release();
   }
}

/////////////////////////////////////////////////////////////////////////////
void CLDAPUser::Serialize(CArchive& ar)
{
   CObject::Serialize(ar);    //Always call base class Serialize
   //Serialize members
   if (ar.IsStoring())
   {
      ar << m_sServer;
      ar << m_sDN;
      ar << m_sUserName;
   }
   else
   {
      ar >> m_sServer;     
      ar >> m_sDN;
      ar >> m_sUserName;
   }
}  

bool CLDAPUser::AddSpeedDial()
{
    //
    // We should intialize local variable
    //
    bool bRet = false;

    DialerMediaType dmtType = DIALER_MEDIATYPE_UNKNOWN;
    DWORD dwAddressType = 0;
    CString sAddress;

    // Retrieve the media type that's preferred by the user...
    IAVTapi *pTapi;
    if ( SUCCEEDED(get_Tapi(&pTapi)) )
    {
        DWORD dwType;
        pTapi->get_dwPreferredMedia( &dwType );
        switch ( dwType )
        {
            case LINEADDRESSTYPE_IPADDRESS:        dmtType = DIALER_MEDIATYPE_INTERNET;
            case LINEADDRESSTYPE_PHONENUMBER:    dmtType = DIALER_MEDIATYPE_POTS;
        }
        pTapi->Release();
    }

    // Find a number for the appropriate media type...
    DialerMediaType dmtNext = dmtType;
    for ( int i = 0; (i < 2) && sAddress.IsEmpty(); i++ )
    {
        dmtType = dmtNext;
        switch ( dmtNext )
        {
            case DIALER_MEDIATYPE_POTS:
                sAddress = m_sPhoneNumber;
                dwAddressType = LINEADDRESSTYPE_PHONENUMBER;
                dmtNext = DIALER_MEDIATYPE_INTERNET;
                break;

            case DIALER_MEDIATYPE_INTERNET:
                sAddress = m_sIPAddress;
                dwAddressType = LINEADDRESSTYPE_DOMAINNAME;
                dmtNext = DIALER_MEDIATYPE_POTS;
                break;
        }
    }

    // Did we get a valid media type?
    if ( !sAddress.IsEmpty() )    dmtType = dmtNext;

    //
    // If the address type should be corelate with
    // DialerMEdiaType
    //

    switch( dwAddressType )
    {
    case LINEADDRESSTYPE_PHONENUMBER:
        dmtType = DIALER_MEDIATYPE_POTS;
        break;
    case LINEADDRESSTYPE_DOMAINNAME:
        dmtType = DIALER_MEDIATYPE_INTERNET;
        break;
    }

    //Get data from selected item and object
    if ( !m_sUserName.IsEmpty() && !sAddress.IsEmpty() )
    {
        CSpeedDialAddDlg dlg;

        // Setup dialog data
        dlg.m_CallEntry.m_MediaType = dmtType;
        dlg.m_CallEntry.m_sDisplayName = m_sUserName;
        dlg.m_CallEntry.m_lAddressType = dwAddressType;
        dlg.m_CallEntry.m_sAddress = sAddress;

        // Show the dialog and add if user says is okay
        if ( dlg.DoModal() == IDOK )
            bRet = (bool) (CDialerRegistry::AddCallEntry(FALSE, dlg.m_CallEntry) == TRUE);
    }

    return bRet;
}

void CLDAPUser::ExternalReleaseProc( void *pThis )
{
    CLDAPUser *pUser = (CLDAPUser *) pThis;
    ASSERT( pUser && pUser->IsKindOf(RUNTIME_CLASS(CLDAPUser)) );

    pUser->Release();
}


/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\fnduserdlg.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////
// FndUserDlg.cpp : implementation file
/////////////////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "avdialer.h"
#include "FndUserDlg.h"
#include "dirasynch.h"
#include "MainFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CDirectoriesFindUser dialog
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
CDirectoriesFindUser::CDirectoriesFindUser(CWnd* pParent /*=NULL*/)
	: CDialog(CDirectoriesFindUser::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDirectoriesFindUser)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
   m_pSelectedUser = NULL;
   m_lCallbackCount = 0;
   m_bCanClearLBSelection = true;
}

CDirectoriesFindUser::~CDirectoriesFindUser()
{
	ASSERT( m_lCallbackCount == 0 );
	RELEASE( m_pSelectedUser );
}

////////////////////////////////////////////////////////////////////////////
void CDirectoriesFindUser::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDirectoriesFindUser)
	DDX_Control(pDX, IDC_DIRECTORIES_FIND_USER_BUTTON_SEARCH, m_buttonSearch);
	DDX_Control(pDX, IDOK, m_buttonAdd);
	DDX_Control(pDX, IDC_DIRECTORIES_FIND_USER_LB_USERS, m_lbUsers);
	DDX_Control(pDX, IDC_DIRECTORIES_FIND_USER_EDIT_USER, m_editUser);
	//}}AFX_DATA_MAP
}

/////////////////////////////////////////////////////////////////////////////
BEGIN_MESSAGE_MAP(CDirectoriesFindUser, CDialog)
	//{{AFX_MSG_MAP(CDirectoriesFindUser)
	ON_BN_CLICKED(IDC_DIRECTORIES_FIND_USER_BUTTON_SEARCH, OnDirectoriesFindUserButtonSearch)
	ON_LBN_SELCHANGE(IDC_DIRECTORIES_FIND_USER_LB_USERS, OnSelchangeDirectoriesFindUserLbUsers)
	ON_WM_HELPINFO()
	ON_WM_CONTEXTMENU()
	ON_EN_CHANGE(IDC_DIRECTORIES_FIND_USER_EDIT_USER, OnChangeDirectoriesFindUserEditUser)
	ON_BN_CLICKED(IDC_DEFAULT, OnDefault)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
BOOL CDirectoriesFindUser::OnInitDialog() 
{
	CDialog::OnInitDialog();

   CenterWindow(GetDesktopWindow());
	
   //disable button until user is found
   m_buttonAdd.EnableWindow(FALSE);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////////////
void CDirectoriesFindUser::OnOK() 
{
	int nIndex = m_lbUsers.GetCurSel();
	if ( nIndex >= 0 )
	{
		CLDAPUser* pUser = (CLDAPUser *) m_lbUsers.GetItemDataPtr( nIndex );
		if (pUser)
		{
			pUser->AddRef();

			RELEASE( m_pSelectedUser );
			m_pSelectedUser = pUser;
		}

		ClearListBox();
		CDialog::OnOK();
	}
	else
	{
		OnCancel();
	}
}

/////////////////////////////////////////////////////////////////////////////
void CDirectoriesFindUser::OnCancel() 
{
	ClearListBox();
	CDialog::OnCancel();
}

/////////////////////////////////////////////////////////////////////////////
void CDirectoriesFindUser::OnDirectoriesFindUserButtonSearch() 
{
	m_buttonAdd.EnableWindow(FALSE);
	ClearListBox();

	//delete previous
	RELEASE( m_pSelectedUser );

	//searching...
	bool bSearching = false;
	CString sOut;
	sOut.LoadString(IDS_DIRECTORIES_FINDUSER_DLG_SEARCHING);
	m_lbUsers.AddString(sOut);

	CString sName,sSearch;
	m_editUser.GetWindowText(sName);

	if (sName == "*") sName = _T("");            //everyone case
	sSearch.Format(_T("(&(ObjectClass=user)(sAMAccountName=%s*)(!ObjectClass=computer))"),sName);

	// Make a request
	if ( AfxGetMainWnd() )
	{
		CActiveDialerDoc *pDoc = ((CMainFrame *) AfxGetMainWnd())->GetDocument();
		if ( pDoc )
		{
			if ( pDoc->m_dir.LDAPListNames(_T(""), sSearch, ListNamesCallBackEntry, this) )
			{
				EnableWindow( FALSE );

				::InterlockedIncrement( &m_lCallbackCount );

				if ( GetDlgItem(IDCANCEL) ) GetDlgItem(IDCANCEL)->EnableWindow( FALSE );
				m_buttonSearch.EnableWindow( FALSE );
				bSearching = true;
			}
		}
	}

	// Search failed for one reason or another
	if ( !bSearching )
	{
		m_buttonAdd.EnableWindow(FALSE);
		ClearListBox();

		CString sOut;
		sOut.LoadString(IDS_DIRECTORIES_FINDUSER_DLG_ERRORSEARCHINGDS);
		m_lbUsers.AddString(sOut);
	}
}

/////////////////////////////////////////////////////////////////////////////
//static entry
void CALLBACK CDirectoriesFindUser::ListNamesCallBackEntry(DirectoryErr err, void* pContext, LPCTSTR szServer, LPCTSTR szSearch, CObList& LDAPUserList)
{
	ASSERT(pContext);
	if ( !pContext ) return;

	((CDirectoriesFindUser*) pContext)->ListNamesCallBack(err,szServer,szSearch,LDAPUserList);
}

/////////////////////////////////////////////////////////////////////////////
void CDirectoriesFindUser::ListNamesCallBack(DirectoryErr err,LPCTSTR szServer, LPCTSTR szSearch, CObList& LDAPUserList)
{
	if ( ::InterlockedDecrement(&m_lCallbackCount) == 0 )
	{
		EnableWindow( TRUE );

		if ( GetDlgItem(IDCANCEL) ) GetDlgItem(IDCANCEL)->EnableWindow( TRUE );
		m_buttonSearch.EnableWindow( TRUE );
	}

	ClearListBox();

	if (err != DIRERR_SUCCESS)
	{
		if (err == DIRERR_QUERYTOLARGE)
		{
			//query too large
			CString sOut;
			sOut.LoadString(IDS_DIRECTORIES_FINDUSER_DLG_QUERYTOLARGE);
			m_lbUsers.AddString(sOut);
		}
		else if (err == DIRERR_NOTFOUND)
		{
			//no matches found
			CString sOut;
			sOut.LoadString(IDS_DIRECTORIES_FINDUSER_DLG_NOMATCHES);
			m_lbUsers.AddString(sOut);
		}
		else
		{
			//error searching ds
			CString sOut;
			sOut.LoadString(IDS_DIRECTORIES_FINDUSER_DLG_ERRORSEARCHINGDS);
			m_lbUsers.AddString(sOut);
		}
		return;
	}

	POSITION pos = LDAPUserList.GetHeadPosition();
	if (pos == NULL)
	{
		//no matches found
		CString sOut;
		sOut.LoadString(IDS_DIRECTORIES_FINDUSER_DLG_NOMATCHES);
		m_lbUsers.AddString(sOut);
		return;
	}

	while (pos)
	{
		//must delete this LDAP user object when done (listbox will do it)
		CLDAPUser *pUser = (CLDAPUser * ) LDAPUserList.GetNext( pos );
		if (!pUser->m_sDN.IsEmpty())
		{
			int nIndex = m_lbUsers.AddString(pUser->m_sUserName);
			if ( nIndex != LB_ERR )
			{
				m_lbUsers.SetItemDataPtr(nIndex,pUser);
				pUser->AddRef();
			}
		}
	}

	//set selection to the first
	m_lbUsers.SetSel(0);
	OnSelchangeDirectoriesFindUserLbUsers();
}

/////////////////////////////////////////////////////////////////////////////
void CDirectoriesFindUser::OnSelchangeDirectoriesFindUserLbUsers() 
{
	int nIndex = m_lbUsers.GetCurSel();
	if (nIndex != LB_ERR)
	{
		CLDAPUser* pUser = (CLDAPUser*)m_lbUsers.GetItemDataPtr(nIndex);
		if (pUser)
		{
			CString sName;
			m_bCanClearLBSelection = false;
			m_lbUsers.GetText(nIndex,sName);
			m_editUser.SetWindowText(sName);
			m_bCanClearLBSelection = true;

			//delete previous
			RELEASE( m_pSelectedUser );

			pUser->AddRef();
			m_pSelectedUser = pUser;

			m_buttonAdd.EnableWindow(TRUE);
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
void CDirectoriesFindUser::ClearListBox()
{
	while (m_lbUsers.GetCount() > 0)
	{
		//get top item and delete it
		CLDAPUser* pUser = (CLDAPUser*)m_lbUsers.GetItemDataPtr(0);
		m_lbUsers.DeleteString(0);

		if ( pUser )
			pUser->Release();
	}
	m_lbUsers.ResetContent();
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


BOOL CDirectoriesFindUser::OnHelpInfo(HELPINFO* pHelpInfo) 
{
	if (pHelpInfo->iContextType == HELPINFO_WINDOW)
	{
		AfxGetApp()->WinHelp( HandleToUlong(pHelpInfo->hItemHandle), HELP_WM_HELP );
		return TRUE;
	}
	return FALSE;
}

void CDirectoriesFindUser::OnContextMenu(CWnd* pWnd, CPoint point) 
{
	AfxGetApp()->WinHelp( HandleToUlong(pWnd->GetSafeHwnd()), HELP_CONTEXTMENU );
}

void CDirectoriesFindUser::OnChangeDirectoriesFindUserEditUser() 
{
	if ( m_bCanClearLBSelection )
		m_lbUsers.SetCurSel( -1 );
}

void CDirectoriesFindUser::OnDefault() 
{
	if ( m_lbUsers.GetCurSel() >= 0 )
		OnOK();
	else
		OnDirectoriesFindUserButtonSearch();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\fnduserdlg.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////
// FndUserDlg.h : header file
/////////////////////////////////////////////////////////////////////////////
#if !defined(AFX_FNDUSERDLG_H__73D2E77D_0C8A_11D2_AA26_0800170982BA__INCLUDED_)
#define AFX_FNDUSERDLG_H__73D2E77D_0C8A_11D2_AA26_0800170982BA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CDirectoriesFindUser dialog
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#include "dirasynch.h"

class CLDAPUser;

class CDirectoriesFindUser : public CDialog
{
// Construction
public:
	CDirectoriesFindUser(CWnd* pParent = NULL);   // standard constructor
   ~CDirectoriesFindUser();

// Dialog Data
	//{{AFX_DATA(CDirectoriesFindUser)
	enum { IDD = IDD_DIRECTORIES_FIND_USER };
	CButton	m_buttonSearch;
	CButton	m_buttonAdd;
	CListBox	m_lbUsers;
	CEdit	m_editUser;
	//}}AFX_DATA

//Attributes
   CLDAPUser*		m_pSelectedUser;           //callers responsibility to delete this object when done
   long				m_lCallbackCount;
   bool				m_bCanClearLBSelection;

//Methods
public:
   static void CALLBACK    ListNamesCallBackEntry(DirectoryErr err, void* pContext, LPCTSTR szServer, LPCTSTR szSearch, CObList& LDAPUserList);
   void                    ListNamesCallBack(DirectoryErr err,LPCTSTR szServer, LPCTSTR szSearch, CObList& LDAPUserList);
protected:
   void           ClearListBox();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDirectoriesFindUser)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDirectoriesFindUser)
	afx_msg void OnDirectoriesFindUserButtonSearch();
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	virtual void OnCancel();
	afx_msg void OnSelchangeDirectoriesFindUserLbUsers();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnChangeDirectoriesFindUserEditUser();
	afx_msg void OnDefault();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
#endif // !defined(AFX_FNDUSERDLG_H__73D2E77D_0C8A_11D2_AA26_0800170982BA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\mainexpwnd.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// MainExplorerWndBase.cpp : implementation file
//

#include "stdafx.h"
#include "avdialer.h"
#include "avDialerDoc.h"
#include "MainExpWnd.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CMainExplorerWndBase
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

CMainExplorerWndBase::CMainExplorerWndBase()
{
   m_pParentWnd = NULL;
}

CMainExplorerWndBase::~CMainExplorerWndBase()
{
}


BEGIN_MESSAGE_MAP(CMainExplorerWndBase, CWnd)
	//{{AFX_MSG_MAP(CMainExplorerWndBase)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndBase::Init(CActiveDialerView* pParentWnd)
{
   m_pParentWnd = pParentWnd;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\helpmap.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////
// helpmap.cpp : implementation file
/////////////////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "dialer.h"
#include "resource.h"

DWORD_PTR aDialerHelpIds[] = 
{
   IDC_DRIVER_MISSING_STATIC_LIST,IDH_DRIVER_MISSING_STATIC_LIST,
   IDC_OPTIONS_VIDEO_COMBO_DEVICE,IDH_OPTIONS_VIDEO_COMBO_DEVICE,
   IDC_OPTIONS_VIDEO_BUTTON_SOURCE,IDH_OPTIONS_VIDEO_BUTTON_SOURCE,
   IDC_OPTIONS_VIDEO_BUTTON_DISPLAY,IDH_OPTIONS_VIDEO_BUTTON_DISPLAY,
   IDC_OPTIONS_VIDEO_BUTTON_FORMAT,IDH_OPTIONS_VIDEO_BUTTON_FORMAT,
   IDC_OPTIONS_VIDEO_STATIC_VIDEOFRAME,IDH_OPTIONS_VIDEO_STATIC_VIDEOFRAME,
   IDC_OPTIONS_VIDEO_STATIC_ICON1,((DWORD)-1),
   IDC_OPTIONS_VIDEO_STATIC_STATIC1,((DWORD)-1),
   IDC_OPTIONS_VIDEO_CHECK_AUTOPREVIEW,IDH_OPTIONS_VIDEO_CHECK_AUTOPREVIEW,
   IDC_SPEEDDIAL_MORE_LIST_ADDRESSES,IDH_SPEEDDIAL_MORE_LIST_ADDRESSES,
   IDC_SPEEDDIAL_MORE_BUTTON_PLACECALL,IDH_SPEEDDIAL_MORE_BUTTON_PLACECALL,
   IDC_SPEEDDIAL_MORE_BUTTON_EDITLIST,IDH_SPEEDDIAL_MORE_BUTTON_EDITLIST,
   IDC_SPEEDDIAL_MORE_STATIC_ICON1,((DWORD)-1),
   IDC_SPEEDDIAL_MORE_STATIC_TEXT1,((DWORD)-1),
   IDC_SPEEDDIAL_EDIT_BUTTON_MOVEUP,IDH_SPEEDDIAL_EDIT_BUTTON_MOVEUP,
   IDC_SPEEDDIAL_EDIT_BUTTON_MOVEDOWN,IDH_SPEEDDIAL_EDIT_BUTTON_MOVEDOWN,
   IDC_SPEEDDIAL_EDIT_BUTTON_REMOVE,IDH_SPEEDDIAL_EDIT_BUTTON_REMOVE,
   IDC_SPEEDDIAL_EDIT_LIST_ENTRIES,IDH_SPEEDDIAL_EDIT_LIST_ENTRIES,
   IDC_SPEEDDIAL_EDIT_BUTTON_EDIT,IDH_SPEEDDIAL_EDIT_BUTTON_EDIT,
   IDC_SPEEDDIAL_EDIT_BUTTON_ADD,IDH_SPEEDDIAL_EDIT_BUTTON_ADD,
   IDC_SPEEDDIAL_EDIT_STATIC_ENTRIES,IDH_SPEEDDIAL_EDIT_LIST_ENTRIES,
   IDC_SPEEDDIAL_ADD_RADIO_NETCALL,IDH_SPEEDDIAL_ADD_RADIO_NETCALL,
   IDC_SPEEDDIAL_ADD_RADIO_PHONECALL,IDH_SPEEDDIAL_ADD_RADIO_PHONECALL,
   IDC_SPEEDDIAL_ADD_RADIO_MULTICASTCONFERENCE,IDH_SPEEDDIAL_ADD_RADIO_MULTICASTCONFERENCE,
   IDC_SPEEDDIAL_ADD_EDIT_DISPLAYNAME,IDH_SPEEDDIAL_ADD_EDIT_DISPLAYNAME,
   IDC_SPEEDDIAL_ADD_EDIT_ADDRESS,IDH_SPEEDDIAL_ADD_EDIT_ADDRESS,
   IDC_SPEEDDIAL_ADD_STATIC_DISPLAYNAME,IDH_SPEEDDIAL_ADD_EDIT_DISPLAYNAME,
   IDC_SPEEDDIAL_ADD_STATIC_ADDRESS,IDH_SPEEDDIAL_ADD_EDIT_ADDRESS,
   IDC_SPEEDDIAL_ADD_STATIC_ICON1,((DWORD)-1),
   IDC_SPEEDDIAL_ADD_STATIC_TEXT1,((DWORD)-1),
   IDC_SELECTADDRESS_BUTTON_PLACECALL,IDH_SELECTADDRESS_BUTTON_PLACECALL,
   IDC_SELECTADDRESS_BUTTON_BROWSE,IDH_SELECTADDRESS_BUTTON_BROWSE,
   IDC_SELECTADDRESS_LISTBOX_NAMES,IDH_SELECTADDRESS_LISTBOX_NAMES,
   IDC_SELECTADDRESS_LISTCTRL_ADDRESSES,IDH_SELECTADDRESS_LISTCTRL_ADDRESSES,
   IDC_SELECTADDRESS_STATIC_NAMES,IDH_SELECTADDRESS_STATIC_NAMES,
   IDC_SELECTADDRESS_STATIC_ADDRESSES,IDH_SELECTADDRESS_STATIC_ADDRESSES,
   IDC_SELECTADDRESS_STATIC_ICON1,((DWORD)-1),
   IDC_SELECTADDRESS_STATIC_TEXT1,((DWORD)-1),
   IDD_OPTIONS_VIDEO, ((DWORD) -1),
   IDC_DIRECTORIES_FIND_USER_EDIT_USER, IDH_DIRECTORIES_FIND_USER_EDIT_USER,
   IDC_DIRECTORIES_FIND_USER_BUTTON_SEARCH, IDH_DIRECTORIES_FIND_USER_BUTTON_SEARCH,
   IDC_DIRECTORIES_FIND_USER_LB_USERS, IDH_DIRECTORIES_FIND_USER_LB_USERS,
   0,0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\mainexpwnd.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// MainExplorerWndBase.h : header file
/////////////////////////////////////////////////////////////////////////////
#if !defined(AFX_MAINEXPLORERWNDBASE_H__6CED3920_41BF_11D1_B6E5_0800170982BA__INCLUDED_)
#define AFX_MAINEXPLORERWNDBASE_H__6CED3920_41BF_11D1_B6E5_0800170982BA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CMainExplorerWndBase window
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class CMainExplorerWndBase : public CWnd
{
// Construction
public:
	CMainExplorerWndBase();

// Attributes
public:
protected:
   CActiveDialerView*   m_pParentWnd;

// Operations
public:
   virtual void         Init(CActiveDialerView* pParentWnd);
   virtual void         PostTapiInit() {};
   
   virtual void         Refresh()                                    {};

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainExplorerWndBase)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainExplorerWndBase();

	// Generated message map functions
protected:
	//{{AFX_MSG(CMainExplorerWndBase)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINEXPLORERWNDBASE_H__6CED3920_41BF_11D1_B6E5_0800170982BA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\ilslist.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// ILSPersonListCtrl.cpp : implemStockation file
//

#include "stdafx.h"
#include "AVDialer.h"
#include "MainFrm.h"
#include "ILSList.h"
#include "SpeedDlgs.h"
#include "directory.h"
#include "ds.h"
#include "DialReg.h"
#include "resource.h"
#include "mapi.h"
#include "avtrace.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

void SendMailToAddress( CString& strUserName, CString& strUserAddr );
DWORD WINAPI ThreadSendMail( LPVOID lpVoid );

//For Context menu
enum {    CNTXMENU_PERSON_EMAIL,
        CNTXMENU_PERSON_WEB,
        CNTXMENU_PERSON_DIAL };

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CPersonListCtrl
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CPersonListCtrl, CListCtrl)

/////////////////////////////////////////////////////////////////////////////
CPersonListCtrl::CPersonListCtrl()
{
   m_pParentWnd = NULL;
   m_pDisplayObject = NULL;
   m_bLargeView = TRUE;
}

/////////////////////////////////////////////////////////////////////////////
CPersonListCtrl::~CPersonListCtrl()
{
    CleanDisplayObject();
}

void CPersonListCtrl::CleanDisplayObject()
{
    if ( m_pDisplayObject )
    {
        if ( m_pDisplayObject->IsKindOf(RUNTIME_CLASS(CLDAPUser)) )
            ((CLDAPUser *) m_pDisplayObject)->Release();
        else
            delete m_pDisplayObject;

        // NULL out the object
        m_pDisplayObject = NULL;
    }
}

void CPersonListCtrl::ClearList()
{
    DeleteAllItems();
}

/////////////////////////////////////////////////////////////////////////////
BEGIN_MESSAGE_MAP(CPersonListCtrl, CListCtrl)
    //{{AFX_MSG_MAP(CPersonListCtrl)
    ON_NOTIFY_REFLECT(NM_DBLCLK, OnDblclk)
    ON_WM_CREATE()
    ON_UPDATE_COMMAND_UI(ID_BUTTON_SPEEDDIAL_ADD, OnUpdateButtonSpeeddialAdd)
    ON_COMMAND(ID_BUTTON_SPEEDDIAL_ADD, OnButtonSpeeddialAdd)
    ON_COMMAND(ID_BUTTON_MAKECALL, OnButtonMakecall)
    ON_MESSAGE(WM_ACTIVEDIALER_BUDDYLIST_DYNAMICUPDATE,OnBuddyListDynamicUpdate)
    ON_WM_KEYUP()
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

int CPersonListCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
    if (CListCtrl::OnCreate(lpCreateStruct) == -1)
        return -1;

   ListView_SetExtendedListViewStyle(GetSafeHwnd(),LVS_EX_TRACKSELECT);
   ListView_SetIconSpacing(GetSafeHwnd(),LARGE_ICON_X, LARGE_ICON_Y );

   m_imageListLarge.Create(IDB_LIST_MEDIA_LARGE,24,0,RGB_TRANS);
   SetImageList(&m_imageListLarge,LVSIL_NORMAL);

   m_imageListSmall.Create(IDB_LIST_MEDIA_SMALL,16,0,RGB_TRANS);
   SetImageList(&m_imageListSmall,LVSIL_SMALL);

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CPersonListCtrl::InsertObject(CObject* pUser,BOOL bUseCache)
{
    ASSERT(pUser);
    BOOL bRet = FALSE;

    if ( (bUseCache == FALSE) && (m_pDisplayObject) )
        CleanDisplayObject();

    m_pDisplayObject = pUser;
    ClearList();

   if (pUser->IsKindOf(RUNTIME_CLASS(CILSUser)))
   {
      CILSUser* pILSUser = (CILSUser*)pUser;
      CString sOut;
      AfxFormatString1(sOut,IDS_WABPERSON_FORMAT_NETPHONE,pILSUser->m_sIPAddress);
      PersonFormatString(sOut);
      InsertItem(sOut,PERSONLISTCTRL_ITEM_NETCALL,PERSONLISTCTRL_IMAGE_NETCALL);
      bRet = TRUE;
   }
   else if (pUser->IsKindOf(RUNTIME_CLASS(CDSUser)))
   {
      CDSUser* pDSUser = (CDSUser*)pUser;
      CString sOut;
      
      //only add netcall if user has ip address
      if (!pDSUser->m_sIPAddress.IsEmpty())
      {
         AfxFormatString1(sOut,IDS_WABPERSON_FORMAT_NETPHONE,pDSUser->m_sIPAddress);
         PersonFormatString(sOut);
         InsertItem(sOut,PERSONLISTCTRL_ITEM_NETCALL,PERSONLISTCTRL_IMAGE_NETCALL);
      }
      if (!pDSUser->m_sPhoneNumber.IsEmpty())
      {
         AfxFormatString1(sOut,IDS_WABPERSON_FORMAT_BUSINESSTELEPHONE,pDSUser->m_sPhoneNumber);
         PersonFormatString(sOut);
         InsertItem(sOut,PERSONLISTCTRL_ITEM_PHONECALL_BUSINESS,PERSONLISTCTRL_IMAGE_PHONECALL);
      }
      
      bRet = TRUE;
   }
   else if (pUser->IsKindOf(RUNTIME_CLASS(CLDAPUser)))
   {
      CLDAPUser* pLDAPUser = (CLDAPUser*)pUser;
      CString sOut;

      //only add netcall if user has ip address
      if (!pLDAPUser->m_sIPAddress.IsEmpty())
      {
         AfxFormatString1(sOut,IDS_WABPERSON_FORMAT_NETPHONE,pLDAPUser->m_sIPAddress);
         PersonFormatString(sOut);
         InsertItem(sOut,PERSONLISTCTRL_ITEM_NETCALL,PERSONLISTCTRL_IMAGE_NETCALL);
      }
      if (!pLDAPUser->m_sPhoneNumber.IsEmpty())
      {
         AfxFormatString1(sOut,IDS_WABPERSON_FORMAT_BUSINESSTELEPHONE,pLDAPUser->m_sPhoneNumber);
         PersonFormatString(sOut);
         InsertItem(sOut,PERSONLISTCTRL_ITEM_PHONECALL_BUSINESS,PERSONLISTCTRL_IMAGE_PHONECALL);
      }
      if (!pLDAPUser->m_sEmail1.IsEmpty())
      {
         AfxFormatString1(sOut,IDS_WABPERSON_FORMAT_EMAIL,pLDAPUser->m_sEmail1);
         PersonFormatString(sOut);
         InsertItem(sOut,PERSONLISTCTRL_ITEM_EMAIL,PERSONLISTCTRL_IMAGE_EMAIL);
      }
      
      bRet = TRUE;
   }
   else
   {
      m_pDisplayObject = NULL;
   }
   return bRet;
}


/////////////////////////////////////////////////////////////////////////////
int CPersonListCtrl::InsertItem(LPCTSTR szStr,UINT uID,int nImage)
{
   int nItem = -1;
   
    LV_ITEM lv_item;
    memset(&lv_item,0,sizeof(LV_ITEM));
    
   if (nItem == -1)
      nItem = GetItemCount();
   lv_item.iItem = nItem;

    lv_item.mask |= LVIF_TEXT;
    lv_item.pszText = (LPTSTR)szStr;
    
   lv_item.mask |= LVIF_IMAGE;
   lv_item.iImage = nImage;

   lv_item.mask |= LVIF_PARAM;
   lv_item.lParam = uID;

    if ((nItem = CListCtrl::InsertItem(&lv_item)) != -1)
      CListCtrl::EnsureVisible(nItem,FALSE);

   int nWidth = GetStringWidth(szStr);
   CListCtrl::SetColumnWidth(-1,nWidth);

   return nItem;
}

/////////////////////////////////////////////////////////////////////////////
void CPersonListCtrl::Refresh(CObject* pUser)
{
}

/////////////////////////////////////////////////////////////////////////////
void CPersonListCtrl::OnDblclk(NMHDR* pNMHDR, LRESULT* pResult) 
{
    *pResult = 0;

    LV_HITTESTINFO lvhti;
    ::GetCursorPos( &lvhti.pt );
    ScreenToClient( &lvhti.pt );

    HitTest(&lvhti);
    if (lvhti.flags & LVHT_ONITEM)
    {
        LV_ITEM lv_item;
        lv_item.mask = LVIF_PARAM;
        lv_item.iItem = lvhti.iItem;
        lv_item.iSubItem = 0;

        // Do we have an item to dial?         
        if ( GetItem(&lv_item) )
        {
            //Get data from selected item and object
            DialerMediaType dmtType = DIALER_MEDIATYPE_UNKNOWN;
            DWORD dwAddressType = 0;
            CString sName,sAddress;

            if (GetSelectedItemData((UINT)lv_item.lParam,dmtType,dwAddressType,sName,sAddress))
            {
                switch ( lv_item.lParam )
                {
                    // Bring up an e-mail client
                    case PERSONLISTCTRL_ITEM_EMAIL:
                        SendMailToAddress( sName, sAddress );
                        break;

                    // Place the call in all other cases
                    default:
                        if ( AfxGetMainWnd() &&  ((CMainFrame*) AfxGetMainWnd())->GetDocument() )
                            ((CMainFrame*) AfxGetMainWnd())->GetDocument()->Dial(sName,sAddress,dwAddressType,dmtType, false);
                        break;
                }
            }
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
void CPersonListCtrl::GetSelectedItemText(CString& sText)
{
   int nItem =  CListCtrl::GetNextItem(-1,LVNI_FOCUSED);
   if (nItem != -1)
   {
      sText = GetItemText(nItem,0);
   }
}

/////////////////////////////////////////////////////////////////////////////
int CPersonListCtrl::GetSelectedObject()
{
   int nRet = -1;
   int nItem =  CListCtrl::GetNextItem(-1,LVNI_FOCUSED);
   if (nItem != -1)
   {
      nRet = (int)GetItemData(nItem);
   }
   return nRet;
}

/////////////////////////////////////////////////////////////////////////////
void CPersonListCtrl::ShowLargeView()
{
   m_bLargeView = TRUE;

   LONG_PTR LPStyle = ::GetWindowLongPtr(GetSafeHwnd(),GWL_STYLE );
   LPStyle |= LVS_ICON;
   LPStyle |= LVS_ALIGNTOP;
   LPStyle &= ~LVS_ALIGNLEFT;
   LPStyle &= ~LVS_SMALLICON;
   ::SetWindowLongPtr(GetSafeHwnd(),GWL_STYLE, LPStyle);

   ListView_SetIconSpacing(GetSafeHwnd(), LARGE_ICON_X, LARGE_ICON_Y );

   if (m_pDisplayObject)
      InsertObject(m_pDisplayObject,TRUE);
}

/////////////////////////////////////////////////////////////////////////////
void CPersonListCtrl::ShowSmallView()
{
   m_bLargeView = FALSE;
   
   LONG_PTR LPStyle = ::GetWindowLongPtr(GetSafeHwnd(),GWL_STYLE );
   LPStyle |= LVS_SMALLICON;
   LPStyle |= LVS_ALIGNLEFT;
   LPStyle &= ~LVS_ALIGNTOP;
   LPStyle &= ~LVS_ICON;
   ::SetWindowLongPtr(GetSafeHwnd(),GWL_STYLE, LPStyle);

   ListView_SetIconSpacing(GetSafeHwnd(), SMALL_ICON_X, SMALL_ICON_Y );

   if (m_pDisplayObject)
      InsertObject(m_pDisplayObject,TRUE);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//SpeedDial Support
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
void CPersonListCtrl::OnButtonSpeeddialAdd() 
{
   ASSERT(m_pDisplayObject);

   //Get data from selected item and object
   DialerMediaType dmtType = DIALER_MEDIATYPE_UNKNOWN;
   DWORD dwAddressType = 0;
   CString sName,sAddress;
   if (GetSelectedItemData(GetSelectedObject(),dmtType,dwAddressType,sName,sAddress))
   {
      CSpeedDialAddDlg dlg;

      // Setup dialog data
      dlg.m_CallEntry.m_MediaType = dmtType;
      dlg.m_CallEntry.m_sDisplayName = sName;
      dlg.m_CallEntry.m_lAddressType = dwAddressType;
      dlg.m_CallEntry.m_sAddress = sAddress;

      // Show the dialog and add if user says is okay
      if ( dlg.DoModal() == IDOK )
         CDialerRegistry::AddCallEntry(FALSE,dlg.m_CallEntry);
   }
}

/////////////////////////////////////////////////////////////////////////////
void CPersonListCtrl::OnUpdateButtonSpeeddialAdd(CCmdUI* pCmdUI) 
{
   int nObject = GetSelectedObject();
   if ( (nObject == PERSONLISTCTRL_ITEM_NETCALL) ||
        (nObject == PERSONLISTCTRL_ITEM_PHONECALL_BUSINESS) )
      pCmdUI->Enable(TRUE);
   else
      pCmdUI->Enable(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
void CPersonListCtrl::OnButtonMakecall() 
{
   //Get data from selected item and object
   DialerMediaType dmtType = DIALER_MEDIATYPE_UNKNOWN;
   DWORD dwAddressType = 0;
   CString sName,sAddress;
   if (GetSelectedItemData(GetSelectedObject(),dmtType,dwAddressType,sName,sAddress))
   {

      if ( !AfxGetMainWnd() || !((CMainFrame*) AfxGetMainWnd())->GetDocument() ) return;
      CActiveDialerDoc* pDoc = ((CMainFrame*) AfxGetMainWnd())->GetDocument();
      if (pDoc) pDoc->Dial(sName,sAddress,dwAddressType,dmtType, false);
   }
   else
   {
      if ( !AfxGetMainWnd() || !((CMainFrame*) AfxGetMainWnd())->GetDocument() ) return;
      CActiveDialerDoc* pDoc = ((CMainFrame*) AfxGetMainWnd())->GetDocument();
      if (pDoc) pDoc->Dial(_T(""),_T(""),LINEADDRESSTYPE_IPADDRESS,DIALER_MEDIATYPE_UNKNOWN, false);
   }
}

/////////////////////////////////////////////////////////////////////////////
BOOL CPersonListCtrl::GetSelectedItemData(UINT uSelectedItem,DialerMediaType& dmtType,DWORD& dwAddressType,CString& sName,CString& sAddress)
{
    BOOL bRet = FALSE;

    dmtType = DIALER_MEDIATYPE_UNKNOWN;
    dwAddressType = 0;

    // Retrieve stock properties for particular object
    CString strIPAddress, strPhoneNumber, strEmailAddress;
    if (m_pDisplayObject->IsKindOf(RUNTIME_CLASS(CILSUser)))
    {
        sName                = ((CILSUser *) m_pDisplayObject)->m_sUserName;
        strIPAddress        = ((CILSUser *) m_pDisplayObject)->m_sIPAddress;
    }
    else if (m_pDisplayObject->IsKindOf(RUNTIME_CLASS(CDSUser)))
    {
        sName                = ((CDSUser *) m_pDisplayObject)->m_sUserName;
        strIPAddress        = ((CDSUser *) m_pDisplayObject)->m_sIPAddress;
        strPhoneNumber        = ((CDSUser *) m_pDisplayObject)->m_sPhoneNumber;
    }
    else if (m_pDisplayObject->IsKindOf(RUNTIME_CLASS(CLDAPUser)))
    {
        sName                = ((CLDAPUser *) m_pDisplayObject)->m_sUserName;
        strIPAddress        = ((CLDAPUser *) m_pDisplayObject)->m_sIPAddress;
        strPhoneNumber        = ((CLDAPUser *) m_pDisplayObject)->m_sPhoneNumber;
        strEmailAddress        = ((CLDAPUser *) m_pDisplayObject)->m_sEmail1;
    }


    // Assign data to appropriate parameters
    switch (uSelectedItem)
    {
        case PERSONLISTCTRL_ITEM_NETCALL:
            sAddress = strIPAddress;
            dwAddressType = LINEADDRESSTYPE_IPADDRESS; 
            dmtType = DIALER_MEDIATYPE_INTERNET;
            break;

        case PERSONLISTCTRL_ITEM_PHONECALL_BUSINESS:
            sAddress = strPhoneNumber;
            dwAddressType = LINEADDRESSTYPE_PHONENUMBER;
            dmtType = DIALER_MEDIATYPE_POTS;
            break;

        case PERSONLISTCTRL_ITEM_EMAIL:
            sAddress = strEmailAddress;
            dwAddressType = LINEADDRESSTYPE_EMAILNAME;
            dmtType = DIALER_MEDIATYPE_INTERNET;
            break;
    }

    if ( dwAddressType && !sAddress.IsEmpty() && (dmtType != DIALER_MEDIATYPE_UNKNOWN) )
        bRet = TRUE;

    return bRet;
}

/////////////////////////////////////////////////////////////////////////////
LRESULT CPersonListCtrl::OnBuddyListDynamicUpdate(WPARAM wParam,LPARAM lParam)
{
    ASSERT(lParam && ((CLDAPUser *) lParam)->IsKindOf(RUNTIME_CLASS(CLDAPUser)) );

    CLDAPUser *pUser = (CLDAPUser *) lParam;

    if ( m_pDisplayObject && m_pDisplayObject->IsKindOf(RUNTIME_CLASS(CLDAPUser)) && (m_pDisplayObject == pUser) )
         InsertObject(m_pDisplayObject,TRUE);

    pUser->Release();
    return 0;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

void CPersonListCtrl::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    LV_HITTESTINFO lvhti;
    ::GetCursorPos( &lvhti.pt );
    ScreenToClient( &lvhti.pt );

    HitTest(&lvhti);
    if (lvhti.flags & LVHT_ONITEM)
    {
        LV_ITEM lv_item;
        memset(&lv_item,0,sizeof(LV_ITEM));
        lv_item.mask = LVIF_PARAM;
        lv_item.iItem = lvhti.iItem;
        lv_item.iSubItem = 0;

        if (GetItem(&lv_item))
        {
            int nSubMenu = -1;

            switch ((UINT)lv_item.lParam)
            {
                case PERSONLISTCTRL_ITEM_NETCALL:
                case PERSONLISTCTRL_ITEM_PHONECALL_BUSINESS:
                    nSubMenu = CNTXMENU_PERSON_DIAL;   
                    break;
            }

            // Do we have a menu to show?
            if ( nSubMenu != -1 )
            {
                CMenu menu;
                menu.LoadMenu(IDR_CONTEXT_COMMOBJECTS);
                CMenu* pContextMenu = menu.GetSubMenu(nSubMenu);
                if (pContextMenu)
                {
                    CPoint pt;
                    ::GetCursorPos(&pt);
                    pContextMenu->TrackPopupMenu( TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                                                  pt.x,pt.y,this);
                }
            }
        }
    }
}

///////////////////////////////////////////////////////////////////////////////////
// Simple class to handle the mail request
//
class CSendMailInfo
{
public:
    CString m_strName;
    CString m_strAddr;
};

void SendMailToAddress( CString& strUserName, CString& strUserAddr )
{
    DWORD dwThreadID;

    CSendMailInfo *pInfo = new CSendMailInfo;
    if ( pInfo )
    {
        // Copy info into data structure
        pInfo->m_strName = strUserName;
        pInfo->m_strAddr = strUserAddr;

        HANDLE hThreadTemp = CreateThread( NULL, 0, ThreadSendMail, (LPVOID)pInfo, 0, &dwThreadID );
        if ( hThreadTemp )
        {
            CloseHandle( hThreadTemp );
        }
        else
        {
            delete pInfo;
        }
    }
}


DWORD WINAPI ThreadSendMail( LPVOID pParam )
{
    AVTRACE(_T(".enter.ThreadSendMail()."));
    ASSERT( pParam );
    if ( !pParam ) return E_INVALIDARG;
    CSendMailInfo *pInfo = (CSendMailInfo *) pParam;

    // Initialize OLE as apartment thread
    HRESULT hr = CoInitialize( NULL );
    if ( SUCCEEDED(hr) )
    {
        HINSTANCE hInstMail = ::LoadLibraryA("MAPI32.DLL");
        if ( !hInstMail )
        {
            AfxMessageBox(AFX_IDP_FAILED_MAPI_LOAD);
            return 0;
        }

        MAPISENDMAIL *lpfnSendMail = (MAPISENDMAIL *) GetProcAddress( hInstMail, "MAPISendMail" );
        if ( lpfnSendMail )
        {
            // Setup a list of message recipients
            MapiRecipDesc recip;
            memset( &recip, 0, sizeof(recip) );
            recip.ulRecipClass = MAPI_TO;

#ifdef _UNICODE
            char szTempNameA[_MAX_PATH];
            char szTempAddrA[_MAX_PATH];
            _wcstombsz( szTempNameA, pInfo->m_strName, ARRAYSIZE(szTempNameA) );
            _wcstombsz( szTempAddrA, pInfo->m_strAddr, ARRAYSIZE(szTempAddrA) );
            
            recip.lpszName = szTempAddrA;
            recip.lpszAddress = NULL;
#else
            recip.lpszName = pInfo->m_strAddr.GetBuffer( -1 );
            recip.lpszAddress = NULL;
#endif

            // prepare the message
            MapiMessage message;
            memset(&message, 0, sizeof(message));
            message.nRecipCount = 1;
            message.lpRecips = &recip;


            int nError = lpfnSendMail( 0,
                                       NULL,
                                       &message,
                                       MAPI_LOGON_UI | MAPI_DIALOG,
                                       0 );

#ifndef _UNICODE
            pInfo->m_strName.ReleaseBuffer();
            pInfo->m_strAddr.ReleaseBuffer();
#endif

            if (nError != SUCCESS_SUCCESS &&
                nError != MAPI_USER_ABORT && nError != MAPI_E_LOGIN_FAILURE)
            {
                AfxMessageBox(AFX_IDP_FAILED_MAPI_SEND);
            }
        }
        else
        {
            // Failed to load the proc address
            AfxMessageBox(AFX_IDP_INVALID_MAPI_DLL);
        }

        // Release MAPI32 DLL
        if ( hInstMail )
            ::FreeLibrary( hInstMail );

        CoUninitialize();
    }

    //
    // We'll delete pInfo in the caller method SendMailToAddress()
    //
    delete pInfo;
    AVTRACE(_T(".exit.ThreadSendMail(%ld).\n"), hr );
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\ilslist.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////
// ILSPersonListCtrl.h : header file
/////////////////////////////////////////////////////////////////////////////////////////

#ifndef _ILSPERSONLISTCTRL_H_
#define _ILSPERSONLISTCTRL_H_

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Defines
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
enum 
{
   PERSONLISTCTRL_ITEM_NETCALL = 0,
   PERSONLISTCTRL_ITEM_CHAT,
   PERSONLISTCTRL_ITEM_PHONECALL_BUSINESS,
   PERSONLISTCTRL_ITEM_PHONECALL_HOME,
   PERSONLISTCTRL_ITEM_CELLCALL,
   PERSONLISTCTRL_ITEM_FAXCALL_BUSINESS,
   PERSONLISTCTRL_ITEM_FAXCALL_HOME,
   PERSONLISTCTRL_ITEM_PAGER,
   PERSONLISTCTRL_ITEM_DESKTOPPAGE,
   PERSONLISTCTRL_ITEM_EMAIL,
   PERSONLISTCTRL_ITEM_PERSONALWEB,
   PERSONLISTCTRL_ITEM_PERSONALURL,
};

enum 
{
   PERSONLISTCTRL_IMAGE_NETCALL = 0,
   PERSONLISTCTRL_IMAGE_CHAT,
   PERSONLISTCTRL_IMAGE_PHONECALL,
   PERSONLISTCTRL_IMAGE_CELLCALL,
   PERSONLISTCTRL_IMAGE_FAXCALL,
   PERSONLISTCTRL_IMAGE_PAGER,
   PERSONLISTCTRL_IMAGE_DESKTOPPAGE,
   PERSONLISTCTRL_IMAGE_EMAIL,
   PERSONLISTCTRL_IMAGE_PERSONALWEB,
   PERSONLISTCTRL_IMAGE_PERSONALURL,
   PERSONLISTCTRL_IMAGE_CONFERENCE,
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CPersonListCtrl window
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class CPersonListCtrl : public CListCtrl
{
	DECLARE_DYNCREATE(CPersonListCtrl)
// Construction
public:
	CPersonListCtrl();

// Attributes
public:
protected:
   CWnd*          m_pParentWnd;

   CObject*       m_pDisplayObject;

   BOOL           m_bLargeView;

   CImageList     m_imageListLarge;
   CImageList     m_imageListSmall;

// Operations
public:
	BOOL			InsertObject(CObject* pUser,BOOL bUseCache=FALSE);
	void			ShowLargeView();
	void			ShowSmallView();
	BOOL			IsLargeView()                                   { return m_bLargeView; };

	void			Refresh(CObject* pUser);
	void			ClearList();

protected:
	void			CleanDisplayObject();
	void			GetSelectedItemText(CString& sText);
	int				InsertItem(LPCTSTR szStr,UINT uID,int nImage);
	int				GetSelectedObject();

	BOOL			GetSelectedItemData(UINT uSelectedItem,DialerMediaType& dmtType,DWORD& dwAddressType,CString& sName,CString& sAddress);

   inline void    PersonFormatString(CString& sOut)
   {
      if (m_bLargeView == FALSE)                      //if small view, then no \r\n
      {
         int nIndex;
         while ((nIndex = sOut.Find(_T("\r\n"))) != -1)
         {
            CString sTemp = sOut.Left(nIndex);
            sTemp += _T(" ");
            sOut = sTemp + sOut.Mid(nIndex+2);
         }
      }
   }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPersonListCtrl)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual		~CPersonListCtrl();

	// Generated message map functions
protected:
	//{{AFX_MSG(CPersonListCtrl)
	afx_msg void OnDblclk(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnUpdateButtonSpeeddialAdd(CCmdUI* pCmdUI);
	afx_msg void OnButtonSpeeddialAdd();
	afx_msg void OnButtonMakecall();
   afx_msg LRESULT OnBuddyListDynamicUpdate(WPARAM wParam,LPARAM lParam);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif //_ILSPERSONLISTCTRL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\mainfrm.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// MainFrm.h : interface of the CMainFrame class
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__A0D7A960_3C0B_11D1_B4F9_00C04FC98AD3__INCLUDED_)
#define AFX_MAINFRM_H__A0D7A960_3C0B_11D1_B4F9_00C04FC98AD3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "TrayIcon.h"
#include "avDialerDoc.h"
#include "ToolBars.h"
#include "DialReg.h"
#include "USB.h"

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Defines
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Tray
#define  WM_TRAY_NOTIFICATION                       (WM_USER + 1020)

//For COM interface
#define WM_ACTIVEDIALER_INTERFACE_MAKECALL			(WM_USER + 1010)  
#define WM_ACTIVEDIALER_INTERFACE_REDIAL			(WM_USER + 1011)  
#define WM_ACTIVEDIALER_INTERFACE_SPEEDDIAL			(WM_USER + 1012)  
#define WM_ACTIVEDIALER_INTERFACE_SHOWEXPLORER		(WM_USER + 1013)  
#define WM_ACTIVEDIALER_INTERFACE_SPEEDDIALEDIT		(WM_USER + 1014)  
#define WM_ACTIVEDIALER_INTERFACE_SPEEDDIALMORE		(WM_USER + 1015)  
#define WM_ACTIVEDIALER_SPLASHSCREENDONE			(WM_USER + 1016)
#define WM_ACTIVEDIALER_CALLCONTROL_CHECKSTATES		(WM_USER + 1018)
#define WM_ACTIVEDIALER_INTERFACE_RESOLVEUSER		(WM_USER + 1019)
#define WM_ACTIVEDIALER_BUDDYLIST_DYNAMICUPDATE		(WM_USER + 1020)
#define WM_DOCHINT									(WM_USER + 1021)

#define	 WM_USERUSER_DIALOG							(WM_USER + 1040)

typedef enum tagExplorerToolBar
{
   ETB_BLANK=0,
   ETB_HIDECALLS,
   ETB_SHOWCALLS,
}ExplorerToolBar;

HRESULT get_Tapi(IAVTapi **ppAVTapi );

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//CMainFrame
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class CMainFrame : public CFrameWnd
{
protected: // create from serialization only
	CMainFrame();
	DECLARE_DYNCREATE(CMainFrame)

// Members
public:
   CTrayIcon            m_trayIcon;
   BOOL                 m_bCanExitApplication;

protected:
	// Tray icon support
	bool				m_bCanSaveDesktop;
	SIZE_T				m_nLButtonTimer;
	BOOL				m_bKillNextLButton;
	UINT				m_nRButtonTimer;
	BOOL				m_bKillNextRButton;
	WPARAM				m_wpTrayId;
	HMENU				m_hTrayMenu;
	POINT				m_ptMouse;

	SIZE_T				m_uHeartBeatTimer;

	HIMAGELIST			m_hImlTrayMenu;
	CMapWordToPtr		m_mapTrayMenuIdToImage;

   // Setup Wizard
#ifndef _MSLITE
   BOOL                 m_bShowSetupWizard;
   COptionsSheet*       m_pOptionsSheet;
#endif //_MSLITE

   CDialog*             m_pSpeedDialEditDlg;       //place holder for add/edit dialogs

   // Conference Explorer spcecific attributes
protected:
	ExplorerToolBar         m_nCurrentExplorerToolBar;
	BOOL                    m_bShutdown;
	BOOL                    m_bShowToolBarText;
	BOOL                    m_bShowToolBars;
	BOOL                    m_bShowStatusBar;
	BOOL					m_bHideWhenMinimized;

	CDirectoriesCoolBar     m_wndCoolBar;
 	CStatusBar              m_wndStatusBar;

	HIMAGELIST              m_hImageListMenu;
	CMapWordToPtr           m_mapMenuIdToImage;
	CBitmap                 m_bmpImageDisabledMenu;
	int                     m_nDisabledImageOffset;
	CMapWordToPtr           m_mapRedialIdToImage;
	CMapWordToPtr           m_mapSpeeddialIdToImage;

	HMENU                   m_hmenuCurrentPopupMenu;

	int                     m_nCurrentDayOfWeek;             //For midnight processing

// Attributes
public:
	CActiveDialerDoc*   GetDocument() const;
	IAVTapi*			GetTapi();
	BOOL				CanJoinConference();
	BOOL				CanLeaveConference();
	void				CanConfRoomShowNames( BOOL &bEnable, BOOL &bCheck );
	void				CanConfRoomShowFullSizeVideo( BOOL &bEnable, BOOL &bCheck );

// Operations
public:
	void				ShowExplorerToolBar(ExplorerToolBar etb);
	void				Show( bool bVisible = true );
	void				NotifyHideCallWindows();
	void				NotifyUnhideCallWindows();

	void                HeartBeat();

	void                ShowTrayMenu();
	bool				UpdateTrayIconState();

protected:
	void                 ClearMenuMaps();
	void                 LoadMenuMaps();
	void                 DoMenuUpdate(CMenu* pMenu);
	void                 AddDialListMenu(CMenu* pParentMenu,BOOL bRedial,int nSubMenuOffset);
	void                 OnButtonMakecall(CCallEntry* pCallentry,BOOL bShowPlaceCallDialog);
	void                 DrawTrayItem(int nIDCtl, LPDRAWITEMSTRUCT lpDIS);
	void                 MeasureTrayItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMIS);

	BOOL                 LoadCallMenu(HMENU hSubMenu,BOOL bRedial);

#ifndef _MSLITE
	BOOL                 ShowSetupWizard();
#endif //_MSLITE

	BOOL                 CreateExplorerMenusAndBars(LPCREATESTRUCT lpCreateStruct);

	void                 LoadDesktop(LPCREATESTRUCT lpCreateStruct);
	void                 SaveDesktop();

	//HeartBeat Processing
	void                 DoMidnightProcessing();
	bool                 CheckDayOfWeekChange();

#ifndef _MSLITE
	void                 CheckReminders();
#endif //_MSLITE

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	public:
	virtual void ActivateFrame(int nCmdShow = -1);
	protected:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
public:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnClose();
	afx_msg LRESULT OnTrayNotification(WPARAM uID, LPARAM lEvent);
	afx_msg LRESULT OnActiveDialerInterfaceMakeCall(WPARAM wParam,LPARAM lParam);
	afx_msg LRESULT OnActiveDialerInterfaceRedial(WPARAM wParam,LPARAM lParam);
	afx_msg LRESULT OnActiveDialerInterfaceSpeedDial(WPARAM wParam,LPARAM lParam);
	afx_msg LRESULT OnActiveDialerInterfaceShowExplorer(WPARAM wParam,LPARAM lParam);
	afx_msg LRESULT OnActiveDialerInterfaceSpeedDialEdit(WPARAM wParam,LPARAM lParam);
	afx_msg LRESULT OnActiveDialerInterfaceSpeedDialMore(WPARAM wParam,LPARAM lParam);
	afx_msg LRESULT OnUserUserDialog(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnSplashScreenDone(WPARAM wParam,LPARAM lParam);
	afx_msg LRESULT OnUpdateAllViews(WPARAM wParam, LPARAM lHint);
	afx_msg void OnTimer(UINT nIDEvent);
	afx_msg void OnTrayState();
	virtual void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	virtual void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
	afx_msg void OnButtonMakecall();
	afx_msg void OnButtonRedial();
	afx_msg void OnButtonOptions();
	afx_msg void OnButtonSpeeddial();
	afx_msg void OnButtonSpeeddialEdit();
	afx_msg void OnButtonSpeeddialMore();
	afx_msg void OnButtonConferenceexplore();
	afx_msg void OnButtonExitdialer();
	afx_msg void OnButtonRoomPreview();
	afx_msg void OnUpdateButtonRoomPreview(CCmdUI* pCmdUI);
	afx_msg void OnUpdateButtonExitdialer(CCmdUI* pCmdUI);
	afx_msg void OnButtonTelephonyservices();
	afx_msg LRESULT OnCreateCallControl(WPARAM,LPARAM);
	afx_msg LRESULT OnDestroyCallControl(WPARAM,LPARAM);
	afx_msg LRESULT OnShowDialerExplorer(WPARAM wParam,LPARAM lParam);
	afx_msg LRESULT OnActiveDialerErrorNotify(WPARAM wParam,LPARAM lParam);
	afx_msg void OnToolbarText();
	afx_msg void OnUpdateToolbarText(CCmdUI* pCmdUI);
	afx_msg void OnViewToolbars();
	afx_msg void OnUpdateViewToolbars(CCmdUI* pCmdUI);
	afx_msg void OnViewStatusbar();
	afx_msg void OnUpdateViewStatusbar(CCmdUI* pCmdUI);
	afx_msg void OnUpdateDialerMruRedialStart(CCmdUI* pCmdUI);
	afx_msg void OnUpdateDialerMruSpeeddialStart(CCmdUI* pCmdUI);
	afx_msg void OnParentNotify(UINT message, LPARAM lParam);
	afx_msg void OnButtonCloseexplorer();
	afx_msg void OnUpdateButtonMakecall(CCmdUI* pCmdUI);
	afx_msg void OnViewLog();
	afx_msg void OnUpdateWindowWindows(CCmdUI* pCmdUI);
	afx_msg LRESULT OnCheckCallControlStates(WPARAM wParam,LPARAM lParam);
	afx_msg LRESULT OnActiveDialerInterfaceResolveUser(WPARAM wParam,LPARAM lParam);
	afx_msg void OnEnable(BOOL bEnable);
	afx_msg void OnCallwindowHide();
	afx_msg void OnUpdateCallwindowHide(CCmdUI* pCmdUI);
	afx_msg void OnCallwindowShow();
	afx_msg void OnUpdateCallwindowShow(CCmdUI* pCmdUI);
	afx_msg void OnButtonConferenceJoin();
	afx_msg void OnUpdateButtonConferenceJoin(CCmdUI* pCmdUI);
	afx_msg void OnButtonRoomDisconnect();
	afx_msg void OnUpdateButtonRoomDisconnect(CCmdUI* pCmdUI);
	afx_msg void OnHideWhenMinimized();
	afx_msg void OnUpdateHideWhenMinimized(CCmdUI* pCmdUI);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnButtonDirectoryAddilsserver();
	afx_msg void OnUpdateButtonDirectoryAddilsserver(CCmdUI* pCmdUI);
	afx_msg void OnCallwindowAlwaysontop();
	afx_msg void OnUpdateCallwindowAlwaysontop(CCmdUI* pCmdUI);
	afx_msg void OnCallwindowSlidesideLeft();
	afx_msg void OnUpdateCallwindowSlidesideLeft(CCmdUI* pCmdUI);
	afx_msg void OnCallwindowSlidesideRight();
	afx_msg void OnUpdateCallwindowSlidesideRight(CCmdUI* pCmdUI);
	afx_msg void OnConfgroupFullsizevideo();
	afx_msg void OnUpdateConfgroupFullsizevideo(CCmdUI* pCmdUI);
	afx_msg void OnConfgroupShownames();
	afx_msg void OnUpdateConfgroupShownames(CCmdUI* pCmdUI);
	afx_msg void OnUpdateButtonOptions(CCmdUI* pCmdUI);
	afx_msg void OnWindowsAlwaysclosecallwindows();
	afx_msg void OnUpdateWindowsAlwaysclosecallwindows(CCmdUI* pCmdUI);
	afx_msg void OnDestroy();
	afx_msg void OnToolBarDropDown(UINT uID,NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnViewSelectedconferencevideoscale(UINT nID);
	afx_msg void OnUpdateViewSelectedconferencevideoscale(CCmdUI* pCmdUI);
	afx_msg LRESULT OnDocHint( WPARAM wParam, LPARAM lParam );
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	//}}AFX_MSG
	afx_msg void OnDialerRedial(UINT nID);
	afx_msg void OnButtonSpeeddial(UINT nID);
	afx_msg void OnWindowWindowsSelect(UINT nID);
	afx_msg LRESULT OnTaskBarCallbackMsg(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnTaskBarCreated(WPARAM wParam, LPARAM lParam );
    afx_msg LRESULT OnUSBPhone( WPARAM wParam, LPARAM lParam);
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__A0D7A960_3C0B_11D1_B4F9_00C04FC98AD3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\msghook.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////
// CMsgHook Copyright 1996 Microsoft Systems Journal. 
// If this code works, it was written by Paul DiLascia.
// If not, I don't know who wrote it.
//
#ifndef _MSGHOOK_H
#define _MSGHOOK_H

//////////////////
// Generic class to hook messages on behalf of a CWnd.
// Once hooked, all messages go to CMsgHook::WindowProc before going
// to the window. Specific subclasses can trap messages and do something.
// To use:
//
// * Derive a class from CMsgHook.
//
// * Override CMsgHook::WindowProc to handle messages. Make sure you call
//   CMsgHook::WindowProc if you don't handle the message, or your window will
//   never get messages. If you write seperate message handlers, you can call
//   Default() to pass the message to the window.
//
// * Instantiate your derived class somewhere and call HookWindow(pWnd)
//   to hook your window, AFTER it has been created.
//	  To unhook, call HookWindow(NULL).
//
class CMsgHook : public CObject {
protected:
	DECLARE_DYNAMIC(CMsgHook);
	CWnd*			m_pWndHooked;		// the window hooked
	WNDPROC		m_pOldWndProc;		// ..and original window proc
	CMsgHook*	m_pNext;				// next in chain of hooks for this window

	// Override this to handle messages in specific handlers
	virtual LRESULT WindowProc(UINT msg, WPARAM wp, LPARAM lp);
	LRESULT Default();				// call this at the end of handler fns

public:
	CMsgHook();
	~CMsgHook();

	// Hook a window. Hook(NULL) to unhook (automatic on WM_NCDESTROY)
#ifdef _DIALER_MSGHOOK_SUPPORT
	BOOL	HookWindow(CWnd* pRealWnd);
#else //_DIALER_MSGHOOK_SUPPORT
   BOOL  HookWindow(CWnd* pRealWnd)       { return TRUE; };
#endif //_DIALER_MSGHOOK_SUPPORT

	BOOL	IsHooked()			{ return m_pWndHooked!=NULL; }

	friend LRESULT CALLBACK HookWndProc(HWND, UINT, WPARAM, LPARAM);
	friend class CMsgHookMap;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\msghook.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////
// Copyright 1996 Microsoft Systems Journal. 
// If this program works, it was written by Paul DiLascia.
// If not, I don't know who wrote it.
//
// CMsgHook is a generic class for hooking another window's messages.

#include "StdAfx.h"
#include "MsgHook.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//////////////////
// The message hook map is derived from CMapPtrToPtr, which associates
// a pointer with another pointer. It maps an HWND to a CMsgHook, like
// the way MFC's internal maps map HWND's to CWnd's. The first hook
// attached to a window is stored in the map; all other hooks for that
// window are then chained via CMsgHook::m_pNext.
//
class CMsgHookMap : private CMapPtrToPtr {
public:
    CMsgHookMap();
    ~CMsgHookMap();
    static CMsgHookMap& GetHookMap();
    void Add(HWND hwnd, CMsgHook* pMsgHook);
    void Remove(CMsgHook* pMsgHook);
    void RemoveAll(HWND hwnd);
    CMsgHook* Lookup(HWND hwnd);
};

// This trick is used so the hook map isn't
// instantiated until someone actually requests it.
//
#define    theHookMap    (CMsgHookMap::GetHookMap())

IMPLEMENT_DYNAMIC(CMsgHook, CWnd);

CMsgHook::CMsgHook()
{
    m_pNext = NULL;
    m_pOldWndProc = NULL;    
    m_pWndHooked  = NULL;
}

CMsgHook::~CMsgHook()
{
    ASSERT(m_pWndHooked==NULL);        // can't destroy while still hooked!
    ASSERT(m_pOldWndProc==NULL);
}

#ifdef _DIALER_MSGHOOK_SUPPORT
//////////////////
// Hook a window.
// This installs a new window proc that directs messages to the CMsgHook.
// pWnd=NULL to remove.
//
BOOL CMsgHook::HookWindow(CWnd* pWnd)
{
    if (pWnd) {
        // Hook the window
        ASSERT(m_pWndHooked==NULL);
        //TRACE("%s::HookWindow(%s)\n",
        //    GetRuntimeClass()->m_lpszClassName, DbgName(pWnd));
        HWND hwnd = pWnd->m_hWnd;
        ASSERT(hwnd && ::IsWindow(hwnd));
        theHookMap.Add(hwnd, this);            // Add to map of hooks

    } else {
        // Unhook the window
        ASSERT(m_pWndHooked!=NULL);
        TRACE("%s::HookWindow(NULL) [unhook 0x%04x]\n",
            GetRuntimeClass()->m_lpszClassName, m_pWndHooked->GetSafeHwnd());
        theHookMap.Remove(this);                // Remove from map
        m_pOldWndProc = NULL;
    }
    m_pWndHooked = pWnd;
    return TRUE;
}
#endif _DIALER_MSGHOOK_SUPPORT

//////////////////
// Window proc-like virtual function which specific CMsgHooks will
// override to do stuff. Default passes the message to the next hook; 
// the last hook passes the message to the original window.
// You MUST call this at the end of your WindowProc if you want the real
// window to get the message. This is just like CWnd::WindowProc, except that
// a CMsgHook is not a window.
//
LRESULT CMsgHook::WindowProc(UINT msg, WPARAM wp, LPARAM lp)
{
    ASSERT(m_pOldWndProc);
    return m_pNext ? m_pNext->WindowProc(msg, wp, lp) :    
        ::CallWindowProc(m_pOldWndProc, m_pWndHooked->m_hWnd, msg, wp, lp);
}

//////////////////
// Like calling base class WindowProc, but with no args, so individual
// message handlers can do the default thing. Like CWnd::Default
//
LRESULT CMsgHook::Default()
{
    // MFC stores current MSG in thread state
    MSG& curMsg = AfxGetThreadState()->m_lastSentMsg;
    // Note: must explicitly call CMsgHook::WindowProc to avoid infinte
    // recursion on virtual function
    return CMsgHook::WindowProc(curMsg.message, curMsg.wParam, curMsg.lParam);
}

//////////////////
// Subclassed window proc for message hooks. Replaces AfxWndProc (or whatever
// else was there before.)
//
LRESULT CALLBACK
HookWndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
#ifdef _USRDLL
    // If this is a DLL, need to set up MFC state
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
#endif

    // Set up MFC message state just in case anyone wants it
    // This is just like AfxCallWindowProc, but we can't use that because
    // a CMsgHook is not a CWnd.
    //
    MSG& curMsg = AfxGetThreadState()->m_lastSentMsg;
    MSG  oldMsg = curMsg;   // save for nesting
    curMsg.hwnd        = hwnd;
    curMsg.message = msg;
    curMsg.wParam  = wp;
    curMsg.lParam  = lp;

    // Get hook object for this window. Get from hook map
    CMsgHook* pMsgHook = theHookMap.Lookup(hwnd);
    //ASSERT(pMsgHook);

    //
    // We really should verify if pMsgHook is valid pointer
    //

    if( NULL == pMsgHook )
    {
        return 0;
    }

    LRESULT lr;
    if (msg==WM_NCDESTROY) {
        // Window is being destroyed: unhook all hooks (for this window)
        // and pass msg to orginal window proc
        //
        WNDPROC wndproc = pMsgHook->m_pOldWndProc;
        theHookMap.RemoveAll(hwnd);
        lr = ::CallWindowProc(wndproc, hwnd, msg, wp, lp);

    } else {
        // pass to msg hook
        lr = pMsgHook->WindowProc(msg, wp, lp);
    }
    curMsg = oldMsg;            // pop state
    return lr;
}

////////////////////////////////////////////////////////////////
// CMsgHookMap implementation

CMsgHookMap::CMsgHookMap()
{
}

CMsgHookMap::~CMsgHookMap()
{
    ASSERT(IsEmpty());    // all hooks should be removed!    
}

//////////////////
// Get the one and only global hook map
// 
CMsgHookMap& CMsgHookMap::GetHookMap()
{
    // By creating theMap here, C++ doesn't instantiate it until/unless
    // it's ever used! This is a good trick to use in C++, to
    // instantiate/initialize a static object the first time it's used.
    //
    static CMsgHookMap theMap;
    return theMap;
}

/////////////////
// Add hook to map; i.e., associate hook with window
//
void CMsgHookMap::Add(HWND hwnd, CMsgHook* pMsgHook)
{
    ASSERT(hwnd && ::IsWindow(hwnd));

    // Add to front of list
    pMsgHook->m_pNext = Lookup(hwnd);
    SetAt(hwnd, pMsgHook);
    
    if (pMsgHook->m_pNext==NULL) {
        // If this is the first hook added, subclass the window
        pMsgHook->m_pOldWndProc = 
            (WNDPROC)SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)HookWndProc);

    } else {
        // just copy wndproc from next hook
        pMsgHook->m_pOldWndProc = pMsgHook->m_pNext->m_pOldWndProc;
    }
    ASSERT(pMsgHook->m_pOldWndProc);
}

//////////////////
// Remove hook from map
//
void CMsgHookMap::Remove(CMsgHook* pUnHook)
{
    HWND hwnd = pUnHook->m_pWndHooked->GetSafeHwnd();
    ASSERT(hwnd && ::IsWindow(hwnd));

    if( (hwnd == NULL) || (!::IsWindow(hwnd)) )
    {
        return;
    }

    CMsgHook* pHook = Lookup(hwnd);
    //ASSERT(pHook);
    //
    // We have to verify if pHook is a valid pointer
    //

    if( NULL == pHook)
    {
        return;
    }

    if (pHook==pUnHook) {
        // hook to remove is the one in the hash table: replace w/next
        if (pHook->m_pNext)
            SetAt(hwnd, pHook->m_pNext);
        else {
            // This is the last hook for this window: restore wnd proc
            RemoveKey(hwnd);
            SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR) pHook->m_pOldWndProc);
        }
    } else {
        // Hook to remove is in the middle: just remove from linked list
        while (pHook->m_pNext!=pUnHook)
            pHook = pHook->m_pNext;
        ASSERT(pHook && pHook->m_pNext==pUnHook);
        pHook->m_pNext = pUnHook->m_pNext;
    }
}

//////////////////
// Remove all the hooks for a window
//
void CMsgHookMap::RemoveAll(HWND hwnd)
{
    CMsgHook* pMsgHook;
    while ((pMsgHook = Lookup(hwnd))!=NULL)
        pMsgHook->HookWindow(NULL);    // (unhook)
}

/////////////////
// Find first hook associate with window
//
CMsgHook* CMsgHookMap::Lookup(HWND hwnd)
{
    CMsgHook* pFound = NULL;
    if (!CMapPtrToPtr::Lookup(hwnd, (void*&)pFound))
        return NULL;
    ASSERT_KINDOF(CMsgHook, pFound);
    return pFound;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\mainfrm.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////
// MainFrm.cpp : implementation of the CMainFrame class
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <HtmlHelp.h>
#include "avDialer.h"
#include "MainFrm.h"
#include "dialerdlg.h"
#include "bitmenu.h"
#include "callctrlwnd.h"
#include "callmgr.h"
#include "SpeedDlgs.h"
#include "avdialervw.h"
#include "util.h"
#include "sound.h"
#include "resolver.h"
#include "dialsel.h"
#include "AboutDlg.h"

// Setup wizard sheets

#ifndef _MSLITE
#include "Splash.h"
#include "RemindDlgs.h"
#include "SetupWiz.h"
#endif //_MSLITE

#ifndef _MSLITE
#include "OptGeneral.h"
#include "OptConfirm.h"
#include "OptSounds.h"
#include "OptCalls.h"
#include "OptHoldXfer.h"
#include "OptVCard.h"
#endif //_MSLITE

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static TCHAR szX[] = _T("wndX");
static TCHAR szY[] = _T("wndY");
static TCHAR szCX[] = _T("wndCX");
static TCHAR szCY[] = _T("wndCY");

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Defines
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#define TRAYICON_LBUTTON_TIMER           1
#define TRAYICON_RBUTTON_TIMER           2
#define TRAYICON_LBUTTON_INTERVAL        400   //milliseconds
#define TRAYICON_RBUTTON_INTERVAL        400   //milliseconds

#define TRAYLEFT                         0
#define TRAYRIGHT                        1
#define TRAYLEFT_REDIAL_OFFSET_NORMAL    3
#define TRAYLEFT_SPEEDDIAL_OFFSET_NORMAL 4
#define TRAYLEFT_REDIAL_OFFSET_ACTIVE    4
#define TRAYLEFT_SPEEDDIAL_OFFSET_ACTIVE 5

//Defined in document class. 
//#define CALLCONTROL_HOVER_TIMER        4

#define DIALER_HEARTBEAT_TIMER           5
#define DIALER_HEARTBEAT_TIMER_INTERVAL  30000     //HeartBeat every 30 seconds

#define SPEEDDIAL_MENU_MAX_ITEMS         20

/////////////////////////////////////////////////////////////////////////////
//Owner-Drawn Menu ID's
#define  EXPLORERFRAME_BITMAPMENUITEMS_MAX               22
#define  EXPLORERFRAME_BITMAPMENUITEMS_CHECKMARK_POS     0
#define  EXPLORERFRAME_BITMAPMENUITEMS_RADIO_POS         1

#define DIALERVIEW_BITMAPMENUITEMS_POTS_POS             11
#define DIALERVIEW_BITMAPMENUITEMS_INTERNET_POS         12
#define DIALERVIEW_BITMAPMENUITEMS_CONFERENCE_POS       13

#define  SPEEDDIAL_MENU_MAX_ITEMS                        20

BitmapMenuItem ExplorerFrameBitmapMenuItems[EXPLORERFRAME_BITMAPMENUITEMS_MAX] =
{
   { ID_BUTTON_DIRECTORY_NEWCONTACT,               2 },
   { ID_BUTTON_DIRECTORY_DETAILS,                  3 },
   { ID_BUTTON_DIRECTORY_FIND,                     4 },
   { ID_BUTTON_DIRECTORY_WAB,                      5 },
   { ID_BUTTON_DIRECTORY_SERVICES,                 6 },
   { ID_BUTTON_REFRESH,                               7 },
   { ID_BUTTON_SPEEDDIAL_ADD,                      8 },
   { ID_BUTTON_SPEEDDIAL_EDIT,                     9 },
   { ID_BUTTON_OPTIONS,                            10 },
   { ID_BUTTON_MAKECALL,                           11 },

   { ID_BUTTON_ROOM_DISCONNECT,                    14 },
   { ID_BUTTON_ROOM_MINIMIZE,                      15 }, 
   { ID_BUTTON_ROOM_PREVIEW,                       16 }, 
   { ID_BUTTON_ROOM_VIDEO,                         17 }, 

   { ID_BUTTON_SERVICES_DETAILS,                   18 }, 
   { ID_BUTTON_SERVICES_FIND,                      19 }, 
   { ID_BUTTON_SERVICES_SERVERS,                   20 }, 
   { ID_BUTTON_CONFERENCE_CREATE,                  21 }, 
   { ID_BUTTON_CONFERENCE_JOIN,                    22 }, 
   { ID_BUTTON_REMINDER_SET,                       23 }, 
   { ID_BUTTON_CONFERENCE_EDIT,                    24 }, 
};

static UINT indicators[] =
{
    ID_SEPARATOR,           // status line indicator
};


/////////////////////////////////////////////////////////////////////////////
//Owner-Drawn Menu ID's
#define  TRAY_BITMAPMENUITEMS_CHECKMARK_POS     0
#define  TRAY_BITMAPMENUITEMS_POTS_POS          1
#define  TRAY_BITMAPMENUITEMS_INTERNET_POS      7
#define  TRAY_BITMAPMENUITEMS_CONFERENCE_POS    8

#define  TRAY_BITMAPMENUITEMS_MAX               7
BitmapMenuItem DialerViewBitmapMenuItems[TRAY_BITMAPMENUITEMS_MAX] =
{
   { ID_BUTTON_MAKECALL,            1 },
   { ID_BUTTON_CONFERENCEEXPLORE,   4 },
   { ID_TRAY_STATE,                 5 },     //For left side sliding
   { ID_BUTTON_SPEEDDIAL_EDIT,      9 },
   { ID_TRAY_STATE_SHOW,            10 },    //For left side sliding
   { ID_TRAY_STATE_RIGHT,           11 },    //For right side sliding
   { ID_TRAY_STATE_SHOW_RIGHT,      12 },    //For right side sliding
};

// Register a window message for the taskbar callback notifications
const UINT    s_uTaskBarNotifyMsg = RegisterWindowMessage(__TEXT("DialerTaskBarNotify"));
const UINT    s_uTaskBarCreated = RegisterWindowMessage(__TEXT("TaskbarCreated"));
     


HRESULT get_Tapi(IAVTapi **ppAVTapi )
{
    HRESULT hr = E_FAIL;

    CMainFrame *pMainFrame = (CMainFrame *) AfxGetMainWnd();
    if ( pMainFrame )
    {
        *ppAVTapi = pMainFrame->GetTapi();
        if ( *ppAVTapi ) hr = S_OK;
    }
    
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Local Functions
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

void SetMenuData( HMENU hMenu, DWORD dwData )
{
   int nMenuCount = ::GetMenuItemCount( hMenu );
   while ( nMenuCount > 0 )
   {
      nMenuCount--;

      MENUITEMINFO mInf = { 0 };
      mInf.cbSize = sizeof( mInf );
      mInf.fMask = MIIM_SUBMENU;
      GetMenuItemInfo( hMenu, nMenuCount, TRUE, &mInf );

      // Recurse if necessary
      if ( mInf.hSubMenu )
         SetMenuData( mInf.hSubMenu, dwData );

      mInf.dwItemData = dwData;
      mInf.fMask = MIIM_DATA;
      SetMenuItemInfo( hMenu, nMenuCount, TRUE, &mInf );
   }
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CMainFrame
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
    //{{AFX_MSG_MAP(CMainFrame)
    ON_WM_CREATE()
    ON_WM_CLOSE()
    ON_MESSAGE(WM_TRAY_NOTIFICATION,OnTrayNotification)
    ON_MESSAGE(WM_ACTIVEDIALER_INTERFACE_MAKECALL,OnActiveDialerInterfaceMakeCall)
    ON_MESSAGE(WM_ACTIVEDIALER_INTERFACE_REDIAL,OnActiveDialerInterfaceRedial)
    ON_MESSAGE(WM_ACTIVEDIALER_INTERFACE_SPEEDDIAL,OnActiveDialerInterfaceSpeedDial)
    ON_MESSAGE(WM_ACTIVEDIALER_INTERFACE_SHOWEXPLORER,OnActiveDialerInterfaceShowExplorer)
    ON_MESSAGE(WM_ACTIVEDIALER_INTERFACE_SPEEDDIALEDIT,OnActiveDialerInterfaceSpeedDialEdit)
    ON_MESSAGE(WM_ACTIVEDIALER_INTERFACE_SPEEDDIALMORE,OnActiveDialerInterfaceSpeedDialMore)
    ON_MESSAGE(WM_USERUSER_DIALOG, OnUserUserDialog)
    ON_MESSAGE(WM_ACTIVEDIALER_SPLASHSCREENDONE,OnSplashScreenDone)
    ON_MESSAGE(WM_UPDATEALLVIEWS, OnUpdateAllViews )
    ON_WM_TIMER()
    ON_COMMAND(ID_TRAY_STATE, OnTrayState)
    ON_WM_MEASUREITEM()
    ON_WM_DRAWITEM()
    ON_COMMAND(ID_BUTTON_MAKECALL, OnButtonMakecall)
    ON_COMMAND(ID_BUTTON_REDIAL, OnButtonRedial)
    ON_COMMAND(ID_BUTTON_OPTIONS, OnButtonOptions)
    ON_COMMAND(ID_BUTTON_SPEEDDIAL, OnButtonSpeeddial)
    ON_COMMAND(ID_BUTTON_SPEEDDIAL_EDIT, OnButtonSpeeddialEdit)
    ON_COMMAND(ID_BUTTON_SPEEDDIAL_MORE, OnButtonSpeeddialMore)
    ON_COMMAND(ID_BUTTON_CONFERENCEEXPLORE, OnButtonConferenceexplore)
    ON_COMMAND(ID_BUTTON_EXITDIALER, OnButtonExitdialer)
    ON_COMMAND(ID_BUTTON_ROOM_PREVIEW, OnButtonRoomPreview)
    ON_UPDATE_COMMAND_UI(ID_BUTTON_ROOM_PREVIEW, OnUpdateButtonRoomPreview)
    ON_UPDATE_COMMAND_UI(ID_BUTTON_EXITDIALER, OnUpdateButtonExitdialer)
    ON_COMMAND(ID_BUTTON_TELEPHONYSERVICES, OnButtonTelephonyservices)
    ON_MESSAGE(WM_DIALERVIEW_CREATECALLCONTROL,OnCreateCallControl)
    ON_MESSAGE(WM_DIALERVIEW_DESTROYCALLCONTROL,OnDestroyCallControl)
    ON_MESSAGE(WM_DIALERVIEW_SHOWEXPLORER,OnShowDialerExplorer)
    ON_MESSAGE(WM_DIALERVIEW_ERRORNOTIFY,OnActiveDialerErrorNotify)
    ON_COMMAND(ID_TOOLBAR_TEXT, OnToolbarText)
    ON_UPDATE_COMMAND_UI(ID_TOOLBAR_TEXT, OnUpdateToolbarText)
    ON_COMMAND(ID_VIEW_TOOLBARS, OnViewToolbars)
    ON_UPDATE_COMMAND_UI(ID_VIEW_TOOLBARS, OnUpdateViewToolbars)
    ON_COMMAND(ID_VIEW_STATUSBAR, OnViewStatusbar)
    ON_UPDATE_COMMAND_UI(ID_VIEW_STATUSBAR, OnUpdateViewStatusbar)
    ON_UPDATE_COMMAND_UI(ID_DIALER_MRU_REDIAL_START, OnUpdateDialerMruRedialStart)
    ON_UPDATE_COMMAND_UI(ID_DIALER_MRU_SPEEDDIAL_START, OnUpdateDialerMruSpeeddialStart)
    ON_WM_PARENTNOTIFY()
    ON_COMMAND(ID_BUTTON_CLOSEEXPLORER, OnButtonCloseexplorer)
    ON_UPDATE_COMMAND_UI(ID_BUTTON_REDIAL, OnUpdateButtonMakecall)
    ON_COMMAND(ID_VIEW_LOG, OnViewLog)
    ON_UPDATE_COMMAND_UI(ID_WINDOW_WINDOWS_START, OnUpdateWindowWindows)
    ON_MESSAGE(WM_ACTIVEDIALER_CALLCONTROL_CHECKSTATES, OnCheckCallControlStates )
    ON_MESSAGE(WM_ACTIVEDIALER_INTERFACE_RESOLVEUSER, OnActiveDialerInterfaceResolveUser)
    ON_WM_ENABLE()
    ON_COMMAND(ID_CALLWINDOW_HIDE, OnCallwindowHide)
    ON_UPDATE_COMMAND_UI(ID_CALLWINDOW_HIDE, OnUpdateCallwindowHide)
    ON_COMMAND(ID_CALLWINDOW_SHOW, OnCallwindowShow)
    ON_UPDATE_COMMAND_UI(ID_CALLWINDOW_SHOW, OnUpdateCallwindowShow)
    ON_COMMAND(ID_BUTTON_CONFERENCE_JOIN, OnButtonConferenceJoin)
    ON_UPDATE_COMMAND_UI(ID_BUTTON_CONFERENCE_JOIN, OnUpdateButtonConferenceJoin)
    ON_COMMAND(ID_BUTTON_ROOM_DISCONNECT, OnButtonRoomDisconnect)
    ON_UPDATE_COMMAND_UI(ID_BUTTON_ROOM_DISCONNECT, OnUpdateButtonRoomDisconnect)
    ON_COMMAND(ID_HIDE_WHEN_MINIMIZED, OnHideWhenMinimized)
    ON_UPDATE_COMMAND_UI(ID_HIDE_WHEN_MINIMIZED, OnUpdateHideWhenMinimized)
    ON_WM_SIZE()
    ON_COMMAND(ID_BUTTON_DIRECTORY_SERVICES_ADDSERVER, OnButtonDirectoryAddilsserver)
    ON_UPDATE_COMMAND_UI(ID_BUTTON_DIRECTORY_SERVICES_ADDSERVER, OnUpdateButtonDirectoryAddilsserver)
    ON_COMMAND(ID_CALLWINDOW_ALWAYSONTOP, OnCallwindowAlwaysontop)
    ON_UPDATE_COMMAND_UI(ID_CALLWINDOW_ALWAYSONTOP, OnUpdateCallwindowAlwaysontop)
    ON_COMMAND(ID_CALLWINDOW_SLIDESIDE_LEFT, OnCallwindowSlidesideLeft)
    ON_UPDATE_COMMAND_UI(ID_CALLWINDOW_SLIDESIDE_LEFT, OnUpdateCallwindowSlidesideLeft)
    ON_COMMAND(ID_CALLWINDOW_SLIDESIDE_RIGHT, OnCallwindowSlidesideRight)
    ON_UPDATE_COMMAND_UI(ID_CALLWINDOW_SLIDESIDE_RIGHT, OnUpdateCallwindowSlidesideRight)
    ON_COMMAND(ID_CONFGROUP_FULLSIZEVIDEO, OnConfgroupFullsizevideo)
    ON_UPDATE_COMMAND_UI(ID_CONFGROUP_FULLSIZEVIDEO, OnUpdateConfgroupFullsizevideo)
    ON_COMMAND(ID_CONFGROUP_SHOWNAMES, OnConfgroupShownames)
    ON_UPDATE_COMMAND_UI(ID_CONFGROUP_SHOWNAMES, OnUpdateConfgroupShownames)
    ON_UPDATE_COMMAND_UI(ID_BUTTON_OPTIONS, OnUpdateButtonOptions)
    ON_COMMAND(ID_WINDOWS_ALWAYSCLOSECALLWINDOWS, OnWindowsAlwaysclosecallwindows)
    ON_UPDATE_COMMAND_UI(ID_WINDOWS_ALWAYSCLOSECALLWINDOWS, OnUpdateWindowsAlwaysclosecallwindows)
    ON_WM_DESTROY()
    ON_COMMAND_EX(ID_VIEW_SELECTEDCONFERENCEVIDEOSCALE_100, OnViewSelectedconferencevideoscale)
    ON_UPDATE_COMMAND_UI(ID_VIEW_SELECTEDCONFERENCEVIDEOSCALE_100, OnUpdateViewSelectedconferencevideoscale)
    ON_MESSAGE(WM_DOCHINT, OnDocHint)
    ON_WM_ENDSESSION()
    ON_COMMAND(ID_TRAY_STATE_RIGHT, OnTrayState)
    ON_COMMAND(ID_TRAY_STATE_SHOW, OnTrayState)
    ON_COMMAND(ID_TRAY_STATE_SHOW_RIGHT, OnTrayState)
    ON_UPDATE_COMMAND_UI(ID_BUTTON_SPEEDDIAL, OnUpdateButtonMakecall)
    ON_UPDATE_COMMAND_UI(ID_BUTTON_MAKECALL, OnUpdateButtonMakecall)
    ON_COMMAND_EX(ID_VIEW_SELECTEDCONFERENCEVIDEOSCALE_200, OnViewSelectedconferencevideoscale)
    ON_UPDATE_COMMAND_UI(ID_VIEW_SELECTEDCONFERENCEVIDEOSCALE_200, OnUpdateViewSelectedconferencevideoscale)
    ON_COMMAND_EX(ID_VIEW_SELECTEDCONFERENCEVIDEOSCALE_400, OnViewSelectedconferencevideoscale)
    ON_UPDATE_COMMAND_UI(ID_VIEW_SELECTEDCONFERENCEVIDEOSCALE_400, OnUpdateViewSelectedconferencevideoscale)
    ON_WM_SHOWWINDOW()
    //}}AFX_MSG_MAP
    ON_COMMAND_RANGE(ID_DIALER_MRU_REDIAL_START,ID_DIALER_MRU_REDIAL_END,OnDialerRedial)
    ON_COMMAND_RANGE(ID_DIALER_MRU_SPEEDDIAL_START,ID_DIALER_MRU_SPEEDDIAL_END,OnButtonSpeeddial)
    ON_COMMAND_RANGE(ID_WINDOW_WINDOWS_START,ID_WINDOW_WINDOWS_END,OnWindowWindowsSelect)
    ON_NOTIFY_RANGE(TBN_DROPDOWN,0,0xffff,OnToolBarDropDown)
    // Global help commands
    ON_COMMAND(ID_HELP_FINDER, CFrameWnd::OnHelpFinder)
    ON_COMMAND(ID_HELP, CFrameWnd::OnHelp)
    ON_COMMAND(ID_CONTEXT_HELP, CFrameWnd::OnContextHelp)
    ON_COMMAND(ID_DEFAULT_HELP, CFrameWnd::OnHelpFinder)
    ON_REGISTERED_MESSAGE(s_uTaskBarNotifyMsg, OnTaskBarCallbackMsg)
    ON_REGISTERED_MESSAGE(s_uTaskBarCreated, OnTaskBarCreated)
    ON_MESSAGE(WM_USBPHONE, OnUSBPhone)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
CMainFrame::CMainFrame() :
   m_trayIcon( IDR_TRAY_NORMAL )
{
    m_bCanSaveDesktop = false;
    m_bCanExitApplication = TRUE;

    m_hTrayMenu = NULL;
    m_nLButtonTimer = 0;
    m_bKillNextLButton = FALSE;
    m_nRButtonTimer = 0;
    m_bKillNextRButton = FALSE;
    m_wpTrayId = 0;

    m_pSpeedDialEditDlg = NULL;
    CString sRegKey;

#ifndef _MSLITE
    m_pOptionsSheet = NULL;

    // Should we show the setup wizard?
    sRegKey.LoadString(IDN_REGISTRY_DIALER_SHOWSETUPWIZARD);
    m_bShowSetupWizard = AfxGetApp()->GetProfileInt(_T(""),sRegKey,TRUE);
#endif //_MSLITE

    // Conference explorer initializations
    m_nCurrentExplorerToolBar = ETB_BLANK;
    m_bShutdown = FALSE;

    m_hImlTrayMenu = NULL;
    m_hImageListMenu = NULL;

    m_nDisabledImageOffset = -1;
    m_hmenuCurrentPopupMenu = NULL;
    m_uHeartBeatTimer = 0;

    m_nCurrentDayOfWeek = -1;

    //get text label state from registry
    CString sDialerExplorer;
    sDialerExplorer.LoadString(IDN_REGISTRY_DIALEREXPLORER_KEY);

    //get the toolbar text, toolbar state, and status bar
    CWinApp *pApp = AfxGetApp();
    sRegKey.LoadString(IDN_REGISTRY_DIALEREXPLORER_TOOLBARTEXTLABELS);
    m_bShowToolBarText = pApp->GetProfileInt(sDialerExplorer,sRegKey,TRUE);

    sRegKey.LoadString(IDN_REGISTRY_DIALEREXPLORER_SHOWTOOLBARS);
    m_bShowToolBars = pApp->GetProfileInt(sDialerExplorer,sRegKey,TRUE);

    sRegKey.LoadString(IDN_REGISTRY_DIALEREXPLORER_SHOWSTATUSBAR);
    m_bShowStatusBar = pApp->GetProfileInt(sDialerExplorer,sRegKey,TRUE);

    sRegKey.LoadString( IDN_REGISTRY_DIALEREXPLORER_HIDEWHENMINIMIZED );
    m_bHideWhenMinimized = pApp->GetProfileInt(sDialerExplorer, sRegKey, FALSE );
}

/////////////////////////////////////////////////////////////////////////////
CMainFrame::~CMainFrame()
{
   //save the toolbar text, toolbar state, and status bar
   CString sDialerExplorer,sRegKey;
   sDialerExplorer.LoadString(IDN_REGISTRY_DIALEREXPLORER_KEY);

   CWinApp *pApp = AfxGetApp();
   sRegKey.LoadString(IDN_REGISTRY_DIALEREXPLORER_TOOLBARTEXTLABELS);
   pApp->WriteProfileInt(sDialerExplorer,sRegKey,m_bShowToolBarText);

   sRegKey.LoadString(IDN_REGISTRY_DIALEREXPLORER_SHOWTOOLBARS);
   pApp->WriteProfileInt(sDialerExplorer,sRegKey,m_bShowToolBars);

   sRegKey.LoadString(IDN_REGISTRY_DIALEREXPLORER_SHOWSTATUSBAR);
   pApp->WriteProfileInt(sDialerExplorer,sRegKey,m_bShowStatusBar);

    sRegKey.LoadString( IDN_REGISTRY_DIALEREXPLORER_HIDEWHENMINIMIZED );
    pApp->WriteProfileInt(sDialerExplorer, sRegKey, m_bHideWhenMinimized );


   ClearMenuMaps();
}

CActiveDialerDoc* CMainFrame::GetDocument() const
{
   if ( !GetActiveView() ) return NULL;
   ASSERT( GetActiveView()->GetDocument()->IsKindOf(RUNTIME_CLASS(CActiveDialerDoc)) );
   return (CActiveDialerDoc *) GetActiveView()->GetDocument();
}

IAVTapi* CMainFrame::GetTapi()
{
    CActiveDialerDoc *pDoc = GetDocument();
    return ( pDoc ) ? pDoc->GetTapi() : NULL;
}


/////////////////////////////////////////////////////////////////////////////
int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
        return -1;

   // Load Image lists
   m_hImageListMenu = ImageList_LoadBitmap(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDB_MENU_DIRECTORY),16,0,RGB_TRANS);
   m_hImlTrayMenu = ImageList_LoadBitmap(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDB_MENU_TRAY),16,0,RGB_TRANS);
   if ( !m_hImageListMenu || !m_hImlTrayMenu )
      return -1;

   // Make disabled state image list
   m_nDisabledImageOffset = ImageList_GetImageCount(m_hImageListMenu);
   m_bmpImageDisabledMenu.LoadBitmap(IDB_MENU_DIRECTORY);
   HBITMAP hbmpDisabled = CBitmapMenu::GetDisabledBitmap(m_bmpImageDisabledMenu,RGB_TRANS,RGB_TRANS);
   ImageList_AddMasked(m_hImageListMenu,hbmpDisabled,RGB_TRANS);

    if ( !CreateExplorerMenusAndBars(lpCreateStruct) )
        return -1;

#ifndef _MSLITE
    if (CSplashWnd::IsSplashScreenEnable())
   {
      //show splash screen.  Splash will send a message back when it's done
      CSplashWnd::ShowSplashScreen(this);
   }
   else
   {
      PostMessage(WM_ACTIVEDIALER_SPLASHSCREENDONE);
   }
#else
      PostMessage(WM_ACTIVEDIALER_SPLASHSCREENDONE);
#endif //_MSLITE

      // Set up tray icon
    m_trayIcon.SetNotificationWnd(this, WM_TRAY_NOTIFICATION);
    m_trayIcon.SetIcon(IDR_TRAY_NORMAL);

   m_uHeartBeatTimer = SetTimer( DIALER_HEARTBEAT_TIMER,DIALER_HEARTBEAT_TIMER_INTERVAL,NULL ); 

   CString sTitle;
   sTitle.LoadString(IDS_APPLICATION_TITLE_DESCRIPTION);
   SetWindowText(sTitle);

   //#APPBAR
   //register us as an appbar.  We need this for the sliders.
   APPBARDATA abd;
   memset(&abd,0,sizeof(APPBARDATA));
   abd.cbSize = sizeof(APPBARDATA);
   abd.hWnd = GetSafeHwnd();
   abd.uCallbackMessage = s_uTaskBarNotifyMsg;
   ::SHAppBarMessage(ABM_NEW,&abd);
   //#APPBAR

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
LRESULT CMainFrame::OnSplashScreenDone(WPARAM wParam,LPARAM lParam)
{
#ifndef _MSLITE
   if ( (m_bShowSetupWizard) && (ShowSetupWizard()) )
   {
      //success, we don't need to do this again
      CString sRegKey;
      sRegKey.LoadString(IDN_REGISTRY_DIALER_SHOWSETUPWIZARD);
      AfxGetApp()->WriteProfileInt(_T(""),sRegKey,FALSE);
   }
#endif //_MSLITE

   //show the preview window
   CActiveDialerDoc* pDoc = GetDocument();
   if ( (pDoc) && (pDoc->IsPreviewWindowVisible() == FALSE) )
   {
      // Show the preview window on start
      CString sBaseKey,sRegKey;
      sBaseKey.LoadString(IDN_REGISTRY_AUDIOVIDEO_BASEKEY);
   }

#ifndef _MSLITE
    //if no splash and we want the explorer to show
    if ( (CSplashWnd::IsSplashScreenEnable() == FALSE) && (CSplashWnd::m_bShowMainWindowOnClose) )
        ShowWindow(SW_NORMAL);
#else
    //show explorer
    ShowWindow( SW_SHOWDEFAULT );
#endif //_MSLITE
    
    return 0;
}

/////////////////////////////////////////////////////////////////////////////
void CMainFrame::OnClose() 
{
    // This flag indicates if it is okay to try and exit the application
    m_bCanExitApplication = FALSE;

    //If there are existing calls.  Let's confirm they want to close
    CActiveDialerDoc* pDoc = (CActiveDialerDoc *) GetDocument();

    if ( (pDoc) && (pDoc->GetCallControlWindowCount(DONT_INCLUDE_PREVIEW, ASK_TAPI) > 0) )
    {
        SetFocus();
        if (AfxMessageBox(IDS_CONFIRM_SHUTDOWN_CALLSINPROGRESS,MB_YESNO|MB_ICONQUESTION) != IDYES)
        {
            m_bCanExitApplication = TRUE;
            return;
        }
    }
    else
    {
        // Check registry to see if we should confirm the exit request.
        UINT nConfirm = 1;
        CWinApp *pWinApp = AfxGetApp();
        CString sRegKey;
        try
        {
            sRegKey.LoadString(IDN_REGISTRY_CONFIRM_EXIT);
            if ( pWinApp )
                nConfirm = pWinApp->GetProfileInt(_T(""), sRegKey,  TRUE );
        }
        catch(...){}


        // Show dialog in case that user wants confirmation
        INT_PTR nRet = IDOK;
        if ( nConfirm == TRUE )
        {
            CDialerExitDlg dlg;
            if ( (nRet = dlg.DoModal()) == IDOK )
            {
                // Store "Don't show dialog" checkbox setting in registry
                if ( pWinApp && (sRegKey.GetLength() > 0) )
                    pWinApp->WriteProfileInt(_T(""), sRegKey, (UINT) !dlg.m_bConfirm );
            }
        }

        // Does the user want to exit?
        if ( nRet != IDOK )
        {
            m_bCanExitApplication = TRUE;
            return;
        }
    }

    ////////////////////////////////////////////////////////
    // Basic cleanup
    //
    ActiveClearSound();
    SaveDesktop();
    //
    // Validate pointer returned by GetDocument()
    //

    if( pDoc )
        pDoc->DestroyAllCallControlWindows();

    if (m_uHeartBeatTimer)
    {
        KillTimer(m_uHeartBeatTimer);
        m_uHeartBeatTimer = 0;
    }

    // Shutdown application help    
    HtmlHelp( m_hWnd, NULL, HH_CLOSE_ALL,  0 );

    /*
    //#APPBAR
    //unregister us as an appbar
    APPBARDATA abd;
    memset(&abd,0,sizeof(APPBARDATA));
    abd.cbSize = sizeof(APPBARDATA);
    abd.hWnd = GetSafeHwnd();
    ::SHAppBarMessage(ABM_REMOVE,&abd);
    //#APPBAR
    */

    CFrameWnd::OnClose();
}

/////////////////////////////////////////////////////////////////////////////
void CMainFrame::OnButtonExitdialer() 
{
    PostMessage(WM_CLOSE);    
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics
/////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
    CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
    CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
void CMainFrame::ActivateFrame(int nCmdShow) 
{
    //CFrameWnd::ActivateFrame(nCmdShow);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//TrayIcon Support
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
LRESULT CMainFrame::OnTrayNotification(WPARAM uID, LPARAM lEvent)
{
    if ( !GetDocument() || (uID != IDR_TRAY_NORMAL)) return 0;

   //Double left click results in a leftup, leftdouble, and leftup.  This makes the leftup
   //think it needs to display the leftup menu, so leftdouble actually flicker's a menu.  To
   //get rid of this, we will start a timer on leftup and if no leftdouble comes within x milliseconds
   //the go with leftup, otherwise pass leftdouble and cancel next leftup.
   //hack or not a hack
   LRESULT lRet = 0;

   switch ( lEvent )
   {
      case WM_LBUTTONDOWN:
         // save mouse position for later
         GetCursorPos( &m_ptMouse );
         break;

      case WM_LBUTTONUP:
         //Check if modal dialog is up
         if (m_bCanExitApplication == FALSE)
         {
            MessageBeep(-1);
            return 0;
         }

         if (m_bKillNextLButton)
         {
            m_bKillNextLButton = FALSE;   
         }
         else
         {
            m_wpTrayId = uID;
            m_nLButtonTimer = SetTimer(TRAYICON_LBUTTON_TIMER,TRAYICON_LBUTTON_INTERVAL,NULL); 
         }
         break;

        case WM_LBUTTONDBLCLK:
            //Check if modal dialog is up
            if (m_bCanExitApplication == FALSE)
            {
                MessageBeep(-1);
                return 0;
            }

            //Cancel timer (cancel lbuttonup)
            KillTimer(m_nLButtonTimer);
            m_nLButtonTimer = 0;
            m_bKillNextLButton = TRUE;

            //handle it ourselves
            {
                //
                // Validate pointer returned by GetDocument()
                //

                CWnd* pMainWnd = AfxGetMainWnd();
                BOOL bVisible = FALSE;

                if( pMainWnd )
                    bVisible = pMainWnd->IsWindowVisible();

                Show();

                //
                // Validate pointer returned by GetDocument()
                //

                CActiveDialerDoc* pDoc = GetDocument();

                if( pDoc )
                {
                    if ( pDoc->GetCallControlWindowCount(DONT_INCLUDE_PREVIEW, ASK_TAPI) )
                    {
                        if ( bVisible )
                            pDoc->ToggleCallControlWindowsVisible();
                        else
                            pDoc->UnhideCallControlWindows();
                    }
                }
            }
            break;
      
      case WM_RBUTTONUP:
         //Check if modal dialog is up
         if (m_bCanExitApplication == FALSE)
         {
            MessageBeep(-1);
            return 0;
         }

         //handle it ourselves

         // save mouse position for later
         GetCursorPos( &m_ptMouse );

         ShowTrayMenu();
         /* Uncomment if you need rbuttondlbclk
         if (m_bKillNextRButton)
         {
            m_bKillNextRButton = FALSE;   
         }
         else
         {
            m_wpTrayId = uID;
            m_nRButtonTimer = SetTimer(TRAYICON_RBUTTON_TIMER,TRAYICON_RBUTTON_INTERVAL,NULL); 
         }*/
         break;
   
      /* Uncomment if you need rbuttondlbclk
      case WM_RBUTTONDBLCLK:
         //Cancel timer (cancel rbuttonup)
         KillTimer(m_nRButtonTimer);
         m_nRButtonTimer = 0;
         m_bKillNextRButton = TRUE;

         // let tray icon do default stuff
         lRet = m_pTrayIcon->OnTrayNotification(uID, lEvent);
         break;*/

      default:
         // let tray icon do default stuff
         lRet = m_trayIcon.OnTrayNotification(uID, lEvent);
         break;
   }

   return lRet;
}

/////////////////////////////////////////////////////////////////////////////
void CMainFrame::OnTimer(UINT nIDEvent) 
{
   switch ( nIDEvent )
   {
      case TRAYICON_LBUTTON_TIMER:
         //timer expired, send lbuttonup
         KillTimer(m_nLButtonTimer);
         m_nLButtonTimer = 0;
         ShowTrayMenu();
         break;
      
      case TRAYICON_RBUTTON_TIMER:
         //timer expired, send lbuttonup
         //KillTimer(m_nRButtonTimer);
         //m_nRButtonTimer = 0;
         break;

      case CALLCONTROL_HOVER_TIMER:
          {
            //
            // Validate pointer returned by GetDocument()
            //

            CActiveDialerDoc* pDoc = GetDocument();
            if ( pDoc )
                pDoc->CheckCallControlHover();
          }
         break;
      case DIALER_HEARTBEAT_TIMER:
         HeartBeat();
         break;
   }
}


/////////////////////////////////////////////////////////////////////////////
void CMainFrame::ShowTrayMenu()
{
   CActiveDialerDoc* pDoc = GetDocument();
   if (pDoc == NULL) return;

   CMenu menu;

   //do we have active calls
   BOOL bActiveCalls = (BOOL) (pDoc->GetCallControlWindowCount(DONT_INCLUDE_PREVIEW, DONT_ASK_TAPI) > 0);

   UINT nMenu = (bActiveCalls) ? IDR_TRAY_ACTIVE : IDR_TRAY_NORMAL;
    if ( !menu.LoadMenu(nMenu) ) return;

   CMenu* pSubMenu = menu.GetSubMenu(TRAYRIGHT);
   if (!pSubMenu) return;

   //Active call menu has changing menu items
   if (bActiveCalls)
   {
      CString sMenuText;
      if (pDoc->IsCallControlWindowsVisible())
      {
         UINT uId = ID_TRAY_STATE;
         UINT uSlideSide = pDoc->GetCallControlSlideSide();
         if (uSlideSide == CALLWND_SIDE_LEFT)
            uId = ID_TRAY_STATE;
         else if (uSlideSide == CALLWND_SIDE_RIGHT)
            uId = ID_TRAY_STATE_RIGHT;

         sMenuText.LoadString(IDS_TRAY_ACTIVE_HIDE);
         pSubMenu->ModifyMenu(ID_TRAY_STATE,MF_BYCOMMAND|MF_STRING,uId,sMenuText);
      }
      else
      {
         UINT uId = ID_TRAY_STATE_SHOW;
         UINT uSlideSide = pDoc->GetCallControlSlideSide();
         if (uSlideSide == CALLWND_SIDE_LEFT)
            uId = ID_TRAY_STATE_SHOW;
         else if (uSlideSide == CALLWND_SIDE_RIGHT)
            uId = ID_TRAY_STATE_SHOW_RIGHT;

         sMenuText.LoadString(IDS_TRAY_ACTIVE_SHOW);
         pSubMenu->ModifyMenu(ID_TRAY_STATE,MF_BYCOMMAND|MF_STRING,uId,sMenuText);
      }
   }

   // Make first menu item the default (bold font)
    ::SetMenuDefaultItem(pSubMenu->m_hMenu, 0, TRUE);

   if (pDoc->m_bInitDialer)
   {
      //Add Redial List Popup Menu
      AddDialListMenu(pSubMenu,TRUE,(bActiveCalls)?TRAYLEFT_REDIAL_OFFSET_ACTIVE:
                                                TRAYLEFT_REDIAL_OFFSET_NORMAL);

      //Add SpeedDial List Popup Menu
      AddDialListMenu(pSubMenu,FALSE,(bActiveCalls)?TRAYLEFT_SPEEDDIAL_OFFSET_ACTIVE:
                                                 TRAYLEFT_SPEEDDIAL_OFFSET_NORMAL);
   }
   else
   {
      // disable all tapi related Menu IDs
      pSubMenu->EnableMenuItem( ID_BUTTON_MAKECALL, MF_BYCOMMAND | MF_GRAYED );
      pSubMenu->EnableMenuItem( 1, MF_BYPOSITION | MF_GRAYED );
      pSubMenu->EnableMenuItem( 2, MF_BYPOSITION | MF_GRAYED );
   }
   
   CBitmapMenu::MakeMenuOwnerDrawn(pSubMenu->GetSafeHmenu(),TRUE);

   // Display the menu at the current mouse location. There's a "bug"
    // (Microsoft calls it a feature) in Windows 95 that requires calling
    // SetForegroundWindow. To find out more, search for Q135788 in MSDN.

   DoMenuUpdate(pSubMenu);

   m_hTrayMenu = pSubMenu->GetSafeHmenu();

   // Set all of the item data to IDR_TRAY_NORMAL, so when we owner draw the
   // item, we know where it came from
   SetMenuData( m_hTrayMenu, IDR_TRAY_NORMAL  );

    ::SetForegroundWindow(this->GetSafeHwnd());    
    ::TrackPopupMenu(pSubMenu->m_hMenu, TPM_BOTTOMALIGN, m_ptMouse.x, m_ptMouse.y, 0,this->GetSafeHwnd(), NULL);
   ::PostMessage(this->GetSafeHwnd(), WM_NULL, 0, 0);
}

void CMainFrame::DoMenuUpdate(CMenu* pMenu)
{
   CCmdUI state;
   state.m_pMenu = pMenu;
   state.m_pParentMenu = pMenu;           //parent == child for tracking popup
   state.m_nIndexMax = pMenu->GetMenuItemCount();

   for (state.m_nIndex = 0; state.m_nIndex < state.m_nIndexMax;state.m_nIndex++)
    {
      state.m_nID = pMenu->GetMenuItemID(state.m_nIndex);

      if (state.m_nID == 0)
           continue;                           //menu separator or invalid cmd - ignore it

      if (state.m_nID != (UINT)-1)
       {
           state.m_pSubMenu = NULL;
           state.DoUpdate(this, TRUE && state.m_nID < 0xF000);
      }
   }
}

/////////////////////////////////////////////////////////////////////////////
void CMainFrame::OnTrayState() 
{
   //
   // Validate pointer returned by GetDocument()
   //

   CActiveDialerDoc* pDoc = GetDocument();
   if ( pDoc ) pDoc->ToggleCallControlWindowsVisible();
}

/////////////////////////////////////////////////////////////////////////////
void CMainFrame::AddDialListMenu(CMenu* pParentMenu,BOOL bRedial,int nSubMenuOffset)
{
   //This offset is HARDCODED, make sure it's set to the appropriate offset
   CMenu* pRedialMenu = pParentMenu->GetSubMenu(nSubMenuOffset);
   if (pRedialMenu)
   {
      //Remove placeholder
      if (bRedial)
         pRedialMenu->RemoveMenu(ID_DIALER_MRU_REDIAL_START,MF_BYCOMMAND);
      else
         pRedialMenu->RemoveMenu(ID_DIALER_MRU_SPEEDDIAL_START,MF_BYCOMMAND);

      int nIndex = 0;
      CCallEntry callentry;
      while (CDialerRegistry::GetCallEntry(nIndex+1,bRedial,callentry))
      {
         //Iterate through MEDIATYPES
         UINT nImage = -1;
         switch (callentry.m_MediaType)
         {
            case DIALER_MEDIATYPE_POTS:         nImage = TRAY_BITMAPMENUITEMS_POTS_POS;         break;
            case DIALER_MEDIATYPE_CONFERENCE:   nImage = TRAY_BITMAPMENUITEMS_CONFERENCE_POS;   break;
            case DIALER_MEDIATYPE_INTERNET:     nImage = TRAY_BITMAPMENUITEMS_INTERNET_POS;     break;
         }
         //map id of menu to image index
         UINT uBaseId = (bRedial)?ID_DIALER_MRU_REDIAL_START:ID_DIALER_MRU_SPEEDDIAL_START;
         m_mapTrayMenuIdToImage.SetAt(uBaseId+nIndex,(void*)(LONG_PTR)nImage);

         //Add to menu
         pRedialMenu->InsertMenu(-1,MF_BYPOSITION|MF_STRING,uBaseId+nIndex,callentry.m_sDisplayName);

         if (nIndex == SPEEDDIAL_MENU_MAX_ITEMS)
            break;

         nIndex++;
      }
 
      //If no items have been added we need to ensure a single item with the base id is present in
      //the menu.  We use this id as a event notificator when the menu is about to be shown so we
      //can dynamically add entries.
      if (nIndex == 0)
      {
         CString sOut;
         sOut.LoadString(IDS_SPEEDDIAL_REDIAL_EMTPY);
         if (bRedial)
            pRedialMenu->InsertMenu(-1,MF_BYPOSITION|MF_STRING,ID_DIALER_MRU_REDIAL_START,sOut);
         else
            pRedialMenu->InsertMenu(-1,MF_BYPOSITION|MF_STRING,ID_DIALER_MRU_SPEEDDIAL_START,sOut);
      }
      
      //if speeddial then we need a more... and edit speeddial list entry
      if (bRedial == FALSE)
      {
         if (nIndex >= SPEEDDIAL_MENU_MAX_ITEMS)
         {
            //Add to menu
            CString sText;
            sText.LoadString(IDS_SPEEDDIAL_MORE);
            pRedialMenu->InsertMenu(-1,MF_BYPOSITION|MF_SEPARATOR);
            pRedialMenu->InsertMenu(-1,MF_BYPOSITION|MF_STRING,ID_BUTTON_SPEEDDIAL_MORE,sText);
         }
         //Add to menu
         CString sText;
         sText.LoadString(IDS_SPEEDDIAL_EDIT);
         pRedialMenu->InsertMenu(-1,MF_BYPOSITION|MF_SEPARATOR);
         pRedialMenu->InsertMenu(-1,MF_BYPOSITION|MF_STRING,ID_BUTTON_SPEEDDIAL_EDIT,sText);
      }
   }
}

/////////////////////////////////////////////////////////////////////////////
void CMainFrame::OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMIS)
{
   if ( lpMIS->itemData == IDR_TRAY_NORMAL )
   {
      MeasureTrayItem( nIDCtl, lpMIS ); 
      return;
   }

   // Normal menus
   HMENU hmenu = NULL;
   if (m_hmenuCurrentPopupMenu)
   {
     hmenu = m_hmenuCurrentPopupMenu;
   }
   else
   {
      CMenu* pMenu = GetMenu();
      if (pMenu==NULL) return;
      hmenu = pMenu->GetSafeHmenu();
   }
   if (hmenu == NULL) return;

   MENUITEMINFO menuiteminfo;
   memset(&menuiteminfo,0,sizeof(MENUITEMINFO));
   menuiteminfo.fMask = MIIM_SUBMENU|MIIM_TYPE|MIIM_ID;
   menuiteminfo.cbSize = sizeof(MENUITEMINFO);
   if (::GetMenuItemInfo(hmenu,lpMIS->itemID,FALSE,&menuiteminfo))
   {
      if (menuiteminfo.cch > 0)  //cch doesn't include & or other key chr's, so add a bit 
      {
         LPTSTR szText = new TCHAR[menuiteminfo.cch+5];     //1 for null terminate plus a few extra
         memset(szText,0,(menuiteminfo.cch+5)*sizeof(TCHAR));
         ::GetMenuString(hmenu,lpMIS->itemID,szText,menuiteminfo.cch+4,MF_BYCOMMAND);
      
         //pass to CBitmapMenu handler
         CBitmapMenu::DoMeasureItem(nIDCtl,lpMIS,szText);

         delete szText;
      }

     //
     // Clean-up MENUITEMINFO
     //

     if( menuiteminfo.hbmpChecked )
         DeleteObject( menuiteminfo.hbmpChecked );
     if( menuiteminfo.hbmpItem )
         DeleteObject( menuiteminfo.hbmpItem );
     if( menuiteminfo.hbmpUnchecked )
         DeleteObject( menuiteminfo.hbmpUnchecked );
   }
}

/////////////////////////////////////////////////////////////////////////////
void CMainFrame::OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDIS)
{
   if ( lpDIS->itemData == IDR_TRAY_NORMAL )
   {
      DrawTrayItem( nIDCtl, lpDIS );
      return;
   }

   // Standard menus
   HMENU hmenu = NULL;
   if (m_hmenuCurrentPopupMenu)
   {
     hmenu = m_hmenuCurrentPopupMenu;
   }
   else
   {
      CMenu* pMenu = GetMenu();
      if (pMenu==NULL) return;
      hmenu = pMenu->GetSafeHmenu();
   }
   if (hmenu == NULL) return;

   MENUITEMINFO menuiteminfo;
   memset(&menuiteminfo,0,sizeof(MENUITEMINFO));
   menuiteminfo.fMask = MIIM_SUBMENU|MIIM_TYPE|MIIM_ID|MIIM_CHECKMARKS;
   menuiteminfo.cbSize = sizeof(MENUITEMINFO);
   if (::GetMenuItemInfo(hmenu,lpDIS->itemID,FALSE,&menuiteminfo))
  {
      if (menuiteminfo.cch > 0)  //cch doesn't include & or other key chr's, so add a bit 
      {
         LPTSTR szText = new TCHAR[menuiteminfo.cch+5];     //1 for null terminate plus a few extra
         memset(szText,0,(menuiteminfo.cch+5)*sizeof(TCHAR));
         ::GetMenuString(hmenu,lpDIS->itemID,szText,menuiteminfo.cch+4,MF_BYCOMMAND);

         int nIndex = -1;
         m_mapMenuIdToImage.Lookup((WORD) lpDIS->itemID,(void*&)nIndex);

         //maybe it's a redial or speeddial
         if (nIndex == -1)
            m_mapRedialIdToImage.Lookup((WORD) lpDIS->itemID,(void*&)nIndex);
         if (nIndex == -1)
            m_mapSpeeddialIdToImage.Lookup((WORD) lpDIS->itemID,(void*&)nIndex);

         //if a check menu item, than goto check image (which is stored in image position 0)
         if (lpDIS->itemState & ODS_CHECKED)
         {
            if (menuiteminfo.hbmpChecked != NULL)
            //if (menuiteminfo.fType & MFT_RADIOCHECK )
               nIndex = EXPLORERFRAME_BITMAPMENUITEMS_RADIO_POS;
            else
               nIndex = EXPLORERFRAME_BITMAPMENUITEMS_CHECKMARK_POS;
         }

         //if disabled, then offer disabled images
         if ( (lpDIS->itemState & ODS_DISABLED) && (nIndex != -1) )
         {
            nIndex += m_nDisabledImageOffset;
         }

         //pass to CBitmapMenu handler
         CBitmapMenu::DoDrawItem(nIDCtl,lpDIS,m_hImageListMenu,nIndex,szText);

         delete szText;
      }

     //
     // Clean-up MENUITEMINFO
     //

     if( menuiteminfo.hbmpChecked )
         DeleteObject( menuiteminfo.hbmpChecked );
     if( menuiteminfo.hbmpItem )
         DeleteObject( menuiteminfo.hbmpItem );
     if( menuiteminfo.hbmpUnchecked )
         DeleteObject( menuiteminfo.hbmpUnchecked );

   }
}

void CMainFrame::DrawTrayItem(int nIDCtl, LPDRAWITEMSTRUCT lpDIS)
{
   MENUITEMINFO menuiteminfo;
   memset(&menuiteminfo,0,sizeof(MENUITEMINFO));
   menuiteminfo.fMask = MIIM_SUBMENU|MIIM_TYPE|MIIM_ID;
   menuiteminfo.cbSize = sizeof(MENUITEMINFO);
   if (::GetMenuItemInfo(m_hTrayMenu,lpDIS->itemID,FALSE,&menuiteminfo))
   {
      if (menuiteminfo.cch > 0)  //cch doesn't include & or other key chr's, so add a bit 
      {
         LPTSTR szText = new TCHAR[menuiteminfo.cch+5];     //1 for null terminate plus a few extra
         memset(szText,0,(menuiteminfo.cch+5)*sizeof(TCHAR));
         ::GetMenuString(m_hTrayMenu,lpDIS->itemID,szText,menuiteminfo.cch+4,MF_BYCOMMAND);

         int nIndex = -1;
         m_mapTrayMenuIdToImage.Lookup((WORD) lpDIS->itemID,(void*&)nIndex);

         //if a check menu item, than goto check image (which is stored in image position 0)
         if (lpDIS->itemState & ODS_CHECKED)
            nIndex = TRAY_BITMAPMENUITEMS_CHECKMARK_POS;

         //pass to CBitmapMenu handler
         CBitmapMenu::DoDrawItem(nIDCtl,lpDIS,m_hImlTrayMenu,nIndex,szText);

         delete szText;
      }
   }
   return;
}

/////////////////////////////////////////////////////////////////////////////
void CMainFrame::MeasureTrayItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMIS)
{
   MENUITEMINFO menuiteminfo;
   memset(&menuiteminfo,0,sizeof(MENUITEMINFO));
   menuiteminfo.fMask = MIIM_SUBMENU|MIIM_TYPE|MIIM_ID;
   menuiteminfo.cbSize = sizeof(MENUITEMINFO);
   if (::GetMenuItemInfo(m_hTrayMenu,lpMIS->itemID,FALSE,&menuiteminfo))
   {
      if (menuiteminfo.cch > 0)  //cch doesn't include & or other key chr's, so add a bit 
      {
         LPTSTR szText = new TCHAR[menuiteminfo.cch+5];     //1 for null terminate plus a few extra
         memset(szText,0,(menuiteminfo.cch+5)*sizeof(TCHAR));
         ::GetMenuString(m_hTrayMenu,lpMIS->itemID,szText,menuiteminfo.cch+4,MF_BYCOMMAND);
      
         //pass to CBitmapMenu handler
         CBitmapMenu::DoMeasureItem(nIDCtl,lpMIS,szText);

         delete szText;
      }
   }
   return;
}

/////////////////////////////////////////////////////////////////////////////
void CMainFrame::LoadMenuMaps()
{
   int i;

   // TRAY items
   for (i=0;i<TRAY_BITMAPMENUITEMS_MAX;i++)
   {
      m_mapTrayMenuIdToImage.SetAt((WORD) DialerViewBitmapMenuItems[i].uMenuId,
                               (void*)(LONG_PTR)DialerViewBitmapMenuItems[i].nImageId);
   }

   // MainFrame items
   for (i=0;i<EXPLORERFRAME_BITMAPMENUITEMS_MAX;i++)
   {
      m_mapMenuIdToImage.SetAt((WORD) ExplorerFrameBitmapMenuItems[i].uMenuId,
                               (void*)(LONG_PTR)ExplorerFrameBitmapMenuItems[i].nImageId);
   }
}

/////////////////////////////////////////////////////////////////////////////
void CMainFrame::ClearMenuMaps()
{
   m_mapTrayMenuIdToImage.RemoveAll();
   m_mapMenuIdToImage.RemoveAll();
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//DeskBand Support
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
LRESULT CMainFrame::OnActiveDialerInterfaceMakeCall(WPARAM wParam,LPARAM lParam)
{
   ASSERT(lParam);
   CCallEntry* pCallEntry = (CCallEntry*)lParam;
   OnButtonMakecall( pCallEntry, FALSE );
   delete pCallEntry;
   return 0;
}

/////////////////////////////////////////////////////////////////////////////
LRESULT CMainFrame::OnActiveDialerInterfaceRedial(WPARAM wParam,LPARAM lParam)
{
   OnDialerRedial( (UINT) (lParam + ID_DIALER_MRU_REDIAL_START) );
   return 0;
}

/////////////////////////////////////////////////////////////////////////////
LRESULT CMainFrame::OnActiveDialerInterfaceSpeedDial(WPARAM wParam,LPARAM lParam)
{
   OnButtonSpeeddial( (UINT) (lParam + ID_DIALER_MRU_SPEEDDIAL_START) );
   return 0;
}

/////////////////////////////////////////////////////////////////////////////
LRESULT CMainFrame::OnActiveDialerInterfaceShowExplorer(WPARAM wParam,LPARAM lParam)
{
   Show();
   return 0;
}

/////////////////////////////////////////////////////////////////////////////
LRESULT CMainFrame::OnActiveDialerInterfaceSpeedDialEdit(WPARAM wParam,LPARAM lParam)
{
   OnButtonSpeeddialEdit();
   return 0;
}

/////////////////////////////////////////////////////////////////////////////
LRESULT CMainFrame::OnActiveDialerInterfaceSpeedDialMore(WPARAM wParam,LPARAM lParam)
{
   OnButtonSpeeddialMore();
   return 0;
}

/////////////////////////////////////////////////////////////////////////////
LRESULT CMainFrame::OnActiveDialerInterfaceResolveUser(WPARAM wParam,LPARAM lParam)
{
   BOOL bRet = FALSE;
   //lParam is a ResolveUserObjectList
   //wParam is a CCallEntry
   ASSERT(lParam);
   ASSERT(wParam);
   CObList* pList = (CObList*)lParam;
   CCallEntry* pCallEntry = (CCallEntry*)wParam;

   CDialSelectAddress dlg;
   dlg.SetResolveUserObjectList(pList);
   dlg.SetCallEntry(pCallEntry);
   if (dlg.DoModal() == IDOK)
   {
      bRet = TRUE;
   }
   return (LRESULT)bRet;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Setup Wizard
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#ifndef _MSLITE
/////////////////////////////////////////////////////////////////////////////
BOOL CMainFrame::ShowSetupWizard()
{
   BOOL bRet = FALSE;

   CString sHeading;
   sHeading.LoadString(IDS_SHEET_SETUPWIZARD_HEADING);
   CSetupWizardSheet* pSheet = new CSetupWizardSheet(sHeading);

   CSetupWizardWelcomePage* pWelcomePage = new CSetupWizardWelcomePage();
   pWelcomePage->m_psp.dwFlags &= ~PSP_HASHELP;
   pWelcomePage->SetSheet(pSheet);

   CSetupWizardStartupPage* pStartupPage = new CSetupWizardStartupPage();
   pStartupPage->m_psp.dwFlags &= ~PSP_HASHELP;
   pStartupPage->SetSheet(pSheet);

   CSetupWizardUserInfo1Page* pUserInfo1Page = new CSetupWizardUserInfo1Page();
   pUserInfo1Page->m_psp.dwFlags &= ~PSP_HASHELP;
   pUserInfo1Page->SetSheet(pSheet);

   CSetupWizardUserInfo2Page* pUserInfo2Page = new CSetupWizardUserInfo2Page();
   pUserInfo2Page->m_psp.dwFlags &= ~PSP_HASHELP;
   pUserInfo2Page->SetSheet(pSheet);

   CSetupWizardToolbarPage* pToolbarPage = new CSetupWizardToolbarPage();
   pToolbarPage->m_psp.dwFlags &= ~PSP_HASHELP;
   pToolbarPage->SetSheet(pSheet);

   CSetupWizardCompletePage* pCompletePage = new CSetupWizardCompletePage();
   pCompletePage->m_psp.dwFlags &= ~PSP_HASHELP;
   pCompletePage->SetSheet(pSheet);

   pSheet->AddPage(pWelcomePage);
   pSheet->AddPage(pStartupPage);
   pSheet->AddPage(pUserInfo1Page);
   pSheet->AddPage(pUserInfo2Page);
   pSheet->AddPage(pToolbarPage);
   pSheet->AddPage(pCompletePage);
   pSheet->SetWizardMode();

   m_bCanExitApplication = FALSE;
   
   pSheet->m_psh.dwFlags &= ~PSH_HASHELP;
   pSheet->m_psh.dwFlags |= PSH_NOAPPLYNOW;
   if (pSheet->DoModal() == ID_WIZFINISH)
   {
      bRet = TRUE;
   }
   
   m_bCanExitApplication = TRUE;
   
   delete pWelcomePage;
   delete pStartupPage;
   delete pUserInfo1Page;
   delete pUserInfo2Page;
   delete pToolbarPage;
   delete pCompletePage;
   delete pSheet;

   // Initially show the explorer view
   Show();

   return bRet;
}
#endif //_MSLITE

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Button Handlers
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
void CMainFrame::OnButtonConferenceexplore() 
{
   Show();
}

/////////////////////////////////////////////////////////////////////////////
void CMainFrame::OnButtonSpeeddial() 
{
   //speeddial first entry
   CCallEntry callentry;
   if (CDialerRegistry::GetCallEntry(1,FALSE,callentry))
   {
      OnButtonMakecall(&callentry,FALSE);
   }

}

/////////////////////////////////////////////////////////////////////////////
void CMainFrame::OnButtonSpeeddial(UINT nID) 
{
   int nIndex = -1;
   if ( (nID >= ID_DIALER_MRU_SPEEDDIAL_START) &&
        (nID <= ID_DIALER_MRU_SPEEDDIAL_END) )
   {
      //Normalize the value
      nIndex = nID - ID_DIALER_MRU_SPEEDDIAL_START + 1;

      CCallEntry callentry;
      if (CDialerRegistry::GetCallEntry(nIndex,FALSE,callentry))
      {
         OnButtonMakecall(&callentry,FALSE);
      }
   }
}

/////////////////////////////////////////////////////////////////////////////
void CMainFrame::OnButtonRedial() 
{
   //redial first entry
   CCallEntry callentry;
   if (CDialerRegistry::GetCallEntry(1,TRUE,callentry))
   {
      OnButtonMakecall(&callentry,FALSE);
   }
}

/////////////////////////////////////////////////////////////////////////////
void CMainFrame::OnDialerRedial(UINT nID)
{
   int nIndex = -1;
   if ( (nID >= ID_DIALER_MRU_REDIAL_START) &&
        (nID <= ID_DIALER_MRU_REDIAL_END) )
   {
      //Normalize the value
      nIndex = nID - ID_DIALER_MRU_REDIAL_START + 1;
      
      CCallEntry callentry;
      if (CDialerRegistry::GetCallEntry(nIndex,TRUE,callentry))
      {
         OnButtonMakecall(&callentry,FALSE);
      }
   }
}

/////////////////////////////////////////////////////////////////////////////
void CMainFrame::OnButtonMakecall() 
{
   CCallEntry callentry;
   callentry.m_lAddressType = LINEADDRESSTYPE_IPADDRESS;
   callentry.m_MediaType = DIALER_MEDIATYPE_UNKNOWN;
   OnButtonMakecall(&callentry,TRUE);
}

/////////////////////////////////////////////////////////////////////////////
void CMainFrame::OnButtonMakecall(CCallEntry* pCallentry,BOOL bShowPlaceCallDialog)
{
   if ( !GetDocument() ) return;
   GetDocument()->MakeCall(pCallentry,bShowPlaceCallDialog);
   return;
}

/////////////////////////////////////////////////////////////////////////////
void CMainFrame::OnButtonSpeeddialEdit() 
{
   if (m_pSpeedDialEditDlg)
   {
      try
      {
         m_pSpeedDialEditDlg->ShowWindow(SW_NORMAL);    
         m_pSpeedDialEditDlg->SetForegroundWindow();
      }
      catch (...) {}
   }
   else
   {
      m_pSpeedDialEditDlg = new CSpeedDialEditDlg( this );
      m_pSpeedDialEditDlg->DoModal();
      delete m_pSpeedDialEditDlg;
      m_pSpeedDialEditDlg = NULL;
   }
}

/////////////////////////////////////////////////////////////////////////////
void CMainFrame::OnButtonSpeeddialMore() 
{
   if (m_pSpeedDialEditDlg)
   {
      try
      {
         m_pSpeedDialEditDlg->ShowWindow(SW_NORMAL);    
         m_pSpeedDialEditDlg->SetForegroundWindow();
      }
      catch (...) {}
   }
   else
   {
      CSpeedDialMoreDlg* pDlg = new CSpeedDialMoreDlg( this );
      m_pSpeedDialEditDlg = pDlg;

      INT_PTR nRet = m_pSpeedDialEditDlg->DoModal();
      if (nRet == CSpeedDialMoreDlg::SDRETURN_PLACECALL)
      {
         OnButtonMakecall(&pDlg->m_retCallEntry,TRUE);
         delete m_pSpeedDialEditDlg;
         m_pSpeedDialEditDlg = NULL;
      }
      else if (nRet == CSpeedDialMoreDlg::SDRETURN_EDIT)
      {
         delete m_pSpeedDialEditDlg;

         m_pSpeedDialEditDlg = new CSpeedDialEditDlg( this );
         m_pSpeedDialEditDlg->DoModal();
         delete m_pSpeedDialEditDlg;
         m_pSpeedDialEditDlg = NULL;
      }
   }
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Preview window
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

void CMainFrame::OnButtonRoomPreview() 
{
   CActiveDialerDoc* pDoc = GetDocument();
   if (pDoc)
   {
      if (pDoc->IsPreviewWindowVisible())
         pDoc->ShowPreviewWindow(FALSE);
      else
         pDoc->ShowPreviewWindow(TRUE);
   }
}


/////////////////////////////////////////////////////////////////////////////
void CMainFrame::OnUpdateButtonRoomPreview(CCmdUI* pCmdUI) 
{
    bool bEnable = false;
    bool bCheck = false;

    CActiveDialerDoc *pDoc = GetDocument();
    if ( pDoc && pDoc->GetCallControlWindowCount(DONT_INCLUDE_PREVIEW, DONT_ASK_TAPI) > 0 ) 
    {
        bEnable = true;
        if ( pDoc->IsPreviewWindowVisible() )
            bCheck = true;
    }

    pCmdUI->Enable( bEnable );
    //pCmdUI->SetCheck( bCheck );
}

/////////////////////////////////////////////////////////////////////////////
void CMainFrame::OnButtonOptions() 
{
#ifdef _MSLITE
    OnButtonTelephonyservices();
    return;
#else
   //if already showing the dialog
   try
   {
      if (m_pOptionsSheet)
      {
         m_pOptionsSheet->ShowWindow(SW_NORMAL);    
         m_pOptionsSheet->SetForegroundWindow();
         return;
      }
   }
   catch (...) {}

   CString sHeading;
   sHeading.LoadString(IDS_SHEET_OPTIONS_HEADING);
   m_pOptionsSheet = new COptionsSheet(sHeading);

   COptionsPageGeneral* pGeneralPage = new COptionsPageGeneral();
   pGeneralPage->m_psp.dwFlags &= ~PSP_HASHELP;
   COptionsPageConfirm* pConfirmPage = new COptionsPageConfirm();
   pConfirmPage->m_psp.dwFlags &= ~PSP_HASHELP;
   COptionsPageSounds* pSoundsPage = new COptionsPageSounds();
   pSoundsPage->m_psp.dwFlags &= ~PSP_HASHELP;
   COptionsPageCalls* pCallsPage = new COptionsPageCalls();
   pCallsPage->m_psp.dwFlags &= ~PSP_HASHELP;
   COptionsPageHoldTransfer* pHoldTransferPage = new COptionsPageHoldTransfer();
   pHoldTransferPage->m_psp.dwFlags &= ~PSP_HASHELP;
   COptionsPageVCard* pVCardPage = new COptionsPageVCard();
   pVCardPage->m_psp.dwFlags &= ~PSP_HASHELP;
   COptionsPageVideo* pVideoPage = new COptionsPageVideo();
   pVideoPage->m_psp.dwFlags &= ~PSP_HASHELP;

   m_pOptionsSheet->AddPage(pGeneralPage);
   m_pOptionsSheet->AddPage(pConfirmPage);
   m_pOptionsSheet->AddPage(pSoundsPage);
   m_pOptionsSheet->AddPage(pCallsPage);
   m_pOptionsSheet->AddPage(pHoldTransferPage);
   m_pOptionsSheet->AddPage(pVCardPage);
   m_pOptionsSheet->AddPage(pVideoPage);

   m_pOptionsSheet->m_psh.dwFlags &= ~PSH_HASHELP;
   m_pOptionsSheet->m_psh.dwFlags |= PSH_NOAPPLYNOW;
   if (m_pOptionsSheet->DoModal() == IDOK)
   {

   }

   delete pGeneralPage;
   delete pConfirmPage;
   delete pSoundsPage;
   delete pCallsPage;
   delete pHoldTransferPage;
   delete pVCardPage;
   delete pVideoPage;

   delete m_pOptionsSheet;
   m_pOptionsSheet = NULL;
#endif
}

void CMainFrame::OnUpdateButtonOptions(CCmdUI* pCmdUI) 
{
   //
   // Validate pointer returned by GetDocument()
   //

   CActiveDialerDoc* pDoc = GetDocument();
    pCmdUI->Enable( (bool) (pDoc && pDoc->m_bInitDialer) );
}

/////////////////////////////////////////////////////////////////////////////
void CMainFrame::OnButtonTelephonyservices() 
{
   //
   // Validate pointer returned by GetDocument()
   //

   CActiveDialerDoc* pDoc = GetDocument();
   if ( !pDoc ) return;

   IAVTapi* pTapi = pDoc->GetTapi();
   if ( pTapi )
   {
      pTapi->ShowOptions();
      pTapi->Release();
   }
}

/////////////////////////////////////////////////////////////////////////////
void CMainFrame::OnUpdateButtonExitdialer(CCmdUI* pCmdUI) 
{
   if (m_bCanExitApplication)
      pCmdUI->Enable(TRUE);
   else
      pCmdUI->Enable(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Dialer Explorer View
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
LRESULT CMainFrame::OnShowDialerExplorer(WPARAM wParam,LPARAM lParam)
{
   Show( (bool) (lParam != 0) );
   return 0;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Error Logging
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
LRESULT CMainFrame::OnActiveDialerErrorNotify(WPARAM wParam,LPARAM lParam)
{  
   ASSERT(lParam);
   ErrorNotifyData* pErrorNotifyData = (ErrorNotifyData*)lParam;
   
   if (pErrorNotifyData->uErrorLevel & ERROR_NOTIFY_LEVEL_INTERNAL)
   {
      //map the lErrorCode to friendly name
      //we could use TAPIERROR_FORMATMESSAGE to map tapi errors, but this interferes with other
      //system errors, so we will just ignore tapi errors for now.
      CString sErrorCode;

      ::FormatMessage(    FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_FROM_HMODULE,
                        GetModuleHandle(_T("TAPI3.DLL")),
                        pErrorNotifyData->lErrorCode,
                        0,
                        sErrorCode.GetBuffer(512),
                        512,
                        NULL );
      sErrorCode.ReleaseBuffer();

      CString sFormat,sFormatOut;
      if (sErrorCode.IsEmpty())
      {
         sFormat.LoadString(IDS_ERROR_MESSAGEBOX_FORMAT2);
         sFormatOut.Format(sFormat,
               pErrorNotifyData->sOperation,
               pErrorNotifyData->sDetails);
      }
      else
      {
         sFormat.LoadString(IDS_ERROR_MESSAGEBOX_FORMAT3);
         sFormatOut.Format(sFormat,
               pErrorNotifyData->sOperation,
               pErrorNotifyData->sDetails,
               sErrorCode);
      }

      //show the message
      CWnd* pFrame = GetParentFrame();
      CString sCaption;
      sCaption.LoadString(IDS_ERROR_MESSAGEBOX_CAPTION);
      ::MessageBox(NULL,sFormatOut,sCaption,MB_OK|MB_ICONERROR|MB_TOPMOST);
   }
   delete pErrorNotifyData;
   return 0;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
LRESULT CMainFrame::OnCreateCallControl(WPARAM wParam,LPARAM lParam)
{
   //
   // Validate pointer returned by GetDocument()
   //

   CActiveDialerDoc* pDoc = GetDocument();
   if ( !pDoc ) return 0;

   WORD nCallId = (WORD) wParam;
   CallManagerMedia cmm = (CallManagerMedia)lParam;

   pDoc->OnCreateCallControl(nCallId,cmm);

   return 0;
}

/////////////////////////////////////////////////////////////////////////////
LRESULT CMainFrame::OnDestroyCallControl(WPARAM wParam,LPARAM lParam)
{
   //
   // Validate pointer returned by GetDocument()
   //

   CActiveDialerDoc* pDoc = GetDocument();
   if ( !pDoc ) return 0;
   CCallControlWnd* pCallWnd = (CCallControlWnd*)lParam;
   if (pCallWnd == NULL) return 0;
   
   pDoc->OnDestroyCallControl(pCallWnd);
   return 0;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CMainFrame::CreateExplorerMenusAndBars(LPCREATESTRUCT lpCreateStruct)
{
   //create the status bar
   if (!m_wndStatusBar.Create(this) ||
        !m_wndStatusBar.SetIndicators(indicators,
          sizeof(indicators)/sizeof(UINT)))
    {
        TRACE0("Failed to create status bar\n");
        return FALSE;      // fail to create
    }
   if (m_bShowStatusBar == FALSE) m_wndStatusBar.ShowWindow(SW_HIDE);

    // Create cool bar
   m_wndCoolBar.ShowTextLabel(m_bShowToolBarText);
    if (!m_wndCoolBar.Create(this,
        WS_CHILD|WS_VISIBLE|WS_BORDER|WS_CLIPSIBLINGS|WS_CLIPCHILDREN|
            RBS_TOOLTIPS|RBS_BANDBORDERS|RBS_VARHEIGHT)) {
        TRACE0("Failed to create cool bar\n");
        return FALSE;      // fail to create
    }

    ShowControlBar(&m_wndCoolBar, m_bShowToolBars, FALSE);
    ShowExplorerToolBar(ETB_HIDECALLS);

    // Bitmaps on the menus
    if ( GetMenu() )
    {
        LoadMenuMaps();
        CBitmapMenu::MakeMenuOwnerDrawn( GetMenu()->GetSafeHmenu(), FALSE );
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//ToolBar Management
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
void CMainFrame::ShowExplorerToolBar(ExplorerToolBar etb)
{
    if ( etb != m_nCurrentExplorerToolBar )
    {
        m_wndCoolBar.ReCreateBands( (bool) (etb == ETB_HIDECALLS) );
        m_nCurrentExplorerToolBar = etb;
    }

    ShowControlBar( &m_wndCoolBar, m_bShowToolBars, TRUE );
}

/////////////////////////////////////////////////////////////////////////////
void CMainFrame::LoadDesktop(LPCREATESTRUCT lpCreateStruct)
{
    CWinApp* pApp = AfxGetApp();
    CString sDialerExplorer;
    sDialerExplorer.LoadString( IDN_REGISTRY_DIALEREXPLORER_KEY );

    int nMaxCx = GetSystemMetrics( SM_CXFULLSCREEN );
    int nMaxCy = GetSystemMetrics( SM_CYFULLSCREEN );
    
    // We need to account for the user specifying startup window state via a shortcut.
    lpCreateStruct->x    = min(max(0, (int) pApp->GetProfileInt(sDialerExplorer, szX, 0)), (int) (nMaxCx * 0.9) );
    lpCreateStruct->y    = min(max(0, (int) pApp->GetProfileInt(sDialerExplorer, szY, 0)), (int) (nMaxCy * 0.9) );
    lpCreateStruct->cx    = max(GetSystemMetrics(SM_CXMIN), (int) pApp->GetProfileInt(sDialerExplorer, szCX, nMaxCx));
    lpCreateStruct->cy    = max(GetSystemMetrics(SM_CYMIN), (int) pApp->GetProfileInt(sDialerExplorer, szCY, nMaxCy));
}

/////////////////////////////////////////////////////////////////////////////
void CMainFrame::SaveDesktop()
{
    // This protects against starting and shutting down while minimized
    if ( !m_bCanSaveDesktop ) return;

    WINDOWPLACEMENT wp;
    wp.length = sizeof(WINDOWPLACEMENT);
    if ( !GetWindowPlacement(&wp) ) return;

    CString sDialerExplorer;
    sDialerExplorer.LoadString(IDN_REGISTRY_DIALEREXPLORER_KEY);

    CWinApp* pApp = AfxGetApp();
    if ( pApp )
    {
        pApp->WriteProfileInt(sDialerExplorer, szX,    wp.rcNormalPosition.left);
        pApp->WriteProfileInt(sDialerExplorer, szY,    wp.rcNormalPosition.top);
        pApp->WriteProfileInt(sDialerExplorer, szCX, wp.rcNormalPosition.right - wp.rcNormalPosition.left );
        pApp->WriteProfileInt(sDialerExplorer, szCY, wp.rcNormalPosition.bottom - wp.rcNormalPosition.top );
    }
}

////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
//Button Handlers
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////
void CMainFrame::OnToolbarText() 
{
   m_bShowToolBarText = !m_bShowToolBarText;

   //recreate all the bands with the proper text state
   m_wndCoolBar.ShowTextLabel(m_bShowToolBarText);
   m_wndCoolBar.ReCreateBands( (bool) (m_nCurrentExplorerToolBar == ETB_HIDECALLS) );
}

////////////////////////////////////////////////////////////////
void CMainFrame::OnUpdateToolbarText(CCmdUI* pCmdUI) 
{
   pCmdUI->SetCheck( m_bShowToolBars && m_bShowToolBarText );
}

////////////////////////////////////////////////////////////////
void CMainFrame::OnViewToolbars() 
{
    m_bShowToolBars = !m_bShowToolBars;
    ShowControlBar(&m_wndCoolBar, m_bShowToolBars, FALSE);
}

////////////////////////////////////////////////////////////////
void CMainFrame::OnUpdateViewToolbars(CCmdUI* pCmdUI) 
{
   pCmdUI->SetCheck( m_bShowToolBars );
}

void CMainFrame::OnHideWhenMinimized() 
{
    m_bHideWhenMinimized = !m_bHideWhenMinimized;
}

void CMainFrame::OnUpdateHideWhenMinimized(CCmdUI* pCmdUI) 
{
    pCmdUI->SetCheck( m_bHideWhenMinimized );
}


////////////////////////////////////////////////////////////////
void CMainFrame::OnViewStatusbar() 
{
   m_bShowStatusBar = !m_bShowStatusBar;
   ShowControlBar(&m_wndStatusBar, m_bShowStatusBar, FALSE);
}

////////////////////////////////////////////////////////////////
void CMainFrame::OnUpdateViewStatusbar(CCmdUI* pCmdUI) 
{
   pCmdUI->SetCheck( m_bShowStatusBar );
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Redial and Speedial
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
void CMainFrame::OnUpdateDialerMruRedialStart(CCmdUI* pCmdUI) 
{
   //Find ID_DIALER_MRU_REDIAL_START in menu
   //This is all hardcoded, so be careful when changing the menu's!!!!
   //Build up the menu
   CMenu* pMenu = GetMenu();
   if (!pMenu) return;

   CMenu* pSubMenu = pMenu->GetSubMenu(3);
   if (!pSubMenu) return;

   pSubMenu = pSubMenu->GetSubMenu(1);
   if (!pSubMenu) return;
   
   UINT uMenuId = pSubMenu->GetMenuItemID(0);

   if ( (uMenuId >= ID_DIALER_MRU_REDIAL_START) && (uMenuId <= ID_DIALER_MRU_REDIAL_END) )
   {
      //delete any existing menu
      while (pSubMenu->DeleteMenu(0,MF_BYPOSITION))
         1;

      m_mapRedialIdToImage.RemoveAll();

      LoadCallMenu(pSubMenu->GetSafeHmenu(),TRUE);

      CBitmapMenu::MakeMenuOwnerDrawn(pSubMenu->GetSafeHmenu(),TRUE);
   }
}

void CMainFrame::OnUpdateDialerMruSpeeddialStart(CCmdUI* pCmdUI) 
{
   //Find ID_DIALER_MRU_SPEEDDIAL_START in menu
   //This is all hardcoded, so be careful when changing the menu's!!!!
   //Build up the menu
   CMenu* pMenu = GetMenu();
   if (!pMenu) return;

   CMenu* pSubMenu = pMenu->GetSubMenu(3);
   if (!pSubMenu) return;

   pSubMenu = pSubMenu->GetSubMenu(2);
   if (!pSubMenu) return;
   
   UINT uMenuId = pSubMenu->GetMenuItemID(0);

   if ( (uMenuId >= ID_DIALER_MRU_SPEEDDIAL_START) && (uMenuId <= ID_DIALER_MRU_SPEEDDIAL_END) )
   {
      //delete any existing menu
      while (pSubMenu->DeleteMenu(0,MF_BYPOSITION))
         1;

      m_mapSpeeddialIdToImage.RemoveAll();

      LoadCallMenu(pSubMenu->GetSafeHmenu(),FALSE);

      CBitmapMenu::MakeMenuOwnerDrawn(pSubMenu->GetSafeHmenu(),TRUE);
   }
}

/////////////////////////////////////////////////////////////////////////////
BOOL CMainFrame::LoadCallMenu(HMENU hSubMenu,BOOL bRedial)
{
   ASSERT(hSubMenu);

   CString sAddress;
   long lAddressType = 0;
   int nIndex = 0;
   DialerMediaType MediaType = DIALER_MEDIATYPE_UNKNOWN;
   CString sDisplayName;
   CCallEntry callentry;
   while (CDialerRegistry::GetCallEntry(nIndex+1,bRedial,callentry))
   {
      //Iterate through MEDIATYPES
      UINT nImage = -1;
      switch (callentry.m_MediaType)
      {
         case DIALER_MEDIATYPE_POTS:         nImage = DIALERVIEW_BITMAPMENUITEMS_POTS_POS;         break;
         case DIALER_MEDIATYPE_CONFERENCE:   nImage = DIALERVIEW_BITMAPMENUITEMS_CONFERENCE_POS;   break;
         case DIALER_MEDIATYPE_INTERNET:     nImage = DIALERVIEW_BITMAPMENUITEMS_INTERNET_POS;     break;
      }
      //map id of menu to image index
      UINT uBaseId = (bRedial)?ID_DIALER_MRU_REDIAL_START:ID_DIALER_MRU_SPEEDDIAL_START;
      if (bRedial)
         m_mapRedialIdToImage.SetAt(uBaseId+nIndex,(void*)(LONG_PTR)nImage);
      else
         m_mapSpeeddialIdToImage.SetAt(uBaseId+nIndex,(void*)(LONG_PTR)nImage);

      if( bRedial )
      {
        ::InsertMenu(hSubMenu,-1,MF_BYPOSITION|MF_STRING,uBaseId+nIndex,callentry.m_sDisplayName); //(LPCTSTR)ID_DIALER_MRU_REDIAL_START+i);  //Insert at end
      }
      else
      {
        ::InsertMenu(hSubMenu,-1,MF_BYPOSITION|MF_STRING,uBaseId+nIndex,
            callentry.m_sDisplayName + CString(": ") + CString(callentry.m_sAddress));
      }

      if (nIndex == SPEEDDIAL_MENU_MAX_ITEMS)
         break;

      nIndex++;
   }

   //If no items have been added we need to ensure a single item with the base id is present in
   //the menu.  We use this id as a event notificator when the menu is about to be shown so we
   //can dynamically add entries.
   if (nIndex == 0)
   {
      CString sOut;
      sOut.LoadString(IDS_SPEEDDIAL_REDIAL_EMTPY);
      if (bRedial)
         ::InsertMenu(hSubMenu,-1,MF_BYPOSITION|MF_STRING,ID_DIALER_MRU_REDIAL_START,sOut);
      else
         ::InsertMenu(hSubMenu,-1,MF_BYPOSITION|MF_STRING,ID_DIALER_MRU_SPEEDDIAL_START,sOut);
   }

   //if speeddial then we need a more... and edit speeddial list entry
   if (bRedial == FALSE)
   {
      if (nIndex >= SPEEDDIAL_MENU_MAX_ITEMS)
      {
         //Add to menu
         CString sText;
         sText.LoadString(IDS_SPEEDDIAL_MORE);
         ::InsertMenu(hSubMenu,-1,MF_BYPOSITION|MF_SEPARATOR,0,NULL);
         ::InsertMenu(hSubMenu,-1,MF_BYPOSITION|MF_STRING,ID_BUTTON_SPEEDDIAL_MORE,sText);
      }
      //Add to menu
      CString sText;
      sText.LoadString(IDS_SPEEDDIAL_EDIT);
      ::InsertMenu(hSubMenu,-1,MF_BYPOSITION|MF_SEPARATOR,0,NULL);
      ::InsertMenu(hSubMenu,-1,MF_BYPOSITION|MF_STRING,ID_BUTTON_SPEEDDIAL_EDIT,sText);
   }

   return TRUE;
}

////////////////////////////////////////////////////////////////
void CMainFrame::OnToolBarDropDown(UINT uID,NMHDR* pNMHDR, LRESULT* pResult)
{
   RECT      rc;
   TPMPARAMS tpm;
   HMENU     hPopupMenu = NULL;

   LPNMTOOLBAR pNMToolBar = (LPNMTOOLBAR)pNMHDR;
   
   switch(pNMHDR->code)
   {
      case TBN_DROPDOWN:
      {
         if ( (pNMToolBar->iItem == ID_BUTTON_REDIAL) || (pNMToolBar->iItem == ID_BUTTON_SPEEDDIAL) )
         {
            ::SendMessage(pNMHDR->hwndFrom, TB_GETRECT,(WPARAM)pNMToolBar->iItem, (LPARAM)&rc);

            ::MapWindowPoints(pNMHDR->hwndFrom,HWND_DESKTOP, (LPPOINT)&rc, 2);                         

            tpm.cbSize = sizeof(TPMPARAMS);
            tpm.rcExclude.top    = rc.top;
            tpm.rcExclude.left   = rc.left;
            tpm.rcExclude.bottom = rc.bottom;
            tpm.rcExclude.right  = rc.right;

            BOOL bRedial = (pNMToolBar->iItem == ID_BUTTON_REDIAL);
            if (bRedial)
               m_mapRedialIdToImage.RemoveAll();
            else
               m_mapSpeeddialIdToImage.RemoveAll();

            hPopupMenu = CreatePopupMenu();
            if (LoadCallMenu(hPopupMenu,bRedial))           //Load the redial or speeddial list
            {
               //make the menu ownerdrawn
               CBitmapMenu::MakeMenuOwnerDrawn(hPopupMenu,TRUE);

               m_hmenuCurrentPopupMenu = hPopupMenu;
               ::TrackPopupMenuEx(hPopupMenu,TPM_LEFTALIGN|TPM_LEFTBUTTON|TPM_VERTICAL,               
                                  rc.left, rc.bottom, GetSafeHwnd(), &tpm);
               m_hmenuCurrentPopupMenu = NULL;
            }
         }
         break;
      }
   }
}

/////////////////////////////////////////////////////////////////////////////
void CMainFrame::OnParentNotify(UINT message, LPARAM lParam)
{
   WORD wEvent = LOWORD(message);

   if ( (wEvent == WM_RBUTTONDOWN) && (m_bShowToolBars) )
   {
      //See if this is from a coolbar 
      CPoint ptCursor;
      ptCursor.x = LOWORD(lParam);
      ptCursor.y = HIWORD(lParam);
      ClientToScreen(&ptCursor);

      CRect rect;
      m_wndCoolBar.GetWindowRect(rect);

      if (rect.PtInRect(ptCursor))
      {
         HMENU hMenu = ::LoadMenu(AfxGetResourceHandle(),MAKEINTRESOURCE(IDR_CONTEXT_TOOLBAR));
         if (hMenu == NULL) return;
         HMENU hSubmenu = ::GetSubMenu(hMenu,0);
         if (hSubmenu == NULL)
         {
             // Clean-up the menu
             ::DestroyMenu( hMenu );
             return;
         }
          //::SetForegroundWindow(this->GetSafeHwnd());    
         ::TrackPopupMenuEx(hSubmenu,TPM_LEFTALIGN|TPM_LEFTBUTTON|TPM_VERTICAL,
                          ptCursor.x, ptCursor.y, this->GetSafeHwnd(),NULL);

         // Clean-up
         ::DestroyMenu( hSubmenu );
         ::DestroyMenu( hMenu );
      }
   }
}

////////////////////////////////////////////////////////////////
void CMainFrame::OnButtonCloseexplorer() 
{
    ShowWindow( SW_HIDE );
}

////////////////////////////////////////////////////////////////
void CMainFrame::OnUpdateButtonMakecall(CCmdUI* pCmdUI) 
{
   pCmdUI->Enable( (bool) (GetDocument() && GetDocument()->m_bInitDialer) );
}

////////////////////////////////////////////////////////////////
LRESULT CMainFrame::OnUpdateAllViews( WPARAM, LPARAM lHint )
{
   //
   // Validate pointer returned by GetDocument()
   //

   CActiveDialerDoc* pDoc = GetDocument();
   if ( pDoc )
      pDoc->UpdateAllViews( NULL, lHint );

   return 0;
}

////////////////////////////////////////////////////////////////
BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs) 
{
   // Use our registered window class name istead of default so that we can
   // quickly determine whether or not the application is running
    CActiveDialerApp *pApp = (CActiveDialerApp *) AfxGetApp();
   if ( pApp )
      cs.lpszClass = pApp->m_sApplicationName;
    
   cs.style &= ~FWS_ADDTOTITLE;

   LoadDesktop( &cs );

    return CFrameWnd::PreCreateWindow(cs);
}

////////////////////////////////////////////////////////////////
void CMainFrame::Show( bool bVisible /*= true*/ )
{
    if ( GetDocument() )
        GetDocument()->ShowDialerExplorer( bVisible );
}

////////////////////////////////////////////////////////////////
void CMainFrame::OnViewLog() 
{
   //Show log file via Notepad
   CString sLogPath;
   GetAppDataPath(sLogPath,IDN_REGISTRY_APPDATA_FILENAME_LOG);
   ShellExecute(GetSafeHwnd(),_T("open"),_T("notepad.exe"),sLogPath,NULL,SW_SHOWNORMAL);
}

////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
//Main HeartBeat of Dialer
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
void CMainFrame::HeartBeat()
{
   try
   {
      //check to see if we need to do midnight processing
      if (CheckDayOfWeekChange())
      {
         DoMidnightProcessing();
      }

#ifndef _MSLITE
      //check all the reminders for any activity
      CheckReminders();
#endif //_MSLITE

   }
   catch (...) 
   {
      ASSERT(0);
   }
}

////////////////////////////////////////////////////////////////
void CMainFrame::DoMidnightProcessing()
{
   //Clean up call log
   if ( GetDocument() )
      GetDocument()->CleanCallLog();
}

////////////////////////////////////////////////////////////////
bool CMainFrame::CheckDayOfWeekChange()
{
   bool bRet = false;

   CTime time = CTime::GetCurrentTime();
   
   //get day of week if it does not exist
   if (m_nCurrentDayOfWeek == -1)   m_nCurrentDayOfWeek = time.GetDayOfWeek();

   //is change in day
   if (m_nCurrentDayOfWeek != time.GetDayOfWeek())
   {
      m_nCurrentDayOfWeek = time.GetDayOfWeek();
      bRet = true;
   }

   return bRet;
}

#ifndef _MSLITE
////////////////////////////////////////////////////////////////
void CMainFrame::CheckReminders()
{
   //get current date/time
   COleDateTime dtsCurrentTime = COleDateTime::GetCurrentTime();

   int nIndex = 1;
   CReminder reminder;
   while (CDialerRegistry::GetReminder(nIndex,reminder))
   {
      //if reminder is past due
      if (reminder.m_dtsReminderTime < dtsCurrentTime)
      {
         //get the conference options for displaying a popup
         CWinApp* pApp = AfxGetApp();
         CString sRegKey,sBaseKey;
         sBaseKey.LoadString(IDN_REGISTRY_CONFERENCE_BASEKEY);
         sRegKey.LoadString(IDN_REGISTRY_CONFERENCE_REMINDER_DISPLAYPOPUP);
         if (pApp->GetProfileInt(sBaseKey,sRegKey,TRUE))
         {
            //Create the reminder popup
            CReminderDisplayDlg* pDlg = new CReminderDisplayDlg;
            pDlg->SetReminder(reminder);
            pDlg->Create(IDD_REMINDER_DISPLAY,this);
            pDlg->ShowWindow(SW_NORMAL);
         }

         //should we play a conference reminder sound
         sRegKey.LoadString(IDN_REGISTRY_SOUNDS_CONFERENCEREMINDER);
         if (pApp->GetProfileInt(sBaseKey,sRegKey,TRUE))
         {
            // --- BUG416970 ---
            CString sSound;
            sSound.LoadString(IDS_SOUNDS_CONFERENCEREMINDER);
            ActivePlaySound(sSound, szSoundDialer,SND_ASYNC);
         }

         //Delete the reminder now that we have told the user about it
         CDialerRegistry::RemoveReminder(reminder);
      }

      nIndex++;
   }
}
#endif //_MSLITE

////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
//Top Level Window Menu Control
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////
void CMainFrame::OnUpdateWindowWindows(CCmdUI* pCmdUI) 
{
    //Build up the menu
    CMenu* pMenu = GetMenu();
    if (!pMenu) return;

    CMenu* pSubMenu = pMenu->GetSubMenu(4);
    if (!pSubMenu) return;

    int nCount = pSubMenu->GetMenuItemCount();
    int nInd;
    for ( nInd = 0; nInd < nCount; nInd++ )
    {
        if ( pSubMenu->GetMenuItemID(nInd) == ID_WINDOW_WINDOWS_START )
            break;
    }

    //delete any existing menu
    //If we delete ID_WINDOW_WINDOWS_START we must ensure we put it back or else
    //we will not come here on menu update
    for ( int i = nInd;  i < nCount; i++ )
        pSubMenu->DeleteMenu( nInd, MF_BYPOSITION );

    CStringList strList;

    //
    // Validate pointer returned by GetDocument()
    //

    CActiveDialerDoc* pDoc = GetDocument();
    if (pDoc)
    {
        pDoc->GetCallControlWindowText(strList);

        //If no windows available
        if (strList.GetCount() == 0)
        {
            CString sText;
            sText.LoadString(IDS_BUTTON_WINDOWS_NONEAVAILABLE);
            pSubMenu->AppendMenu( MF_STRING, ID_WINDOW_WINDOWS_START, sText );
            pSubMenu->EnableMenuItem( ID_WINDOW_WINDOWS_START, MF_BYCOMMAND | MF_DISABLED );
            return;
        }

        POSITION pos = strList.GetHeadPosition();
        int nCount = 1;
        UINT uID = ID_WINDOW_WINDOWS_START;
        while ( (pos) && (uID <= ID_WINDOW_WINDOWS_END) )
        {
            CString sText;
            sText.Format(_T("&%d %s"),nCount,strList.GetNext(pos));
            pSubMenu->AppendMenu(MF_STRING,uID,sText);
            nCount++;
            uID++;
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
void CMainFrame::OnWindowWindowsSelect(UINT nID)
{
   int nIndex = -1;
   if ( (nID >= ID_WINDOW_WINDOWS_START) &&
        (nID <= ID_WINDOW_WINDOWS_END) )
   {
      //Normalize the value
      nIndex = nID - ID_WINDOW_WINDOWS_START + 1;

      //
      // Validate pointer returned by GetDocument()
      //

      CActiveDialerDoc* pDoc = GetDocument();
      if ( pDoc )
         pDoc->SelectCallControlWindow(nIndex);
   }
}

/////////////////////////////////////////////////////////////////////////////
LRESULT CMainFrame::OnCheckCallControlStates(WPARAM wParam,LPARAM lParam)
{
   CActiveDialerDoc* pDoc = GetDocument();
   if (pDoc == NULL) return 0;

   if (pDoc->GetCallControlWindowCount(DONT_INCLUDE_PREVIEW, ASK_TAPI) == 0)
      m_trayIcon.SetIcon(IDR_TRAY_NORMAL);
   else
      m_trayIcon.SetIcon(IDR_TRAY_ACTIVE);
   return 0;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//TaskBar Methods (for call control slider windows)
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
LRESULT CMainFrame::OnTaskBarCallbackMsg(WPARAM uNotifyMsg, LPARAM lParam)
{
   switch (uNotifyMsg)
   {
      case ABN_POSCHANGED:
      {
         //reposition all the call control windows if they are visible
         CActiveDialerDoc* pDoc = GetDocument();
         if ( (pDoc) && (pDoc->IsCallControlWindowsVisible()) )
         {
            pDoc->UnhideCallControlWindows();
         }
         break;
      }
      case ABN_FULLSCREENAPP: 
      case ABN_WINDOWARRANGE:
      case ABN_STATECHANGE:
         break;

      default:
         break;
   }
   return(0);
}


LRESULT CMainFrame::OnTaskBarCreated(WPARAM /*wParam*/, LPARAM /*lParam*/)
{
    m_trayIcon.SetIcon( NULL );
    UpdateTrayIconState();
    return 0;
}

bool CMainFrame::UpdateTrayIconState()
{
    bool bActiveCalls = false;
    CActiveDialerDoc* pDoc = GetDocument();
    if ( pDoc )
        bActiveCalls = (bool) (pDoc->GetCallControlWindowCount(DONT_INCLUDE_PREVIEW, ASK_TAPI) > 0);

    m_trayIcon.SetIcon( (bActiveCalls) ? IDR_TRAY_ACTIVE : IDR_TRAY_NORMAL );
    return bActiveCalls;
}

/////////////////////////////////////////////////////////////////////////////
void CMainFrame::OnEnable(BOOL bEnable)
{
   //if we are disable then we should disable the tray icon
   if (bEnable)
      m_bCanExitApplication = TRUE;
   else
      m_bCanExitApplication = FALSE;
}

void CMainFrame::NotifyUnhideCallWindows()
{
    ShowExplorerToolBar( ETB_HIDECALLS );
}

void CMainFrame::NotifyHideCallWindows()
{
    ShowExplorerToolBar( ETB_SHOWCALLS );
}


void CMainFrame::OnCallwindowHide() 
{
    //
    // Validate pointer returned by GetDocument()
    //

    CActiveDialerDoc* pDoc = GetDocument();
    if ( pDoc ) 
        pDoc->ToggleCallControlWindowsVisible();
}

void CMainFrame::OnUpdateCallwindowHide(CCmdUI* pCmdUI) 
{
    bool bEnable = false;
    CActiveDialerDoc* pDoc = GetDocument();
    if ( pDoc )
        bEnable = (bool) ((pDoc->GetCallControlWindowCount(INCLUDE_PREVIEW, DONT_ASK_TAPI) > 0) && pDoc->IsCallControlWindowsVisible());

    pCmdUI->Enable( bEnable );
}

void CMainFrame::OnCallwindowShow() 
{
    //
    // Validate pointer returned by GetDocument()
    //

    CActiveDialerDoc* pDoc = GetDocument();
    if ( pDoc ) 
        pDoc->ToggleCallControlWindowsVisible();
}

void CMainFrame::OnUpdateCallwindowShow(CCmdUI* pCmdUI) 
{
    bool bEnable = false;
    CActiveDialerDoc* pDoc = GetDocument();
    if ( pDoc )
        bEnable = (bool) ((pDoc->GetCallControlWindowCount(DONT_INCLUDE_PREVIEW, DONT_ASK_TAPI) > 0) && !pDoc->IsCallControlWindowsVisible());

    pCmdUI->Enable( bEnable );
}

void CMainFrame::OnButtonConferenceJoin() 
{
    IAVTapi* pTapi = GetTapi();
    if (pTapi)
    {
        long lRet = 0;
        pTapi->JoinConference( &lRet, TRUE, NULL );
        pTapi->Release();
    }
}

void CMainFrame::OnUpdateButtonConferenceJoin(CCmdUI* pCmdUI) 
{
    pCmdUI->Enable( CanJoinConference() );
}

void CMainFrame::OnButtonRoomDisconnect() 
{
    IAVTapi *pTapi = GetTapi();
    if ( pTapi )
    {
        IConfRoom *pConfRoom;
        if ( SUCCEEDED(pTapi->get_ConfRoom(&pConfRoom)) )
        {
            pConfRoom->Disconnect();
            pConfRoom->Release();
        }
        pTapi->Release();
    }
}

void CMainFrame::OnUpdateButtonRoomDisconnect(CCmdUI* pCmdUI) 
{
    pCmdUI->Enable( CanLeaveConference() );
}




void CMainFrame::OnSize(UINT nType, int cx, int cy) 
{
    if ( m_bHideWhenMinimized && (nType == SIZE_MINIMIZED) )
        ShowWindow( SW_HIDE );
    else
        CFrameWnd::OnSize(nType, cx, cy);
}

void CMainFrame::OnButtonDirectoryAddilsserver() 
{
    IAVTapi *pTapi;
    if ( SUCCEEDED(get_Tapi(&pTapi)) )
    {
        IConfExplorer *pExplorer;
        if ( SUCCEEDED(pTapi->get_ConfExplorer(&pExplorer)) )
        {
            IConfExplorerTreeView *pTree;
            if ( SUCCEEDED(pExplorer->get_TreeView(&pTree)) )
            {
                pTree->AddServer( NULL );
                pTree->Release();
            }
            pExplorer->Release();
        }
        pTapi->Release();
    }
}

void CMainFrame::OnUpdateButtonDirectoryAddilsserver(CCmdUI* pCmdUI) 
{
    pCmdUI->Enable( true );
    
}

LRESULT CMainFrame::OnUserUserDialog(WPARAM wParam, LPARAM lParam)
{
    ASSERT( lParam );
    if ( lParam )
        ((CUserUserDlg *) lParam)->DoModeless( NULL );

    return 0;
}

void CMainFrame::OnCallwindowAlwaysontop() 
{
    CActiveDialerDoc *pDoc = GetDocument();
    if ( pDoc )
        pDoc->SetCallControlWindowsAlwaysOnTop( !pDoc->IsCallControlWindowsAlwaysOnTop() );
}

void CMainFrame::OnUpdateCallwindowAlwaysontop(CCmdUI* pCmdUI) 
{
    CActiveDialerDoc *pDoc = GetDocument();
    if ( pDoc )
    {
        pCmdUI->Enable( true );
        pCmdUI->SetCheck( pDoc->IsCallControlWindowsAlwaysOnTop() );
    }
    else
    {
        pCmdUI->Enable( false );
    }
}

void CMainFrame::OnCallwindowSlidesideLeft() 
{
    CActiveDialerDoc *pDoc = GetDocument();
    if ( pDoc )
        pDoc->SetCallControlSlideSide( CALLWND_SIDE_LEFT, TRUE );
}

void CMainFrame::OnCallwindowSlidesideRight() 
{
    CActiveDialerDoc *pDoc = GetDocument();
    if ( pDoc )
        pDoc->SetCallControlSlideSide( CALLWND_SIDE_RIGHT, TRUE );
}

void CMainFrame::OnUpdateCallwindowSlidesideLeft(CCmdUI* pCmdUI) 
{
    CActiveDialerDoc *pDoc = GetDocument();
    if ( pDoc )
    {
        pCmdUI->Enable( true );
        pCmdUI->SetRadio( (BOOL) (pDoc->GetCallControlSlideSide() == CALLWND_SIDE_LEFT) );
    }
    else
    {
        pCmdUI->Enable( false );
    }
}

void CMainFrame::OnUpdateCallwindowSlidesideRight(CCmdUI* pCmdUI) 
{
    CActiveDialerDoc *pDoc = GetDocument();
    if ( pDoc )
    {
        pCmdUI->Enable( true );
        pCmdUI->SetRadio( (BOOL) (pDoc->GetCallControlSlideSide() == CALLWND_SIDE_RIGHT) );
    }
    else
    {
        pCmdUI->Enable( false );
    }
}

BOOL CMainFrame::CanLeaveConference()
{ 
    //
    // Validate pointer returned by GetDocument()
    //

    CActiveDialerDoc* pDoc = GetDocument();

    BOOL bEnable = (BOOL) ( pDoc && pDoc->m_bInitDialer );

    if ( bEnable )
    {
        IAVTapi *pTapi = GetTapi();
        if ( pTapi )
        {
            IConfRoom *pConfRoom;
            if ( SUCCEEDED(pTapi->get_ConfRoom(&pConfRoom)) )
            {
                bEnable = (BOOL) (pConfRoom->CanDisconnect() == S_OK);
                pConfRoom->Release();
            }
            pTapi->Release();
        }
    }

    return bEnable;
}

BOOL CMainFrame::CanJoinConference()
{
    //
    // Validate pointer returned by GetDocument()
    //

    CActiveDialerDoc* pDoc = GetDocument();
    BOOL bEnable = (BOOL) ( pDoc && pDoc->m_bInitDialer );

    // Should we even try to check the status of the conference room?
    if ( bEnable )
    {
        IAVTapi *pTapi;
        if ( SUCCEEDED(get_Tapi(&pTapi)) )
        {
            IConfRoom *pConfRoom;
            if ( SUCCEEDED(pTapi->get_ConfRoom(&pConfRoom)) )
            {
                bEnable = (bool) (pConfRoom->IsConfRoomInUse() == S_FALSE);
                pConfRoom->Release();
            }
            pTapi->Release();
        }
    }

    return bEnable;
}

void CMainFrame::OnConfgroupFullsizevideo() 
{
    IAVTapi *pTapi;
    if ( SUCCEEDED(get_Tapi(&pTapi)) )
    {
        IConfRoom *pConfRoom;
        if ( SUCCEEDED(pTapi->get_ConfRoom(&pConfRoom)) )
        {
            short nSize = 50;
            pConfRoom->get_MemberVideoSize( &nSize );
            nSize = (nSize > 50) ? 50 : 100;
            pConfRoom->put_MemberVideoSize( nSize );

            pConfRoom->Release();
        }
        pTapi->Release();
    }
}

void CMainFrame::OnUpdateConfgroupFullsizevideo(CCmdUI* pCmdUI) 
{
    BOOL bCheck, bEnable;
    CanConfRoomShowFullSizeVideo( bEnable, bCheck );
    pCmdUI->SetCheck( bCheck );
    pCmdUI->Enable( bEnable );
}

void CMainFrame::OnConfgroupShownames() 
{
    IAVTapi *pTapi;
    if ( SUCCEEDED(get_Tapi(&pTapi)) )
    {
        IConfRoom *pConfRoom;
        if ( SUCCEEDED(pTapi->get_ConfRoom(&pConfRoom)) )
        {
            VARIANT_BOOL bShowNames;
            if ( SUCCEEDED(pConfRoom->get_bShowNames(&bShowNames)) )
                pConfRoom->put_bShowNames( !bShowNames );

            pConfRoom->Release();
        }
        pTapi->Release();
    }
}

void CMainFrame::OnUpdateConfgroupShownames(CCmdUI* pCmdUI) 
{
    BOOL bCheck, bEnable;
    CanConfRoomShowNames( bEnable, bCheck );
    pCmdUI->SetCheck( bCheck );
    pCmdUI->Enable( bEnable );
}


void CMainFrame::CanConfRoomShowNames( BOOL &bEnable, BOOL &bCheck )
{
    //
    // Validate pointer returned by GetDocument()
    //

    CActiveDialerDoc* pDoc = GetDocument();

    bEnable = (BOOL) ( pDoc && pDoc->m_bInitDialer );
    bCheck = false;

    // Should we even try to check the status of the conference room?
    if ( bEnable )
    {
        IAVTapi *pTapi;
        if ( SUCCEEDED(get_Tapi(&pTapi)) )
        {
            IConfRoom *pConfRoom;
            if ( SUCCEEDED(pTapi->get_ConfRoom(&pConfRoom)) )
            {
                VARIANT_BOOL bShow;
                pConfRoom->get_bShowNames( &bShow );
                bCheck = bShow;
                pConfRoom->Release();
            }
            pTapi->Release();
        }
    }
}

void CMainFrame::CanConfRoomShowFullSizeVideo( BOOL &bEnable, BOOL &bCheck )
{
    //
    // Validate pointer returned by GetDocument()
    //

    CActiveDialerDoc* pDoc = GetDocument();

    bEnable = (BOOL) ( pDoc && pDoc->m_bInitDialer );
    bCheck = false;

    // Should we even try to check the status of the conference room?
    if ( bEnable )
    {
        IAVTapi *pTapi;
        if ( SUCCEEDED(get_Tapi(&pTapi)) )
        {
            IConfRoom *pConfRoom;
            if ( SUCCEEDED(pTapi->get_ConfRoom(&pConfRoom)) )
            {
                short nSize = 50;
                pConfRoom->get_MemberVideoSize( &nSize );
                bCheck = (BOOL) (nSize > 50);

                pConfRoom->Release();
            }
            pTapi->Release();
        }
    }
}


void CMainFrame::OnViewSelectedconferencevideoscale( UINT nID ) 
{
    IAVTapi *pTapi;
    if ( SUCCEEDED(get_Tapi(&pTapi)) )
    {
        IConfRoom *pConfRoom;
        if ( SUCCEEDED(pTapi->get_ConfRoom(&pConfRoom)) )
        {
            switch ( nID )
            {
                case ID_VIEW_SELECTEDCONFERENCEVIDEOSCALE_100:    pConfRoom->put_TalkerScale( 100 ); break;
                case ID_VIEW_SELECTEDCONFERENCEVIDEOSCALE_200:    pConfRoom->put_TalkerScale( 150 ); break;
                case ID_VIEW_SELECTEDCONFERENCEVIDEOSCALE_400:    pConfRoom->put_TalkerScale( 200 ); break;
            }
            pConfRoom->Release();
        }
        pTapi->Release();
    }
}

void CMainFrame::OnUpdateViewSelectedconferencevideoscale(CCmdUI* pCmdUI) 
{
    bool bCheck = false;

    IAVTapi *pTapi;
    if ( SUCCEEDED(get_Tapi(&pTapi)) )
    {
        IConfRoom *pConfRoom;
        if ( SUCCEEDED(pTapi->get_ConfRoom(&pConfRoom)) )
        {
            short nScale;
            pConfRoom->get_TalkerScale( &nScale );

            switch ( pCmdUI->m_nID )
            {
                case ID_VIEW_SELECTEDCONFERENCEVIDEOSCALE_100:    bCheck = (bool) (nScale == 100); break;
                case ID_VIEW_SELECTEDCONFERENCEVIDEOSCALE_200:    bCheck = (bool) (nScale == 150); break;
                case ID_VIEW_SELECTEDCONFERENCEVIDEOSCALE_400:    bCheck = (bool) (nScale == 200); break;
            }
            pConfRoom->Release();
        }
        pTapi->Release();
    }

    pCmdUI->Enable( true );
    pCmdUI->SetCheck( bCheck );
}


void CMainFrame::OnWindowsAlwaysclosecallwindows() 
{
    IAVTapi *pTapi;
    if ( SUCCEEDED(get_Tapi(&pTapi)) )
    {
        VARIANT_BOOL bAutoClose;
        pTapi->get_bAutoCloseCalls( &bAutoClose );
        pTapi->put_bAutoCloseCalls( !bAutoClose );
        pTapi->Release();
    }
}

void CMainFrame::OnUpdateWindowsAlwaysclosecallwindows(CCmdUI* pCmdUI) 
{
    IAVTapi *pTapi;
    if ( SUCCEEDED(get_Tapi(&pTapi)) )
    {
        VARIANT_BOOL bAutoClose;
        pTapi->get_bAutoCloseCalls( &bAutoClose );
        pCmdUI->SetCheck( bAutoClose );
        pCmdUI->Enable( true );
        pTapi->Release();
    }
    else
    {
        pCmdUI->Enable( false );
    }
}

void CMainFrame::OnDestroy() 
{
    if ( m_hImlTrayMenu ) ImageList_Destroy( m_hImlTrayMenu );
    if ( m_hImageListMenu ) ImageList_Destroy( m_hImageListMenu );

    CFrameWnd::OnDestroy();
}

LRESULT CMainFrame::OnDocHint( WPARAM wParam, LPARAM lParam )
{
    CActiveDialerDoc *pDoc = GetDocument();
    if ( pDoc )
        pDoc->UpdateAllViews( (CView *) wParam, lParam );
    return 0;
}



void CMainFrame::OnShowWindow(BOOL bShow, UINT nStatus) 
{
    CFrameWnd::OnShowWindow(bShow, nStatus);
    
    if ( bShow )
        m_bCanSaveDesktop = true;
}

//
// OnUSBPhone this message is send by AVTapi.dll
// when the handset is used
//

LRESULT CMainFrame::OnUSBPhone(WPARAM wParam, LPARAM lParam)
{
    CActiveDialerDoc *pDoc = GetDocument();
    if ( pDoc )
    {
        if( wParam == AVUSB_MAKECALL)
        {
            //
            // Let's popup the dial dialog
            //
            pDoc->Dial( _T(""), _T(""), LINEADDRESSTYPE_PHONENUMBER, DIALER_MEDIATYPE_UNKNOWN, 1);
        }
        else if( wParam == AVUSB_CANCELCALL )
        {
            //
            // Destroy all control windows
            //
            pDoc->DestroyAllCallControlWindows();
            UpdateTrayIconState();
        }
        else if( wParam == AVUSB_REDIAL )
        {
            //
            // Make a redial
            //

            ::PostMessage( m_hWnd, WM_COMMAND, MAKEWPARAM(ID_BUTTON_REDIAL,0), 0);
        }
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\palhook.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////
// Copyright 1996 Microsoft Systems Journal. 
// If this program works, it was written by Paul DiLascia.
// If not, I don't know who wrote it.
//
#include "StdAfx.h"
#include "PalHook.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// To turn on tracing for palette messages, you need
// to define _TRACEPAL here or in your make file
//#define _TRACEPAL

#ifndef _TRACEPAL
#undef TRACEFN
#undef TRACE
#undef TRACE0
#define TRACEFN CString().Format
#define TRACE CString().Format
#define TRACE0 CString().Format
#endif

IMPLEMENT_DYNAMIC(CPalMsgHandler, CMsgHook);

CPalMsgHandler::CPalMsgHandler()
{
	m_pPalette = NULL;
}

CPalMsgHandler::~CPalMsgHandler()
{
}

//////////////////
// Message handler handles palette-related messages
//
LRESULT CPalMsgHandler::WindowProc(UINT msg, WPARAM wp, LPARAM lp)
{
	ASSERT_VALID(m_pWndHooked);

	switch (msg) {
	case WM_PALETTECHANGED:
		OnPaletteChanged(CWnd::FromHandle((HWND)wp));
		return 0;
	case WM_QUERYNEWPALETTE:
		return OnQueryNewPalette();
	case WM_SETFOCUS:
		OnSetFocus(CWnd::FromHandle((HWND)wp));
		return 0;
	}
	return CMsgHook::WindowProc(msg, wp, lp);
}

//////////////////
// Handle WM_PALETTECHANGED
//
void CPalMsgHandler::OnPaletteChanged(CWnd* pFocusWnd)
{
	ASSERT(m_pWndHooked);
	CWnd& wnd = *m_pWndHooked;
	//TRACEFN("CPalMsgHandler::OnPaletteChanged for %s [from %s]\n", 
	//	DbgName(&wnd), DbgName(pFocusWnd));

	if (pFocusWnd->GetSafeHwnd() != wnd.m_hWnd) {
		if (DoRealizePalette(FALSE)==0) {
			if (wnd.GetParent()==NULL) {
				// I'm the top-level frame: Broadcast to children
				// (only MFC permanent CWnd's!)
				//
				const MSG& curMsg = AfxGetThreadState()->m_lastSentMsg;
				wnd.SendMessageToDescendants(WM_PALETTECHANGED,
					curMsg.wParam, curMsg.lParam);
			}
		}
	} else {
		// I'm the window that triggered the WM_PALETTECHANGED
		// in the first place: ignore it
		//
		1;//TRACE(_T("[It's me, don't realize palette.]\n"));
	}
}

//////////////////
// Handle WM_QUERYNEWPALETTE
//
BOOL CPalMsgHandler::OnQueryNewPalette()
{
	ASSERT(m_pWndHooked);
	CWnd& wnd = *m_pWndHooked;
	//TRACEFN("CPalMsgHandler::OnQueryNewPalette for %s\n", DbgName(&wnd));

	if (DoRealizePalette(TRUE) == 0)
   {	// realize in foreground
		// No colors changed: if this is the top-level frame,
		// give active view a chance to realize itself
		//
		if (wnd.GetParent()==NULL)
      {
			//ASSERT_KINDOF(CFrameWnd, &wnd);
         if (wnd.IsKindOf(RUNTIME_CLASS(CFrameWnd)))
         {
			   CWnd* pView = ((CFrameWnd&)wnd).GetActiveFrame()->GetActiveView();
			   if (pView) 
				   pView->SendMessage(WM_QUERYNEWPALETTE);
         }
		}
	}
	return TRUE;
}

//////////////////
// Handle WM_SETFOCUS
//
void CPalMsgHandler::OnSetFocus(CWnd* pOldWnd) 
{
	ASSERT(m_pWndHooked);
	CWnd& wnd = *m_pWndHooked;
	//TRACEFN("CPalMsgHandler::OnSetFocus for %s\n", DbgName(&wnd));
	wnd.SetForegroundWindow();		// Windows likes this
	DoRealizePalette(TRUE);			// realize in foreground
	Default();							// let app handle focus message too
}

/////////////////
// Function to actually realize the palette.
// Override this to do different kind of palette realization; e.g.,
// DrawDib instead of setting the CPalette.
//
int CPalMsgHandler::DoRealizePalette(BOOL bForeground)
{
	if (!m_pPalette || !m_pPalette->m_hObject)
		return 0;

	ASSERT(m_pWndHooked);
	CWnd& wnd = *m_pWndHooked;
	//TRACEFN("CPalMsgHandler::DoRealizePalette(%s) for %s\n",
	//	bForeground ? "foreground" : "background", DbgName(&wnd));

	CClientDC dc(&wnd);
	CPalette* pOldPal = dc.SelectPalette(m_pPalette, !bForeground);
	int nColorsChanged = dc.RealizePalette();
	if (pOldPal)
		dc.SelectPalette(pOldPal, TRUE);
	if (nColorsChanged > 0)
		wnd.Invalidate(FALSE); // repaint
	//TRACE(_T("[%d colors changed]\n"), nColorsChanged);
	return nColorsChanged;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\palhook.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////
// Copyright 1996 Microsoft Systems Journal. 
// If this code works, it was written by Paul DiLascia.
// If not, I don't know who wrote it.
//
#ifndef _PALMSGHOOK_H
#define _PALMSGHOOK_H

#include "MsgHook.h"

//////////////////
// Generic palette message handler makes handling palette messages easy.
// To use:
//
// * Instaniate a CPalMsgHandler in your main frame and
//   every CWnd class that needs to realize palettes (e.g., your view).
// * Call Install to install.
// * Call DoRealizePalette(TRUE) from your view's OnInitialUpdate fn.
//
class CPalMsgHandler : public CMsgHook {
protected:
	CPalette* m_pPalette; // ptr to palette

	DECLARE_DYNAMIC(CPalMsgHandler);

	// These are similar to, but NOT the same as the equivalent CWnd fns.
	// Rarely, if ever need to override.
	//
	virtual LRESULT WindowProc(UINT msg, WPARAM wp, LPARAM lp);	
	virtual void OnPaletteChanged(CWnd* pFocusWnd);
	virtual BOOL OnQueryNewPalette();
	virtual void OnSetFocus(CWnd* pOldWnd);

	// Override this if you realize your palette some other way
	// (not by having a ptr to a CPalette).
	//
	virtual int  DoRealizePalette(BOOL bForeground);

public:
	CPalMsgHandler();
	~CPalMsgHandler();

	// Get/Set palette obj
	CPalette* GetPalette()				{ return m_pPalette; }
	void SetPalette(CPalette* pPal)	{ m_pPalette = pPal; }

#ifdef _DIALER_MSGHOOK_SUPPORT
	// Call this to install the palette handler
	BOOL Install(CWnd* pWnd, CPalette* pPal) {
		m_pPalette = pPal;
		return HookWindow(pWnd);
	}
#else //_DIALER_MSGHOOK_SUPPORT
   BOOL Install(CWnd* pWnd, CPalette* pPal) { return TRUE; };
#endif //_DIALER_MSGHOOK_SUPPORT
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\pergrplst.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////
// PerGrpLst.cpp : implementation file
/////////////////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "PerGrpLst.h"
#include "mainfrm.h"
#include "avDialerDoc.h"
#include "directory.h"
#include "ds.h"
#include "util.h"
#include "resource.h"
#include "avtrace.h"
#include "aexpltre.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define OVERLAYMASKTOINDEX(_N_)	(_N_ >> 8)

#define AVDIALER_KEY_ENTER      13

CPersonGroupListItem::CPersonGroupListItem()
{
	m_pObject = NULL;
	m_bRelease = false;
}

CPersonGroupListItem::~CPersonGroupListItem()
{
	ReleaseObject();
}

void CPersonGroupListItem::ReleaseObject()
{
	if ( m_bRelease && m_pObject && m_pObject->IsKindOf(RUNTIME_CLASS(CLDAPUser)) )
		((CLDAPUser *) m_pObject)->Release();

	m_pObject = NULL;
	m_bRelease = false;
}

void CPersonGroupListItem::SetObject( CObject *pObject )
{
	ReleaseObject();
	m_pObject = pObject;

	if ( m_pObject && m_pObject->IsKindOf(RUNTIME_CLASS(CLDAPUser)) )
	{
		((CLDAPUser *) m_pObject)->AddRef();
		m_bRelease = true;
	}
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Person Group View
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#define MAX_COLUMNS		5

UINT CPersonGroupListCtrl::m_uColumnLabel[MAX_COLUMNS];

static int nColumnWidth[MAX_COLUMNS] = { 150, 150, 150, 150, 150 };

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CLASS CPersonGroupListCtrl
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CPersonGroupListCtrl, CAVListCtrl)

BEGIN_MESSAGE_MAP(CPersonGroupListCtrl, CAVListCtrl)
	//{{AFX_MSG_MAP(CPersonGroupListCtrl)
	ON_WM_LBUTTONDBLCLK()
	ON_WM_DESTROY()
	ON_COMMAND(ID_BUTTON_MAKECALL, OnButtonMakecall)
	ON_MESSAGE(WM_ACTIVEDIALER_BUDDYLIST_DYNAMICUPDATE,OnBuddyListDynamicUpdate)
	ON_WM_PAINT()
	ON_WM_CONTEXTMENU()
    ON_WM_KEYUP()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
CPersonGroupListCtrl::CPersonGroupListCtrl()
{
   m_pParentView = NULL;
   m_nNumColumns = 2;
   m_nStyle = (Style_t) -1;
}

/////////////////////////////////////////////////////////////////////////////
CPersonGroupListCtrl::~CPersonGroupListCtrl()
{
}

/////////////////////////////////////////////////////////////////////////////
void CPersonGroupListCtrl::Init(CWnd* pParentView, Style_t nStyle )
{	
	//Set the bitmap for the list 
	if ( pParentView )
	{
		CAVListCtrl::Init(IDB_GROUP_LIST);
		m_pParentView = pParentView;
	}

	if ( m_nStyle != nStyle )
	{
		SaveOrLoadColumnSettings( true );
		m_nStyle = nStyle;
		SaveOrLoadColumnSettings( false );

		switch ( m_nStyle )
		{
			case STYLE_ROOT:
			case STYLE_ILS_ROOT:
				m_uColumnLabel[0] = IDS_HEADING_NONE;
				SetColumns(1);
				break;

			case STYLE_INFO:
				m_uColumnLabel[0] = IDS_HEADING_INFO;
				SetColumns(1);
				break;
				
			case STYLE_ILS:
				m_uColumnLabel[0] = IDS_HEADING_DISPLAY;
				m_uColumnLabel[1] = IDS_HEADING_COMPUTERNAME;
				m_uColumnLabel[2] = IDS_HEADING_IPADDRESS;
				SetColumns(3);
				break;

			case STYLE_DS:
				m_uColumnLabel[0] = IDS_HEADING_DISPLAY;
				m_uColumnLabel[1] = IDS_HEADING_PHONE;
				m_uColumnLabel[2] = IDS_HEADING_IPPHONE;
				m_uColumnLabel[3] = IDS_HEADING_EMAIL;
				SetColumns(4);
				break;

			default:
				ASSERT( FALSE );
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
BOOL CPersonGroupListCtrl::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID)
{
	//We want the report style
 	dwStyle |= LVS_REPORT | LVS_SINGLESEL;

	BOOL bRet = CAVListCtrl::Create(dwStyle,rect,pParentWnd,nID);

   ListView_SetExtendedListViewStyle(GetSafeHwnd(),LVS_EX_FULLROWSELECT);

   return bRet;
}

/////////////////////////////////////////////////////////////////////////////
void CPersonGroupListCtrl::OnDestroy() 
{
	//delete the items in the list
	ClearList();
	CAVListCtrl::OnDestroy();
}

/////////////////////////////////////////////////////////////////////////////
void CPersonGroupListCtrl::InsertObjectToList(CObject* pObject)
{
	ASSERT(pObject);

	//keep in our internal list
	if ( pObject->IsKindOf(RUNTIME_CLASS(CLDAPUser)) )
	{
		((CLDAPUser *) pObject)->AddRef();
	}

	m_PersonEntryList.AddTail(pObject);

	//add to tree
	CPersonGroupListItem* pItem = new CPersonGroupListItem();
	pItem->SetObject(pObject);
	CAVListCtrl::InsertItem(pItem,0,FALSE);

	CAVListCtrl::SortItems();
}

/////////////////////////////////////////////////////////////////////////////
void CPersonGroupListCtrl::InsertList(CObList* pPersonEntryList,BOOL bForce)
{
	ASSERT(pPersonEntryList);

	if ( (bForce == FALSE) && (pPersonEntryList == &m_PersonEntryList) )
	return;

	//delete the items in the list
	ClearList();


	// Copy the list over
	m_PersonEntryList.AddHead( pPersonEntryList );
	POSITION pos = m_PersonEntryList.GetHeadPosition();
	while (pos)
	{
		CPersonGroupListItem* pItem = new CPersonGroupListItem();
		CObject *pObject = m_PersonEntryList.GetNext(pos);

		// AddRef is for the list copy above.  Lists sent in to here are not
		// specifically addref'd.
		if ( pObject->IsKindOf(RUNTIME_CLASS(CLDAPUser)) )
			((CLDAPUser *) pObject)->AddRef();

		pItem->SetObject(pObject);
		CAVListCtrl::InsertItem(pItem,0,FALSE);
	}
	CAVListCtrl::SortItems();
}

/////////////////////////////////////////////////////////////////////////////
//clear the objects in the list, but don't delete the list
void CPersonGroupListCtrl::ClearList()
{
	DeleteAllItems();
	while ( m_PersonEntryList.GetHeadPosition() )
	{
		CObject *pObj = m_PersonEntryList.RemoveHead();

		if ( pObj->IsKindOf(RUNTIME_CLASS(CLDAPUser)) )
			((CLDAPUser *) pObj)->Release();
		else
			delete pObj;
	}
}

/////////////////////////////////////////////////////////////////////////////
void CPersonGroupListCtrl::SetSelItem(CObject* pObject)
{
   int nCount = GetItemCount();
   for (int i=0;i<nCount;i++)
   {
      CPersonGroupListItem* pItem = (CPersonGroupListItem*)GetItemData(i);
      if (pObject == pItem->GetObject())
      {
         CAVListCtrl::SetSelItem(i);
         break;
      }
   }
}

/////////////////////////////////////////////////////////////////////////////
CObject* CPersonGroupListCtrl::GetSelObject()
{
   CObject* pRetPersonEntry = NULL;
   //Get the selected object so we can set it again
   int nSelItem = CAVListCtrl::GetSelItem();
   if (nSelItem != -1)
   {
      CPersonGroupListItem* pItem = (CPersonGroupListItem*)GetItemData(nSelItem);
      if (pItem)
      {
         //create new object and copy data
         CObject* pObject = pItem->GetObject();            
         if (pObject->IsKindOf(RUNTIME_CLASS(CILSUser)))
         {
            pRetPersonEntry = new CILSUser;
            *((CILSUser*)pRetPersonEntry) = (CILSUser*)pObject;
         }
         else if (pObject->IsKindOf(RUNTIME_CLASS(CDSUser)))
         {
            pRetPersonEntry = new CDSUser;
            *((CDSUser*)pRetPersonEntry) = (CDSUser*)pObject;
         }
         else if (pObject->IsKindOf(RUNTIME_CLASS(CLDAPUser)))
         {
			((CLDAPUser*) pObject)->AddRef();
            pRetPersonEntry = pObject;
         }
      }
   }
   return pRetPersonEntry;
}

/////////////////////////////////////////////////////////////////////////////
CObList* CPersonGroupListCtrl::GetSelList()
{
   CObList* pRetList = new CObList;
   int nIndex = -1;

   while ((nIndex = GetNextItem(nIndex,LVNI_SELECTED)) != -1)
   {
      CPersonGroupListItem* pItem = (CPersonGroupListItem*)GetItemData(nIndex);
      CObject* pObject = pItem->GetObject();
      if (pObject)
      {
         pRetList->AddTail(pObject);
      }
   }
   return pRetList;
}

/////////////////////////////////////////////////////////////////////////////
void CPersonGroupListCtrl::OnSetDisplayText(CAVListItem* _pItem,int SubItem,LPTSTR szTextBuf,int nBufSize)
{
	CObject *pObject = ((CPersonGroupListItem*)_pItem)->GetObject();
	CString sText;

	if ( pObject->IsKindOf(RUNTIME_CLASS(CILSUser)) )
	{
		switch (SubItem)
		{
			case 0:		sText = ((CILSUser *) pObject)->m_sUserName;	break;
			case 1:     sText = ((CILSUser *) pObject)->m_sComputer;    break;
			case 2:		sText = ((CILSUser *) pObject)->m_sIPAddress;	break;
		}
	}
	else if (pObject->IsKindOf(RUNTIME_CLASS(CDSUser)))
	{
		switch (SubItem)
		{
			case 0:			sText = ((CDSUser*)pObject)->m_sUserName;	break;
		}
	}
	else if (pObject->IsKindOf(RUNTIME_CLASS(CLDAPUser)))
	{
		switch (SubItem)
		{
			case 0:			sText = ((CLDAPUser *) pObject)->m_sUserName; break;
			case 1:			sText = ((CLDAPUser *) pObject)->m_sPhoneNumber; break;
			case 2:			sText = ((CLDAPUser *) pObject)->m_sIPAddress; break;
			case 3:			sText = ((CLDAPUser *) pObject)->m_sEmail1; break;
		}
	}

	_tcsncpy(szTextBuf,sText,nBufSize-1);			
	szTextBuf[nBufSize-1] = '\0';                            //make sure we are null terminated
}  

/////////////////////////////////////////////////////////////////////////////
void CPersonGroupListCtrl::OnSetDisplayImage(CAVListItem* _pItem,int& iImage)
{
   iImage = -1;

	CObject* pObject = (((CPersonGroupListItem*)_pItem)->GetObject());
	if (pObject->IsKindOf(RUNTIME_CLASS(CILSUser)))
	{
		iImage = (m_nStyle == STYLE_ILS) ? IMAGE_PERSON : IMAGE_FOLDER;
	}
	else if (pObject->IsKindOf(RUNTIME_CLASS(CDSUser)))
	{
		if (!((CDSUser*)pObject)->m_sIPAddress.IsEmpty())
			iImage = IMAGE_CARD;
	}
	else if (pObject->IsKindOf(RUNTIME_CLASS(CLDAPUser)))
	{
		//must check if data is current
		CLDAPUser* pLDAPUser = (CLDAPUser*)pObject;
		iImage = IMAGE_CARD;
	}
}

/////////////////////////////////////////////////////////////////////////////
int CPersonGroupListCtrl::CompareListItems(CAVListItem* _pItem1,CAVListItem* _pItem2,int column)
{
	int ret = 0;
	CObject* pObject1 = (((CPersonGroupListItem*)_pItem1)->GetObject());
	CObject* pObject2 = (((CPersonGroupListItem*)_pItem2)->GetObject());
	CString sText1, sText2;


	if (pObject1->IsKindOf(RUNTIME_CLASS(CILSUser)))
	{
		switch (column)
		{
			case 0:
				if ( m_nStyle != STYLE_INFO )
				{
					sText1 = ((CILSUser *) pObject1)->m_sUserName;
					sText2 = ((CILSUser *) pObject2)->m_sUserName;
				}
				break;

			case 1:
				sText1 = ((CILSUser *) pObject1)->m_sComputer;
				sText2 = ((CILSUser *) pObject2)->m_sComputer;
				break;

			case 2:
				sText1 = ((CILSUser *) pObject1)->m_sIPAddress;
				sText2 = ((CILSUser *) pObject2)->m_sIPAddress;
				break;
		}
	}
	else if (pObject1->IsKindOf(RUNTIME_CLASS(CDSUser)))
	{
	  switch (column)
	  {
		 case 0:
			sText1 = ((CDSUser*)pObject1)->m_sUserName;
			sText2 = ((CDSUser*)pObject2)->m_sUserName;
			break;
	  }
	}
	else if (pObject1->IsKindOf(RUNTIME_CLASS(CLDAPUser)))
	{
	  switch (column)
	  {
		 case 0:
			sText1 = ((CLDAPUser*)pObject1)->m_sUserName;
			sText2 = ((CLDAPUser*)pObject2)->m_sUserName;
			break;
	  }
	}

	ret = _tcsicmp( sText1, sText2 );
	return (CAVListCtrl::GetSortOrder()) ? -ret : ret;
}

/////////////////////////////////////////////////////////////////////////////
void CPersonGroupListCtrl::OnLButtonDblClk(UINT nFlags, CPoint point) 
{
   ASSERT(m_pParentView);

   //reflect to parent view
   m_pParentView->SendMessage(PERSONGROUPVIEWMSG_LBUTTONDBLCLK);

	CAVListCtrl::OnLButtonDblClk(nFlags, point);
}

/////////////////////////////////////////////////////////////////////////////
void CPersonGroupListCtrl::OnKeyUp( UINT nChar, UINT nRepCnt, UINT nFlags)
{
    if( AVDIALER_KEY_ENTER != nChar )
    {
        return;
    }

    // Press ENTER key, try to make a call
    OnButtonMakecall();
}

/////////////////////////////////////////////////////////////////////////////
void CPersonGroupListCtrl::SetColumns( int nCount )
{
   //delete any existing columns
   if ( m_nNumColumns > 0)
   {
      for (int i = m_nNumColumns - 1; i >= 0; i--)
         DeleteColumn(i);
   }

   m_nNumColumns = 0;

   //Set the column headings
   for (int i = 0; i < nCount; i++ )
   {
      CString sLabel;
      sLabel.LoadString(m_uColumnLabel[i]);
      InsertColumn(i,sLabel,LVCFMT_LEFT,nColumnWidth[i]);
      m_nNumColumns++;
   }
}

/////////////////////////////////////////////////////////////////////////////
void CPersonGroupListCtrl::OnButtonMakecall() 
{
	if ( !AfxGetMainWnd() || !((CMainFrame*) AfxGetMainWnd())->GetDocument() ) return;

	CActiveDialerDoc* pDoc = ((CMainFrame*) AfxGetMainWnd())->GetDocument();

	if ( m_nStyle != STYLE_INFO )
	{
		CObject* pObject = GetSelObject();
		if ( pObject )
		{
			if ( pObject->IsKindOf(RUNTIME_CLASS(CILSUser)) )
			{
				((CILSUser*)pObject)->Dial( pDoc );
				delete pObject;
			}
			else if ( pObject->IsKindOf(RUNTIME_CLASS(CDSUser)) )
			{
				((CDSUser*)pObject)->Dial(pDoc);
				delete pObject;
			}
			else if ( pObject->IsKindOf(RUNTIME_CLASS(CLDAPUser)) )
			{
				((CLDAPUser *) pObject)->Dial( pDoc );
				((CLDAPUser *) pObject)->Release();
			}

			return;
		}
	}

	// Default behavior
	pDoc->Dial( _T(""), _T(""), LINEADDRESSTYPE_IPADDRESS, DIALER_MEDIATYPE_UNKNOWN, true );
}

/////////////////////////////////////////////////////////////////////////////
LRESULT CPersonGroupListCtrl::OnBuddyListDynamicUpdate(WPARAM wParam,LPARAM lParam)
{
	CLDAPUser *pUser = (CLDAPUser *) lParam;
	ASSERT( pUser && pUser->IsKindOf(RUNTIME_CLASS(CLDAPUser)) );

	//Check if this pointer is in view
	int nCount = GetItemCount();
	for ( int i = 0; i < nCount; i++ )
	{
		CPersonGroupListItem* pItem = (CPersonGroupListItem *) GetItemData(i);
		if ( pUser == pItem->GetObject() )
		{
			RedrawItems(i,i);
			UpdateWindow();
			break;
		}
	}

	pUser->Release();
	return 0;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////



void CPersonGroupListCtrl::OnPaint() 
{
	if ( !AfxGetMainWnd() || !((CMainFrame *) AfxGetMainWnd())->GetActiveView() ) return;

	CExplorerTreeCtrl *pTreeCtrl = &((CActiveDialerView *) ((CMainFrame *) AfxGetMainWnd())->GetActiveView())->m_wndExplorer.m_wndMainDirectories.m_treeCtrl;
	TREEOBJECT nTreeObject = pTreeCtrl->GetSelectedObject();
	HTREEITEM hItem = pTreeCtrl->GetSelectedItem();

	// User parent item in the case of ILS folders
	if ( (nTreeObject == TOBJ_DIRECTORY_ILS_SERVER_PEOPLE) || (nTreeObject == TOBJ_DIRECTORY_ILS_SERVER_CONF) )
		hItem = pTreeCtrl->GetParentItem( hItem );

	if ( !GetItemCount() )
	{
		CPaintDC dc(this); // device context for painting

		// Figure out where we're going to write the text
		POINT pt;
		ListView_GetItemPosition( m_hWnd, 0, &pt );
		RECT rc;
		GetClientRect(&rc);
		rc.top = pt.y + 4;

		// Give a little bit more of a margin if we can
		if ( (rc.right - rc.left) > 7 )
		{
			rc.left += 3;
			rc.right -= 3;
		}

		POINT ptUL = { rc.left + 1, rc.top + 1};
		POINT ptLR = { rc.right - 1, rc.bottom - 1};

			CString strText;
			UINT nIDS;

			// Choose text based on Tree control style
			switch ( m_nStyle )
			{
				case STYLE_ROOT:		nIDS = IDS_DIRECTORY_ROOT;	break;
				case STYLE_DS:			nIDS = IDS_DS_LIST_EMPTY;	break;
				case STYLE_ILS_ROOT:	nIDS = IDS_ILS_ROOT;		break;
				default:
					{
						TV_ITEM tvi = { 0 };
						tvi.hItem = hItem;
						tvi.mask = TVIF_HANDLE | TVIF_STATE;

						if ( pTreeCtrl->GetItem(&tvi) )
						{
							
							switch( OVERLAYMASKTOINDEX(tvi.state) )
							{
								case SERVER_INVALID:			nIDS = IDS_SERVER_INVALID; break;
								case SERVER_NOT_RESPONDING:		nIDS = IDS_SERVER_NOT_RESPONDING; break;
								case SERVER_QUERYING:			nIDS = IDS_SERVER_QUERYING; break;
								case SERVER_UNKNOWN:			nIDS = IDS_SERVER_UNKNOWN; break;

								default:	nIDS = IDS_NO_ITEMS_TO_SHOW;	break;
							}
						}
					}
					break;
			}

			// Load the string that accurately reflects the state of the server
			strText.LoadString( nIDS );

			HFONT fontOld = (HFONT) dc.SelectObject( GetFont() );
			int nModeOld = dc.SetBkMode( TRANSPARENT );
			COLORREF crTextOld = dc.SetTextColor( GetSysColor(COLOR_BTNTEXT) );
			dc.DrawText( strText, &rc, DT_CENTER | DT_WORDBREAK | DT_NOPREFIX | DT_EDITCONTROL );
			dc.SetTextColor( crTextOld );
			dc.SetBkMode( nModeOld );

			dc.SelectObject( fontOld );
			ValidateRect( &rc );
	}
	else
	{
		DefWindowProc(WM_PAINT, 0, 0);
	}
}

void CPersonGroupListCtrl::OnContextMenu(CWnd* pWnd, CPoint point) 
{
	// Make sure all the windows that we expect to exist, exist
	if ( !AfxGetMainWnd() || !((CMainFrame *) AfxGetMainWnd())->GetActiveView() ) return;
	CExplorerTreeCtrl *pTreeCtrl = &((CActiveDialerView *) ((CMainFrame *) AfxGetMainWnd())->GetActiveView())->m_wndExplorer.m_wndMainDirectories.m_treeCtrl;
	if ( !pTreeCtrl ) return;

	CObject* pObject = GetSelObject();
	if ( pObject )
	{
		CMenu ContextMenu;
		if ( ContextMenu.LoadMenu(IDR_CONTEXT_DIRECTORIES) )
		{
			CMenu *pSubMenu = NULL;

			////////////////////////////////////////////
			// We have an ILS User -- put up menu...
			if ( pObject->IsKindOf(RUNTIME_CLASS(CILSUser)) )
			{
				pSubMenu = ContextMenu.GetSubMenu( CNTXMENU_ILS_USER );
				if ( pSubMenu )
				{
					UINT nMenuFlags = (((CILSUser *) pObject)->m_sIPAddress.IsEmpty()) ? MF_GRAYED : MF_ENABLED;

					pSubMenu->EnableMenuItem( ID_BUTTON_MAKECALL,  nMenuFlags );
					pSubMenu->EnableMenuItem( ID_BUTTON_SPEEDDIAL_ADD, nMenuFlags );

					// Add desktop paging?
					CString strTemp;
					strTemp.LoadString( IDN_REG_DESKTOPPAGE );
					int nInsert = AfxGetApp()->GetProfileInt(_T(""), strTemp,  FALSE );
					if ( nInsert )
					{
						strTemp.LoadString( IDS_MENU_DESKTOP_PAGE );
						pSubMenu->InsertMenu( 1, MF_BYPOSITION, ID_DESKTOP_PAGE, strTemp);
					}
				}
			}

			// Should we show the menu?
			if ( pSubMenu )
			{
				pSubMenu->TrackPopupMenu( TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
										  point.x, point.y, pTreeCtrl->GetParent() );
			}
		}

		// Clean up
		if ( pObject->IsKindOf(RUNTIME_CLASS(CLDAPUser)) )
			((CLDAPUser *) pObject)->Release();
		else
			delete pObject;
	}
}

void CPersonGroupListCtrl::SaveOrLoadColumnSettings( bool bSave )
{
	int i = 0;
	CString strSubKey, strTemp;
	strSubKey.LoadString( IDN_REGISTRY_DIALEREXPLORER_KEY );
	UINT nIDSOrder = 0, nIDSColumn = 0;

	switch ( m_nStyle )
	{
		case STYLE_ROOT:
		case STYLE_ILS_ROOT:
			LOAD_COLUMN( IDN_REG_HEADING_NONE, 150 );
			break;

		case STYLE_INFO:
			LOAD_COLUMN( IDN_REG_HEADING_INFO, 150 );
			break;
			
		case STYLE_ILS:
			LOAD_COLUMN( IDN_REG_HEADING_ILS_DISPLAY, 150 );
			LOAD_COLUMN( IDN_REG_HEADING_ILS_COMPUTERNAME, 150 );
			LOAD_COLUMN( IDN_REG_HEADING_ILS_IPADDRESS, 150 );
			nIDSOrder = IDN_REG_HEADING_ILS_SORTORDER;
			nIDSColumn = IDN_REG_HEADING_ILS_SORTCOLUMN;
			break;

		case STYLE_DS:
			LOAD_COLUMN( IDN_REG_HEADING_DS_DISPLAY, 150 );
			LOAD_COLUMN( IDN_REG_HEADING_DS_PHONE, 150 );
			LOAD_COLUMN( IDN_REG_HEADING_DS_IPPHONE, 150 );
			LOAD_COLUMN( IDN_REG_HEADING_DS_EMAIL, 150 );
			nIDSOrder = IDN_REG_HEADING_DS_SORTORDER;
			nIDSColumn = IDN_REG_HEADING_DS_SORTCOLUMN;
			break;
	}

	// Sort Order & Columns
	if ( nIDSOrder )
	{
		// Order
		strTemp.LoadString( nIDSOrder );
		if ( bSave ) 
			AfxGetApp()->WriteProfileInt( strSubKey, strTemp, m_SortOrder );
		else
			AfxGetApp()->GetProfileInt( strSubKey, strTemp, m_SortOrder );
	
		// Columns
		strTemp.LoadString( nIDSColumn );
		if ( bSave )
			AfxGetApp()->WriteProfileInt( strSubKey, strTemp, m_SortColumn );
		else
			AfxGetApp()->GetProfileInt( strSubKey, strTemp, m_SortColumn );
	}
	else
	{
		ResetSortOrder();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\pergrplst.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// PerGrpLst.h : header file
//

#ifndef _PERSONGROUPLISTCTRL_H_
#define _PERSONGROUPLISTCTRL_H_

#include "avlist.h"

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Defines
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#define PERSONGROUPVIEWMSG_LBUTTONDBLCLK  (WM_USER + 1020) 

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//class CPersonGroupListItem
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class CPurlGroup;
class CPurlName;

class CPersonGroupListItem : public CAVListItem
{
	friend class CPersonGroupListCtrl;
public:
//Construction
   CPersonGroupListItem();
   ~CPersonGroupListItem();

//Attributes
protected:
	CObject*			m_pObject;
	bool				m_bRelease;

//Operations
public:
	void				SetObject(CObject* pObject);
	CObject*			GetObject()						{return m_pObject;};
	void				ReleaseObject();
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CPersonGroupListCtrl window
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class CDirAsynch;
class CWABEntry;

class CPersonGroupListCtrl : public CAVListCtrl
{
	DECLARE_DYNCREATE(CPersonGroupListCtrl)
// Construction
public:
	CPersonGroupListCtrl();

public:
	typedef enum tagImage_t
	{
		IMAGE_CARD,
		IMAGE_PERSON,
		IMAGE_FOLDER,
	} Image_t;

	typedef enum tagStyle_t
	{
		STYLE_ROOT,
		STYLE_ILS_ROOT,
		STYLE_INFO,
		STYLE_ILS,
		STYLE_DS,
	} Style_t;

// Attributes
public:
   CObList			m_PersonEntryList;
   CWnd*			m_pParentView;

   static UINT		m_uColumnLabel[];
   int				m_nNumColumns;
   Style_t			m_nStyle;

// Operations
public:
   void				Init(CWnd* pParentView, Style_t nStyle );
	BOOL	        Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);

   void           InsertObjectToList(CObject* pObject);
   void           InsertList(CObList* pPersonEntryList,BOOL bForce=FALSE);
   void           ClearList();

   CObject*       GetSelObject();
   CObList*       GetSelList();
   void			  SaveOrLoadColumnSettings( bool bSave );

protected:
   void				SetColumns( int nCount );
   
protected:
   void           OnSetDisplayText(CAVListItem* _pItem,int SubItem,LPTSTR szTextBuf,int nBufSize);
	void				OnSetDisplayImage(CAVListItem* pItem,int& iImage);
	int				CompareListItems(CAVListItem* pItem1,CAVListItem* pItem2,int column);

   void           SetSelItem(CObject* pObject);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPersonGroupListCtrl)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CPersonGroupListCtrl();

	// Generated message map functions
protected:
	//{{AFX_MSG(CPersonGroupListCtrl)
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnDestroy();
	afx_msg void OnButtonMakecall();
   afx_msg LRESULT OnBuddyListDynamicUpdate(WPARAM wParam,LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    afx_msg void OnKeyUp( UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif //_PERSONGROUPLISTCTRL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\mystdafx.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// stdafx.cpp : source file that includes just the standard includes
//	ActiveDialer.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

//ATL Support
#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\phonepad.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////
// PhonePad.h : header file
/////////////////////////////////////////////////////////////////////////////
#if !defined(AFX_PHONEPAD_H__90DDA53B_6551_11D1_B709_0800170982BA__INCLUDED_)
#define AFX_PHONEPAD_H__90DDA53B_6551_11D1_B709_0800170982BA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CPhonePad dialog
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class CCallControlWnd;

class CPhonePad : public CDialog
{
// Construction
public:
	CPhonePad(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CPhonePad)
	enum { IDD = IDD_PHONEPAD };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

//Attributes
protected:
   HWND                 m_hwndToolBar;
   HWND                 m_hwndPeerWnd;

//Operations
protected:
   BOOL                 CreatePhonePad();
public:
   void                 SetPeerWindow(HWND hwnd)   { m_hwndPeerWnd = hwnd; };
   HWND                 GetPeerWindow()            { return m_hwndPeerWnd; };

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPhonePad)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CPhonePad)
	virtual BOOL OnInitDialog();
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
   virtual void OnCancel();
	//}}AFX_MSG
   afx_msg void OnDigitPress( UINT nID );
   afx_msg BOOL OnTabToolTip( UINT id, NMHDR * pTTTStruct, LRESULT * pResult );
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PHONEPAD_H__90DDA53B_6551_11D1_B709_0800170982BA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\phonepad.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////
// PhonePad.cpp : implementation file
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "avdialer.h"
#include "MainFrm.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Defines
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
struct CToolBarData
{
	WORD wVersion;
	WORD wWidth;
	WORD wHeight;
	WORD wItemCount;
	WORD* items()     { return (WORD*)(this+1); }
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CPhonePad dialog
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
CPhonePad::CPhonePad(CWnd* pParent /*=NULL*/)
	: CDialog(CPhonePad::IDD, pParent)
{
	//{{AFX_DATA_INIT(CPhonePad)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
   m_hwndToolBar = NULL;
   m_hwndPeerWnd = NULL;
}

/////////////////////////////////////////////////////////////////////////////
void CPhonePad::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPhonePad)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPhonePad, CDialog)
	//{{AFX_MSG_MAP(CPhonePad)
	ON_WM_SHOWWINDOW()
	//}}AFX_MSG_MAP
   ON_COMMAND_RANGE(ID_CALLWINDOW_DTMF_1,ID_CALLWINDOW_DTMF_POUND,OnDigitPress)
//	ON_NOTIFY_EX_RANGE(TTN_NEEDTEXTW, 0, 0xFFFF, OnTabToolTip)
//	ON_NOTIFY_EX_RANGE(TTN_NEEDTEXTA, 0, 0xFFFF, OnTabToolTip)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
BOOL CPhonePad::OnInitDialog() 
{
	CDialog::OnInitDialog();
   CreatePhonePad();

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////////////
BOOL CPhonePad::CreatePhonePad()
{
   if ( m_hwndToolBar ) return TRUE;
   
   BOOL bRet = FALSE;
 
   //Load toolbar from resource
   HINSTANCE hInst = AfxFindResourceHandle(MAKEINTRESOURCE(IDR_CALLWINDOW_DTMF), RT_TOOLBAR);
	HRSRC hRsrc = ::FindResource(hInst, MAKEINTRESOURCE(IDR_CALLWINDOW_DTMF), RT_TOOLBAR);
	if (hRsrc == NULL) return FALSE;

	HGLOBAL hGlobal = LoadResource(hInst, hRsrc);
	if (hGlobal == NULL)	return FALSE;

	CToolBarData* pData = (CToolBarData*)LockResource(hGlobal);
	if (pData == NULL) return FALSE;
	ASSERT(pData->wVersion == 1);

   TBBUTTON* pTBB = new TBBUTTON[pData->wItemCount];
   for (int i = 0; i < pData->wItemCount; i++)
   {
   	pTBB[i].iBitmap = i;
   	pTBB[i].idCommand = pData->items()[i];
   	pTBB[i].fsState = TBSTATE_ENABLED;
   	pTBB[i].fsStyle = TBSTYLE_BUTTON;
   	pTBB[i].dwData = 0;
   	pTBB[i].iString = 0;
   }

	// Create the toolbar
	DWORD ws = WS_CHILD | WS_VISIBLE | WS_BORDER | TBSTYLE_TOOLTIPS | TBSTYLE_FLAT | TBSTYLE_WRAPABLE | CCS_NODIVIDER |CCS_NOPARENTALIGN;
   m_hwndToolBar = CreateToolbarEx(GetSafeHwnd(),	            // parent window
									ws,								         // toolbar style
									1,					                     // ID for toolbar
									pData->wItemCount,                  // Number of bitmaps on toolbar
									AfxGetResourceHandle(),	            // Resource instance that has the bitmap
									IDR_CALLWINDOW_DTMF,			         // ID for bitmap
									pTBB,							            // Button information
									pData->wItemCount,  					   // Number of buttons to add to toolbar
									16, 15, 0, 0,					         // Width and height of buttons/bitmaps
									sizeof(TBBUTTON) );				      // size of TBBUTTON structure
   // Clean up
   delete pTBB;

   if (m_hwndToolBar)
   {
      CRect rect;
      GetClientRect(rect);

      ::ShowWindow(m_hwndToolBar,SW_SHOW);

      CRect rcWindow;
      GetClientRect(rcWindow);

      ::SendMessage(m_hwndToolBar,TB_SETBUTTONSIZE, 0, MAKELPARAM(rcWindow.Width()/3,rcWindow.Height()/4));

//       CRect rcPad;
//      ::SendMessage(m_hwndToolBar,TB_SETROWS , MAKEWPARAM(4,TRUE),(LPARAM)&rcPad);

      ::SetWindowPos(m_hwndToolBar,NULL,1,1,rect.Width(),rect.Height(),SWP_NOACTIVATE|SWP_NOZORDER);

      bRet = TRUE;
   }
   return bRet;
}


void CPhonePad::OnDigitPress( UINT nID )
{
   if ( AfxGetMainWnd() )
   {
      CActiveDialerDoc *pDoc = ((CMainFrame *) AfxGetMainWnd())->GetDocument();
      if ( pDoc )
         pDoc->DigitPress( (PhonePadKey) (nID - ID_CALLWINDOW_DTMF_1) );
   }   
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// ToolTips
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
BOOL CPhonePad::OnTabToolTip( UINT id, NMHDR * pNMHDR, LRESULT * pResult )
{
	// need to handle both ANSI and UNICODE versions of the message
	TOOLTIPTEXTA* pTTTA = (TOOLTIPTEXTA*)pNMHDR;
	TOOLTIPTEXTW* pTTTW = (TOOLTIPTEXTW*)pNMHDR;
	CString strTipText;
	SIZE_T nID = pNMHDR->idFrom;
	if (pNMHDR->code == TTN_NEEDTEXTA && (pTTTA->uFlags & TTF_IDISHWND) ||
		pNMHDR->code == TTN_NEEDTEXTW && (pTTTW->uFlags & TTF_IDISHWND))
	{
		// idFrom is actually the HWND of the tool
      nID = ::GetDlgCtrlID((HWND)nID);
	}

	if (nID != 0) // will be zero on a separator
	{
      CString sToken,sTip;
      sTip.LoadString((UINT32) nID);
      ParseToken(sTip,sToken,'\n');
      strTipText = sTip;
	}
#ifndef _UNICODE
	if (pNMHDR->code == TTN_NEEDTEXTA)
		lstrcpyn(pTTTA->szText, strTipText, sizeof(pTTTA->szText));
	else
		_mbstowcsz(pTTTW->szText, strTipText, sizeof(pTTTW->szText));
#else
	if (pNMHDR->code == TTN_NEEDTEXTA)
		_wcstombsz(pTTTA->szText, strTipText, sizeof(pTTTA->szText));
	else
		lstrcpyn(pTTTW->szText, strTipText, sizeof(pTTTW->szText));
#endif
	*pResult = 0;

	return TRUE;    // message was handled
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

void CPhonePad::OnShowWindow(BOOL bShow, UINT nStatus) 
{
   // Ignore size requests when parent is minimizing
   if ( nStatus == SW_PARENTCLOSING ) return;

	CDialog::OnShowWindow(bShow, nStatus);
	
}

void CPhonePad::OnCancel()
{
   DestroyWindow();
   m_hwndToolBar = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\queue.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////
// queue.h : header file
/////////////////////////////////////////////////////////////////////////////////////////

#ifndef _QUEUE_H_
#define _QUEUE_H_

#define  EVENT_SHUTDOWN    0
#define  EVENT_SIGNAL      1

/////////////////////////////////////////////////////////////////////////////
//CLASS CQueue
/////////////////////////////////////////////////////////////////////////////
class CQueue 
{
// Construction
public:
   CQueue();

// Attributes
public:
protected:
   CPtrList				m_QList;
   HANDLE				m_hEvents[2];                    //For queue read (synchronous) access and shutdown
   HANDLE				m_hEnd;
   CRITICAL_SECTION		m_csQueueLock;                   //Sync on CPtrList resource

// Operations
public: 
   void*    ReadTail();
   BOOL     WriteHead(void* pVoid);
   void     Terminate();

// Implementation
public:
   virtual ~CQueue();
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#endif // _QUEUE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\queue.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////
// queue.cpp : implementation file
/////////////////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "queue.h"
#include "avtrace.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLASS CQueue
/////////////////////////////////////////////////////////////////////////////
CQueue::CQueue()
{
   m_hEvents[EVENT_SIGNAL] = CreateEvent( NULL, true, false, NULL );
   m_hEvents[EVENT_SHUTDOWN] = CreateEvent( NULL, true, false, NULL );
   m_hEnd = CreateEvent( NULL, false, false, NULL );

   InitializeCriticalSection(&m_csQueueLock);
}

/////////////////////////////////////////////////////////////////////////////
CQueue::~CQueue()
{ 
	ASSERT( !m_hEnd );		// must call terminate

	// Clean out list
	while ( m_QList.GetHeadPosition() )
		delete m_QList.RemoveHead();

	DeleteCriticalSection(&m_csQueueLock);
}

/////////////////////////////////////////////////////////////////////////////
void CQueue::Terminate()
{
   if ( m_hEvents[EVENT_SHUTDOWN] )
   {
		SetEvent( m_hEvents[EVENT_SHUTDOWN] );

		if (  WaitForSingleObject(m_hEnd, 5000) != WAIT_OBJECT_0 )
			AVTRACE(_T("CQueue::Terminate() -- failed waiting for thread exit"));
   }

   if (m_hEvents[EVENT_SIGNAL])		CloseHandle( m_hEvents[EVENT_SIGNAL] );
   if (m_hEvents[EVENT_SHUTDOWN])	CloseHandle(m_hEvents[EVENT_SHUTDOWN]);
   if ( m_hEnd )					CloseHandle( m_hEnd );

   m_hEvents[EVENT_SHUTDOWN] = m_hEvents[EVENT_SIGNAL] = m_hEnd = NULL;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CQueue::WriteHead(void* pVoid)
{
	ASSERT(pVoid);

	EnterCriticalSection(&m_csQueueLock);
	m_QList.AddHead(pVoid);
	LeaveCriticalSection(&m_csQueueLock);

	SetEvent(m_hEvents[EVENT_SIGNAL]);                //signal waiting threads
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
void* CQueue::ReadTail()
{     
   void* pVoid = NULL;

	// Reset event if the list appears empty
	EnterCriticalSection(&m_csQueueLock);
	if ( m_QList.IsEmpty() )
		ResetEvent( m_hEvents[EVENT_SIGNAL] );
	LeaveCriticalSection(&m_csQueueLock);

	DWORD dwWait = WaitForMultipleObjects( 2, m_hEvents, false, INFINITE );
	switch ( dwWait )
	{
		case WAIT_OBJECT_0 + 1:
			EnterCriticalSection(&m_csQueueLock);
			pVoid = (void *) m_QList.RemoveTail();
			LeaveCriticalSection(&m_csQueueLock);
			break;

		case WAIT_OBJECT_0:
			AVTRACE(_T(".enter.CQueue::ReadTail() -- shutting down queue."));
		default:
			SetEvent( m_hEnd );
			break;
	}

	return pVoid;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\port.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

#ifndef __PORT_H__
#define __PORT_H__ 1

#include <windows.h>     

#if defined(__CPLUSPLUS__) || defined(__cplusplus)
extern "C" {
#endif
                     
// some of these #defines are commented out because
// Visual C++ sets them on the compiler command line instead

//#define _DEBUG
//#define WIN32
//#define WIN16
//#define _WINDOWS
//#define __MWERKS__
//#define INCLUDEMFC

#define	vCardClipboardFormat		"+//ISBN 1-887687-00-9::versit::PDI//vCard"
#define	vCalendarClipboardFormat	"+//ISBN 1-887687-00-9::versit::PDI//vCalendar"

/* The above strings vCardClipboardFormat and vCalendarClipboardFormat 
are globally unique IDs which can be used to generate clipboard format 
ID's as per the requirements of a specific platform. For example, in 
Windows they are used as the parameter in a call to RegisterClipboardFormat. 
For example:

  CLIPFORMAT foo = RegisterClipboardFormat(vCardClipboardFormat);

*/

#define vCardMimeType		"text/x-vCard"
#define vCalendarMimeType	"text/x-vCalendar"

                
#if defined(WIN32) || defined(_WIN32)
#define DLLEXPORT(t)   __declspec(dllexport) t
#else
#define DLLEXPORT(t)   t CALLBACK __export
#endif
    
#if defined(_STANDALONE)
#undef DLLEXPORT
#define DLLEXPORT(t) t
#endif

#ifndef FALSE
#define FALSE	0
#endif
#ifndef TRUE
#define TRUE	1
#endif


#if defined(__CPLUSPLUS__) || defined(__cplusplus)
}
#endif

#endif // __PORT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\previewwnd.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "tmeter.h"
#include "PreviewWnd.h"
#include "resource.h"
#include "avtrace.h"
#include "avDialerDoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Defines
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#define VIDEOPREVIEW_AUDIOMIXER_TIMER              1
#define VIDEOPREVIEW_AUDIOMIXER_TIMER_INTERVAL     200

enum
{
   VIDEOPREVIEW_MEDIA_CONTROLS_IMAGE_AUDIOIN=0,
   VIDEOPREVIEW_MEDIA_CONTROLS_IMAGE_AUDIOOUT,
   VIDEOPREVIEW_MEDIA_CONTROLS_IMAGE_VIDEO,
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CVideoPreviewWnd
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DYNAMIC(CVideoPreviewWnd,CCallWnd)

/////////////////////////////////////////////////////////////////////////////
CVideoPreviewWnd::CVideoPreviewWnd()
{
	//{{AFX_DATA_INIT(CVideoPreviewWnd)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

   m_nNumToolbarItems = 3;
   m_bIsPreview = true;

   m_hMediaImageList = NULL;
   
   m_hTMeter = TrackMeter_Init(AfxGetInstanceHandle(),NULL);
   m_uMixerTimer = 0;

   m_bAudioOnly = false;
}

/////////////////////////////////////////////////////////////////////////////
CVideoPreviewWnd::~CVideoPreviewWnd()
{
   if (m_hTMeter)
      TrackMeter_Term(m_hTMeter);
}


BEGIN_MESSAGE_MAP(CVideoPreviewWnd, CCallWnd)
	//{{AFX_MSG_MAP(CVideoPreviewWnd)
	ON_WM_PAINT()
	ON_WM_TIMER()
	ON_WM_DESTROY()
	ON_WM_HSCROLL()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
void CVideoPreviewWnd::DoDataExchange(CDataExchange* pDX)
{
	CCallWnd::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CVideoPreviewWnd)
 	DDX_Control(pDX, IDC_VIDEOPREVIEW_STATIC_MEDIATEXT, m_staticMediaText);
   DDX_Control(pDX, IDC_CALLCONTROL_STATIC_VIDEO, m_wndVideo);
	//}}AFX_DATA_MAP
}

/////////////////////////////////////////////////////////////////////////////
BOOL CVideoPreviewWnd::OnInitDialog()
{
   CCallWnd::OnInitDialog();

   m_staticMediaText.SetFont(&m_fontTextBold);

   CString sText;
   m_staticMediaText.GetWindowText(sText);
   SetWindowText(sText);

   m_hMediaImageList = ImageList_LoadBitmap(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDB_BUTTONBAR_MEDIA_CONTROLS),16,0,RGB_TRANS);

   //Load audio mixer support
   if ( (m_AvWav.IsInit() == FALSE) && (m_AvWav.Init(m_pDialerDoc)) )
   {
      //OnInit we don't have a current call so just use preferred device for the mixer
      SetMixers(DIALER_MEDIATYPE_UNKNOWN);
   }
   return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
void CVideoPreviewWnd::OnDestroy() 
{
   // Clean up
   if (m_uMixerTimer)
   {
      KillTimer(m_uMixerTimer);
      m_uMixerTimer = NULL;
   }

   //close any existing mixer device
   m_AvWav.CloseWavMixer(AVWAV_AUDIODEVICE_IN);
   m_AvWav.CloseWavMixer(AVWAV_AUDIODEVICE_OUT);

   if ( m_hMediaImageList )   ImageList_Destroy( m_hMediaImageList ); 

   CCallWnd::OnDestroy();
}

/////////////////////////////////////////////////////////////////////////////
void CVideoPreviewWnd::SetMixers(DialerMediaType dmtMediaType)
{
   HWND hwndTrackMeterIn = ::GetDlgItem(GetSafeHwnd(),IDC_VIDEOPREVIEW_SLIDER_AUDIOIN);
   HWND hwndTrackMeterOut = ::GetDlgItem(GetSafeHwnd(),IDC_VIDEOPREVIEW_SLIDER_AUDIOOUT);
   bool bSetTimer = false;

   if ( (hwndTrackMeterIn) && (OpenMixerWithTrackMeter(dmtMediaType,AVWAV_AUDIODEVICE_IN,hwndTrackMeterIn)) )
   {
      bSetTimer = true;
   }
   if ( (hwndTrackMeterOut) && (OpenMixerWithTrackMeter(dmtMediaType,AVWAV_AUDIODEVICE_OUT,hwndTrackMeterOut)) )
   {
      bSetTimer = true;
   }
   if (bSetTimer)
   {
      //if we dont't have a mixer timer, then set the timer
      //if we already have a timer, then leave it
      if (m_uMixerTimer == 0)
         m_uMixerTimer = SetTimer(VIDEOPREVIEW_AUDIOMIXER_TIMER,VIDEOPREVIEW_AUDIOMIXER_TIMER_INTERVAL,NULL); 
   }
   else
   {
      //kill the previous timer, we don't need it anymore
      if (m_uMixerTimer)
      {
         KillTimer(m_uMixerTimer);
         m_uMixerTimer = NULL;
      }
   }
}

/////////////////////////////////////////////////////////////////////////////
bool CVideoPreviewWnd::OpenMixerWithTrackMeter(DialerMediaType dmtMediaType,AudioDeviceType adt,HWND hwndTrackMeter)
{
   ASSERT(hwndTrackMeter);
   bool bRet = false;

   CString sDeviceId;
   CDialerRegistry::GetAudioDevice(dmtMediaType,adt,sDeviceId);

   //map to real device id's, blank name will get the preferred device
   int nDeviceId = m_AvWav.GetWavIdByName(adt,sDeviceId);

   //init the mixer device, if a mixer is already open for the given adt it will be closed.
   //if the same device is being opened for the adt then nothing will happen
   if ( (nDeviceId != -1) && (bRet = m_AvWav.OpenWavMixer(adt,nDeviceId)) )
   {
      ::EnableWindow(hwndTrackMeter,TRUE);
      SetTrackMeterPos(adt,hwndTrackMeter);
   }
   else
   {
      //disable the track
      ::EnableWindow(hwndTrackMeter,FALSE);
      TrackMeter_SetPos(hwndTrackMeter, 0, TRUE);
      //take out the thumb?
      //DWORD dwStyle = ::GetWindowLong(hwndTrackMeter,GWL_STYLE);
      //dwStyle |= TMS_NOTHUMB;
      //::SetWindowLong(hwndTrackMeter,GWL_STYLE,dwStyle);
   }
   return bRet;
}

/////////////////////////////////////////////////////////////////////////////
void CVideoPreviewWnd::SetTrackMeterPos(AudioDeviceType adt,HWND hwndTrackMeter)
{
   ASSERT(hwndTrackMeter);
   //set the volume level
   int nVolume = m_AvWav.GetWavMixerVolume(adt);
   if (nVolume != -1)
   {
      TrackMeter_SetPos(hwndTrackMeter, nVolume, TRUE);
   }
   else
   {
       //
       // Dissable the track
       //

       ::EnableWindow( hwndTrackMeter, FALSE);
   }
}

/////////////////////////////////////////////////////////////////////////////
void CVideoPreviewWnd::SetTrackMeterLevel(AudioDeviceType adt,HWND hwndTrackMeter)
{
   ASSERT(hwndTrackMeter);
   //set the meter level
   int nLevel = m_AvWav.GetWavMixerLevel(adt);
   if (nLevel != -1)
   {
      TrackMeter_SetLevel(hwndTrackMeter, nLevel, TRUE);
   }
}

/////////////////////////////////////////////////////////////////////////////
//virtual function of CCallWindow Base Class
void CVideoPreviewWnd::DoActiveWindow(BOOL bActive)
{
   m_staticMediaText.SetFocusState(bActive);
}

/////////////////////////////////////////////////////////////////////////////
void CVideoPreviewWnd::SetMediaWindow()
{
   //tell the doc to set the preview window
   if ( m_pDialerDoc )
      m_pDialerDoc->SetPreviewWindow(m_nCallId, true);
}

/////////////////////////////////////////////////////////////////////////////
void CVideoPreviewWnd::SetAudioOnly(bool bAudioOnly)
{
   if (m_bAudioOnly == bAudioOnly) return;

   //set the state
   m_bAudioOnly = bAudioOnly;

   //is dragging allowed
   m_bAllowDrag = (bAudioOnly)?FALSE:TRUE;

   //if we are showing the floater right now, notify it
   if (::IsWindow(m_wndFloater.GetSafeHwnd()))
   {
      m_wndFloater.SetAudioOnly(bAudioOnly);
   }

   if (m_bAudioOnly)
   {
      m_dibVideoImage.DeleteObject();
      m_dibVideoImage.Load(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDB_VIDEO_AUDIO_ONLY1));
   }
   else
   {
      //put the standard green screen back
      m_dibVideoImage.DeleteObject();
      m_dibVideoImage.Load(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDB_VIDEO_SCREEN1));
   }

   //repaint
   CRect rcVideo;
   m_wndVideo.GetWindowRect(rcVideo);
   ScreenToClient(rcVideo);
   InvalidateRect(rcVideo);
}

/////////////////////////////////////////////////////////////////////////////
void CVideoPreviewWnd::OnPaint() 
{
	CPaintDC dc(this); // device context for painting

   if (m_hMediaImageList)
   {
      CRect rcWindow;

      CWnd* pStaticWnd = GetDlgItem(IDC_VIDEOPREVIEW_STATIC_IMAGE_AUDIOIN);
      ASSERT(pStaticWnd);
      pStaticWnd->GetWindowRect(rcWindow);
      ScreenToClient(rcWindow);
      ImageList_Draw(m_hMediaImageList,VIDEOPREVIEW_MEDIA_CONTROLS_IMAGE_AUDIOIN,dc.GetSafeHdc(),rcWindow.left,rcWindow.top,ILD_TRANSPARENT);

      pStaticWnd = GetDlgItem(IDC_VIDEOPREVIEW_STATIC_IMAGE_AUDIOOUT);
      ASSERT(pStaticWnd);
      pStaticWnd->GetWindowRect(rcWindow);
      ScreenToClient(rcWindow);
      ImageList_Draw(m_hMediaImageList,VIDEOPREVIEW_MEDIA_CONTROLS_IMAGE_AUDIOOUT,dc.GetSafeHdc(),rcWindow.left,rcWindow.top,ILD_TRANSPARENT);
   }

   Paint( dc );
}

/////////////////////////////////////////////////////////////////////////////
void CVideoPreviewWnd::OnTimer(UINT nIDEvent) 
{
   //audio mixer timer
   if (nIDEvent == VIDEOPREVIEW_AUDIOMIXER_TIMER)
   {
      if (IsWindowVisible())
      {
         HWND hwndTrackMeter = ::GetDlgItem(GetSafeHwnd(),IDC_VIDEOPREVIEW_SLIDER_AUDIOIN);
         if (hwndTrackMeter)
         {
            SetTrackMeterLevel(AVWAV_AUDIODEVICE_IN,hwndTrackMeter);
            SetTrackMeterPos(AVWAV_AUDIODEVICE_IN,hwndTrackMeter);
         }

         hwndTrackMeter = ::GetDlgItem(GetSafeHwnd(),IDC_VIDEOPREVIEW_SLIDER_AUDIOOUT);
         if (hwndTrackMeter)
         {
            SetTrackMeterLevel(AVWAV_AUDIODEVICE_OUT,hwndTrackMeter);
            SetTrackMeterPos(AVWAV_AUDIODEVICE_OUT,hwndTrackMeter);
         }
      }
   }
	CCallWnd::OnTimer(nIDEvent);
}

/////////////////////////////////////////////////////////////////////////////
void CVideoPreviewWnd::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) 
{
   switch (nSBCode)
   {
      case SB_ENDSCROLL:
      case SB_THUMBTRACK:
      {
         //set the volume levels
         int nVolume = m_AvWav.GetWavMixerVolume(AVWAV_AUDIODEVICE_IN);
         if (nVolume != -1)
         {
            HWND hwndTrackMeter = ::GetDlgItem(GetSafeHwnd(),IDC_VIDEOPREVIEW_SLIDER_AUDIOIN);
            if (hwndTrackMeter)
            {
               nVolume = TrackMeter_GetPos(hwndTrackMeter);
               m_AvWav.SetWavMixerVolume(AVWAV_AUDIODEVICE_IN,nVolume);
            }
         }

         nVolume = m_AvWav.GetWavMixerVolume(AVWAV_AUDIODEVICE_OUT);
         if (nVolume != -1)
         {
            HWND hwndTrackMeter = ::GetDlgItem(GetSafeHwnd(),IDC_VIDEOPREVIEW_SLIDER_AUDIOOUT);
            if (hwndTrackMeter)
            {
               nVolume = TrackMeter_GetPos(hwndTrackMeter);
               m_AvWav.SetWavMixerVolume(AVWAV_AUDIODEVICE_OUT,nVolume);
            }
         }
      }
   }
   
	CCallWnd::OnHScroll(nSBCode, nPos, pScrollBar);
}

/////////////////////////////////////////////////////////////////////////////
//for drag/drop of sliders to left/right sides of desktop
//we must define our own area for context and return true if we within 
//that area
BOOL CVideoPreviewWnd::IsMouseOverForDragDropOfSliders(CPoint& point)
{
   //check if we are trying to move sliders.  We will use the caption text window
   //for context
   CWnd* pCaptionWnd = GetDlgItem(IDC_VIDEOPREVIEW_STATIC_MEDIATEXT);
   if (pCaptionWnd == NULL) return FALSE;

   //get context area
   CRect rcCaption;
   pCaptionWnd->GetWindowRect(rcCaption);
   ScreenToClient(rcCaption);
  
   return rcCaption.PtInRect(point);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\resolver.cpp ===
////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////
// resolver.cpp : implementation of the CResolveUser class
/////////////////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "mainfrm.h"
#include "resolver.h"
#include "ds.h"
#include "directory.h"
#include "tapidialer.h"

IMPLEMENT_DYNCREATE(CResolveUser, CObject)
IMPLEMENT_DYNCREATE(CResolveUserObject, CObject)

/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
//Class CResolveUser
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////
CResolveUser::CResolveUser()
{
   m_pDirectory = NULL;
   m_pParentWnd = NULL;
   InitializeCriticalSection(&m_csDataLock);
}

/////////////////////////////////////////////////////////////////////////////////////////
CResolveUser::~CResolveUser()
{
   if (m_pDirectory)
   {
      delete m_pDirectory;
      m_pDirectory = NULL;
   }

   ClearUsersDS();
   ClearUsersILS();

   DeleteCriticalSection(&m_csDataLock);
}

/////////////////////////////////////////////////////////////////////////////////////////
BOOL CResolveUser::Init()
{
   m_pDirectory = new CDirectory;
   m_pDirectory->Initialize();

   return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////////////
BOOL CResolveUser::AddUser(CDSUser* pDSUser)
{
   EnterCriticalSection(&m_csDataLock);
   m_DSUsers.AddTail(pDSUser);
   LeaveCriticalSection(&m_csDataLock);
   return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////////////
void CResolveUser::ClearUsersDS()
{
   EnterCriticalSection(&m_csDataLock);
   DeleteList(&m_DSUsers);
   LeaveCriticalSection(&m_csDataLock);
}

/////////////////////////////////////////////////////////////////////////////////////////
BOOL CResolveUser::AddUser(CILSUser* pILSUser)
{
   EnterCriticalSection(&m_csDataLock);
   m_ILSUsers.AddTail(pILSUser);
   LeaveCriticalSection(&m_csDataLock);
   return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////////////
void CResolveUser::ClearUsersILS()
{
   EnterCriticalSection(&m_csDataLock);
   DeleteList(&m_ILSUsers);
   LeaveCriticalSection(&m_csDataLock);
}

/////////////////////////////////////////////////////////////////////////////////////////
BOOL CResolveUser::ResolveAddress(LPCTSTR szAddress,CString& sName,CString& sUser1,CString& sUser2)
{
   BOOL bFound = FALSE;

   //We are not really looking for devices, but just call id information.  Just try a few combo's
   //to try to find the id.  Do show any UI on this call.
   CString sResolvedAddress;
   if ( (ResolveAddressEx(szAddress,LINEADDRESSTYPE_SDP,DIALER_MEDIATYPE_UNKNOWN,DIALER_LOCATIONTYPE_UNKNOWN,sName,sResolvedAddress,sUser1,sUser2,false)) ||
        (ResolveAddressEx(szAddress,LINEADDRESSTYPE_EMAILNAME,DIALER_MEDIATYPE_UNKNOWN,DIALER_LOCATIONTYPE_UNKNOWN,sName,sResolvedAddress,sUser1,sUser2,false)) ||
        (ResolveAddressEx(szAddress,LINEADDRESSTYPE_PHONENUMBER,DIALER_MEDIATYPE_UNKNOWN,DIALER_LOCATIONTYPE_UNKNOWN,sName,sResolvedAddress,sUser1,sUser2,false)) )
   {
      bFound = TRUE;
   }

   return bFound;
}

/////////////////////////////////////////////////////////////////////////////////////////
//szAddress - address to work with
//lAddressType - type of address (i.e. email address, phone number)
//dmtMediaType - media type to dial

//e.g. input - Kevin,LINEADDRESSTYPE_SDP,DIALER_MEDIATYPE_POTS,DIALER_LOCATIONTYPE_BUSINESS
//e.g. output - (425)313-1313, Kevin Chestnut, kchestnut@activevoice.com
BOOL CResolveUser::ResolveAddressEx(LPCTSTR szAddress,
                                    long lAddressType,
                                    DialerMediaType dmtMediaType,
                                    DialerLocationType dmtLocationType,
                                    CString& sName,
                                    CString& sResolvedAddress,
                                    CString& sUser1,
                                    CString& sUser2,
                                    bool bShowUI)
{
   EnterCriticalSection(&m_csDataLock);

   BOOL bRet;
   if (bShowUI == false)
      bRet = FALSE;              //by default we return false.  We did not find any caller id
   else 
      bRet = TRUE;               //by default we return true so call can proceed

   //assumption:  LINEADDRESSTYPE_SDP represents a name.  This is really for conferences, but 
   //we will never be asked to resolve conferences and we needed something that represented names.

   //all of our finds will go here
   CObList ResolveUserObjectList;

   //set up callentry for selected call.  This is where the data will be filled in for
   //the resolved call.
   CCallEntry callentry;
   callentry.m_MediaType = dmtMediaType;
   callentry.m_LocationType = dmtLocationType;
   callentry.m_lAddressType = lAddressType;
   callentry.m_sAddress = szAddress;

   //try WAB Users
   CObList WabList;
   if (FindAddressInWAB(szAddress,lAddressType,WabList))
   {
      POSITION pos = WabList.GetHeadPosition();
      while (pos)
      {
         CWABEntry* pWABEntry = (CWABEntry*)WabList.GetNext(pos);
         UserObjectList_AddUser(&ResolveUserObjectList,pWABEntry);
      }
   }

   //lookup information in ILS
   CILSUser* pILSUser = NULL;
   if (pILSUser = FindAddressInILS(szAddress))
   {
      UserObjectList_AddUser(&ResolveUserObjectList,pILSUser);
   }

   //lookup information in DS.  
   CDSUser* pDSUser = NULL;
   if (pDSUser = FindAddressInDS(szAddress))
   {
      UserObjectList_AddUser(&ResolveUserObjectList,pDSUser);
   }

   //if we found something
   if (ResolveUserObjectList.GetCount() > 0)
   {
      if (bShowUI)
      {
         //put up UI for selection
         if ( (m_pParentWnd) && (::IsWindow(m_pParentWnd->GetSafeHwnd())) )
         bRet = (BOOL)::SendMessage(m_pParentWnd->GetSafeHwnd(),WM_ACTIVEDIALER_INTERFACE_RESOLVEUSER,(WPARAM)&callentry,(LPARAM)&ResolveUserObjectList);
      }
      else
      {
         //just pick out the first and get call info
         CResolveUserObject* pUserObject = (CResolveUserObject*)ResolveUserObjectList.GetHead();
         ASSERT(pUserObject);
         bRet = FillCallEntry(pUserObject,&callentry);
      }
   }

   //get data out of call entry
   sName = callentry.m_sDisplayName;
   sResolvedAddress = callentry.m_sAddress;
   sUser1 = callentry.m_sUser1;
   sUser2 = callentry.m_sUser2;

   //delete temp WabList
   DeleteList(&WabList);
   //delete user object list
   UserObjectList_EmptyList(&ResolveUserObjectList);

   LeaveCriticalSection(&m_csDataLock);

   return bRet;
}

/////////////////////////////////////////////////////////////////////////////////////////
BOOL CResolveUser::FindAddressInWAB(LPCTSTR szAddress,long lAddressType,CObList& WabList)
{
   BOOL bRet = FALSE;

   if (m_pDirectory == NULL) return FALSE;

   //we are given a name in szAddress
   if (lAddressType == LINEADDRESSTYPE_SDP)
   {
      if (!( (m_pDirectory->WABSearchByStringProperty(PR_DISPLAY_NAME,szAddress,&WabList) != DIRERR_SUCCESS) &&
           (m_pDirectory->WABSearchByStringProperty(PR_GIVEN_NAME,szAddress,&WabList) != DIRERR_SUCCESS) &&
           (m_pDirectory->WABSearchByStringProperty(PR_SURNAME,szAddress,&WabList) != DIRERR_SUCCESS) ))
      {
         if (WabList.GetCount() > 0)
            bRet = TRUE;         
      }
   }
   //we are given a email address in szAddress
   //***There are collections of email addresses in WAB.  We need to check the collection as well.
   else if (lAddressType == LINEADDRESSTYPE_EMAILNAME)
   {
      if (m_pDirectory->WABSearchByStringProperty(PR_EMAIL_ADDRESS,szAddress,&WabList) == DIRERR_SUCCESS)
      {
         if (WabList.GetCount() > 0)
            bRet = TRUE;         
      }
   }
   //we are given a phone number
   else if (lAddressType == LINEADDRESSTYPE_PHONENUMBER)
   {
      if (!( (m_pDirectory->WABSearchByStringProperty(PR_BUSINESS_TELEPHONE_NUMBER,szAddress,&WabList) != DIRERR_SUCCESS) &&
           (m_pDirectory->WABSearchByStringProperty(PR_OFFICE_TELEPHONE_NUMBER,szAddress,&WabList) != DIRERR_SUCCESS) &&
           (m_pDirectory->WABSearchByStringProperty(PR_PRIMARY_TELEPHONE_NUMBER,szAddress,&WabList) != DIRERR_SUCCESS) &&
           (m_pDirectory->WABSearchByStringProperty(PR_PAGER_TELEPHONE_NUMBER,szAddress,&WabList) != DIRERR_SUCCESS) &&
           (m_pDirectory->WABSearchByStringProperty(PR_CELLULAR_TELEPHONE_NUMBER,szAddress,&WabList) != DIRERR_SUCCESS) &&
           (m_pDirectory->WABSearchByStringProperty(PR_HOME_TELEPHONE_NUMBER,szAddress,&WabList) != DIRERR_SUCCESS) &&
           (m_pDirectory->WABSearchByStringProperty(PR_PRIMARY_FAX_NUMBER,szAddress,&WabList) != DIRERR_SUCCESS) &&
           (m_pDirectory->WABSearchByStringProperty(PR_MOBILE_TELEPHONE_NUMBER,szAddress,&WabList) != DIRERR_SUCCESS) ))
      {
         if (WabList.GetCount() > 0)
            bRet = TRUE;         
      }
   }
   else if (lAddressType == LINEADDRESSTYPE_DOMAINNAME)
   {
      1;
   }
   return bRet;
}

/////////////////////////////////////////////////////////////////////////////////////////
CDSUser* CResolveUser::FindAddressInDS(LPCTSTR szAddress)
{
   CDSUser* pRetDSUser = NULL;

   //try DS Users
   POSITION pos = m_DSUsers.GetHeadPosition();
   while (pos)
   {
      CDSUser* pDSUser = (CDSUser*)m_DSUsers.GetNext(pos);
      ASSERT(pDSUser);
      if (_tcsicmp(pDSUser->m_sIPAddress,szAddress) == 0)
      {
         pRetDSUser = pDSUser;
         break;
      }
      else if (_tcsicmp(pDSUser->m_sPhoneNumber,szAddress) == 0)
      {
         pRetDSUser = pDSUser;
         break;
      }
      else if (_tcsicmp(pDSUser->m_sUserName,szAddress) == 0)
      {
         pRetDSUser = pDSUser;
         break;
      }
   }
   return pRetDSUser;
}

/////////////////////////////////////////////////////////////////////////////////////////
CILSUser* CResolveUser::FindAddressInILS(LPCTSTR szAddress)
{
   CILSUser* pRetILSUser = NULL;

   POSITION pos = m_ILSUsers.GetHeadPosition();
   while (pos)
   {
      CILSUser* pILSUser = (CILSUser*)m_ILSUsers.GetNext(pos);
      ASSERT(pILSUser);
      if (_tcsicmp(pILSUser->m_sIPAddress,szAddress) == 0)
      {
         pRetILSUser = pILSUser;
         break;
      }
      else if (_tcsicmp(pILSUser->m_sUserName,szAddress) == 0)
      {
         pRetILSUser = pILSUser;
         break;
      }
   }
   return pRetILSUser;
}

/////////////////////////////////////////////////////////////////////////////////////////
void CResolveUser::UserObjectList_AddUser(CObList* pList,CWABEntry* pWABEntry)
{
   //Given this WABEntry, can we find CDSUser or CILSUser objects?
   CString sData;
   CILSUser* pILSUser = NULL;
   CDSUser* pDSUser = NULL;

   //get display name
   m_pDirectory->WABGetStringProperty(pWABEntry,PR_DISPLAY_NAME,sData);

   bool bAdded = false;
   if (pDSUser = FindAddressInDS(sData))
   {
      //does this DS user already exist in list
      POSITION pos = pList->GetHeadPosition();
      while (pos)
      {
         CResolveUserObject* pUserObject = (CResolveUserObject*)pList->GetNext(pos);
         if ( (pUserObject->m_pDSUser) && (*pUserObject->m_pDSUser == pDSUser) )
         {
            pUserObject->m_pWABEntry = pWABEntry;
            bAdded = true;
         }
      }
   }
   else if (pILSUser = FindAddressInILS(sData))
   {
      //does this ILS user already exist in list
      POSITION pos = pList->GetHeadPosition();
      while (pos)
      {
         CResolveUserObject* pUserObject = (CResolveUserObject*)pList->GetNext(pos);
         if ( (pUserObject->m_pILSUser) && (*pUserObject->m_pILSUser == pILSUser) )
         {
            //add our WAB to this UserObject
            pUserObject->m_pWABEntry = pWABEntry;
            bAdded = true;
         }
      }
   }

   if (bAdded == false)
   {
      //add new item to list
      CResolveUserObject* pUserObject = new CResolveUserObject;
      pUserObject->m_pWABEntry = pWABEntry;
      pUserObject->m_pDSUser = pDSUser;
      pUserObject->m_pILSUser = pILSUser;
      pList->AddTail(pUserObject);
   }
}


/////////////////////////////////////////////////////////////////////////////////////////
void CResolveUser::UserObjectList_AddUser(CObList* pList,CILSUser* pILSUser)
{
   CDSUser* pDSUser = NULL;
   CWABEntry* pWABEntry = NULL;

   //Given this CILSUser, can we find CDSUser or CWABEntry objects?
   bool bAdded = false;
   
   //check DS vs. the username and ip address of this ILS user
   if ( (pDSUser = FindAddressInDS(pILSUser->m_sUserName)) ||
        (pDSUser = FindAddressInDS(pILSUser->m_sIPAddress)) )
   {
      //does this DS user already exist in list
      POSITION pos = pList->GetHeadPosition();
      while (pos)
      {
         CResolveUserObject* pUserObject = (CResolveUserObject*)pList->GetNext(pos);
         if ( (pUserObject->m_pDSUser) && (*pUserObject->m_pDSUser == pDSUser) )
         {
            //add our ILS to this UserObject
            pUserObject->m_pILSUser = pILSUser;
            bAdded = true;
         }
      }
   }
   //now check the wab for any matches.  Try pDSUser if avail now
   CObList WabList;
   if ( (FindAddressInWAB(pILSUser->m_sUserName,LINEADDRESSTYPE_SDP,WabList)) ||
        (FindAddressInWAB(pILSUser->m_sUserName,LINEADDRESSTYPE_EMAILNAME,WabList)) ||
        (FindAddressInWAB(pILSUser->m_sIPAddress,LINEADDRESSTYPE_DOMAINNAME,WabList)) ||
        (FindAddressInWAB(pILSUser->m_sIPAddress,LINEADDRESSTYPE_IPADDRESS,WabList)) ||
        ( (pDSUser) && (FindAddressInWAB(pDSUser->m_sUserName,LINEADDRESSTYPE_SDP,WabList)) ) || 
        ( (pDSUser) && (FindAddressInWAB(pDSUser->m_sUserName,LINEADDRESSTYPE_EMAILNAME,WabList)) ) || 
        ( (pDSUser) && (FindAddressInWAB(pDSUser->m_sIPAddress,LINEADDRESSTYPE_IPADDRESS,WabList)) ) || 
        ( (pDSUser) && (FindAddressInWAB(pDSUser->m_sPhoneNumber,LINEADDRESSTYPE_PHONENUMBER,WabList)) ) )
   {
      //only take the first find
      if (pWABEntry = (CWABEntry*)WabList.GetHead())
      {
         //does this WAB user already exist in list
         POSITION pos = pList->GetHeadPosition();
         while (pos)
         {
            CResolveUserObject* pUserObject = (CResolveUserObject*)pList->GetNext(pos);
            if ( (pUserObject->m_pWABEntry) && (*pUserObject->m_pWABEntry == pWABEntry) )
            {
               //add our ILS to this UserObject
               pUserObject->m_pILSUser = pILSUser;
               bAdded = true;
            }
         }
      }
   }

   if (bAdded == false)
   {
      //add new item to list
      CResolveUserObject* pUserObject = new CResolveUserObject;
      pUserObject->m_pWABEntry = pWABEntry;
      pUserObject->m_pDSUser = pDSUser;
      pUserObject->m_pILSUser = pILSUser;
      pList->AddTail(pUserObject);
   }
}

/////////////////////////////////////////////////////////////////////////////////////////
void CResolveUser::UserObjectList_AddUser(CObList* pList,CDSUser* pDSUser)
{
   CILSUser* pILSUser = NULL;
   CWABEntry* pWABEntry = NULL;

   //Given this CDSUser, can we find CILSUser or CWABEntry objects?
   bool bAdded = false;
   
   //check ILS vs. the username and ip address of this DS user
   if ( (pILSUser = FindAddressInILS(pDSUser->m_sUserName)) ||
        (pILSUser = FindAddressInILS(pDSUser->m_sIPAddress)) ||
        (pILSUser = FindAddressInILS(pDSUser->m_sPhoneNumber)) )
   {
      //does this DS user already exist in list
      POSITION pos = pList->GetHeadPosition();
      while (pos)
      {
         CResolveUserObject* pUserObject = (CResolveUserObject*)pList->GetNext(pos);
         if ( (pUserObject->m_pILSUser) && (*pUserObject->m_pILSUser == pILSUser) )
         {
            //add our DS to this UserObject
            pUserObject->m_pDSUser = pDSUser;
            bAdded = true;
         }
      }
   }
   //now check the wab for any matches.  Try pDSUser if avail now
   CObList WabList;
   if ( (FindAddressInWAB(pDSUser->m_sUserName,LINEADDRESSTYPE_SDP,WabList)) ||
        (FindAddressInWAB(pDSUser->m_sUserName,LINEADDRESSTYPE_EMAILNAME,WabList)) ||
        (FindAddressInWAB(pDSUser->m_sIPAddress,LINEADDRESSTYPE_IPADDRESS,WabList)) ||
        (FindAddressInWAB(pDSUser->m_sPhoneNumber,LINEADDRESSTYPE_PHONENUMBER,WabList)) ||
        ( (pILSUser) && (FindAddressInWAB(pDSUser->m_sUserName,LINEADDRESSTYPE_SDP,WabList)) ) || 
        ( (pILSUser) && (FindAddressInWAB(pDSUser->m_sUserName,LINEADDRESSTYPE_EMAILNAME,WabList)) ) || 
        ( (pILSUser) && (FindAddressInWAB(pDSUser->m_sIPAddress,LINEADDRESSTYPE_DOMAINNAME,WabList)) ) || 
        ( (pILSUser) && (FindAddressInWAB(pDSUser->m_sIPAddress,LINEADDRESSTYPE_IPADDRESS,WabList)) ) )
   {
      //only take the first find
      if (pWABEntry = (CWABEntry*)WabList.GetHead())
      {
         //does this WAB user already exist in list
         POSITION pos = pList->GetHeadPosition();
         while (pos)
         {
            CResolveUserObject* pUserObject = (CResolveUserObject*)pList->GetNext(pos);
            if ( (pUserObject->m_pWABEntry) && (*pUserObject->m_pWABEntry == pWABEntry) )
            {
               //add our DS to this UserObject
               pUserObject->m_pDSUser = pDSUser;
               bAdded = true;
            }
         }
      }
   }

   if (bAdded == false)
   {
      //add new item to list
      CResolveUserObject* pUserObject = new CResolveUserObject;
      pUserObject->m_pWABEntry = pWABEntry;
      pUserObject->m_pDSUser = pDSUser;
      pUserObject->m_pILSUser = pILSUser;
      pList->AddTail(pUserObject);
   }
}

/////////////////////////////////////////////////////////////////////////////////////////
void CResolveUser::UserObjectList_EmptyList(CObList* pList)
{
   POSITION pos = pList->GetHeadPosition();
   while (pos)
   {
      delete pList->GetNext(pos);
   }
   pList->RemoveAll();
}

/////////////////////////////////////////////////////////////////////////////////////////
//Fill in
//   callentry.m_sDisplayName;
//   callentry.m_sUser1;
//   callentry.m_sUser2;
//from pUserObject
BOOL CResolveUser::FillCallEntry(CResolveUserObject* pUserObject,CCallEntry* pCallEntry)
{
   BOOL bRet = FALSE;
   //check WAB
   if ( (pUserObject->m_pWABEntry) && (m_pDirectory) )
   {
      m_pDirectory->WABGetStringProperty(pUserObject->m_pWABEntry,PR_DISPLAY_NAME,pCallEntry->m_sDisplayName);
      m_pDirectory->WABGetStringProperty(pUserObject->m_pWABEntry,PR_EMAIL_ADDRESS, pCallEntry->m_sUser1);
      m_pDirectory->WABGetStringProperty(pUserObject->m_pWABEntry,PR_BUSINESS_TELEPHONE_NUMBER, pCallEntry->m_sUser2);
      if (!pCallEntry->m_sDisplayName.IsEmpty())
         bRet = TRUE;
   }
   //check ILS
   else if (pUserObject->m_pILSUser)
   {
      pCallEntry->m_sDisplayName = pUserObject->m_pILSUser->m_sUserName;
      pCallEntry->m_sUser1 = pUserObject->m_pILSUser->m_sIPAddress;
      pCallEntry->m_sUser2 = _T("");
      if (!pCallEntry->m_sDisplayName.IsEmpty())
         bRet = TRUE;
   }
   //check DS
   else if (pUserObject->m_pDSUser)
   {
      pCallEntry->m_sDisplayName = pUserObject->m_pDSUser->m_sUserName;
      pCallEntry->m_sUser1 = pUserObject->m_pDSUser->m_sIPAddress;
      pCallEntry->m_sUser2 = pUserObject->m_pDSUser->m_sPhoneNumber;
      if (!pCallEntry->m_sDisplayName.IsEmpty())
         bRet = TRUE;
   }
   //we could check all the DS objects instead of just the first one we have.  This would
   //allow caller id from multiple DS locations.  For now we will just take the caller id
   //from the first DS object that we run across.
   return bRet;
}

/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
//class CResolveUserObject
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////
CResolveUserObject::CResolveUserObject()
{
   m_pDSUser = NULL;
   m_pILSUser = NULL;
   m_pWABEntry = NULL;
}

/////////////////////////////////////////////////////////////////////////////////////////
CResolveUserObject::~CResolveUserObject()
{
   //must delete all objects that have been set
   //we only have copies of objects so don't delete anything!!!
}
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\resolver.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////
// resolver.h : interface of the CResolveUser class

#ifndef _RESOLVER_H_
#define _RESOLVER_H_

#include "dialreg.h"

class CDSUser;
class CILSUser;
class CDirectory;
class CWABEntry;

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//CResolveUserObject
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class CResolveUserObject : public CObject
{
	DECLARE_DYNCREATE(CResolveUserObject)
public:
//construction
   CResolveUserObject();
   ~CResolveUserObject();
public:
   CDSUser*          m_pDSUser;
   CILSUser*         m_pILSUser;
   CWABEntry*        m_pWABEntry;
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Class CResolveUser
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class CResolveUser : public CObject
{
	DECLARE_DYNCREATE(CResolveUser)
public:
//construction
   CResolveUser();
   ~CResolveUser();

public:
   BOOL           Init();
   void           SetParentWindow(CWnd* pWnd)   { m_pParentWnd = pWnd; };
   BOOL           AddUser(CDSUser* pDSUser);
   void           ClearUsersDS();
   BOOL           AddUser(CILSUser* pILSUser);
   void           ClearUsersILS();
   
   BOOL           ResolveAddress(LPCTSTR szAddress,
                                 CString& sName,
                                 CString& sUser1,
                                 CString& sUser2);
   
   BOOL           ResolveAddressEx(LPCTSTR szAddress,
                                   long lAddressType,
                                   DialerMediaType dmtMediaType,
                                   DialerLocationType dmtLocationType,
                                   CString& sName,
                                   CString& sResolvedAddress,
                                   CString& sUser1,
                                   CString& sUser2,
                                   bool bShowUI=true);
   
protected:
   void           DeleteList(CObList* pList)
                  {
                     POSITION pos = pList->GetHeadPosition();
                     while (pos)
                     {
                        delete pList->GetNext(pos);
                     }
                     pList->RemoveAll();
                  };

   BOOL           FindAddressInWAB(LPCTSTR szAddress,long lAddressType,CObList& WabList);
   CDSUser*       FindAddressInDS(LPCTSTR szAddress);
   CILSUser*      FindAddressInILS(LPCTSTR szAddress);

   void           UserObjectList_AddUser(CObList* pList,CWABEntry* pWABEntry);
   void           UserObjectList_AddUser(CObList* pList,CILSUser* pILSUser);
   void           UserObjectList_AddUser(CObList* pList,CDSUser* pDSUser);
   void           UserObjectList_EmptyList(CObList* pList);

   BOOL           FillCallEntry(CResolveUserObject* pUserObject,CCallEntry* pCallEntry);

//Attributes
protected:
   CRITICAL_SECTION  m_csDataLock;

   CObList        m_DSUsers;
   CObList        m_ILSUsers;
   CDirectory*    m_pDirectory;
   CWnd*          m_pParentWnd;
};

#endif //_RESOLVER_H_
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\previewwnd.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// VideoPreviewWnd.h : implementation file
/////////////////////////////////////////////////////////////////////////////
#if !defined(AFX_VIDEOPREVIEWWND_H__5811CF83_26DB_11D1_AEB3_08001709BCA3__INCLUDED_)
#define AFX_VIDEOPREVIEWWND_H__5811CF83_26DB_11D1_AEB3_08001709BCA3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// FWD define
class CVideoPreviewWnd;

#include "CallWnd.h"
#include "cctrlfoc.h"
#include "cavwav.h"

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CVideoPreviewWnd window
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class CVideoPreviewWnd : public CCallWnd
{
   DECLARE_DYNAMIC(CVideoPreviewWnd)
// Construction
public:
	CVideoPreviewWnd();
protected:
// Dialog Data
	//{{AFX_DATA(CVideoPreviewWnd)
	enum { IDD = IDD_VIDEOPREVIEW };
	CCallControlFocusWnd	m_staticMediaText;
	//}}AFX_DATA

// Attributes
protected:
   HIMAGELIST           m_hMediaImageList;
   HMODULE              m_hTMeter;
   CAvWav               m_AvWav;
   SIZE_T               m_uMixerTimer;
   bool                 m_bAudioOnly;
 
// Operations
public:
   void                 SetDialerDoc(CActiveDialerDoc* pDoc) { m_pDialerDoc = pDoc; };
   void                 SetAudioOnly(bool bAudioOnly);
   virtual void         SetMediaWindow();
   void                 SetCallId(WORD nCallId) { m_nCallId = nCallId; };  //To set current callid for this preview window
   void                 SetMixers(DialerMediaType dmtMediaType);           //set mixers for a given media type

protected:
   virtual void         DoActiveWindow(BOOL bActive);
   virtual BOOL         IsMouseOverForDragDropOfSliders(CPoint& point);

   bool                 OpenMixerWithTrackMeter(DialerMediaType dmtMediaType,AudioDeviceType adt,HWND hwndTrackMeter);
   void                 SetTrackMeterPos(AudioDeviceType adt,HWND hwndTrackMeter);
   void                 SetTrackMeterLevel(AudioDeviceType adt,HWND hwndTrackMeter);

protected:
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CVideoPreviewWnd)
	public:
   virtual BOOL OnInitDialog( );
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CVideoPreviewWnd();

	// Generated message map functions
protected:
	//{{AFX_MSG(CVideoPreviewWnd)
	afx_msg void OnPaint();
	afx_msg void OnTimer(UINT nIDEvent);
   afx_msg void OnDestroy();
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_VIDEOPREVIEWWND_H__5811CF83_26DB_11D1_AEB3_08001709BCA3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by avDialer.rc
//
#define IDP_OLE_INIT_FAILED             100
#define IDD_ABOUTBOX                    101
#define IDR_MAINFRAME                   102
#define IDB_TREE_DIRECTORIES            103
#define IDB_TREE_CONFERENCE_SERVICES    104
#define IDB_GROUP_LIST                  104
#define IDB_TREE_CONFERENCE_ROOM        105
#define IDR_TOOLBAR_DIRECTORY           106
#define IDC_CALLCONTROL_VIDEO_GRABBER   107
#define IDR_TOOLBAR_CONFERENCE_SERVICES 113
#define IDR_TOOLBAR_CONFERENCE_ROOM     115
#define IDR_TRAY_ACTIVE                 116
#define IDS_MCCONF                      117
#define IDR_SPEED_DIAL                  118
#define IDS_FAILED_CREATE_VIEW          119
#define IDS_ERR_NO_TAPI_OBJECT          120
#define IDB_LIST_DIAL                   124
#define IDS_NETCALL                     129
#define IDR_DIALEREXPLORER_DIRECTORIES  131
#define IDS_PHONECALL                   132
#define IDR_TRAY_NORMAL                 133
#define IDR_AVTAPINOTIFICATION          134
#define IDN_HTMLHELP                    135
#define IDD_CONFERENCE_SERVICES_CREATE_CONFERENCE 136
#define IDD_DIRECTORIES_ADDSERVER       137
#define IDB_LIST_MEDIA_LARGE            138
#define IDB_LIST_MEDIA_SMALL            139
#define IDR_AVGENERALNOTIFICATION       140
#define IDR_AGENTDIALER                 141
#define IDB_SPLASH256                   142
#define IDN_CONTEXTHELPPATH             143
#define IDN_CONTEXTHELP                 144
#define IDD_DIALER_EXIT                 145
#define IDR_TOOLBAR_OPTIONS             148
#define IDR_CONTEXT_TOOLBAR             150
#define IDB_ABOUT                       153
#define IDD_WIZARD_INIT_USERINFO1       154
#define IDD_VIDEO_FLOATING_DIALOG       155
#define IDD_VIDEO_PREVIEW_DIALOG        156
#define IDB_BUTTONBAR_MEDIA_TRANSPORT   157
#define IDR_TOOLBAR_VIDEO               158
#define IDR_CALLWINDOW_POSITION         161
#define IDR_DIALEREXPLORER_SERVICES     163
#define IDR_DIALEREXPLORER_ROOM         164
#define IDB_MENU_TRAY                   165
#define IDR_CONTEXT_COMMOBJECTS         165
#define IDB_MENU_DIRECTORY              166
#define IDB_MENU_SERVICES               167
#define IDB_MENU_ROOM                   168
#define IDB_VIDEO_SCREEN1               169
#define IDB_VIDEO_SCREEN2               170
#define IDB_BUTTON_MIC                  177
#define IDB_BUTTON_CAMERA               178
#define IDB_BUTTON_SPEAKER              179
#define IDD_CALLCONTROL                 180
#define IDD_VIDEOPREVIEW                181
#define IDD_WIZARD_INIT_TOOLBAR         182
#define IDB_BUTTONBAR_MEDIA_CONTROLS    183
#define IDR_OPTION_VIDEO                188
#define IDR_OPTION_TELEPHONY            196
#define IDB_VIDEO_AUDIO_ONLY1           197
#define IDB_VIDEO_AUDIO_ONLY2           198
#define IDD_SPEEDDIAL_MORE              200
#define IDD_SPEEDDIAL_EDIT              201
#define IDD_SPEEDDIAL_ADD               202
#define IDR_CALLWINDOW_MEDIA            203
#define IDR_CALLWINDOW_DTMF             205
#define IDD_REMINDER_SET                207
#define IDD_PHONEPAD                    208
#define IDB_DIALOG_BULLET               210
#define IDR_CONFERENCE                  212
#define IDB_SPLASH_ANIMATION            215
#define IDD_OPTIONS_VIDEO               280
#define IDD_OPTIONS_VCARD               281
#define IDD_OPTIONS_CONFIRM             282
#define IDD_OPTIONS_TELEPHONY           283
#define IDD_OPTIONS_GENERAL             284
#define IDD_OPTIONS_CALLS               285
#define IDD_OPTIONS_HOLDTRANSFER        286
#define IDD_OPTIONS_SOUNDS              287
#define IDD_VIDEO_TAKEPICTURE           288
#define IDD_REMINDER_DISPLAY            289
#define IDD_DIAL_SELECTADDRESS          290
#define IDR_CALLWINDOW_STATES           294
#define IDR_MAINFRAME_SHOW              295
#define IDR_AVI_ANIMATION_RINGING       310
#define IDR_AVI_ANIMATION_CONNECTING    311
#define IDR_AVI_ANIMATION_HOLDING       312
#define IDR_AVI_ANIMATION_CONNECTED     313
#define IDR_AVI_ANIMATION_REQUEST       314
#define IDB_TERMINATION_STATES          315
#define IDR_CONTEXT_DIRECTORIES         320
#define IDB_ABOUT_BACKGROUND            324
#define IDB_ABOUT_LOGO                  325
#define IDD_DIRECTORIES_FIND_USER       326
#define IDR_MENU                        327
#define IDR_CONTEXT_SPEEDDIAL           331
#define IDD_USERUSER                    332
#define IDD_PAGE                        333
#define IDC_CONFERENCESERVICES_CREATE_EDIT_NAME 1003
#define IDC_CONFERENCESERVICES_CREATE_EDIT_DESCRIPTION 1004
#define IDC_DIRECTORIES_ADDSERVER_EDIT_SERVERNAME 1005
#define IDC_DIRECTORIES_ADDSERVER_EDIT_DISPLAYNAME 1006
#define IDC_CONFERENCESERVICES_TREECTRL_MAIN 1007
#define IDC_CONFERENCESERVICES_VIEWCTRL_DETAILS 1008
#define IDC_CONFERENCEROOM_VIEWCTRL_MAIN 1009
#define IDC_CONFERENCEROOM_VIEWCTRL_DETAILS 1010
#define IDC_DIRECTORIES_TREECTRL_MAIN   1011
#define IDC_DIRECTORIES_VIEWCTRL_EMTPY  1012
#define IDC_DIRECTORIES_VIEWCTRL_WABGROUPDETAILS 1013
#define IDC_DIRECTORIES_VIEWCTRL_WABPERSONDETAILS 1014
#define IDC_DIRECTORIES_VIEWCTRL_PERSONDETAILS 1015
#define IDC_EXPLORER_MAINWND_DIRECTORIES 1016
#define IDC_EXPLORER_MAINWND_CONFERENCESERVICES 1017
#define IDC_EXPLORER_MAINWND_CONFERENCEROOM 1018
#define IDC_ABOUT_STATIC_IMAGE          1019
#define IDC_ABOUT_BUTTON_UPGRADE        1020
#define IDC_DRIVER_MISSING_STATIC_LIST  1021
#define IDC_WIZARD_INIT_WELCOME_STATIC_IMAGE 1025
#define IDC_WIZARD_INIT_STARTUP_CHECK_ADD 1026
#define IDC_WIZARD_INIT_STARTUP_STATIC_IMAGE 1027
#define IDC_WIZARD_INIT_USERINFO1_STATIC_IMAGE 1028
#define IDC_WIZARD_INIT_USERINFO2_STATIC_IMAGE 1033
#define IDC_WIZARD_INIT_USERINFO2_STATIC_VIDEOSCREEN 1034
#define IDC_WIZARD_INIT_USERINFO2_BUTTON_CAPTURE 1035
#define IDC_WIZARD_INIT_USERINFO2_BUTTON_PICTURE 1036
#define IDC_WIZARD_INIT_USERINFO2_BUTTON_NAME 1037
#define IDC_WIZARD_INIT_COMPLETE_STATIC_IMAGE 1040
#define IDC_WIZARD_INIT_COMPLETE_STATIC_IMAGE_INITCOMPLETE 1041
#define IDC_CALLCONTROL_ANIMATE_CALLSTATEIMAGE 1050
#define IDC_CALLCONTROL_STATIC_CALLERID 1051
#define IDC_CALLCONTROL_STATIC_CALLSTATE 1052
#define IDC_CALLCONTROL_STATIC_VIDEO    1053
#define IDC_CALLCONTROL_STATIC_ACTIONTOOLBAR 1054
#define IDC_CALLCONTROL_STATIC_STATETOOLBAR 1055
#define IDC_CALLCONTROL_STATIC_MEDIATEXT 1056
#define IDC_CALLCONTROL_STATIC_APPTOOLBAR 1057
#define IDC_VIDEOPREVIEW_STATIC_VIDEO   1058
#define IDC_VIDEOPREVIEW_STATIC_ACTIONTOOLBAR 1059
#define IDC_VIDEOPREVIEW_STATIC_STATETOOLBAR 1060
#define IDC_VIDEOPREVIEW_SLIDER_AUDIOIN 1061
#define IDC_VIDEOPREVIEW_SLIDER_AUDIOOUT 1062
#define IDC_VIDEOPREVIEW_STATIC_IMAGE_AUDIOIN 1063
#define IDC_VIDEOPREVIEW_STATIC_IMAGE_AUDIOOUT 1064
#define IDC_VIDEOPREVIEWDLG_STATIC_VIDEO 1070
#define IDC_VIDEOFLOATINGDLG_STATIC_VIDEO 1071
#define IDC_WIZARD_INIT_COMPLETE_STATIC_IMAGE_ENABLETOOLBAR 1072
#define IDC_OPTIONS_VCARD_COMBO_USE_CONTACT 1072
#define IDC_OPTIONS_VCARD_BUTTON_EDIT_CONTACT 1073
#define IDC_OPTIONS_VCARD_BUTTON_NEW_CONTACT 1074
#define IDC_OPTIONS_VCARD_STATIC_VIDEOSCREEN 1077
#define IDC_OPTIONS_VCARD_BUTTON_PICTURE 1078
#define IDC_OPTIONS_VCARD_BUTTON_CAPTURE 1079
#define IDC_OPTIONS_VCARD_BUTTON_NAME   1082
#define IDC_OPTIONS_VCARD_CHECK_VCARD_SEND 1084
#define IDC_OPTIONS_VCARD_CHECK_VCARD_SAVE 1085
#define IDC_OPTIONS_CONFIRM_CHECK_DISCONNECT_CALLS 1086
#define IDC_OPTIONS_CONFIRM_CHECK_DISCONNECT_CONFERENCE 1087
#define IDC_OPTIONS_CONFIRM_CHECK_DELETE_CONTACT 1088
#define IDC_OPTIONS_CONFIRM_CHECK_DELETE_CONFERENCE 1089
#define IDC_OPTIONS_CONFIRM_CHECK_DIALER_START 1090
#define IDC_OPTIONS_CONFIRM_CHECK_DIALER_EXIT 1091
#define IDC_OPTIONS_CALLS_INCOMING_RADIO_RINGUNTILANSWERED 1099
#define IDC_OPTIONS_CALLS_INCOMING_RADIO_NOANSWERAFTER 1100
#define IDC_OPTIONS_CALLS_INCOMING_EDIT_RNACOUNT 1101
#define IDC_OPTIONS_HOLDTRANSFER_HOLD_CHECK_REMIND 1104
#define IDC_OPTIONS_CALLS_INCOMING_CHECK_PLAY_NAME 1105
#define IDC_OPTIONS_CALLS_OUTGOING_RADIO_RINGUNTILANSWERED 1106
#define IDC_OPTIONS_HOLDTRANSFER_HOLD_COMBO_REMIND_INTERVAL 1106
#define IDC_OPTIONS_CALLS_OUTGOING_RADIO_NOANSWERAFTER 1107
#define IDC_OPTIONS_HOLDTRANSFER_TRANSFER_EDIT_EXTENSION 1107
#define IDC_OPTIONS_CALLS_OUTGOING_EDIT_RNACOUNT 1108
#define IDC_OPTIONS_HOLDTRANSFER_TRANSFER_EDIT_EXTENSION2 1111
#define IDC_OPTIONS_SOUNDS_CHECK_INCOMING 1114
#define IDC_OPTIONS_SOUNDS_BUTTON_INCOMING_PLAY 1115
#define IDC_OPTIONS_SOUNDS_BUTTON_INCOMING_BROWSE 1116
#define IDC_OPTIONS_SOUNDS_CHECK_OUTGOING 1117
#define IDC_WIZARD_INIT_USERINFO2_STATIC_TRANSPORT 1117
#define IDC_OPTIONS_SOUNDS_BUTTON_OUTGOING_PLAY 1118
#define IDC_OPTIONS_VCARD_STATIC_TRANSPORT 1118
#define IDC_OPTIONS_SOUNDS_BUTTON_OUTGOING_BROWSE 1119
#define IDC_VIDEO_TAKEPICTURE_COMBO_DEVICE 1119
#define IDC_OPTIONS_SOUNDS_CHECK_HOLDING 1120
#define IDC_VIDEO_TAKEPICTURE_BUTTON_FORMAT 1120
#define IDC_OPTIONS_SOUNDS_BUTTON_HOLDING_PLAY 1121
#define IDC_VIDEO_TAKEPICTURE_BUTTON_SOURCE 1121
#define IDC_OPTIONS_SOUNDS_BUTTON_HOLDING_BROWSE 1122
#define IDC_VIDEO_TAKEPICTURE_BUTTON_DISPLAY 1122
#define IDC_OPTIONS_SOUNDS_CHECK_HOLDREMIND 1123
#define IDC_VIDEO_TAKEPICTURE_BUTTON_TAKEPICTURE 1123
#define IDC_OPTIONS_SOUNDS_BUTTON_HOLDREMIND_PLAY 1124
#define IDC_VIDEO_TAKEPICTURE_STATIC_VIDEOFRAME 1124
#define IDC_OPTIONS_SOUNDS_BUTTON_HOLDREMIND_BROWSE 1125
#define IDC_OPTIONS_SOUNDS_CHECK_CONFREMIND 1129
#define IDC_OPTIONS_SOUNDS_BUTTON_CONFREMIND_PLAY 1130
#define IDC_OPTIONS_SOUNDS_BUTTON_CONFREMIND_BROWSE 1131
#define IDC_OPTIONS_SOUNDS_CHECK_REQUEST 1132
#define IDC_OPTIONS_SOUNDS_BUTTON_REQUEST_PLAY 1133
#define IDC_OPTIONS_SOUNDS_BUTTON_REQUEST_BROWSE 1134
#define IDC_OPTIONS_SOUNDS_CHECK_CONNECT 1135
#define IDC_OPTIONS_SOUNDS_BUTTON_CONNECT_PLAY 1136
#define IDC_OPTIONS_SOUNDS_BUTTON_CONNECT_BROWSE 1137
#define IDC_OPTIONS_SOUNDS_CHECK_DISCONNECT 1138
#define IDC_OPTIONS_SOUNDS_BUTTON_DISCONNECT_PLAY 1139
#define IDC_OPTIONS_SOUNDS_BUTTON_DISCONNECT_BROWSE 1140
#define IDC_OPTIONS_SOUNDS_CHECK_ABANDON 1141
#define IDC_OPTIONS_SOUNDS_BUTTON_ABANDON_PLAY 1142
#define IDC_OPTIONS_SOUNDS_BUTTON_PLAY  1142
#define IDC_OPTIONS_SOUNDS_BUTTON_ABANDON_BROWSE 1143
#define IDC_OPTIONS_SOUNDS_BUTTON_BROWSE 1143
#define IDC_OPTIONS_VIDEO_COMBO_DEVICE  1144
#define IDC_OPTIONS_VIDEO_BUTTON_SOURCE 1145
#define IDC_OPTIONS_VIDEO_BUTTON_DISPLAY 1146
#define IDC_OPTIONS_VIDEO_BUTTON_FORMAT 1147
#define IDC_OPTIONS_VIDEO_STATIC_VIDEOFRAME 1148
#define IDC_OPTIONS_VIDEO_STATIC_ICON1  1149
#define IDC_OPTIONS_VIDEO_STATIC_STATIC1 1150
#define IDC_REMINDER_SET_COMBO_REMINDER_TIME 1151
#define IDC_DIALER_EXIT_STATIC_BULLET1  1154
#define IDC_DIALER_EXIT_STATIC_BULLET2  1155
#define IDC_DIALER_EXIT_STATIC_BULLET3  1156
#define IDC_SPEEDDIAL_ADD_RADIO_PHONECALL 1157
#define IDC_SPEEDDIAL_ADD_RADIO_NETCALL 1158
#define IDC_SPEEDDIAL_ADD_RADIO_MULTICASTCONFERENCE 1159
#define IDC_ABOUT_EDIT_LEGAL            1160
#define IDC_VIDEOPREVIEW_STATIC_MEDIATEXT 1161
#define IDC_OPTIONS_SOUNDS_LIST_EVENTS  1162
#define IDC_OPTIONS_SOUNDS_EDIT_SOUND   1163
#define IDC_REMINDER_DISPLAY_STATIC_REMINDER 1164
#define IDC_REMINDER_DISPLAY_STATIC_NAME 1165
#define IDC_SPEEDDIAL_EDIT_STATIC_ENTRIES 1166
#define IDC_SELECTADDRESS_BUTTON_PLACECALL 1180
#define IDC_SELECTADDRESS_BUTTON_BROWSE 1181
#define IDC_SELECTADDRESS_LISTBOX_NAMES 1182
#define IDC_SELECTADDRESS_LISTCTRL_ADDRESSES 1183
#define IDC_SELECTADDRESS_STATIC_NAMES  1184
#define IDC_SELECTADDRESS_STATIC_ADDRESSES 1185
#define IDC_SELECTADDRESS_STATIC_ICON1  1186
#define IDC_SELECTADDRESS_STATIC_TEXT1  1187
#define IDC_DIRECTORIES_FIND_USER_EDIT_USER 2000
#define IDC_DIRECTORIES_FIND_USER_BUTTON_SEARCH 2001
#define IDC_DIRECTORIES_FIND_USER_LB_USERS 2002
#define IDC_CHK_DONT                    2003
#define IDC_BTN_URL                     2004
#define IDC_LBL_FROM                    2008
#define IDC_LBL_URL                     2009
#define IDC_EDT_WEBADDRESS              2010
#define IDC_LBL_TO                      2011
#define IDC_EDT_WELCOME                 2012
#define IDC_DEFAULT                     2020
#define IDC_OPTIONS_VIDEO_CHECK_AUTOPREVIEW 2087
#define IDC_OPTIONS_GENERAL_CHECK_LOG_OUTGOING 2088
#define IDC_OPTIONS_GENERAL_CHECK_LOG_INCOMING 2089
#define IDC_OPTIONS_GENERAL_CHECK_LOG_CONFERENCE 2090
#define IDC_OPTIONS_GENERAL_EDIT_LOG_DAYS 2091
#define IDC_OPTIONS_GENERAL_COMBO_REMINDER_TIME 2093
#define IDC_OPTIONS_GENERAL_REMINDER_CHECK_BY_POPUP 2094
#define IDC_OPTIONS_GENERAL_REMINDER_CHECK_BY_EMAIL 2095
#define IDC_OPTIONS_GENERAL_REMINDER_EDIT_EMAIL_ADDRESS 2097
#define IDC_SPEEDDIAL_MORE_LIST_ADDRESSES 3125
#define IDC_SPEEDDIAL_MORE_BUTTON_PLACECALL 3126
#define IDC_SPEEDDIAL_MORE_BUTTON_EDITLIST 3127
#define IDC_SPEEDDIAL_MORE_STATIC_ICON1 3128
#define IDC_SPEEDDIAL_MORE_STATIC_TEXT1 3129
#define IDC_SPEEDDIAL_EDIT_BUTTON_MOVEUP 3140
#define IDC_SPEEDDIAL_EDIT_BUTTON_MOVEDOWN 3141
#define IDC_SPEEDDIAL_EDIT_BUTTON_REMOVE 3142
#define IDC_SPEEDDIAL_EDIT_LIST_ENTRIES 3143
#define IDC_SPEEDDIAL_EDIT_BUTTON_EDIT  3144
#define IDC_SPEEDDIAL_EDIT_BUTTON_ADD   3145
#define IDC_SPEEDDIAL_ADD_EDIT_DISPLAYNAME 3201
#define IDC_SPEEDDIAL_ADD_DISPLAY       3202
#define IDC_SPEEDDIAL_ADD_EDIT_ADDRESS  3203
#define IDC_SPEEDDIAL_ADD_STATIC_DISPLAYNAME 3204
#define IDC_SPEEDDIAL_ADD_STATIC_ADDRESS 3205
#define IDC_SPEEDDIAL_ADD_STATIC_ICON1  3206
#define IDC_SPEEDDIAL_ADD_STATIC_TEXT1  3207
#define ID_ACTIVE_EMAIL                 20000
#define ID_ACTIVE_TEXTMSG               20001
#define ID_AGENT_ACTIVECALL_CLOSE       20010
#define ID_AGENT_ACTIVECALL_CONFERENCE  20011
#define ID_AGENT_ACTIVECALL_DISCONNECT  20012
#define ID_AGENT_ACTIVECALL_SAVETRANSCRIPT 20013
#define ID_BUTTON_BROWSER_BACK          20030
#define ID_BUTTON_BROWSER_FORWARD       20031
#define ID_BUTTON_BROWSER_HOME          20032
#define ID_BUTTON_BROWSER_OPEN          20033
#define ID_BUTTON_BROWSER_REFRESH       20034
#define ID_BUTTON_BROWSER_STOP          20035
#define ID_BUTTON_CLOSEEXPLORER         20040
#define ID_BUTTON_CONFERENCE_CREATE     20050
#define ID_BUTTON_CONFERENCE_DELETE     20051
#define ID_BUTTON_CONFERENCE_EDIT       20052
#define ID_BUTTON_CONFERENCE_JOIN       20053
#define ID_BUTTON_CONFERENCEEXPLORE     20054
#define ID_BUTTON_DIRECTORY_DELETECONTACT 20060
#define ID_BUTTON_DIRECTORY_DETAILS     20061
#define ID_BUTTON_DIRECTORY_FIND        20062
#define ID_BUTTON_DIRECTORY_NEWCONTACT  20063
#define ID_BUTTON_DIRECTORY_NEWGROUP    20064
#define ID_BUTTON_DIRECTORY_SERVICES    20066
#define ID_BUTTON_DIRECTORY_SERVICES_ADDSERVER 20067
#define ID_BUTTON_DIRECTORY_SERVICES_DELETESERVER 20068
#define ID_BUTTON_DIRECTORY_WAB         20069
#define ID_BUTTON_EXITDIALER            20080
#define ID_BUTTON_ICONS_LARGE           20090
#define ID_BUTTON_ICONS_SMALL           20091
#define ID_BUTTON_MAKECALL              20100
#define ID_BUTTON_MENU_TOP              20110
#define ID_BUTTON_OPTIONS               20120
#define ID_BUTTON_TELEPHONYSERVICES     20121
#define ID_BUTTON_REDIAL                20130
#define ID_BUTTON_REMINDER_EDIT         20140
#define ID_BUTTON_REMINDER_SET          20141
#define ID_BUTTON_ROOM_DISCONNECT       20150
#define ID_BUTTON_ROOM_MINIMIZE         20151
#define ID_BUTTON_ROOM_PREVIEW          20152
#define ID_BUTTON_ROOM_VIDEO            20153
#define ID_BUTTON_SERVICES_DELETE       20160
#define ID_BUTTON_SERVICES_DETAILS      20161
#define ID_BUTTON_SERVICES_FIND         20162
#define ID_BUTTON_SERVICES_SERVERS      20164
#define ID_BUTTON_SPEEDDIAL             20170
#define ID_BUTTON_SPEEDDIAL_ADD         20171
#define ID_BUTTON_SPEEDDIAL_EDIT        20172
#define ID_BUTTON_SPEEDDIAL_MORE        20173
#define ID_BUTTON_VIDEO_ALWAYSONTOP_OFF 20180
#define ID_BUTTON_VIDEO_ALWAYSONTOP_ON  20181
#define ID_BUTTON_VIDEO_OPTIONS         20182
#define ID_BUTTON_VIDEO_SAVEPICTURE     20183
#define ID_BUTTON_MEDIA_RECORD          20184
#define ID_BUTTON_MEDIA_PLAY            20185
#define ID_BUTTON_MEDIA_STOP            20186
#define ID_CALLWINDOW_ALWAYSONTOP       20190
#define ID_CALLWINDOW_HIDE              20191
#define ID_CALLWINDOW_NOTONTOP          20192
#define ID_CALLWINDOW_TOUCHTONE         20193
#define ID_CALLWINDOW_VCARD             20194
#define ID_CALLWINDOW_DESKTOPPAGE       20195
#define ID_CALLWINDOW_CHAT              20196
#define ID_CALLWINDOW_WHITEBOARD        20197
#define ID_CALLWINDOW_APPSHARE          20198
#define ID_CALLWINDOW_DTMF_1            20199
#define ID_CALLWINDOW_DTMF_2            20200
#define ID_CALLWINDOW_DTMF_3            20201
#define ID_CALLWINDOW_DTMF_4            20202
#define ID_CALLWINDOW_DTMF_5            20203
#define ID_CALLWINDOW_DTMF_6            20204
#define ID_CALLWINDOW_DTMF_7            20205
#define ID_CALLWINDOW_DTMF_8            20206
#define ID_CALLWINDOW_DTMF_9            20207
#define ID_CALLWINDOW_DTMF_0            20208
#define ID_CALLWINDOW_DTMF_STAR         20209
#define ID_CALLWINDOW_DTMF_POUND        20210
#define ID_CALLWINDOW_SLIDESIDE_LEFT    20211
#define ID_CALLWINDOW_SLIDESIDE_RIGHT   20212
#define ID_CALLWINDOW_ADDTOSPEEDDIAL    20213
#define ID_TOOLBAR_TEXT                 20215
#define ID_TRAY_STATE                   20220
#define ID_TRAY_STATE_SHOW              20221
#define ID_TRAY_STATE_RIGHT             20222
#define ID_TRAY_STATE_SHOW_RIGHT        20223
#define ID_VIEW_COLUMN_BUSINESS         20230
#define ID_VIEW_COLUMN_COMPANY          20231
#define ID_VIEW_COLUMN_EMAIL            20232
#define ID_VIEW_COLUMN_FIRSTNAME        20233
#define ID_VIEW_COLUMN_HOME             20234
#define ID_VIEW_COLUMN_LASTNAME         20235
#define ID_VIEW_CONFERENCE_ROOM         20236
#define ID_VIEW_CONFERENCE_SERVICES     20237
#define ID_VIEW_DIRECTORIES             20238
#define ID_VIEW_LOG                     20239
#define ID_VIEW_SORT_ASCENDING          20240
#define ID_VIEW_SORT_BUSINESS           20241
#define ID_VIEW_SORT_COMPANY            20242
#define ID_VIEW_SORT_DESCENDING         20243
#define ID_VIEW_SORT_EMAIL              20244
#define ID_VIEW_SORT_FIRSTNAME          20245
#define ID_VIEW_SORT_HOME               20246
#define ID_VIEW_SORT_LASTNAME           20247
#define ID_VIEW_SORT_NAME               20248
#define ID_VIEW_STATUSBAR               20249
#define ID_VIEW_TOOLBARS                20250
#define ID_WINDOW_WINDOWS_START         20300
#define ID_WINDOW_WINDOWS_END           20399
#define ID_BUTTON31305                  20400
#define ID_BUTTON_SERVICES_ADDLOCATION  20410
#define ID_BUTTON_SERVICES_ADDILSSERVER 20411
#define ID_BUTTON_SERVICES_RENAMEILSSERVER 20412
#define ID_BUTTON_SERVICES_DELETEILSSERVER 20413
#define IDS_MENU_DESKTOP_PAGE           20414
#define IDN_REG_DESKTOPPAGE             20415
#define IDS_SPEEDDIAL_LIST_EMPTY        20416
#define IDS_AGENT_ACTIVECALL_CALLBACK   30000
#define IDS_AGENT_ACTIVECALL_INCOMINGCALL 30001
#define IDS_AGENT_ACTIVECALL_MONITOR    30003
#define IDS_AGENT_ACTIVECALL_PLACINGCALLONHOLD 30004
#define IDS_AGENT_ACTIVECALL_TAKEMESSAGE 30005
#define IDS_AGENT_ACTIVECALL_TRANSFER   30006
#define IDS_AGENT_ACTIVECALL_WHOISIT    30007
#define IDS_APPLICATION_CLASSNAME       30010
#define IDS_APPLICATION_TITLE_DESCRIPTION 30011
#define IDS_UNKNOWN                     30012
#define IDS_CALLCONTROL_ACTIONS_CALLBACK 30020
#define IDS_CALLCONTROL_ACTIONS_CLOSE   30021
#define IDS_CALLCONTROL_ACTIONS_DISCONNECT 30022
#define IDS_CALLCONTROL_ACTIONS_HOLD    30023
#define IDS_CALLCONTROL_ACTIONS_LEAVEDESKTOPPAGE 30024
#define IDS_CALLCONTROL_ACTIONS_LEAVEEMAIL 30025
#define IDS_CALLCONTROL_ACTIONS_MONITOR 30026
#define IDS_CALLCONTROL_ACTIONS_REQUESTHOLD 30027
#define IDS_CALLCONTROL_ACTIONS_TAKECALL 30028
#define IDS_CALLCONTROL_ACTIONS_TAKEMESSAGE 30029
#define IDS_CALLCONTROL_ACTIONS_TRANSFER 30030
#define IDS_CALLCONTROL_ACTIONS_WHOISIT 30031
#define IDS_CALLCONTROL_ACTIONS_ENTERCONFROOM 30032
#define IDS_CALLCONTROL_ACTIONS_REJECTCALL 30033
#define IDS_CALLCONTROL_STATE_BUSY      30040
#define IDS_CALLCONTROL_STATE_CONNECTED 30041
#define IDS_CALLCONTROL_STATE_DISCONNECTED 30042
#define IDS_CALLCONTROL_STATE_HOLDING   30043
#define IDS_CALLCONTROL_STATE_LEAVINGMESSAGE 30044
#define IDS_CALLCONTROL_STATE_REQUESTHOLD 30045
#define IDS_CALLCONTROL_STATE_RINGING   30046
#define IDS_CALLCONTROL_STATE_TRANSFERRING 30047
#define IDS_CALLCONTROL_STATE_UNAVAILABLE 30048
#define IDS_CALLCONTROL_STATE_UNKNOWN   30049
#define IDS_CALLCONTROL_STATE_CONNECTING 30049
#define IDS_CONFERENCE_SERVICES_CREATE_NAME_EMPTY 30060
#define IDS_DIRECTORIES_ADDSERVER_NAME_EMPTY 30070
#define IDS_ERROR_MESSAGEBOX_FORMAT3    30080
#define IDS_ERROR_MESSAGEBOX_CAPTION    30081
#define IDS_ERROR_VCARD_CONTACT         30082
#define IDS_ERROR_MESSAGEBOX_FORMAT2    30083
#define IDS_EXPLORER_TAB_CONFERENCEROOM 30090
#define IDS_EXPLORER_TAB_CONFERENCESERVICES 30091
#define IDS_EXPLORER_TAB_DIRECTORIES    30092
#define IDS_SOUND_PHONE_DISCONNECTED    30100
#define IDS_SOUND_PHONE_INCOMINGRING    30101
#define IDS_SOUND_PHONE_OUTGOINGRING    30102
#define IDS_ABOUT_LEGAL                 30121
#define IDS_TOOLBAR_BUTTON_PLACECALL    30130
#define IDS_TOOLBAR_BUTTON_REDIAL       30140
#define IDS_TRAY_ACTIVE_HIDE            30150
#define IDS_TRAY_ACTIVE_SHOW            30151
#define IDS_SPEEDDIAL_EDIT              30160
#define IDS_SPEEDDIAL_MORE              30161
#define IDS_SPEEDDIAL_REDIAL_EMTPY      30162
#define IDS_DIRECTORIES_SPEEDDIAL       30163
#define IDS_DIRECTORIES_SPEEDDIAL_ADDRESS 30164
#define IDS_DIRECTORIES_SPEEDDIAL_NAME  30165
#define IDS_DIRECTORIES_CONFROOM        30166
#define ID_CALLWINDOWS_DTMF_STAR        30203
#define ID_VIEW_SORT_CONF_NAME          30205
#define ID_VIEW_SORT_CONF_DESCRIPTION   30206
#define ID_VIEW_SORT_CONF_START         30207
#define ID_VIEW_SORT_CONF_STOP          30208
#define ID_VIEW_SORT_CONF_OWNER         30209
#define ID_VIEW_VIDEO_LARGE             30210
#define ID_VIEW_VIDEO_SMALL             30211
#define ID_VIEW_VIDEO_PARTICPANT_NAMES  30212
#define IDS_NO_ITEMS_TO_SHOW            30213
#define ID_BUTTON_SENDEMAILMESSAGE      30214
#define IDS_SERVER_NOT_RESPONDING       30214
#define ID_BUTTON_OPENWEBPAGE           30215
#define IDS_SERVER_QUERYING             30215
#define IDS_SERVER_UNKNOWN              30216
#define IDS_SERVER_INVALID              30217
#define IDS_ILS_ROOT                    30218
#define IDS_HEADING_COMPANY             30500
#define IDS_HEADING_DISPLAY             30501
#define IDS_HEADING_EMAIL               30502
#define IDS_HEADING_FIRSTNAME           30503
#define IDS_HEADING_LASTNAME            30504
#define IDS_HEADING_PHONE_BUSINESS      30505
#define IDS_HEADING_PHONE_HOME          30506
#define IDS_HEADING_IPADDRESS           30507
#define IDS_HEADING_COMPUTERNAME        30508
#define IDS_HEADING_IPPHONE             30509
#define IDS_HEADING_PHONE               30510
#define IDS_HEADING_INFO                30511
#define IDS_HEADING_NONE                30512
#define IDS_DIRECTORY_ROOT              30513
#define IDS_REMINDER_0_MINUTES          30600
#define IDS_REMINDER_5_MINUTES          30601
#define IDS_REMINDER_10_MINUTES         30602
#define IDS_REMINDER_15_MINUTES         30603
#define IDS_REMINDER_30_MINUTES         30604
#define IDS_REMINDER_1_HOUR             30605
#define IDS_REMINDER_2_HOURS            30606
#define IDS_REMINDER_3_HOURS            30607
#define IDS_REMINDER_4_HOURS            30608
#define IDS_REMINDER_5_HOURS            30609
#define IDS_REMINDER_6_HOURS            30610
#define IDS_REMINDER_7_HOURS            30611
#define IDS_REMINDER_8_HOURS            30612
#define IDS_REMINDER_9_HOURS            30613
#define IDS_REMINDER_10_HOURS           30614
#define IDS_REMINDER_11_HOURS           30615
#define IDS_REMINDER_HALF_DAY           30616
#define IDS_REMINDER_1_DAY              30617
#define IDS_REMINDER_2_DAYS             30618
#define IDS_DS_LIST_EMPTY               30619
#define IDS_REMINDER_DISPLAY_TEXT       30650
#define IDS_REMINDER_DISPLAY_PASTDUE    30651
#define IDS_WABPERSON_FORMAT_EMAIL      30700
#define IDS_WABPERSON_FORMAT_HOMETELEPHONE 30701
#define IDS_WABPERSON_FORMAT_BUSINESSTELEPHONE 30702
#define IDS_WABPERSON_FORMAT_MOBILETELEPHONE 30703
#define IDS_WABPERSON_FORMAT_PAGERTELEPHONE 30704
#define IDS_WABPERSON_FORMAT_BUSINESSFAX 30705
#define IDS_WABPERSON_FORMAT_HOMEFAX    30706
#define IDS_WABPERSON_FORMAT_PERSONALHOMEPAGE 30707
#define IDS_WABPERSON_FORMAT_BUSINESSHOMEPAGE 30708
#define IDS_WABPERSON_FORMAT_NETPHONE   30709
#define IDS_DIRECTORIES_ENTERPRISEILS   30720
#define IDS_DIRECTORIES_ENTERPRISEDS    30721
#define IDS_DIRECTORIES_ILSSERVERS      30723
#define IDS_DIRECTORIES_ROOT            30724
#define IDS_DIRECTORIES_MYNETWORK       30725
#define IDS_DIRECTORIES_CONFSERVERS     30726
#define IDS_DIRECTORIES_PEOPLE          30727
#define IDS_DIRECTORIES_CONFERENCES     30728
#define IDS_ERR_CREATE_OBJECTS          30729
#define IDS_ERR_AVTAPI_FAILED           30730
#define IDS_ERR_INTERNAL                30731
#define IDS_ERR_AVTAPINOTIFICATION_INIT 30732
#define IDS_CONFIRM_CONTACT_DELETE      31000
#define IDS_CONFIRM_REMINDER_CANCEL     31001
#define IDS_CONFIRM_SHUTDOWN_CALLSINPROGRESS 31002
#define IDS_LOG_CALLTYPE_OUTGOING       31100
#define IDS_LOG_CALLTYPE_INCOMING       31101
#define IDS_LOG_CALLTYPE_CONFERENCE     31102
#define IDS_SOUNDS_FILEDIALOG_MASK      31200
#define IDS_SOUNDS_FILEDIALOG_EXT       31201
#define IDS_SOUNDS_INCOMINGCALL         31202
#define IDS_SOUNDS_OUTGOINGCALL         31203
#define IDS_SOUNDS_HOLDING              31204
#define IDS_SOUNDS_HOLDINGREMINDER      31205
#define IDS_SOUNDS_CONFERENCEREMINDER   31206
#define IDS_SOUNDS_REQUESTACTION        31207
#define IDS_SOUNDS_CALLCONNECTED        31208
#define IDS_SOUNDS_CALLDISCONNECTED     31209
#define IDS_SOUNDS_CALLABANDONED        31210
#define IDS_VIDEO_IMAGE_FILEDIALOG_MASK 31220
#define IDS_VIDEO_IMAGE_FILEDIALOG_EXT_JPG 31221
#define IDS_VIDEO_IMAGE_FILEDIALOG_EXT_BMP 31222
#define IDS_VIDEO_IMAGE_FILEDIALOG_EXT_GIF 31223
#define IDS_VIDEO_IMAGE_FILEDIALOG_MASK_BMPONLY 31224
#define IDS_SHEET_OPTIONS_HEADING       31230
#define IDS_SHEET_SETUPWIZARD_HEADING   31231
#define IDS_DIRECTORIES_FINDUSER_DLG_SEARCHING 31240
#define IDS_DIRECTORIES_FINDUSER_DLG_QUERYTOLARGE 31241
#define IDS_DIRECTORIES_FINDUSER_DLG_ERRORSEARCHINGDS 31242
#define IDS_DIRECTORIES_FINDUSER_DLG_NOMATCHES 31243
#define IDS_BUTTON_WINDOWS_NONEAVAILABLE 31250
#define IDS_ERR_COCREATE_GENERALNOTIFICATION 31251
#define IDS_ERR_INIT_GENERALNOTIFICATION 31252
#define ID_BUTTON_CONFERENCE_DETAILS    31316
#define ID_EDIT_DIRECTORIES_ADDUSER     31317
#define ID_EDIT_DIRECTORIES_EDITUSER    31318
#define ID_EDIT_DIRECTORIES_DELETEUSER  31319
#define ID_VIEW_REFRESH                 31320
#define ID_FILE_PROPERTIES              31321
#define ID_EDIT_ADDITEM                 31322
#define ID_EDIT_DELETEITEM              31323
#define ID_BUTTON_REFRESH               31335
#define ID_CALLWINDOW_SHOW              31337
#define ID_HIDE_WHEN_MINIMIZED          31339
#define ID_BUTTON_DIRECTORY_JOINCONFERENCE 31342
#define ID_EDIT_DELETE                  31345
#define ID_DESKTOP_PAGE                 31347
#define IDS_ERR_AVWAV_LOAD_FAIL         31348
#define ID_CONFGROUP_SHOWNAMES          31348
#define ID_CONFGROUP_FULLSIZEVIDEO      31349
#define ID_CONFGROUP_SELECT             31350
#define ID_VIEW_SELECTEDCONFERENCEVIDEOSCALE_100 31351
#define ID_VIEW_SELECTEDCONFERENCEVIDEOSCALE_200 31352
#define ID_VIEW_SELECTEDCONFERENCEVIDEOSCALE_400 31353
#define ID_WINDOWS_ALWAYSCLOSECALLWINDOWS 31354
#define IDS_WARN_LDAPDUPLICATEADD       31355
#define IDN_REGISTRY_ADDRTYPE_CONFERENCE 50000
#define IDN_REGISTRY_ADDRTYPE_MACHINE   50001
#define IDN_REGISTRY_ADDRTYPE_PHONENUMBER 50002
#define IDN_REGISTRY_ADDRTYPE_SMTP      50003
#define IDN_REGISTRY_ADDRTYPE_TCPIP     50004
#define IDN_REGISTRY_APPLICATION_VERSION_NUMBER 50010
#define IDN_REGISTRY_BASEKEY            50020
#define IDN_REG_SPEEDDIALVIEW           50021
#define IDN_REGISTRY_CALLCONTROL_BASEKEY 50030
#define IDN_REGISTRY_CALLCONTROL_ALWAYSONTOP 50031
#define IDN_REGISTRY_CALLCONTROL_HOVER  50032
#define IDN_REGISTRY_CALLCONTROL_SLIDESIDE 50033
#define IDN_REGISTRY_DIALEREXPLORER_KEY 50040
#define IDN_REGISTRY_DIALEREXPLORER_SPLITTER_POS 50041
#define IDN_REGISTRY_DIALEREXPLORER_TOOLBARTEXTLABELS 50042
#define IDN_REGISTRY_DIALEREXPLORER_SHOWTOOLBARS 50043
#define IDN_REGISTRY_DIALEREXPLORER_SHOWSTATUSBAR 50044
#define IDN_REGISTRY_DIALEREXPLORER_DEFAULTVIEW 50045
#define IDN_REGISTRY_DIALER_SHOWSETUPWIZARD 50046
#define IDN_REGISTRY_DIALEREXPLORER_HIDEWHENMINIMIZED 50047
#define IDN_REGISTRY_DIRECTORIES_ENTRY  50050
#define IDN_REGISTRY_DIRECTORIES_KEY    50051
#define IDN_REGISTRY_DIRECTORIES_WAB    50052
#define IDN_REGISTRY_DIRECTORIES_KEYBASE 50053
#define IDN_REGISTRY_DIRECTORIES_WABCOLUMNS 50054
#define IDN_REGISTRY_DIRECTORIES_WABSORTASCENDING 50055
#define IDN_REGISTRY_DIRECTORIES_WABSORTCOLUMN 50056
#define IDN_REGISTRY_DIRECTORIES_PRIMARYILS 50057
#define IDN_REGISTRY_MEDIATYPE_CONFERENCE 50060
#define IDN_REGISTRY_MEDIATYPE_INTERNET 50061
#define IDN_REGISTRY_MEDIATYPE_POTS     50062
#define IDN_REGISTRY_REDIAL_ENTRY       50070
#define IDN_REGISTRY_REDIAL_INDEX       50071
#define IDN_REGISTRY_REDIAL_KEY         50072
#define IDN_REGISTRY_REDIAL_MAX         50073
#define IDN_REGISTRY_SPEEDDIAL_KEY      50080
#define IDN_REGISTRY_SPEEDDIAL_ENTRY    50081
#define IDN_REGISTRY_CONFIRM_EXIT       50082
#define IDN_REGISTRY_FOLDERS            50083
#define IDN_URL_HOME                    50100
#define IDN_URL_UPGRADE                 50101
#define IDN_REGISTRY_VCARD_BASEKEY      50150
#define IDN_REGISTRY_VCARD_DISPLAYNAME  50151
#define IDN_REGISTRY_VCARD_SENDONCALL   50152
#define IDN_REGISTRY_VCARD_SAVEONRECEIVEDCALL 50153
#define IDN_REGISTRY_CONFIRM_BASEKEY    50160
#define IDN_REGISTRY_CONFIRM_DISCONNECT_CALL 50161
#define IDN_REGISTRY_CONFIRM_DISCONNECT_CONFERENCE 50162
#define IDN_REGISTRY_CONFIRM_DELETE_CONTACT 50163
#define IDN_REGISTRY_CONFIRM_DELETE_CONFERENCE 50164
#define IDN_REGISTRY_CONFIRM_SHUTDOWN_DIALER 50165
#define IDN_REGISTRY_CONFIRM_START_DIALER 50166
#define IDN_REGISTRY_CALLS_BASEKEY      50170
#define IDN_REGISTRY_CALLS_DISCONNECT_RINGCOUNT_INCOMING 50171
#define IDN_REGISTRY_CALLS_DISCONNECT_RNA_INCOMIMG 50172
#define IDN_REGISTRY_CALLS_DISCONNECT_RINGCOUNT_OUTGOING 50173
#define IDN_REGISTRY_CALLS_DISCONNECT_RNA_OUTGOING 50174
#define IDN_REGISTRY_CALLS_PLAYCALLERSRECORDEDNAME 50175
#define IDN_REGISTRY_SOUNDS_DIRECTORY   50180
#define IDN_REGISTRY_SOUNDS_CONTROLPANEL_BASEKEY 50181
#define IDN_REGISTRY_SOUNDS             50182
#define IDN_REGISTRY_SOUNDS_BASEKEY     50183
#define IDN_REGISTRY_SOUNDS_INCOMINGCALL 50184
#define IDN_REGISTRY_SOUNDS_OUTGOINGCALL 50185
#define IDN_REGISTRY_SOUNDS_HOLDING     50186
#define IDN_REGISTRY_SOUNDS_HOLDINGREMINDER 50187
#define IDN_REGISTRY_SOUNDS_CONFERENCEREMINDER 50188
#define IDN_REGISTRY_SOUNDS_REQUESTACTION 50189
#define IDN_REGISTRY_SOUNDS_CALLCONNECTED 50190
#define IDN_REGISTRY_SOUNDS_CALLDISCONNECTED 50191
#define IDN_REGISTRY_SOUNDS_CALLABANDONED 50192
#define IDN_REGISTRY_SOUNDS_FILENAME_INCOMINGCALL 50200
#define IDN_REGISTRY_SOUNDS_FILENAME_OUTGOINGCALL 50201
#define IDN_REGISTRY_SOUNDS_FILENAME_HOLDING 50202
#define IDN_REGISTRY_SOUNDS_FILENAME_HOLDINGREMINDER 50203
#define IDN_REGISTRY_SOUNDS_FILENAME_CONFERENCEREMINDER 50204
#define IDN_REGISTRY_SOUNDS_FILENAME_REQUESTACTION 50205
#define IDN_REGISTRY_SOUNDS_FILENAME_CALLCONNECTED 50206
#define IDN_REGISTRY_SOUNDS_FILENAME_CALLDISCONNECTED 50207
#define IDN_REGISTRY_SOUNDS_FILENAME_CALLABANDONED 50208
#define IDN_REGISTRY_LOGGING_BASEKEY    50210
#define IDN_REGISTRY_LOGGING_INCOMINGCALLS 50211
#define IDN_REGISTRY_LOGGING_OUTGOINGCALLS 50212
#define IDN_REGISTRY_LOGGING_CONFERENCECALLS 50213
#define IDN_REGISTRY_LOGGING_LOGBUFFERSIZEDAYS 50214
#define IDN_REGISTRY_HOLDTRANSFER_BASEKEY 50220
#define IDN_REGISTRY_HOLDTRANSFER_REMINDONHOLD 50221
#define IDN_REGISTRY_HOLDTRANSFER_REMINDONHOLDTIME 50222
#define IDN_REGISTRY_HOLDTRANSFER_TRANSFERNUMBERPHONE 50223
#define IDN_REGISTRY_HOLDTRANSFER_TRANSFERNUMBERNET 50224
#define IDN_REGISTRY_AUDIOVIDEO_BASEKEY 50230
#define IDN_REGISTRY_AUDIOVIDEO_SHOWPREVIEW 50231
#define IDN_REGISTRY_AUDIOVIDEO_SHOWPREVIEWONCALL 50232
#define IDN_REGISTRY_SHELLFOLDERS_KEY   50240
#define IDN_REGISTRY_SHELLFOLDERS_STARTUP 50241
#define IDN_REGISTRY_APPDATA_VALUE      50250
#define IDN_REGISTRY_APPDATA_KEY        50251
#define IDN_REGISTRY_APPDATA_FILENAME_PICTURE 50252
#define IDN_REGISTRY_APPDATA_FILENAME_SOUND 50253
#define IDN_REGISTRY_APPDATA_FILENAME_LOG 50254
#define IDN_REGISTRY_APPDATA_FILENAME_BUDDIES 50255
#define IDN_REGISTRY_CONFERENCE_BASEKEY 50260
#define IDN_REGISTRY_CONFERENCE_REMINDER_ENTRY 50261
#define IDN_REGISTRY_CONFERENCE_REMINDER_MAX 50262
#define IDN_REGISTRY_CONFERENCE_REMINDER_DEFAULTTIME 50263
#define IDN_REGISTRY_CONFERENCE_REMINDER_DISPLAYPOPUP 50264
#define IDN_REGISTRY_CONFERENCE_REMINDER_SENDEMAIL 50265
#define IDN_REGISTRY_CONFERENCE_REMINDER_EMAILADDRESS 50266
#define IDN_REGISTRY_DEVICE_INTERNET_KEY 50280
#define IDN_REGISTRY_DEVICE_CONF_KEY    50281
#define IDN_REGISTRY_DEVICE_POTS_KEY    50282
#define IDN_REGISTRY_DEVICE_AUDIOIN_ENTRY 50283
#define IDN_REGISTRY_DEVICE_AUDIOOUT_ENTRY 50284
#define IDN_REGISTRY_CONFERENCE_SERVICES 50285
#define IDN_REG_HEADING_NONE            50286
#define IDN_REG_HEADING_INFO            50287
#define IDN_REG_HEADING_ILS_DISPLAY     50288
#define IDN_REG_HEADING_ILS_COMPUTERNAME 50289
#define IDN_REG_HEADING_ILS_IPADDRESS   50290
#define IDN_REG_HEADING_DS_DISPLAY      50291
#define IDN_REG_HEADING_DS_PHONE        50292
#define IDN_REG_HEADING_DS_IPPHONE      50293
#define IDN_REG_HEADING_DS_EMAIL        50294
#define IDN_REG_HEADING_SD_NAME         50295
#define IDN_REG_HEADING_SD_ADDRESS      50296
#define IDN_REG_HEADING_SD_SORTORDER    50297
#define IDN_REG_HEADING_SD_SORTCOLUMN   50298
#define IDN_REG_HEADING_DS_SORTCOLUMN   50299
#define IDN_REG_HEADING_DS_SORTORDER    50300
#define IDN_REG_HEADING_ILS_SORTORDER   50301
#define IDN_REG_HEADING_ILS_SORTCOLUMN  50302
#define ID_DIALER_MRU_REDIAL_START      55000
#define ID_DIALER_MRU_REDIAL_END        55099
#define ID_DIALER_MRU_SPEEDDIAL_START   55100
#define ID_DIALER_MRU_SPEEDDIAL_END     55199

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        336
#define _APS_NEXT_COMMAND_VALUE         31355
#define _APS_NEXT_CONTROL_VALUE         2021
#define _APS_NEXT_SYMED_VALUE           108
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\speeddlgs.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////
// SpeedDialDlgs.h : header file
/////////////////////////////////////////////////////////////////////////////////////////
#if !defined(AFX_SPEEDDIALDLGS_H__21176C4F_64F3_11D1_B707_0800170982BA__INCLUDED_)
#define AFX_SPEEDDIALDLGS_H__21176C4F_64F3_11D1_B707_0800170982BA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"
#include "dialreg.h"

/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CSpeedDialAddDlg dialog
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

class CSpeedDialAddDlg : public CDialog
{
// Construction
public:
	CSpeedDialAddDlg(CWnd* pParent = NULL);   // standard constructor
protected:
// Dialog Data
	//{{AFX_DATA(CSpeedDialAddDlg)
	enum { IDD = IDD_SPEEDDIAL_ADD };
	int		m_nMediaType;
	//}}AFX_DATA

//Attributes
public:
	CCallEntry     m_CallEntry;

// Operations
public:
	void		UpdateOkButton();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSpeedDialAddDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSpeedDialAddDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnChangeSpeeddial();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CSpeedDialEditDlg dialog
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class CSpeedDialEditDlg : public CDialog
{
// Construction
public:
	CSpeedDialEditDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CSpeedDialEditDlg)
	enum { IDD = IDD_SPEEDDIAL_EDIT };
	CListCtrl	m_listEntries;
	//}}AFX_DATA

//Methods
protected:
   void        LoadCallEntries();

//Attributes
protected:
   CImageList  m_ImageList;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSpeedDialEditDlg)
	public:
	virtual BOOL DestroyWindow();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void UpdateButtonStates();

	// Generated message map functions
	//{{AFX_MSG(CSpeedDialEditDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSpeeddialEditButtonMovedown();
	afx_msg void OnSpeeddialEditButtonMoveup();
	afx_msg void OnSpeeddialEditButtonClose();
	afx_msg void OnSpeeddialEditButtonRemove();
	afx_msg void OnSpeeddialEditButtonEdit();
	afx_msg void OnSpeeddialEditButtonAdd();
	afx_msg void OnDblclkSpeeddialEditListEntries(NMHDR* pNMHDR, LRESULT* pResult);
   afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnItemchangedSpeeddialEditListEntries(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CSpeedDialMoreDlg dialog
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class CSpeedDialMoreDlg : public CDialog
{
// Construction
public:
	CSpeedDialMoreDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CSpeedDialMoreDlg)
	enum { IDD = IDD_SPEEDDIAL_MORE };
	CListCtrl	m_listEntries;
	//}}AFX_DATA

//Methods
protected:

//Attributes
protected:
   CImageList  m_ImageList;
public:
   CCallEntry  m_retCallEntry;

public:
//Enum
   enum
   {
      SDRETURN_CANCEL=0,
      SDRETURN_PLACECALL,
      SDRETURN_EDIT,
   };

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSpeedDialMoreDlg)
	public:
	virtual BOOL DestroyWindow();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSpeedDialMoreDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSpeeddialMoreButtonEditlist();
	afx_msg void OnSpeeddialMoreButtonPlacecall();
	virtual void OnCancel();
   afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SPEEDDIALDLGS_H__21176C4F_64F3_11D1_B707_0800170982BA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\sound.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

//sound.h

#ifndef _SOUND_H_
#define _SOUND_H_

#include <mmsystem.h>

// --- BUG416970 ---
static LPCTSTR    szSoundDialer    = _T("Dialer");

///////////////////////////////////////////////////////////////////////////////
//Prototypes

BOOL        ActivePlaySound(LPCTSTR szSound,LPCTSTR szSection=NULL,UINT uSound=SND_ASYNC);
BOOL        ActivePlaySound(LPCTSTR szSound,LPCTSTR szSection,CString& sFullPath);
void        ActiveClearSound();

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif //_SOUND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\slidewindow.h ===
//SlideWindow.h
//
#ifndef _SLIDEWINDOW_H_
#define _SLIDEWINDOW_H_
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Defines
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

//Messages to SlideWindows
#define     WM_SLIDEWINDOW_CLEARCURRENTACTIONS     (WM_USER + 1001)
#define     WM_SLIDEWINDOW_ADDCURRENTACTIONS       (WM_USER + 1002)
#define     WM_SLIDEWINDOW_SETCALLSTATE            (WM_USER + 1003)
#define     WM_SLIDEWINDOW_SHOWSTATESTOOLBAR       (WM_USER + 1004)
#define     WM_SLIDEWINDOW_SETCALLERID             (WM_USER + 1005)
#define     WM_SLIDEWINDOW_SETMEDIATYPE            (WM_USER + 1006)
#define     WM_SLIDEWINDOW_UPDATESTATESTOOLBAR     (WM_USER + 1007)

inline void ShowStatesToolBar(CWnd* pWnd,BOOL bAlwaysOnTop,BOOL bShow)
    { pWnd->SendMessage(WM_SLIDEWINDOW_SHOWSTATESTOOLBAR,(WPARAM)bAlwaysOnTop,(LPARAM)bShow); };

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif //_SLIDEWINDOW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\sound.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

//sound.cpp
#include "stdafx.h"
#include "sound.h"

static LPCTSTR    szSoundPath      = _T("AppEvents\\Schemes\\Apps\\");
static LPCTSTR    szDefaultSection = _T(".Default");
static LPCTSTR    szSoundCurrent   = _T(".Current");


///////////////////////////////////////////////////////////////////////////////
//szSection allow the user to specify a section in the registry that the sound
// is grouped within.  By default all sounds are in the section .Default
//An example path is "AppEvents\\Schemes\\Apps\\Active Agent\\Inbound Chat\\.Current",
///////////////////////////////////////////////////////////////////////////////
BOOL ActivePlaySound(LPCTSTR szSound,LPCTSTR szSection,UINT uSound)
{
   BOOL bRet = FALSE;
   CString sPath = szSoundPath;
   if (szSection == NULL)
      sPath += szDefaultSection;
   else
      sPath += szSection;

   sPath += _T("\\");
   sPath += szSound;
   sPath += _T("\\");
   sPath += szSoundCurrent;

   HKEY hSound;
   if ( RegOpenKeyEx(HKEY_CURRENT_USER,sPath,0,KEY_READ,&hSound) == ERROR_SUCCESS)
   {
      CString sStr;
      DWORD dwSize = _MAX_PATH;
      DWORD dwType;
      if (RegQueryValueEx(hSound,NULL,NULL,&dwType,(UCHAR*)(LPCTSTR)sStr.GetBuffer(dwSize),&dwSize) == ERROR_SUCCESS)
      {
         sStr.ReleaseBuffer();
      	sndPlaySound(sStr,uSound);
         bRet = TRUE;
      }
      RegCloseKey(hSound);
   }
   return bRet;
}

///////////////////////////////////////////////////////////////////////////////
void ActiveClearSound()
{
   sndPlaySound(NULL,NULL);
}

///////////////////////////////////////////////////////////////////////////////
//szSection allow the user to specify a section in the registry that the sound
// is grouped within.  By default all sounds are in the section .Default
//An example path is "AppEvents\\Schemes\\Apps\\Active Agent\\Inbound Chat\\.Current",
///////////////////////////////////////////////////////////////////////////////
BOOL ActivePlaySound(LPCTSTR szSound,LPCTSTR szSection,CString& sFullPath)
{
   BOOL bRet = FALSE;
   CString sPath = szSoundPath;
   if (szSection == NULL)
      sPath += szDefaultSection;
   else
      sPath += szSection;

   sPath += _T("\\");
   sPath += szSound;
   sPath += _T("\\");
   sPath += szSoundCurrent;

   HKEY hSound;
   if ( RegOpenKeyEx(HKEY_CURRENT_USER,sPath,0,KEY_READ,&hSound) == ERROR_SUCCESS)
   {
      DWORD dwSize = _MAX_PATH;
      DWORD dwType;
      if (RegQueryValueEx(hSound,NULL,NULL,&dwType,(UCHAR*)(LPCTSTR)sFullPath.GetBuffer(dwSize),&dwSize) == ERROR_SUCCESS)
      {
         sFullPath.ReleaseBuffer();
         bRet = TRUE;
      }
      RegCloseKey(hSound);
   }
   return bRet;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\speeddlgs.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////
// SpeedDialDlgs.cpp : implementation file
/////////////////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <afxpriv.h>
#include "tapi3.h"
#include "avdialer.h"
#include "SpeedDlgs.h"
#include "mainfrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Defines
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#define  DIAL_IMAGE_POTS_POS          0
#define  DIAL_IMAGE_INTERNET_POS      1
#define  DIAL_IMAGE_CONFERENCE_POS    2

/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CSpeedDialAddDlg dialog
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////
CSpeedDialAddDlg::CSpeedDialAddDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CSpeedDialAddDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSpeedDialAddDlg)
	m_nMediaType = 0;
	//}}AFX_DATA_INIT
}

/////////////////////////////////////////////////////////////////////////////////////////
void CSpeedDialAddDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSpeedDialAddDlg)
	DDX_Radio(pDX, IDC_SPEEDDIAL_ADD_RADIO_PHONECALL, m_nMediaType);
	//}}AFX_DATA_MAP
	DDX_Text(pDX, IDC_SPEEDDIAL_ADD_EDIT_DISPLAYNAME, m_CallEntry.m_sDisplayName);
	DDX_Text(pDX, IDC_SPEEDDIAL_ADD_EDIT_ADDRESS, m_CallEntry.m_sAddress);
}


BEGIN_MESSAGE_MAP(CSpeedDialAddDlg, CDialog)
	//{{AFX_MSG_MAP(CSpeedDialAddDlg)
	ON_WM_HELPINFO() 
	ON_WM_CONTEXTMENU()
	ON_EN_CHANGE(IDC_SPEEDDIAL_ADD_EDIT_ADDRESS, OnChangeSpeeddial)
	ON_EN_CHANGE(IDC_SPEEDDIAL_ADD_EDIT_DISPLAYNAME, OnChangeSpeeddial)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
BOOL CSpeedDialAddDlg::OnHelpInfo(HELPINFO* pHelpInfo)
{
	if (pHelpInfo->iContextType == HELPINFO_WINDOW)
	{
      AfxGetApp()->WinHelp(HandleToUlong(pHelpInfo->hItemHandle),HELP_WM_HELP);
		return TRUE;
   }
   return FALSE;
}

/////////////////////////////////////////////////////////////////////////////////////////
void CSpeedDialAddDlg::OnContextMenu(CWnd* pWnd, CPoint point) 
{
   AfxGetApp()->WinHelp(HandleToUlong(pWnd->GetSafeHwnd()),HELP_CONTEXTMENU);
}

/////////////////////////////////////////////////////////////////////////////////////////
BOOL CSpeedDialAddDlg::OnInitDialog() 
{
	CWnd *pWnd = GetDlgItem( IDC_SPEEDDIAL_ADD_EDIT_DISPLAYNAME );
	if ( pWnd )
		pWnd->SendMessage( EM_SETLIMITTEXT, 65, 0 );

	pWnd = GetDlgItem( IDC_SPEEDDIAL_ADD_EDIT_ADDRESS );
	if ( pWnd )
		pWnd->SendMessage( EM_SETLIMITTEXT, 65, 0 );

	switch (m_CallEntry.m_MediaType)
	{
		case DIALER_MEDIATYPE_INTERNET:			m_nMediaType = 1; break;
		case DIALER_MEDIATYPE_CONFERENCE:		m_nMediaType = 2; break;
		default:								m_nMediaType = 0; break;
	}

	CDialog::OnInitDialog();
	CenterWindow(GetDesktopWindow());

	UpdateOkButton();
		
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////////////
void CSpeedDialAddDlg::OnOK() 
{
	UpdateData(TRUE);

	switch (m_nMediaType)
	{
		case 1:
			m_CallEntry.m_MediaType = DIALER_MEDIATYPE_INTERNET;
			m_CallEntry.m_lAddressType = LINEADDRESSTYPE_IPADDRESS;
			break;

		case 2:
			m_CallEntry.m_MediaType = DIALER_MEDIATYPE_CONFERENCE;
			m_CallEntry.m_lAddressType = LINEADDRESSTYPE_SDP;
			break;

		default:
			m_CallEntry.m_MediaType = DIALER_MEDIATYPE_POTS;
			m_CallEntry.m_lAddressType = LINEADDRESSTYPE_PHONENUMBER;
			break;
	}

	CDialog::OnOK();

	if ( !m_CallEntry.m_sDisplayName.GetLength() )
		m_CallEntry.m_sDisplayName = m_CallEntry.m_sAddress;
}

void CSpeedDialAddDlg::OnChangeSpeeddial() 
{
	UpdateOkButton();
}

void CSpeedDialAddDlg::UpdateOkButton()
{
	ASSERT( GetDlgItem(IDOK) &&	GetDlgItem(IDC_SPEEDDIAL_ADD_EDIT_ADDRESS) );

	// Only enable okay button if we have both a name and an address
	if ( GetDlgItem(IDOK) && GetDlgItem(IDC_SPEEDDIAL_ADD_EDIT_ADDRESS) )
		GetDlgItem(IDOK)->EnableWindow( (bool) (GetDlgItem(IDC_SPEEDDIAL_ADD_EDIT_ADDRESS)->GetWindowTextLength() > 0) );
}


/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
// Class CSpeedDialEditDlg dialog
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
CSpeedDialEditDlg::CSpeedDialEditDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CSpeedDialEditDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSpeedDialEditDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

/////////////////////////////////////////////////////////////////////////////
void CSpeedDialEditDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSpeedDialEditDlg)
	DDX_Control(pDX, IDC_SPEEDDIAL_EDIT_LIST_ENTRIES, m_listEntries);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSpeedDialEditDlg, CDialog)
	//{{AFX_MSG_MAP(CSpeedDialEditDlg)
	ON_BN_CLICKED(IDC_SPEEDDIAL_EDIT_BUTTON_MOVEDOWN, OnSpeeddialEditButtonMovedown)
	ON_BN_CLICKED(IDC_SPEEDDIAL_EDIT_BUTTON_MOVEUP, OnSpeeddialEditButtonMoveup)
	ON_BN_CLICKED(IDOK, OnSpeeddialEditButtonClose)
	ON_BN_CLICKED(IDC_SPEEDDIAL_EDIT_BUTTON_REMOVE, OnSpeeddialEditButtonRemove)
	ON_BN_CLICKED(IDC_SPEEDDIAL_EDIT_BUTTON_EDIT, OnSpeeddialEditButtonEdit)
	ON_BN_CLICKED(IDC_SPEEDDIAL_EDIT_BUTTON_ADD, OnSpeeddialEditButtonAdd)
	ON_NOTIFY(NM_DBLCLK, IDC_SPEEDDIAL_EDIT_LIST_ENTRIES, OnDblclkSpeeddialEditListEntries)
   ON_WM_HELPINFO() 
	ON_WM_CONTEXTMENU()
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_SPEEDDIAL_EDIT_LIST_ENTRIES, OnItemchangedSpeeddialEditListEntries)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
BOOL CSpeedDialEditDlg::OnHelpInfo(HELPINFO* pHelpInfo)
{
	if (pHelpInfo->iContextType == HELPINFO_WINDOW)
	{
      AfxGetApp()->WinHelp(HandleToUlong(pHelpInfo->hItemHandle),HELP_WM_HELP);
		return TRUE;
   }
   return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
void CSpeedDialEditDlg::OnContextMenu(CWnd* pWnd, CPoint point) 
{
   AfxGetApp()->WinHelp(HandleToUlong(pWnd->GetSafeHwnd()),HELP_CONTEXTMENU);
}

/////////////////////////////////////////////////////////////////////////////
BOOL CSpeedDialEditDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	CenterWindow(GetDesktopWindow());

	m_ImageList.Create(IDB_LIST_DIAL,16,0,RGB_TRANS);
	m_listEntries.SetImageList(&m_ImageList,LVSIL_SMALL);

	LoadCallEntries();

	m_listEntries.SetItemState(0,LVIS_SELECTED|LVIS_FOCUSED,LVIS_SELECTED|LVIS_FOCUSED);
	m_listEntries.SetFocus();

	UpdateButtonStates();

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////////////
void CSpeedDialEditDlg::LoadCallEntries()
{
   int nCount = m_listEntries.GetItemCount();

   for (int nItem=0;nItem<nCount;nItem++)
   {
      CCallEntry* pCallEntry = (CCallEntry*)m_listEntries.GetItemData(nItem);
      if (pCallEntry) delete pCallEntry;
   }
   m_listEntries.DeleteAllItems();

   int nIndex = 1;
   CCallEntry* pCallEntry = new CCallEntry;
   while (CDialerRegistry::GetCallEntry(nIndex,FALSE,*pCallEntry))
   {
      UINT nImage = -1;
      switch (pCallEntry->m_MediaType)
      {
         case DIALER_MEDIATYPE_POTS:         nImage = DIAL_IMAGE_POTS_POS;          break;
         case DIALER_MEDIATYPE_CONFERENCE:   nImage = DIAL_IMAGE_CONFERENCE_POS;    break;
         case DIALER_MEDIATYPE_INTERNET:     nImage = DIAL_IMAGE_INTERNET_POS;      break;
      }

      m_listEntries.InsertItem(LVIF_TEXT|LVIF_IMAGE|LVIF_PARAM,
              m_listEntries.GetItemCount(),
              pCallEntry->m_sDisplayName,
              0,0,nImage,(LPARAM)pCallEntry);
      nIndex++;
      pCallEntry = new CCallEntry;
   }
   delete pCallEntry;      //delete the extra
}

/////////////////////////////////////////////////////////////////////////////
BOOL CSpeedDialEditDlg::DestroyWindow() 
{
   int nCount = m_listEntries.GetItemCount();

   for (int nItem=0;nItem<nCount;nItem++)
   {
      CCallEntry* pCallEntry = (CCallEntry*)m_listEntries.GetItemData(nItem);
      if (pCallEntry) delete pCallEntry;
   }
   m_listEntries.DeleteAllItems();
	
	return CDialog::DestroyWindow();
}

/////////////////////////////////////////////////////////////////////////////
void CSpeedDialEditDlg::OnSpeeddialEditButtonClose() 
{
   //Apply Changes  
   int nCount = m_listEntries.GetItemCount();

   CObList CallEntryList;

   //make array of index for reorder.  The lParam in listctrl has the original index of entry
   for (int nItem=0;nItem<nCount;nItem++)
   {
      CCallEntry* pCallEntry = (CCallEntry*)m_listEntries.GetItemData(nItem);
      if (pCallEntry)
      {
         CallEntryList.AddTail(pCallEntry);
      }
   }

   //Now rewrite the speeddial list
   CDialerRegistry::ReOrder(FALSE,&CallEntryList);

   //Close the window
   SendMessage(WM_CLOSE);
}

/////////////////////////////////////////////////////////////////////////////
void CSpeedDialEditDlg::OnSpeeddialEditButtonMovedown() 
{
   m_listEntries.SetFocus();
   int nItem;
   //get the selected item
   if ((nItem = m_listEntries.GetNextItem(-1,LVNI_FOCUSED)) != -1)
   {
      //make sure we are not the last
      if (nItem != m_listEntries.GetItemCount()-1)
      {
         LV_ITEM lv_item;
         memset(&lv_item,0,sizeof(LV_ITEM));
         TCHAR szText[256];
         lv_item.pszText = szText;
         lv_item.cchTextMax = 255;
         memset(szText,0,256);
         lv_item.iItem = nItem;
      	lv_item.mask |= LVIF_TEXT|LVIF_PARAM|LVIF_IMAGE;
         if (m_listEntries.GetItem(&lv_item))
         {         
            m_listEntries.DeleteItem(nItem);    
            lv_item.iItem++;
            int nNewIndex = m_listEntries.InsertItem(&lv_item);
            m_listEntries.SetItemState(nNewIndex,LVIS_SELECTED|LVIS_FOCUSED,LVIS_SELECTED|LVIS_FOCUSED);
         }
      }
   }
}

/////////////////////////////////////////////////////////////////////////////
void CSpeedDialEditDlg::OnSpeeddialEditButtonMoveup() 
{
   m_listEntries.SetFocus();
   int nItem;
   //get the selected item
   if ((nItem = m_listEntries.GetNextItem(-1,LVNI_FOCUSED)) != -1)
   {
      //make sure we are not the first
      if (nItem != 0)
      {
         LV_ITEM lv_item;
         memset(&lv_item,0,sizeof(LV_ITEM));
         TCHAR szText[256];
         lv_item.pszText = szText;
         lv_item.cchTextMax = 255;
         memset(szText,0,256);
         lv_item.iItem = nItem;
      	lv_item.mask |= LVIF_TEXT|LVIF_PARAM|LVIF_IMAGE;
         if (m_listEntries.GetItem(&lv_item))
         {         
            m_listEntries.DeleteItem(nItem);    
            lv_item.iItem--;
            int nNewIndex = m_listEntries.InsertItem(&lv_item);
            m_listEntries.SetItemState(nNewIndex,LVIS_SELECTED|LVIS_FOCUSED,LVIS_SELECTED|LVIS_FOCUSED);
         }
      }
   }
}

/////////////////////////////////////////////////////////////////////////////
void CSpeedDialEditDlg::OnSpeeddialEditButtonRemove() 
{
	m_listEntries.SetFocus();
	int nItem;
	//get the selected item
	if ((nItem = m_listEntries.GetNextItem(-1,LVNI_SELECTED)) != -1)
	{
		CCallEntry* pCallEntry = (CCallEntry*)m_listEntries.GetItemData(nItem);
		m_listEntries.DeleteItem(nItem);
		if (pCallEntry) delete pCallEntry;

		// Select an item and set it's state accordingly
		if ( nItem >= m_listEntries.GetItemCount() )
			nItem = m_listEntries.GetItemCount() - 1;

		m_listEntries.SetItemState( nItem, LVIS_SELECTED | LVIS_FOCUSED,LVIS_SELECTED | LVIS_FOCUSED );
	}

	UpdateButtonStates();
}

/////////////////////////////////////////////////////////////////////////////
void CSpeedDialEditDlg::OnDblclkSpeeddialEditListEntries(NMHDR* pNMHDR, LRESULT* pResult) 
{
   OnSpeeddialEditButtonEdit();
	*pResult = 0;
}

/////////////////////////////////////////////////////////////////////////////
void CSpeedDialEditDlg::OnSpeeddialEditButtonEdit() 
{
   m_listEntries.SetFocus();
   int nItem;
   //get the selected item
   if ((nItem = m_listEntries.GetNextItem(-1,LVNI_FOCUSED)) != -1)
   {
      CCallEntry* pCallEntry = (CCallEntry*)m_listEntries.GetItemData(nItem);
      CSpeedDialAddDlg dlg;
      dlg.m_CallEntry = *pCallEntry;
      if (dlg.DoModal() == IDOK)
      {
         *pCallEntry = dlg.m_CallEntry;        

         //remove the item from the list
         m_listEntries.DeleteItem(nItem);    

         //reinsert the item in the list with new attributes
         UINT nImage = -1;
         switch (pCallEntry->m_MediaType)
         {
            case DIALER_MEDIATYPE_POTS:         nImage = DIAL_IMAGE_POTS_POS;          break;
            case DIALER_MEDIATYPE_CONFERENCE:   nImage = DIAL_IMAGE_CONFERENCE_POS;    break;
            case DIALER_MEDIATYPE_INTERNET:     nImage = DIAL_IMAGE_INTERNET_POS;      break;
         }
         m_listEntries.InsertItem(LVIF_TEXT|LVIF_IMAGE|LVIF_PARAM,
              nItem,
              pCallEntry->m_sDisplayName,
              0,0,nImage,(LPARAM)pCallEntry);

         //set selection back to item
         m_listEntries.SetItemState(nItem,LVIS_SELECTED|LVIS_FOCUSED,LVIS_SELECTED|LVIS_FOCUSED);
      }
   }
}

/////////////////////////////////////////////////////////////////////////////
void CSpeedDialEditDlg::OnSpeeddialEditButtonAdd() 
{
   m_listEntries.SetFocus();

   CSpeedDialAddDlg dlg;
   dlg.m_CallEntry.m_MediaType = DIALER_MEDIATYPE_INTERNET;
   dlg.m_CallEntry.m_lAddressType = LINEADDRESSTYPE_IPADDRESS;
   if (dlg.DoModal() == IDOK)
   {
      CCallEntry* pCallEntry = new CCallEntry;
      *pCallEntry = dlg.m_CallEntry;

      //insert the item in the list
      UINT nImage = -1;
      switch (pCallEntry->m_MediaType)
      {
         case DIALER_MEDIATYPE_POTS:         nImage = DIAL_IMAGE_POTS_POS;          break;
         case DIALER_MEDIATYPE_CONFERENCE:   nImage = DIAL_IMAGE_CONFERENCE_POS;    break;
         case DIALER_MEDIATYPE_INTERNET:     nImage = DIAL_IMAGE_INTERNET_POS;      break;
      }

      m_listEntries.InsertItem(LVIF_TEXT|LVIF_IMAGE|LVIF_PARAM,
           0,
           pCallEntry->m_sDisplayName,
           0,0,nImage,(LPARAM)pCallEntry);

      //set selection back to new item
      m_listEntries.SetItemState(0,LVIS_SELECTED|LVIS_FOCUSED,LVIS_SELECTED|LVIS_FOCUSED);
   }

   UpdateButtonStates();
}

void CSpeedDialEditDlg::UpdateButtonStates()
{
	int nSel = ((CListCtrl *) GetDlgItem(IDC_SPEEDDIAL_EDIT_LIST_ENTRIES))->GetNextItem(-1,LVNI_SELECTED);

	bool bEnable = (bool) (nSel >= 0);
	GetDlgItem(IDC_SPEEDDIAL_EDIT_BUTTON_REMOVE)->EnableWindow( bEnable );
	GetDlgItem(IDC_SPEEDDIAL_EDIT_BUTTON_EDIT)->EnableWindow( bEnable );

	bEnable =  (bool) (nSel < ((CListCtrl *) GetDlgItem(IDC_SPEEDDIAL_EDIT_LIST_ENTRIES))->GetItemCount() - 1);
	GetDlgItem(IDC_SPEEDDIAL_EDIT_BUTTON_MOVEDOWN)->EnableWindow( bEnable );

	bEnable = (bool) (nSel > 0);
	GetDlgItem(IDC_SPEEDDIAL_EDIT_BUTTON_MOVEUP)->EnableWindow( bEnable );
}

void CSpeedDialEditDlg::OnItemchangedSpeeddialEditListEntries(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	UpdateButtonStates();
	
	*pResult = 0;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CSpeedDialMoreDlg dialog
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
CSpeedDialMoreDlg::CSpeedDialMoreDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CSpeedDialMoreDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSpeedDialMoreDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

/////////////////////////////////////////////////////////////////////////////
void CSpeedDialMoreDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSpeedDialMoreDlg)
	DDX_Control(pDX, IDC_SPEEDDIAL_MORE_LIST_ADDRESSES, m_listEntries);
	//}}AFX_DATA_MAP
}

/////////////////////////////////////////////////////////////////////////////
BEGIN_MESSAGE_MAP(CSpeedDialMoreDlg, CDialog)
	//{{AFX_MSG_MAP(CSpeedDialMoreDlg)
	ON_BN_CLICKED(IDC_SPEEDDIAL_MORE_BUTTON_EDITLIST, OnSpeeddialMoreButtonEditlist)
	ON_BN_CLICKED(IDC_SPEEDDIAL_MORE_BUTTON_PLACECALL, OnSpeeddialMoreButtonPlacecall)
   ON_WM_HELPINFO() 
	ON_WM_CONTEXTMENU()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
BOOL CSpeedDialMoreDlg::OnHelpInfo(HELPINFO* pHelpInfo)
{
	if (pHelpInfo->iContextType == HELPINFO_WINDOW)
	{
      AfxGetApp()->WinHelp(HandleToUlong(pHelpInfo->hItemHandle),HELP_WM_HELP);
		return TRUE;
   }
   return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
void CSpeedDialMoreDlg::OnContextMenu(CWnd* pWnd, CPoint point) 
{
   AfxGetApp()->WinHelp(HandleToUlong(pWnd->GetSafeHwnd()),HELP_CONTEXTMENU);
}

/////////////////////////////////////////////////////////////////////////////
BOOL CSpeedDialMoreDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
   CenterWindow(GetDesktopWindow());
	
   m_ImageList.Create(IDB_LIST_DIAL,16,0,RGB_TRANS);
   m_listEntries.SetImageList(&m_ImageList,LVSIL_SMALL);

   int nIndex = 1;
   CCallEntry* pCallEntry = new CCallEntry;
   while (CDialerRegistry::GetCallEntry(nIndex,FALSE,*pCallEntry))
   {
      UINT nImage = -1;
      switch (pCallEntry->m_MediaType)
      {
         case DIALER_MEDIATYPE_POTS:         nImage = DIAL_IMAGE_POTS_POS;          break;
         case DIALER_MEDIATYPE_CONFERENCE:   nImage = DIAL_IMAGE_CONFERENCE_POS;    break;
         case DIALER_MEDIATYPE_INTERNET:     nImage = DIAL_IMAGE_INTERNET_POS;      break;
      }

      m_listEntries.InsertItem(LVIF_TEXT|LVIF_IMAGE|LVIF_PARAM,
              m_listEntries.GetItemCount(),
              pCallEntry->m_sDisplayName,
              0,0,nImage,(LPARAM)pCallEntry);
      nIndex++;
      pCallEntry = new CCallEntry;
   }
   delete pCallEntry;      //delete the extra

   m_listEntries.SetItemState(0,LVIS_SELECTED|LVIS_FOCUSED,LVIS_SELECTED|LVIS_FOCUSED);
   m_listEntries.SetFocus();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
BOOL CSpeedDialMoreDlg::DestroyWindow() 
{
   int nCount = m_listEntries.GetItemCount();

   //make array of index for reorder.  The lParam in listctrl has the original index of entry
   for (int nItem=0;nItem<nCount;nItem++)
   {
      CCallEntry* pCallEntry = (CCallEntry*)m_listEntries.GetItemData(nItem);
      if (pCallEntry) delete pCallEntry;
   }
   m_listEntries.DeleteAllItems();
	
	return CDialog::DestroyWindow();
}

/////////////////////////////////////////////////////////////////////////////
void CSpeedDialMoreDlg::OnSpeeddialMoreButtonEditlist() 
{
   EndDialog(SDRETURN_EDIT);
}

/////////////////////////////////////////////////////////////////////////////
void CSpeedDialMoreDlg::OnSpeeddialMoreButtonPlacecall() 
{
   int nItem;
   //get the selected item
   if ((nItem = m_listEntries.GetNextItem(-1,LVNI_FOCUSED)) != -1)
   {
      CCallEntry* pCallEntry = (CCallEntry*)m_listEntries.GetItemData(nItem);
      m_retCallEntry = *pCallEntry;
   }

   EndDialog(SDRETURN_PLACECALL);
}

/////////////////////////////////////////////////////////////////////////////
void CSpeedDialMoreDlg::OnCancel() 
{
   EndDialog(SDRETURN_CANCEL);
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\splitter.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

/* $FILEHEADER
*
* FILE
*   splitter.h
*
* RESPONSIBILITIES
*	 
*
*/

#ifndef _SPLITTER_H_
#define _SPLITTER_H_

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CSplitterView view
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class CSplitterView : public CView
{
protected:
	CSplitterView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CSplitterView)

// Attributes
public:
	enum SPLITTYPE {SP_HORIZONTAL=1,SP_VERTICAL=2};
private:
	CWnd*			m_MainWnd;
	CWnd*			m_DetailWnd;
	BOOL			m_SizingOn;
	int			m_lastPos;
	HCURSOR		m_Cursor;
	SPLITTYPE	m_style;
	int			m_split;
   BOOL        m_bMoveSplitterOnSize;
protected:
	int			m_percent;

// Operations
public:
	BOOL				Init(SPLITTYPE split);
	void				SetMainWindow  (CWnd* pCWnd);
	void				SetDetailWindow(CWnd* pCWnd);
	void				SetDetailWindow(CWnd* pCWnd, UINT percent);
	inline CWnd*	GetDetailWindow()	{return m_DetailWnd;};
	inline CWnd*	GetMainWindow  ()	{return m_MainWnd;};
private:
	void				Arrange(BOOL bMoveSplitter=TRUE);
	int				DrawSplit(int y);

  // Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSplitterView)
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CSplitterView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CSplitterView)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnPaint();
	afx_msg void OnMouseMove(UINT nFlags, CPoint point); 
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
/////////////////////////////////////////////////////////////////////////////
#endif //_SPLITTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\splitter.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

/* $FILEHEADER
*
* FILE
*   splitter.cpp
*
* RESPONSIBILITIES
*	 
*
*/

#include "stdafx.h"
#include "splitter.h"
#include "util.h"
#include "resource.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Defines
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CSplitterView, CView)

//Splitter height or width
#define SPLITHT 6													

// Try to use proper colors
#define SPLIT_FACE   (GetSysColor(COLOR_BTNFACE))		
#define SPLIT_SHADOW (GetSysColor(COLOR_BTNSHADOW))	
#define SPLIT_HILITE (GetSysColor(COLOR_BTNHILIGHT))	
#define BLACK        (RGB(0,0,0))

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CSplitterView
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CSplitterView, CView)
	//{{AFX_MSG_MAP(CSplitterView)
	ON_WM_SIZE()
	ON_WM_PAINT()
	ON_WM_MOUSEMOVE()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_SETCURSOR()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
CSplitterView::CSplitterView()
{
	m_MainWnd	= NULL;
	m_DetailWnd = NULL;
	m_percent	= 50;
	m_split		= 0;
	m_style		= SP_VERTICAL;
 	m_SizingOn	= FALSE;
	m_lastPos	= -1;
   m_bMoveSplitterOnSize = FALSE;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CSplitterView::Init(SPLITTYPE style)
{	
//SetCursor problem with my own cursor with 32bit?
//#ifdef IDC_HORRESIZE
//	if (!(m_Cursor = LoadCursor(AfxGetResourceHandle(),MAKEINTRESOURCE(IDC_HORRESIZE))))
//#endif
	if (style == SP_VERTICAL)
		m_Cursor  = LoadCursor(NULL,IDC_SIZEWE);		//Use system default
	else
		m_Cursor  = LoadCursor(NULL,IDC_SIZENS);		//Use system default
	m_style = style;
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
CSplitterView::~CSplitterView()
{
	DeleteObject(m_Cursor);
}

/////////////////////////////////////////////////////////////////////////////
void CSplitterView::SetMainWindow(CWnd* pCWnd)
{
	ASSERT(pCWnd);
	ASSERT(IsWindow(pCWnd->m_hWnd));

   if (IsWindow(pCWnd->m_hWnd) == FALSE) return;
	if (m_MainWnd==pCWnd) return;             			//Main still the same
  
	if (m_MainWnd) m_MainWnd->ShowWindow(SW_HIDE);		//Hide windows	                  
	m_MainWnd   = pCWnd;											//Save new window
	Arrange(FALSE);												//Arrange the windows
	if (m_MainWnd) m_MainWnd->ShowWindow(SW_SHOW);		//Show the windows
}

/////////////////////////////////////////////////////////////////////////////
void CSplitterView::SetDetailWindow(CWnd* pCWnd)
{
	ASSERT(pCWnd);  
	ASSERT(IsWindow(pCWnd->m_hWnd));
	
   if (IsWindow(pCWnd->m_hWnd) == FALSE) return;
	if (pCWnd == m_DetailWnd) return;					//Detail still the same

	if ( (m_DetailWnd) && (IsWindow(m_DetailWnd->m_hWnd)) )  //Hide old window
   {
      if (m_DetailWnd->GetControlUnknown())        //Is this an OLE control
			m_DetailWnd->MoveWindow(0,0,0,0);            
      else
		   m_DetailWnd->ShowWindow(SW_HIDE);			//Hide the old window
   }
	m_DetailWnd = pCWnd;										//Detail is new window
	Arrange(FALSE);											//Arrange properly
	
	m_DetailWnd->ShowWindow(SW_SHOW);					//Show new window
}

/////////////////////////////////////////////////////////////////////////////
void CSplitterView::SetDetailWindow(CWnd* pCWnd,UINT percent)
{
	ASSERT(pCWnd);  
	ASSERT(IsWindow(pCWnd->m_hWnd));
	ASSERT(m_MainWnd);											//Must be a main window

   if (IsWindow(pCWnd->m_hWnd) == FALSE) return;
	if (pCWnd == m_DetailWnd) return;						//No change

	m_percent = percent;

   RECT rc;
	GetClientRect(&rc);
  
	if (m_DetailWnd) 
   {
      if (m_DetailWnd->GetControlUnknown())           //Is this an OLE control
			m_DetailWnd->MoveWindow(0,0,0,0);            
      else
		   m_DetailWnd->ShowWindow(SW_HIDE);				//Hide the old window
   }
	m_DetailWnd = pCWnd;											//Use the new one

	Arrange(TRUE);													//Arrange the windows
  
	m_DetailWnd->ShowWindow(SW_SHOW);						//Show the new window
}

/////////////////////////////////////////////////////////////////////////////
void CSplitterView::OnPaint() 
{
	CPaintDC dc(this);											//device context for painting
	CDC* cdc = GetDC();
	OnDraw(cdc);
	ReleaseDC(cdc);
}

/////////////////////////////////////////////////////////////////////////////
void CSplitterView::OnDraw(CDC* pDC)
{
	if (m_DetailWnd)
	{	
		RECT rc;
		GetClientRect(&rc);
		if (m_style & SP_HORIZONTAL)
		{
			DrawLine(pDC, 0, m_split+0, rc.right-0, m_split+0, BLACK );
			DrawLine(pDC, 1, m_split+1, rc.right-1, m_split+1, SPLIT_HILITE );
			DrawLine(pDC, 1, m_split+2, rc.right-1, m_split+2, SPLIT_FACE);
			DrawLine(pDC, 1, m_split+3, rc.right-1, m_split+3, SPLIT_FACE);
			DrawLine(pDC, 0, m_split+4, rc.right-1, m_split+4, SPLIT_SHADOW);
			DrawLine(pDC, 0, m_split+5, rc.right-0, m_split+5, BLACK );
			DrawLine(pDC, 0,				m_split+1, 0         , m_split+4, SPLIT_HILITE);
			DrawLine(pDC, rc.right-1,	m_split+1, rc.right-1, m_split+5, SPLIT_SHADOW);
		}
		else //SP_VERTICAL
		{	
			DrawLine(pDC, m_split+0, 0, m_split+0, rc.bottom-0, BLACK );
			DrawLine(pDC, m_split+1, 1, m_split+1, rc.bottom-1, SPLIT_HILITE );
			DrawLine(pDC, m_split+2, 1, m_split+2, rc.bottom-1, SPLIT_FACE);
			DrawLine(pDC, m_split+3, 1, m_split+3, rc.bottom-1, SPLIT_FACE);
			DrawLine(pDC, m_split+4, 0, m_split+4, rc.bottom-1, SPLIT_SHADOW);
			DrawLine(pDC, m_split+5, 0, m_split+5, rc.bottom-0, BLACK );
			DrawLine(pDC, m_split+1, 0,				m_split+4, 0          , SPLIT_HILITE);
			DrawLine(pDC, m_split+1, rc.bottom-1,	m_split+5, rc.bottom-1, SPLIT_SHADOW);
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CSplitterView diagnostics
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
void CSplitterView::AssertValid() const
{
	CView::AssertValid();
}

/////////////////////////////////////////////////////////////////////////////
void CSplitterView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
void CSplitterView::Arrange(BOOL bMoveSplitter)
{
	RECT rc;
	GetClientRect(&rc);
	int cx = rc.right;
	int cy = rc.bottom;

	if (m_MainWnd)
	{
		if (m_DetailWnd)
		{
	      if (m_style & SP_HORIZONTAL)
		   {
            if (bMoveSplitter)
				   m_split = (int)(max(SPLITHT,(long)cy - (((long)cy * min((long)m_percent,100))/100)));
				m_DetailWnd->MoveWindow(0,m_split+SPLITHT,cx,cy-m_split-SPLITHT);
			}
			else	//SP_VERTICAL
			{	
            if (bMoveSplitter)
   				m_split = (int)(max(SPLITHT,(long)cx - (((long)cx * min((long)m_percent,100))/100)));
				m_DetailWnd->MoveWindow(m_split+SPLITHT,0,cx-m_split-SPLITHT,cy);
			}
		}
		else
      {
         m_split = (m_style & SP_HORIZONTAL?cy:cx);  
      }

		//Arrange main
		if (m_style & SP_HORIZONTAL)
			m_MainWnd->MoveWindow(0,0,cx,m_split);
      else	//SP_VERTICAL
			m_MainWnd->MoveWindow(0,0,m_split,cy);
	}
}

/////////////////////////////////////////////////////////////////////////////
void CSplitterView::OnSize(UINT nType, int cx, int cy) 
{
	CView::OnSize(nType, cx, cy);

	Arrange(m_bMoveSplitterOnSize);
}

/////////////////////////////////////////////////////////////////////////////
void CSplitterView::OnLButtonDown(UINT nFlags, CPoint point) 
{
	m_SizingOn=TRUE;
	m_lastPos   =-1;
	SetCapture();
}

/////////////////////////////////////////////////////////////////////////////
void CSplitterView::OnLButtonUp(UINT nFlags, CPoint point) 
{
	if (m_SizingOn)
	{
		m_SizingOn=FALSE;
	
      if (m_lastPos != -1)
		{
			RECT rc;
			GetClientRect(&rc);
			DrawSplit(m_lastPos);

		   if (m_style & SP_HORIZONTAL)
      		m_percent = (int)(100-(((long)m_lastPos*100)/(long)rc.bottom));
			else	//SP_VERTICAL
      		m_percent = (int)(100-(((long)m_lastPos*100)/(long)rc.right));
         
			Arrange();
		}
	}
	ReleaseCapture();
}

/////////////////////////////////////////////////////////////////////////////
int CSplitterView::DrawSplit(int y)
{
	CDC* cdc = GetDC();
	CRect rc;
	GetClientRect(&rc);
	if (m_style & SP_HORIZONTAL)
	{
		y = max(0,min(rc.bottom-SPLITHT,y));
		rc.top = y;
		rc.bottom = y+SPLITHT;
	}
	else	//SP_VERTICAL
	{
		y = max(0,min(rc.right-SPLITHT,y));
		rc.left = y;
		rc.right = y+SPLITHT;
	}
	cdc->InvertRect(&rc);
	ReleaseDC(cdc);
	return y;
}

/////////////////////////////////////////////////////////////////////////////
void CSplitterView::OnMouseMove(UINT nFlags, CPoint pt) 
{
	::SetCursor(m_Cursor);
	if (m_SizingOn)
	{	
	   if (m_lastPos != -1)
         DrawSplit(m_lastPos);

	   m_lastPos = (m_style & SP_HORIZONTAL)?DrawSplit(pt.y):DrawSplit(pt.x);
   }
}

/////////////////////////////////////////////////////////////////////////////
BOOL CSplitterView::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message) 
{
	//Do not let system draw default cursor when pWnd is us.
	if (pWnd == this) 
		return TRUE;
	return CView::OnSetCursor(pWnd, nHitTest, message);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\stdafx.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// stdafx.cpp : source file that includes just the standard includes
//      ActiveDialer.pch will be the pre-compiled header
//      stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\stdafx.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A0D7A95E_3C0B_11D1_B4F9_00C04FC98AD3__INCLUDED_)
#define AFX_STDAFX_H__A0D7A95E_3C0B_11D1_B4F9_00C04FC98AD3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#include <afxmt.h>          // MFC Synch classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <vfw.h> 

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// ATL Support
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#include <atlbase.h>

// ATL can increment MFC's lock count the first time and decrement MFC's lock
// count when its lock count reaches zero.
class CAtlGlobalModule : public CComModule
{
public:
	LONG Lock()
	{
		if (GetLockCount()==0)
			AfxOleLockApp();
		return CComModule::Lock();
	}
	LONG Unlock()
	{
		LONG l = CComModule::Unlock();
		if (GetLockCount() == 0)
			AfxOleUnlockApp();
		return l;
	}
};

extern CAtlGlobalModule _Module;

#include <atlcom.h>

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#define RGB_TRANS        RGB(255,0,255)

#define	LARGE_ICON_X		135
#define LARGE_ICON_Y		80
#define SMALL_ICON_X		10
#define SMALL_ICON_Y		0			

#define RELEASE(_P_)		{ if (_P_) { (_P_)->Release(); _P_ = NULL; } }

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A0D7A95E_3C0B_11D1_B4F9_00C04FC98AD3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\usb.h ===
//
// USB constants
//

#ifndef _AVDIALER_USB_
#define _AVDIALER_USB_

// Message
#define WM_USBPHONE                 (WM_USER + 1050)

// Events
#define AVUSB_MAKECALL              1
#define AVUSB_CANCELCALL            2
#define AVUSB_REDIAL                3

#endif

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\trayicon.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "trayicon.h"
#include "DialReg.h"
#include "resource.h"
#include "util.h"
#include <afxpriv.h>        // for AfxLoadString

IMPLEMENT_DYNAMIC(CTrayIcon, CCmdTarget)

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Class CTrayIcon
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
CTrayIcon::CTrayIcon(UINT uID)
{
    // Initialize NOTIFYICONDATA
    memset(&m_nid,0,sizeof(m_nid));
    m_nid.cbSize = sizeof(m_nid);
    m_nid.uID = uID;                                        // never changes after construction

    AfxLoadString(uID, m_nid.szTip, sizeof(m_nid.szTip)); // Use resource string as tip if there is one
}

/////////////////////////////////////////////////////////////////////////////
CTrayIcon::~CTrayIcon()
{
    SetIcon(0);                                           // remove icon from system tray
}

/////////////////////////////////////////////////////////////////////////////
// Set notification window. It must created already.
/////////////////////////////////////////////////////////////////////////////
void CTrayIcon::SetNotificationWnd(CWnd* pNotifyWnd, UINT uCbMsg)
{
    // If the following assert fails, you're probably
    // calling me before you created your window. Oops.

    //
    // We should verify pNotifyWnd
    //

    if( pNotifyWnd == NULL || !::IsWindow( pNotifyWnd->GetSafeHwnd()))
    {
        return;
    }

    m_nid.hWnd = pNotifyWnd->GetSafeHwnd();

    ASSERT(uCbMsg==0 || uCbMsg>=WM_USER);
    m_nid.uCallbackMessage = uCbMsg;
}

/////////////////////////////////////////////////////////////////////////////
// This is the main variant for setting the icon.
// Sets both the icon and tooltip from resource ID
// To remove the icon, call SetIcon(0)
/////////////////////////////////////////////////////////////////////////////
BOOL CTrayIcon::SetIcon(UINT uID)
{ 
    HICON hicon=NULL;
    if (uID) 
   {
        AfxLoadString(uID, m_nid.szTip, sizeof(m_nid.szTip));
        hicon = AfxGetApp()->LoadIcon(uID);
    }
    return SetIcon(hicon, NULL);
}

/////////////////////////////////////////////////////////////////////////////
// Common SetIcon for all overloads. 
/////////////////////////////////////////////////////////////////////////////
BOOL CTrayIcon::SetIcon(HICON hicon, LPCTSTR lpTip) 
{
   //If we haven't set the notification window
   if (m_nid.uCallbackMessage == 0)
      return TRUE;

    UINT msg;
    m_nid.uFlags = 0;

    // Set the icon
    if (hicon)
   {
        msg = m_nid.hIcon ? NIM_MODIFY : NIM_ADD;          // Add or replace icon in system tray
        m_nid.hIcon = hicon;
        m_nid.uFlags |= NIF_ICON;
    }
   else
   {                                                     
        if (m_nid.hIcon == NULL)                           // remove icon from tray
            return TRUE;                                      // already deleted
        msg = NIM_DELETE;
    }

    // Use the tip, if any
    if (lpTip)
        _tcsncpy(m_nid.szTip, lpTip, sizeof(m_nid.szTip)/sizeof(m_nid.szTip[0]));
    if (m_nid.szTip[0])
        m_nid.uFlags |= NIF_TIP;

    // Use callback if any
    if (m_nid.uCallbackMessage && m_nid.hWnd)
        m_nid.uFlags |= NIF_MESSAGE;

    // Do it
    BOOL bRet = Shell_NotifyIcon(msg, &m_nid);

    if (msg==NIM_DELETE || !bRet)
        m_nid.hIcon = NULL;                                  // failed

    return bRet;
}

/////////////////////////////////////////////////////////////////////////////
// Call this function from your own notification handler.
/////////////////////////////////////////////////////////////////////////////
LRESULT CTrayIcon::OnTrayNotification(WPARAM wID, LPARAM lEvent)
{
    if (wID != m_nid.uID) return 0;

    // If there's a resource menu with the same ID as the icon, use it as 
    // the left-button popup menu. CTrayIcon will interprets the first
    // item in the menu as the default command for WM_LBUTTONDBLCLK

    if (lEvent==WM_RBUTTONUP)
   {
      //hide/unhide call windows
      1;
   }
    else if (lEvent==WM_LBUTTONUP)
   {
      1;
   }
    else if (lEvent==WM_LBUTTONDBLCLK)
   {
      //open explorer view
      1;
   }
    else if (lEvent==WM_RBUTTONDBLCLK)
   {
      1;
   }
    return 1;                                             // handled
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\toolbars.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// ToolBars.h
/////////////////////////////////////////////////////////////////////////////

#ifndef __TOOLBARS_H__
#define __TOOLBARS_H__

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "coolbar.h"
#include "dialtoolbar.h"

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//CDirectoriesCoolBar
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class CDirectoriesCoolBar : public CCoolBar
{
public:
   CDirectoriesCoolBar();
   ~CDirectoriesCoolBar();
protected:
	DECLARE_DYNAMIC(CDirectoriesCoolBar)

// Attributes
protected:
   CCoolToolBar*		m_pwndDialToolBar;
   BOOL					m_bShowText;

// Operations
protected:
   virtual BOOL      OnCreateBands();
public:
   void              ReCreateBands(bool bHideVersion);
   void              ShowTextLabel(BOOL bShowText)       { m_bShowText = bShowText; };

	//{{AFX_MSG(CDirectoriesCoolBar)
   afx_msg void OnToolBarDropDown(NMHDR* pNMHDR, LRESULT* pResult);

	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif //__TOOLBARS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\toolbars.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// ToolBars.cpp
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "avDialer.h"
#include "ToolBars.h"
#include "util.h"

void SetButtonText(CToolBar* pToolBar,LPCTSTR lpszResourceName);
BOOL AddToBand(CCoolBar* pCoolBar,CCoolToolBar* pToolBar);

////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// Class CDirectoriesCoolBar
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CDirectoriesCoolBar, CCoolBar)

BEGIN_MESSAGE_MAP(CDirectoriesCoolBar, CCoolBar)
	//{{AFX_MSG_MAP(CDirectoriesCoolBar)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

////////////////////////////////////////////////////////////////
CDirectoriesCoolBar::CDirectoriesCoolBar()
{
   m_pwndDialToolBar = NULL;
   m_bShowText = TRUE;
}

////////////////////////////////////////////////////////////////
CDirectoriesCoolBar::~CDirectoriesCoolBar()
{
   delete m_pwndDialToolBar;
}

////////////////////////////////////////////////////////////////
// This is the virtual function you have to override to add bands
////////////////////////////////////////////////////////////////
BOOL CDirectoriesCoolBar::OnCreateBands()
{
   ReCreateBands( true );
	return 0; // OK
}

////////////////////////////////////////////////////////////////
void CDirectoriesCoolBar::ReCreateBands( bool bHideVersion )
{
	UINT nID = (bHideVersion) ? IDR_MAINFRAME : IDR_MAINFRAME_SHOW;
   int nCount = GetBandCount();
   for (int i=nCount;i>0;i--)
   {
      DeleteBand(i-1);
   }
   
   if (m_pwndDialToolBar)
   {
      m_pwndDialToolBar->DestroyWindow();
      delete m_pwndDialToolBar;
   }

   m_pwndDialToolBar = new CCoolToolBar;

   if (!m_pwndDialToolBar->Create(this,
		WS_CHILD|WS_VISIBLE|WS_CLIPSIBLINGS|WS_CLIPCHILDREN|
			CBRS_TOOLTIPS|CBRS_SIZE_DYNAMIC|CBRS_FLYBY|CBRS_ORIENT_HORZ) ||
		 !m_pwndDialToolBar->LoadToolBar(nID) ) {
		TRACE0("Failed to create toolbar\n");
		return; // failed to create
	}
	m_pwndDialToolBar->ModifyStyle(0, TBSTYLE_FLAT);

   CToolBarCtrl& toolbarctrl = m_pwndDialToolBar->GetToolBarCtrl();
   toolbarctrl.SendMessage(TB_SETEXTENDEDSTYLE,0,TBSTYLE_EX_DRAWDDARROWS);
   
   if ( m_bShowText )
      SetButtonText( m_pwndDialToolBar, MAKEINTRESOURCE(nID) );

   //set the dropdown style for the redial and speeddial
   UINT uStyle = m_pwndDialToolBar->GetButtonStyle(1);
   uStyle |= TBSTYLE_DROPDOWN;
   m_pwndDialToolBar->SetButtonStyle(1,uStyle);
   uStyle = m_pwndDialToolBar->GetButtonStyle(2);
   uStyle |= TBSTYLE_DROPDOWN;
   m_pwndDialToolBar->SetButtonStyle(2,uStyle);

   AddToBand(this,m_pwndDialToolBar);
}

////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////

struct CToolBarData
{
	WORD wVersion;
	WORD wWidth;
	WORD wHeight;
	WORD wItemCount;
	WORD* items()     { return (WORD*)(this+1); }
};

////////////////////////////////////////////////////////////////
void SetButtonText(CToolBar* pToolBar,LPCTSTR lpszResourceName)
{
	// determine location of the bitmap in resource fork
	HINSTANCE hInst = AfxFindResourceHandle(lpszResourceName, RT_TOOLBAR);
	HRSRC hRsrc = ::FindResource(hInst, lpszResourceName, RT_TOOLBAR);
	if (hRsrc == NULL)
		return;

	HGLOBAL hGlobal = LoadResource(hInst, hRsrc);
	if (hGlobal == NULL)
		return;

	CToolBarData* pData = (CToolBarData*)LockResource(hGlobal);
	if (pData == NULL)
		return;
	ASSERT(pData->wVersion == 1);

	//UINT* pItems = new UINT[pData->wItemCount];
   for (int i = 0; i < pData->wItemCount; i++)
   {
	   CString sFullText,sText;
      sFullText.LoadString(pData->items()[i]);
      ParseToken(sFullText,sText,'\n');
      ParseToken(sFullText,sText,'\n');
      pToolBar->SetButtonText(i,sFullText);
   }
}

////////////////////////////////////////////////////////////////
BOOL AddToBand(CCoolBar* pCoolBar,CCoolToolBar* pToolBar)
{
	CRect rcItem;
	pToolBar->GetItemRect(0,rcItem);
	pToolBar->SetSizes(CSize(rcItem.Width(),rcItem.Height()),CSize(16,15));

	// Get minimum size of bands
	CSize szVert = pToolBar->CalcDynamicLayout(-1, LM_HORZ);	// get min vert size

	CRebarBandInfo rbbi;

	// Band 1: Add toolbar band
	rbbi.fMask = RBBIM_STYLE | RBBIM_CHILD | RBBIM_CHILDSIZE | RBBIM_COLORS;
	rbbi.fStyle = RBBS_CHILDEDGE | RBBS_FIXEDBMP;
	rbbi.hwndChild = pToolBar->GetSafeHwnd();
	rbbi.cxMinChild = szVert.cx;
	rbbi.cyMinChild = szVert.cy - 6;
	rbbi.hbmBack = NULL;
	rbbi.clrFore = GetSysColor(COLOR_BTNTEXT);
	rbbi.clrBack = GetSysColor(COLOR_BTNFACE);

	return pCoolBar->InsertBand( -1, &rbbi );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\trayicon.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

//trayicon.h header file
//
/////////////////////////////////////////////////////////////////////////////
#ifndef _TRAYICON_H_
#define _TRAYICON_H_

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CTrayIcon manages an icon in the Windows 95 system tray. 
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class CBitmapMenu;

class CTrayIcon : public CCmdTarget
{
protected:
	DECLARE_DYNAMIC(CTrayIcon)
	NOTIFYICONDATA m_nid;			// struct for Shell_NotifyIcon args

public:
	CTrayIcon(UINT uID);
	~CTrayIcon();

	// Call this to receive tray notifications
	void     SetNotificationWnd(CWnd* pNotifyWnd, UINT uCbMsg);

	// SetIcon functions. To remove icon, call SetIcon(0)
	BOOL     SetIcon(UINT uID); // main variant you want to use
	BOOL     SetIcon(HICON hicon, LPCTSTR lpTip);
	BOOL     SetIcon(LPCTSTR lpResName, LPCTSTR lpTip)
		      { return SetIcon(lpResName ? AfxGetApp()->LoadIcon(lpResName) : NULL, lpTip); }
	BOOL     SetStandardIcon(LPCTSTR lpszIconName, LPCTSTR lpTip)
		      { return SetIcon(::LoadIcon(NULL, lpszIconName), lpTip); }

	virtual LRESULT OnTrayNotification(WPARAM uID, LPARAM lEvent);
};

#endif //_TRAYICON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\util.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//util.cpp

#include "stdafx.h"
#include <shlobj.h>
#include "util.h"
#include "resource.h"

///////////////////////////////////////////////////////////////////////////////
//Functions
///////////////////////////////////////////////////////////////////////////////
BOOL ParseToken(CString& sBuffer,CString& sToken,char delim)
{
   int index;
   if ((index = sBuffer.Find(delim)) != -1)
   {
      sToken = sBuffer.Left(index);
      sToken.TrimLeft(); sToken.TrimRight();
      sBuffer = sBuffer.Mid(index+1);
      sBuffer.TrimLeft(); sBuffer.TrimRight();
      return TRUE;
   }       
   else
   {
      sToken = sBuffer;       
      return FALSE;
   }
}

///////////////////////////////////////////////////////////////////////////////
//Example "data1","data2","data3",....
//Hardcoded for , delimiters
///////////////////////////////////////////////////////////////////////////////
BOOL ParseTokenQuoted(CString& sBuffer,CString& sToken)
{
   int index;
   if ((index = sBuffer.Find(_T("\","))) != -1)
   {
      sToken = sBuffer.Left(index);

      if ( (sToken.GetLength() > 0) && (sToken[0] == '\"') )
         sToken = sToken.Mid(1);     //strip leading "

      if (sBuffer.GetLength() < index+3) return TRUE;    //check if more data is avail
      sBuffer = sBuffer.Mid(index+3);                    //shift pass delim

      sToken.TrimLeft(); sToken.TrimRight();
      sBuffer.TrimLeft(); sBuffer.TrimRight();
      return TRUE;
   }       
	else
	{
		//We will return a valid answer with the quotes removed
		sToken = sBuffer;       
		if ( sToken.GetLength() > 1 )
		{
			if (sToken[0] == '\"') sToken = sToken.Mid(1);     //strip leading "
			if (sToken[sToken.GetLength()-1] == '\"') sToken = sToken.Left(sToken.GetLength()-1); //strip trailing "
		}
		return FALSE;
	}
}

///////////////////////////////////////////////////////////////////////////////
BOOL GetAgentRootPath(CString& sRootPath)
{
   BOOL bRet = FALSE;
   CString sPath;
   if (::GetModuleFileName(NULL,sPath.GetBuffer(_MAX_PATH),_MAX_PATH))
   {
      sPath.ReleaseBuffer();

      TCHAR szDrive[_MAX_DRIVE];
      TCHAR szDir[_MAX_DIR];
      TCHAR szFileName[_MAX_FNAME];
      TCHAR szExt[_MAX_EXT];
      _tsplitpath(sPath, szDrive, szDir, szFileName, szExt);

      _tmakepath(sRootPath.GetBuffer(_MAX_PATH),szDrive,szDir,_T(""),NULL);

      sRootPath.ReleaseBuffer();

      bRet = TRUE;
   }
   return bRet;
}

///////////////////////////////////////////////////////////////////////////////
void GetAppDataPath(CString& sFilePath,UINT uFileTypeID)
{
	//Get path to file name
	SHGetSpecialFolderPath(	(AfxGetMainWnd()) ? AfxGetMainWnd()->GetSafeHwnd() : NULL, 
							sFilePath.GetBuffer(MAX_PATH),
							CSIDL_LOCAL_APPDATA,
							false );

	sFilePath.ReleaseBuffer();
	
	// add 'Microsoft\Dialer'
	CString sAddlPath;
	sAddlPath.LoadString(IDN_REGISTRY_APPDATA_KEY);
	sFilePath = sFilePath + _T("\\") + sAddlPath;

	//Make sure the directory exists
	sFilePath += _T("\\");
	::CreateDirectory( sFilePath, NULL );

	//get filename for log
	DWORD dwSize = _MAX_PATH;
	GetUserName(sAddlPath.GetBuffer(dwSize),&dwSize);
	sAddlPath.ReleaseBuffer();
	CString sFileName;

    switch( uFileTypeID )
    {
    case IDN_REGISTRY_APPDATA_FILENAME_BUDDIES:
        sFileName.Format(_T("%s_buddies.dat"), sAddlPath);
        break;
    case IDN_REGISTRY_APPDATA_FILENAME_LOG:
        sFileName.Format(_T("%s_call_log.txt"), sAddlPath);
        break;
    }

	sFilePath += sFileName;
}

///////////////////////////////////////////////////////////////////////////////////
BOOL GetTempFile(CString& sTempFile)
{
   //get a temp file
   CString sTempPath;
   GetTempPath(_MAX_PATH,sTempPath.GetBuffer(_MAX_PATH));
   sTempPath.ReleaseBuffer();
   GetTempFileName(sTempPath,_T("tmp"),0,sTempFile.GetBuffer(_MAX_PATH));
   sTempFile.ReleaseBuffer();
   return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// Generic function for thread exit waiting
//
// Function will null out pThread pointer on exit
//
// nTime in MilliSeconds
//
void WaitForThreadExit(CWinThread*& pThread,int nTime)
{
   //Wait for thread to close
   if (pThread)
   {
      try
      {
         BOOL dwRet = WaitForSingleObject(pThread->m_hThread,nTime);
         if (dwRet == WAIT_TIMEOUT)
         {
            //It's not listening to us, so just kill it.
            ::TerminateThread(pThread->m_hThread,NULL);
         }

         delete pThread;
		 pThread  = NULL;
      }
      catch (...)
      {
         1;
      }
   }
}



///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//Registry Methods
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//If the registry key does not exist, it will create one
//If the name,value does not exits it will create one and set
// it to the default value szDefaultValue (REG_SZ).
void GetSZRegistryValue(LPCTSTR szRegPath,          //Path to key in registry       
                      LPCTSTR szName,               //name (name/value pair)           
                      LPTSTR szValue,               //value returned (name/value pair)
                      DWORD dwValueLen,             //length of szValue buffer     
                      LPCTSTR szDefaultValue,       //Default value if name,value pair does not exist
                      HKEY szResv)                  //Registry section (default HKEY_CURRENT_USER)
{
   HKEY hKey = NULL;
   DWORD dwDisp;
   if ( RegCreateKeyEx(szResv,szRegPath,
                        0,_T(""),REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&hKey,&dwDisp) == ERROR_SUCCESS)
   {
      DWORD dwSize = dwValueLen;
      DWORD dwType;
      if (RegQueryValueEx(hKey,szName,NULL,&dwType,(UCHAR*)szValue,&dwSize) != ERROR_SUCCESS)
      {
         //Open failure, try writing default to registry
         RegSetValueEx(hKey,szName,NULL,REG_SZ,(UCHAR*)szDefaultValue,_tcslen(szDefaultValue)*sizeof(TCHAR));
         _tcsncpy(szValue,szDefaultValue,dwValueLen-1);
      }

	  RegCloseKey( hKey );
   }
}

///////////////////////////////////////////////////////////////////////////////
//Get the value of a registry key
BOOL GetSZRegistryValueEx(LPCTSTR szRegPath,        //Path to key in registry       
                      LPCTSTR szName,               //name (name/value pair)           
                      LPTSTR szValue,               //value returned (name/value pair)
                      DWORD dwValueLen,             //length of szValue buffer     
                      HKEY szResv)                  //Registry section (default HKEY_CURRENT_USER)
{
	//empty the string
	if (dwValueLen>0) _tcscpy(szValue,_T(""));

	BOOL bRet = FALSE;
	HKEY hKey = NULL;
	DWORD dwDisp;
	if ( RegCreateKeyEx(szResv,szRegPath,
				0,_T(""),REG_OPTION_NON_VOLATILE,KEY_READ,NULL,&hKey,&dwDisp) == ERROR_SUCCESS)
	{
		DWORD dwSize = dwValueLen;
		DWORD dwType;
		if (RegQueryValueEx(hKey,szName,NULL,&dwType,(UCHAR*)szValue,&dwSize) == ERROR_SUCCESS)
		{
			bRet = TRUE;
		}
		RegCloseKey( hKey );
	}
   
	return bRet;
}

///////////////////////////////////////////////////////////////////////////////
//Get the value of a registry key
BOOL GetSZRegistryValueEx(LPCTSTR szRegPath,        //Path to key in registry       
                      LPCTSTR szName,               //name (name/value pair)           
                      DWORD& dwValue,               //value returned (name/value pair)
                      HKEY szResv)                  //Registry section (default HKEY_CURRENT_USER)
{
   BOOL bRet = FALSE;
   HKEY hKey = NULL;
   DWORD dwDisp;
   if ( RegCreateKeyEx(szResv,szRegPath,
                        0,_T(""),REG_OPTION_NON_VOLATILE,KEY_READ,NULL,&hKey,&dwDisp) == ERROR_SUCCESS)
   {
      DWORD dwType;
      DWORD dwSize = sizeof(DWORD);
      if (RegQueryValueEx(hKey,szName,NULL,&dwType,(UCHAR*)&dwValue,&dwSize) == ERROR_SUCCESS)
      {
         if (dwType == REG_DWORD)
            bRet = TRUE;
      }
	  RegCloseKey( hKey );
   }
   return bRet;
}

///////////////////////////////////////////////////////////////////////////////
//Check if the registry key exists
BOOL CheckSZRegistryValue(LPCTSTR szRegPath,        //Path to key in registry       
                      HKEY szResv)                 //Registry section (default HKEY_CURRENT_USER)
{
   HKEY hKey = NULL;
   BOOL bRet = ( RegOpenKeyEx(szResv,szRegPath,0,KEY_READ,&hKey) == ERROR_SUCCESS)?TRUE:FALSE;
   RegCloseKey( hKey );

   return bRet;
}

///////////////////////////////////////////////////////////////////////////////
//If the registry key does not exist, it will create one
//Sets name,value to registry
BOOL SetSZRegistryValue(LPCTSTR szRegPath,          //Path to key in registry       
                      LPCTSTR szName,               //name (name/value pair)           
                      LPCTSTR szValue,              //value (name/value pair)
                      HKEY szResv)                  //Registry section (default HKEY_CURRENT_USER)
{
	BOOL bRet = FALSE;
	HKEY hKey = NULL;
	DWORD dwDisp;
	if ( RegCreateKeyEx(szResv,szRegPath,
						0,_T(""),REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&hKey,&dwDisp) == ERROR_SUCCESS)
	{
		if (RegSetValueEx(hKey,szName,NULL,REG_SZ,(UCHAR*)szValue,_tcslen(szValue)*sizeof(TCHAR)) == ERROR_SUCCESS)
			bRet = TRUE;

		RegCloseKey( hKey );
	}
   
	return bRet;
}

///////////////////////////////////////////////////////////////////////////////
//If the registry key does not exist, it will create one
//Sets name,value to registry
BOOL SetSZRegistryValue(LPCTSTR szRegPath,          //Path to key in registry       
                      LPCTSTR szName,               //name (name/value pair)           
                      DWORD dwValue,                //value (name/value pair)
                      HKEY szResv)                  //Registry section (default HKEY_CURRENT_USER)
{
	BOOL bRet = FALSE;
	HKEY hKey = NULL;
	DWORD dwDisp;
	if ( RegCreateKeyEx(szResv,szRegPath,
				0,_T(""),REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&hKey,&dwDisp) == ERROR_SUCCESS)
	{
		if (RegSetValueEx(hKey,szName,NULL,REG_DWORD,(UCHAR*)&dwValue,sizeof(DWORD)) == ERROR_SUCCESS)
			bRet = TRUE;

		RegCloseKey( hKey );
	}
	return bRet;
}

/////////////////////////////////////////////////////////////////////////////
BOOL DeleteSZRegistryValue(LPCTSTR szRegPath,       //Path to key in registry       
                      LPCTSTR szName,               //name (name/value pair)           
                      HKEY szResv)                  //Registry section (default HKEY_CURRENT_USER)
{
	BOOL bRet = FALSE;
	HKEY hKey = NULL;
	DWORD dwDisp;
	if ( RegCreateKeyEx(szResv,szRegPath,
				0,_T(""),REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&hKey,&dwDisp) == ERROR_SUCCESS)
	{
		if (RegDeleteValue(hKey,szName) == ERROR_SUCCESS)
			bRet = TRUE;

		RegCloseKey( hKey );
	}
	return bRet;
}

/////////////////////////////////////////////////////////////////////////////
void DrawLine(CDC* pDC,int x1,int y1,int x2,int y2,COLORREF color)
{
	CPen pen,*oldpen;
	pen.CreatePen(PS_SOLID,1,color);
	oldpen = pDC->SelectObject(&pen);
	pDC->MoveTo(x1,y1);
	pDC->LineTo(x2,y2);
	pDC->SelectObject(oldpen);
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\util.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

//util.h

#ifndef _UTIL_H_
#define _UTIL_H_

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//Defines
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#define STARTTRY              try {
#define ENDTRY                } catch (...) { }

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//Prototypes
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
BOOL        ParseToken(CString& sBuffer,CString& sToken,char delim);
BOOL        ParseTokenQuoted(CString& sBuffer,CString& sToken);

void        GetSZRegistryValue(LPCTSTR szRegPath,         //Path to key in registry       
                        LPCTSTR szName,                   //name (name/value pair)           
                        LPTSTR szValue,                   //value returned (name/value pair)
                        DWORD dwValueLen,                 //length of szValue buffer     
                        LPCTSTR szDefaultValue,           //Default value if name,value pair does not exist
                        HKEY szResv=HKEY_CURRENT_USER);   //Registry section (default HKEY_CURRENT_USER)

BOOL        GetSZRegistryValueEx(LPCTSTR szRegPath,       //Path to key in registry       
                      LPCTSTR szName,                     //name (name/value pair)           
                      LPTSTR szValue,                     //value returned (name/value pair)
                      DWORD dwValueLen,                   //length of szValue buffer     
                      HKEY szResv);                       //Registry section (default HKEY_CURRENT_USER)

BOOL        GetSZRegistryValueEx(LPCTSTR szRegPath,       //Path to key in registry       
                      LPCTSTR szName,                     //name (name/value pair)           
                      DWORD& dwValue,                     //value returned (name/value pair)
                      HKEY szResv);                       //Registry section (default HKEY_CURRENT_USER)

BOOL        CheckSZRegistryValue(LPCTSTR szRegPath,       //Path to key in registry       
                        HKEY szResv=HKEY_CURRENT_USER);   //Registry section (default HKEY_CURRENT_USER)

BOOL        SetSZRegistryValue(LPCTSTR szRegPath,         //Path to key in registry       
                        LPCTSTR szName,                   //name (name/value pair)           
                        LPCTSTR szValue,                  //value (name/value pair)
                        HKEY szResv=HKEY_CURRENT_USER);   //Registry section (default HKEY_CURRENT_USER)

BOOL        SetSZRegistryValue(LPCTSTR szRegPath,         //Path to key in registry       
                        LPCTSTR szName,                   //name (name/value pair)           
                        DWORD dwValue,                    //value (name/value pair)
                        HKEY szResv=HKEY_CURRENT_USER);   //Registry section (default HKEY_CURRENT_USER)

BOOL        DeleteSZRegistryValue(LPCTSTR szRegPath,      //Path to key in registry       
                      LPCTSTR szName,                     //name (name/value pair)           
                      HKEY szResv=HKEY_CURRENT_USER);     //Registry section (default HKEY_CURRENT_USER)

BOOL        GetAgentRootPath(CString& sRootPath);
BOOL        GetTempFile(CString& sTempFile);

void        GetAppDataPath(CString& sFilePath,UINT uFileTypeID);

void        WaitForThreadExit(CWinThread*& pThread,int nTime);

void        DrawLine(CDC* pDC,int x1,int y1,int x2,int y2,COLORREF color);

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif //_UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\vcard.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

//
// VCARD.H
//

#ifndef _VCARD_H_
#define _VCARD_H_

#include "vobject.h"
#include "vcc.h"

typedef enum
{
   VCARDPHOTO_GIF,
   VCARDPHOTO_CGM,
   VCARDPHOTO_WMF,
   VCARDPHOTO_BMP,
   VCARDPHOTO_MET,
   VCARDPHOTO_PMB,
   VCARDPHOTO_DIB,
   VCARDPHOTO_PICT,
   VCARDPHOTO_TIFF,
   VCARDPHOTO_PS,
   VCARDPHOTO_PDF,
   VCARDPHOTO_JPEG,
   VCARDPHOTO_MPEG,
   VCARDPHOTO_MPEG2,
   VCARDPHOTO_AVI,
   VCARDPHOTO_QTIME
}
VCARD_PHOTOFORMAT;

typedef enum
{
   VCARDSOUND_WAVE,
   VCARDSOUND_PCM,
   VCARDSOUND_AIFF
}
VCARD_SOUNDFORMAT;

class CVCard : public CObject
{
protected:
   VObject* m_pVObject;

   // Functions from the DLL
   VObject* (*m_fcnParse_MIME_FromFileName)(char*);
   void (*m_fcnWriteVObjectToFile)(char*, VObject*);
   VObject* (*m_fcnAddPropSizedValue)(VObject*, const char*, const char*, unsigned int);

public:
   CVCard();
   bool Initialize();
   bool ImportFromFile(LPCTSTR szFile);
   bool ExportToFile(LPCTSTR szFile);
   bool AddPhoto(LPCTSTR szPhotoFile, VCARD_PHOTOFORMAT iPhotoFormat);
   bool AddSound(LPCTSTR szSoundFile, VCARD_SOUNDFORMAT iSoundFormat);
   bool AddFileProperty(LPCTSTR szProperty, LPCTSTR szFileName);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\vcc.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

#ifndef __VCC_H__
#define __VCC_H__ 1

#include "vobject.h"


#if defined(__CPLUSPLUS__) || defined(__cplusplus)
extern "C" {
#endif

typedef void (*MimeErrorHandler)(char *);

extern DLLEXPORT(void) registerMimeErrorHandler(MimeErrorHandler);

extern DLLEXPORT(VObject*) Parse_MIME(const char *input, unsigned long len);
extern DLLEXPORT(VObject*) Parse_MIME_FromFileName(char* fname);


/* NOTE regarding Parse_MIME_FromFile
The function above, Parse_MIME_FromFile, comes in two flavors,
neither of which is exported from the DLL. Each version takes
a CFile or FILE* as a parameter, neither of which can be
passed across a DLL interface (at least that is my experience).
If you are linking this code into your build directly then
you may find them a more convenient API that the other flavors
that take a file name. If you use them with the DLL LIB you
will get a link error.
*/


#if INCLUDEMFC
extern VObject* Parse_MIME_FromFile(CFile *file);
#else
extern VObject* Parse_MIME_FromFile(FILE *file);
#endif

#if defined(__CPLUSPLUS__) || defined(__cplusplus)
}
#endif

#endif /* __VCC_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\vcard.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

//
// VCARD.CPP
//

#include "stdafx.h"

#include <io.h>
#include <tchar.h>

#include "vcard.h"

LPCTSTR PhotoFormats[]=
{
   TEXT("GIF"),
   TEXT("CGM"),
   TEXT("WMF"),
   TEXT("BMP"),
   TEXT("MET"),
   TEXT("PMB"),
   TEXT("DIB"),
   TEXT("PICT"),
   TEXT("TIFF"),
   TEXT("PS"),
   TEXT("PDF"),
   TEXT("JPEG"),
   TEXT("MPEG"),
   TEXT("MPEG2"),
   TEXT("AVI"),
   TEXT("QTIME")
};


LPCTSTR SoundFormats[]=
{
   TEXT("WAVE"),
   TEXT("PCM"),
   TEXT("AIFF")
};


CVCard::CVCard()
{
   m_fcnParse_MIME_FromFileName= NULL;
   m_fcnWriteVObjectToFile= NULL;
   m_fcnAddPropSizedValue= NULL;
}

//
// Load the DLL
// Make sure to check the return value for this method.
// If it returns false no other method will do anything.
bool CVCard::Initialize()
{
   bool fSuccess= false;
   HINSTANCE hDll;

   // Dynamically load the library and the functions that we need.
   if ((hDll= LoadLibrary(TEXT("avversit.dll"))) != NULL)
   {
      m_fcnParse_MIME_FromFileName= 
         (VObject* (*)(char*))
         GetProcAddress(hDll, "Parse_MIME_FromFileName");
      m_fcnWriteVObjectToFile=      
         (void (*)(char*, VObject*))
         GetProcAddress(hDll, "writeVObjectToFile");
      m_fcnAddPropSizedValue=       
         (VObject* (*)(VObject*, const char*, const char*, unsigned int))
         GetProcAddress(hDll, "addPropSizedValue");

      if ((m_fcnParse_MIME_FromFileName != NULL) &&
          (m_fcnWriteVObjectToFile != NULL) &&
          (m_fcnAddPropSizedValue != NULL))
      {
         fSuccess= true;
      }
   }

   return fSuccess;
}

bool CVCard::ImportFromFile(LPCTSTR szFile)
{
   bool fSuccess= false;

   if (m_fcnParse_MIME_FromFileName != NULL)
   {
#ifdef UNICODE
      char *szAsciiFileName= new char[_tcslen(szFile) + 1];
      WideCharToMultiByte(CP_ACP, 0, szFile, _tcslen(szFile) + 1, 
         szAsciiFileName, _tcslen(szFile) + 1, NULL, NULL);
      m_pVObject= m_fcnParse_MIME_FromFileName((char*) szAsciiFileName);
      delete szAsciiFileName;
#else
      m_pVObject= m_fcnParse_MIME_FromFileName((char*) szFile);
#endif

      if (m_pVObject != NULL)
      {
         fSuccess= true;
      }
   }

   return fSuccess;
}

bool CVCard::ExportToFile(LPCTSTR szFile)
{
   bool fSuccess= false;

   if ((m_pVObject != NULL) &&
       (m_fcnWriteVObjectToFile != NULL))
   {
#ifdef UNICODE
      char *szAsciiFileName= new char[_tcslen(szFile) + 1];
      WideCharToMultiByte(CP_ACP, 0, szFile, _tcslen(szFile) + 1, 
         szAsciiFileName, _tcslen(szFile) + 1, NULL, NULL);
      m_fcnWriteVObjectToFile((char*) szAsciiFileName, m_pVObject);
      delete szAsciiFileName;
#else
      m_fcnWriteVObjectToFile((char*) szFile, m_pVObject);
#endif

      fSuccess= true;
   }

   return fSuccess;
}

bool CVCard::AddFileProperty(LPCTSTR szProperty, LPCTSTR szFileName)
{
   USES_CONVERSION;

   bool fSuccess= false;

   //
   // We should initialize local variable
   //

   FILE* fpPropFile = NULL;

   if ((m_pVObject != NULL) &&
       (m_fcnAddPropSizedValue != NULL) &&
       ((fpPropFile= _tfopen(szFileName, TEXT("rb"))) != NULL))
   {
      int nFileLen= filelength(fileno(fpPropFile));
      BYTE* pbData= new BYTE[nFileLen];
      int nBytesLeft= nFileLen;
      int nBytesRead;

      while (nBytesLeft > 0)
      {
         nBytesRead= fread(pbData, 1, nBytesLeft, fpPropFile);

         if (nBytesRead == 0)
         {
            break;
         }
         else
         {
            nBytesLeft -= nBytesRead;
         }
      }

      if (nBytesLeft == 0)
      {
         m_fcnAddPropSizedValue(m_pVObject, T2CA(szProperty), (LPCSTR) pbData, nFileLen);

         fSuccess= true;
      }

      //
      // We deallocate here the pbData
      //
      if( pbData )
        delete pbData;
   }

   if (fpPropFile != NULL)
   {
      fclose(fpPropFile);
   }

   return fSuccess;
}

bool CVCard::AddPhoto(LPCTSTR szPhotoFile, VCARD_PHOTOFORMAT iPhotoFormat)
{
   CString sProperty;

   sProperty= TEXT("PHOTO;ENCODING=BASE64;TYPE=");
   sProperty += PhotoFormats[iPhotoFormat];

   return AddFileProperty(sProperty, szPhotoFile);
}

bool CVCard::AddSound(LPCTSTR szSoundFile, VCARD_SOUNDFORMAT iSoundFormat)
{
   CString sProperty;

   sProperty= TEXT("SOUND;ENCODING=BASE64;TYPE=");
   sProperty += SoundFormats[iSoundFormat];

   return AddFileProperty(sProperty, szSoundFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\vertbar.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// vertbar.cpp : implementation file
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "vertbar.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CVerticalToolBar
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

CVerticalToolBar::CVerticalToolBar()
{
   m_hwndToolBar = NULL;
}

CVerticalToolBar::CVerticalToolBar(UINT uBitmapID,UINT uButtonHeight,UINT uMaxButtons)
{
   m_uBitmapId = uBitmapID;
   m_uButtonHeight = uButtonHeight;
   m_uMaxButtons = uMaxButtons;
   m_uCurrentButton = 0;

   m_hwndToolBar = NULL;
}

void CVerticalToolBar::Init( UINT uBitmapID, UINT uButtonHeight, UINT uMaxButtons )
{
   m_uBitmapId = uBitmapID;
   m_uButtonHeight = uButtonHeight;
   m_uMaxButtons = uMaxButtons;
   m_uCurrentButton = 0;
}

CVerticalToolBar::~CVerticalToolBar()
{
}


BEGIN_MESSAGE_MAP(CVerticalToolBar, CWnd)
    //{{AFX_MSG_MAP(CVerticalToolBar)
    ON_WM_CREATE()
    ON_WM_PAINT()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CVerticalToolBar message handlers

/////////////////////////////////////////////////////////////////////////////
int CVerticalToolBar::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
    if (CWnd::OnCreate(lpCreateStruct) == -1)
        return -1;
    
    return 0;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CVerticalToolBar::CreateToolBar(UINT nID,UINT uImage)
{
   BOOL bRet = FALSE;

   if (m_hwndToolBar)
   {
      ::DestroyWindow(m_hwndToolBar);
      m_hwndToolBar = NULL;
   }

    TBBUTTON tbb;
    tbb.iBitmap = uImage;
    tbb.idCommand = nID;
    tbb.fsState = TBSTATE_ENABLED;
    tbb.fsStyle = TBSTYLE_BUTTON;
    tbb.dwData = 0;
    tbb.iString = 0;

    // Create the toolbar
    DWORD ws = WS_CHILD | TBSTYLE_TOOLTIPS | TBSTYLE_FLAT | TBSTYLE_WRAPABLE | TBSTYLE_LIST | CCS_NODIVIDER;
   m_hwndToolBar = CreateToolbarEx(m_hWnd,                      // parent window
                                    ws,                                         // toolbar style
                                    1,                                         // ID for toolbar
                                    1,                                         // Number of bitmaps on toolbar
                                    AfxGetResourceHandle(),                // Resource instance that has the bitmap
                                    m_uBitmapId,                             // ID for bitmap
                                    &tbb,                                        // Button information
                                    1,                                       // Number of buttons to add to toolbar
                                    16, 15, 0, 0,                             // Width and height of buttons/bitmaps
                                    sizeof(TBBUTTON) );                      // size of TBBUTTON structure

   if (m_hwndToolBar)
   {
      CRect rect;
      GetClientRect(rect);

      ::ShowWindow(m_hwndToolBar,SW_SHOW);

      bRet = TRUE;
   }
   return bRet;
}

/////////////////////////////////////////////////////////////////////////////
void CVerticalToolBar::AddButton(UINT nID,LPCTSTR szText,UINT uImage) 
{
   CRect rect;
   GetClientRect(rect);

   if (m_uCurrentButton == 0)
   {
      //create new toolbar and add the button
       //
       // We should verify the return value
       //
      if( CreateToolBar(nID,uImage) )
      {
        SetButtonText(szText);

        ::SendMessage(m_hwndToolBar,TB_SETBUTTONSIZE, 0, MAKELPARAM(rect.Width(),m_uButtonHeight) );
        ::SetWindowPos(m_hwndToolBar,NULL,0,0,rect.Width(),rect.Height(),SWP_NOACTIVATE|SWP_NOZORDER);

        m_uCurrentButton++;
      }
   }
   else if ( (m_uCurrentButton < m_uMaxButtons) && (::IsWindow(m_hwndToolBar)) )
   {
      //set the text
          TBBUTTON tbb;
        tbb.iBitmap = uImage;
        tbb.idCommand = nID;
        tbb.fsState = TBSTATE_ENABLED;
        tbb.fsStyle = TBSTYLE_BUTTON;
        tbb.dwData = 0;
        tbb.iString = m_uCurrentButton;
      ::SendMessage(m_hwndToolBar,TB_ADDBUTTONS, (WPARAM)1, (LPARAM)&tbb);

      //set the rows again
      CRect rowrect(0,0,rect.right - rect.left,m_uMaxButtons*m_uButtonHeight);
      ::SendMessage(m_hwndToolBar,TB_SETROWS , MAKEWPARAM(m_uMaxButtons+1,TRUE),(LPARAM)&rowrect);

      SetButtonText(szText);

     ::SendMessage(m_hwndToolBar,TB_SETBUTTONSIZE, 0, MAKELPARAM(rect.Width(),m_uButtonHeight) );
      ::SetWindowPos(m_hwndToolBar,NULL,0,0,rect.Width(),rect.Height(),SWP_NOACTIVATE|SWP_NOZORDER);

     m_uCurrentButton++;
   }
}

/////////////////////////////////////////////////////////////////////////////
void CVerticalToolBar::OnPaint() 
{
    CPaintDC dc(this); // device context for painting

   CRect rect;
   GetClientRect(rect);
   dc.FillSolidRect(rect,GetSysColor(COLOR_3DFACE));
   // Do not call CWnd::OnPaint() for painting messages
}

/////////////////////////////////////////////////////////////////////////////
void CVerticalToolBar::SetButtonText(LPCTSTR szText) 
{
   // add new string to toolbar list
    CString strTemp = szText;
    strTemp += '\0';
   ::SendMessage(m_hwndToolBar,TB_ADDSTRING, 0, (LPARAM)(LPCTSTR)strTemp);
}

/////////////////////////////////////////////////////////////////////////////
void CVerticalToolBar::RemoveAll() 
{
   if (m_hwndToolBar)
   {
      ::DestroyWindow(m_hwndToolBar);
      m_hwndToolBar = NULL;
   }
   
   Invalidate();

   m_uCurrentButton = 0;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CVerticalToolBar::OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo) 
{
   BOOL bRet = FALSE;

   if (nCode == CN_COMMAND)
   {
      CWnd* pParent = GetParent();    
      if ( pParent ) 
         bRet = pParent->OnCmdMsg(nID,nCode,pExtra,pHandlerInfo);
   }
   
   if ( !bRet ) return CWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
void CVerticalToolBar::_SetButton(HWND hwnd,int nIndex, TBBUTTON* pButton)
{
    // get original button state
    TBBUTTON button;
   ::SendMessage(hwnd,TB_GETBUTTON, nIndex, (LPARAM)&button);

    // prepare for old/new button comparsion
    button.bReserved[0] = 0;
    button.bReserved[1] = 0;
    pButton->fsState ^= TBSTATE_ENABLED;
    pButton->bReserved[0] = 0;
    pButton->bReserved[1] = 0;

    // nothing to do if they are the same
    if (memcmp(pButton, &button, sizeof(TBBUTTON)) != 0)
    {
        // don't redraw everything while setting the button
        //DWORD dwStyle = GetStyle();
        //ModifyStyle(WS_VISIBLE, 0);

      ::SendMessage(hwnd,TB_DELETEBUTTON, nIndex, 0);
      ::SendMessage(hwnd,TB_INSERTBUTTON, nIndex, (LPARAM)pButton);

      //ModifyStyle(0, dwStyle & WS_VISIBLE);

       // invalidate just the button
        CRect rect;
      if (::SendMessage(hwnd,TB_GETITEMRECT, nIndex, (LPARAM)&rect))
      {
            InvalidateRect(rect, TRUE);    // erase background
      }

      //
      // we should deallocate the GetDC result
      //

      HDC hDC = ::GetDC( GetSafeHwnd() );

      if( hDC )
      {
        ::SendMessage(hwnd,WM_PAINT, (WPARAM)hDC, (LPARAM)0);
        ::ReleaseDC( hwnd, hDC );
      }
    }
}

/////////////////////////////////////////////////////////////////////////////
void CVerticalToolBar::_GetButton(HWND hwnd,int nIndex, TBBUTTON* pButton)
{
   ::SendMessage(hwnd,TB_GETBUTTON, nIndex, (LPARAM)pButton);
    pButton->fsState ^= TBSTATE_ENABLED;
}

/*++
SetButtonEnabled
was added for USBPhone. If the phone doesn't support speakerphone
we should disables the 'Take Call' button
--*/
void CVerticalToolBar::SetButtonEnabled(UINT nID, BOOL bEnabled)
{
    ::SendMessage( m_hwndToolBar, TB_ENABLEBUTTON, nID, MAKELONG(bEnabled, 0));
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/*
//

// BuildStrList Function

// Creates a list of null-terminated strings from a passed-in

// array of strings. See the documentation about TB_ADDSTRING

// for specific information about this format.

//

// Accepts:

// LPTSTR *: Address of the array of strings.

//

// Returns:

// LPTSTR to the newly created list of button text strings.

//

/////

LPTSTR WINAPI BuildStrList(LPTSTR * ppszStrArray, INT iStrCount)

{

LPTSTR pScan,

pszStrList;

int i;

pScan = pszStrList = malloc((size_t)37 * sizeof(char));

for (i=0;i<iStrCount;i++){

strcpy(pScan,ppszStrArray[i]);

pScan += strlen(pScan)+1;

}

*pScan = '\0';

return(pszStrList);

}
*/

//To modify a button's id or image
      /*
       TBBUTTON button;
       _GetButton(m_pHwndList[m_uCurrentButton],nIndex,&button);
      button.iBitmap = uImage;
      button.idCommand = nID;
      button.iString = 1; //which string in the list of strings
       _SetButton(m_pHwndList[m_uCurrentButton],nIndex, &button);
      */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\vertbar.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_VERTBAR_H__6E51219A_2567_11D1_B4F8_00C04FC98AD3__INCLUDED_)
#define AFX_VERTBAR_H__6E51219A_2567_11D1_B4F8_00C04FC98AD3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// vertbar.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CVerticalToolBar window

class CVerticalToolBar : public CWnd
{
// Construction
public:
   CVerticalToolBar();
	CVerticalToolBar(UINT uBitmapID,UINT uButtonHeight,UINT uMaxButtons);

// Attributes
public:
protected:
   UINT        m_uBitmapId;
   UINT        m_uButtonHeight;
   UINT        m_uMaxButtons;
   UINT        m_uCurrentButton;
   HWND        m_hwndToolBar;

// Operations
public:
   void        Init( UINT uBitmapID, UINT uButtonHeight, UINT uMaxButtons );
   void        RemoveAll();
   void        AddButton(UINT nID,LPCTSTR szText,UINT uImage);
   void        SetButtonEnabled(UINT nID, BOOL bEnabled);

protected:
   BOOL        CreateToolBar(UINT nID,UINT uImage);
   void        _GetButton(HWND hwnd,int nIndex, TBBUTTON* pButton);
   void        _SetButton(HWND hwnd,int nIndex, TBBUTTON* pButton);
   void        SetButtonText(LPCTSTR szText);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CVerticalToolBar)
	public:
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CVerticalToolBar();

	// Generated message map functions
protected:
	//{{AFX_MSG(CVerticalToolBar)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_VERTBAR_H__6E51219A_2567_11D1_B4F8_00C04FC98AD3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\videownd.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// videownd.h : header file
/////////////////////////////////////////////////////////////////////////////
#if !defined(AFX_VIDEOWND_H__9E3BDB2F_5215_11D1_B6F6_0800170982BA__INCLUDED_)
#define AFX_VIDEOWND_H__9E3BDB2F_5215_11D1_B6F6_0800170982BA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "palhook.h"
#include "dib.h"
#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Class CVideoFloatingDialog
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class CCallWnd;

class CVideoFloatingDialog : public CDialog
{
// Construction
public:
	CVideoFloatingDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CVideoFloatingDialog)
	enum { IDD = IDD_VIDEO_FLOATING_DIALOG };
	CStatic	m_wndVideo;
	//}}AFX_DATA

//Attributes
   HWND                       m_hwndToolBar1;
   BOOL                       m_bAlwaysOnTop;
   CCallWnd*                  m_pPeerCallControlWnd;

   CSize                      m_sizeVideoOffsetTop;
   CSize                      m_sizeVideoOffsetBottom;
   CSize                      m_sizeVideoOrig;

   CSize                      m_sizeOldDrag;
   CRect                      m_rcOldDragRect;
   CPoint                     m_ptMouse;
   BOOL                       m_bWindowMoving;
   UINT                       m_nWindowState;

 	CPalMsgHandler             m_palMsgHandler;	// handles palette messages
   CDib                       m_dibVideoImage;

//Operations
public:
   void              Init(CCallWnd* pPeerWnd);
   HWND              GetCurrentVideoWindow()             { return m_wndVideo.GetSafeHwnd(); };
   void              SetAudioOnly(bool bAudioOnly);

protected:
   BOOL              CreateToolBar();
   void              SetButtonText(LPCTSTR szText);

   void              DoLButtonDown();
   void              SetVideoWindowSize();
   void              GetVideoWindowSize(int nWindowState,CSize& sizeWindow,CSize& sizeVideo);
   int				 GetWindowStateFromPoint( POINT point );

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CVideoFloatingDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CVideoFloatingDialog)
	virtual BOOL OnInitDialog();
	afx_msg void OnClose();
   afx_msg void OnAlwaysOnTop();
   afx_msg LRESULT OnExitSizeMove(LPARAM,WPARAM);
   afx_msg UINT OnNcHitTest(CPoint point);
   afx_msg void OnNcLButtonDown( UINT, CPoint );
   afx_msg void OnNcLButtonDblClk( UINT nHitTest, CPoint point );
   afx_msg void OnNcLButtonUp( UINT, CPoint );
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnPaint();
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
   afx_msg void OnSavePicture();
   afx_msg BOOL OnNcActivate( BOOL );
	//}}AFX_MSG
   afx_msg BOOL OnTabToolTip( UINT id, NMHDR * pTTTStruct, LRESULT * pResult );
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_VIDEOWND_H__9E3BDB2F_5215_11D1_B6F6_0800170982BA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\videownd.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// videownd.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "avdialer.h"
#include "callctrlwnd.h"
#include "PreviewWnd.h"
#include "avtrace.h"
#include "util.h"
#include "videownd.h"
#include "bmputil.h"
#include "mainfrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Defines
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#define SIZING_WINDOWSTATE_MIN                        1
#define SIZING_WINDOWSTATE_MAX                        6

#define VIDEODLGWND_TOOLBAR_HEIGHT                    26
#define VIDEODLGWND_TOOLBAR_BUTTONSIZE_WIDTH          30 

#define VIDEODLGWND_TOOLBAR_IMAGE_ALWAYSONTOP_OFF     0
#define VIDEODLGWND_TOOLBAR_IMAGE_TAKEPICTURE         1    
#define VIDEODLGWND_TOOLBAR_IMAGE_OPTIONS             2    
#define VIDEODLGWND_TOOLBAR_IMAGE_ALWAYSONTOP_ON      3

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CVideoFloatingDialog dialog
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
CVideoFloatingDialog::CVideoFloatingDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CVideoFloatingDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CVideoFloatingDialog)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
   m_hwndToolBar1 = NULL;
   m_bAlwaysOnTop = FALSE;
   
   m_pPeerCallControlWnd = NULL;
   m_dibVideoImage.Load( AfxGetInstanceHandle(),MAKEINTRESOURCE(IDB_VIDEO_SCREEN2) );
   
   m_bWindowMoving = FALSE;
   m_nWindowState = 2;
}


void CVideoFloatingDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CVideoFloatingDialog)
	DDX_Control(pDX, IDC_VIDEOFLOATINGDLG_STATIC_VIDEO, m_wndVideo);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CVideoFloatingDialog, CDialog)
	//{{AFX_MSG_MAP(CVideoFloatingDialog)
	ON_WM_CLOSE()
	ON_COMMAND(ID_BUTTON_VIDEO_ALWAYSONTOP_OFF,OnAlwaysOnTop)
	ON_COMMAND(ID_BUTTON_VIDEO_SAVEPICTURE,OnSavePicture)
   ON_MESSAGE(WM_EXITSIZEMOVE,OnExitSizeMove)
   ON_WM_NCHITTEST()
   ON_WM_NCLBUTTONDOWN()
   ON_WM_NCLBUTTONDBLCLK()
	ON_WM_NCLBUTTONUP()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_PAINT()
	ON_WM_SHOWWINDOW()
   ON_WM_NCACTIVATE()
	//}}AFX_MSG_MAP
  	ON_NOTIFY_EX_RANGE(TTN_NEEDTEXTW, 0, 0xFFFF, OnTabToolTip)
	ON_NOTIFY_EX_RANGE(TTN_NEEDTEXTA, 0, 0xFFFF, OnTabToolTip)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
BOOL CVideoFloatingDialog::OnInitDialog() 
{
   CDialog::OnInitDialog();

   //Init member var's
   m_hwndToolBar1 = NULL;
   m_bWindowMoving = FALSE;
   m_nWindowState = 2;

   if (CreateToolBar())
   {
      CRect rect;
      GetWindowRect(rect);
      //Arrange the windows
      ::GetWindowRect(m_hwndToolBar1,&rect);
      ::SetWindowPos(m_hwndToolBar1,NULL,0,0,rect.Width(),VIDEODLGWND_TOOLBAR_HEIGHT,SWP_NOACTIVATE|SWP_NOZORDER);
   }

   CRect rcVideo,rcWindow;
   GetWindowRect(rcWindow);

   m_wndVideo.GetWindowRect(rcVideo);

   m_sizeVideoOrig.cx = rcVideo.Width();
   m_sizeVideoOrig.cy = rcVideo.Height();

   m_sizeVideoOffsetTop.cx = rcVideo.left-rcWindow.left;
   m_sizeVideoOffsetTop.cy = rcVideo.top-rcWindow.top;

   m_sizeVideoOffsetBottom.cx = rcWindow.right - rcVideo.right;
   m_sizeVideoOffsetBottom.cy = rcWindow.bottom - rcVideo.bottom;

   //set the media window
   //ASSERT(m_pPeerCallControlWnd);
   //m_pPeerCallControlWnd->SetMediaWindow();

   //Do Palette realization on 256 color bitmap.  
   m_palMsgHandler.Install(&m_wndVideo, m_dibVideoImage.GetPalette());

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////////////
void CVideoFloatingDialog::OnPaint() 
{
	CPaintDC dc(this); // device context for painting
	
   //paint video window
   CRect rcVideo;
   m_wndVideo.GetWindowRect(rcVideo);
   ScreenToClient(rcVideo);
   m_dibVideoImage.Draw(dc,&rcVideo);
}

/////////////////////////////////////////////////////////////////////////////
void CVideoFloatingDialog::OnClose() 
{
   //tell peer window to close us 

   //Unhook msg handler
   if ( m_palMsgHandler.IsHooked() ) 
      m_palMsgHandler.HookWindow(NULL);

   m_pPeerCallControlWnd->OnCloseFloatingVideo();
   DestroyWindow();
}

/////////////////////////////////////////////////////////////////////////////
void CVideoFloatingDialog::Init(CCallWnd* pPeerWnd)
{
   m_pPeerCallControlWnd = pPeerWnd;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Toolbar support
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
BOOL CVideoFloatingDialog::CreateToolBar()
{
	TBBUTTON tbb[2];
   if ( !m_hwndToolBar1 )
   {
	   tbb[0].iBitmap = VIDEODLGWND_TOOLBAR_IMAGE_ALWAYSONTOP_OFF;
	   tbb[0].idCommand = ID_BUTTON_VIDEO_ALWAYSONTOP_OFF;
	   tbb[0].fsState = TBSTATE_ENABLED;
	   tbb[0].fsStyle = TBSTYLE_BUTTON;
	   tbb[0].dwData = 0;
	   tbb[0].iString = 0;
/*
       tbb[1].iBitmap = VIDEODLGWND_TOOLBAR_IMAGE_TAKEPICTURE;
	   tbb[1].idCommand = ID_BUTTON_VIDEO_SAVEPICTURE;
	   tbb[1].fsState = TBSTATE_ENABLED;
	   tbb[1].fsStyle = TBSTYLE_BUTTON;
	   tbb[1].dwData = 0;
	   tbb[1].iString = 0;
*/
	   // Create the toolbar
	   DWORD ws = CCS_NORESIZE | CCS_NOPARENTALIGN | WS_CHILD | TBSTYLE_TOOLTIPS | TBSTYLE_FLAT | CCS_NODIVIDER |WS_VISIBLE;
      m_hwndToolBar1 = CreateToolbarEx(GetSafeHwnd(),						// parent window
									   ws,								    // toolbar style
									   1,					                // ID for toolbar
									   4,					                // Number of bitmaps on toolbar
									   AfxGetResourceHandle(),				// Resource instance that has the bitmap
									   IDR_TOOLBAR_VIDEO, 					// ID for bitmap
									   tbb,							        // Button information
									   1,                      				// Number of buttons to add to toolbar
									   16, 15, 0, 0,					    // Width and height of buttons/bitmaps
									   sizeof(TBBUTTON) );					// size of TBBUTTON structure
   }
  
 
   if (m_hwndToolBar1)
   {
      CRect rect;
      GetWindowRect(rect);
      //set the button width
//      DWORD dwWidthHeight = ::SendMessage(m_hwndToolBar1,TB_GETBUTTONSIZE, 0, 0);
//      ::SendMessage(m_hwndToolBar1,TB_SETBUTTONSIZE, 0, MAKELPARAM(VIDEODLGWND_TOOLBAR_BUTTONSIZE_WIDTH,HIWORD(dwWidthHeight)) );
   }
   return (BOOL) (m_hwndToolBar1 != NULL);
}

/////////////////////////////////////////////////////////////////////////////
void CVideoFloatingDialog::OnAlwaysOnTop()
{
   m_bAlwaysOnTop = !m_bAlwaysOnTop;
   SetWindowPos((m_bAlwaysOnTop)?&CWnd::wndTopMost:&CWnd::wndNoTopMost,0,0,0,0,SWP_NOSIZE|SWP_NOMOVE);
   ::SendMessage( m_hwndToolBar1, TB_CHANGEBITMAP, ID_BUTTON_VIDEO_ALWAYSONTOP_OFF,
                  (m_bAlwaysOnTop) ? VIDEODLGWND_TOOLBAR_IMAGE_ALWAYSONTOP_ON : VIDEODLGWND_TOOLBAR_IMAGE_ALWAYSONTOP_OFF );
}

/////////////////////////////////////////////////////////////////////////////
BOOL CVideoFloatingDialog::OnNcActivate( BOOL bActive )
{
   ASSERT(m_pPeerCallControlWnd);
   if ((m_pPeerCallControlWnd->GetStyle() & WS_VISIBLE))
   {
      m_pPeerCallControlWnd->SendMessage(WM_NCACTIVATE,bActive);
   }

   return CDialog::OnNcActivate(bActive);
}

/////////////////////////////////////////////////////////////////////////////
void CVideoFloatingDialog::SetAudioOnly(bool bAudioOnly)
{
   if (bAudioOnly)
   {
      m_dibVideoImage.DeleteObject();
      m_dibVideoImage.Load(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDB_VIDEO_AUDIO_ONLY2));
   }
   else
   {
      //put the standard green screen back
      m_dibVideoImage.DeleteObject();
      m_dibVideoImage.Load(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDB_VIDEO_SCREEN2));
   }

   //repaint
   CRect rcVideo;
   m_wndVideo.GetWindowRect(rcVideo);
   ScreenToClient(rcVideo);
   InvalidateRect(rcVideo);
}

/////////////////////////////////////////////////////////////////////////////
LRESULT CVideoFloatingDialog::OnExitSizeMove(LPARAM lParam,WPARAM wParam)
{
   //If you want drop behavior
   /* 
   ASSERT(m_pPeerCallControlWnd);

   //get mouse position and if it's in the peer window then destroy and let
   //peer window have control
   CPoint point;
   ::GetCursorPos(&point);

   CRect rcPeer;
   m_pPeerCallControlWnd->GetWindowRect(rcPeer);
   
   //check if mouse is in peer window space
   if (rcPeer.PtInRect(point))
   {
      //tell peer window to close us 
      m_pPeerCallControlWnd->CloseFloatingVideo();
   }
   */
   return 0;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Sizing code
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
UINT CVideoFloatingDialog::OnNcHitTest(CPoint point) 
{
   //stop sizing other than bottomright corner

   LRESULT  lHitTest;
	// Let DefWindowProc() tell us where the mouse is
	lHitTest = CWnd::OnNcHitTest(point);

   if ( (lHitTest == HTTOP) ||
        (lHitTest == HTBOTTOM) ||
        (lHitTest == HTLEFT) ||
        (lHitTest == HTRIGHT) ||
        (lHitTest == HTBOTTOMLEFT) ||
        (lHitTest == HTTOPLEFT) ||
        (lHitTest == HTTOPRIGHT) )
      return HTCLIENT;

   return (UINT) lHitTest;
}

/////////////////////////////////////////////////////////////////////////////
void CVideoFloatingDialog::OnNcLButtonDown(UINT nHitTest, CPoint point)
{
   switch (nHitTest)
   {
      case HTBOTTOMRIGHT:
      {
         m_ptMouse.x = point.x;
         m_ptMouse.y = point.y;

         DoLButtonDown();
         break;
      }
   }
   CDialog::OnNcLButtonDown(nHitTest,point);
}

/////////////////////////////////////////////////////////////////////////////
void CVideoFloatingDialog::DoLButtonDown()
{
   CRect rect;
   GetWindowRect(rect);

	CWnd* pWnd = CWnd::GetDesktopWindow();
	CDC* pDC = pWnd->GetDCEx(NULL, DCX_WINDOW|DCX_CACHE|DCX_LOCKWINDOWUPDATE);
   if (pDC)
   {
      CRect rcOld(0,0,0,0);
      m_sizeOldDrag = CSize(3,3);
      pDC->DrawDragRect(&rect,m_sizeOldDrag,&rcOld,m_sizeOldDrag);
      m_rcOldDragRect = rect;

      SetCapture();

      m_bWindowMoving = TRUE;
      pWnd->ReleaseDC(pDC);
   }
}

/////////////////////////////////////////////////////////////////////////////
void CVideoFloatingDialog::OnNcLButtonDblClk(UINT nHitTest, CPoint point )
{
   //Close the window if left dbl click in caption
   if (nHitTest == HTCAPTION)
   {
      PostMessage(WM_CLOSE);
   }

   CDialog::OnNcLButtonDblClk(nHitTest,point);
}

/////////////////////////////////////////////////////////////////////////////
void CVideoFloatingDialog::OnNcLButtonUp( UINT nHitTest, CPoint point )
{
   if (m_bWindowMoving)
   {
      m_bWindowMoving = FALSE;  
      ReleaseCapture();
      CWnd* pWnd = CWnd::GetDesktopWindow();
   	CDC* pDC = pWnd->GetDCEx(NULL, DCX_WINDOW|DCX_CACHE|DCX_LOCKWINDOWUPDATE);

      if (pDC)
      {
         //clear out the drag rect
         CRect rcNewDrawRect(0,0,0,0);
         pDC->DrawDragRect(&rcNewDrawRect,CSize(0,0),&m_rcOldDragRect,m_sizeOldDrag);
         pWnd->ReleaseDC(pDC);
      }
   }
   CDialog::OnNcLButtonUp(nHitTest,point);
}

void CVideoFloatingDialog::OnLButtonUp(UINT nFlags, CPoint point) 
{
	if (m_bWindowMoving)
	{
		m_bWindowMoving = FALSE;  
		ReleaseCapture();

		CWnd* pWnd = CWnd::GetDesktopWindow();
		CDC* pDC = pWnd->GetDCEx(NULL, DCX_WINDOW|DCX_CACHE|DCX_LOCKWINDOWUPDATE);
		if (pDC)
		{
			//clear out the drag rect
			CRect rcNewDrawRect(0,0,0,0);
			pDC->DrawDragRect(&rcNewDrawRect,CSize(0,0),&m_rcOldDragRect,m_sizeOldDrag);
			pWnd->ReleaseDC(pDC);
		}

		int nState = GetWindowStateFromPoint( point );
		if ( nState != -1 )
		{
			//get new window state
			m_nWindowState = nState;
			SetVideoWindowSize();
		}
	}
	
	CDialog::OnLButtonUp(nFlags, point);
}

/////////////////////////////////////////////////////////////////////////////
void CVideoFloatingDialog::SetVideoWindowSize()
{
   if ( (m_nWindowState >= SIZING_WINDOWSTATE_MIN) && (m_nWindowState <= SIZING_WINDOWSTATE_MAX) )
   {
      CSize sizeWindow,sizeVideo;
      GetVideoWindowSize(m_nWindowState,sizeWindow,sizeVideo);

      m_wndVideo.SetWindowPos(NULL,0,0,sizeVideo.cx,sizeVideo.cy,SWP_SHOWWINDOW|SWP_NOMOVE|SWP_NOZORDER);
      SetWindowPos(NULL,0,0,sizeWindow.cx,sizeWindow.cy,SWP_SHOWWINDOW|SWP_NOMOVE|SWP_NOZORDER);
      
      //set the media window
      ASSERT(m_pPeerCallControlWnd);
      m_pPeerCallControlWnd->SetMediaWindow();

      CRect rcVideo;
      m_wndVideo.GetWindowRect(rcVideo);
      ScreenToClient(rcVideo);
      InvalidateRect(rcVideo);
   }
}

/////////////////////////////////////////////////////////////////////////////
void CVideoFloatingDialog::GetVideoWindowSize(int nWindowState,CSize& sizeWindow,CSize& sizeVideo)
{
   double fMult = 0.5 * nWindowState;

   sizeWindow.cx = (long) (m_sizeVideoOffsetTop.cx +  m_sizeVideoOrig.cx * fMult + m_sizeVideoOffsetBottom.cx);
   sizeWindow.cy = (long) (m_sizeVideoOffsetTop.cy +  m_sizeVideoOrig.cy * fMult + m_sizeVideoOffsetBottom.cy);

   sizeVideo.cx = (long) (m_sizeVideoOrig.cx * fMult);
   sizeVideo.cy = (long) (m_sizeVideoOrig.cy * fMult);
}

/////////////////////////////////////////////////////////////////////////////
void CVideoFloatingDialog::OnMouseMove(UINT nFlags, CPoint point) 
{
	// Adding own handling method
	if ( m_bWindowMoving )
	{
		int nState = GetWindowStateFromPoint( point );
		if ( nState != -1 )
		{
			CRect rcWindow;
			GetWindowRect(rcWindow);

			// Calc new drag rect
			CSize sizeWindow, sizeVideo;
			GetVideoWindowSize( nState, sizeWindow, sizeVideo );
			rcWindow.right = rcWindow.left + sizeWindow.cx;
			rcWindow.bottom = rcWindow.top + sizeWindow.cy;

			// Paint new drag rect
			CWnd* pWnd = CWnd::GetDesktopWindow();
			CDC* pDC = pWnd->GetDCEx( NULL, DCX_WINDOW | DCX_CACHE | DCX_LOCKWINDOWUPDATE );
			if ( pDC )
			{
				CSize sizeNewSize = CSize( 3, 3 );
				pDC->DrawDragRect( &rcWindow, sizeNewSize, &m_rcOldDragRect, m_sizeOldDrag );

				m_rcOldDragRect = rcWindow;
				m_sizeOldDrag = sizeNewSize; 

				pWnd->ReleaseDC(pDC);
			}
		}
	}

	CDialog::OnMouseMove( nFlags, point );
}

/////////////////////////////////////////////////////////////////////////////
void CVideoFloatingDialog::OnShowWindow(BOOL bShow, UINT nStatus) 
{
   // Ignore size requests when parent is minimizing
   if ( nStatus == SW_PARENTCLOSING ) return;

	CDialog::OnShowWindow(bShow, nStatus);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// ToolTips
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
BOOL CVideoFloatingDialog::OnTabToolTip( UINT id, NMHDR * pNMHDR, LRESULT * pResult )
{
	// need to handle both ANSI and UNICODE versions of the message
	TOOLTIPTEXTA* pTTTA = (TOOLTIPTEXTA*)pNMHDR;
	TOOLTIPTEXTW* pTTTW = (TOOLTIPTEXTW*)pNMHDR;
	CString strTipText;
	SIZE_T nID = pNMHDR->idFrom;
	if (pNMHDR->code == TTN_NEEDTEXTA && (pTTTA->uFlags & TTF_IDISHWND) ||
		pNMHDR->code == TTN_NEEDTEXTW && (pTTTW->uFlags & TTF_IDISHWND))
	{
		// idFrom is actually the HWND of the tool
      nID = ::GetDlgCtrlID((HWND)nID);
	}

	if (nID != 0) // will be zero on a separator
	{
      CString sToken,sTip;
      sTip.LoadString((UINT32) nID);
      ParseToken(sTip,sToken,'\n');
      strTipText = sTip;
	}
#ifndef _UNICODE
	if (pNMHDR->code == TTN_NEEDTEXTA)
		lstrcpyn(pTTTA->szText, strTipText, sizeof(pTTTA->szText));
	else
		_mbstowcsz(pTTTW->szText, strTipText, sizeof(pTTTW->szText));
#else
	if (pNMHDR->code == TTN_NEEDTEXTA)
		_wcstombsz(pTTTA->szText, strTipText, sizeof(pTTTA->szText));
	else
		lstrcpyn(pTTTW->szText, strTipText, sizeof(pTTTW->szText));
#endif
	*pResult = 0;

	return TRUE;    // message was handled
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Save Picture Methods
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
void CVideoFloatingDialog::OnSavePicture()
{
   HDIB hDib = NULL;
   if (hDib = CopyWindowToDIB(m_wndVideo.GetSafeHwnd(),PW_CLIENT))
   {
      EnableWindow(FALSE);

      CString sFileType,sFileExt;
      sFileType.LoadString(IDS_VIDEO_IMAGE_FILEDIALOG_MASK_BMPONLY);
      sFileExt.LoadString(IDS_VIDEO_IMAGE_FILEDIALOG_EXT_BMP);
      CFileDialog dlg(FALSE,sFileExt,_T(""),OFN_PATHMUSTEXIST|OFN_LONGNAMES|OFN_HIDEREADONLY,sFileType);
      if (dlg.DoModal() == IDOK)
      {
         CString sFileName = dlg.GetPathName();
         if (!sFileName.IsEmpty())
         {
            SaveDIB(hDib,sFileName);
         }
      }
      DestroyDIB(hDib);
      EnableWindow(TRUE);
   }
}

int CVideoFloatingDialog::GetWindowStateFromPoint( POINT point )
{
	int nState = -1;

	CRect rcWindow;
	GetWindowRect(rcWindow);
	ClientToScreen( &point );

	int dx = point.x - rcWindow.left - m_sizeVideoOffsetTop.cx - m_sizeVideoOffsetBottom.cx;
	int dy = point.y - rcWindow.top - m_sizeVideoOffsetTop.cy - m_sizeVideoOffsetBottom.cy;

	if ( (dx > 0) && (dy > 0) )
	{
		nState = max((dx * 2) / m_sizeVideoOrig.cx, (dy * 2) / m_sizeVideoOrig.cy) + 1;
		nState = min( max(nState, SIZING_WINDOWSTATE_MIN), SIZING_WINDOWSTATE_MAX );
	}

	return nState;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\wabperlist.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////
// WabPersonListCtrl.cpp : implemStockation file
/////////////////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "MainFrm.h"
#include "WabPerList.h"
#include "SpeedDlgs.h"
#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Defines
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

//For Context menu
enum {CNTXMENU_WABPERSON_EMAIL=0,CNTXMENU_WABPERSON_WEB,CNTXMENU_WABPERSON_DIAL};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CWABPersonListCtrl
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CWABPersonListCtrl, CListCtrl)

/////////////////////////////////////////////////////////////////////////////
CWABPersonListCtrl::CWABPersonListCtrl()
{
   m_pImageListLarge = NULL;
   m_pImageListSmall = NULL;
   m_pParentWnd = NULL;
   m_pDisplayObject = NULL;
   m_bLargeView = TRUE;
}

/////////////////////////////////////////////////////////////////////////////
CWABPersonListCtrl::~CWABPersonListCtrl()
{
   if (m_pImageListLarge) delete m_pImageListLarge;
   if (m_pImageListSmall) delete m_pImageListSmall;
   if (m_pDisplayObject)
   {
      delete m_pDisplayObject;
      m_pDisplayObject = NULL;
   }
}

/////////////////////////////////////////////////////////////////////////////
BEGIN_MESSAGE_MAP(CWABPersonListCtrl, CListCtrl)
	//{{AFX_MSG_MAP(CWABPersonListCtrl)
	ON_NOTIFY_REFLECT(NM_CLICK, OnClick)
	ON_NOTIFY_REFLECT(NM_DBLCLK, OnDblclk)
	ON_WM_CREATE()
	ON_UPDATE_COMMAND_UI(ID_BUTTON_SPEEDDIAL_ADD, OnUpdateButtonSpeeddialAdd)
	ON_COMMAND(ID_BUTTON_SPEEDDIAL_ADD, OnButtonSpeeddialAdd)
	ON_COMMAND(ID_BUTTON_SENDEMAILMESSAGE, OnButtonSendemailmessage)
	ON_COMMAND(ID_BUTTON_OPENWEBPAGE, OnButtonOpenwebpage)
	ON_COMMAND(ID_BUTTON_MAKECALL, OnButtonMakecall)
	ON_WM_CONTEXTMENU()
	ON_WM_KEYUP()
	ON_WM_LBUTTONDBLCLK()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
int CWABPersonListCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CListCtrl::OnCreate(lpCreateStruct) == -1)
		return -1;

   ListView_SetExtendedListViewStyle(GetSafeHwnd(),LVS_EX_TRACKSELECT);
   ListView_SetIconSpacing(GetSafeHwnd(), LARGE_ICON_X, LARGE_ICON_Y );

	return 0;
}

/////////////////////////////////////////////////////////////////////////////
void CWABPersonListCtrl::Init(CWnd* pParentWnd)
{	
   m_pParentWnd = pParentWnd;

   m_pImageListLarge = new CImageList;
   m_pImageListLarge->Create(IDB_LIST_MEDIA_LARGE,24,0,RGB_TRANS);
   SetImageList(m_pImageListLarge,LVSIL_NORMAL);

   m_pImageListSmall = new CImageList;
   m_pImageListSmall->Create(IDB_LIST_MEDIA_SMALL,16,0,RGB_TRANS);
   SetImageList(m_pImageListSmall,LVSIL_SMALL);
}

/////////////////////////////////////////////////////////////////////////////
void CWABPersonListCtrl::InsertObject(CWABEntry* pWabEntry,BOOL bUseCache)
{
   ASSERT(pWabEntry);
   if (m_pDirectory == NULL) return;
   
   if ( (bUseCache == FALSE) && (m_pDisplayObject) )
   {
      delete m_pDisplayObject;
      m_pDisplayObject = NULL;
   }
   
   m_pDisplayObject = pWabEntry;

   DeleteAllItems();

   /*
   //make sure images are a few pixels off left
   if (m_bLargeView)
   {
      CRect rcClient;
      GetClientRect(rcClient);
      ListView_SetWorkAreas(GetSafeHwnd(),0,&rcClient);
   }
   else
   {
      //make sure images are a few pixels off left
      CRect rcClient;
      GetClientRect(rcClient);
      rcClient.left += 3;
      ListView_SetWorkAreas(GetSafeHwnd(),1,&rcClient);
   }*/

   CString sOut;
   if (WabPersonFormatString(sOut,PR_EMAIL_ADDRESS,IDS_WABPERSON_FORMAT_NETPHONE))
      InsertItem(sOut,WABLISTCTRL_ITEM_NETCALL,WABLISTCTRL_IMAGE_NETCALL);

   if (WabPersonFormatString(sOut,PR_BUSINESS_TELEPHONE_NUMBER,IDS_WABPERSON_FORMAT_BUSINESSTELEPHONE))
      InsertItem(sOut,WABLISTCTRL_ITEM_PHONECALL_BUSINESS,WABLISTCTRL_IMAGE_PHONECALL);

   if (WabPersonFormatString(sOut,PR_HOME_TELEPHONE_NUMBER,IDS_WABPERSON_FORMAT_HOMETELEPHONE))
      InsertItem(sOut,WABLISTCTRL_ITEM_PHONECALL_HOME,WABLISTCTRL_IMAGE_PHONECALL);

   if (WabPersonFormatString(sOut,PR_MOBILE_TELEPHONE_NUMBER,IDS_WABPERSON_FORMAT_MOBILETELEPHONE))
      InsertItem(sOut,WABLISTCTRL_ITEM_CELLCALL,WABLISTCTRL_IMAGE_CELLCALL);

   //get the email address list 
   CStringList sEmailList; 
   if ( (m_pDirectory->WABGetStringListProperty(m_pDisplayObject, PR_CONTACT_EMAIL_ADDRESSES, sEmailList) == DIRERR_SUCCESS) && (sEmailList.GetCount() > 0) )
   {
      UINT uId = WABLISTCTRL_ITEM_EMAIL_FIRST;                          //first email address
      POSITION pos = sEmailList.GetHeadPosition();
      while (pos)
      {
         CString sOut = sEmailList.GetNext(pos);
         if (WabPersonFormatString(sOut,IDS_WABPERSON_FORMAT_EMAIL))    //Format the email string
            InsertItem(sOut,uId,WABLISTCTRL_IMAGE_EMAIL);
         uId++;
      }
   }

   if (WabPersonFormatString(sOut,PR_BUSINESS_FAX_NUMBER,IDS_WABPERSON_FORMAT_BUSINESSFAX))
      InsertItem(sOut,WABLISTCTRL_ITEM_FAXCALL_BUSINESS,WABLISTCTRL_IMAGE_FAXCALL);

   if (WabPersonFormatString(sOut,PR_HOME_FAX_NUMBER,IDS_WABPERSON_FORMAT_HOMEFAX))
      InsertItem(sOut,WABLISTCTRL_ITEM_FAXCALL_HOME,WABLISTCTRL_IMAGE_FAXCALL);

   if (WabPersonFormatString(sOut,PR_PAGER_TELEPHONE_NUMBER,IDS_WABPERSON_FORMAT_PAGERTELEPHONE))
      InsertItem(sOut,WABLISTCTRL_ITEM_PAGER,WABLISTCTRL_IMAGE_PAGER);

   if (WabPersonFormatString(sOut,PR_BUSINESS_HOME_PAGE,IDS_WABPERSON_FORMAT_BUSINESSHOMEPAGE))
      InsertItem(sOut,WABLISTCTRL_ITEM_BUSINESSHOMEPAGE,WABLISTCTRL_IMAGE_PERSONALWEB);

   if (WabPersonFormatString(sOut,PR_PERSONAL_HOME_PAGE,IDS_WABPERSON_FORMAT_PERSONALHOMEPAGE))
      InsertItem(sOut,WABLISTCTRL_ITEM_PERSONALHOMEPAGE,WABLISTCTRL_IMAGE_PERSONALWEB);
}


/////////////////////////////////////////////////////////////////////////////
void CWABPersonListCtrl::InsertItem(LPCTSTR szStr,UINT uID,int nImage)
{
   int nItem = -1;
   
	LV_ITEM lv_item;
	memset(&lv_item,0,sizeof(LV_ITEM));
	
   if (nItem == -1)
      nItem = GetItemCount();
   lv_item.iItem = nItem;

	lv_item.mask |= LVIF_TEXT;
	lv_item.pszText = (LPTSTR)szStr;
	
   lv_item.mask |= LVIF_IMAGE;
   lv_item.iImage = nImage;

   lv_item.mask |= LVIF_PARAM;
   lv_item.lParam = uID;

	if ((nItem = CListCtrl::InsertItem(&lv_item)) != -1)
      CListCtrl::EnsureVisible(nItem,FALSE);

   int nWidth = GetStringWidth(szStr);
   CListCtrl::SetColumnWidth(-1,nWidth);
}

/////////////////////////////////////////////////////////////////////////////
void CWABPersonListCtrl::Refresh(CWABEntry* pWabEntry)
{
}

/////////////////////////////////////////////////////////////////////////////
void CWABPersonListCtrl::OnClick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	*pResult = 0;
}

/////////////////////////////////////////////////////////////////////////////
void CWABPersonListCtrl::OnContextMenu(CWnd* pWnd, CPoint point) 
{
   if ( (point.x == -1) && (point.y == -1) )
   {
      //when we come in from a keyboard (SHIFT + VF10) we get a -1,-1
      point.x = 0;
      point.y = 0;
      ClientToScreen(&point);
   }

   //Get selected item
   int nItem = GetNextItem(-1,LVNI_FOCUSED);
   if (nItem != -1)
   {
      LV_ITEM lv_item;
      memset(&lv_item,0,sizeof(LV_ITEM));
      lv_item.mask = LVIF_PARAM;
      lv_item.iItem = nItem;
      lv_item.iSubItem = 0;

      if (GetItem(&lv_item))
      {
         int nSubMenu = -1;

         switch ((UINT)lv_item.lParam)
         {
            case WABLISTCTRL_ITEM_EMAIL:              nSubMenu = CNTXMENU_WABPERSON_EMAIL;   break;
            case WABLISTCTRL_ITEM_BUSINESSHOMEPAGE:   nSubMenu = CNTXMENU_WABPERSON_WEB;     break;
            case WABLISTCTRL_ITEM_PERSONALHOMEPAGE:   nSubMenu = CNTXMENU_WABPERSON_WEB;     break;
            case WABLISTCTRL_ITEM_NETCALL:            nSubMenu = CNTXMENU_WABPERSON_DIAL;    break;
            case WABLISTCTRL_ITEM_PHONECALL_BUSINESS: nSubMenu = CNTXMENU_WABPERSON_DIAL;    break;
            case WABLISTCTRL_ITEM_PHONECALL_HOME:     nSubMenu = CNTXMENU_WABPERSON_DIAL;    break;
            case WABLISTCTRL_ITEM_CELLCALL:           nSubMenu = CNTXMENU_WABPERSON_DIAL;    break;
         }
         if ( ((UINT)lv_item.lParam >= WABLISTCTRL_ITEM_EMAIL_FIRST) && ((UINT)lv_item.lParam <= WABLISTCTRL_ITEM_EMAIL_LAST) )
            nSubMenu = CNTXMENU_WABPERSON_EMAIL; 

         if (nSubMenu != -1)
         {
            CMenu menu;
            menu.LoadMenu(IDR_CONTEXT_COMMOBJECTS);
            CMenu* pContextMenu = menu.GetSubMenu(nSubMenu);
            if (pContextMenu)
            {
               CPoint pt;
               ::GetCursorPos(&pt);
               pContextMenu->TrackPopupMenu(
                  TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
			         point.x,point.y,this);
            }
         }
      }
   }
}

/////////////////////////////////////////////////////////////////////////////
void CWABPersonListCtrl::OnDblclk(NMHDR* pNMHDR, LRESULT* pResult) 
{
	*pResult = 0;

   LV_HITTESTINFO lvhti;
   ::GetCursorPos( &lvhti.pt );
   ScreenToClient( &lvhti.pt );

   HitTest(&lvhti);
   if (lvhti.flags & LVHT_ONITEM)
   {
      LV_ITEM lv_item;
      memset(&lv_item,0,sizeof(LV_ITEM));
      lv_item.mask = LVIF_PARAM;
      lv_item.iItem = lvhti.iItem;
      lv_item.iSubItem = 0;

      if (GetItem(&lv_item))
      {
         switch ((UINT)lv_item.lParam)
         {
            case WABLISTCTRL_ITEM_EMAIL:
               SendEmail(PR_EMAIL_ADDRESS);
               break;
            case WABLISTCTRL_ITEM_BUSINESSHOMEPAGE: 
               OpenWebPage(PR_BUSINESS_HOME_PAGE);   
               break;
            case WABLISTCTRL_ITEM_PERSONALHOMEPAGE: 
               OpenWebPage(PR_PERSONAL_HOME_PAGE); 
               break;
            case WABLISTCTRL_ITEM_NETCALL:
            {
               CreateCall(PR_EMAIL_ADDRESS,
                          LINEADDRESSTYPE_EMAILNAME,
                          DIALER_MEDIATYPE_INTERNET);
               break;
            }
            case WABLISTCTRL_ITEM_PHONECALL_BUSINESS:
            {
               CreateCall(PR_BUSINESS_TELEPHONE_NUMBER,
                          LINEADDRESSTYPE_PHONENUMBER,
                          DIALER_MEDIATYPE_POTS);
               break;
            }
            case WABLISTCTRL_ITEM_PHONECALL_HOME:
            {
               CreateCall(PR_HOME_TELEPHONE_NUMBER,
                          LINEADDRESSTYPE_PHONENUMBER,
                          DIALER_MEDIATYPE_POTS);
               break;
            }
            case WABLISTCTRL_ITEM_CELLCALL:
            {
               CreateCall(PR_MOBILE_TELEPHONE_NUMBER,
                          LINEADDRESSTYPE_PHONENUMBER,
                          DIALER_MEDIATYPE_POTS);
               break;
            }
         }
         if ( ((UINT)lv_item.lParam >= WABLISTCTRL_ITEM_EMAIL_FIRST) && ((UINT)lv_item.lParam <= WABLISTCTRL_ITEM_EMAIL_LAST) )
         {
            CString sEmailAddress;
            if (GetEmailAddressFromId((UINT)lv_item.lParam,sEmailAddress))
            {
               CString sEmailFormat;
               sEmailFormat.Format(_T("mailto:%s"),sEmailAddress);
               ((CActiveDialerApp*)AfxGetApp())->ShellExecute(NULL,_T("open"),sEmailFormat,NULL,NULL,NULL);
            }
         }
      }
   }
	*pResult = 0;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CWABPersonListCtrl::CreateCall(UINT attrib,long lAddressType,DialerMediaType nType)
{
   if ( !AfxGetMainWnd() || !((CMainFrame *) AfxGetMainWnd())->GetDocument() ) return FALSE;
   CActiveDialerDoc *pDoc = ((CMainFrame *) AfxGetMainWnd())->GetDocument();
   m_pDisplayObject->CreateCall(pDoc,m_pDirectory,attrib,lAddressType,nType);
   return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
void CWABPersonListCtrl::GetSelectedItemText(CString& sText)
{
   int nItem =  CListCtrl::GetNextItem(-1,LVNI_FOCUSED);
   if (nItem != -1)
   {
      sText = GetItemText(nItem,0);
   }
}

/////////////////////////////////////////////////////////////////////////////
int CWABPersonListCtrl::GetSelectedObject()
{
   int nRet = -1;
   int nItem =  CListCtrl::GetNextItem(-1,LVNI_FOCUSED);
   if (nItem != -1)
   {
      nRet = (int)GetItemData(nItem);
   }
   return nRet;
}

/////////////////////////////////////////////////////////////////////////////
void CWABPersonListCtrl::ShowLargeView()
{
   m_bLargeView = TRUE;

   LONG_PTR LPStyle = ::GetWindowLongPtr(GetSafeHwnd(),GWL_STYLE );
   LPStyle |= LVS_ICON;
   LPStyle |= LVS_ALIGNTOP;
   LPStyle &= ~LVS_ALIGNLEFT;
   LPStyle &= ~LVS_SMALLICON;
   ::SetWindowLongPtr(GetSafeHwnd(),GWL_STYLE, LPStyle);

   ListView_SetIconSpacing(GetSafeHwnd(), LARGE_ICON_X, LARGE_ICON_Y );

   if (m_pDisplayObject)
      InsertObject(m_pDisplayObject,TRUE);
}

/////////////////////////////////////////////////////////////////////////////
void CWABPersonListCtrl::ShowSmallView()
{
   m_bLargeView = FALSE;
   
   LONG_PTR LPStyle = ::GetWindowLongPtr(GetSafeHwnd(),GWL_STYLE );
   LPStyle |= LVS_SMALLICON;
   LPStyle |= LVS_ALIGNLEFT;
   LPStyle &= ~LVS_ALIGNTOP;
   LPStyle &= ~LVS_ICON;
   ::SetWindowLongPtr(GetSafeHwnd(),GWL_STYLE, LPStyle);

   ListView_SetIconSpacing(GetSafeHwnd(), SMALL_ICON_X, SMALL_ICON_Y);

   if (m_pDisplayObject)
      InsertObject(m_pDisplayObject,TRUE);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//SpeedDial Support
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
void CWABPersonListCtrl::OnButtonSpeeddialAdd() 
{
   CSpeedDialAddDlg dlg( AfxGetMainWnd() );

   dlg.m_CallEntry.m_MediaType = DIALER_MEDIATYPE_UNKNOWN;
   WabPersonString(dlg.m_CallEntry.m_sDisplayName,PR_DISPLAY_NAME);

   UINT uObjectType = GetSelectedObject();
   switch (uObjectType)
   {
      case WABLISTCTRL_ITEM_NETCALL:
      {
         WabPersonString(dlg.m_CallEntry.m_sAddress,PR_EMAIL_ADDRESS);
         dlg.m_CallEntry.m_MediaType = DIALER_MEDIATYPE_INTERNET;
         dlg.m_CallEntry.m_lAddressType = LINEADDRESSTYPE_EMAILNAME;
         break;
      }
      case WABLISTCTRL_ITEM_PHONECALL_BUSINESS:
      {
         WabPersonString(dlg.m_CallEntry.m_sAddress,PR_BUSINESS_TELEPHONE_NUMBER);
         dlg.m_CallEntry.m_MediaType = DIALER_MEDIATYPE_POTS;
         dlg.m_CallEntry.m_lAddressType = LINEADDRESSTYPE_PHONENUMBER;
         break;
      }
      case WABLISTCTRL_ITEM_PHONECALL_HOME:
      {
         WabPersonString(dlg.m_CallEntry.m_sAddress,PR_HOME_TELEPHONE_NUMBER);
         dlg.m_CallEntry.m_MediaType = DIALER_MEDIATYPE_POTS;
         dlg.m_CallEntry.m_lAddressType = LINEADDRESSTYPE_PHONENUMBER;
         break;
      }
      case WABLISTCTRL_ITEM_CELLCALL:
      {
         WabPersonString(dlg.m_CallEntry.m_sAddress,PR_MOBILE_TELEPHONE_NUMBER);
         dlg.m_CallEntry.m_MediaType = DIALER_MEDIATYPE_POTS;
         dlg.m_CallEntry.m_lAddressType = LINEADDRESSTYPE_PHONENUMBER;
         break;
      }
   }
   if (dlg.DoModal() == IDOK)
   {
      CDialerRegistry::AddCallEntry(FALSE,dlg.m_CallEntry);
   }
}

/////////////////////////////////////////////////////////////////////////////
void CWABPersonListCtrl::OnUpdateButtonSpeeddialAdd(CCmdUI* pCmdUI) 
{
   int nSelectedObject = GetSelectedObject();

   if ( (nSelectedObject == WABLISTCTRL_ITEM_NETCALL) ||
        (nSelectedObject == WABLISTCTRL_ITEM_PHONECALL_BUSINESS) ||
        (nSelectedObject == WABLISTCTRL_ITEM_PHONECALL_HOME) ||
        (nSelectedObject == WABLISTCTRL_ITEM_CELLCALL) )
	   pCmdUI->Enable(TRUE);
   else
	   pCmdUI->Enable(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
void CWABPersonListCtrl::OnButtonMakecall() 
{
   UINT uObjectType = GetSelectedObject();
   switch (uObjectType)
   {
      case WABLISTCTRL_ITEM_NETCALL:
         CreateCall(PR_EMAIL_ADDRESS,LINEADDRESSTYPE_EMAILNAME,DIALER_MEDIATYPE_INTERNET);
         break;
      case WABLISTCTRL_ITEM_PHONECALL_BUSINESS:
         CreateCall(PR_BUSINESS_TELEPHONE_NUMBER,LINEADDRESSTYPE_PHONENUMBER,DIALER_MEDIATYPE_POTS);
         break;
      case WABLISTCTRL_ITEM_PHONECALL_HOME:
         CreateCall(PR_HOME_TELEPHONE_NUMBER,LINEADDRESSTYPE_PHONENUMBER,DIALER_MEDIATYPE_POTS);
         break;
      case WABLISTCTRL_ITEM_CELLCALL:
         CreateCall(PR_MOBILE_TELEPHONE_NUMBER,LINEADDRESSTYPE_PHONENUMBER,DIALER_MEDIATYPE_POTS);
         break;
      default:
      {
         if ( !AfxGetMainWnd() || !((CMainFrame*) AfxGetMainWnd())->GetDocument() ) return;
         CActiveDialerDoc* pDoc = ((CMainFrame*) AfxGetMainWnd())->GetDocument();
         if (pDoc)
            pDoc->Dial(_T(""),_T(""),LINEADDRESSTYPE_IPADDRESS,DIALER_MEDIATYPE_UNKNOWN, false);
         break;
      }
   }
}

/////////////////////////////////////////////////////////////////////////////
void CWABPersonListCtrl::OnButtonSendemailmessage() 
{
   UINT uObjectType = GetSelectedObject();
   if (uObjectType == WABLISTCTRL_ITEM_EMAIL)
   {
      SendEmail(PR_EMAIL_ADDRESS);
   }
   else if ( (uObjectType >= WABLISTCTRL_ITEM_EMAIL_FIRST) && (uObjectType <= WABLISTCTRL_ITEM_EMAIL_LAST) )
   {
      CString sEmailAddress;
      if (GetEmailAddressFromId(uObjectType,sEmailAddress))
      {
         CString sEmailFormat;
         sEmailFormat.Format(_T("mailto:%s"),sEmailAddress);
         ((CActiveDialerApp*)AfxGetApp())->ShellExecute(NULL,_T("open"),sEmailFormat,NULL,NULL,NULL);
      }
   }
}

/////////////////////////////////////////////////////////////////////////////
void CWABPersonListCtrl::OnButtonOpenwebpage() 
{
   UINT uObjectType = GetSelectedObject();
   switch (uObjectType)
   {
      case WABLISTCTRL_ITEM_BUSINESSHOMEPAGE:
         OpenWebPage(PR_BUSINESS_HOME_PAGE);
         break;
      case WABLISTCTRL_ITEM_PERSONALHOMEPAGE:
         OpenWebPage(PR_PERSONAL_HOME_PAGE);
         break;
   }
}

/////////////////////////////////////////////////////////////////////////////
BOOL CWABPersonListCtrl::GetEmailAddressFromId(UINT uEmailItem,CString& sOut)
{
   sOut = _T("");
   
   //index of the email address that we want
   UINT uEmailIndex = uEmailItem - WABLISTCTRL_ITEM_EMAIL_FIRST;

   CStringList sEmailList; 
   if ( (m_pDirectory->WABGetStringListProperty(m_pDisplayObject, PR_CONTACT_EMAIL_ADDRESSES, sEmailList) == DIRERR_SUCCESS) && (sEmailList.GetCount() > 0) )
   {
      //skip to correct email address
      POSITION pos = sEmailList.GetHeadPosition();
      UINT uCount = 0;
      while ( (pos) && (uCount < uEmailIndex) )
      {
         uCount++;sEmailList.GetNext(pos);
      }
      if (pos)
      {
         sOut = sEmailList.GetNext(pos);
      }
   }
   return (sOut.IsEmpty())?FALSE:TRUE;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\wabgrplist.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// WabGroupListCtrl.h : header file
//

#ifndef _WABGROUPLISTCTRL_H_
#define _WABGROUPLISTCTRL_H_

#include "avlist.h"

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Defines
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#define WABGROUPVIEWMSG_LBUTTONDBLCLK  (WM_USER + 1010) 

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//class CWABGroupListItem
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class CPurlGroup;
class CPurlName;

class CWABGroupListItem : public CAVListItem
{
	friend class CWABGroupListCtrl;
public:
//Construction
   CWABGroupListItem()  {};
   ~CWABGroupListItem() {};

//Attributes
protected:
	CObject*			m_pObject;
public:   

//Operations
public:
	void			   SetObject(CObject* pObject)   {m_pObject = pObject;};
	CObject*       GetObject()						   {return m_pObject;};
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CWABGroupListCtrl window
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class CDirAsynch;
class CWABEntry;

class CWABGroupListCtrl : public CAVListCtrl
{
	DECLARE_DYNCREATE(CWABGroupListCtrl)
// Construction
public:
	CWABGroupListCtrl();

public:
   enum		//Needed for subitem definition (must start with zero)
   {
      WABGROUPVIEW_NAME=0,
      WABGROUPVIEW_FIRSTNAME,
      WABGROUPVIEW_LASTNAME,
      WABGROUPVIEW_COMPANY,
      WABGROUPVIEW_EMAIL,
      WABGROUPVIEW_BUSINESSPHONE,
      WABGROUPVIEW_HOMEPHONE,
   };

// Attributes
public:
   CObList*       m_pWABEntryList;
   CDirAsynch*    m_pDirectory;
   CWnd*          m_pParentView;

   static UINT    m_uColumnLabel[];

   DWORD          m_dwColumnsVisible;
   int            m_nNumColumns;

// Operations
public:
   void	         Init(CWnd* pParentView);
	BOOL	         Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);
   void           SetDirectoryObject(CDirAsynch* pDir) { m_pDirectory = pDir; };

   void           InsertList(CObList* pWABEntryList,BOOL bForce=FALSE);

   CWABEntry*     GetSelObject();
   CObList*       GetSelList();

   BOOL           IsColumnVisible(UINT uColumn);
   void           SetColumnVisible(UINT uColumn,BOOL bVisible);

protected:
   void           NormalizeColumn(int& column);
   void           SetColumns();


protected:
   void           OnSetDisplayText(CAVListItem* _pItem,int SubItem,LPTSTR szTextBuf,int nBufSize);
	void				OnSetDisplayImage(CAVListItem* pItem,int& iImage);
	int				CompareListItems(CAVListItem* pItem1,CAVListItem* pItem2,int column);

   void           SetSelItem(CObject* pObject);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWABGroupListCtrl)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CWABGroupListCtrl();

	// Generated message map functions
protected:
	//{{AFX_MSG(CWABGroupListCtrl)
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnDestroy();
	afx_msg void OnButtonMakecall();
	afx_msg void OnButtonDirectoryDetails();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif //_WABGROUPLISTCTRL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\wabperlist.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// WabPersonListCtrl.h : header file
//
#ifndef _WABPERSONLISTCTRL_H_
#define _WABPERSONLISTCTRL_H_

#include "dirasynch.h"
#include "DialReg.h"
#include "avdialer.h"

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Defines
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
enum 
{
   WABLISTCTRL_ITEM_NETCALL = 0,
   WABLISTCTRL_ITEM_CHAT,
   WABLISTCTRL_ITEM_PHONECALL_BUSINESS,
   WABLISTCTRL_ITEM_PHONECALL_HOME,
   WABLISTCTRL_ITEM_CELLCALL,
   WABLISTCTRL_ITEM_FAXCALL_BUSINESS,
   WABLISTCTRL_ITEM_FAXCALL_HOME,
   WABLISTCTRL_ITEM_PAGER,
   WABLISTCTRL_ITEM_DESKTOPPAGE,
   WABLISTCTRL_ITEM_EMAIL,
   WABLISTCTRL_ITEM_BUSINESSHOMEPAGE,
   WABLISTCTRL_ITEM_PERSONALHOMEPAGE,
   WABLISTCTRL_ITEM_PERSONALURL,
   WABLISTCTRL_ITEM_EMAIL_FIRST = 100,             //Email Range
   WABLISTCTRL_ITEM_EMAIL_LAST = 200,              //Email Range
};

enum 
{
   WABLISTCTRL_IMAGE_NETCALL = 0,
   WABLISTCTRL_IMAGE_CHAT,
   WABLISTCTRL_IMAGE_PHONECALL,
   WABLISTCTRL_IMAGE_CELLCALL,
   WABLISTCTRL_IMAGE_FAXCALL,
   WABLISTCTRL_IMAGE_PAGER,
   WABLISTCTRL_IMAGE_DESKTOPPAGE,
   WABLISTCTRL_IMAGE_EMAIL,
   WABLISTCTRL_IMAGE_PERSONALWEB,
   WABLISTCTRL_IMAGE_PERSONALURL,
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CWABPersonListCtrl window
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class CWABEntry;
class CDirAsynch;

class CWABPersonListCtrl : public CListCtrl
{
	DECLARE_DYNCREATE(CWABPersonListCtrl)
// Construction
public:
	CWABPersonListCtrl();

// Attributes
public:
protected:
   CWnd*          m_pParentWnd;

   CWABEntry*     m_pDisplayObject;
   CDirAsynch*    m_pDirectory;

   BOOL           m_bLargeView;

   CImageList*    m_pImageListLarge;
   CImageList*    m_pImageListSmall;

// Operations
public:
   void           Init(CWnd* pParentWnd);
   void           SetDirectoryObject(CDirAsynch* pDir) { m_pDirectory = pDir; };

   void           InsertObject(CWABEntry* pWABEntry,BOOL bUseCache=FALSE);
   void           ShowLargeView();
   void           ShowSmallView();
   BOOL           IsLargeView()                                   { return m_bLargeView; };

   void           Refresh(CWABEntry* pWabEntry);

protected:
   void           GetSelectedItemText(CString& sText);
   void           InsertItem(LPCTSTR szStr,UINT uID,int nImage);
   int            GetSelectedObject();
   BOOL           GetEmailAddressFromId(UINT uEmailItem,CString& sOut);

   BOOL           CreateCall(UINT attrib,long lAddressType, DialerMediaType nType);

   inline BOOL    WabPersonFormatString(CString& sOut,UINT attrib,UINT formatid)
   {
      sOut = _T("");
      CString sText;
      if ( (m_pDirectory->WABGetStringProperty(m_pDisplayObject, attrib, sText) == DIRERR_SUCCESS) &&
           (!sText.IsEmpty()) )
      {
         AfxFormatString1(sOut,formatid,sText);
         if (m_bLargeView == FALSE)                      //if small view, then no \r\n
         {
            int nIndex;
            while ((nIndex = sOut.Find(_T("\r\n"))) != -1)
            {
               CString sTemp = sOut.Left(nIndex);
               sTemp += _T(" ");
               sOut = sTemp + sOut.Mid(nIndex+2);
            }
         }
      }
      return (sOut.IsEmpty())?FALSE:TRUE;
   }
   inline BOOL    WabPersonFormatString(CString& sOut,UINT formatid)
   {
      AfxFormatString1(sOut,formatid,sOut);
      if (m_bLargeView == FALSE)                      //if small view, then no \r\n
      {
         int nIndex;
         while ((nIndex = sOut.Find(_T("\r\n"))) != -1)
         {
            CString sTemp = sOut.Left(nIndex);
            sTemp += _T(" ");
            sOut = sTemp + sOut.Mid(nIndex+2);
         }
      }
      return (sOut.IsEmpty())?FALSE:TRUE;
   }
   inline BOOL    WabPersonString(CString& sOut,UINT attrib)
   {
      sOut = _T("");
      m_pDirectory->WABGetStringProperty(m_pDisplayObject, attrib, sOut);
      return (sOut.IsEmpty())?FALSE:TRUE;
   }
   inline void    OpenWebPage(UINT attrib)
   {
      CString sWeb;
      WabPersonString(sWeb,attrib);
      if (!sWeb.IsEmpty())
      {
         ((CActiveDialerApp*)AfxGetApp())->ShellExecute(NULL,_T("open"),sWeb,NULL,NULL,NULL);
      }
   }
   inline void    SendEmail(UINT attrib)
   {
      CString sEmail;
      WabPersonString(sEmail,attrib);
      if (!sEmail.IsEmpty())
      {
         CString sEmailFormat;
         sEmailFormat.Format(_T("mailto:%s"),sEmail);
         ((CActiveDialerApp*)AfxGetApp())->ShellExecute(NULL,_T("open"),sEmailFormat,NULL,NULL,NULL);
      }
   }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWABPersonListCtrl)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CWABPersonListCtrl();

	// Generated message map functions
protected:
	//{{AFX_MSG(CWABPersonListCtrl)
	afx_msg void OnClick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDblclk(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnUpdateButtonSpeeddialAdd(CCmdUI* pCmdUI);
	afx_msg void OnButtonSpeeddialAdd();
	afx_msg void OnButtonSendemailmessage();
	afx_msg void OnButtonOpenwebpage();
	afx_msg void OnButtonMakecall();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
#endif //_WABPERSONLISTCTRL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\wabgrplist.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// WabPersonListCtrl.cpp : implementation file
//

#include "stdafx.h"
#include "WabGrpList.h"
#include "mainfrm.h"
#include "util.h"
#include "resource.h"
#include "dirasynch.h"
#include "avtrace.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//WAB Group View
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#define NUM_COLUMNS_WABGROUPVIEW       7

//***Put this in string table
UINT CWABGroupListCtrl::m_uColumnLabel[NUM_COLUMNS_WABGROUPVIEW]=            //Column headings
{
    IDS_HEADING_DISPLAY,
   IDS_HEADING_FIRSTNAME,
   IDS_HEADING_LASTNAME,
   IDS_HEADING_COMPANY,
   IDS_HEADING_EMAIL,
   IDS_HEADING_PHONE_BUSINESS,
   IDS_HEADING_PHONE_HOME,
};

static int nColumnWidth[NUM_COLUMNS_WABGROUPVIEW]=                   //Column widths
{
    120, 100, 100, 120, 120, 100, 100
};

enum
{
   WABGROUPLISTCTRL_DIRECTORY_WAB_IMAGE=0,
   WABGROUPLISTCTRL_DIRECTORY_PERSON_IMAGE,
   WABGROUPLISTCTRL_DIRECTORY_GROUP_IMAGE,
   WABGROUPLISTCTRL_DIRECTORY_DOMAIN_IMAGE,
   WABGROUPLISTCTRL_DIRECTORY_LOCALE_IMAGE,
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CLASS CWABGroupListCtrl
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CWABGroupListCtrl, CAVListCtrl)

BEGIN_MESSAGE_MAP(CWABGroupListCtrl, CAVListCtrl)
    //{{AFX_MSG_MAP(CWABGroupListCtrl)
    ON_WM_LBUTTONDBLCLK()
    ON_WM_DESTROY()
    ON_COMMAND(ID_BUTTON_MAKECALL, OnButtonMakecall)
    ON_COMMAND(ID_BUTTON_DIRECTORY_DETAILS, OnButtonDirectoryDetails)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
CWABGroupListCtrl::CWABGroupListCtrl()
{
   m_pWABEntryList = NULL;
   m_pDirectory = NULL;
   m_pParentView = NULL;
   m_nNumColumns = 0;
}

/////////////////////////////////////////////////////////////////////////////
CWABGroupListCtrl::~CWABGroupListCtrl()
{
}

/////////////////////////////////////////////////////////////////////////////
void CWABGroupListCtrl::Init(CWnd* pParentView)
{    
    //Set the bitmap for the list 
    CAVListCtrl::Init(IDB_TREE_DIRECTORIES);

    CWinApp* pApp = AfxGetApp();
   CString sDir,sRegKey;
   sDir.LoadString(IDN_REGISTRY_DIRECTORIES_KEYBASE);
   sRegKey.LoadString(IDN_REGISTRY_DIRECTORIES_WABCOLUMNS);
   m_dwColumnsVisible = pApp->GetProfileInt(sDir,sRegKey,0x00000079);   //default is 0x79
   sRegKey.LoadString(IDN_REGISTRY_DIRECTORIES_WABSORTASCENDING);
   m_SortOrder = !pApp->GetProfileInt(sDir,sRegKey,1);
   sRegKey.LoadString(IDN_REGISTRY_DIRECTORIES_WABSORTCOLUMN);
   m_SortColumn = pApp->GetProfileInt(sDir,sRegKey,0);

   m_pParentView = pParentView;

   SetColumns();

   ResetSortOrder();
}

/////////////////////////////////////////////////////////////////////////////
BOOL CWABGroupListCtrl::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID)
{
    //We want the report style
     dwStyle |= LVS_REPORT;

    BOOL bRet = CAVListCtrl::Create(dwStyle,rect,pParentWnd,nID);

   ListView_SetExtendedListViewStyle(GetSafeHwnd(),LVS_EX_FULLROWSELECT);

   return bRet;
}

/////////////////////////////////////////////////////////////////////////////
void CWABGroupListCtrl::InsertList(CObList* pWABEntryList,BOOL bForce)
{
   ASSERT(m_pDirectory);

   if (pWABEntryList == NULL) return;

   if ( (bForce == FALSE) && (pWABEntryList == m_pWABEntryList) )
      return;

   //delete the items in the list
   DeleteAllItems();

   //delete old list and objects within
   if ( m_pWABEntryList )
   {
      while ( m_pWABEntryList->GetHeadPosition() )
         delete m_pWABEntryList->RemoveHead();

      delete m_pWABEntryList;
   }

   m_pWABEntryList = pWABEntryList;

   POSITION pos = m_pWABEntryList->GetHeadPosition();
   while (pos)
   {
      CWABGroupListItem* pItem = new CWABGroupListItem();
      pItem->SetObject(m_pWABEntryList->GetNext(pos));
      CAVListCtrl::InsertItem(pItem,0,FALSE);
   }
   CAVListCtrl::SortItems();
}

/////////////////////////////////////////////////////////////////////////////
void CWABGroupListCtrl::SetSelItem(CObject* pObject)
{
   int nCount = GetItemCount();
   for (int i=0;i<nCount;i++)
   {
      CWABGroupListItem* pItem = (CWABGroupListItem*)GetItemData(i);
      if (pObject == pItem->GetObject())
      {
         CAVListCtrl::SetSelItem(i);
         break;
      }
   }
}

/////////////////////////////////////////////////////////////////////////////
CWABEntry* CWABGroupListCtrl::GetSelObject()
{
   CWABEntry* pRetWabEntry = NULL;
   //Get the selected object so we can set it again
   int nSelItem = CAVListCtrl::GetSelItem();
   if (nSelItem != -1)
   {
      CWABGroupListItem* pItem = (CWABGroupListItem*)GetItemData(nSelItem);
      if (pItem)
      {
         CObject* pObject = pItem->GetObject();            
      
         //create new WABEntry and copy data
         pRetWabEntry = new CWABEntry;
         *pRetWabEntry = (CWABEntry*)pObject;
      }
   }
   return pRetWabEntry;
}

/////////////////////////////////////////////////////////////////////////////
CObList* CWABGroupListCtrl::GetSelList()
{
   CObList* pRetList = new CObList;
   int nIndex = -1;

   while ((nIndex = GetNextItem(nIndex,LVNI_SELECTED)) != -1)
   {
      CWABGroupListItem* pItem = (CWABGroupListItem*)GetItemData(nIndex);
      CObject* pObject = pItem->GetObject();
      if (pObject)
      {
         pRetList->AddTail(pObject);
      }
   }
   return pRetList;
}

/////////////////////////////////////////////////////////////////////////////
void CWABGroupListCtrl::OnSetDisplayText(CAVListItem* _pItem,int SubItem,LPTSTR szTextBuf,int nBufSize)
{
   ASSERT(m_pDirectory);
   CWABEntry* pWABEntry = (CWABEntry*)(((CWABGroupListItem*)_pItem)->GetObject());

   if (pWABEntry == NULL) return;

   NormalizeColumn(SubItem);
   
   switch (SubItem)
   {
      case WABGROUPVIEW_NAME:
      {
         CString sText;
         m_pDirectory->WABGetStringProperty(pWABEntry, PR_DISPLAY_NAME, sText);
          _tcsncpy(szTextBuf,sText,nBufSize-1);            
         szTextBuf[nBufSize-1] = '\0';                            //make sure we are null terminated
         break;
      }
      case WABGROUPVIEW_FIRSTNAME:
      {
         CString sText;
         m_pDirectory->WABGetStringProperty(pWABEntry, PR_GIVEN_NAME, sText);
            _tcsncpy(szTextBuf,sText,nBufSize-1);            
         szTextBuf[nBufSize-1] = '\0';                            //make sure we are null terminated
         break;
      }
      case WABGROUPVIEW_LASTNAME:
      {
         CString sText;
         m_pDirectory->WABGetStringProperty(pWABEntry, PR_SURNAME, sText);
            _tcsncpy(szTextBuf,sText,nBufSize-1);            
         szTextBuf[nBufSize-1] = '\0';                            //make sure we are null terminated
         break;
      }
      case WABGROUPVIEW_COMPANY:
      {
         CString sText;
         m_pDirectory->WABGetStringProperty(pWABEntry, PR_COMPANY_NAME, sText);
            _tcsncpy(szTextBuf,sText,nBufSize-1);            
         szTextBuf[nBufSize-1] = '\0';                            //make sure we are null terminated
         break;
      }
      case WABGROUPVIEW_EMAIL:
      {
         CString sText;
         m_pDirectory->WABGetStringProperty(pWABEntry, PR_EMAIL_ADDRESS, sText);
            _tcsncpy(szTextBuf,sText,nBufSize-1);            
         szTextBuf[nBufSize-1] = '\0';                            //make sure we are null terminated
         break;
      }
      case WABGROUPVIEW_BUSINESSPHONE:
      {
         CString sText;
         m_pDirectory->WABGetStringProperty(pWABEntry, PR_BUSINESS_TELEPHONE_NUMBER, sText);
            _tcsncpy(szTextBuf,sText,nBufSize-1);            
         szTextBuf[nBufSize-1] = '\0';                            //make sure we are null terminated
         break;
      }
      case WABGROUPVIEW_HOMEPHONE:
      {
         CString sText;
         m_pDirectory->WABGetStringProperty(pWABEntry, PR_HOME_TELEPHONE_NUMBER, sText);
            _tcsncpy(szTextBuf,sText,nBufSize-1);            
         szTextBuf[nBufSize-1] = '\0';                            //make sure we are null terminated
         break;
      }
   }
}  

/////////////////////////////////////////////////////////////////////////////
void CWABGroupListCtrl::OnSetDisplayImage(CAVListItem* _pItem,int& iImage)
{
   iImage = -1;

   CWABEntry* pWABEntry = (CWABEntry*)(((CWABGroupListItem*)_pItem)->GetObject());
   
   if (pWABEntry == NULL) return;
   
   if (m_pDirectory->IsPerson(pWABEntry))
   {
      iImage = WABGROUPLISTCTRL_DIRECTORY_PERSON_IMAGE;
   }
   else if (m_pDirectory->IsContainer(pWABEntry))
   {
      iImage = WABGROUPLISTCTRL_DIRECTORY_GROUP_IMAGE;
   }
   else if (m_pDirectory->IsDistributionList(pWABEntry))
   {
      iImage = WABGROUPLISTCTRL_DIRECTORY_GROUP_IMAGE;
   }
}

/////////////////////////////////////////////////////////////////////////////
int CWABGroupListCtrl::CompareListItems(CAVListItem* _pItem1,CAVListItem* _pItem2,int column)
{
   ASSERT(m_pDirectory);

   int ret = 0;

   CWABEntry* pWABEntry1 = (CWABEntry*)(((CWABGroupListItem*)_pItem1)->GetObject());
   CWABEntry* pWABEntry2 = (CWABEntry*)(((CWABGroupListItem*)_pItem2)->GetObject());

   NormalizeColumn(column);

   switch (column)
    {
      case WABGROUPVIEW_NAME:
      {
         CString sText1,sText2;
         m_pDirectory->WABGetStringProperty(pWABEntry1, PR_DISPLAY_NAME, sText1);
         m_pDirectory->WABGetStringProperty(pWABEntry2, PR_DISPLAY_NAME, sText2);
         ret = (_tcsicmp(sText1,sText2) <= 0)?-1:1;
         break;
      }
      case WABGROUPVIEW_FIRSTNAME:
      {
         CString sText1,sText2;
         m_pDirectory->WABGetStringProperty(pWABEntry1, PR_GIVEN_NAME, sText1);
         m_pDirectory->WABGetStringProperty(pWABEntry2, PR_GIVEN_NAME, sText2);
         ret = (_tcsicmp(sText1,sText2) <= 0)?-1:1;
         break;
      }
      case WABGROUPVIEW_LASTNAME:
      {
         CString sText1,sText2;
         m_pDirectory->WABGetStringProperty(pWABEntry1, PR_SURNAME, sText1);
         m_pDirectory->WABGetStringProperty(pWABEntry2, PR_SURNAME, sText2);
         ret = (_tcsicmp(sText1,sText2) <= 0)?-1:1;
         break;
      }
      case WABGROUPVIEW_COMPANY:
      {
         CString sText1,sText2;
         m_pDirectory->WABGetStringProperty(pWABEntry1, PR_COMPANY_NAME, sText1);
         m_pDirectory->WABGetStringProperty(pWABEntry2, PR_COMPANY_NAME, sText2);
         ret = (_tcsicmp(sText1,sText2) <= 0)?-1:1;
         break;
      }
      case WABGROUPVIEW_EMAIL:
      {
         CString sText1,sText2;
         m_pDirectory->WABGetStringProperty(pWABEntry1, PR_EMAIL_ADDRESS, sText1);
         m_pDirectory->WABGetStringProperty(pWABEntry2, PR_EMAIL_ADDRESS, sText2);
         ret = (_tcsicmp(sText1,sText2) <= 0)?-1:1;
         break;
      }
      case WABGROUPVIEW_BUSINESSPHONE:
      {
         CString sText1,sText2;
         m_pDirectory->WABGetStringProperty(pWABEntry1, PR_BUSINESS_TELEPHONE_NUMBER, sText1);
         m_pDirectory->WABGetStringProperty(pWABEntry2, PR_BUSINESS_TELEPHONE_NUMBER, sText2);
         ret = (_tcsicmp(sText1,sText2) <= 0)?-1:1;
         break;
      }
      case WABGROUPVIEW_HOMEPHONE:
      {
         CString sText1,sText2;
         m_pDirectory->WABGetStringProperty(pWABEntry1, PR_HOME_TELEPHONE_NUMBER, sText1);
         m_pDirectory->WABGetStringProperty(pWABEntry2, PR_HOME_TELEPHONE_NUMBER, sText2);
         ret = (_tcsicmp(sText1,sText2) <= 0)?-1:1;
         break;
      }
    }
    return (CAVListCtrl::GetSortOrder())?-ret:ret;
}

/////////////////////////////////////////////////////////////////////////////
void CWABGroupListCtrl::OnLButtonDblClk(UINT nFlags, CPoint point) 
{
   ASSERT(m_pParentView);

   //reflect to parent view
   m_pParentView->SendMessage(WABGROUPVIEWMSG_LBUTTONDBLCLK);

    CAVListCtrl::OnLButtonDblClk(nFlags, point);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Column View Support
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
BOOL CWABGroupListCtrl::IsColumnVisible(UINT uColumn)
{
   //each bit in m_dwColumnsVisible is a column starting with low-order bit 
   UINT uMask = 0x01;

   for (UINT i=0;i<uColumn;i++)
      uMask = uMask << 1;
      
   return (m_dwColumnsVisible & uMask)?TRUE:FALSE;
}

/////////////////////////////////////////////////////////////////////////////
//Used to figure what data column we are being asked to display.  We must skip over
//columns that are currently hidden
void CWABGroupListCtrl::NormalizeColumn(int& column)
{
   //Set the column headings
   for (int i=0; i<NUM_COLUMNS_WABGROUPVIEW; i++)
   {
      if (i > column)
         break;

      if (IsColumnVisible(i) == FALSE)
         column++;
   }
}

/////////////////////////////////////////////////////////////////////////////
void CWABGroupListCtrl::SetColumnVisible(UINT uColumn,BOOL bVisible)
{
   //each bit in m_dwColumnsVisible is a column starting with low-order bit 
   UINT uMask = 0x01;

   for (UINT i=0;i<uColumn;i++)
      uMask = uMask << 1;

   if (bVisible)
      m_dwColumnsVisible = m_dwColumnsVisible |= uMask;
   else
      m_dwColumnsVisible = m_dwColumnsVisible &= ~uMask;

   SetColumns();
   CAVListCtrl::SortItems();
}

/////////////////////////////////////////////////////////////////////////////
void CWABGroupListCtrl::SetColumns()
{
   //delete any existing columns
   if (m_nNumColumns > 0)
   {
      for (int i=m_nNumColumns-1;i>=0;i--)
         DeleteColumn(i);
   }

   m_nNumColumns = 0;

   //Set the column headings
   for (UINT i=0; i<NUM_COLUMNS_WABGROUPVIEW; i++)
   {
      if (IsColumnVisible(i))
      {
         CString sLabel;
         sLabel.LoadString(m_uColumnLabel[i]);
          InsertColumn(i,sLabel,LVCFMT_LEFT,nColumnWidth[i]);
         m_nNumColumns++;
      }
   }
}

/////////////////////////////////////////////////////////////////////////////
void CWABGroupListCtrl::OnDestroy() 
{
    CWinApp* pApp = AfxGetApp();
   CString sDir,sRegKey;
   sDir.LoadString(IDN_REGISTRY_DIRECTORIES_KEYBASE);
   sRegKey.LoadString(IDN_REGISTRY_DIRECTORIES_WABCOLUMNS);
   pApp->WriteProfileInt(sDir,sRegKey,m_dwColumnsVisible);
   sRegKey.LoadString(IDN_REGISTRY_DIRECTORIES_WABSORTASCENDING);
   pApp->WriteProfileInt(sDir,sRegKey,!m_SortOrder);
   sRegKey.LoadString(IDN_REGISTRY_DIRECTORIES_WABSORTCOLUMN);
   pApp->WriteProfileInt(sDir,sRegKey,m_SortColumn);
    
   //delete the items in the list
   DeleteAllItems();

   //delete old list and objects within
   if ( m_pWABEntryList )
   {
      while ( m_pWABEntryList->GetHeadPosition() )
         delete m_pWABEntryList->RemoveHead();

      delete m_pWABEntryList;
   }

    CAVListCtrl::OnDestroy();
}

/////////////////////////////////////////////////////////////////////////////
void CWABGroupListCtrl::OnButtonMakecall() 
{
   CWABEntry* pWABEntry = GetSelObject();
   if (pWABEntry)
   {
      if ( !AfxGetMainWnd() || !((CMainFrame*) AfxGetMainWnd())->GetDocument() )
      {
          //
          // we should deallocate the CWABEntry object
          //
          delete pWABEntry;
          return;
      }
      CActiveDialerDoc* pDoc = ((CMainFrame*) AfxGetMainWnd())->GetDocument();
      if (pDoc) pWABEntry->Dial(pDoc,m_pDirectory);

      delete pWABEntry;
   }
   else
   {
      if ( !AfxGetMainWnd() || !((CMainFrame*) AfxGetMainWnd())->GetDocument() ) return;
      CActiveDialerDoc* pDoc = ((CMainFrame*) AfxGetMainWnd())->GetDocument();
      if (pDoc) pDoc->Dial(_T(""),_T(""),LINEADDRESSTYPE_IPADDRESS,DIALER_MEDIATYPE_UNKNOWN, false);
   }
}

/////////////////////////////////////////////////////////////////////////////
void CWABGroupListCtrl::OnButtonDirectoryDetails() 
{
   CWABEntry* pWABEntry = GetSelObject();
   if (pWABEntry)
   {
      m_pDirectory->WABShowDetails(GetSafeHwnd(),pWABEntry);
      delete pWABEntry;
   }    
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\vobject.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

/*
 
The vCard/vCalendar C interface is implemented in the set 
of files as follows:

vcc.y, yacc source, and vcc.c, the yacc output you will use
implements the core parser

vobject.c implements an API that insulates the caller from
the parser and changes in the vCard/vCalendar BNF

port.h defines compilation environment dependent stuff

vcc.h and vobject.h are header files for their .c counterparts

vcaltmp.h and vcaltmp.c implement vCalendar "macro" functions
which you may find useful.

test.c is a standalone test driver that exercises some of
the features of the APIs provided. Invoke test.exe on a
VCARD/VCALENDAR input text file and you will see the pretty
print output of the internal representation (this pretty print
output should give you a good idea of how the internal 
representation looks like -- there is one such output in the 
following too). Also, a file with the .out suffix is generated 
to show that the internal representation can be written back 
in the original text format.

For more information on this API see the readme.txt file
which accompanied this distribution.

  Also visit:

		http://www.versit.com
		http://www.ralden.com

*/


#ifndef __VOBJECT_H__
#define __VOBJECT_H__ 1


#include "port.h"
#include <stdlib.h>
#include <stdio.h>

#if defined(__CPLUSPLUS__) || defined(__cplusplus)
extern "C" {
#endif


#define VC7bitProp				"7BIT"
#define VC8bitProp				"8BIT"
#define VCAAlarmProp			"AALARM"
#define VCAdditionalNamesProp	"ADDN"
#define VCAdrProp				"ADR"
#define VCAgentProp				"AGENT"
#define VCAIFFProp				"AIFF"
#define VCAOLProp				"AOL"
#define VCAppleLinkProp			"APPLELINK"
#define VCAttachProp			"ATTACH"
#define VCAttendeeProp			"ATTENDEE"
#define VCATTMailProp			"ATTMAIL"
#define VCAudioContentProp		"AUDIOCONTENT"
#define VCAVIProp				"AVI"
#define VCBase64Prop			"BASE64"
#define VCBBSProp				"BBS"
#define VCBirthDateProp			"BDAY"
#define VCBMPProp				"BMP"
#define VCBodyProp				"BODY"
#define VCBusinessRoleProp		"ROLE"
#define VCCalProp				"VCALENDAR"
#define VCCaptionProp			"CAP"
#define VCCardProp				"VCARD"
#define VCCarProp				"CAR"
#define VCCategoriesProp		"CATEGORIES"
#define VCCellularProp			"CELL"
#define VCCGMProp				"CGM"
#define VCCharSetProp			"CS"
#define VCCIDProp				"CID"
#define VCCISProp				"CIS"
#define VCCityProp				"L"
#define VCClassProp				"CLASS"
#define VCCommentProp			"NOTE"
#define VCCompletedProp			"COMPLETED"
#define VCContentIDProp			"CONTENT-ID"
#define VCCountryNameProp		"C"
#define VCDAlarmProp			"DALARM"
#define VCDataSizeProp			"DATASIZE"
#define VCDayLightProp			"DAYLIGHT"
#define VCDCreatedProp			"DCREATED"
#define VCDeliveryLabelProp     "LABEL"
#define VCDescriptionProp		"DESCRIPTION"
#define VCDIBProp				"DIB"
#define VCDisplayStringProp		"DISPLAYSTRING"
#define VCDomesticProp			"DOM"
#define VCDTendProp				"DTEND"
#define VCDTstartProp			"DTSTART"
#define VCDueProp				"DUE"
#define VCEmailAddressProp		"EMAIL"
#define VCEncodingProp			"ENCODING"
#define VCEndProp				"END"
#define VCEventProp				"VEVENT"
#define VCEWorldProp			"EWORLD"
#define VCExNumProp				"EXNUM"
#define VCExpDateProp			"EXDATE"
#define VCExpectProp			"EXPECT"
#define VCExtAddressProp		"EXT ADD"
#define VCFamilyNameProp		"F"
#define VCFaxProp				"FAX"
#define VCFullNameProp			"FN"
#define VCGeoProp				"GEO"
#define VCGeoLocationProp		"GEO"
#define VCGIFProp				"GIF"
#define VCGivenNameProp			"G"
#define VCGroupingProp			"Grouping"
#define VCHomeProp				"HOME"
#define VCIBMMailProp			"IBMMail"
#define VCInlineProp			"INLINE"
#define VCInternationalProp		"INTL"
#define VCInternetProp			"INTERNET"
#define VCISDNProp				"ISDN"
#define VCJPEGProp				"JPEG"
#define VCLanguageProp			"LANG"
#define VCLastModifiedProp		"LAST-MODIFIED"
#define VCLastRevisedProp		"REV"
#define VCLocationProp			"LOCATION"
#define VCLogoProp				"LOGO"
#define VCMailerProp			"MAILER"
#define VCMAlarmProp			"MALARM"
#define VCMCIMailProp			"MCIMAIL"
#define VCMessageProp			"MSG"
#define VCMETProp				"MET"
#define VCModemProp				"MODEM"
#define VCMPEG2Prop				"MPEG2"
#define VCMPEGProp				"MPEG"
#define VCMSNProp				"MSN"
#define VCNamePrefixesProp		"NPRE"
#define VCNameProp				"N"
#define VCNameSuffixesProp		"NSUF"
#define VCNoteProp				"NOTE"
#define VCOrgNameProp			"ORGNAME"
#define VCOrgProp				"ORG"
#define VCOrgUnit2Prop			"OUN2"
#define VCOrgUnit3Prop			"OUN3"
#define VCOrgUnit4Prop			"OUN4"
#define VCOrgUnitProp			"OUN"
#define VCPagerProp				"PAGER"
#define VCPAlarmProp			"PALARM"
#define VCParcelProp			"PARCEL"
#define VCPartProp				"PART"
#define VCPCMProp				"PCM"
#define VCPDFProp				"PDF"
#define VCPGPProp				"PGP"
#define VCPhotoProp				"PHOTO"
#define VCPICTProp				"PICT"
#define VCPMBProp				"PMB"
#define VCPostalBoxProp			"BOX"
#define VCPostalCodeProp		"PC"
#define VCPostalProp			"POSTAL"
#define VCPowerShareProp		"POWERSHARE"
#define VCPreferredProp			"PREF"
#define VCPriorityProp			"PRIORITY"
#define VCProcedureNameProp		"PROCEDURENAME"
#define VCProdIdProp			"PRODID"
#define VCProdigyProp			"PRODIGY"
#define VCPronunciationProp		"SOUND"
#define VCPSProp				"PS"
#define VCPublicKeyProp			"KEY"
#define VCQPProp				"QP"
#define VCQuickTimeProp			"QTIME"
#define VCQuotedPrintableProp	"QUOTED-PRINTABLE"
#define VCRDateProp				"RDATE"
#define VCRegionProp			"R"
#define VCRelatedToProp			"RELATED-TO"
#define VCRepeatCountProp		"REPEATCOUNT"
#define VCResourcesProp			"RESOURCES"
#define VCRNumProp				"RNUM"
#define VCRoleProp				"ROLE"
#define VCRRuleProp				"RRULE"
#define VCRSVPProp				"RSVP"
#define VCRunTimeProp			"RUNTIME"
#define VCSequenceProp			"SEQUENCE"
#define VCSnoozeTimeProp		"SNOOZETIME"
#define VCStartProp				"START"
#define VCStatusProp			"STATUS"
#define VCStreetAddressProp		"STREET"
#define VCSubTypeProp			"SUBTYPE"
#define VCSummaryProp			"SUMMARY"
#define VCTelephoneProp			"TEL"
#define VCTIFFProp				"TIFF"
#define VCTimeZoneProp			"TZ"
#define VCTitleProp				"TITLE"
#define VCTLXProp				"TLX"
#define VCTodoProp				"VTODO"
#define VCTranspProp			"TRANSP"
#define VCUniqueStringProp		"UID"
#define VCURLProp				"URL"
#define VCURLValueProp			"URLVAL"
#define VCValueProp				"VALUE"
#define VCVersionProp			"VERSION"
#define VCVideoProp				"VIDEO"
#define VCVoiceProp				"VOICE"
#define VCWAVEProp				"WAVE"
#define VCWMFProp				"WMF"
#define VCWorkProp				"WORK"
#define VCX400Prop				"X400"
#define VCX509Prop				"X509"
#define VCXRuleProp				"XRULE"


typedef struct VObject VObject;

typedef struct VObjectIterator {
    VObject* start;
    VObject* next;
    } VObjectIterator;

extern DLLEXPORT(VObject*) newVObject(const char *id);
extern DLLEXPORT(void) deleteVObject(VObject *p);
extern DLLEXPORT(char*) dupStr(const char *s, unsigned int size);
extern DLLEXPORT(void) deleteStr(const char *p);
extern DLLEXPORT(void) unUseStr(const char *s);

extern DLLEXPORT(void) setVObjectName(VObject *o, const char* id);
extern DLLEXPORT(void) setVObjectStringZValue(VObject *o, const char *s);
extern DLLEXPORT(void) setVObjectStringZValue_(VObject *o, const char *s);
extern DLLEXPORT(void) setVObjectUStringZValue(VObject *o, const wchar_t *s);
extern DLLEXPORT(void) setVObjectUStringZValue_(VObject *o, const wchar_t *s);
extern DLLEXPORT(void) setVObjectIntegerValue(VObject *o, unsigned int i);
extern DLLEXPORT(void) setVObjectLongValue(VObject *o, unsigned long l);
extern DLLEXPORT(void) setVObjectAnyValue(VObject *o, void *t);
extern DLLEXPORT(VObject*) setValueWithSize(VObject *prop, void *val, unsigned int size);
extern DLLEXPORT(VObject*) setValueWithSize_(VObject *prop, void *val, unsigned int size);

extern DLLEXPORT(const char*) vObjectName(VObject *o);
extern DLLEXPORT(const char*) vObjectStringZValue(VObject *o);
extern DLLEXPORT(const wchar_t*) vObjectUStringZValue(VObject *o);
extern DLLEXPORT(unsigned int) vObjectIntegerValue(VObject *o);
extern DLLEXPORT(unsigned long) vObjectLongValue(VObject *o);
extern DLLEXPORT(void*) vObjectAnyValue(VObject *o);
extern DLLEXPORT(VObject*) vObjectVObjectValue(VObject *o);
extern DLLEXPORT(void) setVObjectVObjectValue(VObject *o, VObject *p);

extern DLLEXPORT(VObject*) addVObjectProp(VObject *o, VObject *p);
extern DLLEXPORT(VObject*) addProp(VObject *o, const char *id);
extern DLLEXPORT(VObject*) addProp_(VObject *o, const char *id);
extern DLLEXPORT(VObject*) addPropValue(VObject *o, const char *p, const char *v);
extern DLLEXPORT(VObject*) addPropSizedValue_(VObject *o, const char *p, const char *v, unsigned int size);
extern DLLEXPORT(VObject*) addPropSizedValue(VObject *o, const char *p, const char *v, unsigned int size);
extern DLLEXPORT(VObject*) addGroup(VObject *o, const char *g);
extern DLLEXPORT(void) addList(VObject **o, VObject *p);

extern DLLEXPORT(VObject*) isAPropertyOf(VObject *o, const char *id);

extern DLLEXPORT(VObject*) nextVObjectInList(VObject *o);
extern DLLEXPORT(void) initPropIterator(VObjectIterator *i, VObject *o);
extern DLLEXPORT(int) moreIteration(VObjectIterator *i);
extern DLLEXPORT(VObject*) nextVObject(VObjectIterator *i);

extern DLLEXPORT(char*) writeMemVObject(char *s, int *len, VObject *o);
extern DLLEXPORT(char*) writeMemVObjects(char *s, int *len, VObject *list);

extern DLLEXPORT(const char*) lookupStr(const char *s);
extern DLLEXPORT(void) cleanStrTbl();

extern DLLEXPORT(void) cleanVObject(VObject *o);
extern DLLEXPORT(void) cleanVObjects(VObject *list);

extern DLLEXPORT(const char*) lookupProp(const char* str);
extern DLLEXPORT(const char*) lookupProp_(const char* str);

extern DLLEXPORT(wchar_t*) fakeUnicode(const char *ps, int *bytes);
extern DLLEXPORT(int) uStrLen(const wchar_t *u);
extern DLLEXPORT(char*) fakeCString(const wchar_t *u);

extern DLLEXPORT(void) printVObjectToFile(char *fname,VObject *o);
extern DLLEXPORT(void) printVObjectsToFile(char *fname,VObject *list);
extern DLLEXPORT(void) writeVObjectToFile(char *fname, VObject *o);
extern DLLEXPORT(void) writeVObjectsToFile(char *fname, VObject *list);

extern DLLEXPORT(int) vObjectValueType(VObject *o);

/* return type of vObjectValueType: */
#define VCVT_NOVALUE	0
	/* if the VObject has no value associated with it. */
#define VCVT_STRINGZ	1
	/* if the VObject has value set by setVObjectStringZValue. */
#define VCVT_USTRINGZ	2
	/* if the VObject has value set by setVObjectUStringZValue. */
#define VCVT_UINT		3
	/* if the VObject has value set by setVObjectIntegerValue. */
#define VCVT_ULONG		4
	/* if the VObject has value set by setVObjectLongValue. */
#define VCVT_RAW		5
	/* if the VObject has value set by setVObjectAnyValue. */
#define VCVT_VOBJECT	6
	/* if the VObject has value set by setVObjectVObjectValue. */

extern const char** fieldedProp;

/* NOTE regarding printVObject and writeVObject

The functions below are not exported from the DLL because they
take a FILE* as a parameter, which cannot be passed across a DLL 
interface (at least that is my experience). Instead you can use
their companion functions which take file names or pointers
to memory. However, if you are linking this code into 
your build directly then you may find them a more convenient API
and you can go ahead and use them. If you try to use them with 
the DLL LIB you will get a link error.
*/
extern void printVObject(FILE *fp,VObject *o);
extern void writeVObject(FILE *fp, VObject *o);


#if defined(__CPLUSPLUS__) || defined(__cplusplus)
}
#endif

#endif /* __VOBJECT_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\app.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	app.c - Windows command line argument functions
////

#include "winlocal.h"

#include <stdlib.h>

#include "app.h"
#include "file.h"
#include "loadlib.h"
#include "mem.h"
#include "str.h"
#include "sys.h"
#include "trace.h"

////
//	private definitions
////

// app control struct
//
typedef struct APP
{
	DWORD dwVersion;
	HINSTANCE hInst;
	HTASK hTask;
	LPTSTR lpszFileName;
	LPTSTR lpszDirectory;
	LPTSTR lpszProfile;
	LPTSTR lpszName;
	HWND hwndMain;
	BOOL fCtl3dEnabled;
	HINSTANCE hInstCtl3d;
} APP, FAR *LPAPP;

// helper functions
//
static LPAPP AppGetPtr(HAPP hApp);
static HAPP AppGetHandle(LPAPP lpApp);

////
//	public functions
////

// AppInit - initialize app engine
//		<dwVersion>			(i) must be APP_VERSION
// 		<hInst>				(i) instance handle of calling module
// return handle (NULL if error)
//
HAPP DLLEXPORT WINAPI AppInit(DWORD dwVersion, HINSTANCE hInst)
{
	BOOL fSuccess = TRUE;
	LPAPP lpApp = NULL;

	if (dwVersion != APP_VERSION)
		fSuccess = TraceFALSE(NULL);
	
	else if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpApp = (LPAPP) MemAlloc(NULL, sizeof(APP), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		TCHAR szPath[_MAX_PATH];
		TCHAR szDrive[_MAX_DRIVE];
		TCHAR szDir[_MAX_DIR];
		TCHAR szFname[_MAX_FNAME];
		TCHAR szExt[_MAX_EXT];

		lpApp->dwVersion = dwVersion;
		lpApp->hInst = hInst;
		lpApp->hTask = GetCurrentTask();
		lpApp->lpszFileName = NULL;
		lpApp->lpszDirectory = NULL;
		lpApp->lpszProfile = NULL;
		lpApp->lpszName = NULL;
		lpApp->hwndMain = NULL;
#ifdef _WIN32
		lpApp->fCtl3dEnabled = (BOOL) (SysGetWindowsVersion() >= 400);
#else
		lpApp->fCtl3dEnabled = FALSE;
#endif
		lpApp->hInstCtl3d = NULL;

		// get the full path of app executable
		//
		if (GetModuleFileName(hInst, szPath, SIZEOFARRAY(szPath)) <= 0)
			fSuccess = TraceFALSE(NULL);

		else if ((lpApp->lpszFileName = StrDup(szPath)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if (FileSplitPath(szPath,
			szDrive, szDir, szFname, szExt) != 0)
			fSuccess = TraceFALSE(NULL);

		// get default app name
		//
		else if ((lpApp->lpszName = StrDup(szFname)) == NULL)
			fSuccess = TraceFALSE(NULL);

		// construct path to app directory
		//
		else if (FileMakePath(szPath,
			szDrive, szDir, NULL, NULL) != 0)
			fSuccess = TraceFALSE(NULL);

		else if ((lpApp->lpszDirectory = StrDup(szPath)) == NULL)
			fSuccess = TraceFALSE(NULL);

		// construct path to app ini file
		//
		else if (AppDirectoryIsReadOnly(AppGetHandle(lpApp)) &&
			FileMakePath(szPath, NULL, NULL, szFname, TEXT("ini")) != 0)
			fSuccess = TraceFALSE(NULL);

		else if (!AppDirectoryIsReadOnly(AppGetHandle(lpApp)) &&
			FileMakePath(szPath, szDrive, szDir, szFname, TEXT("ini")) != 0)
			fSuccess = TraceFALSE(NULL);

		else if ((lpApp->lpszProfile = StrDup(szPath)) == NULL)
			fSuccess = TraceFALSE(NULL);
	}

	if (!fSuccess)
	{
		AppTerm(AppGetHandle(lpApp));
		lpApp = NULL;
	}

	return fSuccess ? AppGetHandle(lpApp) : NULL;
}

// AppTerm - shut down app engine
//		<hApp>				(i) handle returned from AppInit
// return 0 if success
//
int DLLEXPORT WINAPI AppTerm(HAPP hApp)
{
	BOOL fSuccess = TRUE;
	LPAPP lpApp;

	if ((lpApp = AppGetPtr(hApp)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		// shut down Ctl3d if necessary
		//
		if (AppEnable3dControls(hApp, FALSE, 0) != 0)
			fSuccess = TraceFALSE(NULL);

		if (lpApp->lpszFileName != NULL)
		{
			StrDupFree(lpApp->lpszFileName);
			lpApp->lpszFileName = NULL;
		}

		if (lpApp->lpszDirectory != NULL)
		{
			StrDupFree(lpApp->lpszDirectory);
			lpApp->lpszDirectory = NULL;
		}

		if (lpApp->lpszProfile != NULL)
		{
			StrDupFree(lpApp->lpszProfile);
			lpApp->lpszProfile = NULL;
		}

		if (lpApp->lpszName != NULL)
		{
			StrDupFree(lpApp->lpszName);
			lpApp->lpszName = NULL;
		}

		if ((lpApp = MemFree(NULL, lpApp)) != NULL)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// AppGetInstance - get instance handle
//		<hApp>				(i) handle returned from AppInit
// return instance handle, NULL if error
//
HINSTANCE DLLEXPORT WINAPI AppGetInstance(HAPP hApp)
{
	BOOL fSuccess = TRUE;
	LPAPP lpApp;
	HINSTANCE hInst;

	if ((lpApp = AppGetPtr(hApp)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
		hInst = lpApp->hInst;

	return fSuccess ? hInst : NULL;
}

// AppGetFileName - get full path of application executable
//		<hApp>				(i) handle returned from AppInit
// return pointer to app file name, NULL if error
//
LPCTSTR DLLEXPORT WINAPI AppGetFileName(HAPP hApp)
{
	BOOL fSuccess = TRUE;
	LPAPP lpApp;
	LPTSTR lpszFileName;

	if ((lpApp = AppGetPtr(hApp)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
		lpszFileName = lpApp->lpszFileName;

	return fSuccess ? lpszFileName : NULL;
}

// AppGetDirectory - get drive and directory of application executable
//		<hApp>				(i) handle returned from AppInit
// return pointer to app path, NULL if error
//
LPCTSTR DLLEXPORT WINAPI AppGetDirectory(HAPP hApp)
{
	BOOL fSuccess = TRUE;
	LPAPP lpApp;
	LPTSTR lpszDirectory;

	if ((lpApp = AppGetPtr(hApp)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
		lpszDirectory = lpApp->lpszDirectory;

	return fSuccess ? lpszDirectory : NULL;
}

// AppDirectoryIsReadOnly - test if application directory is read-only
//		<hApp>				(i) handle returned from AppInit
// return TRUE if read-only, otherwise FALSE
//
BOOL DLLEXPORT WINAPI AppDirectoryIsReadOnly(HAPP hApp)
{
	BOOL fSuccess = TRUE;
	LPAPP lpApp;
	BOOL fIsReadOnly;
	TCHAR szPath[_MAX_PATH];

	if ((lpApp = AppGetPtr(hApp)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (FileMakePath(szPath, NULL,
		AppGetDirectory(hApp), TEXT("readonly"), TEXT("ini")) != 0)
		fSuccess = TraceFALSE(NULL);

	else
	{
		// [ReadOnly]
		// ReadOnly=1
		//
		fIsReadOnly = (BOOL) GetPrivateProfileInt(TEXT("ReadOnly"),
			TEXT("ReadOnly"), 0, szPath);
	}

	return fSuccess ? fIsReadOnly : FALSE;
}

// AppGetProfile - get ini filename of application
//		<hApp>				(i) handle returned from AppInit
// return pointer to app profile, NULL if error
//
// NOTE: by default, the filename returned by this function
// has the same file path and name as the application executable,
// with a ".ini" extension.  If the application directory is
// read-only, the Windows directory is used instead.
// To override the default, use the AppSetProfile() function.
//
LPCTSTR DLLEXPORT WINAPI AppGetProfile(HAPP hApp)
{
	BOOL fSuccess = TRUE;
	LPAPP lpApp;
	LPTSTR lpszProfile;

	if ((lpApp = AppGetPtr(hApp)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
		lpszProfile = lpApp->lpszProfile;

	return fSuccess ? lpszProfile : NULL;
}

// AppSetProfile - set ini filename of application
//		<hApp>				(i) handle returned from AppInit
//		<lpszProfile>		(i) ini filename
// return 0 if success
//
int DLLEXPORT WINAPI AppSetProfile(HAPP hApp, LPCTSTR lpszProfile)
{
	BOOL fSuccess = TRUE;
	LPAPP lpApp;

	if ((lpApp = AppGetPtr(hApp)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		// save old profile
		//
		LPTSTR lpszProfileOld = lpApp->lpszProfile;

		// set new profile
		//
		if ((lpApp->lpszProfile = StrDup(lpszProfile)) == NULL)
		{
			fSuccess = TraceFALSE(NULL);

			// restore old profile if error
			//
			lpApp->lpszProfile = lpszProfileOld;
		}

		// free old profile
		//
		else if (lpszProfileOld != NULL)
		{
			StrDupFree(lpszProfileOld);
			lpszProfileOld = NULL;
		}
	}

	return fSuccess ? 0 : -1;
}

// AppGetName - get name of application
//		<hApp>				(i) handle returned from AppInit
// return pointer to app profile, NULL if error
//
// NOTE: by default, the name returned by this function
// has the same root name as the application executable,
// with no extension.  To override the default, use the
// AppSetName() function.
//
LPCTSTR DLLEXPORT WINAPI AppGetName(HAPP hApp)
{
	BOOL fSuccess = TRUE;
	LPAPP lpApp;
	LPTSTR lpszName;

	if ((lpApp = AppGetPtr(hApp)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
		lpszName = lpApp->lpszName;

	return fSuccess ? lpszName : NULL;
}

// AppSetName - set name of application
//		<hApp>				(i) handle returned from AppInit
//		<lpszName>			(i) application name
// return 0 if success
//
int DLLEXPORT WINAPI AppSetName(HAPP hApp, LPCTSTR lpszName)
{
	BOOL fSuccess = TRUE;
	LPAPP lpApp;

	if ((lpApp = AppGetPtr(hApp)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		// save old name
		//
		LPTSTR lpszNameOld = lpApp->lpszName;

		// set new name
		//
		if ((lpApp->lpszName = StrDup(lpszName)) == NULL)
		{
			fSuccess = TraceFALSE(NULL);

			// restore old name if error
			//
			lpApp->lpszName = lpszNameOld;
		}

		// free old name
		//
		else if (lpszNameOld != NULL)
		{
			StrDupFree(lpszNameOld);
			lpszNameOld = NULL;
		}
	}

	return fSuccess ? 0 : -1;
}

// AppGetMainWnd - get main window of application
//		<hApp>				(i) handle returned from AppInit
// return window handle, NULL if error or none
//
HWND DLLEXPORT WINAPI AppGetMainWnd(HAPP hApp)
{
	BOOL fSuccess = TRUE;
	LPAPP lpApp;
	HWND hwndMain;

	if ((lpApp = AppGetPtr(hApp)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
		hwndMain = lpApp->hwndMain;

	return fSuccess ? hwndMain : NULL;
}

// AppSetMainWnd - set main window of application
//		<hApp>				(i) handle returned from AppInit
//		<hwndMain>			(i) handle to main window
// return 0 if success
//
int DLLEXPORT WINAPI AppSetMainWnd(HAPP hApp, HWND hwndMain)
{
	BOOL fSuccess = TRUE;
	LPAPP lpApp;

	if ((lpApp = AppGetPtr(hApp)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
		lpApp->hwndMain = hwndMain;

	return fSuccess ? 0 : -1;
}

// ctl3d stuff
//
#ifdef _WIN32
#define CTL3D_LIBRARY TEXT("ctl3d32.dll")
#else
#define CTL3D_LIBRARY TEXT("ctl3dv2.dll")
#endif
typedef BOOL (WINAPI* LPFNCTL3D)();

// AppEnable3dControls - give standard controls a 3d appearance
//		<hApp>				(i) handle returned from AppInit
//		<fEnable>			(i) TRUE to enable, FALSE to disable
//		<dwFlags>			(i) control flags
//			0					reserved; must be zero
// return 0 if success, -1 if error
//
int DLLEXPORT WINAPI AppEnable3dControls(HAPP hApp, BOOL fEnable, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPAPP lpApp;

	if ((lpApp = AppGetPtr(hApp)) == NULL)
		fSuccess = TraceFALSE(NULL);

#ifdef _WIN32
	// nothing to do if OS already supports 3d controls
	//
	else if (SysGetWindowsVersion() >= 400)
		lpApp->fCtl3dEnabled = fEnable;
#endif

	// enable 3d controls unless they already are enabled
	//
	else if (fEnable && !lpApp->fCtl3dEnabled)
	{
		LPFNCTL3D lpfnCtl3dRegister;
		LPFNCTL3D lpfnCtl3dAutoSubclass;

		if (lpApp->hInstCtl3d != NULL)
			fSuccess = TraceFALSE(NULL);

		else if ((lpApp->hInstCtl3d = LoadLibraryPath(CTL3D_LIBRARY,
			NULL, 0)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if ((lpfnCtl3dRegister = (LPFNCTL3D) GetProcAddress(
			lpApp->hInstCtl3d, "Ctl3dRegister")) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if (!((*lpfnCtl3dRegister)(lpApp->hInstCtl3d)))
			fSuccess = TraceFALSE(NULL);
		
		else if ((lpfnCtl3dAutoSubclass = (LPFNCTL3D) GetProcAddress(
			lpApp->hInstCtl3d, "Ctl3dAutoSubclass")) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if (!((*lpfnCtl3dAutoSubclass)(lpApp->hInstCtl3d)))
			fSuccess = TraceFALSE(NULL);

		else
			lpApp->fCtl3dEnabled = TRUE;
	}

	// disable 3d controls unless they already are disabled
	//
	else if (!fEnable && lpApp->fCtl3dEnabled)
	{
		LPFNCTL3D lpfnCtl3dUnregister;

		if (lpApp->hInstCtl3d == NULL)
			fSuccess = TraceFALSE(NULL);

		else if ((lpfnCtl3dUnregister = (LPFNCTL3D) GetProcAddress(
			lpApp->hInstCtl3d, "Ctl3dUnregister")) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if (!((*lpfnCtl3dUnregister)(lpApp->hInstCtl3d)))
			fSuccess = TraceFALSE(NULL);
		
#ifdef _WIN32
		else if (!FreeLibrary(lpApp->hInstCtl3d))
		{
			fSuccess = TraceFALSE(NULL);
		  	TracePrintf_2(NULL, 5,
		  		TEXT("FreeLibrary(\"%s\") failed (%lu)\n"),
				(LPTSTR) CTL3D_LIBRARY,
		  		(unsigned long) GetLastError());
		}
#else
		else if (FreeLibrary(lpApp->hInstCtl3d), FALSE)
			;
#endif
		else
		{
			lpApp->hInstCtl3d = NULL;
			lpApp->fCtl3dEnabled = FALSE;
		}
	}

	return fSuccess ? 0 : -1;
}

// AppIs3dControlsEnabled - return TRUE if 3d controls enabled
//		<hApp>				(i) handle returned from AppInit
// return TRUE if 3d controls enabled, otherwise FALSE
//
BOOL DLLEXPORT WINAPI AppIs3dControlsEnabled(HAPP hApp)
{
	BOOL fSuccess = TRUE;
	LPAPP lpApp;
	BOOL fEnabled;

	if ((lpApp = AppGetPtr(hApp)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
		fEnabled = lpApp->fCtl3dEnabled;

	return fSuccess ? fEnabled : FALSE;
}

// AppOnSysColorChange - handler for WM_SYSCOLORCHANGE message
//		<hApp>				(i) handle returned from AppInit
// return 0 if success
//
LRESULT DLLEXPORT WINAPI AppOnSysColorChange(HAPP hApp)
{
	BOOL fSuccess = TRUE;
	LPAPP lpApp;

	if ((lpApp = AppGetPtr(hApp)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpApp->fCtl3dEnabled)
	{
		LPFNCTL3D lpfnCtl3dColorChange;

		if (lpApp->hInstCtl3d == NULL)
			fSuccess = TraceFALSE(NULL);

		else if ((lpfnCtl3dColorChange = (LPFNCTL3D) GetProcAddress(
			lpApp->hInstCtl3d, "Ctl3dColorChange")) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if (!((*lpfnCtl3dColorChange)()))
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}	

////
//	helper functions
////

// AppGetPtr - verify that arg handle is valid,
//		<hApp>				(i) handle returned from AppInit
// return corresponding arg pointer (NULL if error)
//
static LPAPP AppGetPtr(HAPP hApp)
{
	BOOL fSuccess = TRUE;
	LPAPP lpApp;

	if ((lpApp = (LPAPP) hApp) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadWritePtr(lpApp, sizeof(APP)))
		fSuccess = TraceFALSE(NULL);

#ifdef CHECKTASK
	// make sure current task owns the arg handle
	//
	else if (lpApp->hTask != GetCurrentTask())
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? lpApp : NULL;
}

// AppGetHandle - verify that arg pointer is valid,
//		<lpApp>				(i) pointer to APP struct
// return corresponding arg handle (NULL if error)
//
static HAPP AppGetHandle(LPAPP lpApp)
{
	BOOL fSuccess = TRUE;
	HAPP hApp;

	if ((hApp = (HAPP) lpApp) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hApp : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\arg.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	arg.c - Windows command line argument functions
////

#include "winlocal.h"

#include <stdlib.h>

#include "arg.h"
#include "mem.h"
#include "str.h"
#include "trace.h"

////
//	private definitions
////

#define MAXARGS 64

// arg control struct
//
typedef struct ARG
{
	DWORD dwVersion;
	HINSTANCE hInst;
	HTASK hTask;
	LPTSTR lpszCmdLine;
	LPTSTR lpszArgs;
	int argc;
	LPTSTR argv[MAXARGS];
} ARG, FAR *LPARG;

// helper functions
//
static LPARG ArgGetPtr(HARG hArg);
static HARG ArgGetHandle(LPARG lpArg);

////
//	public functions
////

// ArgInit - initialize arg engine, converting <lpszCmdLine> to argc and argv
//		<dwVersion>			(i) must be ARG_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<lpszCmdLine>		(i) command line from WinMain()
// return handle (NULL if error)
//
HARG DLLEXPORT WINAPI ArgInit(DWORD dwVersion, HINSTANCE hInst, LPCTSTR lpszCmdLine)
{
	BOOL fSuccess = TRUE;
	LPARG lpArg = NULL;

	if (dwVersion != ARG_VERSION)
		fSuccess = TraceFALSE(NULL);
	
	else if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);
                        
                        
	else if (lpszCmdLine == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpArg = (LPARG) MemAlloc(NULL, sizeof(ARG), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
// #ifndef _WIN32
		TCHAR szModuleFileName[_MAX_PATH];
		size_t sizModuleFileName;
// #endif
		LPTSTR lpsz;

		lpArg->dwVersion = dwVersion;
		lpArg->hInst = hInst;
		lpArg->hTask = GetCurrentTask();
		lpArg->lpszCmdLine = NULL;
		lpArg->lpszArgs = NULL;
		lpArg->argc = 0;
		lpArg->argv[0] = NULL;

// #ifndef _WIN32
		// the 0th argument is always the name of the executable
		//
		sizModuleFileName = GetModuleFileName(hInst,
			szModuleFileName, SIZEOFARRAY(szModuleFileName));

		if ((lpArg->argv[lpArg->argc++] = StrDup(szModuleFileName)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else
// #endif

		// save a copy of the command line
		//
		if ((lpArg->lpszCmdLine = StrDup(lpszCmdLine)) == NULL)
			fSuccess = TraceFALSE(NULL);

		// save another copy of the command line to parse into args
		//
		else if ((lpArg->lpszArgs = StrDup(lpszCmdLine)) == NULL)
			fSuccess = TraceFALSE(NULL);

		lpsz = lpArg->lpszArgs;
		while (fSuccess)
		{
			// skip over leading white space
			//
			while (ChrIsSpace(*lpsz))
				lpsz = StrNextChr(lpsz);

			// check for end of command line
			//
			if (*lpsz == '\0')
				break;

			if (*lpsz == '\"')
			{
				// save pointer to beginning of argument, increment counter
				//
				if (lpArg->argc < MAXARGS)
					lpArg->argv[lpArg->argc++] = lpsz = StrNextChr(lpsz);

				// skip over argument body
				//
				while (*lpsz != '\0' && *lpsz != '\"')
					lpsz = StrNextChr(lpsz);
			}

			else
			{
				// save pointer to beginning of argument, increment counter
				//
				if (lpArg->argc < MAXARGS)
					lpArg->argv[lpArg->argc++] = lpsz;

				// skip over argument body
				//
				while (*lpsz != '\0' && !ChrIsSpace(*lpsz))
					lpsz = StrNextChr(lpsz);
			}

			// nul-terminate the argument
			//
			if (*lpsz != '\0')
			{
				*lpsz = '\0';
				++lpsz; // lpsz = StrNextChr(lpsz) will not skip over \0
			}
		}
	}

	if (!fSuccess)
	{
		ArgTerm(ArgGetHandle(lpArg));
		lpArg = NULL;
	}

	return fSuccess ? ArgGetHandle(lpArg) : NULL;
}

// ArgTerm - shut down arg engine
//		<hArg>				(i) handle returned from ArgInit
// return 0 if success
//
int DLLEXPORT WINAPI ArgTerm(HARG hArg)
{
	BOOL fSuccess = TRUE;
	LPARG lpArg;

	if ((lpArg = ArgGetPtr(hArg)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		if (lpArg->lpszCmdLine != NULL)
		{
			StrDupFree(lpArg->lpszCmdLine);
			lpArg->lpszCmdLine = NULL;
		}

		if (lpArg->lpszArgs != NULL)
		{
			StrDupFree(lpArg->lpszArgs);
			lpArg->lpszArgs = NULL;
		}

// #ifndef _WIN32
		if (lpArg->argv[0] != NULL)
		{
			StrDupFree(lpArg->argv[0]);
			lpArg->argv[0] = NULL;
		}
// #endif

		if ((lpArg = MemFree(NULL, lpArg)) != NULL)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// ArgGetCount - get argument count (argc)
//		<hArg>				(i) handle returned from ArgInit
// return number of arguments (argc) (0 if error)
// there should always be at least one, since argv[0] is .EXE file name
//
int DLLEXPORT WINAPI ArgGetCount(HARG hArg)
{
	BOOL fSuccess = TRUE;
	LPARG lpArg;

	if ((lpArg = ArgGetPtr(hArg)) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? lpArg->argc : 0;
}

// ArgGet - get specified argument
//		<hArg>				(i) handle returned from ArgInit
//		<iArg>				(i) zero based index of argument to get
//		<lpszArg>			(o) buffer to hold argument argv[iArg]
//			NULL				do not copy; return static pointer instead
//		<sizArg>			(i) size of buffer
// return pointer to argument (NULL if error)
//
LPTSTR DLLEXPORT WINAPI ArgGet(HARG hArg, int iArg, LPTSTR lpszArg, int sizArg)
{
	BOOL fSuccess = TRUE;
	LPARG lpArg;

	if ((lpArg = ArgGetPtr(hArg)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// make sure iArg is not out of range
	//
	else if (iArg < 0 || iArg >= lpArg->argc)
		fSuccess = TraceFALSE(NULL);

	else
	{
		// copy arg if destination buffer specified
		//
		if (lpszArg != NULL)
			StrNCpy(lpszArg, lpArg->argv[iArg], sizArg);

		// otherwise just point to static copy of arg
		//
		else
			lpszArg = lpArg->argv[iArg];
	}

	return fSuccess ? lpszArg : NULL;
}


////
//	helper functions
////

// ArgGetPtr - verify that arg handle is valid,
//		<hArg>				(i) handle returned from ArgInit
// return corresponding arg pointer (NULL if error)
//
static LPARG ArgGetPtr(HARG hArg)
{
	BOOL fSuccess = TRUE;
	LPARG lpArg;

	if ((lpArg = (LPARG) hArg) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadWritePtr(lpArg, sizeof(ARG)))
		fSuccess = TraceFALSE(NULL);

#ifdef CHECKTASK
	// make sure current task owns the arg handle
	//
	else if (lpArg->hTask != GetCurrentTask())
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? lpArg : NULL;
}

// ArgGetHandle - verify that arg pointer is valid,
//		<lpArg>				(i) pointer to ARG struct
// return corresponding arg handle (NULL if error)
//
static HARG ArgGetHandle(LPARG lpArg)
{
	BOOL fSuccess = TRUE;
	HARG hArg;

	if ((hArg = (HARG) lpArg) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hArg : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\app.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// app.h - interface for command line argument functions in app.c
////

#ifndef __APP_H__
#define __APP_H__

#include "winlocal.h"

#define APP_VERSION 0x00000106

// handle to app engine
//
DECLARE_HANDLE32(HAPP);

#ifdef __cplusplus
extern "C" {
#endif

// AppInit - initialize app engine
//		<dwVersion>			(i) must be APP_VERSION
// 		<hInst>				(i) instance handle of calling module
// return handle (NULL if error)
//
HAPP DLLEXPORT WINAPI AppInit(DWORD dwVersion, HINSTANCE hInst);

// AppTerm - shut down app engine
//		<hApp>				(i) handle returned from AppInit
// return 0 if success
//
int DLLEXPORT WINAPI AppTerm(HAPP hApp);

// AppGetInstance - get instance handle
//		<hApp>				(i) handle returned from AppInit
// return instance handle, NULL if error
//
HINSTANCE DLLEXPORT WINAPI AppGetInstance(HAPP hApp);

// AppGetFileName - get full path of application executable
//		<hApp>				(i) handle returned from AppInit
// return pointer to app file name, NULL if error
//
LPCTSTR DLLEXPORT WINAPI AppGetFileName(HAPP hApp);

// AppGetDirectory - get drive and directory of application executable
//		<hApp>				(i) handle returned from AppInit
// return pointer to app path, NULL if error
//
LPCTSTR DLLEXPORT WINAPI AppGetDirectory(HAPP hApp);

// AppDirectoryIsReadOnly - test if application directory is read-only
//		<hApp>				(i) handle returned from AppInit
// return TRUE if read-only, otherwise FALSE
//
BOOL DLLEXPORT WINAPI AppDirectoryIsReadOnly(HAPP hApp);

// AppGetProfile - get ini filename of application
//		<hApp>				(i) handle returned from AppInit
// return pointer to app profile, NULL if error
//
// NOTE: by default, the filename returned by this function
// has the same file path and name as the application executable,
// with a ".ini" extension.  If the application directory is
// read-only, the Windows directory is used instead.
// To override the default, use the AppSetProfile() function.
//
LPCTSTR DLLEXPORT WINAPI AppGetProfile(HAPP hApp);

// AppSetProfile - set ini filename of application
//		<hApp>				(i) handle returned from AppInit
//		<lpszProfile>		(i) ini filename
// return 0 if success
//
int DLLEXPORT WINAPI AppSetProfile(HAPP hApp, LPCTSTR lpszProfile);

// AppGetName - get name of application
//		<hApp>				(i) handle returned from AppInit
// return pointer to app profile, NULL if error
//
// NOTE: by default, the name returned by this function
// has the same root name as the application executable,
// with no extension.  To override the default, use the
// AppSetName() function.
//
LPCTSTR DLLEXPORT WINAPI AppGetName(HAPP hApp);

// AppSetName - set name of application
//		<hApp>				(i) handle returned from AppInit
//		<lpszName>			(i) application name
// return 0 if success
//
int DLLEXPORT WINAPI AppSetName(HAPP hApp, LPCTSTR lpszName);

// AppGetMainWnd - get main window of application
//		<hApp>				(i) handle returned from AppInit
// return window handle, NULL if error or none
//
HWND DLLEXPORT WINAPI AppGetMainWnd(HAPP hApp);

// AppSetMainWnd - set main window of application
//		<hApp>				(i) handle returned from AppInit
//		<hwndMain>			(i) handle to main window
// return 0 if success
//
int DLLEXPORT WINAPI AppSetMainWnd(HAPP hApp, HWND hwndMain);

// AppEnable3dControls - give standard controls a 3d appearance
//		<hApp>				(i) handle returned from AppInit
//		<fEnable>			(i) TRUE to enable, FALSE to disable
//		<dwFlags>			(i) control flags
//			0					reserved; must be zero
// return 0 if success, -1 if error, 1 if OS already enables 3d controls
//
int DLLEXPORT WINAPI AppEnable3dControls(HAPP hApp, BOOL fEnable, DWORD dwFlags);

// AppIs3dControlsEnabled - return TRUE if 3d controls enabled
//		<hApp>				(i) handle returned from AppInit
// return TRUE if 3d controls enabled, otherwise FALSE
//
BOOL DLLEXPORT WINAPI AppIs3dControlsEnabled(HAPP hApp);

// AppOnSysColorChange - handler for WM_SYSCOLORCHANGE message
//		<hApp>				(i) handle returned from AppInit
// return 0 if success
//
LRESULT DLLEXPORT WINAPI AppOnSysColorChange(HAPP hApp);

#ifdef __cplusplus
}
#endif

#endif // __APP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\arg.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// arg.h - interface for command line argument functions in arg.c
////

#ifndef __ARG_H__
#define __ARG_H__

#include "winlocal.h"

#define ARG_VERSION 0x00000100

// handle to arg engine
//
DECLARE_HANDLE32(HARG);

#ifdef __cplusplus
extern "C" {
#endif

// ArgInit - initialize arg engine, converting <lpszCmdLine> to argc and argv
//		<dwVersion>			(i) must be ARG_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<lpszCmdLine>		(i) command line from WinMain()
// return handle (NULL if error)
//
HARG DLLEXPORT WINAPI ArgInit(DWORD dwVersion, HINSTANCE hInst, LPCTSTR lpszCmdLine);

// ArgTerm - shut down arg engine
//		<hArg>				(i) handle returned from ArgInit
// return 0 if success
//
int DLLEXPORT WINAPI ArgTerm(HARG hArg);

// ArgGetCount - get argument count (argc)
//		<hArg>				(i) handle returned from ArgInit
// return number of arguments (argc) (0 if error)
// there should always be at least one, since argv[0] is .EXE file name
//
int DLLEXPORT WINAPI ArgGetCount(HARG hArg);

// ArgGet - get specified argument
//		<hArg>				(i) handle returned from ArgInit
//		<iArg>				(i) zero based index of argument to get
//		<lpszArg>			(o) buffer to hold argument argv[iArg]
//			NULL				do not copy; return static pointer instead
//		<sizArg>			(i) size of buffer
// return pointer to argument (NULL if error)
//
LPTSTR DLLEXPORT WINAPI ArgGet(HARG hArg, int iArg, LPTSTR lpszArg, int sizArg);

#ifdef __cplusplus
}
#endif

#endif // __ARG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\array.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// array.h - interface for array functions in array.c
////

#ifndef __ARRAY_H__
#define __ARRAY_H__

#include "winlocal.h"

#define ARRAY_VERSION 0x00000106

// handle to a array
//
DECLARE_HANDLE32(HARRAY);

// array data element
//
typedef LPVOID ARRAYELEM, FAR *LPARRAYELEM;

// type required to hold the max number of array elements
//
typedef long ARRAYSIZE_T;

////
// array constructor and destructor functions
////

#ifdef __cplusplus
extern "C" {
#endif

// ArrayCreate - array constructor (array is initially empty)
// 		<dwVersion>			(i) must be ARRAY_VERSION
//		<hInst>				(i) instance handle of calling module
// return new array handle (NULL if error)
//
HARRAY DLLEXPORT WINAPI ArrayCreate(DWORD dwVersion, HINSTANCE hInst);

// ArrayDestroy - array destructor
//		<hArray>			(i) handle returned from ArrayCreate
// return 0 if success
//
int DLLEXPORT WINAPI ArrayDestroy(HARRAY hArray);

////
// array size functions
////

// ArrayGetSize - get array size
//		<hArray>			(i) handle returned from ArrayCreate
// return size of array (0 if empty, -1 if error)
// array indexes are zero-based, so the size is 1 greater than largest index
//
ARRAYSIZE_T DLLEXPORT WINAPI ArrayGetSize(HARRAY hArray);

// ArrayGetUpperBound - get array upper bound
//		<hArray>			(i) handle returned from ArrayCreate
// return largest valid array index (-1 if empty, -2 if error)
//
ARRAYSIZE_T DLLEXPORT WINAPI ArrayGetUpperBound(HARRAY hArray);

// ArraySetSize - establish new size and grow amount for array
//		<hArray>			(i) handle returned from ArrayCreate
// 		<nNewSize>			(i) new array size (number of elements)
//			0					make empty array
//		<nGrowBy>			(i) when array needs to grow, grow by this amount
//			0					use default grow amount
//			-1					leave grow amount unchanged
// return 0 if success
//
int DLLEXPORT WINAPI ArraySetSize(HARRAY hArray, ARRAYSIZE_T nNewSize, ARRAYSIZE_T nGrowBy);

////
//	array clean up functions
////

// ArrayFreeExtra - free unused memory above the array upper bound
//		<hArray>			(i) handle returned from ArrayCreate
// return 0 if success
//
int DLLEXPORT WINAPI ArrayFreeExtra(HARRAY hArray);

// ArrayRemoveAll - remove all elements from array
//		<hArray>			(i) handle returned from ArrayCreate
// return 0 if success
//
int DLLEXPORT WINAPI ArrayRemoveAll(HARRAY hArray);

////
// array element access functions
////

// ArrayGetAt - return data element at specified index
//		<hArray>			(i) handle returned from ArrayCreate
//		<nIndex>			(i) zero based index into array
// return data element value (NULL if error)
//
ARRAYELEM DLLEXPORT WINAPI ArrayGetAt(HARRAY hArray, ARRAYSIZE_T nIndex);

// ArraySetAt - set data element at specified index
//		<hArray>			(i) handle returned from ArrayCreate
//		<nIndex>			(i) zero based index into array
//		<elem>				(i) new data element value
// return 0 if success
//
int DLLEXPORT WINAPI ArraySetAt(HARRAY hArray, ARRAYSIZE_T nIndex, ARRAYELEM elem);

////
// array grow functions
////

// ArraySetAtGrow - set data element at specified index
//		<hArray>			(i) handle returned from ArrayCreate
//		<nIndex>			(i) zero based index into array
//		<elem>				(i) new data element value
// return 0 if success
// NOTE: array size is increased if nIndex > upper bound
//
int DLLEXPORT WINAPI ArraySetAtGrow(HARRAY hArray, ARRAYSIZE_T nIndex, ARRAYELEM elem);

// ArrayAdd - add data element to end of array
//		<hArray>			(i) handle returned from ArrayCreate
//		<elem>				(i) new data element value
// return index of added element (-1 if error)
//
ARRAYSIZE_T DLLEXPORT WINAPI ArrayAdd(HARRAY hArray, ARRAYELEM elem);

////
// array element insertion and removal
////

// ArrayInsertAt - insert <nCount> copies of <elem> at specified index
//		<hArray>			(i) handle returned from ArrayCreate
//		<nIndex>			(i) zero based index into array
//		<elem>				(i) new data element value
//		<nCount>			(i) number of elements to insert
// return 0 if success
// NOTE: elements at end of array will be shifted if necessary
//
int DLLEXPORT WINAPI ArrayInsertAt(HARRAY hArray, ARRAYSIZE_T nIndex, ARRAYELEM elem, ARRAYSIZE_T nCount);

// ArrayRemoveAt - remove <nCount> data elements at specified index
//		<hArray>			(i) handle returned from ArrayCreate
//		<nIndex>			(i) zero based index into array
//		<nCount>			(i) number of elements to remove
// return 0 if success
// NOTE: elements at end of array will be shifted if necessary
//
int DLLEXPORT WINAPI ArrayRemoveAt(HARRAY hArray, ARRAYSIZE_T nIndex, ARRAYSIZE_T nCount);

////
// array element sorting and searching
////

// ArraySort - sort array
//		<hArray>			(i) handle returned from ArrayCreate
//		<lpfnCompare>		(i) comparison function pointer
//			NULL				direct comparison (MemCmp)
// return 0 if success
//
int DLLEXPORT WINAPI ArraySort(HARRAY hArray,
	int (WINAPI *lpfnCompare)(const LPARRAYELEM lpElem1, const LPARRAYELEM lpElem2));

// ArraySearch - search array for matching element
//		<hArray>			(i) handle returned from ArrayCreate
//		<elem>				(i) data element to match
//		<nIndex>			(i) start search after this array index
//			-1					start search at start of array
//		<dwFlags>			(i) reserved; must be 0
//		<lpfnCompare>		(i) comparison function pointer
//			NULL				direct comparison (MemCmp)
// return index of matching element (-1 if no match, -2 if error)
//
ARRAYSIZE_T DLLEXPORT WINAPI ArraySearch(HARRAY hArray, ARRAYELEM elem,
	ARRAYSIZE_T nIndex, DWORD dwFlags,
	int (WINAPI *lpfnCompare)(const LPARRAYELEM lpElem1, const LPARRAYELEM lpElem2));

#ifdef __cplusplus
}
#endif

#endif // __ARRAY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\bscroll.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// bscroll.h - interface for bitmap scroll functions in bscroll.c
////

#ifndef __BSCROLL_H__
#define __BSCROLL_H__

#include "winlocal.h"

#define BSCROLL_VERSION 0x00000109

// handle to bscroll screen
//
DECLARE_HANDLE32(HBSCROLL);

// <dwFlags> values in BScrollInit
//
#define BSCROLL_BACKGROUND		0x00000000
#define BSCROLL_FOREGROUND		0x00000001
#define BSCROLL_UP				0x00000002
#define BSCROLL_DOWN			0x00000004
#define BSCROLL_LEFT			0x00000008
#define BSCROLL_RIGHT			0x00000010
#define BSCROLL_MOUSEMOVE		0x00000020
#define BSCROLL_FLIGHTSIM		0x00000040
#define BSCROLL_DRAG			0x00000080

#ifdef __cplusplus
extern "C" {
#endif

// BScrollInit - initialize bscroll engine
//		<dwVersion>			(i) must be BSCROLL_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<hwndParent>		(i) window which will own the bscroll window
//		<hbmpBackground>	(i) bitmap to display in background
//			NULL				no background bitmap
//		<hbmpForeground>	(i) bitmap to display in foreground
//			NULL				no foreground bitmap
//		<crTransparent>		(i) transparent color in foreground bitmap
//		<hPalette>			(i) palette
//			NULL				use default palette
//		<msScroll>			(i) scroll rate in milleseconds
//			0					do not scroll
//		<pelScroll>			(i) scroll amount in pixels
//		<dwReserved>		(i) reserved; must be zero
//		<dwFlags>			(i) control flags
//			BSCROLL_BACKGROUND	scroll the background bitmap (default)
//			BSCROLL_FOREGROUND	scroll the foreground bitmap
//			BSCROLL_UP			scroll the window up
//			BSCROLL_DOWN		scroll the window down
//			BSCROLL_LEFT		scroll the window left
//			BSCROLL_RIGHT		scroll the window right
//			BSCROLL_MOUSEMOVE	change scroll direction on mouse movement
//			BSCROLL_FLIGHTSIM	reverses BSCROLL_MOUSEMOVE direction
//			BSCROLL_DRAG		allow scrolling using mouse drag
// return handle (NULL if error)
//
// NOTE: BScrollInit creates the window but does not start the scrolling.
// See BScrollStart and BScrollStop
//
HBSCROLL DLLEXPORT WINAPI BScrollInit(DWORD dwVersion, HINSTANCE hInst,
	HWND hwndParent, HBITMAP hbmpBackground, HBITMAP hbmpForeground,
	COLORREF crTransparent, HPALETTE hPalette,	UINT msScroll,
	int pelScroll, DWORD dwReserved, DWORD dwFlags);

// BScrollTerm - shutdown bscroll engine
//		<hBScroll>			(i) handle returned from BScrollInit
// return 0 if success
//
int DLLEXPORT WINAPI BScrollTerm(HBSCROLL hBScroll);

// BScrollStart - start bscroll animation
//		<hBScroll>			(i) handle returned from BScrollInit
// return 0 if success
//
int DLLEXPORT WINAPI BScrollStart(HBSCROLL hBScroll);

// BScrollStop - stop bscroll animation
//		<hBScroll>			(i) handle returned from BScrollInit
// return 0 if success
//
int DLLEXPORT WINAPI BScrollStop(HBSCROLL hBScroll);

// BScrollGetWindowHandle - get bscroll screen window handle
//		<hBScroll>			(i) handle returned from BScrollInit
// return window handle (NULL if error)
//
HWND DLLEXPORT WINAPI BScrollGetWindowHandle(HBSCROLL hBScroll);

#ifdef __cplusplus
}
#endif

#endif // __BSCROLL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\calc.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	calc.c - calc functions
////

#include "winlocal.h"

#include <stdlib.h>

#include "calc.h"

////
//	private definitions
////

////
//	public functions
////

// MulDivU32 - 
//	<dwMult1>
//	<dwMult2>
//	<dwDiv>
//
DWORD DLLEXPORT WINAPI MulDivU32(DWORD dwMult1, DWORD dwMult2, DWORD dwDiv)
{
	DWORD dwResult;

	if (dwDiv == 0L)
		dwResult = ~((DWORD) 0);

	else
	{
		DWORD dwMult3 = 1L;

		// make sure calculation does not overflow
		//
		while (dwMult2 > 0 && dwMult1 >= ~((DWORD) 0) / dwMult2)
		{
			dwMult2 /= 10L;
			dwMult3 *= 10L;
		}

		// calculation
		//
		dwResult = dwMult1 * dwMult2 / dwDiv * dwMult3;
	}

	return dwResult;
}


// GreatestCommonDenominator - 
//	<a>
//	<b>
//
long DLLEXPORT WINAPI GreatestCommonDenominator(long a, long b)
{
	if (b == 0)
		return a;
	else
		return GreatestCommonDenominator(b, a % b);
}

// LeastCommonMultiple - 
//	<a>
//	<b>
//
long DLLEXPORT WINAPI LeastCommonMultiple(long a, long b)
{
	return (a * b) / GreatestCommonDenominator(a, b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\calc.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// calc.h - interface for calc functions in calc.c
////

#ifndef __CALC_H__
#define __CALC_H__

#include "winlocal.h"

#define CALC_VERSION 0x00000107

#define MULDIV16(x, y, z) MulDiv(x, y, z)
// #define MULDIV16(x, y, z) (__int16) (((__int32) ((_int32) (x) * (__int16) (y)) / (_int16) (z)))
#define MULDIVU32(x, y, z) MulDivU32(x, y, z)

#ifdef __cplusplus
extern "C" {
#endif

DWORD DLLEXPORT WINAPI MulDivU32(DWORD dwMult1, DWORD dwMult2, DWORD dwDiv);
long DLLEXPORT WINAPI GreatestCommonDenominator(long a, long b);
long DLLEXPORT WINAPI LeastCommonMultiple(long a, long b);

#ifdef __cplusplus
}
#endif

#endif // __CALC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\bscroll.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	bscroll.c - bitmap scroll functions
////

#include "winlocal.h"

#include <stdlib.h>

#include "bscroll.h"
#include "gfx.h"
#include "mem.h"
#include "sys.h"
#include "trace.h"
#include "wnd.h"

////
//	private definitions
////

#define BSCROLLCLASS TEXT("BScrollClass")

#define ID_TIMER_SCROLL 1024

#define BSCROLL_SCROLLING	0x00000001
#define BSCROLL_DRAGGING	0x00000002
#define BSCROLL_PAUSED		0x00000004

// bscroll control struct
//
typedef struct BSCROLL
{
	DWORD dwVersion;
	HINSTANCE hInst;
	HWND hwndParent;
	HTASK hTask;
	HBITMAP hbmpBackground; // $FIXUP - make copy during BScrollInit
	HBITMAP hbmpForeground; // $FIXUP - make copy during BScrollInit
	COLORREF crTransparent;
	HPALETTE hPalette;
	UINT msScroll;
	int pelScroll;
	DWORD dwReserved;
	DWORD dwFlags;
	HWND hwndBScroll;
	HDC hdcMem;
	HBITMAP hbmpMem;
	HBITMAP hbmpMemSave;
	HRGN hrgnLeft;
	HRGN hrgnRight;
	HRGN hrgnUp;
	HRGN hrgnDown;
	DWORD dwState;
	int xDrag;
	int yDrag;
} BSCROLL, FAR *LPBSCROLL;

// helper functions
//
LRESULT DLLEXPORT CALLBACK BScrollWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
static BOOL BScrollOnNCCreate(HWND hwnd, CREATESTRUCT FAR* lpCreateStruct);
static BOOL BScrollOnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct);
static void BScrollOnDestroy(HWND hwnd);
static void BScrollOnSize(HWND hwnd, UINT state, int cx, int cy);
static void BScrollOnPaint(HWND hwnd);
static void BScrollOnTimer(HWND hwnd, UINT id);
static void BScrollOnChar(HWND hwnd, UINT ch, int cRepeat);
static void BScrollOnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags);
static void BScrollOnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags);
static void BScrollOnRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags);
static void BScrollOnRButtonUp(HWND hwnd, int x, int y, UINT keyFlags);
static void BScrollOnMouseMove(HWND hwnd, int x, int y, UINT keyFlags);
static int BScrollChangeDirection(LPBSCROLL lpBScroll, int x, int y, DWORD dwFlags);
static LPBSCROLL BScrollGetPtr(HBSCROLL hBScroll);
static HBSCROLL BScrollGetHandle(LPBSCROLL lpBScroll);

////
//	public functions
////

// BScrollInit - initialize bscroll engine
//		<dwVersion>			(i) must be BSCROLL_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<hwndParent>		(i) window which will own the bscroll window
//		<hbmpBackground>	(i) bitmap to display in background
//			NULL				no background bitmap
//		<hbmpForeground>	(i) bitmap to display in foreground
//			NULL				no foreground bitmap
//		<crTransparent>		(i) transparent color in foreground bitmap
//		<hPalette>			(i) palette
//			NULL				use default palette
//		<msScroll>			(i) scroll rate in milleseconds
//			0					do not scroll
//		<pelScroll>			(i) scroll amount in pixels
//		<dwReserved>		(i) reserved; must be zero
//		<dwFlags>			(i) control flags
//			BSCROLL_BACKGROUND	scroll the background bitmap (default)
//			BSCROLL_FOREGROUND	scroll the foreground bitmap
//			BSCROLL_UP			scroll the window up
//			BSCROLL_DOWN		scroll the window down
//			BSCROLL_LEFT		scroll the window left
//			BSCROLL_RIGHT		scroll the window right
//			BSCROLL_MOUSEMOVE	change scroll direction on mouse movement
//			BSCROLL_FLIGHTSIM	reverses BSCROLL_MOUSEMOVE direction
//			BSCROLL_DRAG		allow scrolling using mouse drag
// return handle (NULL if error)
//
// NOTE: BScrollInit creates the window but does not start the scrolling.
// See BScrollStart and BScrollStop
//
HBSCROLL DLLEXPORT WINAPI BScrollInit(DWORD dwVersion, HINSTANCE hInst,
	HWND hwndParent, HBITMAP hbmpBackground, HBITMAP hbmpForeground,
	COLORREF crTransparent, HPALETTE hPalette,	UINT msScroll,
	int pelScroll, DWORD dwReserved, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPBSCROLL lpBScroll = NULL;
	WNDCLASS wc;
	RECT rcParent;
	int idChild = 1;

	if (dwVersion != BSCROLL_VERSION)
		fSuccess = TraceFALSE(NULL);
	
	else if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpBScroll = (LPBSCROLL) MemAlloc(NULL, sizeof(BSCROLL), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (!GetClientRect(hwndParent, &rcParent))
		fSuccess = TraceFALSE(NULL);

	else
	{
		lpBScroll->dwVersion = dwVersion;
		lpBScroll->hInst = hInst;
		lpBScroll->hTask = GetCurrentTask();
		lpBScroll->hwndParent = hwndParent;
		lpBScroll->hbmpBackground = hbmpBackground;
		lpBScroll->hbmpForeground = hbmpForeground;
		lpBScroll->crTransparent = crTransparent;
		lpBScroll->hPalette = hPalette;
		lpBScroll->msScroll = msScroll;
		lpBScroll->pelScroll = pelScroll;
		lpBScroll->dwReserved = dwReserved;
		lpBScroll->dwFlags = dwFlags;
		lpBScroll->hwndBScroll = NULL;
		lpBScroll->hdcMem = NULL;
		lpBScroll->hbmpMem = NULL;
		lpBScroll->hbmpMemSave = NULL;
		lpBScroll->hrgnLeft = NULL;
		lpBScroll->hrgnRight = NULL;
		lpBScroll->hrgnUp = NULL;
		lpBScroll->hrgnDown = NULL;
		lpBScroll->dwState = 0;
		lpBScroll->xDrag = -1;
		lpBScroll->yDrag = -1;
	}

    //
    // We should verify lpBScroll before use it
    //

    if( NULL == lpBScroll )
    {
        return NULL;
    }

	// register bscroll window class unless it has been already
	//
	if (fSuccess && GetClassInfo(lpBScroll->hInst, BSCROLLCLASS, &wc) == 0)
	{
		wc.hCursor =		LoadCursor(NULL, IDC_ARROW);
		wc.hIcon =			(HICON) NULL;
		wc.lpszMenuName =	NULL;
		wc.hInstance =		lpBScroll->hInst;
		wc.lpszClassName =	BSCROLLCLASS;
		wc.hbrBackground =	NULL;
		wc.lpfnWndProc =	BScrollWndProc;
		wc.style =			0L;
		wc.cbWndExtra =		sizeof(lpBScroll);
		wc.cbClsExtra =		0;

		if (!RegisterClass(&wc))
			fSuccess = TraceFALSE(NULL);
	}

	// create a bscroll window
	//
	if (fSuccess && (lpBScroll->hwndBScroll = CreateWindowEx(
		0L,
		BSCROLLCLASS,
		(LPTSTR) TEXT(""),
		WS_CHILD | WS_VISIBLE,
		0, 0, rcParent.right - rcParent.left, rcParent.bottom - rcParent.top,
		hwndParent,
		(HMENU)IntToPtr(idChild),
		lpBScroll->hInst,
		lpBScroll)) == NULL)
	{
		fSuccess = TraceFALSE(NULL);
	}
	else
	{
		// set the cursor to something appropriate
		//
		SetClassLongPtr(lpBScroll->hwndBScroll, GCLP_HCURSOR,
			(dwFlags & BSCROLL_DRAG) ?
			(LONG_PTR) LoadCursor(NULL, IDC_SIZEALL) :
			(LONG_PTR) LoadCursor(NULL, IDC_ARROW));
	}

	if (!fSuccess)
	{
		BScrollTerm(BScrollGetHandle(lpBScroll));
		lpBScroll = NULL;
	}

	return fSuccess ? BScrollGetHandle(lpBScroll) : NULL;
}

// BScrollTerm - shutdown bscroll engine
//		<hBScroll>			(i) handle returned from BScrollInit
// return 0 if success
//
int DLLEXPORT WINAPI BScrollTerm(HBSCROLL hBScroll)
{
	BOOL fSuccess = TRUE;
	LPBSCROLL lpBScroll;

	if (BScrollStop(hBScroll) != 0)
		fSuccess = TraceFALSE(NULL);

	else if ((lpBScroll = BScrollGetPtr(hBScroll)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpBScroll->hwndBScroll != NULL &&
		!DestroyWindow(lpBScroll->hwndBScroll))
		fSuccess = TraceFALSE(NULL);

	else if ((lpBScroll = MemFree(NULL, lpBScroll)) != NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}

// BScrollStart - start bscroll animation
//		<hBScroll>			(i) handle returned from BScrollInit
// return 0 if success
//
int DLLEXPORT WINAPI BScrollStart(HBSCROLL hBScroll)
{
	BOOL fSuccess = TRUE;
	LPBSCROLL lpBScroll;

	if ((lpBScroll = BScrollGetPtr(hBScroll)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// set scroll timer if necessary
	//
	else if (!(lpBScroll->dwState & BSCROLL_SCROLLING) && lpBScroll->msScroll > 0)
	{
		if (!SetTimer(lpBScroll->hwndBScroll, ID_TIMER_SCROLL,
			lpBScroll->msScroll, NULL))
			fSuccess = TraceFALSE(NULL);
		else
			lpBScroll->dwState |= BSCROLL_SCROLLING;
	}

	return fSuccess ? 0 : -1;
}

// BScrollStop - stop bscroll animation
//		<hBScroll>			(i) handle returned from BScrollInit
// return 0 if success
//
int DLLEXPORT WINAPI BScrollStop(HBSCROLL hBScroll)
{
	BOOL fSuccess = TRUE;
	LPBSCROLL lpBScroll;

	if ((lpBScroll = BScrollGetPtr(hBScroll)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// kill scroll timer if necessary
	//
	else if (lpBScroll->dwState & BSCROLL_SCROLLING)
	{
		if (!KillTimer(lpBScroll->hwndBScroll, ID_TIMER_SCROLL))
			fSuccess = TraceFALSE(NULL);

		else
			lpBScroll->dwState &= ~BSCROLL_SCROLLING;
	}

	return fSuccess ? 0 : -1;
}

// BScrollGetWindowHandle - get bscroll screen window handle
//		<hBScroll>			(i) handle returned from BScrollInit
// return window handle (NULL if error)
//
HWND DLLEXPORT WINAPI BScrollGetWindowHandle(HBSCROLL hBScroll)
{
	BOOL fSuccess = TRUE;
	LPBSCROLL lpBScroll;

	if ((lpBScroll = BScrollGetPtr(hBScroll)) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? lpBScroll->hwndBScroll : NULL;
}

////
//	helper functions
////

// BScrollWndProc - window procedure for bscroll screen
//
LRESULT DLLEXPORT CALLBACK BScrollWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	BOOL fSuccess = TRUE;
	LRESULT lResult;

	switch (msg)
	{
		case WM_NCCREATE:
			lResult = (LRESULT) HANDLE_WM_NCCREATE(hwnd, wParam, lParam, BScrollOnNCCreate);
			break;

		case WM_CREATE:
			lResult = (LRESULT) HANDLE_WM_CREATE(hwnd, wParam, lParam, BScrollOnCreate);
			break;

		case WM_DESTROY:
			lResult = (LRESULT) HANDLE_WM_DESTROY(hwnd, wParam, lParam, BScrollOnDestroy);
			break;

		case WM_SIZE:
			lResult = (LRESULT) HANDLE_WM_SIZE(hwnd, wParam, lParam, BScrollOnSize);
			break;

		case WM_PAINT:
			lResult = (LRESULT) HANDLE_WM_PAINT(hwnd, wParam, lParam, BScrollOnPaint);
			break;

		case WM_TIMER:
			lResult = (LRESULT) HANDLE_WM_TIMER(hwnd, wParam, lParam, BScrollOnTimer);
			break;

		case WM_CHAR:
			lResult = (LRESULT) HANDLE_WM_CHAR(hwnd, wParam, lParam, BScrollOnChar);
			break;

		case WM_LBUTTONDOWN:
			lResult = (LRESULT) HANDLE_WM_LBUTTONDOWN(hwnd, wParam, lParam, BScrollOnLButtonDown);
			break;

		case WM_LBUTTONUP:
			lResult = (LRESULT) HANDLE_WM_LBUTTONUP(hwnd, wParam, lParam, BScrollOnLButtonUp);
			break;

		case WM_RBUTTONDOWN:
			lResult = (LRESULT) HANDLE_WM_RBUTTONDOWN(hwnd, wParam, lParam, BScrollOnRButtonDown);
			break;

		case WM_RBUTTONUP:
			lResult = (LRESULT) HANDLE_WM_RBUTTONUP(hwnd, wParam, lParam, BScrollOnRButtonUp);
			break;

		case WM_MOUSEMOVE:
			lResult = (LRESULT) HANDLE_WM_MOUSEMOVE(hwnd, wParam, lParam, BScrollOnMouseMove);
			break;

		default:
			lResult = DefWindowProc(hwnd, msg, wParam, lParam);
			break;
	}
	
	return lResult;
}

// BScrollOnNCCreate - handler for WM_NCCREATE message
//
static BOOL BScrollOnNCCreate(HWND hwnd, CREATESTRUCT FAR* lpCreateStruct)
{
	LPBSCROLL lpBScroll = (LPBSCROLL) lpCreateStruct->lpCreateParams;

	lpBScroll->hwndBScroll = hwnd;

	// store lpBScroll in window extra bytes
	//
	SetWindowLongPtr(hwnd, 0, (LONG_PTR) lpBScroll);

	return FORWARD_WM_NCCREATE(hwnd, lpCreateStruct, DefWindowProc);
}

// BScrollOnCreate - handler for WM_CREATE message
//
static BOOL BScrollOnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)
{
	BOOL fSuccess = TRUE;
	HDC hdc = NULL;
	LPBSCROLL lpBScroll;

	if ((lpBScroll = (LPBSCROLL) GetWindowLongPtr(hwnd, 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((hdc = GetDC(hwnd)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpBScroll->hdcMem = CreateCompatibleDC(hdc)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// clean up
	//
	if (hdc != NULL)
		ReleaseDC(hwnd, hdc);

	return fSuccess;
}

// BScrollOnDestroy - handler for WM_DESTROY message
//
static void BScrollOnDestroy(HWND hwnd)
{
	BOOL fSuccess = TRUE;
	LPBSCROLL lpBScroll;

	if ((lpBScroll = (LPBSCROLL) GetWindowLongPtr(hwnd, 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		SelectObject(lpBScroll->hdcMem, lpBScroll->hbmpMemSave);

		if (lpBScroll->hbmpMem != NULL && !DeleteObject(lpBScroll->hbmpMem))
			fSuccess = TraceFALSE(NULL);
		else
			lpBScroll->hbmpMem = NULL;

		if (lpBScroll->hdcMem != NULL && !DeleteDC(lpBScroll->hdcMem))
			fSuccess = TraceFALSE(NULL);
		else
			lpBScroll->hdcMem = NULL;

		if (lpBScroll->hrgnLeft != NULL &&
			!DeleteObject(lpBScroll->hrgnLeft))
			fSuccess = TraceFALSE(NULL);
		else
			lpBScroll->hrgnLeft = NULL;

		if (lpBScroll->hrgnRight != NULL &&
			!DeleteObject(lpBScroll->hrgnRight))
			fSuccess = TraceFALSE(NULL);
		else
			lpBScroll->hrgnRight = NULL;

		if (lpBScroll->hrgnUp != NULL &&
			!DeleteObject(lpBScroll->hrgnUp))
			fSuccess = TraceFALSE(NULL);
		else
			lpBScroll->hrgnUp = NULL;

		if (lpBScroll->hrgnDown != NULL &&
			!DeleteObject(lpBScroll->hrgnDown))
			fSuccess = TraceFALSE(NULL);
		else
			lpBScroll->hrgnDown = NULL;
	}

	return;
}

// BScrollOnSize - handler for WM_SIZE message
//
static void BScrollOnSize(HWND hwnd, UINT state, int cx, int cy)
{
	BOOL fSuccess = TRUE;
	LPBSCROLL lpBScroll;

	if ((lpBScroll = (LPBSCROLL) GetWindowLongPtr(hwnd, 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else switch (state)
	{
		case SIZE_RESTORED:
		case SIZE_MAXIMIZED:
		{
			HDC hdc = NULL;
			HBITMAP hbmpTemp = NULL;

			if ((hdc = GetDC(hwnd)) == NULL)
				fSuccess = TraceFALSE(NULL);

			else if ((hbmpTemp = CreateCompatibleBitmap(hdc, cx, cy)) == NULL)
				fSuccess = TraceFALSE(NULL);

			else
			{
				lpBScroll->hbmpMemSave = (HBITMAP)
					SelectObject(lpBScroll->hdcMem, hbmpTemp);

				if (lpBScroll->hbmpMem != NULL &&
					!DeleteObject(lpBScroll->hbmpMem))
					fSuccess = TraceFALSE(NULL);
				else
					lpBScroll->hbmpMem = hbmpTemp;
			}

			if (hdc != NULL)
				ReleaseDC(hwnd, hdc);

			if (1)
			{
				POINT aptLeft[5];
				POINT aptRight[5];
				POINT aptUp[5];
				POINT aptDown[5];

				aptLeft[0].x = cx / 2;
				aptLeft[0].y = cy / 2;
				aptLeft[1].x = cx / 4;
				aptLeft[1].y = 0;
				aptLeft[2].x = 0;
				aptLeft[2].y = 0;
				aptLeft[3].x = 0;
				aptLeft[3].y = cy;
				aptLeft[4].x = cx / 4;
				aptLeft[4].y = cy;

				aptRight[0].x = cx / 2;
				aptRight[0].y = cy / 2;
				aptRight[1].x = cx - (cx / 4);
				aptRight[1].y = 0;
				aptRight[2].x = cx;
				aptRight[2].y = 0;
				aptRight[3].x = cx;
				aptRight[3].y = cy;
				aptRight[4].x = cx - (cx / 4);
				aptRight[4].y = cy;

				aptUp[0].x = cx / 2;
				aptUp[0].y = cy / 2;
				aptUp[1].x = 0;
				aptUp[1].y = cy / 4;
				aptUp[2].x = 0;
				aptUp[2].y = 0;
				aptUp[3].x = cx;
				aptUp[3].y = 0;
				aptUp[4].x = cx;
				aptUp[4].y = cy / 4;

				aptDown[0].x = cx / 2;
				aptDown[0].y = cy / 2;
				aptDown[1].x = 0;
				aptDown[1].y = cy - (cy / 4);
				aptDown[2].x = 0;
				aptDown[2].y = cy;
				aptDown[3].x = cx;
				aptDown[3].y = cy;
				aptDown[4].x = cx;
				aptDown[4].y = cy - (cy / 4);

				if (lpBScroll->hrgnLeft != NULL &&
					!DeleteObject(lpBScroll->hrgnLeft))
					fSuccess = TraceFALSE(NULL);

				else if ((lpBScroll->hrgnLeft = CreatePolygonRgn(aptLeft,
					SIZEOFARRAY(aptLeft), WINDING)) == NULL)
					fSuccess = TraceFALSE(NULL);

				else if (lpBScroll->hrgnRight != NULL &&
					!DeleteObject(lpBScroll->hrgnRight))
					fSuccess = TraceFALSE(NULL);

				else if ((lpBScroll->hrgnRight = CreatePolygonRgn(aptRight,
					SIZEOFARRAY(aptRight), WINDING)) == NULL)
					fSuccess = TraceFALSE(NULL);

				else if (lpBScroll->hrgnUp != NULL &&
					!DeleteObject(lpBScroll->hrgnUp))
					fSuccess = TraceFALSE(NULL);

				else if ((lpBScroll->hrgnUp = CreatePolygonRgn(aptUp,
					SIZEOFARRAY(aptUp), WINDING)) == NULL)
					fSuccess = TraceFALSE(NULL);

				else if (lpBScroll->hrgnDown != NULL &&
					!DeleteObject(lpBScroll->hrgnDown))
					fSuccess = TraceFALSE(NULL);

				else if ((lpBScroll->hrgnDown = CreatePolygonRgn(aptDown,
					SIZEOFARRAY(aptDown), WINDING)) == NULL)
					fSuccess = TraceFALSE(NULL);
			}

			InvalidateRect(hwnd, NULL, FALSE);
		}
			break;

		default:
			break;
	}

	return;
}

// BScrollOnPaint - handler for WM_PAINT message
//
static void BScrollOnPaint(HWND hwnd)
{
	BOOL fSuccess = TRUE;
	BOOL fBitBlt = TRUE;
	HDC hdc;
	PAINTSTRUCT ps;
	LPBSCROLL lpBScroll;
#if 0
	DWORD msStartTimer = SysGetTimerCount();
	DWORD msStopTimer;
#endif

	if ((lpBScroll = (LPBSCROLL) GetWindowLongPtr(hwnd, 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((hdc = BeginPaint(hwnd, &ps)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpBScroll->hPalette != NULL)
	{
		SelectPalette(hdc, lpBScroll->hPalette, FALSE);

		if (lpBScroll->hPalette != NULL &&
			RealizePalette(hdc) == GDI_ERROR)
			fSuccess = TraceFALSE(NULL);

		else if (fBitBlt)
		{
			SelectPalette(lpBScroll->hdcMem, lpBScroll->hPalette, FALSE);

			if (RealizePalette(lpBScroll->hdcMem) == GDI_ERROR)
				fSuccess = TraceFALSE(NULL);
		}
	}

	//
	// $FIXUP - BSCROLL_FOREGROUND not yet suppported
	//

	if (fSuccess && lpBScroll->hbmpBackground != NULL)
	{
		if (lpBScroll->dwState & BSCROLL_SCROLLING)
		{
			int dxScroll = 0;
			int dyScroll = 0;

			// calculate dx and dy for the scroll
			//
			if (lpBScroll->dwFlags & BSCROLL_LEFT)
				dxScroll = -1 * lpBScroll->pelScroll;
			else if (lpBScroll->dwFlags & BSCROLL_RIGHT)
				dxScroll = +1 * lpBScroll->pelScroll;
			if (lpBScroll->dwFlags & BSCROLL_UP)
				dyScroll = -1 * lpBScroll->pelScroll;
			else if (lpBScroll->dwFlags & BSCROLL_DOWN)
				dyScroll = +1 * lpBScroll->pelScroll;

			if (GfxBitmapScroll((fBitBlt ? lpBScroll->hdcMem : hdc),
				lpBScroll->hbmpBackground,
				dxScroll, dyScroll, BS_ROTATE) != 0)
				fSuccess = TraceFALSE(NULL);
		}

		else if (GfxBitmapDisplay((fBitBlt ? lpBScroll->hdcMem : hdc),
			lpBScroll->hbmpBackground, 0, 0, 0) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	if (fSuccess && lpBScroll->hbmpForeground != NULL)
	{
		if (GfxBitmapDrawTransparent((fBitBlt ? lpBScroll->hdcMem : hdc),
			lpBScroll->hbmpForeground, 0, 0, lpBScroll->crTransparent, 0) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	if (fSuccess && fBitBlt && !BitBlt(hdc,
		ps.rcPaint.left, ps.rcPaint.top,
		ps.rcPaint.right - ps.rcPaint.left,
		ps.rcPaint.bottom - ps.rcPaint.top,
		lpBScroll->hdcMem,
		ps.rcPaint.left, ps.rcPaint.top,
		SRCCOPY))
		fSuccess = TraceFALSE(NULL);

    //
    // We should call EndPaint just if we called BeginPaint
    // BeginPAint should succeded too?
    if((lpBScroll != NULL) && (hdc != NULL))
	    EndPaint(hwnd, &ps);

#if 0
	msStopTimer = SysGetTimerCount();

	TracePrintf_1(NULL, 8, TEXT("elapsed=%ld\n"),
		(long) (msStopTimer - msStartTimer));
#endif

	return;
}

// BScrollOnTimer - handler for WM_TIMER message
//
static void BScrollOnTimer(HWND hwnd, UINT id)
{
	BOOL fSuccess = TRUE;
	LPBSCROLL lpBScroll;

	if ((lpBScroll = (LPBSCROLL) GetWindowLongPtr(hwnd, 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else switch (id)
	{
		case ID_TIMER_SCROLL:
		{
			InvalidateRect(hwnd, NULL, FALSE);
		}
			break;

		default:
			break;
	}

	return;
}

// BScrollOnChar - handler for WM_CHAR message
//
static void BScrollOnChar(HWND hwnd, UINT ch, int cRepeat)
{
	BOOL fSuccess = TRUE;
	LPBSCROLL lpBScroll;

	if ((lpBScroll = (LPBSCROLL) GetWindowLongPtr(hwnd, 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	return;
}

// BScrollOnLButtonDown - handler for WM_LBUTTONDOWN message
//
static void BScrollOnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags)
{
	BOOL fSuccess = TRUE;
	LPBSCROLL lpBScroll;

	if ((lpBScroll = (LPBSCROLL) GetWindowLongPtr(hwnd, 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (!(lpBScroll->dwState & BSCROLL_DRAGGING) &&
		!fDoubleClick && (lpBScroll->dwFlags & BSCROLL_DRAG))
	{
		lpBScroll->dwState |= BSCROLL_DRAGGING;
		lpBScroll->xDrag = x;
		lpBScroll->yDrag = y;

		SetCapture(lpBScroll->hwndBScroll);

		if (lpBScroll->dwState & BSCROLL_SCROLLING)
		{
			if (BScrollStop(BScrollGetHandle(lpBScroll)) != 0)
				fSuccess = TraceFALSE(NULL);

			else
				lpBScroll->dwState |= BSCROLL_PAUSED;
		}
	}

	if (fSuccess)
		FORWARD_WM_LBUTTONDOWN(lpBScroll->hwndParent, fDoubleClick, x, y, keyFlags, SendMessage);

	return;
}

// BScrollOnLButtonUp - handler for WM_LBUTTONUP message
//
static void BScrollOnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags)
{
	BOOL fSuccess = TRUE;
	LPBSCROLL lpBScroll;

	if ((lpBScroll = (LPBSCROLL) GetWindowLongPtr(hwnd, 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpBScroll->dwState & BSCROLL_DRAGGING)
	{
		lpBScroll->dwState &= ~BSCROLL_DRAGGING;
		lpBScroll->xDrag = -1;
		lpBScroll->yDrag = -1;

		ReleaseCapture();

		if (lpBScroll->dwState & BSCROLL_PAUSED)
		{
			if (BScrollStart(BScrollGetHandle(lpBScroll)) != 0)
				fSuccess = TraceFALSE(NULL);

			else
				lpBScroll->dwState &= ~BSCROLL_PAUSED;
		}
	}

	if (fSuccess)
		FORWARD_WM_LBUTTONUP(lpBScroll->hwndParent, x, y, keyFlags, SendMessage);

	return;
}

// BScrollOnRButtonDown - handler for WM_LBUTTONDOWN message
//
static void BScrollOnRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags)
{
	BOOL fSuccess = TRUE;
	LPBSCROLL lpBScroll;

	if ((lpBScroll = (LPBSCROLL) GetWindowLongPtr(hwnd, 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	if (fSuccess)
		FORWARD_WM_RBUTTONDOWN(lpBScroll->hwndParent, fDoubleClick, x, y, keyFlags, SendMessage);

	return;
}

// BScrollOnRButtonUp - handler for WM_RBUTTONUP message
//
static void BScrollOnRButtonUp(HWND hwnd, int x, int y, UINT keyFlags)
{
	BOOL fSuccess = TRUE;
	LPBSCROLL lpBScroll;

	if ((lpBScroll = (LPBSCROLL) GetWindowLongPtr(hwnd, 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	if (fSuccess)
		FORWARD_WM_RBUTTONUP(lpBScroll->hwndParent, x, y, keyFlags, SendMessage);

	return;
}

static void BScrollOnMouseMove(HWND hwnd, int x, int y, UINT keyFlags)
{
	BOOL fSuccess = TRUE;
	LPBSCROLL lpBScroll;

	if ((lpBScroll = (LPBSCROLL) GetWindowLongPtr(hwnd, 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpBScroll->dwState & BSCROLL_DRAGGING)
	{
		if (fSuccess && lpBScroll->hbmpBackground != NULL)
		{
			int dxScroll = x - lpBScroll->xDrag;
			int dyScroll = y - lpBScroll->yDrag;

			lpBScroll->xDrag = x;
			lpBScroll->yDrag = y;

			if (GfxBitmapScroll(lpBScroll->hdcMem,
				lpBScroll->hbmpBackground,
				dxScroll, dyScroll, BS_ROTATE) != 0)
				fSuccess = TraceFALSE(NULL);
			else
			{
				InvalidateRect(lpBScroll->hwndBScroll, NULL, FALSE);
				UpdateWindow(lpBScroll->hwndBScroll);
			}
		}
	}

	if (fSuccess && BScrollChangeDirection(lpBScroll, x, y, 0) != 0)
		fSuccess = TraceFALSE(NULL);

	return;
}

static int BScrollChangeDirection(LPBSCROLL lpBScroll, int x, int y, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	RECT rc;

	if (lpBScroll == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (!(lpBScroll->dwState & BSCROLL_SCROLLING) &&
		!(lpBScroll->dwState & BSCROLL_DRAGGING))
		; // nothing to do

	else if (!GetClientRect(lpBScroll->hwndBScroll, &rc))
		fSuccess = TraceFALSE(NULL);

	else if (x < 0 || x > rc.right - 1 || y < 0 || y > rc.bottom - 1)
		; // outside the window; nothing to do

	else if ((lpBScroll->dwFlags & BSCROLL_MOUSEMOVE) ||
		(lpBScroll->dwState & BSCROLL_DRAGGING))
	{
		lpBScroll->dwFlags &= ~BSCROLL_LEFT;
		lpBScroll->dwFlags &= ~BSCROLL_RIGHT;
		lpBScroll->dwFlags &= ~BSCROLL_UP;
		lpBScroll->dwFlags &= ~BSCROLL_DOWN;

		if (lpBScroll->dwFlags & BSCROLL_FLIGHTSIM &&
			!(lpBScroll->dwState & BSCROLL_DRAGGING))
		{
			if (PtInRegion(lpBScroll->hrgnLeft, x, y))
				lpBScroll->dwFlags |= BSCROLL_RIGHT;
			if (PtInRegion(lpBScroll->hrgnRight, x, y))
				lpBScroll->dwFlags |= BSCROLL_LEFT;
			if (PtInRegion(lpBScroll->hrgnUp, x, y))
				lpBScroll->dwFlags |= BSCROLL_DOWN;
			if (PtInRegion(lpBScroll->hrgnDown, x, y))
				lpBScroll->dwFlags |= BSCROLL_UP;
		}
		else
		{
			if (PtInRegion(lpBScroll->hrgnLeft, x, y))
				lpBScroll->dwFlags |= BSCROLL_LEFT;
			if (PtInRegion(lpBScroll->hrgnRight, x, y))
				lpBScroll->dwFlags |= BSCROLL_RIGHT;
			if (PtInRegion(lpBScroll->hrgnUp, x, y))
				lpBScroll->dwFlags |= BSCROLL_UP;
			if (PtInRegion(lpBScroll->hrgnDown, x, y))
				lpBScroll->dwFlags |= BSCROLL_DOWN;
		}
	}

	return fSuccess ? 0 : -1;
}

// BScrollGetPtr - verify that bscroll handle is valid,
//		<hBScroll>				(i) handle returned from BScrollInit
// return corresponding bscroll pointer (NULL if error)
//
static LPBSCROLL BScrollGetPtr(HBSCROLL hBScroll)
{
	BOOL fSuccess = TRUE;
	LPBSCROLL lpBScroll;

	if ((lpBScroll = (LPBSCROLL) hBScroll) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadWritePtr(lpBScroll, sizeof(BSCROLL)))
		fSuccess = TraceFALSE(NULL);

#ifdef CHECKTASK
	// make sure current task owns the bscroll handle
	//
	else if (lpBScroll->hTask != GetCurrentTask())
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? lpBScroll : NULL;
}

// BScrollGetHandle - verify that bscroll pointer is valid,
//		<lpBScroll>				(i) pointer to BSCROLL struct
// return corresponding bscroll handle (NULL if error)
//
static HBSCROLL BScrollGetHandle(LPBSCROLL lpBScroll)
{
	BOOL fSuccess = TRUE;
	HBSCROLL hBScroll;

	if ((hBScroll = (HBSCROLL) lpBScroll) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hBScroll : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\array.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// array.c - array functions
////

#include "winlocal.h"

#include "array.h"
#include "sort.h"
#include "mem.h"
#include "str.h"
#include "trace.h"

////
//	private definitions
////

// compare element <i> with element <j>
//
#define ElemCompare(lpi, lpj) \
	(lpfnCompare == NULL ? MemCmp(lpi, lpj, sizeof(ARRAYELEM)) : lpfnCompare(lpi, lpj))

// array control struct
//
typedef struct ARRAY
{
	DWORD dwVersion;
	HINSTANCE hInst;
	HTASK hTask;
	ARRAYSIZE_T nSize;
	ARRAYSIZE_T nMaxSize;
	ARRAYSIZE_T nGrowBy;
	LPARRAYELEM lpelem;
} ARRAY, FAR *LPARRAY;

// helper functions
//
static LPARRAY ArrayGetPtr(HARRAY hArray);
static HARRAY ArrayGetHandle(LPARRAY lpArray);

////
//	public functions
////

////
// array constructor and destructor functions
////

// ArrayCreate - array constructor (array is initially empty)
// 		<dwVersion>			(i) must be ARRAY_VERSION
//		<hInst>				(i) instance handle of calling module
// return new array handle (NULL if error)
//
HARRAY DLLEXPORT WINAPI ArrayCreate(DWORD dwVersion, HINSTANCE hInst)
{
	BOOL fSuccess = TRUE;
	LPARRAY lpArray = NULL;

	if (dwVersion != ARRAY_VERSION)
		fSuccess = TraceFALSE(NULL);

	else if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpArray = (LPARRAY) MemAlloc(NULL, sizeof(ARRAY), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		// initially the array is empty
		//
		lpArray->dwVersion = dwVersion;
		lpArray->hInst = hInst;
		lpArray->hTask = GetCurrentTask();
		lpArray->nSize = 0;
		lpArray->nMaxSize = 0;
		lpArray->nGrowBy = 0;
		lpArray->lpelem = NULL;
	}

	return fSuccess ? ArrayGetHandle(lpArray) : NULL;
}

// ArrayDestroy - array destructor
//		<hArray>			(i) handle returned from ArrayCreate
// return 0 if success
//
int DLLEXPORT WINAPI ArrayDestroy(HARRAY hArray)
{
	BOOL fSuccess = TRUE;
	LPARRAY lpArray;

	if ((lpArray = ArrayGetPtr(hArray)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// make sure the array is emptied
	//
	else if (ArrayRemoveAll(hArray) != 0)
		fSuccess = TraceFALSE(NULL);

	else if ((lpArray = MemFree(NULL, lpArray)) != NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}

////
// array size functions
////

// ArrayGetSize - get array size
//		<hArray>			(i) handle returned from ArrayCreate
// return size of array (0 if empty, -1 if error)
// array indexes are zero-based, so the size is 1 greater than largest index
//
ARRAYSIZE_T DLLEXPORT WINAPI ArrayGetSize(HARRAY hArray)
{
	BOOL fSuccess = TRUE;
	LPARRAY lpArray;

	if ((lpArray = ArrayGetPtr(hArray)) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? lpArray->nSize : -1;
}

// ArrayGetUpperBound - get array upper bound
//		<hArray>			(i) handle returned from ArrayCreate
// return largest valid array index (-1 if empty, -2 if error)
//
ARRAYSIZE_T DLLEXPORT WINAPI ArrayGetUpperBound(HARRAY hArray)
{
	return ArrayGetSize(hArray) - 1;
}

// ArraySetSize - establish new size and grow amount for array
//		<hArray>			(i) handle returned from ArrayCreate
// 		<nNewSize>			(i) new array size (number of elements)
//			0					make empty array
//		<nGrowBy>			(i) when array needs to grow, grow by this amount
//			0					use default grow amount
//			-1					leave grow amount unchanged
// return 0 if success
//
int DLLEXPORT WINAPI ArraySetSize(HARRAY hArray, ARRAYSIZE_T nNewSize, ARRAYSIZE_T nGrowBy)
{
	BOOL fSuccess = TRUE;
	LPARRAY lpArray;

	if ((lpArray = ArrayGetPtr(hArray)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (nNewSize < 0)
		fSuccess = TraceFALSE(NULL);

	else
	{
		// if specified, set new grow amount
		//
		if (nGrowBy >= 0)
			lpArray->nGrowBy = nGrowBy;

		// if new size is zero, just shrink array to nothing
		//
		if (nNewSize == 0)
		{
			if (lpArray->lpelem != NULL)
			{
				if ((lpArray->lpelem = MemFree(NULL, lpArray->lpelem)) != NULL)
					fSuccess = TraceFALSE(NULL);

				else
				{
					lpArray->nSize = 0;
					lpArray->nMaxSize = 0;
				}
			}
		}

		// if array is already empty, grow it to exact size requested
		//
		else if (lpArray->lpelem == NULL)
		{
			if ((lpArray->lpelem = (LPARRAYELEM) MemAlloc(NULL,
				nNewSize * sizeof(ARRAYELEM), 0)) == NULL)
			{
				fSuccess = TraceFALSE(NULL);
			}

			else
			{
				lpArray->nSize = nNewSize;
				lpArray->nMaxSize = nNewSize;
			}
		}

		// if new size will fit within current array
		//
		else if (nNewSize <= lpArray->nMaxSize)
		{
			if (nNewSize > lpArray->nSize)
			{
				// clear elements outside of new size
				//
				MemSet(&lpArray->lpelem[lpArray->nSize], 0,
					(nNewSize - lpArray->nSize) * sizeof(ARRAYELEM));
			}

			// adjust virtual size variable, but leave memory block alone
			//
			lpArray->nSize = nNewSize;
		}

		// otherwise grow array to accomodate new size
		//
		else
		{
			ARRAYSIZE_T nGrowBy = lpArray->nGrowBy;
			ARRAYSIZE_T nNewMaxSize;
			LPARRAYELEM lpelem;

			// if nGrowBy not specified, compute it
			//
			if (nGrowBy == 0)
				nGrowBy = min(1024, max(4, lpArray->nSize / 8));

			// make sure the new array size is at least
			// nGrowBy elements larger than the old array size
			//
			nNewMaxSize = max(nNewSize, lpArray->nMaxSize + nGrowBy);
#if 0
			// [From the WinSDK KnowledgeBase PSS ID Number: Q92942]
			// When GlobalReAlloc() is used with GMEM_ZEROINIT, it may not
			// zero out all of the reallocated memory when GlobalReAlloc()
			// is called to shrink a block of memory and then enlarge it.
			//
			if ((lpelem = (LPARRAYELEM) MemReAlloc(NULL, lpArray->lpelem,
				nNewMaxSize * sizeof(ARRAYELEM), 0)) == NULL)
				fSuccess = TraceFALSE(NULL);

			else
			{
				// compensate for GlobalReAlloc bug cited above
				//
				MemSet(&lpelem[lpArray->nSize], 0,
					(nNewMaxSize - lpArray->nSize) * sizeof(ARRAYELEM));

				lpArray->lpelem = lpelem;
				lpArray->nSize = nNewSize;
				lpArray->nMaxSize = nNewMaxSize;
			}
#else
			// allocate new array
			//
			if ((lpelem = (LPARRAYELEM) MemAlloc(NULL,
				nNewMaxSize * sizeof(ARRAYELEM), 0)) == NULL)
			{
				fSuccess = TraceFALSE(NULL);
			}

			else
			{
				// copy old array into new array
				//
				MemCpy(lpelem, lpArray->lpelem,
					lpArray->nSize * sizeof(ARRAYELEM));

				// free old array
				//
				if ((lpArray->lpelem = MemFree(NULL, lpArray->lpelem)) != NULL)
				{
					fSuccess = TraceFALSE(NULL);
					if ((lpArray->lpelem = MemFree(NULL, lpArray->lpelem)) != NULL)
						fSuccess = TraceFALSE(NULL);
				}
				else
				{
					lpArray->lpelem = lpelem;
					lpArray->nSize = nNewSize;
					lpArray->nMaxSize = nNewMaxSize;
				}
			}
#endif
		}
	}

	return fSuccess ? 0 : -1;
}

////
//	array clean up functions
////

// ArrayFreeExtra - free unused memory above the array upper bound
//		<hArray>			(i) handle returned from ArrayCreate
// return 0 if success
//
int DLLEXPORT WINAPI ArrayFreeExtra(HARRAY hArray)
{
	BOOL fSuccess = TRUE;
	LPARRAY lpArray;

	if ((lpArray = ArrayGetPtr(hArray)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpArray->lpelem != NULL && lpArray->nSize != lpArray->nMaxSize)
	{
		LPARRAYELEM lpelem;
#if 0
		// shrink array so there are no unused elements
		//
		if ((lpelem = (LPARRAYELEM) MemReAlloc(NULL, lpArray->lpelem,
			lpArray->nSize * sizeof(ARRAYELEM), 0)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else
		{
			lpArray->lpelem = lpelem;
			lpArray->nMaxSize = lpArray->nSize;
		}
#else
		// allocate new array
		//
		if ((lpelem = (LPARRAYELEM) MemAlloc(NULL,
			lpArray->nSize * sizeof(ARRAYELEM), 0)) == NULL)
		{
			fSuccess = TraceFALSE(NULL);
		}

		else
		{
			// copy old array into new array
			//
			MemCpy(lpelem, lpArray->lpelem,
				lpArray->nSize * sizeof(ARRAYELEM));

			// free old array
			//
			if ((lpArray->lpelem = MemFree(NULL, lpArray->lpelem)) != NULL)
			{
				fSuccess = TraceFALSE(NULL);
				if ((lpelem = MemFree(NULL, lpelem)) != NULL)
					fSuccess = TraceFALSE(NULL);
			}
			else
			{
				lpArray->lpelem = lpelem;
				lpArray->nMaxSize = lpArray->nSize;
			}
		}
#endif
	}

	return fSuccess ? 0 : -1;
}

// ArrayRemoveAll - remove all elements from array
//		<hArray>			(i) handle returned from ArrayCreate
// return 0 if success
//
int DLLEXPORT WINAPI ArrayRemoveAll(HARRAY hArray)
{
	return ArraySetSize(hArray, 0, -1);
}

////
// array element access functions
////

// ArrayGetAt - return data element at specified index
//		<hArray>			(i) handle returned from ArrayCreate
//		<nIndex>			(i) zero based index into array
// return data element value (NULL if error)
//
ARRAYELEM DLLEXPORT WINAPI ArrayGetAt(HARRAY hArray, ARRAYSIZE_T nIndex)
{
	BOOL fSuccess = TRUE;
	LPARRAY lpArray;
	ARRAYELEM elem;

	if ((lpArray = ArrayGetPtr(hArray)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (nIndex < 0 || nIndex >= lpArray->nSize)
		fSuccess = TraceFALSE(NULL);

	else
		elem = lpArray->lpelem[nIndex];

	return fSuccess ? elem : (ARRAYELEM) NULL;
}

// ArraySetAt - set data element at specified index
//		<hArray>			(i) handle returned from ArrayCreate
//		<nIndex>			(i) zero based index into array
//		<elem>				(i) new data element value
// return 0 if success
//
int DLLEXPORT WINAPI ArraySetAt(HARRAY hArray, ARRAYSIZE_T nIndex, ARRAYELEM elem)
{
	BOOL fSuccess = TRUE;
	LPARRAY lpArray;

	if ((lpArray = ArrayGetPtr(hArray)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (nIndex < 0 || nIndex >= lpArray->nSize)
		fSuccess = TraceFALSE(NULL);

	else
		lpArray->lpelem[nIndex] = elem;

	return fSuccess ? 0 : -1;
}

////
// array grow functions
////

// ArraySetAtGrow - set data element at specified index
//		<hArray>			(i) handle returned from ArrayCreate
//		<nIndex>			(i) zero based index into array
//		<elem>				(i) new data element value
// return 0 if success
// NOTE: array size is increased if nIndex > upper bound
//
int DLLEXPORT WINAPI ArraySetAtGrow(HARRAY hArray, ARRAYSIZE_T nIndex, ARRAYELEM elem)
{
	BOOL fSuccess = TRUE;
	LPARRAY lpArray;

	if ((lpArray = ArrayGetPtr(hArray)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (nIndex >= lpArray->nSize &&
		ArraySetSize(hArray, nIndex + 1, -1) != 0)
		fSuccess = TraceFALSE(NULL);

	else
		lpArray->lpelem[nIndex] = elem;

	return fSuccess ? 0 : -1;
}

// ArrayAdd - add data element to end of array
//		<hArray>			(i) handle returned from ArrayCreate
//		<elem>				(i) new data element value
// return index of added element (-1 if error)
//
ARRAYSIZE_T DLLEXPORT WINAPI ArrayAdd(HARRAY hArray, ARRAYELEM elem)
{
	BOOL fSuccess = TRUE;
	ARRAYSIZE_T nIndexNew;

	if ((nIndexNew = ArrayGetSize(hArray)) < 0)
		fSuccess = TraceFALSE(NULL);

	else if (ArraySetAtGrow(hArray, nIndexNew, elem) != 0)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? nIndexNew : -1;
}

////
// array element insertion and removal
////

// ArrayInsertAt - insert <nCount> copies of <elem> at specified index
//		<hArray>			(i) handle returned from ArrayCreate
//		<nIndex>			(i) zero based index into array
//		<elem>				(i) new data element value
//		<nCount>			(i) number of elements to insert
// return 0 if success
// NOTE: elements at end of array will be shifted if necessary
//
int DLLEXPORT WINAPI ArrayInsertAt(HARRAY hArray, ARRAYSIZE_T nIndex, ARRAYELEM elem, ARRAYSIZE_T nCount)
{
	BOOL fSuccess = TRUE;
	LPARRAY lpArray;

	if ((lpArray = ArrayGetPtr(hArray)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (nIndex < 0)
		fSuccess = TraceFALSE(NULL);

	else if (nCount <= 0)
		fSuccess = TraceFALSE(NULL);

	// inserting at or after the end of array
	//
	else if (nIndex >= lpArray->nSize)
	{
		// grow so nIndex is valid
		//
		if (ArraySetSize(hArray, nIndex + nCount, -1) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	// inserting in the middle of the array
	//
	else
	{
		ARRAYSIZE_T nOldSize = lpArray->nSize;

		// grow array to new size
		//
		if (ArraySetSize(hArray, lpArray->nSize + nCount, -1) != 0)
			fSuccess = TraceFALSE(NULL);

		else
		{
			MemMove(&lpArray->lpelem[nIndex + nCount],
				&lpArray->lpelem[nIndex],
				(nOldSize - nIndex) * sizeof(ARRAYELEM));
#if 1
			// initialize inserted elements
			MemSet(&lpArray->lpelem[nIndex], 0, nCount * sizeof(ARRAYELEM));
#endif
		}
	}

	if (fSuccess)
	{
		// insert new element values
		//
		while (nCount-- > 0)
			lpArray->lpelem[nIndex++] = elem;
	}

	return fSuccess ? 0 : -1;
}

// ArrayRemoveAt - remove <nCount> data elements at specified index
//		<hArray>			(i) handle returned from ArrayCreate
//		<nIndex>			(i) zero based index into array
//		<nCount>			(i) number of elements to remove
// return 0 if success
// NOTE: elements at end of array will be shifted if necessary
//
int DLLEXPORT WINAPI ArrayRemoveAt(HARRAY hArray, ARRAYSIZE_T nIndex, ARRAYSIZE_T nCount)
{
	BOOL fSuccess = TRUE;
	LPARRAY lpArray;
	ARRAYSIZE_T nMoveCount;

	if ((lpArray = ArrayGetPtr(hArray)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (nIndex < 0)
		fSuccess = TraceFALSE(NULL);

	else if (nCount < 0)
		fSuccess = TraceFALSE(NULL);

	else if (nIndex + nCount > lpArray->nSize)
		fSuccess = TraceFALSE(NULL);

	else if ((nMoveCount = lpArray->nSize - (nIndex + nCount)) > 0)
	{
		// shift remaining elements on top of removed elements
		//
		MemCpy(&lpArray->lpelem[nIndex],
			&lpArray->lpelem[nIndex + nCount],
			nMoveCount * sizeof(ARRAYELEM));
#if 1
		// initialize elements beyond remaining elements
		//
		MemSet(&lpArray->lpelem[lpArray->nSize - nCount], 0,
			nCount * sizeof(ARRAYELEM));
#endif
	}

	if (fSuccess)
		lpArray->nSize -= nCount;

	return fSuccess ? 0 : -1;
}

////
// array element sorting and searching
////

// ArraySort - sort array
//		<hArray>			(i) handle returned from ArrayCreate
//		<lpfnCompare>		(i) comparison function pointer
//			NULL				direct comparison (MemCmp)
// return 0 if success
//
int DLLEXPORT WINAPI ArraySort(HARRAY hArray,
	int (WINAPI *lpfnCompare)(const LPARRAYELEM lpElem1, const LPARRAYELEM lpElem2))
{
	BOOL fSuccess = TRUE;
	LPARRAY lpArray;
	ARRAYSIZE_T sizArray;

	if ((lpArray = ArrayGetPtr(hArray)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((sizArray = ArrayGetSize(hArray)) < 0)
		fSuccess = TraceFALSE(NULL);

	else if (Sort(lpArray->lpelem, (SORTSIZE_T) sizArray,
		(SORTSIZE_T) sizeof(ARRAYELEM), lpfnCompare, 0) != 0)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}

// ArraySearch - search array for matching element
//		<hArray>			(i) handle returned from ArrayCreate
//		<elem>				(i) data element to match
//		<nIndex>			(i) start search after this array index
//			-1					start search at start of array
//		<dwFlags>			(i) reserved; must be 0
//		<lpfnCompare>		(i) comparison function pointer
//			NULL				direct comparison (MemCmp)
// return index of matching element (-1 if no match, -2 if error)
//
ARRAYSIZE_T DLLEXPORT WINAPI ArraySearch(HARRAY hArray, ARRAYELEM elem,
	ARRAYSIZE_T nIndex, DWORD dwFlags,
	int (WINAPI *lpfnCompare)(const LPARRAYELEM lpElem1, const LPARRAYELEM lpElem2))
{
	BOOL fSuccess = TRUE;
	BOOL fMatch = FALSE;
	LPARRAY lpArray;

	if ((lpArray = ArrayGetPtr(hArray)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (++nIndex < 0 || nIndex >= lpArray->nSize)
		fSuccess = TraceFALSE(NULL);

	else for (; nIndex < lpArray->nSize; ++nIndex)
	{
		if (ElemCompare(&lpArray->lpelem[nIndex], &elem) == 0)
		{
			fMatch = TRUE;
			break;
		}
	}

	return fSuccess ? (fMatch ? nIndex : -1) : -2;
}

////
//	private functions
////

// ArrayGetPtr - verify that array handle is valid,
//		<hArray>			(i) handle returned from ArrayCreate
// return corresponding array pointer (NULL if error)
//
static LPARRAY ArrayGetPtr(HARRAY hArray)
{
	BOOL fSuccess = TRUE;
	LPARRAY lpArray;

	if ((lpArray = (LPARRAY) hArray) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadWritePtr(lpArray, sizeof(ARRAY)))
		fSuccess = TraceFALSE(NULL);

#ifdef CHECKTASK
	// make sure current task owns the array handle
	//
	else if (lpArray->hTask != GetCurrentTask())
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? lpArray : NULL;
}

// ArrayGetHandle - verify that array pointer is valid,
//		<lpArray>			pointer to ARRAY struct
// return corresponding array handle (NULL if error)
//
static HARRAY ArrayGetHandle(LPARRAY lpArray)
{
	BOOL fSuccess = TRUE;
	HARRAY hArray;

	if ((hArray = (HARRAY) lpArray) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hArray : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\date.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// date.h - interface for date functions in date.c
////

#ifndef __DATE_H__
#define __DATE_H__

#include "winlocal.h"

#define DATE_VERSION 0x00000108

#define DATEWEEKDAY_MKTIME	0x00000001
#define DATEWEEKDAY_QUICK	0x00000002
#define DATEWEEKDAY_ZELLER	0x00000004
#define DATEWEEKDAY_SAKAMOTO 0x00000008

// date types
//
typedef long Date_t;
typedef short Year_t;
typedef short Month_t;
typedef short Day_t;
typedef short Weekday_t;

#ifdef __cplusplus
extern "C" {
#endif

// Date - return date value representing year <y>, month <m>, and day <d>
//		<y>					(i) year
//		<m>					(i) month
//		<d>					(i) day
// return date value (0 if error)
// NOTE: if year is between 0 and 27, 2000 is added to it
// NOTE: if year is between 28 and 127, 1900 is added to it
//
Date_t DLLEXPORT WINAPI Date(Year_t y, Month_t m, Day_t d);

// DateToday - return date value representing current year, month, and day
// return date value (0 if error)
//
Date_t DLLEXPORT WINAPI DateToday(void);

// DateValue - return date value representing given date string
//		<lpszDate>			(i) date string to convert
//			"JUL 25 1959"
//			"25 JUL 1959"
//			"7-25-1959"
//			etc.
// return date value (0 if error)
// NOTE: this function assumes English language month names only
// NOTE: if no year specified, current year is assumed
//
Date_t DLLEXPORT WINAPI DateValue(LPCTSTR lpszDate);

// DateYear - return year of a given date (1900-2027)
//		<d>					(i) date value
// return year
//
Year_t DLLEXPORT WINAPI DateYear(Date_t d);

// DateMonth - return month of a given date (1-12)
//		<d>					(i) date value
// return month
//
Month_t DLLEXPORT WINAPI DateMonth(Date_t d);

// DateDay - return day of the month for a given date (1-31)
//		<d>					(i) date value
// return day
//
Day_t DLLEXPORT WINAPI DateDay(Date_t d);

// DateWeekDay - return day of the week for a given date
//		<date>				(i) date value
//		<dwFlags>			(i) control flags
//			0					default algorithm
//			DATEWEEKDAY_MKTIME	mktime algorithm (1/1/1970 - 1/18/2038)
//			DATEWEEKDAY_QUICK	quick algorithm (3/2/1924 - 2/28/2100)
//			DATEWEEKDAY_ZELLER	zeller congruence algorithm (1582 - )
//			DATEWEEKDAY_SAKAMOTO Tomohiko Sakamoto algorithm (1752 - )
// return day of week (0 if error, 1 if SUN, 2 if MON, etc)
//
Weekday_t DLLEXPORT WINAPI DateWeekDay(Date_t date, DWORD dwFlags);

// DateIsValid - test <date> for validity
//		<date>				(i) date value
// return TRUE if valid
//
BOOL DLLEXPORT WINAPI DateIsValid(Date_t date);

// DateIsLeapYear - return TRUE if <y> represents a leap year
//		<y>					(i) year value
// return TRUE if leap year
//
BOOL DLLEXPORT WINAPI DateIsLeapYear(Year_t y);

// DateNew - return date value which is <n> days from date <date>
//		<date>				(i) date value
//		<n>					(i) delta
//			+1					one day later
//			-1					one day earlier, etc.
// return date value (0 if error)
//
Date_t DLLEXPORT WINAPI DateNew(Date_t date, short n);

// DateCmp - return number of days between date1 and date2 (date1 minus date2)
//		<date1>				(i) date value
//		<date2>				(i) date value
// return days between dates
//
long DLLEXPORT WINAPI DateCmp(Date_t date1, Date_t date2);

// DateStartWeek - return date representing first day of the week relative to date <d>
//		<d>					(i) date value
// return date value (0 if error)
//
Date_t DLLEXPORT WINAPI DateStartWeek(Date_t d);

// DateEndWeek - return date representing last day of the week relative to date <d>
//		<d>					(i) date value
// return date value (0 if error)
//
Date_t DLLEXPORT WINAPI DateEndWeek(Date_t d);

// DateStartMonth - return date representing first day of the month relative to date <d>
//		<d>					(i) date value
// return date value (0 if error)
//
Date_t DLLEXPORT WINAPI DateStartMonth(Date_t d);

// DateEndMonth - return date representing last day of the month relative to date <d>
//		<d>					(i) date value
// return date value (0 if error)
//
Date_t DLLEXPORT WINAPI DateEndMonth(Date_t d);

// DateStartQuarter - return date representing first day of the quarter relative to date <d>
//		<d>					(i) date value
// return date value (0 if error)
//
Date_t DLLEXPORT WINAPI DateStartQuarter(Date_t d);

// DateEndQuarter - return date representing last day of the quarter relative to date <d>
//		<d>					(i) date value
// return date value (0 if error)
//
Date_t DLLEXPORT WINAPI DateEndQuarter(Date_t d);

// DateStartYear - return date representing first day of the year relative to date <d>
//		<d>					(i) date value
// return date value (0 if error)
//
Date_t DLLEXPORT WINAPI DateStartYear(Date_t d);

// DateEndYear - return date representing last day of the year relative to date <d>
//		<d>					(i) date value
// return date value (0 if error)
//
Date_t DLLEXPORT WINAPI DateEndYear(Date_t d);

// DateStartLastWeek - return date representing first day of previous week
// return date value (0 if error)
//
Date_t DLLEXPORT WINAPI DateStartLastWeek(void);

// DateEndLastWeek - return date representing last day of previous week
// return date value (0 if error)
//
Date_t DLLEXPORT WINAPI DateEndLastWeek(void);

// DateStartLastMonth - return date representing first day of previous month
// return date value (0 if error)
//
Date_t DLLEXPORT WINAPI DateStartLastMonth(void);

// DateEndLastMonth - return date representing last day of previous month
// return date value (0 if error)
//
Date_t DLLEXPORT WINAPI DateEndLastMonth(void);

// DateStartLastQuarter - return date representing first day of previous quarter
// return date value (0 if error)
//
Date_t DLLEXPORT WINAPI DateStartLastQuarter(void);

// DateEndLastQuarter - return date representing last day of previous quarter
// return date value (0 if error)
//
Date_t DLLEXPORT WINAPI DateEndLastQuarter(void);

// DateStartLastYear - return date representing first day of previous year
// return date value (0 if error)
//
Date_t DLLEXPORT WINAPI DateStartLastYear(void);

// DateEndLastYear - return date representing last day of previous year
// return date value (0 if error)
//
Date_t DLLEXPORT WINAPI DateEndLastYear(void);

// DateThisMonth - return date representing specified day of current month
//		<day>				(i) day value
// return date value (0 if error)
//
Date_t DLLEXPORT WINAPI DateThisMonth(Day_t day);

// DateLastMonth - return date representing specified day of previous month
//		<day>				(i) day value
// return date value (0 if error)
//
Date_t DLLEXPORT WINAPI DateLastMonth(Day_t day);

// macros to emulate MS Excel macros, etc.
//
#define DATE(y, m, d) Date(y, m, d)
#define TODAY() DateToday()
#define DATEVALUE(lpszDate) DateValue(lpszDate)
#define YEAR(d) DateYear(d)
#define MONTH(d) DateMonth(d)
#define DAY(d) DateDay(d)
#define WEEKDAY(d) DateWeekDay(d)
#define ISVALIDDATE(date) DateIsValid(date)
#define ISLEAPYEAR(y) DateIsLeapYear(y)
#define NEWDATE(date, offset) DateNew(date, offset)
#define DATECMP(d1, d2) DateCmp(d1, d2)
#define STARTWEEK(d) DateStartWeek(d)
#define ENDWEEK(d) DateEndWeek(d)
#define STARTMONTH(d) DateStartMonth(d)
#define ENDMONTH(d) DateEndMonth(d)
#define STARTQUARTER(d) DateStartQuarter(d)
#define ENDQUARTER(d) DateEndQuarter(d)
#define STARTYEAR(d) DateStartYear(d)
#define ENDYEAR(d) DateEndYear(d)
#define STARTLASTWEEK() DateStartLastWeek()
#define ENDLASTWEEK() DateEndLastWeek()
#define STARTLASTMONTH() DateStartLastMonth()
#define ENDLASTMONTH() DateEndLastMonth()
#define STARTLASTQUARTER() DateStartLastQuarter()
#define ENDLASTQUARTER() DateEndLastQuarter()
#define STARTLASTYEAR() DateStartLastYear()
#define ENDLASTYEAR() DateEndLastYear()
#define THISMONTH(d) DateThisMonth(d)
#define LASTMONTH(d) DateLastMonth(d)

#ifdef __cplusplus
}
#endif

#endif // __DATE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\date.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	date.c - date functions
////

#include "winlocal.h"

#include <time.h>

#include "date.h"
#include "str.h"
#include "mem.h"

////
//	private definitions
////

// Date_t is stored as (year - BASEYEAR) * YEARFACTOR + month * MONTHFACTOR + day
// i.e. July 25th, 1959 is stored as 590725
//
#define BASEYEAR 1900
#define YEARFACTOR 10000L
#define MONTHFACTOR 100

static short aDays[] = { 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
static TCHAR *aMonths[] = { TEXT(""),
							TEXT("JAN"), TEXT("FEB"), TEXT("MAR"),
							TEXT("APR"), TEXT("MAY"), TEXT("JUN"),
							TEXT("JUL"), TEXT("AUG"), TEXT("SEP"),
							TEXT("OCT"), TEXT("NOV"), TEXT("DEC") };

// helper functions
//
static Month_t MonthValue(LPCTSTR lpszMonth);

////
//	public functions
////

// Date - return date value representing year <y>, month <m>, and day <d>
//		<y>					(i) year
//		<m>					(i) month
//		<d>					(i) day
// return date value (0 if error)
// NOTE: if year is between 0 and 27, 2000 is added to it
// NOTE: if year is between 28 and 127, 1900 is added to it
//
Date_t DLLEXPORT WINAPI Date(Year_t y, Month_t m, Day_t d)
{
	Date_t date;

	if (y < 28)
		y += 2000;
	else if (y < 128)
		y += 1900;

	date = (y - BASEYEAR) * YEARFACTOR + m * MONTHFACTOR + d;

	if (!DateIsValid(date))
		return (Date_t) 0;

	return date;
}

// DateToday - return date value representing current year, month, and day
// return date value (0 if error)
//
Date_t DLLEXPORT WINAPI DateToday(void)
{
	static time_t timeCurr;
	static struct tm *tmCurr;

	timeCurr = time(NULL);
	tmCurr = localtime(&timeCurr);

	return Date((Year_t) (tmCurr->tm_year + 1900),
		(Month_t) (tmCurr->tm_mon + 1), (Day_t) tmCurr->tm_mday);
}

// DateValue - return date value representing given date string
//		<lpszDate>			(i) date string to convert
//			"JUL 25 1959"
//			"25 JUL 1959"
//			"7-25-1959"
//			etc.
// return date value (0 if error)
// NOTE: this function assumes English language month names only
// NOTE: if no year specified, current year is assumed
//
Date_t DLLEXPORT WINAPI DateValue(LPCTSTR lpszDate)
{
	Year_t y = 0;
	Month_t m = 0;
	Day_t d = 0;
	LPTSTR lpszDelimiters = TEXT(" \t/-.,;:");
	TCHAR szDateTmp[32];
	LPTSTR lpszToken1;
	LPTSTR lpszToken2;
	LPTSTR lpszToken3;

	*szDateTmp = '\0';
	if (lpszDate != NULL)
		StrNCpy(szDateTmp, lpszDate, SIZEOFARRAY(szDateTmp));

	lpszToken1 = StrTok(szDateTmp, lpszDelimiters);
	lpszToken2 = StrTok(NULL, lpszDelimiters);
	lpszToken3 = StrTok(NULL, lpszDelimiters);

	if (lpszToken1 != NULL && ChrIsAlpha(*lpszToken1))
	{
		// assume JAN 31 1991 format
		//
		m = MonthValue(lpszToken1);
		d = (lpszToken2 == NULL ? 0 : StrAtoI(lpszToken2));
	}
	else if (lpszToken2 != NULL && ChrIsAlpha(*lpszToken2))
	{
		// assume 31 JAN 1991 format
		//
		m = MonthValue(lpszToken2);
		d = (lpszToken1 == NULL ? 0 : StrAtoI(lpszToken1));
	}
	else
	{
		// assume 1-31-1991 format
		//
		m = (lpszToken1 == NULL ? 0 : StrAtoI(lpszToken1));
		d = (lpszToken2 == NULL ? 0 : StrAtoI(lpszToken2));
	}

	y = (lpszToken3 == NULL ? 0 : StrAtoI(lpszToken3));
	if (y == 0)
		y = DateYear(DateToday());

	return Date(y, m, d);
}

// DateYear - return year of a given date (1900-2027)
//		<d>					(i) date value
// return year
//
Year_t DLLEXPORT WINAPI DateYear(Date_t d)
{
	return (Year_t) (d / YEARFACTOR) + BASEYEAR;
}

// DateMonth - return month of a given date (1-12)
//		<d>					(i) date value
// return month
//
Month_t DLLEXPORT WINAPI DateMonth(Date_t d)
{
	return (Month_t) ((d % YEARFACTOR) / MONTHFACTOR);
}

// DateDay - return day of the month for a given date (1-31)
//		<d>					(i) date value
// return day
//
Day_t DLLEXPORT WINAPI DateDay(Date_t d)
{
	return (Day_t) ((d % YEARFACTOR) % MONTHFACTOR);
}

// DateWeekDay - return day of the week for a given date
//		<date>				(i) date value
//		<dwFlags>			(i) control flags
//			0					default algorithm
//			DATEWEEKDAY_MKTIME	mktime algorithm (1/1/1970 - 1/18/2038)
//			DATEWEEKDAY_QUICK	quick algorithm (3/2/1924 - 2/28/2100)
//			DATEWEEKDAY_ZELLER	zeller congruence algorithm (1582 - )
//			DATEWEEKDAY_SAKAMOTO Tomohiko Sakamoto algorithm (1752 - )
// return day of week (0 if error, 1 if SUN, 2 if MON, etc)
//
Weekday_t DLLEXPORT WINAPI DateWeekDay(Date_t date, DWORD dwFlags)
{
	Year_t y;
	Month_t m;
	Day_t d;

	if (!DateIsValid(date))
		return (Weekday_t) 0;

	y = DateYear(date);
	m = DateMonth(date);
	d = DateDay(date);

	if (dwFlags == 0)
		dwFlags |= DATEWEEKDAY_ZELLER;

	if (dwFlags & DATEWEEKDAY_MKTIME)
	{
#ifndef _WIN32
		static
#endif
		struct tm tmRef;

		MemSet(&tmRef, 0, sizeof(tmRef));

		tmRef.tm_year = y - 1900;
		tmRef.tm_mon = m - 1;
		tmRef.tm_mday = d;

		if (mktime(&tmRef) == -1)
			return (Weekday_t) 0;
		else
			return (Weekday_t) (tmRef.tm_wday + 1);
	}

	if (dwFlags & DATEWEEKDAY_QUICK)
	{
		// NOTE: quick algorithm valid only for 3/2/1924 - 2/28/2100

		y -= 1900;
	    if (m > 2)
	        m -= 2;
	    else
	    {
	        m += 10;
	        --y;
	    }

	    return (Weekday_t) ((((m * 13 - 1) / 5) + d + y + (y / 4) - 34) % 7) + 1;
	}

	if (dwFlags & DATEWEEKDAY_ZELLER)
	{
		short ccyy = y;
		short mm = m;
		short dd = d;

		short n1;
		long n2;
		short r;
		short wccyy;
		short wm;
		short wccyyd400;
		short wccyyd100;
		short zday_num;

		wccyy = ccyy;
		wm = mm;

		if (wm < 3)
		{
			wm = wm + 12;
			wccyy = ccyy - 1;
		}

		n1 = (wm + 1) * 26 / 10;
		n2 = wccyy * 125 / 100;
		wccyyd400 = wccyy / 400;
		wccyyd100 = wccyy / 100;
		zday_num = wccyyd400 - wccyyd100 + dd + n1 + (short) n2;
		r = zday_num / 7;

		/* 0=sat 1=sun 2=mon 3=tue 4=wed 5=thu 6=fri */
		zday_num = zday_num - r * 7;

		/* 7=sat */
		if (zday_num == 0)
			zday_num = 7;

		return(zday_num);
	}

	if (dwFlags & DATEWEEKDAY_SAKAMOTO)
	{
		// Tomohiko Sakamoto
		//
		static int t[] = {0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4};
		y -= m < 3;
		return ((y + y/4 - y/100 + y/400 + t[m-1] + d) % 7) + 1;
	}

	return 0;
}

// DateIsValid - test <date> for validity
//		<date>				(i) date value
// return TRUE if valid
//
BOOL DLLEXPORT WINAPI DateIsValid(Date_t date)
{
	BOOL fValid = TRUE;
	Year_t y = DateYear(date);
	Month_t m = DateMonth(date);
	Day_t d = DateDay(date);

	// check for invalid year, month, or day
	//
	if (y < 0 || y > 9999 || m < 1 || m > 12 || d < 1 || d > aDays[m])
        fValid = FALSE;

	// February 29th only on leap years
	//
    if (m == 2 && d == 29 && !DateIsLeapYear(y))
        fValid = FALSE;

    return fValid;
}

// DateIsLeapYear - return TRUE if <y> represents a leap year
//		<y>					(i) year value
// return TRUE if leap year
//
BOOL DLLEXPORT WINAPI DateIsLeapYear(Year_t y)
{
	return (BOOL) (y % 4 == 0 && y % 100 != 0 || y % 400 == 0);
}

// DateNew - return date value which is <n> days from date <date>
//		<date>				(i) date value
//		<n>					(i) delta
//			+1					one day later
//			-1					one day earlier, etc.
// return date value (0 if error)
//
Date_t DLLEXPORT WINAPI DateNew(Date_t date, short n)
{
	Year_t y;
	Month_t m;
	Day_t d;

	if (!DateIsValid(date))
		return (Date_t) 0;

	y = DateYear(date);
	m = DateMonth(date);
	d = DateDay(date);

    if (n > 0)
    {
		// increment date n times
		//
        for ( ; n != 0; n--)
        {
            if ((++d > aDays[m]) || (m == 2 && d == 29 && !DateIsLeapYear(y)))
            {
                d = 1;
                if (++m == 13)
                {
                    m = 1;
                    y++;
                }
            }
        }
    }
    else
    {
		// decrement date n times
		//
        for ( ; n != 0; n++)
        {
            if (--d == 0)
            {
                if (--m == 2 && !DateIsLeapYear(y))
                    d = 28;
                else
                {
                    if (m == 0)
                    {
                        m = 12;
                        --y;
                    }
                    d = aDays[m];
                }
            }
        }
    }
	return Date(y, m, d);
}

// DateCmp - return number of days between date1 and date2 (date1 minus date2)
//		<date1>				(i) date value
//		<date2>				(i) date value
// return days between dates
//
long DLLEXPORT WINAPI DateCmp(Date_t date1, Date_t date2)
{
	Year_t y1 = DateYear(date1);
	Month_t m1 = DateMonth(date1);
	Day_t d1 = DateDay(date1);
	Year_t y2 = DateYear(date2);
	Month_t m2 = DateMonth(date2);
	Day_t d2 = DateDay(date2);

    if (m1 <= 2)
    {
        --y1;
        m1 += 13;
    }
    else
        ++m1;

    if (m2 <= 2)
    {
        --y2;
        m2 += 13;
    }
    else
        ++m2;

    return ((long) ((1461L * y1) / 4 + (153 * m1) / 5 + d1) -
                   ((1461L * y2) / 4 + (153 * m2) / 5 + d2));
}

// DateStartWeek - return date representing first day of the week relative to date <d>
//		<d>					(i) date value
// return date value (0 if error)
//
Date_t DLLEXPORT WINAPI DateStartWeek(Date_t d)
{
	return DateNew(d, (short) (- DateWeekDay(d, 0) + 1));
}

// DateEndWeek - return date representing last day of the week relative to date <d>
//		<d>					(i) date value
// return date value (0 if error)
//
Date_t DLLEXPORT WINAPI DateEndWeek(Date_t d)
{
	return DateNew(d, (short) (- DateWeekDay(d, 0) + 7));
}

// DateStartMonth - return date representing first day of the month relative to date <d>
//		<d>					(i) date value
// return date value (0 if error)
//
Date_t DLLEXPORT WINAPI DateStartMonth(Date_t d)
{
	return Date(DateYear(d), DateMonth(d), 1);
}

// DateEndMonth - return date representing last day of the month relative to date <d>
//		<d>					(i) date value
// return date value (0 if error)
//
Date_t DLLEXPORT WINAPI DateEndMonth(Date_t d)
{
	Year_t year = DateYear(d);
	Month_t month = DateMonth(d);
	Day_t day = aDays[DateMonth(d)];

	if (month == 2 && !DateIsLeapYear(year))
		--day;

	return Date(year, month, day);
}

// DateStartQuarter - return date representing first day of the quarter relative to date <d>
//		<d>					(i) date value
// return date value (0 if error)
//
Date_t DLLEXPORT WINAPI DateStartQuarter(Date_t d)
{
	return Date(DateYear(d), (Month_t) (3 * ((DateMonth(d) - 1) / 3) + 1), 1);
}

// DateEndQuarter - return date representing last day of the quarter relative to date <d>
//		<d>					(i) date value
// return date value (0 if error)
//
Date_t DLLEXPORT WINAPI DateEndQuarter(Date_t d)
{
	return DateEndMonth(Date(DateYear(d), (Month_t) (3 * ((DateMonth(d) - 1) / 3) + 3), 1));
}

// DateStartYear - return date representing first day of the year relative to date <d>
//		<d>					(i) date value
// return date value (0 if error)
//
Date_t DLLEXPORT WINAPI DateStartYear(Date_t d)
{
	return Date(DateYear(d), 1, 1);
}

// DateEndYear - return date representing last day of the year relative to date <d>
//		<d>					(i) date value
// return date value (0 if error)
//
Date_t DLLEXPORT WINAPI DateEndYear(Date_t d)
{
	return Date(DateYear(d), 12, 31);
}

// DateStartLastWeek - return date representing first day of previous week
// return date value (0 if error)
//
Date_t DLLEXPORT WINAPI DateStartLastWeek(void)
{
	return DateStartWeek(DateEndLastWeek());
}

// DateEndLastWeek - return date representing last day of previous week
// return date value (0 if error)
//
Date_t DLLEXPORT WINAPI DateEndLastWeek(void)
{
	return DateNew(DateStartWeek(DateToday()), -1);
}

// DateStartLastMonth - return date representing first day of previous month
// return date value (0 if error)
//
Date_t DLLEXPORT WINAPI DateStartLastMonth(void)
{
	return DateStartMonth(DateEndLastMonth());
}

// DateEndLastMonth - return date representing last day of previous month
// return date value (0 if error)
//
Date_t DLLEXPORT WINAPI DateEndLastMonth(void)
{
	return DateNew(DateStartMonth(DateToday()), -1);
}

// DateStartLastQuarter - return date representing first day of previous quarter
// return date value (0 if error)
//
Date_t DLLEXPORT WINAPI DateStartLastQuarter(void)
{
	return DateStartQuarter(DateEndLastQuarter());
}

// DateEndLastQuarter - return date representing last day of previous quarter
// return date value (0 if error)
//
Date_t DLLEXPORT WINAPI DateEndLastQuarter(void)
{
	return DateNew(DateStartQuarter(DateToday()), -1);
}

// DateStartLastYear - return date representing first day of previous year
// return date value (0 if error)
//
Date_t DLLEXPORT WINAPI DateStartLastYear(void)
{
	return DateStartYear(DateEndLastYear());
}

// DateEndLastYear - return date representing last day of previous year
// return date value (0 if error)
//
Date_t DLLEXPORT WINAPI DateEndLastYear(void)
{
	return DateNew(DateStartYear(DateToday()), -1);
}

// DateThisMonth - return date representing specified day of current month
//		<day>				(i) day value
// return date value (0 if error)
//
Date_t DLLEXPORT WINAPI DateThisMonth(Day_t day)
{
	return Date(DateYear(DateToday()), DateMonth(DateToday()), day);
}

// DateLastMonth - return date representing specified day of previous month
//		<day>				(i) day value
// return date value (0 if error)
//
Date_t DLLEXPORT WINAPI DateLastMonth(Day_t day)
{
	return Date(DateYear(DateStartLastMonth()), DateMonth(DateStartLastMonth()), day);
}

////
//	private functions
////

// GetMonth - return month number equivalent to month name ("JAN" = 1, "FEB" = 2,...)
//		<lpszMonth>			(i) string representing month
//			"JAN"
//			"Jan"
//			"JANUARY"
//			etc.
// return month value (0 if error)
//
static Month_t MonthValue(LPCTSTR lpszMonth)
{
	short i;
	Month_t month = 0;

	for (i = 1; i < SIZEOFARRAY(aMonths); ++i)
	{
		if (MemICmp(lpszMonth, aMonths[i], StrLen(aMonths[i])) == 0)
		{
			month = i;
			break;
		}
	}

	return month;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\escbutt.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	escbutt.c - escape button control functions
////

#include "winlocal.h"

#include "escbutt.h"
#include "trace.h"

////
//	private definitions
////

// escbutt control struct
//
typedef struct ESCBUTT
{
	WNDPROC lpfnButtWndProc;
	DWORD dwFlags;
} ESCBUTT, FAR *LPESCBUTT;

// helper functions
//
LRESULT DLLEXPORT CALLBACK EscButtWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

////
//	public functions
////

// EscButtInit - initialize escape subclass from button control
//		<hwndButt>			(i) button control to be subclassed
//		<dwFlags>			(i) subclass flags
//			reserved			must be zero
// return 0 if success
//
int DLLEXPORT WINAPI EscButtInit(HWND hwndButt, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	WNDPROC lpfnEscButtWndProc;
	HGLOBAL hEscButt;
	LPESCBUTT lpEscButt;

	if (hwndButt == NULL)
		fSuccess = TraceFALSE(NULL);

	// get pointer to escape subclass window proc
	//
	else if ((lpfnEscButtWndProc =
		(WNDPROC) MakeProcInstance((FARPROC) EscButtWndProc,
		(HINSTANCE) GetWindowWordPtr(GetParent(hwndButt), GWWP_HINSTANCE))) == NULL)
		fSuccess = TraceFALSE(NULL);

	// memory is allocated such that the client app owns it
	//
	else if ((hEscButt = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT,
			sizeof(ESCBUTT))) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpEscButt = GlobalLock(hEscButt)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// store old window proc address
	//
	else if ((lpEscButt->lpfnButtWndProc =
		(WNDPROC) GetWindowLongPtr(hwndButt, GWLP_WNDPROC)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// store flags
	//
	else if ((lpEscButt->dwFlags = dwFlags) != dwFlags)
		fSuccess = TraceFALSE(NULL);

	else if (GlobalUnlock(hEscButt), FALSE)
		;

	// store old window proc address as a property of the control window
	//
	else if (!SetProp(hwndButt, TEXT("hEscButt"), hEscButt))
		fSuccess = TraceFALSE(NULL);

	// replace old window proc with new window proc
	//
	else if ( !SetWindowLongPtr(hwndButt, GWLP_WNDPROC, (LONG_PTR) lpfnEscButtWndProc) )
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}

// EscButtTerm - terminate escape subclass from button control
//		<hwndButton>		(i) subclassed button control
// return 0 if success
//
int DLLEXPORT WINAPI EscButtTerm(HWND hwndButt)
{
	BOOL fSuccess = TRUE;
	WNDPROC lpfnEscButtWndProc;
	HGLOBAL hEscButt;
	LPESCBUTT lpEscButt;

	if (hwndButt == NULL)
		fSuccess = TraceFALSE(NULL);

	// get pointer to escape subclass window proc
	//
	else if ((lpfnEscButtWndProc =
		(WNDPROC) GetWindowLongPtr(hwndButt, GWLP_WNDPROC)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// retrieve old window proc address from window property
	//
	else if ((hEscButt = GetProp(hwndButt, TEXT("hEscButt"))) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpEscButt = GlobalLock(hEscButt)) == NULL ||
		lpEscButt->lpfnButtWndProc == NULL)
		fSuccess = TraceFALSE(NULL);

	// replace new window proc with old window proc
	//
	else if ( !SetWindowLongPtr(hwndButt, GWLP_WNDPROC, (LONG_PTR) lpEscButt->lpfnButtWndProc) )
		fSuccess = TraceFALSE(NULL);

	else if (GlobalUnlock(hEscButt), FALSE)
		;

    //
    //
	else if (( hEscButt = RemoveProp(hwndButt, TEXT("hEscButt"))) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (GlobalFree(hEscButt) != NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}

////
//	helper functions
////

// EscButtWndProc - window procedure for escape button control
//
LRESULT DLLEXPORT CALLBACK EscButtWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	BOOL fSuccess = TRUE;
	LRESULT lResult;
	HGLOBAL hEscButt;
	LPESCBUTT lpEscButt;

	// retrieve old window proc address from window property
	//
	if ((hEscButt = GetProp(hwnd, TEXT("hEscButt"))) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpEscButt = GlobalLock(hEscButt)) == NULL ||
		lpEscButt->lpfnButtWndProc == NULL)
		fSuccess = TraceFALSE(NULL);

	switch (msg)
	{
		// convert escape key messages into spacebar messages
		//
		case WM_KEYUP: 
		case WM_KEYDOWN:
		case WM_CHAR:
			if (wParam == VK_ESCAPE)
				wParam = VK_SPACE;

			// fall through rather than break;

		default:
		{
			// call old window proc
			//
			if (fSuccess)
				lResult = CallWindowProc(lpEscButt->lpfnButtWndProc, hwnd, msg, wParam, lParam);
			else
				lResult = 0L;
		}
			break;
	}
	
	if (fSuccess)
		GlobalUnlock(hEscButt);

	return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\dlg.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// dlg.h - interface for dialog box functions in dlg.c
////

#ifndef __DLG_H__
#define __DLG_H__

#include "winlocal.h"

#define DLG_VERSION 0x00000100

// handle to dlg engine
//
DECLARE_HANDLE32(HDLG);

// dwFlags param in DlgInitDialog
//
#define DLG_NOCENTER		0x00000001

#ifdef __cplusplus
extern "C" {
#endif

// DlgInit - initialize dlg engine
//		<dwVersion>			(i) must be DLG_VERSION
// 		<hInst>				(i) instance handle of calling module
// return handle (NULL if error)
//
HDLG DLLEXPORT WINAPI DlgInit(DWORD dwVersion, HINSTANCE hInst);

// DlgTerm - shut down dlg engine
//		<hDlg>				(i) handle returned from DlgInit
// return 0 if success
//
int DLLEXPORT WINAPI DlgTerm(HDLG hDlg);

// DlgInitDialog - perform standard dialog box initialization
//		<hDlg>				(i) handle returned from DlgInit
//		<hwndDlg>			(i) dialog box to be initialized
//		<hwndCenter>		(i) center dialog box upon this window
//			NULL				center dialog box on its parent
//		<dwFlags>			(i) control flags
//			DLG_NOCENTER		do not center dialog box at all
// return 0 if success
//
int DLLEXPORT WINAPI DlgInitDialog(HDLG hDlg, HWND hwndDlg, HWND hwndCenter, DWORD dwFlags);

// DlgEndDialog - perform standard dialog box shutdown
//		<hDlg>				(i) handle returned from DlgInit
//		<hwndDlg>			(i) dialog box to be shutdown
//		<nResult>			(i) dialog box result code
// return 0 if success
//
int DLLEXPORT WINAPI DlgEndDialog(HDLG hDlg, HWND hwndDlg, int nResult);

// DlgGetCurrentDialog - get handle of current dialog box
//		<hDlg>				(i) handle returned from DlgInit
// return window handle (NULL if no dialog box up)
//
HWND DLLEXPORT WINAPI DlgGetCurrentDialog(HDLG hDlg);

// DlgOnCtlColor - handle WM_CTLCOLOR message sent to dialog
//		<hwndDlg>			(i) dialog box handle
//		<hdc>				(i) display context for child window
//		<hwndChild>			(i) control window handle
//		<nCtlType>			(i) control type (CTLCOLOR_BTN, CTLCOLOR_EDIT, etc)
HBRUSH DLLEXPORT WINAPI DlgOnCtlColor(HWND hwndDlg, HDC hdc, HWND hwndChild, int nCtlType);

#ifdef __cplusplus
}
#endif

#endif // __DLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\dlg.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	dlg.c - dialog box functions
////

#include "winlocal.h"

#include <stdlib.h>

#include "dlg.h"
#include "mem.h"
#include "stack.h"
#include "trace.h"
#include "wnd.h"

////
//	private definitions
////

// dlg control struct
//
typedef struct DLG
{
	DWORD dwVersion;
	HINSTANCE hInst;
	HTASK hTask;
	HSTACK hStack;
} DLG, FAR *LPDLG;

// helper functions
//
static LPDLG DlgGetPtr(HDLG hDlg);
static HDLG DlgGetHandle(LPDLG lpDlg);

////
//	public functions
////

// DlgInit - initialize dlg engine
//		<dwVersion>			(i) must be DLG_VERSION
// 		<hInst>				(i) instance handle of calling module
// return handle (NULL if error)
//
HDLG DLLEXPORT WINAPI DlgInit(DWORD dwVersion, HINSTANCE hInst)
{
	BOOL fSuccess = TRUE;
	LPDLG lpDlg = NULL;

	if (dwVersion != DLG_VERSION)
		fSuccess = TraceFALSE(NULL);
	
	else if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpDlg = (LPDLG) MemAlloc(NULL, sizeof(DLG), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpDlg->hStack = StackCreate(STACK_VERSION, hInst)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lpDlg->dwVersion = dwVersion;
		lpDlg->hInst = hInst;
		lpDlg->hTask = GetCurrentTask();
	}

	if (!fSuccess)
	{
		DlgTerm(DlgGetHandle(lpDlg));
		lpDlg = NULL;
	}

	return fSuccess ? DlgGetHandle(lpDlg) : NULL;
}

// DlgTerm - shut down dlg engine
//		<hDlg>				(i) handle returned from DlgInit
// return 0 if success
//
int DLLEXPORT WINAPI DlgTerm(HDLG hDlg)
{
	BOOL fSuccess = TRUE;
	LPDLG lpDlg;

	if ((lpDlg = DlgGetPtr(hDlg)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (StackDestroy(lpDlg->hStack) != 0)
		fSuccess = TraceFALSE(NULL);

	else if ((lpDlg = MemFree(NULL, lpDlg)) != NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}

// DlgInitDialog - perform standard dialog box initialization
//		<hDlg>				(i) handle returned from DlgInit
//		<hwndDlg>			(i) dialog box to be initialized
//		<hwndCenter>		(i) center dialog box upon this window
//			NULL				center dialog box on its parent
//		<dwFlags>			(i) control flags
//			DLG_NOCENTER		do not center dialog box at all
// return 0 if success
//
int DLLEXPORT WINAPI DlgInitDialog(HDLG hDlg, HWND hwndDlg, HWND hwndCenter, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPDLG lpDlg;
	HWND hwndParent;
	HTASK hTaskParent;

	if ((lpDlg = DlgGetPtr(hDlg)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (hwndDlg == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((hTaskParent = lpDlg->hTask) == NULL, FALSE)
		;

	else if ((hwndParent = GetParent(hwndDlg)) != NULL &&
		(hTaskParent = GetWindowTask(hwndParent)) == NULL, FALSE)
		;

	// disable all task windows except dialog box
	//
	else if (WndEnableTaskWindows(hTaskParent, FALSE, hwndDlg) != 0)
		fSuccess = TraceFALSE(NULL);

	// center the dialog box if necessary
	//
	else if (!(dwFlags & DLG_NOCENTER) &&
		WndCenterWindow(hwndDlg, hwndCenter, 0, 0) != 0)
		fSuccess = TraceFALSE(NULL);

	// keep track of current dialog box
	//
	else if (StackPush(lpDlg->hStack, (STACKELEM) hwndDlg) != 0)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}

// DlgEndDialog - perform standard dialog box shutdown
//		<hDlg>				(i) handle returned from DlgInit
//		<hwndDlg>			(i) dialog box to be shutdown
//		<nResult>			(i) dialog box result code
// return 0 if success
//
int DLLEXPORT WINAPI DlgEndDialog(HDLG hDlg, HWND hwndDlg, int nResult)
{
	BOOL fSuccess = TRUE;
	LPDLG lpDlg;
	HWND hwndParent;
	HTASK hTaskParent;

	if ((lpDlg = DlgGetPtr(hDlg)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (hwndDlg == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((hTaskParent = lpDlg->hTask) == NULL, FALSE)
		;

	else if ((hwndParent = GetParent(hwndDlg)) != NULL &&
		(hTaskParent = GetWindowTask(hwndParent)) == NULL, FALSE)
		;

	else if (hwndDlg != (HWND) StackPeek(lpDlg->hStack))
		fSuccess = TraceFALSE(NULL);

	else
	{
		// hide modal dialog box, nResult will be returned by DialogBox().
		//
		EndDialog(hwndDlg, nResult);

		// remove this dialog box handle from stack
		//
		StackPop(lpDlg->hStack);

		// enable all task windows
		//
		if (WndEnableTaskWindows(hTaskParent, TRUE, NULL) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// DlgGetCurrentDialog - get handle of current dialog box
//		<hDlg>				(i) handle returned from DlgInit
// return window handle (NULL if no dialog box up)
//
HWND DLLEXPORT WINAPI DlgGetCurrentDialog(HDLG hDlg)
{
	BOOL fSuccess = TRUE;
	LPDLG lpDlg;

	if ((lpDlg = DlgGetPtr(hDlg)) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? (HWND) StackPeek(lpDlg->hStack) : NULL;
}

// DlgOnCtlColor - handle WM_CTLCOLOR message sent to dialog
//		<hwndDlg>			(i) dialog box handle
//		<hdc>				(i) display context for child window
//		<hwndChild>			(i) control window handle
//		<nCtlType>			(i) control type (CTLCOLOR_BTN, CTLCOLOR_EDIT, etc)
HBRUSH DLLEXPORT WINAPI DlgOnCtlColor(HWND hwndDlg, HDC hdc, HWND hwndChild, int nCtlType)
{
	return (HBRUSH) NULL;
}

////
//	helper functions
////

// DlgGetPtr - verify that dlg handle is valid,
//		<hDlg>				(i) handle returned from DlgInit
// return corresponding dlg pointer (NULL if error)
//
static LPDLG DlgGetPtr(HDLG hDlg)
{
	BOOL fSuccess = TRUE;
	LPDLG lpDlg;

	if ((lpDlg = (LPDLG) hDlg) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadWritePtr(lpDlg, sizeof(DLG)))
		fSuccess = TraceFALSE(NULL);

#ifdef CHECKTASK
	// make sure current task owns the dlg handle
	//
	else if (lpDlg->hTask != GetCurrentTask())
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? lpDlg : NULL;
}

// DlgGetHandle - verify that dlg pointer is valid,
//		<lpDlg>				(i) pointer to DLG struct
// return corresponding dlg handle (NULL if error)
//
static HDLG DlgGetHandle(LPDLG lpDlg)
{
	BOOL fSuccess = TRUE;
	HDLG hDlg;

	if ((hDlg = (HDLG) lpDlg) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hDlg : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\escbutt.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// escbutt.h - interface for escape button control functions in escbutt.c
////

#ifndef __ESCBUTT_H__
#define __ESCBUTT_H__

#ifdef __cplusplus
extern "C" {
#endif

#include "winlocal.h"

#define ESCBUTT_VERSION 0x00000100

// EscButtInit - initialize escape subclass from button control
//		<hwndButt>			(i) button control to be subclassed
//		<dwFlags>			(i) subclass flags
//			reserved			must be zero
// return 0 if success
//
int DLLEXPORT WINAPI EscButtInit(HWND hwndButt, DWORD dwFlags);

// EscButtTerm - terminate escape subclass from button control
//		<hwndButton>		(i) subclassed button control
// return 0 if success
//
int DLLEXPORT WINAPI EscButtTerm(HWND hwndButt);

#ifdef __cplusplus
}
#endif

#endif // __ESCBUTT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\file.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// file.h - interface for file functions in file.c
////

#ifndef __FILE_H__
#define __FILE_H__

#include "winlocal.h"

#include <io.h>
#include <tchar.h>

#define FILE_VERSION 0x00000104

// handle to file (NOT the same as Windows HFILE)
//
DECLARE_HANDLE32(HFIL);

#ifdef __cplusplus
extern "C" {
#endif

// FileCreate - create a new file or truncate existing file
//		see _lcreate() documentation for behavior
//		<fTaskOwned>		(i) who should own the new file handle?
//			TRUE				calling task should own the file handle
//			FALSE				filesup.exe should own the file handle
// returns file handle if success or NULL
//
HFIL DLLEXPORT WINAPI FileCreate(LPCTSTR lpszFilename, int fnAttribute, BOOL fTaskOwned);

// FileOpen - open an existing file
//		see _lopen() documentation for behavior
//		<fTaskOwned>		(i) who should own the new file handle?
//			TRUE				calling task should own the file handle
//			FALSE				filesup.exe should own the file handle
// returns file handle if success or NULL
//
HFIL DLLEXPORT WINAPI FileOpen(LPCTSTR lpszFilename, int fnOpenMode, BOOL fTaskOwned);

// FileSeek - reposition read/write pointer of an open file
//		see _llseek() documentation for behavior
// returns new file position if success or -1
//
LONG DLLEXPORT WINAPI FileSeek(HFIL hFile, LONG lOffset, int nOrigin);

// FileRead - read data from an open file
//		see _lread() and _hread() documentation for behavior
// returns number of bytes read if success or -1
//
long DLLEXPORT WINAPI FileRead(HFIL hFile, void _huge * hpvBuffer, long cbBuffer);

// FileReadLine - read up through the next newline in an open file
// returns number of bytes read if success or -1
//
long DLLEXPORT WINAPI FileReadLine(HFIL hFile, void _huge * hpvBuffer, long cbBuffer);

// FileWrite - write data to an open file
//		see _lwrite() and _hwrite() documentation for behavior
// returns number of bytes read if success or -1
//
long DLLEXPORT WINAPI FileWrite(HFIL hFile, const void _huge * hpvBuffer, long cbBuffer);

// FileClose - close an open file
//		see _lclose() documentation for behavior
// returns 0 if success
//
int DLLEXPORT WINAPI FileClose(HFIL hFile);

// FileExists - return TRUE if specified file exists
//		<lpszFileName>		(i) file name
// return TRUE or FALSE
//
#ifdef NOTRACE
#define FileExists(lpszFileName) \
	(_taccess(lpszFileName, 0) == 0)
#else
BOOL DLLEXPORT WINAPI FileExists(LPCTSTR lpszFileName);
#endif

// FileFullPath - parse file spec, construct full path
//		see _fullpath() documentation for behavior
// return <lpszFullPath> if success or NULL
//
#ifdef NOTRACE
#define FileFullPath(lpszFullPath, lpszFileSpec, sizFullPath) \
	_tfullpath(lpszFullPath, lpszFileSpec, sizFullPath)
#else
LPTSTR DLLEXPORT WINAPI FileFullPath(LPTSTR lpszFullPath, LPCTSTR lpszFileSpec, int sizFullPath);
#endif

// FileSplitPath - break a full path into its components
//		see _splitpath() documentation for behavior
// return 0 if success
//
#ifdef NOTRACE
#define FileSplitPath(lpszPath, lpszDrive, lpszDir, lpszFname, lpszExt) \
	(_tsplitpath(lpszPath, lpszDrive, lpszDir, lpszFname, lpszExt), 0)
#else
int DLLEXPORT WINAPI FileSplitPath(LPCTSTR lpszPath, LPTSTR lpszDrive, LPTSTR lpszDir, LPTSTR lpszFname, LPTSTR lpszExt);
#endif

// FileMakePath - make a full path from specified components
//		see _makepath() documentation for behavior
// return 0 if success
//
#ifdef NOTRACE
#define FileMakePath(lpszPath, lpszDrive, lpszDir, lpszFname, lpszExt) \
	(_tmakepath(lpszPath, lpszDrive, lpszDir, lpszFname, lpszExt), 0)
#else
int DLLEXPORT WINAPI FileMakePath(LPTSTR lpszPath, LPCTSTR lpszDrive, LPCTSTR lpszDir, LPCTSTR lpszFname, LPCTSTR lpszExt);
#endif

// FileRemove - delete specified file
//		see remove() documentation for behavior
// return 0 if success
//
#ifdef NOTRACE
#define FileRemove(lpszFileName) \
	_tremove(lpszFileName)
#else
int DLLEXPORT WINAPI FileRemove(LPCTSTR lpszFileName);
#endif

// FileRename - rename specified file
//		see rename() documentation for behavior
// return 0 if success
//
#ifdef NOTRACE
#define FileRename(lpszOldName, lpszNewName) \
	_trename(lpszOldName, lpszNewName)
#else
int DLLEXPORT WINAPI FileRename(LPCTSTR lpszOldName, LPCTSTR lpszNewName);
#endif

// GetTempFileNameEx - create temporary file, extended version
//
// This function is similar to GetTempFileName(),
// except that <lpPrefixString> is replaced by <lpExtensionString>
// See Windows SDK documentation for description of original GetTempFileName()
//
UINT DLLEXPORT WINAPI GetTempFileNameEx(LPCTSTR lpPathName,
	LPCTSTR lpExtensionString, UINT uUnique, LPTSTR lpTempFileName);

#ifdef __cplusplus
}
#endif

#endif // __FILE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\file.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	file.c - file functions
////

#include "winlocal.h"

#include <stdlib.h>
#include <io.h>
#include <sys/types.h>
#include <sys/stat.h>

#include "file.h"
#ifdef FILESUP
#include "filesup.h"
#endif
#include "mem.h"
#include "str.h"

////
//	private definitions
////

// file control struct
//
typedef struct FIL
{
	DWORD dwVersion;
	HINSTANCE hInst;
	HTASK hTask;
#ifdef _WIN32
	HANDLE hf;
#else
	HFILE hf;
#endif
	BOOL fTaskOwned;
	LPBYTE lpabBuf;
	long iBuf;
	long cbBuf;
} FIL, FAR *LPFIL;

#define FILEREADLINE_BUFSIZ 4096

#ifdef FILESUP
static int cFileSupUsage = 0;
static HWND hwndFileSup = NULL;
#endif

static TCHAR szFileName[_MAX_PATH];
static struct _stat statbuf;
static TCHAR szPath[_MAX_PATH];
static TCHAR szDrive[_MAX_DRIVE];
static TCHAR szDir[_MAX_DIR];
static TCHAR szFname[_MAX_FNAME];
static TCHAR szExt[_MAX_EXT];

// helper functions
//
static LPFIL FileGetPtr(HFIL hFile);
static HFIL FileGetHandle(LPFIL lpFile);
#ifdef FILESUP
static int FileSupUsage(int nDelta);
static int FileSupInit(void);
static int FileSupTerm(void);
#endif

////
//	public functions
////

// FileCreate - create a new file or truncate existing file
//		see _lcreate() documentation for behavior
//		<fTaskOwned>		(i) who should own the new file handle?
//			TRUE				calling task should own the file handle
#ifdef FILESUP
//			FALSE				filesup.exe should own the file handle
#endif
// returns file handle if success or NULL
//
HFIL DLLEXPORT WINAPI FileCreate(LPCTSTR lpszFilename, int fnAttribute, BOOL fTaskOwned)
{
	BOOL fSuccess = TRUE;
	LPFIL lpFile;
	DWORD dwVersion = FILE_VERSION; // currently not supplied by caller
	HINSTANCE hInst = NULL; // currently not supplied by caller

	if (lpszFilename == NULL)
		fSuccess = FALSE;

	else if ((lpFile = (LPFIL) MemAlloc(NULL, sizeof(FIL), 0)) == NULL)
		fSuccess = FALSE;

	else
	{
		lpFile->dwVersion = dwVersion;
		lpFile->hInst = hInst;
		lpFile->hTask = GetCurrentTask();
#ifdef _WIN32
		lpFile->hf = NULL;
#else
		lpFile->hf = HFILE_ERROR;
#endif
#ifdef FILESUP
		lpFile->fTaskOwned = fTaskOwned;
#else
		lpFile->fTaskOwned = TRUE;
#endif
		lpFile->lpabBuf = NULL;
		lpFile->iBuf = -1L;
		lpFile->cbBuf = 0L;

		if (lpFile->fTaskOwned)
		{
#ifdef _WIN32
			if ((lpFile->hf = CreateFile(lpszFilename, GENERIC_READ | GENERIC_WRITE, 0, NULL,
				CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | \
				((fnAttribute & 1) ? FILE_ATTRIBUTE_READONLY : 0) | \
				((fnAttribute & 2) ? FILE_ATTRIBUTE_HIDDEN : 0) | \
				((fnAttribute & 4) ? FILE_ATTRIBUTE_SYSTEM : 0), NULL)) == NULL)
#else
			if ((lpFile->hf = _lcreat(lpszFilename, fnAttribute)) == HFILE_ERROR)
#endif
				fSuccess = FALSE;
		}
#ifdef FILESUP
		else
		{
			if (FileSupUsage(+1) != 0)
				fSuccess = FALSE;

			else
			{
				FILECREATE fc;

				fc.lpszFilename = lpszFilename;
				fc.fnAttribute = fnAttribute;

				if (hwndFileSup == NULL)
					fSuccess = FALSE;

				else if ((lpFile->hf = (HFILE) SendMessage(hwndFileSup,
					WM_FILECREATE, 0, (LPARAM) (LPFILECREATE) &fc)) == HFILE_ERROR)
					fSuccess = FALSE;

				if (!fSuccess)
					FileSupUsage(-1);
			}
		}
#endif
	}

	return fSuccess ? FileGetHandle(lpFile) : NULL;
}

// FileOpen - open an existing file
//		see _lopen() documentation for behavior
//		<fTaskOwned>		(i) who should own the new file handle?
//			TRUE				calling task should own the file handle
#ifdef FILESUP
//			FALSE				filesup.exe should own the file handle
#endif
// returns file handle if success or NULL
//
HFIL DLLEXPORT WINAPI FileOpen(LPCTSTR lpszFilename, int fnOpenMode, BOOL fTaskOwned)
{
	BOOL fSuccess = TRUE;
	LPFIL lpFile;
	DWORD dwVersion = FILE_VERSION; // currently not supplied by caller
	HINSTANCE hInst = NULL; // currently not supplied by caller

	if (lpszFilename == NULL)
		fSuccess = FALSE;

	else if ((lpFile = (LPFIL) MemAlloc(NULL, sizeof(FIL), 0)) == NULL)
		fSuccess = FALSE;

	else
	{
		lpFile->dwVersion = dwVersion;
		lpFile->hInst = hInst;
		lpFile->hTask = GetCurrentTask();
#ifdef _WIN32
		lpFile->hf = NULL;
#else
		lpFile->hf = HFILE_ERROR;
#endif
#ifdef FILESUP
		lpFile->fTaskOwned = fTaskOwned;
#else
		lpFile->fTaskOwned = TRUE;
#endif
		lpFile->lpabBuf = NULL;
		lpFile->iBuf = -1L;
		lpFile->cbBuf = 0L;

		if (lpFile->fTaskOwned)
		{
#ifdef _WIN32
			if ((lpFile->hf = CreateFile(lpszFilename,
				((fnOpenMode & 3) ? 0 : GENERIC_READ) | \
				((fnOpenMode & 1) ? GENERIC_WRITE : 0) | \
				((fnOpenMode & 2) ? GENERIC_READ | GENERIC_WRITE : 0), \
				0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)) == NULL)
#else
			if ((lpFile->hf = _lopen(lpszFilename, fnOpenMode)) == HFILE_ERROR)
#endif
				fSuccess = FALSE;
		}
#ifdef FILESUP
		else
		{
			if (FileSupUsage(+1) != 0)
				fSuccess = FALSE;

			else
			{
				FILEOPEN fo;

				fo.lpszFilename = lpszFilename;
				fo.fnOpenMode = fnOpenMode;

				if (hwndFileSup == NULL)
					fSuccess = FALSE;

				else if ((lpFile->hf = (HFILE) SendMessage(hwndFileSup,
					WM_FILEOPEN, 0, (LPARAM) (LPFILEOPEN) &fo)) == HFILE_ERROR)
					fSuccess = FALSE;

				if (!fSuccess)
					FileSupUsage(-1);
			}
		}
#endif
	}

	return fSuccess ? FileGetHandle(lpFile) : NULL;
}

// FileSeek - reposition read/write pointer of an open file
//		see _llseek() documentation for behavior
// returns new file position if success or -1
//
LONG DLLEXPORT WINAPI FileSeek(HFIL hFile, LONG lOffset, int nOrigin)
{
	BOOL fSuccess = TRUE;
	LPFIL lpFile;
    //
    // We should initialize local variable
    //
	LONG lPos = 0;

	if ((lpFile = FileGetPtr(hFile)) == NULL)
		fSuccess = FALSE;

	else if (lpFile->fTaskOwned)
	{
#ifdef _WIN32
		if ((lPos = SetFilePointer(lpFile->hf, lOffset, NULL, (DWORD) nOrigin)) == 0xFFFFFFFF)
#else
		if ((lPos = _llseek(lpFile->hf, lOffset, nOrigin)) == HFILE_ERROR)
#endif
			fSuccess = FALSE;
	}

#ifdef FILESUP
	else
	{
		FILESEEK fs;

		fs.hf = lpFile->hf;
		fs.lOffset = lOffset;
		fs.nOrigin = nOrigin;

		if (hwndFileSup == NULL)
			fSuccess = FALSE;

		else if ((lPos = (LONG) SendMessage(hwndFileSup,
			WM_FILESEEK, 0, (LPARAM) (LPFILESEEK) &fs)) == -1L)
			fSuccess = FALSE;
	}
#endif

	// don't use residual bytes in the input buffer
	//
	if (fSuccess)
	{
		lpFile->iBuf = -1L;
		lpFile->cbBuf = 0L;
	}

	return fSuccess ? lPos : -1L;
}

// FileRead - read data from an open file
//		see _lread() and _hread() documentation for behavior
// returns number of bytes read if success or -1
//
long DLLEXPORT WINAPI FileRead(HFIL hFile, void _huge * hpvBuffer, long cbBuffer)
{
	BOOL fSuccess = TRUE;
	LPFIL lpFile;
    //
    // We should initialize local variable
    //
	LONG lBytes = 0;

	if ((lpFile = FileGetPtr(hFile)) == NULL)
		fSuccess = FALSE;

	else if (lpFile->fTaskOwned)
	{
#ifdef _WIN32
		if (!ReadFile(lpFile->hf, hpvBuffer, cbBuffer, &lBytes, NULL))
		{
			fSuccess = FALSE;
			lBytes = -1L;
		}
#else
		if (cbBuffer < 0xFFFF)
			lBytes = _lread(lpFile->hf, hpvBuffer, (UINT) cbBuffer);
		else
			lBytes = _hread(lpFile->hf, hpvBuffer, cbBuffer);

		if (lBytes == HFILE_ERROR)
			fSuccess = FALSE;
#endif
	}

#ifdef FILESUP
	else
	{
		FILEREAD fr;

		fr.hf = lpFile->hf;
		fr.hpvBuffer = hpvBuffer;
		fr.cbBuffer = cbBuffer;

		if (hwndFileSup == NULL)
			fSuccess = FALSE;

		else if ((lBytes = (LONG) SendMessage(hwndFileSup,
			WM_FILEREAD, 0, (LPARAM) (LPFILEREAD) &fr)) == HFILE_ERROR)
			fSuccess = FALSE;
	}
#endif

	return fSuccess ? lBytes : -1L;
}

// FileReadLine - read up through the next newline in an open file
// returns number of bytes read if success or -1
//
// NOTE: use of this function causes subsequent input to be buffered
// therefore, once you start using FileReadLine on a file,
// don't go back to using FileRead unless you first call FileSeek
//
long DLLEXPORT WINAPI FileReadLine(HFIL hFile, void _huge * hpvBuffer, long cbBuffer)
{
	BOOL fSuccess = TRUE;
	LPFIL lpFile;
	LONG lBytes;

	if ((lpFile = FileGetPtr(hFile)) == NULL)
		fSuccess = FALSE;

	// allocate buffer space if needed
	//
	else if (lpFile->lpabBuf == NULL &&
		(lpFile->lpabBuf = (LPBYTE) MemAlloc(NULL,
		FILEREADLINE_BUFSIZ * sizeof(TCHAR), 0)) == NULL)
		fSuccess = FALSE;

	else
	{
		char c;

		lBytes = 0;
		while (lBytes < cbBuffer)
		{
			// fill buffer if necessary
			//
			if (lpFile->iBuf < 0L || lpFile->iBuf >= lpFile->cbBuf)
			{
				if ((lpFile->cbBuf = FileRead(hFile,
					lpFile->lpabBuf, FILEREADLINE_BUFSIZ * sizeof(TCHAR))) <= 0)
					break;

				lpFile->iBuf = 0L;
			}

			// get next char from buffer, place it in out buffer
			//
			if ((c = lpFile->lpabBuf[lpFile->iBuf++]) != '\r')
			{
				*((LPBYTE) hpvBuffer)++ = c;
				++lBytes;

				// reached end of line
				//
				if (c == '\n')
					break;
			}
		}

		// null terminate line
		//
		if (lBytes > 0)
			*((LPBYTE) hpvBuffer) = '\0';
	}

	return fSuccess ? lBytes : -1L;
}

// FileWrite - write data to an open file
//		see _lwrite() and _hwrite() documentation for behavior
// returns number of bytes read if success or -1
//
long DLLEXPORT WINAPI FileWrite(HFIL hFile, const void _huge * hpvBuffer, long cbBuffer)
{
	BOOL fSuccess = TRUE;
	LPFIL lpFile;
    //
    // We should initialize local variable
    //
	LONG lBytes = 0;

	if ((lpFile = FileGetPtr(hFile)) == NULL)
		fSuccess = FALSE;

	else if (lpFile->fTaskOwned)
	{
#ifdef _WIN32
		if (!WriteFile(lpFile->hf, hpvBuffer, cbBuffer, &lBytes, NULL))
		{
			fSuccess = FALSE;
			lBytes = -1L;
		}
#else
		if (cbBuffer < 0xFFFF)
			lBytes = _lwrite(lpFile->hf, hpvBuffer, (UINT) cbBuffer);
		else
			lBytes = _hwrite(lpFile->hf, hpvBuffer, cbBuffer);

		if (lBytes == HFILE_ERROR)
			fSuccess = FALSE;
#endif
	}

#ifdef FILESUP
	else
	{
		FILEWRITE fw;

		fw.hf = lpFile->hf;
		fw.hpvBuffer = hpvBuffer;
		fw.cbBuffer = cbBuffer;

		if (hwndFileSup == NULL)
			fSuccess = FALSE;

		else if ((lBytes = (LONG) SendMessage(hwndFileSup,
			WM_FILEWRITE, 0, (LPARAM) (LPFILEWRITE) &fw)) == HFILE_ERROR)
			fSuccess = FALSE;
	}
#endif

	return fSuccess ? lBytes : -1L;
}

// FileClose - close an open file
//		see _lclose() documentation for behavior
// returns 0 if success
//
int DLLEXPORT WINAPI FileClose(HFIL hFile)
{
	BOOL fSuccess = TRUE;
	LPFIL lpFile;

	if ((lpFile = FileGetPtr(hFile)) == NULL)
		fSuccess = FALSE;

	else if (lpFile->fTaskOwned)
	{
#ifdef _WIN32
		if (!CloseHandle(lpFile->hf))
#else
		if (_lclose(lpFile->hf) == HFILE_ERROR)
#endif
			fSuccess = FALSE;
	}

#ifdef FILESUP
	else
	{
		FILECLOSE fc;
		HFILE ret;

		fc.hf = lpFile->hf;

		if (hwndFileSup == NULL)
			fSuccess = FALSE;

		else if ((ret = (HFILE) SendMessage(hwndFileSup,
			WM_FILECLOSE, 0, (LPARAM) (LPFILECLOSE) &fc)) == HFILE_ERROR)
			fSuccess = FALSE;

		else if (FileSupUsage(-1) != 0)
			fSuccess = FALSE;
	}
#endif

	if (fSuccess)
	{
		if (lpFile->lpabBuf != NULL &&
			(lpFile->lpabBuf = MemFree(NULL, lpFile->lpabBuf)) != NULL)
		{
			fSuccess = FALSE;
		}

		if ((lpFile = MemFree(NULL, lpFile)) != NULL)
			fSuccess = FALSE;
	}

	return fSuccess ? 0 : -1;
}

#ifndef NOTRACE

// FileExists - return TRUE if specified file exists
//		<lpszFileName>		(i) file name
// return TRUE or FALSE
//
BOOL DLLEXPORT WINAPI FileExists(LPCTSTR lpszFileName)
{
	BOOL fSuccess = TRUE;

#ifdef _WIN32
	if (!CloseHandle(CreateFile(lpszFileName,
		GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL)))
		fSuccess = FALSE;
#else
	// we need a near pointer so we can call _stat()
	//
	StrNCpy(szFileName, lpszFileName, SIZEOFARRAY(szFileName));

	// make sure path and file are valid
	//
	if (_stat(szFileName, &statbuf) != 0)
		fSuccess = FALSE;

	// make sure it is a regular file (i.e. not a directory)
	//
	else if ((statbuf.st_mode & _S_IFREG) == 0)
		fSuccess = FALSE;
#endif

	return fSuccess;
}

// FileFullPath - parse file spec, construct full path
//		see _fullpath() documentation for behavior
// return <lpszFullPath> if success or NULL
//
LPTSTR DLLEXPORT WINAPI FileFullPath(LPTSTR lpszPath, LPCTSTR lpszFileName, int sizPath)
{
	BOOL fSuccess = TRUE;

	// we need near pointers so we can call _fullpath()
	//
	StrNCpy(szFileName, lpszFileName, SIZEOFARRAY(szFileName));
	StrNCpy(szPath, lpszPath, SIZEOFARRAY(szPath));

	if (_tfullpath(szPath, szFileName, SIZEOFARRAY(szPath)) == NULL)
		fSuccess = FALSE;

	else
		StrNCpy(lpszPath, szPath, sizPath);

	return fSuccess ? lpszPath : NULL;
}

// FileSplitPath - break a full path into its components
//		see _splitpath() documentation for behavior
// return 0 if success
//
int DLLEXPORT WINAPI FileSplitPath(LPCTSTR lpszPath, LPTSTR lpszDrive, LPTSTR lpszDir, LPTSTR lpszFname, LPTSTR lpszExt)
{
	BOOL fSuccess = TRUE;

	// we need near pointers so we can call _splitpath()
	//
	StrNCpy(szPath, lpszPath, SIZEOFARRAY(szPath));

	_tsplitpath(szPath, szDrive, szDir, szFname, szExt);

	if (lpszDrive != NULL)
		StrCpy(lpszDrive, szDrive); 
	if (lpszDir != NULL)
		StrCpy(lpszDir, szDir); 
	if (lpszFname != NULL)
		StrCpy(lpszFname, szFname); 
	if (lpszExt != NULL)
		StrCpy(lpszExt, szExt); 

	return fSuccess ? 0 : -1;
}

// FileMakePath - make a full path from specified components
//		see _makepath() documentation for behavior
// return 0 if success
//
int DLLEXPORT WINAPI FileMakePath(LPTSTR lpszPath, LPCTSTR lpszDrive, LPCTSTR lpszDir, LPCTSTR lpszFname, LPCTSTR lpszExt)
{
	BOOL fSuccess = TRUE;

	// we need near pointers so we can call _makepath()
	//
	*szDrive = '\0';
	if (lpszDrive != NULL)
		StrNCpy(szDrive, lpszDrive, SIZEOFARRAY(szDrive));
		
	*szDir = '\0';
	if (lpszDir != NULL)
		StrNCpy(szDir, lpszDir, SIZEOFARRAY(szDir));
		
	*szFname = '\0';
	if (lpszFname != NULL)
		StrNCpy(szFname, lpszFname, SIZEOFARRAY(szFname));
		
	*szExt = '\0';
	if (lpszExt != NULL)
		StrNCpy(szExt, lpszExt, SIZEOFARRAY(szExt));

	_tmakepath(szPath, szDrive, szDir, szFname, szExt);

	if (lpszPath != NULL)
		StrCpy(lpszPath, szPath); 

	return fSuccess ? 0 : -1;
}

// FileRemove - delete specified file
//		see remove() documentation for behavior
// return 0 if success
//
int DLLEXPORT WINAPI FileRemove(LPCTSTR lpszFileName)
{
	BOOL fSuccess = TRUE;

#ifdef _WIN32
	if (!DeleteFile(lpszFileName))
		fSuccess = FALSE;
#else
	static TCHAR szFileName[_MAX_PATH];

	// we need a near pointer so we can call remove()
	//
	StrNCpy(szFileName, lpszFileName, SIZEOFARRAY(szFileName));

	if (remove(szFileName) != 0)
		fSuccess = FALSE;
#endif

	return fSuccess ? 0 : -1;
}

// FileRename - rename specified file
//		see rename() documentation for behavior
// return 0 if success
//
int DLLEXPORT WINAPI FileRename(LPCTSTR lpszOldName, LPCTSTR lpszNewName)
{
	BOOL fSuccess = TRUE;

	if (_trename(lpszOldName, lpszNewName) != 0)
		fSuccess = FALSE;

	return fSuccess ? 0 : -1;
}

#endif

// GetTempFileNameEx - create temporary file, extended version
//
// This function is similar to GetTempFileName(),
// except that <lpPrefixString> is replaced by <lpExtensionString>
// See Windows SDK documentation for description of original GetTempFileName()
//
UINT DLLEXPORT WINAPI GetTempFileNameEx(LPCTSTR lpPathName, LPCTSTR lpExtensionString,
	UINT uUnique, LPTSTR lpTempFileName)
{
	UINT uRet;
	TCHAR szTempFileName[_MAX_PATH];

	// create temporary file
	//
	if ((uRet = GetTempFileName(lpPathName,
		TEXT("TMP"), uUnique, szTempFileName)) != 0)
	{
		LPTSTR lpsz;

		StrCpy(lpTempFileName, szTempFileName);

		if ((lpsz = StrRChr(lpTempFileName, '.')) == NULL)
		{
			// unable to locate extension in temporary file
			//
			FileRemove(szTempFileName);
			uRet = 0;
		}

		else
		{
			// use specified extension to alter file name
			//
			StrCpy(lpsz + 1, lpExtensionString);

			if (FileRename(szTempFileName, lpTempFileName) != 0)
			{
				// unable to rename temporary file
				//
				FileRemove(szTempFileName);
				uRet = 0;
			}
		}
	}

	return uRet;
}

////
// private functions
////

// FileGetPtr - verify that file handle is valid,
//		<hFile>				(i) handle returned by FileCreate or FileOpen
// return corresponding file pointer (NULL if error)
//
static LPFIL FileGetPtr(HFIL hFile)
{
	BOOL fSuccess = TRUE;
	LPFIL lpFile;

	if ((lpFile = (LPFIL) hFile) == NULL)
		fSuccess = FALSE;

	else if (IsBadWritePtr(lpFile, sizeof(FIL)))
		fSuccess = FALSE;

#ifdef CHECKTASK
	// make sure current task owns the file handle if appropriate
	//
	else if (lpFile->fTaskOwned && lpFile->hTask != GetCurrentTask())
		fSuccess = FALSE;
#endif

	return fSuccess ? lpFile : NULL;
}

// FileGetHandle - verify that file pointer is valid,
//		<lpFile>			(i) pointer to FIL struct
// return corresponding file handle (NULL if error)
//
static HFIL FileGetHandle(LPFIL lpFile)
{
	BOOL fSuccess = TRUE;
	HFIL hFile;

	if ((hFile = (HFIL) lpFile) == NULL)
		fSuccess = FALSE;

	return fSuccess ? hFile : NULL;
}

#ifdef FILESUP
// FileSupUsage - adjust filesup.exe usage count
//		<nDelta>		(i) +1 to increment, -1 to decrement
// return 0 if success
//
static int FileSupUsage(int nDelta)
{
	BOOL fSuccess = TRUE;

	// increment usage count
	//
	if (nDelta == +1)
	{
		// execute filesup.exe if this is the first usage
		//
		if (cFileSupUsage == 0 && FileSupInit() != 0)
			fSuccess = FALSE;
		else
			++cFileSupUsage;
	}

	// decrement usage count
	//
	else if (nDelta == -1)
	{
		// terminate filesup.exe if this is the last usage
		//
		if (cFileSupUsage == 1 && FileSupTerm() != 0)
			fSuccess = FALSE;
		else
			--cFileSupUsage;
	}

	return fSuccess ? 0 : -1;
}

// FileSupInit - execute filesup.exe and get its window handle
// return 0 if success
//
static int FileSupInit(void)
{
	BOOL fSuccess = TRUE;

	if ((hwndFileSup = FindWindow(FILESUP_CLASS, NULL)) != NULL)
		; // filesup.exe already running

	else if (WinExec(FILESUP_EXE, SW_HIDE) < 32)
		fSuccess = FALSE;

	else if ((hwndFileSup = FindWindow(FILESUP_CLASS, NULL)) == NULL)
		fSuccess = FALSE;

	return fSuccess ? 0 : -1;
}

// FileSupTerm - terminate filesup.exe
// return 0 if success
//
static int FileSupTerm(void)
{
	BOOL fSuccess = TRUE;

	if (hwndFileSup != NULL)
	{
		// close the window, which also terminates filesup.exe
		//
		SendMessage(hwndFileSup, WM_CLOSE, 0, 0);
		hwndFileSup = NULL;
	}

	return fSuccess ? 0 : -1;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\gfx.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	gfx.c - Windows graphics functions
////

#include "winlocal.h"

#include <stdlib.h>

#include "gfx.h"
#include "mem.h"
#include "str.h"
#include "trace.h"

////
//	public functions
////

////
//	bitmap routines
////

// GfxBitmapBackfill - replace bitmap's white backg with curr backg color
//		<hBitmap>			(i/o) bitmap handle
//		<crBkColor>			(i) current background color
//		<wFlags>			(i) option flags
//			0					use default method
//			BF_EXTFLOODFILL		use ExtFloodFill function
//			BF_GETSETPIXEL		use GetPixel/SetPixel functions
//			NOTE: rarely, ExtFloodFill will GP the display device driver
// return 0 if success
//
int DLLEXPORT WINAPI GfxBitmapBackfill(HBITMAP hBitmap, COLORREF crBkColor, WORD wFlags)
{
	BOOL fSuccess = TRUE;
	BOOL fExtFloodFill = (BOOL) !(wFlags & BF_GETSETPIXEL);
	BITMAP Bitmap;
	HDC hdc = NULL;
	HDC hdcMem = NULL;
	HBITMAP hBitmapOld = NULL;
	HBRUSH hbr = NULL;
	HBRUSH hbrOld = NULL;
	COLORREF crMaskColor = RGB(255, 255, 255); // RGB_WHITE

	// need not continue if COLOR_WINDOW is white
	//
	if (crMaskColor == crBkColor)
		return 0;
	
	if (hBitmap == NULL)
		fSuccess = TraceFALSE(NULL);

	// get width and height of bitmap
	//
	else if (GetObject((HGDIOBJ) hBitmap, sizeof(BITMAP), &Bitmap) == 0)
		fSuccess = TraceFALSE(NULL);

	// get device context for screen
	//
	else if ((hdc = GetDC(NULL)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// create a memory device context
	//
	else if ((hdcMem = CreateCompatibleDC(hdc)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// select the bitmap into the memory device context
	//
	else if ((hBitmapOld = SelectObject(hdcMem, hBitmap)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// create a brush with specified background color
	//
	else if ((hbr = CreateSolidBrush(crBkColor)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// select the brush into the memory device context
	//
	else if ((hbrOld = SelectObject(hdcMem, hbr)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		int cx = Bitmap.bmWidth;
		int cy = Bitmap.bmHeight;

		if (fExtFloodFill)
		{
			ExtFloodFill(hdcMem, 0, 0, crMaskColor, FLOODFILLSURFACE);
			ExtFloodFill(hdcMem, cx - 1, 0, crMaskColor, FLOODFILLSURFACE);
			ExtFloodFill(hdcMem, 0, cy - 1, crMaskColor, FLOODFILLSURFACE);
			ExtFloodFill(hdcMem, cx - 1, cy - 1, crMaskColor, FLOODFILLSURFACE);
		}
		else
		{
			int x;
			int y;
			for (x = 0; x < cx; ++x)
				for (y = 0; y < cy; ++y)
					if (GetPixel(hdcMem, x, y) == crMaskColor)
						SetPixel(hdcMem, x, y, crBkColor);
		}
	}

	// restore old brush, if any
	//
	if (hbrOld != NULL)
		SelectObject(hdcMem, hbrOld);

	// delete new brush
	//
	if (hbr != NULL && !DeleteObject(hbr))
		fSuccess = TraceFALSE(NULL);

	// restore old bitmap, if any
	//
	if (hBitmapOld != NULL)
		SelectObject(hdcMem, hBitmapOld);

	// free the memory device context
	//
	if (hdcMem != NULL && !DeleteDC(hdcMem))
		fSuccess = TraceFALSE(NULL);

	// release the common device context
	//
	if (hdc != NULL && !ReleaseDC(NULL, hdc))
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}

// GfxBitmapDisplay - display specified bitmap
//		<hdc>				(i) device context for destination window
//		<hBitmap>			(i) bitmap handle for source bitmap
//		<x>					(i) x coordinate for destination window
//		<y>					(i) y coordinate for destination window
//		<fInvert>			(i) display bitmap inverted
// return 0 if success
//
int DLLEXPORT WINAPI GfxBitmapDisplay(HDC hdc, HBITMAP hBitmap, int x, int y, BOOL fInvert)
{
	BOOL fSuccess = TRUE;
	HDC hdcMem = NULL;
	HBITMAP hBitmapOld = NULL;
	BITMAP Bitmap;

	if (hdc == NULL)
		fSuccess = TraceFALSE(NULL);
	
	else if (hBitmap == NULL)
		fSuccess = TraceFALSE(NULL);

	// get width and height of bitmap
	//
	else if (GetObject((HGDIOBJ) hBitmap, sizeof(BITMAP), &Bitmap) == 0)
		fSuccess = TraceFALSE(NULL);

	// create a memory device context
	//
	else if ((hdcMem = CreateCompatibleDC(hdc)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// select the bitmap into the memory device context
	//
	else if ((hBitmapOld = SelectObject(hdcMem, hBitmap)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// copy the bitmap from hdcMem to hdc, inverted if necessary
	//
	else if (!BitBlt(hdc, x, y, Bitmap.bmWidth, Bitmap.bmHeight,
		hdcMem, 0, 0, fInvert ? NOTSRCCOPY : SRCCOPY))
		fSuccess = TraceFALSE(NULL);

	// restore old bitmap, if any
	//
	if (hBitmapOld != NULL)
		SelectObject(hdcMem, hBitmapOld);

	// free the memory device context
	//
	if (hdcMem != NULL)
		DeleteDC(hdcMem);

	return fSuccess ? 0 : -1;
}

// GfxBitmapDrawTransparent - draw specified bitmap
//		<hdc>				(i) device context for destination window
//		<hBitmap>			(i) bitmap handle for source bitmap
//		<x>					(i) x coordinate for destination window
//		<y>					(i) y coordinate for destination window
//		<crTransparent>		(i) transparent color
//		<dwFlags>			(i) control flags
//			0					reserved; must be zero
// return 0 if success
//
#if 1
int DLLEXPORT WINAPI GfxBitmapDrawTransparent(HDC hdc, HBITMAP hBitmap, int x, int y, COLORREF crTransparent, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	BITMAP bmp;
	int cx;
	int cy;
	HBITMAP hbmpMask = NULL;
	HDC hdcMem = NULL;
	HDC hdcMem2 = NULL;
	HBITMAP hbmpOld;
	HBITMAP hbmpOld2;
	COLORREF crBkOld;
	COLORREF crTextOld;

	if (GetObject(hBitmap, sizeof(BITMAP), (LPVOID) &bmp) == 0)
		fSuccess = TraceFALSE(NULL);

	else if (cx = bmp.bmWidth, cy = bmp.bmHeight, FALSE)
		;

	else if ((hbmpMask = CreateBitmap(cx, cy, 1, 1, NULL)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((hdcMem = CreateCompatibleDC(hdc)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((hdcMem2 = CreateCompatibleDC(hdc)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((hbmpOld = SelectObject(hdcMem, hBitmap)), FALSE)
		;

    else if ((hbmpOld2 = SelectObject(hdcMem2, hbmpMask)), FALSE)
		;

	else if (SetBkColor(hdcMem, crTransparent), FALSE)
		;

	else if (!BitBlt(hdcMem2, 0, 0, cx, cy, hdcMem, 0, 0, SRCCOPY))
		fSuccess = TraceFALSE(NULL);

    else if ((crBkOld = SetBkColor(hdc, RGB(255, 255, 255))) == CLR_INVALID)
		fSuccess = TraceFALSE(NULL);

    else if ((crTextOld = SetTextColor(hdc, RGB(0, 0, 0))) == CLR_INVALID)
		fSuccess = TraceFALSE(NULL);

	else if (!BitBlt(hdc, x, y, cx, cy, hdcMem, 0, 0, SRCINVERT))
		fSuccess = TraceFALSE(NULL);

	else if (!BitBlt(hdc, x, y, cx, cy, hdcMem2, 0, 0, SRCAND))
		fSuccess = TraceFALSE(NULL);

	else if (!BitBlt(hdc, x, y, cx, cy, hdcMem, 0, 0, SRCINVERT))
		fSuccess = TraceFALSE(NULL);

    else if (SetBkColor(hdc, crBkOld) == CLR_INVALID)
		fSuccess = TraceFALSE(NULL);

    else if (SetTextColor(hdc, crTextOld) == CLR_INVALID)
		fSuccess = TraceFALSE(NULL);

    else if (SelectObject(hdcMem, hbmpOld), FALSE)
		;

    else if (SelectObject(hdcMem2, hbmpOld2), FALSE)
		;

    if (hbmpMask != NULL && !DeleteObject(hbmpMask))
		fSuccess = TraceFALSE(NULL);
	else
		hbmpMask = NULL;

    if (hdcMem != NULL && !DeleteDC(hdcMem))
		fSuccess = TraceFALSE(NULL);
	else
		hdcMem = NULL;

    if (hdcMem2 != NULL && !DeleteDC(hdcMem2))
		fSuccess = TraceFALSE(NULL);
	else
		hdcMem2 = NULL;

	return 0;
}
#else
int DLLEXPORT WINAPI GfxBitmapDrawTransparent(HDC hdc, HBITMAP hBitmap, int x, int y, COLORREF crTransparent, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	BITMAP bmp;
	POINT ptSize;
	COLORREF cr;
	HBITMAP hbmpAndBack = NULL;
	HBITMAP hbmpAndObject = NULL;
	HBITMAP hbmpAndMem = NULL;
	HBITMAP hbmpSave = NULL;
	HBITMAP hbmpBackOld = NULL;
	HBITMAP hbmpObjectOld = NULL;
	HBITMAP hbmpMemOld = NULL;
	HBITMAP hbmpSaveOld = NULL;
	HDC hdcTemp = NULL;
	HDC hdcBack = NULL;
	HDC hdcObject = NULL;
	HDC hdcMem = NULL;
	HDC hdcSave = NULL;

	// Select the bitmap
	//
	if ((hdcTemp = CreateCompatibleDC(hdc)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (SelectObject(hdcTemp, hBitmap), FALSE)
		;

	// Get dimensions of bitmap
	//
	else if (GetObject(hBitmap, sizeof(BITMAP), (LPVOID) &bmp) == 0)
		fSuccess = TraceFALSE(NULL);

	else if (ptSize.x = bmp.bmWidth, ptSize.y = bmp.bmHeight, FALSE)
		;

	// Convert from device to logical points
	//
	else if (!DPtoLP(hdcTemp, &ptSize, 1))
		fSuccess = TraceFALSE(NULL);

	// Create some DCs to hold temporary data.
	//
	else if ((hdcBack = CreateCompatibleDC(hdc)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((hdcObject = CreateCompatibleDC(hdc)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((hdcMem = CreateCompatibleDC(hdc)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((hdcSave = CreateCompatibleDC(hdc)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// Create a bitmap for each DC. DCs are required for a number of GDI functions.
	//
	else if ((hbmpAndBack = CreateBitmap(ptSize.x, ptSize.y, 1, 1, NULL)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((hbmpAndObject = CreateBitmap(ptSize.x, ptSize.y, 1, 1, NULL)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((hbmpAndMem = CreateCompatibleBitmap(hdc, ptSize.x, ptSize.y)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((hbmpSave = CreateCompatibleBitmap(hdc, ptSize.x, ptSize.y)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// Each DC must select a bitmap object to store pixel data.
	//
	else if ((hbmpBackOld = SelectObject(hdcBack, hbmpAndBack)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((hbmpObjectOld = SelectObject(hdcObject, hbmpAndObject)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((hbmpMemOld = SelectObject(hdcMem, hbmpAndMem)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((hbmpSaveOld = SelectObject(hdcSave, hbmpSave)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// Set proper mapping mode.
	//
	else if (SetMapMode(hdcTemp, GetMapMode(hdc)) == 0)
		fSuccess = TraceFALSE(NULL);

	// Save the bitmap sent here, because it will be overwritten.
	//
	else if (!BitBlt(hdcSave, 0, 0, ptSize.x, ptSize.y, hdcTemp, 0, 0, SRCCOPY))
		fSuccess = TraceFALSE(NULL);

	// Set the background color of the source DC to the color.
	// contained in the parts of the bitmap that should be transparent
	//
	else if ((cr = SetBkColor(hdcTemp, crTransparent)) == CLR_INVALID)
		fSuccess = TraceFALSE(NULL);

	// Create the object mask for the bitmap by performing a BitBlt
	// from the source bitmap to a monochrome bitmap.
	//
	else if (!BitBlt(hdcObject, 0, 0, ptSize.x, ptSize.y, hdcTemp, 0, 0, SRCCOPY))
		fSuccess = TraceFALSE(NULL);

	// Set the background color of the source DC back to original color.
	//
	else if (SetBkColor(hdcTemp, cr) == CLR_INVALID)
		fSuccess = TraceFALSE(NULL);

	// Create the inverse of the object mask.
	//
	else if (!BitBlt(hdcBack, 0, 0, ptSize.x, ptSize.y, hdcObject, 0, 0, NOTSRCCOPY))
		fSuccess = TraceFALSE(NULL);

	// Copy the background of the main DC to the destination.
	//
	else if (!BitBlt(hdcMem, 0, 0, ptSize.x, ptSize.y, hdc, x, y, SRCCOPY))
		fSuccess = TraceFALSE(NULL);

	// Mask out the places where the bitmap will be placed.
	//
	else if (!BitBlt(hdcMem, 0, 0, ptSize.x, ptSize.y, hdcObject, 0, 0, SRCAND))
		fSuccess = TraceFALSE(NULL);

	// Mask out the transparent colored pixels on the bitmap.
	//
	else if (!BitBlt(hdcTemp, 0, 0, ptSize.x, ptSize.y, hdcBack, 0, 0, SRCAND))
		fSuccess = TraceFALSE(NULL);

	// XOR the bitmap with the background on the destination DC.
	//
	else if (!BitBlt(hdcMem, 0, 0, ptSize.x, ptSize.y, hdcTemp, 0, 0, SRCPAINT))
		fSuccess = TraceFALSE(NULL);

	// Copy the destination to the screen.
	//
	else if (!BitBlt(hdc, x, y, ptSize.x, ptSize.y, hdcMem, 0, 0, SRCCOPY))
		fSuccess = TraceFALSE(NULL);

	// Place the original bitmap back into the bitmap sent here.
	//
	else if (!BitBlt(hdcTemp, 0, 0, ptSize.x, ptSize.y, hdcSave, 0, 0, SRCCOPY))
		fSuccess = TraceFALSE(NULL);

	// restore old bitmaps
	//
	if (hdcBack != NULL && hbmpBackOld != NULL &&
		SelectObject(hdcBack, hbmpBackOld) == NULL)
		fSuccess = TraceFALSE(NULL);

	if (hdcObject != NULL && hbmpObjectOld != NULL &&
		SelectObject(hdcObject, hbmpObjectOld) == NULL)
		fSuccess = TraceFALSE(NULL);

	if (hdcMem != NULL && hbmpMemOld != NULL &&
		SelectObject(hdcMem, hbmpMemOld) == NULL)
		fSuccess = TraceFALSE(NULL);

	if (hdcSave != NULL && hbmpSaveOld != NULL &&
		SelectObject(hdcSave, hbmpSaveOld) == NULL)
		fSuccess = TraceFALSE(NULL);

	// Delete the memory bitmaps.
	//
	if (hbmpAndBack != NULL && !DeleteObject(hbmpAndBack))
		fSuccess = TraceFALSE(NULL);

	if (hbmpAndObject != NULL && !DeleteObject(hbmpAndObject))
		fSuccess = TraceFALSE(NULL);

	if (hbmpAndMem != NULL && !DeleteObject(hbmpAndMem))
		fSuccess = TraceFALSE(NULL);

	if (hbmpSave != NULL && !DeleteObject(hbmpSave))
		fSuccess = TraceFALSE(NULL);

	// Delete the memory DCs.
	//
	if (hdcBack != NULL && !DeleteDC(hdcBack))
		fSuccess = TraceFALSE(NULL);

	if (hdcObject != NULL && !DeleteDC(hdcObject))
		fSuccess = TraceFALSE(NULL);

	if (hdcMem != NULL && !DeleteDC(hdcMem))
		fSuccess = TraceFALSE(NULL);

	if (hdcSave != NULL && !DeleteDC(hdcSave))
		fSuccess = TraceFALSE(NULL);

	if (hdcTemp != NULL && !DeleteDC(hdcTemp))
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}
#endif

// GfxBitmapScroll - scroll specified bitmap
//		<hdc>				(i) device context for destination window
//		<hBitmap>			(i) bitmap handle for source bitmap
//		<dx>				(i) amt of horizontal scroll (cx < 0 scrolls left)
//		<dy>				(i) amt of vertical scroll (cx < 0 scrolls up)
//		<dwFlags>			(i) control flags
//			BS_ROTATE			rotate bitmap
// return 0 if success
//
int DLLEXPORT WINAPI GfxBitmapScroll(HDC hdc, HBITMAP hBitmap, int dx, int dy, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	BITMAP bmp;
	POINT ptSize;
	HDC hdcMem = NULL;
	HDC hdcTemp = NULL;
	HBITMAP hbmpTemp = NULL;
	HBITMAP hbmpSave = NULL;
	int dxAbs;
	int dyAbs;

	// Get dimensions of bitmap
	//
	if (GetObject(hBitmap, sizeof(BITMAP), (LPVOID) &bmp) == 0)
		fSuccess = TraceFALSE(NULL);

	else if (ptSize.x = bmp.bmWidth, ptSize.y = bmp.bmHeight, FALSE)
		;

	else if (dx = dx % ptSize.x, dy = dy % ptSize.y, FALSE)
		;

	else if (dxAbs = abs(dx), dyAbs = abs(dy), FALSE)
		;

	// prepare mem dc
	//
	else if ((hdcMem = CreateCompatibleDC(hdc)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (!DPtoLP(hdcMem, &ptSize, 1))
		fSuccess = TraceFALSE(NULL);

	else if (SelectObject(hdcMem, hBitmap), FALSE)
		;

	// Set proper mapping mode.
	//
	else if (SetMapMode(hdcMem, GetMapMode(hdc)) == 0)
		fSuccess = TraceFALSE(NULL);

	// prepare temp copy
	//
	else if (dwFlags & BS_ROTATE)
	{
		if ((hdcTemp = CreateCompatibleDC(hdc)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if ((hbmpTemp = CreateCompatibleBitmap(hdc, ptSize.x, ptSize.y)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if ((hbmpSave = SelectObject(hdcTemp, hbmpTemp)), FALSE)
			;

		else if (!BitBlt(hdcTemp, 0, 0, ptSize.x, ptSize.y, hdcMem, 0, 0, SRCCOPY))
			fSuccess = TraceFALSE(NULL);
	}

	// scroll (rotate if specified)
	//
	if (fSuccess && dx < 0)
	{
		if (!BitBlt(hdcMem,
			0, 0,
			ptSize.x - dxAbs, ptSize.y,
			hdcMem,
			dxAbs, 0,
			SRCCOPY))
			fSuccess = TraceFALSE(NULL);

		else if ((dwFlags & BS_ROTATE) &&
			!BitBlt(hdcMem,
			ptSize.x - dxAbs, 0,
			dxAbs, ptSize.y,
			hdcTemp,
			0, 0,
			SRCCOPY))
			fSuccess = TraceFALSE(NULL);
	}

	if (fSuccess && dx > 0)
	{
		if (!BitBlt(hdcMem,
			dxAbs, 0,
			ptSize.x - dxAbs, ptSize.y,
			hdcMem,
			0, 0,
			SRCCOPY))
			fSuccess = TraceFALSE(NULL);

		else if ((dwFlags & BS_ROTATE) &&
			!BitBlt(hdcMem,
			0, 0,
			dxAbs, ptSize.y,
			hdcTemp,
			ptSize.x - dxAbs, 0,
			SRCCOPY))
			fSuccess = TraceFALSE(NULL);
	}

	if (fSuccess && dy < 0)
	{
		if ((dwFlags & BS_ROTATE) && dx != 0 &&
			!BitBlt(hdcTemp, 0, 0, ptSize.x, ptSize.y, hdcMem, 0, 0, SRCCOPY))
			fSuccess = TraceFALSE(NULL);

		else if (!BitBlt(hdcMem,
			0, 0,
			ptSize.x, ptSize.y - dyAbs,
			hdcMem,
			0, dyAbs,
			SRCCOPY))
			fSuccess = TraceFALSE(NULL);

		else if ((dwFlags & BS_ROTATE) &&
			!BitBlt(hdcMem,
			0, ptSize.y - dyAbs,
			ptSize.x, dyAbs,
			hdcTemp,
			0, 0,
			SRCCOPY))
			fSuccess = TraceFALSE(NULL);
	}

	if (fSuccess && dy > 0)
	{
		if ((dwFlags & BS_ROTATE) && dx != 0 &&
			!BitBlt(hdcTemp, 0, 0, ptSize.x, ptSize.y, hdcMem, 0, 0, SRCCOPY))
			fSuccess = TraceFALSE(NULL);

		else if (!BitBlt(hdcMem,
			0, dyAbs,
			ptSize.x, ptSize.y - dyAbs,
			hdcMem,
			0, 0,
			SRCCOPY))
			fSuccess = TraceFALSE(NULL);

		else if ((dwFlags & BS_ROTATE) &&
			!BitBlt(hdcMem,
			0, 0,
			ptSize.x, dyAbs,
			hdcTemp,
			0, ptSize.y - dyAbs,
			SRCCOPY))
			fSuccess = TraceFALSE(NULL);
	}

	if (!fSuccess)
		;

	// copy back to original bitmap
	//
	else if (!BitBlt(hdc, 0, 0, ptSize.x, ptSize.y, hdcMem, 0, 0, SRCCOPY))
		fSuccess = TraceFALSE(NULL);

	// clean up
	//

	if (hdcTemp != NULL)
		SelectObject(hdcTemp, hbmpSave);

	if (hdcMem != NULL && !DeleteDC(hdcMem))
		fSuccess = TraceFALSE(NULL);

	if (hbmpTemp != NULL && !DeleteObject(hbmpTemp))
		fSuccess = TraceFALSE(NULL);

	if (hdcTemp != NULL && !DeleteDC(hdcTemp))
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}

// GfxLoadBitmapEx - load specified bitmap resource, get palette
//		<hInstance>			(i) handle of module to load resource from
//			NULL				load pre-defined Windows bitmap
//		<lpszBitmap>		(i) name of bitmap resource
//								or MAKEINTRESOURCE(idBitmap)
//								or <OBM_xxx> if hInstance is NULL
//		<lphPalette>		(o) palette is returned here
//			NULL				do not return palette
// return bitmap handle if success, otherwise NULL
// NOTE: see documentation for LoadBitmap function
// NOTE: call DeleteObject() to free returned bitmap and palette handles
//
HBITMAP DLLEXPORT WINAPI GfxLoadBitmapEx(HINSTANCE hInstance,
	LPCTSTR lpszBitmap, HPALETTE FAR *lphPalette)
{
	BOOL fSuccess = TRUE;
	HRSRC hRsrc = NULL;
	HGLOBAL hGlobal = NULL;
	LPBITMAPINFOHEADER lpbi = NULL;
	HDC hdc = NULL;
	HPALETTE hPalette = NULL;
	HBITMAP hBitmap = NULL;
    int nColors;

	if ((hRsrc = FindResource(hInstance, lpszBitmap, RT_BITMAP)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((hGlobal = LoadResource(hInstance, hRsrc)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpbi = (LPBITMAPINFOHEADER) LockResource(hGlobal)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((hdc = GetDC(NULL)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((hPalette = CreateDIBPalette((LPBITMAPINFO)lpbi, &nColors)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (SelectPalette(hdc, hPalette, FALSE), FALSE)
		;

	else if (RealizePalette(hdc) == GDI_ERROR)
		fSuccess = TraceFALSE(NULL);

	else if ((hBitmap = CreateDIBitmap(hdc,
		(LPBITMAPINFOHEADER) lpbi, (LONG) CBM_INIT,
		(LPSTR)lpbi + lpbi->biSize + nColors * sizeof(RGBQUAD),
		(LPBITMAPINFO) lpbi, DIB_RGB_COLORS)) == NULL)
	{
		fSuccess = TraceFALSE(NULL);
	}

	// clean up
	//

#ifndef _WIN32
	if (hGlobal != NULL)
	{
		UnlockResource(hGlobal);
		FreeResource(hGlobal);
	}
#endif

	if (hdc != NULL)
		ReleaseDC(NULL, hdc);

	if (!fSuccess || lphPalette == NULL)
	{
		if (hPalette != NULL && !DeleteObject(hPalette))
			fSuccess = TraceFALSE(NULL);
	}

	// return palette handle here
	//
	if (fSuccess && lphPalette != NULL)
		*lphPalette = hPalette;

	// return bitmap handle here
	//
	return fSuccess ? hBitmap : NULL;
} 

// GfxCreateDIBPalette - create palette
//		<lpbmi>				(i) ptr to BITMAPINFO struct, describes DIB
//		<lpnColors>			(o) number of colors is returned here
// return new palette handle if success, otherwise NULL
//
HPALETTE DLLEXPORT WINAPI CreateDIBPalette (LPBITMAPINFO lpbmi, LPINT lpnColors)
{
	BOOL fSuccess = TRUE;
	LPBITMAPINFOHEADER lpbi;
	LPLOGPALETTE lpPal = NULL;
	HPALETTE hPal = NULL;
	int nColors;

	if ((lpbi = (LPBITMAPINFOHEADER) lpbmi) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		// calculate color table size
		//
		if (lpbi->biBitCount <= 8)
			nColors = (1 << lpbi->biBitCount);
		else
			nColors = 0;  // No palette needed for 24 BPP DIB

		if (lpbi->biClrUsed > 0)
			nColors = lpbi->biClrUsed;  // Use biClrUsed

		if (nColors <= 0)
			fSuccess = TraceFALSE(NULL);
	}

	if (fSuccess)
	{
		if ((lpPal = (LPLOGPALETTE) MemAlloc(NULL, sizeof(LOGPALETTE) +
			sizeof(PALETTEENTRY) * nColors, 0)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else
		{
			int i;

            //
            // We have to initalize the memory allocated with MemAlloc
            //

            memset( lpPal, 0, sizeof(LOGPALETTE) + sizeof(PALETTEENTRY) * nColors);

			lpPal->palVersion = 0x300;
			lpPal->palNumEntries = (unsigned short) nColors;

			for (i = 0;  i < nColors;  i++)
			{
				lpPal->palPalEntry[i].peRed   = lpbmi->bmiColors[i].rgbRed;
				lpPal->palPalEntry[i].peGreen = lpbmi->bmiColors[i].rgbGreen;
				lpPal->palPalEntry[i].peBlue  = lpbmi->bmiColors[i].rgbBlue;
				lpPal->palPalEntry[i].peFlags = 0;
			}

			if ((hPal = CreatePalette(lpPal)) == NULL)
				fSuccess = TraceFALSE(NULL);

			if ((lpPal = MemFree(NULL, lpPal)) != NULL)
            {
                //
                // We should delete hPal resource
                //

                DeleteObject( hPal );
                hPal = NULL;

				fSuccess = TraceFALSE(NULL);
            }
		}
	}

	// return number of colors here
	//
	if (fSuccess && lpnColors != NULL)
		*lpnColors = nColors;

	// return new palette here
	//
	return fSuccess ? hPal : NULL;
}
 
////
//	text routines
////

// GfxTextExtentTruncate - truncate string if too long
//		<lpsz>				(i/o) string to truncate
//		<hdc>				(i) current device context
//		<cxMax>				(i) maximum string width in logical units
// return new length of string (0 if error)
//
int DLLEXPORT WINAPI GfxTextExtentTruncate(LPTSTR lpsz, HDC hdc, int cxMax)
{
	BOOL fSuccess = TRUE;
	int cbString;

	if (hdc == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpsz == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		// calculate how many chars in string will fit within cxMax
		//
		cbString = StrLen(lpsz);
		while (fSuccess && cbString > 0)
		{
			SIZE size;

			if (!GetTextExtentPoint(hdc, lpsz, cbString, &size))
				fSuccess = TraceFALSE(NULL);

			else if (size.cx <= cxMax)
				break;

			else
				--cbString;
		}

		// truncate string so it fits
		//
		*(lpsz + cbString) = '\0';
	}

	return fSuccess ? cbString : 0;
}

////
//	cursor routines
////

// GfxShowHourglass - show the hourglass cursor
//		<hwndCapture>		(i) window to capture mouse input during hourglass
// return old cursor (NULL if error or none)
//
HCURSOR DLLEXPORT WINAPI GfxShowHourglass(HWND hwnd)
{
	BOOL fSuccess = TRUE;
	HCURSOR hCursorSave;
	HCURSOR hCursorHourglass;

	// get predefined hourglass cursor handle
	//
	if ((hCursorHourglass = LoadCursor(NULL, IDC_WAIT)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		// capture all mouse input to specified window
		//
		SetCapture(hwnd);

		// replace previous cursor with hourglass
		//
		hCursorSave = SetCursor(hCursorHourglass);
	}

	return fSuccess ? hCursorSave : NULL;
}

// GfxHideHourglass - hide the hourglass cursor
//		<hCursorRestore>	(i) cursor handle returned from GfxShowHourglass
//			NULL				replace cursor with IDC_ARROW
// return 0 if success
//
int DLLEXPORT WINAPI GfxHideHourglass(HCURSOR hCursorRestore)
{
	BOOL fSuccess = TRUE;

	// get predefined arrow cursor handle if necessary
	//
	if (hCursorRestore == NULL)
		hCursorRestore = LoadCursor(NULL, IDC_ARROW);

	// replace hourglass with previous cursor
	//
	if (SetCursor(hCursorRestore) == NULL)
		fSuccess = TraceFALSE(NULL);

	// restore normal mouse input processing
	//
	ReleaseCapture();

	return fSuccess ? 0 : -1;
}

// GfxDeviceIsMono - determine if device context is monochrome
//		<hdc>				(i) device context
//			NULL				use screen device context
// return TRUE if monochrome, FALSE if color
//
BOOL DLLEXPORT WINAPI GfxDeviceIsMono(HDC hdc)
{
	BOOL fSuccess = TRUE;
	BOOL fMono;
	HDC hdcScreen = NULL;

	// get screen device context if none specified
	//
	if (hdc == NULL && (hdc = hdcScreen = GetDC(NULL)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		int nColors = GetDeviceCaps(hdc, NUMCOLORS);

		fMono = (BOOL) (nColors >= 0 && nColors <= 2);

		// release screen device context if necessary
		//
		if (hdcScreen != NULL && !ReleaseDC(NULL, hdcScreen))
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? fMono : TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\garb.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	garb.c - garbage bag functions
////

#include "winlocal.h"

#include "garb.h"
#include "file.h"
#include "list.h"
#include "mem.h"
#include "str.h"
#include "trace.h"

////
//	private definitions
////

// garb control struct
//
typedef struct GARB
{
	DWORD dwVersion;
	HINSTANCE hInst;
	HTASK hTask;
	HLIST hList;
} GARB, FAR *LPGARB;

// garbage element struct
//
typedef struct GARBELEM
{
	LPVOID elem;
	DWORD dwFlags;
} GARBELEM, FAR *LPGARBELEM;

// helper functions
//
static LPGARB GarbGetPtr(HGARB hGarb);
static HGARB GarbGetHandle(LPGARB lpGarb);
static LPGARBELEM GarbElemCreate(LPVOID elem, DWORD dwFlags);
static int GarbElemDestroy(LPGARBELEM lpGarbElem);

////
//	public functions
////

// GarbInit - initialize garbage bag
//		<dwVersion>			(i) must be GARB_VERSION
// 		<hInst>				(i) instance handle of calling module
// return handle (NULL if error)
//
HGARB DLLEXPORT WINAPI GarbInit(DWORD dwVersion, HINSTANCE hInst)
{
	BOOL fSuccess = TRUE;
	LPGARB lpGarb = NULL;

	if (dwVersion != GARB_VERSION)
		fSuccess = TraceFALSE(NULL);

	else if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpGarb = (LPGARB) MemAlloc(NULL, sizeof(GARB), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// create a list to hold garbage bag elements
	//
	else if ((lpGarb->hList = ListCreate(LIST_VERSION, hInst)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lpGarb->dwVersion = dwVersion;
		lpGarb->hInst = hInst;
		lpGarb->hTask = GetCurrentTask();
	}

	if (!fSuccess)
	{
		GarbTerm(GarbGetHandle(lpGarb));
		lpGarb = NULL;
	}

	return fSuccess ? GarbGetHandle(lpGarb) : NULL;
}

// GarbTerm - dispose of each element in garbage bag, then destroy it
//		<hGarb>				(i) handle returned from GarbInit
// return 0 if success
//
// NOTE: elements are disposed of in the order they were placed
// in the garbage bag;  therefore, for instance, if a temporary
// file is to be first closed and then deleted, call GarbAddElement()
// first with the file handle (GARBELEM_HFILE) and then with the
// file name (GARBELEM_TEMPFILENAME).
//
int DLLEXPORT WINAPI GarbTerm(HGARB hGarb)
{
	BOOL fSuccess = TRUE;
	LPGARB lpGarb;

	if ((lpGarb = GarbGetPtr(hGarb)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpGarb->hList != NULL)
	{
		// dispose of each element in the list
		//
		while (fSuccess && !ListIsEmpty(lpGarb->hList))
		{
			LPGARBELEM lpGarbElem;

			if ((lpGarbElem = ListRemoveHead(lpGarb->hList)) == NULL)
				fSuccess = TraceFALSE(NULL);

			else if (GarbElemDestroy(lpGarbElem) != 0)
				TraceFALSE(NULL); // keep going despite failure
		}

		// destroy the list
		//
		if (ListDestroy(lpGarb->hList) != 0)
			fSuccess = TraceFALSE(NULL);
		else
			lpGarb->hList = NULL;
	}

	if ((lpGarb = MemFree(NULL, lpGarb)) != NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}

// GarbAddElement - add an element to the garbage bag
//		<hGarb>				(i) handle returned from GarbInit
//		<elem>				(i) garbage elem
//		<dwFlags>			(i) element flags (determines disposal method)
//			GARBELEM_TEMPFILENAME	FileRemove(elem)
//			GARBELEM_STRDUP			StrDupFree(elem)
//			GARBELEM_GLOBALPTR		GlobalFreePtr(elem)
//			GARBELEM_LOCALPTR		LocalFreePtr(elem)
#ifdef _WIN32
//			GARBELEM_HEAPPTR		HeapFreePtr(GetProcessHeap(), 0, elem)
#endif
//			GARBELEM_CURSOR			DestroyCursor(elem)
//			GARBELEM_ICON			DestroyIcon(elem)
//			GARBELEM_MENU			DestroyMenu(elem)
//			GARBELEM_WINDOW			DestroyWindow(elem)
//			GARBELEM_DC				DeleteDC(elem)
//			GARBELEM_METAFILE		DeleteMetafile(elem)
//			GARBELEM_PEN			DeleteObject(elem)
//			GARBELEM_BRUSH			DeleteObject(elem)
//			GARBELEM_FONT			DeleteObject(elem)
//			GARBELEM_BITMAP			DeleteObject(elem)
//			GARBELEM_RGN			DeleteObject(elem)
//			GARBELEM_PALETTE		DeleteObject(elem)
//			GARBELEM_HFIL			FileClose(elem)
//			GARBELEM_HFILE			_lclose(elem)
// return 0 if success
//
// NOTE: it is possible to combine flags, such as
// (GARBELEM_TEMPFILENAME | GARBELEM_STRDUP)
// In this case the FileRemove() will be called before StrDupFree()
// Most flag combinations, however, make no sense.
//
int DLLEXPORT WINAPI GarbAddElement(HGARB hGarb, LPVOID elem, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPGARB lpGarb;
	LPGARBELEM lpGarbElem = NULL;

	if ((lpGarb = GarbGetPtr(hGarb)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpGarbElem = GarbElemCreate(elem, dwFlags)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (ListAddTail(lpGarb->hList, lpGarbElem) == NULL)
		fSuccess = TraceFALSE(NULL);

	if (!fSuccess)
	{
		GarbElemDestroy(lpGarbElem);
		lpGarbElem = NULL;
	}

	return fSuccess ? 0 : -1;
}

////
//	helper functions
////

// GarbGetPtr - verify that garb handle is valid,
//		<hGarb>				(i) handle returned from GarbInit
// return corresponding garb pointer (NULL if error)
//
static LPGARB GarbGetPtr(HGARB hGarb)
{
	BOOL fSuccess = TRUE;
	LPGARB lpGarb;

	if ((lpGarb = (LPGARB) hGarb) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadWritePtr(lpGarb, sizeof(GARB)))
		fSuccess = TraceFALSE(NULL);

#ifdef CHECKTASK
	// make sure current task owns the garb handle
	//
	else if (lpGarb->hTask != GetCurrentTask())
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? lpGarb : NULL;
}

// GarbGetHandle - verify that garb pointer is valid,
//		<lpGarb>			(i) pointer to GARB struct
// return corresponding garb handle (NULL if error)
//
static HGARB GarbGetHandle(LPGARB lpGarb)
{
	BOOL fSuccess = TRUE;
	HGARB hGarb;

	if ((hGarb = (HGARB) lpGarb) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hGarb : NULL;
}

// GarbElemCreate - garbage element constructor
//		<elem>				(i) data element
//		<dwFlags>			(i) element	flags (see GarbAddElement)
// return pointer (NULL if error)
//
static LPGARBELEM GarbElemCreate(LPVOID elem, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPGARBELEM lpGarbElem;

	if ((lpGarbElem = (LPGARBELEM) MemAlloc(NULL, sizeof(GARBELEM), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lpGarbElem->elem = elem;
		lpGarbElem->dwFlags = dwFlags;
	}

	return fSuccess ? lpGarbElem : NULL;
}

// GarbElemDestroy - garbage element destructor
//		<lpGarbElem>			(i) pointer returned from GarbElemCreate
// return 0 if success
//
static int GarbElemDestroy(LPGARBELEM lpGarbElem)
{
	BOOL fSuccess = TRUE;

	if (lpGarbElem == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		// dispose of temporary file
		//
		if (lpGarbElem->dwFlags & GARBELEM_TEMPFILENAME)
		{
			if (FileRemove((LPCTSTR) lpGarbElem->elem) != 0)
				fSuccess = TraceFALSE(NULL);
		}

		// dispose of string created by StrDup
		//
		if (lpGarbElem->dwFlags & GARBELEM_STRDUP &&
			lpGarbElem->elem != NULL)
		{
			if (StrDupFree((LPTSTR) lpGarbElem->elem) != 0)
				fSuccess = TraceFALSE(NULL);
			else
				lpGarbElem->elem = NULL;
		}

		// dispose of global memory block
		//
		if (lpGarbElem->dwFlags & GARBELEM_GLOBALPTR &&
			lpGarbElem->elem != NULL)
		{
			if (GlobalFreePtr(lpGarbElem->elem) != 0)
				fSuccess = TraceFALSE(NULL);
			else
				lpGarbElem->elem = NULL;
		}

		// dispose of local memory block
		//
		if (lpGarbElem->dwFlags & GARBELEM_LOCALPTR &&
			lpGarbElem->elem != NULL)
		{
			if (LocalFreePtr((NPSTR) LOWORD(lpGarbElem->elem)) != 0)
				fSuccess = TraceFALSE(NULL);
			else
				lpGarbElem->elem = NULL;
		}
#ifdef _WIN32
		// dispose of heap memory block
		//
		if (lpGarbElem->dwFlags & GARBELEM_HEAPPTR &&
			lpGarbElem->elem != NULL)
		{
			if (!HeapFree(GetProcessHeap(), 0, lpGarbElem->elem))
				fSuccess = TraceFALSE(NULL);
			else
				lpGarbElem->elem = NULL;
		}
#endif
		// dispose of cursor
		//
		if (lpGarbElem->dwFlags & GARBELEM_CURSOR &&
			lpGarbElem->elem != NULL)
		{
			if (!DestroyCursor((HCURSOR) lpGarbElem->elem))
				fSuccess = TraceFALSE(NULL);
			else
				lpGarbElem->elem = NULL;
		}

		// dispose of icon
		//
		if (lpGarbElem->dwFlags & GARBELEM_ICON &&
			lpGarbElem->elem != NULL)
		{
			if (!DestroyIcon((HICON) lpGarbElem->elem))
				fSuccess = TraceFALSE(NULL);
			else
				lpGarbElem->elem = NULL;
		}

		// dispose of menu
		//
		if (lpGarbElem->dwFlags & GARBELEM_MENU &&
			lpGarbElem->elem != NULL)
		{
			if (!DestroyMenu((HMENU) lpGarbElem->elem))
				fSuccess = TraceFALSE(NULL);
			else
				lpGarbElem->elem = NULL;
		}

		// dispose of window
		//
		if (lpGarbElem->dwFlags & GARBELEM_WINDOW &&
			lpGarbElem->elem != NULL)
		{
			if (!DestroyWindow((HWND) lpGarbElem->elem))
				fSuccess = TraceFALSE(NULL);
			else
				lpGarbElem->elem = NULL;
		}

		// dispose of display context
		//
		if (lpGarbElem->dwFlags & GARBELEM_DC &&
			lpGarbElem->elem != NULL)
		{
			if (!DeleteDC((HDC) lpGarbElem->elem))
				fSuccess = TraceFALSE(NULL);
			else
				lpGarbElem->elem = NULL;
		}

		// dispose of metafile
		//
		if (lpGarbElem->dwFlags & GARBELEM_METAFILE &&
			lpGarbElem->elem != NULL)
		{
			if (!DeleteMetaFile((HMETAFILE) lpGarbElem->elem))
				fSuccess = TraceFALSE(NULL);
			else
				lpGarbElem->elem = NULL;
		}

		// dispose of pen
		//
		if (lpGarbElem->dwFlags & GARBELEM_PEN &&
			lpGarbElem->elem != NULL)
		{
			if (!DeletePen((HPEN) lpGarbElem->elem))
				fSuccess = TraceFALSE(NULL);
			else
				lpGarbElem->elem = NULL;
		}

		// dispose of brush
		//
		if (lpGarbElem->dwFlags & GARBELEM_BRUSH &&
			lpGarbElem->elem != NULL)
		{
			if (!DeleteBrush((HBRUSH) lpGarbElem->elem))
				fSuccess = TraceFALSE(NULL);
			else
				lpGarbElem->elem = NULL;
		}

		// dispose of font
		//
		if (lpGarbElem->dwFlags & GARBELEM_FONT &&
			lpGarbElem->elem != NULL)
		{
			if (!DeleteFont((HFONT) lpGarbElem->elem))
				fSuccess = TraceFALSE(NULL);
			else
				lpGarbElem->elem = NULL;
		}

		// dispose of bitmap
		//
		if (lpGarbElem->dwFlags & GARBELEM_BITMAP &&
			lpGarbElem->elem != NULL)
		{
			if (!DeleteBitmap((HBITMAP) lpGarbElem->elem))
				fSuccess = TraceFALSE(NULL);
			else
				lpGarbElem->elem = NULL;
		}

		// dispose of region
		//
		if (lpGarbElem->dwFlags & GARBELEM_RGN &&
			lpGarbElem->elem != NULL)
		{
			if (!DeleteRgn((HRGN) lpGarbElem->elem))
				fSuccess = TraceFALSE(NULL);
			else
				lpGarbElem->elem = NULL;
		}

		// dispose of palette
		//
		if (lpGarbElem->dwFlags & GARBELEM_PALETTE &&
			lpGarbElem->elem != NULL)
		{
			if (!DeletePalette((HPALETTE) lpGarbElem->elem))
				fSuccess = TraceFALSE(NULL);
			else
				lpGarbElem->elem = NULL;
		}

		// dispose of file handle obtained from FileOpen or FileCreate
		//
		if (lpGarbElem->dwFlags & GARBELEM_HFIL &&
			lpGarbElem->elem != NULL)
		{
			if (FileClose((HFIL) lpGarbElem->elem) != 0)
				fSuccess = TraceFALSE(NULL);
			else
				lpGarbElem->elem = NULL;
		}

		// dispose of file handle obtained from OpenFile, _lopen or _lcreat
		//
		if (lpGarbElem->dwFlags & GARBELEM_HFILE &&
			lpGarbElem->elem != NULL)
		{
			if ( _lclose((HFILE) LOWORD(lpGarbElem->elem)) != 0 )
				fSuccess = TraceFALSE(NULL);
			else
				lpGarbElem->elem = NULL;
		}

		if ((lpGarbElem = MemFree(NULL, lpGarbElem)) != NULL)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\help.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	help.c - help functions
////

#include "winlocal.h"

#include <stdlib.h>

#include "help.h"
#include "mem.h"
#include "str.h"
#include "trace.h"

////
//	private definitions
////

// help control struct
//
typedef struct HELP
{
	DWORD dwVersion;
	HINSTANCE hInst;
	HTASK hTask;
	HWND hwndFrame;
	TCHAR szHelpFile[_MAX_PATH];
	UINT idContents;
} HELP, FAR *LPHELP;

// helper functions
//
static LPHELP HelpGetPtr(HHELP hHelp);
static HHELP HelpGetHandle(LPHELP lpHelp);
static int HelpQuit(HHELP hHelp);

////
//	public functions
////

// HelpInit - initialize help engine
//		<dwVersion>			(i) must be HELP_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<hwndFrame>			(i) frame window of the calling program
//		<lpszHelpFile>		(i) help file to display
// return handle (NULL if error)
//
HHELP DLLEXPORT WINAPI HelpInit(DWORD dwVersion, HINSTANCE hInst, HWND hwndFrame, LPCTSTR lpszHelpFile)
{
	BOOL fSuccess = TRUE;
	LPHELP lpHelp = NULL;

	if (dwVersion != HELP_VERSION)
		fSuccess = TraceFALSE(NULL);
	
	else if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (hwndFrame == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpszHelpFile == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpHelp = (LPHELP) MemAlloc(NULL, sizeof(HELP), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lpHelp->dwVersion = dwVersion;
		lpHelp->hInst = hInst;
		lpHelp->hTask = GetCurrentTask();
		lpHelp->hwndFrame = hwndFrame;
		StrNCpy(lpHelp->szHelpFile, lpszHelpFile, SIZEOFARRAY(lpHelp->szHelpFile));
		lpHelp->idContents = 0;
	}

	if (!fSuccess)
	{
		HelpTerm(HelpGetHandle(lpHelp));
		lpHelp = NULL;
	}

	return fSuccess ? HelpGetHandle(lpHelp) : NULL;
}

// HelpTerm - shut down help engine
//		<hHelp>				(i) handle returned by HelpInit
// return 0 if success
//
int DLLEXPORT WINAPI HelpTerm(HHELP hHelp)
{
	BOOL fSuccess = TRUE;
	LPHELP lpHelp;

	if ((lpHelp = HelpGetPtr(hHelp)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (HelpQuit(hHelp) != 0)
		fSuccess = TraceFALSE(NULL);

	else if ((lpHelp = MemFree(NULL, lpHelp)) != NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}

// HelpGetHelpFile - get help file name
//		<hHelp>				(i) handle returned by HelpInit
//		<lpszHelpFile>		(o) buffer to hold help file name
//		<sizHelpFile>		(i) size of buffer
//			NULL				do not copy; return static pointer instead
// return pointer to help file name (NULL if error)
//
LPTSTR DLLEXPORT WINAPI HelpGetHelpFile(HHELP hHelp, LPTSTR lpszHelpFile, int sizHelpFile)
{
	BOOL fSuccess = TRUE;
	LPHELP lpHelp;

	if ((lpHelp = (LPHELP) hHelp) == NULL)
		fSuccess = TraceFALSE(NULL);

	{
		// copy file name if destination buffer specified
		//
		if (lpszHelpFile != NULL)
			StrNCpy(lpszHelpFile, lpHelp->szHelpFile, sizHelpFile);

		// otherwise just point to static copy of file name
		//
		else
			lpszHelpFile = lpHelp->szHelpFile;
	}

	return fSuccess ? lpszHelpFile : NULL;
}

// HelpContents - display Help contents topic
//		<hHelp>				(i) handle returned by HelpInit
// return 0 if success
//
int DLLEXPORT WINAPI HelpContents(HHELP hHelp)
{
	BOOL fSuccess = TRUE;
	LPHELP lpHelp;

	if ((lpHelp = HelpGetPtr(hHelp)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// use the default contents topic if no other has been set
	//
	else if (lpHelp->idContents == 0 &&
		!WinHelp(lpHelp->hwndFrame,
		lpHelp->szHelpFile, HELP_CONTENTS, 0L))
		fSuccess = TraceFALSE(NULL);

	// display the current contents topic
	//
	else if (lpHelp->idContents != 0
		&& HelpContext(hHelp, lpHelp->idContents) != 0)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}

// HelpOnHelp - display Help topic on using help
//		<hHelp>				(i) handle returned by HelpInit
// return 0 if success
//
int DLLEXPORT WINAPI HelpOnHelp(HHELP hHelp)
{
	BOOL fSuccess = TRUE;
	LPHELP lpHelp;

	if ((lpHelp = HelpGetPtr(hHelp)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (!WinHelp(lpHelp->hwndFrame, lpHelp->szHelpFile,
		HELP_HELPONHELP, 0L))
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}

// HelpContext - display Help topic corresponding to specified context id
//		<hHelp>				(i) handle returned by HelpInit
//		<idContext>			(i) id of the topic to display
// return 0 if success
//
int DLLEXPORT WINAPI HelpContext(HHELP hHelp, UINT idContext)
{
	BOOL fSuccess = TRUE;
#if 0
	TCHAR szKeyword[128];

	if (LoadString(lpHelp->hInst, idContext, szKeyword, SIZEOFARRAY(szKeyword)) <= 0)
		fSuccess = TraceFALSE(NULL);

	else if (HelpKeyword(hHelp, szKeyword) != 0)
		fSuccess = TraceFALSE(NULL);
#else
	LPHELP lpHelp;

	if ((lpHelp = HelpGetPtr(hHelp)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (!WinHelp(lpHelp->hwndFrame, lpHelp->szHelpFile,
		HELP_CONTEXT, (DWORD) idContext))
		fSuccess = TraceFALSE(NULL);
#endif
	return fSuccess ? 0 : -1;
}

// HelpKeyword - display Help topic corresponding to specified keyword
//		<hHelp>				(i) handle returned by HelpInit
//		<lpszKeyword>		(i) keyword of the topic to display
// return 0 id success
//
int DLLEXPORT WINAPI HelpKeyword(HHELP hHelp, LPCTSTR lpszKeyword)
{
	BOOL fSuccess = TRUE;
	LPHELP lpHelp;
	TCHAR szCommand[128];

	if ((lpHelp = HelpGetPtr(hHelp)) == NULL)
		fSuccess = TraceFALSE(NULL);
#if 0
	else if (!WinHelp(lpHelp->hwndFrame, lpHelp->szHelpFile,
		HELP_KEY, (DWORD) lpszKeyword))
		fSuccess = TraceFALSE(NULL);
#else
    //
    // We should verify the lpHelp pointer
    //
    if( lpHelp )
    {
	    if (wsprintf(szCommand, TEXT("JumpID(\"%s\", \"%s\")"),
		    (LPTSTR) lpHelp->szHelpFile, (LPTSTR) lpszKeyword) <= 0)
		    fSuccess = TraceFALSE(NULL);

	    else if (!WinHelp(lpHelp->hwndFrame, lpHelp->szHelpFile,
		    HELP_FORCEFILE, 0L))
		    fSuccess = TraceFALSE(NULL);

	    else if (!WinHelp(lpHelp->hwndFrame, lpHelp->szHelpFile,
		     HELP_COMMAND, (DWORD_PTR) szCommand))
		    fSuccess = TraceFALSE(NULL);
    }
#endif

	return fSuccess ? 0 : -1;
}

// HelpGetContentsId - get Help contents topic id
//		<hHelp>				(i) handle returned by HelpInit
// return id of the current contents topic (0 if default, -1 if error)
//
int DLLEXPORT WINAPI HelpGetContentsId(HHELP hHelp)
{
	BOOL fSuccess = TRUE;
	LPHELP lpHelp;

	if ((lpHelp = HelpGetPtr(hHelp)) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? lpHelp->idContents : -1;
}

// HelpSetContentsId - set Help contents topic id
//		<hHelp>				(i) handle returned by HelpInit
//		<idContents>		(i) new id of the contents topic
//			0					set to default contents id
// return 0 if success
//
int DLLEXPORT WINAPI HelpSetContentsId(HHELP hHelp, UINT idContents)
{
	BOOL fSuccess = TRUE;
	LPHELP lpHelp;

	if ((lpHelp = HelpGetPtr(hHelp)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
		lpHelp->idContents = idContents;

	return fSuccess ? 0 : -1;
}

////
//	helper functions
////

// HelpGetPtr - verify that help handle is valid,
//		<hHelp>				(i) handle returned by HelpInit
// return corresponding help pointer (NULL if error)
//
static LPHELP HelpGetPtr(HHELP hHelp)
{
	BOOL fSuccess = TRUE;
	LPHELP lpHelp;

	if ((lpHelp = (LPHELP) hHelp) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadWritePtr(lpHelp, sizeof(HELP)))
		fSuccess = TraceFALSE(NULL);

#ifdef CHECKTASK
	// make sure current task owns the help handle
	//
	else if (lpHelp->hTask != GetCurrentTask())
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? lpHelp : NULL;
}

// HelpGetHandle - verify that help pointer is valid,
//		<lpHelp>			(i) pointer to HELP struct
// return corresponding help handle (NULL if error)
//
static HHELP HelpGetHandle(LPHELP lpHelp)
{
	BOOL fSuccess = TRUE;
	HHELP hHelp;

	if ((hHelp = (HHELP) lpHelp) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hHelp : NULL;
}

// HelpQuit - close Help application if no other app needs it
//		<hHelp>				(i) handle returned by HelpInit
// return 0 if success
//
static int HelpQuit(HHELP hHelp)
{
	BOOL fSuccess = TRUE;
	LPHELP lpHelp;

	if ((lpHelp = (LPHELP) hHelp) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (!WinHelp(lpHelp->hwndFrame, lpHelp->szHelpFile,
		HELP_QUIT, 0L))
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\garb.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	garb.h - interface for garbage bag functions in garb.c
////

#ifndef __GARB_H__
#define __GARB_H__

#include "winlocal.h"

#define GARB_VERSION 0x00000100

// garbage bag handle
//
DECLARE_HANDLE32(HGARB);

// flags which identify characteristics of a garbage bag element
//
#define GARBELEM_TEMPFILENAME	0x00000001
#define GARBELEM_STRDUP			0x00000002
#define GARBELEM_GLOBALPTR		0x00000004
#define GARBELEM_LOCALPTR		0x00000008
#define GARBELEM_CURSOR			0x00000010
#define GARBELEM_ICON			0x00000020
#define GARBELEM_MENU			0x00000040
#define GARBELEM_WINDOW			0x00000080
#define GARBELEM_ATOM			0x00000100
#define GARBELEM_DC				0x00000200
#define GARBELEM_METAFILE		0x00000400
#define GARBELEM_PEN			0x00001000
#define GARBELEM_BRUSH			0x00002000
#define GARBELEM_FONT			0x00004000
#define GARBELEM_BITMAP			0x00008000
#define GARBELEM_RGN			0x00010000
#define GARBELEM_PALETTE		0x00020000
#define GARBELEM_HFIL			0x00040000
#define GARBELEM_HFILE			0x00080000
#ifdef _WIN32
#define GARBELEM_HEAPPTR		0x00100000
#endif

#ifdef __cplusplus
extern "C" {
#endif

// GarbInit - initialize garbage bag
//		<dwVersion>			(i) must be GARB_VERSION
// 		<hInst>				(i) instance handle of calling module
// return handle (NULL if error)
//
HGARB DLLEXPORT WINAPI GarbInit(DWORD dwVersion, HINSTANCE hInst);

// GarbTerm - dispose of each element in garbage bag, then destroy it
//		<hGarb>				(i) handle returned from GarbInit
// return 0 if success
//
// NOTE: elements are disposed of in the order they were placed
// in the garbage bag;  therefore, for instance, if a temporary
// file is to be first closed and then deleted, call GarbAddElement()
// first with the file handle (GARBELEM_HFILE) and then with the
// file name (GARBELEM_TEMPFILENAME).
//
int DLLEXPORT WINAPI GarbTerm(HGARB hGarb);

// GarbAddElement - add an element to the garbage bag
//		<hGarb>				(i) handle returned from GarbInit
//		<elem>				(i) garbage elem
//		<dwFlags>			(i) element flags (determines disposal method)
//			GARBELEM_TEMPFILENAME	FileRemove(elem)
//			GARBELEM_STRDUP			StrDupFree(elem)
//			GARBELEM_GLOBALPTR		GlobalFreePtr(elem)
//			GARBELEM_LOCALPTR		LocalFreePtr(elem)
#ifdef _WIN32
//			GARBELEM_HEAPPTR		HeapFreePtr(GetProcessHeap(), 0, elem)
#endif
//			GARBELEM_CURSOR			DestroyCursor(elem)
//			GARBELEM_ICON			DestroyIcon(elem)
//			GARBELEM_MENU			DestroyMenu(elem)
//			GARBELEM_WINDOW			DestroyWindow(elem)
//			GARBELEM_DC				DeleteDC(elem)
//			GARBELEM_METAFILE		DeleteMetafile(elem)
//			GARBELEM_PEN			DeleteObject(elem)
//			GARBELEM_BRUSH			DeleteObject(elem)
//			GARBELEM_FONT			DeleteObject(elem)
//			GARBELEM_BITMAP			DeleteObject(elem)
//			GARBELEM_RGN			DeleteObject(elem)
//			GARBELEM_PALETTE		DeleteObject(elem)
//			GARBELEM_HFIL			FileClose(elem)
//			GARBELEM_HFILE			_lclose(elem)
// return 0 if success
//
// NOTE: it is possible to combine flags, such as
// (GARBELEM_TEMPFILENAME | GARBELEM_STRDUP)
// In this case the FileRemove() will be called before StrDupFree()
// Most flag combinations, however, make no sense.
//
int DLLEXPORT WINAPI GarbAddElement(HGARB hGarb, LPVOID elem, DWORD dwFlags);

#ifdef __cplusplus
}
#endif

#endif // __GARB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\gfx.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// gfx.h - interface for graphics functions in gfx.c
////

#ifndef __GFX_H__
#define __GFX_H__

#include "winlocal.h"

#define GFX_VERSION 0x00000100

////
//	bitmap routines
////

// option flags for GfxBitmapBackfill <wFlags> param
//
#define BF_EXTFLOODFILL		0x0001
#define BF_GETSETPIXEL		0x0002

// option flags for GfxBitmapScroll <dwFlags> param
//
#define	BS_ROTATE			0x00000001

#ifdef __cplusplus
extern "C" {
#endif

// GfxBitmapBackfill - replace bitmap's white backg with curr backg color
//		<hBitmap>			(i/o) bitmap handle
//		<crBkColor>			(i) current background color
//		<wFlags>			(i) option flags
//			0					use default method
//			BF_EXTFLOODFILL		use ExtFloodFill function
//			BF_GETSETPIXEL		use GetPixel/SetPixel functions
//			NOTE: rarely, ExtFloodFill will GP the display device driver
// return 0 if success
//
int DLLEXPORT WINAPI GfxBitmapBackfill(HBITMAP hBitmap, COLORREF crBkColor, WORD wFlags);

// GfxBitmapDisplay - display specified bitmap
//		<hdc>				(i) device context for destination window
//		<hBitmap>			(i) bitmap handle for source bitmap
//		<x>					(i) x coordinate for destination window
//		<y>					(i) y coordinate for destination window
//		<fInvert>			(i) display bitmap inverted
// return 0 if success
//
int DLLEXPORT WINAPI GfxBitmapDisplay(HDC hdc, HBITMAP hBitmap, int x, int y, BOOL fInvert);

// GfxBitmapDrawTransparent - draw specified bitmap
//		<hdc>				(i) device context for destination window
//		<hBitmap>			(i) bitmap handle for source bitmap
//		<x>					(i) x coordinate for destination window
//		<y>					(i) y coordinate for destination window
//		<crTransparent>		(i) transparent color
//		<dwFlags>			(i) control flags
//			0					reserved; must be zero
// return 0 if success
//
int DLLEXPORT WINAPI GfxBitmapDrawTransparent(HDC hdc, HBITMAP hBitmap, int x, int y, COLORREF crTransparent, DWORD dwFlags);

// GfxBitmapScroll - scroll specified bitmap
//		<hdc>				(i) device context for destination window
//		<hBitmap>			(i) bitmap handle for source bitmap
//		<dx>				(i) amt of horizontal scroll (cx < 0 scrolls left)
//		<dy>				(i) amt of vertical scroll (cx < 0 scrolls up)
//		<dwFlags>			(i) control flags
//			BS_ROTATE			rotate bitmap
// return 0 if success
//
int DLLEXPORT WINAPI GfxBitmapScroll(HDC hdc, HBITMAP hBitmap, int dx, int dy, DWORD dwFlags);

// GfxLoadBitmapEx - load specified bitmap resource, get palette
//		<hInstance>			(i) handle of module to load resource from
//			NULL				load pre-defined Windows bitmap
//		<lpszBitmap>		(i) name of bitmap resource
//								or MAKEINTRESOURCE(idBitmap)
//								or <OBM_xxx> if hInstance is NULL
//		<lphPalette>		(o) palette is returned here
//			NULL				do not return palette
// return bitmap handle if success, otherwise NULL
// NOTE: see documentation for LoadBitmap function
// NOTE: call DeleteObject() to free returned bitmap and palette handles
//
HBITMAP DLLEXPORT WINAPI GfxLoadBitmapEx(HINSTANCE hInstance,
	LPCTSTR lpszBitmap, HPALETTE FAR *lphPalette);

// GfxCreateDIBPalette - create palette
//		<lpbmi>				(i) ptr to BITMAPINFO struct, describes DIB
//		<lpnColors>			(o) number of colors is returned here
// return new palette handle if success, otherwise NULL
//
HPALETTE DLLEXPORT WINAPI CreateDIBPalette (LPBITMAPINFO lpbmi, LPINT lpnColors);

////
//	text routines
////

// GfxTextExtentTruncate - truncate string if too long
//		<lpsz>				(i/o) string to truncate
//		<hdc>				(i) current device context
//		<cxMax>				(i) maximum string width in logical units
// return new length of string (0 if error)
//
int DLLEXPORT WINAPI GfxTextExtentTruncate(LPTSTR lpsz, HDC hdc, int cxMax);

////
//	cursor routines
////

// GfxShowHourglass - show the hourglass cursor
//		<hwndCapture>		(i) window to capture mouse input during hourglass
// return old cursor (NULL if error or none)
//
HCURSOR DLLEXPORT WINAPI GfxShowHourglass(HWND hwnd);

// GfxHideHourglass - hide the hourglass cursor
//		<hCursorRestore>	(i) cursor handle returned from GfxShowHourglass
//			NULL				replace cursor with IDC_ARROW
// return 0 if success
//
int DLLEXPORT WINAPI GfxHideHourglass(HCURSOR hCursorRestore);

// GfxDeviceIsMono - determine if device context is monochrome
//		<hdc>				(i) device context
//			NULL				use screen device context
// return TRUE if monochrome, FALSE if color
//
BOOL DLLEXPORT WINAPI GfxDeviceIsMono(HDC hdc);

#ifdef __cplusplus
}
#endif

#endif // __GFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\help.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// help.h - interface for help functions in help.c
////

#ifndef __HELP_H__
#define __HELP_H__

#include "winlocal.h"

#define HELP_VERSION 0x00000100

// handle to help engine
//
DECLARE_HANDLE32(HHELP);

#ifdef __cplusplus
extern "C" {
#endif

// HelpInit - initialize help engine
//		<dwVersion>			(i) must be HELP_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<hwndFrame>			(i) frame window of the calling program
//		<lpszHelpFile>		(i) help file to display
// return handle (NULL if error)
//
HHELP DLLEXPORT WINAPI HelpInit(DWORD dwVersion, HINSTANCE hInst, HWND hwndFrame, LPCTSTR lpszHelpFile);

// HelpTerm - shut down help engine
//		<hHelp>				(i) handle returned by HelpInit
// return 0 if success
//
int DLLEXPORT WINAPI HelpTerm(HHELP hHelp);

// HelpGetHelpFile - get help file name
//		<hHelp>				(i) handle returned by HelpInit
//		<lpszHelpFile>		(o) buffer to hold help file name
//		<sizHelpFile>		(i) size of buffer
//			NULL				do not copy; return static pointer instead
// return pointer to help file name (NULL if error)
//
LPTSTR DLLEXPORT WINAPI HelpGetHelpFile(HHELP hHelp, LPTSTR lpszHelpFile, int sizHelpFile);

// HelpContents - display Help contents topic
//		<hHelp>				(i) handle returned by HelpInit
// return 0 if success
//
int DLLEXPORT WINAPI HelpContents(HHELP hHelp);

// HelpOnHelp - display Help topic on using help
//		<hHelp>				(i) handle returned by HelpInit
// return 0 if success
//
int DLLEXPORT WINAPI HelpOnHelp(HHELP hHelp);

// HelpContext - display Help topic corresponding to specified context id
//		<hHelp>				(i) handle returned by HelpInit
//		<idContext>			(i) id of the topic to display
// return 0 if success
//
int DLLEXPORT WINAPI HelpContext(HHELP hHelp, UINT idContext);

// HelpKeyword - display Help topic corresponding to specified keyword
//		<hHelp>				(i) handle returned by HelpInit
//		<lpszKeyword>		(i) keyword of the topic to display
// return 0 id success
//
int DLLEXPORT WINAPI HelpKeyword(HHELP hHelp, LPCTSTR lpszKeyword);

// HelpGetContentsId - get Help contents topic id
//		<hHelp>				(i) handle returned by HelpInit
// return id of the current contents topic (0 if default, -1 if error)
//
int DLLEXPORT WINAPI HelpGetContentsId(HHELP hHelp);

// HelpSetContentsId - set Help contents topic id
//		<hHelp>				(i) handle returned by HelpInit
//		<idContents>		(i) new id of the contents topic
//			0					set to default contents id
// return 0 if success
//
int DLLEXPORT WINAPI HelpSetContentsId(HHELP hHelp, UINT idContents);

#ifdef __cplusplus
}
#endif

#endif // __HELP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\ini.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// ini.h - interface for ini profile functions in ini.c
////

#ifndef __INI_H__
#define __INI_H__

#include "winlocal.h"

#define INI_VERSION 0x00000107

// handle to ini engine
//
DECLARE_HANDLE32(HINI);

#ifdef __cplusplus
extern "C" {
#endif

// IniOpen - open ini file
//		<dwVersion>			(i) must be INI_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<lpszCmdLine>		(i) command line from WinMain()
//		<lpszFilename>		(i) name of ini file
//		<dwFlags>			(i) reserved, must be 0
// return handle (NULL if error)
//
HINI DLLEXPORT WINAPI IniOpen(DWORD dwVersion, HINSTANCE hInst, LPCTSTR lpszFilename, DWORD dwFlags);

// IniClose - close ini file
//		<hIni>				(i) handle returned from IniOpen
// return 0 if success
//
int DLLEXPORT WINAPI IniClose(HINI hIni);

// IniGetInt - read integer value from specified section and entry
//		<hIni>				(i) handle returned from IniOpen
//		<lpszSection>		(i) section heading in the ini file
//		<lpszEntry>			(i) entry whose value is to be retrieved
//		<iDefault>			(i) return value if entry not found
// return entry value (iDefault if error or not found)
//
UINT DLLEXPORT WINAPI IniGetInt(HINI hIni, LPCTSTR lpszSection, LPCTSTR lpszEntry, int iDefault);

// IniGetString - read string value from specified section and entry
//		<hIni>				(i) handle returned from IniOpen
//		<lpszSection>		(i) section heading in the ini file
//		<lpszEntry>			(i) entry whose value is to be retrieved
//		<lpszDefault>		(i) return value if entry not found
//		<lpszReturnBuffer>	(o) destination buffer
//		<sizReturnBuffer>	(i) size of destination buffer
// return count of bytes copied (0 if error or not found)
//
int DLLEXPORT WINAPI IniGetString(HINI hIni, LPCTSTR lpszSection, LPCTSTR lpszEntry,
	LPCTSTR lpszDefault, LPTSTR lpszReturnBuffer, int cbReturnBuffer);

// GetPrivateProfileLong - retrieve long from specified section of specified file
//		<lpszSection>		(i) section name within ini file
//		<lpszEntry>			(i) entry name within section
//		<lDefault>			(i) return value if entry not found
//		<lpszFilename>		(i) name of ini file
// return TRUE if success
//
long DLLEXPORT WINAPI GetPrivateProfileLong(LPCTSTR lpszSection,
	LPCTSTR lpszEntry, long lDefault, LPCTSTR lpszFilename);

// GetProfileLong - retrieve long from specified section of win.ini
//		<lpszSection>		(i) section name within ini file
//		<lpszEntry>			(i) entry name within section
//		<lDefault>			(i) return value if entry not found
// return TRUE if success
//
long DLLEXPORT WINAPI GetProfileLong(LPCTSTR lpszSection,
	LPCTSTR lpszEntry, long lDefault);

// WritePrivateProfileInt - write int to specified section of specified file
//		<lpszSection>		(i) section name within ini file
//		<lpszEntry>			(i) entry name within section
//		<iValue>			(i) integer value to assign to entry
//		<lpszFilename>		(i) name of ini file
// return TRUE if success
//
BOOL DLLEXPORT WINAPI WritePrivateProfileInt(LPCTSTR lpszSection, LPCTSTR lpszEntry, int iValue, LPCTSTR lpszFilename);

// WriteProfileInt - write int to specified section of win.ini
//		<lpszSection>		(i) section name within win.ini file
//		<lpszEntry>			(i) entry name within section
//		<iValue>			(i) integer value to assign to entry
// return TRUE if success
//
BOOL DLLEXPORT WINAPI WriteProfileInt(LPCTSTR lpszSection, LPCTSTR lpszEntry, int iValue);

// WritePrivateProfileLong - write long to specified section of specified file
//		<lpszSection>		(i) section name within ini file
//		<lpszEntry>			(i) entry name within section
//		<iValue>			(i) integer value to assign to entry
//		<lpszFilename>		(i) name of ini file
// return TRUE if success
//
BOOL DLLEXPORT WINAPI WritePrivateProfileLong(LPCTSTR lpszSection, LPCTSTR lpszEntry, long iValue, LPCTSTR lpszFilename);

// WriteProfileLong - write long to specified section of win.ini
//		<lpszSection>		(i) section name within win.ini file
//		<lpszEntry>			(i) entry name within section
//		<iValue>			(i) integer value to assign to entry
// return TRUE if success
//
BOOL DLLEXPORT WINAPI WriteProfileLong(LPCTSTR lpszSection, LPCTSTR lpszEntry, long iValue);

// UpdatePrivateProfileSection - update destination section based on source
//		<lpszSection>		(i) section name within ini file
//		<lpszFileNameSrc>	(i) name of source ini file
//		<lpszFileNameDst>	(i) name of destination ini file
// return 0 if success
//
// NOTE: if the source file has UpdateLocal=1 entry in the specified
// section, each entry in the source file is compared to the corresponding
// entry in the destination file.  If no corresponding entry is found,
// it is copied.  If a corresponding entry is found, it is overwritten
// ONLY IF the source file entry name is all uppercase.
//
//		Src					Dst before			Dst after
//
//		[Section]			[Section]			[Section]
//		UpdateLocal=1
//		EntryA=red			none				EntryA=red
//		EntryB=blue			EntryB=white		EntryB=white
//		ENTRYC=blue			EntryC=white		EntryC=blue
//
int DLLEXPORT WINAPI UpdatePrivateProfileSection(LPCTSTR lpszSection, LPCTSTR lpszFileNameSrc, LPCTSTR lpszFileNameDst);

#ifdef __cplusplus
}
#endif

#endif // __INI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\ini.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	ini.c - Windows ini profile functions
////

#include "winlocal.h"

#include <stdlib.h>

#include "ini.h"
#include "file.h"
#include "mem.h"
#include "str.h"
#include "trace.h"

////
//	private definitions
////

#define INI_MAXLINELEN 128

// ini control struct
//
typedef struct INI
{
	DWORD dwVersion;
	HINSTANCE hInst;
	HTASK hTask;
	HFIL hFile;
	LPTSTR lpszFilename;
	DWORD dwFlags;
	BOOL fReuseLine;
	TCHAR szSection[INI_MAXLINELEN];
	TCHAR szLine[INI_MAXLINELEN];
} INI, FAR *LPINI;

// helper functions
//
static LPINI IniGetPtr(HINI hIni);
static HINI IniGetHandle(LPINI lpIni);

////
//	public functions
////

// IniOpen - open ini file
//		<dwVersion>			(i) must be INI_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<lpszFilename>		(i) name of ini file
//		<dwFlags>			(i) reserved, must be 0
// return handle (NULL if error)
//
HINI DLLEXPORT WINAPI IniOpen(DWORD dwVersion, HINSTANCE hInst, LPCTSTR lpszFilename, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPINI lpIni = NULL;

	if (dwVersion != INI_VERSION)
		fSuccess = TraceFALSE(NULL);
	
	else if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpszFilename == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpIni = (LPINI) MemAlloc(NULL, sizeof(INI), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lpIni->dwVersion = dwVersion;
		lpIni->hInst = hInst;
		lpIni->hTask = GetCurrentTask();
		lpIni->hFile = NULL;
		lpIni->lpszFilename = StrDup(lpszFilename);
		lpIni->dwFlags = dwFlags;
		lpIni->fReuseLine = FALSE;
		*lpIni->szLine = '\0';

		// open the ini file for reading
		//
		if ((lpIni->hFile = FileOpen(lpIni->lpszFilename, OF_READ, TRUE)) == NULL)
			fSuccess = TraceFALSE(NULL);
	}

	if (!fSuccess)
	{
		IniClose(IniGetHandle(lpIni));
		lpIni = NULL;
	}

	return fSuccess ? IniGetHandle(lpIni) : NULL;
}

// IniClose - close ini file
//		<hIni>				(i) handle returned from IniOpen
// return 0 if success
//
int DLLEXPORT WINAPI IniClose(HINI hIni)
{
	BOOL fSuccess = TRUE;
	LPINI lpIni;

	if ((lpIni = IniGetPtr(hIni)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		if (lpIni->hFile != NULL && FileClose(lpIni->hFile) != 0)
			fSuccess = TraceFALSE(NULL);

		if (lpIni->lpszFilename != NULL && StrDupFree(lpIni->lpszFilename) != 0)
			fSuccess = TraceFALSE(NULL);

		if ((lpIni = MemFree(NULL, lpIni)) != NULL)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// IniGetInt - read integer value from specified section and entry
//		<hIni>				(i) handle returned from IniOpen
//		<lpszSection>		(i) section heading in the ini file
//		<lpszEntry>			(i) entry whose value is to be retrieved
//		<iDefault>			(i) return value if entry not found
// return entry value (iDefault if error or not found)
//
UINT DLLEXPORT WINAPI IniGetInt(HINI hIni, LPCTSTR lpszSection, LPCTSTR lpszEntry, int iDefault)
{
	UINT uRet;
	TCHAR szReturnBuffer[128];

	if (IniGetString(hIni, lpszSection, lpszEntry, TEXT(""),
		szReturnBuffer, SIZEOFARRAY(szReturnBuffer)) > 0)
		uRet = (UINT) StrAtoL(szReturnBuffer);
	else
		uRet = iDefault;

	return uRet;
}

// IniGetString - read string value from specified section and entry
//		<hIni>				(i) handle returned from IniOpen
//		<lpszSection>		(i) section heading in the ini file
//		<lpszEntry>			(i) entry whose value is to be retrieved
//		<lpszDefault>		(i) return value if entry not found
//		<lpszReturnBuffer>	(o) destination buffer
//		<sizReturnBuffer>	(i) size of destination buffer
// return count of bytes copied (0 if error or not found)
//
int DLLEXPORT WINAPI IniGetString(HINI hIni, LPCTSTR lpszSection, LPCTSTR lpszEntry,
	LPCTSTR lpszDefault, LPTSTR lpszReturnBuffer, int cbReturnBuffer)
{
	BOOL fSuccess = TRUE;
	LPINI lpIni;
	int nBytesCopied = 0;

	if ((lpIni = IniGetPtr(hIni)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpszSection == NULL || lpszEntry == NULL ||
		lpszDefault == NULL || lpszReturnBuffer == NULL)
		fSuccess = TraceFALSE(NULL);

	else
		StrNCpy(lpszReturnBuffer, lpszDefault, cbReturnBuffer);

	while (fSuccess)
	{
		TCHAR szLineSave[INI_MAXLINELEN];
		LPTSTR lpsz;
		long nBytesRead;

		// read the next line if necessary
		//
		if (!lpIni->fReuseLine && (nBytesRead = FileReadLine(lpIni->hFile,
			lpIni->szLine, SIZEOFARRAY(lpIni->szLine))) <= 0)
		{
			if (nBytesRead == 0)
				fSuccess = FALSE; // no trace needed for eof
			else
				fSuccess = TraceFALSE(NULL);

			continue;
		}

		StrCpy(szLineSave, lpIni->szLine);
		lpIni->fReuseLine = FALSE;

		// remove trailing newline char
		//
		if (StrGetLastChr(lpIni->szLine) == '\n')
			StrSetLastChr(lpIni->szLine, '\0');

		// check for empty line
		//
		if (*lpIni->szLine == '\0' || *lpIni->szLine == ';')
			continue;

		// check for entering new section
		//
		if (*lpIni->szLine == '[')
		{
			// save section name
			//
			StrNCpy(lpIni->szSection, lpIni->szLine + 1, SIZEOFARRAY(lpIni->szSection));
			if (StrGetLastChr(lpIni->szSection) == ']')
				StrSetLastChr(lpIni->szSection, '\0');
			continue;
		}

		if (StrICmp(lpszSection, lpIni->szSection) != 0)
		{
			// section mismatch
			//
			fSuccess = TraceFALSE(NULL);

			// we want the next call to this function to reuse this line
			//
			StrCpy(lpIni->szLine, szLineSave);
			lpIni->fReuseLine = TRUE;

			continue;
		}

		if ((lpsz = StrChr(lpIni->szLine, '=')) == NULL)
		{
			// entry has no equal sign
			//
			fSuccess = TraceFALSE(NULL);
			continue;
		}

		*lpsz = '\0';

		if (StrICmp(lpszEntry, lpIni->szLine) != 0)
		{
			// entry mismatch
			//
			fSuccess = TraceFALSE(NULL);

			// we want the next call to this function to reuse this line
			//
			StrCpy(lpIni->szLine, szLineSave);
			lpIni->fReuseLine = TRUE;

			continue;
		}

		else
		{
			// success
			//
			StrNCpy(lpszReturnBuffer, lpsz + 1, cbReturnBuffer);
			break;
		}
	}

	if (fSuccess)
		nBytesCopied = StrLen(lpszReturnBuffer);

	return fSuccess ? nBytesCopied : 0;
}

// GetPrivateProfileLong - retrieve long from specified section of specified file
//		<lpszSection>		(i) section name within ini file
//		<lpszEntry>			(i) entry name within section
//		<lDefault>			(i) return value if entry not found
//		<lpszFilename>		(i) name of ini file
// return TRUE if success
//
long DLLEXPORT WINAPI GetPrivateProfileLong(LPCTSTR lpszSection,
	LPCTSTR lpszEntry, long lDefault, LPCTSTR lpszFilename)
{
	long lValue = lDefault;
	TCHAR szValue[33];

	GetPrivateProfileString(lpszSection, lpszEntry,
		TEXT(""), szValue, SIZEOFARRAY(szValue), lpszFilename);

	if (*szValue != '\0')
		lValue = StrAtoL(szValue);

	return lValue;
}

// GetProfileLong - retrieve long from specified section of win.ini
//		<lpszSection>		(i) section name within ini file
//		<lpszEntry>			(i) entry name within section
//		<lDefault>			(i) return value if entry not found
// return TRUE if success
//
long DLLEXPORT WINAPI GetProfileLong(LPCTSTR lpszSection,
	LPCTSTR lpszEntry, long lDefault)
{
	long lValue = lDefault;
	TCHAR szValue[33];

	GetProfileString(lpszSection, lpszEntry,
		TEXT(""), szValue, SIZEOFARRAY(szValue));

	if (*szValue != '\0')
		lValue = StrAtoL(szValue);

	return lValue;
}

// WritePrivateProfileInt - write int to specified section of specified file
//		<lpszSection>		(i) section name within ini file
//		<lpszEntry>			(i) entry name within section
//		<iValue>			(i) integer value to assign to entry
//		<lpszFilename>		(i) name of ini file
// return TRUE if success
//
BOOL DLLEXPORT WINAPI WritePrivateProfileInt(LPCTSTR lpszSection, LPCTSTR lpszEntry, int iValue, LPCTSTR lpszFilename)
{
	TCHAR achValue[17];

	StrItoA(iValue, achValue, 10);

	return WritePrivateProfileString(lpszSection, lpszEntry, achValue, lpszFilename);
}

// WriteProfileInt - write int to specified section of win.ini
//		<lpszSection>		(i) section name within win.ini file
//		<lpszEntry>			(i) entry name within section
//		<iValue>			(i) integer value to assign to entry
// return TRUE if success
//
BOOL DLLEXPORT WINAPI WriteProfileInt(LPCTSTR lpszSection, LPCTSTR lpszEntry, int iValue)
{
	TCHAR achValue[17];

	StrItoA(iValue, achValue, 10);

	return WriteProfileString(lpszSection, lpszEntry, achValue);
}

// WritePrivateProfileLong - write long to specified section of specified file
//		<lpszSection>		(i) section name within ini file
//		<lpszEntry>			(i) entry name within section
//		<iValue>			(i) integer value to assign to entry
//		<lpszFilename>		(i) name of ini file
// return TRUE if success
//
BOOL DLLEXPORT WINAPI WritePrivateProfileLong(LPCTSTR lpszSection, LPCTSTR lpszEntry, long iValue, LPCTSTR lpszFilename)
{
	TCHAR achValue[33];

	StrLtoA(iValue, achValue, 10);

	return WritePrivateProfileString(lpszSection, lpszEntry, achValue, lpszFilename);
}

// WriteProfileLong - write long to specified section of win.ini
//		<lpszSection>		(i) section name within win.ini file
//		<lpszEntry>			(i) entry name within section
//		<iValue>			(i) integer value to assign to entry
// return TRUE if success
//
BOOL DLLEXPORT WINAPI WriteProfileLong(LPCTSTR lpszSection, LPCTSTR lpszEntry, long iValue)
{
	TCHAR achValue[33];

	StrLtoA(iValue, achValue, 10);

	return WriteProfileString(lpszSection, lpszEntry, achValue);
}

// UpdatePrivateProfileSection - update destination section based on source
//		<lpszSection>		(i) section name within ini file
//		<lpszFileNameSrc>	(i) name of source ini file
//		<lpszFileNameDst>	(i) name of destination ini file
// return 0 if success
//
// NOTE: if the source file has UpdateLocal=1 entry in the specified
// section, each entry in the source file is compared to the corresponding
// entry in the destination file.  If no corresponding entry is found,
// it is copied.  If a corresponding entry is found, it is overwritten
// ONLY IF the source file entry name is all uppercase.
//
//		Src					Dst before			Dst after
//
//		[Section]			[Section]			[Section]
//		UpdateLocal=1
//		EntryA=red			none				EntryA=red
//		EntryB=blue			EntryB=white		EntryB=white
//		ENTRYC=blue			EntryC=white		EntryC=blue
//
int DLLEXPORT WINAPI UpdatePrivateProfileSection(LPCTSTR lpszSection, LPCTSTR lpszFileNameSrc, LPCTSTR lpszFileNameDst)
{
	BOOL fSuccess = TRUE;
	BOOL fUpdateLocal = GetPrivateProfileInt(lpszSection,
		TEXT("UpdateLocal"), FALSE, lpszFileNameSrc);
	LPTSTR lpszBuf = NULL;

	if (fUpdateLocal)
	{
		if ((lpszBuf = (LPTSTR) MemAlloc(NULL, 4096 * sizeof(TCHAR), 0)) == NULL)
			fSuccess = FALSE;

		// copy entire source section to buffer
		//
		else if (GetPrivateProfileString(lpszSection, NULL, TEXT(""),
			lpszBuf, 4096, lpszFileNameSrc) <= 0)
			fSuccess = FALSE;

		else
		{
			LPTSTR lpszEntry;
			for (lpszEntry = lpszBuf;
				lpszEntry != NULL && *lpszEntry != '\0';
				lpszEntry = StrNextChr(lpszEntry))
			{
				TCHAR szValueSrc[128];
				TCHAR szValueDst[2];
				BOOL fForceUpdate = TRUE;
				LPTSTR lpsz;

				if (StrICmp(lpszEntry, TEXT("UpdateLocal")) != 0)
				{
					for (lpsz = lpszEntry; *lpsz != '\0'; lpsz = StrNextChr(lpsz))
					{
						if (*lpsz != ChrToUpper(*lpsz))
						{
							fForceUpdate = FALSE;
							break;
						}
					}

					GetPrivateProfileString(lpszSection, lpszEntry, TEXT(""),
						szValueDst, SIZEOFARRAY(szValueDst), lpszFileNameDst);

					if (*szValueDst == '\0' || fForceUpdate)
					{
						GetPrivateProfileString(lpszSection, lpszEntry, TEXT(""),
							szValueSrc, SIZEOFARRAY(szValueSrc), lpszFileNameSrc);

						WritePrivateProfileString(lpszSection, lpszEntry,
							StrCmp(szValueSrc, TEXT("NULL")) == 0 ? (LPTSTR) NULL :
							szValueSrc, lpszFileNameDst);
					}
				}

				lpszEntry = StrChr(lpszEntry, '\0');
			}
		}

		if (lpszBuf != NULL &&
			(lpszBuf = MemFree(NULL, lpszBuf)) != NULL)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

////
//	helper functions
////

// IniGetPtr - verify that ini handle is valid,
//		<hIni>				(i) handle returned from IniOpen
// return corresponding ini pointer (NULL if error)
//
static LPINI IniGetPtr(HINI hIni)
{
	BOOL fSuccess = TRUE;
	LPINI lpIni;

	if ((lpIni = (LPINI) hIni) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadWritePtr(lpIni, sizeof(INI)))
		fSuccess = TraceFALSE(NULL);

#ifdef CHECKTASK
	// make sure current task owns the ini handle
	//
	else if (lpIni->hTask != GetCurrentTask())
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? lpIni : NULL;
}

// IniGetHandle - verify that ini pointer is valid,
//		<lpIni>				(i) pointer to INI struct
// return corresponding ini handle (NULL if error)
//
static HINI IniGetHandle(LPINI lpIni)
{
	BOOL fSuccess = TRUE;
	HINI hIni;

	if ((hIni = (HINI) lpIni) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hIni : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\intl.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	intl.h - interface for internationalization functions in intl.c
////

#ifndef __INTL_H__
#define __INTL_H__

#include "winlocal.h"

#define INTL_VERSION 0x00000106

// intl engine handle
//
DECLARE_HANDLE32(HINTL);

// dwFlag defines for IntlDateGetText
//
#define INTL_NOYEAR				0x00000001

// dwFlag defines for IntlTimeGetText
//
#define INTL_NOSECOND			0x00000020
#define INTL_NOAMPM				0x00000040
#define INTL_NOAMPMSEPARATOR	0x00000080

// dwFlag defines for IntlTimeSpanGetText
//
#define INTL_HOURS_LZ			0x00001000
#define INTL_MINUTES_LZ			0x00002000
#define INTL_SECONDS_LZ			0x00004000

// values returned in iDate field of INTLDATE struct
//
#define IDATE_MDY	0
#define IDATE_DMY	1
#define IDATE_YMD	2

// values returned in iTime field of INTLTIME struct
//
#define ITIME_12	0
#define ITIME_24	1

// structure passed to IntlDateGetFormat
//
typedef struct INTLDATEFORMAT
{
	TCHAR szShortDate[32];
	TCHAR szDateSep[32];
	int iDate;
	BOOL fYearCentury;
	BOOL fMonthLeadingZero;
	BOOL fDayLeadingZero;
	DWORD dwReserved;
} INTLDATEFORMAT, FAR *LPINTLDATEFORMAT;

// structure passed to IntlTimeGetFormat
//
typedef struct INTLTIMEFORMAT
{
	TCHAR szTimeSep[32];
	TCHAR szAMPMSep[32];
	TCHAR szAM[32];
	TCHAR szPM[32];
	int iTime;
	BOOL fHourLeadingZero;
	BOOL fMinuteLeadingZero;
	BOOL fSecondLeadingZero;
	DWORD dwReserved;
} INTLTIMEFORMAT, FAR *LPINTLTIMEFORMAT;

#ifdef __cplusplus
extern "C" {
#endif

// IntlInit - initialize intl engine
//		<dwVersion>			(i) must be INTL_VERSION
// 		<hInst>				(i) instance handle of calling module
// return handle (NULL if error)
//
HINTL DLLEXPORT WINAPI IntlInit(DWORD dwVersion, HINSTANCE hInst);

// IntlTerm - shut down intl engine
//		<hIntl>				(i) handle returned from IntlInit
// return 0 if success
//
int DLLEXPORT WINAPI IntlTerm(HINTL hIntl);

// IntlDateGetText - construct date text based on <y>, <m>, <d>
//		<hIntl>				(i) handle returned from IntlInit
//		<y>					(i) year
//		<m>					(i) month
//		<d>					(i) day
//		<lpszText>			(o) buffer to copy date text
//		<sizText>			(i) size of buffer
//		<dwFlags>			(i) option flags
//			INTL_NOYEAR			do not include year in text output
// return 0 if success
//
int DLLEXPORT WINAPI IntlDateGetText(HINTL hIntl, int y, int m, int d, LPTSTR lpszText, size_t sizText, DWORD dwFlags);

// IntlTimeGetText - construct time text based on <h>, <m>, <s>
//		<hIntl>				(i) handle returned from IntlInit
//		<h>					(i) hour
//		<m>					(i) minute
//		<s>					(i) second
//		<lpszText>			(o) buffer to copy time text
//		<sizText>			(i) size of buffer
//		<dwFlags>			(i) option flags
//			INTL_NOSECOND		do not include second in text output
//			INTL_NOAMPM			do not include am or pm in text output
//			INTL_NOAMPMSEPARATOR	do not include space between time and am/pm
// return 0 if success
//
int DLLEXPORT WINAPI IntlTimeGetText(HINTL hIntl, int h, int m, int s, LPTSTR lpszText, size_t sizText, DWORD dwFlags);

// IntlTimeSpanGetText - construct time span text based on <ms>
//		<hIntl>				(i) handle returned from IntlInit
//		<ms>				(i) milleseconds
//		<nDecimalPlaces>	(i) 0, 1, 2, or 3 decimal places for fraction
//		<lpszText>			(o) buffer to copy time span text
//		<sizText>			(i) size of buffer
//		<dwFlags>			(i) option flags
//			INTL_HOURS_LZ		include hours, even if zero
//			INTL_MINUTES_LZ		include minutes, even if zero
//			INTL_SECONDS_LZ		include seconds, even if zero
//
// NOTE: below are some examples
//
//		dwFlags				ms=7299650		ms=1234			ms=0
//		--------------------------------------------------------
//			0				"2:01:39.650"	"1.234"			"0"
//		INTL_HOURS_LZ		"2:01:39.650"	"0:00:01.234"	"0:00:00.000"
//		INTL_MINUTES_LZ		"2:01:39.650"	"0:01.234"		"0:00.000"
//		INTL_SECONDS_LZ		"2:01:39.650"	"1.234"			"0.000"
//
//		dwFlags				ms=7299650		ms=1234			ms=0
//		--------------------------------------------------------
//			3				"2:01:39.650"	"1.234"			".000"
//			2				"2:01:39.65"	"1.23"			".00"
//			1				"2:01:39.7"		"1.2"			".0"
//			0				"2:01:39"		"1"				"0"
//
// return 0 if success
//
int DLLEXPORT WINAPI IntlTimeSpanGetText(HINTL hIntl, DWORD ms,
	int nDecimalPlaces, LPTSTR lpszText, size_t sizText, DWORD dwFlags);

// IntlDateGetFormat - return current date format structure
//		<hIntl>				(i) handle returned from IntlInit
//		<lpIntlDateFormat>	(o) copy date format structure here
// return 0 if success
//
int DLLEXPORT WINAPI IntlDateGetFormat(HINTL hIntl, LPINTLDATEFORMAT lpIntlDateFormat);

// IntlTimeGetFormat - return current time format structure
//		<hIntl>				(i) handle returned from IntlInit
//		<lpIntlTimeFormat>	(o) copy time format structure here
// return 0 if success
//
int DLLEXPORT WINAPI IntlTimeGetFormat(HINTL hIntl, LPINTLTIMEFORMAT lpIntlTimeFormat);

#ifdef __cplusplus
}
#endif

#endif // __INTL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\intl.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	intl.c - internationalization functions
////

#include "winlocal.h"

#include <stdlib.h>

#include "intl.h"
#include "mem.h"
#include "str.h"
#include "trace.h"

////
//	private definitions
////

// intl control struct
//
typedef struct INTL
{
	DWORD dwVersion;
	HINSTANCE hInst;
	HTASK hTask;
	TCHAR szShortDate[32];
	TCHAR szDateSep[32];
	TCHAR szTimeSep[32];
	TCHAR szAMPMSep[32];
	TCHAR szAM[32];
	TCHAR szPM[32];
	int iDate;
	int iTime;
	int iTLZero;
	BOOL fYearCentury;
	BOOL fMonthLeadingZero;
	BOOL fDayLeadingZero;
	BOOL fHourLeadingZero;
	BOOL fMinuteLeadingZero;
	BOOL fSecondLeadingZero;
	int iLZero;
	TCHAR szDecimal[32];
} INTL, FAR *LPINTL;

// helper functions
//
static LPINTL IntlGetPtr(HINTL hIntl);
static HINTL IntlGetHandle(LPINTL lpIntl);

////
//	public functions
////

// IntlInit - initialize intl engine
//		<dwVersion>			(i) must be INTL_VERSION
// 		<hInst>				(i) instance handle of calling module
// return handle (NULL if error)
//
HINTL DLLEXPORT WINAPI IntlInit(DWORD dwVersion, HINSTANCE hInst)
{
	BOOL fSuccess = TRUE;
	LPINTL lpIntl = NULL;

	if (dwVersion != INTL_VERSION)
		fSuccess = TraceFALSE(NULL);

	else if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpIntl = (LPINTL) MemAlloc(NULL, sizeof(INTL), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lpIntl->dwVersion = dwVersion;
		lpIntl->hInst = hInst;
		lpIntl->hTask = GetCurrentTask();

		GetProfileString(TEXT("intl"), TEXT("sShortDate"), TEXT("M/d/yy"), lpIntl->szShortDate, SIZEOFARRAY(lpIntl->szShortDate));
		GetProfileString(TEXT("intl"), TEXT("sDate"), TEXT("/"), lpIntl->szDateSep, SIZEOFARRAY(lpIntl->szDateSep));
		GetProfileString(TEXT("intl"), TEXT("sTime"), TEXT(":"), lpIntl->szTimeSep, SIZEOFARRAY(lpIntl->szTimeSep));
		StrCpy(lpIntl->szAMPMSep, TEXT(" "));
		GetProfileString(TEXT("intl"), TEXT("s1159"), TEXT("AM"), lpIntl->szAM, SIZEOFARRAY(lpIntl->szAM));
		GetProfileString(TEXT("intl"), TEXT("s2359"), TEXT("PM"), lpIntl->szPM, SIZEOFARRAY(lpIntl->szPM));

		lpIntl->iDate = GetProfileInt(TEXT("intl"), TEXT("iDate"), 0);
		lpIntl->iTime = GetProfileInt(TEXT("intl"), TEXT("iTime"), 0);
		lpIntl->iTLZero = GetProfileInt(TEXT("intl"), TEXT("iTLZero"), 0);

		lpIntl->fYearCentury = (BOOL) (StrStr(lpIntl->szShortDate, TEXT("yyyy")) != NULL);
		lpIntl->fMonthLeadingZero = (BOOL) (StrStr(lpIntl->szShortDate, TEXT("MM")) != NULL);
		lpIntl->fDayLeadingZero = (BOOL) (StrStr(lpIntl->szShortDate, TEXT("dd")) != NULL);
		lpIntl->fHourLeadingZero = (BOOL) (lpIntl->iTLZero != 0);
		lpIntl->fMinuteLeadingZero = TRUE;
		lpIntl->fSecondLeadingZero = TRUE;

		lpIntl->iLZero = GetProfileInt(TEXT("intl"), TEXT("iLZero"), 0);
		GetProfileString(TEXT("intl"), TEXT("sDecimal"), TEXT("."), lpIntl->szDecimal, SIZEOFARRAY(lpIntl->szDecimal));
	}

	if (!fSuccess)
	{
		IntlTerm(IntlGetHandle(lpIntl));
		lpIntl = NULL;
	}

	return fSuccess ? IntlGetHandle(lpIntl) : NULL;
}

// IntlTerm - shut down intl engine
//		<hIntl>				(i) handle returned from IntlInit
// return 0 if success
//
int DLLEXPORT WINAPI IntlTerm(HINTL hIntl)
{
	BOOL fSuccess = TRUE;
	LPINTL lpIntl;

	if ((lpIntl = IntlGetPtr(hIntl)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpIntl = MemFree(NULL, lpIntl)) != NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}

// IntlDateGetText - construct date text based on <y>, <m>, <d>
//		<hIntl>				(i) handle returned from IntlInit
//		<y>					(i) year
//		<m>					(i) month
//		<d>					(i) day
//		<lpszText>			(o) buffer to copy date text
//		<sizText>			(i) size of buffer
//		<dwFlags>			(i) option flags
//			INTL_NOYEAR			do not include year in text output
// return 0 if success
//
int DLLEXPORT WINAPI IntlDateGetText(HINTL hIntl, int y, int m, int d, LPTSTR lpszText, size_t sizText, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPINTL lpIntl;

	if ((lpIntl = IntlGetPtr(hIntl)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpszText != NULL)
	{
		TCHAR szYear[16];
		TCHAR szMonth[16];
		TCHAR szDay[16];
		TCHAR szText[64];

		*szYear = '\0';
		if (!lpIntl->fYearCentury)
			y %= 100;
		if (y < 10)
			StrCat(szYear, TEXT("0"));
		StrItoA(y, StrChr(szYear, '\0'), 10);

		*szMonth = '\0';
		if (lpIntl->fMonthLeadingZero && m < 10)
			StrCat(szMonth, TEXT("0"));
		StrItoA(m, StrChr(szMonth, '\0'), 10);

		*szDay = '\0';
		if (lpIntl->fDayLeadingZero && d < 10)
			StrCat(szDay, TEXT("0"));
		StrItoA(d, StrChr(szDay, '\0'), 10);

		*szText = '\0';

		if (lpIntl->iDate == IDATE_MDY)
		{
			StrCat(szText, szMonth);
			StrCat(szText, lpIntl->szDateSep);
			StrCat(szText, szDay);
			if (!(dwFlags & INTL_NOYEAR))
			{
				StrCat(szText, lpIntl->szDateSep);
				StrCat(szText, szYear);
			}
		}
		else if (lpIntl->iDate == IDATE_DMY)
		{
			StrCat(szText, szDay);
			StrCat(szText, lpIntl->szDateSep);
			StrCat(szText, szMonth);
			if (!(dwFlags & INTL_NOYEAR))
			{
				StrCat(szText, lpIntl->szDateSep);
				StrCat(szText, szYear);
			}
		}
		else if (lpIntl->iDate == IDATE_YMD)
		{
			if (!(dwFlags & INTL_NOYEAR))
			{
				StrCat(szText, szYear);
				StrCat(szText, lpIntl->szDateSep);
			}
			StrCat(szText, szMonth);
			StrCat(szText, lpIntl->szDateSep);
			StrCat(szText, szDay);
		}

		StrNCpy(lpszText, szText, sizText);
	}

	return fSuccess ? 0 : -1;
}

// IntlTimeGetText - construct time text based on <h>, <m>, <s>
//		<hIntl>				(i) handle returned from IntlInit
//		<h>					(i) hour
//		<m>					(i) minute
//		<s>					(i) second
//		<lpszText>			(o) buffer to copy time text
//		<sizText>			(i) size of buffer
//		<dwFlags>			(i) option flags
//			INTL_NOSECOND		do not include second in text output
//			INTL_NOAMPM			do not include am or pm in text output
//			INTL_NOAMPMSEPARATOR	do not include space between time and am/pm
// return 0 if success
//
int DLLEXPORT WINAPI IntlTimeGetText(HINTL hIntl, int h, int m, int s, LPTSTR lpszText, size_t sizText, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPINTL lpIntl;

	if ((lpIntl = IntlGetPtr(hIntl)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpszText != NULL)
	{
		TCHAR szHour[16];
		TCHAR szMinute[16];
		TCHAR szSecond[16];
		BOOL fPM = FALSE;
		TCHAR szText[64];

		*szHour = '\0';
		if (lpIntl->iTime == ITIME_12)
		{
			if (h > 11)
				fPM = TRUE;
			if (h > 12)
				h -= 12;
			if (h == 0)
				h = 12;
		}
		if (lpIntl->fHourLeadingZero && h < 10)
			StrCat(szHour, TEXT("0"));
		StrItoA(h, StrChr(szHour, '\0'), 10);

		*szMinute = '\0';
		if (lpIntl->fMinuteLeadingZero && m < 10)
			StrCat(szMinute, TEXT("0"));
		StrItoA(m, StrChr(szMinute, '\0'), 10);

		*szSecond = '\0';
		if (lpIntl->fSecondLeadingZero && s < 10)
			StrCat(szSecond, TEXT("0"));
		StrItoA(s, StrChr(szSecond, '\0'), 10);

		*szText = '\0';

		StrCat(szText, szHour);
		StrCat(szText, lpIntl->szTimeSep);
		StrCat(szText, szMinute);

		if (!(dwFlags & INTL_NOSECOND))
		{
			StrCat(szText, lpIntl->szTimeSep);
			StrCat(szText, szSecond);
		}

		if (!(dwFlags & INTL_NOAMPM))
		{
			if (!(dwFlags & INTL_NOAMPMSEPARATOR))
				StrCat(szText, lpIntl->szAMPMSep);
			StrCat(szText, fPM ? lpIntl->szPM : lpIntl->szAM);
		}

		StrNCpy(lpszText, szText, sizText);
	}

	return fSuccess ? 0 : -1;
}

// IntlTimeSpanGetText - construct time span text based on <ms>
//		<hIntl>				(i) handle returned from IntlInit
//		<ms>				(i) milleseconds
//		<nDecimalPlaces>	(i) 0, 1, 2, or 3 decimal places for fraction
//		<lpszText>			(o) buffer to copy time span text
//		<sizText>			(i) size of buffer
//		<dwFlags>			(i) option flags
//			INTL_HOURS_LZ		include hours, even if zero
//			INTL_MINUTES_LZ		include minutes, even if zero
//			INTL_SECONDS_LZ		include seconds, even if zero
//
// NOTE: below are some examples
//
//		dwFlags				ms=7299650		ms=1234			ms=0
//		--------------------------------------------------------
//			0				"2:01:39.650"	"1.234"			"0"
//		INTL_HOURS_LZ		"2:01:39.650"	"0:00:01.234"	"0:00:00.000"
//		INTL_MINUTES_LZ		"2:01:39.650"	"0:01.234"		"0:00.000"
//		INTL_SECONDS_LZ		"2:01:39.650"	"1.234"			"0.000"
//
//		dwFlags				ms=7299650		ms=1234			ms=0
//		--------------------------------------------------------
//			3				"2:01:39.650"	"1.234"			".000"
//			2				"2:01:39.65"	"1.23"			".00"
//			1				"2:01:39.7"		"1.2"			".0"
//			0				"2:01:39"		"1"				"0"
//
// return 0 if success
//
int DLLEXPORT WINAPI IntlTimeSpanGetText(HINTL hIntl, DWORD ms,
	int nDecimalPlaces, LPTSTR lpszText, size_t sizText, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPINTL lpIntl;

	if ((lpIntl = IntlGetPtr(hIntl)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpszText != NULL)
	{
		long h;
		long m;
		long s;
		long f;
		TCHAR szText[64];

		// break ms into h, m, s, f
		// NOTE: rounding must occur before we break ms
		//
		if (nDecimalPlaces == 1)
			f = (long) ms + 50;
		else if (nDecimalPlaces == 2)
			f = (long) ms + 5;
		else
			f = (long) ms;

		s = f / 1000;
		f = f % 1000;
		m = s / 60;
		s = s % 60;
		h = m / 60;
		m = m % 60;

		// construct text
		//
		*szText = '\0';

		if (h > 0 || (dwFlags & INTL_HOURS_LZ))
		{
			if (lpIntl->fHourLeadingZero && h < 10)
				StrCat(szText, TEXT("0"));
			StrLtoA(h, StrChr(szText, '\0'), 10);
		}

		if (*szText != '\0' || m > 0 || (dwFlags & INTL_MINUTES_LZ))
		{
			if (*szText != '\0')
			{
				StrCat(szText, lpIntl->szTimeSep);
				if (lpIntl->fMinuteLeadingZero && m < 10)
					StrCat(szText, TEXT("0"));
			}
			StrLtoA(m, StrChr(szText, '\0'), 10);
		}

		if (*szText != '\0' || s > 0 || (dwFlags & INTL_SECONDS_LZ) ||
			(ms == 0 && nDecimalPlaces == 0))
		{
			if (*szText != '\0')
			{
				StrCat(szText, lpIntl->szTimeSep);
				if (lpIntl->fSecondLeadingZero && s < 10)
					StrCat(szText, TEXT("0"));
			}
			StrLtoA(s, StrChr(szText, '\0'), 10);
		}

		switch (nDecimalPlaces)
		{
			case 3:
				if (*szText != '\0' || ms < 1000)
				{
					StrCat(szText, lpIntl->szDecimal);
					if (f < 100)
						StrCat(szText, TEXT("0"));
					if (f < 10)
						StrCat(szText, TEXT("0"));
				}
				StrLtoA(f, StrChr(szText, '\0'), 10);
				break;

			case 2:
				f = f / 10;
				if (*szText != '\0' || ms < 1000)
				{
					StrCat(szText, lpIntl->szDecimal);
					if (f < 10)
						StrCat(szText, TEXT("0"));
				}
				StrLtoA(f, StrChr(szText, '\0'), 10);
				break;

			case 1:
				f = f / 100;
				if (*szText != '\0' || ms < 1000)
					StrCat(szText, lpIntl->szDecimal);
				StrLtoA(f, StrChr(szText, '\0'), 10);
				break;

			default:
				break;
		}

		StrNCpy(lpszText, szText, sizText);
	}

	return fSuccess ? 0 : -1;
}

// IntlDateGetFormat - return current date format structure
//		<hIntl>				(i) handle returned from IntlInit
//		<lpIntlDateFormat>	(o) copy date format structure here
// return 0 if success
//
int DLLEXPORT WINAPI IntlDateGetFormat(HINTL hIntl, LPINTLDATEFORMAT lpIntlDateFormat)
{
	BOOL fSuccess = TRUE;
	LPINTL lpIntl;

	if ((lpIntl = IntlGetPtr(hIntl)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpIntlDateFormat != NULL)
	{
		MemSet(lpIntlDateFormat, 0,
			sizeof(INTLDATEFORMAT));
		MemCpy(lpIntlDateFormat->szShortDate, lpIntl->szShortDate,
			sizeof(lpIntl->szShortDate));
		MemCpy(lpIntlDateFormat->szDateSep, lpIntl->szDateSep,
			sizeof(lpIntl->szDateSep));
		lpIntlDateFormat->iDate = lpIntl->iDate;
		lpIntlDateFormat->fYearCentury = lpIntl->fYearCentury;
		lpIntlDateFormat->fMonthLeadingZero = lpIntl->fMonthLeadingZero;
		lpIntlDateFormat->fDayLeadingZero = lpIntl->fDayLeadingZero;
	}

	return fSuccess ? 0 : -1;
}

// IntlTimeGetFormat - return current time format structure
//		<hIntl>				(i) handle returned from IntlInit
//		<lpIntlTimeFormat>	(o) copy time format structure here
// return 0 if success
//
int DLLEXPORT WINAPI IntlTimeGetFormat(HINTL hIntl, LPINTLTIMEFORMAT lpIntlTimeFormat)
{
	BOOL fSuccess = TRUE;
	LPINTL lpIntl;

	if ((lpIntl = IntlGetPtr(hIntl)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpIntlTimeFormat != NULL)
	{
		MemSet(lpIntlTimeFormat, 0,
			sizeof(INTLDATEFORMAT));
		MemCpy(lpIntlTimeFormat->szTimeSep, lpIntl->szTimeSep,
			sizeof(lpIntl->szTimeSep));
		MemCpy(lpIntlTimeFormat->szAMPMSep, lpIntl->szAMPMSep,
			sizeof(lpIntl->szAMPMSep));
		MemCpy(lpIntlTimeFormat->szAM, lpIntl->szAM,
			sizeof(lpIntl->szAM));
		MemCpy(lpIntlTimeFormat->szPM, lpIntl->szPM,
			sizeof(lpIntl->szPM));
		lpIntlTimeFormat->iTime = lpIntl->iTime;
		lpIntlTimeFormat->fHourLeadingZero = lpIntl->fHourLeadingZero;
		lpIntlTimeFormat->fMinuteLeadingZero = lpIntl->fMinuteLeadingZero;
		lpIntlTimeFormat->fSecondLeadingZero = lpIntl->fSecondLeadingZero;
	}

	return fSuccess ? 0 : -1;
}

////
//	helper functions
////

// IntlGetPtr - verify that intl handle is valid,
//		<hIntl>				(i) handle returned from IntlInit
// return corresponding intl pointer (NULL if error)
//
static LPINTL IntlGetPtr(HINTL hIntl)
{
	BOOL fSuccess = TRUE;
	LPINTL lpIntl;

	if ((lpIntl = (LPINTL) hIntl) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadWritePtr(lpIntl, sizeof(INTL)))
		fSuccess = TraceFALSE(NULL);

#ifdef CHECKTASK
	// make sure current task owns the intl handle
	//
	else if (lpIntl->hTask != GetCurrentTask())
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? lpIntl : NULL;
}

// IntlGetHandle - verify that intl pointer is valid,
//		<lpIntl>			(i) pointer to INTL struct
// return corresponding intl handle (NULL if error)
//
static HINTL IntlGetHandle(LPINTL lpIntl)
{
	BOOL fSuccess = TRUE;
	HINTL hIntl;

	if ((hIntl = (HINTL) lpIntl) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hIntl : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\icobutt.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// icobutt.h - interface for icon button functions in icobutt.c
////

#ifndef __ICOBUTT_H__
#define __ICOBUTT_H__

#include "winlocal.h"

#define ICOBUTT_VERSION 0x00000106

// handle to icon button control
//
DECLARE_HANDLE32(HICOBUTT);

#define ICOBUTT_ICONCENTER	0x00000000
#define ICOBUTT_ICONLEFT	0x00000001
#define ICOBUTT_ICONRIGHT	0x00000002
#define ICOBUTT_NOFOCUS		0x00000004
#define ICOBUTT_NOTEXT		0x00000008
#define ICOBUTT_SPLITTEXT	0x00000010
#define ICOBUTT_NOSIZE		0x00000020
#define ICOBUTT_NOMOVE		0x00000040

#ifdef __cplusplus
extern "C" {
#endif

// IcoButtInit - initialize icon button
//		<hwndButton>		(i) button window handle
//			NULL				create new button
//		<dwVersion>			(i) must be ICOBUTT_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<id>				(i) id of button
//		<hIconMono>			(i) icon to display on mono displays
//		<hIconColor>		(i) icon to display on color displays
//			0					use mono icon
//		<hIconGreyed>		(i) icon to display when button disabled
//			0					use mono icon
//		<hFont>				(i) font to use for text
//			NULL				use variable-pitch system font (ANSI_VAR_FONT)
//		<lpszText>			(i) button text string
//		<x>					(i) button horizontal position
//		<y>					(i) button vertical position
//		<cx>				(i) button width
//		<cy>				(i) button height
//		<hwndParent>		(i) button parent
//		<dwFlags>			(i) control flags
//			ICOBUTT_ICONCENTER  draw icon centered above text (default)
//			ICOBUTT_ICONLEFT	draw icon on the left side of text
//			ICOBUTT_ICONRIGHT	draw icon on the right side of text
//			ICOBUTT_NOFOCUS		do not draw control showing focus
//			ICOBUTT_NOTEXT		do not draw any button text
//			ICOBUTT_SPLITTEXT	split long text onto two rows if necessary
//			ICOBUTT_NOSIZE		ignore <cx> and <cy> param
//			ICOBUTT_NOMOVE		ignore <x> and <y> param
// return handle (NULL if error)
//
// NOTE: if <hwndButton> is set to an existing button,
// a new button is not created.  Rather, only the icon button
// control structure <hIcoButt> is created.  This allows
// existing buttons to be turned into an icon button.
//
HICOBUTT DLLEXPORT WINAPI IcoButtInit(HWND hwndButton,
	DWORD dwVersion, HINSTANCE hInst, UINT id,
	HICON hIconMono, HICON hIconColor, HICON hIconGreyed,
	HFONT hFont, LPTSTR lpszText, int x, int y, int cx, int cy,
	HWND hwndParent, DWORD dwFlags);

// IcoButtTerm - terminate icon button
//		<hwndButton>		(i) button window handle
//			NULL				destroy window
//		<hIcoButt>			(i) handle returned from IcoButtCreate
// return 0 if success
//
// NOTE: if <hwndButton> is set to an existing button,
// the button is not destroyed.  Rather, only the icon button
// control structure <hIcoButt> is destroyed.  This allows
// IcoButtInit() to be called again for the same button.
//
int DLLEXPORT WINAPI IcoButtTerm(HWND hwndButton, HICOBUTT hIcoButt);

// IcoButtDraw - draw icon button
//		<lpDrawItem>		(i) structure describing how to draw control
// return 0 if success
//
int DLLEXPORT WINAPI IcoButtDraw(const LPDRAWITEMSTRUCT lpDrawItem);

#ifdef __cplusplus
}
#endif

#endif // __ICOBUTT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\icobutt.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	icobutt.c - icon button functions
////

#include "winlocal.h"

#include "icobutt.h"
#include "gfx.h"
#include "mem.h"
#include "str.h"
#include "sys.h"
#include "trace.h"

////
//	private definitions
////

// dimensions of standard Windows icon
//
#define ICONWIDTH	32
#define ICONHEIGHT	32

// icobutt control struct
//
typedef struct ICOBUTT
{
	DWORD dwVersion;
	HINSTANCE hInst;
	HTASK hTask;
	DWORD dwFlags;
	HICON hIconMono;
	HICON hIconColor;
	HICON hIconGreyed;
	HFONT hFont;
	HWND hwndButton;
} ICOBUTT, FAR *LPICOBUTT;

// helper functions
//
static int IcoButtDrawFace(LPICOBUTT lpIcoButt, const LPDRAWITEMSTRUCT lpDrawItem);
static int IcoButtDrawEdges(LPICOBUTT lpIcoButt, const LPDRAWITEMSTRUCT lpDrawItem);
static int IcoButtDrawIcon(LPICOBUTT lpIcoButt, const LPDRAWITEMSTRUCT lpDrawItem);
static int IcoButtDrawText(LPICOBUTT lpIcoButt, const LPDRAWITEMSTRUCT lpDrawItem);
static int IcoButtDrawLine(LPICOBUTT lpIcoButt, const LPDRAWITEMSTRUCT lpDrawItem,
	LPTSTR lpszLine, int nLine);
static LPICOBUTT IcoButtGetPropPtr(HWND hwndButton);
static int IcoButtSetPropPtr(HWND hwndButton, LPICOBUTT lpIcoButt);
static LPICOBUTT IcoButtRemovePropPtr(HWND hwndButton);
static LPICOBUTT IcoButtGetPtr(HICOBUTT hIcoButt);
static HICOBUTT IcoButtGetHandle(LPICOBUTT lpIcoButt);

////
//	public functions
////

// IcoButtInit - initialize icon button
//		<hwndButton>		(i) button window handle
//			NULL				create new button
//		<dwVersion>			(i) must be ICOBUTT_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<id>				(i) id of button
//		<hIconMono>			(i) icon to display on mono displays
//		<hIconColor>		(i) icon to display on color displays
//			0					use mono icon
//		<hIconGreyed>		(i) icon to display when button disabled
//			0					use mono icon
//		<hFont>				(i) font to use for text
//			NULL				use variable-pitch system font (ANSI_VAR_FONT)
//		<lpszText>			(i) button text string
//		<x>					(i) button horizontal position
//		<y>					(i) button vertical position
//		<cx>				(i) button width
//		<cy>				(i) button height
//		<hwndParent>		(i) button parent
//		<dwFlags>			(i) control flags
//			ICOBUTT_ICONCENTER  draw icon centered above text (default)
//			ICOBUTT_ICONLEFT	draw icon on the left side of text
//			ICOBUTT_ICONRIGHT	draw icon on the right side of text
//			ICOBUTT_NOFOCUS		do not draw control showing focus
//			ICOBUTT_NOTEXT		do not draw any button text
//			ICOBUTT_SPLITTEXT	split long text onto two rows if necessary
//			ICOBUTT_NOSIZE		ignore <cx> and <cy> param
//			ICOBUTT_NOMOVE		ignore <x> and <y> param
// return handle (NULL if error)
//
// NOTE: if <hwndButton> is set to an existing button,
// a new button is not created.  Rather, only the icon button
// control structure <hIcoButt> is created.  This allows
// existing buttons to be turned into an icon button.
//
HICOBUTT DLLEXPORT WINAPI IcoButtInit(HWND hwndButton,
	DWORD dwVersion, HINSTANCE hInst, UINT id,
	HICON hIconMono, HICON hIconColor, HICON hIconGreyed,
	HFONT hFont, LPTSTR lpszText, int x, int y, int cx, int cy,
	HWND hwndParent, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPICOBUTT lpIcoButt = NULL;
	DWORD dwStyle;

	if (hwndButton != NULL &&
		(lpIcoButt = IcoButtGetPropPtr(hwndButton)) != NULL)
	{
		// IcoButtInit() has already been used to initialize this button
		// so we need to call IcoButtTerm before continuing
		//
		if (IcoButtTerm(hwndButton, IcoButtGetHandle(lpIcoButt)) != 0)
			fSuccess = TraceFALSE(NULL);
		else
			lpIcoButt = NULL;
	}

	if (!fSuccess)
		;

	else if (dwVersion != ICOBUTT_VERSION)
		fSuccess = TraceFALSE(NULL);
	
	else if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);

	// at least this icon must be specified
	//
	else if (hIconMono == NULL)
		fSuccess = TraceFALSE(NULL);

	// memory is allocated such that the client app owns it
	//
	else if (lpIcoButt == NULL &&
		(lpIcoButt = (LPICOBUTT) MemAlloc(NULL, sizeof(ICOBUTT), 0)) == NULL)
	{
		fSuccess = TraceFALSE(NULL);
	}

	else
	{
		lpIcoButt->hwndButton = hwndButton;
		lpIcoButt->dwVersion = dwVersion;
		lpIcoButt->hInst = hInst;
		lpIcoButt->hTask = GetCurrentTask();
		lpIcoButt->dwFlags = dwFlags;
		lpIcoButt->hFont =
			(hFont == NULL ? GetStockObject(ANSI_VAR_FONT) : hFont);
		lpIcoButt->hIconMono = hIconMono;
		lpIcoButt->hIconColor = hIconColor;
		lpIcoButt->hIconGreyed = hIconGreyed;
	}

	// if icon button does not yet exist...
	//
	if (fSuccess && hwndButton == NULL)
	{
		// create an icon button window
		//
		if ((lpIcoButt->hwndButton = CreateWindowEx(
			0L,
			TEXT("Button"),
			lpszText,
			BS_OWNERDRAW | WS_POPUP,
			x, y, cx, cy,
			hwndParent,
			(HMENU)IntToPtr(id),
			lpIcoButt->hInst,
			NULL)) == NULL)
		{
			fSuccess = TraceFALSE(NULL);
		}

		// store icobutt pointer as window property
		//
		else if (IcoButtSetPropPtr(lpIcoButt->hwndButton, lpIcoButt) != 0)
			fSuccess = TraceFALSE(NULL);

		// show the window AFTER setting window property because
		// lpIcoButt is needed by IconButtDraw() to draw the button
		//
		else
			ShowWindow(lpIcoButt->hwndButton, SW_SHOW);
	}

	// else if icon button already exists...
	//
	else if (fSuccess && hwndButton != NULL)
	{
		// make sure the button style is owner drawn
		//
		if ((dwStyle = (DWORD)
			GetWindowLongPtr(lpIcoButt->hwndButton, GWL_STYLE)) == 0L)
			fSuccess = TraceFALSE(NULL);

		else if (SetWindowLongPtr(lpIcoButt->hwndButton,
			GWL_STYLE, BS_OWNERDRAW | dwStyle) == 0L)
			fSuccess = TraceFALSE(NULL);

		// set window id
		//
#ifdef _WIN32
		else if (SetWindowLongPtr(lpIcoButt->hwndButton, GWLP_ID, id) == 0)
#else
		else if (SetWindowWordPtr(lpIcoButt->hwndButton, GWWP_ID, id) == 0)
#endif
			fSuccess = TraceFALSE(NULL);

		// set window size
		//
		else if (!(dwFlags & ICOBUTT_NOSIZE) &&
			!SetWindowPos(lpIcoButt->hwndButton, NULL, 0, 0, cx, cy,
			SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOREDRAW | SWP_NOZORDER))
			fSuccess = TraceFALSE(NULL);

		// set window position
		//
		else if (!(dwFlags & ICOBUTT_NOMOVE) &&
			!SetWindowPos(lpIcoButt->hwndButton, NULL, x, y, 0, 0,
			SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOREDRAW | SWP_NOZORDER))
			fSuccess = TraceFALSE(NULL);

		// store icobutt pointer as window property
		//
		else if (IcoButtSetPropPtr(lpIcoButt->hwndButton, lpIcoButt) != 0)
			fSuccess = TraceFALSE(NULL);

		else
		{
			// set window parent
			//
			SetParent(lpIcoButt->hwndButton, hwndParent);

			// set window text AFTER setting window property because
			// lpIcoButt is needed by IconButtDraw() to draw the button
			//
			SetWindowText(lpIcoButt->hwndButton, lpszText);
		}
	}

	if (!fSuccess)
	{
		IcoButtTerm(hwndButton, IcoButtGetHandle(lpIcoButt));
		lpIcoButt = NULL;
	}

	return fSuccess ? IcoButtGetHandle(lpIcoButt) : NULL;
}

// IcoButtTerm - terminate icon button
//		<hwndButton>		(i) button window handle
//			NULL				destroy window
//		<hIcoButt>			(i) handle returned from IcoButtCreate
// return 0 if success
//
// NOTE: if <hwndButton> is set to an existing button,
// the button is not destroyed.  Rather, only the icon button
// control structure <hIcoButt> is destroyed.  This allows
// IcoButtInit() to be called again for the same button.
//
int DLLEXPORT WINAPI IcoButtTerm(HWND hwndButton, HICOBUTT hIcoButt)
{
	BOOL fSuccess = TRUE;
	LPICOBUTT lpIcoButt;

	if ((lpIcoButt = IcoButtGetPtr(hIcoButt)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		if (IcoButtRemovePropPtr(lpIcoButt->hwndButton) == NULL)
			fSuccess = TraceFALSE(NULL);

		if (hwndButton == NULL &&
			lpIcoButt->hwndButton != NULL &&
			!DestroyWindow(lpIcoButt->hwndButton))
			fSuccess = TraceFALSE(NULL);
		else
			lpIcoButt->hwndButton = NULL;

		if ((lpIcoButt = MemFree(NULL, lpIcoButt)) != NULL)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// IcoButtDraw - draw icon button
//		<lpDrawItem>		(i) structure describing how to draw control
// return 0 if success
//
int DLLEXPORT WINAPI IcoButtDraw(const LPDRAWITEMSTRUCT lpDrawItem)
{
	BOOL fSuccess = TRUE;
	LPICOBUTT lpIcoButt;

	// retrieve icobutt pointer from button handle
	//
	if ((lpIcoButt = IcoButtGetPropPtr(lpDrawItem->hwndItem)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// draw the button face
	//
	else if (IcoButtDrawFace(lpIcoButt, lpDrawItem) != 0)
		fSuccess = TraceFALSE(NULL);

	// draw the button edges
	//
	else if (IcoButtDrawEdges(lpIcoButt, lpDrawItem) != 0)
		fSuccess = TraceFALSE(NULL);

	// draw the button icon
	//
	else if (IcoButtDrawIcon(lpIcoButt, lpDrawItem) != 0)
		fSuccess = TraceFALSE(NULL);

	// draw the button text
	//
	else if (IcoButtDrawText(lpIcoButt, lpDrawItem) != 0)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}

// IcoButtDrawFace - draw the button face
//		<lpIcoButt>			(i) pointer to ICOBUTT structure
//		<lpDrawItem>		(i) structure describing how to draw control
// return 0 if success
//
static int IcoButtDrawFace(LPICOBUTT lpIcoButt, const LPDRAWITEMSTRUCT lpDrawItem)
{
	BOOL fSuccess = TRUE;
	HDC hdc = lpDrawItem->hDC;
	RECT rc = lpDrawItem->rcItem;
	HBRUSH hbr = NULL;
	HBRUSH hbrOld;

	// use the default button face color
	//
	if ((hbr = CreateSolidBrush(GetSysColor(COLOR_BTNFACE))) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((hbrOld = SelectObject(hdc, hbr)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (FillRect(hdc, &rc, hbr), FALSE)
		fSuccess = TraceFALSE(NULL);

	else if (SelectObject(hdc, hbrOld) == NULL)
		fSuccess = TraceFALSE(NULL);

	if (hbr != NULL && !DeleteObject(hbr))
		fSuccess = TraceFALSE(NULL);
	else
		hbr = NULL;

	return fSuccess ? 0 : -1;
}

// IcoButtDrawEdges - draw the button edges
//		<lpIcoButt>			(i) pointer to ICOBUTT structure
//		<lpDrawItem>		(i) structure describing how to draw control
// return 0 if success
//
static int IcoButtDrawEdges(LPICOBUTT lpIcoButt, const LPDRAWITEMSTRUCT lpDrawItem)
{
	BOOL fSuccess = TRUE;
	HDC hdc = lpDrawItem->hDC;
	RECT rc = lpDrawItem->rcItem;
	UINT itemState = lpDrawItem->itemState;
	int iColor;
	HPEN hPen = NULL;
	HPEN hPenOld;

	// Draw a black frame border
	//

    //
    // We should verify the value returned by GetStockObject
    HBRUSH hBrush = (HBRUSH)GetStockObject( BLACK_BRUSH );

    if( hBrush )
	    FrameRect(hdc, &rc, hBrush);

	// draw top and left edges of button to give depth
	//
	if (itemState & ODS_SELECTED)
		iColor = COLOR_BTNSHADOW;
#if WINVER >= 0x030A
	else if (SysGetWindowsVersion() >= 310)
		iColor = COLOR_BTNHIGHLIGHT;
#endif
	else
		iColor = COLOR_WINDOW;

	if ((hPen = CreatePen(PS_SOLID, 1, GetSysColor(iColor))) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((hPenOld = SelectObject(hdc, hPen)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		MoveToEx(hdc, 1, 1, NULL);
		LineTo(hdc, rc.right - 1, 1);
		MoveToEx(hdc, 1, 1, NULL);
		LineTo(hdc, 1, rc.bottom - 1);
		MoveToEx(hdc, 2, 2, NULL);
		LineTo(hdc, rc.right - 2, 2);
		MoveToEx(hdc, 2, 2, NULL);
		LineTo(hdc, 2, rc.bottom - 2);

		if (SelectObject(hdc, hPenOld) == NULL)
			fSuccess = TraceFALSE(NULL);
	}

	if (hPen != NULL && !DeleteObject(hPen))
		fSuccess = TraceFALSE(NULL);
	else
		hPen = NULL;

	// draw bottom and right edges of button to give depth
	//
	if (fSuccess && !(itemState & ODS_SELECTED))
	{
		iColor = COLOR_BTNSHADOW;

		if ((hPen = CreatePen(PS_SOLID, 1, GetSysColor(iColor))) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if ((hPenOld = SelectObject(hdc, hPen)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else
		{
		 	MoveToEx(hdc, rc.right - 2, rc.bottom - 2, NULL);
		 	LineTo(hdc, rc.right - 2, 1);
		 	MoveToEx(hdc, rc.right - 2, rc.bottom - 2, NULL);
		 	LineTo(hdc, 1, rc.bottom - 2);
		 	MoveToEx(hdc, rc.right - 3, rc.bottom - 3, NULL);
		 	LineTo(hdc, rc.right - 3, 2);
		 	MoveToEx(hdc, rc.right - 3, rc.bottom - 3, NULL);
		 	LineTo(hdc, 2, rc.bottom - 3);

			if (SelectObject(hdc, hPenOld) == NULL)
				fSuccess = TraceFALSE(NULL);
		}
	}

	if (hPen != NULL && !DeleteObject(hPen))
		fSuccess = TraceFALSE(NULL);
	else
		hPen = NULL;

	return fSuccess ? 0 : -1;
}

// IcoButtDrawIcon - draw the button icon
//		<lpIcoButt>			(i) pointer to ICOBUTT structure
//		<lpDrawItem>		(i) structure describing how to draw control
// return 0 if success
//
static int IcoButtDrawIcon(LPICOBUTT lpIcoButt, const LPDRAWITEMSTRUCT lpDrawItem)
{
	BOOL fSuccess = TRUE;
	HDC hdc = lpDrawItem->hDC;
	RECT rc = lpDrawItem->rcItem;
	UINT itemState = lpDrawItem->itemState;
	HICON hIcon;
	int x;
	int y;

	// choose the appropriate icon
	//
	if (itemState & ODS_DISABLED)
		hIcon = lpIcoButt->hIconGreyed;
	else if (GfxDeviceIsMono(hdc))
		hIcon = lpIcoButt->hIconMono;
	else
		hIcon = lpIcoButt->hIconColor;

	if (hIcon == NULL)
		hIcon = lpIcoButt->hIconMono;

	// calculate horizontal position of icon
	//
	if (lpIcoButt->dwFlags & ICOBUTT_ICONLEFT)
		x = 1;
	else if (lpIcoButt->dwFlags & ICOBUTT_ICONRIGHT)
		x = max(0, rc.right - rc.left - ICONWIDTH);
	else // centered is the default
		x = max(0, rc.right - rc.left - ICONWIDTH) / 2;

	// calculate vertical position of icon
	//
	if ((lpIcoButt->dwFlags & ICOBUTT_NOTEXT) ||
		(lpIcoButt->dwFlags & ICOBUTT_SPLITTEXT))
		y = 1;
	else
		y = 3;

	// if button is depressed, adjust icon position down and to the right
	//
	if (itemState & ODS_SELECTED)
	{
		x += 2;
		y += 2;
	}

	// draw the icon
	//

    //
    // We should verify if hIcon is a valid resource handler
    //
	if ( (NULL == hIcon) || !DrawIcon(hdc, x, y, hIcon))
		fSuccess = TraceFALSE(NULL);

	// draw a rectangle around icon to indicate focus if needed
	//
	else if ((itemState & ODS_FOCUS) &&
		!(lpIcoButt->dwFlags & ICOBUTT_NOFOCUS) &&
		(lpIcoButt->dwFlags & ICOBUTT_NOTEXT))
	{
		RECT rcFocus;
		COLORREF crBkColorOld;

		rcFocus.left = x + 3;
		rcFocus.top = y + 3;
		rcFocus.right = x + ICONWIDTH - 3;
		rcFocus.bottom = y + ICONHEIGHT - 3;

		crBkColorOld = SetBkColor(hdc, GetSysColor(COLOR_WINDOW));

		DrawFocusRect(hdc, &rcFocus);

		SetBkColor(hdc, crBkColorOld);
	}

	return fSuccess ? 0 : -1;
}

// IcoButtDrawText - draw the button text
//		<lpIcoButt>			(i) pointer to ICOBUTT structure
//		<lpDrawItem>		(i) structure describing how to draw control
// return 0 if success
//
static int IcoButtDrawText(LPICOBUTT lpIcoButt, const LPDRAWITEMSTRUCT lpDrawItem)
{
	BOOL fSuccess = TRUE;
	HDC hdc = lpDrawItem->hDC;
	TCHAR szText[64];

	*szText = '\0';
	Button_GetText(lpIcoButt->hwndButton, szText, SIZEOFARRAY(szText));

	if (*szText == '\0' || (lpIcoButt->dwFlags & ICOBUTT_NOTEXT))
		; // no need to continue

	else
	{
		HFONT hFontOld;
		COLORREF crBkColorOld;
		COLORREF crTextColorOld;
		int nBkModeOld;

		if ((hFontOld = SelectObject(hdc, lpIcoButt->hFont)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else
		{
			crBkColorOld = SetBkColor(hdc, GetSysColor(COLOR_BTNFACE));
			crTextColorOld = SetTextColor(hdc, GetSysColor(COLOR_BTNTEXT));
			nBkModeOld = SetBkMode(hdc, TRANSPARENT);
		}

		if (fSuccess)
		{
			LPTSTR lpszLine = szText;
			int cLines = 0;

			if (lpIcoButt->dwFlags & ICOBUTT_SPLITTEXT)
			{
				// split text into lines, draw each one
				//
				lpszLine = StrTok(szText, TEXT("\t\n"));
				while (fSuccess && lpszLine != NULL)
				{
					if (IcoButtDrawLine(lpIcoButt, lpDrawItem,
						lpszLine, ++cLines) != 0)
						fSuccess = TraceFALSE(NULL);

					lpszLine = (LPTSTR) StrTok(NULL, TEXT("\t\n"));
				}
			}
			else
			{
				// draw entire text as one line
				//
				if (IcoButtDrawLine(lpIcoButt, lpDrawItem,
					lpszLine, 0) != 0)
			 		fSuccess = TraceFALSE(NULL);
			}
		}

		if (fSuccess)
		{
			// restore foreground and background text colors
			//
			SetBkColor(hdc, crBkColorOld);
			SetTextColor(hdc, crTextColorOld);
			SetBkMode(hdc, nBkModeOld);

			// restore font
			//
			if (SelectObject(hdc, hFontOld) == NULL)
				fSuccess = TraceFALSE(NULL);
		}
	}

	return fSuccess ? 0 : -1;
}

// IcoButtDrawLine - draw a line of button text
//		<lpIcoButt>			(i) pointer to ICOBUTT structure
//		<lpDrawItem>		(i) structure describing how to draw control
//		<lpszLine>			(i) line of text to draw
//		<nLine>				(i) line count
//			0					one and only line
// return 0 if success
//
static int IcoButtDrawLine(LPICOBUTT lpIcoButt, const LPDRAWITEMSTRUCT lpDrawItem,
	LPTSTR lpszLine, int nLine)
{
	BOOL fSuccess = TRUE;
	HDC hdc = lpDrawItem->hDC;
	RECT rc = lpDrawItem->rcItem;
	UINT itemState = lpDrawItem->itemState;
 	TEXTMETRIC tm;
	SIZE size;
	int cxTemp;

    //
    // We should initialize the local variables
    //

	int xUnderline = 0;
	int cxUnderline = 0;
	LPTSTR lpsz1;
	LPTSTR lpsz2;
	int cchLine;
	int x;
	int y;

 	if (!GetTextMetrics(hdc, &tm))
 		fSuccess = TraceFALSE(NULL);

	else
	{
		// determine position and width of underline
		//
		cxTemp = 0L;
		lpsz1 = lpsz2 = lpszLine;
		while (*lpsz2 != '\0')
		{
			if (*lpsz2 == '&' && *(lpsz2 + 1) != '\0')
			{
				xUnderline = cxTemp;
				lpsz2 = StrNextChr(lpsz2);
				cxUnderline = 0;
				if (GetTextExtentPoint(hdc, lpsz2, 1, &size))
					cxUnderline = size.cx;
			}
			else
			{
				if (GetTextExtentPoint(hdc, lpsz2, 1, &size))
					cxTemp += size.cx;
				*lpsz1 = *lpsz2;
				lpsz1 = StrNextChr(lpsz1);
				lpsz2 = StrNextChr(lpsz2);
			}
		}
		*lpsz1 = '\0';

		// determine width of text
		//
		cchLine = StrLen(lpszLine);
		cxTemp = 0;
		if (GetTextExtentPoint(hdc, lpszLine, cchLine, &size))
			cxTemp = size.cx;

		// calculate horizontal position of line
		//
		if (lpIcoButt->dwFlags & ICOBUTT_ICONLEFT)
			x = 1 + ICONWIDTH;
		else if (lpIcoButt->dwFlags & ICOBUTT_ICONRIGHT)
			x = max(0, rc.right - rc.left - cxTemp) - ICONWIDTH;
		else // centered is the default
			x = max(0, rc.right - rc.left - cxTemp) / 2;

		if ((lpIcoButt->dwFlags & ICOBUTT_ICONLEFT) ||
			(lpIcoButt->dwFlags & ICOBUTT_ICONRIGHT))
		{
			y = nLine == 0 ? 23 : nLine == 1 ? 17 : 29;
		}
		else // centered
		{
			if (lpIcoButt->dwFlags & ICOBUTT_SPLITTEXT)
				y = nLine == 0 ? 47 : nLine == 1 ? 42 : 53;
			else
				y = 50;
		}
		y -= tm.tmHeight;

		if (itemState & ODS_SELECTED)
		{
			x += 2;
			y += 2;
		}

		// draw the text
		//
		if (!(itemState & ODS_DISABLED))
		{
			if (!TextOut(hdc, x, y, lpszLine, cchLine))
		 		fSuccess = TraceFALSE(NULL);
		}
		else
		{
			COLORREF crGray;

			// if ((crGray = GetSysColor(COLOR_GRAYTEXT)) != 0)
			if ((crGray = GetSysColor(COLOR_BTNSHADOW)) != 0 &&
				crGray != GetSysColor(COLOR_BTNFACE) &&
				!GfxDeviceIsMono(hdc))
			{
				COLORREF crTextOld;

				crTextOld = SetTextColor(hdc, crGray);

				if (!TextOut(hdc, x, y, lpszLine, cchLine))
			 		fSuccess = TraceFALSE(NULL);

				SetTextColor(hdc, crTextOld);
			}
			else
			{
				GrayString(hdc, GetStockObject(BLACK_BRUSH),
					NULL, (LPARAM) lpszLine, cchLine, x, y, 0, 0);
			}
		}

		// draw underline if necessary
		//
		if (cxUnderline > 0)
		{
			HPEN hPen = NULL;
			HPEN hPenOld = NULL;

			if ((itemState & ODS_DISABLED))
			{
				if ((hPen = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_BTNSHADOW))) == NULL)
			 		fSuccess = TraceFALSE(NULL);

				else if ((hPenOld = SelectObject(hdc, hPen)) == NULL)
					fSuccess = TraceFALSE(NULL);
			}

			MoveToEx(hdc, x + xUnderline, y + tm.tmAscent + 1, NULL);
			LineTo(hdc, x + xUnderline + cxUnderline, y + tm.tmAscent + 1);

			if (hPenOld != NULL && SelectObject(hdc, hPenOld) == NULL)
				fSuccess = TraceFALSE(NULL);

			if (hPen != NULL && !DeleteObject(hPen))
				fSuccess = TraceFALSE(NULL);
		}

		// draw a rectangle around text to indicate focus if needed
		//
		if ((itemState & ODS_FOCUS) &&
			!(lpIcoButt->dwFlags & ICOBUTT_NOFOCUS))
		{
			RECT rcFocus;
			COLORREF crBkColorOld;

			rcFocus.left = x - 2;
			rcFocus.top = y - 1;
			rcFocus.right = x + cxTemp + 2;
			rcFocus.bottom = y + tm.tmHeight + 1;

			crBkColorOld = SetBkColor(hdc, GetSysColor(COLOR_WINDOW));

			DrawFocusRect(hdc, &rcFocus);

			SetBkColor(hdc, crBkColorOld);
		}
	}

	return fSuccess ? 0 : -1;
}

// IcoButtGetPropPtr - get icobutt pointer from button window property
//		<hwndButton>		(i) button window handle
// return ICOBUTT pointer (NULL if none)
//
static LPICOBUTT IcoButtGetPropPtr(HWND hwndButton)
{
	BOOL fSuccess = TRUE;
	LPICOBUTT lpIcoButt;

	// retrieve button instance data, construct pointer
	//
#ifdef _WIN32
	if ((lpIcoButt = (LPICOBUTT) GetProp(hwndButton, TEXT("lpIcoButt"))) == NULL)
		; // window property does not exist
#else
	WORD wSelector;
	WORD wOffset;

	wSelector = (WORD) GetProp(hwndButton, TEXT("lpIcoButtSELECTOR"));
	wOffset = (WORD) GetProp(hwndButton, TEXT("lpIcoButtOFFSET"));

	if ((lpIcoButt = MAKELP(wSelector, wOffset)) == NULL)
		; // window property does not exist
#endif

	else if (IsBadWritePtr(lpIcoButt, sizeof(ICOBUTT)))
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? lpIcoButt : NULL;
}

// IcoButtSetPropPtr - set icobutt pointer as button window property
//		<hwndButton>		(i) button window handle
//		<lpIcoButt>			(i) pointer to ICOBUTT struct
// return 0 if success
//
static int IcoButtSetPropPtr(HWND hwndButton, LPICOBUTT lpIcoButt)
{
	BOOL fSuccess = TRUE;

#ifdef _WIN32
	if (!SetProp(hwndButton, TEXT("lpIcoButt"), (HANDLE) lpIcoButt))
		fSuccess = TraceFALSE(NULL);
#else
	if (!SetProp(hwndButton,
		TEXT("lpIcoButtSELECTOR"), (HANDLE) SELECTOROF(lpIcoButt)))
		fSuccess = TraceFALSE(NULL);

	else if (!SetProp(hwndButton,
		TEXT("lpIcoButtOFFSET"), (HANDLE) OFFSETOF(lpIcoButt)))
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? 0 : -1;
}

// IcoButtRemovePropPtr - remove icobutt pointer from button window property
//		<hwndButton>		(i) button window handle
// return 0 if success
//
static LPICOBUTT IcoButtRemovePropPtr(HWND hwndButton)
{
	BOOL fSuccess = TRUE;
	LPICOBUTT lpIcoButt;

	// retrieve button instance data, construct pointer
	//
#ifdef _WIN32
	if ((lpIcoButt = (LPICOBUTT) RemoveProp(hwndButton, TEXT("lpIcoButt"))) == NULL)
		; // window property does not exist
#else
	WORD wSelector;
	WORD wOffset;

	wSelector = (WORD) RemoveProp(hwndButton, TEXT("lpIcoButtSELECTOR"));
	wOffset = (WORD) RemoveProp(hwndButton, TEXT("lpIcoButtOFFSET"));

	if ((lpIcoButt = MAKELP(wSelector, wOffset)) == NULL)
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? lpIcoButt : NULL;
}

// IcoButtGetPtr - verify that icobutt handle is valid,
//		<hIcoButt>				(i) handle returned from IcoButtCreate
// return corresponding icobutt pointer (NULL if error)
//
static LPICOBUTT IcoButtGetPtr(HICOBUTT hIcoButt)
{
	BOOL fSuccess = TRUE;
	LPICOBUTT lpIcoButt;

	if ((lpIcoButt = (LPICOBUTT) hIcoButt) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadWritePtr(lpIcoButt, sizeof(ICOBUTT)))
		fSuccess = TraceFALSE(NULL);

#ifdef CHECKTASK
	// make sure current task owns the icobutt handle
	//
	else if (lpIcoButt->hTask != GetCurrentTask())
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? lpIcoButt : NULL;
}

// IcoButtGetHandle - verify that icobutt pointer is valid,
//		<lpIcoButt>				(i) pointer to ICOBUTT struct
// return corresponding icobutt handle (NULL if error)
//
static HICOBUTT IcoButtGetHandle(LPICOBUTT lpIcoButt)
{
	BOOL fSuccess = TRUE;
	HICOBUTT hIcoButt;

	if ((hIcoButt = (HICOBUTT) lpIcoButt) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hIcoButt : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\jpeg.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	jpeg.h - jpeg compression and decompression functions
////

#ifndef __JPEG_H__
#define __JPEG_H__

#ifdef __cplusplus
extern "C" {
#endif

#include "winlocal.h"

#define JPEG_VERSION 0x00000100

#define JPEG_COMPRESS				0x00000001
#define JPEG_DECOMPRESS				0x00000002
#define JPEG_GREYSCALE				0x00000004
#define JPEG_FLOAT					0x00000008
#define JPEG_DEBUG					0x00000010
#define JPEG_OPTIMIZE				0x00000020
#define JPEG_PROGRESSIVE			0x00000040
#define JPEG_DESTGIF				0x00000080
#define JPEG_DESTBMP				0x00000100

// handle to jpeg engine
//
DECLARE_HANDLE32(HJPEG);

// JpegInit - initialize jpeg engine
//		<dwVersion>			(i) must be JPEG_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<dwFlags>			(i) control flags
//			JPEG_COMPRESS		compresssion needed
//			JPEG_DECOMPRESS		decompresssion needed
// return handle (NULL if error)
//
HJPEG DLLEXPORT WINAPI JpegInit(DWORD dwVersion, HINSTANCE hInst, DWORD dwFlags);

// JpegTerm - shut down jpeg engine
//		<hJpeg>				(i) handle returned from JpegInit
// return 0 if success
//
int DLLEXPORT WINAPI JpegTerm(HJPEG hJpeg);

// JpegCompress - compress BMP or GIF input file to JPEG output file
//		<hJpeg>				(i) handle returned from JpegInit
//		<lpszSrc>			(i) name of input file
//		<lpszDst>			(i) name of output file
//		<nQuality>			(i) compression quality (0..100; 5-95 is useful range)
//			-1					default quality
//		<lParam>			(i) reserved; must be NULL
//		<dwFlags>			(i) control flags
//			JPEG_GREYSCALE			force monochrome output
//			JPEG_FLOAT				use floating point computation
//			JPEG_DEBUG				emit verbose debug output
//			JPEG_OPTIMIZE			smaller file, slower compression
//			JPEG_PROGRESSIVE		create progressive JPEG output
// return 0 if success
//
int DLLEXPORT WINAPI JpegCompress(HJPEG hJpeg, LPCTSTR lpszSrc, LPCTSTR lpszDst, int nQuality, LPCTSTR lParam, DWORD dwFlags);

// JpegDecompress - decompress JPEG input file to BMP or GIF output file
//		<hJpeg>				(i) handle returned from JpegInit
//		<lpszSrc>			(i) name of input file
//		<lpszDst>			(i) name of output file
//		<nColors>			(i) restrict image to no more than <nColor>
//			-1					no restriction
//		<lParam>			(i) reserved; must be NULL
//		<dwFlags>			(i) control flags
//			JPEG_GREYSCALE			force monochrome output
//			JPEG_FLOAT				use floating point computation
//			JPEG_DEBUG				emit verbose debug output
//			JPEG_DESTBMP			destination file is BMP format (default)
//			JPEG_DESTGIF			destination file is GIF format
// return 0 if success
//
int DLLEXPORT WINAPI JpegDecompress(HJPEG hJpeg, LPCTSTR lpszSrc, LPCTSTR lpszDst, short nColors, LPCTSTR lParam, DWORD dwFlags);

#ifdef __cplusplus
}
#endif

#endif // __JPEG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\list.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// list.c - linked list functions
////

#include "winlocal.h"

#include "list.h"
#include "mem.h"
#include "trace.h"

////
//	private definitions
////

// list node
//
typedef struct LISTNODE
{
	struct LISTNODE FAR *lpNodePrev;
	struct LISTNODE FAR *lpNodeNext;
	LISTELEM elem;
} LISTNODE, FAR *LPLISTNODE;

// list
//
typedef struct LIST
{
	DWORD dwVersion;
	HINSTANCE hInst;
	HTASK hTask;
	LPLISTNODE lpNodeHead;
	LPLISTNODE lpNodeTail;
	long cNodes;
} LIST, FAR *LPLIST;

// helper functions
//
static LPLIST ListGetPtr(HLIST hList);
static HLIST ListGetHandle(LPLIST lpList);
static LPLISTNODE ListNodeGetPtr(HLISTNODE hNode);
static HLISTNODE ListNodeGetHandle(LPLISTNODE lpNode);
static LPLISTNODE ListNodeCreate(LPLIST lpList, LPLISTNODE lpNodePrev, LPLISTNODE lpNodeNext, LISTELEM elem);
static int ListNodeDestroy(LPLIST lpList, LPLISTNODE lpNode);

////
//	public functions
////

////
// list constructor and destructor functions
////

// ListCreate - list constructor
//		<dwVersion>			(i) must be LIST_VERSION
// 		<hInst>				(i) instance handle of calling module
// return new list handle (NULL if error)
//
HLIST DLLEXPORT WINAPI ListCreate(DWORD dwVersion, HINSTANCE hInst)
{
	BOOL fSuccess = TRUE;
	LPLIST lpList = NULL;

	if (dwVersion != LIST_VERSION)
		fSuccess = TraceFALSE(NULL);

	else if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpList = (LPLIST) MemAlloc(NULL, sizeof(LIST), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		// initially the list is empty
		//
		lpList->dwVersion = dwVersion;
		lpList->hInst = hInst;
		lpList->hTask = GetCurrentTask();
		lpList->lpNodeHead = NULL;
		lpList->lpNodeTail = NULL;
		lpList->cNodes = 0;
	}

	return fSuccess ? ListGetHandle(lpList) : NULL;
}

// ListDestroy - list destructor
//		<hList>				(i) handle returned from ListCreate
// return 0 if success
// NOTE: any nodes within list are destroyed also
//
int DLLEXPORT WINAPI ListDestroy(HLIST hList)
{
	BOOL fSuccess = TRUE;
	LPLIST lpList;

	if ((lpList = ListGetPtr(hList)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// make sure the list is emptied
	//
	else if (ListRemoveAll(hList) != 0)
		fSuccess = TraceFALSE(NULL);

	else if ((lpList = MemFree(NULL, lpList)) != NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}

////
// list status functions
////

// ListGetCount - return count of nodes in list
//		<hList>				(i) handle returned from ListCreate
// return node count (-1 if error)
//
long DLLEXPORT WINAPI ListGetCount(HLIST hList)
{
	BOOL fSuccess = TRUE;
	LPLIST lpList;

	if ((lpList = ListGetPtr(hList)) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? lpList->cNodes : -1;
}

// ListIsEmpty - return TRUE if list has no nodes
//		<hList>				(i) handle returned from ListCreate
// return TRUE or FALSE
//
BOOL DLLEXPORT WINAPI ListIsEmpty(HLIST hList)
{
	return (BOOL) (ListGetCount(hList) <= 0);
}

////
// list iteration functions
////

// ListGetHeadNode - get list head node
//		<hList>				(i) handle returned from ListCreate
// return list head node (NULL if error or empty)
//
HLISTNODE DLLEXPORT WINAPI ListGetHeadNode(HLIST hList)
{
	BOOL fSuccess = TRUE;
	LPLIST lpList;

	if ((lpList = ListGetPtr(hList)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpList->lpNodeHead == NULL)
		fSuccess = FALSE; // empty list, which is not an error

	return fSuccess ? ListNodeGetHandle(lpList->lpNodeHead) : NULL;
}

// ListGetTailNode - get list tail node
//		<hList>				(i) handle returned from ListCreate
// return list tail node (NULL if error or empty)
//
HLISTNODE DLLEXPORT WINAPI ListGetTailNode(HLIST hList)
{
	BOOL fSuccess = TRUE;
	LPLIST lpList;

	if ((lpList = ListGetPtr(hList)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpList->lpNodeTail == NULL)
		fSuccess = FALSE; // empty list, which is not an error

	return fSuccess ? ListNodeGetHandle(lpList->lpNodeTail) : NULL;
}

// ListGetNextNode - get node which follows specified node
//		<hList>				(i) handle returned from ListCreate
//		<hNode>				(i) node handle
// return node which follows specified node (NULL if error or none)
//
HLISTNODE DLLEXPORT WINAPI ListGetNextNode(HLIST hList, HLISTNODE hNode)
{
	BOOL fSuccess = TRUE;
	LPLIST lpList;
	LPLISTNODE lpNode;

	if ((lpList = ListGetPtr(hList)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpNode = ListNodeGetPtr(hNode)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpNode->lpNodeNext == NULL)
		fSuccess = FALSE; // no more nodes, which is not an error

	return fSuccess ? ListNodeGetHandle(lpNode->lpNodeNext) : NULL;
}

// ListGetPrevNode - get node which precedes specified node
//		<hList>				(i) handle returned from ListCreate
//		<hNode>				(i) node handle
// return node which precedes specified node (NULL if error or none)
//
HLISTNODE DLLEXPORT WINAPI ListGetPrevNode(HLIST hList, HLISTNODE hNode)
{
	BOOL fSuccess = TRUE;
	LPLIST lpList;
	LPLISTNODE lpNode;

	if ((lpList = ListGetPtr(hList)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpNode = ListNodeGetPtr(hNode)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpNode->lpNodePrev == NULL)
		fSuccess = FALSE; // no more nodes, which is not an error

	return fSuccess ? ListNodeGetHandle(lpNode->lpNodePrev) : NULL;
}

////
// list element insertion functions
////

// ListAddHead - add new node with data <elem> to head of list,
//		<hList>				(i) handle returned from ListCreate
//		<elem>				(i) new data element
// returns new node handle (NULL if error)
//
HLISTNODE DLLEXPORT WINAPI ListAddHead(HLIST hList, LISTELEM elem)
{
	BOOL fSuccess = TRUE;
	LPLIST lpList;
	LPLISTNODE lpNodeNew;

	if ((lpList = ListGetPtr(hList)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpNodeNew = ListNodeCreate(lpList,
		NULL, lpList->lpNodeHead, elem)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		if (lpList->lpNodeHead != NULL)
			lpList->lpNodeHead->lpNodePrev = lpNodeNew;
		else
			lpList->lpNodeTail = lpNodeNew;

		lpList->lpNodeHead = lpNodeNew;
	}

	return fSuccess ? ListNodeGetHandle(lpNodeNew) : NULL;
}

// ListAddTail - add new node with data <elem> to tail of list,
//		<hList>				(i) handle returned from ListCreate
//		<elem>				(i) new data element
// returns new node handle (NULL if error)
//
HLISTNODE DLLEXPORT WINAPI ListAddTail(HLIST hList, LISTELEM elem)
{
	BOOL fSuccess = TRUE;
	LPLIST lpList;
	LPLISTNODE lpNodeNew;

	if ((lpList = ListGetPtr(hList)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpNodeNew = ListNodeCreate(lpList,
		lpList->lpNodeTail, NULL, elem)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		if (lpList->lpNodeTail != NULL)
			lpList->lpNodeTail->lpNodeNext = lpNodeNew;
		else
			lpList->lpNodeHead = lpNodeNew;

		lpList->lpNodeTail = lpNodeNew;
	}

	return fSuccess ? ListNodeGetHandle(lpNodeNew) : NULL;
}

// ListInsertBefore - insert new node with data <elem> before specified node
//		<hList>				(i) handle returned from ListCreate
//		<hNode>				(i) node handle
//		<elem>				(i) new data element
// return handle to new node (NULL if error)
//
HLISTNODE DLLEXPORT WINAPI ListInsertBefore(HLIST hList, HLISTNODE hNode, LISTELEM elem)
{
	BOOL fSuccess = TRUE;
	LPLIST lpList;
	LPLISTNODE lpNodeOld;
	LPLISTNODE lpNodeNew;

	if ((lpList = ListGetPtr(hList)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// special case to insert at head of list
	//
	else if (hNode == NULL)
		return ListAddHead(hList, elem);

	else if ((lpNodeOld = ListNodeGetPtr(hNode)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpNodeNew = ListNodeCreate(lpList,
		lpNodeOld->lpNodePrev, lpNodeOld, elem)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		if (lpNodeOld->lpNodePrev != NULL)
			lpNodeOld->lpNodePrev->lpNodeNext = lpNodeNew;
		else
			lpList->lpNodeHead = lpNodeNew;

		lpNodeOld->lpNodePrev = lpNodeNew;
	}

	return fSuccess ? ListNodeGetHandle(lpNodeNew) : NULL;
}

// ListInsertAfter - insert new node with data <elem> after specified node
//		<hList>				(i) handle returned from ListCreate
//		<hNode>				(i) node handle
//		<elem>				(i) new data element
// return handle to new node (NULL if error)
//
HLISTNODE DLLEXPORT WINAPI ListInsertAfter(HLIST hList, HLISTNODE hNode, LISTELEM elem)
{
	BOOL fSuccess = TRUE;
	LPLIST lpList;
	LPLISTNODE lpNodeOld;
	LPLISTNODE lpNodeNew;

	if ((lpList = ListGetPtr(hList)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// special case to insert at tail of list
	//
	else if (hNode == NULL)
		return ListAddTail(hList, elem);

	else if ((lpNodeOld = ListNodeGetPtr(hNode)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpNodeNew = ListNodeCreate(lpList,
		lpNodeOld, lpNodeOld->lpNodeNext, elem)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		if (lpNodeOld->lpNodeNext != NULL)
			lpNodeOld->lpNodeNext->lpNodePrev = lpNodeNew;
		else
			lpList->lpNodeTail = lpNodeNew;

		lpNodeOld->lpNodeNext = lpNodeNew;
	}

	return fSuccess ? ListNodeGetHandle(lpNodeNew) : NULL;
}

////
// list element removal functions
////

// ListRemoveHead - remove node from head of list,
//		<hList>				(i) handle returned from ListCreate
// returns removed data element
//
LISTELEM DLLEXPORT WINAPI ListRemoveHead(HLIST hList)
{
	BOOL fSuccess = TRUE;
	LPLIST lpList;
	LPLISTNODE lpNodeOld;
	LISTELEM elemOld;

	if ((lpList = ListGetPtr(hList)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// error if list is empty
	//
	else if (lpList->lpNodeHead == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		// save the node to be removed
		//
		lpNodeOld = lpList->lpNodeHead;
		elemOld = lpNodeOld->elem;

		// point to new head node and tail node, if any
		//
		lpList->lpNodeHead = lpNodeOld->lpNodeNext;
		if (lpList->lpNodeHead != NULL)
			lpList->lpNodeHead->lpNodePrev = NULL;
		else
			lpList->lpNodeTail = NULL;

		if (ListNodeDestroy(lpList, lpNodeOld) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? elemOld : (LISTELEM) NULL;
}

// ListRemoveTail - remove node from tail of list,
//		<hList>				(i) handle returned from ListCreate
// returns removed data element
//
LISTELEM DLLEXPORT WINAPI ListRemoveTail(HLIST hList)
{
	BOOL fSuccess = TRUE;
	LPLIST lpList;
	LPLISTNODE lpNodeOld;
	LISTELEM elemOld;

	if ((lpList = ListGetPtr(hList)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// error if list is empty
	//
	else if (lpList->lpNodeTail == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		// save the node to be removed
		//
		lpNodeOld = lpList->lpNodeTail;
		elemOld = lpNodeOld->elem;

		// point to new tail node and head node, if any
		//
		lpList->lpNodeTail = lpNodeOld->lpNodePrev;
		if (lpList->lpNodeTail != NULL)
			lpList->lpNodeTail->lpNodeNext = NULL;
		else
			lpList->lpNodeHead = NULL;

		if (ListNodeDestroy(lpList, lpNodeOld) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? elemOld : (LISTELEM) NULL;
}

// ListRemoveAt - remove specified node from list,
//		<hList>				(i) handle returned from ListCreate
//		<hNode>				(i) node handle
// returns removed data element
//
LISTELEM DLLEXPORT WINAPI ListRemoveAt(HLIST hList, HLISTNODE hNode)
{
	BOOL fSuccess = TRUE;
	LPLIST lpList;
	LPLISTNODE lpNodeOld;
	LISTELEM elemOld;

	if ((lpList = ListGetPtr(hList)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpNodeOld = ListNodeGetPtr(hNode)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		// save the data to be removed
		//
		elemOld = lpNodeOld->elem;

		if (lpNodeOld == lpList->lpNodeHead)
			lpList->lpNodeHead = lpNodeOld->lpNodeNext;
		else
			lpNodeOld->lpNodePrev->lpNodeNext = lpNodeOld->lpNodeNext;

		if (lpNodeOld == lpList->lpNodeTail)
			lpList->lpNodeTail = lpNodeOld->lpNodePrev;
		else
			lpNodeOld->lpNodeNext->lpNodePrev = lpNodeOld->lpNodePrev;

		if (ListNodeDestroy(lpList, lpNodeOld) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? elemOld : (LISTELEM) NULL;
}

// ListRemoveAll - remove all nodes from list
//		<hList>				(i) handle returned from ListCreate
// return 0 if success
//
int DLLEXPORT WINAPI ListRemoveAll(HLIST hList)
{
	BOOL fSuccess = TRUE;

	while (fSuccess && !ListIsEmpty(hList))
		ListRemoveHead(hList);

	return fSuccess ? 0 : -1;
}

////
// list element get/set value functions
////

// ListGetHead - return data element from head node
//		<hList>				(i) handle returned from ListCreate
// return data element
//
LISTELEM DLLEXPORT WINAPI ListGetHead(HLIST hList)
{
	return ListGetAt(hList, ListGetHeadNode(hList));
}

// ListGetTail - return data element from tail node
//		<hList>				(i) handle returned from ListCreate
// return data element
//
LISTELEM DLLEXPORT WINAPI ListGetTail(HLIST hList)
{
	return ListGetAt(hList, ListGetTailNode(hList));
}

// ListGetAt - return data element from specified node
//		<hList>				(i) handle returned from ListCreate
//		<hNode>				(i) node handle
// return data element
//
LISTELEM DLLEXPORT WINAPI ListGetAt(HLIST hList, HLISTNODE hNode)
{
	BOOL fSuccess = TRUE;
	LPLIST lpList;
	LPLISTNODE lpNode;

	if ((lpList = ListGetPtr(hList)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpNode = ListNodeGetPtr(hNode)) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? lpNode->elem : (LISTELEM) NULL;
}

// ListSetAt - set data element in specified node
//		<hList>				(i) handle returned from ListCreate
//		<hNode>				(i) node handle
//		<elem>				(i) data element
// return 0 if success
//
int DLLEXPORT WINAPI ListSetAt(HLIST hList, HLISTNODE hNode, LISTELEM elem)
{
	BOOL fSuccess = TRUE;
	LPLIST lpList;
	LPLISTNODE lpNode;

	if ((lpList = ListGetPtr(hList)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpNode = ListNodeGetPtr(hNode)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
		lpNode->elem = elem;

	return fSuccess ? 0 : -1;
}

// ListFind - search list for node with matching element
//		<hList>				(i) handle returned from ListCreate
//		<elem>				(i) data element to match
//		<hNodeAfter>		(i) node handle to begin search after
//			NULL				start search at head node
// return matching node (NULL if error or none)
//
HLISTNODE DLLEXPORT WINAPI ListFind(HLIST hList, LISTELEM elem, HLISTNODE hNodeAfter)
{
	BOOL fSuccess = TRUE;
	LPLIST lpList;
	LPLISTNODE lpNode;

	if ((lpList = ListGetPtr(hList)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// if not otherwise specified, start search at head node
	//
	else if (hNodeAfter == NULL)
		lpNode = lpList->lpNodeHead;

	else if ((lpNode = ListNodeGetPtr(hNodeAfter)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// otherwise, start search at after specified node
	//
	else
		lpNode = lpNode->lpNodeNext;

	if (fSuccess)
	{
		while (lpNode != NULL)
		{
			if (lpNode->elem == elem)
				return ListNodeGetHandle(lpNode);
			lpNode = lpNode->lpNodeNext;
		}
	}

	return NULL;
}

// ListFindIndex - search list for nth node in list
//		<hList>				(i) handle returned from ListCreate
//		<nIndex>			(i) zero based index into list
// return handle to node (NULL if error)
//
HLISTNODE DLLEXPORT WINAPI ListFindIndex(HLIST hList, long nIndex)
{
	BOOL fSuccess = TRUE;
	LPLIST lpList;
	LPLISTNODE lpNode;

	if ((lpList = ListGetPtr(hList)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// error if index out of range
	//
	else if (nIndex < 0 || nIndex >= lpList->cNodes)
		fSuccess = TraceFALSE(NULL);

	else for (lpNode = lpList->lpNodeHead;
		lpNode != NULL;  lpNode = lpNode->lpNodeNext)
	{
		if (nIndex-- == 0)
			return ListNodeGetHandle(lpNode);
	}

	return NULL;
}

////
//	private functions
////

// ListGetPtr - verify that list handle is valid,
//		<hList>				(i) handle returned from ListCreate
// return corresponding list pointer (NULL if error)
//
static LPLIST ListGetPtr(HLIST hList)
{
	BOOL fSuccess = TRUE;
	LPLIST lpList;

	if ((lpList = (LPLIST) hList) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadWritePtr(lpList, sizeof(LIST)))
		fSuccess = TraceFALSE(NULL);

#ifdef CHECKTASK
	// make sure current task owns the list handle
	//
	else if (lpList->hTask != GetCurrentTask())
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? lpList : NULL;
}

// ListGetHandle - verify that list pointer is valid,
//		<lpList>			(i) pointer to LIST struct
// return corresponding list handle (NULL if error)
//
static HLIST ListGetHandle(LPLIST lpList)
{
	BOOL fSuccess = TRUE;
	HLIST hList;

	if ((hList = (HLIST) lpList) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hList : NULL;
}

// ListNodeGetPtr - verify that list node handle is valid,
//		<hNode>				(i) node handle
// return corresponding list node pointer (NULL if error)
//
static LPLISTNODE ListNodeGetPtr(HLISTNODE hNode)
{
	BOOL fSuccess = TRUE;
	LPLISTNODE lpNode;

	if ((lpNode = (LPLISTNODE) hNode) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadWritePtr(lpNode, sizeof(LISTNODE)))
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? lpNode : NULL;
}

// ListNodeGetHandle - verify that list node pointer is valid,
//		<lpNode>			(i) pointer to LISTNODE struct
// return corresponding list node handle (NULL if error)
//
static HLISTNODE ListNodeGetHandle(LPLISTNODE lpNode)
{
	BOOL fSuccess = TRUE;
	HLISTNODE hNode;

	if ((hNode = (HLISTNODE) lpNode) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hNode : NULL;
}

// ListNodeCreate - list node constructor
//		<lpList>			(i) pointer to LIST struct
//		<lpNodePrev>		(i) pointer to prior LISTNODE struct
//		<lpNodeNext>		(i) pointer to next LISTNODE struct
//		<elem>				(i) new data element
// return new list node handle (NULL if error)
// NOTE: list node count is incremented here
//
static LPLISTNODE ListNodeCreate(LPLIST lpList, LPLISTNODE lpNodePrev, LPLISTNODE lpNodeNext, LISTELEM elem)
{
	BOOL fSuccess = TRUE;
	LPLISTNODE lpNode;

	if (lpList == NULL)
		fSuccess = TraceFALSE(NULL);

	// check for overflow
	//
	else if (++lpList->cNodes <= 0)
		fSuccess = TraceFALSE(NULL);

	else if ((lpNode = (LPLISTNODE) MemAlloc(NULL, sizeof(LISTNODE), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		// initialize using supplied values
		//
		lpNode->lpNodePrev = lpNodePrev;
		lpNode->lpNodeNext = lpNodeNext;
		lpNode->elem = elem;
	}

	return fSuccess ? lpNode : NULL;
}

// ListNodeDestroy - list node destructor
//		<lpList>			(i) pointer to LIST struct
//		<lpNode>			(i) pointer to LISTNODE struct to destroy
// return 0 if success
// NOTE: list node count is decremented here
//
static int ListNodeDestroy(LPLIST lpList, LPLISTNODE lpNode)
{
	BOOL fSuccess = TRUE;

	if (lpList == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpNode == NULL)
		fSuccess = TraceFALSE(NULL);

	// check for underflow
	//
	else if (--lpList->cNodes < 0)
		fSuccess = TraceFALSE(NULL);

	else if ((lpNode = MemFree(NULL, lpNode)) != NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\loadlib.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	loadlib.c - loadlib functions
////

#include "winlocal.h"

#include <stdlib.h>

#include "loadlib.h"
#include "file.h"
#include "trace.h"

////
//	private definitions
////

////
// helper functions
////

static HINSTANCE WINAPI LoadLib(LPCTSTR lpLibFileName);

////
//	public functions
////

// LoadLibraryPath - load specified module into address space of calling process
//		<lpLibFileName>		(i) address of filename of executable module
//		<hInst>				(i) module handle used to get library path
//			NULL				use module used to create calling process
//		<dwFlags>			(i) reserved; must be zero
// return handle of loaded module (NULL if error)
//
// NOTE: This function behaves like the standard LoadLibrary(), except that
// the first attempt to load <lpLibFileName> is made by constructing an
// explicit path name, using GetModuleFileName(hInst, ...) to supply the
// drive and directory, and using <lpLibFileName> to supply the file name
// and extension. If the first attempt fails, LoadLibrary(lpLibFileName)
// is called.
//
HINSTANCE DLLEXPORT WINAPI LoadLibraryPath(LPCTSTR lpLibFileName, HINSTANCE hInst, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	HINSTANCE hInstLib;
	TCHAR szPath[_MAX_PATH];
	TCHAR szDrive[_MAX_DRIVE];
	TCHAR szDir[_MAX_DIR];
	TCHAR szFname[_MAX_FNAME];
	TCHAR szExt[_MAX_EXT];

	if (GetModuleFileName(hInst, szPath, SIZEOFARRAY(szPath)) <= 0)
		fSuccess = TraceFALSE(NULL);

	else if (FileSplitPath(szPath,
		szDrive, szDir, NULL, NULL) != 0)
		fSuccess = TraceFALSE(NULL);

	else if (FileSplitPath(lpLibFileName,
		NULL, NULL, szFname, szExt) != 0)
		fSuccess = TraceFALSE(NULL);

	else if (FileMakePath(szPath,
		szDrive, szDir, szFname, szExt) != 0)
		fSuccess = TraceFALSE(NULL);

	// load lib using constructed path, or try
	// the original library name as a last resort
	// 
	else if ((hInstLib = LoadLib(szPath)) == NULL &&
		(hInstLib = LoadLib(lpLibFileName)) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hInstLib : NULL;
}

////
// helper functions
////

static HINSTANCE WINAPI LoadLib(LPCTSTR lpLibFileName)
{
	BOOL fSuccess = TRUE;
	HINSTANCE hInstLib;

	// load the library if possible
	//
	if ((hInstLib = LoadLibrary(lpLibFileName))
#ifdef _WIN32
		== NULL)
	{
		DWORD dwLastError = GetLastError();
#else
		< HINSTANCE_ERROR)
	{
		DWORD dwLastError = (DWORD) (WORD) hInstLib;
		hInstLib = NULL;
#endif
		fSuccess = TraceFALSE(NULL);
	  	TracePrintf_2(NULL, 5,
	  		TEXT("LoadLibrary(\"%s\") failed (%lu)\n"),
			(LPTSTR) lpLibFileName,
	  		(unsigned long) dwLastError);
	}
	else
	{
	  	TracePrintf_1(NULL, 6,
	  		TEXT("LoadLibrary(\"%s\") succeeded\n"),
			(LPTSTR) lpLibFileName);
	}

	return fSuccess ? hInstLib : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\mem.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	mem.c - memory functions
////

#include "winlocal.h"

#include <string.h>

#include "mem.h"
#include "sys.h"
#include "trace.h"

////
//	private definitions
////

#ifndef NOTRACE

// mem control struct
//
typedef struct MEM
{
	DWORD dwVersion;
	HINSTANCE hInst;
	HTASK hTask;
	long nBlocks;
	long sizBlocks;
} MEM, FAR *LPMEM;

// shared mem engine handle
//
static LPMEM lpMemShare = NULL;
static int cShareUsage = 0;

// helper functions
//
static LPMEM MemGetPtr(HMEM hMem);
static HMEM MemGetHandle(LPMEM lpMem);

////
//	public functions
////

// MemInit - initialize mem engine
//		<dwVersion>			(i) must be MEM_VERSION
// 		<hInst>				(i) instance handle of calling module
// return handle (NULL if error)
//
HMEM DLLEXPORT WINAPI MemInit(DWORD dwVersion, HINSTANCE hInst)
{
	BOOL fSuccess = TRUE;
	LPMEM lpMem = NULL;
	BOOL fShare = TRUE;

	if (dwVersion != MEM_VERSION)
		fSuccess = FALSE;
	
	else if (hInst == NULL)
		fSuccess = FALSE;

	// if a shared mem engine already exists,
	// use it rather than create another one
	//
	else if (fShare && cShareUsage > 0 && lpMemShare != NULL)
		lpMem = lpMemShare;

	// memory is allocated such that the client app owns it
	// unless we are sharing the mem handle among several apps
	//
#ifdef _WIN32
	else if ((lpMem = (LPMEM) HeapAlloc(GetProcessHeap(),
		HEAP_ZERO_MEMORY, sizeof(MEM))) == NULL)
#else
	else if ((lpMem = (LPMEM) GlobalAllocPtr(GMEM_MOVEABLE |
		GMEM_ZEROINIT, sizeof(MEM))) == NULL)
#endif
		fSuccess = FALSE;

	else
	{
		lpMem->dwVersion = dwVersion;
		lpMem->hInst = hInst;
		lpMem->hTask = GetCurrentTask();
		lpMem->nBlocks = 0;
		lpMem->sizBlocks = 0;
	}

	if (!fSuccess)
	{
		MemTerm(MemGetHandle(lpMem));
		lpMem = NULL;
	}

	// keep track of total modules sharing a mem engine handle
	//
	if (fSuccess && fShare)
	{
		if (++cShareUsage == 1)
			lpMemShare = lpMem;
	}

	return fSuccess ? MemGetHandle(lpMem) : NULL;
}

// MemTerm - shut down mem engine
//		<hMem>				(i) handle returned from MemInit or NULL
// return 0 if success
//
int DLLEXPORT WINAPI MemTerm(HMEM hMem)
{
	BOOL fSuccess = TRUE;
	LPMEM lpMem;

	if ((lpMem = MemGetPtr(hMem)) == NULL)
		fSuccess = FALSE;

	// only shut down mem engine if handle
	// is not shared (or is no longer being shared)
	//
	else if (lpMem != lpMemShare || --cShareUsage <= 0)
	{
		// shared mem engine handle no longer valid
		//
		if (cShareUsage <= 0)
			lpMemShare = NULL;

#ifdef _WIN32
		if (!HeapFree(GetProcessHeap(), 0, lpMem))
#else
		if (GlobalFreePtr(lpMem) != 0)
#endif
			fSuccess = FALSE;
	}

	return fSuccess ? 0 : -1;
}

// MemAlloc - allocate memory block
//		<hMem>				(i) handle returned from MemInit or NULL
//		<sizBlock>			(i) size of block, in bytes
//		<dwFlags>			(i) control flags
//			MEM_NOZEROINIT		do not initialize block
// return pointer to block, NULL if error
//
LPVOID DLLEXPORT WINAPI MemAllocEx(HMEM hMem, long sizBlock, DWORD dwFlags,
	LPCTSTR lpszFileName, unsigned uLineNumber)
{
	BOOL fSuccess = TRUE;
	LPMEM lpMem;
	LPVOID lpBlock;

#ifdef _WIN32
	if ((lpMem = MemGetPtr(hMem)) == NULL)
		fSuccess = FALSE;

	else if ((lpBlock = HeapAlloc(GetProcessHeap(),
		(dwFlags & MEM_NOZEROINIT) ? 0 : HEAP_ZERO_MEMORY,
		sizBlock)) == NULL)
		fSuccess = FALSE;
#else
	UINT wFlags = 0;

	wFlags |= GMEM_MOVEABLE;
		
	if (!(dwFlags & MEM_NOZEROINIT))
		wFlags |= GMEM_ZEROINIT;
		
	if ((lpMem = MemGetPtr(hMem)) == NULL)
		fSuccess = FALSE;

	else if ((lpBlock = GlobalAllocPtr(wFlags, sizBlock)) == NULL)
		fSuccess = FALSE;
#endif

	// keep track of total blocks allocated, total size of all blocks
	//
	else if (++lpMem->nBlocks, lpMem->sizBlocks += sizBlock, FALSE)
		;

	else if (TraceGetLevel(NULL) >= 9)
	{
		TracePrintf_7(NULL, 9, TEXT("%s(%u) : %08X = MemAllocEx(%p, %08X) (%ld, %ld)\n"),
			(LPTSTR) lpszFileName,
			(unsigned) uLineNumber,
			lpBlock,
			(long) sizBlock,
			(unsigned long) dwFlags,
			lpMem->nBlocks,
			lpMem->sizBlocks);
	}

	return fSuccess ? lpBlock : NULL;
}

// MemReAlloc - reallocate memory block
//		<hMem>				(i) handle returned from MemInit or NULL
//		<lpBlock>			(i) pointer returned from MemAlloc
//		<sizBlock>			(i) new size of block, in bytes
//		<dwFlags>			(i) control flags
//			MEM_NOZEROINIT		do not initialize block
// return pointer to block, NULL if error
//
LPVOID DLLEXPORT WINAPI MemReAllocEx(HMEM hMem, LPVOID lpBlock, long sizBlock,
	DWORD dwFlags, LPCTSTR lpszFileName, unsigned uLineNumber)
{
	BOOL fSuccess = TRUE;
	LPMEM lpMem;
	LPVOID lpBlockOld = lpBlock;
	long sizBlockOld;

#ifdef _WIN32
	if ((lpMem = MemGetPtr(hMem)) == NULL)
		fSuccess = FALSE;

	else if ((sizBlockOld = MemSize(hMem, lpBlock)) <= 0)
		fSuccess = FALSE;

	else if ((lpBlock = HeapReAlloc(GetProcessHeap(),
		(dwFlags & MEM_NOZEROINIT) ? 0 : HEAP_ZERO_MEMORY,
		lpBlockOld, sizBlock)) == NULL)
		fSuccess = FALSE;
#else
	UINT wFlags = 0;

	wFlags |= GMEM_MOVEABLE;
		
	if (!(dwFlags & MEM_NOZEROINIT))
		wFlags |= GMEM_ZEROINIT;
		
	if ((lpMem = MemGetPtr(hMem)) == NULL)
		fSuccess = FALSE;

	else if ((sizBlockOld = MemSize(hMem, lpBlock)) <= 0)
		fSuccess = FALSE;

	else if ((lpBlock = GlobalReAllocPtr(lpBlockOld, sizBlock, wFlags)) == NULL)
		fSuccess = FALSE;
#endif

	// keep track of total blocks allocated, total size of all blocks
	//
	else if (lpMem->sizBlocks -= sizBlockOld, lpMem->sizBlocks += sizBlock, FALSE)
		;

	else if (TraceGetLevel(NULL) >= 9)
	{
		TracePrintf_8(NULL, 9, TEXT("%s(%u) : %p = MemReAllocEx(%p, %ld, %08X) (%ld, %ld)\n"),
			(LPTSTR) lpszFileName,
			(unsigned) uLineNumber,
			lpBlock,
			lpBlockOld,
			(long) sizBlock,
			(unsigned long) dwFlags,
			lpMem->nBlocks,
			lpMem->sizBlocks);
	}

	return fSuccess ? lpBlock : NULL;
}

// MemFree - free memory block
//		<hMem>				(i) handle returned from MemInit or NULL
//		<lpBlock>			(i) pointer returned from MemAlloc
// return NULL if success, lpBlock if error
//
// NOTE: the return value of this function is designed to allow the
// user of this function to easily assign NULL to a freed pointer,
// as the following example demonstrates:
//
//		if ((p = MemFree(hMem, p)) != NULL)
//			; // error
//
LPVOID DLLEXPORT WINAPI MemFreeEx(HMEM hMem, LPVOID lpBlock,
	LPCTSTR lpszFileName, unsigned uLineNumber)
{
	BOOL fSuccess = TRUE;
	LPMEM lpMem;
	long sizBlock;

	if ((lpMem = MemGetPtr(hMem)) == NULL)
		fSuccess = FALSE;

	else if ((sizBlock = MemSize(hMem, lpBlock)) <= 0)
		fSuccess = FALSE;

#ifdef _WIN32
	else if (!HeapFree(GetProcessHeap(), 0, lpBlock))
#else
	else if (GlobalFreePtr(lpBlock) != 0)
#endif
		fSuccess = FALSE;

	// keep track of total blocks allocated, total size of all blocks
	//
	else if (--lpMem->nBlocks, lpMem->sizBlocks -= sizBlock, FALSE)
		;

	else if (TraceGetLevel(NULL) >= 9)
	{
		TracePrintf_5(NULL, 9, TEXT("%s(%u) : MemFreeEx(%p) (%ld, %ld)\n"),
			(LPTSTR) lpszFileName,
			(unsigned) uLineNumber,
			lpBlock,
			lpMem->nBlocks,
			lpMem->sizBlocks);
	}

	return fSuccess ? NULL : lpBlock;
}

// MemSize - get size of memory block
//		<hMem>				(i) handle returned from MemInit or NULL
//		<lpBlock>			(i) pointer returned from MemAlloc
// return size of block if success, 0 if error
//
long DLLEXPORT WINAPI MemSize(HMEM hMem, LPVOID lpBlock)
{
	BOOL fSuccess = TRUE;
	LPMEM lpMem;
	long sizBlock;

	if ((lpMem = MemGetPtr(hMem)) == NULL)
		fSuccess = FALSE;

#ifdef _WIN32
	else if ((sizBlock = (long) HeapSize(GetProcessHeap(), 0, lpBlock)) <= 0)
#else
	else if ((sizBlock = (long) GlobalSize(GlobalPtrHandle(lpBlock))) <= 0)
#endif
		fSuccess = FALSE;

	return fSuccess ? sizBlock : 0;
}

#endif // #ifndef NOTRACE

#ifndef _WIN32

static void hmemmove(void _huge *d, const void _huge *s, long len);

#ifndef SIZE_T_MAX
#define SIZE_T_MAX (~((size_t) 0))
#endif

void _huge* DLLEXPORT MemCCpyEx(void _huge* dest, const void _huge* src, int c, long count)
{
	if (count <= SIZE_T_MAX)
		return _fmemccpy(dest, src, c, (size_t) count);
	else
		return NULL; //$FIXUP - need to handle large count
}

void _huge* DLLEXPORT MemChrEx(void _huge* buf, int c, long count)
{
	if (count <= SIZE_T_MAX)
		return _fmemchr(buf, c, (size_t) count);
	else
		return NULL; //$FIXUP - need to handle large count
}

int DLLEXPORT MemCmpEx(const void _huge* buf1, void _huge* buf2, long count)
{
	if (count <= SIZE_T_MAX)
		return _fmemcmp(buf1, buf2, (size_t) count);
	else
		return NULL; //$FIXUP - need to handle large count
}

void _huge* DLLEXPORT MemCpyEx(void _huge* dest, const void _huge* src, long count)
{
	if (count <= SIZE_T_MAX)
		return _fmemcpy(dest, src, (size_t) count);
	else
	{
		hmemcpy(dest, src, count);
		return dest;
	}
}

int DLLEXPORT MemICmpEx(const void _huge* buf1, void _huge* buf2, long count)
{
	if (count <= SIZE_T_MAX)
		return _fmemicmp(buf1, buf2, (size_t) count);
	else
		return NULL; //$FIXUP - need to handle large count
}

void _huge* DLLEXPORT MemMoveEx(void _huge* dest, const void _huge* src, long count)
{
	if (count <= SIZE_T_MAX)
		return _fmemmove(dest, src, (size_t) count);
	else
	{
		hmemmove(dest, src, count);
		return dest;
	}
}

void _huge* DLLEXPORT MemSet(void _huge* dest, int c, long count)
{
	if (count <= SIZE_T_MAX)
		return _fmemset(dest, c, (size_t) count);

	else
	{
		BYTE _huge* destTemp = dest;
		long countTemp = count;

		while (countTemp > 0)
		{
			size_t cb = (size_t) min(SIZE_T_MAX, countTemp);

			_fmemset(destTemp, c, cb);

			destTemp += cb;
			countTemp -= cb;
		}

		return dest;
	}
}

#endif // #ifndef _WIN32

////
//	helper functions
////

#ifndef NOTRACE

// MemGetPtr - verify that mem handle is valid,
//		<hMem>				(i) handle returned from MemInit
// return corresponding mem pointer (NULL if error)
//
static LPMEM MemGetPtr(HMEM hMem)
{
	BOOL fSuccess = TRUE;
	LPMEM lpMem;

	// use shared mem handle if no other supplied
	//
	if (hMem == NULL && lpMemShare != NULL)
		lpMem = lpMemShare;

	// create shared mem handle if no other supplied
	//
	else if (hMem == NULL && lpMemShare == NULL &&
		(hMem = MemInit(MEM_VERSION, SysGetTaskInstance(NULL))) == NULL)
		fSuccess = FALSE;

	else if ((lpMem = (LPMEM) hMem) == NULL)
		fSuccess = FALSE;

	// note: check for good pointer made only if not using lpMemShare
	//
	else if (lpMem != lpMemShare &&
		IsBadWritePtr(lpMem, sizeof(MEM)))
		fSuccess = FALSE;

#ifdef CHECKTASK
	// make sure current task owns the mem handle
	// except when shared mem handle is used
	//
	if (fSuccess && lpMem != lpMemShare &&
		lpMem->hTask != GetCurrentTask())
		fSuccess = FALSE;
#endif

	return fSuccess ? lpMem : NULL;
}

// MemGetHandle - verify that mem pointer is valid,
//		<lpMem>				(i) pointer to MEM struct
// return corresponding mem handle (NULL if error)
//
static HMEM MemGetHandle(LPMEM lpMem)
{
	BOOL fSuccess = TRUE;
	HMEM hMem;

	if ((hMem = (HMEM) lpMem) == NULL)
		fSuccess = FALSE;

	return fSuccess ? hMem : NULL;
}

#endif // #ifndef NOTRACE

#ifndef _WIN32

// from Microsoft Windows SDK KnowledgeBase PSS ID Number: Q117743
//
static void hmemmove(void _huge *d, const void _huge *s, long len)
{
	register long i;
	long safesize, times;

	// There are four cases to consider
	// case 1: source and destination are the same
	// case 2: source and destination do not overlap
	// case 3: source starts at a location before destination in
	//         linear memory
	// case 4: source starts at a location after destination in
	//         linear memory

	// detect case 1 and handle it
	if (d == s)
		return;

	// determine the amount of overlap
	if (d > s)     // get the absolute difference
		safesize = ((unsigned long)d - (unsigned long)s);
	else
		safesize = ((unsigned long)s - (unsigned long)d);

	// detect case 2
	if (safesize >= len)
	{
		hmemcpy(d, s, len);  // no overlap
		return;
	}

	times = len/safesize;

	// detect case 3 and handle it
	if ((s < d) && ((unsigned long)s+len-1) >(unsigned long)d)
	{
		// copy bytes from the end of source to the end of
		// destination in safesize quantum.
		for (i = 1; i <= times; i++)
			hmemcpy((void _huge *)((unsigned long) d+len-i*safesize),
			(void _huge *)((unsigned long)s+len-i*safesize),
			safesize);

		// copy the bytes remaining to be copied after
		// times*safesize bytes have been copied.
		if (times*safesize < len)
			hmemcpy(d, s, len - times*safesize);

	}
	else // this is case 4. handle it
	{
		// ASSERT (s > d) && ((d+len-1) > s))

		// copy bytes from the beginning of source to the
		// beginning of destination in safesize quantum
		for (i = 0; i < times; i++)
			hmemcpy((void _huge *)((unsigned long)d+i*safesize),
			(void _huge *)((unsigned long)s+i*safesize),
			safesize);

		// copy the bytes remaining to be copied after
		// times*safesize bytes have been copied.
		if (times*safesize < len)
			hmemcpy((void _huge*)((unsigned long)d+times*safesize),
			(void _huge*)((unsigned long)s+times*safesize),
			len - times*safesize);
	}

	return;
}

#endif // #ifndef _WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\nbox.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	nbox.c - notify box functions
////

#include "winlocal.h"

#include <stdlib.h>

#include "nbox.h"
#include "escbutt.h"
#include "gfx.h"
#include "mem.h"
#include "str.h"
#include "trace.h"
#include "wnd.h"

////
//	private definitions
////

#define NBOXCLASS TEXT("NBoxClass")
#define NBOXMAXCOLUMNS 60
#define NBOXMAXROWS 20

// nbox control struct
//
typedef struct NBOX
{
	DWORD dwVersion;
	HINSTANCE hInst;
	HTASK hTask;
	LPTSTR lpszText;
	DWORD dwFlags;
	HWND hwndNBox;
	BOOL fVisible;
	HWND hwndCancel;
	BOOL fCancelled;
	HWND hwndFocusOld;
	HCURSOR hCursorOld;
} NBOX, FAR *LPNBOX;

// helper functions
//
LRESULT DLLEXPORT CALLBACK NBoxWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
static BOOL NBoxOnNCCreate(HWND hwnd, CREATESTRUCT FAR* lpCreateStruct);
static void NBoxOnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
static void NBoxOnPaint(HWND hwnd);
static LPNBOX NBoxGetPtr(HNBOX hNBox);
static HNBOX NBoxGetHandle(LPNBOX lpNBox);

////
//	public functions
////

// NBoxCreate - notify box constructor
//		<dwVersion>			(i) must be NBOX_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<hwndParent>		(i) window which will own the notify box
//			NULL				desktop window
//		<lpszText>			(i) message to be displayed
//		<lpszTitle>			(i) notify box caption
//			NULL				no caption
//		<lpszButtonText>	(i) pushbutton text, if NB_CANCEL specified
//			NULL				use default text ("Cancel")
//		<dwFlags>			(i)	control flags
//			NB_CANCEL			notify box includes Cancel pushbutton
//			NB_TASKMODAL		disable parent task's top-level windows
//			NB_HOURGLASS		show hourglass cursor while notify box visible
// return notify box handle (NULL if error)
//
// NOTE: NBoxCreate creates the window but does not show it.
// See NBoxShow and NBoxHide.
// The size of the notify box is determined by the number of
// lines in <lpszText>, and the length of the longest line.
//
HNBOX DLLEXPORT WINAPI NBoxCreate(DWORD dwVersion, HINSTANCE hInst,
	HWND hwndParent, LPCTSTR lpszText, LPCTSTR lpszTitle,
	LPCTSTR lpszButtonText, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPNBOX lpNBox = NULL;
	WNDCLASS wc;
	int nRows;
	int nColumns;
	int cxChar;
	int cyChar;

	if (dwVersion != NBOX_VERSION)
		fSuccess = TraceFALSE(NULL);
	
	else if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpszText == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpNBox = (LPNBOX) MemAlloc(NULL, sizeof(NBOX), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lpNBox->dwVersion = dwVersion;
		lpNBox->hInst = hInst;
		lpNBox->hTask = GetCurrentTask();
		lpNBox->lpszText = NULL;
		lpNBox->dwFlags = dwFlags;
		lpNBox->hwndNBox = NULL;
		lpNBox->fVisible = FALSE;
		lpNBox->hwndCancel = NULL;
		lpNBox->fCancelled = FALSE;
		lpNBox->hwndFocusOld = NULL;
		lpNBox->hCursorOld = NULL;

		if (hwndParent == NULL)
			hwndParent = GetDesktopWindow();

		if ((lpNBox->lpszText = StrDup(lpszText)) == NULL)
			fSuccess = TraceFALSE(NULL);
	}

	// register notify box class unless it has been already
	//
	if (fSuccess && GetClassInfo(lpNBox->hInst, NBOXCLASS, &wc) == 0)
	{
		wc.hCursor =		LoadCursor(NULL, IDC_ARROW);
		wc.hIcon =			(HICON) NULL;
		wc.lpszMenuName =	NULL;
		wc.hInstance =		lpNBox->hInst;
		wc.lpszClassName =	NBOXCLASS;
		wc.hbrBackground =	(HBRUSH) (COLOR_WINDOW + 1);
		wc.lpfnWndProc =	NBoxWndProc;
		wc.style =			0L;
		wc.cbWndExtra =		sizeof(lpNBox);
		wc.cbClsExtra =		0;

		if (!RegisterClass(&wc))
			fSuccess = TraceFALSE(NULL);
	}

	// create a notify box window
	//
	if (fSuccess && (lpNBox->hwndNBox = CreateWindowEx(
		WS_EX_DLGMODALFRAME,
		NBOXCLASS,
		(LPTSTR) lpszTitle,
		WS_POPUP | (lpszTitle == NULL ? 0 : WS_CAPTION), // | WS_DLGFRAME,
		0, 0, 0, 0, // we will calculate size and position later
#if 1
		hwndParent,
#else
		(HWND) NULL,
#endif
		(HMENU) NULL,
		lpNBox->hInst,
		lpNBox)) == NULL)
	{
		fSuccess = TraceFALSE(NULL);
	}

	// calculate avg char width and height
	//
	if (fSuccess)
	{
		HDC hdc = NULL;
		TEXTMETRIC tm;

		if ((hdc = GetDC(hwndParent)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if (!GetTextMetrics(hdc, &tm))
			fSuccess = TraceFALSE(NULL);

		else
		{
			cxChar = tm.tmAveCharWidth;
			cyChar = tm.tmHeight + tm.tmExternalLeading;
		}

		if (hdc != NULL && !ReleaseDC(hwndParent, hdc))
			fSuccess = TraceFALSE(NULL);
	}

	if (fSuccess)
	{
		// calculate size of text
		//
		if (StrGetRowColumnCount(lpszText, &nRows, &nColumns) != 0)
			fSuccess = TraceFALSE(NULL);

		nRows = min(nRows, NBOXMAXROWS);
		nColumns = min(nColumns, NBOXMAXCOLUMNS);
	}

	if (fSuccess)
	{
		int cxNBox;
		int cyNBox;
		int cxCancel;
		int cyCancel;
		int xCancel;
		int yCancel;

		// calculate window size
		//
		cxNBox = (nColumns + 10) * cxChar +
			2 * GetSystemMetrics(SM_CXBORDER);
		cyNBox = (nRows + 4) * cyChar +
			2 * GetSystemMetrics(SM_CYBORDER);

		// increase notify box size to accomodate caption
		//
		if (lpszTitle != NULL)
			cyNBox += GetSystemMetrics(SM_CYCAPTION);


		if (lpNBox->dwFlags & NB_CANCEL)
		{
			// calculate cancel button size
			//
			cxCancel = (40 * (int) LOWORD(GetDialogBaseUnits())) / 4;
			cyCancel = (14 * (int) HIWORD(GetDialogBaseUnits())) / 8;

			// increase notify box size to accomodate CANCEL button
			//
			cxNBox = max(cxNBox, cxCancel);
			cyNBox += cyCancel * 2;

			// calculate cancel button position
			//
			xCancel = (cxNBox - cxCancel) / 2;
			yCancel = (cyNBox - (cyCancel * 2));

			// modify cancel button position to accomodate caption
			//
			if (lpszTitle != NULL)
				yCancel -= GetSystemMetrics(SM_CYCAPTION);
		}

		// set window size
		//
		if (!SetWindowPos(lpNBox->hwndNBox,
			NULL, 0, 0, cxNBox, cyNBox,
			SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOREDRAW | SWP_NOZORDER))
			fSuccess = TraceFALSE(NULL);

		// center the window on its parent
		//
		else if (WndCenterWindow(lpNBox->hwndNBox, hwndParent, 0, 0) != 0)
			fSuccess = TraceFALSE(NULL);

		else if ((lpNBox->dwFlags & NB_CANCEL))
		{
			// create cancel button as child of notify box
			//
			if ((lpNBox->hwndCancel = CreateWindowEx(
				0L,
				TEXT("BUTTON"),
				lpszButtonText == NULL ? TEXT("Cancel") : lpszButtonText,
				WS_CHILD | WS_VISIBLE | BS_DEFPUSHBUTTON,
				xCancel, yCancel, cxCancel, cyCancel,
				(HWND) lpNBox->hwndNBox,
				(HMENU) IDCANCEL,
				lpNBox->hInst,
				NULL)) == NULL)
			{
				fSuccess = TraceFALSE(NULL);
			}

			// subclass the cancel button, so the escape key pushes it
			//
			else if (EscButtInit(lpNBox->hwndCancel, 0) != 0)
				fSuccess = TraceFALSE(NULL);
		}
	}

	if (!fSuccess)
	{
		NBoxDestroy(NBoxGetHandle(lpNBox));
		lpNBox = NULL;
	}

	return fSuccess ? NBoxGetHandle(lpNBox) : NULL;
}

// NBoxDestroy - notify box destructor
//		<hNBox>				(i) handle returned from NBoxCreate
// return 0 if success
//
int DLLEXPORT WINAPI NBoxDestroy(HNBOX hNBox)
{
	BOOL fSuccess = TRUE;
	LPNBOX lpNBox;

	if (NBoxHide(hNBox) != 0)
		fSuccess = TraceFALSE(NULL);

	else if ((lpNBox = NBoxGetPtr(hNBox)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		// destroy text string
		//
		if (lpNBox->lpszText != NULL &&
			StrDupFree(lpNBox->lpszText) != 0)
			fSuccess = TraceFALSE(NULL);
		else
			lpNBox->lpszText = NULL;

		// destroy cancel button
		//
		if (lpNBox->hwndCancel != NULL)
		{
			if (EscButtTerm(lpNBox->hwndCancel) != 0)
				fSuccess = TraceFALSE(NULL);

			if (!DestroyWindow(lpNBox->hwndCancel))
				fSuccess = TraceFALSE(NULL);
			else
				lpNBox->hwndCancel = NULL;
		}

		// destroy notify box
		//
		if (lpNBox->hwndNBox != NULL &&
			!DestroyWindow(lpNBox->hwndNBox))
			fSuccess = TraceFALSE(NULL);
		else
			lpNBox->hwndNBox = NULL;

		// destroy control struct
		//
		if ((lpNBox = MemFree(NULL, lpNBox)) != NULL)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// NBoxShow - show notify box
//		<hNBox>				(i) handle returned from NBoxCreate
// return 0 if success
//
int DLLEXPORT WINAPI NBoxShow(HNBOX hNBox)
{
	BOOL fSuccess = TRUE;
	LPNBOX lpNBox;

	if ((lpNBox = NBoxGetPtr(hNBox)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpNBox->fVisible)
		; // already visible, so no need to do anything else

	else
	{
		HWND hwndParent = GetParent(lpNBox->hwndNBox);

		// disable other windows in this task if necessary
		//
		if (lpNBox->dwFlags & NB_TASKMODAL)
		{
			HTASK hTaskParent;

			if (hwndParent != NULL)
				hTaskParent = GetWindowTask(hwndParent);
			else
				hTaskParent = lpNBox->hTask;

			if (WndEnableTaskWindows(hTaskParent, FALSE, lpNBox->hwndNBox) != 0)
				TraceFALSE(NULL); // not a fatal error
		}

		// otherwise just disable parent of notify box
		//
		else if (hwndParent != NULL)
			EnableWindow(hwndParent, FALSE);

		if (fSuccess)
		{
			// show the window
			//
			ShowWindow(lpNBox->hwndNBox, TRUE ? SW_SHOW : SW_SHOWNA);
			UpdateWindow(lpNBox->hwndNBox);
			lpNBox->fVisible = TRUE;

			// set focus to cancel button if necessary
			//
			if (lpNBox->dwFlags & NB_CANCEL && lpNBox->hwndCancel != NULL)
				lpNBox->hwndFocusOld = SetFocus(lpNBox->hwndCancel);
		}

		// display hourglass cursor if specified
		//
		if (fSuccess && lpNBox->dwFlags & NB_HOURGLASS)
			lpNBox->hCursorOld = GfxShowHourglass(lpNBox->hwndNBox);
	}

	return fSuccess ? 0 : -1;
}

// NBoxHide - hide notify box
//		<hNBox>				(i) handle returned from NBoxCreate
// return 0 if success
//
int DLLEXPORT WINAPI NBoxHide(HNBOX hNBox)
{
	BOOL fSuccess = TRUE;
	LPNBOX lpNBox;

	if ((lpNBox = NBoxGetPtr(hNBox)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (!lpNBox->fVisible)
		; // already hidden, so no need to do anything else

	else
	{
		HWND hwndParent = GetParent(lpNBox->hwndNBox);

		// enable other windows in this task if necessary
		//
		if (lpNBox->dwFlags & NB_TASKMODAL)
		{
			HTASK hTaskParent;

			if (hwndParent != NULL)
				hTaskParent = GetWindowTask(hwndParent);
			else
				hTaskParent = lpNBox->hTask;

			if (WndEnableTaskWindows(hTaskParent, TRUE, NULL) != 0)
				TraceFALSE(NULL); // not a fatal error
		}

		// otherwise just enable parent of notify box
		//
		else if (hwndParent != NULL)
			EnableWindow(hwndParent, TRUE);

		if (fSuccess)
		{
			// hide the window
			//
			ShowWindow(lpNBox->hwndNBox, SW_HIDE);
			UpdateWindow(lpNBox->hwndNBox);
			lpNBox->fVisible = FALSE;

			// remove focus from cancel button if necessary
			//
			if (lpNBox->dwFlags & NB_CANCEL &&
				lpNBox->hwndCancel != NULL &&
				GetFocus() == lpNBox->hwndCancel)
				SetFocus(lpNBox->hwndFocusOld);
		}

		// hide hourglass, restore old cursor
		//
		if (fSuccess && lpNBox->dwFlags & NB_HOURGLASS)
		{
			if (GfxHideHourglass(lpNBox->hCursorOld) != 0)
				fSuccess = TraceFALSE(NULL);
			else
				lpNBox->hCursorOld = NULL;
		}
	}

	return fSuccess ? 0 : -1;
}

// NBoxIsVisible - get visible flag
//		<hNBox>				(i) handle returned from NBoxCreate
// return TRUE if notify box is visible, FALSE if hidden
//
int DLLEXPORT WINAPI NBoxIsVisible(HNBOX hNBox)
{
	BOOL fSuccess = TRUE;
	LPNBOX lpNBox;

	if ((lpNBox = NBoxGetPtr(hNBox)) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? lpNBox->fVisible : FALSE;
}

// NBoxGetWindowHandle - get notify box window handle
//		<hNBox>				(i) handle returned from NBoxCreate
// return window handle (NULL if error)
//
HWND DLLEXPORT WINAPI NBoxGetWindowHandle(HNBOX hNBox)
{
	BOOL fSuccess = TRUE;
	LPNBOX lpNBox;

	if ((lpNBox = NBoxGetPtr(hNBox)) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? lpNBox->hwndNBox : NULL;
}

// NBoxSetText - set notify box message text
//		<hNBox>				(i) handle returned from NBoxCreate
//		<lpszText>			(i) message to be displayed
//			NULL				do not modify text
//		<lpszTitle>			(i) notify box caption
//			NULL				do not modify caption
// return 0 if success
//
// NOTE: The size of the notify box is not changed by this function,
// even if <lpszText> is larger than when NBoxCreate() was called.
//
int DLLEXPORT WINAPI NBoxSetText(HNBOX hNBox, LPCTSTR lpszText, LPCTSTR lpszTitle)
{
	BOOL fSuccess = TRUE;
	LPNBOX lpNBox;

	if ((lpNBox = NBoxGetPtr(hNBox)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		if (lpszTitle != NULL)
		{
			// set new title
			//
			SetWindowText(lpNBox->hwndNBox, lpszTitle);
		}

		if (lpszText != NULL)
		{
			// dispose of previous text
			//
			if (lpNBox->lpszText != NULL)
			{
				if (StrDupFree(lpNBox->lpszText) != 0)
					fSuccess = TraceFALSE(NULL);
				else
					lpNBox->lpszText = NULL;
			}

			// set new text
			//
			if ((lpNBox->lpszText = StrDup(lpszText)) == NULL)
				fSuccess = TraceFALSE(NULL);
		}

		// update the display
		//
		if (fSuccess)
		{

			RECT rc;

			// assume entire client area needs to be painted
			//
			GetClientRect(lpNBox->hwndNBox, &rc);

			// adjust client rect so cancel button is no repainted
			//
			if (lpNBox->dwFlags & NB_CANCEL)
			{
				int cyCancel = (14 * (int) HIWORD(GetDialogBaseUnits())) / 8;
				rc.bottom -= cyCancel * 2;
			}

			InvalidateRect(lpNBox->hwndNBox, &rc, TRUE);
			UpdateWindow(lpNBox->hwndNBox);
		}
	}

	return fSuccess ? 0 : -1;
}

// NBoxIsCancelled - get cancel flag, set when Cancel button pushed
//		<hNBox>				(i) handle returned from NBoxCreate
// return TRUE if notify box Cancel button pushed
//
BOOL DLLEXPORT WINAPI NBoxIsCancelled(HNBOX hNBox)
{
	BOOL fSuccess = TRUE;
	LPNBOX lpNBox;

	if ((lpNBox = NBoxGetPtr(hNBox)) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? lpNBox->fCancelled : FALSE;
}

// NBoxSetCancelled - set cancel flag
//		<hNBox>				(i) handle returned from NBoxCreate
//		<fCancelled>		(i) new value for cancel flag
// return 0 if success
//
int DLLEXPORT WINAPI NBoxSetCancelled(HNBOX hNBox, BOOL fCancelled)
{
	BOOL fSuccess = TRUE;
	LPNBOX lpNBox;

	if ((lpNBox = NBoxGetPtr(hNBox)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
		lpNBox->fCancelled = fCancelled;

	return fSuccess ? 0 : -1;
}

////
//	helper functions
////

// NBoxWndProc - window procedure for notify box
//
LRESULT DLLEXPORT CALLBACK NBoxWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	BOOL fSuccess = TRUE;
	LRESULT lResult;

	switch (msg)
	{
		case WM_NCCREATE:
			lResult = (LRESULT) HANDLE_WM_NCCREATE(hwnd, wParam, lParam, NBoxOnNCCreate);
			break;

		case WM_COMMAND:
			lResult = (LRESULT) HANDLE_WM_COMMAND(hwnd, wParam, lParam, NBoxOnCommand);
			break;

		case WM_PAINT:
			lResult = (LRESULT) HANDLE_WM_PAINT(hwnd, wParam, lParam, NBoxOnPaint);
			break;

		default:
			lResult = DefWindowProc(hwnd, msg, wParam, lParam);
			break;
	}
	
	return lResult;
}


// NBoxOnNCCreate - handler for WM_NCCREATE message
//
static BOOL NBoxOnNCCreate(HWND hwnd, CREATESTRUCT FAR* lpCreateStruct)
{
	LPNBOX lpNBox = (LPNBOX) lpCreateStruct->lpCreateParams;

	lpNBox->hwndNBox = hwnd;

	// store lpNBox in window extra bytes
	//
	SetWindowLongPtr(hwnd, 0, (LONG_PTR) lpNBox);

	return FORWARD_WM_NCCREATE(hwnd, lpCreateStruct, DefWindowProc);
}

// NBoxOnCommand - handler for WM_COMMAND message
//
static void NBoxOnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
	// retrieve lpNBox from window extra bytes
	//
	LPNBOX lpNBox = (LPNBOX) GetWindowLongPtr(hwnd, 0);

	if (id == IDCANCEL)
		if (codeNotify == BN_CLICKED)
			lpNBox->fCancelled = TRUE;

	return;
}

// NBoxOnPaint - handler for WM_PAINT message
//
static void NBoxOnPaint(HWND hwnd)
{
	BOOL fSuccess = TRUE;
	HDC hdc;
	PAINTSTRUCT ps;
	TEXTMETRIC tm;
	int cxChar;
	int cyChar;
	COLORREF crBkColorOld;
	COLORREF crTextColorOld;
	int nRows;
	int nColumns;

	// retrieve lpNBox from window extra bytes
	//
	LPNBOX lpNBox = (LPNBOX) GetWindowLongPtr(hwnd, 0);

	hdc = BeginPaint(hwnd, &ps);

	if (!GetTextMetrics(hdc, &tm))
		fSuccess = TraceFALSE(NULL);

	else
	{
		cxChar = tm.tmAveCharWidth;
		cyChar = tm.tmHeight + tm.tmExternalLeading;

		// set foreground and background text colors
		//
		crBkColorOld = SetBkColor(hdc, GetSysColor(COLOR_WINDOW));
		crTextColorOld = SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));

		if (StrGetRowColumnCount(lpNBox->lpszText, &nRows, &nColumns) != 0)
			fSuccess = TraceFALSE(NULL);

		else
		{
			int iRow;

			for (iRow = 0; iRow < nRows; ++iRow)
			{
				TCHAR szRow[NBOXMAXCOLUMNS + 1];

				if (StrGetRow(lpNBox->lpszText, iRow, szRow, SIZEOFARRAY(szRow)) != 0)
					fSuccess = TraceFALSE(NULL);

				else
				{
					int x = 5 * cxChar;
					int y = (iRow + 2) * cyChar;

					if (!TextOut(hdc, x, y, szRow, StrLen(szRow)))
						fSuccess = TraceFALSE(NULL);
				}
			}
		}

        //
        // Restore foreground and background in the right place
        //

        // restore foreground and background text colors
    	//
	    SetBkColor(hdc, crBkColorOld);
	    SetTextColor(hdc, crTextColorOld);
	}

    //
    // Call EndPaint just BeginPaint succeded
    //
    if( hdc )
	    EndPaint(hwnd, &ps);

	return;
}

// NBoxGetPtr - verify that nbox handle is valid,
//		<hNBox>				(i) handle returned from NBoxInit
// return corresponding nbox pointer (NULL if error)
//
static LPNBOX NBoxGetPtr(HNBOX hNBox)
{
	BOOL fSuccess = TRUE;
	LPNBOX lpNBox;

	if ((lpNBox = (LPNBOX) hNBox) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadWritePtr(lpNBox, sizeof(NBOX)))
		fSuccess = TraceFALSE(NULL);

#ifdef CHECKTASK
	// make sure current task owns the nbox handle
	//
	else if (lpNBox->hTask != GetCurrentTask())
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? lpNBox : NULL;
}

// NBoxGetHandle - verify that nbox pointer is valid,
//		<lpNBox>				(i) pointer to NBOX struct
// return corresponding nbox handle (NULL if error)
//
static HNBOX NBoxGetHandle(LPNBOX lpNBox)
{
	BOOL fSuccess = TRUE;
	HNBOX hNBox;

	if ((hNBox = (HNBOX) lpNBox) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hNBox : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\list.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// list.h - interface for linked list functions in list.c
////

#ifndef __LIST_H__
#define __LIST_H__

#include "winlocal.h"

#define LIST_VERSION 0x00000100

// handle to a list
//
DECLARE_HANDLE32(HLIST);

// handle to a list node
//
DECLARE_HANDLE32(HLISTNODE);

// list data element
//
typedef LPVOID LISTELEM;

#ifdef __cplusplus
extern "C" {
#endif

////
// list constructor and destructor functions
////

// ListCreate - list constructor
//		<dwVersion>			(i) must be LIST_VERSION
// 		<hInst>				(i) instance handle of calling module
// return new list handle (NULL if error)
//
HLIST DLLEXPORT WINAPI ListCreate(DWORD dwVersion, HINSTANCE hInst);

// ListDestroy - list destructor
//		<hList>				(i) handle returned from ListCreate
// return 0 if success
// NOTE: any nodes within list are destroyed also
//
int DLLEXPORT WINAPI ListDestroy(HLIST hList);

////
// list status functions
////

// ListGetCount - return count of nodes in list
//		<hList>				(i) handle returned from ListCreate
// return node count (-1 if error)
//
long DLLEXPORT WINAPI ListGetCount(HLIST hList);

// ListIsEmpty - return TRUE if list has no nodes
//		<hList>				(i) handle returned from ListCreate
// return TRUE or FALSE
//
BOOL DLLEXPORT WINAPI ListIsEmpty(HLIST hList);

////
// list iteration functions
////

// ListGetHeadNode - get list head node
//		<hList>				(i) handle returned from ListCreate
// return list head node (NULL if error or empty)
//
HLISTNODE DLLEXPORT WINAPI ListGetHeadNode(HLIST hList);

// ListGetTailNode - get list tail node
//		<hList>				(i) handle returned from ListCreate
// return list tail node (NULL if error or empty)
//
HLISTNODE DLLEXPORT WINAPI ListGetTailNode(HLIST hList);

// ListGetNextNode - get node which follows specified node
//		<hList>				(i) handle returned from ListCreate
//		<hNode>				(i) node handle
// return node which follows specified node (NULL if error or none)
//
HLISTNODE DLLEXPORT WINAPI ListGetNextNode(HLIST hList, HLISTNODE hNode);

// ListGetPrevNode - get node which precedes specified node
//		<hList>				(i) handle returned from ListCreate
//		<hNode>				(i) node handle
// return node which precedes specified node (NULL if error or none)
//
HLISTNODE DLLEXPORT WINAPI ListGetPrevNode(HLIST hList, HLISTNODE hNode);

////
// list element insertion functions
////

// ListAddHead - add new node with data <elem> to head of list,
//		<hList>				(i) handle returned from ListCreate
//		<elem>				(i) new data element
// returns new node handle (NULL if error)
//
HLISTNODE DLLEXPORT WINAPI ListAddHead(HLIST hList, LISTELEM elem);

// ListAddTail - add new node with data <elem> to tail of list,
//		<hList>				(i) handle returned from ListCreate
//		<elem>				(i) new data element
// returns new node handle (NULL if error)
//
HLISTNODE DLLEXPORT WINAPI ListAddTail(HLIST hList, LISTELEM elem);

// ListInsertBefore - insert new node with data <elem> before specified node
//		<hList>				(i) handle returned from ListCreate
//		<hNode>				(i) node handle
//		<elem>				(i) new data element
// return handle to new node (NULL if error)
//
HLISTNODE DLLEXPORT WINAPI ListInsertBefore(HLIST hList, HLISTNODE hNode, LISTELEM elem);

// ListInsertAfter - insert new node with data <elem> after specified node
//		<hList>				(i) handle returned from ListCreate
//		<hNode>				(i) node handle
//		<elem>				(i) new data element
// return handle to new node (NULL if error)
//
HLISTNODE DLLEXPORT WINAPI ListInsertAfter(HLIST hList, HLISTNODE hNode, LISTELEM elem);

////
// list element removal functions
////

// ListRemoveHead - remove node from head of list,
//		<hList>				(i) handle returned from ListCreate
// returns removed data element
//
LISTELEM DLLEXPORT WINAPI ListRemoveHead(HLIST hList);

// ListRemoveTail - remove node from tail of list,
//		<hList>				(i) handle returned from ListCreate
// returns removed data element
//
LISTELEM DLLEXPORT WINAPI ListRemoveTail(HLIST hList);

// ListRemoveAt - remove specified node from list,
//		<hList>				(i) handle returned from ListCreate
//		<hNode>				(i) node handle
// returns removed data element
//
LISTELEM DLLEXPORT WINAPI ListRemoveAt(HLIST hList, HLISTNODE hNode);

// ListRemoveAll - remove all nodes from list
//		<hList>				(i) handle returned from ListCreate
// return 0 if success
//
int DLLEXPORT WINAPI ListRemoveAll(HLIST hList);

////
// list element get/set value functions
////

// ListGetHead - return data element from head node
//		<hList>				(i) handle returned from ListCreate
// return data element
//
LISTELEM DLLEXPORT WINAPI ListGetHead(HLIST hList);

// ListGetTail - return data element from tail node
//		<hList>				(i) handle returned from ListCreate
// return data element
//
LISTELEM DLLEXPORT WINAPI ListGetTail(HLIST hList);

// ListGetAt - return data element from specified node
//		<hList>				(i) handle returned from ListCreate
//		<hNode>				(i) node handle
// return data element
//
LISTELEM DLLEXPORT WINAPI ListGetAt(HLIST hList, HLISTNODE hNode);

// ListSetAt - set data element in specified node
//		<hList>				(i) handle returned from ListCreate
//		<hNode>				(i) node handle
//		<elem>				(i) data element
// return 0 if success
//
int DLLEXPORT WINAPI ListSetAt(HLIST hList, HLISTNODE hNode, LISTELEM elem);

////
// list search functions
////

// ListFind - search list for node with matching element
//		<hList>				(i) handle returned from ListCreate
//		<elem>				(i) data element to match
//		<hNodeAfter>		(i) node handle to begin search after
//			NULL				start search at head node
// return matching node (NULL if error or none)
//
HLISTNODE DLLEXPORT WINAPI ListFind(HLIST hList, LISTELEM elem, HLISTNODE hNodeAfter);

// ListFindIndex - search list for nth node in list
//		<hList>				(i) handle returned from ListCreate
//		<nIndex>			(i) zero based index into list
// return handle to node (NULL if error)
//
HLISTNODE DLLEXPORT WINAPI ListFindIndex(HLIST hList, long nIndex);

#ifdef __cplusplus
}
#endif

#endif // __LIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\loadlib.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// loadlib.h - interface for loadlib functions in loadlib.c
////

#ifndef __LOADLIB_H__
#define __LOADLIB_H__

#include "winlocal.h"

#ifdef __cplusplus
extern "C" {
#endif

// LoadLibraryPath - load specified module into address space of calling process
//		<lpLibFileName>		(i) address of filename of executable module
//		<hInst>				(i) module handle used to get library path
//			NULL				use module used to create calling process
//		<dwFlags>			(i) reserved; must be zero
// return handle of loaded module (NULL if error)
//
// NOTE: This function behaves like the standard LoadLibrary(), except that
// the first attempt to load <lpLibFileName> is made by constructing an
// explicit path name, using GetModuleFileName(hInst, ...) to supply the
// drive and directory, and using <lpLibFileName> to supply the file name
// and extension. If the first attempt fails, LoadLibrary(lpLibFileName)
// is called.
//
HINSTANCE DLLEXPORT WINAPI LoadLibraryPath(LPCTSTR lpLibFileName, HINSTANCE hInst, DWORD dwFlags);

#ifdef __cplusplus
}
#endif

#endif // __LOADLIB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\mem.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// mem.h - interface for memory functions in mem.c
////

#ifndef __MEM_H__
#define __MEM_H__

#include "winlocal.h"

#include <memory.h>

#define MEM_VERSION 0x00000106

// handle to mem engine
//
DECLARE_HANDLE32(HMEM);

// <dwFlags> values in MemAlloc
//
#define MEM_NOZEROINIT		0x00000001

#ifdef __cplusplus
extern "C" {
#endif

// MemInit - initialize mem engine
//		<dwVersion>			(i) must be MEM_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<dwFlags>			(i) control flags
//			0					reserved; must be zero
// return handle (NULL if error)
//
#ifdef NOTRACE
#define MemInit(dwVersion, hInst) 1
#else
HMEM DLLEXPORT WINAPI MemInit(DWORD dwVersion, HINSTANCE hInst);
#endif

// MemTerm - shut down mem engine
//		<hMem>				(i) handle returned from MemInit or NULL
// return 0 if success
//
#ifdef NOTRACE
#define MemTerm(hMem) 0
#else
int DLLEXPORT WINAPI MemTerm(HMEM hMem);
#endif

// MemAlloc - allocate memory block
//		<hMem>				(i) handle returned from MemInit or NULL
//		<sizBlock>			(i) size of block, in bytes
//		<dwFlags>			(i) control flags
//			MEM_NOZEROINIT		do not initialize block
// return pointer to block, NULL if error
//
#ifdef NOTRACE
#ifdef _WIN32
#define MemAlloc(hMem, sizBlock, dwFlags) \
	HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizBlock)
#else
#define MemAlloc(hMem, sizBlock, dwFlags) \
	GlobalAllocPtr(GMEM_MOVEABLE | GMEM_ZEROINIT, sizBlock)
#endif
#else
#define MemAlloc(hMem, sizBlock, dwFlags) \
	MemAllocEx(hMem, sizBlock, dwFlags, TEXT(__FILE__), __LINE__)
LPVOID DLLEXPORT WINAPI MemAllocEx(HMEM hMem, long sizBlock, DWORD dwFlags,
	LPCTSTR lpszFileName, unsigned uLineNumber);
#endif

// MemReAlloc - reallocate memory block
//		<hMem>				(i) handle returned from MemInit or NULL
//		<lpBlock>			(i) pointer returned from MemAlloc
//		<sizBlock>			(i) new size of block, in bytes
//		<dwFlags>			(i) control flags
//			MEM_NOZEROINIT		do not initialize block
// return pointer to block, NULL if error
//
#ifdef NOTRACE
#ifdef _WIN32
#define MemReAlloc(hMem, lpBlock, sizBlock, dwFlags) \
	HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, lpBlock, sizBlock)
#else
#define MemReAlloc(hMem, lpBlock, sizBlock, dwFlags) \
	GlobalReAllocPtr(lpBlock, sizBlock, GMEM_MOVEABLE | GMEM_ZEROINIT)
#endif
#else
#define MemReAlloc(hMem, lpBlock, sizBlock, dwFlags) \
	MemReAllocEx(hMem, lpBlock, sizBlock, dwFlags, TEXT(__FILE__), __LINE__)
LPVOID DLLEXPORT WINAPI MemReAllocEx(HMEM hMem, LPVOID lpBlock, long sizBlock,
	DWORD dwFlags, LPCTSTR lpszFileName, unsigned uLineNumber);
#endif

// MemFree - free memory block
//		<hMem>				(i) handle returned from MemInit or NULL
//		<lpBlock>			(i) pointer returned from MemAlloc
// return NULL if success, lpBlock if error
//
// NOTE: the return value of this function is designed to allow the
// user of this function to easily assign NULL to a freed pointer,
// as the following example demonstrates:
//
//		if ((p = MemFree(hMem, p)) != NULL)
//			; // error
//
#ifdef NOTRACE
#ifdef _WIN32
#define MemFree(hMem, lpBlock) \
	(!HeapFree(GetProcessHeap(), 0, lpBlock) ? lpBlock : NULL)
#else
#define MemFree(hMem, lpBlock) \
	(GlobalFreePtr(lpBlock) == 0 ? NULL : lpBlock)
#endif
#else
#define MemFree(hMem, lpBlock) \
	MemFreeEx(hMem, lpBlock, TEXT(__FILE__), __LINE__)
LPVOID DLLEXPORT WINAPI MemFreeEx(HMEM hMem, LPVOID lpBlock,
	LPCTSTR lpszFileName, unsigned uLineNumber);
#endif

// MemSize - get size of memory block
//		<hMem>				(i) handle returned from MemInit or NULL
//		<lpBlock>			(i) pointer returned from MemAlloc
// return size of block if success, 0 if error
//
#ifdef NOTRACE
#ifdef _WIN32
#define MemSize(hMem, lpBlock) \
	(max(0, (long) HeapSize(GetProcessHeap(), 0, lpBlock)))
#else
#define MemSize(hMem, lpBlock) \
	((long) GlobalSize(GlobalPtrHandle(lpBlock)))
#endif
#else
long DLLEXPORT WINAPI MemSize(HMEM hMem, LPVOID lpBlock);
#endif

////
//	memory buffer macros/functions
////

#ifdef _WIN32

#define MemCCpy(dest, src, count) _fmemccpy(dest, src, c, count)
#define MemChr(buf, count) _fmemchr(buf, c, count)
#define MemCmp(buf1, buf2, count) _fmemcmp(buf1, buf2, count)
#define MemCpy(dest, src, count) _fmemcpy(dest, src, count) // CopyMemory(dest, src, (DWORD) count)
#define MemICmp(buf1, buf2, count) _fmemicmp(buf1, buf2, count)
#define MemMove(dest, src, count) _fmemmove(dest, src, count) // MoveMemory(dest, src, (DWORD) count)
#define MemSet(dest, c, count) _fmemset(dest, c, count) // FillMemory(dest, (DWORD) count, (BYTE) c)

#else

#define MemCCpy(dest, src, count) MemCCpyEx(dest, src, count)
void _huge* DLLEXPORT MemCCpyEx(void _huge* dest, const void _huge* src, int c, long count);

#define MemChr(buf, count) MemChrEx(buf, count)
void _huge* DLLEXPORT MemChrEx(void _huge* buf, int c, long count);

#define MemCmp(buf1, buf2, count) MemCmpEx(buf1, buf2, count)
int DLLEXPORT MemCmpEx(const void _huge* buf1, void _huge* buf2, long count);

#define MemCpy(dest, src, count) MemCpyEx(dest, src, count)
void _huge* DLLEXPORT MemCpyEx(void _huge* dest, const void _huge* src, long count);

#define MemICmp(buf1, buf2, count) MemICmpEx(buf1, buf2, count)
int DLLEXPORT MemICmpEx(const void _huge* buf1, void _huge* buf2, long count);

#define MemMove(dest, src, count) MemMoveEx(dest, src, count)
void _huge* DLLEXPORT MemMoveEx(void _huge* dest, const void _huge* src, long count);

#define MemSet(dest, c, count) MemSetEx(dest, c, count)
void _huge* DLLEXPORT MemSetEx(void _huge* dest, int c, long count);

#endif

////
//	LocalAlloc macros
////

#define LocalPtrHandle(lp) \
	((HLOCAL) LocalHandle(lp))
#define LocalLockPtr(lp) \
	((BOOL) (LocalLock(LocalPtrHandle(lp)) != NULL))
#define LocalUnlockPtr(lp) \
	LocalUnlock(LocalPtrHandle(lp))

#define LocalAllocPtr(flags, cb) \
	(LocalLock(LocalAlloc((flags), (cb))))
#define LocalReAllocPtr(lp, cbNew, flags)	\
	(LocalUnlockPtr(lp), LocalLock(LocalReAlloc(LocalPtrHandle(lp) , (cbNew), (flags))))
#define LocalFreePtr(lp) \
	(LocalUnlockPtr(lp), (INT64) LocalFree(LocalPtrHandle(lp)))

#ifdef __cplusplus
}
#endif

#endif // __MEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\nbox.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// nbox.h - interface for notify box functions in nbox.c
////

#ifndef __NBOX_H__
#define __NBOX_H__

#include "winlocal.h"

#define NBOX_VERSION 0x00000106

// handle to notify box
//
DECLARE_HANDLE32(HNBOX);

#define NB_CANCEL			0x0001
#define NB_TASKMODAL		0x0002
#define NB_HOURGLASS		0x0004

#ifdef __cplusplus
extern "C" {
#endif

// NBoxCreate - notify box constructor
//		<dwVersion>			(i) must be NBOX_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<hwndParent>		(i) window which will own the notify box
//			NULL				desktop window
//		<lpszText>			(i) message to be displayed
//		<lpszTitle>			(i) notify box caption
//			NULL				no caption
//		<lpszButtonText>	(i) pushbutton text, if NB_CANCEL specified
//			NULL				use default text ("Cancel")
//		<dwFlags>			(i)	control flags
//			NB_CANCEL			notify box includes Cancel pushbutton
//			NB_TASKMODAL		disable parent task's top-level windows
//			NB_HOURGLASS		show hourglass cursor while notify box visible
// return notify box handle (NULL if error)
//
// NOTE: NBoxCreate creates the window but does not show it.
// See NBoxShow and NBoxHide.
// The size of the notify box is determined by the number of
// lines in <lpszText>, and the length of the longest line.
//
HNBOX DLLEXPORT WINAPI NBoxCreate(DWORD dwVersion, HINSTANCE hInst,
	HWND hwndParent, LPCTSTR lpszText, LPCTSTR lpszTitle,
	LPCTSTR lpszButtonText, DWORD dwFlags);

// NBoxDestroy - notify box destructor
//		<hNBox>				(i) handle returned from NBoxCreate
// return 0 if success
//
int DLLEXPORT WINAPI NBoxDestroy(HNBOX hNBox);

// NBoxShow - show notify box
//		<hNBox>				(i) handle returned from NBoxCreate
// return 0 if success
//
int DLLEXPORT WINAPI NBoxShow(HNBOX hNBox);

// NBoxHide - hide notify box
//		<hNBox>				(i) handle returned from NBoxCreate
// return 0 if success
//
int DLLEXPORT WINAPI NBoxHide(HNBOX hNBox);

// NBoxIsVisible - get visible flag
//		<hNBox>				(i) handle returned from NBoxCreate
// return TRUE if notify box is visible, FALSE if hidden
//
int DLLEXPORT WINAPI NBoxIsVisible(HNBOX hNBox);

// NBoxGetWindowHandle - get notify box window handle
//		<hNBox>				(i) handle returned from NBoxCreate
// return window handle (NULL if error)
//
HWND DLLEXPORT WINAPI NBoxGetWindowHandle(HNBOX hNBox);

// NBoxSetText - set notify box message text
//		<hNBox>				(i) handle returned from NBoxCreate
//		<lpszText>			(i) message to be displayed
//			NULL				do not modify text
//		<lpszTitle>			(i) notify box caption
//			NULL				do not modify caption
// return 0 if success
//
// NOTE: The size of the notify box is not changed by this function,
// even if <lpszText> is larger than when NBoxCreate() was called.
//
int DLLEXPORT WINAPI NBoxSetText(HNBOX hNBox, LPCTSTR lpszText, LPCTSTR lpszTitle);

// NBoxIsCancelled - get cancel flag, set when Cancel button pushed
//		<hNBox>				(i) handle returned from NBoxCreate
// return TRUE if notify box Cancel button pushed
//
BOOL DLLEXPORT WINAPI NBoxIsCancelled(HNBOX hNBox);

// NBoxSetCancelled - set cancel flag
//		<hNBox>				(i) handle returned from NBoxCreate
//		<fCancelled>		(i) new value for cancel flag
// return 0 if success
//
int DLLEXPORT WINAPI NBoxSetCancelled(HNBOX hNBox, BOOL fCancelled);

#ifdef __cplusplus
}
#endif

#endif // __NBOX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\paola.c ===
// here is a rough summary of the code you will need.
//


// point to the AVWAV project for these
// link with AVWAV.LIB, ship with AVWAV.DLL
//
#include "wav.h"
#include "strmio.h"
#include "mulaw.h"
#include "vox.h"

//
///////////////////// create a new wav stream /////////////////////////
//

// get a pointer to an new stream from somewhere
//
LPSTREAM lpStream = PaolaCreateStream();
DWORD adwInfo[3] = { lpStream, 0L, 0L };

// choose one of these audio formats
//
LPWAVEFORMATEX lpwfx = VoxFormat(NULL, 6000); // low quality
LPWAVEFORMATEX lpwfx = VoxFormat(NULL, 8000); // medium quality, default for messages
LPWAVEFORMATEX lpwfx = MulawFormat(NULL, 8000); // high quality, default for prompts and greetings

// create a new wav stream
//
HWAV hWav = WavOpen(WAV_VERSION, AfxGetInstanceHandle(),
	NULL, lpwfx, StreamIOProc, adwInfo, WAV_CREATE | WAV_READWRITE);
	
// when the user presses the Record button
//
WavRecord(hWav, -1, WAV_RECORDASYNCH);

// when the user presses the Stop button
//
WavStop(hWav);

// when the user presses the Play button
//
WavPlay(hWav, -1, WAV_PLAYASYNCH);

// when you are finished
//
WavClose(hWav);

//
///////////////////// play an existing wav stream /////////////////////////
//

// get a pointer to an existing stream from somewhere
//
LPSTREAM lpStream = PaolaGetStream();
DWORD adwInfo[3] = { lpStream, 0L, 0L };

// or open an existing wav stream
//
HWAV hWav = WavOpen(WAV_VERSION, AfxGetInstanceHandle(),
	NULL, NULL, StreamIOProc, adwInfo, WAV_READ);

// when the user presses the Play button
//
WavPlay(hWav, -1, WAV_PLAYASYNCH);

// when the user presses the Stop button
//
WavStop(hWav);

// when you are finished
//
WavClose(hWav);

	

//
///////////////////// other functions you might want to try ///////////////
//

WavGetLength
WavGetPosition
WavSetPosition
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\queue.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// queue.c - queue functions
////

#include "winlocal.h"

#include "queue.h"
#include "list.h"
#include "mem.h"
#include "trace.h"

////
//	private definitions
////

// queue
//
typedef struct QUEUE
{
	DWORD dwVersion;
	HINSTANCE hInst;
	HTASK hTask;
	HLIST hList;
} QUEUE, FAR *LPQUEUE;

// helper functions
//
static LPQUEUE QueueGetPtr(HQUEUE hQueue);
static HQUEUE QueueGetHandle(LPQUEUE lpQueue);

////
//	public functions
////

////
// queue constructor and destructor functions
////

// QueueCreate - queue constructor
//		<dwVersion>			(i) must be QUEUE_VERSION
// 		<hInst>				(i) instance handle of calling module
// return new queue handle (NULL if error)
//
HQUEUE DLLEXPORT WINAPI QueueCreate(DWORD dwVersion, HINSTANCE hInst)
{
	BOOL fSuccess = TRUE;
	LPQUEUE lpQueue = NULL;

	if (dwVersion != QUEUE_VERSION)
		fSuccess = TraceFALSE(NULL);

	else if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);

	// memory is allocated such that the client app owns it
	//
	else if ((lpQueue = (LPQUEUE) MemAlloc(NULL, sizeof(QUEUE), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpQueue->hList = ListCreate(LIST_VERSION, hInst)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		// initially the queue is empty
		//
		lpQueue->dwVersion = dwVersion;
		lpQueue->hInst = hInst;
		lpQueue->hTask = GetCurrentTask();
	}

	if (!fSuccess)
	{
		QueueDestroy(QueueGetHandle(lpQueue));
		lpQueue = NULL;
	}


	return fSuccess ? QueueGetHandle(lpQueue) : NULL;
}

// QueueDestroy - queue destructor
//		<hQueue>				(i) handle returned from QueueCreate
// return 0 if success
//
int DLLEXPORT WINAPI QueueDestroy(HQUEUE hQueue)
{
	BOOL fSuccess = TRUE;
	LPQUEUE lpQueue;

	if ((lpQueue = QueueGetPtr(hQueue)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (ListDestroy(lpQueue->hList) != 0)
		fSuccess = TraceFALSE(NULL);

	else if ((lpQueue = MemFree(NULL, lpQueue)) != NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}

////
// queue status functions
////

// QueueGetCount - return count of nodes in queue
//		<hQueue>				(i) handle returned from QueueCreate
// return node count (-1 if error)
//
long DLLEXPORT WINAPI QueueGetCount(HQUEUE hQueue)
{
	BOOL fSuccess = TRUE;
	LPQUEUE lpQueue;
	long cNodes;

	if ((lpQueue = QueueGetPtr(hQueue)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((cNodes = ListGetCount(lpQueue->hList)) < 0)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? cNodes : -1;
}

// QueueIsEmpty - return TRUE if queue has no nodes
//		<hQueue>				(i) handle returned from QueueCreate
// return TRUE or FALSE
//
BOOL DLLEXPORT WINAPI QueueIsEmpty(HQUEUE hQueue)
{
	BOOL fSuccess = TRUE;
	LPQUEUE lpQueue;

	if ((lpQueue = QueueGetPtr(hQueue)) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? ListIsEmpty(lpQueue->hList) : TRUE;
}

////
// queue element insertion functions
////

// QueueAddTail - add new node with data <elem> to end of queue
//		<hQueue>			(i) handle returned from QueueCreate
//		<elem>				(i) new data element
// returns 0 if success
//
int DLLEXPORT WINAPI QueueAddTail(HQUEUE hQueue, QUEUEELEM elem)
{
	BOOL fSuccess = TRUE;
	LPQUEUE lpQueue;

	if ((lpQueue = QueueGetPtr(hQueue)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (ListAddTail(lpQueue->hList, elem) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}

////
// queue element removal functions
////

// QueueRemoveHead - remove node from head of queue
//		<hQueue>				(i) handle returned from QueueCreate
// returns removed data element (NULL of error or empty)
//
QUEUEELEM DLLEXPORT WINAPI QueueRemoveHead(HQUEUE hQueue)
{
	BOOL fSuccess = TRUE;
	LPQUEUE lpQueue;

	if ((lpQueue = QueueGetPtr(hQueue)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (ListIsEmpty(lpQueue->hList))
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? (QUEUEELEM) ListRemoveHead(lpQueue->hList) : NULL;
}

// QueueRemoveAll - remove all nodes from queue
//		<hQueue>				(i) handle returned from QueueCreate
// return 0 if success
//
int DLLEXPORT WINAPI QueueRemoveAll(HQUEUE hQueue)
{
	BOOL fSuccess = TRUE;
	LPQUEUE lpQueue;

	if ((lpQueue = QueueGetPtr(hQueue)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (ListRemoveAll(lpQueue->hList) != 0)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}

////
// queue element get value functions
////

// QueuePeek - return node from head of queue, but leave it on queue
//		<hQueue>				(i) handle returned from QueueCreate
// returns data element (NULL if error or empty)
//
QUEUEELEM DLLEXPORT WINAPI QueuePeek(HQUEUE hQueue)
{
	BOOL fSuccess = TRUE;
	LPQUEUE lpQueue;

	if ((lpQueue = QueueGetPtr(hQueue)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (ListIsEmpty(lpQueue->hList))
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? (QUEUEELEM) ListGetHead(lpQueue->hList) : NULL;
}

////
//	private functions
////

// QueueGetPtr - verify that queue handle is valid,
//		<hQueue>				(i) handle returned from QueueCreate
// return corresponding queue pointer (NULL if error)
//
static LPQUEUE QueueGetPtr(HQUEUE hQueue)
{
	BOOL fSuccess = TRUE;
	LPQUEUE lpQueue;

	if ((lpQueue = (LPQUEUE) hQueue) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadWritePtr(lpQueue, sizeof(QUEUE)))
		fSuccess = TraceFALSE(NULL);

#ifdef CHECKTASK
	// make sure current task owns the queue handle
	//
	else if (lpQueue->hTask != GetCurrentTask())
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? lpQueue : NULL;
}

// QueueGetHandle - verify that queue pointer is valid,
//		<lpQueue>			(i) pointer to QUEUE struct
// return corresponding queue handle (NULL if error)
//
static HQUEUE QueueGetHandle(LPQUEUE lpQueue)
{
	BOOL fSuccess = TRUE;
	HQUEUE hQueue;

	if ((hQueue = (HQUEUE) lpQueue) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hQueue : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\queue.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// queue.h - interface for queue functions in queue.c
////

#ifndef __QUEUE_H__
#define __QUEUE_H__

#include "winlocal.h"

#define QUEUE_VERSION 0x00000100

// handle to a queue
//
DECLARE_HANDLE32(HQUEUE);

// queue data element
//
typedef LPVOID QUEUEELEM;

#ifdef __cplusplus
extern "C" {
#endif

////
// queue constructor and destructor functions
////

// QueueCreate - queue constructor
//		<dwVersion>			(i) must be QUEUE_VERSION
// 		<hInst>				(i) instance handle of calling module
// return new queue handle (NULL if error)
//
HQUEUE DLLEXPORT WINAPI QueueCreate(DWORD dwVersion, HINSTANCE hInst);

// QueueDestroy - queue destructor
//		<hQueue>				(i) handle returned from QueueCreate
// return 0 if success
//
int DLLEXPORT WINAPI QueueDestroy(HQUEUE hQueue);

////
// queue status functions
////

// QueueGetCount - return count of nodes in queue
//		<hQueue>				(i) handle returned from QueueCreate
// return node count (-1 if error)
//
long DLLEXPORT WINAPI QueueGetCount(HQUEUE hQueue);

// QueueIsEmpty - return TRUE if queue has no nodes
//		<hQueue>				(i) handle returned from QueueCreate
// return TRUE or FALSE
//
BOOL DLLEXPORT WINAPI QueueIsEmpty(HQUEUE hQueue);

////
// queue element insertion functions
////

// QueueAddTail - add new node with data <elem> to end of queue
//		<hQueue>			(i) handle returned from QueueCreate
//		<elem>				(i) new data element
// returns 0 if success
//
int DLLEXPORT WINAPI QueueAddTail(HQUEUE hQueue, QUEUEELEM elem);

////
// queue element removal functions
////

// QueueRemoveHead - remove node from head of queue
//		<hQueue>				(i) handle returned from QueueCreate
// returns removed data element (NULL of error or empty)
//
QUEUEELEM DLLEXPORT WINAPI QueueRemoveHead(HQUEUE hQueue);

// QueueRemoveAll - remove all nodes from queue
//		<hQueue>				(i) handle returned from QueueCreate
// return 0 if success
//
int DLLEXPORT WINAPI QueueRemoveAll(HQUEUE hQueue);

////
// queue element get value functions
////

// QueuePeek - return node from head of queue, but leave it on queue
//		<hQueue>				(i) handle returned from QueueCreate
// returns data element (NULL if error or empty)
//
QUEUEELEM DLLEXPORT WINAPI QueuePeek(HQUEUE hQueue);

#ifdef __cplusplus
}
#endif

#endif // __QUEUE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\res.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// res.h - interface for resource functions in res.c
////

#ifndef __RES_H__
#define __RES_H__

#include "winlocal.h"

#include "commdlg.h"

#define RES_VERSION 0x00000107

// handle to res engine
//
DECLARE_HANDLE32(HRES);

#ifdef __cplusplus
extern "C" {
#endif

// ResInit - initialize resource engine
//		<dwVersion>			(i) must be RES_VERSION
// 		<hInst>				(i) instance handle of calling module
// return handle (NULL if error)
//
HRES DLLEXPORT WINAPI ResInit(DWORD dwVersion, HINSTANCE hInst);

// ResTerm - shut down resource engine
//		<hRes>				(i) handle returned from ResInit
// return 0 if success
//
int DLLEXPORT WINAPI ResTerm(HRES hRes);

// ResAddModule - add module resources to res engine
//		<hRes>				(i) handle returned from ResInit
//		<hInst>				(i) instance handle of resource module
// return 0 if success
//
int DLLEXPORT WINAPI ResAddModule(HRES hRes, HINSTANCE hInst);

// ResRemoveModule - remove module resources from res engine
//		<hRes>				(i) handle returned from ResInit
//		<hInst>				(i) instance handle of resource module
// return 0 if success
//
int DLLEXPORT WINAPI ResRemoveModule(HRES hRes, HINSTANCE hInst);

// ResLoadAccelerators - load specified accelerator table
//		<hRes>				(i) handle returned from ResInit
//		<lpszTableName>		(i) name of accelerator table
//								or MAKEINTRESOURCE(idAccel)
// return accel handle if success, otherwise NULL
// NOTE: see documentation for LoadAccelerators function
//
HACCEL DLLEXPORT WINAPI ResLoadAccelerators(HRES hRes, LPCTSTR lpszTableName);

// ResLoadBitmap - load specified bitmap resource
//		<hRes>				(i) handle returned from ResInit
//			NULL				load pre-defined Windows bitmap
//		<lpszBitmap>		(i) name of bitmap resource
//								or MAKEINTRESOURCE(idBitmap)
//								or <OBM_xxx> if hRes is NULL
// return bitmap handle if success, otherwise NULL
// NOTE: see documentation for LoadBitmap function
//
HBITMAP DLLEXPORT WINAPI ResLoadBitmap(HRES hRes, LPCTSTR lpszBitmap);

// ResLoadCursor - load specified cursor resource
//		<hRes>				(i) handle returned from ResInit
//			NULL				load pre-defined Windows cursor
//		<lpszCursor>		(i) name of cursor resource
//								or MAKEINTRESOURCE(idCursor)
//								or <IDC_xxx> if hRes is NULL
// return cursor handle if success, otherwise NULL
// NOTE: see documentation for LoadCursor function
//
HCURSOR DLLEXPORT WINAPI ResLoadCursor(HRES hRes, LPCTSTR lpszCursor);

// ResLoadIcon - load specified icon resource
//		<hRes>				(i) handle returned from ResInit
//			NULL				load pre-defined Windows icon
//		<lpszIcon>			(i) name of icon resource
//								or MAKEINTRESOURCE(idIcon)
//								or <IDI_xxx> if hRes is NULL
// return icon handle if success, otherwise NULL
// NOTE: see documentation for LoadIcon function
//
HICON DLLEXPORT WINAPI ResLoadIcon(HRES hRes, LPCTSTR lpszIcon);

// ResLoadMenu - load specified menu resource
//		<hRes>				(i) handle returned from ResInit
//		<lpszMenu>			(i) name of menu resource
//								or MAKEINTRESOURCE(idMenu)
// return menu handle if success, otherwise NULL
// NOTE: see documentation for LoadMenu function
//
HMENU DLLEXPORT WINAPI ResLoadMenu(HRES hRes, LPCTSTR lpszMenu);

// ResFindResource - find specified resource
//		<hRes>				(i) handle returned from ResInit
//		<lpszName>			(i) resource name
//								or MAKEINTRESOURCE(idResource)
//		<lpszType>			(i) resource type (RT_xxx)
// return resource handle if success, otherwise NULL
// NOTE: see documentation for FindResource function
//
HRSRC DLLEXPORT WINAPI ResFindResource(HRES hRes, LPCTSTR lpszName, LPCTSTR lpszType);

// ResLoadResource - load specified resource
//		<hRes>				(i) handle returned from ResInit
//		<hrsrc>				(i) handle returned from ResFindResource
// return resource handle if success, otherwise NULL
// NOTE: see documentation for LoadResource function
//
HGLOBAL DLLEXPORT WINAPI ResLoadResource(HRES hRes, HRSRC hrsrc);

// ResLoadString - load specified string resource
//		<hRes>				(i) handle returned from ResInit
//		<idResource>		(i) string id
//		<lpszBuffer>		(o) buffer to receive the string
//		<cbBuffer>			(i) buffer size in bytes
// return number of bytes copied to <lpszBuffer>, -1 if error, 0 if not found
// NOTE: see documentation for LoadString function
//
int DLLEXPORT WINAPI ResLoadString(HRES hRes, UINT idResource, LPTSTR lpszBuffer, int cbBuffer);

// ResString - return specified string resource
//		<hRes>				(i) handle returned from ResInit
//		<idResource>		(i) string id
// return ptr to string in next available string buffer (NULL if error)
// NOTE: If the the specified id in <idResource> is not found,
// a string in the form "String #<idResource>" is returned.
//
LPTSTR DLLEXPORT WINAPI ResString(HRES hRes, UINT idResource);

// ResCreateDialog - create modeless dialog box from template resource
//		<hRes>				(i) handle returned from ResInit
//		<lpszDlgTemp>		(i) dialog box template name
//								or MAKEINTRESOURCE(idDlg)
//		<hwndOwner>			(i) handle of owner window
//		<dlgproc>			(i) instance address of dialog box procedure
// return dialog box window handle (NULL if error)
// NOTE: see documentation for CreateDialog function
//
HWND DLLEXPORT WINAPI ResCreateDialog(HRES hRes,
	LPCTSTR lpszDlgTemp, HWND hwndOwner, DLGPROC dlgproc);

// ResCreateDialogIndirect - create modeless dialog box from template resource
//		<hRes>				(i) handle returned from ResInit
//		<lpvDlgTemp>		(i) dialog box header structure
//		<hwndOwner>			(i) handle of owner window
//		<dlgproc>			(i) instance address of dialog box procedure
// return dialog box window handle (NULL if error)
// NOTE: see documentation for CreateDialogIndirect function
//
HWND DLLEXPORT WINAPI ResCreateDialogIndirect(HRES hRes,
	const void FAR* lpvDlgTemp, HWND hwndOwner, DLGPROC dlgproc);

// ResCreateDialogParam - create modeless dialog box from template resource
//		<hRes>				(i) handle returned from ResInit
//		<lpszDlgTemp>		(i) dialog box template name
//								or MAKEINTRESOURCE(idDlg)
//		<hwndOwner>			(i) handle of owner window
//		<dlgproc>			(i) instance address of dialog box procedure
//		<lParamInit>		(i) initialization value
// return dialog box window handle (NULL if error)
// NOTE: see documentation for CreateDialogParam function
//
HWND DLLEXPORT WINAPI ResCreateDialogParam(HRES hRes,
	LPCTSTR lpszDlgTemp, HWND hwndOwner, DLGPROC dlgproc, LPARAM lParamInit);

// ResCreateDialogIndirectParam - create modeless dialog box from template resource
//		<hRes>				(i) handle returned from ResInit
//		<lpvDlgTemp>		(i) dialog box header structure
//		<hwndOwner>			(i) handle of owner window
//		<dlgproc>			(i) instance address of dialog box procedure
//		<lParamInit>		(i) initialization value
// return dialog box window handle (NULL if error)
// NOTE: see documentation for CreateDialogIndirectParam function
//
HWND DLLEXPORT WINAPI ResCreateDialogIndirectParam(HRES hRes,
	const void FAR* lpvDlgTemp, HWND hwndOwner, DLGPROC dlgproc, LPARAM lParamInit);

// ResDialogBox - create modal dialog box from template resource
//		<hRes>				(i) handle returned from ResInit
//		<lpszDlgTemp>		(i) dialog box template name
//								or MAKEINTRESOURCE(idDlg)
//		<hwndOwner>			(i) handle of owner window
//		<dlgproc>			(i) instance address of dialog box procedure
// return dialog box return code (-1 if error)
// NOTE: see documentation for DialogBox function
//
INT_PTR DLLEXPORT WINAPI ResDialogBox(HRES hRes,
	LPCTSTR lpszDlgTemp, HWND hwndOwner, DLGPROC dlgproc);

// ResDialogBoxIndirect - create modal dialog box from template resource
//		<hRes>				(i) handle returned from ResInit
//		<hglbDlgTemp>		(i) dialog box header structure
//		<hwndOwner>			(i) handle of owner window
//		<dlgproc>			(i) instance address of dialog box procedure
// return dialog box return code (-1 if error)
// NOTE: see documentation for DialogBoxIndirect function
//
INT_PTR DLLEXPORT WINAPI ResDialogBoxIndirect(HRES hRes,
	HGLOBAL hglbDlgTemp, HWND hwndOwner, DLGPROC dlgproc);

// ResDialogBoxParam - create modal dialog box from template resource
//		<hRes>				(i) handle returned from ResInit
//		<lpszDlgTemp>		(i) dialog box template name
//								or MAKEINTRESOURCE(idDlg)
//		<hwndOwner>			(i) handle of owner window
//		<dlgproc>			(i) instance address of dialog box procedure
//		<lParamInit>		(i) initialization value
// return dialog box return code (-1 if error)
// NOTE: see documentation for DialogBoxParam function
//
INT_PTR DLLEXPORT WINAPI ResDialogBoxParam(HRES hRes,
	LPCTSTR lpszDlgTemp, HWND hwndOwner, DLGPROC dlgproc, LPARAM lParamInit);

// ResDialogBoxIndirectParam - create modal dialog box from template resource
//		<hRes>				(i) handle returned from ResInit
//		<hglbDlgTemp>		(i) dialog box header structure
//		<hwndOwner>			(i) handle of owner window
//		<dlgproc>			(i) instance address of dialog box procedure
//		<lParamInit>		(i) initialization value
// return dialog box return code (-1 if error)
// NOTE: see documentation for DialogBoxIndirectParam function
//
INT_PTR DLLEXPORT WINAPI ResDialogBoxIndirectParam(HRES hRes,
	HGLOBAL hglbDlgTemp, HWND hwndOwner, DLGPROC dlgproc, LPARAM lParamInit);

// ResGetOpenFileName - display common dialog for selecting a file to open
//		<hRes>				(i) handle returned from ResInit
//		<lpofn>				(i/o) address of struct with initialization data
// return non-zero if file chosen, 0 if error or no file chosen
// NOTE: see documentation for GetOpenFileName function
//
BOOL DLLEXPORT WINAPI ResGetOpenFileName(HRES hRes,	LPOPENFILENAME lpofn);

// ResGetSaveFileName - display common dialog for selecting a file to save
//		<hRes>				(i) handle returned from ResInit
//		<lpofn>				(i/o) address of struct with initialization data
// return non-zero if file chosen, 0 if error or no file chosen
// NOTE: see documentation for GetSaveFileName function
//
BOOL DLLEXPORT WINAPI ResGetSaveFileName(HRES hRes,	LPOPENFILENAME lpofn);

#ifdef __cplusplus
}
#endif

#endif // __RES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\roedit.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	roedit.c - read-only edit control functions
////

#include "winlocal.h"

#include "roedit.h"
#include "mem.h"
#include "str.h"
#include "trace.h"

////
//	private definitions
////

// roedit control struct
//
typedef struct ROEDIT
{
	WNDPROC lpfnEditWndProc;
	DWORD dwFlags;
} ROEDIT, FAR *LPROEDIT;

// helper functions
//
LRESULT DLLEXPORT CALLBACK ROEditWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
static int ROEditHighlightWord(HWND hwndEdit);

////
//	public functions
////

// ROEditInit - initialize read-only subclass from edit control
//		<hwndEdit>			(i) edit control to be subclassed
//		<dwFlags>			(i) subclass flags
//			ROEDIT_FOCUS		allow control to get focus
//			ROEDIT_MOUSE		allow control to process mouse messages
//			ROEDIT_COPY			allow text to be copied to clipboard
//			ROEDIT_SELECT		allow user to select any text with mouse
//			ROEDIT_SELECTWORD	allow user to select words with mouse
// return 0 if success
//
int DLLEXPORT WINAPI ROEditInit(HWND hwndEdit, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	WNDPROC lpfnROEditWndProc;
	HGLOBAL hROEdit;
	LPROEDIT lpROEdit;

	// copying text to the clipboard requires selecting text
	//
	if ((dwFlags & ROEDIT_COPY) &&
		!(dwFlags & ROEDIT_SELECT) &&
		!(dwFlags & ROEDIT_SELECTWORD))
	{
		dwFlags |= ROEDIT_SELECT;
	}

	// selecting text requires both getting focus and mouse usage
	//
	if ((dwFlags & ROEDIT_SELECT) ||
		(dwFlags & ROEDIT_SELECTWORD))
	{
		dwFlags |= ROEDIT_FOCUS;
		dwFlags |= ROEDIT_MOUSE;
	}

	if (hwndEdit == NULL)
		fSuccess = TraceFALSE(NULL);

	// get pointer to read-only subclass window proc
	//
	else if ((lpfnROEditWndProc =
		(WNDPROC) MakeProcInstance((FARPROC) ROEditWndProc,
		(HINSTANCE) GetWindowWordPtr(GetParent(hwndEdit), GWWP_HINSTANCE))) == NULL)
		fSuccess = TraceFALSE(NULL);

	// memory is allocated such that the client app owns it
	//
	else if ((hROEdit = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT,
			sizeof(ROEDIT))) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpROEdit = GlobalLock(hROEdit)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// store old window proc address
	//
	else if ((lpROEdit->lpfnEditWndProc =
		(WNDPROC) GetWindowLongPtr(hwndEdit, GWLP_WNDPROC)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// store flags
	//
	else if ((lpROEdit->dwFlags = dwFlags) != dwFlags)
		fSuccess = TraceFALSE(NULL);

	else if (GlobalUnlock(hROEdit), FALSE)
		;

	// store old window proc address as a property of the control window
	//
	else if (!SetProp(hwndEdit, TEXT("hROEdit"), hROEdit))
		fSuccess = TraceFALSE(NULL);

	// replace old window proc with new window proc
	//
	else if ( !SetWindowLongPtr(hwndEdit, GWLP_WNDPROC, (LONG_PTR) lpfnROEditWndProc) )
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}

// ROEditTerm - terminate read-only subclass from edit control
//		<hwndEdit>			(i) subclassed edit control
// return 0 if success
//
int DLLEXPORT WINAPI ROEditTerm(HWND hwndEdit)
{
	BOOL fSuccess = TRUE;
	WNDPROC lpfnROEditWndProc;
	HGLOBAL hROEdit;
	LPROEDIT lpROEdit;

	if (hwndEdit == NULL)
		fSuccess = TraceFALSE(NULL);

	// get pointer to read-only subclass window proc
	//
	else if ((lpfnROEditWndProc =
		(WNDPROC) GetWindowLongPtr(hwndEdit, GWLP_WNDPROC)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// retrieve old window proc address from window property
	//
	else if ((hROEdit = GetProp(hwndEdit, TEXT("hROEdit"))) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpROEdit = GlobalLock(hROEdit)) == NULL ||
		lpROEdit->lpfnEditWndProc == NULL)
		fSuccess = TraceFALSE(NULL);

	// replace new window proc with old window proc
	//
	else if ( !SetWindowLongPtr(hwndEdit, GWLP_WNDPROC, (LONG_PTR) lpROEdit->lpfnEditWndProc) )
		fSuccess = TraceFALSE(NULL);

	else if (GlobalUnlock(hROEdit), FALSE)
		;

    //
    // 
	else if (( hROEdit = RemoveProp(hwndEdit, TEXT("hROEdit"))) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (GlobalFree(hROEdit) != NULL)
		fSuccess = TraceFALSE(NULL);


	return fSuccess ? 0 : -1;
}

////
//	helper functions
////

// ROEditWndProc - window procedure for read-only edit control
//
LRESULT CALLBACK EXPORT ROEditWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	BOOL fSuccess = TRUE;
	LRESULT lResult;
	HGLOBAL hROEdit;
	LPROEDIT lpROEdit;

    //
    // we should verify the hwnd argument
    //

    if( NULL == hwnd )
    {
        return 0L;
    }

	// retrieve old window proc address from window property
	//
	if ((hROEdit = GetProp(hwnd, TEXT("hROEdit"))) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpROEdit = GlobalLock(hROEdit)) == NULL ||
		lpROEdit->lpfnEditWndProc == NULL)
		fSuccess = TraceFALSE(NULL);

	switch (msg)
	{
		// ignore all keyboard messages
		//
		case WM_KEYUP: 
		case WM_KEYDOWN:
		case WM_CHAR:
			lResult = 1L;
			break;

		// ignore clipboard messages which modify control text
		//
		case WM_CUT:
		case WM_PASTE:
			lResult = 1L;
			break;

		// ignore clipboard copy command
		// unless ROEDIT_COPY flag set
		//
		case WM_COPY:
			if (fSuccess && lpROEdit->dwFlags & ROEDIT_COPY)
				lResult = CallWindowProc(lpROEdit->lpfnEditWndProc, hwnd, msg, wParam, lParam);
			else
		 		lResult = 1L;
			break;

		// ignore all mouse messages
		// unless ROEDIT_MOUSE flag set
		//
		case WM_LBUTTONUP:
		case WM_LBUTTONDOWN:
		case WM_LBUTTONDBLCLK:
			if (fSuccess && lpROEdit->dwFlags & ROEDIT_MOUSE)
				lResult = CallWindowProc(lpROEdit->lpfnEditWndProc, hwnd, msg, wParam, lParam);
			else
		 		lResult = 1L;
			break;

		// do not allow the edit control to get the focus
		// unless ROEDIT_FOCUS flag set
		//
		case WM_GETDLGCODE:
			if (fSuccess && lpROEdit->dwFlags & ROEDIT_FOCUS)
				lResult = CallWindowProc(lpROEdit->lpfnEditWndProc, hwnd, msg, wParam, lParam);
			else
				lResult = 0L;
			break;

		default:
		{
			// call old window proc
			//
			if (fSuccess)
				lResult = CallWindowProc(lpROEdit->lpfnEditWndProc, hwnd, msg, wParam, lParam);
			else
				lResult = 0L;
		}
			break;
	}
	
	// highlight current word after mouse button up
	// if ROEDIT_SELECTWORD flag is set
	//
	if (fSuccess && (lpROEdit->dwFlags & ROEDIT_SELECTWORD))
		if (msg == WM_LBUTTONUP)
			ROEditHighlightWord(hwnd);

	if (fSuccess)
		GlobalUnlock(hROEdit);

	return lResult;
}

// ROEditHighlightWord - select current word within edit control
//		<hwndEdit>			(i) edit control window handle
// return 0 if success
//
static int ROEditHighlightWord(HWND hwndEdit)
{
	BOOL fSuccess = TRUE;
	DWORD dwSel = Edit_GetSel(hwndEdit);
	WORD wStart = LOWORD(dwSel);
	WORD wStop = HIWORD(dwSel);
	LPTSTR lpszText = NULL;
	int sizText;
	LPTSTR lpsz;

	if (hwndEdit == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((sizText = Edit_GetTextLength(hwndEdit)) <= 0)
		fSuccess = TraceFALSE(NULL);

	else if ((lpszText = (LPTSTR) MemAlloc(NULL, (sizText + 1) * sizeof(TCHAR), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (Edit_GetText(hwndEdit, lpszText, sizText + 1) != sizText)
		fSuccess = TraceFALSE(NULL);

	else
	{
		// adjust wStart to point to start of word
		//
		lpsz = lpszText + wStart;
		while (lpsz > lpszText && ChrIsWordDelimiter(*lpsz))
			lpsz = StrPrevChr(lpszText, lpsz), --wStart;
		while (lpsz > lpszText && !ChrIsWordDelimiter(*lpsz))
			lpsz = StrPrevChr(lpszText, lpsz), --wStart;
		if (lpsz > lpszText)
			lpsz = StrNextChr(lpsz), ++wStart;

		// adjust wStop to point to end of word
		//
		wStop = wStart;
		lpsz = lpszText + wStop;
		while (*lpsz != '\0' && !ChrIsWordDelimiter(*lpsz))
			lpsz = StrNextChr(lpsz), ++wStop;
		while (*lpsz != '\0' && ChrIsWordDelimiter(*lpsz))
			lpsz = StrNextChr(lpsz), ++wStop;

		// select the word
		//
		Edit_SetSel(hwndEdit, wStart, wStop);
	}

	if (lpszText != NULL &&
		(lpszText = MemFree(NULL, lpszText)) != NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\res.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	res.c - resource functions
////

#include "winlocal.h"

#include <stdlib.h>

#include "res.h"
#include "list.h"
#include "mem.h"
#include "str.h"
#include "strbuf.h"
#include "trace.h"

////
//	private definitions
////

// res control struct
//
typedef struct RES
{
	DWORD dwVersion;
	HINSTANCE hInst;
	HTASK hTask;
	HLIST hListModules;
	HSTRBUF hStrBuf;
	int cBuf;
	int sizBuf;
} RES, FAR *LPRES;

// helper functions
//
static LPRES ResGetPtr(HRES hRes);
static HRES ResGetHandle(LPRES lpRes);

////
//	public functions
////

// ResInit - initialize resource engine
//		<dwVersion>			(i) must be RES_VERSION
// 		<hInst>				(i) instance handle of calling module
// return handle (NULL if error)
//
HRES DLLEXPORT WINAPI ResInit(DWORD dwVersion, HINSTANCE hInst)
{
	BOOL fSuccess = TRUE;
	LPRES lpRes = NULL;

	if (dwVersion != RES_VERSION)
		fSuccess = TraceFALSE(NULL);
	
	else if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpRes = (LPRES) MemAlloc(NULL, sizeof(RES), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lpRes->dwVersion = dwVersion;
		lpRes->hInst = hInst;
		lpRes->hTask = GetCurrentTask();
		lpRes->hListModules = NULL;
		lpRes->hStrBuf = NULL;
		lpRes->cBuf = 8;
		lpRes->sizBuf = 512;

		// create linked list to hold instance handles of resource modules
		//
		if ((lpRes->hListModules = ListCreate(LIST_VERSION, hInst)) == NULL)
			fSuccess = TraceFALSE(NULL);

		// calling module is always the first resource module in list
		//
		else if (ResAddModule(ResGetHandle(lpRes), hInst) != 0)
			fSuccess = TraceFALSE(NULL);

		// create string buffer array to be used by ResString
		//
		else if ((lpRes->hStrBuf = StrBufInit(STRBUF_VERSION, hInst,
			lpRes->cBuf, lpRes->sizBuf)) == NULL)
			fSuccess = TraceFALSE(NULL);
	}

	if (!fSuccess)
	{
		ResTerm(ResGetHandle(lpRes));
		lpRes = NULL;
	}

	return fSuccess ? ResGetHandle(lpRes) : NULL;
}

// ResTerm - shut down resource engine
//		<hRes>				(i) handle returned from ResInit
// return 0 if success
//
int DLLEXPORT WINAPI ResTerm(HRES hRes)
{
	BOOL fSuccess = TRUE;
	LPRES lpRes;

	if ((lpRes = ResGetPtr(hRes)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		if (lpRes->hListModules != NULL)
		{
			if (ListDestroy(lpRes->hListModules) != 0)
				fSuccess = TraceFALSE(NULL);
			else
				lpRes->hStrBuf = NULL;
		}

		if (lpRes->hStrBuf != NULL)
		{
			if (StrBufTerm(lpRes->hStrBuf) != 0)
				fSuccess = TraceFALSE(NULL);
			else
				lpRes->hStrBuf = NULL;
		}

		if ((lpRes = MemFree(NULL, lpRes)) != NULL)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// ResAddModule - add module resources to res engine
//		<hRes>				(i) handle returned from ResInit
//		<hInst>				(i) instance handle of resource module
// return 0 if success
//
int DLLEXPORT WINAPI ResAddModule(HRES hRes, HINSTANCE hInst)
{
	BOOL fSuccess = TRUE;
	LPRES lpRes;

	if ((lpRes = ResGetPtr(hRes)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (ListAddHead(lpRes->hListModules, (LISTELEM) hInst) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}

// ResRemoveModule - remove module resources from res engine
//		<hRes>				(i) handle returned from ResInit
//		<hInst>				(i) instance handle of resource module
// return 0 if success
//
int DLLEXPORT WINAPI ResRemoveModule(HRES hRes, HINSTANCE hInst)
{
	BOOL fSuccess = TRUE;
	LPRES lpRes;
	HLISTNODE hNode;

	if ((lpRes = ResGetPtr(hRes)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((hNode = ListFind(lpRes->hListModules, (LISTELEM) hInst, NULL)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (ListRemoveAt(lpRes->hListModules, hNode) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}

// ResLoadAccelerators - load specified accelerator table
//		<hRes>				(i) handle returned from ResInit
//		<lpszTableName>		(i) name of accelerator table
//								or MAKEINTRESOURCE(idAccel)
// return accel handle if success, otherwise NULL
// NOTE: see documentation for LoadAccelerators function
//
HACCEL DLLEXPORT WINAPI ResLoadAccelerators(HRES hRes, LPCTSTR lpszTableName)
{
	BOOL fSuccess = TRUE;
	LPRES lpRes;
	HLISTNODE hNode;
	HACCEL hAccel = NULL;

	if ((lpRes = ResGetPtr(hRes)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// search each module for the specified resource
	//
	else for (hNode = ListGetHeadNode(lpRes->hListModules);
		fSuccess && hNode != NULL;
		hNode = ListGetNextNode(lpRes->hListModules, hNode))
	{
		HINSTANCE hInst;

		if ((hInst = (HINSTANCE) ListGetAt(lpRes->hListModules, hNode)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if ((hAccel = LoadAccelerators(hInst, lpszTableName)) != NULL)
			break; // resource found
	}

	return fSuccess ? hAccel : NULL;
}

// ResLoadBitmap - load specified bitmap resource
//		<hRes>				(i) handle returned from ResInit
//			NULL				load pre-defined Windows bitmap
//		<lpszBitmap>		(i) name of bitmap resource
//								or MAKEINTRESOURCE(idBitmap)
//								or <OBM_xxx> if hRes is NULL
// return bitmap handle if success, otherwise NULL
// NOTE: see documentation for LoadBitmap function
//
HBITMAP DLLEXPORT WINAPI ResLoadBitmap(HRES hRes, LPCTSTR lpszBitmap)
{
	BOOL fSuccess = TRUE;
	LPRES lpRes;
	HLISTNODE hNode;
	HBITMAP hBitmap = NULL;

	if (hRes == NULL)
	{
		// special case to handle pre-defined Windows resources
		//
		if ((hBitmap = LoadBitmap(NULL, lpszBitmap)) == NULL)
			fSuccess = TraceFALSE(NULL);
	}

	else if ((lpRes = ResGetPtr(hRes)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// search each module for the specified resource
	//
	else for (hNode = ListGetHeadNode(lpRes->hListModules);
		fSuccess && hNode != NULL;
		hNode = ListGetNextNode(lpRes->hListModules, hNode))
	{
		HINSTANCE hInst;

		if ((hInst = (HINSTANCE) ListGetAt(lpRes->hListModules, hNode)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if ((hBitmap = LoadBitmap(hInst, lpszBitmap)) != NULL)
			break; // resource found
	}

	return fSuccess ? hBitmap : NULL;
}

// ResLoadCursor - load specified cursor resource
//		<hRes>				(i) handle returned from ResInit
//			NULL				load pre-defined Windows cursor
//		<lpszCursor>		(i) name of cursor resource
//								or MAKEINTRESOURCE(idCursor)
//								or <IDC_xxx> if hRes is NULL
// return cursor handle if success, otherwise NULL
// NOTE: see documentation for LoadCursor function
//
HCURSOR DLLEXPORT WINAPI ResLoadCursor(HRES hRes, LPCTSTR lpszCursor)
{
	BOOL fSuccess = TRUE;
	LPRES lpRes;
	HLISTNODE hNode;
	HCURSOR hCursor = NULL;

	if (hRes == NULL)
	{
		// special case to handle pre-defined Windows resources
		//
		if ((hCursor = LoadCursor(NULL, lpszCursor)) == NULL)
			fSuccess = TraceFALSE(NULL);
	}

	else if ((lpRes = ResGetPtr(hRes)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// search each module for the specified resource
	//
	else for (hNode = ListGetHeadNode(lpRes->hListModules);
		fSuccess && hNode != NULL;
		hNode = ListGetNextNode(lpRes->hListModules, hNode))
	{
		HINSTANCE hInst;

		if ((hInst = (HINSTANCE) ListGetAt(lpRes->hListModules, hNode)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if ((hCursor = LoadCursor(hInst, lpszCursor)) != NULL)
			break; // resource found
	}

	return fSuccess ? hCursor : NULL;
}

// ResLoadIcon - load specified icon resource
//		<hRes>				(i) handle returned from ResInit
//			NULL				load pre-defined Windows icon
//		<lpszIcon>			(i) name of icon resource
//								or MAKEINTRESOURCE(idIcon)
//								or <IDI_xxx> if hRes is NULL
// return icon handle if success, otherwise NULL
// NOTE: see documentation for LoadIcon function
//
HICON DLLEXPORT WINAPI ResLoadIcon(HRES hRes, LPCTSTR lpszIcon)
{
	BOOL fSuccess = TRUE;
	LPRES lpRes;
	HLISTNODE hNode;
	HICON hIcon = NULL;

	if (hRes == NULL)
	{
		// special case to handle pre-defined Windows resources
		//
		if ((hIcon = LoadIcon(NULL, lpszIcon)) == NULL)
			fSuccess = TraceFALSE(NULL);
	}

	else if ((lpRes = ResGetPtr(hRes)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// search each module for the specified resource
	//
	else for (hNode = ListGetHeadNode(lpRes->hListModules);
		fSuccess && hNode != NULL;
		hNode = ListGetNextNode(lpRes->hListModules, hNode))
	{
		HINSTANCE hInst;

		if ((hInst = (HINSTANCE) ListGetAt(lpRes->hListModules, hNode)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if ((hIcon = LoadIcon(hInst, lpszIcon)) != NULL)
			break; // resource found
	}

	return fSuccess ? hIcon : NULL;
}

// ResLoadMenu - load specified menu resource
//		<hRes>				(i) handle returned from ResInit
//		<lpszMenu>			(i) name of menu resource
//								or MAKEINTRESOURCE(idMenu)
// return menu handle if success, otherwise NULL
// NOTE: see documentation for LoadMenu function
//
HMENU DLLEXPORT WINAPI ResLoadMenu(HRES hRes, LPCTSTR lpszMenu)
{
	BOOL fSuccess = TRUE;
	LPRES lpRes;
	HLISTNODE hNode;
	HMENU hMenu = NULL;

	if ((lpRes = ResGetPtr(hRes)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// search each module for the specified resource
	//
	else for (hNode = ListGetHeadNode(lpRes->hListModules);
		fSuccess && hNode != NULL;
		hNode = ListGetNextNode(lpRes->hListModules, hNode))
	{
		HINSTANCE hInst;

		if ((hInst = (HINSTANCE) ListGetAt(lpRes->hListModules, hNode)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if ((hMenu = LoadMenu(hInst, lpszMenu)) != NULL)
			break; // resource found
	}

	return fSuccess ? hMenu : NULL;
}

// ResFindResource - find specified resource
//		<hRes>				(i) handle returned from ResInit
//		<lpszName>			(i) resource name
//								or MAKEINTRESOURCE(idResource)
//		<lpszType>			(i) resource type (RT_xxx)
// return resource handle if success, otherwise NULL
// NOTE: see documentation for FindResource function
//
HRSRC DLLEXPORT WINAPI ResFindResource(HRES hRes, LPCTSTR lpszName, LPCTSTR lpszType)
{
	BOOL fSuccess = TRUE;
	LPRES lpRes;
	HLISTNODE hNode;
	HRSRC hrsrc = NULL;

	if ((lpRes = ResGetPtr(hRes)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// search each module for the specified resource
	//
	else for (hNode = ListGetHeadNode(lpRes->hListModules);
		fSuccess && hNode != NULL;
		hNode = ListGetNextNode(lpRes->hListModules, hNode))
	{
		HINSTANCE hInst;

		if ((hInst = (HINSTANCE) ListGetAt(lpRes->hListModules, hNode)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if ((hrsrc = FindResource(hInst, lpszName, lpszType)) != NULL)
			break; // resource found
	}

	return fSuccess ? hrsrc : NULL;
}

// ResLoadResource - load specified resource
//		<hRes>				(i) handle returned from ResInit
//		<hrsrc>				(i) handle returned from ResFindResource
// return resource handle if success, otherwise NULL
// NOTE: see documentation for LoadResource function
//
HGLOBAL DLLEXPORT WINAPI ResLoadResource(HRES hRes, HRSRC hrsrc)
{
	BOOL fSuccess = TRUE;
	LPRES lpRes;
	HLISTNODE hNode;
	HGLOBAL hGlobal = NULL;

	if ((lpRes = ResGetPtr(hRes)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// search each module for the specified resource
	//
	else for (hNode = ListGetHeadNode(lpRes->hListModules);
		fSuccess && hNode != NULL;
		hNode = ListGetNextNode(lpRes->hListModules, hNode))
	{
		HINSTANCE hInst;

		if ((hInst = (HINSTANCE) ListGetAt(lpRes->hListModules, hNode)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if ((hGlobal = LoadResource(hInst, hrsrc)) != NULL)
			break; // resource found
	}

	return fSuccess ? hGlobal : NULL;
}

// ResLoadString - load specified string resource
//		<hRes>				(i) handle returned from ResInit
//		<idResource>		(i) string id
//		<lpszBuffer>		(o) buffer to receive the string
//		<cbBuffer>			(i) buffer size in bytes
// return number of bytes copied to <lpszBuffer>, -1 if error, 0 if not found
// NOTE: see documentation for LoadString function
//
int DLLEXPORT WINAPI ResLoadString(HRES hRes, UINT idResource, LPTSTR lpszBuffer, int cbBuffer)
{
	BOOL fSuccess = TRUE;
	LPRES lpRes;
	HLISTNODE hNode;
	int nBytesCopied = 0;

	if ((lpRes = ResGetPtr(hRes)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpszBuffer == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (cbBuffer < 0)
		fSuccess = TraceFALSE(NULL);

	// search each module for the specified resource
	//
	else for (hNode = ListGetHeadNode(lpRes->hListModules);
		fSuccess && hNode != NULL;
		hNode = ListGetNextNode(lpRes->hListModules, hNode))
	{
		HINSTANCE hInst;

		if ((hInst = (HINSTANCE) ListGetAt(lpRes->hListModules, hNode)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if ((nBytesCopied = LoadString(hInst, idResource, lpszBuffer, cbBuffer)) > 0)
			break; // resource found
	}

	return fSuccess ? nBytesCopied : -1;
}

// ResString - return specified string resource
//		<hRes>				(i) handle returned from ResInit
//		<idResource>		(i) string id
// return ptr to string in next available string buffer (NULL if error)
// NOTE: If the the specified id in <idResource> is not found,
// a string in the form "String #<idResource>" is returned.
//
LPTSTR DLLEXPORT WINAPI ResString(HRES hRes, UINT idResource)
{
	BOOL fSuccess = TRUE;
	LPRES lpRes;
	LPTSTR lpszBuf;

	if ((lpRes = ResGetPtr(hRes)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpszBuf = StrBufGetNext(lpRes->hStrBuf)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (ResLoadString(hRes, idResource, lpszBuf, lpRes->sizBuf) <= 0)
	{
		// resource not found; construct a dummy string instead
		//
		wsprintf(lpszBuf, TEXT("String #%u"), idResource);
	}

	return fSuccess ? lpszBuf : NULL;
}

// ResCreateDialog - create modeless dialog box from template resource
//		<hRes>				(i) handle returned from ResInit
//		<lpszDlgTemp>		(i) dialog box template name
//								or MAKEINTRESOURCE(idDlg)
//		<hwndOwner>			(i) handle of owner window
//		<dlgproc>			(i) instance address of dialog box procedure
// return dialog box window handle (NULL if error)
// NOTE: see documentation for CreateDialog function
//
HWND DLLEXPORT WINAPI ResCreateDialog(HRES hRes,
	LPCTSTR lpszDlgTemp, HWND hwndOwner, DLGPROC dlgproc)
{
	BOOL fSuccess = TRUE;
	LPRES lpRes;
	HLISTNODE hNode;
	HWND hwndDlg = NULL;

	if ((lpRes = ResGetPtr(hRes)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// search each module for the specified resource
	//
	else for (hNode = ListGetHeadNode(lpRes->hListModules);
		fSuccess && hNode != NULL;
		hNode = ListGetNextNode(lpRes->hListModules, hNode))
	{
		HINSTANCE hInst;

		if ((hInst = (HINSTANCE) ListGetAt(lpRes->hListModules, hNode)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if ((hwndDlg = CreateDialog(hInst,
			lpszDlgTemp, hwndOwner, dlgproc)) != NULL)
			break; // resource found
	}

	return fSuccess ? hwndDlg : NULL;
}

// ResCreateDialogIndirect - create modeless dialog box from template resource
//		<hRes>				(i) handle returned from ResInit
//		<lpvDlgTemp>		(i) dialog box header structure
//		<hwndOwner>			(i) handle of owner window
//		<dlgproc>			(i) instance address of dialog box procedure
// return dialog box window handle (NULL if error)
// NOTE: see documentation for CreateDialogIndirect function
//
HWND DLLEXPORT WINAPI ResCreateDialogIndirect(HRES hRes,
	const void FAR* lpvDlgTemp, HWND hwndOwner, DLGPROC dlgproc)
{
	BOOL fSuccess = TRUE;
	LPRES lpRes;
	HLISTNODE hNode;
	HWND hwndDlg = NULL;

	if ((lpRes = ResGetPtr(hRes)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// search each module for the specified resource
	//
	else for (hNode = ListGetHeadNode(lpRes->hListModules);
		fSuccess && hNode != NULL;
		hNode = ListGetNextNode(lpRes->hListModules, hNode))
	{
		HINSTANCE hInst;

		if ((hInst = (HINSTANCE) ListGetAt(lpRes->hListModules, hNode)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if ((hwndDlg = CreateDialogIndirect(hInst,
			lpvDlgTemp, hwndOwner, dlgproc)) != NULL)
			break; // resource found
	}

	return fSuccess ? hwndDlg : NULL;
}

// ResCreateDialogParam - create modeless dialog box from template resource
//		<hRes>				(i) handle returned from ResInit
//		<lpszDlgTemp>		(i) dialog box template name
//								or MAKEINTRESOURCE(idDlg)
//		<hwndOwner>			(i) handle of owner window
//		<dlgproc>			(i) instance address of dialog box procedure
//		<lParamInit>		(i) initialization value
// return dialog box window handle (NULL if error)
// NOTE: see documentation for CreateDialogParam function
//
HWND DLLEXPORT WINAPI ResCreateDialogParam(HRES hRes,
	LPCTSTR lpszDlgTemp, HWND hwndOwner, DLGPROC dlgproc, LPARAM lParamInit)
{
	BOOL fSuccess = TRUE;
	LPRES lpRes;
	HLISTNODE hNode;
	HWND hwndDlg = NULL;

	if ((lpRes = ResGetPtr(hRes)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// search each module for the specified resource
	//
	else for (hNode = ListGetHeadNode(lpRes->hListModules);
		fSuccess && hNode != NULL;
		hNode = ListGetNextNode(lpRes->hListModules, hNode))
	{
		HINSTANCE hInst;

		if ((hInst = (HINSTANCE) ListGetAt(lpRes->hListModules, hNode)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if ((hwndDlg = CreateDialogParam(hInst,
			lpszDlgTemp, hwndOwner, dlgproc, lParamInit)) != NULL)
			break; // resource found
	}

	return fSuccess ? hwndDlg : NULL;
}

// ResCreateDialogIndirectParam - create modeless dialog box from template resource
//		<hRes>				(i) handle returned from ResInit
//		<lpvDlgTemp>		(i) dialog box header structure
//		<hwndOwner>			(i) handle of owner window
//		<dlgproc>			(i) instance address of dialog box procedure
//		<lParamInit>		(i) initialization value
// return dialog box window handle (NULL if error)
// NOTE: see documentation for CreateDialogIndirectParam function
//
HWND DLLEXPORT WINAPI ResCreateDialogIndirectParam(HRES hRes,
	const void FAR* lpvDlgTemp, HWND hwndOwner, DLGPROC dlgproc, LPARAM lParamInit)
{
	BOOL fSuccess = TRUE;
	LPRES lpRes;
	HLISTNODE hNode;
	HWND hwndDlg = NULL;

	if ((lpRes = ResGetPtr(hRes)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// search each module for the specified resource
	//
	else for (hNode = ListGetHeadNode(lpRes->hListModules);
		fSuccess && hNode != NULL;
		hNode = ListGetNextNode(lpRes->hListModules, hNode))
	{
		HINSTANCE hInst;

		if ((hInst = (HINSTANCE) ListGetAt(lpRes->hListModules, hNode)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if ((hwndDlg = CreateDialogIndirectParam(hInst,
			lpvDlgTemp, hwndOwner, dlgproc, lParamInit)) != NULL)
			break; // resource found
	}

	return fSuccess ? hwndDlg : NULL;
}

// ResDialogBox - create modal dialog box from template resource
//		<hRes>				(i) handle returned from ResInit
//		<lpszDlgTemp>		(i) dialog box template name
//								or MAKEINTRESOURCE(idDlg)
//		<hwndOwner>			(i) handle of owner window
//		<dlgproc>			(i) instance address of dialog box procedure
// return dialog box return code (-1 if error)
// NOTE: see documentation for DialogBox function
//
INT_PTR DLLEXPORT WINAPI ResDialogBox(HRES hRes,
	LPCTSTR lpszDlgTemp, HWND hwndOwner, DLGPROC dlgproc)
{
	BOOL fSuccess = TRUE;
	LPRES lpRes;
	HLISTNODE hNode;
	INT_PTR iRet = -1;

	if ((lpRes = ResGetPtr(hRes)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// search each module for the specified resource
	//
	else for (hNode = ListGetHeadNode(lpRes->hListModules);
		fSuccess && hNode != NULL;
		hNode = ListGetNextNode(lpRes->hListModules, hNode))
	{
		HINSTANCE hInst;

		if ((hInst = (HINSTANCE) ListGetAt(lpRes->hListModules, hNode)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if ((iRet = DialogBox(hInst,
			lpszDlgTemp, hwndOwner, dlgproc)) != -1)
			break; // resource found
	}

	return fSuccess ? iRet : -1;
}

// ResDialogBoxIndirect - create modal dialog box from template resource
//		<hRes>				(i) handle returned from ResInit
//		<hglbDlgTemp>		(i) dialog box header structure
//		<hwndOwner>			(i) handle of owner window
//		<dlgproc>			(i) instance address of dialog box procedure
// return dialog box return code (-1 if error)
// NOTE: see documentation for DialogBoxIndirect function
//
INT_PTR DLLEXPORT WINAPI ResDialogBoxIndirect(HRES hRes,
	HGLOBAL hglbDlgTemp, HWND hwndOwner, DLGPROC dlgproc)
{
	BOOL fSuccess = TRUE;
	LPRES lpRes;
	HLISTNODE hNode;
	INT_PTR iRet = -1;

	if ((lpRes = ResGetPtr(hRes)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// search each module for the specified resource
	//
	else for (hNode = ListGetHeadNode(lpRes->hListModules);
		fSuccess && hNode != NULL;
		hNode = ListGetNextNode(lpRes->hListModules, hNode))
	{
		HINSTANCE hInst;

		if ((hInst = (HINSTANCE) ListGetAt(lpRes->hListModules, hNode)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if ((iRet = DialogBoxIndirect(hInst,
			hglbDlgTemp, hwndOwner, dlgproc)) != -1)
			break; // resource found
	}

	return fSuccess ? iRet : -1;
}

// ResDialogBoxParam - create modal dialog box from template resource
//		<hRes>				(i) handle returned from ResInit
//		<lpszDlgTemp>		(i) dialog box template name
//								or MAKEINTRESOURCE(idDlg)
//		<hwndOwner>			(i) handle of owner window
//		<dlgproc>			(i) instance address of dialog box procedure
//		<lParamInit>		(i) initialization value
// return dialog box return code (-1 if error)
// NOTE: see documentation for DialogBoxParam function
//
INT_PTR DLLEXPORT WINAPI ResDialogBoxParam(HRES hRes,
	LPCTSTR lpszDlgTemp, HWND hwndOwner, DLGPROC dlgproc, LPARAM lParamInit)
{
	BOOL fSuccess = TRUE;
	LPRES lpRes;
	HLISTNODE hNode;
	INT_PTR iRet = -1;

	if ((lpRes = ResGetPtr(hRes)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// search each module for the specified resource
	//
	else for (hNode = ListGetHeadNode(lpRes->hListModules);
		fSuccess && hNode != NULL;
		hNode = ListGetNextNode(lpRes->hListModules, hNode))
	{
		HINSTANCE hInst;

		if ((hInst = (HINSTANCE) ListGetAt(lpRes->hListModules, hNode)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if ((iRet = DialogBoxParam(hInst,
			lpszDlgTemp, hwndOwner, dlgproc, lParamInit)) != -1)
			break; // resource found
	}

	return fSuccess ? iRet : -1;
}

// ResDialogBoxIndirectParam - create modal dialog box from template resource
//		<hRes>				(i) handle returned from ResInit
//		<hglbDlgTemp>		(i) dialog box header structure
//		<hwndOwner>			(i) handle of owner window
//		<dlgproc>			(i) instance address of dialog box procedure
//		<lParamInit>		(i) initialization value
// return dialog box return code (-1 if error)
// NOTE: see documentation for DialogBoxIndirectParam function
//
INT_PTR DLLEXPORT WINAPI ResDialogBoxIndirectParam(HRES hRes,
	HGLOBAL hglbDlgTemp, HWND hwndOwner, DLGPROC dlgproc, LPARAM lParamInit)
{
	BOOL fSuccess = TRUE;
	LPRES lpRes;
	HLISTNODE hNode;
	INT_PTR iRet = -1;

	if ((lpRes = ResGetPtr(hRes)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// search each module for the specified resource
	//
	else for (hNode = ListGetHeadNode(lpRes->hListModules);
		fSuccess && hNode != NULL;
		hNode = ListGetNextNode(lpRes->hListModules, hNode))
	{
		HINSTANCE hInst;

		if ((hInst = (HINSTANCE) ListGetAt(lpRes->hListModules, hNode)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if ((iRet = DialogBoxIndirectParam(hInst,
			hglbDlgTemp, hwndOwner, dlgproc, lParamInit)) != -1)
			break; // resource found
	}

	return fSuccess ? iRet : -1;
}

// ResGetOpenFileName - display common dialog for selecting a file to open
//		<hRes>				(i) handle returned from ResInit
//		<lpofn>				(i/o) address of struct with initialization data
// return non-zero if file chosen, 0 if error or no file chosen
// NOTE: see documentation for GetOpenFileName function
//
BOOL DLLEXPORT WINAPI ResGetOpenFileName(HRES hRes,	LPOPENFILENAME lpofn)
{
	BOOL fSuccess = TRUE;
	BOOL fFound = FALSE;
	LPRES lpRes;
	HLISTNODE hNode;

	if ((lpRes = ResGetPtr(hRes)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// search each module for the specified resource
	//
	else for (hNode = ListGetHeadNode(lpRes->hListModules);
		fSuccess && hNode != NULL;
		hNode = ListGetNextNode(lpRes->hListModules, hNode))
	{
		HINSTANCE hInst;

		if ((hInst = (HINSTANCE) ListGetAt(lpRes->hListModules, hNode)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if (FindResource(hInst, lpofn->lpTemplateName, RT_DIALOG) != NULL)
		{
			fFound = TRUE;

			lpofn->hInstance = hInst;

			if (!GetOpenFileName(lpofn))
				fSuccess = TraceFALSE(NULL);

			break;
		}
	}

	if (fSuccess && !fFound)
		fSuccess = TraceFALSE(NULL);

	return fSuccess;
}

// ResGetSaveFileName - display common dialog for selecting a file to save
//		<hRes>				(i) handle returned from ResInit
//		<lpofn>				(i/o) address of struct with initialization data
// return non-zero if file chosen, 0 if error or no file chosen
// NOTE: see documentation for GetSaveFileName function
//
BOOL DLLEXPORT WINAPI ResGetSaveFileName(HRES hRes,	LPOPENFILENAME lpofn)
{
	BOOL fSuccess = TRUE;
	BOOL fFound = FALSE;
	LPRES lpRes;
	HLISTNODE hNode;

	if ((lpRes = ResGetPtr(hRes)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// search each module for the specified resource
	//
	else for (hNode = ListGetHeadNode(lpRes->hListModules);
		fSuccess && hNode != NULL;
		hNode = ListGetNextNode(lpRes->hListModules, hNode))
	{
		HINSTANCE hInst;

		if ((hInst = (HINSTANCE) ListGetAt(lpRes->hListModules, hNode)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if (FindResource(hInst, lpofn->lpTemplateName, RT_DIALOG) != NULL)
		{
			fFound = TRUE;

			lpofn->hInstance = hInst;

			if (!GetSaveFileName(lpofn))
				fSuccess = TraceFALSE(NULL);

			break;
		}
	}

	if (fSuccess && !fFound)
		fSuccess = TraceFALSE(NULL);

	return fSuccess;
}

////
//	helper functions
////

// ResGetPtr - verify that res handle is valid,
//		<hRes>				(i) handle returned from ResInit
// return corresponding res pointer (NULL if error)
//
static LPRES ResGetPtr(HRES hRes)
{
	BOOL fSuccess = TRUE;
	LPRES lpRes;

	if ((lpRes = (LPRES) hRes) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadWritePtr(lpRes, sizeof(RES)))
		fSuccess = TraceFALSE(NULL);

#ifdef CHECKTASK
	// make sure current task owns the res handle
	//
	else if (lpRes->hTask != GetCurrentTask())
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? lpRes : NULL;
}

// ResGetHandle - verify that res pointer is valid,
//		<lpRes>				(i) pointer to RES struct
// return corresponding res handle (NULL if error)
//
static HRES ResGetHandle(LPRES lpRes)
{
	BOOL fSuccess = TRUE;
	HRES hRes;

	if ((hRes = (HRES) lpRes) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hRes : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\roedit.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// roedit.h - interface for read-only edit control functions in roedit.c
////

#ifndef __ROEDIT_H__
#define __ROEDIT_H__

#ifdef __cplusplus
extern "C" {
#endif

#include "winlocal.h"

#define ROEDIT_VERSION 0x00000100

#define ROEDIT_FOCUS			0x0001
#define ROEDIT_MOUSE			0x0002
#define ROEDIT_COPY				0x0004
#define ROEDIT_SELECT			0x0008
#define ROEDIT_SELECTWORD		0x0010

// ROEditInit - initialize read-only subclass from edit control
//		<hwndEdit>			(i) edit control to be subclassed
//		<dwFlags>			(i) subclass flags
//			ROEDIT_FOCUS		allow control to get focus
//			ROEDIT_MOUSE		allow control to process mouse messages
//			ROEDIT_COPY			allow text to be copied to clipboard
//			ROEDIT_SELECT		allow user to select any text with mouse
//			ROEDIT_SELECTWORD	allow user to select words with mouse
// return 0 if success
//
int DLLEXPORT WINAPI ROEditInit(HWND hwndEdit, DWORD dwFlags);

// ROEditTerm - terminate read-only subclass from edit control
//		<hwndEdit>			(i) subclassed edit control
// return 0 if success
//
int DLLEXPORT WINAPI ROEditTerm(HWND hwndEdit);

#ifdef __cplusplus
}
#endif

#endif // __ROEDIT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\sort.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// sort.h - interface for sort functions in sort.c
////

#ifndef __SORT_H__
#define __SORT_H__

#include "winlocal.h"

#define SORT_VERSION 0x00000106

// type required to hold the max number of sort elements
//
typedef long SORTSIZE_T;

#define SORT_INSERTIONSORT	0x00000001
#define SORT_BUBBLESORT		0x00000002
#define SORT_SHELLSORT		0x00000004
#define SORT_EXCHANGESORT	0x00000008
#define SORT_HEAPSORT		0x00000010
#define SORT_QUICKSORT		0x00000020

#ifdef __cplusplus
extern "C" {
#endif

// Sort - sort an array
//		<base>				(i/o) pointer to start of target array
//		<num>				(i) array size in elements
//		<width>				(i) element size in bytes
//		<compare>			(i) comparison function pointer
//			NULL				direct comparison (MemCmp)
//		<dwFlags>			(i) control flags
//			0					use default sort algorithm
//			SORT_INSERTIONSORT	use insertion sort algorithm
//			SORT_BUBBLESORT		use bubble sort algorithm
//			SORT_SHELLSORT		use shell sort algorithm
//			SORT_EXCHANGESORT	use exchange sort algorithm
//			SORT_HEAPSORT		use heap sort algorithm
//			SORT_QUICKSORT		use quick sort algorithm
// return 0 if success
//
int DLLEXPORT WINAPI Sort(LPVOID base, SORTSIZE_T num, SORTSIZE_T width,
	int (WINAPI *compare)(const LPVOID elem1, const LPVOID elem2),
	DWORD dwFlags);

// SortCompareBool - compare two boolean values during a sort
//		<lpBool1>			(i) a pointer to a boolean value
//		<lpBool2>			(i) a pointer to a boolean value
// return difference between <fBool1> and <fBool2> (0 if equal)
//
int DLLEXPORT WINAPI SortCompareBool(const LPVOID lpBool1, const LPVOID lpBool2);

// SortCompareShort - compare two short values during a sort
//		<lpShort1>			(i) a pointer to a short value
//		<lpShort2>			(i) a pointer to a short value
// return difference between <short1> and <short2> (0 if equal)
//
int DLLEXPORT WINAPI SortCompareShort(const LPVOID lpShort1, const LPVOID lpShort2);

// SortCompareLong - compare two long values during a sort
//		<lpLong1>			(i) a pointer to a long value
//		<lpLong2>			(i) a pointer to a long value
// return difference between <long1> and <long2> (0 if equal)
//
int DLLEXPORT WINAPI SortCompareLong(const LPVOID lpLong1, const LPVOID lpLong2);

// SortCompareNull - dummy comparison function
//		<lpv1>				(i) pointer to anything
//		<lpv2>				(i) pointer to anything
// return 0
//
int DLLEXPORT WINAPI SortCompareNull(const LPVOID lpv1, const LPVOID lpv2);

// SortCompareString - compare two strings during a sort
//		<lplpsz1>			(i) a pointer to a string pointer
//		<lplpsz2>			(i) a pointer to a string pointer
// return difference between <lpsz1> and <lpsz2> (0 if equal)
//
int DLLEXPORT WINAPI SortCompareString(const LPVOID lplpsz1, const LPVOID lplpsz2);

#ifdef __cplusplus
}
#endif

#endif // __SORT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\splash.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	splash.c - splash screen functions
////

#include "winlocal.h"

#include <stdlib.h>

#include "splash.h"
#include "gfx.h"
#include "mem.h"
#include "trace.h"
#include "wnd.h"

////
//	private definitions
////

#define SPLASHCLASS TEXT("SplashClass")

#define ID_TIMER_MINSHOW 100
#define ID_TIMER_MAXSHOW 200

// splash control struct
//
typedef struct SPLASH
{
	DWORD dwVersion;
	HINSTANCE hInst;
	HTASK hTask;
	UINT msMinShow;
	UINT msMaxShow;
	DWORD dwFlags;
	HWND hwndSplash;
	HBITMAP hBitmap;
	BOOL fVisible;
	BOOL fHideAfterMinShowTimer;
	BOOL fMinShowTimerSet;
	BOOL fMaxShowTimerSet;
} SPLASH, FAR *LPSPLASH;

// helper functions
//
LRESULT DLLEXPORT CALLBACK SplashWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
static BOOL SplashOnNCCreate(HWND hwnd, CREATESTRUCT FAR* lpCreateStruct);
static void SplashOnPaint(HWND hwnd);
static void SplashOnTimer(HWND hwnd, UINT id);
static UINT SplashOnNCHitTest(HWND hwnd, int x, int y);
static void SplashOnChar(HWND hwnd, UINT ch, int cRepeat);
static void SplashOnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags);
static void SplashOnRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags);
static int SplashAbort(LPSPLASH lpSplash);
static LPSPLASH SplashGetPtr(HSPLASH hSplash);
static HSPLASH SplashGetHandle(LPSPLASH lpSplash);

////
//	public functions
////

// SplashCreate - create splash screen
//		<dwVersion>			(i) must be SPLASH_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<hwndParent>		(i) window which will own the splash screen
//			NULL				desktop window
//		<hBitmapMono>		(i) bitmap to display on mono displays
//		<hBitmapColor>		(i) bitmap to display on color displays
//			0					use mono bitmap
//		<msMinShow>			(i) minimum time (ms) to show splash screen
//			0					no minimum time
//		<msMaxShow>			(i) maximum time (ms) to show splash screen
//			0					no maximum time
//		<dwFlags>			(i) control flags
//			SPLASH_SETFOCUS		SplashShow will set focus to splash screen
//			SPLASH_NOFOCUS		user cannot set focus to splash screen
//			SPLASH_ABORT		user can hide splash screen w/mouse or keybd
//			SPLASH_NOMOVE		user cannot move the splash screen w/mouse
// return handle (NULL if error)
//
// NOTE: SplashCreate creates the window but does not show it.
// See SplashShow and SplashHide
//
HSPLASH DLLEXPORT WINAPI SplashCreate(DWORD dwVersion, HINSTANCE hInst,
	HWND hwndParent, HBITMAP hBitmapMono, HBITMAP hBitmapColor,
	UINT msMinShow, UINT msMaxShow, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPSPLASH lpSplash = NULL;
	WNDCLASS wc;

	if (dwVersion != SPLASH_VERSION)
		fSuccess = TraceFALSE(NULL);
	
	else if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpSplash = (LPSPLASH) MemAlloc(NULL, sizeof(SPLASH), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lpSplash->dwVersion = dwVersion;
		lpSplash->hInst = hInst;
		lpSplash->hTask = GetCurrentTask();
		lpSplash->msMinShow = msMinShow;
		lpSplash->msMaxShow = msMaxShow;
		lpSplash->dwFlags = dwFlags;
		lpSplash->hwndSplash = NULL;
		lpSplash->hBitmap = NULL;
		lpSplash->fVisible = FALSE;
		lpSplash->fHideAfterMinShowTimer = FALSE;
		lpSplash->fMinShowTimerSet = FALSE;
		lpSplash->fMaxShowTimerSet = FALSE;

		if (hwndParent == NULL)
			hwndParent = GetDesktopWindow();

		// store either the mono or color bitmap, as appropriate
		//
		if (GfxDeviceIsMono(NULL) || hBitmapColor == 0)
			lpSplash->hBitmap = hBitmapMono;
		else
			lpSplash->hBitmap = hBitmapColor;
	}

	// register splash screen class unless it has been already
	//
	if (fSuccess && GetClassInfo(lpSplash->hInst, SPLASHCLASS, &wc) == 0)
	{
		wc.hCursor =		LoadCursor(NULL, IDC_ARROW);
		wc.hIcon =			(HICON) NULL;
		wc.lpszMenuName =	NULL;
		wc.hInstance =		lpSplash->hInst;
		wc.lpszClassName =	SPLASHCLASS;
		wc.hbrBackground =	NULL;
		wc.lpfnWndProc =	SplashWndProc;
		wc.style =			0L;
		wc.cbWndExtra =		sizeof(lpSplash);
		wc.cbClsExtra =		0;

		if (!RegisterClass(&wc))
			fSuccess = TraceFALSE(NULL);
	}

	// create a splash screen window
	//
	if (fSuccess && (lpSplash->hwndSplash = CreateWindowEx(
		0L,
		SPLASHCLASS,
		(LPTSTR) TEXT(""),
		WS_POPUP,
		0, 0, 0, 0, // we will calculate size and position later
		hwndParent,
		(HMENU) NULL,
		lpSplash->hInst,
		lpSplash)) == NULL)
	{
		fSuccess = TraceFALSE(NULL);
	}

	if (fSuccess)
	{
		BITMAP Bitmap;

		// the size of the window is equal to the size of the bitmap
		//
		if (GetObject((HGDIOBJ) lpSplash->hBitmap, sizeof(BITMAP), &Bitmap) == 0)
			fSuccess = TraceFALSE(NULL);

		else if (!SetWindowPos(lpSplash->hwndSplash,
			NULL, 0, 0, Bitmap.bmWidth, Bitmap.bmHeight,
			SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOREDRAW | SWP_NOZORDER))
			fSuccess = TraceFALSE(NULL);
	}

	if (fSuccess)
	{
		int cxOffCenter = 0;
		int cyOffCenter = 0;

		// try to avoid having the window overlap
		// the icons at the bottom of the desktop window
		//
		if (hwndParent == GetDesktopWindow())
		{
#if 0
			cyOffCenter = -1 * ((GetSystemMetrics(SM_CYICON) +
				GetSystemMetrics(SM_CYCAPTION) * 2) / 2);
#endif
		}

		// center the window on its parent
		//
		if (WndCenterWindow(lpSplash->hwndSplash,
			hwndParent, cxOffCenter, cyOffCenter) != 0)
		{
			fSuccess = TraceFALSE(NULL);
		}
	}

	if (!fSuccess)
	{
		SplashDestroy(SplashGetHandle(lpSplash));
		lpSplash = NULL;
	}

	return fSuccess ? SplashGetHandle(lpSplash) : NULL;
}

// SplashDestroy - destroy splash screen
//		<hSplash>			(i) handle returned from SplashCreate
// return 0 if success
//
// NOTE: SplashDestroy always destroys the splash screen,
// whether or not the minimum show time has elapsed.
//
int DLLEXPORT WINAPI SplashDestroy(HSPLASH hSplash)
{
	BOOL fSuccess = TRUE;
	LPSPLASH lpSplash;

	if (SplashHide(hSplash) != 0)
		fSuccess = TraceFALSE(NULL);

	else if ((lpSplash = SplashGetPtr(hSplash)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpSplash->hwndSplash != NULL &&
		!DestroyWindow(lpSplash->hwndSplash))
		fSuccess = TraceFALSE(NULL);

	else if ((lpSplash = MemFree(NULL, lpSplash)) != NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}

// SplashShow - show splash screen
//		<hSplash>			(i) handle returned from SplashCreate
// return 0 if success
//
// NOTE: SplashShow() makes the splash screen visible.  Also, timers are
// initiated for minimum and maximum show times, if they were specified.
//
int DLLEXPORT WINAPI SplashShow(HSPLASH hSplash)
{
	BOOL fSuccess = TRUE;
	LPSPLASH lpSplash;

	if ((lpSplash = SplashGetPtr(hSplash)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpSplash->fVisible)
		; // already visible, so no need to do anything else

	else
	{
		// prevent user input if SPLASH_NOFOCUS flag set
		//
		if (lpSplash->dwFlags & SPLASH_NOFOCUS)
			EnableWindow(lpSplash->hwndSplash, FALSE);

		// show the window
		//
		ShowWindow(lpSplash->hwndSplash, SW_SHOW);
		UpdateWindow(lpSplash->hwndSplash);
		lpSplash->fVisible = TRUE;

		// set focus to splash screen if SPLASH_SETFOCUS flag set
		//
		if (lpSplash->dwFlags & SPLASH_SETFOCUS)
			SetFocus(lpSplash->hwndSplash);

		// set min show timer if necessary
		//
		if (!lpSplash->fMinShowTimerSet &&
			lpSplash->msMinShow > 0)
		{
			if (!SetTimer(lpSplash->hwndSplash, ID_TIMER_MINSHOW,
				lpSplash->msMinShow, NULL))
				fSuccess = TraceFALSE(NULL);
			else
				lpSplash->fMinShowTimerSet = TRUE;
		}

		// set max show timer if necessary
		//
		if (!lpSplash->fMaxShowTimerSet &&
			lpSplash->msMaxShow > 0)
		{
			if (!SetTimer(lpSplash->hwndSplash, ID_TIMER_MAXSHOW,
				lpSplash->msMaxShow, NULL))
				fSuccess = TraceFALSE(NULL);
			else
				lpSplash->fMaxShowTimerSet = TRUE;
		}
	}

	return fSuccess ? 0 : -1;
}

// SplashHide - hide splash screen
//		<hSplash>			(i) handle returned from SplashCreate
// return 0 if success
//
// NOTE: SplashHide() will hide the splash screen, unless
//		1)	the minimum show time has not yet elapsed.  If not,
//			the splash screen will remain visible until then.
//		2)	the maximum show time has already elapsed.  If so,
//			the splash screen has already been hidden.
//
int DLLEXPORT WINAPI SplashHide(HSPLASH hSplash)
{
	BOOL fSuccess = TRUE;
	LPSPLASH lpSplash;

	if ((lpSplash = SplashGetPtr(hSplash)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (!lpSplash->fVisible)
		; // already hidden, so no need to do anything else

	else if (lpSplash->fMinShowTimerSet)
	{
		// minimum show time not yet elapsed
		// set a flag so we know to hide window later
		//
		lpSplash->fHideAfterMinShowTimer = TRUE;
	}

	else
	{
		// hide the window
		//
		ShowWindow(lpSplash->hwndSplash, SW_HIDE);
		lpSplash->fVisible = FALSE;
		lpSplash->fHideAfterMinShowTimer = FALSE;

		// kill min show timer if necessary
		//
		if (lpSplash->fMinShowTimerSet &&
			!KillTimer(lpSplash->hwndSplash, ID_TIMER_MINSHOW))
			fSuccess = TraceFALSE(NULL);

		else
			lpSplash->fMinShowTimerSet = FALSE;

		// kill max show timer if necessary
		//
		if (lpSplash->fMaxShowTimerSet &&
			!KillTimer(lpSplash->hwndSplash, ID_TIMER_MAXSHOW))
			fSuccess = TraceFALSE(NULL);

		else
			lpSplash->fMaxShowTimerSet = FALSE;
	}

	return fSuccess ? 0 : -1;
}

// SplashIsVisible - get visible flag
//		<hSplash>			(i) handle returned from SplashCreate
// return TRUE if splash screen is visible, FALSE if hidden or error
//
int DLLEXPORT WINAPI SplashIsVisible(HSPLASH hSplash)
{
	BOOL fSuccess = TRUE;
	LPSPLASH lpSplash;

	if ((lpSplash = SplashGetPtr(hSplash)) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? lpSplash->fVisible : FALSE;
}

// SplashGetWindowHandle - get splash screen window handle
//		<hSplash>			(i) handle returned from SplashCreate
// return window handle (NULL if error)
//
HWND DLLEXPORT WINAPI SplashGetWindowHandle(HSPLASH hSplash)
{
	BOOL fSuccess = TRUE;
	LPSPLASH lpSplash;

	if ((lpSplash = SplashGetPtr(hSplash)) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? lpSplash->hwndSplash : NULL;
}

////
//	helper functions
////

// SplashWndProc - window procedure for splash screen
//
LRESULT DLLEXPORT CALLBACK SplashWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	BOOL fSuccess = TRUE;
	LRESULT lResult;

	switch (msg)
	{
		case WM_NCCREATE:
			lResult = (LRESULT) HANDLE_WM_NCCREATE(hwnd, wParam, lParam, SplashOnNCCreate);
			break;

		case WM_PAINT:
			lResult = (LRESULT) HANDLE_WM_PAINT(hwnd, wParam, lParam, SplashOnPaint);
			break;

		case WM_TIMER:
			lResult = (LRESULT) HANDLE_WM_TIMER(hwnd, wParam, lParam, SplashOnTimer);
			break;

		case WM_NCHITTEST:
			lResult = (LRESULT) HANDLE_WM_NCHITTEST(hwnd, wParam, lParam, SplashOnNCHitTest);
			break;

		case WM_CHAR:
			lResult = (LRESULT) HANDLE_WM_CHAR(hwnd, wParam, lParam, SplashOnChar);
			break;

		case WM_LBUTTONDOWN:
			lResult = (LRESULT) HANDLE_WM_LBUTTONDOWN(hwnd, wParam, lParam, SplashOnLButtonDown);
			break;

		case WM_RBUTTONDOWN:
			lResult = (LRESULT) HANDLE_WM_RBUTTONDOWN(hwnd, wParam, lParam, SplashOnRButtonDown);
			break;

		default:
			lResult = DefWindowProc(hwnd, msg, wParam, lParam);
			break;
	}
	
	return lResult;
}

// SplashOnNCCreate - handler for WM_NCCREATE message
//
static BOOL SplashOnNCCreate(HWND hwnd, CREATESTRUCT FAR* lpCreateStruct)
{
	LPSPLASH lpSplash = (LPSPLASH) lpCreateStruct->lpCreateParams;

	lpSplash->hwndSplash = hwnd;

	// store lpSplash in window extra bytes
	//
	SetWindowLongPtr(hwnd, 0, (LONG_PTR) lpSplash);

	return FORWARD_WM_NCCREATE(hwnd, lpCreateStruct, DefWindowProc);
}

// SplashOnPaint - handler for WM_PAINT message
//
static void SplashOnPaint(HWND hwnd)
{
	HDC hdc;
	PAINTSTRUCT ps;

	// retrieve lpSplash from window extra bytes
	//
	LPSPLASH lpSplash = (LPSPLASH) GetWindowLongPtr(hwnd, 0);

	hdc = BeginPaint(hwnd, &ps);

	// display splash screen bitmap
	//
	GfxBitmapDisplay(hdc, lpSplash->hBitmap, 0, 0, FALSE);

	EndPaint(hwnd, &ps);

	return;
}

// SplashOnTimer - handler for WM_TIMER message
//
static void SplashOnTimer(HWND hwnd, UINT id)
{
	BOOL fSuccess = TRUE;
	
	// retrieve lpSplash from window extra bytes
	//
	LPSPLASH lpSplash = (LPSPLASH) GetWindowLongPtr(hwnd, 0);

	switch (id)
	{
		case ID_TIMER_MINSHOW:
		{
			// kill the timer so it does not repeat
			//
			if (lpSplash->fMinShowTimerSet &&
				!KillTimer(lpSplash->hwndSplash, ID_TIMER_MINSHOW))
				fSuccess = TraceFALSE(NULL);
			else
			{
				lpSplash->fMinShowTimerSet = FALSE;

				// hide window if SplashHide was called earlier
				//
				if (lpSplash->fVisible &&
					lpSplash->fHideAfterMinShowTimer &&
					SplashHide(SplashGetHandle(lpSplash)) != 0)
					fSuccess = TraceFALSE(NULL);
			}
		}
			break;

		case ID_TIMER_MAXSHOW:
		{
			// kill the timer so it does not repeat
			//
			if (lpSplash->fMaxShowTimerSet &&
				!KillTimer(lpSplash->hwndSplash, ID_TIMER_MAXSHOW))
				fSuccess = TraceFALSE(NULL);
			else
			{
				lpSplash->fMaxShowTimerSet = FALSE;

				// hide window if max show time expired
				//
				if (lpSplash->fVisible &&
					SplashHide(SplashGetHandle(lpSplash)) != 0)
					fSuccess = TraceFALSE(NULL);
			}
		}
			break;

		default:
			break;
	}

	return;
}

// SplashOnNCHitTest - handler for WM_NCHITTEST message
//
static UINT SplashOnNCHitTest(HWND hwnd, int x, int y)
{
	// retrieve lpSplash from window extra bytes
	//
	LPSPLASH lpSplash = (LPSPLASH) GetWindowLongPtr(hwnd, 0);
	UINT uResult;

	// prevent the user from dragging the window
	// if SPLASH_NOMOVE flag is set
	//
	if (lpSplash->dwFlags & SPLASH_NOMOVE)
		uResult = FORWARD_WM_NCHITTEST(hwnd, x, y, DefWindowProc);

	else
	{
		POINT pt;
		RECT rc;

		// get current mouse cursor position relative to client area
		//
		pt.x = x;
		pt.y = y;
		ScreenToClient(lpSplash->hwndSplash, &pt);

		// if mouse cursor is within window client area
		// pretend it is actually within the title bar
		//
		GetClientRect(lpSplash->hwndSplash, &rc);
		if (PtInRect(&rc, pt))
			uResult = HTCAPTION;
		else
			uResult = FORWARD_WM_NCHITTEST(hwnd, x, y, DefWindowProc);
	}

	return uResult;
}

// SplashOnChar - handler for WM_CHAR message
//
static void SplashOnChar(HWND hwnd, UINT ch, int cRepeat)
{
	BOOL fSuccess = TRUE;
	
	// retrieve lpSplash from window extra bytes
	//
	LPSPLASH lpSplash = (LPSPLASH) GetWindowLongPtr(hwnd, 0);

	// hide window if key pressed
	//
	if (SplashAbort(lpSplash) != 0)
		fSuccess = TraceFALSE(NULL);

	return;
}

// SplashOnLButtonDown - handler for WM_LBUTTONDOWN message
//
static void SplashOnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags)
{
	BOOL fSuccess = TRUE;
	
	// retrieve lpSplash from window extra bytes
	//
	LPSPLASH lpSplash = (LPSPLASH) GetWindowLongPtr(hwnd, 0);

	// hide window if mouse clicked on window
	//
	if (SplashAbort(lpSplash) != 0)
		fSuccess = TraceFALSE(NULL);

	return;
}

// SplashOnRButtonDown - handler for WM_LBUTTONDOWN message
//
static void SplashOnRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags)
{
	BOOL fSuccess = TRUE;
	
	// retrieve lpSplash from window extra bytes
	//
	LPSPLASH lpSplash = (LPSPLASH) GetWindowLongPtr(hwnd, 0);

	// hide window if mouse clicked on window
	//
	if (SplashAbort(lpSplash) != 0)
		fSuccess = TraceFALSE(NULL);

	return;
}

// SplashAbort - hide splash window if SPLASH_ABORT flag set
//		<lpSplash>				(i) pointer to SPLASH struct
// return 0 if success
//
static int SplashAbort(LPSPLASH lpSplash)
{
	BOOL fSuccess = TRUE;

	// hide window if SPLASH_ABORT flag set
	//
	if ((lpSplash->dwFlags & SPLASH_ABORT) &&
		lpSplash->fVisible &&
		SplashHide(SplashGetHandle(lpSplash)) != 0)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}

// SplashGetPtr - verify that splash handle is valid,
//		<hSplash>				(i) handle returned from SplashInit
// return corresponding splash pointer (NULL if error)
//
static LPSPLASH SplashGetPtr(HSPLASH hSplash)
{
	BOOL fSuccess = TRUE;
	LPSPLASH lpSplash;

	if ((lpSplash = (LPSPLASH) hSplash) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadWritePtr(lpSplash, sizeof(SPLASH)))
		fSuccess = TraceFALSE(NULL);

#ifdef CHECKTASK
	// make sure current task owns the splash handle
	//
	else if (lpSplash->hTask != GetCurrentTask())
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? lpSplash : NULL;
}

// SplashGetHandle - verify that splash pointer is valid,
//		<lpSplash>				(i) pointer to SPLASH struct
// return corresponding splash handle (NULL if error)
//
static HSPLASH SplashGetHandle(LPSPLASH lpSplash)
{
	BOOL fSuccess = TRUE;
	HSPLASH hSplash;

	if ((hSplash = (HSPLASH) lpSplash) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hSplash : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\splash.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// splash.h - interface for splash screen functions in splash.c
////

#ifndef __SPLASH_H__
#define __SPLASH_H__

#include "winlocal.h"

#define SPLASH_VERSION 0x00000106

// handle to splash screen
//
DECLARE_HANDLE32(HSPLASH);

#define SPLASH_SETFOCUS		0x00000001
#define SPLASH_NOFOCUS		0x00000002
#define SPLASH_ABORT		0x00000004
#define SPLASH_NOMOVE		0x00000008

#ifdef __cplusplus
extern "C" {
#endif

// SplashCreate - create splash screen
//		<dwVersion>			(i) must be SPLASH_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<hwndParent>		(i) window which will own the splash screen
//			NULL				desktop window
//		<hBitmapMono>		(i) bitmap to display on mono displays
//		<hBitmapColor>		(i) bitmap to display on color displays
//			0					use mono bitmap
//		<msMinShow>			(i) minimum time (ms) to show splash screen
//			0					no minimum time
//		<msMaxShow>			(i) maximum time (ms) to show splash screen
//			0					no maximum time
//		<dwFlags>			(i) control flags
//			SPLASH_SETFOCUS		SplashShow will set focus to splash screen
//			SPLASH_NOFOCUS		user cannot set focus to splash screen
//			SPLASH_ABORT		user can hide splash screen w/mouse or keybd
//			SPLASH_NOMOVE		user cannot move the splash screen w/mouse
// return handle (NULL if error)
//
// NOTE: SplashCreate creates the window but does not show it.
// See SplashShow and SplashHide
//
HSPLASH DLLEXPORT WINAPI SplashCreate(DWORD dwVersion, HINSTANCE hInst,
	HWND hwndParent, HBITMAP hBitmapMono, HBITMAP hBitmapColor,
	UINT msMinShow, UINT msMaxShow, DWORD dwFlags);

// SplashDestroy - destroy splash screen
//		<hSplash>			(i) handle returned from SplashCreate
// return 0 if success
//
// NOTE: SplashDestroy always destroys the splash screen,
// whether or not the minimum show time has elapsed.
//
int DLLEXPORT WINAPI SplashDestroy(HSPLASH hSplash);

// SplashShow - show splash screen
//		<hSplash>			(i) handle returned from SplashCreate
// return 0 if success
//
// NOTE: SplashShow() makes the splash screen visible.  Also, timers are
// initiated for minimum and maximum show times, if they were specified.
//
int DLLEXPORT WINAPI SplashShow(HSPLASH hSplash);

// SplashHide - hide splash screen
//		<hSplash>			(i) handle returned from SplashCreate
// return 0 if success
//
// NOTE: SplashHide() will hide the splash screen, unless
//		1)	the minimum show time has not yet elapsed.  If not,
//			the splash screen will remain visible until then.
//		2)	the maximum show time has already elapsed.  If so,
//			the splash screen has already been hidden.
//
int DLLEXPORT WINAPI SplashHide(HSPLASH hSplash);

// SplashIsVisible - get visible flag
//		<hSplash>			(i) handle returned from SplashCreate
// return TRUE if splash screen is visible, FALSE if hidden
//
int DLLEXPORT WINAPI SplashIsVisible(HSPLASH hSplash);

// SplashGetWindowHandle - get splash screen window handle
//		<hSplash>			(i) handle returned from SplashCreate
// return window handle (NULL if error)
//
HWND DLLEXPORT WINAPI SplashGetWindowHandle(HSPLASH hSplash);

#ifdef __cplusplus
}
#endif

#endif // __SPLASH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\sort.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	sort.c - sort functions
////

#include "winlocal.h"

#include <limits.h>

#include "sort.h"
#include "mem.h"
#include "str.h"
#include "trace.h"

////
//	private definitions
////

// calculate pointer to element <i>
//
#define Elem(i) \
	(LPBYTE) base + ((i) * width)

// compare element <i> with element <j>
//
#define ElemCompare(lpi, lpj) \
	(compare == NULL ? MemCmp(lpi, lpj, width) : compare(lpi, lpj))

// copy element <j> to element <i>
//
#define ElemCopy(lpi, lpj) \
	MemCpy(lpi, lpj, width)

// swap element <i> with element <j>
//
#define ElemSwap(lpi, lpj) \
	ElemCopy(lpTemp, lpi), \
	ElemCopy(lpi, lpj), \
	ElemCopy(lpj, lpTemp)

// helper functions
//
static int SortInsertionSort(LPVOID base, SORTSIZE_T num, SORTSIZE_T width,
	int (WINAPI *compare)(const LPVOID elem1, const LPVOID elem2),
	LPVOID lpTemp);
static int SortBubbleSort(LPVOID base, SORTSIZE_T num, SORTSIZE_T width,
	int (WINAPI *compare)(const LPVOID elem1, const LPVOID elem2),
	LPVOID lpTemp);
static int SortShellSort(LPVOID base, SORTSIZE_T num, SORTSIZE_T width,
	int (WINAPI *compare)(const LPVOID elem1, const LPVOID elem2),
	LPVOID lpTemp);
static int SortExchangeSort(LPVOID base, SORTSIZE_T num, SORTSIZE_T width,
	int (WINAPI *compare)(const LPVOID elem1, const LPVOID elem2),
	LPVOID lpTemp);
static int SortHeapSort(LPVOID base, SORTSIZE_T num, SORTSIZE_T width,
	int (WINAPI *compare)(const LPVOID elem1, const LPVOID elem2),
	LPVOID lpTemp);
static int SortQuickSort(LPVOID base, SORTSIZE_T num, SORTSIZE_T width,
	int (WINAPI *compare)(const LPVOID elem1, const LPVOID elem2),
	LPVOID lpTemp, SORTSIZE_T iLow, SORTSIZE_T iHigh);

////
//	public functions
////

// Sort - sort an array
//		<base>				(i/o) pointer to start of target array
//		<num>				(i) array size in elements
//		<width>				(i) element size in bytes
//		<compare>			(i) comparison function pointer
//			NULL				direct comparison (MemCmp)
//		<dwFlags>			(i) control flags
//			0					use default sort algorithm
//			SORT_INSERTIONSORT	use insertion sort algorithm
//			SORT_BUBBLESORT		use bubble sort algorithm
//			SORT_SHELLSORT		use shell sort algorithm
//			SORT_EXCHANGESORT	use exchange sort algorithm
//			SORT_HEAPSORT		use heap sort algorithm
//			SORT_QUICKSORT		use quick sort algorithm
// return 0 if success
//
int DLLEXPORT WINAPI Sort(LPVOID base, SORTSIZE_T num, SORTSIZE_T width,
	int (WINAPI *compare)(const LPVOID elem1, const LPVOID elem2),
	DWORD dwFlags)
{
	BOOL fSuccess = TRUE;

    //
    // We have to initialize local variable
    //
	LPBYTE lpTemp = NULL;

    if (base == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (num < 0)
		fSuccess = TraceFALSE(NULL);

	else if (width <= 0)
		fSuccess = TraceFALSE(NULL);

	else if (num == 0)
		; // nothing to sort is not an error

	// allocate block big enough to hold an array element temporarily.
	// each sort algorithm can use this for swapping array elements
	//
	else if ((lpTemp = (LPBYTE) MemAlloc(NULL, width, 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (dwFlags & SORT_INSERTIONSORT)
	{
		if (SortInsertionSort(base, num, width, compare, lpTemp) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	else if (dwFlags & SORT_BUBBLESORT)
	{
		if (SortBubbleSort(base, num, width, compare, lpTemp) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	else if (dwFlags & SORT_SHELLSORT)
	{
		if (SortShellSort(base, num, width, compare, lpTemp) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	else if (dwFlags & SORT_EXCHANGESORT)
	{
		if (SortExchangeSort(base, num, width, compare, lpTemp) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	else if (dwFlags & SORT_HEAPSORT)
	{
		if (SortHeapSort(base, num, width, compare, lpTemp) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	else if (dwFlags & SORT_QUICKSORT)
	{
		if (SortQuickSort(base, num, width, compare, lpTemp, 0, num - 1) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	else // default sort algorithm
	{
		if (SortHeapSort(base, num, width, compare, lpTemp) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	if (lpTemp != NULL &&
		(lpTemp = MemFree(NULL, lpTemp)) != NULL)
	{
		fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// SortCompareBool - compare two boolean values during a sort
//		<lpBool1>			(i) a pointer to a boolean value
//		<lpBool2>			(i) a pointer to a boolean value
// return difference between <fBool1> and <fBool2> (0 if equal)
//
int DLLEXPORT WINAPI SortCompareBool(const LPVOID lpBool1, const LPVOID lpBool2)
{
	return ((* (BOOL FAR *) lpBool1 ? 0 : 1) - (* (BOOL FAR *) lpBool2 ? 0 : 1));
}

// SortCompareShort - compare two short values during a sort
//		<lpShort1>			(i) a pointer to a short value
//		<lpShort2>			(i) a pointer to a short value
// return difference between <short1> and <short2> (0 if equal)
//
int DLLEXPORT WINAPI SortCompareShort(const LPVOID lpShort1, const LPVOID lpShort2)
{
	return (int) (* (short FAR *) lpShort1 - * (short FAR *) lpShort2);
}

// SortCompareLong - compare two long values during a sort
//		<lpLong1>			(i) a pointer to a long value
//		<lpLong2>			(i) a pointer to a long value
// return difference between <long1> and <long2> (0 if equal)
//
int DLLEXPORT WINAPI SortCompareLong(const LPVOID lpLong1, const LPVOID lpLong2)
{
	return (int) min(INT_MAX, max(INT_MIN,
		* (long FAR *) lpLong1 - * (long FAR *) lpLong2));
}

// SortCompareString - compare two strings during a sort
//		<lplpsz1>			(i) a pointer to a string pointer
//		<lplpsz2>			(i) a pointer to a string pointer
// return difference between <lpsz1> and <lpsz2> (0 if equal)
//
int DLLEXPORT WINAPI SortCompareString(const LPVOID lplpsz1, const LPVOID lplpsz2)
{
	return StrICmp(* (LPTSTR FAR *) lplpsz1, * (LPTSTR FAR *) lplpsz2);
}

// SortCompareNull - dummy comparison function
//		<lpv1>				(i) pointer to anything
//		<lpv2>				(i) pointer to anything
// return 0
//
int DLLEXPORT WINAPI SortCompareNull(const LPVOID lpv1, const LPVOID lpv2)
{
	return 0;
}

////
//	helper functions
////

// SortInsertionSort - insertion sort algorithm
//		<base>				(i/o) pointer to start of target array
//		<num>				(i) array size in elements
//		<width>				(i) element size in bytes
//		<compare>			(i) comparison function pointer
//			NULL				direct comparison (MemCmp)
//		<lpTemp>			(i) block to hold element temporarily
// return 0 if success
//
// NOTE: the insertion sort compares each element with
// all the preceding elements. When the appropriate place
// for the new element is found, the element is inserted and
// all the other elements are moved down one place.
//
static int SortInsertionSort(LPVOID base, SORTSIZE_T num, SORTSIZE_T width,
	int (WINAPI *compare)(const LPVOID elem1, const LPVOID elem2),
	LPVOID lpTemp)
{
	BOOL fSuccess = TRUE;
    SORTSIZE_T iRow;
	SORTSIZE_T iRowTmp;

    // start at the top
	//
    for (iRow = 0; iRow < num; ++iRow)
    {
		ElemCopy(lpTemp, Elem(iRow));

		// As long as the temporary element is greater than
		// the the original, keep shifting the elements down
        //
        for (iRowTmp = iRow; iRowTmp; --iRowTmp)
        {
			if (ElemCompare(Elem(iRowTmp - 1), lpTemp) > 0)
				ElemCopy(Elem(iRowTmp), Elem(iRowTmp - 1));
            else
                break;
        }

        // insert the original element in the temporary position
		//
		ElemCopy(Elem(iRowTmp), lpTemp);
    }

	return fSuccess ? 0 : -1;
}

// SortBubbleSort - bubble sort algorithm
//		<base>				(i/o) pointer to start of target array
//		<num>				(i) array size in elements
//		<width>				(i) element size in bytes
//		<compare>			(i) comparison function pointer
//			NULL				direct comparison (MemCmp)
//		<lpTemp>			(i) block to hold element temporarily
// return 0 if success
//
// NOTE: the bubble sort cycles through the elements, comparing
// adjacent elements and swapping pairs that are out of order. It
// continues to do this until no out-of-order pairs are found.
//
static int SortBubbleSort(LPVOID base, SORTSIZE_T num, SORTSIZE_T width,
	int (WINAPI *compare)(const LPVOID elem1, const LPVOID elem2),
	LPVOID lpTemp)
{
	BOOL fSuccess = TRUE;
	SORTSIZE_T iRow;
	SORTSIZE_T iSwitch;
	SORTSIZE_T iLimit = num - 1;

    // move the largest element to the bottom until all are in order
	//
    do
    {
        iSwitch = 0;

        for (iRow = 0; iRow < iLimit; ++iRow)
        {
            // swap two adjacent elements if they are out of order,
            //
            if (ElemCompare(Elem(iRow), Elem(iRow + 1)) > 0)
            {
				ElemSwap(Elem(iRow), Elem(iRow + 1));

                iSwitch = iRow;
            }
        }

        // sort on next pass only to where the last switch was made
		//
        iLimit = iSwitch;

    } while (iSwitch != 0);

	return fSuccess ? 0 : -1;
}

// SortShellSort - shell sort algorithm
//		<base>				(i/o) pointer to start of target array
//		<num>				(i) array size in elements
//		<width>				(i) element size in bytes
//		<compare>			(i) comparison function pointer
//			NULL				direct comparison (MemCmp)
//		<lpTemp>			(i) block to hold element temporarily
// return 0 if success
//
// NOTE: the shell sort is similar to the bubble sort. However, it
// begins by comparing elements that are far apart (separated by the
// value of the iOffset variable, which is initially half the distance
// between the first and last element), then comparing elements that
// are closer together. When iOffset is one, the last iteration is
// merely a bubble sort.
//
static int SortShellSort(LPVOID base, SORTSIZE_T num, SORTSIZE_T width,
	int (WINAPI *compare)(const LPVOID elem1, const LPVOID elem2),
	LPVOID lpTemp)
{
	BOOL fSuccess = TRUE;
    SORTSIZE_T iOffset;
	SORTSIZE_T iSwitch;
	SORTSIZE_T iLimit;
	SORTSIZE_T iRow;

    // set comparison offset to half the number of elements
	//
    iOffset = num / 2;

    while (iOffset != 0)
    {
        // loop until offset gets to zero
		//
        iLimit = num - iOffset - 1;

        do
        {
			// assume no switches at this offset
			//
            iSwitch = 0;

            // compare elements and switch ones out of order
			//
            for (iRow = 0; iRow <= iLimit; ++iRow)
            {
                if (ElemCompare(Elem(iRow), Elem(iRow + iOffset)) > 0)
                {
	                ElemSwap(Elem(iRow), Elem(iRow + iOffset));

                    iSwitch = iRow;
                }
            }

            // sort on next pass only to where last switch was made
			//
            iLimit = iSwitch - iOffset;

        } while (iSwitch != 0);

        // no switches at last offset, try one half as big
		//
        iOffset = iOffset / 2;
    }

	return fSuccess ? 0 : -1;
}

// SortExchangeSort - exchange sort algorithm
//		<base>				(i/o) pointer to start of target array
//		<num>				(i) array size in elements
//		<width>				(i) element size in bytes
//		<compare>			(i) comparison function pointer
//			NULL				direct comparison (MemCmp)
//		<lpTemp>			(i) block to hold element temporarily
// return 0 if success
//
// NOTE: the exchange sort compares each element - starting with
// the first - with every following element. If any of the following
// elements is smaller than the current element, it is exchanged with
// the current element and the process is repeated for the next element.
//
static int SortExchangeSort(LPVOID base, SORTSIZE_T num, SORTSIZE_T width,
	int (WINAPI *compare)(const LPVOID elem1, const LPVOID elem2),
	LPVOID lpTemp)
{
	BOOL fSuccess = TRUE;
    SORTSIZE_T iRowCur;
	SORTSIZE_T iRowMin;
	SORTSIZE_T iRowNext;

    for (iRowCur = 0; iRowCur < num; ++iRowCur)
    {
        iRowMin = iRowCur;

        for (iRowNext = iRowCur; iRowNext < num; ++iRowNext)
            if (ElemCompare(Elem(iRowNext), Elem(iRowMin)) < 0)
                iRowMin = iRowNext;

        // if a row is shorter than the current row,
		// swap those two array elements.
		//
        if (iRowMin > iRowCur)
            ElemSwap(Elem(iRowCur), Elem(iRowMin));
    }

	return fSuccess ? 0 : -1;
}

// SortHeapSort - heap sort algorithm
//		<base>				(i/o) pointer to start of target array
//		<num>				(i) array size in elements
//		<width>				(i) element size in bytes
//		<compare>			(i) comparison function pointer
//			NULL				direct comparison (MemCmp)
//		<lpTemp>			(i) block to hold element temporarily
// return 0 if success
//
// NOTE: the heap sort (also called the tree sort) works by
// organizing the elements into a heap, or tree, where each
// parent node is greater than each of its child nodes.
// Therefore, once the first loop is finished, the largest
// element is at the top of the tree.
// The second loop rebuilds the heap, but starts at the top
// and works down, moving the largest elements to the bottom.
// This has the effect of moving the smallest elements to the
// top and sorting the heap.
//
static int SortHeapSort(LPVOID base, SORTSIZE_T num, SORTSIZE_T width,
	int (WINAPI *compare)(const LPVOID elem1, const LPVOID elem2),
	LPVOID lpTemp)
{
	BOOL fSuccess = TRUE;
    SORTSIZE_T i;

	// convert elements into a "heap" with the largest element at the top
	//
    for (i = 1; i < num; ++i)
	{
		SORTSIZE_T iMaxLevel = i;
   		SORTSIZE_T j = iMaxLevel;
		SORTSIZE_T iParent;

   		// move the element iMaxLevel up the heap until it has
   		// reached its proper node (that is, until it is greater than either
   		// of its child nodes, or until it has reached 1, the top of the heap
		//
   		while (j != 0)
   		{
			// get the subscript for the parent node
			//
       		iParent = j / 2;

       		if (ElemCompare(Elem(j), Elem(iParent)) > 0)
       		{
           		// the element at the current node is bigger than 
				// its parent node, its parent node, so swap them
           		//
           		ElemSwap(Elem(iParent), Elem(j));

           		j = iParent;
       		}
       		else
			{
           		// otherwise, the element has reached its proper place
				// in the heap, so exit
				//
           		break;
			}
   		}
	}

	// converts elements to a "heap" with the largest elements at the bottom
	// When this is done to a reversed heap (largest elements at top),
	// it has the effect of sorting the elements
	//
    for (i = num - 1; i > 0; --i)
    {
		SORTSIZE_T iMaxLevel = i - 1;
   		SORTSIZE_T iChild;
		SORTSIZE_T j = 0;

        ElemSwap(Elem(0), Elem(i));

   		// Move element 0 down the heap until it has reached
   		// its proper node (that is, until it is less than its parent node
   		// or until it has reached iMaxLevel, the bottom of the current heap
		//
   		while (TRUE)
   		{
       		// get the subscript for the child node
			//
       		iChild = 2 * j;

       		// reached the bottom of the heap, so exit
			//
       		if (iChild > iMaxLevel)
           		break;

       		// if there are two child nodes, find out which one is bigger
			//
       		if (iChild + 1 <= iMaxLevel)
       		{
				if (ElemCompare(Elem(iChild + 1), Elem(iChild)) > 0)
               		++iChild;
       		}

       		if (ElemCompare(Elem(j), Elem(iChild)) < 0)
       		{
           		// move the element down since it is still
				// not bigger than either one of its children
				//
           		ElemSwap(Elem(j), Elem(iChild));
           		j = iChild;
       		}
       		else
			{
           		// otherwise, array has been restored to a heap
				// from 1 to iMaxLevel, so exit
				//
           		break;
			}
   		}
    }

	return fSuccess ? 0 : -1;
}

// SortQuickSort - quick sort algorithm (recursive)
//		<base>				(i/o) pointer to start of target array
//		<num>				(i) array size in elements
//		<width>				(i) element size in bytes
//		<compare>			(i) comparison function pointer
//			NULL				direct comparison (MemCmp)
//		<lpTemp>			(i) block to hold element temporarily
//		<iLow>				(i) low subdivision
//		<iHigh>				(i) high subdivision
// return 0 if success
//
// NOTE: the quick sort works by picking a random "pivot" element,
// then moving every element that is bigger to one side of the pivot,
// and every element that is smaller to the other side. SortQuickSort is
// then called recursively with the two subdivisions created by the pivot.
// Once the number of elements in a subdivision reaches two, the recursive
// calls end and the array is sorted.
//
static int SortQuickSort(LPVOID base, SORTSIZE_T num, SORTSIZE_T width,
	int (WINAPI *compare)(const LPVOID elem1, const LPVOID elem2),
	LPVOID lpTemp, SORTSIZE_T iLow, SORTSIZE_T iHigh)
{
	BOOL fSuccess = TRUE;
    SORTSIZE_T iUp;
	SORTSIZE_T iDown;
	SORTSIZE_T iBreak;

    if (iLow < iHigh)
    {
        // only two elements in this subdivision;
		// swap them if they are out of order,
		// then end recursive calls
        //
        if ((iHigh - iLow) == 1)
        {
            if (ElemCompare(Elem(iLow), Elem(iHigh)) > 0)
            {
            	ElemSwap(Elem(iLow), Elem(iHigh));
            }
        }
        else
        {
            iBreak = iHigh;

            do
            {
                // move in from both sides towards the pivot element
				//
                iUp = iLow;
                iDown = iHigh;

                while ((iUp < iDown) &&
					ElemCompare(Elem(iUp), Elem(iBreak)) <= 0)
				{
                    ++iUp;
				}

                while ((iDown > iUp) &&
					ElemCompare(Elem(iDown), Elem(iBreak)) >= 0)
				{
                    ++iDown;
				}

                // if we haven't reached the pivot, it means that two
                // elements on either side are out of order, so swap them
                //
                if (iUp < iDown)
                {
					ElemSwap(Elem(iUp), Elem(iDown));
                }

            } while (iUp < iDown);

            // move pivot element back to its proper place in the array
			//
            ElemSwap(Elem(iUp), Elem(iHigh));

            // recursively call SortQuickSort
			// to conserve stack, pass the smaller subdivision first
            //
            if ((iUp - iLow) < (iHigh - iUp))
            {
                SortQuickSort(base, num, width, compare, lpTemp,
					iLow, iUp - 1);
                SortQuickSort(base, num, width, compare, lpTemp,
					iUp + 1, iHigh);
            }
            else
            {
                SortQuickSort(base, num, width, compare, lpTemp,
					iUp + 1, iHigh);
                SortQuickSort(base, num, width, compare, lpTemp,
					iLow, iUp - 1);
            }
        }
    }

	return fSuccess ? 0 : -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\str.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	str.c - string functions
////

#include "winlocal.h"

#include <stdlib.h>
#include <stdarg.h>

#include "str.h"
#include "mem.h"

////
//	private definitions
////

////
//	public functions
////

#ifndef NOTRACE

// StrItoA - convert int nValue to ascii digits, the result stored in lpszDest
//		<nValue>			(i) integer to convert
//		<lpszDest>			(o) buffer to copy result (max 17 bytes)
//		<nRadix>			(i) conversion radix (base-2 through base-36)
// return <lpszDest>
//
LPTSTR DLLEXPORT WINAPI StrItoA(int nValue, LPTSTR lpszDest, int nRadix)
{
	static TCHAR szDest[17];

	_itot(nValue, szDest, nRadix);

	if (lpszDest != NULL)
		StrCpy(lpszDest, szDest);

	return lpszDest;
}

// StrLtoA - convert long nValue to ascii digits, the result stored in lpszDest
//		<nValue>			(i) integer to convert
//		<lpszDest>			(o) buffer to copy result (max 33 bytes)
//		<nRadix>			(i) conversion radix (base-2 through base-36)
// return lpszDest
//
LPTSTR DLLEXPORT WINAPI StrLtoA(long nValue, LPTSTR lpszDest, int nRadix)
{
	static TCHAR szDest[33];

	_ltot(nValue, szDest, nRadix);

	if (lpszDest != NULL)
		StrCpy(lpszDest, szDest);

	return lpszDest;
}

// StrAtoI - convert ascii digits to int
//		<lpszSrc>			(i) string of digits to convert
// return int
//
int DLLEXPORT WINAPI StrAtoI(LPCTSTR lpszSrc)
{
	static TCHAR szSrc[17];

	StrNCpy(szSrc, lpszSrc, SIZEOFARRAY(szSrc));

	return _ttoi(szSrc);
}

// StrAtoL - convert ascii digits to long
//		<lpszSrc>			(i) string of digits to convert
// return long
//
long DLLEXPORT WINAPI StrAtoL(LPCTSTR lpszSrc)
{
	static TCHAR szSrc[33];

	StrNCpy(szSrc, lpszSrc, SIZEOFARRAY(szSrc));

	return _ttol(szSrc);
}

// StrDup - create duplicate copy of specified string
//		<lpsz>				(i) string to duplicate
// return pointer to duplicate string (NULL if error)
// NOTE: call StrDupFree to release allocated memory
//
LPTSTR DLLEXPORT WINAPI StrDup(LPCTSTR lpsz)
{
	BOOL fSuccess = TRUE;
	LPTSTR lpszDup = NULL;
	int sizDup;

	if (lpsz == NULL)
		fSuccess = FALSE;

	else if ((lpszDup = (LPTSTR) MemAlloc(NULL, 
		(sizDup = StrLen(lpsz) + 1) * sizeof(TCHAR), 0)) == NULL)
		fSuccess = FALSE;

	else
		MemCpy(lpszDup, lpsz, sizDup * sizeof(TCHAR));

	return fSuccess ? lpszDup : NULL;
}

// StrDupFree - free memory associated with duplicate string
//		<lpsz>				(i) string returned by StrDup
// return 0 if success
//
int DLLEXPORT WINAPI StrDupFree(LPTSTR lpsz)
{
	BOOL fSuccess = TRUE;

	if (lpsz == NULL)
		fSuccess = FALSE;

	else if ((lpsz = MemFree(NULL, lpsz)) != NULL)
		fSuccess = FALSE;

	return fSuccess ? 0 : -1;
}

#endif // #ifndef NOTRACE

// StrClean - copy up to n chars from string szSrc to string szDst,
// except for leading and trailing white space
// return szDst
//
LPTSTR DLLEXPORT WINAPI StrClean(LPTSTR szDst, LPCTSTR szSrc, size_t n)
{
	szDst[n] = '\0';
	MemMove(szDst, szSrc, n);
	StrTrimWhite(szDst);
	StrTrimWhiteLeading(szDst);
	return (szDst);
}

// StrGetLastChr - return last char in string s
//
TCHAR DLLEXPORT WINAPI StrGetLastChr(LPCTSTR s)
{
	TCHAR c = '\0';
	if (*s != '\0')
		c = *(s + StrLen(s) - 1);
	return (c);
}

// StrSetLastChr - replace last char in string s with c
// return s
//
LPTSTR DLLEXPORT WINAPI StrSetLastChr(LPTSTR s, TCHAR c)
{
    if (*s != '\0')
		*(s + StrLen(s) - 1) = c;
	return (s);
}

// StrTrimChr - strip trailing c chars from string s
// return s
//
LPTSTR DLLEXPORT WINAPI StrTrimChr(LPTSTR s, TCHAR c)
{
    LPTSTR p = StrChr(s, '\0');
	while (p > s && *(p = StrPrevChr(s, p)) == c)
		*p = '\0';
		
	return (s);
}

// StrTrimChrLeading - strip leading c chars from string s
// return s
//
LPTSTR DLLEXPORT WINAPI StrTrimChrLeading(LPTSTR s, TCHAR c)
{
	LPTSTR p = s;
	while (*p == c)
		p = StrNextChr(p);
	if (p > s)
		MemMove(s, p, StrLen(p) + 1);
	return (s);
}

// StrTrimWhite - strip trailing white space from string s
// return s
//
LPTSTR DLLEXPORT WINAPI StrTrimWhite(LPTSTR s)
{
    LPTSTR p = StrChr(s, '\0');
	while (p > s)
	{
		p = StrPrevChr(s, p);
		if (ChrIsAscii(*p) && ChrIsSpace(*p))
			*p = '\0';
		else
			break;
	}
	return (s);
}

// StrTrimWhiteLeading - strip leading white space from string s
// return s
//
LPTSTR DLLEXPORT WINAPI StrTrimWhiteLeading(LPTSTR s)
{
	LPTSTR p = s;
	while (ChrIsAscii(*p) && ChrIsSpace(*p))
		p = StrNextChr(p);
	if (p > s)
		MemMove(s, p, StrLen(p) + 1);
	return (s);
}

// StrTrimQuotes - strip leading and trailing quotes from string s
// return s
//
LPTSTR DLLEXPORT WINAPI StrTrimQuotes(LPTSTR s)
{
	StrTrimChrLeading(s, '\"');
	StrTrimChr(s, '\"');
	return s;
}

// StrChrCat - concatenate char c to end of string s
// return s
//
LPTSTR DLLEXPORT WINAPI StrChrCat(LPTSTR s, TCHAR c)
{
    LPTSTR p = StrChr(s, '\0');
    if( p == NULL )
    {
        return (NULL);
    }

	*p = c;
	p = StrNextChr(p);
	*p = '\0';
	return (s);
}

// StrChrCatLeft - concatenate char c to front of string s
// return s
//
LPTSTR DLLEXPORT WINAPI StrChrCatLeft(LPTSTR s, TCHAR c)
{	
    MemMove(s + 1, s, StrLen(s) + 1);
	*s = c;
	return (s);
}

// StrInsert - insert string szSrc in front of szDst
// return szDst
//
LPTSTR DLLEXPORT WINAPI StrInsert(LPTSTR szDst, LPTSTR szSrc)
{	
    MemMove(szDst + StrLen(szSrc), szDst, StrLen(szDst) + 1);
	MemMove(szDst, szSrc, StrLen(szSrc));
	return (szDst);
}

// StrSetN - set first n chars of string s to char c, null terminate s
// return s
//
LPTSTR DLLEXPORT WINAPI StrSetN(LPTSTR s, TCHAR c, size_t n)
{
    MemSet(s, c, n);
	*(s + n) = '\0';
	return (s);
}

// StrCpyXChr - copy string szSrc to string szDst, except for c chars
// return szDst
//
LPTSTR DLLEXPORT WINAPI StrCpyXChr(LPTSTR szDst, LPCTSTR szSrc, TCHAR c)
{
	TCHAR cTmp;
	if (c == '\0')
	    MemMove(szDst, szSrc, StrLen(szSrc));
	else
	{
		while ((cTmp = *szSrc) != '\0')
		{
			if (cTmp != c)
			{
				*szDst = cTmp;
				szDst = StrNextChr(szDst);
			}
			szSrc = StrNextChr(szSrc);
		}
		*szDst = '\0';
  	}
	return (szDst);
}

// StrGetRowColumnCount - calculate number of lines and longest line in string
//		<lpszText>			(i) string to examine
//		<lpnRows>			(o) int pointer to receive line count
//		<lpnColumnsMax>		(o) int pointer to receive size of longest line
// return 0 if success
//
int DLLEXPORT WINAPI StrGetRowColumnCount(LPCTSTR lpszText, LPINT lpnRows, LPINT lpnColumnsMax)
{
	BOOL fSuccess = TRUE;
	int nRows = 0;
	int nColumnsMax = 0;

	if (lpszText == NULL)
		fSuccess = FALSE;
	
	else if (lpnRows == NULL)
		fSuccess = FALSE;

	else if (lpnColumnsMax == NULL)
		fSuccess = FALSE;

	else while (*lpszText != '\0')
	{
		int nColumns = 0;

		++nRows;
		while (*lpszText != '\0')
		{
			if (*lpszText == '\n')
			{
				lpszText = StrNextChr(lpszText);
				break;
			}

			++nColumns;
			lpszText = StrNextChr(lpszText);
		}

		if (nColumns > nColumnsMax)
			nColumnsMax = nColumns;
	}

	if (fSuccess)
	{
		*lpnRows = nRows;
		*lpnColumnsMax = nColumnsMax;
	}

	return fSuccess ? 0 : -1;
}

// StrGetRow - extract specified line from string
//		<lpszText>			(i) string from which to extract line
//		<iRow>				(i) index of line to extract (0 = first row, ...)
//		<lpszBuf>			(o) buffer to copy line into
//		<sizBuf>			(i) size of buffer
// return 0 if success
//
int DLLEXPORT WINAPI StrGetRow(LPCTSTR lpszText, int iRow, LPTSTR lpszBuf, int sizBuf)
{
	BOOL fSuccess = TRUE;
	int nRows = 0;

	if (lpszText == NULL)
		fSuccess = FALSE;

	else if (iRow < 0)
		fSuccess = FALSE;

	else if (lpszBuf == NULL)
		fSuccess = FALSE;

	else while (*lpszText != '\0')
	{
		int nColumns = 0;

		++nRows;
		while (*lpszText != '\0')
		{
			if (*lpszText == '\n')
			{
				lpszText = StrNextChr(lpszText);
				break;
			}

			++nColumns;

			if (iRow == nRows - 1 && nColumns < sizBuf - 1)
			{
				*lpszBuf = *lpszText;
				lpszBuf = StrNextChr(lpszBuf);
			}

			lpszText = StrNextChr(lpszText);
		}

		if (iRow == nRows - 1)
		{
			*lpszBuf = '\0';
			break;
		}
	}

	return fSuccess ? 0 : -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\stack.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// stack.c - stack functions
////

#include "winlocal.h"

#include "stack.h"
#include "list.h"
#include "mem.h"
#include "trace.h"

////
//	private definitions
////

// stack
//
typedef struct STACK
{
	DWORD dwVersion;
	HINSTANCE hInst;
	HTASK hTask;
	HLIST hList;
} STACK, FAR *LPSTACK;

// helper functions
//
static LPSTACK StackGetPtr(HSTACK hStack);
static HSTACK StackGetHandle(LPSTACK lpStack);

////
//	public functions
////

////
// stack constructor and destructor functions
////

// StackCreate - stack constructor
//		<dwVersion>			(i) must be STACK_VERSION
// 		<hInst>				(i) instance handle of calling module
// return new stack handle (NULL if error)
//
HSTACK DLLEXPORT WINAPI StackCreate(DWORD dwVersion, HINSTANCE hInst)
{
	BOOL fSuccess = TRUE;
	LPSTACK lpStack = NULL;

	if (dwVersion != STACK_VERSION)
		fSuccess = TraceFALSE(NULL);

	else if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpStack = (LPSTACK) MemAlloc(NULL, sizeof(STACK), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpStack->hList = ListCreate(LIST_VERSION, hInst)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		// initially the stack is empty
		//
		lpStack->dwVersion = dwVersion;
		lpStack->hInst = hInst;
		lpStack->hTask = GetCurrentTask();
	}

	if (!fSuccess)
	{
		StackDestroy(StackGetHandle(lpStack));
		lpStack = NULL;
	}


	return fSuccess ? StackGetHandle(lpStack) : NULL;
}

// StackDestroy - stack destructor
//		<hStack>				(i) handle returned from StackCreate
// return 0 if success
//
int DLLEXPORT WINAPI StackDestroy(HSTACK hStack)
{
	BOOL fSuccess = TRUE;
	LPSTACK lpStack;

	if ((lpStack = StackGetPtr(hStack)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (ListDestroy(lpStack->hList) != 0)
		fSuccess = TraceFALSE(NULL);

	else if ((lpStack = MemFree(NULL, lpStack)) != NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}

////
// stack status functions
////

// StackGetCount - return count of nodes in stack
//		<hStack>				(i) handle returned from StackCreate
// return node count (-1 if error)
//
long DLLEXPORT WINAPI StackGetCount(HSTACK hStack)
{
	BOOL fSuccess = TRUE;
	LPSTACK lpStack;
	long cNodes;

	if ((lpStack = StackGetPtr(hStack)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((cNodes = ListGetCount(lpStack->hList)) < 0)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? cNodes : -1;
}

// StackIsEmpty - return TRUE if stack has no nodes
//		<hStack>				(i) handle returned from StackCreate
// return TRUE or FALSE
//
BOOL DLLEXPORT WINAPI StackIsEmpty(HSTACK hStack)
{
	BOOL fSuccess = TRUE;
	LPSTACK lpStack;

	if ((lpStack = StackGetPtr(hStack)) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? ListIsEmpty(lpStack->hList) : TRUE;
}

////
// stack element insertion functions
////

// StackPush - add new node with data <elem> to bottom of stack
//		<hStack>			(i) handle returned from StackCreate
//		<elem>				(i) new data element
// returns 0 if success
//
int DLLEXPORT WINAPI StackPush(HSTACK hStack, STACKELEM elem)
{
	BOOL fSuccess = TRUE;
	LPSTACK lpStack;

	if ((lpStack = StackGetPtr(hStack)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (ListAddHead(lpStack->hList, elem) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}

////
// stack element removal functions
////

// StackPop - remove node from bottom of stack
//		<hStack>				(i) handle returned from StackCreate
// returns removed data element (NULL of error or empty)
//
STACKELEM DLLEXPORT WINAPI StackPop(HSTACK hStack)
{
	BOOL fSuccess = TRUE;
	LPSTACK lpStack;

	if ((lpStack = StackGetPtr(hStack)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (ListIsEmpty(lpStack->hList))
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? (STACKELEM) ListRemoveHead(lpStack->hList) : NULL;
}

// StackRemoveAll - remove all nodes from stack
//		<hStack>				(i) handle returned from StackCreate
// return 0 if success
//
int DLLEXPORT WINAPI StackRemoveAll(HSTACK hStack)
{
	BOOL fSuccess = TRUE;
	LPSTACK lpStack;

	if ((lpStack = StackGetPtr(hStack)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (ListRemoveAll(lpStack->hList) != 0)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}

////
// stack element get value functions
////

// StackPeek - return node from bottom of stack, but leave it on stack
//		<hStack>				(i) handle returned from StackCreate
// returns data element (NULL if error or empty)
//
STACKELEM DLLEXPORT WINAPI StackPeek(HSTACK hStack)
{
	BOOL fSuccess = TRUE;
	LPSTACK lpStack;

	if ((lpStack = StackGetPtr(hStack)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (ListIsEmpty(lpStack->hList))
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? (STACKELEM) ListGetHead(lpStack->hList) : NULL;
}

////
//	private functions
////

// StackGetPtr - verify that stack handle is valid,
//		<hStack>				(i) handle returned from StackCreate
// return corresponding stack pointer (NULL if error)
//
static LPSTACK StackGetPtr(HSTACK hStack)
{
	BOOL fSuccess = TRUE;
	LPSTACK lpStack;

	if ((lpStack = (LPSTACK) hStack) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadWritePtr(lpStack, sizeof(STACK)))
		fSuccess = TraceFALSE(NULL);

#ifdef CHECKTASK
	// make sure current task owns the stack handle
	//
	else if (lpStack->hTask != GetCurrentTask())
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? lpStack : NULL;
}

// StackGetHandle - verify that stack pointer is valid,
//		<lpStack>			(i) pointer to STACK struct
// return corresponding stack handle (NULL if error)
//
static HSTACK StackGetHandle(LPSTACK lpStack)
{
	BOOL fSuccess = TRUE;
	HSTACK hStack;

	if ((hStack = (HSTACK) lpStack) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hStack : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\stack.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// stack.h - interface for stack functions in stack.c
////

#ifndef __STACK_H__
#define __STACK_H__

#include "winlocal.h"

#define STACK_VERSION 0x00000100

// handle to a stack
//
DECLARE_HANDLE32(HSTACK);

// stack data element
//
typedef LPVOID STACKELEM;

#ifdef __cplusplus
extern "C" {
#endif

////
// stack constructor and destructor functions
////

// StackCreate - stack constructor
//		<dwVersion>			(i) must be STACK_VERSION
// 		<hInst>				(i) instance handle of calling module
// return new stack handle (NULL if error)
//
HSTACK DLLEXPORT WINAPI StackCreate(DWORD dwVersion, HINSTANCE hInst);

// StackDestroy - stack destructor
//		<hStack>				(i) handle returned from StackCreate
// return 0 if success
//
int DLLEXPORT WINAPI StackDestroy(HSTACK hStack);

////
// stack status functions
////

// StackGetCount - return count of nodes in stack
//		<hStack>				(i) handle returned from StackCreate
// return node count (-1 if error)
//
long DLLEXPORT WINAPI StackGetCount(HSTACK hStack);

// StackIsEmpty - return TRUE if stack has no nodes
//		<hStack>				(i) handle returned from StackCreate
// return TRUE or FALSE
//
BOOL DLLEXPORT WINAPI StackIsEmpty(HSTACK hStack);

////
// stack element insertion functions
////

// StackPush - add new node with data <elem> to bottom of stack
//		<hStack>			(i) handle returned from StackCreate
//		<elem>				(i) new data element
// returns 0 if success
//
int DLLEXPORT WINAPI StackPush(HSTACK hStack, STACKELEM elem);

////
// stack element removal functions
////

// StackPop - remove node from bottom of stack
//		<hStack>				(i) handle returned from StackCreate
// returns removed data element (NULL of error or empty)
//
STACKELEM DLLEXPORT WINAPI StackPop(HSTACK hStack);

// StackRemoveAll - remove all nodes from stack
//		<hStack>				(i) handle returned from StackCreate
// return 0 if success
//
int DLLEXPORT WINAPI StackRemoveAll(HSTACK hStack);

////
// stack element get value functions
////

// StackPeek - return node from bottom of stack, but leave it on stack
//		<hStack>				(i) handle returned from StackCreate
// returns data element (NULL if error or empty)
//
STACKELEM DLLEXPORT WINAPI StackPeek(HSTACK hStack);

#ifdef __cplusplus
}
#endif

#endif // __STACK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\strbuf.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// strbuf.h - interface for string buffer functions in strbuf.c
////

#ifndef __STRBUF_H__
#define __STRBUF_H__

#include "winlocal.h"

#define STRBUF_VERSION 0x00000100

// handle to string buffer engine
//
DECLARE_HANDLE32(HSTRBUF);

#ifdef __cplusplus
extern "C" {
#endif

// StrBufInit - initialize str buffer engine
//		<dwVersion>			(i) must be STRBUF_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<cBuf>				(i) number of string buffers to create
//			0					use default number
//		<sizBuf>			(i) size of each string buffer
//			0					use default size
// return str buffer engine handle (NULL if error)
//
HSTRBUF DLLEXPORT WINAPI StrBufInit(DWORD dwVersion, HINSTANCE hInst, int cBuf, int sizBuf);

// StrBufTerm - shut down str buffer engine
//		<hStrBuf>			(i) handle returned by StrBufInit
// return 0 if success
//
int DLLEXPORT WINAPI StrBufTerm(HSTRBUF hStrBuf);

// StrBufLoad - load string with specified id from resource file
//		<hStrBuf>			(i) handle returned by StrBufInit
//		<idString>			(i) resource id of string to load
// return ptr to string in next available string buffer (NULL if error)
//
LPTSTR DLLEXPORT WINAPI StrBufLoad(HSTRBUF hStrBuf, UINT idString);

// StrBufSprintf - modified version of wsprintf
//		<hStrBuf>			(i) handle returned by StrBufInit
//		<lpszOutput>		(o) buffer to hold formatted string result
//			NULL				do not copy; return string buffer pointer
//		<lpszFormat,...>	(i) format string and arguments
// returns pointer to resultant string (NULL if error)
//
LPTSTR DLLEXPORT FAR CDECL StrBufSprintf(HSTRBUF hStrBuf, LPTSTR lpszOutput, LPCTSTR lpszFormat, ...);

// StrBufGetNext - get next available static string buffer
//		<hStrBuf>			(i) handle returned by StrBufInit
// return string buffer pointer (NULL if error)
// NOTE: buffers are recycled every <cBuf> times function is called
//
LPTSTR DLLEXPORT WINAPI StrBufGetNext(HSTRBUF hStrBuf);

#ifdef __cplusplus
}
#endif

#endif // __STRBUF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\strbuf.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	strbuf.c - string buffer functions
////

#include "winlocal.h"

#include <stdarg.h>

#include "strbuf.h"
#include "mem.h"
#include "trace.h"

////
//	private definitions
////

#define CBUF_DEFAULT 8
#define SIZBUF_DEFAULT 512

// string buffer control struct
//
typedef struct STRBUF
{
	DWORD dwVersion;
	HINSTANCE hInst;
	HTASK hTask;
	int cBuf;
	int sizBuf;
	int iBuf;
	LPTSTR lpszBuf;
} STRBUF, FAR *LPSTRBUF;

// helper functions
//
static LPSTRBUF StrBufGetPtr(HSTRBUF hStrBuf);
static HSTRBUF StrBufGetHandle(LPSTRBUF lpStrBuf);

////
//	public functions
////

// StrBufInit - initialize str buffer engine
//		<dwVersion>			(i) must be STRBUF_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<cBuf>				(i) number of string buffers to create
//			0					use default number
//		<sizBuf>			(i) size of each string buffer, in characters
//			0					use default size
// return str buffer engine handle (NULL if error)
//
HSTRBUF DLLEXPORT WINAPI StrBufInit(DWORD dwVersion, HINSTANCE hInst, int cBuf, int sizBuf)
{
	BOOL fSuccess = TRUE;
	LPSTRBUF lpStrBuf = NULL;

	if (dwVersion != STRBUF_VERSION)
		fSuccess = TraceFALSE(NULL);

	else if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpStrBuf = (LPSTRBUF) MemAlloc(NULL, sizeof(STRBUF), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lpStrBuf->dwVersion = dwVersion;
		lpStrBuf->hInst = hInst;
		lpStrBuf->hTask = GetCurrentTask();
		lpStrBuf->cBuf = cBuf == 0 ? CBUF_DEFAULT : cBuf;
		lpStrBuf->sizBuf = sizBuf == 0 ? SIZBUF_DEFAULT : sizBuf;
		lpStrBuf->iBuf = -1;
		lpStrBuf->lpszBuf = NULL;

		if ((lpStrBuf->lpszBuf = (LPTSTR) MemAlloc(NULL,
			lpStrBuf->cBuf * lpStrBuf->sizBuf * sizeof(TCHAR), 0)) == NULL)
		{
			fSuccess = TraceFALSE(NULL);
		}
	}

	if (!fSuccess)
	{
		StrBufTerm(StrBufGetHandle(lpStrBuf));
		lpStrBuf = NULL;
	}

	return fSuccess ? StrBufGetHandle(lpStrBuf) : NULL;
}

// StrBufTerm - shut down str buffer engine
//		<hStrBuf>			(i) handle returned by StrBufInit
// return 0 if success
//
int DLLEXPORT WINAPI StrBufTerm(HSTRBUF hStrBuf)
{
	BOOL fSuccess = TRUE;
	LPSTRBUF lpStrBuf;

	if ((lpStrBuf = StrBufGetPtr(hStrBuf)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		if (lpStrBuf->lpszBuf != NULL &&
			(lpStrBuf->lpszBuf = MemFree(NULL, lpStrBuf->lpszBuf)) != NULL)
		{
			fSuccess = TraceFALSE(NULL);
		}

		if ((lpStrBuf = MemFree(NULL, lpStrBuf)) != NULL)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// StrBufLoad - load string with specified id from resource file
//		<hStrBuf>			(i) handle returned by StrBufInit
//		<idString>			(i) resource id of string to load
// return ptr to string in next available string buffer (NULL if error)
//
LPTSTR DLLEXPORT WINAPI StrBufLoad(HSTRBUF hStrBuf, UINT idString)
{
	BOOL fSuccess = TRUE;
	LPSTRBUF lpStrBuf;
	LPTSTR lpsz;
		
	if ((lpStrBuf = StrBufGetPtr(hStrBuf)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpsz = StrBufGetNext(hStrBuf)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (idString != 0
		&& LoadString(lpStrBuf->hInst, idString, lpsz, (int) lpStrBuf->sizBuf) <= 0)
	{
		// specified string not found, construct a dummy string instead
		//
		wsprintf(lpsz, TEXT("String #%u"), idString);
	}

	return fSuccess ? lpsz : NULL;
}

// StrBufSprintf - modified version of wsprintf
//		<hStrBuf>			(i) handle returned by StrBufInit
//		<lpszOutput>		(o) buffer to hold formatted string result
//			NULL				do not copy; return string buffer pointer
//		<lpszFormat,...>	(i) format string and arguments
// returns pointer to resultant string (NULL if error)
//
LPTSTR DLLEXPORT FAR CDECL StrBufSprintf(HSTRBUF hStrBuf, LPTSTR lpszOutput, LPCTSTR lpszFormat, ...)
{
	BOOL fSuccess = TRUE;
	LPTSTR lpszTemp = lpszOutput;

	if (lpszOutput == NULL &&
		(lpszTemp = StrBufGetNext(hStrBuf)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
	    va_list args;
	    va_start(args, lpszFormat);
    	wvsprintf(lpszTemp, lpszFormat, args);
	    va_end(args);
	}

	return fSuccess ? lpszTemp : NULL;
}

// StrBufGetNext - get next available static string buffer
//		<hStrBuf>			(i) handle returned by StrBufInit
// return string buffer pointer (NULL if error)
// NOTE: buffers are recycled every <cBuf> times function is called
//
LPTSTR DLLEXPORT WINAPI StrBufGetNext(HSTRBUF hStrBuf)
{
	BOOL fSuccess = TRUE;
	LPSTRBUF lpStrBuf;
	LPTSTR lpszBuf;

	if ((lpStrBuf = StrBufGetPtr(hStrBuf)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		if (++lpStrBuf->iBuf >= lpStrBuf->cBuf)
			lpStrBuf->iBuf = 0;

		lpszBuf = lpStrBuf->lpszBuf + (lpStrBuf->iBuf * lpStrBuf->sizBuf);
	}

	return fSuccess ? lpszBuf : NULL;
}

////
//	helper functions
////

// verify that str buffer engine handle is valid,
//		<hStrBuf>			(i) handle returned by StrBufInit
// return corresponding str buffer engine pointer (NULL if error)
//
static LPSTRBUF StrBufGetPtr(HSTRBUF hStrBuf)
{
	BOOL fSuccess = TRUE;
	LPSTRBUF lpStrBuf;

	if ((lpStrBuf = (LPSTRBUF) hStrBuf) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadWritePtr(lpStrBuf, sizeof(STRBUF)))
		fSuccess = TraceFALSE(NULL);

#ifdef CHECKTASK
	// make sure current task owns the str buffer engine handle
	//
	else if (lpStrBuf->hTask != GetCurrentTask())
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? lpStrBuf : NULL;
}

// verify that str buffer engine pointer is valid,
//		<lpStrBuf>			(i) pointer to STRBUF struct
// return corresponding str buffer engine handle (NULL if error)
//
static HSTRBUF StrBufGetHandle(LPSTRBUF lpStrBuf)
{
	BOOL fSuccess = TRUE;
	HSTRBUF hStrBuf;

	if ((hStrBuf = (HSTRBUF) lpStrBuf) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hStrBuf : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\str.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// str.h - interface for string functions in str.c
////

#ifndef __STR_H__
#define __STR_H__

#include "winlocal.h"

#define STR_VERSION 0x00000100

#include <tchar.h>
#include <string.h>
#include <ctype.h>

////
//	string macros
////

#ifndef _WIN32
#define CharPrev AnsiPrev
#define CharNext AnsiNext
#define CharLowerBuff AnsiLowerBuff
#define CharUpperBuff AnsiUpperBuff
#define CharLower AnsiLower
#define CharUpper AnsiUpper
#endif

#ifndef NOLSTRING
#define StrCat(string1, string2) lstrcat(string1, string2)
#define StrCmp(string1, string2) lstrcmp(string1, string2)
#define StrICmp(string1, string2) lstrcmpi(string1, string2)
#define StrCpy(string1, string2) lstrcpy(string1, string2)
#define StrLen(string) (UINT) lstrlen(string)
#if (WINVER >= 0x030a)
#define StrNCpy(string1, string2, count) lstrcpyn(string1, string2, (int) count)
#else
#define StrNCpy(string1, string2, count) _tcsncpy(_fmemset(string1, 0, count), string2, count - 1)
#endif
#define StrLwr(string) (CharLowerBuff(string, (UINT) lstrlen(string)), string)
#define StrUpr(string) (CharUpperBuff(string, (UINT) lstrlen(string)), string)
#define StrNextChr(string) CharNext(string)
#define StrPrevChr(start, string) CharPrev(start, string)
#else
#define StrCat(string1, string2) _tcscat(string1, string2)
#define StrCmp(string1, string2) _tcscmp(string1, string2)
#define StrICmp(string1, string2) _tcsicmp(string1, string2)
#define StrCpy(string1, string2) _tcscpy(string1, string2)
#define StrLen(string) _tcslen(string)
#define StrNCpy(string1, string2, count) _tcsncpy(_fmemset(string1, 0, count), string2, count - 1)
#define StrLwr(string) _tcslwr(string)
#define StrUpr(string) _tcsupr(string)
#define StrNextChr(string) (*(string) == '\0' ? (string) : ((string) + 1))
#define StrNextChr(string) _tcsinc(string)
// #define StrNextChr(string) (*(string) == '\0' ? (string) : ((string) + 1))
#define StrPrevChr(start, string) _tcsdec(start, string)
// #define StrPrevChr(start, string) ((string > start) ? ((string) - 1) : (start))
#endif
#define StrChr(string, c) _tcschr(string, c)
#define StrCSpn(string1, string2) _tcscspn(string1, string2)

#define StrNCat(string1, string2, count) _tcsncat(string1, string2, count)
#define StrNCmp(string1, string2, count) _tcsncmp(string1, string2, count)
#define StrNICmp(string1, string2, count) _tcsnicmp(string1, string2, count)
#define StrNSet(string, c, count) _tcsnset(string, c, count)
#define StrPBrk(string1, string2) _tcspbrk(string1, string2)
#define StrRChr(string, c) _tcsrchr(string, c)
#define StrRev(string, c) _tcsrev(string, c)
#define StrSet(string, c) _tcsset(string, c)
#define StrSpn(string1, string2) _tcsspn(string1, string2)
#define StrStr(string1, string2) _tcsstr(string1, string2)
#define StrTok(string1, string2) _tcstok(string1, string2)

////
//	character type macros
////

#ifndef  NOLANGUAGE
#define ChrIsAlpha(c) IsCharAlpha(c)
#define ChrIsAlnum(c) IsCharAlphaNumeric(c)
#define ChrIsUpper(c) IsCharUpper(c)
#define ChrIsLower(c) IsCharLower(c)
#define ChrToUpper(c) (TCHAR) CharUpper((LPTSTR) (DWORD_PTR)(c))
#define ChrToLower(c) (TCHAR) CharLower((LPTSTR) (DWORD_PTR)(c))
#else
#define ChrIsAlpha(c) _istalpha(c)
#define ChrIsAlnum(c) _istalnum(c)
#define ChrIsUpper(c) _istupper(c)
#define ChrIsLower(c) _istlower(c)
#define ChrToUpper(c) _totupper(c)
#define ChrToLower(c) _totlower(c)
#endif
#define ChrIsDigit(c) _istdigit(c)
#define ChrIsHexDigit(c) _istxdigit(c)
#define ChrIsSpace(c) _istspace(c)
#define ChrIsPunct(c) _istpunct(c)
#define ChrIsPrint(c) _istprint(c)
#define ChrIsGraph(c) _istgraph(c)
#define ChrIsCntrl(c) _istcntrl(c)
#define ChrIsAscii(c) _istascii(c)

#define ChrIsWordDelimiter(c) (ChrIsSpace(c) || ChrIsPunct(c))

////
//	string functions
////

#ifdef __cplusplus
extern "C" {
#endif

// StrItoA - convert int nValue to ascii digits, the result stored in lpszDest
//		<nValue>			(i) integer to convert
//		<lpszDest>			(o) buffer to copy result (max 17 bytes)
//		<nRadix>			(i) conversion radix (base-2 through base-36)
// return <lpszDest>
//
#ifdef NOTRACE
#define StrItoA(nValue, lpszDest, nRadix) _itot(nValue, lpszDest, nRadix)
#else
LPTSTR DLLEXPORT WINAPI StrItoA(int nValue, LPTSTR lpszDest, int nRadix);
#endif

// StrLtoA - convert long nValue to ascii digits, the result stored in lpszDest
//		<nValue>			(i) integer to convert
//		<lpszDest>			(o) buffer to copy result (max 33 bytes)
//		<nRadix>			(i) conversion radix (base-2 through base-36)
// return lpszDest
//
#ifdef NOTRACE
#define StrLtoA(nValue, szDest, nRadix) _ltot(nValue, szDest, nRadix)
#else
LPTSTR DLLEXPORT WINAPI StrLtoA(long nValue, LPTSTR lpszDest, int nRadix);
#endif

// StrAtoI - convert ascii digits to int
//		<lpszSrc>			(i) string of digits to convert
// return int
//
#ifdef NOTRACE
#define StrAtoI(lpszSrc) _ttoi(lpszSrc)
#else
int DLLEXPORT WINAPI StrAtoI(LPCTSTR lpszSrc);
#endif

// StrAtoL - convert ascii digits to long
//		<lpszSrc>			(i) string of digits to convert
// return long
//
#ifdef NOTRACE
#define StrAtoL(lpszSrc) _ttol(lpszSrc)
#else
long DLLEXPORT WINAPI StrAtoL(LPCTSTR lpszSrc);
#endif

// StrDup - create duplicate copy of specified string
//		<lpsz>				(i) string to duplicate
// return pointer to duplicate string (NULL if error)
// NOTE: call StrDupFree to release allocated memory
//
#ifdef NOTRACE
#define StrDup(string) _tcsdup(string)
#else
LPTSTR DLLEXPORT WINAPI StrDup(LPCTSTR lpsz);
#endif

// StrDupFree - free memory associated with duplicate string
//		<lpsz>				(i) string returned by StrDup
// return 0 if success
//
#ifdef NOTRACE
#define StrDupFree(string) (free(string), 0)
#else
int DLLEXPORT WINAPI StrDupFree(LPTSTR lpsz);
#endif

// StrClean - copy up to n chars from string szSrc to string szDst,
// except for leading and trailing white space
// return szDst
//
LPTSTR DLLEXPORT WINAPI StrClean(LPTSTR szDst, LPCTSTR szSrc, size_t n);

// StrGetLastChr - return last char in string s
//
TCHAR DLLEXPORT WINAPI StrGetLastChr(LPCTSTR s);

// StrSetLastChr - replace last char in string s with c
// return s
//
LPTSTR DLLEXPORT WINAPI StrSetLastChr(LPTSTR s, TCHAR c);

// StrTrimChr - strip trailing c chars from string s
// return s
//
LPTSTR DLLEXPORT WINAPI StrTrimChr(LPTSTR s, TCHAR c);

// StrTrimChrLeading - strip leading c chars from string s
// return s
//
LPTSTR DLLEXPORT WINAPI StrTrimChrLeading(LPTSTR s, TCHAR c);

// StrTrimWhite - strip trailing white space from string s
// return s
//
LPTSTR DLLEXPORT WINAPI StrTrimWhite(LPTSTR s);

// StrTrimWhiteLeading - strip leading white space from string s
// return s
//
LPTSTR DLLEXPORT WINAPI StrTrimWhiteLeading(LPTSTR s);

// StrTrimQuotes - strip leading and trailing quotes from string s
// return s
//
LPTSTR DLLEXPORT WINAPI StrTrimQuotes(LPTSTR s);

// StrChrCat - concatenate char c to end of string s
// return s
//
LPTSTR DLLEXPORT WINAPI StrChrCat(LPTSTR s, TCHAR c);

// StrChrCatLeft - concatenate char c to front of string s
// return s
//
LPTSTR DLLEXPORT WINAPI StrChrCatLeft(LPTSTR s, TCHAR c);

// StrInsert - insert string szSrc in front of szDst
// return szDst
//
LPTSTR DLLEXPORT WINAPI StrInsert(LPTSTR szDst, LPTSTR szSrc);

// StrSetN - set first n chars of string s to char c, null terminate s
// return s
//
LPTSTR DLLEXPORT WINAPI StrSetN(LPTSTR s, TCHAR c, size_t n);

// StrCpyXChr - copy string szSrc to string szDst, except for c chars
// return szDst
//
LPTSTR DLLEXPORT WINAPI StrCpyXChr(LPTSTR szDst, LPCTSTR szSrc, TCHAR c);

// StrGetRowColumnCount - calculate number of lines and longest line in string
//		<lpszText>			(i) string to examine
//		<lpnRows>			(o) int pointer to receive line count
//		<lpnColumnsMax>		(o) int pointer to receive size of longest line
// return 0 if success
//
int DLLEXPORT WINAPI StrGetRowColumnCount(LPCTSTR lpszText, LPINT lpnRows, LPINT lpnColumnsMax);

// StrGetRow - extract specified line from string
//		<lpszText>			(i) string from which to extract line
//		<iRow>				(i) index of line to extract (0 = first row, ...)
//		<lpszBuf>			(o) buffer to copy line into
//		<sizBuf>			(i) size of buffer
// return 0 if success
//
int DLLEXPORT WINAPI StrGetRow(LPCTSTR lpszText, int iRow, LPTSTR lpszBuf, int sizBuf);

#ifdef __cplusplus
}
#endif

#endif // __STR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\trace.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// trace.c - debug trace functions
////

#ifndef NOTRACE

#include "winlocal.h"

#include <stdlib.h>
#include <stdarg.h>

#include "trace.h"
#include "mem.h"
#include "sys.h"
#include "str.h"

////
//	private definitions
////

// wOutputTo values
//
#define TRACE_OUTPUTNONE			0x0000
#define TRACE_OUTPUTDEBUGSTRING		0x0001
#define TRACE_OUTPUTCOMM			0x0002
#if 0 // no longer supported
#define TRACE_OUTPUTFILE			0x0004
#endif
#ifdef _WIN32
#define TRACE_OUTPUTCONSOLE			0x0008
#endif

// trace control struct
//
typedef struct TRACE
{
	DWORD dwVersion;
	HINSTANCE hInst;
	HTASK hTask;
	int nLevel;
	int wOutputTo;
#ifdef TRACE_OUTPUTFILE
	HFIL hFile;
#endif
#ifdef _WIN32
	HANDLE hConsole;
#endif
	int hComm;
	LPTSTR lpszTemp;
} TRACE, FAR *LPTRACE;

// shared trace engine handle
//
static LPTRACE lpTraceShare = NULL;
static int cShareUsage = 0;

#define TRACE_SECTION TEXT("TRACE")
#define TRACE_PROFILE TraceGetProfile()

// helper functions
//
static LPTRACE TraceGetPtr(HTRACE hTrace);
static HTRACE TraceGetHandle(LPTRACE lpTrace);
static int TraceError(LPCTSTR lpszFormat, ...);
static LPTSTR TraceGetProfile(void);

////
//	public functions
////

// TraceInit - initialize trace engine
//		<dwVersion>			(i) must be TRACE_VERSION
//		<hInst>				(i) instance of calling module
// return handle to trace engine (NULL if error)
//
// NOTE: The level and destination of trace output is determined
// by values found in the file TRACE.INI in the Windows directory.
// TRACE.INI is expected to have the following format:
//
//		[TRACE]
//		Level=0						{TRACE_MINLEVEL...TRACE_MAXLEVEL}
//		OutputTo=					OutputDebugString()
//				=COM1				COM1:9600,n,8,1
//				=COM2:2400,n,8,1	specified comm device
//				=filename			specified file
#ifdef _WIN32
//				=console			stdout
#endif
//
HTRACE DLLEXPORT WINAPI TraceInit(DWORD dwVersion, HINSTANCE hInst)
{
	BOOL fSuccess = TRUE;
	LPTRACE lpTrace = NULL;
	TCHAR szOutputTo[_MAX_PATH];
#ifdef _WIN32
	BOOL fShare = TRUE; // FALSE;
#else
	BOOL fShare = TRUE;
#endif
	int nLevel = -1;
	LPTSTR lpszOutputTo = NULL;

	if (dwVersion != TRACE_VERSION)
		fSuccess = FALSE;

	else if (hInst == NULL)
		fSuccess = FALSE;

	else if (nLevel != -1 &&
		(nLevel < TRACE_MINLEVEL || nLevel > TRACE_MAXLEVEL))
		fSuccess = FALSE;

	// if a shared trace engine already exists,
	// use it rather than create another one
	//
	else if (fShare && cShareUsage > 0 && lpTraceShare != NULL)
		lpTrace = lpTraceShare;

#if 0 // can't call mem functions, because they require trace functions
	else if ((lpTrace = (LPTRACE) MemAlloc(NULL, sizeof(TRACE), 0)) == NULL)
#else
#ifdef _WIN32
	else if ((lpTrace = (LPTRACE) HeapAlloc(GetProcessHeap(),
		HEAP_ZERO_MEMORY, sizeof(TRACE))) == NULL)
#else
	else if ((lpTrace = (LPTRACE) GlobalAllocPtr(GMEM_MOVEABLE |
		GMEM_ZEROINIT, sizeof(TRACE))) == NULL)
#endif
#endif
		fSuccess = FALSE;

	else
	{
		lpTrace->dwVersion = dwVersion;
		lpTrace->hInst = hInst;
		lpTrace->hTask = GetCurrentTask();
		lpTrace->nLevel = nLevel != -1 ? nLevel :
			GetPrivateProfileInt(TRACE_SECTION, TEXT("Level"), 0, TRACE_PROFILE);
		lpTrace->wOutputTo = TRACE_OUTPUTNONE;
#ifdef TRACE_OUTPUTFILE
		lpTrace->hFile = NULL;
#endif
#ifdef _WIN32
		lpTrace->hConsole = NULL;
#endif
		lpTrace->hComm = -1;
		lpTrace->lpszTemp = NULL;

		// use the specified destination if possible
		//
		if (lpszOutputTo != NULL)
			StrNCpy(szOutputTo, lpszOutputTo, SIZEOFARRAY(szOutputTo));

		// else use the last known destination
		//
		else
		{
			GetPrivateProfileString(TRACE_SECTION, TEXT("OutputTo"), TEXT(""),
				szOutputTo, SIZEOFARRAY(szOutputTo), TRACE_PROFILE);
		}

		// use OutputDebugString() if destination == ""
		//
		if (*szOutputTo == '\0')
			lpTrace->wOutputTo = TRACE_OUTPUTDEBUGSTRING;

		// use standard output console if specified
		//
		else if (StrICmp(szOutputTo, TEXT("Console")) == 0)
		{
#ifdef _WIN32
			COORD coord;

			lpTrace->wOutputTo = TRACE_OUTPUTCONSOLE;

			AllocConsole();
			lpTrace->hConsole = GetStdHandle(STD_OUTPUT_HANDLE);

			coord.X = 80;
			coord.Y = 1000;
			SetConsoleScreenBufferSize(lpTrace->hConsole, coord);
#else
			lpTrace->wOutputTo = TRACE_OUTPUTDEBUGSTRING;
#endif
		}

		// use serial comm device if destination starts with "COMx"
		//
		else if (StrNICmp(szOutputTo, TEXT("COM"), 3) == 0 &&
			ChrIsDigit(*(szOutputTo + 3)))
		{
// Comm functions not available under WIN32
//
#ifdef _WIN32
			lpTrace->wOutputTo = TRACE_OUTPUTDEBUGSTRING;
#else
			TCHAR szComX[16];
			DCB dcb;
			int iError;

			StrNCpy(szComX, szOutputTo, 5);
			*(szComX + 5) = '\0';

			// convert "COM1" to "COM1:"
			//
			if (*(szOutputTo + 4) == '\0')
				StrCat(szOutputTo, TEXT(":"));

			// convert "COM1:" to "COM1:9600,n,8,1"
			//
			if (*(szOutputTo + 5) == '\0')
				StrCat(szOutputTo, TEXT("9600,n,8,1"));

			// [From the WinSDK KnowledgeBase PSS ID Number: Q102642]
			// The cbInQueue and cbOutQueue parameters of OpenComm() are
			// both type UINT and should be valid up to 64K. However,
			// values greater than or equal to 32K cause strange behavior.
			//
			if ((lpTrace->hComm = OpenComm(szComX, 1024, 32767)) < 0)
			{
				TraceError(TEXT("OpenComm error (%d)\n"), lpTrace->hComm);
				lpTrace->hComm = -1;
				fSuccess = FALSE;
			}

			else if ((iError = BuildCommDCB(szOutputTo, &dcb)) != 0)
			{
				TraceError(TEXT("BuildCommDCB error (%d)\n"), iError);
				fSuccess = FALSE;
			}

			else if ((iError = SetCommState(&dcb)) != 0)
			{
				TraceError(TEXT("SetCommState error (%d)\n"), iError);
				fSuccess = FALSE;
			}

			else
				lpTrace->wOutputTo = TRACE_OUTPUTCOMM;
#endif
		}

#ifdef TRACE_OUTPUTFILE
		// else assume the string must be a file name
		//
		else
		{
			if ((lpTrace->hFile = FileCreate(szOutputTo, 0, !fShare)) == NULL)
			{
				TraceError(TEXT("FileCreate error (%s)\n"), (LPTSTR) szOutputTo);
				fSuccess = FALSE;
			}

			else
				lpTrace->wOutputTo = TRACE_OUTPUTFILE;
		}
#else
		else
		{
			TraceError(TEXT("Unknown trace OutputTo (%s)\n"), (LPTSTR) szOutputTo);
			fSuccess = FALSE;
		}
#endif

		if (fSuccess &&
#if 0 // can't call mem functions, because they require trace functions
			(lpTrace->lpszTemp = (LPTSTR) MemAlloc(NULL,
			1024 * sizeof(TCHAR), 0)) == NULL)
#else
#ifdef _WIN32
			(lpTrace->lpszTemp = (LPTSTR) HeapAlloc(GetProcessHeap(),
			HEAP_ZERO_MEMORY, 1024 * sizeof(TCHAR))) == NULL)
#else
			(lpTrace->lpszTemp = (LPTSTR) GlobalAllocPtr(
			GMEM_MOVEABLE | GMEM_ZEROINIT, 1024 * sizeof(TCHAR))) == NULL)
#endif
#endif
			fSuccess = FALSE;
	}

	if (!fSuccess)
	{
		TraceTerm(TraceGetHandle(lpTrace));
		lpTrace = NULL;
	}

	// keep track of total modules sharing a task engine handle
	//
	if (fSuccess && fShare)
	{
		if (++cShareUsage == 1)
			lpTraceShare = lpTrace;
	}

	return fSuccess ? TraceGetHandle(lpTrace) : NULL;
}

// TraceTerm - shut down trace engine
//		<hTrace>			(i) handle returned from TraceInit or NULL
// return 0 if success
//
int DLLEXPORT WINAPI TraceTerm(HTRACE hTrace)
{
	BOOL fSuccess = TRUE;
	LPTRACE lpTrace;

	if ((lpTrace = TraceGetPtr(hTrace)) == NULL)
		fSuccess = FALSE;

	// only shut down trace engine if handle
	// is not shared (or is no longer being shared)
	//
	else if (lpTrace != lpTraceShare || --cShareUsage <= 0)
	{
#ifndef _WIN32
		int iError;
#endif
		// shared trace engine handle no longer valid
		//
		if (cShareUsage <= 0)
			lpTraceShare = NULL;

// Comm functions not available under WIN32
//
#ifndef _WIN32
		if (lpTrace->hComm != -1 &&
			(iError = CloseComm(lpTrace->hComm)) != 0)
		{
			TraceError(TEXT("CloseComm error (%d)\n"), iError);
			fSuccess = FALSE;
		}
		else
			lpTrace->hComm = -1;
#endif

#ifdef _WIN32
		if (lpTrace->hConsole != NULL)
		{
			FreeConsole();
			lpTrace->hConsole = NULL;
		}
#endif

#ifdef TRACE_OUTPUTFILE
		if (lpTrace->hFile != NULL &&
			FileClose(lpTrace->hFile) != 0)
		{
			TraceError(TEXT("FileClose error\n"));
			fSuccess = FALSE;
		}
		else
			lpTrace->hFile = NULL;
#endif

		if (lpTrace->lpszTemp != NULL &&
#if 0 // can't call mem functions, because they require trace functions
			(lpTrace->lpszTemp = MemFree(NULL, lpTrace->lpszTemp)) != NULL)
#else
#ifdef _WIN32
			(!HeapFree(GetProcessHeap(), 0, lpTrace->lpszTemp)))
#else
			(GlobalFreePtr(lpTrace->lpszTemp) != 0))
#endif
#endif
			fSuccess = FALSE;

		lpTrace->wOutputTo = TRACE_OUTPUTNONE;

#if 0 // can't call mem functions, because they require trace functions
		if ((lpTrace = MemFree(NULL, lpTrace)) != NULL)
#else
#ifdef _WIN32
		if (!HeapFree(GetProcessHeap(), 0, lpTrace->lpszTemp))
#else
		if (GlobalFreePtr(lpTrace->lpszTemp) != 0)
#endif
#endif
			fSuccess = FALSE;
	}

	return fSuccess ? 0 : -1;
}

// TraceGetLevel - get current trace level
//		<hTrace>			(i) handle returned from TraceInit or NULL
// return trace level (-1 if error)
//
int DLLEXPORT WINAPI TraceGetLevel(HTRACE hTrace)
{
	BOOL fSuccess = TRUE;
	LPTRACE lpTrace;

	if ((lpTrace = TraceGetPtr(hTrace)) == NULL)
		fSuccess = FALSE;

	return fSuccess ? lpTrace->nLevel : -1;
}

// TraceSetLevel - set new trace level (-1 if error)
//		<hTrace>			(i) handle returned from TraceInit or NULL
//		<nLevel>			(i) new trace level {TRACE_MINLEVEL...TRACE_MAXLEVEL}
// return 0 if success
//
int DLLEXPORT WINAPI TraceSetLevel(HTRACE hTrace, int nLevel)
{
	BOOL fSuccess = TRUE;
	LPTRACE lpTrace;

	if ((lpTrace = TraceGetPtr(hTrace)) == NULL)
		fSuccess = FALSE;

	else if (nLevel < TRACE_MINLEVEL || nLevel > TRACE_MAXLEVEL)
		fSuccess = FALSE;

	else
	{
		TCHAR szLevel[17];

		lpTrace->nLevel = nLevel;

		// save the level for next time
		//
		StrItoA(lpTrace->nLevel, szLevel, 10);
		WritePrivateProfileString(TRACE_SECTION, TEXT("Level"), szLevel, TRACE_PROFILE);

		// display new trace level whenever it changes
		//
		TracePrintf_1(hTrace, 1, TEXT("TraceLevel=%d\n"),
			(int) lpTrace->nLevel);
	}

	return fSuccess ? 0 : -1;
}

// TraceOutput - output debug string
//		<hTrace>			(i) handle returned from TraceInit or NULL
//		<nLevel>			(i) output only if current trace level is >= nLevel
//		<lpszText>			(i) string to output
// return 0 if success
//
int DLLEXPORT WINAPI TraceOutput(HTRACE hTrace, int nLevel, LPCTSTR lpszText)
{
	BOOL fSuccess = TRUE;
	LPTRACE lpTrace;

	if ((lpTrace = TraceGetPtr(hTrace)) == NULL)
		fSuccess = FALSE;

	else if (lpszText == NULL)
		fSuccess = FALSE;

	else if (nLevel > 0 && nLevel <= lpTrace->nLevel)
	{
		switch (lpTrace->wOutputTo)
		{
			case TRACE_OUTPUTNONE:
				break;

			case TRACE_OUTPUTDEBUGSTRING:
				OutputDebugString(lpszText);
				break;
#ifdef _WIN32
			case TRACE_OUTPUTCONSOLE:
				if (lpTrace->hConsole != NULL)
				{
					DWORD dwBytes;
					WriteFile(lpTrace->hConsole, lpszText, StrLen(lpszText), &dwBytes, NULL);
				}
				break;
#endif

			case TRACE_OUTPUTCOMM:
// Comm functions not available under WIN32
//
#ifdef _WIN32
				OutputDebugString(lpszText);
#else
				if (lpTrace->hComm != -1)
				{
					LPCTSTR lpsz;
					TCHAR chReturn = '\r';

					for (lpsz = lpszText; *lpsz != '\0'; lpsz = StrNextChr(lpsz))
					{
						if ((*lpsz == '\n' &&
							WriteComm(lpTrace->hComm, &chReturn, 1) < 0) ||
							WriteComm(lpTrace->hComm, lpsz, 1) <= 0)
						{
							COMSTAT comstat;
							GetCommError(lpTrace->hComm, &comstat);
							TraceError(TEXT("WriteComm error (%u, %u, %u) %s\n"),
								(UINT) comstat.status,
								(UINT) comstat.cbInQue,
								(UINT) comstat.cbOutQue,
								(LPTSTR) lpszText);
							fSuccess = FALSE;
							break;
						}
					}
				}
#endif
				break;

#ifdef TRACE_OUTPUTFILE
			case TRACE_OUTPUTFILE:
				if (lpTrace->hFile != NULL)
				{
					LPCTSTR lpsz;
					TCHAR chReturn = '\r';

					for (lpsz = lpszText; *lpsz != '\0'; lpsz = StrNextChr(lpsz))
					{
						if ((*lpsz == '\n' &&
							FileWrite(lpTrace->hFile, &chReturn, 1) == -1) ||
							FileWrite(lpTrace->hFile, lpsz, 1) == -1)
						{
							TraceError(TEXT("FileWrite error: %s\n"),
								(LPTSTR) lpszText);
							fSuccess = FALSE;
							break;
						}
					}
				}
				break;
#endif

			default:
				break;
		}
	}

	return fSuccess ? 0 : -1;
}

// TracePrintf - output formatted debug string
//		<hTrace>			(i) handle returned from TraceInit or NULL
//		<nLevel>			(i) output only if current trace level is >= nLevel
//		<lpszFormat,...>	(i) format string and arguments to output
// return 0 if success
//
int DLLEXPORT FAR CDECL TracePrintf(HTRACE hTrace, int nLevel, LPCTSTR lpszFormat, ...)
{
	BOOL fSuccess = TRUE;
	LPTRACE lpTrace;

	if ((lpTrace = TraceGetPtr(hTrace)) == NULL)
		fSuccess = FALSE;

	else if (nLevel <= lpTrace->nLevel)
	{	                    
	    va_list args;

	    va_start(args, lpszFormat);
	   	wvsprintf(lpTrace->lpszTemp, lpszFormat, args);
	    va_end(args);

		if (TraceOutput(hTrace, nLevel, lpTrace->lpszTemp) != 0)
			fSuccess = FALSE;
	}

	return fSuccess ? 0 : -1;
}

////
//	private functions
////

// TraceGetPtr - convert trace handle to trace pointer
//		<hTrace>			(i) handle returned from TraceInit or NULL
// return trace pointer (NULL if error)
//
static LPTRACE TraceGetPtr(HTRACE hTrace)
{
	BOOL fSuccess = TRUE;
	LPTRACE lpTrace;

	// use shared trace handle if no other supplied
	//
	if (hTrace == NULL && lpTraceShare != NULL)
		lpTrace = lpTraceShare;

	// create shared trace handle if no other supplied
	//
	else if (hTrace == NULL && lpTraceShare == NULL &&
		(hTrace = TraceInit(TRACE_VERSION, SysGetTaskInstance(NULL))) == NULL)
		fSuccess = FALSE;

	else if ((lpTrace = (LPTRACE) hTrace) == NULL)
		fSuccess = FALSE;

	// note: check for good pointer made only if not using lpTraceShare
	//
	else if (lpTrace != lpTraceShare &&
		IsBadWritePtr(lpTrace, sizeof(TRACE)))
		fSuccess = FALSE;

#ifdef CHECKTASK
	// make sure current task owns the trace handle
	// except when shared trace handle is used
	//
	if (fSuccess && lpTrace != lpTraceShare &&
		lpTrace->hTask != GetCurrentTask())
		fSuccess = FALSE;
#endif

	return fSuccess ? lpTrace : NULL;
}

// TraceGetHandle - convert trace pointer to trace handle
//		<lpTrace>			(i) pointer to TRACE struct
// return trace handle (NULL if error)
//
static HTRACE TraceGetHandle(LPTRACE lpTrace)
{
	BOOL fSuccess = TRUE;
	HTRACE hTrace;

	if ((hTrace = (HTRACE) lpTrace) == NULL)
		fSuccess = FALSE;

	return fSuccess ? hTrace : NULL;
}

// TraceError - display formatted trace error string
//		<lpszFormat...>		(i) format string and arguments to output
// return 0 if success
//
static int TraceError(LPCTSTR lpszFormat, ...)
{
	BOOL fSuccess = TRUE;
    va_list args;
	TCHAR lpszTemp[256];

    va_start(args, lpszFormat);
   	wvsprintf(lpszTemp, lpszFormat, args);
    va_end(args);

	OutputDebugString(lpszTemp);

	return fSuccess ? 0 : -1;
}

// TraceGetProfile - get trace ini file name
// return pointer to file name
//
static LPTSTR TraceGetProfile(void)
{
	return TEXT("trace.ini");
}

#endif // #ifndef NOTRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\tim.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	tim.c - time functions
////

#include "winlocal.h"

#include <time.h>

#include "tim.h"
#include "str.h"

////
//	private definitions
////

// Time_t is stored as (hour * HOURFACTOR + minute * MINUTEFACTOR +
// 						second * SECONDFACTOR + millesecond)
// i.e. 23:59:59.999 is stored as 235959999
//
#define HOURFACTOR		10000000L
#define MINUTEFACTOR	100000L
#define SECONDFACTOR	1000L

// helper functions
//

////
//	public functions
////

// Time - return time value representing hour, minute, second, and millesecond
//		<h>					(i) hour
//		<m>					(i) minute
//		<s>					(i) second
//		<ms>				(i) millesecond
// return time value (0 if error)
//
Time_t DLLEXPORT WINAPI Time(Hour_t h, Minute_t m, Second_t s, Millesecond_t ms)
{
	Time_t time;

	time = h * HOURFACTOR + m * MINUTEFACTOR + s * SECONDFACTOR + ms;

	if (!TimeIsValid(time))
		return (Time_t) 0;

	return time;
}

// TimeNow - return time value representing current hour, minute, and second, and millesecond
// return time value (0 if error)
//
Time_t DLLEXPORT WINAPI TimeNow(void)
{
	static time_t timeCurr;
	static struct tm *tmCurr;

	timeCurr = time(NULL);
	tmCurr = localtime(&timeCurr);

	return Time((Hour_t) tmCurr->tm_hour, (Minute_t) tmCurr->tm_min,
		(Second_t) tmCurr->tm_sec, (Millesecond_t) 0);
}

// TimeValue - return time value representing given time string
//		<lpszTime>			(i) time string to convert
//			"23:59:59.999"
//			etc.
// return time value (0 if error)
//
Time_t DLLEXPORT WINAPI TimeValue(LPCTSTR lpszTime)
{
	Hour_t h = 0;
	Minute_t m = 0;
	Second_t s = 0;
	Millesecond_t ms = 0;
	LPTSTR lpszDelimiters = TEXT(" \t/-.,;:");
	TCHAR szTimeTmp[32];
	LPTSTR lpszToken1;
	LPTSTR lpszToken2;
	LPTSTR lpszToken3;
	LPTSTR lpszToken4;

	*szTimeTmp = '\0';
	if (lpszTime != NULL)
		StrNCpy(szTimeTmp, lpszTime, SIZEOFARRAY(szTimeTmp));

	lpszToken1 = StrTok(szTimeTmp, lpszDelimiters);
	lpszToken2 = StrTok(NULL, lpszDelimiters);
	lpszToken3 = StrTok(NULL, lpszDelimiters);
	lpszToken4 = StrTok(NULL, lpszDelimiters);

	h = (lpszToken1 == NULL ? 0 : StrAtoI(lpszToken1));
	m = (lpszToken2 == NULL ? 0 : StrAtoI(lpszToken2));
	s = (lpszToken3 == NULL ? 0 : StrAtoI(lpszToken3));
	ms = (lpszToken4 == NULL ? 0 : StrAtoI(lpszToken4));

	return Time(h, m, s, ms);
}

// TimeHour - return hour of a given time (0-23)
//		<t>					(i) time value
// return hour
//
Hour_t DLLEXPORT WINAPI TimeHour(Time_t t)
{
	return (Hour_t) (t / HOURFACTOR);
}

// TimeMinute - return minute of a given time (0-59)
//		<t>					(i) time value
// return minute
//
Minute_t DLLEXPORT WINAPI TimeMinute(Time_t t)
{
	return (Minute_t) ((t % HOURFACTOR) / MINUTEFACTOR);
}

// TimeSecond - return second of a given time (0-59)
//		<t>					(i) time value
// return second
//
Second_t DLLEXPORT WINAPI TimeSecond(Time_t t)
{
	return (Second_t) ((t % MINUTEFACTOR) / SECONDFACTOR);
}

// TimeMillesecond - return millesecond of a given time (0-999)
//		<t>					(i) time value
// return second
//
Millesecond_t DLLEXPORT WINAPI TimeMillesecond(Time_t t)
{
	return (Millesecond_t) ((t % MINUTEFACTOR) % SECONDFACTOR);
}

// TimeDayMillesecond - return millesecond since the start of the day for a given time
//		<t>					(i) time value
// return millesecond
//
long DLLEXPORT WINAPI TimeDayMillesecond(Time_t t)
{
	Hour_t h;
	Minute_t m;
	Second_t s;
	Millesecond_t ms;

	if (!TimeIsValid(t))
		return (Millesecond_t) 0;

	h = TimeHour(t);
	m = TimeMinute(t);
	s = TimeSecond(t);
	ms = TimeMillesecond(t);

    return (long) (h * 60L * 60L * 1000L) +
		(m * 60L * 1000L) + (s * 1000L) + ms;
}

// TimeIsValid - test <t> for validity
//		<t>					(i) time value
// return TRUE if valid
//
BOOL DLLEXPORT WINAPI TimeIsValid(Time_t t)
{
	BOOL fValid = TRUE;
	Hour_t h = TimeHour(t);
	Minute_t m = TimeMinute(t);
	Second_t s = TimeSecond(t);
	Millesecond_t ms = TimeMillesecond(t);

	// check for invalid hour, minute, second, or millesecond
	//
	if (h < 0 || h > 23 || m < 0 || m > 59 ||
		s < 0 || s > 59 || ms < 0 || ms > 999)
        fValid = FALSE;

    return fValid;
}

// TimeIsAfternoon - return TRUE if <t> represents a time after noon
//		<t>					(i) time value
// return TRUE if leap hour
//
BOOL DLLEXPORT WINAPI TimeIsAfternoon(Time_t t)
{
	return (BOOL) (TimeHour(t) >= 12);
}

// TimeNew - return time value which is <n> milleseconds from time <t>	
//		<t>					(i) time value
//		<n>					(i) delta
//			+1					one millesecond later
//			-1					one millesecond earlier, etc.
// return time value (0 if error)
//
Time_t DLLEXPORT WINAPI TimeNew(Time_t t, long n)
{
	Hour_t h;
	Minute_t m;
	Second_t s;
	Millesecond_t ms;

	if (!TimeIsValid(t))
		return (Time_t) 0;

	h = TimeHour(t);
	m = TimeMinute(t);
	s = TimeSecond(t);
	ms = TimeMillesecond(t);

    if (n > 0)
    {
		// increment time n times
		//
        for ( ; n != 0; n--)
        {
			if (++ms == 1000)
			{
				ms = 0;
				if (++s == 60)
				{
					s = 0;
					if (++m == 60)
					{
						m = 0;
						if (++h == 24)
							h = 0;
					}
				}
			}
        }
    }
    else
    {
		// decrement time n times
		//
        for ( ; n != 0; n++)
        {
			if (--ms < 0)
			{
				ms = 999;
				if (--s < 0)
				{
					s = 59;
					if (--m < 0)
					{
						m = 59;
						if (--h < 0)
							h = 23;
					}
				}
			}
		}
    }

	return Time(h, m, s, ms);
}

// TimeCmp - return number of milleseconds between t1 and t2 (t1 minus t2)
//		<t1>				(i) time value
//		<t2>				(i) time value
// return milleseconds between times
//
long DLLEXPORT WINAPI TimeCmp(Time_t t1, Time_t t2)
{
    return (long) (TimeDayMillesecond(t1) - TimeDayMillesecond(t2));
}

// TimeStartSecond - return time representing start the second relative to time <t>
//		<t>					(i) time value
// return time value (0 if error)
//
Time_t DLLEXPORT WINAPI TimeStartSecond(Time_t t)
{
	return Time(TimeHour(t), TimeMinute(t), TimeSecond(t), 0);
}

// TimeEndSecond - return time representing end of the second relative to time <t>
//		<t>					(i) time value
// return time value (0 if error)
//
Time_t DLLEXPORT WINAPI TimeEndSecond(Time_t t)
{
	return Time(TimeHour(t), TimeMinute(t), TimeSecond(t), 999);
}

// TimeStartMinute - return time representing start the minute relative to time <t>
//		<t>					(i) time value
// return time value (0 if error)
//
Time_t DLLEXPORT WINAPI TimeStartMinute(Time_t t)
{
	return Time(TimeHour(t), TimeMinute(t), 0, 0);
}

// TimeEndMinute - return time representing end of the minute relative to time <t>
//		<t>					(i) time value
// return time value (0 if error)
//
Time_t DLLEXPORT WINAPI TimeEndMinute(Time_t t)
{
	return Time(TimeHour(t), TimeMinute(t), 59, 999);
}

// TimeStartHour - return time representing start of the hour relative to time <t>
//		<t>					(i) time value
// return time value (0 if error)
//
Time_t DLLEXPORT WINAPI TimeStartHour(Time_t t)
{
	return Time(TimeHour(t), 0, 0, 0);
}

// TimeEndHour - return time representing end of the hour relative to time <t>
//		<t>					(i) time value
// return time value (0 if error)
//
Time_t DLLEXPORT WINAPI TimeEndHour(Time_t t)
{
	return Time(TimeHour(t), 59, 59, 999);
}

// TimeStartLastSecond - return time representing start of previous second
// return time value (0 if error)
//
Time_t DLLEXPORT WINAPI TimeStartLastSecond(void)
{
	return TimeStartSecond(TimeEndLastSecond());
}

// TimeEndLastSecond - return time representing end of previous second
// return time value (0 if error)
//
Time_t DLLEXPORT WINAPI TimeEndLastSecond(void)
{
	return TimeNew(TimeStartSecond(TimeNow()), -1);
}

// TimeStartLastMinute - return time representing start of previous minute
// return time value (0 if error)
//
Time_t DLLEXPORT WINAPI TimeStartLastMinute(void)
{
	return TimeStartMinute(TimeEndLastMinute());
}

// TimeEndLastMinute - return time representing end of previous minute
// return time value (0 if error)
//
Time_t DLLEXPORT WINAPI TimeEndLastMinute(void)
{
	return TimeNew(TimeStartMinute(TimeNow()), -1);
}

// TimeStartLastHour - return time representing start of previous hour
// return time value (0 if error)
//
Time_t DLLEXPORT WINAPI TimeStartLastHour(void)
{
	return TimeStartHour(TimeEndLastHour());
}

// TimeEndLastHour - return time representing end of previous hour
// return time value (0 if error)
//
Time_t DLLEXPORT WINAPI TimeEndLastHour(void)
{
	return TimeNew(TimeStartHour(TimeNow()), -1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\sys.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// sys.h - interface for system functions in sys.c
////

#ifndef __SYS_H__
#define __SYS_H__

#include "winlocal.h"

#define SYS_VERSION 0x00000107

// flags returned by SysGetWinFlags
//
#define SYS_WF_WIN3X			0x00000001
#define SYS_WF_WINNT			0x00000002
#define SYS_WF_WIN95			0x00000004

#ifdef __cplusplus
extern "C" {
#endif

// SysGetWinFlags - get system information
// return flags
//		SYS_WF_WIN3X			Windows 3.x
//		SYS_WF_WINNT			Windows NT
//		SYS_WF_WIN95			Windows 95
//
DWORD DLLEXPORT WINAPI SysGetWinFlags(void);

// SysGetWindowsVersion - get version of Microsoft Windows
// return version (v3.10 = 310, etc.)
//
UINT DLLEXPORT WINAPI SysGetWindowsVersion(void);

// SysGetDOSVersion - get version of Microsoft DOS
// return version (v6.20 = 620, etc.)
//
UINT DLLEXPORT WINAPI SysGetDOSVersion(void);

// SysGetTimerCount - get elapsed time since Windows started
// return milleseconds
//
#ifdef _WIN32
#define SysGetTimerCount() GetTickCount()
#else
DWORD DLLEXPORT WINAPI SysGetTimerCount(void);
#endif

// SysGetTaskInstance - get instance handle of specified task
//		<hTask>				(i) specified task
//			NULL				current task
// returns instance handle (NULL if error)
//
// NOTE: under WIN32, <hTask> must be NULL
//
#ifdef _WIN32
#define SysGetTaskInstance(hTask) \
	(hTask == NULL ? GetModuleHandle(NULL) : NULL)
#else
HINSTANCE DLLEXPORT WINAPI SysGetTaskInstance(HTASK hTask);
#endif

#ifdef __cplusplus
}
#endif

#endif // __SYS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\sys.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	sys.c - system functions
////

#include "winlocal.h"

#include <stdlib.h>
#include <stdarg.h>

#include "sys.h"

#ifndef _WIN32
#include <toolhelp.h> // get TimerCount and TaskFindHandle prototypes

#ifdef VERTHUNK
// generic thunk prototypes from "/msdev/include/wownt16.h"
DWORD FAR PASCAL LoadLibraryEx32W(LPCSTR lpszLibFile, DWORD hFile, DWORD dwFlags);
DWORD FAR PASCAL GetProcAddress32W(DWORD hModule, LPCSTR lpszProc);
DWORD FAR PASCAL FreeLibrary32W(DWORD hLibModule);
DWORD FAR CallProcEx32W( DWORD, DWORD, DWORD, ... );
#endif

#endif

////
//	private definitions
////

// flag returned by GetWinFlags but not defined in windows.h
//
#ifndef WF_WINNT
#define WF_WINNT 0x4000
#endif

////
//	public functions
////

// SysGetWinFlags - get system information
// return flags
//		SYS_WF_WIN3X			Windows 3.x
//		SYS_WF_WINNT			Windows NT
//		SYS_WF_WIN95			Windows 95
//
DWORD DLLEXPORT WINAPI SysGetWinFlags(void)
{
	DWORD dwSysWinFlags = 0;
	DWORD dwVersion = GetVersion();

#ifdef _WIN32
	if (!(dwVersion & 0x80000000))
		dwSysWinFlags |= SYS_WF_WINNT;
	else if ((dwVersion & 0x80000000) && LOBYTE(LOWORD(dwVersion)) >= 4)
		dwSysWinFlags |= SYS_WF_WIN95;
	else
		dwSysWinFlags |= SYS_WF_WIN3X;
#else
	DWORD dwWinFlags = GetWinFlags();

	if (dwWinFlags & WF_WINNT)
		dwSysWinFlags |= SYS_WF_WINNT;
	else if (LOBYTE(LOWORD(dwVersion)) == 3 &&
		HIBYTE(LOWORD(dwVersion)) == 95)
		dwSysWinFlags |= SYS_WF_WIN95;
	else
		dwSysWinFlags |= SYS_WF_WIN3X;
#endif

	return dwSysWinFlags;
}

// SysGetWindowsVersion - get version of Microsoft Windows
// return version (v3.10 = 310, etc.)
//
UINT DLLEXPORT WINAPI SysGetWindowsVersion(void)
{
	static DWORD dwVersion = 0;
	BYTE nVersionMajor;
	BYTE nVersionMinor;

	// only get version the first time this function is called
	//
	if (dwVersion == 0)
	{
#ifndef _WIN32
#ifdef VERTHUNK
		DWORD dwFlags = SysGetWinFlags();
#endif
#endif
		// only get version the first time this function is called
		//
		dwVersion = GetVersion();

#ifndef _WIN32
#ifdef VERTHUNK
		// 16 bit GetVersion() returns v3.10 for WinNT and v3.95 for Win95
		// so we will call the 32-bit version of GetVersion
		//
		if ((dwFlags & SYS_WF_WINNT) || (dwFlags & SYS_WF_WIN95))
		{
			DWORD hKernel32;
			DWORD lpfnGetVersion;

			if ((hKernel32 = LoadLibraryEx32W("KERNEL32.DLL", NULL, 0)) != 0)
			{
				if ((lpfnGetVersion = GetProcAddress32W(hKernel32, "GetVersion")) != 0)
					dwVersion = CallProcEx32W(0, 0, lpfnGetVersion);

				FreeLibrary32W(hKernel32);
			}
		}
#endif
#endif
	}

	nVersionMajor = LOBYTE(LOWORD(dwVersion));
	nVersionMinor = HIBYTE(LOWORD(dwVersion));

	return ((UINT) nVersionMajor * 100) + (UINT) nVersionMinor;
}

// SysGetDOSVersion - get version of Microsoft DOS
// return version (v6.20 = 620, etc.)
//
UINT DLLEXPORT WINAPI SysGetDOSVersion(void)
{
	DWORD dwVersion = GetVersion();
	BYTE nVersionMajor = LOBYTE(HIWORD(dwVersion));
	BYTE nVersionMinor = HIBYTE(HIWORD(dwVersion));

	return ((UINT) nVersionMajor * 100) + (UINT) nVersionMinor;
}

#ifndef _WIN32
// SysGetTimerCount - get elapsed time since Windows started
// return milleseconds
//
DWORD DLLEXPORT WINAPI SysGetTimerCount(void)
{
	DWORD msSinceStart;

// TimerCount() not available under WIN32
//
#ifndef _WIN32
	TIMERINFO ti;

	ti.dwSize = sizeof(TIMERINFO);

	// use TimerCount function if possible, because
	// it is much more accurate than GetTickCount
	//
	if (TimerCount(&ti))
		msSinceStart = ti.dwmsSinceStart;
	else
#endif
		msSinceStart = GetTickCount();

	return msSinceStart;
}
#endif

#ifndef _WIN32
// SysGetTaskInstance - get instance handle of specified task
//		<hTask>				(i) specified task
//			NULL				current task
// returns instance handle (NULL if error)
//
// NOTE: under WIN32, <hTask> must be NULL
//
HINSTANCE DLLEXPORT WINAPI SysGetTaskInstance(HTASK hTask)
{
	BOOL fSuccess = TRUE;
	HINSTANCE hInst;

#ifdef _WIN32
	if (hTask != NULL)
		fSuccess = FALSE; // $FIXUP - any alternatives ?

	else if ((hInst = GetModuleHandle(NULL)) == NULL)
		fSuccess = FALSE;
#else
	TASKENTRY te;

	// prepare to call TaskFindHandle
	//
	te.dwSize = sizeof(TASKENTRY);

	// assume current task if none specified
	//
	if (hTask == NULL && (hTask = GetCurrentTask()) == NULL)
		fSuccess = FALSE;
	
	// get instance handle of specified task
	//
	else if (!TaskFindHandle(&te, hTask))
		fSuccess = FALSE;

	else
		hInst = te.hInst;
#endif

	return fSuccess ? hInst : NULL;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\tim.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// tim.h - interface for time functions in tim.c
////

#ifndef __TIME_H__
#define __TIME_H__

#include "winlocal.h"

#define TIME_VERSION 0x00000100

// time types
//
typedef long Time_t;
typedef short Hour_t;
typedef short Minute_t;
typedef short Second_t;
typedef short Millesecond_t;

#ifdef __cplusplus
extern "C" {
#endif

// Time - return time value representing hour, minute, second, and millesecond
//		<h>					(i) hour
//		<m>					(i) minute
//		<s>					(i) second
//		<ms>				(i) millesecond
// return time value (0 if error)
//
Time_t DLLEXPORT WINAPI Time(Hour_t h, Minute_t m, Second_t s, Millesecond_t ms);

// TimeNow - return time value representing current hour, minute, and second, and millesecond
// return time value (0 if error)
//
Time_t DLLEXPORT WINAPI TimeNow(void);

// TimeValue - return time value representing given time string
//		<lpszTime>			(i) time string to convert
//			"23:59:59.999"
//			etc.
// return time value (0 if error)
//
Time_t DLLEXPORT WINAPI TimeValue(LPCTSTR lpszTime);

// TimeHour - return hour of a given time (0-23)
//		<t>					(i) time value
// return hour
//
Hour_t DLLEXPORT WINAPI TimeHour(Time_t t);

// TimeMinute - return minute of a given time (0-59)
//		<t>					(i) time value
// return minute
//
Minute_t DLLEXPORT WINAPI TimeMinute(Time_t t);

// TimeSecond - return second of a given time (0-59)
//		<t>					(i) time value
// return second
//
Second_t DLLEXPORT WINAPI TimeSecond(Time_t t);

// TimeMillesecond - return millesecond of a given time (0-999)
//		<t>					(i) time value
// return second
//
Millesecond_t DLLEXPORT WINAPI TimeMillesecond(Time_t t);

// TimeDayMillesecond - return millesecond since the start of the day for a given time
//		<t>					(i) time value
// return millesecond
//
long DLLEXPORT WINAPI TimeDayMillesecond(Time_t t);

// TimeIsValid - test <t> for validity
//		<t>					(i) time value
// return TRUE if valid
//
BOOL DLLEXPORT WINAPI TimeIsValid(Time_t t);

// TimeIsAfternoon - return TRUE if <t> represents a time after noon
//		<t>					(i) time value
// return TRUE if leap hour
//
BOOL DLLEXPORT WINAPI TimeIsAfternoon(Time_t t);

// TimeNew - return time value which is <n> milleseconds from time <t>	
//		<t>					(i) time value
//		<n>					(i) delta
//			+1					one millesecond later
//			-1					one millesecond earlier, etc.
// return time value (0 if error)
//
Time_t DLLEXPORT WINAPI TimeNew(Time_t t, long n);

// TimeCmp - return number of milleseconds between t1 and t2 (t1 minus t2)
//		<t1>				(i) time value
//		<t2>				(i) time value
// return milleseconds between times
//
long DLLEXPORT WINAPI TimeCmp(Time_t t1, Time_t t2);

// TimeStartSecond - return time representing start the second relative to time <t>
//		<t>					(i) time value
// return time value (0 if error)
//
Time_t DLLEXPORT WINAPI TimeStartSecond(Time_t t);

// TimeEndSecond - return time representing end of the second relative to time <t>
//		<t>					(i) time value
// return time value (0 if error)
//
Time_t DLLEXPORT WINAPI TimeEndSecond(Time_t t);

// TimeStartMinute - return time representing start the minute relative to time <t>
//		<t>					(i) time value
// return time value (0 if error)
//
Time_t DLLEXPORT WINAPI TimeStartMinute(Time_t t);

// TimeEndMinute - return time representing end of the minute relative to time <t>
//		<t>					(i) time value
// return time value (0 if error)
//
Time_t DLLEXPORT WINAPI TimeEndMinute(Time_t t);

// TimeStartHour - return time representing start of the hour relative to time <t>
//		<t>					(i) time value
// return time value (0 if error)
//
Time_t DLLEXPORT WINAPI TimeStartHour(Time_t t);

// TimeEndHour - return time representing end of the hour relative to time <t>
//		<t>					(i) time value
// return time value (0 if error)
//
Time_t DLLEXPORT WINAPI TimeEndHour(Time_t t);

// TimeStartLastSecond - return time representing start of previous second
// return time value (0 if error)
//
Time_t DLLEXPORT WINAPI TimeStartLastSecond(void);

// TimeEndLastSecond - return time representing end of previous second
// return time value (0 if error)
//
Time_t DLLEXPORT WINAPI TimeEndLastSecond(void);

// TimeStartLastMinute - return time representing start of previous minute
// return time value (0 if error)
//
Time_t DLLEXPORT WINAPI TimeStartLastMinute(void);

// TimeEndLastMinute - return time representing end of previous minute
// return time value (0 if error)
//
Time_t DLLEXPORT WINAPI TimeEndLastMinute(void);

// TimeStartLastHour - return time representing start of previous hour
// return time value (0 if error)
//
Time_t DLLEXPORT WINAPI TimeStartLastHour(void);

// TimeEndLastHour - return time representing end of previous hour
// return time value (0 if error)
//
Time_t DLLEXPORT WINAPI TimeEndLastHour(void);

// macros to emulate MS Excel macros, etc.
//
#define TIME(h, m, s, ms) Time(h, m, s, ms)
#define NOW() TimeNow()
#define TIMEVALUE(lpszTime) TimeValue(lpszTime)
#define HOUR(t) TimeHour(t)
#define MINUTE(t) TimeMinute(t)
#define SECOND(t) TimeSecond(t)
#define MILLESECOND(t) TimeMillesecond(t)
#define TIMEDAYMILLESECOND(t) TimeDayMillesecond(t)
#define ISVALIDTIME(t) TimeIsValid(t)
#define ISAFTERNOON(t) TimeIsAfternoon(t)
#define NEWTIME(t, offset) TimeNew(t, offset)
#define TIMECMP(t1, t2) TimeCmp(t1, t2)
#define STARTSECOND(t) TimeStartSecond(t)
#define ENDSECOND(t) TimeEndSecond(t)
#define STARTMINUTE(t) TimeStartMinute(t)
#define ENDMINUTE(t) TimeEndMinute(t)
#define STARTHOUR(t) TimeStartHour(t)
#define ENDHOUR(t) TimeEndHour(t)
#define STARTLASTSECOND() TimeStartLastSecond()
#define ENDLASTSECOND() TimeEndLastSecond()
#define STARTLASTMINUTE() TimeStartLastMinute()
#define ENDLASTMINUTE() TimeEndLastMinute()
#define STARTLASTHOUR() TimeStartLastHour()
#define ENDLASTHOUR() TimeEndLastHour()

#ifdef __cplusplus
}
#endif

#endif // __TIME_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\winlocal.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	winlocal.h - local windows include umbrella
////

#ifndef __WINLOCAL_H__
#define __WINLOCAL_H__

#ifndef STRICT
#define STRICT
#endif

#ifndef WINVER
#ifndef _WIN32
#define WINVER 0x030A
#endif
#endif

#ifndef _MFC_VER
#include <windows.h>
#include <windowsx.h>
#endif

#ifndef EXPORT
#ifdef _WIN32
#define EXPORT
#else
#define EXPORT __export
#endif
#endif

#ifndef DLLEXPORT
#ifdef _WIN32
#define DLLEXPORT __declspec(dllexport)
#else
#define DLLEXPORT __export
#endif
#endif

#ifndef DLLIMPORT
#ifdef _WIN32
#define DLLIMPORT __declspec(dllimport)
#else
#define DLLIMPORT __export
#endif
#endif

////
//	scalar types containing specific number of bits
////
#if 0

#ifndef INT8
typedef signed char INT8;
typedef INT8 FAR * LPINT8;
#endif

#ifndef UINT8
typedef unsigned char UINT8;
typedef UINT8 FAR * LPUINT8;
#endif

#ifndef INT16
typedef signed short INT16;
typedef INT16 FAR * LPINT16;
#endif

#ifndef UINT16
typedef unsigned short UINT16;
typedef UINT16 FAR * LPUINT16;
#endif

#ifndef INT32
typedef signed long INT32;
typedef INT32 FAR * LPINT32;
#endif

#ifndef UINT32
typedef unsigned long UINT32;
typedef UINT32 FAR * LPUINT32;
#endif

#endif

////
//	misc macros
////

#ifndef SIZEOFARRAY
#define SIZEOFARRAY(a) (sizeof(a) / sizeof(a[0]))
#endif

#ifndef NOREF
#define NOREF(p) p
#endif

#ifndef MAKEWORD
#define MAKEWORD(low, high) ((WORD)(((BYTE)(low)) | (((WORD)((BYTE)(high))) << 8)))
#endif

////
//	_WIN32 portability stuff
////

#ifdef _WIN32

#define _huge

#define GetCurrentTask() ((HTASK) GetCurrentProcess())

#ifndef DECLARE_HANDLE32
#define DECLARE_HANDLE32    DECLARE_HANDLE
#endif

#else // #ifndef _WIN32

#ifndef TEXT
#define TEXT(s) s
#endif

#if 0

#define RegOpenKeyEx(hKey, lpSubKey, ulOptions, samDesired, phkResult) \
	RegOpenKey(HKEY_CLASSES_ROOT, lpSubKey, phkResult)

#define RegCreateKeyEx(hKey, lpSubKey, Reserved, lpClass, dwOptions, \
	samDesired, lpSecurityAttributes, phkResult, lpdwDisposition) \
	RegCreateKey(HKEY_CLASSES_ROOT, lpSubKey, phkResult)

#define RegQueryValueEx(hKey, lpValueName, lpReserved, lpType, lpData, lpcbData) \
	RegQueryValue(hKey, lpValueName, lpData, lpcbData)

#define RegSetValueEx(hKey, lpValueName, Reserved, dwType, lpData, cbData) \
	RegSetValue(hKey, lpValueName, REG_SZ, lpData, cbData)

#endif

#endif

#endif // __WINLOCAL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\trace.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// trace.h - interface for debugging trace functions in trace.c
////

#ifndef __TRACE_H__
#define __TRACE_H__

#include "winlocal.h"

#define TRACE_VERSION 0x00000100

// handle to trace engine
//
DECLARE_HANDLE32(HTRACE);

#define TRACE_MINLEVEL 0
#define TRACE_MAXLEVEL 9

#ifdef __cplusplus
extern "C" {
#endif

// TraceInit - initialize trace engine
//		<dwVersion>			(i) must be TRACE_VERSION
//		<hInst>				(i) instance of calling module
// return handle to trace engine (NULL if error)
//
// NOTE: The level and destination of trace output is determined
// by values found in the file TRACE.INI in the Windows directory.
// TRACE.INI is expected to have the following format:
//
//		[TRACE]
//		Level=0						{TRACE_MINLEVEL...TRACE_MAXLEVEL}
//		OutputTo=					OutputDebugString()
//				=COM1				COM1:9600,n,8,1
//				=COM2:2400,n,8,1	specified comm device
#ifdef TRACE_OUTPUTFILE
//				=filename			specified file
#endif
#ifdef _WIN32
//				=console			stdout
#endif
//
#ifdef NOTRACE
#define TraceInit(dwVersion, hInst) 1
#else
HTRACE DLLEXPORT WINAPI TraceInit(DWORD dwVersion, HINSTANCE hInst);
#endif

// TraceTerm - shut down trace engine
//		<hTrace>			(i) handle returned from TraceInit or NULL
// return 0 if success
//
#ifdef NOTRACE
#define TraceTerm(hTrace) 0
#else
int DLLEXPORT WINAPI TraceTerm(HTRACE hTrace);
#endif

// TraceGetLevel - get current trace level
//		<hTrace>			(i) handle returned from TraceInit or NULL
// return trace level (-1 if error)
//
#ifdef NOTRACE
#define TraceGetLevel(hTrace) 0
#else
int DLLEXPORT WINAPI TraceGetLevel(HTRACE hTrace);
#endif

// TraceSetLevel - set new trace level (-1 if error)
//		<hTrace>			(i) handle returned from TraceInit or NULL
//		<nLevel>			(i) new trace level {TRACE_MINLEVEL...TRACE_MAXLEVEL}
// return 0 if success
//
#ifdef NOTRACE
#define TraceSetLevel(hTrace) 0
#else
int DLLEXPORT WINAPI TraceSetLevel(HTRACE hTrace, int nLevel);
#endif

// TraceOutput - output debug string
//		<hTrace>			(i) handle returned from TraceInit or NULL
//		<nLevel>			(i) output only if current trace level is >= nLevel
//		<lpszText>			(i) string to output
// return 0 if success
//
#ifdef NOTRACE
#define TraceOutput(hTrace, nLevel, lpszText) 0
#else
int DLLEXPORT WINAPI TraceOutput(HTRACE hTrace, int nLevel, LPCTSTR lpszText);
#endif

// TracePrintf - output formatted debug string
//		<hTrace>			(i) handle returned from TraceInit or NULL
//		<nLevel>			(i) output only if current trace level is >= nLevel
//		<lpszFormat,...>	(i) format string and arguments to output
// return 0 if success
//
#ifdef NOTRACE
#define TracePrintf_0(hTrace, nLevel, lpszFormat) 0
#define TracePrintf_1(hTrace, nLevel, lpszFormat, p1) 0
#define TracePrintf_2(hTrace, nLevel, lpszFormat, p1, p2) 0
#define TracePrintf_3(hTrace, nLevel, lpszFormat, p1, p2, p3) 0
#define TracePrintf_4(hTrace, nLevel, lpszFormat, p1, p2, p3, p4) 0
#define TracePrintf_5(hTrace, nLevel, lpszFormat, p1, p2, p3, p4, p5) 0
#define TracePrintf_6(hTrace, nLevel, lpszFormat, p1, p2, p3, p4, p5, p6) 0
#define TracePrintf_7(hTrace, nLevel, lpszFormat, p1, p2, p3, p4, p5, p6, p7) 0
#define TracePrintf_8(hTrace, nLevel, lpszFormat, p1, p2, p3, p4, p5, p6, p7, p8) 0
#define TracePrintf_9(hTrace, nLevel, lpszFormat, p1, p2, p3, p4, p5, p6, p7, p8, p9) 0
#else
int DLLEXPORT FAR CDECL TracePrintf(HTRACE hTrace, int nLevel, LPCTSTR lpszFormat, ...);
#define TracePrintf_0(hTrace, nLevel, lpszFormat) \
	TracePrintf(hTrace, nLevel, lpszFormat)
#define TracePrintf_1(hTrace, nLevel, lpszFormat, p1) \
	TracePrintf(hTrace, nLevel, lpszFormat, p1)
#define TracePrintf_2(hTrace, nLevel, lpszFormat, p1, p2) \
	TracePrintf(hTrace, nLevel, lpszFormat, p1, p2)
#define TracePrintf_3(hTrace, nLevel, lpszFormat, p1, p2, p3) \
	TracePrintf(hTrace, nLevel, lpszFormat, p1, p2, p3)
#define TracePrintf_4(hTrace, nLevel, lpszFormat, p1, p2, p3, p4) \
	TracePrintf(hTrace, nLevel, lpszFormat, p1, p2, p3, p4)
#define TracePrintf_5(hTrace, nLevel, lpszFormat, p1, p2, p3, p4, p5) \
	TracePrintf(hTrace, nLevel, lpszFormat, p1, p2, p3, p4, p5)
#define TracePrintf_6(hTrace, nLevel, lpszFormat, p1, p2, p3, p4, p5, p6) \
	TracePrintf(hTrace, nLevel, lpszFormat, p1, p2, p3, p4, p5, p6)
#define TracePrintf_7(hTrace, nLevel, lpszFormat, p1, p2, p3, p4, p5, p6, p7) \
	TracePrintf(hTrace, nLevel, lpszFormat, p1, p2, p3, p4, p5, p6, p7)
#define TracePrintf_8(hTrace, nLevel, lpszFormat, p1, p2, p3, p4, p5, p6, p7, p8) \
	TracePrintf(hTrace, nLevel, lpszFormat, p1, p2, p3, p4, p5, p6, p7, p8)
#define TracePrintf_9(hTrace, nLevel, lpszFormat, p1, p2, p3, p4, p5, p6, p7, p8, p9) \
	TracePrintf(hTrace, nLevel, lpszFormat, p1, p2, p3, p4, p5, p6, p7, p8, p9)
#endif

// TracePosition - output current source file name and line number
//		<hTrace>			(i) handle returned from TraceInit or NULL
//		<nLevel>			(i) output only if current trace level is >= nLevel
// return 0 if success
//
#ifdef NOTRACE
#define TracePosition(hTrace, nLevel)
#else
#define TracePosition(hTrace, nLevel) TracePrintf(hTrace, nLevel, \
	TEXT("%s(%u) : *** TracePosition\n"), (LPSTR) __FILE__, (unsigned) __LINE__)
#endif

// TraceFALSE - output file and line number, return FALSE
//		<hTrace>			(i) handle returned from TraceInit or NULL
// return FALSE
// 
// NOTE: Useful for tracking down where a function failure originates.
//		For example,
//
//		if (Function(a, b, c) != 0)
//		   	fSuccess = TraceFALSE(NULL);
//
#ifdef NOTRACE
#define TraceFALSE(hTrace) FALSE
#define TraceTRUE(hTrace) TRUE
#else
#define TraceFALSE(hTrace) (TracePosition(hTrace, 3), FALSE)
#define TraceTRUE(hTrace) (TracePosition(hTrace, 3), TRUE)
#endif

#ifdef __cplusplus
}
#endif

#endif // __TRACE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\avgenntfy.cpp ===
// AVGenNtfy.cpp : Implementation of CAVGeneralNotification
#include "stdafx.h"
#include "TapiDialer.h"
#include "AVGenNtfy.h"
#include "GenNtfy.h"

/////////////////////////////////////////////////////////////////////////////
// CAVGeneralNotification

#define VECT_CLS CAVGeneralNotification
#define VECT_IID IID_IGeneralNotification
#define VECT_IPTR IGeneralNotification

STDMETHODIMP CAVGeneralNotification::Init()
{
	_Module.SetAVGenNot( this );
	return S_OK;
}

STDMETHODIMP CAVGeneralNotification::Term()
{
	_Module.SetAVGenNot( NULL );
	return S_OK;
}

STDMETHODIMP CAVGeneralNotification::fire_IsReminderSet(BSTR bstrServer, BSTR bstrName)
{
	FIRE_VECTOR( IsReminderSet(bstrServer, bstrName) );
}

STDMETHODIMP CAVGeneralNotification::fire_ResolveAddress(BSTR bstrAddress, BSTR * pbstrName, BSTR * pbstrUser1, BSTR * pbstrUser2)
{
	FIRE_VECTOR( ResolveAddress(bstrAddress, pbstrName, pbstrUser1, pbstrUser2) );
}

STDMETHODIMP CAVGeneralNotification::fire_ClearUserList()
{
	FIRE_VECTOR( ClearUserList() );
}

STDMETHODIMP CAVGeneralNotification::fire_AddUser(BSTR bstrName, BSTR bstrAddress, BSTR bstrPhoneNumber)
{
	FIRE_VECTOR( AddUser(bstrName, bstrAddress, bstrPhoneNumber) );
}

STDMETHODIMP CAVGeneralNotification::fire_ResolveAddressEx(BSTR bstrAddress, long lAddressType, DialerMediaType nMedia, DialerLocationType nLocation, BSTR * pbstrName, BSTR * pbstrAddress, BSTR * pbstrUser1, BSTR * pbstrUser2)
{
	FIRE_VECTOR( ResolveAddressEx(bstrAddress, lAddressType, nMedia, nLocation, pbstrName, pbstrAddress, pbstrUser1, pbstrUser2) );
}

STDMETHODIMP CAVGeneralNotification::fire_AddSiteServer(BSTR bstrName)
{
	FIRE_VECTOR( AddSiteServer(bstrName) );
}

STDMETHODIMP CAVGeneralNotification::fire_RemoveSiteServer(BSTR bstrName)
{
	FIRE_VECTOR( RemoveSiteServer(bstrName) );
}

STDMETHODIMP CAVGeneralNotification::fire_NotifySiteServerStateChange(BSTR bstrName, ServerState nState)
{
	FIRE_VECTOR( NotifySiteServerStateChange(bstrName, nState) );
}

STDMETHODIMP CAVGeneralNotification::fire_AddSpeedDial(BSTR bstrName, BSTR bstrAddress, CallManagerMedia cmm)
{
	FIRE_VECTOR( AddSpeedDial(bstrName, bstrAddress, cmm) );
}

STDMETHODIMP CAVGeneralNotification::fire_UpdateConfRootItem(BSTR bstrNewText)
{
	FIRE_VECTOR( UpdateConfRootItem(bstrNewText) );
}

STDMETHODIMP CAVGeneralNotification::fire_UpdateConfParticipant(MyUpdateType nType, IParticipant * pParticipant, BSTR bstrText)
{
	FIRE_VECTOR( UpdateConfParticipant(nType, pParticipant, bstrText) );
}

STDMETHODIMP CAVGeneralNotification::fire_DeleteAllConfParticipants()
{
	FIRE_VECTOR( DeleteAllConfParticipants() );
}

STDMETHODIMP CAVGeneralNotification::fire_SelectConfParticipant(IParticipant * pParticipant)
{
	FIRE_VECTOR( SelectConfParticipant(pParticipant) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avmeter\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by tmeter.rc
//
#define IDS_TRACKMETER                  1
#define IDD_TRACKMETERSTYLE             101
#define IDC_RADIO_HORIZONTAL            1000
#define IDC_RADIO_VERTICAL              1001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\wnd.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	wnd.c - window functions
////

#include "winlocal.h"

#include "wnd.h"
#include "trace.h"
#include "sys.h"

////
//	private definitions
////

// data passed from WndEnableTaskWindows to EnableTaskWndProc
//
typedef struct ENABLETASKWINDOW
{
	BOOL fEnable;
	HWND hwndExcept;
	int iNestLevel;
} ENABLETASKWINDOW, FAR *LPENABLETASKWINDOW;

// helper functions
//
BOOL DLLEXPORT CALLBACK EnableTaskWndProc(HWND hwnd, LPARAM lParam);

////
//	public functions
////

// WndCenterWindow - center one window on top of another
//		<hwnd1>				(i) window to be centered
//		<hwnd2>				(i) window to be centered upon
//			NULL				center on parent or owner
//		<xOffCenter>		(i) offset from horizontal center
//			0					center window exactly
//		<yOffCenter>		(i) offset from vertical center
//			0					center window exactly
// return 0 if success
//
int DLLEXPORT WINAPI WndCenterWindow(HWND hwnd1, HWND hwnd2, int xOffCenter, int yOffCenter)
{
	BOOL fSuccess = TRUE;
	POINT pt;
	RECT rc1;
	RECT rc2;
	int nWidth;
	int nHeight;

	if (hwnd1 == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		// use parent or owner window if no other specified
		//
		if (hwnd2 == NULL)
			hwnd2 = GetParent(hwnd1);

		// use desktop window if no parent or owner
		// or if parent or owner is iconic or invisible
		//
		if (hwnd2 == NULL || IsIconic(hwnd2) || !IsWindowVisible(hwnd2))
			hwnd2 = GetDesktopWindow();

		// get the rectangles for both windows
		//
		GetWindowRect(hwnd1, &rc1);
		GetClientRect(hwnd2, &rc2);

		// calculate the height and width for MoveWindow
		//
		nWidth = rc1.right - rc1.left;
		nHeight = rc1.bottom - rc1.top;

		// find the center point and convert to screen coordinates
		//
		pt.x = (rc2.right - rc2.left) / 2;
		pt.y = (rc2.bottom - rc2.top) / 2;
		ClientToScreen(hwnd2, &pt);

		// calculate the new x, y starting point
		//
		pt.x -= (nWidth / 2);
		pt.y -= (nHeight / 2);

		// adjust the window position off center, if necessary
		//
		pt.x = max(0, pt.x + xOffCenter);
		pt.y = max(0, pt.y + yOffCenter);
	
		// center the window
		//
		if (!MoveWindow(hwnd1, pt.x, pt.y, nWidth, nHeight, FALSE))
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// WndMessageBox - display message box, but first disable task windows
//		see MessageBox() documentation for behavior
//
int DLLEXPORT WINAPI WndMessageBox(HWND hwndParent, LPCTSTR lpszText, LPCTSTR lpszTitle, UINT fuStyle)
{
	int iRet;
	HWND hwndActive = GetActiveWindow();
	HTASK hTask = NULL;

	if (hwndParent != NULL)
		hTask = GetWindowTask(hwndParent);

	WndEnableTaskWindows(hTask, FALSE, hwndActive);

	iRet = MessageBox(hwndActive, lpszText, lpszTitle, fuStyle | MB_TASKMODAL);

	WndEnableTaskWindows(hTask, TRUE, NULL);

	return iRet;
}

// WndEnableTaskWindows - enable or disable top-level windows of a task
//		<hTask>				(i) specified task
//			NULL				current task
//		<fEnable>			(i) FALSE to disable, TRUE to enable
//		<hwndExcept>		(i) disable/enable all windows except this one
//			NULL				no exceptions
// return 0 if success
//
// This function enables or disables top-level windows
// which are owned by the specified task.
//
// Disabling task windows is useful when an a modal
// dialog box or task modal notify box is displayed,
// because this ensures that all task windows are
// disabled, not just the modal box's parent.
//
// Task windows need to be enabled when the modal dialog
// box or task modal notify box is about to be destroyed.
// It is important to call this function in nested pairs,
// such as:
//
//		WndEnableTaskWindows(..., FALSE, ...);
//			...
//			WndEnableTaskWindows(..., FALSE, ...);
//				...
//			WndEnableTaskWindows(..., TRUE, ...);
//				...
//		WndEnableTaskWindows(..., TRUE, ...);
//
int DLLEXPORT WINAPI WndEnableTaskWindows(HTASK hTask, BOOL fEnable, HWND hwndExcept)
{
	static int iNestLevel = 0;
	BOOL fSuccess = TRUE;
	ENABLETASKWINDOW etw;
	WNDENUMPROC fpEnableTaskWndProc = NULL;
#if 0 // MakeProcInstance not required for WIN32 or DLLs
	HINSTANCE hInst;
#endif

	// data to be sent to EnableTaskWndProc
	//
	etw.fEnable = fEnable;
	etw.hwndExcept = hwndExcept;
	etw.iNestLevel = fEnable ? iNestLevel : iNestLevel + 1;

	// assume current task if none specified
	//
	if (hTask == NULL && (hTask = GetCurrentTask()) == NULL)
		fSuccess = TraceFALSE(NULL);

#if 1 // MakeProcInstance not required for WIN32 or DLLs
	else if ((fpEnableTaskWndProc = (WNDENUMPROC) EnableTaskWndProc) == NULL)
		fSuccess = TraceFALSE(NULL);
#else
	// get instance handle of specified task
	//
	else if ((hInst = SysGetTaskInstance(hTask)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((fpEnableTaskWndProc = (WNDENUMPROC)
		MakeProcInstance((FARPROC) EnableTaskWndProc, hInst)) == NULL)
		fSuccess = TraceFALSE(NULL);
#endif

	// call EnableTaskWndProc once for each task window
	//
	else if (EnumTaskWindows(hTask, fpEnableTaskWndProc,
		(LPARAM) (LPENABLETASKWINDOW) &etw) == 0)
		fSuccess = TraceFALSE(NULL);

#if 0 // MakeProcInstance not required for WIN32 or DLLs
	if (fpEnableTaskWndProc != NULL)
	{
		FreeProcInstance((FARPROC) fpEnableTaskWndProc);
		fpEnableTaskWndProc = NULL;
	}
#endif

	if (fSuccess)
	{
		// if we just finished disabling, increment nest level
		//
		if (!fEnable)
			++iNestLevel;

		// if we just finished enabling, decrement nest level
		//
		if (fEnable)
			--iNestLevel;
	}

	return fSuccess ? 0 : -1;
}

////
//	helper functions
////

// EnableTaskWndProc - called once for each task window
//		<hwnd>				(i) task window handle
//		<lParam>			(i) pointer to ENABLETASKWINDOW struct
// return TRUE to continue enumeration of task windows
//
BOOL DLLEXPORT CALLBACK EnableTaskWndProc(HWND hwnd, LPARAM lParam)
{
	static LPTSTR lpszProp = TEXT("TaskWindowDisabled");
	LPENABLETASKWINDOW lpetw = (LPENABLETASKWINDOW) lParam;
	BOOL fEnable = lpetw->fEnable;
	int iNestLevel = lpetw->iNestLevel;
	HWND hwndExcept = lpetw->hwndExcept;

    //
    //
    HANDLE hProp = NULL;

	if (TraceGetLevel(NULL) >= 6)
	{
		TCHAR szClassName[64];
		TCHAR szWindowText[128];

		*szClassName = '\0';
		GetClassName(hwnd, szClassName, SIZEOFARRAY(szClassName));

		*szWindowText = '\0';
		GetWindowText(hwnd, szWindowText, SIZEOFARRAY(szWindowText));

		TracePrintf_7(NULL, 6, TEXT("TaskWindow: (%p, \"%s\", \"%s\" \"%c%c%c\", %d)\n"),
			hwnd,
			(LPTSTR) szClassName,
			(LPTSTR) szWindowText,
			(TCHAR) (IsIconic(hwnd) ? 'I' : ' '),
			(TCHAR) (IsWindowVisible(hwnd) ? 'V' : ' '),
			(TCHAR) (IsWindowEnabled(hwnd) ? 'E' : ' '),
			(int) iNestLevel);
	}

	// the exception window should not be affected
	//
	if (hwndExcept != NULL && hwndExcept == hwnd)
	{
		TraceOutput(NULL, 6, TEXT("->hwndExcept\n"));
		return TRUE;
	}

	// NOTE: we only disable/enable task windows which are visible.
	//		This is convenient because:
	//		1)	it prevents unnecessary disabling/enabling
	//			of invisible windows, which can't receive
	//			mouse or keyboard input anyway.
	//		2)	it allows us to call this function from
	//			a dialog box's WM_INITDIALOG handler without
	//			affecting the dialog box itself (the dialog box is
	//			a top-level task window, but is not yet visible)
	//		3)	it prevents the listbox of a drop-down ComboBox
	//			from being disabled, which is somehow considered
	//			a top-level task window

	if (!fEnable)
	{
		// only disable windows which are visible and enabled
		//
		if (!IsIconic(hwnd) && IsWindowVisible(hwnd) && IsWindowEnabled(hwnd))
		{
			// give the window a property reminding us we disabled it
			//
			if (SetProp(hwnd, lpszProp, (HANDLE) (WORD) iNestLevel))
			{
				TraceOutput(NULL, 6, TEXT("->EnableWindow(FALSE)\n"));
				EnableWindow(hwnd, FALSE);
			}
		}
	}

	else if (fEnable)
	{
		// only enable windows which we disabled at this nest level
		//
		if (GetProp(hwnd, lpszProp) == (HANDLE) (WORD) iNestLevel)
		{
			TraceOutput(NULL, 6, TEXT("->EnableWindow(TRUE)\n"));
			EnableWindow(hwnd, TRUE);

            //
            // We should delete the handler
            //

            hProp = RemoveProp(hwnd, lpszProp);

            if( hProp )
            {
                GlobalUnlock( hProp );
                GlobalFree( hProp );
            }
		}
	}

	// keep calling this function until no more task windows
	//
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avlib\wnd.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// wnd.h - interface for window functions in wnd.c
////

#ifndef __WND_H__
#define __WND_H__

#include "winlocal.h"

#define WND_VERSION 0x00000100

////
//	window functions
////

#ifdef __cplusplus
extern "C" {
#endif

// WndCenterWindow - center one window on top of another
//		<hwnd1>				(i) window to be centered
//		<hwnd2>				(i) window to be centered upon
//			NULL				center on parent or owner
//		<xOffCenter>		(i) offset from horizontal center
//			0					center window exactly
//		<yOffCenter>		(i) offset from vertical center
//			0					center window exactly
// return 0 if success
//
int DLLEXPORT WINAPI WndCenterWindow(HWND hwnd1, HWND hwnd2, int xOffCenter, int yOffCenter);

// WndMessageBox - display message box, but first disable task windows
//		see MessageBox() documentation for behavior
//
int DLLEXPORT WINAPI WndMessageBox(HWND hwndParent, LPCTSTR lpszText, LPCTSTR lpszTitle, UINT fuStyle);

// WndEnableTaskWindows - enable or disable top-level windows of a task
//		<hTask>				(i) specified task
//			NULL				current task
//		<fEnable>			(i) FALSE to disable, TRUE to enable
//		<hwndExcept>		(i) disable/enable all windows except this one
//			NULL				no exceptions
// return 0 if success
//
int DLLEXPORT WINAPI WndEnableTaskWindows(HTASK hTask, BOOL fEnable, HWND hwndExcept);

#ifdef __cplusplus
}
#endif

#endif // __WND_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avmeter\tmeter.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// tmeter.c - TrackMeter custom control
////

#include "tmeter.h"
#include "resource.h"

#include <commctrl.h>
#include <custcntl.h>

#include "trace.h"
#include "mem.h"

////
// public
////

BOOL WINAPI DllMain(HANDLE hModule, DWORD fdwReason, LPVOID lpReserved);
UINT DLLEXPORT CALLBACK CustomControlInfoA(LPCCINFOA acci);
BOOL DLLEXPORT CALLBACK TrackMeter_Style(HWND hWndParent, LPCCSTYLEA pccs);
INT DLLEXPORT CALLBACK TrackMeter_SizeToText(
	DWORD flStyle, DWORD flExtStyle, HFONT hFont, LPSTR pszText);
LRESULT DLLEXPORT CALLBACK TrackMeter_WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

////
// private
////

static HINSTANCE g_hInstLib;

#define GWL_USER 0

#define TRACKMETER_DESCRIPTION "TrackBar with level meter"
#define TRACKMETER_DEFAULTTEXT "[===||=======]"

// control styles
//
#define SS_HORIZONTAL			0x0001
#define SS_VERTICAL				0x0002

CCSTYLEFLAGA aTrackMeterStyleFlags[] =
{
	{ TMS_HORZ, 0, "TMS_HORZ" },
	{ TMS_VERT, 0, "TMS_VERT" },
	{ TMS_NOTHUMB, 0, "TMS_NOTHUMB" }
};

// number of extra bytes for control window
//
#define TRACKMETER_EXTRABYTES	(1*sizeof(DWORD_PTR))

// tmeter control struct
//
typedef struct TMETER
{
	HWND hwnd;
	HWND hwndParent;
	HDC hdcCompat;
	HBITMAP hbmpSave;
	HBITMAP hbmpCompat;
	long lPosition;
	long lMinimum;
	long lMaximum;
	long lLevel;
	long lLineSize;
	long lPageSize;
	BOOL fHasFocus;
	BOOL fIsEnabled;
	BOOL fIsThumbPressed;
	DWORD dwFlags;

	RECT rcCtrl;
	RECT rcTrack;
	RECT rcMeter;
	RECT rcLevel;
	POINT aptThumb[5];
	COLORREF acr[TMCR_MAX];

} TMETER, FAR *LPTMETER;

// helper functions
//
static BOOL TrackMeter_OnNCCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct);
static void TrackMeter_OnNCDestroy(LPTMETER lptm);
static BOOL TrackMeter_OnCreate(LPTMETER lptm, CREATESTRUCT FAR* lpCreateStruct);
static void TrackMeter_OnDestroy(LPTMETER lptm);
static void TrackMeter_OnSize(LPTMETER lptm, UINT state, int cx, int cy);
static BOOL TrackMeter_OnEraseBkgnd(LPTMETER lptm, HDC hdc);
static void TrackMeter_OnPaint(LPTMETER lptm);
static int TrackMeter_Draw(LPTMETER lptm, HDC hdc);
static void TrackMeter_OnCommand(LPTMETER lptm, int id, HWND hwndCtl, UINT codeNotify);
static void TrackMeter_OnSetFocus(LPTMETER lptm, HWND hwndOldFocus);
static void TrackMeter_OnKillFocus(LPTMETER lptm, HWND hwndNewFocus);
static void TrackMeter_OnEnable(LPTMETER lptm, BOOL fEnable);
static UINT TrackMeter_OnGetDlgCode(LPTMETER lptm, LPMSG lpmsg);
static void TrackMeter_OnKey(LPTMETER lptm, UINT vk, BOOL fDown, int cRepeat, UINT flags);
static void TrackMeter_OnLButtonDown(LPTMETER lptm, BOOL fDoubleClick, int x, int y, UINT keyFlags);
static void TrackMeter_OnLButtonUp(LPTMETER lptm, int x, int y, UINT keyFlags);
static void TrackMeter_OnRButtonDown(LPTMETER lptm, BOOL fDoubleClick, int x, int y, UINT keyFlags);
static void TrackMeter_OnRButtonUp(LPTMETER lptm, int x, int y, UINT keyFlags);
static void TrackMeter_OnMouseMove(LPTMETER lptm, int x, int y, UINT keyFlags);
static void TrackMeter_OnCaptureChanged(LPTMETER lptm, HWND hwndNewCapture);
static void TrackMeter_NotifyParent(LPTMETER lptm, UINT code, UINT nPos);

static LONG TrackMeter_OnTMMGetPos(LPTMETER lptm);
static void TrackMeter_OnTMMSetPos(LPTMETER lptm, LONG lPosition, BOOL fRedraw);
static LONG TrackMeter_OnTMMGetLevel(LPTMETER lptm);
static void TrackMeter_OnTMMSetLevel(LPTMETER lptm, LONG lLevel, BOOL fRedraw);
static LONG TrackMeter_OnTMMGetRangeMin(LPTMETER lptm);
static void TrackMeter_OnTMMSetRangeMin(LPTMETER lptm, LONG lMinimum, BOOL fRedraw);
static LONG TrackMeter_OnTMMGetRangeMax(LPTMETER lptm);
static void TrackMeter_OnTMMSetRangeMax(LPTMETER lptm, LONG lMaximum, BOOL fRedraw);
static void TrackMeter_OnTMMSetRange(LPTMETER lptm, LONG lMinimum, LONG lMaximum, BOOL fRedraw);
static COLORREF TrackMeter_OnTMMGetColor(LPTMETER lptm, UINT elem);
static void TrackMeter_OnTMMSetColor(LPTMETER lptm, COLORREF cr, UINT elem, BOOL fRedraw);

#define TrackMeter_DefProc(hwnd, msg, wParam, lParam) \
	DefWindowProc(hwnd, msg, wParam, lParam)

static int TrackMeter_Recalc(LPTMETER lptm, DWORD dwFlags);
#define TMR_TRACK		0x00000001
#define TMR_METER		0x00000002
#define TMR_LEVEL		0x00000004
#define TMR_THUMB		0x00000008
#define TMR_COLORS		0x00000010
#define TMR_PAGESIZE	0x00000020
#define TMR_ALL (TMR_TRACK | TMR_METER | TMR_LEVEL | TMR_THUMB | TMR_COLORS | TMR_PAGESIZE)

static int TrackMeter_PositionToX(LPTMETER lptm, long lPosition);
static long TrackMeter_XToPosition(LPTMETER lptm, int xPosition);
static BOOL TrackMeter_PtInThumb(LPTMETER lptm, int x, int y);

// for some reason this is not in windowsx.h
//
#ifndef HANDLE_WM_CAPTURECHANGED
/* void Cls_OnCaptureChanged(HWND hwnd, HWND hwndNewCapture) */
#define HANDLE_WM_CAPTURECHANGED(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_CAPTURECHANEGED(hwnd, hwndNewCapture, fn) \
    (void)(fn)((hwnd), WM_CAPTURECHANGED, (WPARAM)(HWND)(hwndNewCapture), 0L)
#endif

////
// public
////

BOOL WINAPI DllMain(HANDLE hModule, DWORD fdwReason, LPVOID lpReserved)
{
	BOOL fSuccess = TRUE;

	switch (fdwReason)
	{
		case DLL_PROCESS_ATTACH:
		{
			WNDCLASS wc;

			g_hInstLib = hModule;

			wc.style = CS_HREDRAW | CS_VREDRAW | CS_OWNDC | CS_GLOBALCLASS;
			wc.lpfnWndProc = TrackMeter_WndProc;
			wc.cbClsExtra = 0;
			wc.cbWndExtra = TRACKMETER_EXTRABYTES;
			wc.hInstance = hModule;
			wc.hIcon = NULL;
			wc.hCursor = LoadCursor(NULL, IDC_ARROW);
			wc.hbrBackground = NULL;
			wc.lpszMenuName = (LPTSTR) NULL;
			wc.lpszClassName = (LPTSTR) TRACKMETER_CLASS;

			if (!RegisterClass (&wc))
			{
				fSuccess = TraceFALSE(NULL);
				return FALSE;
			}
		}
			break;

		case DLL_THREAD_ATTACH:
			break;

		case DLL_THREAD_DETACH:
			break;

		case DLL_PROCESS_DETACH:
			if (!UnregisterClass ((LPTSTR) TRACKMETER_CLASS, hModule))
				fSuccess = TraceFALSE(NULL);
			break;

		default:
			break;
	}

	return fSuccess;
}

// CustomControlInfoA
//		<lpacci>		(i/o) pointer to array of CCINFOA structs
// returns number of controls supported by this DLL
// NOTE: see CUSTCNTL.H for more info
//
UINT DLLEXPORT CALLBACK CustomControlInfoA(LPCCINFOA acci)
{
	UINT uControls = 1;

	if (acci != NULL)
	{
		// calculate width and height of dialog units (in pixels)
		//
		DWORD dw = GetDialogBaseUnits();
		WORD cxBaseUnits = LOWORD(dw);
		WORD cyBaseUnits = HIWORD(dw);

		// fill in a CCINFOA struct for each supported control
		//
		strncpy(acci[0].szClass, TRACKMETER_CLASS_A,
			sizeof(acci[0].szClass));
		acci[0].flOptions = CCF_NOTEXT;
		strncpy(acci[0].szDesc, TRACKMETER_DESCRIPTION,
			sizeof(acci[0].szDesc));
		acci[0].cxDefault = (120 * 4) / max(1, cxBaseUnits);
		acci[0].cyDefault = (18 * 8) / max(1, cyBaseUnits);
		acci[0].flStyleDefault = WS_CHILD | WS_VISIBLE | SS_HORIZONTAL;
		acci[0].flExtStyleDefault = 0;
		acci[0].flCtrlTypeMask = 0;
		strncpy(acci[0].szTextDefault, TRACKMETER_DEFAULTTEXT,
			sizeof(acci[0].szTextDefault));
		acci[0].cStyleFlags = (sizeof(aTrackMeterStyleFlags) / sizeof(aTrackMeterStyleFlags[0]));
		acci[0].aStyleFlags = aTrackMeterStyleFlags;
		acci[0].lpfnStyle = TrackMeter_Style;
		acci[0].lpfnSizeToText = TrackMeter_SizeToText;
		acci[0].dwReserved1 = 0;
		acci[0].dwReserved2 = 0;
	}

	// return the number of controls that the DLL supports
	//
	return uControls;
}

// TrackMeter_Style - do modal dialog for custom control style
//		<hwndParent>		(i) parent window (dialog editor)
//		<pccs>				(i/o) pointer to CCSTYLE struct
// returns TRUE if success, otherwise FALSE
//
BOOL DLLEXPORT CALLBACK TrackMeter_Style(HWND hWndParent, LPCCSTYLEA pccs)
{
	BOOL fSuccess = TRUE;
#if 0
	if (DialogBox(g_hInstLib, MAKEINTRESOURCE(IDD_TMETERSTYLE),
		hWndParent, TrackMeter_DlgProc) == -1)
		fSuccess = TraceFALSE(NULL);
#else
	fSuccess = TraceFALSE(NULL);
#endif
	return fSuccess;
}

// TrackMeter_SizeToText
//		<flStyle>			(i) control style
//		<flExtStyle>		(i) control extended style
//		<hFont>				(i) handle of font used to draw text
//		<pszText>			(i) control text
// returns control width (pixels) needed to accomodate text, -1 if error
//
INT DLLEXPORT CALLBACK TrackMeter_SizeToText(
	DWORD flStyle, DWORD flExtStyle, HFONT hFont, LPSTR pszText)
{
	// this control has no text to resize, so do nothing
	//
	return -1;
}

LRESULT DLLEXPORT CALLBACK TrackMeter_WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	BOOL fSuccess = TRUE;
	LPTMETER lptm = (LPTMETER) GetWindowLongPtr(hwnd, GWL_USER);

#if 0
	TracePrintf_1(NULL, 1,
		TEXT("msg 0x%X\n"),
		(unsigned int) msg);
#endif

	switch (msg)
	{
		HANDLE_MSG(hwnd, WM_NCCREATE, TrackMeter_OnNCCreate);
		HANDLE_MSG(lptm, WM_NCDESTROY, TrackMeter_OnNCDestroy);
		HANDLE_MSG(lptm, WM_CREATE, TrackMeter_OnCreate);
		HANDLE_MSG(lptm, WM_DESTROY, TrackMeter_OnDestroy);
		HANDLE_MSG(lptm, WM_SIZE, TrackMeter_OnSize);
		HANDLE_MSG(lptm, WM_ERASEBKGND, TrackMeter_OnEraseBkgnd);
		HANDLE_MSG(lptm, WM_PAINT, TrackMeter_OnPaint);
		HANDLE_MSG(lptm, WM_COMMAND, TrackMeter_OnCommand);
		HANDLE_MSG(lptm, WM_SETFOCUS, TrackMeter_OnSetFocus);
		HANDLE_MSG(lptm, WM_KILLFOCUS, TrackMeter_OnKillFocus);
		HANDLE_MSG(lptm, WM_ENABLE, TrackMeter_OnEnable);
		HANDLE_MSG(lptm, WM_GETDLGCODE, TrackMeter_OnGetDlgCode);
		HANDLE_MSG(lptm, WM_KEYDOWN, TrackMeter_OnKey);
		HANDLE_MSG(lptm, WM_KEYUP, TrackMeter_OnKey);
		HANDLE_MSG(lptm, WM_LBUTTONDOWN, TrackMeter_OnLButtonDown);
		HANDLE_MSG(lptm, WM_LBUTTONUP, TrackMeter_OnLButtonUp);
//		HANDLE_MSG(lptm, WM_RBUTTONDOWN, TrackMeter_OnRButtonDown);
//		HANDLE_MSG(lptm, WM_RBUTTONUP, TrackMeter_OnRButtonUp);
		HANDLE_MSG(lptm, WM_MOUSEMOVE, TrackMeter_OnMouseMove);
		HANDLE_MSG(lptm, WM_CAPTURECHANGED, TrackMeter_OnCaptureChanged);

		HANDLE_MSG(lptm, TMM_GETPOS, TrackMeter_OnTMMGetPos);
		HANDLE_MSG(lptm, TMM_SETPOS, TrackMeter_OnTMMSetPos);
		HANDLE_MSG(lptm, TMM_GETRANGEMIN, TrackMeter_OnTMMGetRangeMin);
		HANDLE_MSG(lptm, TMM_SETRANGEMIN, TrackMeter_OnTMMSetRangeMin);
		HANDLE_MSG(lptm, TMM_GETRANGEMAX, TrackMeter_OnTMMGetRangeMax);
		HANDLE_MSG(lptm, TMM_SETRANGEMAX, TrackMeter_OnTMMSetRangeMax);
		HANDLE_MSG(lptm, TMM_SETRANGE, TrackMeter_OnTMMSetRange);

		HANDLE_MSG(lptm, TMM_GETLEVEL, TrackMeter_OnTMMGetLevel);
		HANDLE_MSG(lptm, TMM_SETLEVEL, TrackMeter_OnTMMSetLevel);
		HANDLE_MSG(lptm, TMM_GETCOLOR, TrackMeter_OnTMMGetColor);
		HANDLE_MSG(lptm, TMM_SETCOLOR, TrackMeter_OnTMMSetColor);

		default:
			return TrackMeter_DefProc(hwnd, msg, wParam, lParam);
	}
	return (LRESULT) TRUE;
}

////
//	helper functions
////

static BOOL TrackMeter_OnNCCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)
{
	BOOL fSuccess = TRUE;
	LPTMETER lptm;

	// create control struct and associate it with window
	//
	if ((lptm = (LPTMETER) GetWindowLongPtr(hwnd, GWL_USER)) == NULL &&
		(lptm = (LPTMETER) MemAlloc(NULL, sizeof(TMETER), 0)) == NULL)
	{
		fSuccess = TraceFALSE(NULL);
		return FALSE;
	}
	else
	{
		lptm->hwnd = hwnd;
		SetWindowLongPtr(hwnd, GWL_USER, (LONG_PTR) lptm);
	}

	return FORWARD_WM_NCCREATE(hwnd, lpCreateStruct, DefWindowProc);
}

static void TrackMeter_OnNCDestroy(LPTMETER lptm)
{
	BOOL fSuccess = TRUE;

	// destroy control struct and disassociate it from window
	//
	if (lptm != NULL)
	{
		HWND hwnd = lptm->hwnd;

		SetWindowLongPtr(hwnd, GWL_USER, (LPARAM) NULL);

		if ((lptm = MemFree(NULL, lptm)) != NULL)
			fSuccess = TraceFALSE(NULL);

		FORWARD_WM_NCDESTROY(hwnd, DefWindowProc);
	}
}

static BOOL TrackMeter_OnCreate(LPTMETER lptm, CREATESTRUCT FAR* lpCreateStruct)
{
	BOOL fSuccess = TRUE;
	HWND hwnd = lptm->hwnd;
	LPVOID lpParam = (LPVOID) lpCreateStruct->lpCreateParams;
	HDC hdc = NULL;

	if ((hdc = GetDC(hwnd)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lptm->hdcCompat = CreateCompatibleDC(hdc)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lptm->hwndParent = lpCreateStruct->hwndParent;
		lptm->hdcCompat = lptm->hdcCompat; // recalc during WM_CREATE
		lptm->hbmpSave = NULL;
		lptm->hbmpCompat = NULL;
		lptm->lPosition = 0;
		lptm->lMinimum = 0;
		lptm->lMaximum = 100;
		lptm->lLevel = 0;
		lptm->lLineSize = 1;
		lptm->lPageSize = lptm->lPageSize; // recalc later
		lptm->fHasFocus = FALSE;
		lptm->fIsEnabled = TRUE;
		lptm->fIsThumbPressed = FALSE;
		lptm->dwFlags = 0;

		TrackMeter_Recalc(lptm, TMR_ALL);
	}

	if (hdc != NULL)
		ReleaseDC(hwnd, hdc);

	return fSuccess ? 1 : -1;
}

static void TrackMeter_OnDestroy(LPTMETER lptm)
{
	BOOL fSuccess = TRUE;
	
	SelectObject(lptm->hdcCompat, lptm->hbmpSave);

	if (lptm->hbmpCompat != NULL && !DeleteObject(lptm->hbmpCompat))
		fSuccess = TraceFALSE(NULL);
	else
		lptm->hbmpCompat = NULL;

	if (lptm->hdcCompat != NULL && !DeleteDC(lptm->hdcCompat))
		fSuccess = TraceFALSE(NULL);
	else
		lptm->hdcCompat = NULL;
}

static void TrackMeter_OnSize(LPTMETER lptm, UINT state, int cx, int cy)
{
	BOOL fSuccess = TRUE;
	HWND hwnd = lptm->hwnd;

	TracePrintf_3(NULL, 6,
		TEXT("WM_SIZE, state=%u, cx=%d, cy=%d\n"),
		(unsigned) state,
		(int) cx,
		(int) cy);

	switch (state)
	{
		case SIZE_RESTORED:
		case SIZE_MAXIMIZED:
		{
			HDC hdc = NULL;
			HBITMAP hbmpTemp = NULL;

			if ((hdc = GetDC(hwnd)) == NULL)
				fSuccess = TraceFALSE(NULL);

			else if (TrackMeter_Recalc(lptm, TMR_TRACK | TMR_METER | TMR_LEVEL | TMR_THUMB) != 0)
				fSuccess = TraceFALSE(NULL);

			else if ((hbmpTemp = CreateCompatibleBitmap(hdc, cx, cy)) == NULL)
				fSuccess = TraceFALSE(NULL);

			else
			{
				lptm->hbmpSave = SelectObject(lptm->hdcCompat, hbmpTemp);

				if (lptm->hbmpCompat != NULL && !DeleteObject(lptm->hbmpCompat))
					fSuccess = TraceFALSE(NULL);
				else
					lptm->hbmpCompat = hbmpTemp;
			}

			if (hdc != NULL)
				ReleaseDC(hwnd, hdc);

			InvalidateRect(hwnd, NULL, FALSE);
		}
			break;

		default:
			break;
	}
}

static BOOL TrackMeter_OnEraseBkgnd(LPTMETER lptm, HDC hdc)
{
	BOOL fSuccess = TRUE;

	// we do nothing
	//

	return fSuccess;
}

static void TrackMeter_OnPaint(LPTMETER lptm)
{
	BOOL fSuccess = TRUE;
	PAINTSTRUCT ps;
	BOOL fBitBlt = TRUE;
	HDC hdc;

    //
    // We have tot ake care for EndPaint
    //

	if (!BeginPaint(lptm->hwnd, &ps))
    {
		fSuccess = TraceFALSE(NULL);
    }
	else
    {
        if ((hdc = (fBitBlt ? lptm->hdcCompat : ps.hdc)) == NULL)
        {
            EndPaint( lptm->hwnd, &ps);
		    fSuccess = TraceFALSE(NULL);
        }
	    else if (TrackMeter_Draw(lptm, hdc))
        {
            EndPaint( lptm->hwnd, &ps);
		    fSuccess = TraceFALSE(NULL);
        }
	    else if (!EndPaint(lptm->hwnd, &ps))
		    fSuccess = TraceFALSE(NULL);

	    else if (fBitBlt && !BitBlt(ps.hdc,	ps.rcPaint.left, ps.rcPaint.top,
		    ps.rcPaint.right - ps.rcPaint.left, ps.rcPaint.bottom - ps.rcPaint.top,
		    lptm->hdcCompat, ps.rcPaint.left, ps.rcPaint.top, SRCCOPY))
	    {
		    fSuccess = TraceFALSE(NULL);
	    }
    }
}

static int TrackMeter_Draw(LPTMETER lptm, HDC hdc)
{
	BOOL fSuccess = TRUE;
	HPEN hpenOld = GetCurrentObject(hdc, OBJ_PEN);
	HBRUSH hbrushOld = GetCurrentObject(hdc, OBJ_BRUSH);
	LONG_PTR LPStyle = GetWindowLongPtr(lptm->hwnd, GWL_STYLE);
	BOOL fDrawThumb = !(LPStyle & TMS_NOTHUMB);

	// draw background of control
	//
	if (1)
	{
		HBRUSH hbrushCtrlBackground;

		if ((hbrushCtrlBackground = CreateSolidBrush(lptm->acr[TMCR_CTRLBACKGROUND])) == NULL)
			fSuccess = TraceFALSE(NULL);

		else
		{
			if (!FillRect(hdc, &lptm->rcCtrl, hbrushCtrlBackground))
				fSuccess = TraceFALSE(NULL);

			if (!DeleteObject(hbrushCtrlBackground))
				fSuccess = TraceFALSE(NULL);
		}
	}

	// draw background of track
	//
	if (1)
	{
		HBRUSH hbrushTrackBackground;

		if ((hbrushTrackBackground = CreateSolidBrush(lptm->acr[TMCR_TRACKBACKGROUND])) == NULL)
			fSuccess = TraceFALSE(NULL);

		else
		{
			if (!FillRect(hdc, &lptm->rcTrack, hbrushTrackBackground))
				fSuccess = TraceFALSE(NULL);

			if (!DeleteObject(hbrushTrackBackground))
				fSuccess = TraceFALSE(NULL);
		}
	}

	// draw track light
	//
	if (1)
	{
		HPEN hpenTrackLight;

		if ((hpenTrackLight = CreatePen(PS_SOLID, 1, lptm->acr[TMCR_TRACKLIGHT])) == NULL)
			fSuccess = TraceFALSE(NULL);

		else
		{
			SelectObject(hdc, hpenTrackLight);
			MoveToEx(hdc, lptm->rcTrack.right, lptm->rcTrack.top, NULL);
			LineTo(hdc, lptm->rcTrack.right, lptm->rcTrack.bottom + 1);
			MoveToEx(hdc, lptm->rcTrack.right, lptm->rcTrack.bottom, NULL);
			LineTo(hdc, lptm->rcTrack.left - 1, lptm->rcTrack.bottom);

			if (!DeleteObject(hpenTrackLight))
				fSuccess = TraceFALSE(NULL);
		}
	}

	// draw track shadow
	//
	if (1)
	{
		HPEN hpenTrackShadow;

		if ((hpenTrackShadow = CreatePen(PS_SOLID, 1,
			lptm->fIsEnabled ? lptm->acr[TMCR_TRACKSHADOW] :
			lptm->acr[TMCR_CTRLBACKGROUND])) == NULL)
			fSuccess = TraceFALSE(NULL);

		else
		{
			SelectObject(hdc, hpenTrackShadow);
			MoveToEx(hdc, lptm->rcTrack.left, lptm->rcTrack.top, NULL);
			LineTo(hdc, lptm->rcTrack.right, lptm->rcTrack.top);
			MoveToEx(hdc, lptm->rcTrack.left, lptm->rcTrack.top, NULL);
			LineTo(hdc, lptm->rcTrack.left, lptm->rcTrack.bottom);

			if (!DeleteObject(hpenTrackShadow))
				fSuccess = TraceFALSE(NULL);
		}
	}

	// draw track dark shadow
	//
	if (1)
	{
		HPEN hpenTrackDkShadow;

		if ((hpenTrackDkShadow = CreatePen(PS_SOLID, 1,
			lptm->fIsEnabled ? lptm->acr[TMCR_TRACKDKSHADOW] :
			lptm->acr[TMCR_TRACKSHADOW])) == NULL)
			fSuccess = TraceFALSE(NULL);

		else
		{
			SelectObject(hdc, hpenTrackDkShadow);
			MoveToEx(hdc, lptm->rcTrack.left + 1, lptm->rcTrack.top + 1, NULL);
			LineTo(hdc, lptm->rcTrack.right - 1, lptm->rcTrack.top + 1);
			MoveToEx(hdc, lptm->rcTrack.left + 1, lptm->rcTrack.top + 1, NULL);
			LineTo(hdc, lptm->rcTrack.left + 1, lptm->rcTrack.bottom - 1);

			if (!DeleteObject(hpenTrackDkShadow))
				fSuccess = TraceFALSE(NULL);
		}
	}

	// fill track up to current level
	//
	if (lptm->fIsEnabled && lptm->lLevel > lptm->lMinimum)
	{
		HBRUSH hbrushLevel;

		if ((hbrushLevel = CreateSolidBrush(lptm->acr[TMCR_LEVEL])) == NULL)
			fSuccess = TraceFALSE(NULL);

		else
		{
			FillRect(hdc, &lptm->rcLevel, hbrushLevel);

			if (!DeleteObject(hbrushLevel))
				fSuccess = TraceFALSE(NULL);
		}
	}

	// fill thumb region
	//
	if (fDrawThumb)
	{
		HRGN hrgnThumb;

		if ((hrgnThumb = CreatePolygonRgn(lptm->aptThumb, 
			(sizeof(lptm->aptThumb)/sizeof(lptm->aptThumb[0])), WINDING)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else
		{
			HBRUSH hbrushThumbFace;

			if ((hbrushThumbFace = CreateSolidBrush(lptm->acr[lptm->fIsThumbPressed ?
				TMCR_THUMBFACEPRESSED : TMCR_THUMBFACE])) == NULL)
				fSuccess = TraceFALSE(NULL);

			else
			{
				if (!FillRgn(hdc, hrgnThumb, hbrushThumbFace))
					fSuccess = TraceFALSE(NULL);

				if (!DeleteObject(hbrushThumbFace))
					fSuccess = TraceFALSE(NULL);
			}

			if (!DeleteObject(hrgnThumb))
				fSuccess = TraceFALSE(NULL);
		}
	}

	// draw thumb light
	//
	if (fDrawThumb)
	{
		HPEN hpenThumbLight;

		if ((hpenThumbLight = CreatePen(PS_SOLID, 1,
			lptm->fIsEnabled ? lptm->acr[TMCR_THUMBLIGHT] :
			lptm->acr[TMCR_THUMBSHADOW])) == NULL)
			fSuccess = TraceFALSE(NULL);

		else
		{
			SelectObject(hdc, hpenThumbLight);
			MoveToEx(hdc, lptm->aptThumb[0].x, lptm->aptThumb[0].y, NULL);
			LineTo(hdc, lptm->aptThumb[1].x - 1, lptm->aptThumb[1].y + 1);
			MoveToEx(hdc, lptm->aptThumb[1].x, lptm->aptThumb[1].y, NULL);
			LineTo(hdc, lptm->aptThumb[2].x, lptm->aptThumb[2].y);

			if (!DeleteObject(hpenThumbLight))
				fSuccess = TraceFALSE(NULL);
		}
	}

	// draw thumb dark shadow
	//
	if (fDrawThumb)
	{
		HPEN hpenThumbDkShadow;

		if ((hpenThumbDkShadow = CreatePen(PS_SOLID, 1,
			lptm->fIsEnabled ? lptm->acr[TMCR_THUMBDKSHADOW] :
			lptm->acr[TMCR_THUMBLIGHT])) == NULL)
			fSuccess = TraceFALSE(NULL);

		else
		{
			SelectObject(hdc, hpenThumbDkShadow);
			MoveToEx(hdc, lptm->aptThumb[2].x, lptm->aptThumb[2].y, NULL);
			LineTo(hdc, lptm->aptThumb[3].x + 1, lptm->aptThumb[3].y);
			MoveToEx(hdc, lptm->aptThumb[3].x, lptm->aptThumb[3].y, NULL);
			LineTo(hdc, lptm->aptThumb[4].x, lptm->aptThumb[4].y - 1);
			MoveToEx(hdc, lptm->aptThumb[4].x, lptm->aptThumb[4].y, NULL);
			LineTo(hdc, lptm->aptThumb[0].x, lptm->aptThumb[0].y);

			if (!DeleteObject(hpenThumbDkShadow))
				fSuccess = TraceFALSE(NULL);
		}
	}

	// draw focus border, if necessary
	//
	if (lptm->fHasFocus)
	{
		COLORREF crBkColorOld = SetBkColor(hdc, lptm->acr[TMCR_FOCUSBACKGROUND]);

		if (!DrawFocusRect(hdc, &lptm->rcCtrl))
			fSuccess = TraceFALSE(NULL);

		SetBkColor(hdc, crBkColorOld);
	}

	// cleanup
	//
	if (hpenOld != NULL)
		SelectObject(hdc, hpenOld);

	if (hbrushOld != NULL)
		SelectObject(hdc, hbrushOld);

	return fSuccess ? 0 : -1;
}

static void TrackMeter_OnCommand(LPTMETER lptm, int id, HWND hwndCtl, UINT codeNotify)
{
}

static void TrackMeter_OnSetFocus(LPTMETER lptm, HWND hwndOldFocus)
{
	BOOL fSuccess = TRUE;

	TracePrintf_0(NULL, 6,
		TEXT("WM_SETFOCUS\n"));

	lptm->fHasFocus = TRUE;

	if (!InvalidateRect(lptm->hwnd, NULL, TRUE))
		fSuccess = TraceFALSE(NULL);
}

static void TrackMeter_OnKillFocus(LPTMETER lptm, HWND hwndNewFocus)
{
	BOOL fSuccess = TRUE;

	TracePrintf_0(NULL, 6,
		TEXT("WM_KILLFOCUS\n"));

	lptm->fHasFocus = FALSE;

	if (!InvalidateRect(lptm->hwnd, NULL, TRUE))
		fSuccess = TraceFALSE(NULL);
}

static void TrackMeter_OnEnable(LPTMETER lptm, BOOL fEnable)
{
	BOOL fSuccess = TRUE;

	TracePrintf_1(NULL, 6,
		TEXT("WM_ENABLE, fEnable=%d\n"),
		(int) fEnable);

	lptm->fIsEnabled = fEnable;

	if (!InvalidateRect(lptm->hwnd, NULL, TRUE))
		fSuccess = TraceFALSE(NULL);
}

static UINT TrackMeter_OnGetDlgCode(LPTMETER lptm, LPMSG lpmsg)
{
	return DLGC_WANTARROWS;
}

static void TrackMeter_OnKey(LPTMETER lptm, UINT vk, BOOL fDown, int cRepeat, UINT flags)
{
	UINT code = 0;
	UINT nPos = 0;
	LONG lPosition;

	switch (vk)
	{
		case VK_UP:		
		case VK_RIGHT:
			lPosition = lptm->lPosition + lptm->lLineSize;
			code = TB_LINEDOWN;
			break;

		case VK_DOWN:
		case VK_LEFT:
			lPosition = lptm->lPosition - lptm->lLineSize;
			code = TB_LINEUP;
			break;

		case VK_NEXT:
			lPosition = lptm->lPosition + lptm->lPageSize;
			code = TB_PAGEDOWN;
			break;

		case VK_PRIOR:
			lPosition = lptm->lPosition - lptm->lPageSize;
			code = TB_PAGEUP;
			break;

		case VK_HOME:
			lPosition = lptm->lMinimum;
			code = TB_TOP;
			break;

		case VK_END:
			lPosition = lptm->lMaximum;
			code = TB_BOTTOM;
			break;

		default:
			return;
	}

	// Adjust position of thumb
	if (fDown)
	{
		// we change the current position for WM_KEYDOWN only
		TrackMeter_OnTMMSetPos(lptm, lPosition, TRUE);
		TrackMeter_NotifyParent(lptm, code, 0);
	}

	TrackMeter_NotifyParent(lptm, TB_ENDTRACK, 0);
}

static void TrackMeter_OnLButtonDown(LPTMETER lptm, BOOL fDoubleClick, int x, int y, UINT keyFlags)
{
	SetFocus(lptm->hwnd);
	SetCapture(lptm->hwnd);

	TracePrintf_3(NULL, 6,
		TEXT("WM_LBUTTONDOWN, fDoubleClick=%d, x=%d, y=%d\n"),
		(int) fDoubleClick,
		(int) x,
		(int) y);

	if (TrackMeter_PtInThumb(lptm, x, y))
	{
		lptm->fIsThumbPressed = TRUE;
		TrackMeter_OnMouseMove(lptm, x, y, 0);
	}

	else if (x < lptm->aptThumb[0].x)
		TrackMeter_OnKey(lptm, VK_PRIOR, TRUE, 1, 0);

	else if (x > lptm->aptThumb[0].x)
		TrackMeter_OnKey(lptm, VK_NEXT, TRUE, 1, 0);
}

static void TrackMeter_OnLButtonUp(LPTMETER lptm, int x, int y, UINT keyFlags)
{
	TracePrintf_2(NULL, 6,
		TEXT("WM_LBUTTONUP, x=%d, y=%d\n"),
		(int) x,
		(int) y);

	ReleaseCapture();

	if (lptm->fIsThumbPressed)
	{
		LONG lPosition = TrackMeter_XToPosition(lptm, x);

		lptm->fIsThumbPressed = FALSE;
		TrackMeter_OnTMMSetPos(lptm, lptm->lPosition, TRUE); // just redraw

		if (lPosition >= lptm->lMinimum && lPosition <= lptm->lMaximum)
			TrackMeter_NotifyParent(lptm, TB_THUMBPOSITION, lptm->lPosition);
	}

	TrackMeter_NotifyParent(lptm, TB_ENDTRACK, 0);
}

static void TrackMeter_OnRButtonDown(LPTMETER lptm, BOOL fDoubleClick, int x, int y, UINT keyFlags)
{
	SetFocus(lptm->hwnd);
	SetCapture(lptm->hwnd);

	TracePrintf_3(NULL, 6,
		TEXT("WM_RBUTTONDOWN, fDoubleClick=%d, x=%d, y=%d\n"),
		(int) fDoubleClick,
		(int) x,
		(int) y);

	if (TrackMeter_PtInThumb(lptm, x, y))
	{
		LONG lPosition = TrackMeter_XToPosition(lptm, x);

		lptm->fIsThumbPressed = TRUE;
		
		TrackMeter_OnTMMSetPos(lptm, lPosition, TRUE);
		TrackMeter_OnMouseMove(lptm, lptm->aptThumb[0].x, y, 0);
		TrackMeter_NotifyParent(lptm, TB_THUMBPOSITION, lptm->lPosition);
	}
}

static void TrackMeter_OnRButtonUp(LPTMETER lptm, int x, int y, UINT keyFlags)
{
	TracePrintf_2(NULL, 6,
		TEXT("WM_RBUTTONUP, x=%d, y=%d\n"),
		(int) x,
		(int) y);

	ReleaseCapture();

	if ( lptm->fIsThumbPressed )
		TrackMeter_NotifyParent(lptm, TB_ENDTRACK, 0);
}

static void TrackMeter_OnMouseMove(LPTMETER lptm, int x, int y, UINT keyFlags)
{
	if (lptm->fIsThumbPressed)
	{
		LONG lPosition = TrackMeter_XToPosition(lptm, x);

		TracePrintf_2(NULL, 6,
			TEXT("WM_MOUSEMOVE, x=%d, y=%d\n"),
			(int) x,
			(int) y);

		if (lPosition != lptm->lPosition)
		{
			TrackMeter_OnTMMSetPos(lptm, lPosition, TRUE);
			TrackMeter_NotifyParent(lptm, TB_THUMBTRACK, lptm->lPosition);
		}
	}
}

static void TrackMeter_OnCaptureChanged(LPTMETER lptm, HWND hwndNewCapture)
{
	TracePrintf_0(NULL, 6,
		TEXT("WM_CAPTURECHANGED\n"));
}

static void TrackMeter_NotifyParent(LPTMETER lptm, UINT code, UINT nPos)
{
	if (TraceGetLevel(NULL) >= 6)
	{
		LPTSTR lpszCode;
		switch (code)
		{
			case TB_LINEUP:
				lpszCode = TEXT("LB_LINEUP");
				break;
			case TB_LINEDOWN:
				lpszCode = TEXT("LB_LINEDOWN");
				break;
			case TB_PAGEUP:
				lpszCode = TEXT("LB_PAGEUP");
				break;
			case TB_PAGEDOWN:
				lpszCode = TEXT("LB_PAGEDOWN");
				break;
			case TB_TOP:
				lpszCode = TEXT("LB_TOP");
				break;
			case TB_BOTTOM:
				lpszCode = TEXT("LB_BOTTOM");
				break;
			case TB_ENDTRACK:
				lpszCode = TEXT("LB_ENDTRACK");
				break;
			case TB_THUMBTRACK:
				lpszCode = TEXT("LB_THUMBTRACK");
				break;
			case TB_THUMBPOSITION:
				lpszCode = TEXT("LB_THUMBPOSITION");
				break;
			default:
				lpszCode = TEXT("***unknown***");
				break;					
		}

		TracePrintf_4(NULL, 6,
			TEXT("WM_HSCROLL, %s, code=%u, nPos=%u, lPosition=%ld\n"),
			(LPTSTR) lpszCode,
			(unsigned) code,
			(unsigned) nPos,
			(long) lptm->lPosition);
	}

	if (1) // $FIXUP - check for horizontal style here
	{
		FORWARD_WM_HSCROLL(lptm->hwndParent,
			lptm->hwnd, code, nPos, SendMessage);
	}
	else
	{
		FORWARD_WM_VSCROLL(lptm->hwndParent,
			lptm->hwnd, code, nPos, SendMessage);
	}
}

static LONG TrackMeter_OnTMMGetPos(LPTMETER lptm)
{
	BOOL fSuccess = TRUE;
	LONG lPosition = 0;

	if (lptm == NULL)
		fSuccess = TraceFALSE(NULL);

	else
		lPosition = lptm->lPosition;

	return lPosition;
}

static void TrackMeter_OnTMMSetPos(LPTMETER lptm, LONG lPosition, BOOL fRedraw)
{
	BOOL fSuccess = TRUE;

	if (lptm == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lptm->lPosition = max(lptm->lMinimum,
			min(lPosition, lptm->lMaximum));

		if (TrackMeter_Recalc(lptm, TMR_THUMB) != 0)
			fSuccess = TraceFALSE(NULL);

		if (fRedraw && !InvalidateRect(lptm->hwnd, NULL, TRUE))
			fSuccess = TraceFALSE(NULL);
	}
}

static LONG TrackMeter_OnTMMGetRangeMin(LPTMETER lptm)
{
	BOOL fSuccess = TRUE;
	LONG lMinimum = 0;

	if (lptm == NULL)
		fSuccess = TraceFALSE(NULL);

	else
		lMinimum = lptm->lMinimum;

	return lMinimum;
}

static void TrackMeter_OnTMMSetRangeMin(LPTMETER lptm, LONG lMinimum, BOOL fRedraw)
{
	BOOL fSuccess = TRUE;

	if (lptm == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lptm->lMinimum = lMinimum;
	
		// adjust position and level if necessary
		//
		TrackMeter_OnTMMSetPos(lptm, lptm->lPosition, FALSE);
		TrackMeter_OnTMMSetLevel(lptm, lptm->lLevel, FALSE);

		if (TrackMeter_Recalc(lptm, TMR_PAGESIZE) != 0)
			fSuccess = TraceFALSE(NULL);

		if (fRedraw && !InvalidateRect(lptm->hwnd, NULL, TRUE))
			fSuccess = TraceFALSE(NULL);
	}
}

static LONG TrackMeter_OnTMMGetRangeMax(LPTMETER lptm)
{
	BOOL fSuccess = TRUE;
	LONG lMaximum = 0;

	if (lptm == NULL)
		fSuccess = TraceFALSE(NULL);

	else
		lMaximum = lptm->lMaximum;

	return lMaximum;
}

static void TrackMeter_OnTMMSetRangeMax(LPTMETER lptm, LONG lMaximum, BOOL fRedraw)
{
	BOOL fSuccess = TRUE;

	if (lptm == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lptm->lMaximum = lMaximum;
	
		// adjust position and level if necessary
		//
		TrackMeter_OnTMMSetPos(lptm, lptm->lPosition, FALSE);
		TrackMeter_OnTMMSetLevel(lptm, lptm->lLevel, FALSE);

		if (TrackMeter_Recalc(lptm, TMR_PAGESIZE) != 0)
			fSuccess = TraceFALSE(NULL);

		if (fRedraw && !InvalidateRect(lptm->hwnd, NULL, TRUE))
			fSuccess = TraceFALSE(NULL);
	}
}

static void TrackMeter_OnTMMSetRange(LPTMETER lptm, LONG lMinimum, LONG lMaximum, BOOL fRedraw)
{
	TrackMeter_OnTMMSetRangeMin(lptm, lMinimum, FALSE);
	TrackMeter_OnTMMSetRangeMax(lptm, lMaximum, fRedraw);
}


static LONG TrackMeter_OnTMMGetLevel(LPTMETER lptm)
{
	BOOL fSuccess = TRUE;
	LONG lLevel = 0;

	if (lptm == NULL)
		fSuccess = TraceFALSE(NULL);

	else
		lLevel = lptm->lLevel;

	return lLevel;
}

static void TrackMeter_OnTMMSetLevel(LPTMETER lptm, LONG lLevel, BOOL fRedraw)
{
	BOOL fSuccess = TRUE;

	if (lptm == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lptm->lLevel = max(lptm->lMinimum,
			min(lLevel, lptm->lMaximum));

		if (TrackMeter_Recalc(lptm, TMR_LEVEL) != 0)
			fSuccess = TraceFALSE(NULL);

		if (fRedraw && !InvalidateRect(lptm->hwnd, NULL, TRUE))
			fSuccess = TraceFALSE(NULL);
	}
}

static COLORREF TrackMeter_OnTMMGetColor(LPTMETER lptm, UINT elem)
{
	BOOL fSuccess = TRUE;
	COLORREF cr = RGB(0, 0, 0);

	if (lptm == NULL)
		fSuccess = TraceFALSE(NULL);

	else
		cr = lptm->acr[elem];

	return cr;
}

static void TrackMeter_OnTMMSetColor(LPTMETER lptm, COLORREF cr, UINT elem, BOOL fRedraw)
{
	BOOL fSuccess = TRUE;

	if (lptm == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lptm->acr[elem] = cr;

		if (fRedraw && !InvalidateRect(lptm->hwnd, NULL, TRUE))
			fSuccess = TraceFALSE(NULL);
	}
}

static int TrackMeter_Recalc(LPTMETER lptm, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;

	if (!GetClientRect(lptm->hwnd, &lptm->rcCtrl))
		fSuccess = TraceFALSE(NULL);

	else
	{
		int cxCtrl = lptm->rcCtrl.right - lptm->rcCtrl.left;
		int cyCtrl = lptm->rcCtrl.bottom - lptm->rcCtrl.top;
		int cxBorder = 2;
		int cyBorder = 2;
		int cxThumb = ((cyCtrl - cyBorder - cyBorder) / 2) * 2 - 1;
		int cyThumb = cxThumb - 2;
		int cyTrackTopBorder = 2;
		int cxTrackLeftBorder = 2;
		int cxTrackRightBorder = 2;
		int cyTrackBottomBorder = 1;
		int xTrack = cxThumb / 2 - cxTrackLeftBorder + cxBorder;
		int yTrack = cyBorder;
		int cxTrack = cxCtrl - xTrack - xTrack;
		int cyTrack = (cyCtrl - cyBorder - cyBorder) / 2 + 1;
		int xMeter = xTrack + cxTrackLeftBorder;
		int yMeter = yTrack + cyTrackTopBorder;
		int cxMeter = cxTrack - cxTrackLeftBorder - cxTrackRightBorder;
		int cyMeter = cyTrack - cyTrackTopBorder - cyTrackBottomBorder;

		if (dwFlags & TMR_TRACK)
		{
			lptm->rcTrack.left = xTrack;
			lptm->rcTrack.top = yTrack;
			lptm->rcTrack.right = xTrack + cxTrack - 1;
			lptm->rcTrack.bottom = yTrack + cyTrack - 1;
		}

		if (dwFlags & TMR_METER)
		{
			lptm->rcMeter.left = xMeter;
			lptm->rcMeter.top = yMeter;
			lptm->rcMeter.right = xMeter + cxMeter - 1;
			lptm->rcMeter.bottom = yMeter + cyMeter;
		}
	
		if (dwFlags & TMR_LEVEL)
		{
			lptm->rcLevel.left = xMeter;
			lptm->rcLevel.top = yMeter;
			lptm->rcLevel.right = TrackMeter_PositionToX(lptm, lptm->lLevel) + 1;
			lptm->rcLevel.bottom = yMeter + cyMeter;
		}
	
		if (dwFlags & TMR_THUMB)
		{
			lptm->aptThumb[0].x = TrackMeter_PositionToX(lptm, lptm->lPosition);
			lptm->aptThumb[0].y = cyCtrl - cyBorder - cyThumb;
			lptm->aptThumb[1].x = lptm->aptThumb[0].x - (cxThumb / 2);
			lptm->aptThumb[1].y = lptm->aptThumb[0].y + (cyThumb / 2) + 1;
			lptm->aptThumb[2].x = lptm->aptThumb[1].x;
			lptm->aptThumb[2].y = lptm->aptThumb[0].y + cyThumb - 1;
			lptm->aptThumb[3].x = lptm->aptThumb[2].x + cxThumb - 1;
			lptm->aptThumb[3].y = lptm->aptThumb[2].y;
			lptm->aptThumb[4].x = lptm->aptThumb[3].x;
			lptm->aptThumb[4].y = lptm->aptThumb[1].y;
		}

		if (dwFlags & TMR_COLORS)
		{
			COLORREF crWindow = GetSysColor(COLOR_WINDOW);
			COLORREF cr3DFace = GetSysColor(COLOR_3DFACE);
			COLORREF cr3DLight = GetSysColor(COLOR_3DLIGHT);
			COLORREF cr3DHilight = GetSysColor(COLOR_3DHILIGHT);
			COLORREF cr3DShadow = GetSysColor(COLOR_3DSHADOW);
			COLORREF cr3DDkShadow = GetSysColor(COLOR_3DDKSHADOW);
			COLORREF crGreen = RGB(0, 128, 0);

			// try to make cr3DLight distinctive
			//
			if (cr3DLight == cr3DFace || cr3DLight == cr3DHilight)
			{
				HDC hdc = NULL;
				int nColors;

				if ((hdc = GetDC(NULL)) == NULL)
					fSuccess = TraceFALSE(NULL);

				// make sure screen device has more than 8 bits per pixel
				//
				else if ((nColors = GetDeviceCaps(hdc, NUMCOLORS)) == -1)
				{
					cr3DLight = RGB((GetRValue(cr3DFace) + GetRValue(cr3DHilight)) / 2,
						(GetGValue(cr3DFace) + GetGValue(cr3DHilight)) / 2,
						(GetBValue(cr3DFace) + GetBValue(cr3DHilight)) / 2);
				}

				else
				{
					cr3DLight = cr3DHilight;
				}

				if (hdc != NULL && !ReleaseDC(NULL, hdc))
					fSuccess = TraceFALSE(NULL);
			}

			lptm->acr[TMCR_CTRLBACKGROUND] = cr3DFace;
			lptm->acr[TMCR_FOCUSBACKGROUND] = crWindow;
			lptm->acr[TMCR_TRACKBACKGROUND] = cr3DLight;
			lptm->acr[TMCR_TRACKLIGHT] = cr3DHilight;
			lptm->acr[TMCR_TRACKSHADOW] = cr3DShadow;
			lptm->acr[TMCR_TRACKDKSHADOW] = cr3DDkShadow;
			lptm->acr[TMCR_THUMBFACE] = cr3DFace;
			lptm->acr[TMCR_THUMBFACEPRESSED] = cr3DLight;
			lptm->acr[TMCR_THUMBLIGHT] = cr3DHilight;
			lptm->acr[TMCR_THUMBSHADOW] = cr3DShadow;
			lptm->acr[TMCR_THUMBDKSHADOW] = cr3DDkShadow;
			lptm->acr[TMCR_LEVEL] = crGreen;
		}

		if (dwFlags & TMR_PAGESIZE)
		{
			lptm->lPageSize = max(1, (lptm->lMaximum - lptm->lMinimum) / 5);
		}
	}

	return fSuccess ? 0 : -1;
}

// given lPosition between lptm->lMinimum and lptm->lMaximum,
// return x coordinate between lptm->rcMeter.left and lptm->rcMeter.right
//
static int TrackMeter_PositionToX(LPTMETER lptm, long lPosition)
{
	long lPos = max(lptm->lMinimum, min(lPosition, lptm->lMaximum));
	long lPct = ((1000 * (lPos - lptm->lMinimum) /
		max(1, lptm->lMaximum - lptm->lMinimum)) + 5) / 10;
	int cxMeter = lptm->rcMeter.right - lptm->rcMeter.left + 1;
	long cxPosition = ((10 * max(0, min(100, lPct)) * cxMeter / 100) + 5) / 10;
	int xPosition = max(lptm->rcMeter.left, lptm->rcMeter.left + min(cxPosition, cxMeter) - 1);
	return xPosition;
}

// given x coordinate between lptm->rcMeter.left and lptm->rcMeter.right,
// return lPosition between lptm->lMinimum and lptm->lMaximum
//
static long TrackMeter_XToPosition(LPTMETER lptm, int xPosition)
{
	int x = max(lptm->rcMeter.left, min(xPosition, lptm->rcMeter.right));
	long lPct = ((1000 * (x - lptm->rcMeter.left) /
		max(1, lptm->rcMeter.right - lptm->rcMeter.left)) + 5) / 10;
	long lRange = lptm->lMaximum - lptm->lMinimum + 1;
	long cxPosition = ((10 * max(0, min(100, lPct)) * lRange / 100) + 5) / 10;
	long lPosition = max(lptm->lMinimum, lptm->lMinimum + min(cxPosition, lRange) - 1);
	return lPosition;
}

static BOOL TrackMeter_PtInThumb(LPTMETER lptm, int x, int y)
{
	BOOL fSuccess = TRUE;
	BOOL fInThumb = FALSE;
	HRGN hrgnThumb;

	if ((hrgnThumb = CreatePolygonRgn(lptm->aptThumb, 
		(sizeof(lptm->aptThumb) / sizeof(lptm->aptThumb[0])), WINDING)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		if (PtInRegion(hrgnThumb, x, y))
			fInThumb = TRUE;

		if (!DeleteObject(hrgnThumb))
			fSuccess = TraceFALSE(NULL);
	}

	return fInThumb;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\avgenntfy.h ===
// AVGenNtfy.h : Declaration of the CAVGeneralNotification

#ifndef __AVGENERALNOTIFICATION_H_
#define __AVGENERALNOTIFICATION_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CAVGeneralNotification
class ATL_NO_VTABLE CAVGeneralNotification : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CAVGeneralNotification, &CLSID_AVGeneralNotification>,
	public IAVGeneralNotification,
	public IConnectionPointContainerImpl<CAVGeneralNotification>,
	public IConnectionPointImpl<CAVGeneralNotification, &IID_IGeneralNotification>
{
public:
	CAVGeneralNotification()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_AVGENERALNOTIFICATION)

BEGIN_COM_MAP(CAVGeneralNotification)
	COM_INTERFACE_ENTRY(IAVGeneralNotification)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CAVGeneralNotification)
	CONNECTION_POINT_ENTRY(IID_IGeneralNotification)
END_CONNECTION_POINT_MAP()


// IAVGeneralNotification
public:
	STDMETHOD(fire_SelectConfParticipant)(IParticipant *pParticipant);
	STDMETHOD(fire_DeleteAllConfParticipants)();
	STDMETHOD(fire_UpdateConfParticipant)(MyUpdateType nType, IParticipant *pParticipant, BSTR bstrText);
	STDMETHOD(fire_UpdateConfRootItem)(BSTR bstrNewText);
	STDMETHOD(fire_AddSpeedDial)(BSTR bstrName, BSTR bstrAddress, CallManagerMedia cmm);
	STDMETHOD(fire_NotifySiteServerStateChange)(BSTR bstrName, ServerState nState);
	STDMETHOD(fire_RemoveSiteServer)(BSTR bstrName);
	STDMETHOD(fire_AddSiteServer)(BSTR bstrName);
	STDMETHOD(fire_ResolveAddressEx)(BSTR bstrAddress, long lAddressType, DialerMediaType nMedia, DialerLocationType nLoctaion, BSTR *pbstrName, BSTR *pbstrAddress, BSTR *pbstrUser1, BSTR *pbstrUser2);
	STDMETHOD(fire_AddUser)(BSTR bstrName, BSTR bstrAddress, BSTR bstrPhoneNumber);
	STDMETHOD(fire_ClearUserList)();
	STDMETHOD(fire_ResolveAddress)(BSTR bstrAddress, BSTR *pbstrName, BSTR *pbstrUser1, BSTR *pbstrUser2);
	STDMETHOD(Term)();
	STDMETHOD(Init)();

// ConnectionPointFiring
	STDMETHOD(fire_IsReminderSet)(BSTR bstrServer, BSTR bstrName);
};

#endif //__AVGENERALNOTIFICATION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avmeter\tmeter.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// tmeter.h - TrackMeter custom control
////

////
// public
////

//#if 0
//#include "winlocal.h"
//#else
#ifndef STRICT
#define STRICT
#endif
#include <windows.h>
#include <windowsx.h>
#define DLLEXPORT __declspec(dllexport)
#define DECLARE_HANDLE32    DECLARE_HANDLE
//#endif

#include <commctrl.h>

// control styles
//
#define TMS_HORZ				TBS_HORZ
#define TMS_VERT				TBS_VERT
#define TMS_NOTHUMB				TBS_NOTHUMB

// control messages
//
#define TMM_GETPOS				TBM_GETPOS
#define TMM_SETPOS				TBM_SETPOS
#define TMM_GETRANGEMIN         TBM_GETRANGEMIN
#define TMM_SETRANGEMIN			TBM_SETRANGEMIN
#define TMM_GETRANGEMAX			TBM_GETRANGEMAX
#define TMM_SETRANGEMAX			TBM_SETRANGEMAX
#define TMM_SETRANGE			TBM_SETRANGE

#define TMM_GETLEVEL			(WM_USER + 100)
#define TMM_SETLEVEL			(WM_USER + 101)
#define TMM_GETCOLOR			(WM_USER + 102)
#define TMM_SETCOLOR			(WM_USER + 103)

#define TRACKMETER_MODULE TEXT("avMeter.dll")
#define TRACKMETER_CLASS TEXT("TrackMeterClass")
#define TRACKMETER_CLASS_A "TrackMeterClass"

// TrackMeter_Init - initialize control library
//		<lpLibFileName>		(i) address of filename of executable module
//		<hInst>				(i) module handle used to get library path
//			NULL				use module used to create calling process
//		<dwFlags>			(i) reserved; must be zero
// returns HMODULE of control library, NULL if error
//
#ifdef __LOADLIB_H__
#define TrackMeter_Init(hInst, dwFlags) \
	(HMODULE) LoadLibraryPath(TRACKMETER_MODULE, hInst, dwFlags)
#else
#define TrackMeter_Init(hInst, dwFlags) \
	(HMODULE) LoadLibrary(TRACKMETER_MODULE)
#endif

// TrackMeter_Term - shuts down control library
//		<hModule>			(i) handle returned from TrackMeter_Init
// returns non-zero if success
//
#define TrackMeter_Term(hModule) \
	(BOOL) FreeLibrary(hModule)

// TrackMeter_Create - create TrackMeter control
//		<dwStyle>			(i) style flags
//			TMS_HORZ			horizontal control (default)
//			TMS_VERT			vertical control $FIXUP - not supported yet
//			TMS_NOTHUMB			do not display thumb
//			WS_CHILD | WS_VISIBLE and other standard window styles
//		<x>					(i) horizontal position of control
//		<y>					(i) vertical position of control
//		<cx>				(i) width of control
//		<cy>				(i) height of control
//		<hwndParent>		(i) handle to parent of control
//		<hInst>				(i) instance of module associated with control
// returns hwnd of control, NULL if error
//
#define TrackMeter_Create(dwStyle, x, y, cx, cy, hwndParent, hInst) \
	(HWND) CreateWindowEx(0L, TRACKMETER_CLASS, TEXT(""), \
		dwStyle, x, y, cx, cy, hwndParent, NULL, hInst, NULL)

// TrackMeter_Destroy - destroy TrackMeter control
//		<hwnd>				(i) handle returned by TrackMeter_Create
// returns non-zero if success
//
#define TrackMeter_Destroy(hwnd) \
	(BOOL) DestroyWindow(hwnd)

// TrackMeter_GetPos - get current position of slider
//		<hwnd>				(i) handle returned by TrackMeter_Create
// returns 32-bit slider position
//
#define TrackMeter_GetPos(hwnd) \
	(LONG)(DWORD) SNDMSG(hwnd, TMM_GETPOS, 0, 0)
/* LONG Cls_OnTMMGetPos(HWND hwnd) */
#define HANDLE_TMM_GETPOS(hwnd, wParam, lParam, fn) \
	(LRESULT)(DWORD)(long)(fn)(hwnd)
#define FORWARD_TMM_GETPOS(hwnd, fn) \
    (LONG)(DWORD)(fn)((hwnd), TMM_GETPOS, 0L, 0L)

// TrackMeter_SetPos - set current position of slider
//		<hwnd>				(i) handle returned by TrackMeter_Create
//		<lPosition>			(i) new position for slider
//		<fRedraw>			(i) redraw control at new position if TRUE
// returns nothing
//
#define TrackMeter_SetPos(hwnd, lPosition, fRedraw) \
	(void) SNDMSG(hwnd, TMM_SETPOS, (WPARAM) fRedraw, (LPARAM) lPosition)
/* void Cls_OnTMMSetPos(HWND hwnd, LONG lPosition, BOOL fRedraw) */
#define HANDLE_TMM_SETPOS(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (LONG)(lParam), (BOOL)(wParam)), 0L)
#define FORWARD_TMM_SETPOS(hwnd, lPosition, fRedraw, fn) \
    (void)(fn)((hwnd), TMM_SETPOS, (WPARAM)(BOOL)(fRedraw), (LPARAM)(LONG)(lPosition))

// TrackMeter_GetRangeMin - get minimum position of slider
//		<hwnd>				(i) handle returned by TrackMeter_Create
// returns 32-bit slider minimum position
//
#define TrackMeter_GetRangeMin(hwnd) \
	(LONG)(DWORD) SNDMSG(hwnd, TMM_GETRANGEMIN, 0, 0)
/* LONG Cls_OnTMMGetRangeMin(HWND hwnd) */
#define HANDLE_TMM_GETRANGEMIN(hwnd, wParam, lParam, fn) \
	(LRESULT)(DWORD)(long)(fn)(hwnd)
#define FORWARD_TMM_GETRANGEMIN(hwnd, fn) \
    (LONG)(DWORD)(fn)((hwnd), TMM_GETRANGEMIN, 0L, 0L)

// TrackMeter_SetRangeMin - set minimum position of slider
//		<hwnd>				(i) handle returned by TrackMeter_Create
//		<lMinimum>			(i) new minimum position for slider
//		<fRedraw>			(i) redraw control if TRUE
// returns nothing
//
#define TrackMeter_SetRangeMin(hwnd, lMinimum, fRedraw) \
	(void) SNDMSG(hwnd, TMM_SETRANGEMIN, (WPARAM) fRedraw, (LPARAM) lMinimum)
/* void Cls_OnTMMSetRangeMin(HWND hwnd, LONG lMinimum, BOOL fRedraw) */
#define HANDLE_TMM_SETRANGEMIN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (LONG)(lParam), (BOOL)(wParam)), 0L)
#define FORWARD_TMM_SETRANGEMIN(hwnd, lMinimum, fRedraw, fn) \
    (void)(fn)((hwnd), TMM_SETRANGEMIN, (WPARAM)(BOOL)(fRedraw), (LPARAM)(LONG)(lMinimum))

// TrackMeter_GetRangeMax - get maximum position of slider
//		<hwnd>				(i) handle returned by TrackMeter_Create
// returns 32-bit slider maximum position
//
#define TrackMeter_GetRangeMax(hwnd) \
	(LONG)(DWORD) SNDMSG(hwnd, TMM_GETRANGEMAX, 0, 0)
/* LONG Cls_OnTMMGetRangeMax(HWND hwnd) */
#define HANDLE_TMM_GETRANGEMAX(hwnd, wParam, lParam, fn) \
	(LRESULT)(DWORD)(long)(fn)(hwnd)
#define FORWARD_TMM_GETRANGEMAX(hwnd, fn) \
    (LONG)(DWORD)(fn)((hwnd), TMM_GETRANGEMAX, 0L, 0L)

// TrackMeter_SetRangeMax - set maximum position of slider
//		<hwnd>				(i) handle returned by TrackMeter_Create
//		<lMaximum>			(i) new maximum position for slider
//		<fRedraw>			(i) redraw control if TRUE
// returns nothing
//
#define TrackMeter_SetRangeMax(hwnd, lMaximum, fRedraw) \
	(void) SNDMSG(hwnd, TMM_SETRANGEMAX, (WPARAM) fRedraw, (LPARAM) lMaximum)
/* void Cls_OnTMMSetRangeMax(HWND hwnd, LONG lMaximum, BOOL fRedraw) */
#define HANDLE_TMM_SETRANGEMAX(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (LONG)(lParam), (BOOL)(wParam)), 0L)
#define FORWARD_TMM_SETRANGEMAX(hwnd, lMaximum, fRedraw, fn) \
    (void)(fn)((hwnd), TMM_SETRANGEMAX, (WPARAM)(BOOL)(fRedraw), (LPARAM)(LONG)(lMaximum))

// TrackMeter_SetRange - set minimum and maximum positions of slider
//		<hwnd>				(i) handle returned by TrackMeter_Create
//		<lMinimum>			(i) new minimum position for slider
//		<lMaximum>			(i) new maximum position for slider
//		<fRedraw>			(i) redraw control if TRUE
// returns nothing
//
#define TrackMeter_SetRange(hwnd, lMinimum, lMaximum, fRedraw) \
	(void) SNDMSG(hwnd, TMM_SETRANGE, (WPARAM) fRedraw, \
		(LPARAM) MAKELONG(lMinimum, lMaximum))
/* void Cls_OnTMMSetRange(HWND hwnd, LONG lMinimum, LONG lMaximum, BOOL fRedraw) */
#define HANDLE_TMM_SETRANGE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (LONG)LOWORD(lParam), (LONG)HIWORD(lParam), (BOOL)(wParam)), 0L)
#define FORWARD_TMM_SETRANGE(hwnd, lMinimum, lMaximum, fRedraw, fn) \
    (void)(fn)((hwnd), TMM_SETRANGE, (WPARAM)(BOOL)(fRedraw), (LPARAM)MAKELONG(lMinimum, lMaximum))

// TrackMeter_GetLevel - get current level of meter
//		<hwnd>				(i) handle returned by TrackMeter_Create
// returns 32-bit meter level
//
#define TrackMeter_GetLevel(hwnd) \
	(LONG)(DWORD) SNDMSG(hwnd, TMM_GETLEVEL, 0, 0)
/* LONG Cls_OnTMMGetLevel(HWND hwnd) */
#define HANDLE_TMM_GETLEVEL(hwnd, wParam, lParam, fn) \
	(LRESULT)(DWORD)(long)(fn)(hwnd)
#define FORWARD_TMM_GETLEVEL(hwnd, fn) \
    (LONG)(DWORD)(fn)((hwnd), TMM_GETLEVEL, 0L, 0L)

// TrackMeter_SetLevel - set current level of meter
//		<hwnd>				(i) handle returned by TrackMeter_Create
//		<lLevel>			(i) new level for meter
//		<fRedraw>			(i) redraw control at new level if TRUE
// returns nothing
//
#define TrackMeter_SetLevel(hwnd, lLevel, fRedraw) \
	(void) SNDMSG(hwnd, TMM_SETLEVEL, (WPARAM) fRedraw, (LPARAM) lLevel)
/* void Cls_OnTMMSetLevel(HWND hwnd, LONG lLevel, BOOL fRedraw) */
#define HANDLE_TMM_SETLEVEL(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (LONG)(lParam), (BOOL)(wParam)), 0L)
#define FORWARD_TMM_SETLEVEL(hwnd, lLevel, fRedraw, fn) \
    (void)(fn)((hwnd), TMM_SETLEVEL, (WPARAM)(BOOL)(fRedraw), (LPARAM)(LONG)(lLevel))

// TrackMeter_GetColor - get current color for control element
//		<hwnd>				(i) handle returned by TrackMeter_Create
//		<elem>				(i) which element color to get
//			see TMCR_ #defines below
// returns 32-bit COLORREF
//
#define TrackMeter_GetColor(hwnd, elem) \
	(COLORREF)(DWORD) SNDMSG(hwnd, TMM_GETCOLOR, (WPARAM) 0, \
		(LPARAM) MAKELONG(elem, 0))
/* COLORREF Cls_OnTMMGetColor(HWND hwnd, UINT elem) */
#define HANDLE_TMM_GETCOLOR(hwnd, wParam, lParam, fn) \
	(LRESULT)(DWORD)(long)(fn)(hwnd, (UINT)LOWORD(lParam))
#define FORWARD_TMM_GETCOLOR(hwnd, fn) \
    (COLORREF)(DWORD)(fn)((hwnd), TMM_GETCOLOR, (WAPRAM) 0L, \
		(LPARAM)MAKELONG((UINT)(elem), 0))

// TrackMeter_SetColor - set color for control element
//		<hwnd>				(i) handle returned by TrackMeter_Create
//		<cr>				(i) COLORREF for specified element
//		<elem>				(i) which element gets the specified color
//			see TMCR_ #defines below
//		<fRedraw>			(i) redraw control if TRUE
// returns nothing
//
#define TrackMeter_SetColor(hwnd, cr, elem, fRedraw) \
	(void) SNDMSG(hwnd, TMM_SETCOLOR, (WPARAM) cr, \
		(LPARAM) MAKELONG(elem, fRedraw))
/* void Cls_OnTMMSetColor(HWND hwnd, COLORREF cr, UINT elem, BOOL fRedraw) */
#define HANDLE_TMM_SETCOLOR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (COLORREF)(wParam), (UINT)LOWORD(lParam), (BOOL)HIWORD(lParam)), 0L)
#define FORWARD_TMM_SETCOLOR(hwnd, cr, elem, fRedraw, fn) \
    (void)(fn)((hwnd), TMM_SETCOLOR, (WPARAM)(COLORREF)(cr), \
		(LPARAM)MAKELONG((UINT)(elem), (BOOL)(fRedraw)))

// <elem> values for ThumbTrack_GetColor and ThumbTrack_SetColor
//
#define TMCR_CTRLBACKGROUND			1
#define TMCR_FOCUSBACKGROUND		2
#define TMCR_TRACKBACKGROUND		3
#define TMCR_TRACKLIGHT				4
#define TMCR_TRACKSHADOW			5
#define TMCR_TRACKDKSHADOW			6
#define TMCR_LEVEL					7
#define TMCR_THUMBFACE				8
#define TMCR_THUMBFACEPRESSED		9
#define TMCR_THUMBLIGHT				10
#define TMCR_THUMBSHADOW			11
#define TMCR_THUMBDKSHADOW			12
#define TMCR_MAX					32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\avtapi.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// AVTapi.h : Declaration of the CAVTapi

#ifndef __AVTAPI_H_
#define __AVTAPI_H_

#include "TapiNotify.h"
#include "ThreadPub.h"
#include "..\avdialer\usb.h"

#pragma warning( disable : 4786 )

#include <list>
using namespace std;
typedef list<IAVTapiCall *> AVTAPICALLLIST;

// Conference Room settings
#define DEFAULT_VIDEO    6
#define MAX_VIDEO        20

// Terminals settings
#define MAX_TERMINALS    (6 + MAX_VIDEO)

#define LINEADDRESSTYPE_NETCALLS ~(LINEADDRESSTYPE_SDP | LINEADDRESSTYPE_PHONENUMBER)

///////////////////////////////////////////////////////////////
// simple class for storing information about Lines
//
class CMyAddressID
{
// Construction
public:
    CMyAddressID()
    {
        m_lPermID = m_lAddrID = 0;
    }

// Members
public:
    long m_lPermID;
    long m_lAddrID;
};

class CDlgPlaceCall;

/////////////////////////////////////////////////////////////////////////////
// CAVTapi
class ATL_NO_VTABLE CAVTapi : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CAVTapi, &CLSID_AVTapi>,
    public IAVTapi2,
    public IConnectionPointContainerImpl<CAVTapi>,
    public IConnectionPointImpl<CAVTapi, &IID_IAVTapiNotification>
{
// Enumerations
public:
    enum tagAddressTypes_t
    {
        CONFERENCE,
        EMAILNAME,
        IPADDRESS,
        DOMAINNAME,
        PHONENUMBER,
        MAX_ADDRESS_TYPES
    };

    typedef enum tagMediaTypes_t
    {
        MEDIA_POTS,
        MEDIA_INTERNET,
        MEDIA_CONFERENCE,
        MAX_MEDIA_TYPES
    } MediaTypes_t;

// Statics
public:
    static    arAddressTypes[MAX_ADDRESS_TYPES];

// Construction
public:
    CAVTapi();
    void FinalRelease();

// Members
public:
    ITTAPI                    *m_pITTapi;
    VARIANT_BOOL            m_bResolved;

protected:
    IConfExplorer            *m_pIConfExplorer;
    IConfRoom                *m_pIConfRoom;
    ITapiNotification        *m_pITapiNotification;

    CComAutoCriticalSection m_critConfExplorer;
    CComAutoCriticalSection m_critConfRoom;

    AVTAPICALLLIST            m_lstAVTapiCalls;
    CComAutoCriticalSection    m_critLstAVTapiCalls;
    bool                    m_bAutoCloseCalls;

    BSTR                    m_bstrDefaultServer;

    ITPhone*                m_pUSBPhone;            // USB Phone, if exist
    CComAutoCriticalSection m_critUSBPhone;         // Critical section
    BOOL                    m_bUSBOpened;           // If the USBPhone was open
    BSTR                    m_bstrUSBCaptureTerm;   // Audio capture terminal
    BSTR                    m_bstrUSBRenderTerm;    // Audio render terminal
    long                    m_nUSBInVolume;         // Audio in (microphone) volume
    long                    m_nUSBOutVolume;        // Audio out (speakers) volume

    HANDLE                  m_hEventDialerReg;      // Event use to signal Dialer registration done

private:
    long                    m_lShowCallDialog;
    long                    m_lRefreshDS;

    // Use this reference to send key pressed at the
    // phone object
    CDlgPlaceCall*          m_pDlgCall;

    // Audio echo cancellation
    BOOL                    m_bAEC;

// Attributes
public:
    bool        IsPreferredAddress( ITAddress *pITAddress, DWORD dwAddressType );

    HRESULT        GetDefaultAddress( DWORD dwAddressType, DWORD dwPermID, DWORD dwAddrID, ITAddress **ppITAddress );
    HRESULT        GetAddress( DWORD dwAddressType, bool bErrorMsg, ITAddress **ppITAddress );
    HRESULT        GetTerminal( ITTerminalSupport *pITTerminalSupport, long nReqType, TERMINAL_DIRECTION nReqTD, BSTR bstrReqName, ITTerminal **ppITTerminal );
    HRESULT        GetFirstCall( IAVTapiCall **ppAVCall );
    HRESULT     GetAllCallsAtState( AVTAPICALLLIST *pList, CALL_STATE callState );
    HRESULT        GetSwapHoldCallCandidate( IAVTapiCall *pAVCall, IAVTapiCall **ppAVCandidate );


    HRESULT USBCancellCall();
    HRESULT USBMakeCall();
    HRESULT USBKeyPress(long lButton);
    HRESULT USBAnswer();

private:
    HRESULT USBOffering( 
        IN  ITCallInfo* pCallInfo
        );

    HRESULT USBInprogress( 
        IN  ITCallInfo* pCallInfo
        );

    HRESULT USBDisconnected(
        IN  long    lCallID
        );

    BOOL    USBGetCheckboxValue(
        IN  BOOL bVerifyUSB = TRUE
        );

    HRESULT USBSetCheckboxValue(
        IN  BOOL    bCheckValue
        );

    HRESULT USBReserveStreamForPhone(
        IN  UINT    nStream,
        OUT BSTR*   pbstrTerminal
        );

private:
    BOOL AECGetRegistryValue(
        );

// Operations
public:
    HRESULT                CreateTerminalArray( ITAddress *pITAddress, IAVTapiCall *pAVCall, ITCallInfo *pITCallInfo );
    HRESULT                CreateTerminals( ITAddress *pITAddress, DWORD dwAddressType, IAVTapiCall *pAVCall, ITCallInfo *pITCallInfo, BSTR *pbstrTerm );
    CallManagerMedia    ResolveMediaType( long lAddressType );

    IAVTapiCall*        FindAVTapiCall( long lCallID );
    IAVTapiCall*        FindAVTapiCall( ITBasicCallControl *pControl );
    IAVTapiCall*        AddAVTapiCall( ITBasicCallControl *pControl, long lCallID );
    bool                RemoveAVTapiCall( ITBasicCallControl *pDeleteControl );

    static void            SetVideoWindowProperties( IVideoWindow *pVideoWindow, HWND hWndParent, BOOL bVisible );
    void                CloseExtraneousCallWindows();

    HRESULT                SelectTerminalOnStream( ITStreamControl *pStreamControl, long lMediaMode, long nDir, ITTerminal *pTerminal, IAVTapiCall *pAVCall );
    HRESULT                UnselectTerminalOnStream( ITStreamControl *pStreamControl, long lMediaMode, long nDir, ITTerminal *pTerminal, IAVTapiCall *pAVCall );

protected:
    void                LoadRegistry();
    void                SaveRegistry();
    HRESULT USBFindPhone(
        OUT ITPhone** ppUSBPhone
        );
    BOOL    USBIsH323Address(
        IN    ITAddress* pAddress
        );

    HRESULT USBGetH323Address(
        OUT ITAddress2** ppAddress2
        );

    HRESULT USBGetPhoneFromAddress(
        IN  ITAddress2* pAddress,
        OUT ITPhone**   ppPhone
        );

    HRESULT USBPhoneInitialize(
        IN  ITPhone* pPhone
        );

    HRESULT USBRegPutTerminals(
        );

    HRESULT USBRegDelTerminals(
        );

    HRESULT AECSetOnStream(
        IN  ITStreamControl*    pStreamControl,
        IN  BOOL                bAEC
        );

    HRESULT AnswerAction(
        IN  ITCallInfo*          pCallInfo,
        IN  ITBasicCallControl* pControl,
        IN  IAVTapiCall*        pAVCall,
        IN  BOOL                bUSBAnswer
        );

// Implementation
public:
DECLARE_REGISTRY_RESOURCEID(IDR_AVTAPI)
DECLARE_NOT_AGGREGATABLE(CAVTapi)

BEGIN_COM_MAP(CAVTapi)
    COM_INTERFACE_ENTRY(IAVTapi)
    COM_INTERFACE_ENTRY(IAVTapi2)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

// Connection Point mapping
BEGIN_CONNECTION_POINT_MAP(CAVTapi)
    CONNECTION_POINT_ENTRY(IID_IAVTapiNotification)
END_CONNECTION_POINT_MAP()

// IAVTapi
public:
    STDMETHOD(get_bAutoCloseCalls)(/*[out, retval]*/ VARIANT_BOOL *pVal);
    STDMETHOD(put_bAutoCloseCalls)(/*[in]*/ VARIANT_BOOL newVal);
    STDMETHOD(get_bstrDefaultServer)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_bstrDefaultServer)(/*[in]*/ BSTR newVal);
    STDMETHOD(FindAVTapiCallFromCallID)(long lCallID, IAVTapiCall **ppAVCall);
    STDMETHOD(CreateNewCall)(ITAddress *pITAddress, IAVTapiCall **ppAVCall);
    STDMETHOD(CreateDataCall)(long lCallID, BSTR bstrName, BSTR bstrAddress, BYTE *pBuf, DWORD dwBufSize);
    STDMETHOD(SendUserUserInfo)(long lCallID, BYTE *pBuf, DWORD dwSizeBuf);
    STDMETHOD(FindAVTapiCallFromCallInfo)(ITCallInfo *pCallInfo, IAVTapiCall **ppCall);
    STDMETHOD(RegisterUser)(VARIANT_BOOL bCreate, BSTR bstrServer);
    STDMETHOD(get_Call)(/*[in]*/ long lCallID, /*[out, retval]*/ IAVTapiCall **ppCall);
    STDMETHOD(CreateCallEx)(BSTR bstrName, BSTR bstrAddress, BSTR bstrUser1, BSTR bstrUser2, DWORD dwAddressType);
    STDMETHOD(RefreshDS)();
    STDMETHOD(CanCreateVideoWindows)(DWORD dwAddressType);
    STDMETHOD(FindAVTapiCallFromParticipant)(ITParticipant *pParticipant, IAVTapiCall **ppAVCall);
    STDMETHOD(get_nNumCalls)(/*[out, retval]*/ long *pVal);
    STDMETHOD(FindAVTapiCallFromCallHub)(ITCallHub *pCallHub, IAVTapiCall **ppCall);
    STDMETHOD(DigitPress)(long lCallID, PhonePadKey nKey);
    STDMETHOD(get_dwPreferredMedia)(/*[out, retval]*/ DWORD *pVal);
    STDMETHOD(put_dwPreferredMedia)(/*[in]*/ DWORD newVal);
    STDMETHOD(UnpopulateTerminalsDialog)(DWORD dwAddressType, HWND *phWnd);
    STDMETHOD(UnpopulateAddressDialog)(DWORD dwPreferred, HWND hWndPOTS, HWND hWndIP, HWND hWndConf);
    STDMETHOD(PopulateTerminalsDialog)(DWORD dwAddressType, HWND *phWnd);
    STDMETHOD(PopulateAddressDialog)(DWORD *pdwPreferred, HWND hWndPots, HWND hWndIP, HWND hWndConf);
    STDMETHOD(get_dwCallCaps)(long lCallID, /*[out, retval]*/ DWORD *pVal);
    STDMETHOD(JoinConference)(long *pnRet, BOOL bShowDialog, long *pConfDetails );
    STDMETHOD(ShowMediaPreview)(long lCallID, HWND hWndParent, BOOL bVisible);
    STDMETHOD(ShowOptions)();
    STDMETHOD(get_hWndParent)(/*[out, retval]*/ HWND *pVal);
    STDMETHOD(put_hWndParent)(/*[in]*/ HWND newVal);
    STDMETHOD(get_ConfRoom)(/*[out, retval]*/ IConfRoom **ppVal);
    STDMETHOD(ShowMedia)(long lCallID, HWND hWndParent, BOOL bVisible);
    STDMETHOD(ActionSelected)(long lCallID, CallManagerActions cma);
    STDMETHOD(get_ConfExplorer)(/*[out, retval]*/ IConfExplorer **ppVal);
    STDMETHOD(CreateCall)(AVCreateCall *pInfo);
    STDMETHOD(Term)();
    STDMETHOD(Init)(BSTR *pbstrOperation, BSTR *pbstrDetails, long *phr);
// IAVTapiNotification event firing
    STDMETHOD(fire_CloseCallControl)(long lCallID);
    STDMETHOD(fire_SetCallState)(long lCallID, ITCallStateEvent *pEvent, IAVTapiCall *pAVCall);
    STDMETHOD(fire_AddCurrentAction)(long lCallID, CallManagerActions cma, BSTR bstrText);
    STDMETHOD(fire_ClearCurrentActions)(long lCallID);
    STDMETHOD(fire_SetCallerID)(long lCallID, BSTR bstrCallerID);
    STDMETHOD(fire_NewCall)(ITAddress *pITAddress, DWORD dwAddressType, long lCallID, IDispatch *pDisp, AVCallType nType, IAVTapiCall **ppAVCall);
    STDMETHOD(fire_NewCallWindow)(long* plCallID, CallManagerMedia cmm, BSTR bstrAddressName, AVCallType nType);
    STDMETHOD(fire_SetCallState_CMS)(long lCallID, CallManagerStates cms, BSTR bstrText);
    STDMETHOD(fire_ErrorNotify)(long *pErrorInfo);
    STDMETHOD(fire_LogCall)(long lCallID, CallLogType nType, DATE dateStart, DATE dateEnd, BSTR bstrAddr, BSTR bstrName);
    STDMETHOD(fire_ActionSelected)(CallClientActions cca);
    STDMETHOD(fire_NotifyUserUserInfo)(long lCallID, ULONG_PTR hMem);
// IAVTapi2 methods
    STDMETHOD(USBIsPresent)(
        /*[out]*/   BOOL* pVal
        );

    STDMETHOD(USBNewPhone)(
        /*[in]*/    ITPhone* pPhone
        );

    STDMETHOD(USBRemovePhone)(
        /*[in]*/    ITPhone* pPhone
        );

    STDMETHOD(USBTakeCallEnabled)( 
        /*[out]*/ BOOL* pEnabled
        );

    STDMETHOD(USBGetDefaultUse)(
        /*[out]*/   BOOL* pVal
        );

    STDMETHOD(DoneRegistration)();

    STDMETHOD(USBSetHandling)(
        /*[in]*/    BOOL    bUSeUSB
        );

    STDMETHOD(USBGetTerminalName)(
        /*[in]*/    AVTerminalDirection Direction,
        /*[out]*/   BSTR*               pbstrName
        );

    STDMETHOD(USBSetVolume)(
        /*[in]*/    AVTerminalDirection Direction,
        /*[in]*/    long                nVolume
        );

    STDMETHOD(USBGetVolume)(
        /*[in]*/    AVTerminalDirection Direction,
        /*[in]*/    long*               pVolume
        );


    };

#endif //__AVTAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\avtapi.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// AVTapi.cpp : Implementation of CAVTapi
#include "stdafx.h"
#include "TapiDialer.h"
#include "AVTapi.h"
#include "AVTapiCall.h"

#include "ConfExp.h"
#include "ConfRoom.h"
#include "ConfDetails.h"

#include "ThreadAns.h"
#include "ThreadDial.h"
#include "ThreadDS.h"
 
#include "DlgCall.h"
#include "DlgJoin.h"
#ifdef _BAKEOFF
#include "DlgAddr.h"
#endif

#define VECT_CLS CAVTapi
#define VECT_IID IID_IAVTapiNotification
#define VECT_IPTR IAVTapiNotification

#define CLOSE_CONF(_P_, _CRIT_)    \
_CRIT_.Lock();                    \
if ( _P_ )                        \
{                                \
    _P_->Release();                \
    _P_ = NULL;                    \
}                                \
_CRIT_.Unlock();

#define BAIL_ON_DATACALL                                    \
{                                                            \
    AVCallType nType = AV_VOICE_CALL;                        \
    IAVTapiCall *pAVCall = FindAVTapiCall( lCallID );        \
    if ( pAVCall )                                            \
    {                                                        \
        pAVCall->get_nCallType(&nType);                        \
        pAVCall->Release();                                    \
    }                                                        \
    if ( nType == AV_DATA_CALL ) return S_OK;                \
}

#define BAIL_ON_CONFCALL                                    \
{                                                            \
    AVCallType nType = AV_VOICE_CALL;                        \
    DWORD dwAddressType = dwAddressType = 0;                \
    IAVTapiCall *pAVCall = FindAVTapiCall( lCallID );        \
    if ( pAVCall )                                            \
    {                                                        \
        pAVCall->get_nCallType(&nType);                        \
        pAVCall->get_dwAddressType(&dwAddressType);            \
        pAVCall->Release();                                    \
    }                                                        \
    if ( (nType != AV_DATA_CALL) && (dwAddressType == LINEADDRESSTYPE_SDP) ) return S_OK;    \
}

#define BAIL_ON_DATA_OR_CONFCALL                            \
{                                                            \
    AVCallType nType = AV_VOICE_CALL;                        \
    DWORD dwAddressType = dwAddressType = 0;                \
    IAVTapiCall *pAVCall = FindAVTapiCall( lCallID );        \
    if ( pAVCall )                                            \
    {                                                        \
        pAVCall->get_nCallType(&nType);                        \
        pAVCall->get_dwAddressType(&dwAddressType);            \
        pAVCall->Release();                                    \
    }                                                        \
    if ( (nType == AV_DATA_CALL) || (dwAddressType == LINEADDRESSTYPE_SDP) ) return S_OK;    \
}


int CAVTapi::arAddressTypes[] = {    LINEADDRESSTYPE_SDP,
                                    LINEADDRESSTYPE_EMAILNAME,
                                    LINEADDRESSTYPE_IPADDRESS,
                                    LINEADDRESSTYPE_DOMAINNAME,
                                    LINEADDRESSTYPE_PHONENUMBER };

#define NUM_CB_TERMINALS    3
#define AUDIO_CAPTURE        0
#define AUDIO_RENDER        1
#define VIDEO_CAPTURE        2
#define VIDEO_RENDER        3

#define MAX_CALLWINDOWS        4

#define _USE_DEFAULTSERVER

#define USB_NULLVOLUME      (-1)


UINT AddressTypeToRegKey( DWORD dwAddressType, bool bPermanent )
{
    if ( (dwAddressType & LINEADDRESSTYPE_SDP) != 0 )
        return (bPermanent) ? IDN_REG_REDIAL_ADDRESS_CONF : IDN_REG_REDIAL_ADDRESS_CONF_ADDR;
    else if ( (dwAddressType & LINEADDRESSTYPE_PHONENUMBER) != 0 )
        return (bPermanent) ? IDN_REG_REDIAL_ADDRESS_POTS : IDN_REG_REDIAL_ADDRESS_POTS_ADDR;

    return (bPermanent) ? IDN_REG_REDIAL_ADDRESS_INTERNET : IDN_REG_REDIAL_ADDRESS_INTERNET_ADDR;
}

DialerMediaType AddressToMediaType( long dwAddressType )
{
    if ( (dwAddressType & LINEADDRESSTYPE_SDP) != 0 )
        return DIALER_MEDIATYPE_CONFERENCE;
    if ( (dwAddressType & LINEADDRESSTYPE_PHONENUMBER) != 0 )
        return DIALER_MEDIATYPE_POTS;

    return DIALER_MEDIATYPE_INTERNET;
}

/////////////////////////////////////////////////////////////////////////////
// CAVTapi

CAVTapi::CAVTapi()
{
    m_pITTapi = NULL;

    m_pIConfExplorer = NULL;
    m_pIConfRoom = NULL;
    m_pITapiNotification = NULL;

    m_lShowCallDialog = 0;
    m_lRefreshDS = 0;

    m_bstrDefaultServer = NULL;
    m_bAutoCloseCalls = false;

    m_pUSBPhone = NULL;
    m_pDlgCall = NULL;
    m_bUSBOpened = FALSE;
    m_bstrUSBCaptureTerm = NULL;
    m_bstrUSBRenderTerm = NULL;

    m_hEventDialerReg = NULL;

    // Audio echo cancellation
    m_bAEC = FALSE;

    m_nUSBInVolume  = USB_NULLVOLUME;
    m_nUSBOutVolume = USB_NULLVOLUME;
}

void CAVTapi::FinalRelease()
{
    ATLTRACE(_T(".enter.CAVTapi::FinalRelease().\n"));
    SysFreeString( m_bstrDefaultServer );

    ATLTRACE(_T(".exit.CAVTapi::FinalRelease().\n"));
}

STDMETHODIMP CAVTapi::Init(BSTR *pbstrOperation, BSTR *pbstrDetails, long *phr)
{
    _ASSERT( pbstrOperation && pbstrDetails && phr );
    ATLTRACE(_T(".enter.CAVTapi::Init().\n"));

    HCURSOR hCurOld = SetCursor( LoadCursor(NULL, IDC_APPSTARTING) );

    //
    // Open the event object to detect when the
    // Dialer was registered as client for the events
    //

    m_hEventDialerReg = CreateEvent( NULL,
        TRUE,
        FALSE,
        NULL
        );

    // Create the conference room object
    m_critConfRoom.Lock();
    if ( !m_pIConfRoom )
    {
        // No conference explorer object, create a new one
        m_pIConfRoom = new CComObject<CConfRoom>;
        if ( m_pIConfRoom )
            m_pIConfRoom->AddRef();
    }
    m_critConfRoom.Unlock();


    // Load registry settings
    LoadRegistry();

    CErrorInfo er;
    er.set_Operation( IDS_ER_INIT_TAPI );

    // Startup threads
    er.set_Details( IDS_ER_CREATE_THREAD );
    if ( !_Module.StartupThreads() )
    {
        SetCursor( hCurOld );
        return er.set_hr(E_UNEXPECTED);
    }

    HRESULT hr = S_OK;

    // Create and initialize TAPI if not already done
    if ( !m_pITTapi )
    {
        er.set_Details( IDS_ER_CREATE_TAPI_OBJECT );
        hr = er.set_hr(CoCreateInstance( CLSID_TAPI,
                                         NULL,
                                         CLSCTX_INPROC_SERVER,
                                         IID_ITTAPI,
                                         (void **) &m_pITTapi ));
        
        if ( SUCCEEDED(hr) )
        {
            er.set_Details( IDS_ER_INITIALIZE_TAPI );
            if ( SUCCEEDED(hr = er.set_hr(m_pITTapi->Initialize())) )
            {
                // Register ourselves with the _Module object
                _Module.SetAVTapi( this );

                // Set the Event filter to only give us only the events we're interested in
                m_pITTapi->put_EventFilter(TE_CALLNOTIFICATION | \
                                           TE_CALLSTATE        | \
                                           TE_CALLMEDIA        | \
                                           TE_CALLINFOCHANGE   | \
                                           TE_REQUEST          | \
                                           TE_PRIVATE          | \
                                           TE_ADDRESS          | \
                                           TE_PHONEEVENT       | \
                                           TE_TAPIOBJECT);

                // Listen for incoming calls
                er.set_Details( IDS_ER_CREATE_TAPI_NOTIFICATION_OBJECT );

                // $CRIT - enter
                ITapiNotification *pNotify = new CComObject<CTapiNotification>;
                if ( pNotify )
                {
                    Lock();
                    m_pITapiNotification = pNotify;
                    m_pITapiNotification->AddRef();
                    Unlock();

                    hr = pNotify->Init( m_pITTapi, (long *) &er );

                    // Register for assisted telephony
                    m_pITTapi->RegisterRequestRecipient( 0, LINEREQUESTMODE_MAKECALL, TRUE);

                    // Publish user in ILS servers
                    RegisterUser( true, NULL );
                }
                else
                {
                    // Couldn't create object
                    hr = er.set_hr( E_OUTOFMEMORY );
                }

                //
                // Detect USB Phone
                //

                USBFindPhone( &m_pUSBPhone );

                //
                // Detect the audio echo cancellation setting
                //

                m_bAEC = AECGetRegistryValue();
            }

            // Failure!            
            if ( FAILED(hr) )
            {
                ATLTRACE(_T(".error.CAVTapi::Init() -- failed to initialize TAPI(0x%08lx).\n"), hr );
                _Module.SetAVTapi( NULL );
                RELEASE( m_pITTapi );
            }
        }
    }

    if ( FAILED(hr) )
    {
        _Module.ShutdownThreads();

        // Extract error code information
        er.Commit();
        *pbstrOperation = SysAllocString( er.m_bstrOperation );
        *pbstrDetails = SysAllocString( er.m_bstrDetails );
        *phr = er.m_hr;
        // Don't want to call the ErrorNotify callback
        er.set_hr( S_OK );
    }

    RefreshDS();

    ATLTRACE(_T(".exit.CAVTapi::Init(0x%08lx).\n"), hr);
    SetCursor( hCurOld );
    return hr;
}

STDMETHODIMP CAVTapi::Term()
{
    ATLTRACE(_T(".enter.CAVTapi::Term().\n"));

    HCURSOR hCurOld = SetCursor( LoadCursor(NULL, IDC_APPSTARTING) );
    HRESULT hr = S_OK;

    SaveRegistry();

    //
    // Dialer registration event
    //
    if( m_hEventDialerReg)
    {
        CloseHandle( m_hEventDialerReg );
    }


   //Unregister the user
   //FIXUP: The shutdown threads just waits for 5 seconds for thread to finish and then just exits.
   //This will cause the app to hang.  We really should KillThread the threads that are not
   //returning.
   //RegisterUser( false, NULL );

    // Hide conference windows
    CLOSE_CONF(m_pIConfExplorer, m_critConfExplorer );
    CLOSE_CONF(m_pIConfRoom, m_critConfRoom );


    RELEASE_CRITLIST(m_lstAVTapiCalls, m_critLstAVTapiCalls);

    Lock();
    if ( m_pITapiNotification )    m_pITapiNotification->Shutdown();
    RELEASE( m_pITapiNotification );
    Unlock();

    //
    // Release ITPhone, if exist one
    //
    m_critUSBPhone.Lock();
    if( m_pUSBPhone )
    {
        m_pUSBPhone->Release();
        m_pUSBPhone = NULL;
    }

    if( m_bstrUSBCaptureTerm )
    {
        SysFreeString( m_bstrUSBCaptureTerm );
        m_bstrUSBCaptureTerm = NULL;
    }

    if( m_bstrUSBRenderTerm )
    {
        SysFreeString( m_bstrUSBRenderTerm );
        m_bstrUSBRenderTerm = NULL;
    }

    m_critUSBPhone.Unlock();

    // Shutdown threads
    _Module.ShutdownThreads();

    if ( m_pITTapi )
    {
        ATLTRACE(_T(".1.CAVTapi::Term() -- shutting down Telephony Services.\n"));
        m_pITTapi->RegisterRequestRecipient( 0, LINEREQUESTMODE_MAKECALL, FALSE );
        hr = m_pITTapi->Shutdown();
        RELEASE( m_pITTapi );
    }

    // Unregister ourselves with the _Module object
    _Module.SetAVTapi( NULL );

    ATLTRACE(_T(".exit.CAVTapi::Term(0x%08lx).\n"), hr);
    SetCursor( hCurOld );
    return hr;
}

void CAVTapi::LoadRegistry()
{
    USES_CONVERSION;
    CRegKey regKey;
    DWORD dwTemp;
    TCHAR szText[255], szType[255], szServer[MAX_PATH + 100];

    // Cached ILS server
    LoadString( _Module.GetResourceInstance(), IDN_REG_DIALER_KEY, szText, ARRAYSIZE(szText) );
    LoadString( _Module.GetResourceInstance(), IDN_REG_CONFSERV_DEFAULTSERVER, szType, ARRAYSIZE(szType) );
    if ( regKey.Open(HKEY_CURRENT_USER, szText, KEY_READ) == ERROR_SUCCESS )
    {
        dwTemp = ARRAYSIZE(szServer);
        regKey.QueryValue( szServer, szType, &dwTemp );
        regKey.Close();
        BSTR bstrTemp = NULL;
        bstrTemp = SysAllocString( T2COLE(szServer) );
        put_bstrDefaultServer( bstrTemp );
        SysFreeString( bstrTemp );
    }

    // Automatically close call widows
    LoadString( _Module.GetResourceInstance(), IDN_REG_AUTOCLOSECALLS, szType, ARRAYSIZE(szType) );
    if ( regKey.Open(HKEY_CURRENT_USER, szText, KEY_READ) == ERROR_SUCCESS )
    {
        dwTemp = m_bAutoCloseCalls;
        regKey.QueryValue( dwTemp, szType );
        regKey.Close();
        put_bAutoCloseCalls( (VARIANT_BOOL) (dwTemp != 0) );
    }

    // # of conference room windows    
    LoadString( _Module.GetResourceInstance(), IDN_REG_REDIAL_KEY, szText, ARRAYSIZE(szText) );
    LoadString( _Module.GetResourceInstance(), AddressTypeToRegKey(LINEADDRESSTYPE_SDP, true), szType, ARRAYSIZE(szType) );
    _tcscat( szText, _T("\\") );
    _tcscat( szText, szType );
    regKey.Open( HKEY_CURRENT_USER, szText, KEY_READ );

    LoadString( _Module.GetResourceInstance(), IDN_REG_REDIAL_TERMINAL_MAX_VIDEO, szText, ARRAYSIZE(szText) );
    IConfRoom *pConfRoom;
    if ( SUCCEEDED(get_ConfRoom(&pConfRoom)) )
    {
        short nMax;
        pConfRoom->get_nMaxTerms( &nMax );

        dwTemp = nMax;
        regKey.QueryValue( dwTemp, szText );
        nMax = (short) min( MAX_VIDEO, max(1, dwTemp) );

        pConfRoom->put_nMaxTerms( nMax );
        pConfRoom->Release();
    }
}

void CAVTapi::SaveRegistry()
{
    USES_CONVERSION;
    CRegKey regKey;
    TCHAR szKey[255], szType[255];
    
    BSTR bstrServer = NULL;
    get_bstrDefaultServer( &bstrServer );

    // Cached ILS server
    LoadString( _Module.GetResourceInstance(), IDN_REG_DIALER_KEY, szKey, ARRAYSIZE(szKey) );
    LoadString( _Module.GetResourceInstance(), IDN_REG_CONFSERV_DEFAULTSERVER, szType, ARRAYSIZE(szType) );
    if ( regKey.Open(HKEY_CURRENT_USER, szKey, KEY_WRITE) == ERROR_SUCCESS )
    {
        if ( bstrServer )
            regKey.SetValue( OLE2CT(bstrServer), szType );
        else
            regKey.DeleteValue( szType );

        regKey.Close();
    }
    SysFreeString( bstrServer );

    // Automatically close call widows
    LoadString( _Module.GetResourceInstance(), IDN_REG_AUTOCLOSECALLS, szType, ARRAYSIZE(szType) );
    if ( regKey.Open(HKEY_CURRENT_USER, szKey, KEY_WRITE) == ERROR_SUCCESS )
    {
        VARIANT_BOOL bAutoClose;
        get_bAutoCloseCalls( &bAutoClose );
        regKey.SetValue( bAutoClose, szType );
        regKey.Close();
    }
}


STDMETHODIMP CAVTapi::get_hWndParent(HWND * pVal)
{
    *pVal = _Module.GetParentWnd();
    return S_OK;
}

STDMETHODIMP CAVTapi::put_hWndParent(HWND newVal)
{
    if ( !::IsWindow(newVal) ) return E_INVALIDARG;

    _Module.SetParentWnd(newVal );
    return S_OK;
}

STDMETHODIMP CAVTapi::CreateCall(AVCreateCall *pInfo)
{
    USES_CONVERSION;
    ATLTRACE(_T(".enter.CAVTapi::CreateCall().\n"));
    _ASSERT( pInfo );

    // Make sure we only show once
    if ( pInfo->bShowDialog && !AtomicSeizeToken(m_lShowCallDialog) ) return S_OK;

    HRESULT hr = S_OK;
    int nRet;
    CComBSTR l_bstrDisplayableAddress( pInfo->lpszDisplayableAddress );

    if ( pInfo->bShowDialog )
    {

        // Create dialog and initialize data memebers
        CDlgPlaceCall dlg;
        SysReAllocString( &dlg.m_bstrAddress, pInfo->bstrAddress );
        dlg.m_dwAddressType = pInfo->lAddressType;

        //
        // Store the pointer to the dialog for USBEvents
        //
        m_pDlgCall = &dlg;

        nRet = dlg.DoModal( _Module.GetParentWnd() );

        //
        // Release the pojnter to the dialog
        //
        m_pDlgCall = NULL;

        AtomicReleaseToken( m_lShowCallDialog );
        pInfo->lRet = (long) nRet;
        ATLTRACE(_T(".1.CAVTapi::CreateCall() - dialog returned %ld.\n"), nRet );

        // Retrieve dialog information
        SysReAllocString( &pInfo->bstrName, dlg.m_bstrName );
        SysReAllocString( &pInfo->bstrAddress, dlg.m_bstrAddress );
        pInfo->lAddressType = dlg.m_dwAddressType;
        pInfo->bAddToSpeeddial = dlg.m_bAddToSpeeddial;

        if ( nRet != IDOK )
            return hr;
    }
    else if ( (pInfo->lAddressType & LINEADDRESSTYPE_SDP) != NULL )
    {
        // Make sure there isn't a conference already in session
        CErrorInfo er( IDS_ER_CALL_ENTERCONFROOM, IDS_ER_CONFERENCE_ROOM_LIMIT_EXCEEDED );
        IConfRoom *pConfRoom;
        if ( SUCCEEDED(get_ConfRoom(&pConfRoom)) )
        {
            if ( pConfRoom->IsConfRoomInUse() == S_OK )
                er.set_hr( E_ABORT );

            pConfRoom->Release();
        }

        if ( FAILED(er.m_hr) )
            return er.m_hr;
    }

    ///////////////////////////////////////////////////////////////////////////////////////
    // If the user specifies a conference, we try to match it using the information entered
    // If the match is solid (one hit) we automatically call, otherwise we throw up a dialog
    // showing all the conferences that appear to match.
    //
    if ( !pInfo->lpszDisplayableAddress && ((pInfo->lAddressType & LINEADDRESSTYPE_SDP) != NULL) )
    {
        bool bReturn = true;
        IConfExplorer *pConfExplorer;
        if ( SUCCEEDED(hr = get_ConfExplorer(&pConfExplorer)) )
        {
            CONFDETAILSLIST    lstConfs;

            // Enumerate all the conferences that match the criteria entered
            IConfExplorerTreeView *pTreeView;
            if ( SUCCEEDED(pConfExplorer->get_TreeView(&pTreeView)) )
            {
                // first time through request only scheduled conferences
                pTreeView->BuildJoinConfListText( (long *) &lstConfs, pInfo->bstrAddress );
                pTreeView->Release();
            }

            // Do we have a definitive match?
            if ( lstConfs.size() == 0 )
            {
                _Module.DoMessageBox(IDS_MSG_NO_CONFS_MATCHED, MB_ICONINFORMATION, false );
            }
            else if ( (lstConfs.size() == 1) && lstConfs.front()->m_bstrAddress && (SysStringLen(lstConfs.front()->m_bstrAddress) > 0) )
            {
                // Setup to join this specific conference
                if ( pInfo->bstrName )
                {
                    SysFreeString( pInfo->bstrName );
                    pInfo->bstrName = NULL;
                }

                SysReAllocString( &pInfo->bstrAddress, lstConfs.front()->m_bstrAddress );
                SysReAllocString( &l_bstrDisplayableAddress, lstConfs.front()->m_bstrName );
                bReturn = false;
            }
            else
            {
                // Multiple hits, resolve via conference dialog
                CDlgJoinConference dlgJoin;
                SysReAllocString( &dlgJoin.m_bstrSearchText, pInfo->bstrAddress );

                if ( ((nRet = dlgJoin.DoModal(_Module.GetParentWnd())) == IDOK) && dlgJoin.m_confDetails.m_bstrAddress && (SysStringLen(dlgJoin.m_confDetails.m_bstrAddress) > 0) )
                    hr = pConfExplorer->Join( (long *) &dlgJoin.m_confDetails );

                // Store dialog return value
                pInfo->lRet = (long) nRet;
            }

            // Clean up
            DELETE_LIST( lstConfs );
            pConfExplorer->Release();
        }

        if ( bReturn )    return hr;
    }

    CErrorInfo er;
    er.set_Operation( IDS_ER_PLACECALL );
    er.set_Details( IDS_ER_GET_ADDRESS );

    ITAddress *pITAddress;
    if ( SUCCEEDED(hr = er.set_hr(GetAddress(pInfo->lAddressType, true, &pITAddress))) )
    {
        // Setup dialing info to pass to dialing thread
        er.set_Details( IDS_ER_CREATE_THREAD );
        CThreadDialingInfo *pThreadInfo = new CThreadDialingInfo;
        if ( pThreadInfo )
        {
            HRESULT hrDialog = S_OK;

            // Resolve the address
            if ( (pInfo->lAddressType & LINEADDRESSTYPE_SDP) == NULL )
            {
                CComPtr<IAVGeneralNotification> pAVGen;
                if ( SUCCEEDED(_Module.get_AVGenNot(&pAVGen)) )
                {
                    BSTR bstrResolvedName = NULL;
                    BSTR bstrResolvedAddress = NULL;

                    // Resolve
                    hrDialog = pAVGen->fire_ResolveAddressEx( pInfo->bstrAddress,
                                                   _Module.GuessAddressType( OLE2CT(pInfo->bstrAddress) ),
                                                   AddressToMediaType(pInfo->lAddressType),
                                                   DIALER_LOCATIONTYPE_UNKNOWN,
                                                   &bstrResolvedName,
                                                   &bstrResolvedAddress,
                                                   &pThreadInfo->m_bstrUser1,
                                                   &pThreadInfo->m_bstrUser2 );

                    if ( SUCCEEDED(hrDialog) )
                        pThreadInfo->m_bResolved = true;
                }
            }

            if ( hrDialog != S_FALSE )
            {
                // Store information in dialing structure
                pThreadInfo->set_ITAddress( pITAddress );
                if ( pInfo->bstrName ) pThreadInfo->m_bstrName = SysAllocString( pInfo->bstrName );
                pThreadInfo->m_bstrAddress = SysAllocString( pInfo->bstrAddress );
                pThreadInfo->m_bstrOriginalAddress = SysAllocString( (l_bstrDisplayableAddress == NULL) ? pInfo->bstrAddress : l_bstrDisplayableAddress );
                pThreadInfo->m_dwAddressType = pInfo->lAddressType;
                pThreadInfo->TranslateAddress();

                // Want to return the displayable address, rather than the dialable address
                SysReAllocString( &pInfo->bstrAddress, pThreadInfo->m_bstrOriginalAddress );

                // Dialing takes place on separate thread
                DWORD dwID;
                HANDLE hThread = CreateThread( NULL, 0, ThreadDialingProc, (void *) pThreadInfo, NULL, &dwID );
                if ( !hThread )
                {
                    hr = er.set_hr( E_UNEXPECTED );
                    ATLTRACE(_T(".error.CAVTapi::CreateCall() -- failed to creat the dialing thread.\n") );
                    delete pThreadInfo;
                }
                else
                {
                    CloseHandle( hThread );
                }
            }
        }
        else
        {
            hr = er.set_hr( E_OUTOFMEMORY );
        }

        pITAddress->Release();
    }

    return hr;
}

STDMETHODIMP CAVTapi::JoinConference(long *pnRet, BOOL bShowDialog, long *pConfDetails )
{
    CDlgJoinConference dlg;
    HRESULT hr = S_OK;
    int nRet = IDOK;

    // Gather information from user
    if ( bShowDialog )
    {
        nRet = dlg.DoModal( _Module.GetParentWnd() );
        if ( pnRet ) *pnRet = nRet;
    }
    else
    {
        _ASSERT( pConfDetails );        // if you're not showing the dialog, you better have something to dial
        dlg.m_confDetails = *((CConfDetails *) pConfDetails);
    }
    
    // Join selected conference
    // Join the conference if we have a valid conference name
    if ( (nRet == IDOK) && dlg.m_confDetails.m_bstrAddress && (SysStringLen(dlg.m_confDetails.m_bstrAddress) > 0) )
    {
        m_critConfExplorer.Lock();
        if ( m_pIConfExplorer )
            hr = m_pIConfExplorer->Join( (long *) &dlg.m_confDetails );
        m_critConfExplorer.Unlock();
    }

    return hr;
}


HRESULT CAVTapi::GetAddress( DWORD dwAddressType, bool bErrorMsg, ITAddress **ppITAddress )
{
    HRESULT hr = S_OK;
    DWORD dwPermID = 0;
    DWORD dwAddrID = 0;

    // Retrieve address information stored in the registry
    TCHAR szText[255];
    CRegKey regKey;
    LoadString( _Module.GetResourceInstance(), IDN_REG_REDIAL_KEY, szText, ARRAYSIZE(szText) );
    if ( regKey.Open(HKEY_CURRENT_USER, szText, KEY_READ) == ERROR_SUCCESS )
    {
        LoadString( _Module.GetResourceInstance(), AddressTypeToRegKey(dwAddressType, true), szText, ARRAYSIZE(szText) );
        regKey.QueryValue( dwPermID, szText );

        LoadString( _Module.GetResourceInstance(), AddressTypeToRegKey(dwAddressType, false), szText, ARRAYSIZE(szText) );
        regKey.QueryValue( dwAddrID, szText );


        // Has the user specified a particular address?        
        if ( dwPermID )
        {
            // Open the specified address
            if ( FAILED(hr = GetDefaultAddress(dwAddressType, dwPermID, dwAddrID, ppITAddress)) )
            {
                // Notify user that we could not retrieve the specified address
                if ( !bErrorMsg || _Module.DoMessageBox(IDS_MSG_PLACECALL_GETADDRESS, MB_YESNO | MB_ICONQUESTION, false) == IDYES )
                    dwPermID = 0;
            }
        }
    }

    if ( !dwPermID ) hr = GetDefaultAddress( dwAddressType, 0, 0, ppITAddress );
    return hr;
}

HRESULT CAVTapi::GetDefaultAddress( DWORD dwAddressType, DWORD dwPermID, DWORD dwAddrID, ITAddress **ppITAddress )
{
    // Is TAPI running?
    _ASSERT(m_pITTapi);
    if ( !m_pITTapi ) return E_PENDING;

    // Loop through addresses, looking for one that supports interactive voice
    HRESULT hr;
    IEnumAddress *pEnumAddresses;
    if ( FAILED(hr = m_pITTapi->EnumerateAddresses(&pEnumAddresses)) ) return hr;
    bool bFoundAddress = false;

    while ( !bFoundAddress )
    {
        if ( (hr = pEnumAddresses->Next(1, ppITAddress, NULL)) != S_OK ) break;

        // Address must support audio in and out
        ITMediaSupport *pITMediaSupport;
        if ( SUCCEEDED(hr = (*ppITAddress)->QueryInterface(IID_ITMediaSupport, (void **) &pITMediaSupport)) )
        {
            VARIANT_BOOL bSupport;
            if ( SUCCEEDED(pITMediaSupport->QueryMediaType(TAPIMEDIATYPE_AUDIO, &bSupport)) && bSupport )
            {
                // Look for an address that supports the requested address type
                ITAddressCapabilities *pCaps;
                if ( SUCCEEDED((*ppITAddress)->QueryInterface(IID_ITAddressCapabilities, (void **) &pCaps)) )
                {
                    long lAddrTypes = 0;
                    pCaps->get_AddressCapability( AC_ADDRESSTYPES, &lAddrTypes );

                    // Is this the address type we're looking for?
                    if ( (lAddrTypes & dwAddressType) != 0 )
                        bFoundAddress = TRUE;

                    pCaps->Release();
                }
            }
            pITMediaSupport->Release();
        }

        // Is a particular address specified?
        if ( dwPermID )
        {
            long lPermID = 0, lAddrID = 0;
            // We need this to identify an address

            ITAddressCapabilities *pCaps;
            if ( SUCCEEDED((*ppITAddress)->QueryInterface(IID_ITAddressCapabilities, (void **) &pCaps)) )
            {
                pCaps->get_AddressCapability( AC_PERMANENTDEVICEID, &lPermID );
                pCaps->get_AddressCapability( AC_ADDRESSID, &lAddrID );
                pCaps->Release();
            }

            if ( ((DWORD) lPermID != dwPermID) || ((DWORD) lAddrID != dwAddrID) )    bFoundAddress = false;
        }

        // If we didn't find an address, move on to the next one
        if ( !bFoundAddress )
            RELEASE(*ppITAddress);
    }
    pEnumAddresses->Release();

    if ( SUCCEEDED(hr) && !bFoundAddress ) hr = E_ABORT;
    return hr;
}

HRESULT CAVTapi::CreateTerminalArray( ITAddress *pITAddress, IAVTapiCall *pAVCall, ITCallInfo *pITCallInfo )
{
    int i;
    HRESULT hr;

    // Has the user specified particular terminals for the address?
    USES_CONVERSION;
    BSTR bstrTerm[3] = { NULL, NULL, NULL };
    DWORD dwAddressType;
    pAVCall->get_dwAddressType( &dwAddressType );

    if ( IsPreferredAddress(pITAddress, dwAddressType) )
    {
        // Build the registry key where the terminal information is stored
        TCHAR szText[255], szKey[255];
        CRegKey regKey;
        LoadString( _Module.GetResourceInstance(), IDN_REG_REDIAL_KEY, szText, ARRAYSIZE(szText) );
        LoadString( _Module.GetResourceInstance(), AddressTypeToRegKey(dwAddressType, true), szKey, ARRAYSIZE(szKey) );
        _tcscat( szText, _T("\\") );
        _tcscat( szText, szKey );

        // Try to open the key
        if ( (regKey.Open(HKEY_CURRENT_USER, szText, KEY_READ) == ERROR_SUCCESS) ||
            (dwAddressType == LINEADDRESSTYPE_SDP))
        {
            UINT nIDS_Key[] = { IDN_REG_REDIAL_TERMINAL_AUDIO_CAPTURE, IDN_REG_REDIAL_TERMINAL_AUDIO_RENDER, IDN_REG_REDIAL_TERMINAL_VIDEO_CAPTURE };
            for ( i = 0; i < ARRAYSIZE(nIDS_Key); i++ )
            {
                // Retrieve terminal specified for a particular device
                DWORD dwCount = ARRAYSIZE(szKey);

                //
                // Don't select terminals on audio streams
                // if Phone was already selected
                //
                HRESULT hrReserved = E_FAIL;
                hrReserved = USBReserveStreamForPhone(
                    nIDS_Key[i], 
                    &bstrTerm[i]
                    );

               if( FAILED(hrReserved) )
                {
                    // The Phone wasn't selected on this stream
                    // we'll use the old mechanism to get from registry
                    // the terminal for this stream
                    LoadString( _Module.GetResourceInstance(), nIDS_Key[i], szText, ARRAYSIZE(szText) );
                    if ( (regKey.QueryValue(szKey, szText, &dwCount) == ERROR_SUCCESS) && (dwCount > 0) )
                        bstrTerm[i] = SysAllocString( T2COLE(szKey) );
                }
            }
        }
    }

    // Did we get a good set of terminals?
    hr = CreateTerminals( pITAddress, dwAddressType, pAVCall, pITCallInfo, bstrTerm );

    // Clean up
    for ( i = 0; i < ARRAYSIZE(bstrTerm); i++ )
        SysFreeString( bstrTerm[i] );

    return hr;
}


HRESULT CAVTapi::CreateTerminals( ITAddress *pITAddress, DWORD dwAddressType, IAVTapiCall *pAVCall, ITCallInfo *pITCallInfo, BSTR *pbstrTerm )
{
#define    LOOP_AUDIOIN    0
#define LOOP_AUDIOOUT    1
#define LOOP_VIDEOIN    2

     // Must have a valid address object
    _ASSERT( pITAddress );

    ATLTRACE(_T(".enter.CAVTapi::CreateTerminals().\n"));

    USES_CONVERSION;
    HRESULT hr;
    bool bAllocPreview = false;

    ITStreamControl *pStreamControl;
    hr = pITCallInfo->QueryInterface( IID_ITStreamControl, (void **) &pStreamControl );
    if ( FAILED(hr) )
        return (hr == E_NOINTERFACE) ? S_OK : hr;

    int nInd = 0;
    TCHAR szTemp[100];
    LoadString( _Module.GetResourceInstance(), IDS_NONE_DEVICE, szTemp, ARRAYSIZE(szTemp) );
    BSTR bstrNone = SysAllocString( T2COLE(szTemp) );
    if ( !bstrNone ) return E_OUTOFMEMORY;

    // What media types does the address support
    long lSupportedMediaModes = 0;
    ITMediaSupport *pITMediaSupport;
    if ( SUCCEEDED(pITAddress->QueryInterface(IID_ITMediaSupport, (void **) &pITMediaSupport)) )
    {
        pITMediaSupport->get_MediaTypes( &lSupportedMediaModes );
        pITMediaSupport->Release();
    }

    ITTerminalSupport *pITTerminalSupport;
    if ( SUCCEEDED(hr = pITAddress->QueryInterface(IID_ITTerminalSupport, (void **) &pITTerminalSupport)) )
    {
        for ( int i = 0; i < 3; i++ )
        {
            CErrorInfo er;
            er.set_Operation( IDS_ER_CREATE_TERMINALS );

            // Which terminal are we doing?
            long lMediaMode;
            TERMINAL_DIRECTION nDir;
            UINT nIDSDetails;
            
            switch ( i )
            {
                case LOOP_AUDIOIN:
                    nIDSDetails = IDS_ER_CREATE_AUDIO_CAPTURE;
                    lMediaMode = TAPIMEDIATYPE_AUDIO;
                    nDir = TD_CAPTURE;
                    break;

                case LOOP_AUDIOOUT:
                    nIDSDetails = IDS_ER_CREATE_AUDIO_RENDER;
                    lMediaMode = TAPIMEDIATYPE_AUDIO;
                    nDir = TD_RENDER;
                    break;

                case LOOP_VIDEOIN:
                    nIDSDetails = IDS_ER_CREATE_VIDEO_CAPTURE;
                    lMediaMode = TAPIMEDIATYPE_VIDEO;
                    nDir = TD_CAPTURE;
                    break;
            }

            // Skip if they don't support the media mode                
            if ( (lMediaMode & lSupportedMediaModes) == 0 )
                continue;

            // Check and make sure that terminals exist for this driver:
            bool bSkipTerminal = true;
            IEnumTerminal *pEnumTerminal;
            if ( pITTerminalSupport->EnumerateStaticTerminals(&pEnumTerminal) == S_OK )    
            {
                // What type of terminal do we have?  (audio in, audio out, video in, etc.)
                ITTerminal *pITTerminal;
                while ( bSkipTerminal && (pEnumTerminal->Next(1, &pITTerminal, NULL) == S_OK) )
                {
                    TERMINAL_DIRECTION nTD;
                    long nTerminalType;

                    // Render or Capture?    
                    if ( SUCCEEDED(pITTerminal->get_Direction(&nTD)) && SUCCEEDED(pITTerminal->get_MediaType(&nTerminalType)) )
                    {
                        if ( (nTerminalType == lMediaMode) && (nTD == nDir)  )
                            bSkipTerminal = false;
                    }

                    // Clean up
                    pITTerminal->Release();
                }
                pEnumTerminal->Release();
            }

            if ( bSkipTerminal ) 
                continue;

            // Set Audio Echo Cancellation
            if( (lMediaMode == TAPIMEDIATYPE_AUDIO) &&
                ( nDir == TD_CAPTURE) &&
                ( m_bAEC == TRUE) )
            {
                HRESULT hrAEC = AECSetOnStream( pStreamControl, m_bAEC);
            }

            //////////////////////////////////////////////////////////////////
            // Allocate the terminal
            //

            ITTerminal *pTempTerminal = NULL;

            if ( pbstrTerm[i] )
            {
                // Ignore NONE terminals
                if ( !wcscmp(bstrNone, pbstrTerm[i]) ) 
                    continue;
                
                er.set_Details( nIDSDetails );
                hr = er.set_hr( GetTerminal(pITTerminalSupport, lMediaMode, nDir, pbstrTerm[i], &pTempTerminal) );
                ATLTRACE(_T("CAVTapi::CreateTerminals(%d) -- hr=0x%08lx creating terminal %s.\n"), nInd, hr, OLE2CT(pbstrTerm[i]) );
            }

            // If the user hasn't specified a particular terminal, use the default one
            if ( !pTempTerminal )
            {
                hr = er.set_hr( pITTerminalSupport->GetDefaultStaticTerminal(lMediaMode, nDir, &pTempTerminal) );
                ATLTRACE(_T("CAVTapi::CreateTerminals(%d) -- hr=0x%08lx create default Audio=%d, Render=%d.\n"), nInd, hr, (bool) (lMediaMode == TAPIMEDIATYPE_AUDIO), nDir );
            }

            if ( hr != S_OK ) break;        // failed to get the terminal

            // Select the terminal onto the stream
            if ( SUCCEEDED(hr = SelectTerminalOnStream(pStreamControl, lMediaMode, nDir, pTempTerminal, pAVCall)) )
            {
                if ( (lMediaMode == TAPIMEDIATYPE_VIDEO) && (nDir == TD_CAPTURE) )
                    bAllocPreview = true;

                nInd++;
            }

            pTempTerminal->Release();
        }

        // Did we get the requested terminals?
        if ( SUCCEEDED(hr) )
        {
            CErrorInfo er;
            er.set_Operation( IDS_ER_CREATE_TERMINALS );
            
            HRESULT hrTemp = S_OK;
            LPOLESTR psz = NULL;
            BSTR bstrTerminalClass = NULL;
            STRING_FROM_IID(CLSID_VideoWindowTerm, bstrTerminalClass);

            // Do we need to allocate a preview window?
            if ( bAllocPreview )
            {
                ITTerminal *pPreviewTerminal = NULL;
                if ( ((hrTemp = er.set_hr(pITTerminalSupport->CreateTerminal(bstrTerminalClass, TAPIMEDIATYPE_VIDEO, TD_RENDER, &pPreviewTerminal))) == S_OK) && pPreviewTerminal )
                {
                    SelectTerminalOnStream( pStreamControl, TAPIMEDIATYPE_VIDEO, TD_CAPTURE, pPreviewTerminal, pAVCall );
                    pPreviewTerminal->Release();
                }
            }
            
            // Try for video in (recieve video) -- this is a 'dynamic' terminal
            if ( ((lSupportedMediaModes & TAPIMEDIATYPE_VIDEO) != 0) && (CanCreateVideoWindows(dwAddressType) == S_OK) )
            {
                // For conferences we want to create more terminals.
                short nNumCreate = 1;
                if ( (dwAddressType & LINEADDRESSTYPE_SDP) != NULL )
                {
                    IConfRoom *pConfRoom;
                    if ( SUCCEEDED(get_ConfRoom(&pConfRoom)) )
                    {
                        pConfRoom->get_nMaxTerms(&nNumCreate);
                        pConfRoom->Release();
                    }
                }

                er.set_Details( IDS_ER_CREATE_VIDEO_RENDER );

                // Create the requested number of terminals
                while ( nNumCreate-- )
                {
                    ITTerminal *pVidTerminal = NULL;
                    if ( ((hrTemp = er.set_hr(pITTerminalSupport->CreateTerminal(bstrTerminalClass, TAPIMEDIATYPE_VIDEO, TD_RENDER, &pVidTerminal))) == S_OK) && pVidTerminal )
                    {
                        SelectTerminalOnStream( pStreamControl, TAPIMEDIATYPE_VIDEO, TD_RENDER, pVidTerminal, pAVCall );
                        pVidTerminal->Release();
                        nInd++;
                    }
                }

                ATLTRACE(_T("CAVTapi::CreateTerminals(%d) -- hr=0x%08lx creating Video Render.\n"), nInd, hr );
            }
            SysFreeString( bstrTerminalClass );

/*            
            // Was not able to create any terminals!
            if ( nInd == 0 )
                hr = E_ABORT;
*/
        }

        pITTerminalSupport->Release();
    }

    SysFreeString( bstrNone );
    pStreamControl->Release();

    ATLTRACE(_T(".exit.CAVTapi::CreateTerminals().\n"));
    return hr;
}

HRESULT CAVTapi::GetTerminal( ITTerminalSupport *pITTerminalSupport, long nReqType, TERMINAL_DIRECTION nReqTD, BSTR bstrReqName, ITTerminal **ppITTerminal  )
{
    IEnumTerminal *pEnumTerminal;
    HRESULT hr = pITTerminalSupport->EnumerateStaticTerminals( &pEnumTerminal );
    if ( hr != S_OK ) return hr;

    bool bFoundTerminal = false;

    // Look for a terminal with the specified characteristics
    while ( pEnumTerminal->Next(1, ppITTerminal, NULL) == S_OK )
    {
        // Is it going the right direction? Render / Capture
        TERMINAL_DIRECTION nTD;
        if ( SUCCEEDED((*ppITTerminal)->get_Direction(&nTD)) && (nTD == nReqTD) )
        {
            // Is in the right type?  Audio / Video
            long nType;
            if ( SUCCEEDED(hr = (*ppITTerminal)->get_MediaType(&nType)) && (nType == nReqType) )
            {
                // Does it have the right name?
                BSTR bstrName = NULL;
                if ( SUCCEEDED(hr = (*ppITTerminal)->get_Name(&bstrName)) && (wcscmp(bstrName, bstrReqName) == 0) )
                    bFoundTerminal = true;

                SysFreeString( bstrName );
            }
        }

        // Exit condition
        if ( bFoundTerminal ) break;

        // Reset pointer
        (*ppITTerminal)->Release();
        *ppITTerminal = NULL;
    }

    pEnumTerminal->Release();
    return hr;
}

STDMETHODIMP CAVTapi::get_ConfExplorer(IConfExplorer **ppVal)
{
    HRESULT hr = S_OK;
    m_critConfExplorer.Lock();

    if ( !m_pIConfExplorer )
    {
        // No conference explorer object, create a new one
        m_pIConfExplorer = new CComObject<CConfExplorer>;
        if ( m_pIConfExplorer )
            m_pIConfExplorer->AddRef();
        else
            hr = E_OUTOFMEMORY;
    }

    // AddRef before returning
    if ( SUCCEEDED(hr) )
    {
        *ppVal = m_pIConfExplorer;
        (*ppVal)->AddRef();
    }

    m_critConfExplorer.Unlock();
    return hr;
}

STDMETHODIMP CAVTapi::get_ConfRoom(IConfRoom **ppVal)
{
    HRESULT hr = E_FAIL;
    m_critConfRoom.Lock();
    if ( m_pIConfRoom )
        hr = m_pIConfRoom->QueryInterface(IID_IConfRoom, (void **) ppVal );
    m_critConfRoom.Unlock();

    return hr;
}


CallManagerMedia CAVTapi::ResolveMediaType( long lAddressType )
{
    switch ( lAddressType )
    {
        case LINEADDRESSTYPE_SDP:                    return CM_MEDIA_MCCONF;
        case LINEADDRESSTYPE_PHONENUMBER:            return CM_MEDIA_POTS;
    }

    return CM_MEDIA_INTERNET;
}

IAVTapiCall* CAVTapi::FindAVTapiCall( long lCallID )
{
    IAVTapiCall *pRet = NULL;

    // $CRIT_ENTER
    m_critLstAVTapiCalls.Lock();
    AVTAPICALLLIST::iterator i, iEnd = m_lstAVTapiCalls.end();
    for ( i = m_lstAVTapiCalls.begin(); i != iEnd; i++ )
    {
        long lNewCallID;
        if ( SUCCEEDED((*i)->get_lCallID(&lNewCallID)) && (lCallID == lNewCallID) )
        {
            (*i)->AddRef();
            pRet = *i;
            break;
        }
    }
    m_critLstAVTapiCalls.Unlock();
    // $CRIT_EXIT

    return pRet;
}

IAVTapiCall* CAVTapi::FindAVTapiCall( ITBasicCallControl *pControl )
{
    ATLTRACE(_T(".enter.CAVTapi::FindAVTapiCall().\n"));
    _ASSERT( pControl );
    IAVTapiCall *pRet = NULL;

    // $CRIT_ENTER
    m_critLstAVTapiCalls.Lock();
    AVTAPICALLLIST::iterator i, iEnd = m_lstAVTapiCalls.end();
    for ( i = m_lstAVTapiCalls.begin(); i != iEnd; i++ )
    {
        ITBasicCallControl *pIndControl;
        if ( SUCCEEDED((*i)->get_ITBasicCallControl(&pIndControl)) && pIndControl)
        {
            // found match?
            pIndControl->Release();
            if ( pIndControl == pControl )
            {
                (*i)->AddRef();
                pRet = *i;
                break;
            }
        }
    }
    m_critLstAVTapiCalls.Unlock();
    // $CRIT_EXIT

    return pRet;
}

IAVTapiCall* CAVTapi::AddAVTapiCall( ITBasicCallControl *pControl, long lCallID )
{
    CAVTapiCall *pNewCall = new CComObject<CAVTapiCall>;
    if ( pNewCall )
    {
        pNewCall->AddRef();
        pNewCall->put_lCallID( lCallID );
        pNewCall->put_callState( CS_IDLE );

        if ( pControl )
            pNewCall->put_ITBasicCallControl( pControl );

        // Add to list
        // $CRIT_ENTER
        m_critLstAVTapiCalls.Lock();
        m_lstAVTapiCalls.push_back( pNewCall );
        m_critLstAVTapiCalls.Unlock();
        // $CRIT_EXIT

        ATLTRACE(_T(".1.CAVTapi::AddAVTapiCall() -- added %ld.\n"), lCallID );

        // Second AddRef() is for the 'get' type operation
        pNewCall->AddRef();
        return pNewCall;
    }

    return NULL;
}

bool CAVTapi::RemoveAVTapiCall( ITBasicCallControl *pDeleteControl )
{
    IAVTapiCall *pAVCall = NULL;

    // $CRIT_ENTER
    m_critLstAVTapiCalls.Lock();
    AVTAPICALLLIST::iterator i, iEnd = m_lstAVTapiCalls.end();
    for ( i = m_lstAVTapiCalls.begin(); i != iEnd; i++ )
    {
        ITBasicCallControl *pControl;
        if ( SUCCEEDED((*i)->get_ITBasicCallControl(&pControl)) )
        {
            if ( pControl == pDeleteControl )
            {
                // found match?
                ATLTRACE(_T("CAVTapi::RemoveAVTapiCall(%p).\n"), pControl );
                pAVCall = *i;
                m_lstAVTapiCalls.erase( i );
                pControl->Release();
                break;
            }
            pControl->Release();
        }
    }
    m_critLstAVTapiCalls.Unlock();
    // $CRIT_EXIT

    // Destroy call object
    if ( pAVCall ) pAVCall->Release();

    return bool (pAVCall != NULL);
}

//////////////////////////////////////////////////////////////////////////////////
// ActionSelected()
//
// This method is use by the client EXE to signal an action taken on a particular call
// identified by lCallID.  The action is defined by the CallManagerActions enum.  If
// lCallID is -1 the function will use the GetFirstActiveCall() method to retrieve a
// call to use.
//
//
STDMETHODIMP CAVTapi::ActionSelected(long lCallID, CallManagerActions cma)
{
#undef FETCH_STRING
#define FETCH_STRING(_CMS_, _IDS_)                                                    \
{                                                                                    \
    LoadString( _Module.GetResourceInstance(), _IDS_, szText, ARRAYSIZE(szText) );    \
    SysReAllocString( &bstrText, T2COLE(szText) );                                    \
    fire_SetCallState_CMS(lCallID, _CMS_, bstrText);                                \
}

    ATLTRACE(_T(".enter.CAVTapi::ActionSelected(id=%ld, action=%d).\n"), lCallID, cma );
    IAVTapiCall *pAVCall = NULL;
    if ( lCallID == -1 ) 
        GetFirstCall( &pAVCall );                // If -1 use any call we can find
    else
        pAVCall = FindAVTapiCall( lCallID );

    if ( !pAVCall ) 
    {
        // We don't have this call anymore, close it
        if ( (lCallID != -1) && (cma == CM_ACTIONS_CLOSE) )    fire_CloseCallControl( lCallID );
        return S_OK;
    }

    USES_CONVERSION;
    HRESULT hr;
    BSTR bstrText = NULL;
    TCHAR szText[255];

    ITCallInfo *pInfo = NULL;
    ITBasicCallControl *pControl = NULL;
    CALL_STATE curState = CS_IDLE;

    if ( SUCCEEDED(hr = pAVCall->get_ITBasicCallControl(&pControl)) )
    {
        if ( SUCCEEDED(pControl->QueryInterface(IID_ITCallInfo, (void **) &pInfo)) )
            pInfo->get_CallState( &curState );
    }

    switch( cma )
    {
        // Place call on hold or take off hold
        case CM_ACTIONS_TAKECALL:
            if ( pControl && pInfo  )
            {
                if ( curState == CS_HOLD )
                {
                    FETCH_STRING( CM_STATES_CURRENT, IDS_PLACECALL_UNHOLDING );
                    hr = pControl->Hold( false );
                }
                else
                {
                    hr = AnswerAction( pInfo, pControl, pAVCall, FALSE );
                }
            }
            break;

        // Hang up the call; if OFFERING then this means reject the call
        case CM_ACTIONS_REJECTCALL:
        case CM_ACTIONS_DISCONNECT:
            FETCH_STRING(CM_STATES_CURRENT, IDS_PLACECALL_DISCONNECTING)
            fire_ClearCurrentActions( lCallID );
            fire_AddCurrentAction( lCallID, CM_ACTIONS_CLOSE, NULL );

            hr = pAVCall->PostMessage( 0, CAVTapiCall::TI_DISCONNECT );
            break;

        // Place call on hold
        case CM_ACTIONS_HOLD:
            if ( pControl )
                hr = pControl->Hold( (bool) (curState != CS_HOLD) );
            break;

        case CM_ACTIONS_ENTERCONFROOM:
            {
                IConfRoom *pConfRoom;
                if ( SUCCEEDED(get_ConfRoom(&pConfRoom)) )
                {
                    pConfRoom->Release();
                }
            }
            break;

        // Close call control dialog
        case CM_ACTIONS_CLOSE:
            if ( SUCCEEDED(hr = fire_CloseCallControl(lCallID)) )
                RemoveAVTapiCall( pControl );
            break;

#ifdef _BAKEOFF
        case CM_ACTIONS_TRANSFER:
            if ( pControl )
            {
                CDlgGetAddress dlg;
                if (  dlg.DoModal(GetActiveWindow()) == IDOK )
                {
                    CErrorInfo er( IDS_ER_CALL_TRANSFER, 0 );
                    hr = er.set_hr( pControl->BlindTransfer(dlg.m_bstrAddress) );
                    if ( SUCCEEDED(hr) )
                    {
                        if ( SUCCEEDED(hr = pControl->Disconnect(DC_NORMAL)) )
                            hr = fire_CloseCallControl( lCallID );
                    }
                }
            }
            break;

        case CM_ACTIONS_CALLBACK:
            if ( pControl )
            {
                CErrorInfo er( IDS_ER_SWAPHOLD, IDS_ER_SWAPHOLD_FIND_CANDIDATE );
                IAVTapiCall *pAVCandidate;
                if ( SUCCEEDED(hr = er.set_hr(GetSwapHoldCallCandidate(pAVCall, &pAVCandidate))) )
                {
                    er.set_Details( IDS_ER_SWAPHOLD_EXECUTE );
                    ITBasicCallControl *pControlSwap;
                    if ( SUCCEEDED(pAVCandidate->get_ITBasicCallControl(&pControlSwap)) )
                    {
                        hr = er.set_hr( pControl->SwapHold(pControlSwap) );
                        pControlSwap->Release();
                    }
                    pAVCandidate->Release();
                }

            }
            break;
#endif
    }

    RELEASE( pInfo );
    RELEASE( pControl );

    // Clean up
    pAVCall->Release();
    SysFreeString( bstrText );

    return hr;
}

STDMETHODIMP CAVTapi::DigitPress(long lCallID, PhonePadKey nKey)
{
    USES_CONVERSION;
    HRESULT hr = S_OK;

    // Convert the digit to the appropriate string.
    BSTR bstrDigit = NULL;
    switch ( nKey )
    {
        case PP_DTMF_STAR:    bstrDigit = SysAllocString(L"*");    break;
        case PP_DTMF_POUND:    bstrDigit = SysAllocString(L"#");    break;
        case PP_DTMF_0:      bstrDigit = SysAllocString(L"0");   break;

        default:
        {
            bstrDigit = SysAllocString(L"1");

            //
            // We have to verify the string allocation before we use it
            //
            if( IsBadStringPtr( bstrDigit, (UINT)-1) )
            {
                return E_OUTOFMEMORY;
            }

            bstrDigit[0] += nKey;
            break;
        }
    }

    //
    // We have to verify the string allocation before we use it
    // We didn't verify for PP_DTMF_STAR, PP_DTMF_POUND and PP_DTMF_0
    //
    if( IsBadStringPtr( bstrDigit, (UINT)-1) )
    {
        return E_OUTOFMEMORY;
    }

    ATLTRACE(_T(".enter.CAVTapi::DigitPress(id=%ld, digit=%d).\n"), lCallID, nKey );

    // Do for all connected calls
    AVTAPICALLLIST lstCalls;
    GetAllCallsAtState( &lstCalls, CS_CONNECTED );

    while ( !lstCalls.empty() )
    {
        IAVTapiCall *pAVCall = lstCalls.front();
        lstCalls.pop_front();

        ITBasicCallControl *pControl;
        if ( SUCCEEDED(hr = pAVCall->get_ITBasicCallControl(&pControl)) )
        {
            // Generate the digits on the MediaControl
            ITLegacyCallMediaControl *pMediaControl;
            if ( SUCCEEDED(hr = pControl->QueryInterface(IID_ITLegacyCallMediaControl, (void **) &pMediaControl)) )
            {
                hr = pMediaControl->GenerateDigits( bstrDigit, 2 );
                pMediaControl->Release();
            }
            pControl->Release();
        }

        // Release ref to call
        pAVCall->Release();
    }

    // Clean up
    SysFreeString( bstrDigit );

    return hr;
}

HRESULT    CAVTapi::GetFirstCall( IAVTapiCall **ppAVCall )
{
    HRESULT hr = E_FAIL;

    // Grab first call on list
    // $CRIT_ENTER
    m_critLstAVTapiCalls.Lock();
    if ( !m_lstAVTapiCalls.empty() )
    {
        *ppAVCall = m_lstAVTapiCalls.front();
        (*ppAVCall)->AddRef();
        hr = S_OK;
    }
    m_critLstAVTapiCalls.Unlock();
    // $CRIT_EXIT

    return hr;
}


////////////////////////////////////////////////////////////////////////////////////
// CAVTapi::ShowMediaPreview( long lCallID, hWndParent, bVisible )
// 
// Pass in -1 for the lCallID to search all calls!
// Pass in 0 to notify that the preview window is hidden
//
STDMETHODIMP CAVTapi::ShowMediaPreview(long lCallID, HWND hWndParent, BOOL bVisible)
{
    ATLTRACE(_T(".enter.CAVTapi::ShowMediaPreview(%ld, %d).\n"), lCallID, bVisible );
    HRESULT hr = E_NOINTERFACE;
    IAVTapiCall *pAVCall = NULL;
    IVideoWindow *pVideoPreview = NULL;

    // Does the call selected support video?
    if ( lCallID > 0 )
    {
        /// Selected a particular call
        pAVCall = FindAVTapiCall( lCallID );
        if ( pAVCall )
            hr = pAVCall->get_IVideoWindowPreview( (IDispatch **) &pVideoPreview );
    }

    // ------------------------- Did we find a valid call
    if ( SUCCEEDED(hr) && pVideoPreview  )
        SetVideoWindowProperties( pVideoPreview, hWndParent, bVisible );

    RELEASE(pVideoPreview);
    RELEASE(pAVCall);
    return hr;
}

STDMETHODIMP CAVTapi::ShowMedia(long lCallID, HWND hWndParent, BOOL bVisible)
{
    ATLTRACE(_T(".enter.CAVTapi::ShowMedia(%ld, %d).\n"), lCallID, bVisible );
    HRESULT    hr = E_NOINTERFACE;
    if ( lCallID > 0 )
    {
        IAVTapiCall *pAVCall = FindAVTapiCall( lCallID );
        if ( pAVCall )
        {
            if ( !bVisible || (pAVCall->IsRcvVideoStreaming() == S_OK) )
            {
                IVideoWindow *pVideoWindow;
                if ( SUCCEEDED(hr = pAVCall->get_IVideoWindow(0, (IDispatch **) &pVideoWindow)) )
                {
                    SetVideoWindowProperties( pVideoWindow, hWndParent, bVisible );
                    pVideoWindow->Release();
                }
            }

            pAVCall->Release();
        }
    }

    return hr;
}

STDMETHODIMP CAVTapi::get_dwCallCaps(long lCallID, DWORD * pVal)
{
    HRESULT hr = E_FAIL;

    IAVTapiCall *pAVCall = FindAVTapiCall( lCallID );
    if ( pAVCall )
    {
        hr = pAVCall->get_dwCaps( pVal );
        pAVCall->Release();
    }

    return hr;
}

// Event notification methods

STDMETHODIMP CAVTapi::CreateNewCall(ITAddress * pITAddress, IAVTapiCall * * ppAVCall)
{
    HRESULT hr = E_OUTOFMEMORY;
    _ASSERT( pITAddress );

    // Create and add call to call list
    if ( (*ppAVCall = AddAVTapiCall(NULL, 0)) != NULL )
        hr = S_OK;
    
    return hr;
}

STDMETHODIMP CAVTapi::fire_NewCall( ITAddress *pITAddress, DWORD dwAddressType, long lCallID, IDispatch *pDisp, AVCallType nType, IAVTapiCall **ppAVCallRet )
{
#ifdef _DEBUG
    if ( nType == AV_DATA_CALL )
        ATLTRACE(_T(".enter.CAVTapi::fire_NewCall() data call.\n"));
    else
        ATLTRACE(_T(".enter.CAVTapi::fire_NewCall() voice call.\n"));
#endif
    _ASSERT( pITAddress );

    // First attempt to get an ITBasicCallControl interface for the call
    HRESULT hr = E_FAIL;

    ITBasicCallControl *pITControl = NULL;
    if ( !pDisp || SUCCEEDED(hr = pDisp->QueryInterface(IID_ITBasicCallControl, (void **) &pITControl)) )
    {
        // Make sure that we haven't already created a dialog for this call
        IAVTapiCall *pAVCall = (pDisp) ? FindAVTapiCall( pITControl ) : NULL;
        if ( !pAVCall )
        {
            // Create and add call to call list
            long lAddressType = LINEADDRESSTYPE_IPADDRESS;
            BSTR bstrAddressName = NULL;
            pITAddress->get_AddressName( &bstrAddressName );
            
            if ( lCallID || SUCCEEDED(hr = fire_NewCallWindow(&lCallID, ResolveMediaType(dwAddressType), bstrAddressName, nType)) )
            {
                pAVCall = AddAVTapiCall( pITControl, lCallID );

                // If we fail to add to list, make sure we close the dialog
                if ( !pAVCall )
                {
                    fire_CloseCallControl( lCallID );
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    // Set the appropriate address type for the call
                    pAVCall->put_nCallType( nType );
                    hr = S_OK;
                }
            }

            SysFreeString( bstrAddressName );
        }

        // Return the call or release it
        if ( ppAVCallRet )
            *ppAVCallRet = pAVCall;
        else
            RELEASE( pAVCall );

        if ( pITControl ) pITControl->Release();
    }

    return hr;
}

STDMETHODIMP CAVTapi::fire_NewCallWindow(long *plCallID, CallManagerMedia cmm, BSTR bstrAddressName, AVCallType nType)
{
    ATLTRACE(_T(".enter.CAVTapi::fire_NewCallWindow().\n") );

    // Clean out existing call control windows if necessary
    CloseExtraneousCallWindows();

    // Do we have a different call type?
    switch ( nType )
    {
        case AV_DATA_CALL:
            if ( cmm == CM_MEDIA_INTERNET )
                cmm = CM_MEDIA_INTERNETDATA;
            break;
    }

    FIRE_VECTOR( NewCall(plCallID, cmm, bstrAddressName));
}

STDMETHODIMP CAVTapi::fire_SetCallerID(long lCallID, BSTR bstrCallerID)
{
    ATLTRACE(_T(".enter.CAVTapi::fire_SetCallerID(%ld).\n"), lCallID );
    BAIL_ON_DATA_OR_CONFCALL;
    FIRE_VECTOR( SetCallerID(lCallID, bstrCallerID));
}

STDMETHODIMP CAVTapi::fire_ClearCurrentActions(long lCallID)
{
    ATLTRACE(_T(".enter.CAVTapi::fire_ClearCurrentActions(%ld).\n"), lCallID );
    BAIL_ON_DATA_OR_CONFCALL;
    FIRE_VECTOR( ClearCurrentActions(lCallID));
}

STDMETHODIMP CAVTapi::fire_AddCurrentAction(long lCallID, CallManagerActions cma, BSTR bstrText)
{
    ATLTRACE(_T(".enter.CAVTapi::fire_AddCurrentAction(%ld,cma=%d).\n"), lCallID, cma );
    BAIL_ON_DATA_OR_CONFCALL;
    FIRE_VECTOR( AddCurrentAction(lCallID, cma, bstrText));
}

STDMETHODIMP CAVTapi::fire_SetCallState(long lCallID, ITCallStateEvent *pEvent, IAVTapiCall *pAVCall )
{
    ATLTRACE(_T(".enter.CAVTapi::fire_SetCallState(ID=%ld, pEvent=%p, pAVCall=%p).\n"), lCallID, pEvent, pAVCall );
#define IF_ADD_ACTION(_LC_, _CMA_)                                \
    if ( (lCaps & (_LC_)) != 0 )                                \
        fire_AddCurrentAction( lCallID, (_CMA_), NULL );

#undef FETCH_STRING
#define FETCH_STRING(_CMS_, _IDS_)                                                    \
    cms = _CMS_;                                                                    \
    LoadString( _Module.GetResourceInstance(), _IDS_, szText, ARRAYSIZE(szText) );    \
    SysReAllocString( &bstrText, T2COLE(szText) );

    USES_CONVERSION;
    CallManagerStates cms = CM_STATES_UNKNOWN;
    BSTR bstrText = NULL;
    TCHAR szText[255];

    if ( pEvent )
    {
        CALL_STATE callState;
        CALL_STATE_EVENT_CAUSE nCec = CEC_NONE;

        pEvent->get_State( &callState );
        pEvent->get_Cause( &nCec );

        // Setup incoming call dialog with appropriate information
        CALL_STATE csPrev = CS_IDLE;
        pAVCall->get_callState( &csPrev );

        // Only update if state has changed
        if ( csPrev != callState )
        {
            AVCallType nCallType;
            pAVCall->get_nCallType( &nCallType );

            // Update call's state
            pAVCall->put_callState( callState );

            // Clear out for new actions based on call state
            fire_ClearCurrentActions( lCallID );

            // Get Address Caps
            long lCaps = 0;
            ITAddress *pITAddress;
            if ( SUCCEEDED(pAVCall->get_ITAddress(&pITAddress)) )
            {
                ITAddressCapabilities *pCaps;
                if ( SUCCEEDED(pITAddress->QueryInterface(IID_ITAddressCapabilities, (void **) &pCaps)) )
                {
                    pCaps->get_AddressCapability( AC_CALLFEATURES1, &lCaps );
                    pCaps->Release();
                }
                pITAddress->Release();
            }

            switch ( callState )
            {    
                // Inbound call
                case CS_OFFERING:
                    {
                    ATLTRACE(_T(".1.CAVTapi::fire_SetCallState(CS_OFFERING).\n"));
                    pAVCall->put_nCallLogType( CL_CALL_INCOMING );
                    fire_AddCurrentAction( lCallID, CM_ACTIONS_TAKECALL, NULL );
                    fire_AddCurrentAction( lCallID, CM_ACTIONS_REJECTCALL, NULL );

                    ITCallInfo* pCallInfo = NULL;
                    HRESULT hr = pAVCall->get_ITCallInfo( &pCallInfo );
                    if( SUCCEEDED(hr) )
                    {
                        USBOffering( pCallInfo );
                        pCallInfo->Release();
                    }

                    FETCH_STRING( CM_STATES_OFFERING, IDS_PLACECALL_OFFERING );
                    }
                    break;

                case CS_INPROGRESS:
                    {
                    ATLTRACE(_T(".1.CAVTapi::fire_SetCallState(CS_INPROGRESS).\n"));
                    fire_AddCurrentAction( lCallID, CM_ACTIONS_DISCONNECT, NULL );
                    FETCH_STRING( CM_STATES_RINGING, IDS_PLACECALL_INPROGRESS );

                    ITCallInfo* pCallInfo = NULL;
                    HRESULT hr = pAVCall->get_ITCallInfo( &pCallInfo );
                    if( SUCCEEDED(hr) )
                    {
                        USBInprogress( pCallInfo );
                        pCallInfo->Release();
                    }
                    }
                    break;

                case CS_CONNECTED:
                    ATLTRACE(_T(".1.CAVTapi::fire_SetCallState(CS_CONNECTED).\n"));
                    // Only do something if we don't want to disconnect
                    if ( SUCCEEDED(pAVCall->CheckKillMe()) )
                    {
                        DWORD dwAddressType = 0;
                        pAVCall->get_dwAddressType( &dwAddressType );
                        if ( (dwAddressType & LINEADDRESSTYPE_SDP) == NULL )
                        {
                            // Normal call, connect as usual
                            IF_ADD_ACTION( LINECALLFEATURE_HOLD, CM_ACTIONS_HOLD );
#ifdef _BAKEOFF
                            // If there are any calls on hold, show the swap hold button.
                            IAVTapiCall *pAVCandidate;
                            if ( SUCCEEDED(GetSwapHoldCallCandidate(pAVCall, &pAVCandidate)) )
                            {
                                IF_ADD_ACTION( LINECALLFEATURE_SWAPHOLD, CM_ACTIONS_CALLBACK );
                                pAVCandidate->Release();
                            }
                            IF_ADD_ACTION( LINECALLFEATURE_BLINDTRANSFER, CM_ACTIONS_TRANSFER );
#endif

                            fire_AddCurrentAction( lCallID, CM_ACTIONS_DISCONNECT, NULL );
                            cms = CM_STATES_CONNECTED;
                        }

                    }
                    break;

                case CS_HOLD:
                    ATLTRACE(_T(".1.CAVTapi::fire_SetCallState(CS_HOLD).\n"));
                    fire_AddCurrentAction( lCallID, CM_ACTIONS_TAKECALL, NULL );
                    cms = CM_STATES_HOLDING;
                    break;

                case CS_DISCONNECTED:
                    {
                        bool bClearCall = false;

                        // Hide video windows, and stop all streaming
                        ShowMedia( lCallID, NULL, FALSE );
                        ShowMediaPreview( lCallID, NULL, FALSE );
                        fire_AddCurrentAction( lCallID, CM_ACTIONS_NOTIFY_PREVIEW_STOP, NULL );
                        fire_AddCurrentAction( lCallID, CM_ACTIONS_NOTIFY_STREAMSTOP, NULL );

                        USBDisconnected( lCallID );

                        // Log all calls that go to the disconnected state
                        pAVCall->Log( CL_UNKNOWN );

                        // Auto close, closes the slider window for all calls
                        VARIANT_BOOL bAutoClose = false;
                        get_bAutoCloseCalls( &bAutoClose );

                        ATLTRACE(_T(".1.CAVTapi::fire_SetCallState(CS_DISCONNECTED).\n"));

                        if ( (bAutoClose || FAILED(pAVCall->CheckKillMe()) || (nCallType == AV_DATA_CALL) ) && SUCCEEDED(fire_CloseCallControl(lCallID)) )
                        {
                            bClearCall = true;
                        }
                        else 
                        {
                            // Want to leave call visible because the remote party hung up
                            if ( SUCCEEDED(pAVCall->Disconnect(FALSE)) )
                            {
                                bClearCall = true;
                                fire_AddCurrentAction( lCallID, CM_ACTIONS_CLOSE, NULL );
                                switch ( nCec )
                                {
                                    case CEC_DISCONNECT_BUSY:        FETCH_STRING( CM_STATES_BUSY, IDS_PLACECALL_DISCONNECT_BUSY );                break;
                                    case CEC_DISCONNECT_NOANSWER:    FETCH_STRING( CM_STATES_UNAVAILABLE, IDS_PLACECALL_DISCONNECT_NOANSWER);    break;
                                    case CEC_DISCONNECT_REJECTED:    FETCH_STRING( CM_STATES_UNAVAILABLE, IDS_PLACECALL_DISCONNECT_REJECTED);    break;
                                    case CEC_DISCONNECT_BADADDRESS:    FETCH_STRING( CM_STATES_UNAVAILABLE, IDS_PLACECALL_DISCONNECT_BADADDRESS);    break;
                                    case CEC_DISCONNECT_CANCELLED:    FETCH_STRING( CM_STATES_UNAVAILABLE, IDS_PLACECALL_DISCONNECT_CANCELLED);    break;
                                    case CEC_DISCONNECT_FAILED:        FETCH_STRING( CM_STATES_UNAVAILABLE, IDS_PLACECALL_DISCONNECT_FAILED);        break;
                                    // Normal
                                    default: cms = CM_STATES_DISCONNECTED;    break;
                                }
                            }
                        }

                        // Remove all ref's to the call
                        if ( bClearCall )
                        {
                            ITBasicCallControl *pControl = NULL;
                            if ( SUCCEEDED(pAVCall->get_ITBasicCallControl(&pControl)) )
                            {
                                RemoveAVTapiCall( pControl );
                                pControl->Release();
                            }
                            else
                            {
                                RemoveAVTapiCall( NULL );
                            }
                        }

                        break;
                    }
            }
        }
    }

    // Notify application of call state changing    
    ATLTRACE(_T(".exit.CAVTapi::fire_SetCallState() -- preparing to bail.\n") );
    BAIL_ON_DATA_OR_CONFCALL;
    if ( cms != CM_STATES_UNKNOWN )
    {
        ATLTRACE(_T(".enter.CAVTapi::fire_SetCallState(%ld, cms=%d).\n"), lCallID, cms );
        FIRE_VECTOR( SetCallState(lCallID, cms, bstrText));
    }

    return S_OK;
}

STDMETHODIMP CAVTapi::fire_CloseCallControl(long lCallID)
{
    BAIL_ON_CONFCALL;
    ATLTRACE(_T(".enter.CAVTapi::fire_CloseCallControl(%ld).\n"), lCallID );
    FIRE_VECTOR( CloseCallControl(lCallID));
}

STDMETHODIMP CAVTapi::fire_ErrorNotify(long * pErrorInfo)
{
    ATLTRACE(_T(".enter.CAVTapi::fire_ErrorInfo().\n") );
    _ASSERT( pErrorInfo );
    CErrorInfo *pEr = (CErrorInfo *) pErrorInfo;
#ifdef _DEBUG
    USES_CONVERSION;
    ATLTRACE(_T(".1.\tOperation: %s\n"), OLE2CT(pEr->m_bstrOperation) );
    ATLTRACE(_T(".1.\tDetails  : %s\n"), OLE2CT(pEr->m_bstrDetails) );
    ATLTRACE(_T(".1.\tHRESULT  : 0x%08lx\n"), pEr->m_hr );
#endif
    FIRE_VECTOR( ErrorNotify( pEr->m_bstrOperation, pEr->m_bstrDetails, pEr->m_hr ) );
}

STDMETHODIMP CAVTapi::fire_SetCallState_CMS(long lCallID, CallManagerStates cms, BSTR bstrText)
{
    ATLTRACE(_T(".enter.CAVTapi::fire_SetCallState_CMS(%ld,cms=%d).\n"), lCallID, cms );
    BAIL_ON_DATA_OR_CONFCALL;
    FIRE_VECTOR( SetCallState(lCallID, cms, bstrText));
}

STDMETHODIMP CAVTapi::fire_ActionSelected(CallClientActions cca)
{
    ATLTRACE(_T(".enter.CAVTapi::fire_ActionSelected(%d).\n"), cca );
    FIRE_VECTOR( ActionSelected(cca));
}

STDMETHODIMP CAVTapi::fire_LogCall(long lCallID, CallLogType nType, DATE dateStart, DATE dateEnd, BSTR bstrAddr, BSTR bstrName)
{
    ATLTRACE(_T(".enter.CAVTapi::fire_LogCall(%d).\n"), nType );
    FIRE_VECTOR( LogCall(lCallID, nType, dateStart, dateEnd, bstrAddr, bstrName));
}

STDMETHODIMP CAVTapi::fire_NotifyUserUserInfo(long lCallID, ULONG_PTR hMem)
{
    ATLTRACE(_T(".enter.CAVTapi::fire_NotifyUserUserInfo(%p).\n"), hMem );
    FIRE_VECTOR( NotifyUserUserInfo(lCallID, hMem));
}


#include "PageAddress.h"

STDMETHODIMP CAVTapi::ShowOptions()
{
    USES_CONVERSION;
    IUnknown *pUnk = GetUnknown();

#ifdef _NEWPROPS
   CPageConf::s_nCount = 0;

    CLSID clsidPages[4];
   clsidPages[0] = CLSID_PageGeneral;
    clsidPages[1] = CLSID_PageConf;
    clsidPages[2] = CLSID_PageConf;
    clsidPages[3] = CLSID_PageConf;
#else
    CLSID clsidPages[2];
    clsidPages[0] = CLSID_PageAddress;
    clsidPages[1] = CLSID_PageTerminals;
#endif

    TCHAR szTitle[255];
    LoadString( _Module.GetResourceInstance(), IDS_OPTIONS_TITLE, szTitle, ARRAYSIZE(szTitle) );

    HRESULT hr;
    hr = OleCreatePropertyFrame( _Module.GetParentWnd(), 100, 100, T2COLE(szTitle),
                                 1, &pUnk,                            // Objects being invoked on behalf of
                                 ARRAYSIZE(clsidPages), clsidPages,    // Property pages
                                 LOCALE_USER_DEFAULT,                // System locale
                                 0, NULL );                            // Reserved

    //
    // Read the new audio echo cancellation flag
    //

    m_bAEC = AECGetRegistryValue();

    return S_OK;
}


// Static helper functions
void CAVTapi::SetVideoWindowProperties( IVideoWindow *pVideoWindow, HWND hWndParent, BOOL bVisible )
{
    ATLTRACE(_T(".enter.SetVideoWindowProperties(%p, %d).\n"), pVideoWindow, bVisible );

    HWND hWndTemp;
    if ( SUCCEEDED(pVideoWindow->get_Owner((OAHWND FAR*) &hWndTemp)) )
    {
        if ( hWndParent )
        {
            // We have a pointer to the VideoWindow, now set up the parent and stuff
             pVideoWindow->put_Owner((ULONG_PTR) hWndParent);
            pVideoWindow->put_MessageDrain((ULONG_PTR) hWndParent);
            pVideoWindow->put_WindowStyle(WS_CHILD | WS_BORDER);
            
            // Drop video onto call control
            RECT rc;
            GetClientRect( hWndParent, &rc );
            pVideoWindow->SetWindowPosition(rc.left, rc.top, rc.right, rc.bottom);
            pVideoWindow->put_AutoShow( (bVisible) ? OATRUE : OAFALSE );
            pVideoWindow->put_Visible( (bVisible) ? OATRUE : OAFALSE );
        }
        else
        {
            // Release ownership of window
            pVideoWindow->put_AutoShow( OAFALSE );
            pVideoWindow->put_Visible( OAFALSE );
            pVideoWindow->put_Owner( NULL );
            pVideoWindow->put_MessageDrain( NULL );
        }
    }
}

STDMETHODIMP CAVTapi::PopulateAddressDialog(DWORD *pdwPreferred, HWND hWndPots, HWND hWndIP, HWND hWndConf)
{
    _ASSERT( IsWindow(hWndPots) && IsWindow(hWndIP) && IsWindow(hWndConf) );
    _ASSERT( pdwPreferred );

    // Is TAPI running?
    _ASSERT(m_pITTapi);
    if ( !m_pITTapi ) return E_PENDING;

    // Enumerate through addresses, adding them to each listbox
    USES_CONVERSION;
    HRESULT hr;
    IEnumAddress *pEnumAddresses;
    if ( FAILED(hr = m_pITTapi->EnumerateAddresses(&pEnumAddresses)) ) return hr;

    HCURSOR hCurOld = SetCursor( LoadCursor(NULL, IDC_APPSTARTING) );

    // Retrieve preferred media type
    get_dwPreferredMedia( pdwPreferred );

    CMyAddressID *pMyID;
    ITAddress *pITAddress;
    while ( pEnumAddresses->Next(1, &pITAddress, NULL) == S_OK )
    {
        ITMediaSupport *pITMediaSupport;
        if ( SUCCEEDED(hr = pITAddress->QueryInterface(IID_ITMediaSupport, (void **) &pITMediaSupport)) )
        {
            // Must support audio in and out
            VARIANT_BOOL bSupport;
            if ( SUCCEEDED(pITMediaSupport->QueryMediaType(TAPIMEDIATYPE_AUDIO, &bSupport)) && bSupport )
            {
                // Determine the types of media the address supports
                ITAddressCapabilities *pCaps;
                if ( SUCCEEDED(pITAddress->QueryInterface(IID_ITAddressCapabilities, (void **) &pCaps)) )
                {
                    BSTR bstrName = NULL;
                    pITAddress->get_AddressName( &bstrName );

                    if ( bstrName && (SysStringLen(bstrName) > 0) )
                    {
                        long lAddrTypes = 0;
                        pCaps->get_AddressCapability( AC_ADDRESSTYPES, &lAddrTypes );

                        for ( int i = 0; i < 3; i++ )
                        {
                            HWND hWnd = NULL;
                            switch ( i )
                            {
                                // Multicast Conferences
                                case 0:
                                    if ( (lAddrTypes & LINEADDRESSTYPE_SDP) != NULL )
                                        hWnd = hWndConf;
                                    break;

                                // Phone Calls
                                case 1:
                                    if ( (lAddrTypes & LINEADDRESSTYPE_PHONENUMBER) != NULL )
                                        hWnd = hWndPots;
                                    break;

                                // Network based calls
                                case 2:
                                    if ( (lAddrTypes & LINEADDRESSTYPE_NETCALLS) != NULL )
                                        hWnd = hWndIP;
                                    break;
                            }
                        
                            // Do we have something to add?
                            if ( hWnd )
                            {
                                int nInd = SendMessage( hWnd, CB_ADDSTRING, 0, (LPARAM) OLE2CT(bstrName) );
                                if ( nInd >= 0 )
                                {
                                    pMyID = new CMyAddressID;
                                    if ( pMyID )
                                    {
                                        pCaps->get_AddressCapability( AC_PERMANENTDEVICEID, &pMyID->m_lPermID );
                                        pCaps->get_AddressCapability( AC_ADDRESSID, &pMyID->m_lAddrID );
                                        SendMessage( hWnd, CB_SETITEMDATA, nInd, (LPARAM) pMyID );
                                    }
                                }
                            }
                        }
                    }
                    SysFreeString( bstrName );
                    pCaps->Release();
                }
            }
            pITMediaSupport->Release();
        }
        pITAddress->Release();
    }
    pEnumAddresses->Release();

    // Add default for all lists
    TCHAR szText[255];
    CRegKey regKey;
    LoadString( _Module.GetResourceInstance(), IDN_REG_REDIAL_KEY, szText, ARRAYSIZE(szText) );
    regKey.Open( HKEY_CURRENT_USER, szText, KEY_READ );
    DWORD dwAddrType[] = { LINEADDRESSTYPE_PHONENUMBER, LINEADDRESSTYPE_IPADDRESS, LINEADDRESSTYPE_SDP };

    HWND hWndTemp[] = { hWndPots, hWndIP, hWndConf };
    for ( int i = 0; i < ARRAYSIZE(hWndTemp); i++ )
    {
        // Selecte a default list item for the combo box
        UINT nIDS = IDS_DEFAULT_LINENAME;
        if ( !SendMessage(hWndTemp[i], CB_GETCOUNT, 0, 0) )
        {
            ::EnableWindow( hWndTemp[i], false );
            nIDS = IDS_NO_LINES;
        }

        // Add item to list
        if ( nIDS )
        {
            LoadString( _Module.GetResourceInstance(), nIDS, szText, ARRAYSIZE(szText) );
            int nInd = SendMessage( hWndTemp[i], CB_INSERTSTRING, 0, (LPARAM) szText );
            if ( nInd >= 0 )
                SendMessage( hWndTemp[i], CB_SETITEMDATA, 0, 0 );
        }

        // Retrieve previously selected item from registry
        DWORD dwPermID = 0, dwAddrID;
        if ( regKey.m_hKey )
        {
            LoadString( _Module.GetResourceInstance(), AddressTypeToRegKey(dwAddrType[i], true), szText, ARRAYSIZE(szText) );
            regKey.QueryValue( dwPermID, szText );

            LoadString( _Module.GetResourceInstance(), AddressTypeToRegKey(dwAddrType[i], false), szText, ARRAYSIZE(szText) );
            regKey.QueryValue( dwAddrID, szText );
        }
    
        // Look for item in the listbox
        int nCurSel = 0;
        if ( dwPermID )
        {
            int nCount = SendMessage( hWndTemp[i], CB_GETCOUNT, 0, 0 );
            for ( int j = 0; j < nCount; j++ )
            {
                pMyID = (CMyAddressID *) SendMessage(hWndTemp[i], CB_GETITEMDATA, j, 0);
                if ( pMyID && ((DWORD) pMyID->m_lPermID == dwPermID) && ((DWORD) pMyID->m_lAddrID == dwAddrID) )
                {
                    nCurSel = j;
                    break;
                }
            }

            // Line device no longer exists
            if ( !nCurSel )
            {
                // Add temporary place holder
                pMyID = new CMyAddressID;
                if ( pMyID )
                {
                    pMyID->m_lPermID = dwPermID;
                    pMyID->m_lAddrID = dwAddrID;

                    LoadString( _Module.GetResourceInstance(), IDS_LINENOTFOUND, szText, ARRAYSIZE(szText) );
                    int nInd = SendMessage( hWndTemp[i], CB_INSERTSTRING, 0, (LPARAM) szText );
                    if ( nInd >= 0 )
                        SendMessage( hWndTemp[i], CB_SETITEMDATA, 0, (LPARAM) pMyID );
                }
            }
        }

        // Select item in the combo box
        SendMessage( hWndTemp[i], CB_SETCURSEL, nCurSel, 0 );
    }

    // Restore the cursor
    SetCursor( hCurOld );
    return S_OK;
}

STDMETHODIMP CAVTapi::PopulateTerminalsDialog(DWORD dwAddressType, HWND *phWnd)
{
    USES_CONVERSION;
    HRESULT hr = S_OK;
    bool bFoundAddress = false;

    int i;

    HCURSOR hCurOld = SetCursor( LoadCursor(NULL, IDC_APPSTARTING) );

    // Clear out the lists
    for ( i = 0; i < NUM_CB_TERMINALS; i++ )
    {
        SendMessage( phWnd[i], CB_RESETCONTENT, 0, 0 );
        EnableWindow( phWnd[i], true );
    }

    // Resolve address type to an active address
    ITAddress *pITAddress;
    if ( SUCCEEDED(hr = GetAddress(dwAddressType, false, &pITAddress)) )
    {
        HRESULT hrTemp;
        bFoundAddress = true;

        // Get terminals supported by address
        ITTerminalSupport *pITTerminalSupport;
        if ( SUCCEEDED(hrTemp = pITAddress->QueryInterface(IID_ITTerminalSupport, (void **) &pITTerminalSupport)) )
        {
            IEnumTerminal *pEnumTerminal;
            if ( (hrTemp = pITTerminalSupport->EnumerateStaticTerminals(&pEnumTerminal)) == S_OK )    
            {
                // What type of terminal do we have?  (audio in, audio out, video in, etc.)
                ITTerminal *pITTerminal;
                while ( pEnumTerminal->Next(1, &pITTerminal, NULL) == S_OK )
                {
                    TERMINAL_DIRECTION nTD;
                    long nTerminalType;
                    // Render or Capture?    
                    if ( SUCCEEDED(pITTerminal->get_Direction(&nTD)) )
                    {
                        // Audio or Video?
                        BSTR bstrName = NULL;
                        HWND hWnd = NULL;

                        pITTerminal->get_Name( &bstrName );
                        if ( bstrName && (SysStringLen(bstrName) > 0) )
                        {
                            pITTerminal->get_MediaType( &nTerminalType );

                            switch ( nTerminalType )
                            {
                                // ------------------
                                case TAPIMEDIATYPE_VIDEO:
                                    if ( nTD == TD_CAPTURE )
                                        hWnd = phWnd[VIDEO_CAPTURE];
                                    break;

                                // ------------
                                case TAPIMEDIATYPE_AUDIO:
                                    hWnd = (nTD == TD_CAPTURE) ? phWnd[AUDIO_CAPTURE] : phWnd[AUDIO_RENDER];
                                    break;
                            }

                            // Add item to appropriate listbox
                            if ( hWnd )
                                SendMessage( hWnd, CB_ADDSTRING, 0, (LPARAM) OLE2CT(bstrName) );
                        }

                        // Clean up
                        SysFreeString( bstrName );
                    }
                    // Clean up
                    pITTerminal->Release();
                }
                pEnumTerminal->Release();
            }

            // Does the address support video render?
            if ( phWnd[VIDEO_RENDER] )
            { 
                bool bSupported = false;

                IEnumTerminalClass *pEnumClass = NULL;
                if ( SUCCEEDED(pITTerminalSupport->EnumerateDynamicTerminalClasses(&pEnumClass)) && pEnumClass )
                {
                    GUID guidTerminal;
                    while ( pEnumClass->Next(1, &guidTerminal, NULL) == S_OK )
                    {
                        if ( guidTerminal == CLSID_VideoWindowTerm )
                        {
                            bSupported = true;
                            break;
                        }
                    }
                    pEnumClass->Release();
                }
                EnableWindow( phWnd[VIDEO_RENDER], bSupported );
            }

            // Clean up
            pITTerminalSupport->Release();
        }
        pITAddress->Release();
    }
    else
    {
        // Disable video playback
        if ( phWnd[VIDEO_RENDER] )
            EnableWindow( phWnd[VIDEO_RENDER], false );
    }


    // Add default for all lists
    CRegKey regKey;
    UINT nIDS_Key[] = { IDN_REG_REDIAL_TERMINAL_AUDIO_CAPTURE, IDN_REG_REDIAL_TERMINAL_AUDIO_RENDER, IDN_REG_REDIAL_TERMINAL_VIDEO_CAPTURE };

    // Open the key for the addresstype
    TCHAR szText[255], szType[255];
    LoadString( _Module.GetResourceInstance(), IDN_REG_REDIAL_KEY, szText, ARRAYSIZE(szText) );
    LoadString( _Module.GetResourceInstance(), AddressTypeToRegKey(dwAddressType, true), szType, ARRAYSIZE(szType) );
    _tcscat( szText, _T("\\") );
    _tcscat( szText, szType );
    regKey.Open( HKEY_CURRENT_USER, szText, KEY_READ );

    // Load audio and video terminal settings
    for ( i = 0; i < NUM_CB_TERMINALS; i++ )
    {
        // Selecte a default list item for the combo box
        UINT nIDS = IDS_PREFERRED_DEVICE;
        if ( !SendMessage(phWnd[i], CB_GETCOUNT, 0, 0) )
        {
            ::EnableWindow( phWnd[i], false );
            nIDS = (bFoundAddress) ? IDS_NO_DEVICES : IDS_NO_LINE_SUPPORTING_CALL_TYPE;
        }

        // Add item to list
        if ( nIDS )
        {
            // Do we want to give them the capability of selecting no terminal?
            if ( nIDS == IDS_PREFERRED_DEVICE )
            {
                LoadString( _Module.GetResourceInstance(), IDS_NONE_DEVICE, szText, ARRAYSIZE(szText) );
                SendMessage( phWnd[i], CB_INSERTSTRING, 0, (LPARAM) szText );
            }

            LoadString( _Module.GetResourceInstance(), nIDS, szText, ARRAYSIZE(szText) );
            SendMessage( phWnd[i], CB_INSERTSTRING, 0, (LPARAM) szText );
        }

        // Select an item
        int nCurSel = 0;
        if ( regKey.m_hKey )
        {
            LoadString( _Module.GetResourceInstance(), nIDS_Key[i], szText, ARRAYSIZE(szText) );
            DWORD dwCount = ARRAYSIZE(szType) - 1;
            if ( (regKey.QueryValue(szType, szText, &dwCount) == ERROR_SUCCESS) && (dwCount > 0) )
                nCurSel = SendMessage( phWnd[i], CB_FINDSTRINGEXACT, 1, (LPARAM) szType );
        }

      if ( nCurSel >= 0 )
      {
           SendMessage( phWnd[i], CB_SETCURSEL, nCurSel, 0 );
      }
      else
      {
           SendMessage( phWnd[i], CB_SETCURSEL, 0, 0 );
      }
    }

    // Should we check show video windows?
    SendMessage( phWnd[3], BM_SETCHECK, (WPARAM) (CanCreateVideoWindows(dwAddressType) == S_OK), 0 );

    // Max video windows
    if ( dwAddressType == LINEADDRESSTYPE_SDP )
    {
        LoadString( _Module.GetResourceInstance(), IDN_REG_REDIAL_TERMINAL_MAX_VIDEO, szText, ARRAYSIZE(szText) );
        IConfRoom *pConfRoom;
        if ( SUCCEEDED(get_ConfRoom(&pConfRoom)) )
        {
            short nMax;
            pConfRoom->get_nMaxTerms( &nMax );

            DWORD dwTemp = nMax;
            regKey.QueryValue( dwTemp, szText );
            dwTemp = min( MAX_VIDEO, max(1, dwTemp) );

            TCHAR szText[100];
            _ltot( dwTemp, szText, 10 );
            SetWindowText( phWnd[4], szText );

            pConfRoom->Release();
        }
    }

    SetCursor( hCurOld );
    return hr;
}

STDMETHODIMP CAVTapi::UnpopulateAddressDialog(DWORD dwPreferred, HWND hWndPOTS, HWND hWndIP, HWND hWndConf)
{
    // Store preferred device
    put_dwPreferredMedia( dwPreferred );

    // Store selected provider for each line
    HWND hWnd[] = { hWndPOTS, hWndIP, hWndConf };
    
    CRegKey regKey;
    TCHAR szText[255];
    LoadString( _Module.GetResourceInstance(), IDN_REG_REDIAL_KEY, szText, ARRAYSIZE(szText) );
    if ( regKey.Create(HKEY_CURRENT_USER, szText) == ERROR_SUCCESS )
    {
        CMyAddressID *pMyID;
        DWORD arAddr[] = { LINEADDRESSTYPE_PHONENUMBER, LINEADDRESSTYPE_IPADDRESS, LINEADDRESSTYPE_SDP };
        _ASSERT( ARRAYSIZE(hWnd) == ARRAYSIZE(arAddr) );

        // Write provider ID's out to the registry
        for ( int i = 0; i < ARRAYSIZE(hWnd); i++ )
        {
            _ASSERT( IsWindow(hWnd[i]) );
            int nSel = (int) SendMessage( hWnd[i], CB_GETCURSEL, 0, 0 );
            if ( nSel >= 0 )
            {
                pMyID = (CMyAddressID *) SendMessage(hWnd[i], CB_GETITEMDATA, nSel, 0);

                LoadString( _Module.GetResourceInstance(), AddressTypeToRegKey(arAddr[i], true), szText, ARRAYSIZE(szText) );
                regKey.SetValue( (pMyID) ? pMyID->m_lPermID : 0, szText );

                LoadString( _Module.GetResourceInstance(), AddressTypeToRegKey(arAddr[i], false), szText, ARRAYSIZE(szText) );
                regKey.SetValue( (pMyID) ? pMyID->m_lAddrID : 0, szText );
            }
        }
    }

    return S_OK;
}

STDMETHODIMP CAVTapi::UnpopulateTerminalsDialog(DWORD dwAddressType, HWND *phWnd)
{
    UINT nIDS_Key[] = { IDN_REG_REDIAL_TERMINAL_AUDIO_CAPTURE, IDN_REG_REDIAL_TERMINAL_AUDIO_RENDER, IDN_REG_REDIAL_TERMINAL_VIDEO_CAPTURE };

    // Create the registry key, its a combination of redial and
    CRegKey regKey;
    TCHAR szText[255], szType[50];
    LoadString( _Module.GetResourceInstance(), IDN_REG_REDIAL_KEY, szText, ARRAYSIZE(szText) );
    LoadString( _Module.GetResourceInstance(), AddressTypeToRegKey(dwAddressType, true), szType, ARRAYSIZE(szType) );
    _tcscat( szText, _T("\\") );
    _tcscat( szText, szType );
    regKey.Create( HKEY_CURRENT_USER, szText );
    
    // Store all terminals for audio in, audio out and video in
    for ( int i = 0; i < NUM_CB_TERMINALS; i++ )
    {
        _ASSERT( IsWindow(phWnd[i]) );

        // Store name of terminal in a registry key
        if ( regKey.m_hKey )
        {
            LoadString( _Module.GetResourceInstance(), nIDS_Key[i], szText, ARRAYSIZE(szText) );

            // What is selected?  Preferred device or a specific one
            bool bSetValue = false;

            int nCurSel = SendMessage( phWnd[i], CB_GETCURSEL, 0, 0 );
            if ( nCurSel > 0 )
            {
                int nSize = SendMessage(phWnd[i], CB_GETLBTEXTLEN, nCurSel, 0) + 1;
                if ( nSize > 0 )
                {
                    TCHAR *pszTerminal = new TCHAR[nSize];
                    if ( pszTerminal )
                    {
                        bSetValue = true;
                        SendMessage( phWnd[i], CB_GETLBTEXT, nCurSel, (LPARAM) pszTerminal );
                        regKey.SetValue( pszTerminal, szText );
                        delete pszTerminal;
                    }
                }
            }
            
            // Clean out the entry
            if ( !bSetValue )
                regKey.DeleteValue( szText );
        }
    }

    // Should we check show video windows?
    LoadString( _Module.GetResourceInstance(), IDN_REG_REDIAL_TERMINAL_VIDEO_RENDER, szText, ARRAYSIZE(szText) );
    DWORD dwTemp = SendMessage( phWnd[VIDEO_RENDER], BM_GETCHECK, 0, 0 );
    regKey.SetValue( dwTemp, szText );

    // Max video windows
    if ( dwAddressType == LINEADDRESSTYPE_SDP )
    {
        LoadString( _Module.GetResourceInstance(), IDN_REG_REDIAL_TERMINAL_MAX_VIDEO, szText, ARRAYSIZE(szText) );
        IConfRoom *pConfRoom;
        if ( SUCCEEDED(get_ConfRoom(&pConfRoom)) )
        {
            TCHAR szNum[100];
            GetWindowText( phWnd[4], szNum, ARRAYSIZE(szNum) - 1 );
            dwTemp = _ttol( szNum );
            dwTemp = min( MAX_VIDEO, max(1, dwTemp) );

            pConfRoom->put_nMaxTerms( (short) dwTemp );
            regKey.SetValue( dwTemp, szText );

            pConfRoom->Release();
        }
    }

    return S_OK;
}

STDMETHODIMP CAVTapi::get_dwPreferredMedia(DWORD * pVal)
{
    // Load preferred media type from registry
    _ASSERT( pVal );
    *pVal = LINEADDRESSTYPE_IPADDRESS;        // set a default

    CRegKey regKey;
    TCHAR szTemp[255];

    LoadString( _Module.GetResourceInstance(), IDN_REG_REDIAL_KEY, szTemp, ARRAYSIZE(szTemp) );
    if ( regKey.Open(HKEY_CURRENT_USER, szTemp, KEY_READ) == ERROR_SUCCESS )
    {
        LoadString( _Module.GetResourceInstance(), IDN_REG_REDIAL_PREFERRED_MEDIA, szTemp, ARRAYSIZE(szTemp) );
        regKey.QueryValue( *pVal, szTemp );
    }

    return S_OK;
}

STDMETHODIMP CAVTapi::put_dwPreferredMedia(DWORD newVal)
{
    // Save prefered media type to registry
    CRegKey regKey;
    TCHAR szTemp[255];

    LoadString( _Module.GetResourceInstance(), IDN_REG_REDIAL_KEY, szTemp, ARRAYSIZE(szTemp) );
    if ( regKey.Create(HKEY_CURRENT_USER, szTemp) == ERROR_SUCCESS )
    {
        LoadString( _Module.GetResourceInstance(), IDN_REG_REDIAL_PREFERRED_MEDIA, szTemp, ARRAYSIZE(szTemp) );
        regKey.SetValue( newVal, szTemp );
    }
    
    return S_OK;
}


HRESULT CAVTapi::GetAllCallsAtState( AVTAPICALLLIST *pList, CALL_STATE callState )
{
    CALL_STATE nState;

    // $CRIT_ENTER
    m_critLstAVTapiCalls.Lock();
    AVTAPICALLLIST::iterator i, iEnd = m_lstAVTapiCalls.end();
    for ( i = m_lstAVTapiCalls.begin(); i != iEnd; i++ )
    {
        // If call states match, add to list
        if ( SUCCEEDED((*i)->get_callState(&nState)) && (nState == callState) )
        {
            (*i)->AddRef();
            pList->push_back( *i );
        }
    }
    m_critLstAVTapiCalls.Unlock();
    // $CRIT_EXIT

    return (pList->empty()) ? E_FAIL : S_OK;
}

STDMETHODIMP CAVTapi::FindAVTapiCallFromCallHub(ITCallHub * pCallHub, IAVTapiCall * * ppCall)
{
    HRESULT hr = E_FAIL;
    *ppCall = NULL;

    // $CRIT_ENTER
    m_critLstAVTapiCalls.Lock();
    AVTAPICALLLIST::iterator i, iEnd = m_lstAVTapiCalls.end();
    for ( i = m_lstAVTapiCalls.begin(); i != iEnd; i++ )
    {
        if ( (*i)->IsSameCallHub(pCallHub) == S_OK )
        {
            *ppCall = (*i);
            (*ppCall)->AddRef();
            hr = S_OK;
            break;
        }
    }
    m_critLstAVTapiCalls.Unlock();
    // $CRIT_EXIT
    
    return hr;
}

STDMETHODIMP CAVTapi::FindAVTapiCallFromCallInfo(ITCallInfo * pCallInfo, IAVTapiCall **ppCall)
{
    HRESULT hr = E_FAIL;
    *ppCall = NULL;

    // $CRIT_ENTER
    m_critLstAVTapiCalls.Lock();
    AVTAPICALLLIST::iterator i, iEnd = m_lstAVTapiCalls.end();
    for ( i = m_lstAVTapiCalls.begin(); i != iEnd; i++ )
    {
        ITCallInfo *pMyCallInfo;
        if ( SUCCEEDED((*i)->get_ITCallInfo(&pMyCallInfo)) )
        {
            if ( pCallInfo == pMyCallInfo )
            {
                *ppCall = (*i);
                (*ppCall)->AddRef();
                hr = S_OK;
            }

            pMyCallInfo->Release();
        }
        
        if ( SUCCEEDED(hr) ) break;
    }
    m_critLstAVTapiCalls.Unlock();
    // $CRIT_EXIT

    return hr;
}



STDMETHODIMP CAVTapi::get_nNumCalls(long * pVal)
{
//    m_critLstAVTapiCalls.Lock();
    *pVal = m_lstAVTapiCalls.size();
//    m_critLstAVTapiCalls.Unlock();

    return S_OK;
}



STDMETHODIMP CAVTapi::FindAVTapiCallFromParticipant(ITParticipant * pParticipant, IAVTapiCall **ppCall)
{
    HRESULT hr = E_FAIL;
    *ppCall = NULL;

    // $CRIT_ENTER
    m_critLstAVTapiCalls.Lock();
    AVTAPICALLLIST::iterator i, iEnd = m_lstAVTapiCalls.end();
    for ( i = m_lstAVTapiCalls.begin(); i != iEnd; i++ )
    {
        if ( (*i)->IsMyParticipant(pParticipant) == S_OK )
        {
            *ppCall = (*i);
            (*ppCall)->AddRef();
            hr = S_OK;
            break;
        }
    }
    m_critLstAVTapiCalls.Unlock();
    // $CRIT_EXIT
    
    return hr;
}

STDMETHODIMP CAVTapi::CanCreateVideoWindows(DWORD dwAddressType)
{
    // Load default registry values...
    CRegKey regKey;
    TCHAR szText[255], szType[255];
    LoadString( _Module.GetResourceInstance(), IDN_REG_REDIAL_KEY, szText, ARRAYSIZE(szText) );
    LoadString( _Module.GetResourceInstance(), AddressTypeToRegKey(dwAddressType, true), szType, ARRAYSIZE(szType) );
    _tcscat( szText, _T("\\") );
    _tcscat( szText, szType );
    regKey.Open( HKEY_CURRENT_USER, szText, KEY_READ );


    // Retrieve information on creating video window?
    LoadString( _Module.GetResourceInstance(), IDN_REG_REDIAL_TERMINAL_VIDEO_RENDER, szText, ARRAYSIZE(szText) );
    DWORD dwTemp = 1;
    regKey.QueryValue( dwTemp, szText );
    dwTemp = min( 1, dwTemp);

    return (dwTemp == 1) ? S_OK : S_FALSE;
}

STDMETHODIMP CAVTapi::RefreshDS()
{
    HRESULT hr = E_FAIL;

    if ( InterlockedIncrement(&m_lRefreshDS) == 1 )
    {
        // Start up the thread
        DWORD dwID;
        HANDLE hThread = CreateThread(NULL, 0, ThreadDSProc, (void *) &m_lRefreshDS, NULL, &dwID);
        if ( hThread ) 
        {
            CloseHandle( hThread );
            hr = S_OK;
        }
    }

    // Decrement count since we didn't start the thread for one reason
    // or another.
    if ( FAILED(hr) )
        InterlockedDecrement( &m_lRefreshDS );

    return hr;
}

STDMETHODIMP CAVTapi::CreateCallEx(BSTR bstrName, BSTR bstrAddress, BSTR bstrUser1, BSTR bstrUser2, DWORD dwAddressType)
{
    _ASSERT( bstrAddress && dwAddressType );
    HRESULT hr = S_OK;

    //
    // Wait for Dialer to register as client
    //

    if( m_hEventDialerReg)
    {
        WaitForSingleObject( m_hEventDialerReg, INFINITE);
    }

    CErrorInfo er;
    er.set_Operation( IDS_ER_PLACECALL );
    er.set_Details( IDS_ER_GET_ADDRESS );

    ITAddress *pITAddress;
    if ( SUCCEEDED(hr = er.set_hr(GetAddress(dwAddressType, true, &pITAddress))) )
    {
        // Setup dialing info to pass to dialing thread
        er.set_Details( IDS_ER_CREATE_THREAD );
        CThreadDialingInfo *pInfo = new CThreadDialingInfo;
        if ( pInfo )
        {
            // Copy information into the info structure
            pInfo->set_ITAddress( pITAddress );
            if ( bstrName ) pInfo->m_bstrName = SysAllocString( bstrName );
            if ( bstrAddress )
            {
                pInfo->m_bstrAddress = SysAllocString( bstrAddress );
                pInfo->m_bstrOriginalAddress = SysAllocString( bstrAddress );
            }
            if ( bstrUser1 ) pInfo->m_bstrUser1 = SysAllocString( bstrUser1 );
            if ( bstrUser2 ) pInfo->m_bstrUser2 = SysAllocString( bstrUser2 );
            pInfo->m_dwAddressType = dwAddressType;
            pInfo->TranslateAddress();

            // Dialing takes place on separate thread
            DWORD dwID;
            HANDLE hThread = CreateThread(NULL, 0, ThreadDialingProc, (void *) pInfo, NULL, &dwID);
            if ( !hThread )
            {
                hr = er.set_hr( E_UNEXPECTED );
                ATLTRACE(_T(".error.CAVTapi::CreateCall() -- failed to creat the dialing thread.\n") );
                delete pInfo;
            }
            else
            {
                CloseHandle( hThread );
            }
        }
        else
        {
            hr = er.set_hr( E_OUTOFMEMORY );
        }

        pITAddress->Release();
    }

    return hr;
}

STDMETHODIMP CAVTapi::get_Call(long lCallID, IAVTapiCall **ppCall)
{
    *ppCall = NULL;
    *ppCall = FindAVTapiCall( lCallID );    

    return (*ppCall) ? S_OK : E_FAIL;
}


bool CAVTapi::IsPreferredAddress( ITAddress *pITAddress, DWORD dwAddressType )
{
    bool bRet = false;

    CRegKey regKey;
    TCHAR szText[255];
    LoadString( _Module.GetResourceInstance(), IDN_REG_REDIAL_KEY, szText, ARRAYSIZE(szText) );
    regKey.Open( HKEY_CURRENT_USER, szText, KEY_READ );

    DWORD dwPermID = 0, dwAddrID;
    if ( regKey.m_hKey )
    {
        LoadString( _Module.GetResourceInstance(), AddressTypeToRegKey(dwAddressType, true), szText, ARRAYSIZE(szText) );
        regKey.QueryValue( dwPermID, szText );

        if ( dwPermID )
        {
            // Is the call on the preferred address
            LoadString( _Module.GetResourceInstance(), AddressTypeToRegKey(dwAddressType, false), szText, ARRAYSIZE(szText) );
            regKey.QueryValue( dwAddrID, szText );

            long lPreferredPermID = 0, lPreferredAddrID = 0;
            ITAddressCapabilities *pCaps;
            if ( SUCCEEDED(pITAddress->QueryInterface(IID_ITAddressCapabilities, (void **) &pCaps)) )
            {
                pCaps->get_AddressCapability( AC_PERMANENTDEVICEID, &lPreferredPermID );
                pCaps->get_AddressCapability( AC_ADDRESSID, &lPreferredAddrID );
                pCaps->Release();
            }

            bRet = ((DWORD) lPreferredPermID == dwPermID) && ((DWORD) lPreferredAddrID == dwAddrID);
        }
        else
        {
            // If user has not specified a preferred address, use the selected terminals for everything
            bRet = true;
        }
    }

    ATLTRACE(_T(".1.CAVTapi::IsPreferredAddress() returning %d.\n"), bRet );
    return bRet;
}

void CAVTapi::CloseExtraneousCallWindows()
{
    m_critLstAVTapiCalls.Lock();
    if ( m_lstAVTapiCalls.size() >= MAX_CALLWINDOWS )
    {
        AVTAPICALLLIST::iterator i, iEnd = m_lstAVTapiCalls.end();
        for ( i = m_lstAVTapiCalls.begin(); i != iEnd; i++ )
        {
            CALL_STATE callState = CS_IDLE;
            ITCallInfo *pCallInfo;
            if ( SUCCEEDED((*i)->get_ITCallInfo(&pCallInfo)) )
            {
                pCallInfo->get_CallState( &callState );
                pCallInfo->Release();
            }

            // Clear the window slider if it's disconnected
            if ( callState == CS_DISCONNECTED )
            {
                long lCallID = 0;
                (*i)->get_lCallID( &lCallID );

                // Pop out of crit temporarily
                m_critLstAVTapiCalls.Unlock();
                ActionSelected( lCallID, CM_ACTIONS_CLOSE );
                return;
            }
        }
    }

    m_critLstAVTapiCalls.Unlock();
}


STDMETHODIMP CAVTapi::RegisterUser(VARIANT_BOOL bCreate, BSTR bstrServer)
{
    DWORD dwID = 0;

    CPublishUserInfo *pInfo = NULL;
    if ( bstrServer )
    {
        // Allocate user info structure
        pInfo = new CPublishUserInfo();
        if ( !pInfo )
            return E_OUTOFMEMORY;

        // Use the server passed in as an argument
        BSTR bstrTemp = SysAllocString( bstrServer );
        if ( !bstrTemp )
        {
            delete pInfo;
            return E_OUTOFMEMORY;
        }

        // add server to the list
        pInfo->m_lstServers.push_back( bstrTemp );
        pInfo->m_bCreateUser = (bool) (bCreate != 0);
    }

    // If we fail to create the thread clean up appropriately
    HANDLE hThread = CreateThread(NULL, 0, ThreadPublishUserProc, (void *) pInfo, NULL, &dwID);
    if ( !hThread )
    {
        if ( pInfo )
            delete pInfo;

        return E_UNEXPECTED;
    }
    else
    {
        CloseHandle( hThread );
    }

    return (dwID) ? S_OK : E_FAIL;
}

HRESULT CAVTapi::GetSwapHoldCallCandidate( IAVTapiCall *pAVCall, IAVTapiCall **ppAVCandidate )
{
    HRESULT hr = E_FAIL;

    _ASSERT( pAVCall && ppAVCandidate );
    *ppAVCandidate = NULL;

    ITAddress *pITAddress;
    if ( SUCCEEDED(pAVCall->get_ITAddress(&pITAddress)) )
    {
        // Calls on the list
        AVTAPICALLLIST lstCalls;
        GetAllCallsAtState( &lstCalls, CS_HOLD );
        
        AVTAPICALLLIST::iterator i, iEnd = lstCalls.end();
        for ( i = lstCalls.begin(); i != iEnd; i++ )
        {
            ITAddress *pITAddressInd;
            (*i)->get_ITAddress( &pITAddressInd );

            // found a match
            if ( pITAddress == pITAddressInd )
            {
                hr = (*i)->QueryInterface( IID_IAVTapiCall, (void **) ppAVCandidate );
                break;
            }
        }
        
        RELEASE_LIST( lstCalls );

        // Clean-up
        pITAddress->Release();
    }

    return hr;
}

HRESULT CAVTapi::SelectTerminalOnStream( ITStreamControl *pStreamControl,
                                         long lMediaMode,
                                         long nDir,
                                         ITTerminal *pTerminal,
                                         IAVTapiCall *pAVCall )
{
    HRESULT hr;

    IEnumStream *pEnumStreams;
    if ( SUCCEEDED(hr = pStreamControl->EnumerateStreams(&pEnumStreams)) )
    {
        // Loop through streams
        bool bSelectedTerminal = false;
        ITStream *pStream = NULL;

        while ( !bSelectedTerminal && ((hr = pEnumStreams->Next(1, &pStream, NULL)) == S_OK) && pStream )
        {
            long lStreamMediaMode;
            TERMINAL_DIRECTION nStreamDir;

            pStream->get_Direction( &nStreamDir );
            pStream->get_MediaType( &lStreamMediaMode );

            // If the media and direction are correct, select the terminal
            if ( (lMediaMode == lStreamMediaMode) && (nDir == nStreamDir) )
            {
                hr = pStream->SelectTerminal( pTerminal );
                
                if ( SUCCEEDED(hr) )
                {
                    // Preview terminal is a special case
                    TERMINAL_DIRECTION nTermDir = TD_CAPTURE;
                    pTerminal->get_Direction( &nTermDir );
                    if ( (nTermDir == TD_RENDER) && (nDir == TD_CAPTURE) && (lMediaMode == TAPIMEDIATYPE_VIDEO) )
                        pAVCall->put_ITTerminalPreview( pTerminal );
                    else
                        pAVCall->AddTerminal( pTerminal );

                    bSelectedTerminal = true;
                }
            }

            // clean up
            pStream->Release();
            pStream = NULL;
        }

        pEnumStreams->Release();
    }

    return hr;
}

HRESULT CAVTapi::UnselectTerminalOnStream( ITStreamControl *pStreamControl,
                                         long lMediaMode,
                                         long nDir,
                                         ITTerminal *pTerminal,
                                         IAVTapiCall *pAVCall )
{
    HRESULT hr;

    IEnumStream *pEnumStreams;
    if ( SUCCEEDED(hr = pStreamControl->EnumerateStreams(&pEnumStreams)) )
    {
        // Loop through streams
        bool bUnselectedTerminal = false;
        ITStream *pStream = NULL;

        while ( !bUnselectedTerminal && ((hr = pEnumStreams->Next(1, &pStream, NULL)) == S_OK) && pStream )
        {
            long lStreamMediaMode;
            TERMINAL_DIRECTION nStreamDir;

            pStream->get_Direction( &nStreamDir );
            pStream->get_MediaType( &lStreamMediaMode );

            // If the media and direction are correct, select the terminal
            if ( (lMediaMode == lStreamMediaMode) && (nDir == nStreamDir) )
            {
                hr = pStream->UnselectTerminal( pTerminal );
                
                if ( SUCCEEDED(hr) )
                {
                    // Preview terminal is a special case
                    TERMINAL_DIRECTION nTermDir = TD_CAPTURE;
                    pTerminal->get_Direction( &nTermDir );
                    if ( (nTermDir == TD_RENDER) && (nDir == TD_CAPTURE) && (lMediaMode == TAPIMEDIATYPE_VIDEO) )
                    {
                        pAVCall->put_ITTerminalPreview( NULL );
                    }
                    else
                        pAVCall->RemoveTerminal( pTerminal );

                    bUnselectedTerminal = true;
                }
            }

            // clean up
            pStream->Release();
            pStream = NULL;
        }

        pEnumStreams->Release();
    }

    return hr;
}

STDMETHODIMP CAVTapi::SendUserUserInfo(long lCallID, BYTE * pBuf, DWORD dwSizeBuf)
{
    ATLTRACE(_T(".enter.CAVTapiCall::SendUserUserInfo(call=%ld, size=%ld).\n"), lCallID, dwSizeBuf );

    IAVTapiCall *pAVCall = FindAVTapiCall( lCallID );
    if ( pAVCall )
    {
        ITCallInfo *pCallInfo;
        if ( SUCCEEDED(pAVCall->get_ITCallInfo(&pCallInfo)) )
        {
            pCallInfo->SetCallInfoBuffer( CIB_USERUSERINFO, dwSizeBuf, pBuf );
            pCallInfo->Release();
        }
        pAVCall->Release();
    }

    return E_NOTIMPL;
}

STDMETHODIMP CAVTapi::CreateDataCall(long lCallID, BSTR bstrName, BSTR bstrAddress, BYTE *pBuf, DWORD dwBufSize )
{
    USES_CONVERSION;
    ATLTRACE(_T(".enter.CAVTapi::CreateDataCall().\n"));
    _ASSERT( lCallID && bstrAddress && pBuf && (dwBufSize > 0) );

    HRESULT hr = E_POINTER;

    CErrorInfo er;
    er.set_Operation( IDS_ER_PLACECALL );
    er.set_Details( IDS_ER_GET_ADDRESS );

    ITAddress *pITAddress;
    if ( bstrAddress && SUCCEEDED(hr = er.set_hr(GetAddress(LINEADDRESSTYPE_IPADDRESS, false, &pITAddress))) )
    {
        // Setup dialing info to pass to dialing thread
        er.set_Details( IDS_ER_CREATE_THREAD );

        CThreadDialingInfo *pThreadInfo = new CThreadDialingInfo;
        if ( pThreadInfo )
        {
            // Store information in dialing structure
            pThreadInfo->set_ITAddress( pITAddress );

            if ( bstrName ) pThreadInfo->m_bstrName = SysAllocString( bstrName );
            SysReAllocString( &pThreadInfo->m_bstrAddress, bstrAddress );
            pThreadInfo->m_dwAddressType = LINEADDRESSTYPE_IPADDRESS;
            pThreadInfo->m_nCallType = AV_DATA_CALL;
            pThreadInfo->m_lCallID = lCallID;
            pThreadInfo->TranslateAddress();

            // Get first user-user data ready to send to remote party
            HGLOBAL hMem = GlobalAlloc( GMEM_MOVEABLE | GMEM_DISCARDABLE, dwBufSize );
            if ( hMem )
            {
                void *pbUU = GlobalLock( hMem );
                if ( pbUU )
                {
                    // Get user to user info
                    memcpy( pbUU, pBuf, dwBufSize);
                    GlobalUnlock( hMem );
                }

                pThreadInfo->m_hMem = hMem;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }


            // Dialing takes place on separate thread
            DWORD dwID;
            HANDLE hThread = NULL;
            if ( SUCCEEDED(hr) )
            {
                hThread = CreateThread( NULL, 0, ThreadDialingProc, (void *) pThreadInfo, NULL, &dwID );
                if ( hThread ) CloseHandle( hThread );
            }

            if ( FAILED(hr) || !hThread )
            {
                hr = er.set_hr( E_UNEXPECTED );
                ATLTRACE(_T(".error.CAVTapi::CreateCall() -- failed to create the dialing thread.\n") );
                delete pThreadInfo;
            }
        }
        else
        {
            hr = er.set_hr( E_OUTOFMEMORY );
        }

        pITAddress->Release();
    }

    return hr;
}

STDMETHODIMP CAVTapi::FindAVTapiCallFromCallID(long lCallID, IAVTapiCall * * ppAVCall)
{
    *ppAVCall = FindAVTapiCall( lCallID );
    return (*ppAVCall) ? S_OK : E_FAIL;
}

STDMETHODIMP CAVTapi::get_bstrDefaultServer(BSTR * pVal)
{
    _ASSERT( pVal );
    *pVal = NULL;

    Lock();
    HRESULT hr = SysReAllocString( pVal, m_bstrDefaultServer );
    Unlock();

    return hr;
}

STDMETHODIMP CAVTapi::put_bstrDefaultServer(BSTR newVal)
{
    HRESULT hr = S_OK;

// Don't want this checked in
#ifdef _USE_DEFAULTSERVER
    Lock();
    if ( !newVal || (SysStringLen(newVal) == 0) )
    {
        SysFreeString( m_bstrDefaultServer );
        m_bstrDefaultServer = NULL;
    }
    else 
    {
        hr = SysReAllocString( &m_bstrDefaultServer, newVal );
    }
    Unlock();
#endif

    return hr;
}

STDMETHODIMP CAVTapi::get_bAutoCloseCalls(VARIANT_BOOL * pVal)
{
    Lock();
    *pVal = (VARIANT_BOOL) (m_bAutoCloseCalls != false);
    Unlock();

    return S_OK;
}

STDMETHODIMP CAVTapi::put_bAutoCloseCalls(VARIANT_BOOL newVal)
{
    Lock();
    m_bAutoCloseCalls = (newVal != FALSE);
    Unlock();

    return S_OK;
}

/*++
USBFindPhone

Try to find out if there is an USBPhone
The critical section should be lock outsite
--*/
HRESULT CAVTapi::USBFindPhone(
    OUT ITPhone** ppUSBPhone
    )
{
    _ASSERT(ppUSBPhone);
    _ASSERT(m_pITTapi);

    //
    //Critical section
    //

    m_critUSBPhone.Lock();

    //
    // Don't return garbage
    //

    *ppUSBPhone = NULL;

    //
    // Get the H323 address
    //

    ITAddress2* pH323Address = NULL;
    HRESULT hr = E_FAIL;

    hr = USBGetH323Address(&pH323Address);
    if( FAILED(hr) )
    {
        m_critUSBPhone.Unlock();
        return hr;
    }

    //
    // Get the phone object if on this address is
    // someone
    //

    ITPhone* pPhone = NULL;
    hr = USBGetPhoneFromAddress(
        pH323Address,
        &pPhone
        );

    //
    // Clean-up pH32Address
    //

    pH323Address->Release();

    //
    // We failed to get a phone object on
    // H323 address
    //

    if( FAILED(hr) )
    {
        m_critUSBPhone.Unlock();
        return hr;
    }

    //
    // Initialize the phone
    //

    hr = USBPhoneInitialize(
        pPhone );

    if( FAILED(hr) )
    {
        //
        // Clean-up the phone object
        //

        pPhone->Release();

        m_critUSBPhone.Unlock();
        return hr;
    }

    //
    // Set the phone
    //
    *ppUSBPhone = pPhone;
    m_critUSBPhone.Unlock();
    return S_OK;
}

/*++
USBIsPresent

Determine if the USBPhone was detected
--*/
STDMETHODIMP CAVTapi::USBIsPresent(
    OUT BOOL* pVal
    )
{
    _ASSERT( pVal );

    m_critUSBPhone.Lock();

    *pVal = (NULL != m_pUSBPhone);

    m_critUSBPhone.Unlock();
    return S_OK;
}

/*++
USBGetDefaultUse

Returns the value for "Audio/Video" checkbox
--*/
STDMETHODIMP CAVTapi::USBGetDefaultUse(
    OUT BOOL* pVal
    )
{
    _ASSERT( pVal );

    if( NULL == m_pUSBPhone )
    {
        *pVal = FALSE;
        return S_OK;
    }

    *pVal = USBGetCheckboxValue();
    return S_OK;
}

/*++
USBNewPhone

Is called by CTapiNotification::Address_Event when
an AE_NEWPHONE is fired
--*/
STDMETHODIMP CAVTapi::USBNewPhone( 
    IN  ITPhone* pPhone
    )
{
    // Critical Section
    m_critUSBPhone.Lock();

    if( NULL != m_pUSBPhone)
    {
        //
        // we already have a phone
        // sorry, we don't support two phone objects
        //

        m_critUSBPhone.Unlock();
        return S_OK;

    }

    //
    // Validates argument
    //

    if( pPhone == NULL)
    {
        m_critUSBPhone.Unlock();
        return E_INVALIDARG;
    }

    //
    // Determine if the phone is a real one
    // has a H323 address
    //
    IEnumAddress* pAddresses = NULL;
    HRESULT hr = pPhone->EnumerateAddresses( &pAddresses );
    if( FAILED(hr) )
    {
        m_critUSBPhone.Unlock();
        return hr;
    }

    //
    // Go to each address to see if we have
    // a H323 one
    //

    ITAddress* pAddress = NULL;
    ULONG uFetched = 0;
    BOOL bHasH323Address = FALSE;

    while( S_OK == pAddresses->Next(1, &pAddress, &uFetched))
    {
        if( USBIsH323Address( pAddress ) )
        {
            bHasH323Address = TRUE;
            pAddress->Release();
            break;
        }

        //
        // Clean-up
        //

        pAddress->Release();
    }

    //
    // Clean-up enumeration
    //
    pAddresses->Release();

    //
    // Phone object supports H323 address?
    //
    if( !bHasH323Address )
    {        
        m_critUSBPhone.Unlock();
        return E_FAIL;
    }

    //
    // Initialize the phone object
    //

    hr = USBPhoneInitialize(
        pPhone);

    if( FAILED(hr) )
    {
        m_critUSBPhone.Unlock();
        return hr;
    }

    //
    // Set the new phone object
    //

    m_pUSBPhone = pPhone;
    m_pUSBPhone->AddRef();

    //
    // Set the registry value
    //

    USBSetCheckboxValue( TRUE );

    m_critUSBPhone.Unlock();
    return S_OK;
}

/*++
USBRemovePhone

Is called by CTapiNotification::Address_Event when
an AE_REMOVEPHONE is fired
--*/
STDMETHODIMP CAVTapi::USBRemovePhone(
    IN  ITPhone* pPhone
    )
{
    // Critical Section
    m_critUSBPhone.Lock();

    //
    // If we don't have a phone 
    // bad luck
    //

    if( NULL == m_pUSBPhone )
    {
        m_critUSBPhone.Unlock();
        return S_OK;
    }

    //
    // Validates argument
    //

    if( pPhone == NULL)
    {
        m_critUSBPhone.Unlock();
        return E_INVALIDARG;
    }

    //
    // Are the same phone?
    // We use the IUnknow interface to
    // see if they are identical
    //

    //
    // Get IUnknown interface for existing phone object
    //
    IUnknown* pUSBUnk = NULL;

    HRESULT hr = m_pUSBPhone->QueryInterface(IID_IUnknown, (void**)&pUSBUnk);
    if( FAILED(hr) )
    {
        m_critUSBPhone.Unlock();
        return hr;
    }

    //
    // Get IUnknown interface for removed phone
    //
    IUnknown* pRemUnk = NULL;
    hr = pPhone->QueryInterface(IID_IUnknown, (void**)&pRemUnk);
    if( FAILED(hr) )
    {
        pUSBUnk->Release();
        m_critUSBPhone.Unlock();
        return hr;
    }

    //
    // Let's compare the two interfaces
    //

    if( pUSBUnk == pRemUnk )
    {
        m_pUSBPhone->Close();
        USBRegDelTerminals();
        m_pUSBPhone->Release();
        m_pUSBPhone = NULL;

        if( m_bstrUSBCaptureTerm )
        {
            SysFreeString( m_bstrUSBCaptureTerm );
            m_bstrUSBCaptureTerm = NULL;
        }

        if( m_bstrUSBRenderTerm )
        {
            SysFreeString( m_bstrUSBRenderTerm );
            m_bstrUSBRenderTerm = NULL;
        }

        //
        // If there are some calls destroy them,
        // as cleany is possible
        //

        HWND hWnd = NULL;
        get_hWndParent( &hWnd );

        if( ::IsWindow(hWnd) )
        {
            RELEASE_CRITLIST(m_lstAVTapiCalls, m_critLstAVTapiCalls);
            ::SendMessage( hWnd, WM_USBPHONE, AVUSB_CANCELCALL, 0);
        }
    }

    //
    // Set registry value on FALSE
    //

    USBSetCheckboxValue( FALSE );

    //
    // Clean-up the IUnknown interfaces
    //
    pUSBUnk->Release();
    pRemUnk->Release();


    m_critUSBPhone.Unlock();
    return S_OK;
}

/*++
USBCancellCall

Is called by CTapiNotification::Phone_Event when 
a PE_HOOKSWITCH (hhok state is PHSS_ONHOOK) is
fired
--*/
HRESULT CAVTapi::USBCancellCall( )
{
    // Critical Section
    m_critUSBPhone.Lock();

    // We don't have USB phone
    if( m_pUSBPhone == NULL)
    {
        m_critUSBPhone.Unlock();
        return S_OK;
    }

    // We don't have the dialog
    if( NULL == m_pDlgCall )
    {
        m_critUSBPhone.Unlock();
        return S_OK;
    }

    // Delete the dialog box
    if( ::IsWindow(m_pDlgCall->m_hWnd))
    {
        ::SendMessage(m_pDlgCall->m_hWnd, WM_CLOSE, 0, 0);
    }

    m_critUSBPhone.Unlock();
    return S_OK;
}

/*++
USBMakeCall

Is called by CTapiNotification::Phone_Event when 
a PE_HOOKSWITCH (hhok state is PHSS_OFFHOOK) is
fired
--*/
HRESULT CAVTapi::USBMakeCall()
{
    m_critUSBPhone.Lock();

    if( NULL == m_pUSBPhone )
    {
        m_critUSBPhone.Unlock();
        return S_OK;
    }

    //
    // Get the IAutomatedPhoneControl interface
    //

    ITAutomatedPhoneControl* pAutomated = NULL;
    HRESULT hr = E_FAIL;

    hr = m_pUSBPhone->QueryInterface(
        IID_ITAutomatedPhoneControl,
        (void**)&pAutomated
        );

    //
    // Try to see if we are already into a call
    // If are 'offering calls' then we tre to
    // answer to these calls
    //
    if( SUCCEEDED(hr) )
    {
        //
        // Enumerate the calls
        //
        HRESULT hr = E_FAIL;
        IEnumCall* pCalls = NULL;
        hr= pAutomated->EnumerateSelectedCalls(&pCalls);

        //
        // Clean up
        //
        pAutomated->Release();

        //
        // Are there a selected call ?
        //

        bool bCallsSelected = false;
        ULONG cFetched = 0;
        ITCallInfo* pCallInfo = NULL;

        while( S_OK == pCalls->Next(1, &pCallInfo, &cFetched))
        {
            bCallsSelected = true;

            // Get the call state
            CALL_STATE callState = CS_IDLE;
            pCallInfo->get_CallState( &callState );

            if(callState != CS_OFFERING)
            {
                pCallInfo->Release();
                pCallInfo = NULL;
            }

            //
            // Just one call could be selected 
            // on phone object
            //
            break;
        }

        // Clean-up
        pCalls->Release();

        if( bCallsSelected )
        {
            //
            // We are into a call
            //
            if( pCallInfo )
            {
                //
                // We are into an offering call
                // We should simultate the CreateTerminalArray
                //

                IAVTapiCall* pAVTapiCall = NULL;
                FindAVTapiCallFromCallInfo( pCallInfo, &pAVTapiCall);

                if( pAVTapiCall )
                {
                    ITAddress* pAddress = NULL;
                    pCallInfo->get_Address( &pAddress );

                    if( pAddress )
                    {
                        CreateTerminalArray( pAddress, pAVTapiCall, pCallInfo);

                        // Clean-up
                        pAddress->Release();
                    }

                    // Clean-up
                    pAVTapiCall->Release();
                }

                // Clean-up
                pCallInfo->Release();
            }

            m_critUSBPhone.Unlock();
            return S_OK;
        }
    }

    HWND hWnd = NULL;
    get_hWndParent( &hWnd );

    if( ::IsWindow(hWnd) && (m_pDlgCall == NULL) )
    {
        ::SendMessage( hWnd, WM_USBPHONE, AVUSB_MAKECALL, 0);
    }

    m_critUSBPhone.Unlock();
    return S_OK;
}

/*++
USBKeyPress

Is called from CTapiNotification::Phone_Event
when a PE_BUTTON or PE_NUMBERGATHERED is fired
from the phone
--*/
HRESULT CAVTapi::USBKeyPress(long lButton)
{
    m_critUSBPhone.Lock();

    if( NULL == m_pUSBPhone )
    {
        m_critUSBPhone.Unlock();
        return S_OK;
    }

    //
    // If the PlaceCall dialog is not pop-up
    // then we send this key as DTMF tones
    // If the PlaceCall dialog is pop-up
    // then this key should be add to the
    // 'PhoneNumber' editbox into PlaceCall dialog
    //

    if( NULL == m_pDlgCall )
    {
        if( (0<= lButton) && (lButton <=11) )
        {
            //
            // There are calls on this phone
            // If yes, send DTMFs
            //

            ITAutomatedPhoneControl* pAutomated;
            IEnumCall* pCalls = NULL;
            HRESULT hr = E_FAIL;

            hr = m_pUSBPhone->QueryInterface(
                IID_ITAutomatedPhoneControl, (void**)&pAutomated);
            if( FAILED(hr) )
            {
                m_critUSBPhone.Unlock();
                return hr;
            }

            hr = pAutomated->EnumerateSelectedCalls( &pCalls );
            if( FAILED(hr) )
            {
                pAutomated->Release();
                m_critUSBPhone.Unlock();
                return hr;
            }

            pAutomated->Release(); //Clean-up

            // Enumerate the calls
            ITCallInfo* pCall = NULL;
            ULONG cFetched = 0;
            while( S_OK == pCalls->Next(1, &pCall, &cFetched) )
            {
                // Get the ITBasiccallControl
                ITBasicCallControl* pControl = NULL;
                hr = pCall->QueryInterface(
                    IID_ITBasicCallControl, 
                    (void**)&pControl
                    );

                if( SUCCEEDED(hr) )
                {
                    // Get AVCall
                    IAVTapiCall *pAVCall = FindAVTapiCall( pControl );
                    if( pAVCall )
                    {
                        // Get the Call ID
                        long lCallID = 0;
                        pAVCall->get_lCallID( &lCallID );

                        // Call DigitPrees for this call
                        if( (0 <= lButton) && (lButton <= 11))
                        {
                            //
                            // Digit Press
                            PhonePadKey PPKey = PP_DTMF_0;
                            BOOL bDtmf = TRUE;
                            switch( lButton )
                            {
                            case 0: PPKey = PP_DTMF_0; break;
                            case 1: PPKey = PP_DTMF_1; break;
                            case 2: PPKey = PP_DTMF_2; break;
                            case 3: PPKey = PP_DTMF_3; break;
                            case 4: PPKey = PP_DTMF_4; break;
                            case 5: PPKey = PP_DTMF_5; break;
                            case 6: PPKey = PP_DTMF_6; break;
                            case 7: PPKey = PP_DTMF_7; break;
                            case 8: PPKey = PP_DTMF_8; break;
                            case 9: PPKey = PP_DTMF_9; break;
                            case 10: PPKey = PP_DTMF_STAR; break;
                            case 11: PPKey = PP_DTMF_POUND; break;
                            default: bDtmf = FALSE; break;
                            }

                            if( bDtmf )
                            {
                                DigitPress( lCallID, PPKey);
                            }
                        }

                        // Release the pAVCall
                        pAVCall->Release();
                    }

                    // Clean-up
                    pControl->Release();
                }


                // Clean-up
                pCall->Release();
            }

            // Clean-up
            pCalls->Release();
        }
        else
        {
            // Determine the button function
            PHONE_BUTTON_FUNCTION nFunction;
            if( SUCCEEDED(m_pUSBPhone->get_ButtonFunction(lButton, &nFunction)) )
            {
                if( nFunction == PBF_LASTNUM )
                {
                    //
                    // Redial
                    //

                    HWND hWnd = NULL;
                    get_hWndParent( &hWnd );

                    if( ::IsWindow(hWnd) && (m_pDlgCall == NULL) )
                    {
                        ::SendMessage( hWnd, WM_USBPHONE, AVUSB_REDIAL, 0);
                    }
                }
            } // Succeeded
        } 
    }
    else
    {
        // The Dial Dialog is opened, so show the digit
        // in the edit control
        m_pDlgCall->KeyPress( lButton );
    }

    m_critUSBPhone.Unlock();
    return S_OK;
}

/*++
USBOffering

Is called by CAVTapi::fire_SetCallState when the call state
is CS_OFFERING (incoming calls)
--*/
HRESULT CAVTapi::USBOffering(
    IN  ITCallInfo* pCallInfo
    )
{
    m_critUSBPhone.Lock();

    //
    // Incoming call
    //

    HRESULT hr = S_OK;

    if( NULL == m_pUSBPhone)
    {
        m_critUSBPhone.Unlock();
        return S_OK;
    }

    //
    // Validate the USB checkbox value
    //
    BOOL bUSBCheckbox = FALSE;
    bUSBCheckbox = USBGetCheckboxValue();
    if( !bUSBCheckbox )
    {
        m_critUSBPhone.Unlock();
        return S_OK;
    }

    //
    // Get the state of hook
    //
    PHONE_HOOK_SWITCH_STATE HookState = PHSS_OFFHOOK;
    hr = m_pUSBPhone->get_HookSwitchState( PHSD_HANDSET, &HookState);
    if( FAILED(hr) )
    {
        //
        // Something wrong
        // Go ahead and handle the call into common way
        //

        m_critUSBPhone.Unlock();
        return hr;
    }

    if( HookState == PHSS_OFFHOOK )
    {
        //
        // We are really busy
        // Reject the call
        //

        ITBasicCallControl* pCallControl = NULL;
        hr = pCallInfo->QueryInterface( 
            IID_ITBasicCallControl,
            (void**)&pCallControl
            );

        if( FAILED(hr) )
        {
            // This is really bad
            m_critUSBPhone.Unlock();
            return E_FAIL;
        }

        pCallControl->Disconnect(DC_REJECTED);
        pCallControl->Release();

        m_critUSBPhone.Unlock();
        return S_OK;
    }

    //
    // OK let's ring
    //
    ITAutomatedPhoneControl* pAutomated = NULL;
    hr = m_pUSBPhone->QueryInterface(
        IID_ITAutomatedPhoneControl,
        (void**)&pAutomated
        );

    if( FAILED(hr) )
    {
        m_critUSBPhone.Unlock();
        return hr;
    }

    //
    // Select call
    //
    
    VARIANT_BOOL varSelectDefault = VARIANT_TRUE;
    varSelectDefault = USBGetCheckboxValue() ? VARIANT_TRUE : VARIANT_FALSE;

    hr = pAutomated->SelectCall(
        pCallInfo,
        varSelectDefault
        );

    // Clean-up
    pAutomated->Release();


    if( FAILED(hr) )
    {
        // Hmmm! This is a problem
        // Anyway, go ahead and handle the call
        //

        m_critUSBPhone.Unlock();
        return S_OK;
    }

    m_critUSBPhone.Unlock();
    return S_OK;
}

/*++
USBDisconnected

Is called by CAVTapi::fire_SetCallState when the call state
is CS_DISCONECTED (outgoing/incoming calls)
--*/
HRESULT CAVTapi::USBDisconnected(
    IN  long lCallID)
{

    // Critical Section
    m_critUSBPhone.Lock();

    HRESULT hr = S_OK;

    //
    // We are have an UPBPhone
    // 

    if( NULL == m_pUSBPhone)
    {
        m_critUSBPhone.Unlock();
        return S_OK;
    }

    m_critUSBPhone.Unlock();
    hr = fire_CloseCallControl(lCallID);
    return hr;
}

/*++
USBTakeCallEnabled

Is called by AVDialer to determine if 'Take call' button
should be enabled or not
--*/
HRESULT CAVTapi::USBTakeCallEnabled(
    OUT BOOL* pEnabled
    )
{
    // Critical Section
    m_critUSBPhone.Lock();

    //
    // Get the checkbox value
    //

    BOOL bCheckboxValue = USBGetCheckboxValue();
    if( !bCheckboxValue )
    {
        //
        // The Dialer should work as the phone is not
        // present, so the Take Call button should be enabled
        // always in this case
        //

        *pEnabled = TRUE;
        m_critUSBPhone.Unlock();
        return S_OK;
    }

    //
    // Validate argument
    //
    if( IsBadWritePtr( pEnabled, sizeof( BOOL )) )
    {
        m_critUSBPhone.Unlock();
        return E_POINTER;
    }

    //
    // Have we an USBPhone
    //

    if( NULL == m_pUSBPhone )
    {
        *pEnabled = TRUE;
        m_critUSBPhone.Unlock();
        return S_OK;
    }

    //
    // Does phone support Speakers?
    //

    long lCaps = 0;
    HRESULT hr = E_FAIL;

    // Get the caps
    hr = m_pUSBPhone->get_PhoneCapsLong(
        PCL_HOOKSWITCHES,
        &lCaps);

    if( FAILED(hr) )
    {
        *pEnabled = FALSE;
        m_critUSBPhone.Unlock();
        return E_FAIL;
    }

    // Supports the speakerphone
    if( lCaps & ((long)PHSD_SPEAKERPHONE))
    {
        *pEnabled = TRUE;
    }
    else
    {
        *pEnabled = FALSE;
    }

    m_critUSBPhone.Unlock();
    return S_OK;
}

/*++
USBGetCheckboxValue

Goes to registry and read the value for USB checkbox from
'Options' property page
Is called from USBOffering
--*/
BOOL  CAVTapi::USBGetCheckboxValue(
    IN  BOOL bVerifyUSB /*TRUE*/
    )
{
    //
    // Have we USBPhone present?
    //
    if( bVerifyUSB && (NULL == m_pUSBPhone))
    {
        // No Always, even was seted before
        return FALSE;
    }

    //
    // Read the registry for the previous 
    // setting for USB Phone
    //

    TCHAR szText[255], szType[255];
    LoadString( _Module.GetResourceInstance(), IDN_REG_REDIAL_KEY, szText, ARRAYSIZE(szText) );

    CRegKey regKey;
    if( regKey.Open( HKEY_CURRENT_USER, szText, KEY_READ )!= ERROR_SUCCESS)
    {
        return FALSE;
    };

    //
    // Read data
    //

    DWORD dwValue = 0;
    LoadString( _Module.GetResourceInstance(), IDN_REG_REDIAL_USBALWAYS, szType, ARRAYSIZE(szType) );
    if( regKey.QueryValue(dwValue, szType) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    return (BOOL)dwValue;
}

/*++
USBSetCheckboxValue

  Is called by USBNewPhone. Sets the registry value
  for the USB checkbox in 'Options' dialog,
  also is called bt USBremovePhone
--*/
HRESULT CAVTapi::USBSetCheckboxValue(
    IN  BOOL    bCheckValue
    )
{
    //
    // Set the entries in registry
    //
	CRegKey regKey;
    TCHAR szText[255], szType[255];

	LoadString( _Module.GetResourceInstance(), IDN_REG_REDIAL_KEY, szText, ARRAYSIZE(szText) );
	LoadString( _Module.GetResourceInstance(), IDN_REG_REDIAL_USBALWAYS, szType, ARRAYSIZE(szType) );

    if( regKey.Create( HKEY_CURRENT_USER, szText) != ERROR_SUCCESS)
    {
        return E_FAIL;
    }

    // Set the value
    if( regKey.SetValue((DWORD)bCheckValue, szType) != ERROR_SUCCESS)
    {
        return E_FAIL;
    }

    return S_OK;
}


/*++
USBInprogress

Is called by CAVTapi::fire_SetCallState when the call state
is CS_INPROGRESS (outgoing calls)
--*/
HRESULT CAVTapi::USBInprogress( 
    IN  ITCallInfo* pCallInfo
    )
{
    // Critical section
    m_critUSBPhone.Lock();

    //
    // Outgoing call
    //

    HRESULT hr = S_OK;

    if( NULL == m_pUSBPhone)
    {
        m_critUSBPhone.Unlock();
        return S_OK;
    }

    //
    // Validate the USB checkbox value
    //
    BOOL bUSBCheckbox = FALSE;
    bUSBCheckbox = USBGetCheckboxValue();
    if( !bUSBCheckbox )
    {
        m_critUSBPhone.Unlock();
        return S_OK;
    }


    //
    // OK let's ring
    //

    ITAutomatedPhoneControl* pAutomated = NULL;
    hr = m_pUSBPhone->QueryInterface(
        IID_ITAutomatedPhoneControl,
        (void**)&pAutomated
        );

    if( FAILED(hr) )
    {
        m_critUSBPhone.Unlock();
        return hr;
    }

    //
    // Select call
    //
    
    VARIANT_BOOL varSelectDefault = VARIANT_TRUE;
    varSelectDefault = USBGetCheckboxValue() ? VARIANT_TRUE : VARIANT_FALSE;

    hr = pAutomated->SelectCall(
        pCallInfo,
        varSelectDefault
        );

    // Clean-up
    pAutomated->Release();

    if( FAILED(hr) )
    {
        //
        // Hmmm! This is a problem
        // Anyway, go ahead and handle the call
        //

        m_critUSBPhone.Unlock();
        return S_OK;
    }

    m_critUSBPhone.Unlock();
    return S_OK;
}

/*++
USBIsH323Address

Detects if the address is a H323 one,
is called by  USBFindPhone.
we don't need critical section is seted when
USBFindPhone was called
--*/
BOOL CAVTapi::USBIsH323Address(
    IN    ITAddress* pAddress)
{
    _ASSERTE( pAddress );

    //
    // Get ITAddressCapabilities
    //

    ITAddressCapabilities* pCap = NULL;
    HRESULT hr = E_FAIL;

    hr = pAddress->QueryInterface(
        IID_ITAddressCapabilities,
        (void**)&pCap
        );

    if( FAILED(hr) )
    {
        // Bad luck
        return FALSE;
    }

    //
    // Determine the propocol
    //

    BSTR bstrProtocol = NULL;
    hr = pCap->get_AddressCapabilityString(
        ACS_PROTOCOL,
        &bstrProtocol
        );

    // Clean-up
    pCap->Release();

    if( FAILED(hr) )
    {
        // Bad luck
        return FALSE;
    }

    //
    // Get the CLSID for the protocol
    //

    CLSID clsid;
    hr = CLSIDFromString( bstrProtocol, &clsid);
    SysFreeString( bstrProtocol );

    if( FAILED(hr) )
    {
        // Somebody try to make a joke!
        return FALSE;
    }

    if( TAPIPROTOCOL_H323 != clsid)
    {
        // It's someting different
        return FALSE;
    }
    
    return TRUE;
}

/*++
USBGetH323Address

Returns a H323 address if exists someone
Else returns E_FAIL. It is called by USBFindPhone()
method
--*/
HRESULT CAVTapi::USBGetH323Address(
    OUT ITAddress2** ppAddress2
    )
{
    //
    // We should have Tapi object
    //

    if( NULL == m_pITTapi )
    {
        return E_FAIL;
    }

    //
    // set on NULL just in case
    //

    *ppAddress2 = NULL;

    //
    // Enumerate the addresses
    //

    IEnumAddress* pAddresses = NULL;
    HRESULT hr = E_FAIL;
    
    hr = m_pITTapi->EnumerateAddresses(&pAddresses);
    if( FAILED(hr) )
    {
        return hr;
    }

    //
    // Parse the enumeration
    //

    ITAddress* pAddress = NULL;
    ULONG cFetched = 0;

    while( pAddresses->Next(1, &pAddress, &cFetched) == S_OK)
    {
        //
        // Is it a H323 address?
        //

        BOOL bH323 = USBIsH323Address( pAddress );
        if( !bH323 )
        {
            //
            // Clean-up and go to next address
            //

            pAddress->Release();
            pAddress = NULL;

            continue;
        }

        //
        // OK, we got the H323 address
        // we break the loop, we keep pAddress
        // and release it later

        break;

    }

    //
    // Clean-up the addresses enumeration
    //

    pAddresses->Release();

    //
    // Did we find a H323 address?
    //

    if( NULL == pAddress )
    {
        //
        // No, there is no H323 address
        // the *ppAddress2 was already set on NULL
        //

        return E_FAIL;
    }

    //
    // We got an H323 address
    // so we need to get ITAddress2 interface
    //

    hr = pAddress->QueryInterface(
        IID_ITAddress2, 
        (void**)ppAddress2
        );

    //
    // Clean-up pAddress
    //

    pAddress->Release();

    //
    // That's all, return the hr
    //

    return hr;
}

/*++
USBGetPhoneFromAddress

  Returns the ITPhone object on this address
  if a phone object exists. It is called by
  USBFindPhone.
--*/
HRESULT CAVTapi::USBGetPhoneFromAddress(
    IN  ITAddress2* pAddress,
    OUT ITPhone**   ppPhone
    )
{
    //
    // Enumerate the phones
    //

    IEnumPhone* pPhones = NULL;
    HRESULT hr = pAddress->EnumeratePhones(&pPhones);
    if( FAILED(hr) )
    {
        return hr;
    }

    //
    // Parse the phones enumeration and try to find out
    // if we have a Phone object. For this we should
    // enumerate the terminals and find out if the phone
    // supports both audio terminals: capture and render
    //

    ITPhone* pPhone = NULL;
    ULONG cPhoneFetched = 0;
    while( pPhones->Next(1, &pPhone, &cPhoneFetched) == S_OK)
    {
        //
        // Enumerate terminals
        //
        IEnumTerminal* pTerminals = NULL;
        hr = pPhone->EnumerateTerminals(pAddress, &pTerminals);
        if( FAILED(hr) )
        {
            pPhone->Release();
            pPhone = NULL;
            continue; // Go to another phone object
        }

        //
        // The phone should support both audio
        // terminals: capture & render
        //

        BOOL bCapture = FALSE;
        BOOL bRender = FALSE;

        //
        // Parse terminals enumeration
        //
        ITTerminal* pTerminal = NULL;
        ULONG cTermFetched = 0;
        BSTR bstrCapture = NULL;
        BSTR bstrRender = NULL;

        while( pTerminals->Next(1, &pTerminal, &cTermFetched) == S_OK)
        {
            //Get direction
            TERMINAL_DIRECTION Dir;
            hr = pTerminal->get_Direction(&Dir);
            if( SUCCEEDED(hr) )
            {
                // Capture?
                if( TD_CAPTURE == Dir )
                {
                    // Clean-up
                    if( bstrCapture )
                    {
                        SysFreeString( bstrCapture );
                        bstrCapture = NULL;
                    }

                    // Get terminal name
                    pTerminal->get_Name( &bstrCapture );
                    bCapture = TRUE;
                } else if( TD_RENDER == Dir )
                {
                    if( bstrRender )
                    {
                        SysFreeString( bstrRender );
                        bstrRender = NULL;
                    }
                    pTerminal->get_Name( &bstrRender );
                    bRender = TRUE;
                }
            }

            //
            // Clean-up terminal
            //
            pTerminal->Release();
        }

        //
        // Clean-up terminals
        //
        pTerminals->Release();

        //
        // The phone should support both directions
        //
        if( bCapture && bRender )
        {
            //
            // We keep the reference to pPhone
            // We'll release this reference later
            //
            *ppPhone = pPhone;

            //
            // Save the terminals names
            //

            m_bstrUSBCaptureTerm = SysAllocString(bstrCapture);
            m_bstrUSBRenderTerm = SysAllocString(bstrRender);

            //
            // Clean-up
            //
            if( bstrCapture )
            {
                SysFreeString( bstrCapture );
                bstrCapture = NULL;
            }

            if( bstrRender )
            {
                SysFreeString( bstrRender );
                bstrRender = NULL;
            }
            break;
        }

        // Clean-up
        pPhone->Release();
        pPhone = NULL;

        if( bstrCapture )
        {
            SysFreeString( bstrCapture );
            bstrCapture = NULL;
        }
        if( bstrRender )
        {
            SysFreeString( bstrRender );
            bstrRender = NULL;
        }
    }

    //
    // Clean-up the phones enumeration
    //

    pPhones->Release();

    return (pPhone != NULL) ? S_OK : E_FAIL;
}

/*++
USBPhoneInitialize

  Initialize (open, set handling on true)
  the phone object.
  Is called by USBFindPhone
--*/
HRESULT CAVTapi::USBPhoneInitialize(
    IN  ITPhone* pPhone
    )
{
    //
    // Get the registry value
    //

    BOOL bUSBEnabled = USBGetCheckboxValue(FALSE);

    //
    // Open the Phone
    //
    if( !bUSBEnabled )
    {
        return S_OK;
    }

    //
    // Error object
    //
    CErrorInfo er;
    er.set_Operation( IDS_ER_USB );
    er.set_Details( IDS_ER_USB_OPEN );
    HRESULT hr = pPhone->Open( PP_OWNER );
    er.set_hr( hr );

    if( FAILED(hr) )
    {
        USBSetCheckboxValue( FALSE );
        m_bUSBOpened = FALSE;
        return S_FALSE;
    }

    //
    // MArk as opened
    //

    m_bUSBOpened = TRUE;

    //
    // Set the registry with the handset terminals
    //
    USBRegPutTerminals();

    //
    // Get the ITAutomatedPhoneControl interface
    //

    er.set_hr( S_OK );
    er.set_Details( IDS_ER_USB_INITIALIZE );

    ITAutomatedPhoneControl* pAutomated = NULL;
    hr = pPhone->QueryInterface(
        IID_ITAutomatedPhoneControl, (void**)&pAutomated);
    er.set_hr( hr );

    if( FAILED(hr) )
    {
        USBSetCheckboxValue( FALSE );
        m_bUSBOpened = FALSE;
        pPhone->Close();
        return hr;
    }

    //
    // Set on true Phone handling
    //

    hr = pAutomated->put_PhoneHandlingEnabled(VARIANT_TRUE);
    er.set_hr( hr );
    if( FAILED(hr) )
    {
        USBSetCheckboxValue( FALSE );
        m_bUSBOpened = FALSE;
        pAutomated->Release();
        pPhone->Close();
        return hr;
    }

    //
    // Clean-up
    // 
    pAutomated->Release();
    return S_OK;
}

/*++
    USBSetHandling - call put_PhoneHandlingEnabled 
    after read the registry value
--*/
HRESULT CAVTapi::USBSetHandling(
    IN  BOOL    bUSBEnabled
    )
{
    m_critUSBPhone.Lock();

    if( m_pUSBPhone == NULL )
    {
        m_critUSBPhone.Unlock();
        return S_OK;
    }

    //
    // If the phone is enabled, try to Open
    //

    CErrorInfo er;
    er.set_Operation( IDS_ER_USB );
    er.set_Details( IDS_ER_USB_INITIALIZE );

    if( bUSBEnabled )
    {
        //
        // Try to open if is necessary
        //
        if( m_bUSBOpened == FALSE )
        {
            HRESULT hr = m_pUSBPhone->Open( PP_OWNER );
            if( FAILED(hr) )
            {
                //
                // Reset the registry and the mark
                //
                m_bUSBOpened = FALSE;
                USBSetCheckboxValue( FALSE );
                er.set_hr( hr );

                m_critUSBPhone.Unlock();
                return hr;
            }

            //
            // Set the registry with the handset terminals
            //
            USBRegPutTerminals();
        }
    }
    else
    {
        //
        // Try to close the phone
        // First let's see if we have a call selected on the phone
        // object
        //
        ITAutomatedPhoneControl* pAutomated = NULL;
        HRESULT hr = m_pUSBPhone->QueryInterface(
            IID_ITAutomatedPhoneControl, 
            (void**)&pAutomated
            );

        if( FAILED(hr) )
        {
            m_critUSBPhone.Unlock();
            return E_UNEXPECTED;
        }

        IEnumCall* pEnumCalls = NULL;
        hr = pAutomated->EnumerateSelectedCalls(&pEnumCalls);

        // Clean-up
        pAutomated->Release();
        pAutomated = NULL;

        if( FAILED(hr) )
        {
            // Close the phone
            m_pUSBPhone->Close();
            USBRegDelTerminals();
            m_bUSBOpened = FALSE;
            USBSetCheckboxValue( FALSE );

            m_critUSBPhone.Unlock();
            return S_OK;
        }
        
        //
        // Browse for selected calls
        //
        BOOL bSelectedCalls = FALSE;
        ITCallInfo* pCallInfo = NULL;
        ULONG uFetched = 0;
        hr = pEnumCalls->Next(1, &pCallInfo, &uFetched);

        // Clean-up
        pEnumCalls->Release();
        pEnumCalls = NULL;

        //
        // Is there a call on this phone object?
        //
        if( hr == S_OK)
        {
            pCallInfo->Release();
            pCallInfo = NULL;

            bSelectedCalls = TRUE;
        }

        //
        // Do we have selected calls
        //
        if( bSelectedCalls )
        {
            //
            // Do not close the phone
            //
            if( m_bUSBOpened )
            {
                // Reset the registry value
                USBSetCheckboxValue( TRUE );

                // Error message
                er.set_Details( IDS_ER_USB_CLOSE );
                er.set_hr(E_FAIL);

                m_critUSBPhone.Unlock();
                return E_FAIL;
            }

            m_critUSBPhone.Unlock();
            return S_OK;
        }

        m_pUSBPhone->Close();
        USBRegDelTerminals();
        m_bUSBOpened = FALSE;
        USBSetCheckboxValue( FALSE );

        m_critUSBPhone.Unlock();
        return S_OK;
    }

    //
    // Is already opened?
    //
    if( m_bUSBOpened == bUSBEnabled )
    {
        // Don't try twice to open the USBPhone
        m_critUSBPhone.Unlock();
        return S_OK;
    }

    //
    // Get the ITAutomatedPhoneControl interface
    //

    ITAutomatedPhoneControl* pAutomated = NULL;
    HRESULT hr = m_pUSBPhone->QueryInterface(
        IID_ITAutomatedPhoneControl, 
        (void**)&pAutomated
        );

    if( FAILED(hr) )
    {
        //
        // Reset the registry and the mark
        //
        m_pUSBPhone->Close();
        USBRegDelTerminals();
        m_bUSBOpened = FALSE;
        USBSetCheckboxValue( FALSE );
        er.set_hr( hr );

        m_critUSBPhone.Unlock();
        return hr;
    }

    //
    // Set on true Phone handling
    //

    hr = pAutomated->put_PhoneHandlingEnabled( (bUSBEnabled ? VARIANT_TRUE : VARIANT_FALSE) );
    if( FAILED(hr) )
    {
        //
        // Reset the registry and the mark
        //
        m_pUSBPhone->Close();
        USBRegDelTerminals();
        m_bUSBOpened = FALSE;
        USBSetCheckboxValue( FALSE );
        er.set_hr( hr );

        // Clean-up
        pAutomated->Release();

        m_critUSBPhone.Unlock();
        return hr;
    }

    // Save in registry
    m_bUSBOpened = TRUE;
    USBSetCheckboxValue( TRUE );

    // Clean-up
    pAutomated->Release();

    m_critUSBPhone.Unlock();
    return S_OK;
}

/*++
    Get the USB handset terminals name
--*/
HRESULT CAVTapi::USBGetTerminalName(
    IN  AVTerminalDirection Direction,
    OUT BSTR*               pbstrName
    )
{
    *pbstrName = NULL;

    if( Direction == AVTERM_CAPTURE )
    {
        if( m_bstrUSBCaptureTerm )
        {
            *pbstrName = SysAllocString( m_bstrUSBCaptureTerm );
        }
        else
        {
            *pbstrName = SysAllocString( _T("") );
        }
        return S_OK;
    }

    if( Direction == AVTERM_RENDER )
    {
        if( m_bstrUSBRenderTerm )
        {
            *pbstrName = SysAllocString( m_bstrUSBRenderTerm );
        }
        else
        {
            *pbstrName = SysAllocString( _T("") );
        }
        return S_OK;
    }
    return E_FAIL;
}

HRESULT CAVTapi::USBSetVolume(
    IN  AVTerminalDirection avDirection,
    OUT long                nVolume
    )
{
    m_critUSBPhone.Lock();

    TCHAR szTrace[256];
    _stprintf( szTrace, _T("VLDTRACE * USBSetVolume - Dir=%d, Vol=%d\n"), avDirection, nVolume);
    OutputDebugString( szTrace );

    TERMINAL_DIRECTION TermDirection = TD_CAPTURE;

    //
    // Get terminal direction
    //
    switch(avDirection)
    {
    case AVTERM_CAPTURE:
        TermDirection = TD_CAPTURE;
        break;
    case AVTERM_RENDER:
        TermDirection = TD_RENDER;
        break;
    default:
        m_critUSBPhone.Unlock();
        return E_INVALIDARG;
    }

    //
    // Check the phone object
    //
    if(NULL == m_pUSBPhone)
    {
        // no phone
        m_critUSBPhone.Unlock();
        return S_OK;
    }

    //
    // Get automated interface
    //
    ITAutomatedPhoneControl* pAutomated = NULL;
    HRESULT hr = m_pUSBPhone->QueryInterface(
        IID_ITAutomatedPhoneControl,
        (void**)&pAutomated
        );

    if( FAILED(hr) )
    {
        m_critUSBPhone.Unlock();
        return hr;
    }

    //
    // Get the call selected on the phone
    //
    IEnumCall* pEnumCalls = NULL;
    hr = pAutomated->EnumerateSelectedCalls( &pEnumCalls );

    //
    // Clean-up
    //
    pAutomated->Release();
    pAutomated = NULL;

    if( FAILED(hr) )
    {
        m_critUSBPhone.Unlock();
        return hr;
    }

    //
    // Get the calls
    //
    ITCallInfo* pCallInfo = NULL;
    ULONG uFetched = 0;
    while( S_OK == pEnumCalls->Next(1, &pCallInfo, &uFetched))
    {
        // Get the address
        ITAddress* pAddress = NULL;
        HRESULT hr = pCallInfo->get_Address(&pAddress);
        if( SUCCEEDED(hr) )
        {
            // Enumerate terminals on this address
            IEnumTerminal* pEnumTerminals = NULL;
            hr = m_pUSBPhone->EnumerateTerminals( pAddress, &pEnumTerminals);
            if( SUCCEEDED(hr) )
            {
                ITTerminal* pTerminal = NULL;
                ULONG uFetched = 0;

                while( S_OK == pEnumTerminals->Next(1, &pTerminal, &uFetched))
                {
                    // Get the direction
                    TERMINAL_DIRECTION Direction = TD_CAPTURE;
                    hr = pTerminal->get_Direction(&Direction);
                    if( SUCCEEDED(hr) )
                    {
                        if( Direction == TermDirection )
                        {
                            // Get ITBasicAudioTerminal interface
                            ITBasicAudioTerminal* pAudio = NULL;
                            hr = pTerminal->QueryInterface(IID_ITBasicAudioTerminal, (void**)&pAudio);
                            if( SUCCEEDED(hr) )
                            {
                                // Set the volume
                                pAudio->put_Volume( nVolume);

                                // Set the member volume
                                if( TermDirection == TD_CAPTURE)
                                {
                                    m_nUSBInVolume = nVolume;
                                }
                                else
                                {
                                    m_nUSBOutVolume = nVolume;
                                }

                                // Clean-up
                                pAudio->Release();
                                pAudio = NULL;
                            }
                        }
                    }

                    // Clean-up
                    pTerminal->Release();
                    pTerminal = NULL;
                }

                //Clean-up
                pEnumTerminals->Release();
                pEnumTerminals = NULL;
            }

            // Clean-up
            pAddress->Release();
            pAddress = NULL;
        }

        // Clean-up
        pCallInfo->Release();
        pCallInfo = NULL;
    }

    //
    // Clean-up
    //
    pEnumCalls->Release();
    pEnumCalls = NULL;

    m_critUSBPhone.Unlock();
    return S_OK;
}

HRESULT CAVTapi::USBGetVolume(
    IN  AVTerminalDirection avDirection,
    OUT long*               pVolume
    )
{
    m_critUSBPhone.Lock();

    TERMINAL_DIRECTION TermDirection = 
        (avDirection == AVTERM_CAPTURE) ?
        TD_CAPTURE :
        TD_RENDER;

    *pVolume = USB_NULLVOLUME;

    //
    // Set volume
    //
    *pVolume = (avDirection == AVTERM_CAPTURE) ? 
        m_nUSBInVolume :
        m_nUSBOutVolume;
    //
    // Check the phone object
    //
    if(NULL == m_pUSBPhone)
    {
        // no phone
        m_critUSBPhone.Unlock();
        return S_OK;
    }

    //
    // Validate direction
    //
    if( (avDirection != AVTERM_CAPTURE) &&
        (avDirection != AVTERM_RENDER) )
    {
        m_critUSBPhone.Unlock();
        return E_INVALIDARG;
    }

    //
    // The volume was initialized?
    //
    if( *pVolume != USB_NULLVOLUME )
    {
        m_critUSBPhone.Unlock();
        return S_OK;
    }

    //
    // Let's go and initialize the volume
    // Get automated interface
    //
    ITAutomatedPhoneControl* pAutomated = NULL;
    HRESULT hr = m_pUSBPhone->QueryInterface(
        IID_ITAutomatedPhoneControl,
        (void**)&pAutomated
        );

    if( FAILED(hr) )
    {
        m_critUSBPhone.Unlock();
        return hr;
    }

    //
    // Get the call selected on the phone
    //
    IEnumCall* pEnumCalls = NULL;
    hr = pAutomated->EnumerateSelectedCalls( &pEnumCalls );

    //
    // Clean-up
    //
    pAutomated->Release();
    pAutomated = NULL;

    if( FAILED(hr) )
    {
        m_critUSBPhone.Unlock();
        return hr;
    }

    //
    // Get the calls
    //
    ITCallInfo* pCallInfo = NULL;
    ULONG uFetched = 0;
    long nVolume = USB_NULLVOLUME;
    HRESULT hrVolume = S_OK;
    while( S_OK == pEnumCalls->Next(1, &pCallInfo, &uFetched))
    {
        // Get the address
        ITAddress* pAddress = NULL;
        HRESULT hr = pCallInfo->get_Address(&pAddress);
        if( SUCCEEDED(hr) )
        {
            // Enumerate terminals on this address
            IEnumTerminal* pEnumTerminals = NULL;
            hr = m_pUSBPhone->EnumerateTerminals( pAddress, &pEnumTerminals);
            if( SUCCEEDED(hr) )
            {
                ITTerminal* pTerminal = NULL;
                ULONG uFetched = 0;

                while( S_OK == pEnumTerminals->Next(1, &pTerminal, &uFetched))
                {
                    // Get the direction
                    TERMINAL_DIRECTION Direction = TD_CAPTURE;
                    hr = pTerminal->get_Direction(&Direction);
                    if( SUCCEEDED(hr) )
                    {
                        if( Direction == TermDirection )
                        {
                            // Get ITBasicAudioTerminal interface
                            ITBasicAudioTerminal* pAudio = NULL;
                            hr = pTerminal->QueryInterface(IID_ITBasicAudioTerminal, (void**)&pAudio);
                            if( SUCCEEDED(hr) )
                            {
                                // Set the volume
                                hrVolume = pAudio->get_Volume( &nVolume);

                                // Clean-up
                                pAudio->Release();
                                pAudio = NULL;
                            }
                        }
                    }

                    // Clean-up
                    pTerminal->Release();
                    pTerminal = NULL;
                }

                //Clean-up
                pEnumTerminals->Release();
                pEnumTerminals = NULL;
            }

            // Clean-up
            pAddress->Release();
            pAddress = NULL;
        }

        // Clean-up
        pCallInfo->Release();
        pCallInfo = NULL;
    }

    //
    // Clean-up
    //
    pEnumCalls->Release();
    pEnumCalls = NULL;

    if( FAILED(hrVolume) )
    {
        TCHAR szTrace[256];
        _stprintf( szTrace, _T("VLDTRECE * Erro get_Volume 0x%08x\n"), hr);
        OutputDebugString( szTrace );

        m_critUSBPhone.Unlock();
        return hrVolume;
    }

    //
    // Set the volume
    //
    *pVolume = nVolume;
    if( (avDirection == AVTERM_CAPTURE) )
    {
        m_nUSBInVolume = nVolume;
    }
    else
    {
        m_nUSBOutVolume = nVolume;
    }
    
    m_critUSBPhone.Unlock();
    return S_OK;
}


/*++
    USBRegPutTerminals
    It is called when the phone is opened.
    Add in the registry the name of the handset terminals
--*/
HRESULT CAVTapi::USBRegPutTerminals(
    )
{
    // Create the registry key, its a combination of redial and USB terminals
    CRegKey regKey;
    TCHAR szText[255], szType[50];
    LoadString( _Module.GetResourceInstance(), IDN_REG_REDIAL_KEY, szText, ARRAYSIZE(szText) );
    LoadString( _Module.GetResourceInstance(), IDN_REG_REDIAL_USBTERMS , szType, ARRAYSIZE(szType) );
    _tcscat( szText, _T("\\") );
    _tcscat( szText, szType );
    regKey.Create( HKEY_CURRENT_USER, szText );

    if ( regKey.m_hKey == NULL)
    {
        return E_FAIL;
    }

    //
    // Capture terminal
    //
    LoadString( _Module.GetResourceInstance(), IDN_REG_REDIAL_USBCAPTURE, szText, ARRAYSIZE(szText) );
    regKey.SetValue( (m_bstrUSBCaptureTerm!=NULL)? m_bstrUSBCaptureTerm : _T(""), szText );

    //
    // Render terminal
    //
    LoadString( _Module.GetResourceInstance(), IDN_REG_REDIAL_USBRENDER, szText, ARRAYSIZE(szText) );
    regKey.SetValue( (m_bstrUSBRenderTerm!=NULL)? m_bstrUSBRenderTerm : _T(""), szText );

    //
    // Close the registry key
    //
    regKey.Close();

    return S_OK;
}

/*++
    USBRegDelTerminals
    Delete the resgistry entry for USB handset terminals
    Is caled when USB handset is called
--*/
HRESULT CAVTapi::USBRegDelTerminals(
    )
{
    // Create the registry key, its a combination of redial and USB terminals
    CRegKey regKey;
    TCHAR szText[255], szType[50];
    LoadString( _Module.GetResourceInstance(), IDN_REG_REDIAL_KEY, szText, ARRAYSIZE(szText) );
    LoadString( _Module.GetResourceInstance(), IDN_REG_REDIAL_USBTERMS , szType, ARRAYSIZE(szType) );
    _tcscat( szText, _T("\\") );
    _tcscat( szText, szType );
    regKey.Create( HKEY_CURRENT_USER, szText );

    if ( regKey.m_hKey == NULL)
    {
        return E_FAIL;
    }

    //
    // Capture terminal
    //
    LoadString( _Module.GetResourceInstance(), IDN_REG_REDIAL_USBCAPTURE, szText, ARRAYSIZE(szText) );
    regKey.SetValue( _T(""), szText );

    //
    // Render terminal
    //
    LoadString( _Module.GetResourceInstance(), IDN_REG_REDIAL_USBRENDER, szText, ARRAYSIZE(szText) );
    regKey.SetValue( _T(""), szText );

    //
    // Close the registry key
    //
    regKey.Close();

    return S_OK;
}


/*++
DoneRegistration

Is called by AVDialer after IConnectionPoint::Advise method
was called
--*/
STDMETHODIMP CAVTapi::DoneRegistration()
{
    //
    // Signal the event
    // The Dialer just register as client for the events
    //

    if( m_hEventDialerReg)
    {
        SetEvent( m_hEventDialerReg );
    }
    return S_OK;
}

/*++
USBReserveStreamForPhone

  Is called by CreateTerminalArray
  Allocate a termnal name that represents
  'Don't select a terminal for this stream'
  That stream will be reserved for the Phone terminals
  return;
    S_OK - the stream was reserved and pbstrTerminal was allocated
            by USBReserveStreamForPhone.
    E_FAIL - the stream wasn't reserved
--*/
HRESULT CAVTapi::USBReserveStreamForPhone(
    IN  UINT    nStream,
    OUT BSTR*   pbstrTerminal
    )
{

    if( (nStream != IDN_REG_REDIAL_TERMINAL_AUDIO_CAPTURE) &&
        (nStream != IDN_REG_REDIAL_TERMINAL_AUDIO_RENDER))
    {
        //
        // Phone works just on Audio streams
        //
        return E_INVALIDARG;
    }
    
    if( !USBGetCheckboxValue() )
    {
        //
        // We are not interested in USBPhone
        //
        return E_FAIL;
    }

    TCHAR szTemp[255];
    int nRetVal = LoadString( _Module.GetResourceInstance(), IDS_NONE_DEVICE, szTemp, ARRAYSIZE(szTemp) );
    if( 0 == nRetVal )
    {
        //
        // No resource string
        //

        return E_UNEXPECTED;
    }

    *pbstrTerminal = SysAllocString( T2COLE(szTemp) );
    if( NULL == *pbstrTerminal )
    {
        // E_OUTOFMEMORY
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

/*++
    AECGetRegistryValue
    Read the flag from the registry
++*/
BOOL CAVTapi::AECGetRegistryValue(
    )
{
    BOOL bAEC = FALSE;
    //
    // Read the registry for the previous 
    // setting for AEC
    //

    TCHAR szText[255], szType[255];
	LoadString( _Module.GetResourceInstance(), IDN_REG_REDIAL_KEY, szText, ARRAYSIZE(szText) );

	CRegKey regKey;
	if( regKey.Open( HKEY_CURRENT_USER, szText, KEY_READ )!= ERROR_SUCCESS)
    {
        return bAEC;
    };

    //
    // Read data
    //

    DWORD dwValue = 0;
	LoadString( _Module.GetResourceInstance(), IDN_REG_REDIAL_AEC, szType, ARRAYSIZE(szType) );
    if( regKey.QueryValue(dwValue, szType) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    return (BOOL)dwValue;
}

/*++
Sets on Audio capture the AEC on true
--*/
HRESULT CAVTapi::AECSetOnStream(
    IN  ITStreamControl *pStreamControl,
    IN  BOOL        bAEC
    )
{
    HRESULT hr = E_FAIL;

    //
    // Get the streams
    //
    IEnumStream *pEnumStreams = NULL;
    hr = pStreamControl->EnumerateStreams(&pEnumStreams);
    if( FAILED(hr) )
    {
        return hr;
    }

    //
    // Go to the audio capture stream
    //

    ITStream *pStream = NULL;

    while(pEnumStreams->Next(1, &pStream, NULL) == S_OK)
    {
        //
        // Get media type and the direction
        //
        long lStreamMediaMode = 0;
        TERMINAL_DIRECTION nStreamDir = TD_CAPTURE;

        pStream->get_Direction( &nStreamDir );
        pStream->get_MediaType( &lStreamMediaMode );

        //
        // Set the audio AEC on audio capture streams
        //

        if( (lStreamMediaMode == TAPIMEDIATYPE_AUDIO) && 
            (nStreamDir == TD_CAPTURE) )
        {
            //
            // Get ITAudioDeviceControl interface
            //
            ITAudioDeviceControl* pAudioDevice = NULL;
            hr = pStream->QueryInterface( 
                IID_ITAudioDeviceControl,
                (void**)&pAudioDevice
                );

            if( SUCCEEDED(hr) )
            {
                //
                // Set the value for AEC
                //
                hr = pAudioDevice->Set(
                    AudioDevice_AcousticEchoCancellation, 
                    bAEC, 
                    TAPIControl_Flags_None
                    );

                //
                // Clean-up
                //
                pAudioDevice->Release();
                pAudioDevice = NULL;
            }
        }

        //
        // Clean up the stream
        //
        pStream->Release();
        pStream = NULL;
    }

    //
    // Clean-up the enumeration
    //
    pEnumStreams->Release();

    return hr;
}


HRESULT CAVTapi::USBAnswer()
{
    // Critical Section
    m_critUSBPhone.Lock();

    // We don't have USB phone
    if( m_pUSBPhone == NULL)
    {
        m_critUSBPhone.Unlock();
        return S_OK;
    }

    // IS the phone opened ?
    if( !m_bUSBOpened )
    {
        m_critUSBPhone.Unlock();
        return S_OK;
    }

    // Get the automated interface
    ITAutomatedPhoneControl* pAutomated = NULL;
    HRESULT hr = m_pUSBPhone->QueryInterface(
        IID_ITAutomatedPhoneControl, 
        (void**)&pAutomated);

    if( FAILED(hr) )
    {
        m_critUSBPhone.Unlock();
        return hr;
    }

    // Get the calls selected on this phone object
    IEnumCall* pEnumCalls = NULL;
    hr = pAutomated->EnumerateSelectedCalls(&pEnumCalls);
    // Clean-up
    pAutomated->Release();
    pAutomated = NULL;

    if( FAILED(hr) )
    {
        m_critUSBPhone.Unlock();
        return hr;
    }

    // Browse the enumeration
    ITCallInfo* pCallInfo = NULL;
    ULONG uFetched = 0;

    // Get the first call. Right now the phone supports just one
    // call. In the future, if the phone will support many calls
    // there should be a method to find out what is the call for
    // this event
    hr = pEnumCalls->Next(1, &pCallInfo, &uFetched);

    // Clean-up the enumeration
    pEnumCalls->Release();
    pEnumCalls = NULL;

    if( pCallInfo == NULL )
    {
        m_critUSBPhone.Unlock();
        return E_UNEXPECTED;
    }

    //
    // Get the ITBasicCallControl
    //
    ITBasicCallControl* pControl = NULL;
    hr = pCallInfo->QueryInterface(
        IID_ITBasicCallControl,
        (void**)&pControl);
    if( FAILED(hr) )
    {
        // Clean-up the call
        pCallInfo->Release();
        pCallInfo = NULL;
    
        m_critUSBPhone.Unlock();

        return hr;
    }

    //
    // Get IAVCall interface
    //
    IAVTapiCall* pAVCall = FindAVTapiCall( pControl );
    if( pAVCall == NULL )
    {
        // Clean-up the call
        pControl->Release();
        pControl = NULL;

        pCallInfo->Release();
        pCallInfo = NULL;
    
        m_critUSBPhone.Unlock();
        return E_FAIL;
    }

    //
    // Select terminals and the preview window
    //
    hr = AnswerAction(
        pCallInfo,
        pControl,
        pAVCall,
        TRUE
        );

    // Clean-up the call
    pAVCall->Release();
    pAVCall = NULL;
    pControl->Release();
    pControl = NULL;
    pCallInfo->Release();
    pCallInfo = NULL;
    
    m_critUSBPhone.Unlock();
    return hr;
}


HRESULT CAVTapi::AnswerAction(
    IN  ITCallInfo*          pInfo,
    IN  ITBasicCallControl* pControl,
    IN  IAVTapiCall*        pAVCall,
    IN  BOOL                bUSBAnswer
    )
{
    if( (pInfo == NULL) ||
        (pControl == NULL) )
    {
        return E_UNEXPECTED;
    }

    HRESULT hr = S_OK;
    CThreadAnswerInfo *pAnswerInfo = new CThreadAnswerInfo;
    if ( pAnswerInfo == NULL )
    {
        return E_UNEXPECTED;
    }

    //
    // Was 'Take call' answer (FALSE) or
    // a USB phone answer
    //
    pAnswerInfo->m_bUSBAnswer = bUSBAnswer;

    if ( SUCCEEDED(hr = pAnswerInfo->set_AVTapiCall(pAVCall)) &&
         SUCCEEDED(hr = pAnswerInfo->set_ITCallInfo(pInfo)) &&
         SUCCEEDED(hr = pAnswerInfo->set_ITBasicCallControl(pControl)) )
    {
        DWORD dwID = 0;
        HANDLE hThread = CreateThread( NULL, 0, ThreadAnswerProc, (void *) pAnswerInfo, NULL, &dwID );
        if ( !hThread )
        {
            hr = E_UNEXPECTED;
            delete pAnswerInfo;
        }
        else
        {
            CloseHandle( hThread );
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\cedetailvw.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// ConfExplorerDetailsView.cpp : Implementation of CConfExplorerDetailsView
#include "stdafx.h"
#include <stdio.h>
#include "TapiDialer.h"
#include "avTapi.h"
#include "CEDetailsVw.h"
#include "CETreeView.h"
#include "ConfExp.h"
#include "SDPBlb.h"

static UINT arCols[] = { IDS_EXPLORE_COLUMN_NAME,
                         IDS_EXPLORE_COLUMN_PURPOSE,
                         IDS_EXPLORE_COLUMN_STARTS,
                         IDS_EXPLORE_COLUMN_ENDS,
                         IDS_EXPLORE_COLUMN_ORIGINATOR };

// Sort function
static int CALLBACK CompareFunc( LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort )
{
    CConfExplorerDetailsView *p = (CConfExplorerDetailsView *) lParamSort;
    return ((CConfDetails *) lParam1)->Compare( (CConfDetails *) lParam2, p->IsSortAscending(), p->GetSortColumn(), p->GetSecondarySortColumn() );
}

/////////////////////////////////////////////////////////////////////////////
// CConfExplorerDetailsView

CConfExplorerDetailsView::CConfExplorerDetailsView()
{
    m_pIConfExplorer = NULL;
    m_nSortColumn = 0;
    m_bSortAscending = true;

    m_nUpdateCount = 0;
}


void CConfExplorerDetailsView::FinalRelease()
{
    ATLTRACE(_T(".enter.CConfExplorerDetailsView::FinalRelease().\n"));

    DeleteAllItems();
    put_hWnd( NULL );
    put_ConfExplorer( NULL );

    CComObjectRootEx<CComMultiThreadModel>::FinalRelease();
}

STDMETHODIMP CConfExplorerDetailsView::get_hWnd(HWND * pVal)
{
    *pVal = m_wndList.m_hWnd;
    return S_OK;
}

STDMETHODIMP CConfExplorerDetailsView::put_hWnd(HWND newVal)
{
    // Load up image lists items for conferences
    if ( IsWindow(newVal) )
    {
        // Make sure the window isn't already subclassed
        if ( m_wndList.m_hWnd ) m_wndList.UnsubclassWindow();

        // Load listbox with items
        if ( m_wndList.SubclassWindow(newVal))
        {
            // Take over window to get sorting messages and other things
            m_wndList.m_pDetailsView = this;
            m_wndList.PostMessage( WM_MYCREATE, 0, 0 );
        }
    }
    else if ( IsWindow(m_wndList.m_hWnd) )
    {
        put_Columns();
        DeleteAllItems();
        m_wndList.UnsubclassWindow();
        m_wndList.m_pDetailsView = NULL;
        m_wndList.m_hWnd = NULL;
    }

    return S_OK;
}

bool CConfExplorerDetailsView::IsSortColumnDateBased(int nCol) const 
{
    bool bRet = false;
    switch ( nCol )
    {
        case COL_STARTS:
        case COL_ENDS:
            bRet = true;
            break;
    }

    return bRet;
}

int CConfExplorerDetailsView::GetSecondarySortColumn() const
{
    return (m_nSortColumn) ? COL_NAME : COL_STARTS;
}

void CConfExplorerDetailsView::get_Columns()
{
#define CONFEXP_DEFAULT_WIDTH    125

    // Load column settings from registry
    USES_CONVERSION;
    CRegKey regKey;
    TCHAR szReg[255], szEntry[50];

    LV_COLUMN lvc;
    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM; 
    lvc.fmt = LVCFMT_LEFT;
    lvc.pszText = szReg;

    LoadString( _Module.GetResourceInstance(), IDN_REG_CONFSERV_VIEW_KEY, szReg, ARRAYSIZE(szReg) );
    regKey.Open( HKEY_CURRENT_USER, szReg, KEY_READ );

    // Add the columns.
    for ( int i = 0; i < ARRAYSIZE(arCols); i++ )
    {
        lvc.iSubItem = i; 
        lvc.cx = CONFEXP_DEFAULT_WIDTH;

        // Load registry stuff if exists        
        if ( regKey.m_hKey )
        {
            DWORD dwVal = 0;

            // Get sort column and sort direction
            LoadString( _Module.GetResourceInstance(), IDN_REG_CONFSERV_SORT_COLUMN, szReg, ARRAYSIZE(szReg) );
            regKey.QueryValue( dwVal, szReg );
            m_nSortColumn = (int) max(0, ((int)min(dwVal,ARRAYSIZE(arCols))));

            LoadString( _Module.GetResourceInstance(), IDN_REG_CONFSERV_SORT_ASCENDING, szReg, ARRAYSIZE(szReg) );
            regKey.QueryValue( dwVal, szReg );
            m_bSortAscending = (bool) (dwVal > 0);

            // Column Widths
            LoadString( _Module.GetResourceInstance(), IDN_REG_CONFSERV_ENTRY, szReg, ARRAYSIZE(szReg) );
            _sntprintf( szEntry, ARRAYSIZE(szEntry), szReg, i );
            szEntry[ARRAYSIZE(szEntry)-1] = _T('\0');
            dwVal = 0;
            if ( (regKey.QueryValue(dwVal, szEntry) == ERROR_SUCCESS) && (dwVal > 0) )
                lvc.cx = (int) max(MIN_COL_WIDTH, min( 5000, dwVal ));

        }

        LoadString( _Module.GetResourceInstance(), arCols[i], szReg, ARRAYSIZE(szReg) );
        ListView_InsertColumn( m_wndList.m_hWnd, i, &lvc );
    }
}

void CConfExplorerDetailsView::put_Columns()
{
    // Save column setting to registry
    USES_CONVERSION;
    CRegKey regKey;
    TCHAR szReg[100], szEntry[50];

    LoadString( _Module.GetResourceInstance(), IDN_REG_CONFSERV_VIEW_KEY, szReg, ARRAYSIZE(szReg) );
    if ( regKey.Create(HKEY_CURRENT_USER, szReg) == ERROR_SUCCESS )
    {
        // Save sort column and sort direction
        LoadString( _Module.GetResourceInstance(), IDN_REG_CONFSERV_SORT_COLUMN, szReg, ARRAYSIZE(szReg) );
        regKey.SetValue( m_nSortColumn, szReg );
        LoadString( _Module.GetResourceInstance(), IDN_REG_CONFSERV_SORT_ASCENDING, szReg, ARRAYSIZE(szReg) );
        regKey.SetValue( m_bSortAscending, szReg );

        // Save column widths
        int nWidth;
        for ( int i = 0; i < ARRAYSIZE(arCols); i++ )
        {
            nWidth = ListView_GetColumnWidth( m_wndList.m_hWnd, i );

            LoadString( _Module.GetResourceInstance(), IDN_REG_CONFSERV_ENTRY, szReg, ARRAYSIZE(szReg) );
            _sntprintf( szEntry, ARRAYSIZE(szEntry), szReg, i );
            szEntry[ARRAYSIZE(szEntry)-1] =  _T('\0');
            regKey.SetValue( nWidth, szEntry );
        }
    }
}

STDMETHODIMP CConfExplorerDetailsView::Refresh()
{
    HRESULT hr;

    IConfExplorer *pConfExplorer;
    if ( SUCCEEDED(hr = get_ConfExplorer(&pConfExplorer)) )
    {
        // Show hourglass
        HCURSOR hCurOld = SetCursor( LoadCursor(NULL, IDC_WAIT) );

        IConfExplorerTreeView *pView;
        if ( SUCCEEDED(hr = pConfExplorer->get_TreeView(&pView)) )
        {
            BSTR bstrLocation = NULL, bstrServer = NULL;
            if ( SUCCEEDED(hr = pView->GetSelection(&bstrLocation, &bstrServer)) )
            {
                pView->ForceConfServerForEnum( bstrServer );
                DeleteAllItems();
            }

            SysFreeString( bstrLocation );
            SysFreeString( bstrServer );
            pView->Release();
        }

        put_Columns();    

        // Restore wait cursor
        SetCursor( hCurOld );
        pConfExplorer->Release();
    }
    
    return hr;
}

HRESULT CConfExplorerDetailsView::ShowConferencesAndPersons(BSTR bstrServer )
{
    USES_CONVERSION;
    IConfExplorer *pConfExplorer;
    ITDirectory *pDir;

    //
    // We should initialize the ocal variable
    //
    HRESULT hr = E_FAIL;

    if ( SUCCEEDED(get_ConfExplorer(&pConfExplorer)) )
    {
        if ( SUCCEEDED(hr = pConfExplorer->get_ConfDirectory(NULL, (IDispatch **) &pDir)) )
        {
            // Enumerate through conferences adding them as we go along
            IEnumDirectoryObject *pEnum;
            ITDirectoryObject *pITDirObject;
            long nCount;

            // Enumerate list of conferences
            if ( SUCCEEDED(hr = pDir->EnumerateDirectoryObjects(OT_CONFERENCE, A2BSTR("*"), &pEnum)) )
            {
                nCount = 0;
                m_critConfList.Lock();
                DELETE_LIST(m_lstConfs);
                while ( (nCount++ < MAX_ENUMLISTSIZE) && ((hr = pEnum->Next(1, &pITDirObject, NULL)) == S_OK) )
                {
                    _ASSERT( pITDirObject );
                    CConfDetails *p = AddListItem( bstrServer, pITDirObject, m_lstConfs );
                    pITDirObject->Release();
                }
                m_critConfList.Unlock();
                pEnum->Release();
            }

            // Retrieve the people in the ILS server
            if ( SUCCEEDED(hr = pDir->EnumerateDirectoryObjects(OT_USER, A2BSTR("*"), &pEnum)) )
            {
                nCount = 0;
                m_critConfList.Lock();
                DELETE_LIST(m_lstPersons);
                while ( (nCount++ < MAX_ENUMLISTSIZE) && ((hr = pEnum->Next(1, &pITDirObject, NULL)) == S_OK) )
                {
                    _ASSERT( pITDirObject );
                    CPersonDetails *p = AddListItemPerson( bstrServer, pITDirObject, m_lstPersons );
                    pITDirObject->Release();
                }
                m_critConfList.Unlock();
                pEnum->Release();
            }

            pDir->Release();

            // Put conferences in the listbox
            UpdateConfList( NULL );
        }
        pConfExplorer->Release();
    }

    return hr;
}

STDMETHODIMP CConfExplorerDetailsView::get_Selection(DATE *pdateStart, DATE *pdateEnd, BSTR *pVal )
{
    if ( !IsWindow(m_wndList.m_hWnd) ) return E_PENDING;

    HRESULT hr = E_FAIL;

    m_critConfList.Lock();
    for ( int i = 0; i < ListView_GetItemCount(m_wndList.m_hWnd); i++ )
    {
        if ( ListView_GetItemState(m_wndList.m_hWnd, i, LVIS_SELECTED) )
        {
            LV_ITEM lvi = {0};
            lvi.iItem = i;
            lvi.mask = LVIF_PARAM;
            if ( ListView_GetItem(m_wndList.m_hWnd, &lvi) && lvi.lParam )
            {
                *pVal = SysAllocString( ((CConfDetails *) lvi.lParam)->m_bstrName );

                if ( pdateStart )    *pdateStart = ((CConfDetails *) lvi.lParam)->m_dateStart;
                if ( pdateEnd )        *pdateEnd = ((CConfDetails *) lvi.lParam)->m_dateEnd;
                hr = S_OK;
                break;
            }
        }
    }
    m_critConfList.Unlock();

    return hr;
}


STDMETHODIMP CConfExplorerDetailsView::get_ConfExplorer(IConfExplorer **ppVal)
{
    HRESULT hr = E_PENDING;
    Lock();
    if ( m_pIConfExplorer )
        hr = m_pIConfExplorer->QueryInterface(IID_IConfExplorer, (void **) ppVal );
    Unlock();

    return hr;
}

STDMETHODIMP CConfExplorerDetailsView::put_ConfExplorer(IConfExplorer * newVal)
{
    HRESULT hr = S_OK;

    Lock();
    RELEASE( m_pIConfExplorer );
    if ( newVal )
        hr = newVal->QueryInterface( IID_IConfExplorer, (void **) &m_pIConfExplorer );
    Unlock();

    return hr;
}


STDMETHODIMP CConfExplorerDetailsView::OnColumnClicked(long nColumn)
{
    ATLTRACE(_T(".enter.CConfExplorerDetailsView::OnColumnClicked(%ld).\n"), nColumn );
    if ( !IsWindow(m_wndList.m_hWnd) ) return E_PENDING;
    if ( ListView_GetColumnWidth(m_wndList.m_hWnd, nColumn) == 0 ) return E_INVALIDARG;

    // Sort on column selected; if new column sort ascending
    if ( m_nSortColumn == nColumn )
    {
        m_bSortAscending = !m_bSortAscending;
    }
    else
    {
        m_nSortColumn = nColumn;
        m_bSortAscending = true;
    }

    ListView_SortItems( m_wndList.m_hWnd, CompareFunc, (LPARAM) this );
    return S_OK;
}

void CConfExplorerDetailsView::DeleteAllItems()
{
    if ( IsWindow(m_wndList.m_hWnd) )
        ListView_DeleteAllItems( m_wndList.m_hWnd );

    DELETE_CRITLIST(m_lstConfs, m_critConfList);
    DELETE_CRITLIST(m_lstPersons, m_critConfList);
}

long CConfExplorerDetailsView::OnGetDispInfo( LV_DISPINFO *pInfo )
{
    USES_CONVERSION;

    if ( pInfo && (pInfo->hdr.hwndFrom == m_wndList.m_hWnd) )
    {
        switch( pInfo->hdr.code )
        {
            case LVN_GETDISPINFO:
                // Write out the text
                if ( pInfo->item.lParam  )
                {
                    CConfDetails *pDetails = (CConfDetails *) pInfo->item.lParam;

                    ///////////////////////////////////////////// Set image for item
                    if ( pInfo->item.mask & LVIF_IMAGE )
                    {
                        CComPtr<IAVGeneralNotification> pAVGen;

                        if ( SUCCEEDED(_Module.get_AVGenNot(&pAVGen)) && (pAVGen->fire_IsReminderSet(pDetails->m_bstrServer, pDetails->m_bstrName) == S_OK) )
                        {
                            // User has set a reminder
                            pInfo->item.iImage = IMAGE_REMINDER;
                        }
                        else
                        {
                            // Is the conference in session
                            DATE dateNow;
                            SYSTEMTIME st;
                            GetLocalTime( &st );
                            SystemTimeToVariantTime( &st, &dateNow );
                            DATE dateStart = pDetails->m_dateStart - (DATE) (.125 / 12 );        // drop back 15 minutes

                            if ( (dateStart <= dateNow) && (pDetails->m_dateEnd >= dateNow) )
                                pInfo->item.iImage = IMAGE_INSESSION;
                            else
                                pInfo->item.iImage = IMAGE_NONE;
                        }
                    }

                    ////////////////////////////////////////////////////////// item state
                    if ( pInfo->item.mask & LVIF_STATE )
                    {
                        // What type of media does the conference support?
                        switch ( pDetails->m_sdp.m_nConfMediaType )
                        {
                            case CConfSDP::MEDIA_AUDIO:
                                pInfo->item.state += INDEXTOSTATEIMAGEMASK( IMAGE_STATE_AUDIO );
                                break;

                            case CConfSDP::MEDIA_VIDEO:
                                pInfo->item.state += INDEXTOSTATEIMAGEMASK( IMAGE_STATE_VIDEO );
                                break;
                        }
                    }


                    /////////////////////////////////////////  Set text for item
                    if ( pInfo->item.mask & LVIF_TEXT )
                    {
                        BSTR bstrTemp = NULL;
                        
                        switch ( pInfo->item.iSubItem )
                        {
                            case COL_NAME:            bstrTemp = SysAllocString( pDetails->m_bstrName ); break;
                            case COL_PURPOSE:        bstrTemp = SysAllocString( pDetails->m_bstrDescription ); break;
                            case COL_ORIGINATOR:    bstrTemp = SysAllocString( pDetails->m_bstrOriginator ); break;
                            case COL_STARTS:        VarBstrFromDate( pDetails->m_dateStart, LOCALE_USER_DEFAULT, NULL, &bstrTemp );    break;
                            case COL_ENDS:            VarBstrFromDate( pDetails->m_dateEnd, LOCALE_USER_DEFAULT, NULL, &bstrTemp ); break;
                            default:    _ASSERT( false );
                        }
                        
                        // Copy string
                        _tcsncpy( pInfo->item.pszText, (bstrTemp) ? OLE2CT(bstrTemp) : _T(""), pInfo->item.cchTextMax );
                        pInfo->item.pszText[pInfo->item.cchTextMax - 1] = 0;
                        SysFreeString( bstrTemp );
                    }
                }
                break;

            case LVN_SETDISPINFO:
                break;
        }
    }

    return 0;
}

STDMETHODIMP CConfExplorerDetailsView::UpdateConfList(long * pList)
{
    // Keep count on the number of requests to update the conference
    m_critUpdateList.Lock();
    m_nUpdateCount++;
    m_critUpdateList.Unlock();

    // If failed, request is queued
    if ( TryEnterCriticalSection(&m_critConfList.m_sec) == FALSE )
        return E_PENDING;

    // Disable redraw
    ::SendMessage( m_wndList.m_hWnd, WM_SETREDRAW, false, 0 );

    for ( ;; )
    {
        // Check to see how many times we need to update the conference list
        m_critUpdateList.Lock();
        if ( m_nUpdateCount == 0 )
            break;
        else
            m_nUpdateCount--;
        m_critUpdateList.Unlock();

        ///////////////////////////////////////////////////////////////////////////////////        
        // Clear out all items from the listbox
        ListView_DeleteAllItems( m_wndList.m_hWnd );

        // Copy list over
        CONFDETAILSLIST::iterator i, iEnd;
        if ( pList )
        {
            DELETE_LIST(m_lstConfs);
            iEnd = ((CONFDETAILSLIST *) pList)->end();
            for ( i = ((CONFDETAILSLIST *) pList)->begin(); i != iEnd; i++ )
            {
                CConfDetails *pDetails = new CConfDetails;
                if ( pDetails )
                {
                    *pDetails = *(*i);
                    m_lstConfs.push_back( pDetails );
                }
            }
        }

        // Populate the details view
        LV_ITEM lvi = {0};
        lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
        lvi.pszText = LPSTR_TEXTCALLBACK;
        lvi.iImage = I_IMAGECALLBACK;

        iEnd = m_lstConfs.end();
        for ( i = m_lstConfs.begin(); i != iEnd; i++ )
        {
            lvi.lParam = (LPARAM) *i;
            ListView_InsertItem( m_wndList.m_hWnd, &lvi );
        }
    }

    // Enable redraw prior to exiting crit
    ::SendMessage( m_wndList.m_hWnd, WM_SETREDRAW, true, 0 );
    m_critConfList.Unlock();
    m_critUpdateList.Unlock();

    // Sort the list of items
    ListView_SortItems( m_wndList.m_hWnd, CompareFunc, (LPARAM) this );
    ::InvalidateRect(m_wndList.m_hWnd, NULL, true);

    return S_OK;
}

CConfDetails* CConfExplorerDetailsView::AddListItem( BSTR bstrServer, ITDirectoryObject *pITDirObject, CONFDETAILSLIST& lstConfs )
{
    _ASSERT( pITDirObject );
    USES_CONVERSION;

    // Create list box item and add to list
    CConfDetails *p = new CConfDetails;
    if ( p )
    {
        p->Populate( bstrServer, pITDirObject );
        lstConfs.push_front( p );
    }

    return NULL;
}

CPersonDetails* CConfExplorerDetailsView::AddListItemPerson( BSTR bstrServer, ITDirectoryObject *pITDirObject, PERSONDETAILSLIST& lstPersons )
{
    _ASSERT( pITDirObject );
    USES_CONVERSION;

    // Create list box item and add to list
    CPersonDetails *p = new CPersonDetails;
    if ( p )
    {
        p->Populate( bstrServer, pITDirObject );
        lstPersons.push_front( p );
    }

    return NULL;
}

STDMETHODIMP CConfExplorerDetailsView::get_bSortAscending(VARIANT_BOOL * pVal)
{
    Lock();
    *pVal = m_bSortAscending;
    Unlock();

    return S_OK;
}

STDMETHODIMP CConfExplorerDetailsView::get_nSortColumn(long * pVal)
{
    Lock();
    *pVal = m_nSortColumn;
    Unlock();

    return S_OK;
}

STDMETHODIMP CConfExplorerDetailsView::put_nSortColumn(long newVal)
{
    return OnColumnClicked( newVal );
}

STDMETHODIMP CConfExplorerDetailsView::IsConferenceSelected()
{
    if ( !IsWindow(m_wndList.m_hWnd) ) return E_PENDING;

    for ( int i = 0; i < ListView_GetItemCount(m_wndList.m_hWnd); i++ )
    {
        if ( ListView_GetItemState(m_wndList.m_hWnd, i, LVIS_SELECTED) )
            return S_OK;
    }

    return S_FALSE;
}


STDMETHODIMP CConfExplorerDetailsView::get_SelectedConfDetails(long ** ppVal)
{
    if ( !IsWindow(m_wndList.m_hWnd) ) return E_PENDING;

    HRESULT hr = E_FAIL;

    m_critConfList.Lock();
    for ( int i = 0; i < ListView_GetItemCount(m_wndList.m_hWnd); i++ )
    {
        if ( ListView_GetItemState(m_wndList.m_hWnd, i, LVIS_SELECTED) )
        {
            LV_ITEM lvi = {0};
            lvi.iItem = i;
            lvi.mask = LVIF_PARAM;
            if ( ListView_GetItem(m_wndList.m_hWnd, &lvi) && lvi.lParam )
            {
                CConfDetails *pNew = new CConfDetails;
                if ( pNew )
                {
                    // copy this over
                    *pNew = *((CConfDetails *) lvi.lParam);
                    *ppVal = (long *) pNew;
                    hr = S_OK;
                }
                break;
            }
        }
    }
    m_critConfList.Unlock();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\avtapicall.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// AVTapiCall.cpp : Implementation of CAVTapiCall
#include "stdafx.h"
#include "TapiDialer.h"
#include "AVTapi.h"
#include "AVTapiCall.h"
#include "CRTreeView.h"
#include "ConfRoom.h"
#include "CRMemWnd.h" 

/////////////////////////////////////////////////////////////////////////////
// CAVTapiCall

CAVTapiCall::CAVTapiCall()
{
    m_dwThreadID = 0;

    m_pITControl = NULL;
    m_pITTerminalPreview = NULL;
    m_callState = CS_IDLE;
    m_bCallLogged = false;
    m_nCallType = AV_VOICE_CALL;
    
    m_bstrName = NULL;
    for ( int i = 0; i < NUM_USER_BSTR; i++ )
        m_bstrUser[i] = NULL;

    m_bstrDisplayableAddress = NULL;
    m_bstrOriginalAddress = NULL;
    m_dwAddressType = 0;
    m_nCallLogType = CL_CALL_OUTGOING;

    m_lCallID = 0;
    m_bKillMe = false;
    m_bResolvedAddress = false;

    m_bPreviewStreaming = false;
    m_bRcvVideoStreaming = false;
    m_bMustDisconnect = false;

    SYSTEMTIME st;
    GetLocalTime( &st );
    SystemTimeToVariantTime( &st, &m_dateStart );
}

void CAVTapiCall::FinalRelease()
{
    ATLTRACE(_T(".enter.CAVTapiCall::FinalRelease().\n"));
#ifdef _DEBUG
    if ( !m_bCallLogged )
        ATLTRACE(_T(".warning.CAVTapiCall::FinalRelease() -- call not logged.\n") );
#endif _DEBUG

    m_bKillMe = true;

    // Insure that the Video windows have been destroyed
    short i = 0;
    IVideoWindow *pVideoWindow;
    while ( SUCCEEDED(get_IVideoWindow(i, (IDispatch **) &pVideoWindow)) )
    {
        ATLTRACE(_T(".1.CAVTapiCall::FinalRelease() hiding term #%d.\n"), i );
//        CAVTapi::SetVideoWindowProperties( pVideoWindow, NULL, false );
        pVideoWindow->Release();
        i++;
    }

    // Video preview
    if ( SUCCEEDED(get_IVideoWindowPreview((IDispatch **) &pVideoWindow)) )
    {
        ATLTRACE(_T(".1.CAVTapiCall::FinalRelease() hiding preview.\n") );
        CAVTapi::SetVideoWindowProperties( pVideoWindow, NULL, false );
        pVideoWindow->Release();
    }

    m_atomList.Lock( CAtomicList::LIST_WRITE );
    RELEASE_LIST( m_lstParticipants );
    m_atomList.Unlock( CAtomicList::LIST_WRITE );

    RELEASE_CRITLIST( m_lstStreamingVideo, m_critLstStreamingVideo );
    RELEASE( m_pITControl );
    RELEASE( m_pITTerminalPreview );

#ifdef _DEBUG
    // Clean out the list of terminal streams
    USES_CONVERSION;
    TERMINALLIST::iterator j, jEnd = m_lstTerminals.end();
    for ( j = m_lstTerminals.begin(); j != jEnd; j++ )
    {
        BSTR bstrName = NULL;
        (*j)->get_Name( &bstrName );
        (*j)->AddRef();
        DWORD dwRet = (*j)->Release();
        ATLTRACE(_T(".1.CAVTapiCall::FinalRelease() -- terminal ref @ %d, %s.\n"), dwRet - 1, OLE2CT(bstrName) );
        SysFreeString( bstrName );
    }
#endif

    RELEASE_CRITLIST( m_lstTerminals, m_critTerminals );

    // Shutdown thread
    if ( m_dwThreadID )
    {
        PostThreadMessage( m_dwThreadID, WM_THREADINSTRUCTION, TI_QUIT, 0 );
        Sleep(0);
    }

    SysFreeString( m_bstrDisplayableAddress );
    SysFreeString( m_bstrOriginalAddress );
    SysFreeString( m_bstrName );
    for ( i = 0; i < NUM_USER_BSTR; i++ )
        SysFreeString( m_bstrUser[i] );

    ATLTRACE(_T(".exit.CAVTapiCall::FinalRelease().\n"));    
    CComObjectRootEx<CComMultiThreadModel>::FinalRelease();
}


STDMETHODIMP CAVTapiCall::get_lCallID(long * pVal)
{
    Lock();
    *pVal = m_lCallID;
    Unlock();
    return S_OK;
}

STDMETHODIMP CAVTapiCall::put_lCallID(long newVal)
{
    Lock();
    m_lCallID = newVal;
    Unlock();

    return S_OK;
}

STDMETHODIMP CAVTapiCall::get_callState(CALL_STATE * pVal)
{
    Lock();
    *pVal = m_callState;
    Unlock();
    return S_OK;
}

STDMETHODIMP CAVTapiCall::put_callState(CALL_STATE newVal)
{
    DWORD dwAddressType = 0;

    Lock();
    m_callState = newVal;
    dwAddressType = m_dwAddressType;

    if ( m_callState == CS_CONNECTED )
        m_bMustDisconnect = true;

    Unlock();

    // Notify conf room of state change (might be it's call)
    if ( dwAddressType == LINEADDRESSTYPE_SDP ) 
    {
        CErrorInfo er( IDS_ER_THREAD_MSG_PROCESS, IDS_ER_CALL_ENTERCONFROOM );
        er.set_hr( NotifyConfRoomState((long *) &er) );
//        PostMessage( 0, CAVTapiCall::TI_NOTIFYCONFROOMSTATE );
    }

    return S_OK;
}

STDMETHODIMP CAVTapiCall::get_ITBasicCallControl(ITBasicCallControl **ppVal)
{
    HRESULT hr = E_FAIL;
    
    Lock();
    if ( m_pITControl )
        hr = m_pITControl->QueryInterface( IID_ITBasicCallControl, (void **) ppVal );
    else
        *ppVal = NULL;
    Unlock();

    return hr;
}

STDMETHODIMP CAVTapiCall::put_ITBasicCallControl(ITBasicCallControl *newVal)
{
    HRESULT hr = S_OK;

    Lock();
    RELEASE( m_pITControl );
    if ( newVal )
        hr = newVal->QueryInterface( IID_ITBasicCallControl, (void **) &m_pITControl );
    Unlock();

    return hr;
}

STDMETHODIMP CAVTapiCall::get_ITTerminalPreview(ITTerminal **ppVal)
{
    HRESULT hr = E_FAIL;
    
    Lock();
    if ( m_pITTerminalPreview )
        hr = m_pITTerminalPreview->QueryInterface( IID_ITTerminal, (void **) ppVal );
    Unlock();
    return hr;
}

STDMETHODIMP CAVTapiCall::put_ITTerminalPreview(ITTerminal * newVal)
{
    HRESULT hr = S_OK;

    Lock();
    RELEASE( m_pITTerminalPreview );
    if ( newVal )
        hr = newVal->QueryInterface( IID_ITTerminal, (void **) &m_pITTerminalPreview );
    Unlock();

    return hr;
}

STDMETHODIMP CAVTapiCall::get_IVideoWindowPreview(IDispatch **ppVal)
{
    HRESULT hr = E_FAIL;
    
    Lock();
    if ( m_pITTerminalPreview )
        hr = m_pITTerminalPreview->QueryInterface( IID_IVideoWindow, (void **) ppVal );
    Unlock();

    return hr;
}


STDMETHODIMP CAVTapiCall::get_ITCallInfo(ITCallInfo **ppVal)
{
    HRESULT hr = E_FAIL;

    Lock();
    if ( m_pITControl )
        hr = m_pITControl->QueryInterface( IID_ITCallInfo, (void **) ppVal );
    Unlock();

    return hr;
}

STDMETHODIMP CAVTapiCall::get_ITParticipantControl(ITParticipantControl **ppVal)
{
    HRESULT hr = E_FAIL;

    Lock();
    if ( m_pITControl )
        hr = m_pITControl->QueryInterface( IID_ITParticipantControl, (void **) ppVal );
    Unlock();

    return hr;
}


STDMETHODIMP CAVTapiCall::get_ITAddress(ITAddress **ppVal)
{
    Lock();
    if ( !m_pITControl )
    {
         Unlock();
         return E_PENDING;
    }


    HRESULT hr;
    ITCallInfo *pInfo;
    if ( SUCCEEDED(hr = m_pITControl->QueryInterface(IID_ITCallInfo, (void **) &pInfo)) )
    {
        hr = pInfo->get_Address( ppVal );
        pInfo->Release();
    }
    Unlock();

    return hr;
}

STDMETHODIMP CAVTapiCall::get_ITCallHub(ITCallHub **ppVal)
{
    HRESULT hr = E_PENDING;

    Lock();
    // Register for call hub notifications
    ITCallInfo *pCallInfo;
    if ( SUCCEEDED(hr = get_ITCallInfo(&pCallInfo)) )
    {
        hr = pCallInfo->get_CallHub( ppVal );
        pCallInfo->Release();
    }
    Unlock();

    return hr;
}

STDMETHODIMP CAVTapiCall::get_IBasicVideo(IDispatch **ppVal)
{
    _ASSERT( FALSE ); // implement please
    return E_FAIL;
}

STDMETHODIMP CAVTapiCall::get_bKillMe(BOOL *pVal)
{
    Lock();
    *pVal = m_bKillMe;
    Unlock();
    return S_OK;
}

STDMETHODIMP CAVTapiCall::put_bKillMe(BOOL newVal)
{
    Lock();
    m_bKillMe =  newVal;
    Unlock();
    return S_OK;
}

STDMETHODIMP CAVTapiCall::get_nCallLogType(CallLogType * pVal)
{
    Lock();
    *pVal = m_nCallLogType;
    Unlock();
    return S_OK;
}

STDMETHODIMP CAVTapiCall::put_nCallLogType(CallLogType newVal)
{
    Lock();
    m_nCallLogType = newVal;
    Unlock();
    return S_OK;
}

STDMETHODIMP CAVTapiCall::CheckKillMe()
{
    Lock();
    HRESULT hr = (m_bKillMe) ? E_ABORT : S_OK;
    Unlock();

    return hr;
}

STDMETHODIMP CAVTapiCall::AddTerminal(ITTerminal *pITTerminal)
{
    _ASSERT( pITTerminal );

    DWORD dwCount = pITTerminal->AddRef();
    ATLTRACE(_T(".CAVTapiCall::AddTerminal() -- ref count at %ld.\n"), dwCount );
    m_critTerminals.Lock();
    m_lstTerminals.push_back( pITTerminal );
    m_critTerminals.Unlock();
    
    return S_OK;
}

STDMETHODIMP CAVTapiCall::RemoveTerminal(ITTerminal *pITTerminal)
{
    _ASSERT( pITTerminal );

    m_critTerminals.Lock();
    m_lstTerminals.remove( pITTerminal );
    m_critTerminals.Unlock();
    DWORD dwCount = pITTerminal->Release();
    ATLTRACE(_T(".CAVTapiCall::AddTerminal() -- ref count at %ld.\n"), dwCount );
    
    return S_OK;
}

STDMETHODIMP CAVTapiCall::get_dwAddressType(DWORD * pVal)
{
    Lock();
    *pVal = m_dwAddressType;
    Unlock();
    return S_OK;
}

STDMETHODIMP CAVTapiCall::put_dwAddressType(DWORD newVal)
{
    Lock();
    m_dwAddressType = newVal;
    Unlock();
    return S_OK;
}

STDMETHODIMP CAVTapiCall::Disconnect( VARIANT_BOOL bKill )
{
    // Signal that this call can be disconnected
    if ( bKill )
        put_bKillMe( TRUE );

    HRESULT hr;
    ITBasicCallControl *pITControl = NULL;
    if ( (hr = get_ITBasicCallControl(&pITControl)) == S_OK )
    {
        // Different disconnects based on the call state
        switch ( m_callState )
        {
            case CS_OFFERING:    hr = pITControl->Disconnect( DC_REJECTED );    break;

            case CS_INPROGRESS: hr = pITControl->Disconnect( DC_NOANSWER );    break;

            // Before attempting to disconnect, make sure we haven't already done it
            case CS_IDLE:
            case CS_DISCONNECTED:
            case CS_CONNECTED:
                Lock();
                if ( !m_bMustDisconnect )
                {
                    Unlock();
                    break;
                }
                m_bMustDisconnect = false;
                Unlock();

                hr = pITControl->Disconnect( DC_NORMAL );
                break;

            case CS_HOLD:
            case CS_QUEUED:        hr = E_FAIL;                                break;
        }
        pITControl->Release();
    }

    // Force the disconnect
    if ( FAILED(hr) )
    {
        ATLTRACE(_T(".error.CAVTapiCall::Disconnect(0x%08lx) -- requested on call that has no ITBasicCallControl.\n"), hr );
        _ASSERT( false );

        // Fake disconnect
        put_bKillMe( TRUE );
        put_callState( CS_DISCONNECTED );

        // Log the call
        CallLogType nType;
        get_nCallLogType( &nType );
        if ( nType != CL_CALL_CONFERENCE )
            Log( nType );

        // Now remove ourselves from the call list
        CAVTapi *pAVTapi;
        if ( SUCCEEDED(_Module.GetAVTapi(&pAVTapi)) )
        {
            long lCallID;
            get_lCallID(&lCallID);
            
            if ( lCallID )            
            {
                pAVTapi->fire_CloseCallControl( lCallID );
                pAVTapi->RemoveAVTapiCall( NULL );
            }

            (dynamic_cast<IUnknown *> (pAVTapi))->Release();
        }
    }

    return hr;
}

STDMETHODIMP CAVTapiCall::NotifyConfRoomState(long *pErrorInfo)
{
    CComPtr<IAVTapi> pAVTapi;
    if ( SUCCEEDED(_Module.get_AVTapi(&pAVTapi)) )
    {
        // Notify the conference room of this update
        IConfRoom *pConfRoom;
        if ( SUCCEEDED(pAVTapi->get_ConfRoom(&pConfRoom)) )
        {
            CALL_STATE nState;
            get_callState( &nState );

            // If the call has just connected, enumerate the participants
            if ( nState == CS_CONNECTED )
            {
                Lock();
                m_nCallLogType = CL_CALL_CONFERENCE;
                Unlock();
                EnumParticipants();
            }
                        
            pConfRoom->NotifyStateChange( dynamic_cast<IAVTapiCall *> (this) );
            pConfRoom->Release();
        }
    }

    return S_OK;
}


STDMETHODIMP CAVTapiCall::get_bstrDisplayableAddress(BSTR * pVal)
{
    Lock();
    HRESULT hr = SysReAllocString( pVal, m_bstrDisplayableAddress );
    Unlock();

    return S_OK;
}

STDMETHODIMP CAVTapiCall::put_bstrDisplayableAddress(BSTR newVal)
{
    Lock();
    HRESULT hr = SysReAllocString( &m_bstrDisplayableAddress, newVal );
    Unlock();

    return S_OK;
}


STDMETHODIMP CAVTapiCall::get_bstrOriginalAddress(BSTR *pVal)
{
    Lock();
    HRESULT hr = SysReAllocString( pVal, m_bstrOriginalAddress );
    Unlock();

    return hr;
}

STDMETHODIMP CAVTapiCall::put_bstrOriginalAddress(BSTR newVal)
{
    Lock();
    HRESULT hr = SysReAllocString( &m_bstrOriginalAddress, newVal );
    Unlock();

    return hr;
}

STDMETHODIMP CAVTapiCall::get_bstrName(BSTR * pVal)
{
    Lock();
    HRESULT hr = SysReAllocString( pVal, m_bstrName );
    Unlock();

    return hr;
}

STDMETHODIMP CAVTapiCall::put_bstrName(BSTR newVal)
{
    Lock();
    HRESULT hr = SysReAllocString( &m_bstrName, newVal );
    Unlock();

    return hr;
}

STDMETHODIMP CAVTapiCall::get_bstrUser(short nIndex, BSTR * pVal)
{
    // Validate parameters
    _ASSERT( pVal );
    _ASSERT( (nIndex >= 0) && (nIndex < NUM_USER_BSTR) );
    if ( !pVal ) return E_POINTER;
    if ( (nIndex < 0) || (nIndex >= NUM_USER_BSTR) )
        return E_INVALIDARG;

    Lock();
    HRESULT hr = SysReAllocString( pVal, m_bstrUser[nIndex] );
    Unlock();
    return S_OK;
}

STDMETHODIMP CAVTapiCall::put_bstrUser(short nIndex, BSTR newVal)
{
    // Validate index
    _ASSERT( (nIndex >= 0) && (nIndex < NUM_USER_BSTR) );
    if ( (nIndex < 0) || (nIndex >= NUM_USER_BSTR) )
        return E_INVALIDARG;

    Lock();
    HRESULT hr = SysReAllocString( &m_bstrUser[nIndex], newVal );
    Unlock();
    return S_OK;
}

STDMETHODIMP CAVTapiCall::TerminalArrival(ITTerminal *pTerminal)
{
    DWORD dwAddressType;
    LONG lMediaType;
    TERMINAL_DIRECTION nDir;
    HRESULT hr = S_OK;
        
    get_dwAddressType(&dwAddressType);

    pTerminal->get_MediaType(&lMediaType);
    pTerminal->get_Direction(&nDir);

    ITCallInfo *pCallInfo;
    hr = get_ITCallInfo(&pCallInfo);

    if ( SUCCEEDED(hr) )
    {
        ITAddress *pAddress;
        hr = get_ITAddress(&pAddress);

        if ( SUCCEEDED(hr) )
        {
            ITStreamControl *pStreamControl;
            hr = pCallInfo->QueryInterface( IID_ITStreamControl, (void **) &pStreamControl );

            if ( SUCCEEDED(hr) )
            {
                // What media types does the address support
                long lSupportedMediaTypes = 0;
                ITMediaSupport *pMediaSupport;
                if ( SUCCEEDED(pAddress->QueryInterface(IID_ITMediaSupport, (void **) &pMediaSupport)) )
                {
                    pMediaSupport->get_MediaTypes( &lSupportedMediaTypes );
                    pMediaSupport->Release();
                }

                // Skip if the address doesn't support the media type                
                if ( lMediaType & lSupportedMediaTypes )
                {

                    CAVTapi *pAVTapi;
                    if ( SUCCEEDED(_Module.GetAVTapi(&pAVTapi)) )
                    {
                         hr = pAVTapi->SelectTerminalOnStream(pStreamControl, lMediaType, nDir, pTerminal, this);

                         if ( SUCCEEDED(hr) )
                         {
                             // Do we need to allocate a preview window
                             if ( (lMediaType == TAPIMEDIATYPE_VIDEO) && (nDir == TD_CAPTURE) )
                             {
                                ITTerminalSupport *pTerminalSupport;
                                BSTR bstrTerminalClass = NULL;
                                LPOLESTR psz = NULL;
                                STRING_FROM_IID(CLSID_VideoWindowTerm, bstrTerminalClass);
                                
                                hr = pAddress->QueryInterface(IID_ITTerminalSupport, (void **) &pTerminalSupport);

                                if ( SUCCEEDED(hr) )
                                {
                                    ITTerminal *pPreviewTerminal = NULL;

                                    hr = pTerminalSupport->CreateTerminal(bstrTerminalClass, TAPIMEDIATYPE_VIDEO, TD_RENDER, &pPreviewTerminal);
                                    {
                                        hr = pAVTapi->SelectTerminalOnStream( pStreamControl, TAPIMEDIATYPE_VIDEO, TD_CAPTURE, pPreviewTerminal, this );
                                        pPreviewTerminal->Release();
                                    }                                  
                                }
                               
                                if ( (dwAddressType & LINEADDRESSTYPE_SDP) != NULL )
                                {
                                    IConfRoom *pConfRoom;
                                    if ( SUCCEEDED(pAVTapi->get_ConfRoom(&pConfRoom)) )
                                    {
                                        if (pConfRoom->IsConfRoomConnected() == S_OK)
                                            pConfRoom->put_CallState(CS_CONNECTED);
                                        pConfRoom->Release();
                                    }
                                }

                                SysFreeString(bstrTerminalClass);
                                pTerminalSupport->Release();
                             }
                         }
                    }
                }
                pStreamControl->Release();
            }
            pAddress->Release();
        }
        pCallInfo->Release();
    }

    return hr;
}

STDMETHODIMP CAVTapiCall::TerminalRemoval(ITTerminal *pTerminal)
{
    DWORD dwAddressType;
    LONG lMediaType;
    TERMINAL_DIRECTION nDir;
    HRESULT hr = S_OK;
        
    get_dwAddressType(&dwAddressType);

    pTerminal->get_MediaType(&lMediaType);
    pTerminal->get_Direction(&nDir);

    ITCallInfo *pCallInfo;
    hr = get_ITCallInfo(&pCallInfo);

    if ( SUCCEEDED(hr) )
    {
        ITAddress *pAddress;
        hr = get_ITAddress(&pAddress);

        if ( SUCCEEDED(hr) )
        {
            ITStreamControl *pStreamControl;
            hr = pCallInfo->QueryInterface( IID_ITStreamControl, (void **) &pStreamControl );

            if ( SUCCEEDED(hr) )
            {
                // What media types does the address support
                long lSupportedMediaTypes = 0;
                ITMediaSupport *pMediaSupport;
                if ( SUCCEEDED(pAddress->QueryInterface(IID_ITMediaSupport, (void **) &pMediaSupport)) )
                {
                    pMediaSupport->get_MediaTypes( &lSupportedMediaTypes );
                    pMediaSupport->Release();
                }

                // Skip if the address doesn't support the media type                
                if ( lMediaType & lSupportedMediaTypes )
                {

                    CAVTapi *pAVTapi;
                    if ( SUCCEEDED(_Module.GetAVTapi(&pAVTapi)) )
                    {
                         hr = pAVTapi->UnselectTerminalOnStream(pStreamControl, lMediaType, nDir, pTerminal, this);

                         if ( SUCCEEDED(hr) )
                         {
                             // Do we need to remove a preview window
                             if ( (lMediaType == TAPIMEDIATYPE_VIDEO) && (nDir == TD_CAPTURE) )
                             {
                                ITTerminal *pPreviewTerminal = NULL;

                                hr = get_ITTerminalPreview( &pPreviewTerminal );

                                if ( SUCCEEDED(hr) )
                                {                                    
                                    BSTR bstrTerminalClass = NULL;
                                    LPOLESTR psz = NULL;
                                    STRING_FROM_IID(CLSID_VideoWindowTerm, bstrTerminalClass);

                                    hr = pAVTapi->UnselectTerminalOnStream( pStreamControl, TAPIMEDIATYPE_VIDEO, TD_CAPTURE, pPreviewTerminal, this );

                                    SysFreeString(bstrTerminalClass);
                                    pPreviewTerminal->Release();
                                }

                                if ( (dwAddressType & LINEADDRESSTYPE_SDP) != NULL )
                                {
                                    IConfRoom *pConfRoom;
                                    if ( SUCCEEDED(pAVTapi->get_ConfRoom(&pConfRoom)) )
                                    {
                                        if (pConfRoom->IsConfRoomConnected() == S_OK)
                                            pConfRoom->put_CallState(CS_CONNECTED);
                                        pConfRoom->Release();
                                    }
                                }
                             }
                         }

                         ITTerminalSupport *pTerminalSupport;

                         hr = pAddress->QueryInterface(IID_ITTerminalSupport, (void **) &pTerminalSupport);

                         if ( SUCCEEDED(hr) )
                         {
                             ITTerminal *pDefaultTerminal = NULL;

                             hr = pTerminalSupport->GetDefaultStaticTerminal( lMediaType, nDir, &pDefaultTerminal );

                             if ( SUCCEEDED(hr) )
                             {
                                 TerminalArrival(pDefaultTerminal);
                                 pDefaultTerminal->Release();                             
                             }
                             pTerminalSupport->Release();                            
                         }
                    }
                }
                pStreamControl->Release();
            }
            pAddress->Release();
        }
        pCallInfo->Release();
    }

    return hr;
}

STDMETHODIMP CAVTapiCall::get_bstrCallerID(BSTR * pVal)
{
    Lock();
    CComBSTR bstrRet( m_bstrName );

    BSTR bstrAddr = (m_bstrDisplayableAddress) ?  m_bstrDisplayableAddress : m_bstrOriginalAddress;

    // Only add if the address is different then the name!
    if ( bstrAddr && (SysStringLen(bstrAddr) > 0) && (!m_bstrName || wcscmp(m_bstrName, bstrAddr)) )
    {
        // Add new line if necessary
        if ( bstrRet.Length() > 0  )
            bstrRet.Append( L"\n" );

        bstrRet.Append( bstrAddr );
    }

    // Do user variables...
    for ( int i = 0; i < NUM_USER_BSTR; i++ )
    {
        if ( m_bstrUser[i] && (SysStringLen(m_bstrUser[i]) > 0) )
        {
            if ( bstrRet.Length() > 0 )
                bstrRet.Append( L"\n" );

            bstrRet.Append( m_bstrUser[i] );
        }
    }

    Unlock();

    // Use unknown if we have no caller ID
    if ( !bstrRet.Length() )
    {
        USES_CONVERSION;

        TCHAR szText[255];
        LoadString( _Module.GetResourceInstance(), IDS_UNKNOWN, szText, ARRAYSIZE(szText) );
        bstrRet = szText;
    }

    return SysReAllocString( pVal, bstrRet );
}

STDMETHODIMP CAVTapiCall::get_dwThreadID(DWORD * pVal)
{
    Lock();
    *pVal = m_dwThreadID;
    Unlock();
    return S_OK;
}

STDMETHODIMP CAVTapiCall::put_dwThreadID(DWORD newVal)
{
    Lock();
    m_dwThreadID = newVal;
    Unlock();
    return S_OK;
}

STDMETHODIMP CAVTapiCall::PostMessage(long msg, WPARAM wParam)
{
    ATLTRACE(_T(".enter.CAVTapiCall::PostMesage(%ld, %ld).\n"), msg, wParam );
    HRESULT hr = E_FAIL;

    Lock();

    // Always kill call with this instruction
    if ( wParam == TI_DISCONNECT )
        m_bKillMe = true;

    // Do we have a thread running for this call?
    if ( m_dwThreadID )
    {
        AddRef();
        if ( PostThreadMessage(m_dwThreadID, (msg) ? msg : WM_THREADINSTRUCTION, wParam, (LPARAM) this) )
        {
            hr = S_OK;
        }
        else
        {
            Release();
            hr = E_FAIL;
        }
    }
    else if ( wParam == TI_DISCONNECT )
    {
        // No thread running, should we disconnect?
        hr = Disconnect( TRUE );
    }
    Unlock();
    
    ATLTRACE(_T(".exit.CAVTapiCall::PostMessage().\n"));
    return hr;
}


////////////////////////////////////////////////////////////////////
// Message loop for dialing and answer threads
//
bool CAVTapiCall::WaitWithMessageLoop()
{
    DWORD dwRet;
    MSG msg;
    bool bExit = false;

    while( !bExit )
    {
        dwRet = MsgWaitForMultipleObjects(1, &_Module.m_hEventThreadWakeUp, FALSE, INFINITE, QS_ALLINPUT);

        if (dwRet == WAIT_OBJECT_0)
            return true;    // The event was signaled

        if (dwRet != WAIT_OBJECT_0 + 1)
            break;          // Something else happened

        // There is one or more window message available. Dispatch them
        while(PeekMessage(&msg,NULL,NULL,NULL,PM_REMOVE))
        {
            CErrorInfo er;
            er.set_Operation( IDS_ER_THREAD_MSG_PROCESS );
            IAVTapiCall *pAVCall = (IAVTapiCall *) msg.lParam;
            bool bRelease = true;

            switch ( msg.message )
            {
                case WM_THREADINSTRUCTION:
                    switch( msg.wParam )
                    {
                        // Terminate thread
                        case TI_QUIT:
                            bExit = true;
                            break;

                        // Disconnect call
                        case TI_REJECT:
                        case TI_DISCONNECT:
                            er.set_Details( IDS_ER_CALL_DISCONNECT );
                            er.set_hr( pAVCall->Disconnect( TRUE ) );
                            break;

                        // Enter the conference room
                        case TI_NOTIFYCONFROOMSTATE:
                            er.set_Details( IDS_ER_CALL_ENTERCONFROOM );
                            er.set_hr( pAVCall->NotifyConfRoomState((long *) &er) );
                            break;

                        // Set QOS on conference room participants
                        case TI_REQUEST_QOS:
                            {
                                CComPtr<IAVTapi> pAVTapi;
                                if ( SUCCEEDED(_Module.get_AVTapi(&pAVTapi)) )
                                {
                                    IConfRoom *pConfRoom;
                                    if ( SUCCEEDED(pAVTapi->get_ConfRoom(&pConfRoom)) )
                                    {
                                        pConfRoom->SetQOSOnParticipants();
                                        pConfRoom->Release();
                                    }
                                }
                            }
                            break;

                        // Recieving user to user information
                        case TI_USERUSERINFO:
                            pAVCall->HandleUserUserInfo();
                            break;

                        case TI_STREAM_ACTIVE:
                            pAVCall->put_StreamActive( true );
                            break;

                        case TI_STREAM_INACTIVE:
                            pAVCall->put_StreamActive( false );
                            break;

                        case TI_RCV_VIDEO_ACTIVE:
                            pAVCall->put_RcvVideoStreaming( true  );
                            break;

                        case TI_RCV_VIDEO_INACTIVE:
                            pAVCall->put_RcvVideoStreaming( false );
                            break;
                    }
                    break;
                
                // Call state changed
                case WM_CALLSTATE:
                    if ( msg.wParam )
                    {
                        CComPtr<IAVTapi> pAVTapi;
                        if ( SUCCEEDED(_Module.get_AVTapi(&pAVTapi)) )
                        {
                            long lCallID;
                            pAVCall->get_lCallID( &lCallID );
                            pAVTapi->fire_SetCallState( lCallID, (ITCallStateEvent *) msg.wParam, pAVCall );
                        }
                        ((ITCallStateEvent *) msg.wParam)->Release();
                    }
                    break;

                // Participant being added to list of participants
                case WM_ADDPARTICIPANT:
                    if ( msg.wParam )
                    {
                        ITParticipant *p = (ITParticipant *) msg.wParam;
                        pAVCall->AddParticipant( p );
                        pAVCall->NotifyParticipantChangeConfRoom( p, AV_PARTICIPANT_JOIN );
                        p->Release();
                    }
                    break;

                // Participant being removed from the list of participants
                case WM_REMOVEPARTICIPANT:
                    if ( msg.wParam )
                    {
                        ITParticipant *p = (ITParticipant *) msg.wParam;
                        pAVCall->RemoveParticipant( p );
                        pAVCall->NotifyParticipantChangeConfRoom( p, AV_PARTICIPANT_LEAVE );
                        p->Release();
                    }
                    break;

                // Participant's information changing
                case WM_UPDATEPARTICIPANT:
                    if ( msg.wParam )
                    {
                        ITParticipant *p = (ITParticipant *) msg.wParam;
                        pAVCall->UpdateParticipant( p );
                        pAVCall->NotifyParticipantChangeConfRoom( p, AV_PARTICIPANT_UPDATE );
                        p->Release();
                    }
                    break;


                /////////////////////////////////////////////////////////////
                // Participant being mapped or unmapped from conference 
                case WM_STREAM_EVENT:
                    if ( msg.wParam )
                    {
                        ATLTRACE(_T(".1.CAVTapiCall::WaitWithMessageLoop() -- WM_STREAM_EVENT.\n"));
                        CComPtr<IAVTapi> pAVTapi;
                        ITParticipantEvent *pParticipantEvent = (ITParticipantEvent *) msg.wParam;
                        PARTICIPANT_EVENT nEvent;
                        ITSubStream *pITSubStream;
                        if ( SUCCEEDED(pParticipantEvent->get_Event(&nEvent)) &&
                             SUCCEEDED(_Module.get_AVTapi(&pAVTapi)) &&
                             SUCCEEDED(pParticipantEvent->get_SubStream(&pITSubStream)) )
                        {
                            IConfRoom *pConfRoom;
                            if (SUCCEEDED(pAVTapi->get_ConfRoom(&pConfRoom)) )
                            {
                                IVideoFeed *pFeed;
                                if ( SUCCEEDED(pConfRoom->FindVideoFeedFromSubStream(pITSubStream, &pFeed)) )
                                {
                                    ITParticipant *pParticipant;
                                    if ( SUCCEEDED(pParticipantEvent->get_Participant(&pParticipant)) )
                                    {
                                        pFeed->put_ITParticipant( (nEvent == PE_SUBSTREAM_MAPPED) ? pParticipant : NULL );
                                        pAVCall->OnStreamingChanged( pFeed, (bool) (nEvent == PE_SUBSTREAM_MAPPED) );

                                        pParticipant->Release();
                                    }
                                    pFeed->Release();
                                }
                                pConfRoom->Release();
                            }
                            pITSubStream->Release();
                        }
                        pParticipantEvent->Release();
                    }
                    break;

                // Terminal is streaming video
                case WM_CME_STREAMSTART:
                    if ( msg.wParam )
                    {
                        pAVCall->OnStreamingChanged( (IVideoFeed *) msg.wParam, true );
                        ((IVideoFeed *) msg.wParam)->Release();
                    }
                    break;

                // Terminal has stopped streaming video
                case WM_CME_STREAMSTOP:
                    if ( msg.wParam )
                    {
                        pAVCall->OnStreamingChanged( (IVideoFeed *) msg.wParam, false );
                        ((IVideoFeed *) msg.wParam)->Release();
                    }
                    break;

                default:
                    // Normal dispatch
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                    bRelease = false;
                    break;
            }

            // Release the AVTapiCall interface
            if ( bRelease && pAVCall ) pAVCall->Release();

            // Anything signaled?
            if (WaitForSingleObject(_Module.m_hEventThreadWakeUp, 0) == WAIT_OBJECT_0)
                return true; // Event is now signaled.
        }
    }
    return false;
}

STDMETHODIMP CAVTapiCall::get_IVideoWindow(short nInd, IDispatch **ppVal )
{
    return GetTerminalInterface( IID_IVideoWindow, TAPIMEDIATYPE_VIDEO, TD_RENDER, (void **) ppVal, nInd );
}

STDMETHODIMP CAVTapiCall::get_ITBasicAudioTerminal(ITBasicAudioTerminal **ppVal)
{
    return GetTerminalInterface( IID_ITBasicAudioTerminal, TAPIMEDIATYPE_AUDIO, TD_CAPTURE, (void **) ppVal, 0 );
}

HRESULT CAVTapiCall::GetTerminalInterface( REFIID riid, long nMediaType, TERMINAL_DIRECTION nTD, void **ppVoid, short nInd )
{
    USES_CONVERSION;

    _ASSERT( ppVoid );
    *ppVoid = NULL;

    HRESULT hr = E_FAIL;
    long nType;
    bool bBreak = false;

    // $CRIT - enter
    m_critTerminals.Lock();
    TERMINALLIST::iterator i, iEnd = m_lstTerminals.end();
    for ( i = m_lstTerminals.begin(); i != iEnd; i++ )
    {
        TERMINAL_DIRECTION nCurTD;
        if ( SUCCEEDED(hr = (*i)->get_Direction(&nCurTD)) && (nCurTD == nTD) &&
             SUCCEEDED(hr = (*i)->get_MediaType(&nType)) && (nType == nMediaType) )
        {
            if ( !nInd )
            {
                hr = (*i)->QueryInterface( riid, ppVoid );
                bBreak = true;
            }
            else
            {
                nInd--;
            }
        }

        // Found a video window...
        if ( bBreak ) break;

        // Prepare for next loop
        hr = E_NOINTERFACE;
    }
    // $CRIT - exit
    m_critTerminals.Unlock();
    return hr;
}

STDMETHODIMP CAVTapiCall::get_dwCaps(DWORD * pVal)
{
    *pVal = 0;

    // Check audio capabilities for call
    ITBasicAudioTerminal *pBasicAudio;
    if ( SUCCEEDED(get_ITBasicAudioTerminal(&pBasicAudio)) )
    {
        *pVal += CALL_CAPS_FULLDUPLEX_AUDIO;
        pBasicAudio->Release();
    }

    // Check video capture capabilities for call
    ITTerminal *pITTerminal;
    TERMINAL_STATE nState;

    if ( SUCCEEDED(GetTerminalInterface(IID_ITTerminal, TAPIMEDIATYPE_VIDEO, TD_CAPTURE, (void **) &pITTerminal, 0 )) )
    {
        if ( SUCCEEDED(pITTerminal->get_State(&nState)) && (nState == TS_INUSE) )
            *pVal += CALL_CAPS_VIDEO_CAPTURE;

        pITTerminal->Release();
    }

    // Check video render capabilities for call
    if ( SUCCEEDED(GetTerminalInterface(IID_ITTerminal, TAPIMEDIATYPE_VIDEO, TD_RENDER, (void **) &pITTerminal, 0 )) )
    {
        if ( SUCCEEDED(pITTerminal->get_State(&nState)) && (nState == TS_INUSE) )
            *pVal += CALL_CAPS_VIDEO_RENDER;

        pITTerminal->Release();
    }

    return S_OK;
}


STDMETHODIMP CAVTapiCall::Log( CallLogType nType )
{
    CComPtr<IAVTapi> pAVTapi;
    if ( FAILED(_Module.get_AVTapi(&pAVTapi)) ) return E_PENDING;

    DATE dateEnd;
    SYSTEMTIME st;
    GetLocalTime( &st );
    SystemTimeToVariantTime( &st, &dateEnd );

    HRESULT hr = E_ABORT;
    Lock();
    if ( !m_bCallLogged )
    {
        // Request that the app log the call
        hr = pAVTapi->fire_LogCall( m_lCallID, m_nCallLogType, m_dateStart, dateEnd, m_bstrOriginalAddress, m_bstrName );
        m_bCallLogged = true;
    }
    Unlock();
     
    return hr;
}

STDMETHODIMP CAVTapiCall::ResolveAddress()
{
    HRESULT hr = E_ACCESSDENIED;
    CComPtr<IAVGeneralNotification> pAVGen;

    Lock();
    // We don't resolve conference names!
    if ( !m_bResolvedAddress && (m_dwAddressType != LINEADDRESSTYPE_SDP) )
    {
        BSTR bstrName = NULL;
        BSTR bstrUser1 = NULL;
        BSTR bstrUser2 = NULL;

        if ( !m_bResolvedAddress && SUCCEEDED(hr = _Module.get_AVGenNot(&pAVGen)) )
        {    
            if ( SUCCEEDED(hr = pAVGen->fire_ResolveAddress(m_bstrOriginalAddress, &bstrName, &bstrUser1, &bstrUser2)) )
                m_bResolvedAddress = true;

            if ( bstrName && (SysStringLen(bstrName) > 0) )
                SysReAllocString( &m_bstrName, bstrName );

            if ( bstrUser1 && (SysStringLen(bstrUser1) > 0) )
                SysReAllocString( &m_bstrUser[0], bstrUser1 );

            if ( bstrUser2 && (SysStringLen(bstrUser2) > 0) )
                SysReAllocString( &m_bstrUser[1], bstrUser2 );
        }

        // Clean-up
        SysFreeString( bstrName );
        SysFreeString( bstrUser1 );
        SysFreeString( bstrUser2 );
    }
    Unlock();

    return hr;
}

STDMETHODIMP CAVTapiCall::PopulateTreeView( IConfRoomTreeView *pTreeView )
{
    _ASSERT( pTreeView );
    if ( !pTreeView ) return E_POINTER;

    CComPtr<IAVGeneralNotification> pAVGen;
    if ( FAILED(_Module.get_AVGenNot(&pAVGen)) )
        return E_UNEXPECTED;

    USES_CONVERSION;    
    HWND hWnd;
    TCHAR szText[255];
    pTreeView->get_hWnd( &hWnd );

    if ( IsWindow(hWnd) )
    {
        // Populate list
        SendMessage( hWnd, WM_SETREDRAW, FALSE, 0 );

        // Add Me
        LoadString( _Module.GetResourceInstance(), IDS_CONFROOM_ME, szText, ARRAYSIZE(szText) );
        BSTR bstrTemp = NULL;
        bstrTemp = SysAllocString( T2COLE(szText) );
        pAVGen->fire_UpdateConfParticipant( UPDATE_ADD, NULL, bstrTemp );
        SysFreeString( bstrTemp );
            

        // Walk list adding participants
        m_atomList.Lock( CAtomicList::LIST_READ );
        PARTICIPANTLIST::iterator i, iEnd = m_lstParticipants.end();
        for ( i = m_lstParticipants.begin(); i != iEnd; i++ )
        {
            BSTR bstrTemp = NULL;
            (*i)->get_bstrDisplayName( CParticipant::NAMESTYLE_PARTICIPANT, &bstrTemp );
            ATLTRACE(_T("CAVTapiCall::PopulateTreeView() Added Participant %s\n"),OLE2CT(bstrTemp));
            pAVGen->fire_UpdateConfParticipant( UPDATE_ADD, *i, bstrTemp );
            SysFreeString(bstrTemp);
        }
        m_atomList.Unlock( CAtomicList::LIST_READ );
            
        SendMessage( hWnd, WM_SETREDRAW, true, 0 );
        InvalidateRect( hWnd, NULL, true );

        // Insure that tree view has something selected!
        IConfRoom *pConfRoom;
        if ( SUCCEEDED(pTreeView->get_ConfRoom(&pConfRoom)) )
        {
            ITParticipant *pParticipant = NULL;
            pConfRoom->get_TalkerParticipant( &pParticipant );
            pConfRoom->SelectTalker( pParticipant, true );
            RELEASE( pParticipant );

            pConfRoom->Release();
        }
    }
    
    return S_OK;
}

////////////////////////////////////////////////////////////////////////
// ForceCallerIDUpdate
//
// Forces an update of the caller ID on the slide window.  Uses the CAVTapi::fire_SetCallerID
// method to force the update
//
STDMETHODIMP CAVTapiCall::ForceCallerIDUpdate()
{
    HRESULT hr;
    CComPtr<IAVTapi> pAVTapi;

    if ( SUCCEEDED(hr = _Module.get_AVTapi(&pAVTapi)) )
    {
        BSTR bstrCallerID = NULL;
        long lCallID;

        get_bstrCallerID( &bstrCallerID );
        get_lCallID( &lCallID );

        hr = pAVTapi->fire_SetCallerID( lCallID, bstrCallerID );
        SysFreeString( bstrCallerID );
    }

    return S_OK;
}

STDMETHODIMP CAVTapiCall::NotifyStreamEvent(CALL_MEDIA_EVENT cme)
{
    return S_OK;
}


STDMETHODIMP CAVTapiCall::GetVideoFeedCount(short * pnCount)
{
    if ( !pnCount ) return E_POINTER;
    *pnCount = 0;

    // Figure out how many video terminals we need to add
    IVideoWindow *pVideo = NULL;
    while ( get_IVideoWindow(*pnCount, (IDispatch **) &pVideo) == S_OK )
    {
        pVideo->Release();
        (*pnCount)++;
    }

    return S_OK;
}


STDMETHODIMP CAVTapiCall::get_bResolved(VARIANT_BOOL * pVal)
{
    Lock();
    *pVal = m_bResolvedAddress;
    Unlock();

    return S_OK;
}

STDMETHODIMP CAVTapiCall::put_bResolved(VARIANT_BOOL newVal)
{
    Lock();
    m_bResolvedAddress = (bool) (newVal != 0);
    Unlock();

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////////////////
// Participant functions
//

STDMETHODIMP CAVTapiCall::AddParticipant(ITParticipant * pParticipant)
{
    ATLTRACE(_T(".enter.CAVTapiCall::AddParticipant(%p).\n"), pParticipant );
    _ASSERT( pParticipant );
    if ( !pParticipant ) return E_POINTER;

    // First see if the partipant exists
    m_atomList.Lock( CAtomicList::LIST_WRITE );
    IParticipant *pFind;
    if ( SUCCEEDED(FindParticipant(pParticipant, &pFind)) )
    {
        pFind->Release();
        m_atomList.Unlock( CAtomicList::LIST_WRITE );
        return S_OK;
    }

    // Didn't find it, add to the list
    IParticipant *pNew = new CComObject<CParticipant>;
    if ( pNew )
    {
        pNew->AddRef();
        pNew->put_ITParticipant( pParticipant );
        
        m_lstParticipants.push_back( pNew );
    }
    m_atomList.Unlock( CAtomicList::LIST_WRITE );

    // Notify of adding the participant to the tree view
    CComPtr<IAVGeneralNotification> pAVGen;
    if ( pNew && SUCCEEDED(_Module.get_AVGenNot(&pAVGen)) )
    {
#ifdef _DEBUG
        pNew->AddRef();
        ATLTRACE(_T(".1.CAVTapiCall::AddParticipant() refcount - %p @ %ld.\n"), pNew, pNew->Release() );
#endif
        BSTR bstrName = NULL;
        pNew->get_bstrDisplayName( CParticipant::NAMESTYLE_PARTICIPANT, &bstrName );
        pAVGen->fire_UpdateConfParticipant( UPDATE_ADD, pNew, bstrName );
        SysFreeString( bstrName );
    }

    return (pNew) ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP CAVTapiCall::RemoveParticipant(ITParticipant * pParticipant)
{
    ATLTRACE(_T(".enter.CAVTapiCall::RemoveParticipant(%p).\n"), pParticipant );
    HRESULT hr = E_FAIL;

    m_atomList.Lock( CAtomicList::LIST_WRITE );
    PARTICIPANTLIST::iterator i, iEnd = m_lstParticipants.end();
    for ( i = m_lstParticipants.begin(); i != iEnd; i++ )
    {
        ITParticipant *pMyParticipant;
        if ( SUCCEEDED((*i)->get_ITParticipant(&pMyParticipant)) )
        {
            if ( pMyParticipant == pParticipant )
            {
#ifdef _DEBUG
                (*i)->AddRef();
                ATLTRACE(_T(".1.CAVTapiCall::RemoveParticipant() refcount - %p @ %ld.\n"), (*i), (*i)->Release() );
#endif

                // Notify of removing the participant from the tree view
                CComPtr<IAVGeneralNotification> pAVGen;
                if ( SUCCEEDED(_Module.get_AVGenNot(&pAVGen)) )
                    pAVGen->fire_UpdateConfParticipant( UPDATE_REMOVE, (*i), NULL );

                // Release from list
                (*i)->Release();
                m_lstParticipants.erase( i );
                hr = S_OK;
            }

            pMyParticipant->Release();
            if ( SUCCEEDED(hr) ) break;
        }
    }    
    m_atomList.Unlock( CAtomicList::LIST_WRITE );

    return hr;
}

STDMETHODIMP CAVTapiCall::UpdateParticipant(ITParticipant * pITParticipant)
{
    HRESULT hr = E_FAIL;

    IParticipant *p;
    if ( SUCCEEDED(FindParticipant(pITParticipant, &p)) )
    {
        CComPtr<IAVGeneralNotification> pAVGen;
        if ( SUCCEEDED(_Module.get_AVGenNot(&pAVGen)) )
        {
#ifdef _DEBUG
            p->AddRef();
            ATLTRACE(_T(".1.CAVTapiCall::RemoveParticipant() refcount - %p @ %ld.\n"), p, p->Release() );
#endif
            BSTR bstrName = NULL;
            p->get_bstrDisplayName( CParticipant::NAMESTYLE_PARTICIPANT, &bstrName );
            hr = pAVGen->fire_UpdateConfParticipant( UPDATE_MODIFY, p, bstrName );
            SysFreeString( bstrName );
        }

        p->Release();
    }

    return hr;
}


STDMETHODIMP CAVTapiCall::EnumParticipants()
{
    ATLTRACE(_T(".enter.CAVTapiCall::EnumParticipants().\n") );
    
    HRESULT hr;
    ITParticipantControl *pITParticipantControl;
    if ( SUCCEEDED(hr = get_ITParticipantControl(&pITParticipantControl)) )
    {
        IEnumParticipant *pEnum;
        if ( SUCCEEDED(pITParticipantControl->EnumerateParticipants(&pEnum)) )
        {
            // Clear out the list of participants for now
            m_atomList.Lock( CAtomicList::LIST_WRITE );
            RELEASE_LIST( m_lstParticipants );

            ITParticipant *pParticipant = NULL;
            while ( (pEnum->Next(1, &pParticipant, NULL) == S_OK) && pParticipant )
            {
                IParticipant *pNew = new CComObject<CParticipant>;
                if ( pNew )
                {
                    ATLTRACE(_T(".1.CAVTapiCall::EnumParticipants() -- adding participant %p.\n"), pParticipant );
                    // Add the participant to the list 
                    pNew->AddRef();
                    pNew->put_ITParticipant( pParticipant );
                    m_lstParticipants.push_back( pNew );
                }

                RELEASE( pParticipant );
            }

            pEnum->Release();
            m_atomList.Unlock( CAtomicList::LIST_WRITE );
        }

        // Clean up
        pITParticipantControl->Release();
    }

    return S_OK;
}

STDMETHODIMP CAVTapiCall::IsMyParticipant(ITParticipant * pParticipant)
{
    HRESULT hr = S_FALSE;

    IParticipant *p;
    if ( SUCCEEDED(FindParticipant(pParticipant, &p)) )
    {
        hr = S_OK;
        p->Release();
    }

    return hr;
}

STDMETHODIMP CAVTapiCall::IsSameCallHub(ITCallHub * pCallHub)
{
    HRESULT hr = S_FALSE;

    ITCallHub *pMyCallHub;
    if ( SUCCEEDED(get_ITCallHub(&pMyCallHub)) )
    {
        if ( pMyCallHub == pCallHub )
            hr = S_OK;

        pMyCallHub->Release();
    }

    return hr;
}

STDMETHODIMP CAVTapiCall::NotifyParticipantChangeConfRoom(ITParticipant * pParticipant, AV_PARTICIPANT_EVENT nEvent )
{

#ifdef _DEBUG
    if ( pParticipant )
    {
        pParticipant->AddRef();
        ATLTRACE(_T(".1.NotifyParticipantChangConfRoom() -- ref count %p @ %ld.\n"), pParticipant, pParticipant->Release() );
    }
#endif 

    // Notify conference room so that it can re-layout the windows
    DWORD dwAddressType;
    get_dwAddressType( &dwAddressType );

    if ( dwAddressType == LINEADDRESSTYPE_SDP ) 
    {
        CComPtr<IAVTapi> pAVTapi;
        if ( SUCCEEDED(_Module.get_AVTapi(&pAVTapi)) )
        {
            IConfRoom *pConfRoom;
            if ( SUCCEEDED(pAVTapi->get_ConfRoom(&pConfRoom)) )
            {
                // Notify the conference room of the change to the participant
                pConfRoom->NotifyParticipantChange( dynamic_cast<IAVTapiCall *> (this), pParticipant, nEvent );
                pConfRoom->Release();
            }
        }
    }

    return S_OK;
}


STDMETHODIMP CAVTapiCall::GetDisplayNameForParticipant(ITParticipant * pParticipant, BSTR *pbstrName )
{
    HRESULT hr = E_FAIL;
    *pbstrName = NULL;

    // Look for a IParticipant that matches
    IParticipant *p;
    if ( SUCCEEDED(FindParticipant(pParticipant, &p)) )
    {
        hr = p->get_bstrDisplayName( CParticipant::NAMESTYLE_PARTICIPANT, pbstrName );
        p->Release();
    }

    if ( FAILED(hr) )
    {
        ATLTRACE(_T(".warning.CAVTapiCall::GetDisplayNameForParticipant() failed to find participant.\n"));
        // Use default name...
        USES_CONVERSION;
        TCHAR szText[255];

        //
        // We have to initialize szText
        //

        _tcscpy( szText, _T(""));

        LoadString( _Module.GetResourceInstance(), IDS_PARTICIPANT, szText, ARRAYSIZE(szText) );
        *pbstrName = SysAllocString( T2COLE(szText) );
    }

    return hr;
}

STDMETHODIMP CAVTapiCall::UpdateCallerIDFromParticipant()
{
    // Update caller ID based on participant information we have
    HRESULT hr = S_FALSE;

    Lock();
    if ( !m_bstrName || !SysStringLen(m_bstrName) )
    {
        SysFreeString( m_bstrName );
        m_bstrName = NULL;

        // Fetch information on first participant in the list
        m_atomList.Lock( CAtomicList::LIST_READ );
        if ( !m_lstParticipants.empty() )
        {
            (*m_lstParticipants.begin())->get_bstrDisplayName( CParticipant::NAMESTYLE_NULL, &m_bstrName );

            // Should we update the caller ID for the object?
            if ( m_bstrName )
                hr = S_OK;
        }
        m_atomList.Unlock( CAtomicList::LIST_READ );
    }
    Unlock();

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Streaming code
//
STDMETHODIMP CAVTapiCall::OnStreamingChanged(IVideoFeed * pFeed, VARIANT_BOOL bStreaming)
{
    // Notify that the partcipant has either started or stopped streaming
    ITParticipant *pParticipant;
    if ( SUCCEEDED(pFeed->get_ITParticipant(&pParticipant)) )
    {
        NotifyParticipantChangeConfRoom( pParticipant, (bStreaming) ? AV_PARTICIPANT_STREAMING_START : AV_PARTICIPANT_STREAMING_STOP );
        pParticipant->Release();
    }

    return S_OK;
}

STDMETHODIMP CAVTapiCall::put_StreamActive(VARIANT_BOOL bActive )
{
    USES_CONVERSION;
    HRESULT hr = E_FAIL;

    // Notify the application of the streaming event.
    Lock();
    m_bPreviewStreaming = (bool) (bActive != 0);
    Unlock();

    CComPtr<IAVTapi> pAVTapi;
    if ( SUCCEEDED(_Module.get_AVTapi(&pAVTapi)) )
    {    
        // Force conference room to be re-layed out
        DWORD dwAddressType;
        get_dwAddressType( &dwAddressType );
        if ( dwAddressType == LINEADDRESSTYPE_SDP )
        {
            IConfRoom *pConfRoom;
            if ( SUCCEEDED(pAVTapi->get_ConfRoom(&pConfRoom)) )
            {
                pConfRoom->Layout( true, true );
                pConfRoom->Release();

                // Notify that we need to update the conference me participant
                CComPtr<IAVGeneralNotification> pAVGen;
                if ( SUCCEEDED(_Module.get_AVGenNot(&pAVGen)) )
                {
                    TCHAR szText[255];
                    LoadString( _Module.GetResourceInstance(), IDS_CONFROOM_ME, szText, ARRAYSIZE(szText) );

                    BSTR bstrTemp = NULL;
                    bstrTemp = SysAllocString( T2COLE(szText) );
                    pAVGen->fire_UpdateConfParticipant( UPDATE_MODIFY, NULL, bstrTemp );
                    SysFreeString( bstrTemp );
                }
            }
        }

        long lCallID;
        get_lCallID( &lCallID );
        hr = pAVTapi->fire_AddCurrentAction( lCallID, (bActive) ? CM_ACTIONS_NOTIFY_PREVIEW_START : CM_ACTIONS_NOTIFY_PREVIEW_STOP, NULL );
    }

    return hr;
}

STDMETHODIMP CAVTapiCall::put_RcvVideoStreaming(VARIANT_BOOL bActive)
{
    HRESULT hr = E_FAIL;

    // Notify the application of the streaming event.
    Lock();
    m_bRcvVideoStreaming = (bool) (bActive != 0);
    Unlock();

    long lCallID;
    get_lCallID( &lCallID );

    CComPtr<IAVTapi> pAVTapi;
    if ( SUCCEEDED(_Module.get_AVTapi(&pAVTapi)) )
        hr = pAVTapi->fire_AddCurrentAction( lCallID, (bActive) ? CM_ACTIONS_NOTIFY_STREAMSTART : CM_ACTIONS_NOTIFY_STREAMSTOP, NULL );

    return hr;
}



STDMETHODIMP CAVTapiCall::IsPreviewStreaming()
{
    HRESULT hr = S_FALSE;

    IVideoWindow *pVideo;
    if ( SUCCEEDED(get_IVideoWindowPreview((IDispatch **) &pVideo)) )
    {
        Lock();
        if ( m_bPreviewStreaming ) hr = S_OK;
        Unlock();

        pVideo->Release();
    }

    return hr;
}

STDMETHODIMP CAVTapiCall::IsRcvVideoStreaming()
{
    Lock();
    HRESULT hr = (m_bRcvVideoStreaming) ? S_OK : S_FALSE;
    Unlock();

    return hr;
}

STDMETHODIMP CAVTapiCall::get_RcvVideoStreaming(VARIANT_BOOL * pVal)
{
    Lock();
    *pVal = m_bRcvVideoStreaming;
    Unlock();

    return S_OK;
}



STDMETHODIMP CAVTapiCall::GetCallerIDInfo(ITCallInfo * pCallInfo)
{
    BSTR bstrTemp = NULL, bstrTemp2 = NULL;

    // Name
    pCallInfo->get_CallInfoString( CIS_CALLERIDNAME, &bstrTemp );
    if ( bstrTemp && SysStringLen(bstrTemp) )
        put_bstrName( bstrTemp );
    SysFreeString( bstrTemp );
    bstrTemp = NULL;

    // Number
    pCallInfo->get_CallInfoString( CIS_CALLERIDNUMBER, &bstrTemp );
    if ( bstrTemp && SysStringLen(bstrTemp) )
        put_bstrDisplayableAddress( bstrTemp );
    SysFreeString( bstrTemp );
    bstrTemp = NULL;

    // Redirecting
    // $FIXUP ... should add these as well

    ForceCallerIDUpdate();

    return S_OK;
}


STDMETHODIMP CAVTapiCall::HandleUserUserInfo()
{
    HRESULT hr;

    ITCallInfo *pCallInfo;
    if ( SUCCEEDED(hr = get_ITCallInfo(&pCallInfo)) )
    {
        long nSize = 0;
        void *pbUU;
        
        hr = pCallInfo->GetCallInfoBuffer( CIB_USERUSERINFO, (DWORD*)&nSize, (BYTE**)&pbUU );

        if ( SUCCEEDED(hr) )
        {
            ATLTRACE(_T(".1.CAVTapiCall::HandleUserUserInfo() -- recieved data.\n"));
            long lCallID;
            get_lCallID( &lCallID );

            CComPtr<IAVTapi> pAVTapi;
            if ( FAILED(_Module.get_AVTapi(&pAVTapi)) || 
                 FAILED(pAVTapi->fire_NotifyUserUserInfo(lCallID, (ULONG_PTR) pbUU)) )
            {
                ATLTRACE(_T(".error.CAVTapiCall::HandleUserUserInfo() -- failed to notify client.\n"));
                CoTaskMemFree( pbUU );
            }

        }

        pCallInfo->Release();
    }

    return hr;
}




STDMETHODIMP CAVTapiCall::get_nCallType(AVCallType * pVal)
{
    Lock();
    *pVal = m_nCallType;
    Unlock();

    return S_OK;
}

STDMETHODIMP CAVTapiCall::put_nCallType(AVCallType newVal)
{
    _ASSERT( (newVal >= 0) && (newVal < AV_CALLTYPE_MAX) );
    Lock();
    m_nCallType = (AVCallType) newVal;
    Unlock();

    return S_OK;
}


STDMETHODIMP CAVTapiCall::FindParticipant(ITParticipant * pParticipant, IParticipant * * ppFound)
{
    _ASSERT( ppFound );

    *ppFound = NULL;
    m_atomList.Lock( CAtomicList::LIST_READ );
    PARTICIPANTLIST::iterator i, iEnd = m_lstParticipants.end();
    for (  i = m_lstParticipants.begin(); i != iEnd; i++ )
    {
        ITParticipant *pMyParticipant;
        if ( SUCCEEDED((*i)->get_ITParticipant(&pMyParticipant)) )
        {
            if ( pMyParticipant == pParticipant )
            {
                *ppFound = (*i);
                (*ppFound)->AddRef();
            }

            pMyParticipant->Release();
            if ( *ppFound ) break;
        }
    }
    m_atomList.Unlock( CAtomicList::LIST_READ );

    return (*ppFound) ? S_OK : E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\avtapintfy.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// AVTapiNotification.h : Declaration of the CAVTapiNotification

#ifndef __AVTAPINOTIFICATION_H_
#define __AVTAPINOTIFICATION_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CAVTapiNotification
class ATL_NO_VTABLE CAVTapiNotification : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CAVTapiNotification, &CLSID_AVTapiNotification>,
	public IAVTapiNotification
{
public:
	CAVTapiNotification()
	{
	}

DECLARE_NOT_AGGREGATABLE(CAVTapiNotification)

BEGIN_COM_MAP(CAVTapiNotification)
	COM_INTERFACE_ENTRY(IAVTapiNotification)
END_COM_MAP()

// IAVTapiNotification
public:
	STDMETHOD(NotifyUserUserInfo)(long lCallID, ULONG_PTR hMem);
	STDMETHOD(IsReminderSet)(BSTR bstrServer, BSTR bstrName);
	STDMETHOD(LogCall)(long lCallID, CallLogType nType, DATE dateStart, DATE dateEnd, BSTR bstrAddr, BSTR bstrName);
	STDMETHOD(ActionSelected)(CallClientActions cca);
	STDMETHOD(ErrorNotify)(BSTR bstrOperation, BSTR bstrDetails, long hrError);
	STDMETHOD(CloseCallControl)(long lCallID);
	STDMETHOD(SetCallState)(long lCallID, CallManagerStates cms, BSTR bstrText);
	STDMETHOD(AddCurrentAction)(long lCallID, CallManagerActions cma, BSTR bstrText);
	STDMETHOD(ClearCurrentActions)(long lCallerID);
	STDMETHOD(SetCallerID)(long lCallID, BSTR bstrCallerID);
	STDMETHOD(NewCall)(long *plCallID, CallManagerMedia cmm, BSTR bstrMediaName);
};

#endif //__AVTAPINOTIFICATION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\avtapintfy.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// AVTapiNotification.cpp : Implementation of CAVTapiNotification
#include "stdafx.h"
#include "TapiDialer.h"
#include "AVTapiNtfy.h"

/////////////////////////////////////////////////////////////////////////////
// CAVTapiNotification


STDMETHODIMP CAVTapiNotification::NewCall(long * plCallID, CallManagerMedia cmm, BSTR bstrMediaName)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CAVTapiNotification::SetCallerID(long lCallID, BSTR bstrCallerID)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CAVTapiNotification::ClearCurrentActions(long lCallerID)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CAVTapiNotification::AddCurrentAction(long lCallID, CallManagerActions cma, BSTR bstrText)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CAVTapiNotification::SetCallState(long lCallID, CallManagerStates cms, BSTR bstrText)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CAVTapiNotification::CloseCallControl(long lCallID)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CAVTapiNotification::ErrorNotify(BSTR bstrOperation, BSTR bstrDetails, long hrError)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CAVTapiNotification::ActionSelected(CallClientActions cca)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CAVTapiNotification::LogCall(long lCallID, CallLogType nType, DATE dateStart, DATE dateEnd, BSTR bstrAddr, BSTR bstrName)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CAVTapiNotification::IsReminderSet(BSTR bstrServer, BSTR bstrName)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CAVTapiNotification::NotifyUserUserInfo(long lCallID, ULONG_PTR hMem)
{
	// TODO: Add your implementation code here

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\avtapicall.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// AVTapiCall.h : Declaration of the CAVTapiCall

#ifndef __AVTAPICALL_H_
#define __AVTAPICALL_H_

#include "resource.h"       // main symbols
#include "particip.h"

#include <list>
using namespace std;
typedef list<ITTerminal *> TERMINALLIST;
typedef list<IVideoWindow *> VIDEOWINDOWLIST;

#define WM_THREADINSTRUCTION        (WM_USER + 5057)
#define WM_ADDPARTICIPANT            (WM_USER + 5058)
#define WM_REMOVEPARTICIPANT        (WM_USER + 5059)
#define WM_UPDATEPARTICIPANT        (WM_USER + 5060)
#define WM_CME_STREAMSTART            (WM_USER + 5061)
#define WM_CME_STREAMSTOP            (WM_USER + 5062)
#define WM_CALLSTATE                (WM_USER + 5063)
#define WM_STREAM_EVENT                (WM_USER + 5064)

#define NUM_USER_BSTR    2

/////////////////////////////////////////////////////////////////////////////
// CAVTapiCall
class ATL_NO_VTABLE CAVTapiCall : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CAVTapiCall, &CLSID_AVTapiCall>,
    public IAVTapiCall
{
// Enumerations
public:
    typedef enum tag_ThreadInstructions_t
    {
        TI_NONE,
        TI_DISCONNECT,
        TI_NOTIFYCONFROOMSTATE,
        TI_REQUEST_QOS,
        TI_USERUSERINFO,
        TI_STREAM_ACTIVE,
        TI_STREAM_INACTIVE,
        TI_RCV_VIDEO_ACTIVE,
        TI_RCV_VIDEO_INACTIVE,
        TI_REJECT,
        TI_CONNECT,
        TI_QUIT,
    } ThreadInstructions_t;

// Construction
public:
    CAVTapiCall();
    void FinalRelease();

// Members
public:
    DWORD                    m_dwThreadID;

    long                    m_lCallID;                // Host app information
    bool                    m_bCallLogged;

    BSTR                    m_bstrName;
    BSTR                    m_bstrUser[NUM_USER_BSTR];
    BSTR                    m_bstrOriginalAddress;        // Originally dialed string
    BSTR                    m_bstrDisplayableAddress;    // String displayed as the dialed number

    DWORD                    m_dwAddressType;
    CallLogType                m_nCallLogType;
    DATE                    m_dateStart;

    bool                    m_bPreviewStreaming;
    bool                    m_bRcvVideoStreaming;
    AVCallType                m_nCallType;

protected:
    ITBasicCallControl        *m_pITControl;            // TAPI call information
    ITTerminal                *m_pITTerminalPreview;

    CALL_STATE                m_callState;            // Current call state (convienence)
    TERMINALLIST            m_lstTerminals;            // List of terminals in use for the call
    PARTICIPANTLIST            m_lstParticipants;
    VIDEOWINDOWLIST            m_lstStreamingVideo;

    CAtomicList                m_atomList;
    CComAutoCriticalSection    m_critTerminals;
    CComAutoCriticalSection    m_critLstStreamingVideo;

    BOOL                    m_bKillMe;                // For cancelling during dial
    bool                    m_bResolvedAddress;        // have we successfully resolved the address
    bool                    m_bMustDisconnect;        // Once a call goes to connected, we must call disconnect on it

// Implementation
public:
    static bool                WaitWithMessageLoop();
    HRESULT                    GetTerminalInterface( REFIID riid, long nMediaType, TERMINAL_DIRECTION nTD, void **ppVoid, short nInd );

protected:
    void                    StreamingChanged( IVideoFeed *pFeed, bool bStreaming );

// COM Implementation
public:
DECLARE_NOT_AGGREGATABLE(CAVTapiCall)

BEGIN_COM_MAP(CAVTapiCall)
    COM_INTERFACE_ENTRY(IAVTapiCall)
END_COM_MAP()

// IAVTapiCall
public:
    STDMETHOD(FindParticipant)(ITParticipant *pParticipant, IParticipant **ppFound);
    STDMETHOD(UpdateParticipant)(ITParticipant *pITParticipant);
    STDMETHOD(get_nCallType)(/*[out, retval]*/ AVCallType *pVal);
    STDMETHOD(put_nCallType)(/*[in]*/ AVCallType newVal);
    STDMETHOD(OnStreamingChanged)(IVideoFeed *pFeed, VARIANT_BOOL bStreaming);
    STDMETHOD(get_RcvVideoStreaming)(/*[out, retval]*/ VARIANT_BOOL *pVal);
    STDMETHOD(put_RcvVideoStreaming)(/*[in]*/ VARIANT_BOOL newVal);
    STDMETHOD(IsRcvVideoStreaming)();
    STDMETHOD(put_StreamActive)(/*[in]*/ VARIANT_BOOL bActive );
    STDMETHOD(HandleUserUserInfo)();
    STDMETHOD(GetCallerIDInfo)(ITCallInfo *pCallInfo);
    STDMETHOD(IsPreviewStreaming)();
    STDMETHOD(get_ITCallInfo)(/*[out, retval]*/ ITCallInfo * *pVal);
    STDMETHOD(NotifyParticipantChangeConfRoom)(ITParticipant *pParticipant, AV_PARTICIPANT_EVENT nEvent);
    STDMETHOD(get_bResolved)(/*[out, retval]*/ VARIANT_BOOL *pVal);
    STDMETHOD(put_bResolved)(/*[in]*/ VARIANT_BOOL newVal);
    STDMETHOD(get_bstrDisplayableAddress)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_bstrDisplayableAddress)(/*[in]*/ BSTR newVal);
    STDMETHOD(GetVideoFeedCount)(short *pnCount);
    STDMETHOD(NotifyStreamEvent)(CALL_MEDIA_EVENT cme);
    STDMETHOD(ForceCallerIDUpdate)();
    STDMETHOD(get_bstrUser)(/*[in]*/ short nIndex, /*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_bstrUser)(/*[in]*/ short nIndex, /*[in]*/ BSTR newVal);
    STDMETHOD(TerminalArrival)(/*[in]*/ITTerminal *pTerminal);
    STDMETHOD(TerminalRemoval)(/*[in]*/ITTerminal *pTerminal);

    // Basic call properties
    STDMETHOD(get_bstrCallerID)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_bstrName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_bstrName)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_dwAddressType)(/*[out, retval]*/ DWORD *pVal);
    STDMETHOD(put_dwAddressType)(/*[in]*/ DWORD newVal);
    STDMETHOD(get_bstrOriginalAddress)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_bstrOriginalAddress)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_dwCaps)(/*[out, retval]*/ DWORD *pVal);
    STDMETHOD(get_nCallLogType)(/*[out, retval]*/ CallLogType *pVal);
    STDMETHOD(put_nCallLogType)(/*[in]*/ CallLogType newVal);
    STDMETHOD(get_callState)(/*[out, retval]*/ CALL_STATE *pVal);
    STDMETHOD(put_callState)(/*[in]*/ CALL_STATE newVal);

    // Object properties
    STDMETHOD(CheckKillMe)();
    STDMETHOD(get_bKillMe)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_bKillMe)(/*[in]*/ BOOL newVal);
    STDMETHOD(get_lCallID)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_lCallID)(/*[in]*/ long newVal);
    STDMETHOD(get_dwThreadID)(/*[out, retval]*/ DWORD *pVal);
    STDMETHOD(put_dwThreadID)(/*[in]*/ DWORD newVal);

    // Participant related methods
    STDMETHOD(IsSameCallHub)(ITCallHub *pCallHub);
    STDMETHOD(get_ITCallHub)(/*[out, retval]*/ ITCallHub * *pVal);
    STDMETHOD(IsMyParticipant)(ITParticipant *pParticipant);
    STDMETHOD(EnumParticipants)();
    STDMETHOD(AddParticipant)(ITParticipant *pParticipant);
    STDMETHOD(RemoveParticipant)(ITParticipant *pParticipant);
    STDMETHOD(PopulateTreeView)(IConfRoomTreeView *pTreeView);
    STDMETHOD(GetDisplayNameForParticipant)(ITParticipant *pParticipant, BSTR *pbstrName );
    STDMETHOD(UpdateCallerIDFromParticipant)();

    // General operations
    STDMETHOD(ResolveAddress)();
    STDMETHOD(Log)(CallLogType nType);

    // Call control methods
    STDMETHOD(NotifyConfRoomState)(long *pErrorInfo);
    STDMETHOD(PostMessage)(long msg, WPARAM wParam);
    STDMETHOD(Disconnect)(/*[in]*/ VARIANT_BOOL bKill);

    // Retrieving other interfaces
    STDMETHOD(get_ITBasicAudioTerminal)(/*[out, retval]*/ ITBasicAudioTerminal* *pVal);
    STDMETHOD(get_IBasicVideo)(/*[out, retval]*/ IDispatch **pVal);
    STDMETHOD(get_ITAddress)(/*[out, retval]*/ ITAddress **pVal);
    STDMETHOD(get_ITBasicCallControl)(/*[out, retval]*/ ITBasicCallControl **pVal);
    STDMETHOD(put_ITBasicCallControl)(/*[in]*/ ITBasicCallControl *newVal);
    STDMETHOD(get_IVideoWindow)(short nInd, /*[out, retval]*/ IDispatch **pVal);
    STDMETHOD(get_ITParticipantControl)(/*[out, retval]*/ ITParticipantControl **ppVal);
    STDMETHOD(get_IVideoWindowPreview)(/*[out, retval]*/ IDispatch **ppVal);
    STDMETHOD(get_ITTerminalPreview)(/*[out, retval]*/ ITTerminal **ppVal);
    STDMETHOD(put_ITTerminalPreview)(/*[in]*/ ITTerminal * newVal);

    STDMETHOD(AddTerminal)(ITTerminal *pITTerminal);
    STDMETHOD(RemoveTerminal)(ITTerminal *pITTerminal);
};

#endif //__AVTAPICALL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\cedetailsvw.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// ConfExplorerDetailsView.h : Declaration of the CConfExplorerDetailsView

#ifndef __CONFEXPLORERDETAILSVIEW_H_
#define __CONFEXPLORERDETAILSVIEW_H_

#include "resource.h"       // main symbols
#include "ConfDetails.h"
#include "ExpDtlList.h"

/////////////////////////////////////////////////////////////////////////////
// CConfExplorerDetailsView
class ATL_NO_VTABLE CConfExplorerDetailsView : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CConfExplorerDetailsView, &CLSID_ConfExplorerDetailsView>,
	public IConfExplorerDetailsView
{

friend class CExpDetailsList;

// Enumerations
public:
	enum tagColumns_t
	{
		COL_NAME,
		COL_PURPOSE,
		COL_STARTS,
		COL_ENDS,
		COL_ORIGINATOR,
		COL_SERVER,
		COL_MAX
	};

	enum tagListImage_t
	{
		IMAGE_NONE,
		IMAGE_INSESSION,
		IMAGE_REMINDER,
	};

	enum tagListImageState_t
	{
		IMAGE_STATE_NONE,
		IMAGE_STATE_AUDIO,
		IMAGE_STATE_VIDEO,
	};

// Construction
public:
	CConfExplorerDetailsView();
	void FinalRelease();

// Members
public:
	CONFDETAILSLIST			m_lstConfs;
	PERSONDETAILSLIST		m_lstPersons;
protected:
	HWND					m_hWndParent;

	CExpDetailsList			m_wndList;
	IConfExplorer			*m_pIConfExplorer;
	int						m_nSortColumn;
	bool					m_bSortAscending;
	int						m_nUpdateCount;

	CComAutoCriticalSection	m_critConfList;
	CComAutoCriticalSection m_critUpdateList;

// Attributes
public:
	void			get_Columns();
	void			put_Columns();

	bool			IsSortAscending() const			{ return m_bSortAscending; }
	int				GetSortColumn() const			{ return m_nSortColumn; }
	int				GetSecondarySortColumn() const;
	bool			IsSortColumnDateBased(int nCol) const;

// Operations
public:
	static CConfDetails*	AddListItem( BSTR bstrServer, ITDirectoryObject *pITDirObject, CONFDETAILSLIST& lstConfs );
	static CPersonDetails*	AddListItemPerson( BSTR bstrServer, ITDirectoryObject *pITDirObject, PERSONDETAILSLIST& lstPersons );

	long					OnGetDispInfo( LV_DISPINFO *pInfo );
protected:
	void			DeleteAllItems();

	HRESULT			ShowConferencesAndPersons( BSTR bstrServer );

// Interface mapping
public:
DECLARE_NOT_AGGREGATABLE(CConfExplorerDetailsView)

BEGIN_COM_MAP(CConfExplorerDetailsView)
	COM_INTERFACE_ENTRY(IConfExplorerDetailsView)
END_COM_MAP()

// IConfExplorerDetailsView
public:
	STDMETHOD(get_SelectedConfDetails)(/*[out, retval]*/ long **ppVal);
	STDMETHOD(IsConferenceSelected)();
	STDMETHOD(get_nSortColumn)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_nSortColumn)(/*[in]*/ long newVal);
	STDMETHOD(get_bSortAscending)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(UpdateConfList)(long *pList);
	STDMETHOD(OnColumnClicked)(long nColumn);
	STDMETHOD(get_Selection)(DATE *pdateStart, DATE *pdateEnd, /*[out, retval]*/ BSTR *pVal );
	STDMETHOD(get_ConfExplorer)(/*[out, retval]*/ IConfExplorer * *pVal);
	STDMETHOD(put_ConfExplorer)(/*[in]*/ IConfExplorer * newVal);
	STDMETHOD(Refresh)();
	STDMETHOD(get_hWnd)(/*[out, retval]*/ HWND *pVal);
	STDMETHOD(put_hWnd)(/*[in]*/ HWND newVal);
};

#endif //__CONFEXPLORERDETAILSVIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\cetreeview.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// ConfExplorerTreeView.cpp : Implementation of CConfExplorerTreeView
#include "stdafx.h"
#include <stdio.h>
#include "TapiDialer.h"
#include "CETreeView.h"
#include "DlgAddCSvr.h"
#include "DlgAddLoc.h"
#include "EnumSite.h"

#define DEFAULT_REFRESH_INTERVAL	1800000

int CALLBACK CETreeCompare( LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
	return 0;
} 

/////////////////////////////////////////////////////////////////////////////
// CConfExplorerTreeView

CConfExplorerTreeView::CConfExplorerTreeView()
{
	m_pIConfExplorer = NULL;
	m_hIml = NULL;
	m_dwRefreshInterval = DEFAULT_REFRESH_INTERVAL;
}

void CConfExplorerTreeView::FinalRelease()
{
	ATLTRACE(_T(".enter.CConfExplorerTreeView::FinalRelease().\n"));

	// Destroy the image list
	if ( m_hIml ) ImageList_Destroy( m_hIml );
	put_hWnd( NULL );
	DELETE_CRITLIST(m_lstServers, m_critServerList);
	put_ConfExplorer( NULL );

	CComObjectRootEx<CComMultiThreadModel>::FinalRelease();
}

void CConfExplorerTreeView::UpdateData( bool bSaveAndValidate )
{
	// Need the tree view to store the information in the registry
	_ASSERT( IsWindow(m_wndTree.m_hWnd) );
	if ( !IsWindow(m_wndTree.m_hWnd) ) return;

	// Variable initialization
	USES_CONVERSION;
	int nCount = 0, nLevel = 1;
	CRegKey regKey;

	TCHAR szReg[MAX_SERVER_SIZE + 100], szSubKey[50], szText[MAX_SERVER_SIZE];
	LoadString( _Module.GetResourceInstance(), IDN_REG_CONFSERV_KEY, szReg, ARRAYSIZE(szReg) );

	TV_ITEM tvi = {0};
	tvi.mask = TVIF_TEXT | TVIF_HANDLE | TVIF_STATE | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
	tvi.pszText = szText;
	tvi.cchTextMax = ARRAYSIZE( szText );
	tvi.stateMask = TVIS_EXPANDED | TVIS_SELECTED;

	// Write information to the registry
	if ( bSaveAndValidate )
	{
		// Open and then clean the registry key
		if ( regKey.Open(HKEY_CURRENT_USER, szReg) == ERROR_SUCCESS )
		{
			regKey.RecurseDeleteKey( NULL );
			regKey.Close();
		}

		// Write out listbox information to registry (include open/closed state of items)
		if ( regKey.Create(HKEY_CURRENT_USER, szReg) == ERROR_SUCCESS )
		{
			// Save dwRefresh interval
			LoadString( _Module.GetResourceInstance(), IDN_REG_CONFSERV_REFRESHINTERVAL, szReg, ARRAYSIZE(szReg) );
			regKey.SetValue( m_dwRefreshInterval, szReg );

			HTREEITEM hItemTemp, hItem = TreeView_GetRoot( m_wndTree.m_hWnd );
			while ( hItem )
			{
				tvi.hItem = hItem;
				TreeView_GetItem( m_wndTree.m_hWnd, &tvi );

				// Write information out to registry && increment the counter
				LoadString( _Module.GetResourceInstance(), IDN_REG_CONFSERV_ENTRY, szReg, ARRAYSIZE(szReg) );
				_sntprintf( szSubKey, ARRAYSIZE(szSubKey), szReg, nCount );
				_sntprintf( szReg, ARRAYSIZE(szReg), _T("\"%u\",\"%u\",\"%u\",\"%s\""), nLevel, tvi.iImage, tvi.state, tvi.pszText );

				regKey.SetValue( szReg, szSubKey );
				nCount++;

				// Enumerate through child items
				hItemTemp = TreeView_GetChild( m_wndTree.m_hWnd, hItem );
				if ( hItemTemp )
					nLevel++;
				else
					hItemTemp = TreeView_GetNextSibling( m_wndTree.m_hWnd, hItem );

				while ( !hItemTemp && (hItemTemp = TreeView_GetParent(m_wndTree.m_hWnd, hItem)) != NULL )
				{
					nLevel--;
					hItem = hItemTemp;
					hItemTemp = TreeView_GetNextSibling( m_wndTree.m_hWnd, hItem );
				}

				// Swap with temporary storage
				hItem = hItemTemp;
			}

			// Close down the registry
			regKey.Close();
		}
	}
	else
	{
		// Notification for host application of servers being loaded
		CComPtr<IAVGeneralNotification> pAVGen;
		_Module.get_AVGenNot( &pAVGen );

		if ( regKey.Open(HKEY_CURRENT_USER, szReg, KEY_READ) == ERROR_SUCCESS )
		{
			// Load dwRefresh interval
			LoadString( _Module.GetResourceInstance(), IDN_REG_CONFSERV_REFRESHINTERVAL, szReg, ARRAYSIZE(szReg) );
			regKey.QueryValue( m_dwRefreshInterval, szReg );

			// Clear out the listbox and add default item
			TreeView_DeleteAllItems( m_wndTree.m_hWnd );
			::SendMessage( m_wndTree.m_hWnd, WM_SETREDRAW, false, 0 );

			HTREEITEM hItem; 
			HTREEITEM hParent[MAX_TREE_DEPTH] = {0};
			hParent[0] = TVI_ROOT;

			// Load up info from registry
			int nCount = 0;
			DWORD dwSize;
			TV_INSERTSTRUCT tvis;
			tvis.hInsertAfter = TVI_LAST;

			HTREEITEM hItemSelected = NULL;

			do
			{
				// Read registry entry
				LoadString( _Module.GetResourceInstance(), IDN_REG_CONFSERV_ENTRY, szReg, ARRAYSIZE(szReg) );
				_sntprintf( szSubKey, ARRAYSIZE(szSubKey), szReg, nCount );
				szSubKey[ARRAYSIZE(szSubKey)-1] = _T('\0');
				dwSize = ARRAYSIZE(szReg) - 1;
				if ( (regKey.QueryValue(szReg, szSubKey, &dwSize) != ERROR_SUCCESS) || !dwSize ) break;

				// Parse registry entry
				GetToken( 1, _T("\","), szReg, szText ); nLevel = min(MAX_TREE_DEPTH - 1, max(1,_ttoi(szText)));
				GetToken( 2, _T("\","), szReg, szText ); tvi.iImage = tvi.iSelectedImage = _ttoi( szText );
				GetToken( 3, _T("\","), szReg, szText ); tvi.state = (UINT) _ttoi( szText );
				GetToken( 4, _T("\","), szReg, szText );

				// Add item to the list and set expanded if necessary			
				tvis.hParent = hParent[nLevel - 1];
				tvis.item = tvi;
				
				// Notify host app of server being added.
				if ( pAVGen )
				{
					if ( tvi.iImage == IMAGE_MYNETWORK )
					{
						pAVGen->fire_AddSiteServer( NULL );
					}
					else if ( tvi.iImage == IMAGE_SERVER )
					{
						BSTR bstrTemp = NULL;
						bstrTemp = SysAllocString( T2COLE(tvi.pszText) );
						pAVGen->fire_AddSiteServer( bstrTemp );
						SysFreeString( bstrTemp );
					}
				}

				hItem = TreeView_InsertItem( m_wndTree.m_hWnd, &tvis );
				if ( hItem && (tvis.item.state & TVIS_SELECTED) )
					hItemSelected = hItem;

				hParent[nLevel] = hItem;
			} while  ( ++nCount );

			// Redraw the listbox
			::SendMessage( m_wndTree.m_hWnd, WM_SETREDRAW, true, 0 );
			::InvalidateRect(m_wndTree.m_hWnd, NULL, true);

			// Make the listbox selection
			if ( hItemSelected )
				m_wndTree.PostMessage( TVM_SELECTITEM, TVGN_CARET, (LPARAM) hItemSelected );
		}
		else
		{
			// Just add the default server to the list
			TreeView_DeleteAllItems( m_wndTree.m_hWnd );
			HTREEITEM hFindItem;
			FindOrAddItem( NULL, NULL, true, false, (long **) &hFindItem );

			// Notify host app of server being added
			if ( pAVGen )
				pAVGen->fire_AddSiteServer( NULL );
		}

		// Store list of servers
		EnumerateConfServers();
	}
}	

HRESULT CConfExplorerTreeView::EnumerateConfServers()
{
	if ( !IsWindow(m_wndTree.m_hWnd) ) return E_PENDING;
	
	USES_CONVERSION;
	BSTR bstrServer = NULL;
	TCHAR szText[MAX_SERVER_SIZE];

	TV_ITEM tvi = {0};
	tvi.mask = TVIF_HANDLE | TVIF_IMAGE | TVIF_TEXT;
	tvi.pszText = szText;
	tvi.cchTextMax = ARRAYSIZE(szText);

	HTREEITEM hItemServer;
	HTREEITEM hItemLocation = tvi.hItem = TreeView_GetChild( m_wndTree.m_hWnd, TreeView_GetRoot(m_wndTree.m_hWnd) );

	while ( hItemLocation && TreeView_GetItem(m_wndTree.m_hWnd, &tvi) )
	{
		// Skip location entries in list
		if ( tvi.iImage == IMAGE_LOCATION )
			hItemServer = tvi.hItem = TreeView_GetChild( m_wndTree.m_hWnd, hItemLocation );
		else
			hItemServer = tvi.hItem;

		// Server names first
		while ( hItemServer && TreeView_GetItem(m_wndTree.m_hWnd, &tvi) && (tvi.iImage != IMAGE_LOCATION) )
		{
			if ( tvi.iImage == IMAGE_MYNETWORK )
			{
				SysFreeString( bstrServer );
				bstrServer = NULL;
			}
			else
			{
				SysReAllocString( &bstrServer, T2COLE(tvi.pszText) );
			}

			AddConfServer( bstrServer );

			// Next Server
			hItemServer = tvi.hItem = TreeView_GetNextSibling( m_wndTree.m_hWnd, hItemServer );
		}

		// Next Location
		hItemLocation = tvi.hItem = TreeView_GetNextSibling( m_wndTree.m_hWnd, hItemLocation );
	}

	SysFreeString( bstrServer );
	return S_OK;
}


void CConfExplorerTreeView::SetServerState( CConfServerDetails* pcsd )
{
	if ( !IsWindow(m_wndTree.m_hWnd) ) return;
	
	USES_CONVERSION;
	BSTR bstrServer = NULL;
	TCHAR szText[MAX_SERVER_SIZE];
	bool bRefreshDetailsView = false;

	TV_ITEM tvi = {0};
	tvi.mask = TVIF_HANDLE | TVIF_IMAGE | TVIF_TEXT | TVIF_STATE;
	tvi.pszText = szText;
	tvi.cchTextMax = ARRAYSIZE(szText);
	tvi.stateMask = TVIS_OVERLAYMASK | TVIS_SELECTED;

	HTREEITEM hItemServer;
	HTREEITEM hItemLocation = tvi.hItem = TreeView_GetChild( m_wndTree.m_hWnd, TreeView_GetRoot(m_wndTree.m_hWnd) );

	while ( hItemLocation && TreeView_GetItem(m_wndTree.m_hWnd, &tvi) )
	{
		// Skip location entries in list
		if ( tvi.iImage == IMAGE_LOCATION )
			hItemServer = tvi.hItem = TreeView_GetChild( m_wndTree.m_hWnd, hItemLocation );
		else
			hItemServer = tvi.hItem;

		// Server names first
		while ( hItemServer && TreeView_GetItem(m_wndTree.m_hWnd, &tvi) && (tvi.iImage != IMAGE_LOCATION) )
		{
			if ( tvi.iImage == IMAGE_MYNETWORK )
			{
				SysFreeString( bstrServer );
				bstrServer = NULL;
			}
			else
			{
				SysReAllocString( &bstrServer, T2COLE(tvi.pszText) );
			}

			// Set state if necessary
			if ( pcsd->IsSameAs(bstrServer) )
			{
				if ( !bRefreshDetailsView )
					bRefreshDetailsView = (bool) ((tvi.state & TVIS_SELECTED) != 0);

				TV_ITEM tvTemp = tvi;
				tvTemp.mask = TVIF_STATE | TVIF_HANDLE;
				tvTemp.state = INDEXTOOVERLAYMASK(pcsd->m_nState);
				tvTemp.stateMask = TVIS_OVERLAYMASK;

				TreeView_SetItem( m_wndTree.m_hWnd, &tvTemp );

				// Notify Host app of change
				CComPtr<IAVGeneralNotification> pAVGen;
				if ( SUCCEEDED(_Module.get_AVGenNot(&pAVGen)) )
					pAVGen->fire_NotifySiteServerStateChange( bstrServer, (ServerState) pcsd->m_nState );
			}

			// Next Server
			hItemServer = tvi.hItem = TreeView_GetNextSibling( m_wndTree.m_hWnd, hItemServer );
		}

		// Next Location
		hItemLocation = tvi.hItem = TreeView_GetNextSibling( m_wndTree.m_hWnd, hItemLocation );
	}

	// Clean up
	SysFreeString( bstrServer );

	// Invalidate the details view if necessary
	if ( bRefreshDetailsView )
	{
		IConfExplorer *pConfExplorer;
		if ( SUCCEEDED(get_ConfExplorer(&pConfExplorer)) )
		{
			IConfExplorerDetailsView *pDetails;
			if ( SUCCEEDED(pConfExplorer->get_DetailsView(&pDetails)) )
			{
				HWND hWndDetails;
				pDetails->get_hWnd( &hWndDetails );
				pDetails->Release();

				::InvalidateRect( hWndDetails, NULL, TRUE );
			}
			pConfExplorer->Release();
		}
	}
}

CConfServerDetails* CConfExplorerTreeView::FindConfServer( const OLECHAR *lpoleServer )
{	
	// Should be locked prior to entering!
	_ASSERT( m_critServerList.m_sec.LockCount >= 0 );

	// NOTE must already have crit locked
	CConfServerDetails *pRet = NULL;
	for ( CONFSERVERLIST::iterator i = m_lstServers.begin(); i != m_lstServers.end(); i++ )
	{
		if ( (*i)->IsSameAs(lpoleServer) )
		{
			pRet = *i;
			break;
		}
	}

	return pRet;
}

HRESULT CConfExplorerTreeView::AddConfServer( BSTR bstrServer )
{
	HRESULT hr = S_OK;
	
	// $CRIT - enter
	m_critServerList.Lock();
	CConfServerDetails *pConfServer = FindConfServer( bstrServer );
	CConfServerDetails csTemp;
	bool bSetState = false;

	if ( !pConfServer )
	{
		// Create a new conf server
		pConfServer = new CConfServerDetails;
		if ( pConfServer )
		{
			SysReAllocString( &pConfServer->m_bstrServer, bstrServer );

			// Add item to the list
			m_lstServers.push_back( pConfServer );
			csTemp = *pConfServer;
			bSetState = true;
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
	{
		// Archive if it's already in the list
		pConfServer->m_bArchived = true;
	}
	m_critServerList.Unlock();
	// $CRIT - exit

	if ( bSetState ) SetServerState( &csTemp );

	return hr;
}

void CConfExplorerTreeView::ArchiveConfServers()
{
	CComPtr<IAVGeneralNotification> pAVGen;
	_Module.get_AVGenNot( &pAVGen );

	// Walk list of conf servers, destroying ones that don't have their archive bit set
	// $CRIT - enter
	m_critServerList.Lock();

	bool bContinue = true;
	while ( bContinue && !m_lstServers.empty() )
	{
		bContinue = false;
		CONFSERVERLIST::iterator i = m_lstServers.begin();
		do
		{
			// Not to be archived, delete
			if ( !(*i)->m_bArchived )
			{
#ifdef _DEBUG
				USES_CONVERSION;
				ATLTRACE(_T(".1.CConfExplorerTreeView::ArchiveConfServers() -- removing %s.\n"), OLE2CT((*i)->m_bstrServer) );
#endif
				// Notification for host application of server being deleted
				if ( pAVGen ) pAVGen->fire_RemoveSiteServer( (*i)->m_bstrServer );

				delete (*i);
				m_lstServers.erase( i );

				bContinue = true;
				break;
			}

			i++;	// increment iterator
		} while ( i != m_lstServers.end() );
	}

	m_critServerList.Unlock();
	// $CRIT - exit
}

void CConfExplorerTreeView::CleanConfServers()
{
	// Clear all archive flags on conf servers
	m_critServerList.Lock();
	for ( CONFSERVERLIST::iterator i = m_lstServers.begin(); i !=m_lstServers.end(); i++ )
		(*i)->m_bArchived = false;
	m_critServerList.Unlock();

	EnumerateConfServers();
	ArchiveConfServers();
}

void CConfExplorerTreeView::RemoveServerFromReg( BSTR bstrServer )
{
	CRegKey regKey;

    //
    // Get the 'Conference Services' key name
    //
	TCHAR szReg[MAX_SERVER_SIZE + 100];
	LoadString( _Module.GetResourceInstance(), IDN_REG_CONFSERV_KEY, szReg, ARRAYSIZE(szReg) );

    //
    // open the registry key name
    //
	if ( regKey.Open(HKEY_CURRENT_USER, szReg) != ERROR_SUCCESS )
	{
        return;
	}

    //
    // Parse the items
    //
    int nCount = 1;
    TCHAR szSubKey[50];
    while( TRUE)
    {
        //
        // Get the item entry name
        //
	    LoadString( _Module.GetResourceInstance(), IDN_REG_CONFSERV_ENTRY, szReg, ARRAYSIZE(szReg) );
	    _sntprintf( szSubKey, ARRAYSIZE(szSubKey), szReg, nCount );
	    szSubKey[ARRAYSIZE(szSubKey)-1] = _T('\0');

        //
        // Get the key value
        //
        DWORD dwValue = 255;
        TCHAR szValue[256];
        LONG lReturn = regKey.QueryValue( szValue, szSubKey, &dwValue);
        if( lReturn != ERROR_SUCCESS )
        {
            // Don't go further
            break;
        }

        //
        // Let see if is our server
        //

        if( wcsstr( szValue, bstrServer) != NULL )
        {
            // We find the server, let's delete it!
            regKey.DeleteValue( szSubKey );
            break;
        }

        //
        // Go to the next entry
        //
        nCount++;
    }

    //
    // Close the key
    //
    regKey.Close();

}



LRESULT CConfExplorerTreeView::OnSelChanged( LPNMHDR lpnmHdr )
{
	CConfServerDetails *pConfServer = NULL;
	CConfServerDetails csTemp;

	BSTR bstrLocation = NULL, bstrServer = NULL;
	if ( SUCCEEDED(GetSelection(&bstrLocation, &bstrServer)) )
	{
		// Get a copy of the information stored for the server
		m_critServerList.Lock();

		pConfServer = FindConfServer( bstrServer );
		if ( pConfServer )
			csTemp = *pConfServer;

		m_critServerList.Unlock();
		
		// Clean up
		SysFreeString( bstrLocation );
		SysFreeString( bstrServer );
	}

	// Set the details list with the information stored for this server location
	IConfExplorer *pConfExplorer;
	if ( SUCCEEDED(get_ConfExplorer(&pConfExplorer)) )
	{
		IConfExplorerDetailsView *pDetails;
		if ( SUCCEEDED(pConfExplorer->get_DetailsView(&pDetails)) )
		{
			pDetails->UpdateConfList( (long *) &csTemp.m_lstConfs );
			pDetails->Release();
		}
		pConfExplorer->Release();
	}
	
	return 0;
}


LRESULT CConfExplorerTreeView::OnEndLabelEdit( TV_DISPINFO *pInfo )
{
	if ( !pInfo->item.pszText ) return 0;

	// Make sure that we're changing the text of something valid
	TCHAR szText[MAX_SERVER_SIZE + 1];
	TV_ITEM tvi;
	tvi.hItem = pInfo->item.hItem;
	tvi.mask = TVIF_IMAGE | TVIF_TEXT | TVIF_STATE;
	tvi.stateMask = TVIS_OVERLAYMASK;
	tvi.pszText = szText;
	tvi.cchTextMax = ARRAYSIZE(szText) - 1;

	TreeView_GetItem( m_wndTree.m_hWnd, &tvi );
	if ( (tvi.iImage == IMAGE_ROOT) || (tvi.iImage == IMAGE_MYNETWORK) ) return 0;

	// Make sure the server isn't presently being queried
	if ( (tvi.state >> 8) == SERVER_QUERYING )
	{
		CErrorInfo er( IDS_ER_RENAME_TREEVIEW_ITEM, IDS_ER_RENAME_UNALLOWED_IN_QUERY );
		er.set_hr( E_ABORT );
		return 0;
	}

	// Make sure that we have something to actually change
	pInfo->item.mask = TVIF_TEXT;
	TreeView_SetItem( m_wndTree.m_hWnd, &pInfo->item );

	// If the user is renaming a conference server, we need to go out and change the 
	// information stored in the ConfDetails object for the server
	if ( tvi.iImage == IMAGE_SERVER )
	{
		USES_CONVERSION;
		m_critServerList.Lock();
		CConfServerDetails *pDetails = FindConfServer( T2COLE(tvi.pszText) );
		if ( pDetails )
			SysReAllocString( &pDetails->m_bstrServer, T2COLE(pInfo->item.pszText) );

		m_critServerList.Unlock();
	}

	return 0;
}

///////////////////////////////////////////////////////////////////////////
// COM interface methods and properties
//

STDMETHODIMP CConfExplorerTreeView::get_ConfExplorer(IConfExplorer **ppVal)
{
	HRESULT hr = E_PENDING;
	Lock();
	if ( m_pIConfExplorer )
		hr = m_pIConfExplorer->QueryInterface(IID_IConfExplorer, (void **) ppVal );
	Unlock();

	return hr;
}

STDMETHODIMP CConfExplorerTreeView::put_ConfExplorer(IConfExplorer * newVal)
{
	HRESULT hr = S_OK;

	Lock();
	RELEASE( m_pIConfExplorer );
	if ( newVal )
		hr = newVal->QueryInterface( IID_IConfExplorer, (void **) &m_pIConfExplorer );
	Unlock();

	return hr;
}


STDMETHODIMP CConfExplorerTreeView::get_hWnd(HWND *pVal)
{
	*pVal = m_wndTree.m_hWnd;
	return S_OK;
}

STDMETHODIMP CConfExplorerTreeView::put_hWnd(HWND newVal)
{
	if ( IsWindow(newVal) )
	{
		// Make sure the window isn't already subclassed
		if ( m_wndTree.m_hWnd ) m_wndTree.UnsubclassWindow();

		// Set up tree view
		if ( m_wndTree.SubclassWindow(newVal) )
		{
			// Hook up link
			m_wndTree.m_pTreeView = this;

			// Verify that window has proper styles
			::SetWindowLongPtr( m_wndTree.m_hWnd, GWL_STYLE, GetWindowLongPtr(m_wndTree.m_hWnd, GWL_STYLE) | 
														  TVS_HASLINES |
														  TVS_HASBUTTONS |
														  TVS_SHOWSELALWAYS |
														  TVS_DISABLEDRAGDROP );

			// Setup image lists for Tree View
			InitImageLists();
			UpdateData( false );
		}
	}
	else if ( IsWindow(m_wndTree.m_hWnd) )
	{
		// Shutdown
		UpdateData( true );
		TreeView_DeleteAllItems( m_wndTree.m_hWnd );
		m_wndTree.UnsubclassWindow();
		m_wndTree.m_pTreeView = NULL;
		m_wndTree.m_hWnd = NULL;
	}

	return S_OK;
}

STDMETHODIMP CConfExplorerTreeView::get_dwRefreshInterval(DWORD * pVal)
{
	*pVal = m_dwRefreshInterval;
	return S_OK;
}

STDMETHODIMP CConfExplorerTreeView::put_dwRefreshInterval(DWORD newVal)
{
	m_dwRefreshInterval = newVal;
	return S_OK;
}

STDMETHODIMP CConfExplorerTreeView::Select(BSTR bstrName)
{
	HRESULT hr;
	HTREEITEM hItem;
	if ( SUCCEEDED(hr = FindOrAddItem(NULL, bstrName, false, false, (long **) &hItem)) )
		TreeView_SelectItem( m_wndTree.m_hWnd, hItem );

	return hr;
}

STDMETHODIMP CConfExplorerTreeView::SelectItem(short nSel)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CConfExplorerTreeView::Refresh()
{
	// Load up the conference explorer control
	if ( !m_wndTree.m_hWnd ) return E_PENDING;

	return S_OK;
}

STDMETHODIMP CConfExplorerTreeView::AddLocation(BSTR bstrLocation)
{
	HRESULT hr = S_FALSE;

	// Show dialog that let's use add a server
	CDlgAddLocation dlg;
	if ( bstrLocation )
		SysReAllocString( &dlg.m_bstrLocation, bstrLocation );

	if ( dlg.DoModal(_Module.GetParentWnd()) == IDOK )
	{
		// Add items to the tree view
		HTREEITEM hItem;
		hr = FindOrAddItem( dlg.m_bstrLocation, NULL, true, true, (long **) &hItem );
	}

	return hr;
}

STDMETHODIMP CConfExplorerTreeView::AddServer( BSTR bstrServer )
{
	HRESULT hr = S_FALSE;

	if ( bstrServer && !SysStringLen(bstrServer) ) bstrServer = NULL;

	// Show dialog that let's use add a server
	CDlgAddConfServer dlg;
	if ( !bstrServer )
	{
		// Only want location from current selection
		GetSelection( &dlg.m_bstrLocation, &dlg.m_bstrServer );

		// Never set server names
		SysFreeString( dlg.m_bstrServer );
		dlg.m_bstrServer = NULL;
	}
	else
	{
		// Use user supplied parameters
		dlg.m_bstrServer = SysAllocString( bstrServer );
	}

	if ( dlg.DoModal(_Module.GetParentWnd()) == IDOK )
	{
		TCHAR szFormat[255];
		TCHAR szMessage[255 + MAX_SERVER_SIZE];
		CConfServerDetails *pConfServer = NULL;
		bool bMyNetwork = false;

		// If the server to add matches "(My Network)" then just ignore it as a duplicate
		::LoadString( _Module.GetResourceInstance(), IDS_DEFAULT_SERVER, szFormat, ARRAYSIZE(szFormat) );
		if ( !_tcsicmp(szFormat, OLE2CT(dlg.m_bstrServer)) )
		{
			bMyNetwork = true;
		}
		else
		{
			m_critServerList.Lock();
			pConfServer = FindConfServer( dlg.m_bstrServer );
			m_critServerList.Unlock();
		}

		// Does the conference server already exist?
		if ( !bMyNetwork && !pConfServer )
		{
			// Add items to the tree view
			HTREEITEM hItem;
			if ( SUCCEEDED(hr = FindOrAddItem(NULL, dlg.m_bstrServer, true, false, (long **) &hItem)) )
			{
				AddConfServer( dlg.m_bstrServer );

				// Notify host app of server addition
				CComPtr<IAVGeneralNotification> pAVGen;
				if ( SUCCEEDED(_Module.get_AVGenNot(&pAVGen)) )
					pAVGen->fire_AddSiteServer( dlg.m_bstrServer );

				// Publish our information on the server
				CComPtr<IAVTapi> pAVTapi;
				if ( SUCCEEDED(_Module.get_AVTapi(&pAVTapi)) )
					pAVTapi->RegisterUser( true, dlg.m_bstrServer );
			}
		}
		else
		{
			// Notify user that the server already exists
			::LoadString( _Module.GetResourceInstance(), IDS_CONFEXP_SERVEREXISTS, szFormat, ARRAYSIZE(szFormat) );
			_sntprintf( szMessage, ARRAYSIZE(szMessage), szFormat, OLE2CT(dlg.m_bstrServer) );
			szMessage[ARRAYSIZE(szMessage)-1] = _T('\0');

			_Module.DoMessageBox( szMessage, MB_OK | MB_ICONINFORMATION, false );
		}
	}

	return hr;
}

STDMETHODIMP CConfExplorerTreeView::RemoveServer(BSTR bstrLocation, BSTR bstrName )
{
	if ( !IsWindow(m_wndTree.m_hWnd) ) return E_FAIL;
	HTREEITEM hItem = NULL;
	HRESULT hr = S_FALSE;

	// if all args NULL that means delete currently selected item
	if ( !bstrLocation && !bstrName )
	{
		hItem = TreeView_GetSelection( m_wndTree.m_hWnd );
	}
	else
	{
		if ( FAILED(FindOrAddItem(bstrLocation, bstrName, false, false, (long **) &hItem)) )
			hItem = NULL;
	}

	// Have an item to delete?
	if ( hItem && (hItem != TreeView_GetRoot(m_wndTree.m_hWnd)) )
	{
		TCHAR szText[MAX_SERVER_SIZE];
		TV_ITEM tvi = {0};
		tvi.mask = TVIF_IMAGE | TVIF_HANDLE | TVIF_TEXT;
		tvi.hItem = hItem;
		tvi.pszText = szText;
		tvi.cchTextMax = ARRAYSIZE(szText);

		TreeView_GetItem( m_wndTree.m_hWnd, &tvi );
		if ( tvi.iImage != IMAGE_MYNETWORK )
		{
			TCHAR szFormat[255];
			TCHAR szMessage[255 + MAX_SERVER_SIZE];
			::LoadString( _Module.GetResourceInstance(), IDS_CONFIRM_REMOVE_SERVER, szFormat, ARRAYSIZE(szFormat) );
			_sntprintf( szMessage, ARRAYSIZE(szMessage), szFormat, tvi.pszText );

			// Confirm
			if ( _Module.DoMessageBox(szMessage, MB_YESNO | MB_ICONQUESTION, false) == IDYES )
			{
				if ( TreeView_DeleteItem(m_wndTree.m_hWnd, hItem) )
				{
                    RemoveServerFromReg( bstrName );
					CleanConfServers();
					hr = S_OK;
				}
			}
		}
	}

	return hr;
}

STDMETHODIMP CConfExplorerTreeView::FindOrAddItem(BSTR bstrLocation, BSTR bstrServer, BOOL bAddItem, BOOL bLocationOnly, long **pphItem)
{
#undef FETCH_STRING
#define FETCH_STRING( _IDS_ )	\
	LoadString( _Module.GetResourceInstance(), _IDS_, szJunk, ARRAYSIZE(szJunk) );	\
	SysReAllocString( &bstrItemText, T2COLE(szJunk) );

	if ( !IsWindow(m_wndTree.m_hWnd) ) return E_FAIL;

	HRESULT hr = S_OK;
	_ASSERT( pphItem );
	*pphItem = NULL;

	USES_CONVERSION;
	TCHAR szText[MAX_SERVER_SIZE], szJunk[MAX_SERVER_SIZE];

	TV_ITEM tvi = {0};
	tvi.mask = TVIF_TEXT | TVIF_HANDLE | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_STATE;
	tvi.pszText = szText;
	tvi.cchTextMax = ARRAYSIZE( szText );
	tvi.stateMask = TVIS_EXPANDED;

	TV_INSERTSTRUCT tvis;
	tvis.hParent = TVI_ROOT;
	tvis.hInsertAfter = TVI_SORT;
	
	HTREEITEM hItem = TreeView_GetRoot( m_wndTree.m_hWnd );

	BSTR bstrItemText = NULL;
	int nImage;
	int nEnd = (bLocationOnly) ? IMAGE_LOCATION : IMAGE_SERVER;

	for ( int i = 0; i <= nEnd; i++ )
	{
		// Pick the string based on how deep in the search we are
		nImage = i;

		switch ( i )
		{
			case IMAGE_ROOT:		FETCH_STRING( IDS_CONFSERV_ROOT );					break;
			case IMAGE_LOCATION:	SysReAllocString( &bstrItemText, bstrLocation );		break;

			case IMAGE_SERVER:
				if ( bstrServer )
				{
					SysReAllocString( &bstrItemText, bstrServer );
				}
				else
				{
					FETCH_STRING( IDS_DEFAULT_SERVER );
					nImage = IMAGE_MYNETWORK;
				}
				break;
		}

		if ( bstrItemText )
		{
			while ( hItem )
			{
				tvi.hItem = hItem;
				TreeView_GetItem( m_wndTree.m_hWnd, &tvi );

				// Found item
				if ( !_tcsicmp(OLE2CT(bstrItemText), tvi.pszText) )
					break;

				hItem = TreeView_GetNextSibling( m_wndTree.m_hWnd, hItem );
			}

			// If no item is found, should we add one?
			if ( !hItem )
			{
				if ( bAddItem )
				{
					_tcscpy( tvi.pszText, OLE2CT(bstrItemText) );
					tvi.iSelectedImage = tvi.iImage = nImage;
					tvi.state = TVIS_EXPANDED | TVIS_EXPANDEDONCE;
					tvis.item = tvi;
					hItem = TreeView_InsertItem( m_wndTree.m_hWnd, &tvis );
					if ( hItem )
						TreeView_SelectItem( m_wndTree.m_hWnd, hItem );
				}
				else
				{
					// No item found and can't add
					hr = E_FAIL;
					break;
				}
			}

			// Set up parent information
			if ( hItem )
			{
				*pphItem = (long *) hItem;		// return value
				tvis.hParent = hItem;
				hItem = TreeView_GetChild( m_wndTree.m_hWnd, hItem );
			}

			SysFreeString( bstrItemText );
			bstrItemText = NULL;
		}
	}

	// Clean-up
	SysFreeString( bstrItemText );
	return hr;
}

STDMETHODIMP CConfExplorerTreeView::GetSelection(BSTR * pbstrLocation, BSTR * pbstrServer)
{
	// Initialize [in,out] parameters
	*pbstrLocation = *pbstrServer = NULL;

	HTREEITEM hItem = TreeView_GetSelection( m_wndTree.m_hWnd );
	if ( !hItem ) return E_PENDING;

	USES_CONVERSION;
	HRESULT hr = E_FAIL;
	TCHAR szText[MAX_SERVER_SIZE];
	TV_ITEM tvi;
	tvi.mask = TVIF_TEXT | TVIF_IMAGE;
	tvi.pszText = szText;
	tvi.cchTextMax = ARRAYSIZE( szText );
	tvi.hItem = hItem;

	TreeView_GetItem( m_wndTree.m_hWnd, &tvi );
	switch ( tvi.iImage)
	{
		case IMAGE_MYNETWORK:
			// This is the default (NULL, NULL, NULL)
			hr = S_OK;
			break;

		case IMAGE_SERVER:
			hr = S_OK;
			*pbstrServer = SysAllocString( T2COLE(tvi.pszText) );	
			// drop out here if we don't have a parent item
			if ( (tvi.hItem = TreeView_GetParent(m_wndTree.m_hWnd, tvi.hItem)) == NULL )
				break;

			TreeView_GetItem( m_wndTree.m_hWnd, &tvi );

		case IMAGE_LOCATION:
			// Don't return root item itself
			if ( tvi.hItem != TreeView_GetRoot(m_wndTree.m_hWnd) )
				*pbstrLocation = SysAllocString( T2COLE(tvi.pszText) );
			break;
	}

	return hr;
}

void CConfExplorerTreeView::InitImageLists()
{
    if ( m_hIml || !IsWindow(m_wndTree.m_hWnd) ) return;

	// Normal
	if ( (m_hIml = ImageList_LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_LST_CONFSERV), 16, 9, RGB(255, 0, 255))) != NULL )
	{
		// Overlay images for various states
		for ( int i = 1; i < 4; i++ )
			ImageList_SetOverlayImage( m_hIml, 5 + i, i );

		TreeView_SetImageList( m_wndTree.m_hWnd, m_hIml, TVSIL_NORMAL );
	}
}

STDMETHODIMP CConfExplorerTreeView::CanRemoveServer()
{
	if ( IsWindow(m_wndTree.m_hWnd) )
	{
		HTREEITEM hItem = TreeView_GetSelection( m_wndTree.m_hWnd );
		if ( hItem && (hItem != TreeView_GetRoot(m_wndTree.m_hWnd)) )
		{
			TV_ITEM tvi = {0};
			tvi.mask = TVIF_HANDLE | TVIF_IMAGE;
			tvi.hItem = hItem;
			TreeView_GetItem( m_wndTree.m_hWnd, &tvi );
			if ( tvi.iImage != IMAGE_MYNETWORK )
				return S_OK;
		}
	}

	return S_FALSE;
}

STDMETHODIMP CConfExplorerTreeView::ForceConfServerForEnum( BSTR bstrServer )
{
	HRESULT hr = E_FAIL;

	m_critServerList.Lock();
	CConfServerDetails *pConfServer = FindConfServer( bstrServer );
	CConfServerDetails csTemp;

	if ( pConfServer && (pConfServer->m_nState != SERVER_QUERYING) )
	{
		pConfServer->m_nState = SERVER_UNKNOWN;
		pConfServer->m_dwTickCount = 0;
		DELETE_LIST( pConfServer->m_lstConfs );
		DELETE_LIST( pConfServer->m_lstPersons );

		csTemp.CopyLocalProperties( *pConfServer );
		hr = S_OK;
	}
	
	m_critServerList.Unlock();

	// Repaint if succeeded
	if ( SUCCEEDED(hr) )
	{
		SetServerState( &csTemp );
		if ( IsWindow(m_wndTree.m_hWnd) ) m_wndTree.RedrawWindow();
	}

	return hr;
}


STDMETHODIMP CConfExplorerTreeView::GetConfServerForEnum(BSTR * pbstrServer )
{
	HRESULT hr = E_FAIL;
	CConfServerDetails *pConfServer = NULL;
	CConfServerDetails csTemp;

	m_critServerList.Lock();
	for ( CONFSERVERLIST::iterator i = m_lstServers.begin(); i != m_lstServers.end(); i++ )
	{
		if ( ((*i)->m_nState != SERVER_QUERYING) && 
			 (!(*i)->m_dwTickCount || ((GetTickCount() - (*i)->m_dwTickCount) > m_dwRefreshInterval)) )
		{
			if ( !pConfServer || ((GetTickCount() - pConfServer->m_dwTickCount) < (GetTickCount() - (*i)->m_dwTickCount)) )
				pConfServer = *i;
		}
	}

	// This is the conference server that is most in need of updating
	if ( pConfServer )
	{
		*pbstrServer = SysAllocString( pConfServer->m_bstrServer );
		pConfServer->m_nState = SERVER_QUERYING;

		csTemp = *pConfServer;
		hr = S_OK;
	}

	m_critServerList.Unlock();
	
	if ( SUCCEEDED(hr) ) SetServerState( &csTemp );
	return hr;
}

STDMETHODIMP CConfExplorerTreeView::SetConfServerForEnum(BSTR bstrServer, long *pList, long *pListPersons, DWORD dwTicks, BOOL bUpdate)
{
	m_critServerList.Lock();

	CConfServerDetails *pConfServer = FindConfServer( bstrServer );
	CConfServerDetails csTemp;
	bool bSetState = false;

	if ( pConfServer )
	{
		pConfServer->m_dwTickCount = dwTicks;
		DELETE_LIST( pConfServer->m_lstConfs );
		DELETE_LIST( pConfServer->m_lstPersons );

		if ( pList )
		{
			///////////////////////////////////////////
			// Add all of the conference servers
			{
				CONFDETAILSLIST::iterator i, iEnd = ((CONFDETAILSLIST *) pList)->end();
				for ( i = ((CONFDETAILSLIST *) pList)->begin(); i != iEnd; i++ )
				{
					CConfDetails *pDetails = new CConfDetails;
					if ( pDetails )
					{
						*pDetails = *(*i);
						pConfServer->m_lstConfs.push_back( pDetails );
					}
				}
			}

			///////////////////////////////////////////
			// Add all of the people
			{
				if ( pListPersons )
				{
					PERSONDETAILSLIST::iterator i, iEnd = ((PERSONDETAILSLIST *) pListPersons)->end();
					for ( i = ((PERSONDETAILSLIST *) pListPersons)->begin(); i != iEnd; i++ )
					{
						CPersonDetails *pDetails = new CPersonDetails;
						if ( pDetails )
						{
							*pDetails = *(*i);
							pConfServer->m_lstPersons.push_back( pDetails );
						}
					}
				}
			}

			pConfServer->m_nState = SERVER_OK;
		}
		else
		{
			// Server connection broken
			pConfServer->m_nState = SERVER_NOT_RESPONDING;
		}

		csTemp = *pConfServer;
		bSetState = true;
	}

	m_critServerList.Unlock();

	// Force update of list if selected
	if ( bSetState ) SetServerState( &csTemp );

	if ( bUpdate )
	{
		IConfExplorer *pConfExplorer;
		if ( SUCCEEDED(get_ConfExplorer(&pConfExplorer)) )
		{
			BSTR bstrMyLocation = NULL, bstrMyServer = NULL;
			if ( SUCCEEDED(GetSelection(&bstrMyLocation, &bstrMyServer)) )
			{
				if ( csTemp.IsSameAs(bstrMyServer) )
				{
					IConfExplorerDetailsView *pDetails;
					if ( SUCCEEDED(pConfExplorer->get_DetailsView(&pDetails)) )
					{
						pDetails->UpdateConfList( (long *) &csTemp.m_lstConfs );
						pDetails->Release();
					}
				}

				SysFreeString( bstrMyLocation );
				SysFreeString( bstrMyServer );
			}
			pConfExplorer->Release();
		}
	}

	return S_OK;
}


STDMETHODIMP CConfExplorerTreeView::BuildJoinConfList(long * pList, VARIANT_BOOL bAllConfs )
{
	_ASSERT( pList );

	m_critServerList.Lock();
	for ( CONFSERVERLIST::iterator i = m_lstServers.begin(); i != m_lstServers.end(); i++ )
		(*i)->BuildJoinConfList( (CONFDETAILSLIST *) pList, bAllConfs );
	m_critServerList.Unlock();

	return S_OK;
}

STDMETHODIMP CConfExplorerTreeView::get_nServerState(ServerState * pVal)
{
	// default return value
	*pVal = SERVER_INVALID;

	HTREEITEM hItem = TreeView_GetSelection( m_wndTree.m_hWnd );
	if ( hItem )
	{
		TV_ITEM tvi;
		tvi.hItem = hItem;
		tvi.mask = TVIF_HANDLE | TVIF_STATE | TVIF_IMAGE;
		tvi.stateMask = TVIS_OVERLAYMASK;

		TreeView_GetItem( m_wndTree.m_hWnd, &tvi );

		switch ( tvi.iImage ) 
		{
			case IMAGE_SERVER:
			case IMAGE_MYNETWORK:
				switch ( tvi.state >> 8 )
				{
					case 0:	*pVal = SERVER_OK;	break;
					case 1: *pVal = SERVER_UNKNOWN; break;
					case 2: *pVal = SERVER_NOT_RESPONDING; break;
					case 3: *pVal = SERVER_QUERYING; break;
				}
				break;
		}
	}

	return S_OK;
}

STDMETHODIMP CConfExplorerTreeView::BuildJoinConfListText(long * pList, BSTR bstrText)
{
	_ASSERT( pList );

	m_critServerList.Lock();
	for ( CONFSERVERLIST::iterator i = m_lstServers.begin(); i != m_lstServers.end(); i++ )
		(*i)->BuildJoinConfList( (CONFDETAILSLIST *) pList, bstrText );
	m_critServerList.Unlock();

	return S_OK;
}

STDMETHODIMP CConfExplorerTreeView::RenameServer()
{
	HTREEITEM hItem;
	hItem = TreeView_GetSelection( m_wndTree.m_hWnd );
	if ( hItem )
		TreeView_EditLabel( m_wndTree.m_hWnd, hItem );

	return S_OK;
}

STDMETHODIMP CConfExplorerTreeView::RemoveConference(BSTR bstrServer, BSTR bstrName)
{
	HRESULT hr = E_FAIL;

	m_critServerList.Lock();

	CConfServerDetails *pConfServer = FindConfServer( bstrServer );
	if ( pConfServer )
	{
		if ( SUCCEEDED(hr = pConfServer->RemoveConference(bstrName)) )
		{
			IConfExplorer *pConfExplorer;
			if ( SUCCEEDED(get_ConfExplorer(&pConfExplorer)) )
			{
				IConfExplorerDetailsView *pDetails;
				if ( SUCCEEDED(pConfExplorer->get_DetailsView(&pDetails)) )
				{
					pDetails->UpdateConfList( (long *) &pConfServer->m_lstConfs );
					pDetails->Release();
				}
				pConfExplorer->Release();
			}
		}
	}

	m_critServerList.Unlock();

	return hr;
}

STDMETHODIMP CConfExplorerTreeView::AddPerson(BSTR bstrServer, ITDirectoryObject * pDirObj)
{
	HRESULT hr = E_FAIL;

	int nCount = 0;
	bool bRetry;
	bool bSuccess = false;

	// Spin in loop waiting to add person to the conference
	do
	{
		bRetry = false;
		m_critServerList.Lock();
		CConfServerDetails *pConfServer = FindConfServer( bstrServer );
		if ( pConfServer )
		{
			if ( pConfServer->m_nState == SERVER_QUERYING )
			{
				ATLTRACE(_T(".1.CConfExplorerTreeView::AddPerson() -- sleeping, server being queried.\n"));
				bRetry = true;
			}
			else if ( SUCCEEDED(hr = pConfServer->AddPerson(bstrServer, pDirObj)) )
			{
				ATLTRACE(_T(".1.CConfExplorerTreeView::AddPerson() -- adding to list.\n"));
				bSuccess = true;
			}
		}
		m_critServerList.Unlock();

		// Sleep while we're waiting
		if ( bRetry )
			Sleep( 3000 );

	} while ( bRetry && (++nCount < 20) );
	ATLTRACE(_T(".1.CConfExplorerTreeView::AddPerson() -- safely out of spin loop.\n"));

	// Notification for host application of servers being loaded
	if ( bSuccess )
	{
		CComPtr<IAVGeneralNotification> pAVGen;
		_Module.get_AVGenNot( &pAVGen );
		if ( pAVGen )
			pAVGen->fire_AddUser( NULL, NULL, NULL );
	}

	return hr;
}


STDMETHODIMP CConfExplorerTreeView::AddConference(BSTR bstrServer, ITDirectoryObject * pDirObj)
{
	HRESULT hr = E_FAIL;

	m_critServerList.Lock();

	CConfServerDetails *pConfServer = FindConfServer( bstrServer );
	if ( pConfServer )
	{
		if ( SUCCEEDED(hr = pConfServer->AddConference(bstrServer, pDirObj)) )
		{
			IConfExplorer *pConfExplorer;
			if ( SUCCEEDED(get_ConfExplorer(&pConfExplorer)) )
			{
				IConfExplorerDetailsView *pDetails;
				if ( SUCCEEDED(pConfExplorer->get_DetailsView(&pDetails)) )
				{
					pDetails->UpdateConfList( (long *) &pConfServer->m_lstConfs );
					pDetails->Release();
				}
				pConfExplorer->Release();
			}
		}
	}

	m_critServerList.Unlock();

	return hr;
}

STDMETHODIMP CConfExplorerTreeView::EnumSiteServer(BSTR bstrName, IEnumSiteServer * * ppEnum)
{
	// First make a copy of what we have for the server
	CConfServerDetails *pConfServer = NULL;
	CConfServerDetails csTemp;

	m_critServerList.Lock();
	pConfServer = FindConfServer( bstrName );
	if ( pConfServer )
		csTemp = *pConfServer;
	m_critServerList.Unlock();

	// Bad server name
	if ( !pConfServer )
	{
#ifdef _DEBUG
		USES_CONVERSION;
		ATLTRACE(_T(".warning.CConfExplorerTreeView::EnumSiteServer(%s) name not found in list.\n"), OLE2CT(bstrName) );
#endif
		return E_FAIL;
	}

	// Make a copy of everything...
	HRESULT hr = E_OUTOFMEMORY;
	*ppEnum = new CComObject<CEnumSiteServer>;
	if ( *ppEnum )
		hr = (*ppEnum)->BuildList( (long *) &csTemp.m_lstPersons );

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\cetreeview.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// ConfExplorerTreeView.h : Declaration of the CConfExplorerTreeView

#ifndef __CONFEXPLORERTREEVIEW_H_
#define __CONFEXPLORERTREEVIEW_H_

// FWD define
class CConfExplorerTreeView;

#include "resource.h"       // main symbols
#include "ExpTreeView.h"
#include "ConfDetails.h"

#pragma warning( disable : 4786 )
#include <list>
using namespace std;
typedef list<CConfServerDetails *> CONFSERVERLIST;

#define MAX_SERVER_SIZE				255
#define MAX_TREE_DEPTH				5

/////////////////////////////////////////////////////////////////////////////
// CConfExplorerTreeView
class ATL_NO_VTABLE CConfExplorerTreeView : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CConfExplorerTreeView, &CLSID_ConfExplorerTreeView>,
	public IConfExplorerTreeView
{
friend class CExpTreeView;

// Enumerations
public:
	typedef enum tag_ListType_t
	{
		LISTTYPE_LOCATION,
		LISTTYPE_SERVER,
	} ListType_t;

	typedef enum tag_ImageType_t
	{
		IMAGE_ROOT,
		IMAGE_MYNETWORK,
		IMAGE_LOCATION,
		IMAGE_SERVER,
		IMAGE_SERVER_CONF,
		IMAGE_CONFERENCE,
	} ImageType_t;

// Construction
public:
	CConfExplorerTreeView();
	void FinalRelease();

// Members
protected:
	IConfExplorer	*m_pIConfExplorer;
	CExpTreeView	m_wndTree;
	HWND			m_hWndParent;
	DWORD			m_dwRefreshInterval;
	HIMAGELIST		m_hIml;

	CONFSERVERLIST				m_lstServers;
	CComAutoCriticalSection		m_critServerList;

// Operations
public:
	void					UpdateData( bool bSaveAndValidate );
	LRESULT					OnSelChanged( LPNMHDR lpnmHdr );
	LRESULT					OnEndLabelEdit( TV_DISPINFO *pInfo );
protected:
	void					InitImageLists();

	HRESULT					EnumerateConfServers();
	HRESULT					AddConfServer( BSTR bstrServer );
	void					ArchiveConfServers();
	void					CleanConfServers();
    void                    RemoveServerFromReg( BSTR bstrServer );

	void					SetServerState( CConfServerDetails *pcsd );

private:
	CConfServerDetails*		FindConfServer( const OLECHAR *lpoleServer );

// Implementation
public:
DECLARE_NOT_AGGREGATABLE(CConfExplorerTreeView)

BEGIN_COM_MAP(CConfExplorerTreeView)
	COM_INTERFACE_ENTRY(IConfExplorerTreeView)
END_COM_MAP()

// IConfExplorerTreeView
public:
	STDMETHOD(AddPerson)(BSTR bstrServer, ITDirectoryObject *pDirObj);
	STDMETHOD(EnumSiteServer)(BSTR bstrName, IEnumSiteServer **ppEnum);
	STDMETHOD(AddConference)(BSTR bstrServer, ITDirectoryObject *pDirObj);
	STDMETHOD(RenameServer)();
	STDMETHOD(BuildJoinConfListText)(long *pList, BSTR bstrText);
	STDMETHOD(AddLocation)(BSTR bstrLocation);
	STDMETHOD(RemoveConference)(BSTR bstrServer, BSTR bstrName);
	STDMETHOD(get_nServerState)(/*[out, retval]*/ ServerState *pVal);
	STDMETHOD(BuildJoinConfList)(long *pList, VARIANT_BOOL bAllConfs);
	STDMETHOD(get_dwRefreshInterval)(/*[out, retval]*/ DWORD *pVal);
	STDMETHOD(put_dwRefreshInterval)(/*[in]*/ DWORD newVal);
	STDMETHOD(ForceConfServerForEnum)(BSTR bstrServer );
	STDMETHOD(SetConfServerForEnum)(BSTR bstrServer, long *pList, long *pListPersons, DWORD dwTicks, BOOL bUpdate);
	STDMETHOD(GetConfServerForEnum)(BSTR *pbstrServer );
	STDMETHOD(CanRemoveServer)();
	STDMETHOD(GetSelection)(BSTR *pbstrLocation, BSTR *pbstrServer);
	STDMETHOD(FindOrAddItem)(BSTR bstrLocation, BSTR bstrServer, BOOL bAdd, BOOL bLocationOnly, long **pphItem);
	STDMETHOD(get_ConfExplorer)(/*[out, retval]*/ IConfExplorer* *pVal);
	STDMETHOD(put_ConfExplorer)(/*[in]*/ IConfExplorer* newVal);
	STDMETHOD(RemoveServer)(BSTR bstrLocation, BSTR bstrName);
	STDMETHOD(AddServer)(BSTR bstrName);
	STDMETHOD(Refresh)();
	STDMETHOD(SelectItem)(short nSel);
	STDMETHOD(Select)(BSTR bstrName);
	STDMETHOD(get_hWnd)(/*[out, retval]*/ HWND *pVal);
	STDMETHOD(put_hWnd)(/*[in]*/ HWND newVal);
};

#endif //__CONFEXPLORERTREEVIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\confexp.cpp ===
///////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// ConfExplorer.cpp : Implementation of CConfExplorer
#include "stdafx.h"
#include <stdio.h>
#include "TapiDialer.h"
#include "AVTapi.h"
#include "ConfExp.h"
#include "CETreeView.h"
#include "CEDetailsVw.h"
#include "confprop.h"

#ifndef RENDBIND_AUTHENTICATE
#define RENDBIND_AUTHENTICATE	TRUE
#endif

#define HARDCODEDERROR_CREATEFAILDUPLICATE	0x800700b7
#define HARDCODEDERROR_ACCESSDENIED			   0x80070005

/////////////////////////////////////////////////////////////////////////////
// CConfExplorer

CConfExplorer::CConfExplorer()
{
	m_pITRend = NULL;

	m_pDetailsView = NULL;
	m_pTreeView = NULL;
}

void CConfExplorer::FinalRelease()
{
	ATLTRACE(_T(".enter.CConfExplorer::FinalRelease().\n"));

	// These should be released through the UNSHOW method
	_ASSERT( !m_pDetailsView );
	_ASSERT( !m_pTreeView );

	RELEASE( m_pITRend );

	CComObjectRootEx<CComMultiThreadModel>::FinalRelease();
}

STDMETHODIMP CConfExplorer::get_TreeView(IConfExplorerTreeView **ppVal)
{
	HRESULT hr = E_OUTOFMEMORY;

	Lock();
	if ( m_pTreeView )
		hr = m_pTreeView->QueryInterface(IID_IConfExplorerTreeView, (void **) ppVal );
	Unlock();

	return hr;
}

STDMETHODIMP CConfExplorer::get_DetailsView(IConfExplorerDetailsView **ppVal)
{
	HRESULT hr = E_OUTOFMEMORY;

	Lock();
	if ( m_pDetailsView )
		hr = m_pDetailsView->QueryInterface( IID_IConfExplorerDetailsView, (void **) ppVal ); 		
	Unlock();

	return hr;
}

HRESULT CConfExplorer::GetDirectory( ITRendezvous *pRend, BSTR bstrServer, ITDirectory **ppDir )
{
	HRESULT hr = E_FAIL;
	*ppDir = NULL;

	// Do they want the default server?
	if ( !bstrServer )
	{
		// Get default server name
		BSTR bstrDefaultServer = NULL;
		CComPtr<IAVTapi> pAVTapi = NULL;
		if ( SUCCEEDED(hr = _Module.get_AVTapi(&pAVTapi)) )
		{
			pAVTapi->get_bstrDefaultServer( &bstrDefaultServer );

			if ( bstrDefaultServer )
				hr = pRend->CreateDirectory( DT_ILS, bstrDefaultServer, ppDir );
			else
				hr = E_FAIL;
		}
		SysFreeString( bstrDefaultServer );
		bstrDefaultServer = NULL;

		// Return if we succeed to connect and bind to the server
		if ( SUCCEEDED(hr) && SUCCEEDED(ConnectAndBindToDirectory(*ppDir)) )
			return S_OK;

		// Clear out stored default server name
		if ( pAVTapi )
			pAVTapi->put_bstrDefaultServer( NULL );

		// No default server, or the default server is bad -- get a new one
		IEnumDirectory *pEnum;
		if ( SUCCEEDED(hr = pRend->EnumerateDefaultDirectories(&pEnum)) )
		{
			// Default is we don't find a server
			hr = E_FAIL;
			ITDirectory *pDir;

			while ( pEnum->Next(1, &pDir, NULL) == S_OK )
			{
				// Look for an ILS server
				DIRECTORY_TYPE nType;
				pDir->get_DirectoryType( &nType );
				if ( nType == DT_ILS )
				{
					// Try to connect and bind
					*ppDir = pDir;

					// Store default name for future reference
					if ( pAVTapi )
					{
						pDir->get_DisplayName( &bstrDefaultServer );
						pAVTapi->put_bstrDefaultServer( bstrDefaultServer );
						SysFreeString( bstrDefaultServer );
						bstrDefaultServer = NULL;
					}

					hr = S_OK;
					break;
				}

				// Clear out variables for next round
				pDir->Release();
			}
			pEnum->Release();
		}
	}

	if ( bstrServer )
	{
		// This is a user specified directory
		hr = pRend->CreateDirectory( DT_ILS, bstrServer, ppDir );
	}

	if ( SUCCEEDED(hr) && *ppDir )
		hr = ConnectAndBindToDirectory( *ppDir );

	return hr;
}

HRESULT CConfExplorer::ConnectAndBindToDirectory( ITDirectory *pDir )
{
	HRESULT hr = E_FAIL;

	// If we have a valid Directory object, connect and bind to it
	if ( pDir )
	{
		if ( SUCCEEDED(hr = pDir->Connect(FALSE)) )
		{
			// Bind to the server
			pDir->Bind( NULL, NULL, NULL, RENDBIND_AUTHENTICATE );
		}
		else
		{
			pDir->Release();
			pDir = NULL;
		}
	}

	return hr;
}


STDMETHODIMP CConfExplorer::get_ConfDirectory(BSTR *pbstrServer, IDispatch **ppVal)
{
	HRESULT hr = S_OK;
	*ppVal = NULL;

	ITRendezvous *pRend;
	if ( SUCCEEDED(get_ITRendezvous((IUnknown **) &pRend)) )
	{
		IConfExplorerTreeView *pTreeView;
		if ( SUCCEEDED(hr = get_TreeView(&pTreeView)) )
		{
			BSTR bstrLocation = NULL, bstrServer = NULL;
			if ( SUCCEEDED(hr = pTreeView->GetSelection(&bstrLocation, &bstrServer)) )
			{
				if ( SUCCEEDED(hr = GetDirectory(m_pITRend, bstrServer, (ITDirectory **) ppVal)) && pbstrServer )
				{
					// copy server name if requested
					*pbstrServer = bstrServer;
					bstrServer = NULL;
				}
			}

			SysFreeString( bstrLocation );
			SysFreeString( bstrServer );

			pTreeView->Release();
		}
		pRend->Release();
	}

	return hr;
}

STDMETHODIMP CConfExplorer::Show(HWND hWndList, HWND hWndDetails)
{
	_ASSERT( IsWindow(hWndList) && IsWindow(hWndDetails) );	// Must have both
	if ( !IsWindow(hWndList) || !IsWindow(hWndDetails) ) return E_INVALIDARG;

	// Allocate conf explorer objects
	Lock();
	m_pTreeView = new CComObject<CConfExplorerTreeView>;
	if ( m_pTreeView )
	{
		m_pTreeView->AddRef();
		m_pTreeView->put_ConfExplorer( this );
	}

	m_pDetailsView = new CComObject<CConfExplorerDetailsView>;
	if ( m_pDetailsView )
	{
		m_pDetailsView->AddRef();
		m_pDetailsView->put_ConfExplorer( this );
	}
	Unlock();

	// Setup the HWND's
	IConfExplorerTreeView *pList;
	if ( SUCCEEDED(get_TreeView(&pList)) )
	{
		IConfExplorerDetailsView *pDetails;
		if ( SUCCEEDED(get_DetailsView(&pDetails)) )
		{
			pList->put_hWnd( hWndList );
			pDetails->put_hWnd( hWndDetails );

			pDetails->Release();
		}
		pList->Release();
	}

	// Register resource instance with ConfProp library
	ConfProp_Init( _Module.GetResourceInstance() );

	return S_OK;
}

STDMETHODIMP CConfExplorer::UnShow()
{
	ATLTRACE(_T(".enter.CConfExplorer::UnShow().\n"));

	IConfExplorerTreeView *pTreeView;
	if ( SUCCEEDED(get_TreeView(&pTreeView)) )
	{
		pTreeView->put_hWnd( NULL );
		pTreeView->Release();
	}

	IConfExplorerDetailsView *pDetailsView;
	if ( SUCCEEDED(get_DetailsView(&pDetailsView)) )
	{
		pDetailsView->put_hWnd( NULL );
		pDetailsView->Release();
	}

	// Clean up objects
	Lock();
	RELEASE( m_pTreeView );
	RELEASE( m_pDetailsView );
	Unlock();

	return S_OK;
}

STDMETHODIMP CConfExplorer::Create(BSTR bstrName)
{
	CErrorInfo er(IDS_ER_CREATE_CONF, IDS_ER_GET_RENDEZVOUS);

	ITRendezvous *pRend;
	if ( SUCCEEDED(er.set_hr(get_ITRendezvous((IUnknown **) &pRend))) )
	{
		IConfExplorerTreeView *pTreeView;
		if ( SUCCEEDED(get_TreeView(&pTreeView)) )
		{
			BSTR bstrLocation = NULL, bstrServer = NULL;
			er.set_Details( IDS_ER_NO_VALID_SELECTION );
			if (SUCCEEDED(er.set_hr(pTreeView->GetSelection(&bstrLocation, &bstrServer))))
			{
				// let user assign properties to conference
				//
				ITDirectoryObject *pDirObject = NULL;

				CONFPROP confprop;
				confprop.ConfInfo.Init(pRend, NULL, &pDirObject, true);

				do
				{
					er.set_hr( S_OK );

					int nRet = ConfProp_DoModal( _Module.GetParentWnd(), confprop );
					if ( (nRet == IDOK) && pDirObject )
					{
						// Show hourglass
						HCURSOR hCurOld = SetCursor( LoadCursor(NULL, IDC_WAIT) );

						ITDirectory *pDirectory = NULL;
						er.set_Details( IDS_ER_ACCESS_ILS_SERVER );
						if ( SUCCEEDED(er.set_hr(GetDirectory(pRend, bstrServer, &pDirectory))) )
						{
							er.set_Details( IDS_ER_ADD_CONF_TO_SERVER );
							if ( SUCCEEDED(er.set_hr(pDirectory->AddDirectoryObject(pDirObject))) )
								pTreeView->AddConference( bstrServer, pDirObject );

							// Failure with ACL's try with different set.
							if ( er.m_hr == HARDCODEDERROR_ACCESSDENIED )
							{
								// Try using NULL security descriptor.
								//if ( _Module.DoMessageBox(IDS_ER_ADD_CONF_FAIL_ACCESSDENIED_TRYAGAIN, MB_ICONEXCLAMATION | MB_YESNO, true) == IDYES )
								//{
								//	pDirObject->put_SecurityDescriptor( NULL );
								//	pTreeView->AddConference( bstrServer, pDirObject );
								//}

                                //Bug391254. If was a security problem, the conference wasn't create
								_Module.DoMessageBox(IDS_ER_ADD_CONF_FAIL_ACCESSDENIED_TRYAGAIN, MB_ICONERROR, true);

								// Reset the error code.
								er.set_hr( S_OK );
							}

							if ( er.m_hr == HARDCODEDERROR_CREATEFAILDUPLICATE )
								_Module.DoMessageBox( IDS_ER_ADD_CONF_FAIL_DUPLICATE, MB_ICONEXCLAMATION, true );

							pDirectory->Release();
						}
						// Restore wait cursor
						SetCursor( hCurOld );
					}
				} while ( er.m_hr == HARDCODEDERROR_CREATEFAILDUPLICATE );

				// Clean up
				RELEASE( pDirObject );
			}
			SysFreeString( bstrLocation );
			SysFreeString( bstrServer );

			pTreeView->Release();
		}
		pRend->Release();
	}

	return er.m_hr;
}

STDMETHODIMP CConfExplorer::Delete(BSTR bstrName)
{
	CErrorInfo er( IDS_ER_CONF_DELETE, 0 );

	ITDirectory *pConfDir;
	ITDirectoryObjectConference *pConf = NULL;;

	// Show hourglass
	HCURSOR hCurOld = SetCursor( LoadCursor(NULL, IDC_WAIT) );
	BSTR bstrServer = NULL;
	BSTR bstrConf = NULL;

	er.set_Details( IDS_ER_NO_VALID_SELECTION );
	if ( SUCCEEDED(er.set_hr(get_ConfDirectory(&bstrServer, (IDispatch **) &pConfDir))) )
	{
		if ( bstrName && SysStringLen(bstrName) )
		{
			bstrConf = SysAllocString( bstrName );
		}
		else
		{
			IConfExplorerDetailsView *pDetailsView;
			if ( SUCCEEDED(er.set_hr(get_DetailsView(&pDetailsView))) )
			{
				er.set_hr( pDetailsView->get_Selection(NULL, NULL, &bstrConf) );
				pDetailsView->Release();
			}
		}

		// Delete the conference specified
		if ( SUCCEEDED(er.set_hr(GetConference(pConfDir, bstrConf, &pConf))) && pConf )
		{
			ITDirectoryObject *pDirObject;
			er.set_Details( IDS_ER_QUERYINTERFACE );
			if ( SUCCEEDED(er.set_hr(pConf->QueryInterface(IID_ITDirectoryObject, (void **) &pDirObject))) )
			{
				er.set_Details( IDS_ER_DELETE_FROM_SERVER );
				er.set_hr( pConfDir->DeleteDirectoryObject(pDirObject) );
				pDirObject->Release();
			}

			pConf->Release();
		}

		pConfDir->Release();
	}

	// If we successfully deleted the conference then we should refresh the view
	if ( SUCCEEDED(er.m_hr) )
	{
		if ( pConf )
			RemoveConference( bstrServer, bstrConf );
		else
			er.set_hr( E_FAIL );
	}

	SysFreeString( bstrServer );
	SysFreeString( bstrConf );

	// Restore cursor
	SetCursor( hCurOld );

	return er.m_hr;
}

HRESULT CConfExplorer::GetDialableAddress( BSTR bstrServer, BSTR bstrConf, BSTR *pbstrAddress )
{
	CComPtr<IAVTapi> pAVTapi;
	HRESULT hr = E_FAIL;

	IConfExplorer *pExplorer;
	if ( SUCCEEDED(_Module.get_AVTapi(&pAVTapi)) && SUCCEEDED(hr = pAVTapi->get_ConfExplorer(&pExplorer)) )
	{
		// Convert the conference name to a dialable address
		ITDirectoryObject *pDirObj;
		if ( SUCCEEDED(hr = pExplorer->get_DirectoryObject(bstrServer, bstrConf, (IUnknown **) &pDirObj)) )
		{
			// convert conf name to a dialable address
			IEnumDialableAddrs *pEnum;
			if ( SUCCEEDED(hr = pDirObj->EnumerateDialableAddrs( LINEADDRESSTYPE_SDP, &pEnum)) )
			{
				hr = pEnum->Next( 1, pbstrAddress, NULL );
				if ( hr == S_FALSE ) hr = E_FAIL;			// no dialable address
				pEnum->Release();
			}
			pDirObj->Release();
		}
		pExplorer->Release();
	}

	return hr;
}

STDMETHODIMP CConfExplorer::Join(long *pConfDetailsArg)
{
	HRESULT hr;
	CComPtr<IAVTapi> pAVTapi;
	if ( FAILED(_Module.get_AVTapi(&pAVTapi)) ) return E_PENDING;

	// Show hourglass
	HCURSOR hCurOld = SetCursor( LoadCursor(NULL, IDC_WAIT) );

	IConfExplorerDetailsView *pDetailsView;
	if ( SUCCEEDED(hr = get_DetailsView(&pDetailsView)) )
	{
		CConfDetails *pConfDetails = (CConfDetails *) pConfDetailsArg;

		// If no name address specified use selected item
		if ( !pConfDetailsArg )
			pDetailsView->get_SelectedConfDetails( (long **) &pConfDetails );

		// Do we have a valid conference to join?
		if ( pConfDetails && pConfDetails->m_bstrAddress && (SysStringLen(pConfDetails->m_bstrAddress) > 0) )
		{
			AVCreateCall info = { 0 };
			info.bstrAddress = SysAllocString( pConfDetails->m_bstrAddress );
			info.lpszDisplayableAddress = pConfDetails->m_bstrName;
			info.lAddressType = LINEADDRESSTYPE_SDP;

			hr = pAVTapi->CreateCall( &info );
			SysFreeString( info.bstrName );
			SysFreeString( info.bstrAddress );

			// Store the conference details in the conference room
			if ( pConfDetails && SUCCEEDED(hr) )
			{
				IConfRoom *pConfRoom;
				if ( SUCCEEDED(pAVTapi->get_ConfRoom(&pConfRoom)) )
				{
					pConfRoom->put_ConfDetails( (long *) pConfDetails );
					pConfRoom->Release();
				}
			}
		}
		else
		{
			// Throw up a dialog for the user
			pAVTapi->JoinConference( NULL, true, NULL );
		}

		// Clean up
		if ( !pConfDetailsArg && pConfDetails ) delete pConfDetails;
		pDetailsView->Release();
	}

	// Restore cursor
	SetCursor( hCurOld );

	return hr;
}

STDMETHODIMP CConfExplorer::Edit(BSTR bstrName)
{
	CErrorInfo er(IDS_ER_EDIT_CONFERENCE, 0);

	IConfExplorerDetailsView *pDetailsView;
	if ( FAILED(er.set_hr(get_DetailsView(&pDetailsView))) )
		return er.m_hr;

	IConfExplorerTreeView *pTreeView;
	if ( SUCCEEDED(er.set_hr(get_TreeView(&pTreeView))) )
	{
		// Show hourglass
		HCURSOR hCurOld = SetCursor( LoadCursor(NULL, IDC_WAIT) );

		BSTR bstrServer = NULL;
		ITDirectory *pConfDir;
		er.set_Details( IDS_ER_GET_CONFERENCE_OBJECT );
		if ( SUCCEEDED(er.set_hr(get_ConfDirectory(&bstrServer, (IDispatch **) &pConfDir))) )
		{
			ITDirectoryObjectConference *pITConf = NULL;

			// Either fetch the requested conference, or get the currently selected one
			if ( (bstrName != NULL) && SysStringLen(bstrName) )
			{
				// Caller specified a particular conference
				er.set_hr( GetConference(pConfDir, bstrName, &pITConf));
			}
			else
			{
				// get currently selected conference
				BSTR bstrTemp = NULL;
				if ( (er.set_hr(pDetailsView->get_Selection(NULL, NULL, &bstrTemp))) == S_OK )
					er.set_hr( GetConference(pConfDir, bstrTemp, &pITConf));

				SysFreeString( bstrTemp );
			}

			// Restore wait cursor
			SetCursor( hCurOld );

			// Did we retrive a conference to edit?  If so show the dialog.
			if ( pITConf )
			{
				ITDirectoryObject *pDirObject = NULL;
				CONFPROP confprop;
				confprop.ConfInfo.Init(NULL, pITConf, &pDirObject, false);

				int nRet = ConfProp_DoModal( _Module.GetParentWnd(), confprop );

				// Did the user pres ok?
				if ( (nRet == IDOK) && pDirObject )
				{
					er.set_Details( IDS_ER_MODIFY_CONF );

					if (SUCCEEDED(er.set_hr(pConfDir->ModifyDirectoryObject(pDirObject))))
						pTreeView->AddConference( bstrServer, pDirObject );
				}

				RELEASE( pDirObject );
				pITConf->Release();
			}
			pConfDir->Release();
		}
		else
		{
			// Restore wait cursor
			SetCursor( hCurOld );
		}

		SysFreeString( bstrServer );
		pTreeView->Release();
	}
	
	// Clean-Up
	pDetailsView->Release();
	return er.m_hr;
}

STDMETHODIMP CConfExplorer::Refresh()
{
	IConfExplorerTreeView *pTreeView;
	if ( SUCCEEDED(get_TreeView(&pTreeView)) )
	{
		pTreeView->Refresh();
		pTreeView->Release();
	}

	IConfExplorerDetailsView *pDetailsView;
	if ( SUCCEEDED(get_DetailsView(&pDetailsView)) )
	{
		pDetailsView->Refresh();
		pDetailsView->Release();
	}

	return S_OK;
}


HRESULT CConfExplorer::GetConference( ITDirectory *pDir, BSTR bstrName, ITDirectoryObjectConference **ppConf )
{
	HRESULT hr;

	// Enumerate through conferences adding them as we go along
	IEnumDirectoryObject *pEnumConf;
	if ( SUCCEEDED(hr = pDir->EnumerateDirectoryObjects(OT_CONFERENCE, bstrName, &pEnumConf)) )
	{
		ITDirectoryObject *pDirObject;
		if ( (hr = pEnumConf->Next(1, &pDirObject, NULL)) == S_OK )
		{
			hr = pDirObject->QueryInterface( IID_ITDirectoryObjectConference, (void **) ppConf );
			pDirObject->Release();
		}
		pEnumConf->Release();
	}

	return hr;
}

HRESULT CConfExplorer::GetDirectoryObject( BSTR bstrServer, BSTR bstrConf, ITDirectoryObject **ppDirObj )
{
	_ASSERT( ppDirObj );
	*ppDirObj = NULL;

	HRESULT hr = E_PENDING;
	Lock();
	if ( !m_pITRend )
	{
		Unlock();
		IDispatch *pDisp;
		if ( SUCCEEDED(get_ConfDirectory(NULL, &pDisp)) )
			pDisp->Release();
		Lock();
	}

	if ( m_pITRend )
	{
		ITDirectory *pDir;
		if ( SUCCEEDED(hr = GetDirectory(m_pITRend, bstrServer, &pDir)) )
		{
			IEnumDirectoryObject *pEnum;
			if ( SUCCEEDED(hr = pDir->EnumerateDirectoryObjects(OT_CONFERENCE, bstrConf, &pEnum)) )
			{
				hr = pEnum->Next( 1, ppDirObj, NULL );
				if ( hr == S_FALSE ) hr = E_FAIL;		// fail on empty list
				pEnum->Release();
			}

			pDir->Release();
		}
	}
	Unlock();
	return hr;
}

STDMETHODIMP CConfExplorer::get_DirectoryObject(BSTR bstrServer, BSTR bstrConf, IUnknown **ppVal)
{
	return GetDirectoryObject( bstrServer, bstrConf, (ITDirectoryObject **) ppVal );
}

HRESULT	CConfExplorer::RemoveConference( BSTR bstrServer, BSTR bstrConf )
{
	IConfExplorerTreeView *pTreeView;
	if ( SUCCEEDED(get_TreeView(&pTreeView)) )
	{
		pTreeView->RemoveConference( bstrServer, bstrConf );
		pTreeView->Release();
	}

	return S_OK;
}

STDMETHODIMP CConfExplorer::get_ITRendezvous(IUnknown **ppVal)
{
	HRESULT hr = E_FAIL;

	Lock();

	// If it doesn't exist, try to create it
	if ( !m_pITRend )
	{
		hr = CoCreateInstance( CLSID_Rendezvous,
							   NULL,
							   CLSCTX_INPROC_SERVER,
							   IID_ITRendezvous,
							   (void **) &m_pITRend );
	}

	if ( m_pITRend )
		hr = m_pITRend->QueryInterface( IID_ITRendezvous, (void **) ppVal );

	Unlock();

	return hr;
}

STDMETHODIMP CConfExplorer::EnumSiteServer(BSTR bstrName, IEnumSiteServer * * ppEnum)
{
	HRESULT hr = E_UNEXPECTED;

	IConfExplorerTreeView *pTreeView;
	if ( SUCCEEDED(get_TreeView(&pTreeView)) )
	{
		hr = pTreeView->EnumSiteServer( bstrName, ppEnum );
		pTreeView->Release();
	}

	return hr;
}

STDMETHODIMP CConfExplorer::AddSpeedDial(BSTR bstrName)
{
	CComPtr<IAVGeneralNotification> pAVGen;
	if ( SUCCEEDED(_Module.get_AVGenNot(&pAVGen)) )
	{
		IConfExplorerDetailsView *pDetailsView;
		if ( SUCCEEDED(get_DetailsView(&pDetailsView)) )
		{
			CConfDetails *pDetails;
			if ( SUCCEEDED(pDetailsView->get_SelectedConfDetails( (long **) &pDetails)) )
			{
				pAVGen->fire_AddSpeedDial( pDetails->m_bstrName, pDetails->m_bstrName, CM_MEDIA_MCCONF );
				delete pDetails;
			}
			else
			{
				pAVGen->fire_AddSpeedDial( NULL, NULL, CM_MEDIA_MCCONF );
			}

			pDetailsView->Release();
		}
	}

	return S_OK;
}

STDMETHODIMP CConfExplorer::IsDefaultServer(BSTR bstrServer)
{
	if ( !bstrServer ) return S_OK;

	HRESULT hr = S_FALSE;
	BSTR bstrDefaultServer = NULL;
	CComPtr<IAVTapi> pAVTapi = NULL;
	if ( SUCCEEDED(_Module.get_AVTapi(&pAVTapi)) )
	{
		pAVTapi->get_bstrDefaultServer( &bstrDefaultServer );
		if ( bstrDefaultServer && (SysStringLen(bstrDefaultServer) > 0) )
		{
			if ( wcsicmp(bstrDefaultServer, bstrServer) == 0 )
				hr = S_OK;
		}
	}
	SysFreeString( bstrDefaultServer );

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\confdetails.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////
// ConfDetails.h
//

#include "sdpblb.h"
#include "tapidialer.h"

#ifndef __CONFDETAILS_H__
#define __CONFDETAILS_H__

// FWD defines
class CPersonDetails;
class CConfDetails;
class CConfServerDetails;
class CConfExplorerDetailsView;

#include <list>
using namespace std;
typedef list<CConfDetails *> CONFDETAILSLIST;
typedef list<CPersonDetails *> PERSONDETAILSLIST;

//////////////////////////////////////////////////////
// class CConfSDP
//
class CConfSDP
{
// Enums
public:
	typedef enum tagConfMediaType_t
	{
		MEDIA_NONE			= 0x0000,
		MEDIA_AUDIO			= 0x0001,
		MEDIA_VIDEO			= 0x0002,
		MEDIA_AUDIO_VIDEO	= 0x0003,
	} ConfMediaType;

// Construction
public:
	CConfSDP();
	virtual ~CConfSDP();

// Members
public:
	ConfMediaType		m_nConfMediaType;

// Operations
public:
	void		UpdateData( ITSdp *pSdp );
	CConfSDP&	operator=( const CConfSDP &src );
};

///////////////////////////////////////////////////////////
// clase CPersonDetails
//
class CPersonDetails
{
// Construction
public:
	CPersonDetails();
	virtual ~CPersonDetails();

// Members
public:
	BSTR		m_bstrName;
	BSTR		m_bstrAddress;
	BSTR		m_bstrComputer;

// Operators
public:
	virtual	CPersonDetails& operator=( const CPersonDetails& src );

// Implementation
public:
	int		Compare( const CPersonDetails& src );
	void	Empty();
	void	Populate( BSTR bstrServer, ITDirectoryObject *pITDirObject );
};

//////////////////////////////////////////////////////////
// class CConfDetails
//
class CConfDetails
{
// Construction
public:
	CConfDetails();
	virtual ~CConfDetails();

// Members
public:
	BSTR			m_bstrServer;
	BSTR			m_bstrName;
	BSTR			m_bstrDescription;
	BSTR			m_bstrOriginator;
	DATE			m_dateStart;
	DATE			m_dateEnd;
	VARIANT_BOOL	m_bIsEncrypted;

	BSTR			m_bstrAddress;

	CConfSDP		m_sdp;

// Attributes
public:
	HRESULT			get_bstrDisplayableServer( BSTR *pbstrServer );
	bool			IsSimilar( BSTR bstrText );

// Operations
public:
	int				Compare( CConfDetails *p1, bool bAscending, int nSortCol1, int nSortCol2 ) const;
	void			MakeDetailsCaption( BSTR& bstrCaption );

// Implementation
public:
	void			Populate( BSTR bstrServer, ITDirectoryObject *pITDirObject );

// Operators
public:
	virtual			CConfDetails& operator=( const CConfDetails& src );
};


/////////////////////////////////////////////////////////////////////////////
// class CConfServerDetails
//
class CConfServerDetails
{
// Construction
public:
	CConfServerDetails();
	virtual ~CConfServerDetails();

// Members
public:
	BSTR						m_bstrServer;
	CONFDETAILSLIST				m_lstConfs;
	PERSONDETAILSLIST			m_lstPersons;
	CComAutoCriticalSection		m_critLstConfs;
	CComAutoCriticalSection		m_critLstPersons;

	ServerState			m_nState;
	bool				m_bArchived;
	DWORD				m_dwTickCount;

// Attributes
public:
	bool IsSameAs( const OLECHAR *lpoleServer ) const;

// Operators
public:
	HRESULT RemoveConference( BSTR bstrName );
	HRESULT AddConference( BSTR bstrServer, ITDirectoryObject *pDirObj );
	HRESULT AddPerson( BSTR bstrServer, ITDirectoryObject *pDirObj );

	virtual CConfServerDetails& operator=( const CConfServerDetails& src );
	void	CopyLocalProperties( const CConfServerDetails& src );

	void	BuildJoinConfList( CONFDETAILSLIST *pList, VARIANT_BOOL bAllConfs );
	void	BuildJoinConfList( CONFDETAILSLIST *pList, BSTR bstrText );
};

#endif //__CONFDETAILS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\confexp.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// ConfExplorer.h : Declaration of the CConfExplorer

#ifndef __CONFEXPLORER_H_
#define __CONFEXPLORER_H_

#include "resource.h"       // main symbols

#define MAX_ENUMLISTSIZE		1000

/////////////////////////////////////////////////////////////////////////////
// CConfExplorer
class ATL_NO_VTABLE CConfExplorer : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CConfExplorer, &CLSID_ConfExplorer>,
	public IConfExplorer
{
// Construction
public:
	CConfExplorer();
	void FinalRelease();

// Members
protected:
	ITRendezvous				*m_pITRend;

	IConfExplorerTreeView		*m_pTreeView;
	IConfExplorerDetailsView	*m_pDetailsView;

// Attributes
public:
	static HRESULT  GetDialableAddress( BSTR bstrServer, BSTR bstrConf, BSTR *pbstrAddress );
	static HRESULT	GetDirectory( ITRendezvous *pRend, BSTR bstrServer, ITDirectory **ppDir );
	static HRESULT  ConnectAndBindToDirectory( ITDirectory *pDir );
	HRESULT			GetDirectoryObject( BSTR bstrServer, BSTR bstrConf, ITDirectoryObject **ppDirObj );

	HRESULT			RemoveConference( BSTR bstrServer, BSTR bstrConf );

// Implementation
public:
	static HRESULT GetConference( ITDirectory *pDir, BSTR bstrName, ITDirectoryObjectConference **ppConf );

DECLARE_NOT_AGGREGATABLE(CConfExplorer)

BEGIN_COM_MAP(CConfExplorer)
	COM_INTERFACE_ENTRY(IConfExplorer)
END_COM_MAP()

// IConfExplorer
public:
	STDMETHOD(IsDefaultServer)(BSTR bstrServer);
	STDMETHOD(AddSpeedDial)(BSTR bstrName);
	STDMETHOD(EnumSiteServer)(BSTR bstrName, IEnumSiteServer **ppEnum);
	STDMETHOD(get_ITRendezvous)(/*[out, retval]*/ IUnknown **ppVal);
	STDMETHOD(get_DirectoryObject)(BSTR bstrServer, BSTR bstrConf, /*[out, retval]*/ IUnknown* *pVal);
	STDMETHOD(get_ConfDirectory)(BSTR *pbstrServer, /*[out, retval]*/ IDispatch * *pVal);
	STDMETHOD(get_DetailsView)(/*[out, retval]*/ IConfExplorerDetailsView * *pVal);
	STDMETHOD(get_TreeView)(/*[out, retval]*/ IConfExplorerTreeView * *pVal);
	STDMETHOD(Refresh)();
	STDMETHOD(Edit)(BSTR bstrName);
	STDMETHOD(Delete)(BSTR bstrName);
	STDMETHOD(Create)(BSTR bstrName);
	STDMETHOD(Join)(long *pDetails);
	STDMETHOD(UnShow)();
	STDMETHOD(Show)(HWND hWndList, HWND hWndDetails);
};

#endif //__CONFEXPLORER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\confrmwnd.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////
// ConfRoomWnd.cpp
//

#include "stdafx.h"
#include "TapiDialer.h"
#include "AVTapi.h"
#include "ConfRoom.h"

// Hard coded video values
#define WND_DX		4
#define WND_DY		3

CConfRoomWnd::CConfRoomWnd()
{
	m_pConfRoom = NULL;
	m_wndMembers.m_pConfRoomWnd = this;
	m_wndTalker.m_pConfRoomWnd = this;

	m_hBmpFeed_Large = NULL;
	m_hBmpFeed_Small = NULL;
	m_hBmpFeed_LargeAudio = NULL;
}

bool CConfRoomWnd::CreateStockWindows()
{
	CErrorInfo er( IDS_ER_CREATE_WINDOWS, 0 );
	bool bRet = true;
	RECT rc = {0};
	
	// Talker window is top frame
	if ( !IsWindow(m_wndTalker.m_hWnd) )
	{
		m_wndTalker.m_hWnd = NULL;
		m_wndTalker.Create( m_hWnd, rc, NULL, WS_CHILD | WS_BORDER | WS_VISIBLE, WS_EX_CLIENTEDGE, IDW_TALKER );
		bRet = (bool) (m_wndTalker != NULL);
	}

	// Member window is bottom frame
	if ( !IsWindow(m_wndMembers.m_hWnd) )
	{
		m_wndMembers.m_hWnd = NULL;
		m_wndMembers.Create( m_hWnd, rc, NULL, WS_CHILD | WS_BORDER | WS_VISIBLE | WS_VSCROLL, WS_EX_CLIENTEDGE, IDW_MEMBERS );

		// Make sure window accepts double clicks
		if ( m_wndMembers.m_hWnd )
		{
			ULONG_PTR ulpClass = GetClassLongPtr( m_wndMembers.m_hWnd, GCL_STYLE );
			ulpClass |= CS_DBLCLKS;
			SetClassLongPtr( m_wndMembers.m_hWnd, GCL_STYLE, ulpClass );
		}
		else
		{
			bRet = false;
		}
	}

	_ASSERT( bRet );
	if ( !bRet ) er.set_hr( E_UNEXPECTED );
	return bRet;
}


HRESULT CConfRoomWnd::LayoutRoom( LayoutStyles_t layoutStyle, bool bRedraw )
{
	// Push the request onto a FIFO
	m_critLayout.Lock();
	DWORD dwInfo = layoutStyle;
	m_lstLayout.push_back( dwInfo );
	m_critLayout.Unlock();

	// Queue request if critical section already locked.
	if ( TryEnterCriticalSection(&m_critThis.m_sec) == FALSE )
		return E_PENDING;
	
	// Create the conference room windows if not already created
	if ( !m_pConfRoom || !IsWindow(m_hWnd) )
	{
		m_critLayout.Lock();
		m_lstLayout.pop_front();
		m_critLayout.Unlock();

		m_critThis.Unlock();
		return E_FAIL;
	}

	
	// Pull next item off of the list.
	for (;;)
	{
		m_critLayout.Lock();
		// No more items on list to process
		if ( m_lstLayout.empty() )
		{
			m_critLayout.Unlock();
			break;
		}
		dwInfo = m_lstLayout.front();
		m_lstLayout.pop_front();
		m_critLayout.Unlock();

		// Extract function parameters
		layoutStyle = (LayoutStyles_t) dwInfo;

		// Layout members of the conference
		if ( (layoutStyle & CREATE_MEMBERS) != 0 )
			m_wndMembers.Layout();

		// Resize conference room window to parent's size
		if ( (layoutStyle & LAYOUT_TALKER) != 0 )
		{
			IAVTapiCall *pAVCall = NULL;
			m_pConfRoom->get_IAVTapiCall( &pAVCall );

			m_wndTalker.Layout( pAVCall, m_pConfRoom->m_szTalker );
//			m_wndTalker.SendMessage( WM_LAYOUT );
//			if ( bRedraw ) m_wndTalker.RedrawWindow();
			m_wndTalker.PostMessage( WM_LAYOUT );
			if ( bRedraw ) m_wndTalker.Invalidate();

			RELEASE( pAVCall );
		}

		if ( (layoutStyle & LAYOUT_MEMBERS) != 0 )
		{
//			m_wndMembers.SendMessage( WM_LAYOUT );
//			if ( bRedraw ) m_wndMembers.RedrawWindow();
			m_wndMembers.PostMessage( WM_LAYOUT, -1, -1 );
			if ( bRedraw ) m_wndMembers.Invalidate();

		}
	}

	// Release crit section and exit
	m_critThis.Unlock();
	return S_OK;
}

//////////////////////////////////////////////////////////////////////////
// Message Handlers

LRESULT CConfRoomWnd::OnDestroy(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled)
{
	if ( m_hBmpFeed_Large )	DeleteObject( m_hBmpFeed_Large );
	if ( m_hBmpFeed_Small ) DeleteObject( m_hBmpFeed_Small );
	if ( m_hBmpFeed_LargeAudio ) DeleteObject( m_hBmpFeed_LargeAudio );

	return 0;
}

LRESULT CConfRoomWnd::OnCreate(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled)
{
	SetClassLongPtr( m_hWnd, GCLP_HBRBACKGROUND, (LONG_PTR) GetSysColorBrush(COLOR_BTNFACE) );

	if ( !m_hBmpFeed_Large )
		m_hBmpFeed_Large = LoadBitmap( GetModuleHandle(NULL), MAKEINTRESOURCE(IDB_STOCK_VIDEO_LARGE) );

	if ( !m_hBmpFeed_Small )
		m_hBmpFeed_Small = LoadBitmap( GetModuleHandle(NULL), MAKEINTRESOURCE(IDB_STOCK_VIDEO_SMALL) );

	if ( !m_hBmpFeed_LargeAudio ) 
		m_hBmpFeed_LargeAudio = LoadBitmap( GetModuleHandle(NULL), MAKEINTRESOURCE(IDB_VIDEO_AUDIO_ONLY2) );

	CreateStockWindows();

	return 0;
}

LRESULT CConfRoomWnd::OnSize(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled)
{
	bHandled = true;

	if ( m_pConfRoom )
	{
		// Resize conference room window to parent's size
		RECT rc;
		::GetClientRect( GetParent(), &rc );
		SetWindowPos( NULL, &rc, SWP_NOACTIVATE );

		// Size Talker window
		RECT rcClient = { WND_DX, WND_DY, max(WND_DX, rc.right - WND_DX), WND_DY + m_pConfRoom->m_szTalker.cy + 2 * VID_DY };
		m_wndTalker.SetWindowPos( NULL, &rcClient, SWP_NOACTIVATE );

		// Size Members window
		OffsetRect( &rcClient, 0, rcClient.bottom + WND_DY );
		rcClient.bottom = max( rcClient.top, rc.bottom - WND_DY );
		m_wndMembers.SetWindowPos(NULL, &rcClient, SWP_NOACTIVATE );
	}

	return 0;
}

LRESULT CConfRoomWnd::OnContextMenu(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled)
{
	// Only handle if we have a detail view to work with
	if ( !m_pConfRoom ) return 0;

	bHandled = true;

	// Load popup menu for Details View
	HMENU hMenu = LoadMenu( _Module.GetResourceInstance(), MAKEINTRESOURCE(IDR_POPUP_CONFROOM_DETAILS) );
	HMENU hMenuPopup = GetSubMenu( hMenu, 0 );
	if ( hMenuPopup )
	{
		// Get current mouse position
		POINT pt = { 10, 10 };
		ClientToScreen( &pt );
		if ( lParam != -1 )
			GetCursorPos( &pt );

		IVideoFeed *pFeed = NULL;
		IVideoWindow *pVideo = NULL;

		if ( SUCCEEDED(m_wndMembers.HitTest(pt, &pFeed)) )
			pFeed->get_IVideoWindow( (IUnknown **) &pVideo );

		// Enable menus accordingly
		if ( m_pConfRoom->CanDisconnect() == S_FALSE )
			EnableMenuItem( hMenuPopup, ID_POPUP_DISCONNECT, MF_BYCOMMAND | MF_GRAYED );
		else
			EnableMenuItem( hMenuPopup, ID_POPUP_JOIN, MF_BYCOMMAND | MF_GRAYED );

		if ( !pVideo )
		{
			// Don't allow QOS on preview
			VARIANT_BOOL bPreview = FALSE;
			if ( pFeed ) pFeed->get_bPreview( &bPreview );

			if ( !bPreview )
				EnableMenuItem( hMenuPopup, ID_POPUP_FASTVIDEO, MF_BYCOMMAND | MF_GRAYED );
		}
		
		// Quality of service
		VARIANT_BOOL bQOS = FALSE;
		if ( pFeed )
			pFeed->get_bRequestQOS( &bQOS );
		CheckMenuItem( hMenuPopup, ID_POPUP_FASTVIDEO, MF_BYCOMMAND | (bQOS) ? MF_CHECKED : MF_UNCHECKED );

		// Full size video
		short nSize = 50;
		m_pConfRoom->get_MemberVideoSize( &nSize );
		CheckMenuItem( hMenuPopup, ID_POPUP_FULLSIZEVIDEO, MF_BYCOMMAND | (nSize > 50) ? MF_CHECKED : MF_UNCHECKED );

		// Show names
		VARIANT_BOOL bShowNames;
		m_pConfRoom->get_bShowNames( &bShowNames );
		CheckMenuItem( hMenuPopup, ID_POPUP_SHOWNAMES, MF_BYCOMMAND | (bShowNames) ? MF_CHECKED : MF_UNCHECKED );

		HMENU hMenuScale = GetSubMenu( hMenuPopup, 5 );
		if ( hMenuScale )
		{
			short nScale;
			m_pConfRoom->get_TalkerScale( &nScale );
			CheckMenuItem( hMenuScale, (nScale - 100) / 50, MF_BYPOSITION | MFT_RADIOCHECK | MFS_CHECKED );
		}

		// Show popup menu
		int nRet = TrackPopupMenu(	hMenuPopup,
									TPM_LEFTALIGN | TPM_TOPALIGN | TPM_RETURNCMD | TPM_RIGHTBUTTON,
									pt.x, pt.y,
									0, m_hWnd, NULL );

		// Process command
		switch ( nRet )
		{
			// Join a conference
			case ID_POPUP_JOIN:
				{
					CComPtr<IAVTapi> pAVTapi;
					if ( SUCCEEDED(_Module.get_AVTapi(&pAVTapi)) )
						pAVTapi->JoinConference( NULL, true, NULL );
				}
				break;

			// Hang up the conference
			case ID_POPUP_DISCONNECT:
				m_pConfRoom->Disconnect();
				break;

			// Switch default size of video screens
			case ID_POPUP_FULLSIZEVIDEO:
				nSize = (nSize > 50) ? 50 : 100;
				m_pConfRoom->put_MemberVideoSize( nSize );
				break;

			// Toggle show names property
			case ID_POPUP_SHOWNAMES:
				m_pConfRoom->put_bShowNames( !bShowNames );
				break;

			// Toggle quality of service
			case ID_POPUP_FASTVIDEO:
				if ( pFeed ) pFeed->put_bRequestQOS( !bQOS );
				{
					IAVTapiCall *pAVCall = NULL;
					if ( SUCCEEDED(m_pConfRoom->get_IAVTapiCall(&pAVCall)) )
					{
						pAVCall->PostMessage( 0, CAVTapiCall::TI_REQUEST_QOS );
						pAVCall->Release();
					}
				}
				break;

			case ID_POPUP_SELECTEDVIDEOSCALE_100:	m_pConfRoom->put_TalkerScale( 100 );	break;
			case ID_POPUP_SELECTEDVIDEOSCALE_150:	m_pConfRoom->put_TalkerScale( 150 );	break;
			case ID_POPUP_SELECTEDVIDEOSCALE_200:	m_pConfRoom->put_TalkerScale( 200 );	break;
		}

		RELEASE( pVideo );
		RELEASE( pFeed );
	}

	// Clean up
	if ( hMenu ) DestroyMenu( hMenu );
	return 0;
}

void CConfRoomWnd::UpdateNames( ITParticipant *pParticipant )
{
	m_wndTalker.UpdateNames( NULL );
	m_wndMembers.UpdateNames( pParticipant );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\confdetail.cpp ===
////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////
// ConfDetails.cpp

#include "stdafx.h"
#include "TapiDialer.h"
#include "CEDetailsVw.h"
#include "ConfDetails.h"

#define MAX_STR        255
#define MAX_FORMAT    500

int CompareDate( DATE d1, DATE d2 )
{
    if ( d1 > d2 )
        return -1;
    else if ( d1 == d2 )
        return 0;
    
    return 1;
}

//////////////////////////////////////////////////////////
// class CConfSDP
//
CConfSDP::CConfSDP()
{
    m_nConfMediaType = MEDIA_AUDIO_VIDEO;
}

CConfSDP::~CConfSDP()
{
}

void CConfSDP::UpdateData( ITSdp *pSdp )
{
    m_nConfMediaType = MEDIA_NONE;

    // Let's see what kind of media this conf supports
    ITMediaCollection *pMediaCollection;
    if ( SUCCEEDED(pSdp->get_MediaCollection(&pMediaCollection)) )
    {
        IEnumMedia *pEnum;
        if ( SUCCEEDED(pMediaCollection->get_EnumerationIf(&pEnum)) )
        {
            ITMedia *pMedia;
            while ( pEnum->Next(1, &pMedia, NULL) == S_OK )
            {
                BSTR bstrMedia = NULL;
                pMedia->get_MediaName( &bstrMedia );
                if ( bstrMedia )
                {
                    if ( !_wcsicmp(bstrMedia, L"audio") )
                        m_nConfMediaType = (ConfMediaType) (m_nConfMediaType + MEDIA_AUDIO);
                    else if ( !_wcsicmp(bstrMedia, L"video") )
                        m_nConfMediaType = (ConfMediaType) (m_nConfMediaType + MEDIA_VIDEO);
                }

                pMedia->Release();
                SysFreeString( bstrMedia );
            }
            pEnum->Release();
        }
        pMediaCollection->Release();
    }
}

CConfSDP& CConfSDP::operator=(const CConfSDP &src)
{
    m_nConfMediaType = src.m_nConfMediaType;
    return *this;
}

////////////////////////////////////////////////////////////
// class CConfDetails
//
CPersonDetails::CPersonDetails()
{
    m_bstrName = NULL;
    m_bstrAddress = NULL;
    m_bstrComputer = NULL;
}

CPersonDetails::~CPersonDetails()
{
    SysFreeString( m_bstrName );
    SysFreeString( m_bstrAddress );
    SysFreeString( m_bstrComputer );
}

void CPersonDetails::Empty()
{
    SysFreeString( m_bstrName );
    m_bstrName = NULL;

    SysFreeString( m_bstrAddress );
    m_bstrAddress = NULL;

    SysFreeString( m_bstrComputer );
    m_bstrComputer = NULL;
}

CPersonDetails& CPersonDetails::operator =( const CPersonDetails& src )
{
    SysReAllocString( &m_bstrName, src.m_bstrName );
    SysReAllocString( &m_bstrAddress, src.m_bstrAddress );
    SysReAllocString( &m_bstrComputer, src.m_bstrComputer );

    return *this;
}

int    CPersonDetails::Compare( const CPersonDetails& src )
{
    int nRet = wcscmp( m_bstrName, src.m_bstrName );
    if ( nRet != 0 ) return nRet;

    nRet = wcscmp( m_bstrAddress, src.m_bstrAddress );
    return nRet;
}

void CPersonDetails::Populate( BSTR bstrServer, ITDirectoryObject *pITDirObject )
{
    // Extract information from ITDirectoryObject
    Empty();

    pITDirObject->get_Name( &m_bstrName );
    
    // Get a computer name
    IEnumDialableAddrs *pEnum = NULL;
    if ( SUCCEEDED(pITDirObject->EnumerateDialableAddrs(LINEADDRESSTYPE_DOMAINNAME, &pEnum)) && pEnum )
    {
        SysFreeString( m_bstrComputer );
        m_bstrComputer = NULL;
        pEnum->Next(1, &m_bstrComputer, NULL );
        pEnum->Release();
    }

    // Get an IP Address
    pEnum = NULL;
    if ( SUCCEEDED(pITDirObject->EnumerateDialableAddrs(LINEADDRESSTYPE_IPADDRESS, &pEnum)) && pEnum )
    {
        SysFreeString( m_bstrAddress );
        m_bstrAddress = NULL;
        pEnum->Next(1, &m_bstrAddress, NULL );
        pEnum->Release();
    }
}



////////////////////////////////////////////////////////////
// class CConfDetails
//
CConfDetails::CConfDetails()
{
    m_bstrServer = m_bstrName = m_bstrDescription = m_bstrOriginator = m_bstrAddress = NULL;
    m_dateStart = m_dateEnd = 0;
    m_bIsEncrypted = FALSE;
}

CConfDetails::~CConfDetails()
{
    SysFreeString( m_bstrServer );
    SysFreeString( m_bstrName );
    SysFreeString( m_bstrDescription );
    SysFreeString( m_bstrOriginator );
    SysFreeString( m_bstrAddress );
}

int    CConfDetails::Compare( CConfDetails *p2, bool bAscending, int nSortCol1, int nSortCol2 ) const
{
    USES_CONVERSION;
    if ( !p2 ) return -1;

    //
    // PREFIX 49769 - VLADE
    // We initialize local variables
    //

    BSTR bstr1 = NULL, bstr2 = NULL;
    int nRet;

    for ( int nSearch = 0; nSearch < 2; nSearch++ )
    {
        bool bStrCmp = true;

        // Secondary sort is always ascending
        nRet = (bAscending || nSearch) ? 1 : -1;

        switch( (nSearch) ? nSortCol2 : nSortCol1 )
        {
            case CConfExplorerDetailsView::COL_STARTS:        nRet *= CompareDate( m_dateStart, p2->m_dateStart );    bStrCmp = false;    break;
            case CConfExplorerDetailsView::COL_ENDS:        nRet *= CompareDate( m_dateEnd, p2->m_dateEnd );        bStrCmp = false;    break;
            case CConfExplorerDetailsView::COL_NAME:        bstr1 = m_bstrName; bstr2 = p2->m_bstrName;                    break;
            case CConfExplorerDetailsView::COL_PURPOSE:        bstr1 = m_bstrDescription; bstr2 = p2->m_bstrDescription;    break;
            case CConfExplorerDetailsView::COL_ORIGINATOR:    bstr1 = m_bstrOriginator, bstr2 = p2->m_bstrOriginator;        break;
            case CConfExplorerDetailsView::COL_SERVER:        bstr1 = m_bstrServer, bstr2 = p2->m_bstrServer;                break;

            default: _ASSERT( false );
        }

        // Perform string comparison and guard against NULLs
        if ( bStrCmp )
        {
            if ( bstr1 && bstr2 )
                nRet *= _wcsicoll( bstr1, bstr2 );
            else if ( bstr2 )
                nRet *= -1;
            else if ( !bstr1 && !bstr2 )
                nRet = 0;
        }

        // If we have a definite search order, then break
        if ( nRet ) break;
    }

    return nRet;
}

CConfDetails& CConfDetails::operator=( const CConfDetails& src )
{
    SysReAllocString( &m_bstrServer, src.m_bstrServer );
    SysReAllocString( &m_bstrName, src.m_bstrName );
    SysReAllocString( &m_bstrDescription, src.m_bstrDescription );
    SysReAllocString( &m_bstrOriginator, src.m_bstrOriginator );
    SysReAllocString( &m_bstrAddress, src.m_bstrAddress );

    m_dateStart = src.m_dateStart;
    m_dateEnd = src.m_dateEnd;
    m_bIsEncrypted = src.m_bIsEncrypted;
    m_sdp = src.m_sdp;

    return *this;
}

HRESULT    CConfDetails::get_bstrDisplayableServer( BSTR *pbstrServer )
{
    *pbstrServer = NULL;

    if ( m_bstrServer )
        return SysReAllocString( pbstrServer, m_bstrServer );
    
    USES_CONVERSION;
    TCHAR szText[255];
    LoadString( _Module.GetResourceInstance(), IDS_DEFAULT_SERVER, szText, ARRAYSIZE(szText) );
    return SysReAllocString( pbstrServer, T2COLE(szText) );
}

void CConfDetails::MakeDetailsCaption( BSTR& bstrCaption )
{
    USES_CONVERSION;
    TCHAR szText[MAX_STR], szMessage[MAX_FORMAT], szMedia[MAX_STR];
    BSTR bstrStart = NULL, bstrEnd = NULL;

    // Convert start and stop time to strings
    VarBstrFromDate( m_dateStart, LOCALE_USER_DEFAULT, NULL, &bstrStart );
    VarBstrFromDate( m_dateEnd, LOCALE_USER_DEFAULT, NULL, &bstrEnd );

    // What type of media do we support?
    //
    // We should initialize nIDS
    //

    UINT nIDS = IDS_CONFROOM_MEDIA_AUDIO;
    switch ( m_sdp.m_nConfMediaType )
    {
        case CConfSDP::MEDIA_AUDIO:                nIDS = IDS_CONFROOM_MEDIA_AUDIO; break;
        case CConfSDP::MEDIA_VIDEO:                nIDS = IDS_CONFROOM_MEDIA_VIDEO; break;
        case CConfSDP::MEDIA_AUDIO_VIDEO:        nIDS = IDS_CONFROOM_MEDIA_AUDIO_VIDEO; break;
    }
    LoadString( _Module.GetResourceInstance(), nIDS, szMedia, ARRAYSIZE(szMedia) );


    LoadString( _Module.GetResourceInstance(), IDS_CONFROOM_DETAILS, szText, ARRAYSIZE(szText) );
    _sntprintf( szMessage, MAX_FORMAT, szText, OLE2CT(m_bstrName),
                                               szMedia,
                                               OLE2CT(bstrStart),
                                               OLE2CT(bstrEnd),
                                               OLE2CT(m_bstrOriginator) );
    szMessage[MAX_FORMAT-1] = _T('\0');

    // Store return value
    bstrCaption = SysAllocString( T2COLE(szMessage) );

    SysFreeString( bstrStart );
    SysFreeString( bstrEnd );
}

bool CConfDetails::IsSimilar( BSTR bstrText )
{
    if ( bstrText )
    {
        if ( !wcsicmp(m_bstrName, bstrText) ) return true;
        if ( !wcsicmp(m_bstrOriginator, bstrText) ) return true;

        // Case independent search of the description
        if ( m_bstrDescription )
        {
            CComBSTR bstrTempText( bstrText );
            CComBSTR bstrTempDescription( m_bstrDescription );
            wcsupr( bstrTempText );
            wcsupr( bstrTempDescription );
            if ( wcsstr(bstrTempDescription, bstrTempText) ) return true;
        }
    }

    return false;
}

void CConfDetails::Populate( BSTR bstrServer, ITDirectoryObject *pITDirObject )
{
    // Set CConfDetails object information
    m_bstrServer = SysAllocString( bstrServer );
    pITDirObject->get_Name( &m_bstrName );

    ITDirectoryObjectConference *pConf;
    if ( SUCCEEDED(pITDirObject->QueryInterface(IID_ITDirectoryObjectConference, (void **) &pConf)) )
    {
        pConf->get_Description( &m_bstrDescription );
        pConf->get_Originator( &m_bstrOriginator );
        pConf->get_StartTime( &m_dateStart );
        pConf->get_StopTime( &m_dateEnd );
        pConf->get_IsEncrypted( &m_bIsEncrypted );

        IEnumDialableAddrs *pEnum;
        if ( SUCCEEDED(pITDirObject->EnumerateDialableAddrs( LINEADDRESSTYPE_SDP, &pEnum)) )
        {
            pEnum->Next( 1, &m_bstrAddress, NULL );
            pEnum->Release();
        }
        
        // Download the SDP information for the conference
        ITSdp *pSdp;
        if ( SUCCEEDED(pConf->QueryInterface(IID_ITSdp, (void **) &pSdp)) )
        {
            m_sdp.UpdateData( pSdp );
            pSdp->Release();
        }

        pConf->Release();
    }
}

///////////////////////////////////////////////////////////////////////
// class CConfServerDetails()
//

CConfServerDetails::CConfServerDetails()
{
    m_bstrServer = NULL;

    m_nState = SERVER_UNKNOWN;
    m_bArchived = true;
    m_dwTickCount = 0;
}

CConfServerDetails::~CConfServerDetails()
{
    SysFreeString( m_bstrServer );
    DELETE_CRITLIST( m_lstConfs, m_critLstConfs );
    DELETE_CRITLIST( m_lstPersons, m_critLstPersons );
}

bool CConfServerDetails::IsSameAs( const OLECHAR *lpoleServer ) const
{
    // Compare server names (case independent); protect against NULL strings
    if ( ((lpoleServer && m_bstrServer) && !wcsicmp(lpoleServer, m_bstrServer)) || (!lpoleServer && !m_bstrServer) )
        return true;

    return false;
}

void CConfServerDetails::CopyLocalProperties( const CConfServerDetails& src )
{
    SysReAllocString( &m_bstrServer, src.m_bstrServer );

    m_nState = src.m_nState;
    m_bArchived = src.m_bArchived;
    m_dwTickCount = src.m_dwTickCount;
}

CConfServerDetails& CConfServerDetails::operator=( const CConfServerDetails& src )
{
    CopyLocalProperties( src );

    // Copy the conference list
    m_critLstConfs.Lock();
    {
        DELETE_LIST( m_lstConfs );
        CONFDETAILSLIST::iterator i, iEnd = src.m_lstConfs.end();
        for ( i = src.m_lstConfs.begin(); i != iEnd; i++ )
        {
            CConfDetails *pDetails = new CConfDetails;
            if ( pDetails )
            {
                *pDetails = *(*i);
                m_lstConfs.push_back( pDetails );
            }
        }
    }
    m_critLstConfs.Unlock();

    // Copy the people lists
    m_critLstPersons.Lock();
    {
        DELETE_LIST( m_lstPersons );
        PERSONDETAILSLIST::iterator i, iEnd = src.m_lstPersons.end();
        for ( i = src.m_lstPersons.begin(); i != iEnd; i++ )
        {
            CPersonDetails *pDetails = new CPersonDetails;
            if ( pDetails )
            {
                *pDetails = *(*i);
                m_lstPersons.push_back( pDetails );
            }
        }
    }
    m_critLstPersons.Unlock();

    return *this;
}

void CConfServerDetails::BuildJoinConfList( CONFDETAILSLIST *pList, BSTR bstrMatchText )
{
    m_critLstConfs.Lock();
    CONFDETAILSLIST::iterator i, iEnd = m_lstConfs.end();
    for ( i = m_lstConfs.begin(); i != iEnd; i++ )
    {
        // Add if the conference either about to start, or started?
        // drop Start time back 15 minutes
        if ( (*i)->IsSimilar(bstrMatchText) )
        {
            CConfDetails *pDetails = new CConfDetails;
            if ( pDetails )
            {
                *pDetails = *(*i);
                pList->push_back( pDetails );
            }
        }
    }
    m_critLstConfs.Unlock();
}

void CConfServerDetails::BuildJoinConfList( CONFDETAILSLIST *pList, VARIANT_BOOL bAllConfs )
{
    DATE dateNow;
    SYSTEMTIME st;
    GetLocalTime( &st );
    SystemTimeToVariantTime( &st, &dateNow );

    m_critLstConfs.Lock();
    CONFDETAILSLIST::iterator i, iEnd = m_lstConfs.end();
    for ( i = m_lstConfs.begin(); i != iEnd; i++ )
    {
        // Add if the conference either about to start, or started?
        // drop Start time back 15 minutes
        if ( bAllConfs || ((((*i)->m_dateStart - (DATE) (.125 / 12)) <= dateNow) && ((*i)->m_dateEnd >= dateNow)) )
        {
            CConfDetails *pDetails = new CConfDetails;
            if ( pDetails )
            {
                *pDetails = *(*i);
                pList->push_back( pDetails );
            }
        }
    }
    m_critLstConfs.Unlock();
}

HRESULT CConfServerDetails::RemoveConference( BSTR bstrName )
{
    HRESULT hr = E_FAIL;
    m_critLstConfs.Lock();
    CONFDETAILSLIST::iterator i, iEnd = m_lstConfs.end();
    for ( i = m_lstConfs.begin(); i != iEnd; i++ )
    {
        // Remove if we have a name match
        if ( !wcscmp((*i)->m_bstrName, bstrName) )
        {
            delete *i;
            m_lstConfs.erase( i );
            hr = S_OK;
            break;
        }

    }
    m_critLstConfs.Unlock();

    return hr;
}

HRESULT CConfServerDetails::AddConference( BSTR bstrServer, ITDirectoryObject *pDirObj )
{
    HRESULT hr = E_FAIL;

    CConfDetails *pNew = new CConfDetails;
    if ( pNew )
    {
        pNew->Populate( bstrServer, pDirObj );

        // First, make sure it doesn't exist
        RemoveConference( pNew->m_bstrName );

        // Add it to the list
        m_critLstConfs.Lock();
        m_lstConfs.push_back( pNew );
        m_critLstConfs.Unlock();
        hr = S_OK;
    }

    return hr;
}

HRESULT CConfServerDetails::AddPerson( BSTR bstrServer, ITDirectoryObject *pDirObj )
{
    // Create a CPersonDetails object containing the information stored in the
    // ITDirectoryObject

    CPersonDetails *pPerson = new CPersonDetails;
    if ( !pPerson ) return E_OUTOFMEMORY;
    pPerson->Populate(bstrServer, pDirObj );

    bool bMatch = false;
        
    m_critLstPersons.Lock();
    {
        PERSONDETAILSLIST::iterator i, iEnd = m_lstPersons.end();
        for ( i = m_lstPersons.begin(); i != iEnd; i++ )
        {
            if ( pPerson->Compare(**i) == 0 )
            {
                bMatch = true;
                break;
            }
        }
    }

    // Add or delete the item depending on whether or not it already exists in the list
    if ( !bMatch )
        m_lstPersons.push_back( pPerson );
    else
        delete pPerson;
        
    m_critLstPersons.Unlock();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\crmemwnd.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// ConfRoomMembersWnd.cpp
//

#include "stdafx.h"
#include "TapiDialer.h"
#include "ConfRoom.h"


// Helper functions...

void AdvanceRect( RECT& rc, const RECT& rcClient, POINT &pt, const SIZE& sz, short nNumLines, VARIANT_BOOL bShowNames, LONG nHeight )
{
    // Basic rectangle dimensions...
    rc.left = pt.x;
    rc.right = pt.x + sz.cx;
    rc.top = pt.y;
    rc.bottom = pt.y + sz.cy;

    pt.x += RECTWIDTH(&rc) + VID_DX;
    if ( (pt.x + RECTWIDTH(&rc)) > rcClient.right )
    {
        pt.x = VID_DX;
        pt.y += RECTHEIGHT(&rc) + VID_DY;
        // Include space for the names?
        if ( bShowNames )
            pt.y +=  nNumLines * nHeight;
    }
}


HRESULT PlaceVideoWindow( IVideoWindow *pVideo, HWND hWnd, const RECT& rc )
{
    _ASSERT( pVideo );

    HWND hWndTemp;
    HRESULT hr = pVideo->get_Owner( (OAHWND FAR*) &hWndTemp );

    if ( SUCCEEDED(hr) )
    {
        pVideo->put_Visible( OAFALSE );
        pVideo->put_Owner( (ULONG_PTR) hWnd );
        pVideo->put_MessageDrain( (ULONG_PTR) ::GetParent(hWnd) );
        pVideo->put_WindowStyle( WS_CHILD | WS_BORDER );

        // Reposition window and set visibility accordingly
        pVideo->SetWindowPosition( rc.left, rc.top, RECTWIDTH(&rc), RECTHEIGHT(&rc) );
        pVideo->put_Visible( OATRUE );
    }

    return hr;
}

HRESULT SizeVideoWindow( IVideoWindow *pVideo, HWND hWnd, const RECT& rc )
{
    // Only show ones that we actually now own!
    HWND hWndOwner;
    HRESULT hr = pVideo->get_Owner( (OAHWND FAR*) &hWndOwner );
    if ( FAILED(hr) ) return hr;

    // Take ownership of the window if it's just floating
    if ( !hWndOwner )
    {
        PlaceVideoWindow( pVideo, hWnd, rc );
    }
    else if ( (hWndOwner == hWnd) )
    {
        long nLeft, nTop, nWidth, nHeight;
        hr = pVideo->GetWindowPosition( &nLeft, &nTop, &nWidth, &nHeight );
        
        if ( SUCCEEDED(hr) )
        {
            if ( (nLeft != rc.left) || (nTop != rc.top) || (nWidth != RECTWIDTH(&rc)) || (nHeight != RECTHEIGHT(&rc)) )
                hr = pVideo->SetWindowPosition( rc.left, rc.top, RECTWIDTH(&rc), RECTHEIGHT(&rc) ); 

            // Set visible only if necessary
            if ( SUCCEEDED(hr) )
            {
                long lVisible;
                pVideo->get_Visible( &lVisible );
                if ( !lVisible )
                    hr = pVideo->put_Visible( OATRUE );
            }
        }
    }

    return hr;
}


#define MY_TIMER_ID        540
UINT CConfRoomMembersWnd::m_nFontHeight = 0;

CConfRoomMembersWnd::CConfRoomMembersWnd()
{
    m_pConfRoomWnd = NULL;
    m_nTimerID = 0;
}

CConfRoomMembersWnd::~CConfRoomMembersWnd()
{
    EmptyList();
}

void CConfRoomMembersWnd::EmptyList()
{
    RELEASE_CRITLIST_TRACE(m_lstFeeds, m_critFeedList );
}

HRESULT CConfRoomMembersWnd::FindVideoFeedFromParticipant( ITParticipant *pParticipant, IVideoFeed **ppFeed )
{
    *ppFeed = NULL;
    if ( !pParticipant ) return E_POINTER;

    HRESULT hr = E_FAIL;    
    m_critFeedList.Lock();
    VIDEOFEEDLIST::iterator i, iEnd = m_lstFeeds.end();
    for ( i = m_lstFeeds.begin(); i != iEnd; i++ )
    {
        ITParticipant *pNewParticipant;
        if ( SUCCEEDED((*i)->get_ITParticipant(&pNewParticipant)) && pNewParticipant )
        {
            if ( pNewParticipant == pParticipant )
            {
                hr = (*i)->QueryInterface( IID_IVideoFeed, (void **) ppFeed );
                pNewParticipant->Release();
                break;
            }
            
            pNewParticipant->Release();
        }
    }
    m_critFeedList.Unlock();

    return hr;
}


HRESULT    CConfRoomMembersWnd::FindVideoPreviewFeed( IVideoFeed **ppFeed )
{
    HRESULT hr = E_FAIL;    
    *ppFeed = NULL;

    m_critFeedList.Lock();
    VIDEOFEEDLIST::iterator i, iEnd = m_lstFeeds.end();
    for ( i = m_lstFeeds.begin(); i != iEnd; i++ )
    {
        VARIANT_BOOL bPreview;
        if ( SUCCEEDED((*i)->get_bPreview(&bPreview)) && bPreview )
        {
            hr = (*i)->QueryInterface( IID_IVideoFeed, (void **) ppFeed );
            break;
        }
    }
    m_critFeedList.Unlock();

    return hr;
}

HRESULT CConfRoomMembersWnd::FindVideoFeed( IVideoWindow *pVideo, IVideoFeed **ppFeed )
{
    *ppFeed = NULL;
    if ( !pVideo ) return E_POINTER;

    HRESULT hr = E_FAIL;    
    m_critFeedList.Lock();
    VIDEOFEEDLIST::iterator i, iEnd = m_lstFeeds.end();
    for ( i = m_lstFeeds.begin(); i != iEnd; i++ )
    {
        IVideoWindow *pNewVideo;
        if ( SUCCEEDED((*i)->get_IVideoWindow((IUnknown **) &pNewVideo)) )
        {
            if ( pNewVideo == pVideo )
            {
                hr = (*i)->QueryInterface( IID_IVideoFeed, (void **) ppFeed );
                pNewVideo->Release();
                break;
            }

            pNewVideo->Release();
        }
    }
    m_critFeedList.Unlock();

    return hr;
}

IVideoFeed* CConfRoomMembersWnd::NewFeed( IVideoWindow *pVideo, const RECT& rc, VARIANT_BOOL bPreview )
{
    // Store location of video feed info
    IVideoFeed *pFeed = NULL;
    if ( SUCCEEDED(FindVideoFeed(pVideo, &pFeed)) )
    {
        // Already represented on the list, don't bother adding
        pFeed->Release();
    }
    else
    {
        // Add video feed to list
        ATLTRACE(_T(".1.CConfRoomMembersWnd::NewVideo() -- adding video feed to list bPreview = %d.\n"), bPreview );
        pFeed = new CComObject<CVideoFeed>;
        if ( pFeed )
        {
            pFeed->AddRef();
            pFeed->put_IVideoWindow( pVideo );

            // Set position of feed
            pFeed->put_rc( rc );
            pFeed->put_bPreview( bPreview );

            m_critFeedList.Lock();
            if ( bPreview )
                m_lstFeeds.push_front( pFeed );
            else
                m_lstFeeds.push_back( pFeed );

            m_critFeedList.Unlock();
        }
    }

    return pFeed;
}

HRESULT CConfRoomMembersWnd::Layout()
{
    ATLTRACE(_T(".enter.CConfRoomMembersWnd::Layout().\n"));
    HRESULT hr = S_FALSE;

    if ( !IsWindow(m_hWnd) ) return hr;

    m_critLayout.Lock();
    _ASSERT( m_pConfRoomWnd && m_pConfRoomWnd->m_pConfRoom );

    RECT rcClient;
    GetClientRect( &rcClient );
    POINT pt = { VID_DX, VID_DY };
    VARIANT_BOOL bShowNames;
    short nNumLines;
    m_pConfRoomWnd->m_pConfRoom->get_bShowNames( &bShowNames );
    m_pConfRoomWnd->m_pConfRoom->get_nShowNamesNumLines( &nNumLines );

    // Retrieve font metrics if we're showing names
    long nHeight;
    if ( bShowNames ) nHeight = GetFontHeight();

    short nPreview = 0;
    short nCount = 0;
    short nNumTerms;
    SIZE sz;

    IAVTapiCall *pAVCall = NULL;
//    IVideoWindow *pTalker = NULL;
    m_pConfRoomWnd->m_pConfRoom->get_IAVTapiCall( &pAVCall );

    // Empty feed list
    EmptyList();

//    m_pConfRoomWnd->m_pConfRoom->get_TalkerVideo( (IDispatch **) &pTalker );
    m_pConfRoomWnd->m_pConfRoom->get_nNumTerms( &nNumTerms );
    m_pConfRoomWnd->m_pConfRoom->get_szMembers( &sz );


    // Set up the original coordinates of the target rect
    RECT rc = { pt.x, pt.y, pt.x + sz.cx, pt.y + sz.cy };

    // Should we add the preview to the list?
    CComPtr<IAVTapi> pAVTapi;
    if ( pAVCall && (m_pConfRoomWnd->m_pConfRoom->IsConfRoomConnected() == S_OK) && SUCCEEDED(_Module.get_AVTapi(&pAVTapi)) )
    {
        // show preview in list of conference memebers
        IVideoWindow *pPreviewVideo;
        if ( SUCCEEDED(pAVCall->get_IVideoWindowPreview((IDispatch **) &pPreviewVideo)) )
        {
            nPreview = 1;

            // Store for later reference
            m_pConfRoomWnd->m_pConfRoom->set_PreviewVideo(pPreviewVideo);

            if ( pAVCall->IsPreviewStreaming() == S_OK )
            {
                PlaceVideoWindow( pPreviewVideo, m_hWnd, rc );
                AdvanceRect( rc, rcClient, pt, sz, nNumLines, bShowNames, nHeight );
            }
            else
            {
                // Insure window is hidden
                pPreviewVideo->put_Visible( OAFALSE );
            }

            NewFeed( pPreviewVideo, rc, TRUE );
            pPreviewVideo->Release();
        }
    }


    // Loop for nNumTerms when there is no AVTapiCall, and loop for all terminals
    // selected when there is an AVTapiCall
    bool bContinue = true;
    for ( int i = 0; (!pAVCall && (i < nNumTerms)) || (pAVCall && bContinue); i++ )
    {
        AdvanceRect( rc, rcClient, pt, sz, nNumLines, bShowNames, nHeight );

        // If we have a call then assign an IVideoWindow interface to each feed
        if ( pAVCall )
        {
            IVideoWindow *pVideo = NULL;
            if ( pAVCall->get_IVideoWindow(nCount, (IDispatch **) &pVideo) == S_OK )
            {
                // Don't mess with talker video window
//                if ( pVideo != pTalker )
                    hr = PlaceVideoWindow( pVideo, m_hWnd, rc );

                // Increment counter
                nCount++;
                NewFeed( pVideo, rc, FALSE );
                pVideo->Release();
            }
            else
            {
                // No more terminals, stop loop
                bContinue = false;
            }
        }
        else
        {
            NewFeed( NULL, rc, FALSE );
        }
    }


    // Setup or destroy timer
    if ( pAVCall && ((nCount + nPreview) > 0) && !m_nTimerID )
    {
        m_nTimerID = SetTimer( MY_TIMER_ID, 450, NULL );
    }
    else if ( !nCount && m_nTimerID )
    {
        if ( KillTimer(MY_TIMER_ID) )
            m_nTimerID = 0;
    }

    RELEASE( pAVCall );
//    RELEASE( pTalker );

    m_critLayout.Unlock();
    return hr;
}

HRESULT CConfRoomMembersWnd::HitTest( POINT pt, IVideoFeed **ppFeed )
{
    HRESULT hr = E_FAIL;
    *ppFeed = NULL;

    ScreenToClient( &pt );

    m_critFeedList.Lock();
    VIDEOFEEDLIST::iterator i, iEnd = m_lstFeeds.end();
    for ( i = m_lstFeeds.begin(); i != iEnd; i++ )
    {
        RECT rc;
        (*i)->get_rc( &rc );

        if ( PtInRect(&rc, pt) )
        {
            hr = (*i)->QueryInterface( IID_IVideoFeed, (void **) ppFeed );
            break;
        }
    }
    m_critFeedList.Unlock();

    return hr;
}

void CConfRoomMembersWnd::ClearFeed( IVideoWindow *pVideo )
{
    if ( !IsWindow(m_hWnd) ) return;

    // Make sure we have a valid conference room pointer
    if ( m_pConfRoomWnd && m_pConfRoomWnd->m_pConfRoom && !m_pConfRoomWnd->m_pConfRoom->IsExiting() )
    {
        IVideoFeed *pFeed;
        if ( SUCCEEDED(FindVideoFeed(pVideo, &pFeed)) )
        {
            RECT rc; 
            pFeed->get_rc( &rc );

            // Make a copy of the talker window
            HDC hDC = GetDC();
            if ( hDC )
            {
                // Erase border around feed
                InflateRect( &rc, SEL_DX, SEL_DY );
                rc.right++;
                HBRUSH hbr = (HBRUSH) GetClassLongPtr( m_hWnd, GCLP_HBRBACKGROUND );
                Erase3dBox( hDC, rc, hbr );

                //
                // We'll release here hDC resource, we don't need it anymore
                //

                ReleaseDC( hDC );
            }

            // Drop video feed back onto the members window
            HWND hWndTemp;
            if ( SUCCEEDED(pVideo->get_Owner((OAHWND FAR*) &hWndTemp)) )
            {
                pVideo->put_Visible( OAFALSE );
                pVideo->put_Owner( (ULONG_PTR) m_hWnd );
                pVideo->put_MessageDrain( (ULONG_PTR) GetParent() );
                pVideo->SetWindowPosition( rc.left, rc.top, RECTWIDTH(&rc), RECTHEIGHT(&rc) );
                pVideo->put_Visible( OATRUE );
            }

            pFeed->Release();
        }
    }
}

void CConfRoomMembersWnd::UpdateTalkerFeed( bool bUpdateAll, bool bForceSelect )
{
    // Make sure we have a valid conference room pointer
    if ( m_pConfRoomWnd && m_pConfRoomWnd->m_pConfRoom &&
         (m_pConfRoomWnd->m_wndTalker.m_dlgTalker.m_callState == CS_CONNECTED) )
    {
        // If the talker video is invalid, or not showing video, select another
        IVideoWindow *pVideo = NULL;
        m_pConfRoomWnd->m_pConfRoom->get_TalkerVideo( (IDispatch **) &pVideo );

        IAVTapiCall *pAVCall = NULL;
        m_pConfRoomWnd->m_pConfRoom->get_IAVTapiCall( &pAVCall );

        // Is the user requesting that we select something as the talker?
        if ( pAVCall && bForceSelect && (!pVideo || (IsVideoWindowStreaming(pVideo) == S_FALSE)) )
        {
            RELEASE( pVideo );

            // Find some video that's actually streaming
            m_pConfRoomWnd->m_pConfRoom->GetFirstVideoWindowThatsStreaming((IDispatch **) &pVideo);

            // Try for preview?
            if ( !pVideo )
            {
                CComPtr<IAVTapi> pAVTapi;
                if ( SUCCEEDED(_Module.get_AVTapi(&pAVTapi)) )
                    pAVCall->get_IVideoWindowPreview( (IDispatch **) &pVideo );
            }

            // Select the new talker
            if ( pVideo )
                m_pConfRoomWnd->m_pConfRoom->set_TalkerVideo( pVideo, false, true );
        }

        RELEASE( pAVCall );

        // Get the video feed associated with the talker
        IVideoFeed *pFeed = NULL;
        if ( pVideo )
        {
            // Get the CVideoFeed object that's associated with the IVideoWindow
            FindVideoFeed( pVideo, &pFeed );
            pVideo->Release();
        }

        // Do we have a valid feed?
        if ( pFeed )
        {
            HWND hWndTalker = FindWindowEx( m_pConfRoomWnd->m_wndTalker.m_hWnd, NULL, _T("VideoRenderer"), NULL );
            if ( hWndTalker )
            {
                // Make a copy of the talker window
                HDC hDC = GetDC();
                if ( hDC )
                {
                    if ( bUpdateAll )
                        pFeed->Paint( (ULONG_PTR) hDC, hWndTalker );

                    // Copy name off of dialog -- this way we don't risk deadlock with TAPI
                    BSTR bstrName = NULL;
                    SysReAllocString( &bstrName, m_pConfRoomWnd->m_wndTalker.m_dlgTalker.m_bstrCallerID );
                    if ( !bstrName )
                    {
                        USES_CONVERSION;
                        TCHAR szText[255];
                        LoadString( _Module.GetResourceInstance(), IDS_NO_PARTICIPANT, szText, ARRAYSIZE(szText) );
                        bstrName = SysAllocString( T2COLE(szText) );
                    }
                    
                    if ( bstrName )
                    {
                        PaintFeedName( hDC, bstrName, pFeed );
                        SysFreeString( bstrName );
                    }
                }
                ReleaseDC( hDC );
            }
            pFeed->Release();
        }
    }
}

void CConfRoomMembersWnd::PaintFeed( HDC hDC, IVideoFeed *pFeed )
{
    // These items must be defined to paint the feed
    if ( !m_pConfRoomWnd || !m_pConfRoomWnd->m_pConfRoom ||
         !m_pConfRoomWnd->m_hBmpFeed_Large || !m_pConfRoomWnd->m_hBmpFeed_Small )
    {
        return;
    }

    bool bFreeDC = false;
    if ( !hDC )
    {
        hDC = GetDC();
        bFreeDC = true;
    }

    // Draw the feed bitmap
    if ( hDC )
    {
        // Show stock video feed window
        RECT rc;
        pFeed->get_rc( &rc );

        Draw( hDC, (RECTWIDTH(&rc) == VID_SX) ? m_pConfRoomWnd->m_hBmpFeed_Small : m_pConfRoomWnd->m_hBmpFeed_Large,
              rc.left, rc.top,
              RECTWIDTH(&rc), RECTHEIGHT(&rc) );

        // Clean up
        if ( bFreeDC )
            ReleaseDC( hDC );
    }
}

void CConfRoomMembersWnd::PaintFeedName( HDC hDC, BSTR bstrName, IVideoFeed *pFeed )
{
    _ASSERT( hDC && bstrName && pFeed );
    _ASSERT( m_pConfRoomWnd && m_pConfRoomWnd->m_pConfRoom );

    USES_CONVERSION;
    VARIANT_BOOL bShowNames;
    m_pConfRoomWnd->m_pConfRoom->get_bShowNames( &bShowNames );

    if ( bShowNames )
    {
        // Don't paint feeds that aren't presently visible
        IVideoWindow *pVideo;
        if ( SUCCEEDED(pFeed->get_IVideoWindow((IUnknown **) &pVideo)) )
        {
            long lVisible = 0;
            pVideo->get_Visible( &lVisible );
            pVideo->Release();
            if ( !lVisible )
                return;
        }

        // Select same font as is TreeView if exists
        HFONT hFontOld = NULL;
        HWND hWnd = m_pConfRoomWnd->m_wndTalker.m_dlgTalker.GetDlgItem( IDC_LBL_CALLERID );
        if ( hWnd )
            hFontOld = (HFONT) SelectObject(hDC, (HFONT) ::SendMessage(hWnd, WM_GETFONT, 0, 0));

        // Get height of font so we can determine our painting rect
        TEXTMETRIC tm;
        GetTextMetrics( hDC, &tm );

        // Rectangle for writing text
        short nNumLines = 1;
        m_pConfRoomWnd->m_pConfRoom->get_nShowNamesNumLines( &nNumLines );
        RECT rc;
        pFeed->get_rc( &rc );
        rc.top = rc.bottom + (VID_DY / 2);
        rc.bottom = rc.top + (tm.tmHeight * nNumLines) + (VID_DY / 2);

        // Erase rectangle for painting
        HBRUSH hbrOld = (HBRUSH) SelectObject( hDC, GetSysColorBrush(COLOR_BTNFACE) );
        PatBlt( hDC, rc.left, rc.top, RECTWIDTH(&rc), RECTHEIGHT(&rc), PATCOPY );
        SelectObject( hDC, hbrOld );

        // Use same background color
        COLORREF crOld = SetBkColor( hDC, GetSysColor(COLOR_BTNFACE) );
        COLORREF crTextOld = SetTextColor( hDC, GetSysColor(COLOR_BTNTEXT) );
        DrawText( hDC, OLE2CT(bstrName), SysStringLen(bstrName), &rc, DT_CENTER | DT_WORDBREAK | DT_EDITCONTROL | DT_NOPREFIX );
        SetTextColor( hDC, crTextOld );
        SetBkColor( hDC, crOld );

        if ( hFontOld ) SelectObject( hDC, hFontOld );
    }
}

void CConfRoomMembersWnd::PaintFeedName( HDC hDC, IVideoFeed *pFeed )
{
    _ASSERT( hDC && pFeed );

    BSTR bstrName = NULL;
    if ( SUCCEEDED(pFeed->get_bstrName(&bstrName)) && bstrName )
    {
        PaintFeedName( hDC, bstrName, pFeed );
    }
    SysFreeString( bstrName );
}

long CConfRoomMembersWnd::GetFontHeight() 
{
    return m_nFontHeight;
}


//////////////////////////////////////////////////////////////////
// Message Handlers
//
LRESULT CConfRoomMembersWnd::OnCreate(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled)
{
    SetClassLongPtr( m_hWnd, GCLP_HBRBACKGROUND, GetClassLongPtr(GetParent(), GCLP_HBRBACKGROUND) );

    // Store the font height to be used later
    if ( !m_nFontHeight )
    {
        TEXTMETRIC tm;
        tm.tmHeight = 0;

        HDC hDC = GetDC();
        if ( hDC )
        {
            HFONT hFontOld = (HFONT) SelectObject( hDC, GetFont() );
            GetTextMetrics( hDC, &tm );

            // Clean up
            SelectObject( hDC, hFontOld );
            ReleaseDC( hDC );
        }

        m_nFontHeight = tm.tmHeight;
    }

    return 0;
}


LRESULT CConfRoomMembersWnd::OnDestroy(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled)
{
    if ( m_nTimerID )    KillTimer( m_nTimerID );
    return 0;
}



LRESULT CConfRoomMembersWnd::OnPaint(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled)
{
    PAINTSTRUCT ps;
    HDC hDC = BeginPaint( &ps );
    if ( !hDC ) return 0;

    IVideoWindow *pTalkerVideo = NULL;
    if ( m_pConfRoomWnd && m_pConfRoomWnd->m_pConfRoom )
        m_pConfRoomWnd->m_pConfRoom->get_TalkerVideo( (IDispatch **) &pTalkerVideo );

    m_critFeedList.Lock();
    // Draw stock video feed windows
    VIDEOFEEDLIST::iterator i, iEnd = m_lstFeeds.end();
    for ( i = m_lstFeeds.begin(); i != iEnd; i++ )
    {
        // Paint picture of a TV
        IVideoWindow *pVideo = NULL;
        (*i)->get_IVideoWindow( (IUnknown **) &pVideo );

        // Is the  preview not streaming video?
        bool bPreviewNotStreaming = false;
        VARIANT_BOOL bPreview;
        (*i)->get_bPreview( &bPreview );
        if ( bPreview )
        {
            IAVTapiCall *pAVCall;
            if ( SUCCEEDED(m_pConfRoomWnd->m_pConfRoom->get_IAVTapiCall(&pAVCall)) )
            {
                if ( pAVCall->IsPreviewStreaming() == S_FALSE )
                    bPreviewNotStreaming = true;

                pAVCall->Release();
            }
        }

        if ( !pVideo || (bPreview && bPreviewNotStreaming) )
            PaintFeed( hDC, *i );

        // Draw name
        if ( !pTalkerVideo || (pVideo != pTalkerVideo) )
            PaintFeedName( hDC, *i );

        RELEASE(pVideo);
    }
    EndPaint( &ps );
    m_critFeedList.Unlock();

    // Repaint talker window
    UpdateTalkerFeed( true, false );
    RELEASE( pTalkerVideo );

    bHandled = true;
    return 0;
}

LRESULT CConfRoomMembersWnd::OnContextMenu(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled)
{
    bHandled = true;
    return ::SendMessage( GetParent(), nMsg, wParam, lParam );
}

LRESULT CConfRoomMembersWnd::OnTimer(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled)
{
    bHandled = true;

    UpdateTalkerFeed( true, false );
    return 0;
}

LRESULT CConfRoomMembersWnd::OnParentNotify(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled)
{
    // validate back pointer objects
    if ( !m_pConfRoomWnd || !m_pConfRoomWnd->m_pConfRoom )  return 0;

    if ( LOWORD(wParam) == WM_LBUTTONDOWN )
    {
        bHandled = true;

        POINT pt;
        GetCursorPos( &pt );
        
        IVideoFeed *pFeed;
        if ( SUCCEEDED(HitTest(pt, &pFeed)) )
        {
            IVideoWindow *pVideo;
            if ( SUCCEEDED(pFeed->get_IVideoWindow((IUnknown **) &pVideo)) )
            {
                m_pConfRoomWnd->m_pConfRoom->set_TalkerVideo( pVideo, true, true );
                pVideo->Release();
            }
            pFeed->Release();
        }
    }

    return 0;
}

LRESULT CConfRoomMembersWnd::OnSize(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled)
{
    BOOL bHandledLayout;
    return OnLayout( WM_LAYOUT, -1, -1, bHandledLayout );
}

LRESULT CConfRoomMembersWnd::OnLayout(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled)
{
    DoLayout( wParam, lParam );
    return 0;
}

void CConfRoomMembersWnd::DoLayout( WPARAM wParam, int nScrollPos )
{
    if ( !m_pConfRoomWnd || !m_pConfRoomWnd->m_pConfRoom ) return;

    VARIANT_BOOL bShowNames;
    short nNumLines;
    SIZE sz;
    m_pConfRoomWnd->m_pConfRoom->get_bShowNames( &bShowNames );
    m_pConfRoomWnd->m_pConfRoom->get_nShowNamesNumLines( &nNumLines );
    m_pConfRoomWnd->m_pConfRoom->get_szMembers( &sz );

    // Retrieve font metrics if we're showing names
    long nHeight;
    if ( bShowNames ) nHeight = GetFontHeight();

    // Get size of client area to paint in
    bool bAdvance = true;
    RECT rcClient;
    GetClientRect( &rcClient );
    POINT pt = { VID_DX, VID_DY };
    RECT rc = { pt.x, pt.y, pt.x + sz.cx, pt.y + sz.cy };

    // Do all the messy calculations for laying out the video widows
    int nFeedHeight = pt.y + sz.cy + ((bShowNames) ? nHeight : 0);
    int nNumFeedsHorz = (RECTWIDTH(&rcClient) / (pt.x + sz.cx));
    if ( nNumFeedsHorz == 0 ) nNumFeedsHorz = 1;        // must have at least one feed
    int nMaxFeeds =  nNumFeedsHorz * (RECTHEIGHT(&rcClient) / nFeedHeight);
    int nNumFeeds = GetStreamingCount();

    //////////////////////////////////////////////////////////////
    // Scroll bar setup
    SCROLLINFO scrollInfo = { 0 };
    scrollInfo.cbSize = sizeof(SCROLLINFO);
    scrollInfo.fMask = SIF_PAGE | SIF_RANGE | SIF_POS;
    GetScrollInfo( m_hWnd, SB_VERT, &scrollInfo );

    // Process scroll requests
    bool bBoundaryCheck = true;
    switch ( wParam )
    {
        case SB_LINEUP:        nScrollPos = scrollInfo.nPos - nFeedHeight;            break;
        case SB_PAGEUP:        nScrollPos = scrollInfo.nPos - scrollInfo.nPage;    break;
        case SB_LINEDOWN:    nScrollPos = scrollInfo.nPos + nFeedHeight;            break;
        case SB_PAGEDOWN:    nScrollPos = scrollInfo.nPos + scrollInfo.nPage;    break;

        default:
            bBoundaryCheck = false;
            break;
    }

    // Make sure our scroll bar is within range
    if ( bBoundaryCheck )
    {
        if ( nScrollPos < 0 ) nScrollPos = 0;

        GetClientRect( &rcClient );
        if ( nScrollPos > (scrollInfo.nMax - (RECTHEIGHT(&rcClient) - 1)) )
            nScrollPos = scrollInfo.nMax - (RECTHEIGHT(&rcClient) - 1);    
    }

    // -1 indicates that scroll position should not be set
    if ( nScrollPos == -1 )
        nScrollPos = scrollInfo.nPos;

    scrollInfo.nPage = RECTHEIGHT(&rcClient);
    scrollInfo.nPos = nScrollPos;

    if ( nNumFeeds > 0 )
    {
        scrollInfo.nMax = (nNumFeeds / nNumFeedsHorz) * nFeedHeight;
        if ( (nNumFeeds % nNumFeedsHorz) != 0 ) scrollInfo.nMax += nFeedHeight;
    }

    SetScrollInfo( m_hWnd, SB_VERT, &scrollInfo, true );

    // Ignore scroll position if we can fit everything onto the display
    if ( nNumFeeds <= nMaxFeeds )
        nScrollPos = 0;

    // Account for scrolling when painting
    pt.y -= nScrollPos;

    ////////////////////////////////////////////////////////////////////
    // Start placing the video feed windows
    m_critFeedList.Lock();
    VIDEOFEEDLIST::iterator i = m_lstFeeds.begin(), iEnd = m_lstFeeds.end();
    while ( i != iEnd )
    {
        // Position the video feed
        if ( bAdvance )
        {
            AdvanceRect( rc, rcClient, pt, sz, nNumLines, bShowNames, nHeight );        
            bAdvance = false;
        }

        // Store coordinates for video feed
        (*i)->put_rc( rc );

        // Are we showing preview?  Show it first
        IVideoWindow *pVideo;
        VARIANT_BOOL bPreview;
        (*i)->get_bPreview(&bPreview);
        if ( bPreview )
        {
            // Size the preview window
            CComPtr<IAVTapi> pAVTapi;
            if ( SUCCEEDED(_Module.get_AVTapi(&pAVTapi)) )
            {
                if ( SUCCEEDED((*i)->get_IVideoWindow((IUnknown **) &pVideo)) )
                {
                    // show preview in list of conference memebers
                    if ( SUCCEEDED(SizeVideoWindow(pVideo, m_hWnd, rc)) )
                    {
                        bAdvance = true;

                        // Must set as different background palette for low color systems
                        HDC hDC = GetDC();
                        if ( hDC )
                        {
                            int nNumBits = GetDeviceCaps( hDC, BITSPIXEL );
                            pVideo->put_BackgroundPalette( (nNumBits > 8) ? OAFALSE : OATRUE );

                            ReleaseDC( hDC );
                        }
                    }

                    pVideo->Release();
                }
            }

            // Failed to position the video feed for one reason or another
            if ( !bAdvance )
            {
                RECT rcTemp = { -1, -1, -1, -1 };
                (*i)->put_rc( rcTemp );
            }
        }
        else
        {
            // Only show the video window if it has a participant associated with it
            if ( SUCCEEDED((*i)->get_IVideoWindow((IUnknown **) &pVideo)) )
            {
                // Size the member video window
                if ( ((*i)->IsVideoStreaming(true) == S_OK) &&
                     SUCCEEDED(SizeVideoWindow(pVideo, m_hWnd, rc)) )
                {
                    bAdvance = true;
                }
                else
                {
                    // Hide this video window!
                    pVideo->put_Visible( OAFALSE );
                    RECT rcTemp = { -1, -1, -1, -1 };
                     (*i)->put_rc( rcTemp );
                }
                pVideo->Release();
            }
            else
            {
                bAdvance = true;
            }
        }

        i++;
    }
    m_critFeedList.Unlock();
}

void CConfRoomMembersWnd::UpdateNames( ITParticipant *pParticipant )
{
    VIDEOFEEDLIST lstTemp;
    VIDEOFEEDLIST::iterator i, iEnd;

    HDC hDC = GetDC();
    if ( hDC )
    {
        // Copy the name list prior to update
        m_critFeedList.Lock();
        iEnd = m_lstFeeds.end();
        for ( i = m_lstFeeds.begin(); i != iEnd; i++ )
        {
            (*i)->AddRef();
            lstTemp.push_back( *i );
        }
        m_critFeedList.Unlock();

        // Draw stock video feed windows
        iEnd = lstTemp.end();
        for ( i = lstTemp.begin(); i != iEnd; i++ )
        {
            // Does this participant need to update their name?
            ITParticipant *pIndParticipant = NULL;
            if ( SUCCEEDED((*i)->get_ITParticipant(&pIndParticipant)) )
            {
                if ( !pParticipant || (pParticipant == pIndParticipant) )
                    (*i)->UpdateName();

                pIndParticipant->Release();
            }

            // Paint it.
            PaintFeedName( hDC, *i );
        }

        UpdateTalkerFeed( false, false );
        ReleaseDC( hDC );
    }

    RELEASE_LIST( lstTemp );
}

void CConfRoomMembersWnd::HideVideoFeeds()
{
    ATLTRACE(_T(".enter.CConfRoomMembersWnd::HideVideoFeeds().\n"));
    m_critFeedList.Lock();
    VIDEOFEEDLIST::iterator i, iEnd = m_lstFeeds.end();
    for ( i = m_lstFeeds.begin(); i != iEnd; i++ )
    {
        IVideoWindow *pVideo;
        if ( SUCCEEDED((*i)->get_IVideoWindow((IUnknown **) &pVideo)) )
        {
            pVideo->put_Visible( OAFALSE );
            pVideo->SetWindowPosition( -10, -10, 1, 1 );
            pVideo->Release();
        }
    }
    m_critFeedList.Unlock();
}

HRESULT CConfRoomMembersWnd::GetFirstVideoWindowThatsStreaming( IVideoWindow **ppVideo, bool bIncludePreview /*= true*/ )
{
    HRESULT hr = E_FAIL;

    int nTries = (bIncludePreview) ? 2 : 1;

    m_critFeedList.Lock();
    VIDEOFEEDLIST::iterator i, iEnd = m_lstFeeds.end();
    for ( int j = 0; FAILED(hr) && (j < nTries); j ++ )
    {
        for ( i = m_lstFeeds.begin(); i != iEnd; i++ )
        {
            if ( (*i)->IsVideoStreaming((VARIANT_BOOL) (j != 0))  == S_OK )
            {
                hr = (*i)->get_IVideoWindow( (IUnknown **) ppVideo );
                break;
            }
        }
    }
    m_critFeedList.Unlock();

    return hr;
}

HRESULT CConfRoomMembersWnd::GetFirstVideoFeedThatsStreaming( IVideoFeed **ppFeed, bool bIncludePreview /*= true*/ )
{
    HRESULT hr = E_FAIL;

    int nTries = (bIncludePreview) ? 2 : 1;

    m_critFeedList.Lock();
    VIDEOFEEDLIST::iterator i, iEnd = m_lstFeeds.end();
    for ( int j = 0; FAILED(hr) && (j < nTries); j ++ )
    {
        for ( i = m_lstFeeds.begin(); i != iEnd; i++ )
        {
            if ( (*i)->IsVideoStreaming((VARIANT_BOOL) (j != 0))  == S_OK )
            {
                hr = (*i)->QueryInterface( IID_IVideoFeed, (void **) ppFeed );
                break;
            }
        }
    }
    m_critFeedList.Unlock();

    return hr;
}

HRESULT CConfRoomMembersWnd::GetAndMoveVideoFeedThatStreamingForParticipantReMap( IVideoFeed **ppFeed )
{
    HRESULT hr = E_FAIL;

    m_critFeedList.Lock();
    VIDEOFEEDLIST::iterator i, iEnd = m_lstFeeds.end();
    for ( i = m_lstFeeds.begin(); i != iEnd; i++ )
    {
        if ( (*i)->IsVideoStreaming(FALSE)  == S_OK )
        {
            hr = (*i)->QueryInterface( IID_IVideoFeed, (void **) ppFeed );
            if ( SUCCEEDED(hr) )
            {
                // Move the feed to the tail of the list
                IVideoFeed *pFeed;
                if ( SUCCEEDED((*i)->QueryInterface(IID_IVideoFeed, (void **) &pFeed)) )
                {
                    (*i)->Release();
                    m_lstFeeds.erase( i );
                    m_lstFeeds.push_back( pFeed );
                }
            }
            break;
        }
    }
    m_critFeedList.Unlock();

    return hr;
}



HRESULT CConfRoomMembersWnd::IsVideoWindowStreaming( IVideoWindow *pVideo )
{
    HRESULT hr = E_FAIL;
    bool bBreak = false;
    
    m_critFeedList.Lock();
    VIDEOFEEDLIST::iterator i, iEnd = m_lstFeeds.end();
    for ( i = m_lstFeeds.begin(); i != iEnd; i++ )
    {
        IVideoWindow *pFeedsVideo;
        if ( SUCCEEDED((*i)->get_IVideoWindow( (IUnknown **) &pFeedsVideo)) )
        {
            if ( pFeedsVideo == pVideo )
            {
                hr = (*i)->IsVideoStreaming( true );
                bBreak = true;
            }
            pFeedsVideo->Release();
        }
        if ( bBreak ) break;
    }
    m_critFeedList.Unlock();

    return hr;
}

HRESULT CConfRoomMembersWnd::GetNameFromVideo( IVideoWindow *pVideo, BSTR *pbstrName, BSTR *pbstrInfo, bool bAllowNull, bool bPreview )
{
    HRESULT hr;
    IVideoFeed *pFeed;
    if ( SUCCEEDED(hr = FindVideoFeed(pVideo, &pFeed)) )
    {
        hr = pFeed->GetNameFromVideo( pVideo, pbstrName, pbstrInfo, bAllowNull, bPreview );
        pFeed->Release();
    }

    return hr;
}

LRESULT CConfRoomMembersWnd::OnVScroll(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled)
{
    int nScrollCode = (int) LOWORD(wParam); // scroll bar value 
    int nPos = (short int) HIWORD(wParam);  // scroll box position 

    switch ( nScrollCode )
    {
        case SB_LINEUP:
        case SB_LINEDOWN:
        case SB_PAGEUP:
        case SB_PAGEDOWN:
        case SB_THUMBTRACK:
        case SB_THUMBPOSITION:
            PostMessage( WM_LAYOUT, nScrollCode, nPos );
            Invalidate();
            break;
    }

    return 0;
}


int CConfRoomMembersWnd::GetStreamingCount()
{
    int nCount = 0;
    long nLeft, nTop, nWidth, nHeight;

    m_critFeedList.Lock();
    VIDEOFEEDLIST::iterator i = m_lstFeeds.begin(), iEnd = m_lstFeeds.end();
    while ( i != iEnd )
    {
        IVideoWindow *pVideo;

        VARIANT_BOOL bPreview;
        (*i)->get_bPreview(&bPreview);
        if ( bPreview )
        {
            if ( SUCCEEDED((*i)->get_IVideoWindow((IUnknown **) &pVideo)) )
            {
                if ( SUCCEEDED(pVideo->GetWindowPosition(&nLeft, &nTop, &nWidth, &nHeight)) )
                    nCount++;

                pVideo->Release();
            }
        }
        else
        {
            // Only show the video window if it has a participant associated with it
            if ( SUCCEEDED((*i)->get_IVideoWindow((IUnknown **) &pVideo)) )
            {
                // Size the member video window
                if ( ((*i)->IsVideoStreaming(true) == S_OK) && SUCCEEDED(pVideo->GetWindowPosition(&nLeft, &nTop, &nWidth, &nHeight)) )
                    nCount++;

                pVideo->Release();
            }
            else
            {
                nCount++;
            }
        }
        i++;
    }
    m_critFeedList.Unlock();

    return nCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\confroom.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// ConfRoom.h : Declaration of the CConfRoom

#ifndef __CONFROOM_H_
#define __CONFROOM_H_

#include "resource.h"       // main symbols

// FWD define
class CConfRoom;


#include "ConfRoomWnd.h"
#include "ConfDetails.h"

#define AV_CS_DIALING			1000
#define AV_CS_ABORT				1001
#define AV_CS_DISCONNECTING		1002

/////////////////////////////////////////////////////////////////////////////
// CConfRoom
class ATL_NO_VTABLE CConfRoom : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CConfRoom, &CLSID_ConfRoom>,
	public IConfRoom
{
// Construction
public:
	CConfRoom();
	void FinalRelease();
	void ReleaseAVCall( IAVTapiCall *pAVCall, bool bDisconnect );

// Members
public:
	CAVTapiCall			*m_pAVCall;			// Call in conference room
	IConfRoomTreeView	*m_pTreeView;		// Tree View
	IVideoWindow		*m_pVideoPreview;	// Video Preview Window
	CConfRoomWnd		m_wndRoom;			// Details View
	CConfDetails		m_confDetails;

	SIZE				m_szTalker;			// Size of respective video windows
	SIZE				m_szMembers;
	VARIANT_BOOL		m_bPreviewStreaming;
	short				m_nScale;

protected:
	short						m_nNumTerms;			// Number of video terminals on call
	short						m_nMaxTerms;
	long						m_lNumParticipants;
	IVideoWindow				*m_pITalkerVideo;
	ITParticipant				*m_pITTalkerParticipant;
	CComAutoCriticalSection		m_critCreateTerminals;
	CAtomicList					m_atomTalkerVideo;
	CAtomicList					m_atomTalkerParticipant;

	CComAutoCriticalSection		m_critAVCall;

	VARIANT_BOOL				m_bShowNames;			// Show name under video feed window
	short						m_nShowNamesNumLines;
	VARIANT_BOOL				m_bConfirmDisconnect;
	bool						m_bExiting;

// Attributes
public:
	void						set_PreviewVideo( IVideoWindow *pVideo );
	bool						IsPreviewVideo( IVideoWindow *pVideo );
	bool						IsTalkerParticipant( ITParticipant *pParticipant );
	bool						IsTalkerStreaming();
	bool						IsExiting();

	HRESULT						set_TalkerVideo( IVideoWindow *pVideo, bool bUpdate, bool bUpdateTree );

	HRESULT						get_szMembers( SIZE *pSize );

private:
	HRESULT						get_ITTalkerParticipant( ITParticipant **ppVal );
	HRESULT						set_ITTalkerParticipant( ITParticipant *pVal );

// Operations
public:
	void	InternalDisconnect();
	bool	MapStreamingParticipant( IParticipant *pIParticipant, IVideoFeed **ppFeed );
protected:
	void	UpdateNumParticipants( IAVTapiCall *pAVCall );
	void	OnAbort();
	void	OnConnected();
	void	OnDisconnected();
	void	UpdateData( bool bSaveAndValidate );

// Implementation
public:
DECLARE_NOT_AGGREGATABLE(CConfRoom)

BEGIN_COM_MAP(CConfRoom)
	COM_INTERFACE_ENTRY(IConfRoom)
END_COM_MAP()

// IConfRoom
public:
	STDMETHOD(get_TalkerScale)(/*[out, retval]*/ short *pVal);
	STDMETHOD(put_TalkerScale)(/*[in]*/ short newVal);
	STDMETHOD(get_szTalker)(/*[out, retval]*/ SIZE *pVal);
	STDMETHOD(put_CallState)(/*[in]*/ CALL_STATE newVal);
	STDMETHOD(Cancel)();
	STDMETHOD(IsConfRoomConnected)();
	STDMETHOD(GetFirstVideoWindowThatsStreaming)(IDispatch **ppVideo);
	STDMETHOD(FindVideoFeedFromSubStream)(ITSubStream *pSubStream, IVideoFeed **ppFeed);
	STDMETHOD(SetQOSOnParticipants)();
	STDMETHOD(FindVideoFeedFromParticipant)(ITParticipant *pParticipant, IVideoFeed **ppFeed);
	STDMETHOD(get_bPreviewStreaming)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(get_TalkerVideo)(/*[out, retval]*/ IDispatch * *pVal);
	STDMETHOD(get_hWndMembers)(/*[out, retval]*/ HWND *pVal);
	STDMETHOD(get_hWndTalker)(/*[out, retval]*/ HWND *pVal);
	STDMETHOD(SelectTalkerVideo)(IDispatch *pDisp, VARIANT_BOOL bUpdate);
	STDMETHOD(Layout)(VARIANT_BOOL bTalker, VARIANT_BOOL bMembers);
	STDMETHOD(get_bstrConfDetails)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_ConfDetails)(/*[out, retval]*/ long * *pVal);
	STDMETHOD(put_ConfDetails)(/*[in]*/ long * newVal);
	STDMETHOD(get_lNumParticipants)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_nMaxTerms)(/*[out, retval]*/ short *pVal);
	STDMETHOD(put_nMaxTerms)(/*[in]*/ short newVal);
	STDMETHOD(get_TalkerParticipant)(/*[out, retval]*/ ITParticipant **ppVal);
	STDMETHOD(NotifyParticipantChange)(IAVTapiCall *pAVCall, ITParticipant *pParticipant, AV_PARTICIPANT_EVENT nEvent);
	STDMETHOD(get_bConfirmDisconnect)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_bConfirmDisconnect)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(get_IAVTapiCall)(/*[out, retval]*/ IAVTapiCall * *pVal);
	STDMETHOD(get_nShowNamesNumLines)(/*[out, retval]*/ short *pVal);
	STDMETHOD(put_nShowNamesNumLines)(/*[in]*/ short newVal);
	STDMETHOD(get_bShowNames)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_bShowNames)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(get_hWndConfRoom)(/*[out, retval]*/ HWND *pVal);
	STDMETHOD(get_bstrConfName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(SelectTalker)(ITParticipant *pParticipant, VARIANT_BOOL bUpdateTree);
	STDMETHOD(get_nNumTerms)(/*[out, retval]*/ short *pVal);
	STDMETHOD(get_MemberVideoSize)(/*[out, retval]*/ short *pVal);
	STDMETHOD(put_MemberVideoSize)(/*[in]*/ short newVal);
	STDMETHOD(NotifyStateChange)(IAVTapiCall *pAVCall);
	STDMETHOD(CanDisconnect)();
	STDMETHOD(Disconnect)();
	STDMETHOD(get_TreeView)(/*[out, retval]*/ IConfRoomTreeView * *pVal);
	STDMETHOD(Show)(HWND hWndTree, HWND hWndClient);
	STDMETHOD(UnShow)();
	STDMETHOD(IsConfRoomInUse)();
	STDMETHOD(EnterConfRoom)(IAVTapiCall *pAVCall);
};

#endif //__CONFROOM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\confroom.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// ConfRoom.cpp : Implementation of CConfRoom
#include "stdafx.h"
#include "TapiDialer.h"
#include "AVTapi.h"
#include "ConfRoom.h"
#include "CRTreeView.h"

/////////////////////////////////////////////////////////////////////////////
// CConfRoom

CConfRoom::CConfRoom()
{
    m_pAVCall = NULL;
    m_pTreeView = NULL;
    m_wndRoom.m_pConfRoom = this;
    m_bShowNames = true;
    m_nShowNamesNumLines = 1;
    
    m_nMaxTerms = DEFAULT_VIDEO;
    m_nNumTerms = m_nMaxTerms;
    m_lNumParticipants = 0;

    m_szMembers.cx = VID_SX;
    m_szMembers.cy = VID_SY;

    m_szTalker.cx = VID_X;
    m_szTalker.cy = VID_Y;

    m_bConfirmDisconnect = false;

    m_pVideoPreview = NULL;
    m_pITTalkerParticipant = NULL;
    m_pITalkerVideo = NULL;

    m_bPreviewStreaming = FALSE;
    m_bExiting = false;
    m_nScale = 100;
}

void CConfRoom::FinalRelease()
{
    ATLTRACE(_T(".enter.CConfRoom::FinalRelease().\n") );

    // Clean out the call object
    IAVTapiCall *pAVCall = m_pAVCall;
    m_pAVCall = NULL;
    ReleaseAVCall( pAVCall, true );
    
    RELEASE( m_pTreeView );

    // Is the window still visible?
    if ( m_wndRoom.m_hWnd && IsWindow(m_wndRoom.m_hWnd) )
        m_wndRoom.DestroyWindow();

    CComObjectRootEx<CComMultiThreadModel>::FinalRelease();
    ATLTRACE(_T(".exit.CConfRoom::FinalRelease().\n") );
}

void CConfRoom::ReleaseAVCall( IAVTapiCall *pAVCall, bool bDisconnect )
{
    ATLTRACE(_T(".enter.CConfRoom::ReleaseAVCall().\n"));
    if ( pAVCall )
    {
        ITBasicCallControl *pControl;
        if ( SUCCEEDED(pAVCall->get_ITBasicCallControl(&pControl)) )
        {
            // Only attempt disconnect if requested
            if ( bDisconnect )
                pControl->Disconnect( DC_NORMAL );

            // Release ref to call and remove from call list
            CAVTapi *pAVTapi;
            if ( SUCCEEDED(_Module.GetAVTapi(&pAVTapi)) )
            {
                pAVTapi->RemoveAVTapiCall( pControl );
                (dynamic_cast<IUnknown *> (pAVTapi))->Release();
            }

            pControl->Release();
        }

        pAVCall->Release();
        pAVCall = NULL;
    }

    // Release the call, and disconnect if active
    set_TalkerVideo( NULL, !IsExiting(), false );
    set_ITTalkerParticipant( NULL );
    ATLTRACE(_T(".exit.CConfRoom::ReleaseAVCall().\n"));
}

STDMETHODIMP CConfRoom::UnShow()
{
    ATLTRACE(_T(".enter.CConfRoom::UnShow().\n") );
    UpdateData( true );
    
    IConfRoomTreeView *pTreeView;
    if ( SUCCEEDED(get_TreeView(&pTreeView)) )
    {
        pTreeView->put_hWnd( NULL );
        pTreeView->put_ConfRoom( NULL );
        pTreeView->Release();
    }

    if ( IsWindow(m_wndRoom.m_hWnd) )
    {
        Lock();
        m_bExiting = true;
        Unlock();
        InternalDisconnect();
    }

    return S_OK;
}

bool CConfRoom::IsExiting()
{
    bool bRet;
    Lock();
    bRet = m_bExiting;
    Unlock();
    return bRet;
}

void CConfRoom::UpdateData( bool bSaveAndValidate )
{
    CRegKey regKey;
    TCHAR szReg[255];
    DWORD dwTemp;

    LoadString( _Module.GetResourceInstance(), IDN_REG_CONFROOM_VIEW_KEY, szReg, ARRAYSIZE(szReg) );
    if ( bSaveAndValidate )
    {
        // Save data to registry
        if ( regKey.Create(HKEY_CURRENT_USER, szReg) == ERROR_SUCCESS )
        {
            // Full size video
            short nSize;
            get_MemberVideoSize( &nSize );
            LoadString( _Module.GetResourceInstance(), IDN_REG_CONFROOM_VIDEOSIZE, szReg, ARRAYSIZE(szReg) );
            regKey.SetValue( (DWORD) nSize, szReg );

            // $CRIT - enter
            Lock();

            // Show Names
            LoadString( _Module.GetResourceInstance(), IDN_REG_CONFROOM_SHOWNAMES, szReg, ARRAYSIZE(szReg) );
            dwTemp = m_bShowNames;
            regKey.SetValue( dwTemp, szReg );

            // Number of lines in name text
            LoadString( _Module.GetResourceInstance(), IDN_REG_CONFROOM_SHOWNAMES_NUMLINES, szReg, ARRAYSIZE(szReg) );
            dwTemp = m_nShowNamesNumLines;
            regKey.SetValue( dwTemp, szReg );

            // Size of talker window
            LoadString( _Module.GetResourceInstance(), IDN_REG_CONFROOM_TALKER_SCALE, szReg, ARRAYSIZE(szReg) );
            dwTemp = m_nScale;
            regKey.SetValue( dwTemp, szReg );

            Unlock();
            // $CRIT - exit
        }
    }
    else if ( regKey.Open(HKEY_CURRENT_USER, szReg, KEY_READ) == ERROR_SUCCESS )
    {
        // Load data from registry

        // Full size video?
        dwTemp = 50;        // default is 50 percent
        LoadString( _Module.GetResourceInstance(), IDN_REG_CONFROOM_VIDEOSIZE, szReg, ARRAYSIZE(szReg) );
        regKey.QueryValue( dwTemp, szReg );
        put_MemberVideoSize( (short) max(10, min(dwTemp, 100)) );        // arbitrary limits

        // $CRIT - enter
        Lock();

        // Show names
        LoadString( _Module.GetResourceInstance(), IDN_REG_CONFROOM_SHOWNAMES, szReg, ARRAYSIZE(szReg) );
        dwTemp = 1;
        regKey.QueryValue( dwTemp, szReg );
        m_bShowNames = (bool) (dwTemp != 0 );

        // Number of lines in name text
        LoadString( _Module.GetResourceInstance(), IDN_REG_CONFROOM_SHOWNAMES_NUMLINES, szReg, ARRAYSIZE(szReg) );
        regKey.QueryValue( dwTemp, szReg );
        m_nShowNamesNumLines = (short) max(1, min(dwTemp, 3));

        // Size of talker window
        LoadString( _Module.GetResourceInstance(), IDN_REG_CONFROOM_TALKER_SCALE, szReg, ARRAYSIZE(szReg) );
        regKey.QueryValue( dwTemp, szReg );
        m_nScale = (short) max(100, min(dwTemp, 200));
        m_szTalker.cx = VID_X * m_nScale / 100;
        m_szTalker.cy = VID_Y * m_nScale / 100;

        Unlock();
        // $CRIT - exit
    }

    regKey.Close();

}

STDMETHODIMP CConfRoom::get_TalkerVideo(IDispatch **ppVideo)
{
    HRESULT hr = E_FAIL;

    m_atomTalkerVideo.Lock( CAtomicList::LIST_READ );
    if ( m_pITalkerVideo )
        hr = m_pITalkerVideo->QueryInterface( IID_IVideoWindow, (void **) ppVideo );
    m_atomTalkerVideo.Unlock( CAtomicList::LIST_READ );

    return hr;
}

HRESULT CConfRoom::get_ITTalkerParticipant(ITParticipant **ppVal)
{
    HRESULT hr = E_FAIL;

    m_atomTalkerParticipant.Lock( CAtomicList::LIST_READ );
    if ( m_pITTalkerParticipant )
        hr = m_pITTalkerParticipant->QueryInterface( IID_ITParticipant, (void **) ppVal );
    m_atomTalkerParticipant.Unlock( CAtomicList::LIST_READ );

    return hr;
}

HRESULT CConfRoom::set_ITTalkerParticipant(ITParticipant *pVal)
{
    HRESULT hr = E_FAIL;

    m_atomTalkerParticipant.Lock( CAtomicList::LIST_WRITE );
    RELEASE( m_pITTalkerParticipant );
    if ( pVal )
        hr = pVal->QueryInterface( IID_ITParticipant, (void **) &m_pITTalkerParticipant );
    m_atomTalkerParticipant.Unlock( CAtomicList::LIST_WRITE );

    return hr;
}



HRESULT CConfRoom::set_TalkerVideo( IVideoWindow *pVideo, bool bUpdate, bool bUpdateTree )
{
    if ( pVideo && !m_pAVCall ) return S_OK;

    HRESULT hr = S_OK;
    
    // Set the talker video if it's different from the current one
    m_atomTalkerVideo.Lock( CAtomicList::LIST_WRITE );
    if ( !pVideo || (pVideo != m_pITalkerVideo) )
    {
        // Save old video window
        IVideoWindow *pVideoOld = m_pITalkerVideo;
        m_pITalkerVideo = pVideo;
        if ( m_pITalkerVideo )
            m_pITalkerVideo->AddRef();

        m_atomTalkerVideo.Unlock( CAtomicList::LIST_WRITE );

        // Clean out old talker window
        if ( pVideoOld )
        {
            pVideoOld->put_Visible( OAFALSE );
            m_wndRoom.m_wndMembers.ClearFeed( pVideoOld );
            pVideoOld->Release();
        }

        // Show new talker
        if ( bUpdate )
        {
            // Layout the talker dialog
            m_wndRoom.LayoutRoom( CConfRoomWnd::LAYOUT_TALKER, true );

            // Only update the talker if there is video to show
            if ( pVideo )
                m_wndRoom.m_wndMembers.UpdateTalkerFeed( true, false );
        }
    }
    else
    {
        m_atomTalkerVideo.Unlock( CAtomicList::LIST_WRITE );
    }

    // Select the appropriate talker from the treeview
    if ( bUpdateTree )
    {
        VARIANT_BOOL bPreview = TRUE;
        ITParticipant *pParticipant = NULL;

        IVideoFeed *pFeed;
        if ( SUCCEEDED(m_wndRoom.m_wndMembers.FindVideoFeed(pVideo, &pFeed)) )
        {
            if ( FAILED(pFeed->get_bPreview(&bPreview)) || !bPreview )
                pFeed->get_ITParticipant( &pParticipant );

            pFeed->Release();
        }

        // Select the appropriate participant
        IConfRoomTreeView *pTreeView;
        if ( SUCCEEDED(get_TreeView(&pTreeView)) )
        {
            pTreeView->SelectParticipant( pParticipant, bPreview );
            pTreeView->Release();
        }

        RELEASE( pParticipant );
    }

    return hr;
}

STDMETHODIMP CConfRoom::SelectTalker(ITParticipant *pParticipant, VARIANT_BOOL bUpdateTree )
{
    HRESULT hr = S_OK;
    IVideoFeed *pFeed = NULL;

    set_ITTalkerParticipant( NULL );

    // Select 'Me' from the list if possible (don't select me if the conference room is minimized)
    if ( !pParticipant )
        m_wndRoom.m_wndMembers.FindVideoPreviewFeed( &pFeed );

    // Bail if necessary
    if ( FAILED(hr) ) return hr;

    if ( pFeed || (pParticipant && SUCCEEDED(hr = FindVideoFeedFromParticipant(pParticipant, &pFeed))) )
    {
        IVideoWindow *pVideo;
        if ( SUCCEEDED(hr = pFeed->get_IVideoWindow((IUnknown **) &pVideo)) )
        {
            hr = set_TalkerVideo( pVideo, true, (bool) (bUpdateTree != 0));
            pVideo->Release();
        }
        pFeed->Release();
    }
    else if ( pParticipant )
    {
        // Must re-map to valid stream
        bool bSucceed = false;

        IAVTapiCall *pAVCall;
        if ( SUCCEEDED(get_IAVTapiCall(&pAVCall)) )
        {
            IParticipant *pIParticipant;
            if ( SUCCEEDED(pAVCall->FindParticipant(pParticipant, &pIParticipant)) )
            {
                VARIANT_BOOL bStreamingVideo = false;
                pIParticipant->get_bStreamingVideo( &bStreamingVideo );

                if ( bStreamingVideo )
                {
                    IVideoFeed *pFeed;
                    bSucceed = MapStreamingParticipant( pIParticipant, &pFeed );
                    if ( bSucceed )
                    {
                        IVideoWindow *pVideo;
                        if ( SUCCEEDED(pFeed->get_IVideoWindow((IUnknown **) &pVideo)) )
                        {
                            hr = set_TalkerVideo( pVideo, true, (bool) (bUpdateTree != 0) );
                            pVideo->Release();
                        }
                        pFeed->Release();
                    }
                }

                pIParticipant->Release();
            }
            pAVCall->Release();
        }

        // Participant only, no video
        if ( !bSucceed )
        {
            set_ITTalkerParticipant( pParticipant );
            hr = set_TalkerVideo( NULL, false, (bool) (bUpdateTree != 0) );
        }

        m_wndRoom.m_wndTalker.UpdateNames( pParticipant );
        m_wndRoom.m_wndTalker.Invalidate( FALSE );

        // Make sure to update the member's as well
        if ( bSucceed )
            m_wndRoom.m_wndMembers.UpdateNames( NULL );
    }
    else
    {
        // Select nothing
        hr = set_TalkerVideo( NULL, true, (bool) (bUpdateTree != 0) );
    }

    return hr;
}

STDMETHODIMP CConfRoom::put_CallState(CALL_STATE callState)
{
    bool bUpdateTree = false;

    // Update call state information
    Lock();
    if ( (m_wndRoom.m_wndTalker.m_dlgTalker.m_callState != AV_CS_ABORT) || 
         (callState == CS_DISCONNECTED) || (callState == CS_IDLE) )
    {
        m_wndRoom.m_wndTalker.m_dlgTalker.m_callState = callState;
    }
    Unlock();

    switch ( callState )
    {
        case AV_CS_DIALING:
            Lock();
            // Setup conference name information
            SysFreeString( m_wndRoom.m_wndTalker.m_dlgTalker.m_bstrConfName );
            m_wndRoom.m_wndTalker.m_dlgTalker.m_bstrConfName = NULL;
            get_bstrConfName( &m_wndRoom.m_wndTalker.m_dlgTalker.m_bstrConfName );
            Unlock();
            m_wndRoom.LayoutRoom( CConfRoomWnd::LAYOUT_TALKER, false );
            break;

        /////////////////////////////
        case CS_CONNECTED:
            bUpdateTree = true;
            OnConnected();
            break;

        ///////////////////////////////
        case AV_CS_ABORT:
            bUpdateTree = true;
            OnAbort();
            break;

        ///////////////////////////////
        case CS_DISCONNECTED:
            bUpdateTree = true;
            OnDisconnected();
            break;

        /////////////////////////////
        default:
            m_wndRoom.LayoutRoom( CConfRoomWnd::LAYOUT_TALKER, false );
            break;
    }


    // Store conference server setup
    if ( bUpdateTree )
    {
        IConfRoomTreeView *pTreeView;
        if ( SUCCEEDED(get_TreeView(&pTreeView)) )
        {
            pTreeView->UpdateData( false );
            pTreeView->Release();
        }
    }

    return S_OK;
}

void CConfRoom::OnConnected()
{
    IAVTapiCall *pAVCall;
    if ( SUCCEEDED(get_IAVTapiCall(&pAVCall)) )
    {
        // Preview Streaming?
        IVideoWindow *pVideoPreview = NULL;;
        pAVCall->get_IVideoWindowPreview( (IDispatch **) &pVideoPreview );
        Lock();
        m_bPreviewStreaming = (BOOL) (pVideoPreview != NULL);
        Unlock();

        // Basic status information for conference room
        UpdateNumParticipants( pAVCall );
        m_wndRoom.LayoutRoom( CConfRoomWnd::LAYOUT_CREATE, true );
        
        // Force window to re-paint itself
        m_wndRoom.PostMessage( WM_SIZE );

        // Clean up
        RELEASE(pVideoPreview);
        pAVCall->Release();
    }
}

void CConfRoom::OnAbort()
{
    OnDisconnected();

    Lock();
    m_wndRoom.m_wndTalker.m_dlgTalker.m_callState = CS_DISCONNECTED;
    Unlock();

    m_wndRoom.LayoutRoom( CConfRoomWnd::LAYOUT_CREATE, true );
}

void CConfRoom::OnDisconnected()
{
    IAVTapiCall *pAVCall = NULL;
    get_IAVTapiCall( &pAVCall );

    Lock();
    // Clean out conference name
    SysFreeString( m_wndRoom.m_wndTalker.m_dlgTalker.m_bstrConfName );
    m_wndRoom.m_wndTalker.m_dlgTalker.m_bstrConfName = NULL;

    SysFreeString( m_wndRoom.m_wndTalker.m_dlgTalker.m_bstrCallerID );
    m_wndRoom.m_wndTalker.m_dlgTalker.m_bstrCallerID = NULL;

    SysFreeString( m_wndRoom.m_wndTalker.m_dlgTalker.m_bstrCallerInfo );
    m_wndRoom.m_wndTalker.m_dlgTalker.m_bstrCallerInfo = NULL;

    // Reset number of video terminals
    m_nNumTerms = m_nMaxTerms;
    Unlock();

    m_critAVCall.Lock();
    RELEASE(m_pAVCall);
    m_critAVCall.Unlock();

    if ( !IsExiting() )
        m_wndRoom.LayoutRoom( CConfRoomWnd::LAYOUT_CREATE, true );

    // Log the call after it's released
    if ( pAVCall )
        pAVCall->Log( CL_CALL_CONFERENCE );

    ReleaseAVCall( pAVCall, false );

    // Notify that the conference room is no longer in use
    if ( !IsExiting() )
    {
        CAVTapi *pAVTapi;
        if ( SUCCEEDED(_Module.GetAVTapi(&pAVTapi)) )
            pAVTapi->fire_ActionSelected( CC_ACTIONS_LEAVE_CONFERENCE );
    }
}

void CConfRoom::InternalDisconnect()
{
    IAVTapiCall *pAVCall;
    if ( SUCCEEDED(get_IAVTapiCall(&pAVCall)) )
    {
        if ( IsConfRoomConnected() == S_OK )
        {
            // Hide video feeds, prior to disconnecting
            m_wndRoom.m_wndMembers.HideVideoFeeds();

            if ( IsWindow(m_wndRoom.m_wndTalker.m_dlgTalker.m_hWnd) )
            {
                m_wndRoom.m_wndTalker.m_dlgTalker.m_callState = (CALL_STATE) AV_CS_DISCONNECTING;
                m_wndRoom.m_wndTalker.m_dlgTalker.UpdateData( false );
            }

            pAVCall->PostMessage( 0, CAVTapiCall::TI_DISCONNECT );
        }
        else
        {
            // Disconnect the call
            pAVCall->Disconnect( TRUE );
        }

        // Release the call
        pAVCall->Release();
    }
}

//////////////////////////////////////////////////////////////////////////////////////
// COM interface methods
//


STDMETHODIMP CConfRoom::IsConfRoomInUse()
{
    HRESULT hr = S_FALSE;
    m_critAVCall.Lock();
    if ( m_pAVCall ) hr = S_OK;
    m_critAVCall.Unlock();

    return hr;
}

STDMETHODIMP CConfRoom::IsConfRoomConnected()
{
    HRESULT hr = S_FALSE;

    IAVTapiCall *pAVCall;
    if ( SUCCEEDED(get_IAVTapiCall(&pAVCall)) )
    {
        CALL_STATE nState;
        pAVCall->get_callState(&nState);
        if ( nState == CS_CONNECTED )
            hr = S_OK;

        pAVCall->Release();
    }

    return hr;
}


////////////////////////////////////////////////////////////////////////////////////////
// CConfRoom::EnterConfRoom( pAVCall )
//
// This method is invoked by the AVTapiCall object to request that it be represtented by
// the conference room.
//
STDMETHODIMP CConfRoom::EnterConfRoom(IAVTapiCall * pAVCall )
{
    // Upfront verifications...
    _ASSERT( pAVCall );
    CErrorInfo er ( IDS_ER_CALL_ENTERCONFROOM, 0 );
    if ( !IsWindow(m_wndRoom.m_hWnd) ) er.set_hr( E_PENDING );    // Must have window alread set up via Show()
    else if ( !pAVCall ) er.set_hr( E_POINTER );                // Must have valid pAVCall pointer

    // Is conference room already in use?
    m_critAVCall.Lock();
    if ( m_pAVCall )
    {
        er.set_Details( IDS_ER_CONFERENCE_ROOM_LIMIT_EXCEEDED );
        er.set_hr( E_ACCESSDENIED );
    }
    else
    {
        er.set_Details( IDS_ER_QUERY_AVCALL);
        er.set_hr( pAVCall->QueryInterface(IID_IAVTapiCall, (void **) &m_pAVCall) );
    }
    m_critAVCall.Unlock();

    if ( SUCCEEDED(er.m_hr) )
    {
        put_CallState( (CALL_STATE) AV_CS_DIALING );

        // General notification of conference room in use
        CAVTapi *pAVTapi;
        if ( SUCCEEDED(_Module.GetAVTapi(&pAVTapi)) )
            pAVTapi->fire_ActionSelected( CC_ACTIONS_JOIN_CONFERENCE );
    }

    return er.m_hr;
}

void CConfRoom::UpdateNumParticipants( IAVTapiCall *pAVCall )
{
    _ASSERT( pAVCall );
    ITParticipantControl *pITParticipantControl;
    if ( SUCCEEDED(pAVCall->get_ITParticipantControl(&pITParticipantControl)) )
    {
        long lNum = 0;
        IEnumParticipant *pEnum;
        if ( SUCCEEDED(pITParticipantControl->EnumerateParticipants(&pEnum)) )
        {
            lNum++;        // add one for ourself

            ITParticipant *pParticipant = NULL;
            while ( (pEnum->Next(1, &pParticipant, NULL) == S_OK) && pParticipant )
            {
                pParticipant->Release();
                pParticipant = NULL;
                lNum++;
            }

            pEnum->Release();
        }

        // Clean up
        pITParticipantControl->Release();

        // Store participant count
        Lock();
        m_lNumParticipants = lNum;
        Unlock();
    }
}


STDMETHODIMP CConfRoom::Show(HWND hWndTree, HWND hWndClient)
{
    _ASSERT( IsWindow(hWndTree) && IsWindow(hWndClient) );
    if ( !IsWindow(hWndTree) || !IsWindow(hWndClient) ) return E_INVALIDARG;

    HRESULT hr = E_FAIL;

    // Retrieve conf room settings
    UpdateData( false );


    IConfRoomTreeView *pTreeView;
    if ( SUCCEEDED(hr = get_TreeView(&pTreeView)) )
    {
        // Create the tree view
        pTreeView->put_hWnd( hWndTree );
        pTreeView->Release();

        // Create the conferenc room window
        ::SetClassLongPtr( hWndClient, GCLP_HBRBACKGROUND, (LONG_PTR) GetSysColorBrush(COLOR_BTNFACE) );
        if ( IsWindow(m_wndRoom.m_hWnd) ) 
        {
            // Are we just changing parents?
            m_wndRoom.SetParent( hWndClient );
        }
        else
        {
            // Are we creating a new conference room window?
            RECT rc;
            GetClientRect( hWndClient, &rc );
            m_wndRoom.Create( hWndClient, rc, NULL, WS_CHILD | WS_VISIBLE, 0, IDW_CONFROOM );
        }

        // Before continuing, make sure we have a valid window
        if ( IsWindow(m_wndRoom.m_hWnd) )
        {
            hr = m_wndRoom.LayoutRoom( CConfRoomWnd::LAYOUT_CREATE, true );
            m_wndRoom.PostMessage( WM_SIZE );
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}


STDMETHODIMP CConfRoom::get_TreeView(IConfRoomTreeView **ppVal)
{
    HRESULT hr = S_OK;

    Lock();
    if ( !m_pTreeView )
    {
        m_pTreeView = new CComObject<CConfRoomTreeView>;
        if ( m_pTreeView )
        {
            m_pTreeView->AddRef();
            m_pTreeView->put_ConfRoom( this );
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if ( SUCCEEDED(hr) )
    {
        *ppVal = m_pTreeView;
        (*ppVal)->AddRef();
    }
    Unlock();

    return hr;
}

STDMETHODIMP CConfRoom::Disconnect()
{
    HRESULT hr = E_FAIL;

    if ( IsConfRoomConnected() == S_OK )
    {
        Lock();
        VARIANT_BOOL bConfirm = m_bConfirmDisconnect;
        Unlock();

        if ( !bConfirm || (_Module.DoMessageBox(IDS_CONFIRM_CONFROOM_DISCONNECT, MB_YESNO | MB_ICONQUESTION, false) == IDYES) )
        {
            m_wndRoom.RedrawWindow();
            InternalDisconnect();
        }
    }
    else
    {
        Cancel();
    }

    return hr;
}

STDMETHODIMP CConfRoom::CanDisconnect()
{
    HRESULT hr = S_FALSE;

    m_critAVCall.Lock();
    if ( m_pAVCall )
    {
        CALL_STATE callState;
        if ( SUCCEEDED(m_pAVCall->get_callState(&callState)) )
        {
            if ( (callState != CS_IDLE) && (callState != CS_DISCONNECTED) )
                hr = S_OK;
        }
    }
    m_critAVCall.Unlock();

    return hr;
}

STDMETHODIMP CConfRoom::NotifyStateChange( IAVTapiCall *pAVCall )
{
    HRESULT hr = E_FAIL;
    bool bMatch = false;

    m_critAVCall.Lock();
    if ( m_pAVCall == pAVCall )
        bMatch = true;
    m_critAVCall.Unlock();

    if ( bMatch )
    {
        CALL_STATE callState;
        pAVCall->get_callState( &callState );
        put_CallState( callState );
    }

    return hr;
}


STDMETHODIMP CConfRoom::NotifyParticipantChange(IAVTapiCall * pAVCall, ITParticipant * pParticipant, AV_PARTICIPANT_EVENT nEvent )
{
    ATLTRACE(_T(".enter.CConfRoom::NotifyParticipantChange(%d, %p).\n"), nEvent, pParticipant);
    HRESULT hr = E_FAIL;

    m_critAVCall.Lock();
    if ( m_pAVCall && (m_pAVCall == pAVCall) || !pAVCall )
        hr = S_OK;
    m_critAVCall.Unlock();

    CConfRoomWnd::LayoutStyles_t nStyle = CConfRoomWnd::LAYOUT_NONE;

    // If we have a match, re-load the treeview
    if ( SUCCEEDED(hr) )
    {
        IConfRoomTreeView *pTreeView;
        if ( SUCCEEDED(get_TreeView(&pTreeView)) )
        {
            switch ( nEvent )
            {
                case AV_PARTICIPANT_UPDATE:
                    m_wndRoom.UpdateNames( pParticipant );
                    break;

                // Joined the conference
                case AV_PARTICIPANT_JOIN:
                    UpdateNumParticipants( pAVCall );
                    pTreeView->UpdateRootItem();
                    break;

                // Showing video
                case AV_PARTICIPANT_STREAMING_START:
                    pTreeView->UpdateRootItem();
                    m_wndRoom.UpdateNames( NULL );
                    nStyle = CConfRoomWnd::LAYOUT_MEMBERS;

                    // Any video to start streaming gets automatically selected
                    if ( !IsTalkerStreaming() )
                        SelectTalker( pParticipant, true );

                    break;

                // Not Showing video
                case AV_PARTICIPANT_STREAMING_STOP:
                    pTreeView->UpdateRootItem();
                    nStyle = (IsTalkerParticipant(pParticipant)) ? CConfRoomWnd::LAYOUT_ALL : CConfRoomWnd::LAYOUT_MEMBERS;
                    break;

                // Participant leaving
                case AV_PARTICIPANT_LEAVE:
                    UpdateNumParticipants( pAVCall );
                    pTreeView->UpdateRootItem();
                    m_wndRoom.UpdateNames( NULL );

                    // Select new talker in the case where the talker leaves
                    nStyle = CConfRoomWnd::LAYOUT_MEMBERS;
                    {
                        ITParticipant *pTemp = NULL;
//                        bool bNewTalker = (bool) (FAILED(get_TalkerParticipant(&pTemp)) || IsTalkerParticipant(pParticipant));
                        bool bNewTalker = (bool) IsTalkerParticipant(pParticipant);
                        RELEASE( pTemp );

                        if ( bNewTalker )
                        {
                            nStyle = CConfRoomWnd::LAYOUT_ALL;
                            // Find a video feed that's streaming!
                            IVideoWindow *pVideo = NULL;
                            if ( SUCCEEDED(GetFirstVideoWindowThatsStreaming((IDispatch **) &pVideo)) )
                            {
                                set_TalkerVideo( pVideo, true, true );
                                pVideo->Release();
                            }
                            else
                            {
                                // Select anything!
                                SelectTalker( NULL, true );
                            }
                        }
                    }
                    break;
            }

            pTreeView->Release();

            // Layout room if requested
            if ( nStyle != CConfRoomWnd::LAYOUT_NONE )
                m_wndRoom.LayoutRoom( nStyle, true );
        }
    }

    return hr;
}


STDMETHODIMP CConfRoom::get_MemberVideoSize(short * pVal)
{
    Lock();
    *pVal = (m_szMembers.cx * 100) / VID_X;
    Unlock();
    return S_OK;
}

STDMETHODIMP CConfRoom::put_MemberVideoSize(short newVal)
{
    Lock();
    m_szMembers.cx = (newVal * VID_X) / 100;
    m_szMembers.cy = (newVal * VID_Y) / 100;
    Unlock();

    return m_wndRoom.LayoutRoom( CConfRoomWnd::LAYOUT_MEMBERS, true );
}

STDMETHODIMP CConfRoom::get_nNumTerms(short *pVal)
{
    Lock();
    *pVal = m_nNumTerms;
    Unlock();
    
    return S_OK;
}

STDMETHODIMP CConfRoom::get_bstrConfName(BSTR * pVal)
{
    HRESULT hr = E_FAIL;
    
    // Name of conference is stored as originally dialed address
    m_critAVCall.Lock();
    if ( m_pAVCall )
        hr = m_pAVCall->get_bstrOriginalAddress( pVal );
    m_critAVCall.Unlock();
    
    return hr;
}

STDMETHODIMP CConfRoom::get_hWndConfRoom(HWND * pVal)
{
    Lock();
    *pVal = m_wndRoom.m_hWnd;
    Unlock();
    return S_OK;
}

STDMETHODIMP CConfRoom::get_bShowNames(VARIANT_BOOL * pVal)
{
    Lock();
    *pVal = m_bShowNames;
    Unlock();
    return S_OK;
}

STDMETHODIMP CConfRoom::put_bShowNames(VARIANT_BOOL newVal)
{
    // Only update if different
    bool bChanged = false;

    Lock();
    if ( newVal != m_bShowNames )
    {
        m_bShowNames = newVal;
        bChanged = true;
    }
    Unlock();

    if ( bChanged )
        m_wndRoom.LayoutRoom( CConfRoomWnd::LAYOUT_MEMBERS, true );
    
    return S_OK;
}

STDMETHODIMP CConfRoom::get_nShowNamesNumLines(short * pVal)
{
    Lock();
    *pVal = m_nShowNamesNumLines;
    Unlock();
    return S_OK;
}

STDMETHODIMP CConfRoom::put_nShowNamesNumLines(short newVal)
{    
    bool bChanged = false;
    Lock();
    if ( m_nShowNamesNumLines != newVal )
    {
        m_nShowNamesNumLines = newVal;
        bChanged = true;
    }
    Unlock();

    if ( bChanged )
        m_wndRoom.LayoutRoom( CConfRoomWnd::LAYOUT_MEMBERS, true );

    return S_OK;
}

STDMETHODIMP CConfRoom::get_IAVTapiCall(IAVTapiCall **ppVal)
{
    HRESULT hr = E_POINTER;

    if ( ppVal )
    {
        m_critAVCall.Lock();
        if ( m_pAVCall )
            hr = m_pAVCall->QueryInterface( IID_IAVTapiCall, (void **) ppVal );
        m_critAVCall.Unlock();
    }
    
    return hr;
}

STDMETHODIMP CConfRoom::get_bConfirmDisconnect(VARIANT_BOOL * pVal)
{
    Lock();
    *pVal = m_bConfirmDisconnect;
    Unlock();
    return S_OK;
}

STDMETHODIMP CConfRoom::put_bConfirmDisconnect(VARIANT_BOOL newVal)
{
    Lock();
    m_bConfirmDisconnect;
    Unlock();
    return S_OK;
}

HRESULT    CConfRoom::get_szMembers( SIZE *pSize )
{
    Lock();
    *pSize = m_szMembers;
    Unlock();

    return S_OK;
}

STDMETHODIMP CConfRoom::get_TalkerParticipant(ITParticipant **ppVal)
{
    HRESULT hr = E_FAIL;
    *ppVal = NULL;

    // Set the talker video if it's different from the current one
    m_atomTalkerVideo.Lock( CAtomicList::LIST_READ );
    if ( m_pITalkerVideo )
    {
        IVideoFeed *pFeed;
        if ( SUCCEEDED(hr = m_wndRoom.m_wndMembers.FindVideoFeed(m_pITalkerVideo, &pFeed)) )
        {
            hr = pFeed->get_ITParticipant( ppVal );
            pFeed->Release();
        }

    }
    else
    {
        hr = get_ITTalkerParticipant( ppVal );
    }
    m_atomTalkerVideo.Unlock( CAtomicList::LIST_READ );

    return hr;
}

STDMETHODIMP CConfRoom::get_nMaxTerms(short * pVal)
{
    Lock();
    *pVal = m_nMaxTerms;
    Unlock();

    return S_OK;
}

STDMETHODIMP CConfRoom::put_nMaxTerms(short newVal)
{
    HRESULT hrInUse = IsConfRoomInUse();

    Lock();
    m_nMaxTerms = max(0, min(MAX_VIDEO, newVal));
    if ( hrInUse == S_FALSE )
        m_nNumTerms = m_nMaxTerms;
    Unlock();

    // Redraw room with new number of terminals (note that this won't change for an active call)
    if ( hrInUse == S_FALSE )
        m_wndRoom.LayoutRoom( CConfRoomWnd::LAYOUT_CREATE, true );

    return S_OK;
}

STDMETHODIMP CConfRoom::get_lNumParticipants(long * pVal)
{
    Lock();
    *pVal = m_lNumParticipants;
    Unlock();

    return S_OK;
}


STDMETHODIMP CConfRoom::get_ConfDetails(long **ppVal)
{
    Lock();
    *((CConfDetails *) *ppVal) = m_confDetails;
    Unlock();

    return S_OK;
}

STDMETHODIMP CConfRoom::put_ConfDetails(long * newVal)
{
    Lock();
    m_confDetails = *((CConfDetails *) newVal);
    Unlock();

    return S_OK;
}

STDMETHODIMP CConfRoom::get_bstrConfDetails(BSTR * pVal)
{
    _ASSERT( pVal );
    if ( IsConfRoomInUse() == S_OK )
    {
        // Retrieve information from details data structuren
        Lock();
        m_confDetails.MakeDetailsCaption( *pVal );
        Unlock();
    }
    else
    {
        // Conference room not presently in use
        USES_CONVERSION;
        TCHAR szText[255];

        //
        // We have to initialize szText
        //

        _tcscpy( szText, _T(""));

        LoadString( _Module.GetResourceInstance(), IDS_CONFROOM_NODETAILS, szText, ARRAYSIZE(szText) );
        *pVal = SysAllocString( T2COLE(szText) );
    }

    return S_OK;
}

STDMETHODIMP CConfRoom::Layout(VARIANT_BOOL bTalker, VARIANT_BOOL bMembers )
{
    CConfRoomWnd::LayoutStyles_t nStyle = CConfRoomWnd::LAYOUT_NONE;

    if ( bTalker ) nStyle = (CConfRoomWnd::LayoutStyles_t) (nStyle | CConfRoomWnd::LAYOUT_TALKER);
    if ( bMembers ) nStyle = (CConfRoomWnd::LayoutStyles_t) (nStyle | CConfRoomWnd::LAYOUT_MEMBERS);

    return m_wndRoom.LayoutRoom( nStyle, true );
}


void CConfRoom::set_PreviewVideo( IVideoWindow *pVideo )
{
    Lock();
    m_pVideoPreview = pVideo;
    Unlock();
}

bool CConfRoom::IsPreviewVideo( IVideoWindow *pVideo )
{
    bool bRet;
    Lock();
    bRet = (bool) (m_pVideoPreview && (m_pVideoPreview == pVideo));
    Unlock();

    return bRet;
}

bool CConfRoom::IsTalkerParticipant( ITParticipant *pParticipant )
{
    bool bRet = false;

    ITParticipant *pTalkerParticipant;
    if ( SUCCEEDED(get_TalkerParticipant(&pTalkerParticipant)) )
    {
        if ( pTalkerParticipant == pParticipant )
            bRet = true;

        pTalkerParticipant->Release();
    }

    return bRet;
}

STDMETHODIMP CConfRoom::SelectTalkerVideo(IDispatch * pDisp, VARIANT_BOOL bUpdate)
{
    return set_TalkerVideo( (IVideoWindow *) pDisp, (bool) (bUpdate != 0), true);
}

STDMETHODIMP CConfRoom::get_hWndTalker(HWND * pVal)
{
    *pVal = m_wndRoom.m_wndTalker;
    return S_OK;
}

STDMETHODIMP CConfRoom::get_hWndMembers(HWND * pVal)
{
    *pVal = m_wndRoom.m_wndMembers;
    return S_OK;
}

STDMETHODIMP CConfRoom::get_bPreviewStreaming(VARIANT_BOOL * pVal)
{
    Lock();
    *pVal = m_bPreviewStreaming;
    Unlock();

    return S_OK;
}

STDMETHODIMP CConfRoom::FindVideoFeedFromParticipant(ITParticipant * pParticipant, IVideoFeed **ppFeed)
{
    return m_wndRoom.m_wndMembers.FindVideoFeedFromParticipant( pParticipant, ppFeed );
}

STDMETHODIMP CConfRoom::SetQOSOnParticipants()
{
    // TODO: Add your implementation code here

    return S_OK;
}

STDMETHODIMP CConfRoom::FindVideoFeedFromSubStream(ITSubStream * pSubStream, IVideoFeed * * ppFeed)
{
    HRESULT hr;

    _ASSERT( pSubStream );
    IEnumTerminal *pEnum;
    if ( SUCCEEDED(hr = pSubStream->EnumerateTerminals(&pEnum)) )
    {
        hr = E_FAIL;

        ITTerminal *pITTerminal = NULL;
        if ( (pEnum->Next(1, &pITTerminal, NULL) == S_OK) && pITTerminal )
        {
            IVideoWindow *pVideo;
            if ( SUCCEEDED(pITTerminal->QueryInterface(IID_IVideoWindow, (void **) &pVideo)) )
            {
                hr = m_wndRoom.m_wndMembers.FindVideoFeed( pVideo, ppFeed );
                pVideo->Release();
            }
            RELEASE( pITTerminal );
        }
        pEnum->Release();
    }

    return hr;
}

STDMETHODIMP CConfRoom::GetFirstVideoWindowThatsStreaming(IDispatch **ppVideo)
{
    return m_wndRoom.m_wndMembers.GetFirstVideoWindowThatsStreaming( (IVideoWindow **) ppVideo );
}


STDMETHODIMP CConfRoom::Cancel()
{
    Lock();
    CALL_STATE nState =    m_wndRoom.m_wndTalker.m_dlgTalker.m_callState;
    Unlock();

    if ( (nState != AV_CS_DISCONNECTING) && (IsConfRoomInUse() == S_OK) )
        put_CallState( (CALL_STATE) AV_CS_ABORT );

    return S_OK;
}


bool CConfRoom::IsTalkerStreaming()
{
    IVideoWindow *pVideo = NULL;
    HRESULT hr = get_TalkerVideo( (IDispatch **) &pVideo );

    // For preview make sure we're streaming!
    if ( SUCCEEDED(hr) && IsPreviewVideo(pVideo) )
    {
        IAVTapiCall *pAVCall;
        if ( SUCCEEDED(get_IAVTapiCall(&pAVCall)) )
        {
            // If we are failing to stream video for some reason, flag as error.
            if ( pAVCall->IsPreviewStreaming() != S_OK )
                hr = E_FAIL;

            pAVCall->Release();
        }
    }

    RELEASE( pVideo );
    
    return (bool) (hr == S_OK);
}

STDMETHODIMP CConfRoom::get_szTalker(SIZE * pVal)
{
    Lock();
    *pVal = m_szTalker;
    Unlock();

    return S_OK;
}

STDMETHODIMP CConfRoom::get_TalkerScale(short * pVal)
{
    Lock();
    *pVal = m_nScale;
    Unlock();

    return S_OK;
}

STDMETHODIMP CConfRoom::put_TalkerScale(short newVal)
{
    Lock();
    if ( newVal != m_nScale )
    {
        m_nScale = newVal;
        m_szTalker.cx = (VID_X * m_nScale) / 100;
        m_szTalker.cy = (VID_Y * m_nScale) / 100;
    }
    Unlock();

    m_wndRoom.PostMessage( WM_SIZE, 0, 0 );
    return S_OK;
}


bool CConfRoom::MapStreamingParticipant( IParticipant *pIParticipant, IVideoFeed **ppFeed )
{
    _ASSERT( pIParticipant && ppFeed );
    bool bRet = false;

    if ( SUCCEEDED(m_wndRoom.m_wndMembers.GetAndMoveVideoFeedThatStreamingForParticipantReMap((IVideoFeed **) ppFeed)) )
    {
        ITParticipant *p;
        if ( SUCCEEDED(pIParticipant->get_ITParticipant(&p)) )
        {
            if ( SUCCEEDED((*ppFeed)->MapToParticipant(p)) )
                bRet = true;

            p->Release();
        }

        // Make sure we clean up feed ref count accordingly...
        if ( !bRet )
            (*ppFeed)->Release();
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\confroomwnd.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////
// ConfRoomWnd.h
//

#ifndef __CONFROOMWND_H__
#define __CONFROOMWND_H__

// FWD define
class CConfRoomWnd;

#define WM_LAYOUT	(WM_USER + 1032)

#include "AVTapiCall.h"
#include "ConfRoom.h"
#include "CRMemWnd.h"
#include "CRTalkerWnd.h"

#include <list>
using namespace std;

typedef list<DWORD>	LayoutList;

#define VID_X		176
#define VID_Y		144

#define VID_SX		88
#define VID_SY		72

#define VID_DX		10
#define VID_DY		8

#define SEL_DX		3
#define SEL_DY		3


class CConfRoomWnd :
	public CWindowImpl<CConfRoomWnd>
{
// Enums
public:
	typedef enum tag_LayoutStyles_t
	{
		LAYOUT_NONE			= 0x0000,
		LAYOUT_TALKER		= 0x0001,
		LAYOUT_MEMBERS		= 0x0002,
		CREATE_MEMBERS		= 0x1000,
		LAYOUT_ALL			= 0x0FFF,
		LAYOUT_CREATE		= 0xFFFF,
	} LayoutStyles_t;

//Construction
public:
	CConfRoomWnd();

// Members
public:
	CConfRoom				*m_pConfRoom;			// back pointer
	CConfRoomTalkerWnd		m_wndTalker;			// talker window
	CConfRoomMembersWnd		m_wndMembers;			// all conf members

	HBITMAP					m_hBmpFeed_LargeAudio;
	HBITMAP					m_hBmpFeed_Large;
	HBITMAP					m_hBmpFeed_Small;

protected:
	CComAutoCriticalSection	m_critThis;

	LayoutList				m_lstLayout;
	CComAutoCriticalSection m_critLayout;

// Operations
public:
	void UpdateNames( ITParticipant *pParticipant );
	HRESULT LayoutRoom( LayoutStyles_t layoutStyle, bool bRedraw );

protected:
	bool	CreateStockWindows();

	
// Implementation
public:
BEGIN_MSG_MAP(CExpTreeView)
	MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
	MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
	MESSAGE_HANDLER(WM_CREATE, OnCreate)
	MESSAGE_HANDLER(WM_SIZE, OnSize)
END_MSG_MAP()
	LRESULT OnContextMenu(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
	LRESULT OnDestroy(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
	LRESULT OnCreate(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
	LRESULT OnSize(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
};

#endif //__CONFROOMWND_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\crmemwnd.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////
// ConfRoomMembersWnd.h
//

#ifndef __CONFROOMMEMBERSWND_H__
#define __CONFROOMMEMBERSWND_H__

// FWD define
class CConfRoomMembersWnd;

#include "ConfRoomWnd.h"
#include "VideoFeed.h"
#pragma warning( disable : 4786 )

#include <list>
using namespace std;
typedef list<IVideoFeed *>	VIDEOFEEDLIST;

class CConfRoomMembersWnd :
	public CWindowImpl<CConfRoomMembersWnd>
{
//Construction
public:
	CConfRoomMembersWnd();
	virtual ~CConfRoomMembersWnd();

// Members
public:
	CConfRoomWnd	*m_pConfRoomWnd;
	VIDEOFEEDLIST	m_lstFeeds;
	
protected:
	static	UINT				m_nFontHeight;
	UINT						m_nTimerID;

	CComAutoCriticalSection		m_critFeedList;
	CComAutoCriticalSection		m_critLayout;

// Attributes
public:
	long					GetFontHeight();
	HRESULT					GetNameFromVideo( IVideoWindow *pVideo, BSTR *pbstrName, BSTR *pbstrInfo, bool bAllowNull, bool bPreview );
	HRESULT					GetFirstVideoWindowThatsStreaming(IVideoWindow **ppVideo, bool bIncludePreview = true );
	HRESULT					GetFirstVideoFeedThatsStreaming( IVideoFeed **ppFeed, bool bIncludePreview = true );
	HRESULT					GetAndMoveVideoFeedThatStreamingForParticipantReMap( IVideoFeed **ppFeed );

// Operations
public:
	void					PaintFeed( HDC hDC, IVideoFeed *pFeed );
	void					PaintFeedName( HDC hDC, BSTR bstrName, IVideoFeed *pFeed );
	void					PaintFeedName( HDC hDC, IVideoFeed *pFeed );
	void					ClearFeed( IVideoWindow *pIVideoWindow );
	void					UpdateTalkerFeed( bool bUpdateAll, bool bForceSelect );

	void					UpdateNames( ITParticipant *pParticipant );
	HRESULT					Layout();
	void					EmptyList();

	HRESULT					FindVideoPreviewFeed( IVideoFeed **ppFeed );
	HRESULT					FindVideoFeed( IVideoWindow *pVideo, IVideoFeed **ppFeed );
	HRESULT					FindVideoFeedFromParticipant( ITParticipant *pParticipant, IVideoFeed **ppFeed );
	HRESULT					HitTest( POINT pt, IVideoFeed **ppFeed );
	HRESULT					IsVideoWindowStreaming( IVideoWindow *pVideo );
	
	IVideoFeed*				NewFeed( IVideoWindow *pVideo, const RECT& rc, VARIANT_BOOL bPreview );
	void					HideVideoFeeds();
	void					DoLayout( WPARAM wParam, int nScrollPos );
	int						GetStreamingCount();

// Implementation
public:
BEGIN_MSG_MAP(CConfRoomMembersWnd)
	MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
	MESSAGE_HANDLER(WM_CREATE, OnCreate)
	MESSAGE_HANDLER(WM_PAINT, OnPaint)
	MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
	MESSAGE_HANDLER(WM_SIZE, OnSize)
	MESSAGE_HANDLER(WM_PARENTNOTIFY, OnParentNotify)
	MESSAGE_HANDLER(WM_TIMER, OnTimer)
	MESSAGE_HANDLER(WM_LAYOUT, OnLayout)
	MESSAGE_HANDLER(WM_VSCROLL, OnVScroll )
END_MSG_MAP()

	LRESULT OnCreate(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
	LRESULT OnPaint(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
	LRESULT OnDestroy(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
	LRESULT OnContextMenu(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
	LRESULT OnLayoutWindow(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
	LRESULT OnTimer(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
	LRESULT OnSize(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
	LRESULT OnLayout(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
	LRESULT OnParentNotify(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
	LRESULT OnVScroll(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
};

#endif //__CONFROOMMEMBERSWND_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\crtreeview.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// ConfRoomTreeView.cpp : Implementation of CConfRoomTreeView
#include "stdafx.h"
#include <stdio.h>
#include "TapiDialer.h"
#include "CRTreeView.h"
#include "Particip.h"

/////////////////////////////////////////////////////////////////////////////
// CConfRoomTreeView

CConfRoomTreeView::CConfRoomTreeView()
{
	m_pIConfRoom = NULL;
}

void CConfRoomTreeView::FinalRelease()
{
	ATLTRACE(_T(".enter.CConfRoomTreeView::FinalRelease().\n") );

	put_hWnd( NULL );
	RELEASE( m_pIConfRoom );

	CComObjectRootEx<CComMultiThreadModel>::FinalRelease();
}

/////////////////////////////////////////////////////////////////////////////////////////
// COM interface methods
//

STDMETHODIMP CConfRoomTreeView::get_hWnd(HWND * pVal)
{
	Lock();
	*pVal = m_wndTree;
	Unlock();
	return S_OK;
}

STDMETHODIMP CConfRoomTreeView::put_hWnd(HWND newVal)
{
	Lock();
	m_wndTree = newVal;
	Unlock();

	return S_OK;
}

STDMETHODIMP CConfRoomTreeView::get_ConfRoom(IConfRoom **ppVal)
{
	HRESULT hr = E_PENDING;
	Lock();
	if ( m_pIConfRoom )
		hr = m_pIConfRoom->QueryInterface( IID_IConfRoom, (void **) ppVal );
	Unlock();

	return hr;
}

STDMETHODIMP CConfRoomTreeView::put_ConfRoom(IConfRoom * newVal)
{
	HRESULT hr = S_OK;

	Lock();
	RELEASE( m_pIConfRoom );
	if ( newVal )
		hr = newVal->QueryInterface( IID_IConfRoom, (void **) &m_pIConfRoom );
	Unlock();

	return hr;
}

STDMETHODIMP CConfRoomTreeView::UpdateData(BOOL bSaveAndValidate)
{
	// Clear out all participants and update the root item
	CComPtr<IAVGeneralNotification> pAVGen;
	if ( SUCCEEDED(_Module.get_AVGenNot(&pAVGen)) )
	{
		pAVGen->fire_DeleteAllConfParticipants();
		if ( !bSaveAndValidate )
		{
			// Populate the tree control
			UpdateRootItem();
			AddParticipants();
		}
	}

	return S_OK;
}

void CConfRoomTreeView::AddParticipants()
{
	IAVTapiCall *pAVCall = NULL;
	IConfRoom *pConfRoom;
	if ( SUCCEEDED(get_ConfRoom(&pConfRoom)) )
	{
		if ( pConfRoom->IsConfRoomConnected() == S_OK )
			pConfRoom->get_IAVTapiCall( &pAVCall );

		pConfRoom->Release();
	}

	if ( pAVCall )
	{
		pAVCall->PopulateTreeView( dynamic_cast<IConfRoomTreeView *> (this) );
		pAVCall->Release();
	}
}

STDMETHODIMP CConfRoomTreeView::SelectParticipant(ITParticipant * pParticipant, VARIANT_BOOL bMeParticipant )
{
	HRESULT hr = S_OK;

	CComPtr<IAVGeneralNotification> pAVGen;
	if ( SUCCEEDED(_Module.get_AVGenNot(&pAVGen)) )
	{
		IAVTapiCall *pAVCall;
		if ( SUCCEEDED(m_pIConfRoom->get_IAVTapiCall(&pAVCall)) )
		{	
			bool bSelect = true;
			IParticipant *p = NULL;

			if ( !bMeParticipant )
				hr = pAVCall->FindParticipant( pParticipant, &p );

			if ( SUCCEEDED(hr) )
				pAVGen->fire_SelectConfParticipant( p );

			// Clean up
			RELEASE(p);
			pAVCall->Release();
		}
	}

	return hr;
}


STDMETHODIMP CConfRoomTreeView::UpdateRootItem()
{
	// Conference room tree view title
	BSTR bstrConfName = NULL;
	if ( m_pIConfRoom && SUCCEEDED(m_pIConfRoom->get_bstrConfName(&bstrConfName)) && (SysStringLen(bstrConfName) > 0) )
	{
		// How many participants are there in the conference?
		if ( m_pIConfRoom->IsConfRoomConnected() == S_OK )
		{
			USES_CONVERSION;
			TCHAR szText[255];
			long lNumParticipants = 1;
			m_pIConfRoom->get_lNumParticipants( &lNumParticipants );

			_sntprintf( szText, ARRAYSIZE(szText) - 1, _T("%s - (%ld)"), OLE2CT(bstrConfName), lNumParticipants );
			SysReAllocString( &bstrConfName, T2COLE(szText) );
		}
	}

	// Fire notification
	CComPtr<IAVGeneralNotification> pAVGen;
	if ( SUCCEEDED(_Module.get_AVGenNot(&pAVGen)) )
		pAVGen->fire_UpdateConfRootItem( bstrConfName );

	// Release String
	SysFreeString( bstrConfName );

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\crtalkerwnd.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////
// ConfRoomTalkerWnd.h
//

#ifndef __CONFROOMTALKERWND_H__
#define __CONFROOMTALKERWND_H__

// FWD define
class CConfRoomTalkerWnd;

#include "DlgCRTalker.h"

class CConfRoomTalkerWnd :
	public CWindowImpl<CConfRoomTalkerWnd>
{
//Construction
public:
	CConfRoomTalkerWnd();
	virtual ~CConfRoomTalkerWnd();

// Members
public:
	CConfRoomWnd			*m_pConfRoomWnd;
	CDlgConfRoomTalker		m_dlgTalker;			// conference information
	CComAutoCriticalSection	m_critLayout;

// Operations
public:
	HRESULT Layout( IAVTapiCall *pAVCall, const SIZE& sz );
	void	UpdateNames( ITParticipant *pParticipant );
	bool	SetHostWnd( IVideoWindow *pVideo );

// Implementation
public:
BEGIN_MSG_MAP(CConfRoomTalkerWnd)
	MESSAGE_HANDLER(WM_PAINT, OnPaint)
	MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
	MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBkgnd)
	MESSAGE_HANDLER(WM_SIZE, OnSize)
	MESSAGE_HANDLER(WM_LAYOUT, OnLayout)
	MESSAGE_HANDLER(WM_CREATE, OnCreate)
END_MSG_MAP()

	LRESULT OnPaint(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
	LRESULT OnEraseBkgnd(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
	LRESULT OnContextMenu(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
	LRESULT OnSize(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
	LRESULT OnLayout(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
	LRESULT OnCreate(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
};

#endif //__CONFROOMTALKERWND_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\crtalkwnd.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////
// ConfRoomTalkerWnd.cpp
//

#include "stdafx.h"
#include "TapiDialer.h"
#include "ConfRoom.h"
#include "VideoFeed.h"

CConfRoomTalkerWnd::CConfRoomTalkerWnd()
{
	m_pConfRoomWnd = NULL;
	m_dlgTalker.m_pConfRoomTalkerWnd = this;
}

CConfRoomTalkerWnd::~CConfRoomTalkerWnd()
{
}

LRESULT CConfRoomTalkerWnd::OnCreate(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled)
{
	m_dlgTalker.Create( m_hWnd );
	return 0;
}

HRESULT CConfRoomTalkerWnd::Layout( IAVTapiCall *pAVCall, const SIZE& sz )
{
	_ASSERT( m_pConfRoomWnd );
	if ( !m_pConfRoomWnd ) return E_UNEXPECTED;

	m_critLayout.Lock();
	HRESULT hr = S_OK;

	CALL_STATE nState;
	bool bConfConnected = (bool) (pAVCall && SUCCEEDED(pAVCall->get_callState(&nState)) && (nState == CS_CONNECTED));

	// Set up conference information
	if ( IsWindow(m_dlgTalker.m_hWnd) )
	{
		IVideoWindow *pVideo = NULL;

		// Locate the talker window on the appropriate host window.
		if ( bConfConnected )
		{
			// Should have a valid IVideoWindow pointer by now
			m_pConfRoomWnd->m_pConfRoom->get_TalkerVideo( (IDispatch **) &pVideo );

			// Force a selection if we don't already have one
//			if ( !pVideo )
//				if ( SUCCEEDED(m_pConfRoomWnd->m_wndMembers.GetFirstVideoWindowThatsStreaming(&pVideo)) )
//					m_pConfRoomWnd->m_pConfRoom->set_TalkerVideo( pVideo, false, true );

			SetHostWnd( pVideo );
		}

		///////////////////////////////////////////////////////////////////////
		// Update dialog data
		//

		// Clean up existing strings
		SysFreeString( m_dlgTalker.m_bstrCallerID );
		SysFreeString( m_dlgTalker.m_bstrCallerInfo );
		m_dlgTalker.m_bstrCallerID = NULL;
		m_dlgTalker.m_bstrCallerInfo = NULL;

		// Retrieve name for talker either from the video or the participant
		if ( pVideo )
		{
			m_pConfRoomWnd->m_wndMembers.GetNameFromVideo( pVideo, &m_dlgTalker.m_bstrCallerID, &m_dlgTalker.m_bstrCallerInfo, true, m_pConfRoomWnd->m_pConfRoom->IsPreviewVideo(pVideo) );	
			pVideo->Release();
		}
		else if ( bConfConnected )
		{
			// Retrieve participant that's talking
			ITParticipant *pTalkerParticipant;
			if ( SUCCEEDED(m_pConfRoomWnd->m_pConfRoom->get_TalkerParticipant(&pTalkerParticipant)) )
			{
				CVideoFeed::GetNameFromParticipant( pTalkerParticipant, &m_dlgTalker.m_bstrCallerID, &m_dlgTalker.m_bstrCallerInfo );
				pTalkerParticipant->Release();
			}
			else
			{
				// This is the ME participant
				USES_CONVERSION;
				TCHAR szText[255];
				LoadString( _Module.GetResourceInstance(), IDS_VIDEOPREVIEW, szText, ARRAYSIZE(szText) );
				SysReAllocString( &m_dlgTalker.m_bstrCallerID, T2COLE(szText) );
			}
		}
	}
	m_critLayout.Unlock();

	// Show dialog data on dialog
	if ( IsWindow(m_dlgTalker.m_hWnd) )
		m_dlgTalker.UpdateData( false );

	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// Message Handlers
//

LRESULT CConfRoomTalkerWnd::OnPaint(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled)
{
	PAINTSTRUCT ps;
	HDC hDC = BeginPaint( &ps );
	if ( !hDC ) return 0;

	// Draw stock bitmap
	if ( m_pConfRoomWnd && m_pConfRoomWnd->m_pConfRoom )
	{
		// Are we presently streaming video?
		if ( !m_pConfRoomWnd->m_pConfRoom->IsTalkerStreaming() )
		{
			// Center vertically in client area
			int dy = 0;
			SIZE sz = m_pConfRoomWnd->m_pConfRoom->m_szTalker;
			RECT rc;
			GetClientRect( &rc );
			if ( rc.bottom > sz.cy )
				dy = (rc.bottom - sz.cy) / 2;

			rc.left = VID_DX;
			rc.top = dy;
			rc.right = rc.left + sz.cx;
			rc.bottom = rc.top + sz.cy;

			// Draw video feed, use Audio bitmap in case of talker that has no video
			ITParticipant *pParticipant = NULL;
			m_pConfRoomWnd->m_pConfRoom->get_TalkerParticipant( &pParticipant );

			// If no participant and talker window then it must be the Me participant
			bool bConfRoomInUse = false;
			if ( !pParticipant )
				bConfRoomInUse = (bool) (m_pConfRoomWnd->m_pConfRoom->IsConfRoomConnected() == S_OK);

			HBITMAP hBmp = (pParticipant || bConfRoomInUse) ? m_pConfRoomWnd->m_hBmpFeed_LargeAudio : m_pConfRoomWnd->m_hBmpFeed_Large;
			RELEASE(pParticipant);

			Draw( hDC, hBmp, VID_DX, dy, max(0, min(sz.cx, ps.rcPaint.right - VID_DX)), max(0, min(sz.cy, ps.rcPaint.bottom - dy)), true );
			Draw( hDC, hBmp, VID_DX, dy, sz.cx, sz.cy, true );
		}
	}

	EndPaint( &ps );

	bHandled = true;
	return 0;
}

LRESULT CConfRoomTalkerWnd::OnEraseBkgnd(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled)
{
    /*
	bHandled = true;
    
	RECT rc;
	GetClientRect( &rc );
	
	HBRUSH hBrNew = (HBRUSH) GetSysColorBrush( COLOR_ACTIVEBORDER );
	HBRUSH hBrOld;

	if ( hBrNew ) hBrOld = (HBRUSH) SelectObject( (HDC) wParam,  hBrNew);
	PatBlt( (HDC) wParam, 0, 0, RECTWIDTH(&rc), RECTHEIGHT(&rc), PATCOPY );
	if ( hBrNew ) SelectObject( (HDC) wParam, hBrOld );
    */

	return true;
}


LRESULT CConfRoomTalkerWnd::OnContextMenu(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled)
{
	bHandled = true;
	return ::SendMessage( GetParent(), nMsg, wParam, lParam );
}

LRESULT CConfRoomTalkerWnd::OnSize(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled)
{
	BOOL bHandleLayout;
	return OnLayout( WM_LAYOUT, wParam, lParam, bHandleLayout );
}

LRESULT CConfRoomTalkerWnd::OnLayout(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled)
{
	_ASSERT( m_pConfRoomWnd && m_pConfRoomWnd->m_pConfRoom );
	bHandled = true;

	// Initial coordinate info
	int dy = 0;
	RECT rc;
	GetClientRect( &rc );
	SIZE sz;
	m_pConfRoomWnd->m_pConfRoom->get_szTalker( &sz );
	if ( rc.bottom > sz.cy ) dy = (rc.bottom - sz.cy) / 2;

	// Get the video window we'll be laying out
	IVideoWindow *pVideo;
	if ( SUCCEEDED(m_pConfRoomWnd->m_pConfRoom->get_TalkerVideo((IDispatch **) &pVideo)) )
	{
		if ( SetHostWnd(pVideo) )
		{
			pVideo->SetWindowPosition( VID_DX, dy, sz.cx, sz.cy );
			pVideo->put_Visible( OATRUE );
		}
		pVideo->Release();
	}

	// Adjust position of talker dialog and child controls
	if ( IsWindow(m_dlgTalker.m_hWnd) )
	{
		m_dlgTalker.SetWindowPos( NULL, VID_DX + sz.cx, dy, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_SHOWWINDOW );

		// Adjust STATUS to proper position
		HWND hWndTemp = m_dlgTalker.GetDlgItem( IDC_LBL_STATUS );
		RECT rcTemp;
		::GetWindowRect( hWndTemp, &rcTemp );
		m_dlgTalker.ScreenToClient( &rcTemp );
		::SetWindowPos( hWndTemp, NULL, rcTemp.left, rc.bottom - (dy + RECTHEIGHT(&rcTemp)), 0, 0, SWP_NOSIZE | SWP_NOACTIVATE );

		// Adjust ANIMATE to proper position
		float fMult = (m_dlgTalker.m_callState == CS_DISCONNECTED) ? 1 : 1.3;
		hWndTemp = m_dlgTalker.GetDlgItem( IDC_ANIMATE );
		::GetWindowRect( hWndTemp, &rcTemp );
		m_dlgTalker.ScreenToClient( &rcTemp );
		::SetWindowPos( hWndTemp, NULL, rcTemp.left, rc.bottom - (dy + RECTHEIGHT(&rcTemp) * fMult), 0, 0, SWP_NOSIZE | SWP_NOACTIVATE );
	}

	return 0;
}



void CConfRoomTalkerWnd::UpdateNames( ITParticipant *pParticipant )
{
	if ( !m_pConfRoomWnd || !m_pConfRoomWnd->m_pConfRoom ) return;

	// Set caller ID based on participant info
	IVideoWindow *pVideo = NULL;
	if ( pParticipant || SUCCEEDED(m_pConfRoomWnd->m_pConfRoom->get_TalkerVideo((IDispatch **) &pVideo)) )
	{
		SysFreeString( m_dlgTalker.m_bstrCallerID );
		SysFreeString( m_dlgTalker.m_bstrCallerInfo );
		m_dlgTalker.m_bstrCallerID = NULL;
		m_dlgTalker.m_bstrCallerInfo = NULL;

		if ( pParticipant ) 
			CVideoFeed::GetNameFromParticipant( pParticipant, &m_dlgTalker.m_bstrCallerID, &m_dlgTalker.m_bstrCallerInfo );
		else
			m_pConfRoomWnd->m_wndMembers.GetNameFromVideo( pVideo, &m_dlgTalker.m_bstrCallerID, &m_dlgTalker.m_bstrCallerInfo, true, m_pConfRoomWnd->m_pConfRoom->IsPreviewVideo(pVideo) );

		m_dlgTalker.UpdateData( false );
	}

	RELEASE( pVideo );
}

bool CConfRoomTalkerWnd::SetHostWnd( IVideoWindow *pVideo )
{
	bool bRet = false;

	if ( pVideo )
	{
		// Get the video window we'll be laying out
		HWND hWndOwner;
		if ( SUCCEEDED(pVideo->get_Owner((OAHWND FAR*) &hWndOwner)) )
		{
			bRet = true;

			if ( hWndOwner != m_hWnd )
			{
				pVideo->put_Visible( OAFALSE );
				pVideo->put_Owner( (ULONG_PTR) m_hWnd );
				pVideo->put_MessageDrain( (ULONG_PTR) GetParent() );
				pVideo->put_WindowStyle( WS_CHILD | WS_BORDER );
			}
		}
	}

	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\dlgaddcsvr.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// DlgAddConfServer.h : Declaration of the CDlgAddConfServer

#ifndef __DLGADDCONFSERVER_H_
#define __DLGADDCONFSERVER_H_

#include "resource.h"       // main symbols
#include "DlgBase.h"

/////////////////////////////////////////////////////////////////////////////
// CDlgAddConfServer
class CDlgAddConfServer : 
	public CDialogImpl<CDlgAddConfServer>
{
public:
	CDlgAddConfServer();
	~CDlgAddConfServer();

	enum { IDD = IDD_DLGADDCONFSERVER };

	DECLARE_MY_HELP;

// Members
public:
	BSTR		m_bstrLocation;
	BSTR		m_bstrServer;

// Operations
public:
	void		UpdateData( bool bSaveAndValidate );
	void		LoadDefaultServers( HWND hWndList );

// Implementation
public:
BEGIN_MSG_MAP(CDlgAddConfServer)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	COMMAND_ID_HANDLER(IDC_BTN_ADD_ILS_SERVER, OnOK)
	COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
	COMMAND_HANDLER(IDC_EDT_NAME, CBN_EDITCHANGE, OnEdtNameChange)
	COMMAND_HANDLER(IDC_EDT_NAME, CBN_SELCHANGE, OnSelChange)
	MESSAGE_MY_HELP
END_MSG_MAP()

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnEdtNameChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnSelChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
};

#endif //__DLGADDCONFSERVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\dlgaddcsvr.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// DlgAddConfServer.cpp : Implementation of CDlgAddConfServer
#include "stdafx.h"
#include "TapiDialer.h"
#include "AVTapi.h"
#include "DlgAddCSvr.h"

/////////////////////////////////////////////////////////////////////////////
// CDlgAddConfServer

IMPLEMENT_MY_HELP(CDlgAddConfServer)

CDlgAddConfServer::CDlgAddConfServer()
{
	m_bstrLocation = m_bstrServer = NULL;
}

CDlgAddConfServer::~CDlgAddConfServer()
{
	SysFreeString( m_bstrLocation );
	SysFreeString( m_bstrServer );
}

void CDlgAddConfServer::UpdateData( bool bSaveAndValidate )
{
	USES_CONVERSION;

	if ( bSaveAndValidate )
	{
		// Retrieve data
		SysFreeString( m_bstrServer );
		GetDlgItemText( IDC_EDT_NAME, m_bstrServer );
	}
	else
	{
		LoadDefaultServers( GetDlgItem(IDC_EDT_NAME) );		

		// Set any default text the author specified, otherwise select the first item in
		// the list box
		if ( m_bstrServer && SysStringLen(m_bstrServer) )
		{
			SetDlgItemText( IDC_EDT_NAME, OLE2CT(m_bstrServer) );
		}
		else if ( SendDlgItemMessage(IDC_EDT_NAME, CB_GETCOUNT, 0, 0) >= 0 )
		{
			SendDlgItemMessage( IDC_EDT_NAME, CB_SETCURSEL, 0, 0 );
			SendDlgItemMessage( IDC_EDT_NAME, CB_SETEDITSEL, 0, MAKELPARAM(0, -1) );
		}

		::EnableWindow( GetDlgItem(IDC_BTN_ADD_ILS_SERVER), (BOOL) (::GetWindowTextLength(GetDlgItem(IDC_EDT_NAME)) > 0) );
	}
}

LRESULT CDlgAddConfServer::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	UpdateData( false );
	return true;  // Let the system set the focus
}

LRESULT CDlgAddConfServer::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	UpdateData( true );
	EndDialog(IDOK);
	return 0;
}

LRESULT CDlgAddConfServer::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	EndDialog(wID);
	return 0;
}

LRESULT CDlgAddConfServer::OnEdtNameChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	::EnableWindow( GetDlgItem(IDC_BTN_ADD_ILS_SERVER), (BOOL) (::GetWindowTextLength(GetDlgItem(IDC_EDT_NAME)) > 0) );
	return 0;
}

void CDlgAddConfServer::LoadDefaultServers( HWND hWndList )
{
	USES_CONVERSION;
	_ASSERT( hWndList );
	if ( !hWndList ) return;

	// Load the default servers into the dialog
	CComPtr<IAVTapi> pAVTapi;
	if ( SUCCEEDED(_Module.get_AVTapi(&pAVTapi)) )
	{
		IConfExplorer *pIConfExplorer;
		if ( SUCCEEDED(pAVTapi->get_ConfExplorer(&pIConfExplorer)) )
		{
			ITRendezvous *pITRend;
			if ( SUCCEEDED(pIConfExplorer->get_ITRendezvous((IUnknown **) &pITRend)) )
			{
				IEnumDirectory *pEnum = NULL;
				if ( SUCCEEDED(pITRend->EnumerateDefaultDirectories(&pEnum)) && pEnum )
				{
					ITDirectory *pDir = NULL;
					while ( (pEnum->Next(1, &pDir, NULL) == S_OK) && pDir )
					{
						// Look for ILS servers
						DIRECTORY_TYPE nDirType;
						if ( SUCCEEDED(pDir->get_DirectoryType(&nDirType)) && (nDirType == DT_ILS) )
						{
							BSTR bstrName = NULL;
							pDir->get_DisplayName( &bstrName );
							if ( bstrName && SysStringLen(bstrName) )
								::SendMessage( hWndList, CB_ADDSTRING, 0, (LPARAM) OLE2CT(bstrName) );

							SysFreeString( bstrName );
						}

						pDir->Release();
						pDir = NULL;
					}
					pEnum->Release();
				}
				pITRend->Release();
			}
			pIConfExplorer->Release();
		}
	}
}

LRESULT CDlgAddConfServer::OnSelChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	bHandled = false;
	::EnableWindow( GetDlgItem(IDC_BTN_ADD_ILS_SERVER), true );
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\detailslist.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////
// DetailsList.h
//

#ifndef __DETAILSLIST_H__
#define __DETAILSLIST_H__

// FWD define
class CConfExplorerDetailsView;

/////////////////////////////////////////////////////////////////////////////
// CDetailsList
class CDetailsList : 
	public CWindowImpl<CDetailsList>
{
public:
	CDetailsList();

// Members
public:
	CConfExplorerDetailsView		*m_pDetailsView;


BEGIN_MSG_MAP(CDetailsList)
	NOTIFY_CODE_HANDLER(LVN_GETDISPINFO, OnGetDispInfo)
	NOTIFY_CODE_HANDLER(LVN_COLUMNCLICK, OnColumnClicked)
END_MSG_MAP()

	LRESULT OnGetDispInfo(WPARAM wParam, LPNMHDR lpnmHdr, BOOL& bHandled);
	LRESULT OnColumnClicked(WPARAM wParam, LPNMHDR lpnmHdr, BOOL& bHandled);
};

#endif //__DETAILSLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\dlgaddloc.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// DlgAddLocation.cpp : Implementation of CDlgAddLocation
#include "stdafx.h"
#include "DlgAddLoc.h"

/////////////////////////////////////////////////////////////////////////////
// CDlgAddLocation

IMPLEMENT_MY_HELP(CDlgAddLocation)

CDlgAddLocation::CDlgAddLocation()
{
	m_bstrLocation = NULL;
}

CDlgAddLocation::~CDlgAddLocation()
{
	SysFreeString( m_bstrLocation );
}

void CDlgAddLocation::UpdateData( bool bSaveAndValidate )
{
	USES_CONVERSION;

	if ( bSaveAndValidate )
	{
		// Retrieve data
		SysFreeString( m_bstrLocation );
		GetDlgItemText( IDC_EDT_LOCATION, m_bstrLocation );
	}
	else
	{
		// Set data
		SetDlgItemText( IDC_EDT_LOCATION, OLE2CT(m_bstrLocation) );
		::EnableWindow( GetDlgItem(IDC_BTN_ADD_NEW_FOLDER), (BOOL) (::GetWindowTextLength(GetDlgItem(IDC_EDT_LOCATION)) > 0) );
	}
}

LRESULT CDlgAddLocation::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	UpdateData( false );
	return true;
}

LRESULT CDlgAddLocation::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	UpdateData( true );
	EndDialog(IDOK);
	return 0;
}

LRESULT CDlgAddLocation::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	EndDialog(wID);
	return 0;
}

LRESULT CDlgAddLocation::OnEdtLocationChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	::EnableWindow( GetDlgItem(IDC_BTN_ADD_NEW_FOLDER), (BOOL) (::GetWindowTextLength(GetDlgItem(IDC_EDT_LOCATION)) > 0) );
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\dialer.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by avDialer.rc
//
#define IDH_DRIVER_MISSING_STATIC_LIST  1021
#define IDH_OPTIONS_VIDEO_COMBO_DEVICE  1144
#define IDH_OPTIONS_VIDEO_BUTTON_SOURCE 1145
#define IDH_OPTIONS_VIDEO_BUTTON_DISPLAY 1146
#define IDH_OPTIONS_VIDEO_BUTTON_FORMAT 1147
#define IDH_OPTIONS_VIDEO_STATIC_VIDEOFRAME 1148
#define IDH_SPEEDDIAL_ADD_RADIO_NETCALL 1157
#define IDH_SPEEDDIAL_ADD_RADIO_PHONECALL 1158
#define IDH_SPEEDDIAL_ADD_RADIO_MULTICASTCONFERENCE 1159
#define IDH_OPTIONS_VIDEO_CHECK_AUTOPREVIEW 2087
#define IDH_SPEEDDIAL_MORE_LIST_ADDRESSES 3125
#define IDH_SPEEDDIAL_MORE_BUTTON_PLACECALL 3126
#define IDH_SPEEDDIAL_MORE_BUTTON_EDITLIST 3127
#define IDH_SPEEDDIAL_EDIT_BUTTON_MOVEUP 3128
#define IDH_SPEEDDIAL_EDIT_BUTTON_MOVEDOWN 3129
#define IDH_SPEEDDIAL_EDIT_BUTTON_REMOVE 3130
#define IDH_SPEEDDIAL_EDIT_LIST_ENTRIES 3131
#define IDH_SPEEDDIAL_EDIT_BUTTON_EDIT  3135
#define IDH_SPEEDDIAL_EDIT_BUTTON_ADD   3136
#define IDH_SPEEDDIAL_ADD_EDIT_DISPLAYNAME 3201
#define IDH_SPEEDDIAL_ADD_EDIT_ADDRESS  3203
#define IDH_SELECTADDRESS_BUTTON_PLACECALL 1180
#define IDH_SELECTADDRESS_BUTTON_BROWSE 1181
#define IDH_SELECTADDRESS_LISTBOX_NAMES 1182
#define IDH_SELECTADDRESS_LISTCTRL_ADDRESSES 1183
#define IDH_SELECTADDRESS_STATIC_NAMES  1184
#define IDH_SELECTADDRESS_STATIC_ADDRESSES 1185
//This is from TAPIdialer.rc. All new stuff.
#define IDH_EDT_TRUSTEE                 5231
#define IDH_RDO_ADDADMIN                5232
#define IDH_RDO_ADDPARTICIPANT          5233
#define IDH_RDO_ADDEXCLUDE              5234
#define IDH_EDIT_NAME                   5205
#define IDH_EDIT_DESCRIPTION            5206
#define IDH_CHECK_ENCRYPT               5207
#define IDH_EDIT_OWNER                  5208
#define IDH_DTP_STARTDATE               5219
#define IDH_DTP_STARTTIME               5220
#define IDH_DTP_STOPTIME                5221
#define IDH_DTP_STOPDATE                5222
#define IDH_LST_PERMISSIONS             5223
#define IDH_RDO_ADMIN                   5224
#define IDH_RDO_PARTICIPANT             5225
#define IDH_RDO_EXCLUDE                 5226
#define IDH_BTN_ADDACE                  5227
#define IDH_BTN_REMOVEACE               5228
#define IDH_LST_CONFS                   212
#define IDH_CBO_ADDRESS                 204
#define IDH_RDO_POTS                    228
#define IDH_RDO_INTERNET                229
#define IDH_RDO_CONF                    230
#define IDH_CBO_LOCATION                247
#define IDH_BTN_TELEPHONY_CPL           248
#define IDH_LBL_POTS                    240
#define IDH_LBL_INTERNET                241
#define IDH_LBL_CONF                    242
#define IDH_CBO_POTS                    225
#define IDH_CBO_IPTELEPHONY             226
#define IDH_CBO_IPCONF                  227
#define IDH_LBL_CALLTYPE                243
#define IDH_CBO_CALLTYPE                232
#define IDH_LBL_AUDIO_IN                237
#define IDH_LBL_AUDIO_OUT               238
#define IDH_LBL_VIDEO_IN                239
#define IDH_CBO_AUDIO_IN                234
#define IDH_CBO_AUDIO_OUT               235
#define IDH_CBO_VIDEO_IN                236
#define IDH_CHK_VIDEO_OUT               249
#define IDH_LBL_MAX_WINDOWS             250
#define IDH_EDT_MAX_WINDOWS             5240
#define IDH_EDT_NAME                    208
#define IDH_EDT_LOCATION                218
#define	IDH_JOIN_CONFERENCE_JOIN		254
#define	IDH_BTN_MMSYS_CPL				259
#define IDH_BTN_ADD_ILS_SERVER			6002
#define IDH_BTN_ADD_NEW_FOLDER			6003
#define IDH_RDO_PREFER_POTS				6004
#define IDH_RDO_PREFER_INTERNET			6005
#define IDH_RDO_PREFER_CONF				6006
#define IDH_BTN_ADD_ACE					6007
#define IDH_CHK_ADD_SPEEDDIAL			6008
#define IDH_CHK_USBALWAYS               279
#define IDH_CHK_AEC                     280
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\dlgaddloc.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// DlgAddLocation.h : Declaration of the CDlgAddLocation

#ifndef __DLGADDLOC_H_
#define __DLGADDLOC_H_

#include "resource.h"       // main symbols
#include "DlgBase.h"

/////////////////////////////////////////////////////////////////////////////
// CDlgAddLocation
class CDlgAddLocation : 
	public CDialogImpl<CDlgAddLocation>
{
public:
	CDlgAddLocation();
	~CDlgAddLocation();

	enum { IDD = IDD_DLGADDLOCATION };

	DECLARE_MY_HELP

// Members
public:
	BSTR		m_bstrLocation;

// Operations
public:
	void		UpdateData( bool bSaveAndValidate );

// Implementation
public:
BEGIN_MSG_MAP(CDlgAddLocation)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	COMMAND_ID_HANDLER(IDC_BTN_ADD_NEW_FOLDER, OnOK)
	COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
	COMMAND_HANDLER(IDC_EDT_LOCATION, EN_CHANGE, OnEdtLocationChange)
	MESSAGE_MY_HELP
END_MSG_MAP()

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnEdtLocationChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
};

#endif //__DLGADDLOC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\crtreeview.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// ConfRoomTreeView.h : Declaration of the CConfRoomTreeView

#ifndef __CONFROOMTREEVIEW_H_
#define __CONFROOMTREEVIEW_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CConfRoomTreeView
class ATL_NO_VTABLE CConfRoomTreeView : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CConfRoomTreeView, &CLSID_ConfRoomTreeView>,
	public IConfRoomTreeView
{
// Friends
friend class CRoomTreeView;

// Enumerations
public:
	typedef enum tag_ImageType_t
	{
		IMAGE_ROOT,
		IMAGE_OUT_STREAMING,
		IMAGE_IN_STREAMING,
		IMAGE_OUT,
		IMAGE_IN,
	} ImageType;

	typedef enum tag_StateType_t
	{
		STATE_NONE,
		STATE_SELECTED,
		STATE_BROKEN,
		STATE_SELECTEDBROKEN,
	} StateType_t;

// Construction
public:
	CConfRoomTreeView();
	void FinalRelease();

// Members
public:
	HWND			m_wndTree;
protected:
	IConfRoom		*m_pIConfRoom;

// Operations
protected:
	void			AddParticipants();

// Implementation
public:
DECLARE_NOT_AGGREGATABLE(CConfRoomTreeView)

BEGIN_COM_MAP(CConfRoomTreeView)
	COM_INTERFACE_ENTRY(IConfRoomTreeView)
END_COM_MAP()

// IConfRoomTreeView
public:
	STDMETHOD(UpdateRootItem)();
	STDMETHOD(SelectParticipant)(ITParticipant *pParticipant, VARIANT_BOOL bMeParticipant);
	STDMETHOD(UpdateData)(BOOL bSaveAndValidate);
	STDMETHOD(get_hWnd)(/*[out, retval]*/ HWND *pVal);
	STDMETHOD(put_hWnd)(/*[in]*/ HWND newVal);
	STDMETHOD(get_ConfRoom)(/*[out, retval]*/ IConfRoom **ppVal);
	STDMETHOD(put_ConfRoom)(/*[in]*/ IConfRoom * newVal);
};

#endif //__CONFROOMTREEVIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\dlgaddr.h ===
// DlgAddr.h : Declaration of the CDlgGetAddress

#ifndef __DLGGETADDRESS_H_
#define __DLGGETADDRESS_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CDlgGetAddress
class CDlgGetAddress : 
	public CDialogImpl<CDlgGetAddress>
{
public:
	CDlgGetAddress();
	~CDlgGetAddress();

	enum { IDD = IDD_DLGGETADDRESS };

// Attributes
public:
	BSTR		m_bstrAddress;

// Operations
public:
	void		UpdateData( bool bSaveAndValidate );

BEGIN_MSG_MAP(CDlgGetAddress)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	COMMAND_ID_HANDLER(IDOK, OnOK)
	COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
	COMMAND_HANDLER(IDC_EDT_ADDRESS, EN_CHANGE, OnEdtAddressChange)
END_MSG_MAP()

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnEdtAddressChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
};

#endif //__DLGGETADDRESS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\dlgaddr.cpp ===
// DlgAddr.cpp : Implementation of CDlgGetAddress
#include "stdafx.h"
#include "DlgAddr.h"

/////////////////////////////////////////////////////////////////////////////
// CDlgGetAddress

CDlgGetAddress::CDlgGetAddress()
{
	m_bstrAddress = NULL;
}

CDlgGetAddress::~CDlgGetAddress()
{
	SysFreeString( m_bstrAddress );
}

LRESULT CDlgGetAddress::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	return 1;  // Let the system set the focus
}

LRESULT CDlgGetAddress::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	UpdateData( true );

	EndDialog(wID);
	return 0;
}

LRESULT CDlgGetAddress::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	UpdateData( true );

	EndDialog(wID);
	return 0;
}

void CDlgGetAddress::UpdateData( bool bSaveAndValidate )
{
	USES_CONVERSION;

	if ( bSaveAndValidate )
	{
		// Save data to variables
		GetDlgItemText( IDC_EDT_ADDRESS, m_bstrAddress );
	}
	else
	{
		// Load data into the controls
		::SetWindowText( GetDlgItem(IDC_EDT_ADDRESS), OLE2CT(m_bstrAddress) );

		// Update the "okay" button initially
		BOOL bHandled;
		OnEdtAddressChange( EN_CHANGE, IDC_EDT_ADDRESS, GetDlgItem(IDC_EDT_ADDRESS), bHandled );
	}
}

LRESULT CDlgGetAddress::OnEdtAddressChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	::EnableWindow( GetDlgItem(IDC_EDT_ADDRESS), (BOOL) (::GetWindowTextLength(GetDlgItem(IDC_EDT_ADDRESS)) > 0) );
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\dlgcall.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// DlgPlaceCall.cpp : Implementation of CDlgPlaceCall
#include "stdafx.h"
#include "TapiDialer.h"
#include "AVTapi.h"
#include "DlgCall.h"
#include "ThreadDial.h"

#define IMAGE_WIDTH        16
#define IMAGE_MARGIN    5

int AddressTypeToImageListItem( DWORD dwAddressType )
{
    switch ( dwAddressType )
    {
        case LINEADDRESSTYPE_PHONENUMBER:        return 0;
        case LINEADDRESSTYPE_SDP:                return 2;
    }

    return 1;
}

CRedialEntry::CRedialEntry()
{
    m_bstrName = NULL;
    m_bstrAddress = NULL;
    m_dwAddressType = 0;
}

CRedialEntry::CRedialEntry( LPCTSTR szName, LPCTSTR szAddress, DWORD dwAddressType, CAVTapi::MediaTypes_t nType )
{
    USES_CONVERSION;
    m_bstrName = SysAllocString( T2COLE(szName) );
    m_bstrAddress = SysAllocString( T2COLE(szAddress) );
    m_dwAddressType = dwAddressType;
    m_nMediaType = nType;
}

CRedialEntry::~CRedialEntry()
{
    SysFreeString( m_bstrName );
    SysFreeString( m_bstrAddress );
}


/////////////////////////////////////////////////////////////////////////////
// CDlgPlaceCall

IMPLEMENT_MY_HELP(CDlgPlaceCall)

CDlgPlaceCall::CDlgPlaceCall()
{
    m_bstrName = NULL;
    m_bstrAddress = NULL;
    m_dwAddressType = LINEADDRESSTYPE_IPADDRESS;
    m_hIml = NULL;
    m_bAutoSelect = true;
    m_bAddToSpeeddial = false;

    m_bAllowPOTS = true;
    m_bAllowIP = true;
    m_bUSBFirstUse = true;
}

CDlgPlaceCall::~CDlgPlaceCall()
{
    SysFreeString( m_bstrName );
    SysFreeString( m_bstrAddress );
    if ( m_hIml ) ImageList_Destroy( m_hIml );
    DELETE_LIST(m_lstRedials);
}

void CDlgPlaceCall::UpdateData( bool bSaveAndValidate /*= false*/)
{
    USES_CONVERSION;
    int nSel;

    if ( bSaveAndValidate )
    {
        // Retrieve address from dialog box
        SysFreeString( m_bstrAddress );
        nSel = SendDlgItemMessage( IDC_CBO_ADDRESS, CB_GETCURSEL, 0, 0 );
        if ( nSel != CB_ERR )
        {
            CRedialEntry *pEntry = (CRedialEntry *) SendDlgItemMessage( IDC_CBO_ADDRESS, CB_GETITEMDATA, nSel, 0 );
            if ( pEntry )
            {
                m_bstrAddress = SysAllocString( pEntry->m_bstrAddress );
                m_bstrName = SysAllocString( pEntry->m_bstrName );
            }
        }
        else
        {
            GetDlgItemText( IDC_CBO_ADDRESS, m_bstrAddress );
            SysFreeString( m_bstrName );
            m_bstrName = NULL;
        }

        if ( IsDlgButtonChecked(IDC_RDO_POTS) )
            m_dwAddressType =  LINEADDRESSTYPE_PHONENUMBER;
        else
            m_dwAddressType = LINEADDRESSTYPE_IPADDRESS;

        m_bAddToSpeeddial = (bool) (IsDlgButtonChecked(IDC_CHK_ADD_SPEEDDIAL) != 0);
    }
    else
    {
        // Select the item from the redial list
        nSel = (int) SendDlgItemMessage(IDC_CBO_ADDRESS, CB_FINDSTRINGEXACT, 0, (LPARAM) OLE2CT(m_bstrAddress));
        if ( ((nSel >= 0) && (m_dwAddressType == ((CRedialEntry *) SendDlgItemMessage(IDC_CBO_ADDRESS, CB_GETITEMDATA, nSel, 0))->m_dwAddressType)) ||
             !m_bstrAddress || !SysStringLen(m_bstrAddress) )
        {
            // Correct for LB_ERR case
            nSel = max( 0, nSel );
            SendDlgItemMessage( IDC_CBO_ADDRESS, CB_SETCURSEL, nSel );        
        }
        else
        {
            SetDlgItemText( IDC_CBO_ADDRESS, OLE2CT(m_bstrAddress) );
            SelectAddressType( m_dwAddressType );
            return;
        }

        CheckDlgButton( IDC_CHK_ADD_SPEEDDIAL, m_bAddToSpeeddial );

        BOOL bHandled = false;
        OnAddressChange(0, 0, 0, bHandled);
    }    
}

LRESULT CDlgPlaceCall::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // Create the image list
    m_hIml = ImageList_LoadBitmap( _Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_MEDIA_TYPES), IMAGE_WIDTH, 0, RGB(255, 0, 255) );

    // Check and see what types of addresses we support and enable the check boxes appropriately...
    CAVTapi *pAVTapi;
    if ( SUCCEEDED(_Module.GetAVTapi(&pAVTapi)) )
    {
        // Do we support POTS?
        ITAddress *pITAddress;
        if ( SUCCEEDED(pAVTapi->GetAddress(LINEADDRESSTYPE_PHONENUMBER, false, &pITAddress)) )
        {
            pITAddress->Release();
        }
        else
        {
            ::EnableWindow( GetDlgItem(IDC_RDO_POTS), false );
            m_bAllowPOTS = false;
        }

        // Do we support IP?
        if ( SUCCEEDED(pAVTapi->GetAddress(LINEADDRESSTYPE_IPADDRESS, false, &pITAddress)) )
        {
            pITAddress->Release();
        }
        else
        {
            ::EnableWindow( GetDlgItem(IDC_RDO_INTERNET), false );
            m_bAllowIP = false;
        }

        (dynamic_cast<IUnknown *> (pAVTapi))->Release();
    }

    LoadRedialList();
    UpdateData( false );
    UpdateWelcomeText();

    // Message use if we don't have any addresses to select from
    if ( !m_bAllowPOTS && !m_bAllowIP )
    {
        ShowWindow( SW_SHOW );
        _Module.DoMessageBox( IDS_MSG_NOADDRESSESTODIAL, MB_ICONINFORMATION, true );
        PostMessage( WM_CLOSE, 0, 0 );
        return false;
    }


    ::SetFocus( GetDlgItem(IDC_CBO_ADDRESS) );
    return false;
}

LRESULT CDlgPlaceCall::OnBtnPushed(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    // IDOK mapping -- this is for context help
    if ( wID == IDC_BTN_PLACECALL )
        wID = IDOK;

    UpdateData( true );
    EndDialog(wID);
    return 0;
}

LRESULT CDlgPlaceCall::OnAddressChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    bool bSetAddressType = false;
    long nSel = SendDlgItemMessage( IDC_CBO_ADDRESS, CB_GETCURSEL );
    if ( nSel >= 0 )
        bSetAddressType = SelectAddressType( ((CRedialEntry *) SendDlgItemMessage(IDC_CBO_ADDRESS, CB_GETITEMDATA, nSel))->m_dwAddressType );
        
    EnableOkButton( nSel );

    // Default to last address type
    if ( !bSetAddressType )
    {
        DWORD dwPreferred = LINEADDRESSTYPE_IPADDRESS;
        CComPtr<IAVTapi> pAVTapi;
        if ( SUCCEEDED(_Module.get_AVTapi(&pAVTapi)) )
            pAVTapi->get_dwPreferredMedia( &dwPreferred );

        SelectAddressType( dwPreferred );
    }

    return 0;
}

LRESULT CDlgPlaceCall::OnEdtAddressChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    int nLen = ::GetWindowTextLength( GetDlgItem(IDC_CBO_ADDRESS) );
    EnableOkButton( nLen - 1 );

    // What type of address do we have?
    if ( nLen > 0 )
    {
        TCHAR szText[255];
        ::GetWindowText( GetDlgItem(IDC_CBO_ADDRESS), szText, ARRAYSIZE(szText) - 1 );
        DWORD dwAddressType = _Module.GuessAddressType( szText );
        if ( dwAddressType == LINEADDRESSTYPE_SDP ) dwAddressType = LINEADDRESSTYPE_DOMAINNAME;

        if ( m_bAutoSelect )        
            SelectAddressType( dwAddressType );
    }

    return 0;
}

bool CDlgPlaceCall::SelectAddressType( DWORD dwData )
{
    UINT nCheck;

    // Select the address type based on the item data
    switch ( dwData )
    {
        case LINEADDRESSTYPE_PHONENUMBER:
            if ( ::IsWindowEnabled(GetDlgItem(IDC_RDO_POTS)) )
                nCheck = IDC_RDO_POTS;
            else
                nCheck = IDC_RDO_INTERNET;
            break;

        default:
            if ( ::IsWindowEnabled(GetDlgItem(IDC_RDO_INTERNET)) )
                nCheck = IDC_RDO_INTERNET;
            else
                nCheck = IDC_RDO_POTS;
            break;
    }

    // Now put the check in place
    bool bRet = (CheckRadioButton(IDC_RDO_POTS, IDC_RDO_INTERNET, nCheck) == TRUE);
    m_bAutoSelect = true;
    return bRet;
}

LRESULT CDlgPlaceCall::OnMediaRadio(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    m_bAutoSelect = false;
    int nLen = ::GetWindowTextLength( GetDlgItem(IDC_CBO_ADDRESS) );
    EnableOkButton( nLen - 1 );
    UpdateWelcomeText();
    return 0;
}

void CDlgPlaceCall::UpdateWelcomeText()
{
    TCHAR szText[255];
    LoadString( _Module.GetResourceInstance(),
                IsDlgButtonChecked(IDC_RDO_POTS) ? IDS_DLG_PHONENUMBER : IDS_DLG_INTERNETCALL,
                szText, ARRAYSIZE(szText) );

    ::SetWindowText( GetDlgItem(IDC_LBL_WELCOME), szText );
}


//////////////////////////////////////////////////////////////////////////////////////
// Registry parsing stuff here
//
void CDlgPlaceCall::LoadRedialList()
{
    CRegKey regKey;
    TCHAR szTemp[500];

    ::LoadString( _Module.GetResourceInstance(), IDN_REG_REDIAL_KEY, szTemp, ARRAYSIZE(szTemp) );
    if ( regKey.Open(HKEY_CURRENT_USER, szTemp, KEY_READ) == ERROR_SUCCESS )
    {
        // defaults for index and max
        DWORD dwIndex = 1, dwMax = 10;
        ::LoadString( _Module.GetResourceInstance(), IDN_REG_REDIAL_INDEX, szTemp, ARRAYSIZE(szTemp) );
        regKey.QueryValue( dwIndex, szTemp );

        ::LoadString( _Module.GetResourceInstance(), IDN_REG_REDIAL_MAX, szTemp, ARRAYSIZE(szTemp) );
        regKey.QueryValue( dwMax, szTemp );

        // Load up redial strings and add to list ones of the appropriate media and address type
        TCHAR szSubKey[255];
        dwIndex = min(dwMax, max(1, dwIndex));
        for ( int i = 0; i < (int) dwMax; i++ )
        {
            // First retrieve the value stored ind Redial#n slot
            ::LoadString( _Module.GetResourceInstance(), IDN_REG_REDIAL_ENTRY, szTemp, ARRAYSIZE(szTemp) );
            _stprintf( szSubKey, szTemp, (int) ((dwIndex + i) % dwMax) ? ((dwIndex + i) % dwMax) : dwMax );
            DWORD dwSize = ARRAYSIZE(szTemp);
            if ( regKey.QueryValue(szTemp, szSubKey, &dwSize) == ERROR_SUCCESS )
            {
                // Parse redial information for [Media Type], [Address Type] and [Address]
                TCHAR szMedia[100], szAddrType[100], szName[255];
                if ( ParseRedialEntry(szTemp, szMedia, szAddrType, szSubKey, szName) )
                {
                    for ( int j = 0; j < CAVTapi::MAX_MEDIA_TYPES; j++ )
                    {
                        // Validate the [Media Type]
                        ::LoadString( _Module.GetResourceInstance(), IDN_REG_MEDIATYPE_POTS + j, szTemp, ARRAYSIZE(szTemp) );
                        if ( !_tcsicmp(szTemp, szMedia) )
                        {
                            // Validate the [Address Type]
                            for ( int k = 0; k < CAVTapi::MAX_ADDRESS_TYPES; k++ )
                            {
                                // Skip conferences and disabled lines
                                if ( k == 0 ) continue;
                                if ( !m_bAllowIP && (k > 0) && (k < 4) ) continue;
                                if ( !m_bAllowPOTS && (k == 4) ) continue;

                                ::LoadString( _Module.GetResourceInstance(), IDN_REG_ADDRTYPE_CONFERENCE + k, szTemp, ARRAYSIZE(szTemp) );
                                if ( !_tcsicmp(szTemp, szAddrType) )
                                {
                                    CRedialEntry *pEntry = new CRedialEntry(szName, szSubKey, CAVTapi::arAddressTypes[k], (CAVTapi::MediaTypes_t) j );
                                    if ( pEntry )
                                    {
                                        m_lstRedials.push_back( pEntry );

                                        // We've found a match, add to the drop list; use the item data to store the address type
                                        int nInd = SendDlgItemMessage( IDC_CBO_ADDRESS, CB_ADDSTRING, 0, (LPARAM) szName );
                                        if ( nInd >= 0 )
                                            SendDlgItemMessage( IDC_CBO_ADDRESS, CB_SETITEMDATA, (WPARAM) nInd, LPARAM(pEntry) );
                                    }
                                    break;
                                }
                            }
                            break;
                        }
                    }
                }
            }
        }
    }
}

bool CDlgPlaceCall::ParseRedialEntry( LPTSTR szText, LPTSTR szParam1, LPTSTR szParam2, LPTSTR szParam3, LPTSTR szParam4 )
{
    USES_CONVERSION;

    GetToken( 1, _T("\","), szText, szParam1 );
    GetToken( 2, _T("\","), szText, szParam2 );
    GetToken( 3, _T("\","), szText, szParam3 );
    GetToken( 4, _T("\","), szText, szParam4 );

    return *szParam1 && *szParam2 && *szParam3 && *szParam4;
}


////////////////////////////////////////////////////////////////////////////////////////
// Owner draw stuff here
//
LRESULT CDlgPlaceCall::OnDrawItem(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if ( wParam == IDC_CBO_ADDRESS )
    {
        LPDRAWITEMSTRUCT lpDis = (LPDRAWITEMSTRUCT) lParam;
        COLORREF crText, crBk;

        // Draw the selection rectangle
        if ( (lpDis->itemState & ODS_SELECTED) != 0 )
        {
            crText = SetTextColor( lpDis->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT) );
            crBk = SetBkColor( lpDis->hDC, GetSysColor(COLOR_HIGHLIGHT) );
        }

#define BMP_MARGIN        3
#define BMP_WIDTH        16
#define BMP_HEIGHT        16
#define TEXT_MARGIN        (BMP_MARGIN*2 + BMP_WIDTH)

        int yOffset = max(0, (((lpDis->rcItem.bottom - lpDis->rcItem.top) - BMP_HEIGHT) / 2));
        ImageList_Draw( m_hIml, AddressTypeToImageListItem(((CRedialEntry *) lpDis->itemData)->m_dwAddressType),
                        lpDis->hDC, BMP_MARGIN, lpDis->rcItem.top + yOffset, ILD_NORMAL );

        // Print out the text for the item
        int nLen = (int) SendDlgItemMessage( IDC_CBO_ADDRESS, CB_GETLBTEXTLEN, (WPARAM) lpDis->itemID );
        if ( nLen > 0 )
        {
            TCHAR *lpszText = new TCHAR[nLen + 1];
            if ( lpszText )
            {
                TEXTMETRIC tm;
                GetTextMetrics( lpDis->hDC, &tm );
                int yOffset = max(0, (((lpDis->rcItem.bottom - lpDis->rcItem.top) - tm.tmHeight) / 2));
                RECT rcText = lpDis->rcItem;
                rcText.left += TEXT_MARGIN;

                SendDlgItemMessage( IDC_CBO_ADDRESS, CB_GETLBTEXT, (WPARAM) lpDis->itemID, (LPARAM) lpszText );
                ExtTextOut( lpDis->hDC, rcText.left + BMP_MARGIN, rcText.top + yOffset, ETO_OPAQUE | ETO_CLIPPED, &rcText, lpszText, nLen, NULL );
                delete lpszText;
            }
        }

        // Restore DC to current colors
        if ( lpDis->itemState & ODS_SELECTED )
        {
            SetTextColor( lpDis->hDC, crText );
            SetBkColor( lpDis->hDC, crBk );
        }

        bHandled = true;
    }

    return 0;
}

LRESULT CDlgPlaceCall::OnPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // Must have valid image list to work
    if ( !m_hIml ) return 0;

    PAINTSTRUCT ps;
    HDC hDC = BeginPaint( &ps );
    if ( !hDC ) return 0;

    // IDS of items to paint
    UINT nID[] = { IDC_RDO_POTS,
                   IDC_RDO_INTERNET };
    
    // Paint bitmaps next to corresponding images
    for ( int i = 0; i < ARRAYSIZE(nID); i++ )
    {
        RECT rc;
        ::GetWindowRect( GetDlgItem(nID[i]), &rc );
        ScreenToClient( &rc );

        // Paint image of rect
        ImageList_Draw( m_hIml, i, hDC, rc.left - (IMAGE_WIDTH + IMAGE_MARGIN), rc.top, ILD_NORMAL );
    }

    EndPaint( &ps );
    bHandled = true;
    return 0;
}

bool CDlgPlaceCall::EnableOkButton( int nSel )
{
    bool bEnable = (bool) (nSel >= 0);

    ::EnableWindow( GetDlgItem(IDC_BTN_PLACECALL), bEnable );
    return bEnable;
}

HRESULT CDlgPlaceCall::KeyPress(long lButton)
{
    if( 0 <= lButton && lButton <=10)
    {
        //
        // Digit, let's put it into the edit box
        // Also we allow the * key
        //

        HWND hWnd = ::GetDlgItem(m_hWnd, IDC_CBO_ADDRESS);
        if(::IsWindow(hWnd) )
        {
            // Select phone number
            CheckRadioButton(IDC_RDO_POTS, IDC_RDO_INTERNET, IDC_RDO_POTS);

            TCHAR szBuffer[MAX_PATH+1];
            _stprintf(szBuffer,_T(""));

            // Delete text if is the first use
            if( m_bUSBFirstUse)
            {
                // Reset the selection
                ::SendMessage( hWnd, CB_SETCURSEL, (WPARAM)-1,0);
                //::SetWindowText( hWnd, szBuffer);
                m_bUSBFirstUse = false;
            }

            // Get the existing text
            ::GetWindowText(hWnd, szBuffer, MAX_PATH);

            TCHAR szKey[2];
            _stprintf( szKey, _T("%d"), lButton);

            // Add the key
            _tcscat( szBuffer, szKey);
            
            // Set text
            ::SetWindowText(hWnd, szBuffer);

            // Move the caret to the end of edit text
            ::SendMessage( hWnd, CB_SETEDITSEL, 0, MAKELPARAM(0,-1));
            ::SendMessage( hWnd, CB_SETEDITSEL, 0, MAKELPARAM(-1,0));

            // Enable OK button
            EnableOkButton( 0 );
        }
    }
    else if( lButton == 11 )
    {
        //
        // Place a call, the button pressed is #
        //

        UpdateData( true );
        EndDialog( IDOK );
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\dlgcall.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// DlgPlaceCall.h : Declaration of the CDlgPlaceCall

#ifndef __DLGPLACECALL_H_
#define __DLGPLACECALL_H_

#include "DlgBase.h"

class CRedialEntry;

#include "resource.h"       // main symbols
#include <list>
using namespace std;
typedef list<CRedialEntry *> REDIALLIST;

class CRedialEntry
{
// Construction
public:
	CRedialEntry();
	CRedialEntry( LPCTSTR szName, LPCTSTR szAddress, DWORD dwAddressType, CAVTapi::MediaTypes_t nType );
	virtual ~CRedialEntry();

// Members
public:
	BSTR					m_bstrName;
	BSTR					m_bstrAddress;
	DWORD					m_dwAddressType;
	CAVTapi::MediaTypes_t	m_nMediaType;
};


/////////////////////////////////////////////////////////////////////////////
// CDlgPlaceCalld
class CDlgPlaceCall : 
	public CDialogImpl<CDlgPlaceCall>
{
// Construction
public:
	CDlgPlaceCall();
	~CDlgPlaceCall();
	enum { IDD = IDD_DLGPLACECALL };

// Members
public:
	BSTR				m_bstrName;
	BSTR				m_bstrAddress;
	DWORD				m_dwAddressType;
	HIMAGELIST			m_hIml;
	REDIALLIST			m_lstRedials;
	bool				m_bAutoSelect;
	bool				m_bAddToSpeeddial;
	bool				m_bAllowPOTS;			// are we POTS capable
	bool				m_bAllowIP;				// are we IP capable
    bool                m_bUSBFirstUse;         // first use of key from USB

    HRESULT KeyPress(long lButton);

// Attributes
public:

// Operations
public:
	void		UpdateData( bool bSaveAndValidate = false);

protected:
	void		LoadRedialList();
	bool		ParseRedialEntry( LPTSTR szText, LPTSTR szParam1, LPTSTR szParam2, LPTSTR szParam3, LPTSTR szParam4 );
	bool		SelectAddressType( DWORD dwData );
	bool		EnableOkButton( int nSel );

// Operations
protected:
	void		UpdateWelcomeText();

// Implementation
public:
DECLARE_MY_HELP

BEGIN_MSG_MAP(CDlgPlaceCall)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	MESSAGE_HANDLER(WM_DRAWITEM, OnDrawItem)
	MESSAGE_HANDLER(WM_PAINT, OnPaint)
	COMMAND_HANDLER(IDC_CBO_ADDRESS, CBN_SELCHANGE, OnAddressChange)
	COMMAND_ID_HANDLER(IDC_BTN_PLACECALL, OnBtnPushed)
	COMMAND_ID_HANDLER(IDCANCEL, OnBtnPushed)
	COMMAND_ID_HANDLER(IDC_RDO_POTS, OnMediaRadio)
	COMMAND_ID_HANDLER(IDC_RDO_INTERNET, OnMediaRadio)
	COMMAND_HANDLER(IDC_CBO_ADDRESS, CBN_EDITCHANGE, OnEdtAddressChange)
	MESSAGE_MY_HELP
END_MSG_MAP()

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnDrawItem(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnBtnPushed(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnAddressChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnEdtAddressChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnMediaRadio(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
};

#endif //__DLGPLACECALL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\dlgbase.h ===
//////////////////////////////////////////////////////////////////////////////
// DlgBase.h
//

#ifndef __DLGBASE_H__
#define __DLGBASE_H__

extern DWORD aDialerHelpIds[];
extern void MyWinHelp(HWND hWnd, UINT nCmd);
extern void ConvertPropSheetHelp( HWND hWndPropSheet );

extern BOOL GeneralOnHelp( HWND hwndDlg, WPARAM wParam, LPARAM lParam );
extern BOOL GeneralOnContextMenu( HWND hwndDlg, WPARAM wParam, LPARAM lParam );

#define DECLARE_MY_HELP															\
LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);		\
LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);


#define MESSAGE_MY_HELP										\
		MESSAGE_HANDLER(WM_HELP, OnHelp)					\
		MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)

#define IMPLEMENT_MY_HELP(_CLASS_)													\
LRESULT _CLASS_::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)	\
{																					\
	if ( ((HELPINFO *) lParam)->iContextType == HELPINFO_WINDOW )					\
	{																				\
		MyWinHelp( (HWND) ((HELPINFO *) lParam)->hItemHandle, HELP_WM_HELP );		\
		return TRUE;																\
	}																				\
	return FALSE;																	\
}																					\
LRESULT _CLASS_::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)		\
{																							\
	MyWinHelp( m_hWnd, HELP_CONTEXTMENU );											\
	return 0;																				\
}

#endif //__DLGBASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\dlgbase.cpp ===
//////////////////////////////////////////////////////////////////////////
// CDlgBase.cpp
//

#include "stdafx.h"
#include "TapiDialer.h"
#include "AVTapi.h"
#include "Dialer.h"				// Help author generated file
#include "DlgBase.h"

DWORD aDialerHelpIds[] = 
{
	IDC_EDT_TRUSTEE, IDH_EDT_TRUSTEE,
	IDC_RDO_ADDADMIN, IDH_RDO_ADDADMIN,
	IDC_RDO_ADDPARTICIPANT, IDH_RDO_ADDPARTICIPANT,
	IDC_RDO_ADDEXCLUDE, IDH_RDO_ADDEXCLUDE,
	IDC_EDIT_NAME, IDH_EDIT_NAME,
	IDC_EDIT_DESCRIPTION, IDH_EDIT_DESCRIPTION,
	IDC_EDT_NAME, IDH_EDT_NAME,
	IDC_EDT_LOCATION, IDH_EDT_LOCATION,
	IDC_CHECK_ENCRYPT, IDH_CHECK_ENCRYPT,
	IDC_EDIT_OWNER, IDH_EDIT_OWNER,
	IDC_STATIC_OWNER, IDH_EDIT_OWNER,
	IDC_DTP_STARTDATE, IDH_DTP_STARTDATE,
	IDC_DTP_STARTTIME, IDH_DTP_STARTTIME,
	IDC_DTP_STOPTIME, IDH_DTP_STOPTIME,
	IDC_DTP_STOPDATE, IDH_DTP_STOPDATE,
	IDC_LST_PERMISSIONS, IDH_LST_PERMISSIONS,
	IDC_RDO_ADMIN, IDH_RDO_ADMIN,
	IDC_RDO_PARTICIPANT, IDH_RDO_PARTICIPANT,
	IDC_RDO_EXCLUDE, IDH_RDO_EXCLUDE,
	IDC_BTN_ADDACE, IDH_BTN_ADDACE,
	IDC_BTN_REMOVEACE, IDH_BTN_REMOVEACE,
	IDC_LST_CONFS, IDH_LST_CONFS,
	IDC_LBL_WELCOME, IDH_CBO_ADDRESS,
	IDC_CBO_ADDRESS, IDH_CBO_ADDRESS,
	IDC_RDO_POTS, IDH_RDO_POTS,
	IDC_RDO_INTERNET, IDH_RDO_INTERNET,
	IDC_RDO_CONF, IDH_RDO_CONF,
	IDC_CBO_LOCATION, IDH_CBO_LOCATION,
	IDC_BTN_TELEPHONY_CPL, IDH_BTN_TELEPHONY_CPL,
	IDC_LBL_WELCOME_PAGEADDRESS, -1,
	IDC_BTN_MMSYS_CPL, IDH_BTN_MMSYS_CPL,
	IDC_LBL_WELCOME_PAGETERMINALS, -1,
	IDC_LBL_POTS, IDH_LBL_POTS,
	IDC_LBL_INTERNET, IDH_LBL_INTERNET,
	IDC_LBL_CONF, IDH_LBL_CONF,
	IDC_CBO_POTS, IDH_CBO_POTS,
	IDC_CBO_IPTELEPHONY, IDH_CBO_IPTELEPHONY,
	IDC_CBO_IPCONF, IDH_CBO_IPCONF,
	IDC_LBL_CALLTYPE, IDH_LBL_CALLTYPE,
	IDC_CBO_CALLTYPE, IDH_CBO_CALLTYPE,
	IDC_LBL_CALLTYPE, IDH_CBO_CALLTYPE,
	IDC_LBL_AUDIO_IN, IDH_LBL_AUDIO_IN,
	IDC_LBL_AUDIO_OUT, IDH_LBL_AUDIO_OUT,
	IDC_LBL_VIDEO_IN, IDH_LBL_VIDEO_IN,
	IDC_CBO_AUDIO_IN, IDH_CBO_AUDIO_IN,
	IDC_CBO_AUDIO_OUT, IDH_CBO_AUDIO_OUT,
	IDC_CBO_VIDEO_IN, IDH_CBO_VIDEO_IN,
	IDC_CHK_VIDEO_OUT, IDH_CHK_VIDEO_OUT,
	IDC_LBL_MAX_WINDOWS, IDH_LBL_MAX_WINDOWS,
	IDC_EDT_MAX_WINDOWS, IDH_EDT_MAX_WINDOWS,
	IDC_BTN_PLACECALL, IDH_SELECTADDRESS_BUTTON_PLACECALL,
	IDC_BTN_JOIN_CONFERENCE, IDH_JOIN_CONFERENCE_JOIN,
	IDC_BTN_ADD_ILS_SERVER, IDH_BTN_ADD_ILS_SERVER,
	IDC_BTN_ADD_NEW_FOLDER, IDH_BTN_ADD_NEW_FOLDER,
	IDC_ICO_WELCOME_JOIN, -1,
	IDC_LBL_WELCOME_JOIN, -1,
	IDC_ICO_ACTION, -1,
	IDC_FRA_CALLTYPE, -1,
	IDC_RDO_PREFER_POTS, IDH_RDO_PREFER_POTS,
	IDC_RDO_PREFER_INTERNET, IDH_RDO_PREFER_INTERNET,
	IDC_RDO_PREFER_CONF, IDH_RDO_PREFER_CONF,
	IDC_BTN_ADD_ACE, IDH_BTN_ADD_ACE,
	IDC_CHK_ADD_SPEEDDIAL, IDH_CHK_ADD_SPEEDDIAL,
    IDC_CHK_USBALWAYS, IDH_CHK_USBALWAYS,
    IDC_CHK_AEC, IDH_CHK_AEC,
	0, 0
};

/////////////////////////////////////////////////////////////////////////////
void MyWinHelp(HWND hWnd, UINT nCmd) 
{
	TCHAR szWinDir[_MAX_PATH + _MAX_PATH];
	if( GetWindowsDirectory( szWinDir, _MAX_PATH ) == 0)
    {
        return;
    }

	TCHAR szFile[_MAX_PATH];
	LoadString( _Module.GetResourceInstance(), IDS_HELP_PATH, szFile, ARRAYSIZE(szFile) );
	_tcsncat( szWinDir, szFile, _MAX_PATH - 1 );

	if (nCmd == HELP_CONTEXTMENU)
	{
		if (!::WinHelp (hWnd, szWinDir, HELP_CONTEXTMENU, (DWORD_PTR) &aDialerHelpIds))
			_Module.DoMessageBox( IDS_FAILED_TO_LAUNCH_HELP, MB_ICONEXCLAMATION, true );
		return;
	}
	else if (nCmd == HELP_WM_HELP)
	{
		if (!::WinHelp (hWnd, szWinDir, HELP_WM_HELP, (DWORD_PTR) &aDialerHelpIds))
			_Module.DoMessageBox( IDS_FAILED_TO_LAUNCH_HELP, MB_ICONEXCLAMATION, true );
		return;
	}
}

BOOL GeneralOnHelp( HWND hwndDlg, WPARAM wParam, LPARAM lParam )
{
	if ( ((HELPINFO *) lParam)->iContextType == HELPINFO_WINDOW )
	{
		MyWinHelp( (HWND) ((HELPINFO *) lParam)->hItemHandle, HELP_WM_HELP );
		return TRUE;
	}
	return FALSE;
}

BOOL GeneralOnContextMenu( HWND hwndDlg, WPARAM wParam, LPARAM lParam )
{
	MyWinHelp( hwndDlg, HELP_CONTEXTMENU );
	return TRUE;
}

void ConvertPropSheetHelp( HWND hWndPropSheet )
{
	_ASSERT( hWndPropSheet );

	// Change the style of the window to support context help
	SetWindowLongPtr( hWndPropSheet, GWL_EXSTYLE, GetWindowLongPtr(hWndPropSheet, GWL_EXSTYLE) | WS_EX_CONTEXTHELP );

	// Shift all buttons over one place
	UINT arBtns[4] = { IDOK, IDCANCEL, ID_APPLY_NOW, IDHELP };

	for ( int i = 0; i < ARRAYSIZE(arBtns) - 1; i++ )
	{
		HWND hWnd = GetDlgItem( hWndPropSheet, arBtns[i] );
		HWND hWndNew = GetDlgItem( hWndPropSheet, arBtns[i + 1] );

		_ASSERT( hWnd && hWndNew );

		RECT rc;
		GetWindowRect( hWndNew, &rc );
        // --- BUG 305511 ---
		//POINT pt = {rc.left, rc.top };
		//ScreenToClient( hWndPropSheet, &pt );
		//SetWindowPos( hWnd, NULL, pt.x, pt.y, RECTWIDTH(&rc), RECTHEIGHT(&rc), SWP_NOZORDER );
        MapWindowPoints(NULL, hWndPropSheet, (LPPOINT)&rc, 2);
        SetWindowPos( hWnd, NULL, rc.left, rc.top, RECTWIDTH(&rc), RECTHEIGHT(&rc), SWP_NOZORDER );
	}

	// Remove the help button
	HWND hWndHelp = GetDlgItem( hWndPropSheet, (UINT) IDHELP );
	if ( hWndHelp )
		DestroyWindow( hWndHelp );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\dlgcrtalker.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// DlgConfRoomTalker.h : Declaration of the CDlgConfRoomTalker

#ifndef __DLGCONFROOMTALKER_H_
#define __DLGCONFROOMTALKER_H_

// FWD define
class CDlgConfRoomTalker;

#include "resource.h"       // main symbols
#include "CRTalkerWnd.h"

/////////////////////////////////////////////////////////////////////////////
// CDlgConfRoomTalker
class CDlgConfRoomTalker : 
	public CDialogImpl<CDlgConfRoomTalker>
{
// Construction
public:
	CDlgConfRoomTalker();
	~CDlgConfRoomTalker();

	enum { IDD = IDD_DLGCONFROOMTALKER };

// Members
public:
	BSTR				m_bstrCallerID;
	BSTR				m_bstrConfName;
	BSTR				m_bstrCallerInfo;

	CALL_STATE			m_callState;
	CConfRoomTalkerWnd	*m_pConfRoomTalkerWnd;

protected:
	HWND			m_hWndTips;
	TCHAR			*m_pszDetails;
	
// Operations
public:
	void		UpdateData( bool bSaveAndValidate );
	void		UpdateStatusBitmaps();
protected:
	void		AddToolTip( HWND hWndToolTip, const RECT& rc );

// Implementation
public:
BEGIN_MSG_MAP(CDlgConfRoomTalker)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
	MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
	MESSAGE_HANDLER(WM_PAINT, OnPaint)
	MESSAGE_HANDLER(WM_MOUSEMOVE, OnMouse)
	MESSAGE_HANDLER(WM_LBUTTONDOWN, OnMouse)
	MESSAGE_HANDLER(WM_LBUTTONUP, OnMouse)
	MESSAGE_HANDLER(WM_RBUTTONDOWN, OnMouse)
	MESSAGE_HANDLER(WM_RBUTTONUP, OnMouse)
END_MSG_MAP()

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnMouse(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
};

#endif //__DLGCONFROOMTALKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\dlgcrtalk.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// DlgConfRoomTalker.cpp : Implementation of CDlgConfRoomTalker
#include "stdafx.h"
#include "TapiDialer.h"
#include "ConfRoom.h"

#define TOOLTIP_ID	1

/////////////////////////////////////////////////////////////////////////////
// CDlgConfRoomTalker

CDlgConfRoomTalker::CDlgConfRoomTalker()
{
	m_callState = CS_DISCONNECTED;

	m_bstrCallerID = NULL;
	m_bstrConfName = NULL;
	m_bstrCallerInfo = NULL;

	m_pszDetails = NULL;

	m_hWndTips = NULL;
	m_pConfRoomTalkerWnd = NULL;
}

CDlgConfRoomTalker::~CDlgConfRoomTalker()
{
	if ( m_pszDetails ) delete m_pszDetails;
	SysFreeString( m_bstrCallerID );
	SysFreeString( m_bstrConfName );
	SysFreeString( m_bstrCallerInfo );
}

LRESULT CDlgConfRoomTalker::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	// Tool tips for conference room
	if ( !m_hWndTips )
	{
		m_hWndTips = CreateWindow( TOOLTIPS_CLASS, NULL, WS_POPUP | WS_EX_TOOLWINDOW | TTS_ALWAYSTIP,
								   CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
								   m_hWnd, (HMENU) NULL, _Module.GetResourceInstance(), NULL );
	}

	UpdateData( false );

	return 1;  // Let the system set the focus
}

void CDlgConfRoomTalker::UpdateData( bool bSaveAndValidate )
{
	USES_CONVERSION;
	TCHAR szText[255] = _T("");

	if ( bSaveAndValidate )
	{
		_ASSERT( false );		// not implemented
	}
	else
	{
		// Caller ID -- use default text if none available
		if ( (!m_bstrCallerID || (SysStringLen(m_bstrCallerID) == 0)) &&
			 (!m_bstrCallerInfo || (SysStringLen(m_bstrCallerInfo) == 0)) )
		{
			if ( m_callState == CS_CONNECTED )
				LoadString( _Module.GetResourceInstance(), IDS_CONFROOM_NO_CALLERID, szText, ARRAYSIZE(szText) );

			SetDlgItemText( IDC_LBL_CALLERID, szText );
		}
		else
		{
			CComBSTR bstrTemp( m_bstrCallerID );
			if ( m_bstrCallerInfo && (SysStringLen(m_bstrCallerInfo) > 0) )
			{
				if ( bstrTemp.Length() > 0 )
					bstrTemp.Append( L"\n" );

				bstrTemp.Append( m_bstrCallerInfo );
			}

			SetDlgItemText( IDC_LBL_CALLERID, OLE2CT(bstrTemp) );
		}

		// Status (combine conference name and status)
		TCHAR szText[255], szState[100];
		UINT nIDS = IDS_CONFROOM_CONF_DISCONNECTED;
		switch ( m_callState )
		{
			case AV_CS_DIALING:			nIDS = IDS_CONFROOM_CONF_DIALING;			break;
			case CS_INPROGRESS:			nIDS = IDS_CONFROOM_CONF_INPROGRESS;		break;
			case CS_CONNECTED:			nIDS = IDS_CONFROOM_CONF_CONNECTED;			break;
			case AV_CS_DISCONNECTING:	nIDS = IDS_CONFROOM_CONF_DISCONNECTING;		break;
			case AV_CS_ABORT:			nIDS = IDS_CONFROOM_CONF_ABORT;				break;
		}

		LoadString( _Module.GetResourceInstance(), nIDS, szState, ARRAYSIZE(szState) );

		// Default to null
		if ( !m_bstrConfName )
			m_bstrConfName = SysAllocString( T2COLE(_T("")) );
	
		_sntprintf( szText, ARRAYSIZE(szText), _T("%s\n%s"), OLE2CT(m_bstrConfName), szState );
		SetDlgItemText( IDC_LBL_STATUS, szText );

		// Update Status bitmaps
		UpdateStatusBitmaps();

		if ( m_hWndTips )
		{
			RECT rc;
			::GetWindowRect( GetDlgItem(IDC_LBL_STATUS), &rc );
			ScreenToClient( &rc );
			AddToolTip( m_hWndTips, rc );
		}
	}
}

void CDlgConfRoomTalker::UpdateStatusBitmaps()
{
	HWND hWndAnimate = GetDlgItem(IDC_ANIMATE);
	UINT nIDA;
		
	switch ( m_callState )
	{
		case AV_CS_ABORT:
		case AV_CS_DIALING:
			nIDA = IDA_CONNECTING;
			break;

		case CS_INPROGRESS:
			nIDA = IDA_RINGING;
			break;

		case CS_CONNECTED:
		case AV_CS_DISCONNECTING:
			nIDA = IDA_CONNECTED;
			break;

		default:
			// Stop animation and show disconnected bitmap
			Animate_Stop( hWndAnimate );
			::ShowWindow( hWndAnimate, SW_HIDE );
			RECT rc;
			::GetWindowRect( hWndAnimate, &rc );
			ScreenToClient( &rc );
			RedrawWindow( &rc );
			return;
	}

	// Play the animation that corresponds to the current call state
	Animate_OpenEx( hWndAnimate, GetModuleHandle(NULL), MAKEINTRESOURCE(nIDA) );
	Animate_Play( hWndAnimate, 0, -1, -1 );
	::ShowWindow( hWndAnimate, SW_SHOW );
}

////////////////////////////////////////////////////////////////////////
// Message handlers
//

LRESULT CDlgConfRoomTalker::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	bHandled = true;
	return ::SendMessage( ::GetParent( GetParent() ), uMsg, wParam, lParam );
}

LRESULT CDlgConfRoomTalker::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	Animate_Close( GetDlgItem(IDC_ANIMATE) );
	return 0;
}

LRESULT CDlgConfRoomTalker::OnPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	PAINTSTRUCT ps;
	HDC hDC = BeginPaint( &ps );
	if ( !hDC ) return 0;

	// Draw stock bitmap
	switch ( m_callState )
	{
		case CS_DISCONNECTED:
		case AV_CS_DISCONNECTING:
		case AV_CS_ABORT:
			{
				HBITMAP hBmp = LoadBitmap( _Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_DISCONNECTED) );
				if ( hBmp )
				{
					RECT rc;
					::GetWindowRect( GetDlgItem(IDC_ANIMATE), &rc );
					ScreenToClient( &rc );
					
					DrawTrans( hDC, hBmp, rc.left, rc.top );
				}
			}
			break;
	}

	EndPaint( &ps );
	bHandled = true;
	return 0;
}

void CDlgConfRoomTalker::AddToolTip( HWND hWndToolTip, const RECT& rc )
{
	TOOLINFO ti;

	ti.cbSize = sizeof(TOOLINFO);
	ti.uFlags = 0;
	ti.hwnd = m_hWnd;
	ti.hinst = _Module.GetResourceInstance();
	ti.uId = TOOLTIP_ID;
	ti.lpszText = NULL;
	ti.rect = rc;

	// Make sure the tool doesn't already exist
	::SendMessage( hWndToolTip, TTM_DELTOOL, 0, (LPARAM) &ti );

	// Add the tool to the list
	if ( m_pConfRoomTalkerWnd &&
		 m_pConfRoomTalkerWnd->m_pConfRoomWnd &&
		 m_pConfRoomTalkerWnd->m_pConfRoomWnd->m_pConfRoom )
	{
		USES_CONVERSION;
		BSTR bstrText = NULL;
		m_pConfRoomTalkerWnd->m_pConfRoomWnd->m_pConfRoom->get_bstrConfDetails( &bstrText );

		// delete previous value
		if ( m_pszDetails )
		{
			delete m_pszDetails;
			m_pszDetails = NULL;
		}

		// Allocate for new tool tip
		int nLen = SysStringLen(bstrText);
		if ( nLen > 0 )
		{
			m_pszDetails = new TCHAR[nLen + 1];
			if ( m_pszDetails )
			{
				_tcscpy( m_pszDetails, OLE2CT(bstrText) );
				ti.lpszText = m_pszDetails;

				::SendMessage( hWndToolTip, TTM_ADDTOOL, 0, (LPARAM) &ti );
			}
		}

		SysFreeString( bstrText );
	}
}

LRESULT CDlgConfRoomTalker::OnMouse(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled)
{
	// Forward message on to tool tip
	if ( m_hWndTips )
	{
		MSG msg;
		msg.hwnd = m_hWnd;
		msg.message = nMsg;
		msg.wParam = wParam;
		msg.lParam = lParam;

		bHandled = false;
		::SendMessage( m_hWndTips, TTM_RELAYEVENT, 0, (LPARAM) &msg );
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\dlgjoin.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// DlgJoinConference.cpp : Implementation of CDlgJoinConference
#include "stdafx.h"
#include <stdio.h>
#include "DlgJoin.h"
#include "TapiDialer.h"
#include "AVTapi.h"
#include "CEDetailsVw.h"

static UINT arCols[] = { IDS_EXPLORE_COLUMN_SERVER,
						 IDS_EXPLORE_COLUMN_NAME,
						 IDS_EXPLORE_COLUMN_STARTS,
						 IDS_EXPLORE_COLUMN_ORIGINATOR };

static int arColSort[] = { CConfExplorerDetailsView::COL_SERVER,
						   CConfExplorerDetailsView::COL_NAME,
						   CConfExplorerDetailsView::COL_STARTS,
						   CConfExplorerDetailsView::COL_ORIGINATOR };


static int CALLBACK CompareFunc( LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort )
{
	CDlgJoinConference *p = (CDlgJoinConference *) lParamSort;
	return ((CConfDetails *) lParam1)->Compare( (CConfDetails *) lParam2, p->IsSortAscending(), p->GetSortColumn(), p->GetSecondarySortColumn() );
}


/////////////////////////////////////////////////////////////////////////////
// CDlgJoinConference

IMPLEMENT_MY_HELP(CDlgJoinConference)

CDlgJoinConference::CDlgJoinConference()
{
	m_bSortAscending = true;
	m_nSortColumn = 1;
	m_bstrSearchText = NULL;
}

CDlgJoinConference::~CDlgJoinConference()
{
	DELETE_CRITLIST(m_lstConfs, m_critLstConfs);
	SysFreeString( m_bstrSearchText );
}

LRESULT CDlgJoinConference::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	get_Columns();		// retrieve user's settings
	ListView_SetExtendedListViewStyle( GetDlgItem(IDC_LST_CONFS), LVS_EX_FULLROWSELECT );

	ShowWindow( SW_SHOW );
	UpdateData( false );

	return 1;  // Let the system set the focus
}

LRESULT CDlgJoinConference::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	put_Columns();		// persist user's settings

	// Retrieve the selected item
	for ( int i = 0; i < ListView_GetItemCount(GetDlgItem(IDC_LST_CONFS)); i++ )
	{
		if ( ListView_GetItemState(GetDlgItem(IDC_LST_CONFS), i, LVIS_SELECTED) )
		{
			LV_ITEM lvi = {0};
			lvi.iItem = i;
			lvi.mask = LVIF_PARAM;
			if ( ListView_GetItem(GetDlgItem(IDC_LST_CONFS), &lvi) && lvi.lParam )
			{
				m_confDetails = *((CConfDetails *) lvi.lParam);
				break;
			}
		}
	}

	EndDialog(IDOK);
	return 0;
}

LRESULT CDlgJoinConference::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	put_Columns();		// persist user's settings
	EndDialog(wID);
	return 0;
}

int	CDlgJoinConference::GetSortColumn() const
{
	return arColSort[m_nSortColumn];
}

int CDlgJoinConference::GetSecondarySortColumn() const
{
	if ( arColSort[m_nSortColumn] == CConfExplorerDetailsView::COL_NAME )
		return CConfExplorerDetailsView::COL_SERVER;

	return CConfExplorerDetailsView::COL_NAME;
}


void CDlgJoinConference::get_Columns()
{
#define CONFJOIN_DEFAULT_WIDTH	120

	// Load column settings from registry
	USES_CONVERSION;
	CRegKey regKey;
	TCHAR szReg[255], szEntry[50];

	LV_COLUMN lvc;
    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM; 
    lvc.fmt = LVCFMT_LEFT;
	lvc.pszText = szReg;

	LoadString( _Module.GetResourceInstance(), IDN_REG_DLGJOINCONF_VIEW_KEY, szReg, ARRAYSIZE(szReg) );
	regKey.Open( HKEY_CURRENT_USER, szReg, KEY_READ );

    // Add the columns.
	for ( int i = 0; i < ARRAYSIZE(arCols); i++ )
	{
        lvc.iSubItem = i; 
		lvc.cx = CONFJOIN_DEFAULT_WIDTH;

		// Load registry stuff if exists		
		if ( regKey.m_hKey )
		{
			DWORD dwVal = 0;

			// Get sort column and sort direction
			LoadString( _Module.GetResourceInstance(), IDN_REG_DLGJOINCONF_SORT_COLUMN, szReg, ARRAYSIZE(szReg) );
			regKey.QueryValue( dwVal, szReg );
			m_nSortColumn = (int) max(0, ((int)min(dwVal,ARRAYSIZE(arCols))));

			LoadString( _Module.GetResourceInstance(), IDN_REG_DLGJOINCONF_SORT_ASCENDING, szReg, ARRAYSIZE(szReg) );
			regKey.QueryValue( dwVal, szReg );
			m_bSortAscending = (bool) (dwVal > 0);

			// Column Widths
			LoadString( _Module.GetResourceInstance(), IDN_REG_DLGJOINCONF_ENTRY, szReg, ARRAYSIZE(szReg) );
			_sntprintf( szEntry, ARRAYSIZE(szEntry), szReg, i );
			szEntry[ARRAYSIZE(szEntry)-1] = _T('\0');
			dwVal = 0;
			if ( (regKey.QueryValue(dwVal, szEntry) == ERROR_SUCCESS) && (dwVal > 0) )
				lvc.cx = (int) max( MIN_COL_WIDTH, min( 5000, dwVal ));

		}

        LoadString( _Module.GetResourceInstance(), arCols[i], szReg, ARRAYSIZE(szReg) );
        ListView_InsertColumn( GetDlgItem(IDC_LST_CONFS), i, &lvc );
	}
}

void CDlgJoinConference::put_Columns()
{
	// Save column setting to registry
	USES_CONVERSION;
	CRegKey regKey;
	TCHAR szReg[100], szEntry[50];

	LoadString( _Module.GetResourceInstance(), IDN_REG_DLGJOINCONF_VIEW_KEY, szReg, ARRAYSIZE(szReg) );
	if ( regKey.Create(HKEY_CURRENT_USER, szReg) == ERROR_SUCCESS )
	{
		// Save sort column and sort direction
		LoadString( _Module.GetResourceInstance(), IDN_REG_DLGJOINCONF_SORT_COLUMN, szReg, ARRAYSIZE(szReg) );
		regKey.SetValue( m_nSortColumn, szReg );
		LoadString( _Module.GetResourceInstance(), IDN_REG_DLGJOINCONF_SORT_ASCENDING, szReg, ARRAYSIZE(szReg) );
		regKey.SetValue( m_bSortAscending, szReg );

		// Save column widths
		int nWidth;
		for ( int i = 0; i < ARRAYSIZE(arCols); i++ )
		{
			nWidth = ListView_GetColumnWidth( GetDlgItem(IDC_LST_CONFS), i );
			LoadString( _Module.GetResourceInstance(), IDN_REG_DLGJOINCONF_ENTRY, szReg, ARRAYSIZE(szReg) );
			_sntprintf( szEntry, ARRAYSIZE(szEntry), szReg, i );
			szEntry[ARRAYSIZE(szEntry)-1] = _T('\0');

			regKey.SetValue( nWidth, szEntry );
		}
	}
}

///////////////////////////////////////////////////////////////////////////
// Message handlers
//
LRESULT CDlgJoinConference::OnGetDispInfo(WPARAM wParam, LPNMHDR lpnmHdr, BOOL& bHandled)
{
	if ( !lpnmHdr ) return 0;

	USES_CONVERSION;
	LV_DISPINFO *pInfo = (LV_DISPINFO *) lpnmHdr;

	if ( (pInfo->hdr.code == LVN_GETDISPINFO) && pInfo->item.lParam && (pInfo->item.mask & LVIF_TEXT) )
	{
		BSTR bstrTemp = NULL;
		CConfDetails *pDetails = (CConfDetails *) pInfo->item.lParam;
		switch ( arColSort[pInfo->item.iSubItem] )
		{
			case CConfExplorerDetailsView::COL_SERVER:		pDetails->get_bstrDisplayableServer( &bstrTemp ); break;
			case CConfExplorerDetailsView::COL_NAME:		bstrTemp = SysAllocString( pDetails->m_bstrName );	 break;
			case CConfExplorerDetailsView::COL_ORIGINATOR:	bstrTemp = SysAllocString( pDetails->m_bstrOriginator ); break;
			case CConfExplorerDetailsView::COL_STARTS:		VarBstrFromDate( pDetails->m_dateStart, LOCALE_USER_DEFAULT, NULL, &bstrTemp );	break;
			default:	_ASSERT( false );
		}
		
		// Copy string
		_tcsncpy( pInfo->item.pszText, (bstrTemp) ? OLE2CT(bstrTemp) : _T(""), pInfo->item.cchTextMax );
		pInfo->item.pszText[pInfo->item.cchTextMax - 1] = 0;
		SysFreeString( bstrTemp );
	}

	return 0;
}

LRESULT CDlgJoinConference::OnColumnClicked(WPARAM wParam, LPNMHDR lpnmHdr, BOOL& bHandled)
{
	int nColumn = ((NM_LISTVIEW *) lpnmHdr)->iSubItem;

	if ( ListView_GetColumnWidth(GetDlgItem(IDC_LST_CONFS), nColumn) == 0 ) return 0;

	// Sort on column selected; if new column sort ascending
	if ( m_nSortColumn == nColumn )
	{
		m_bSortAscending = !m_bSortAscending;
	}
	else
	{
		m_nSortColumn = nColumn;
		m_bSortAscending = true;
	}

	ListView_SortItems( GetDlgItem(IDC_LST_CONFS), CompareFunc, (LPARAM) this );
	return 0;
}


void CDlgJoinConference::UpdateData( bool bSaveAndValidate )
{
	bool bEndDialog = false;
	int nTries = (m_bstrSearchText) ? 1 : 2;

	m_critLstConfs.Lock();

	if ( !bSaveAndValidate )
	{
		CComPtr<IAVTapi> pAVTapi;

		// Load listbox with conference information
		if ( SUCCEEDED(_Module.get_AVTapi(&pAVTapi)) )
		{
			for ( int i = 0; i < nTries; i++ )
			{
				IConfExplorer *pConfExplorer;
				if ( SUCCEEDED(pAVTapi->get_ConfExplorer(&pConfExplorer)) )
				{
					IConfExplorerTreeView *pTreeView;
					if ( SUCCEEDED(pConfExplorer->get_TreeView(&pTreeView)) )
					{
						// first time through request only scheduled conferences
						if ( m_bstrSearchText )
							pTreeView->BuildJoinConfListText( (long *) &m_lstConfs, m_bstrSearchText );
						else
							pTreeView->BuildJoinConfList( (long *) &m_lstConfs, (bool) (i != 0) );

						pTreeView->Release();
					}
					pConfExplorer->Release();
				}

				// Verify that we have some conferences to display
				if ( !m_lstConfs.empty() )
				{
					// Add items to list
					LV_ITEM lvi = {0};
					lvi.mask = LVIF_TEXT | LVIF_PARAM;
					lvi.pszText = LPSTR_TEXTCALLBACK;

					::SendMessage( GetDlgItem(IDC_LST_CONFS), WM_SETREDRAW, false, 0 );
					for ( CONFDETAILSLIST::iterator i = m_lstConfs.begin(); i != m_lstConfs.end(); i++ )
					{
						lvi.lParam = (LPARAM) (*i);
						ListView_InsertItem( GetDlgItem(IDC_LST_CONFS), &lvi );
					}

					ListView_SortItems( GetDlgItem(IDC_LST_CONFS), CompareFunc, (LPARAM) this );
					::SendMessage( GetDlgItem(IDC_LST_CONFS), WM_SETREDRAW, true, 0 );
					::InvalidateRect( GetDlgItem(IDC_LST_CONFS), NULL, true );

					break;
				}
				else
				{
					// Msg box user that there are no conferences presently
					if ( !i )
					{
						if ( m_bstrSearchText )
						{
							_Module.DoMessageBox(IDS_MSG_NO_CONFS_MATCHED, MB_ICONINFORMATION, true );
							bEndDialog = true;
							break;
						}

						if ( _Module.DoMessageBox(IDS_MSG_NO_CONFS_SCHEDULED, MB_YESNO | MB_ICONQUESTION, true) == IDNO )
						{
							bEndDialog = true;
							break;
						}

						// Change dialog title based on information shown
						TCHAR szText[255];
						LoadString( _Module.GetResourceInstance(), IDS_JOINCONF_SELECTALL, szText, ARRAYSIZE(szText) );
						SetDlgItemText( IDC_LBL_WELCOME_JOIN, szText );
					}
					else
					{
						_Module.DoMessageBox(IDS_MSG_NO_CONFS, MB_ICONEXCLAMATION, true);
						bEndDialog = true;
					}
				}
			}
		}
	}

	m_critLstConfs.Unlock();

	UpdateJoinBtn();

	if ( bEndDialog ) 
		EndDialog(IDCANCEL);
}

LRESULT CDlgJoinConference::OnConfDblClk(WPARAM wParam, LPNMHDR lpnmHdr, BOOL& bHandled)
{
	return OnOK( (WORD) NM_DBLCLK, (WORD) IDOK, GetDlgItem(IDC_LST_CONFS), bHandled );
}

LRESULT CDlgJoinConference::OnItemChanged(WPARAM wParam, LPNMHDR lpnmHdr, BOOL& bHandled)
{
	UpdateJoinBtn();
	return 0;
}

void CDlgJoinConference::UpdateJoinBtn()
{
	bool bSelected = false;
	HWND hWnd = GetDlgItem(IDC_LST_CONFS);

	if ( hWnd )
	{
		for ( int i = 0; i < ListView_GetItemCount(hWnd); i++ )
		{
			if ( ListView_GetItemState(hWnd, i, LVIS_SELECTED) )
			{
				bSelected = true;
				break;
			}
		}
	}

	::EnableWindow( GetDlgItem(IDC_BTN_JOIN_CONFERENCE), bSelected );	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\dlgjoin.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// DlgJoinConference.h : Declaration of the CDlgJoinConference

#ifndef __DLGJOINCONFERENCE_H_
#define __DLGJOINCONFERENCE_H_

#include "resource.h"       // main symbols
#include "ConfDetails.h"
#include "DlgBase.h"

/////////////////////////////////////////////////////////////////////////////
// CDlgJoinConference
class CDlgJoinConference : 
	public CDialogImpl<CDlgJoinConference>
{
public:
	CDlgJoinConference();
	~CDlgJoinConference();

	enum { IDD = IDD_DLGJOINCONFERENCE };

	DECLARE_MY_HELP;

// Members
public:
	CConfDetails				m_confDetails;
	
	int							m_nSortColumn;
	bool						m_bSortAscending;
	BSTR						m_bstrSearchText;

	CONFDETAILSLIST				m_lstConfs;
	CComAutoCriticalSection		m_critLstConfs;

// Attributes
public:
	bool		IsSortAscending() const			{ return m_bSortAscending; }
	int			GetSortColumn() const;
	int			GetSecondarySortColumn() const;

// Operations
public:
	void		UpdateData( bool bSaveAndValidate );
	void		UpdateJoinBtn();

protected:
	void	get_Columns();
	void	put_Columns();

// Implementation
public:
BEGIN_MSG_MAP(CDlgJoinConference)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	COMMAND_ID_HANDLER(IDC_BTN_JOIN_CONFERENCE, OnOK)
	COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
	NOTIFY_HANDLER(IDC_LST_CONFS, LVN_GETDISPINFO, OnGetDispInfo)
	NOTIFY_HANDLER(IDC_LST_CONFS, LVN_COLUMNCLICK, OnColumnClicked)
	NOTIFY_HANDLER(IDC_LST_CONFS, NM_DBLCLK, OnConfDblClk)
	NOTIFY_HANDLER(IDC_LST_CONFS, LVN_ITEMCHANGED, OnItemChanged)
	MESSAGE_MY_HELP
END_MSG_MAP()

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnGetDispInfo(WPARAM wParam, LPNMHDR lpnmHdr, BOOL& bHandled);
	LRESULT OnColumnClicked(WPARAM wParam, LPNMHDR lpnmHdr, BOOL& bHandled);
	LRESULT OnConfDblClk(WPARAM wParam, LPNMHDR lpnmHdr, BOOL& bHandled);
	LRESULT OnItemChanged(WPARAM wParam, LPNMHDR lpnmHdr, BOOL& bHandled);
};

#endif //__DLGJOINCONFERENCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\expdtllist.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////
// ExpDetailsList.cpp
//

#include "stdafx.h"
#include "TapiDialer.h"
#include "avTapi.h"
#include "ExpDtlList.h"
#include "CEDetailsVw.h"
#include "ConfDetails.h"

#define AVTAPI_KEY_ENTER    13

CExpDetailsList::CExpDetailsList()
{
	m_pDetailsView = NULL;

	m_hIml = NULL;
	m_hImlState = NULL;
}

CExpDetailsList::~CExpDetailsList()
{
}

LRESULT CExpDetailsList::OnGetDispInfo(WPARAM wParam, LPNMHDR lpnmHdr, BOOL& bHandled)
{
	if ( m_pDetailsView )
	{
		bHandled = true;
		return m_pDetailsView->OnGetDispInfo( (LV_DISPINFO *) lpnmHdr );
	}


	return 0;
}

LRESULT CExpDetailsList::OnColumnClicked(WPARAM wParam, LPNMHDR lpnmHdr, BOOL& bHandled)
{
	if ( m_pDetailsView )
	{
		bHandled = true;
		return m_pDetailsView->OnColumnClicked( ((NM_LISTVIEW *) lpnmHdr)->iSubItem );
	}

	return 0;
}

LRESULT CExpDetailsList::OnDblClk(WPARAM wParam, LPNMHDR lpnmHdr, BOOL& bHandled)
{
	return m_pDetailsView->m_pIConfExplorer->Join( NULL );
}

LRESULT CExpDetailsList::OnContextMenu(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled)
{
#define CLICK_COL(_COL_)	\
	if ( m_pDetailsView->GetSortColumn() != CConfExplorerDetailsView::COL_##_COL_)	\
	{																				\
		m_pDetailsView->OnColumnClicked( CConfExplorerDetailsView::COL_##_COL_ );	\
	}

	// Only handle if we have a detail view to work with
	if ( !m_pDetailsView || !m_pDetailsView->m_pIConfExplorer ) return 0;

	bHandled = true;

	// Load popup menu for Details View
	HMENU hMenu = LoadMenu( _Module.GetResourceInstance(), MAKEINTRESOURCE(IDR_POPUP_CONFSERV_DETAILS) );
	HMENU hMenuPopup = GetSubMenu( hMenu, 0 );
	if ( hMenuPopup )
	{
		POINT pt = { 10, 10 };
		ClientToScreen( &pt );
		if ( lParam != -1 )
			GetCursorPos( &pt );

		bool bAscending = m_pDetailsView->IsSortAscending();

		// Check the current 'Sort By' column
		for ( int i = 0; i < GetMenuItemCount(hMenuPopup); i++ )
		{
			if ( GetMenuItemID(hMenuPopup, i) == -1 )
			{
				HMENU hMenuSortBy = GetSubMenu( hMenuPopup, i );
				if ( hMenuSortBy )
				{
					// Check sort column
					CheckMenuItem( hMenuSortBy, m_pDetailsView->GetSortColumn(), MF_BYPOSITION | MFT_RADIOCHECK | MFS_CHECKED );

					// Check if descending order
					CheckMenuItem( hMenuSortBy, ID_POPUP_SORTBY_ASCENDING, MF_BYCOMMAND | ((bAscending) ? MFT_RADIOCHECK | MFS_CHECKED : MF_UNCHECKED) );
					CheckMenuItem( hMenuSortBy, ID_POPUP_SORTBY_DESCENDING, MF_BYCOMMAND | ((!bAscending) ? MFT_RADIOCHECK | MFS_CHECKED : MF_UNCHECKED) );
				}
				break;
			}
		}

		// Is there an item seleceted?
		if ( !ListView_GetSelectedCount(m_pDetailsView->m_wndList.m_hWnd) )
		{	
			EnableMenuItem( hMenuPopup, ID_POPUP_DELETE,		MF_BYCOMMAND | MF_GRAYED );
			EnableMenuItem( hMenuPopup, ID_POPUP_JOIN,			MF_BYCOMMAND | MF_GRAYED );
			EnableMenuItem( hMenuPopup, ID_POPUP_PROPERTIES,	MF_BYCOMMAND | MF_GRAYED );
		}

		// Gray out the Join option if the conference room is presently in use
		CComPtr<IAVTapi> pAVTapi;
		if ( SUCCEEDED(_Module.get_AVTapi(&pAVTapi)) )
		{
			IConfRoom *pConfRoom;
			if ( SUCCEEDED(pAVTapi->get_ConfRoom(&pConfRoom)) )
			{
				if ( pConfRoom->IsConfRoomInUse() == S_OK )
					EnableMenuItem( hMenuPopup, ID_POPUP_JOIN, MF_BYCOMMAND | MF_GRAYED );

				pConfRoom->Release();
			}
		}
		
	
		// Show popup menu
		int nRet = TrackPopupMenu(	hMenuPopup,
									TPM_LEFTALIGN | TPM_TOPALIGN | TPM_RETURNCMD | TPM_RIGHTBUTTON,
									pt.x, pt.y,
									0, m_hWnd, NULL );

		// Process command
		switch ( nRet )
		{
			// Column sorting
			case ID_POPUP_SORTBY_NAME:				CLICK_COL(NAME);		break;
			case ID_POPUP_SORTBY_PURPOSE:			CLICK_COL(PURPOSE);		break;
			case ID_POPUP_SORTBY_STARTTIME:			CLICK_COL(STARTS );		break;
			case ID_POPUP_SORTBY_ENDTIME:			CLICK_COL(ENDS );		break;
			case ID_POPUP_SORTBY_ORIGINATOR:		CLICK_COL(ORIGINATOR );	break;

			// Sort order
			case ID_POPUP_SORTBY_ASCENDING:
				if ( !bAscending )
					m_pDetailsView->OnColumnClicked(m_pDetailsView->GetSortColumn());
				break;

			case ID_POPUP_SORTBY_DESCENDING:
				if ( bAscending )
					m_pDetailsView->OnColumnClicked(m_pDetailsView->GetSortColumn());
				break;

			// Basic commands
			case ID_POPUP_CREATE:			m_pDetailsView->m_pIConfExplorer->Create( NULL );		break;
			case ID_POPUP_DELETE:			m_pDetailsView->m_pIConfExplorer->Delete( NULL );		break;
			case ID_POPUP_JOIN:				m_pDetailsView->m_pIConfExplorer->Join( NULL );			break;
			case ID_POPUP_PROPERTIES:		m_pDetailsView->m_pIConfExplorer->Edit( NULL );			break;
			case ID_POPUP_REFRESH:			m_pDetailsView->Refresh(); break;

			case ID_ADD_SPEEDDIAL:
				{
					CComPtr<IAVGeneralNotification> pAVGen;
					if ( SUCCEEDED(_Module.get_AVGenNot(&pAVGen)) )
					{
						CConfDetails *pDetails;
						if ( SUCCEEDED(m_pDetailsView->get_SelectedConfDetails( (long **) &pDetails)) )
						{
							pAVGen->fire_AddSpeedDial( pDetails->m_bstrName, pDetails->m_bstrName, CM_MEDIA_MCCONF );
							delete pDetails;
						}
					}
				}
				break;
		}
	}

	// Clean up
	if ( hMenu ) DestroyMenu( hMenu );

	return 0;
}

LRESULT CExpDetailsList::OnPaint(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled)
{
	if ( ListView_GetItemCount(m_hWnd) )
		return DefWindowProc(nMsg, wParam, lParam);

	PAINTSTRUCT ps;
	HDC hDC = BeginPaint( &ps );
	if ( !hDC ) return 0;
	bHandled = true;

	// Figure out where we're going to write the text
	POINT pt;
	ListView_GetItemPosition( m_hWnd, 0, &pt );
	RECT rc;
	GetClientRect(&rc);
	rc.top = pt.y + 4;

	POINT ptUL = { rc.left + 1, rc.top + 1};
	POINT ptLR = { rc.right - 1, rc.bottom - 1};

	//if ( TRUE || IsRectEmpty(&ps.rcPaint) || (PtInRect(&ps.rcPaint, ptUL) && PtInRect(&ps.rcPaint, ptLR)) )
	//{
		// Print the text that says there are no items to show in this view
		TCHAR szText[255];
		UINT nIDS = IDS_NO_ITEMS_TO_SHOW;

		// Find out what state the tree control is in
		if ( m_pDetailsView && m_pDetailsView->m_pIConfExplorer )
		{
			IConfExplorerTreeView *pTreeView;
			if ( SUCCEEDED(m_pDetailsView->m_pIConfExplorer->get_TreeView(&pTreeView)) )
			{
				ServerState nState;
				if ( SUCCEEDED(pTreeView->get_nServerState(&nState)) )
				{
					switch ( nState )
					{
						case SERVER_INVALID:			nIDS = IDS_SERVER_INVALID; break;
						case SERVER_NOT_RESPONDING:		nIDS = IDS_SERVER_NOT_RESPONDING; break;
						case SERVER_QUERYING:			nIDS = IDS_SERVER_QUERYING; break;
						case SERVER_UNKNOWN:			nIDS = IDS_SERVER_UNKNOWN; break;
					}
				}
				pTreeView->Release();
			}
		}

		// Load the string that accurately reflects the state of the server
		LoadString( _Module.GetResourceInstance(), nIDS, szText, ARRAYSIZE(szText) );

		HFONT fontOld = (HFONT) SelectObject( hDC, GetFont() );

		int nModeOld = SetBkMode( hDC, TRANSPARENT );
		COLORREF crTextOld = SetTextColor( hDC, GetSysColor(COLOR_BTNTEXT) );
		DrawText( hDC, szText, _tcslen(szText), &rc, DT_CENTER | DT_WORDBREAK | DT_NOPREFIX | DT_EDITCONTROL );
		SetTextColor( hDC, crTextOld );
		SetBkMode( hDC, nModeOld );

		SelectObject( hDC, fontOld );
		ValidateRect( &rc );
	//}
	//else
	//{
		// Make sure entire row is invalidated so we can properly draw the text
	//	InvalidateRect( &rc );
	//}

	EndPaint( &ps );

	return 0;
}

LRESULT CExpDetailsList::OnKillFocus(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled)
{
	// Clear any selected items
	for ( int i = 0; i < ListView_GetItemCount(m_hWnd); i++ )
	{
		if ( ListView_GetItemState(m_hWnd, i, LVIS_SELECTED) )
			ListView_SetItemState( m_hWnd, i, 0, LVIS_SELECTED | LVIS_FOCUSED );
	}

	return 0;
}

LRESULT CExpDetailsList::OnSetFocus(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled)
{
    bHandled = FALSE;
    BOOL bSelected = FALSE;
	for ( int i = 0; i < ListView_GetItemCount(m_hWnd); i++ )
	{
		if ( ListView_GetItemState(m_hWnd, i, LVIS_SELECTED) )
        {
            bSelected = TRUE;
            break;
        }
	}

    if( !bSelected )
    {
        ListView_SetItemState(m_hWnd, 0, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED);
    }

	return 0;
}

LRESULT CExpDetailsList::OnKeyUp(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled)
{
    bHandled = FALSE;

    if( AVTAPI_KEY_ENTER != wParam )
    {
        return 0;
    }

    // Press ENTER key, try to make a call
	return m_pDetailsView->m_pIConfExplorer->Join( NULL );
}


LRESULT CExpDetailsList::OnSettingChange(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled)
{
	Invalidate();	
	bHandled = false;
	return 0;
}

LRESULT CExpDetailsList::OnMyCreate(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled)
{
	bHandled = false;

	// Create the image lists if they don't already exist
	if ( !m_hIml )
		m_hIml = ImageList_LoadBitmap( _Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_CONFDETAILS), 15, 3, RGB(255, 0, 255) );

	if ( !m_hImlState )
		m_hImlState = ImageList_LoadBitmap( _Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_CONFDETAILS_STATE), 11, 2, RGB(255, 0, 255) );

	if ( m_hIml && m_hImlState )
	{
		// Owner sorting won't work if sort style pre-set
		::SetWindowLongPtr( m_hWnd, GWL_STYLE, (::GetWindowLongPtr(m_hWnd, GWL_STYLE) | LVS_REPORT | LVS_SINGLESEL) & ~(LVS_SORTASCENDING | LVS_SORTDESCENDING) );
		ListView_SetExtendedListViewStyle( m_hWnd, LVS_EX_FULLROWSELECT );

		ListView_SetImageList( m_hWnd, m_hIml, LVSIL_SMALL );
		ListView_SetImageList( m_hWnd, m_hImlState, LVSIL_STATE );
		ListView_SetCallbackMask( m_hWnd, LVIS_STATEIMAGEMASK );

		// Not fully thread safe, but okay for this operation
		if ( m_pDetailsView )
		{
			m_pDetailsView->get_Columns();
			m_pDetailsView->Refresh();
		}
	}

	return 0;
}


LRESULT CExpDetailsList::OnDestroy(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled)
{
	bHandled = false;

	// Destroy the image list
	if ( m_hIml )		ImageList_Destroy( m_hIml );
	if ( m_hImlState)	ImageList_Destroy( m_hImlState );

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\errorinfo.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////
// ErrorInfo.cpp
//

#include "stdafx.h"
#include "TapiDialer.h"
#include "AVTapi.h"
#include "ErrorInfo.h"

CErrorInfo::CErrorInfo()
{
	Init( 0, 0 );
}

CErrorInfo::CErrorInfo( UINT nOperation, UINT nDetails )
{
	Init( nOperation, nDetails );
}

void CErrorInfo::Init( UINT nOperation, UINT nDetails )
{
	m_bstrOperation = NULL;
	m_bstrDetails = NULL;

	if ( !nOperation ) nOperation = IDS_ER_GENERAL_OPERATION;
	set_Operation( nOperation );

	if ( !nDetails ) nDetails = IDS_ER_GENERAL_DETAILS;
	set_Details( nDetails );

	m_hr = S_OK;
}

CErrorInfo::~CErrorInfo()
{
	CComPtr<IAVTapi> pAVTapi;
	if ( FAILED(m_hr) && SUCCEEDED(_Module.get_AVTapi(&pAVTapi)) )
	{
		Commit();

		// Notify the application of the problem
		pAVTapi->fire_ErrorNotify( (long *) this );
	}

	SysFreeString( m_bstrOperation );
	SysFreeString( m_bstrDetails );
}

void CErrorInfo::set_Operation( UINT nIDS )
{
	m_nOperation = nIDS;
}

void CErrorInfo::set_Details( UINT nIDS )
{
	m_nDetails = nIDS;
}

void CErrorInfo::Commit()
{
	// Translate error code to equivalent strings
	USES_CONVERSION;
	TCHAR szText[512];

	if ( m_nOperation )
	{
		LoadString( _Module.GetResourceInstance(), m_nOperation, szText, ARRAYSIZE(szText) );
		SysReAllocString( &m_bstrOperation, T2COLE(szText) );
	}

	if ( m_nDetails )
	{
		LoadString( _Module.GetResourceInstance(), m_nDetails, szText, ARRAYSIZE(szText) );
		SysReAllocString( &m_bstrDetails, T2COLE(szText) );
	}
}

HRESULT CErrorInfo::set_hr( HRESULT hr )
{
	m_hr = hr;
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\enumsite.cpp ===
// EnumSite.cpp : Implementation of CEnumSiteServer
#include "stdafx.h"
#include "TapiDialer.h"
#include "EnumSite.h"
#include "ConfDetails.h"

/////////////////////////////////////////////////////////////////////////////
// CSiteServer

CSiteUser::CSiteUser()
{
	m_bstrName = NULL;
	m_bstrAddress = NULL;
	m_bstrComputer = NULL;
}

CSiteUser::~CSiteUser()
{
	ATLTRACE(_T(".enter.CSiteUser::~CSiteUser().\n"));
	SysFreeString( m_bstrName );
	SysFreeString( m_bstrAddress );
	SysFreeString( m_bstrComputer );
}

STDMETHODIMP CSiteUser::get_bstrName(BSTR * pVal)
{
	HRESULT hr;

	Lock();
	hr = SysReAllocString(pVal, m_bstrName);
	Unlock();

	return hr;
}

STDMETHODIMP CSiteUser::put_bstrName(BSTR newVal)
{
	HRESULT hr = S_OK;
	Lock();
	if ( newVal )
	{
		hr = SysReAllocString( &m_bstrName, newVal );
	}
	else
	{
		SysFreeString( m_bstrName );
		m_bstrName = NULL;
	}
	
	return hr;
}

STDMETHODIMP CSiteUser::get_bstrAddress(BSTR * pVal)
{
	HRESULT hr;

	Lock();
	hr = SysReAllocString( pVal, m_bstrAddress );
	Unlock();

	return hr;
}

STDMETHODIMP CSiteUser::put_bstrAddress(BSTR newVal)
{
	HRESULT hr = S_OK;
	Lock();
	if ( newVal )
	{
		hr = SysReAllocString( &m_bstrAddress, newVal );
	}
	else
	{
		SysFreeString( m_bstrAddress );
		m_bstrAddress = NULL;
	}
	
	return hr;
}

STDMETHODIMP CSiteUser::get_bstrComputer(BSTR * pVal)
{
	HRESULT hr;

	Lock();
	hr = SysReAllocString( pVal, m_bstrComputer );
	Unlock();

	return hr;
}

STDMETHODIMP CSiteUser::put_bstrComputer(BSTR newVal)
{
	HRESULT hr = S_OK;
	Lock();
	if ( newVal )
	{
		hr = SysReAllocString( &m_bstrComputer, newVal );
	}
	else
	{
		SysFreeString( m_bstrComputer );
		m_bstrComputer = NULL;
	}
	
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CEnumSiteServer

CEnumSiteServer::CEnumSiteServer()
{
	m_pInd = NULL;
}

CEnumSiteServer::~CEnumSiteServer()
{
	ATLTRACE(_T("CEnumSiteServer::~CEnumSiteServer() releasing user list.\n"));
	RELEASE_LIST(m_lstUsers);
}

STDMETHODIMP CEnumSiteServer::Reset()
{
	Lock();
	m_pInd = m_lstUsers.begin();
	Unlock();

	return S_OK;
}

STDMETHODIMP CEnumSiteServer::Next(ISiteUser * * ppUser)
{
	HRESULT hr = S_FALSE;

	Lock();
	if ( m_pInd != m_lstUsers.end() )
	{
		*ppUser = *m_pInd;
		(*ppUser)->AddRef();
		m_pInd++;
		hr = S_OK;
	}
	Unlock();

	return hr;
}


STDMETHODIMP CEnumSiteServer::BuildList(long * pPersonDetailList)
{
	Lock();
	RELEASE_LIST( m_lstUsers );
	if ( pPersonDetailList )
	{
		PERSONDETAILSLIST::iterator i, iEnd = ((PERSONDETAILSLIST *) pPersonDetailList)->end();
		for ( i = ((PERSONDETAILSLIST *) pPersonDetailList)->begin(); i != iEnd; i++ )
		{
			ISiteUser *pUser = new CComObject<CSiteUser>;
			if ( pUser )
			{
				pUser->AddRef();
				pUser->put_bstrName( (*i)->m_bstrName );
				pUser->put_bstrAddress( (*i)->m_bstrAddress );
				pUser->put_bstrComputer( (*i)->m_bstrComputer );

				m_lstUsers.push_back( pUser );
			}
		}
	}

	m_pInd = m_lstUsers.begin();
	Unlock();

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\errorinfo.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////
// ErrorInfo.h
//

#ifndef __ERRORINFO_H__
#define __ERRORINFO_H__

class CErrorInfo
{
// Construction
public:
	CErrorInfo();
	CErrorInfo( UINT nOperation, UINT nDetails );
	void Init( UINT nOperation, UINT nDetails );
	virtual ~CErrorInfo();

// Members
public:
	UINT		m_nOperation;
	UINT		m_nDetails;
	BSTR		m_bstrOperation;
	BSTR		m_bstrDetails;
	HRESULT		m_hr;

// Attributes
public:
	void		set_Operation( UINT nIDS );
	void		set_Details( UINT nIDS );
	HRESULT		set_hr( HRESULT hr );

// Operations
public:
	void		Commit();
};

#endif //__ERRORINFO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\enumsite.h ===
// EnumSite.h : Declaration of the CEnumSiteServer

#ifndef __ENUMSITESERVER_H_
#define __ENUMSITESERVER_H_

#include "resource.h"       // main symbols
#include <list>
using namespace std;

class CSiteUser;
typedef list<ISiteUser *>	SITEUSERLIST;

/////////////////////////////////////////////////////////////////////////////
// CSiteUser
class ATL_NO_VTABLE CSiteUser : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CSiteUser, &CLSID_SiteUser>,
	public ISiteUser
{
// Construction / Destruction
public:
	CSiteUser();
	virtual ~CSiteUser();

// Members
public:
	BSTR		m_bstrName;
	BSTR		m_bstrAddress;
	BSTR		m_bstrComputer;

DECLARE_NOT_AGGREGATABLE(CSiteUser)

BEGIN_COM_MAP(CSiteUser)
	COM_INTERFACE_ENTRY(ISiteUser)
END_COM_MAP()

// ISiteUser
public:
	STDMETHOD(get_bstrComputer)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_bstrComputer)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_bstrName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_bstrName)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_bstrAddress)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_bstrAddress)(/*[in]*/ BSTR newVal);
};


/////////////////////////////////////////////////////////////////////////////
// CEnumSiteServer
class ATL_NO_VTABLE CEnumSiteServer : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CEnumSiteServer, &CLSID_EnumSiteServer>,
	public IEnumSiteServer
{
// Construction / Destruction
public:
	CEnumSiteServer();
	virtual ~CEnumSiteServer();

// Members
public:
	SITEUSERLIST::iterator	m_pInd;
	SITEUSERLIST			m_lstUsers;

DECLARE_NOT_AGGREGATABLE(CEnumSiteServer)

BEGIN_COM_MAP(CEnumSiteServer)
	COM_INTERFACE_ENTRY(IEnumSiteServer)
END_COM_MAP()

// IEnumSiteServer
public:
	STDMETHOD(BuildList)(long *pPersonDetailList);
	STDMETHOD(Reset)();
	STDMETHOD(Next)(ISiteUser **ppUser);
};


#endif //__ENUMSITESERVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\expdtllist.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////
// ExpDetailsList.h
//

#ifndef __ExpDetailsList_H__
#define __ExpDetailsList_H__

// FWD define
class CConfExplorerDetailsView;

#define WM_MYCREATE		(WM_USER + 1451)

/////////////////////////////////////////////////////////////////////////////
// CExpDetailsList
class CExpDetailsList : 
	public CWindowImpl<CExpDetailsList>
{
public:
	CExpDetailsList();
	~CExpDetailsList();

// Members
public:
	CConfExplorerDetailsView	*m_pDetailsView;
	HIMAGELIST					m_hIml;
	HIMAGELIST					m_hImlState;

BEGIN_MSG_MAP(CExpDetailsList)
	NOTIFY_CODE_HANDLER(LVN_GETDISPINFO, OnGetDispInfo)
	NOTIFY_CODE_HANDLER(LVN_COLUMNCLICK, OnColumnClicked)
	NOTIFY_CODE_HANDLER(NM_DBLCLK, OnDblClk)
	MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
	MESSAGE_HANDLER(WM_PAINT, OnPaint)
	MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
	MESSAGE_HANDLER(WM_SETTINGCHANGE, OnSettingChange)
	MESSAGE_HANDLER(WM_MYCREATE, OnMyCreate)
	MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
    MESSAGE_HANDLER(WM_KEYUP, OnKeyUp)
END_MSG_MAP()

	LRESULT OnGetDispInfo(WPARAM wParam, LPNMHDR lpnmHdr, BOOL& bHandled);
	LRESULT OnColumnClicked(WPARAM wParam, LPNMHDR lpnmHdr, BOOL& bHandled);
	LRESULT OnDblClk(WPARAM wParam, LPNMHDR lpnmHdr, BOOL& bHandled);
	LRESULT OnContextMenu(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
	LRESULT OnPaint(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
	LRESULT OnKillFocus(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
	LRESULT OnSettingChange(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
	LRESULT OnMyCreate(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
	LRESULT OnDestroy(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
	LRESULT OnSetFocus(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
	LRESULT OnKeyUp(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
};

#endif //__ExpDetailsList_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\exptreevw.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////
// ExpTreeView.cpp
//

#include "stdafx.h"
#include "TapiDialer.h"
#include "CETreeView.h"
#include "ExpTreeView.h"

CExpTreeView::CExpTreeView()
{
	m_pTreeView = NULL;
	m_bCapture = false;
}


LRESULT CExpTreeView::OnRButtonDown(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled)
{
	DefWindowProc(nMsg, wParam, lParam);

	if ( m_pTreeView )
	{
		// Cause the selection to change
		TV_HITTESTINFO tvht = {0};
		tvht.pt.x = LOWORD(lParam);
		tvht.pt.y = HIWORD(lParam);

		TreeView_HitTest( m_pTreeView->m_wndTree.m_hWnd, &tvht );
		if ( tvht.hItem )
			TreeView_SelectItem( m_pTreeView->m_wndTree.m_hWnd, tvht.hItem );
	}

	POINT pt = { LOWORD(lParam), HIWORD(lParam) };
	ClientToScreen(&pt);
	lParam = MAKELONG(pt.x, pt.y);
	return OnContextMenu( nMsg, wParam, lParam, bHandled );	
}


LRESULT CExpTreeView::OnContextMenu(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled)
{
	// Only handle if we have a detail view to work with
	if ( !m_pTreeView || !m_pTreeView->m_pIConfExplorer ) return 0;
	bHandled = true;

	// Load popup menu for Details View
	HMENU hMenu = LoadMenu( _Module.GetResourceInstance(), MAKEINTRESOURCE(IDR_POPUP_CONFSERV_TREE) );
	HMENU hMenuPopup = GetSubMenu( hMenu, 0 );
	if ( hMenuPopup )
	{
		POINT pt = { 10, 10 };
		ClientToScreen( &pt );
		if ( lParam != -1 )
		{
			pt.x = LOWORD(lParam);
			pt.y = HIWORD(lParam);
		}

		// Should we enable the delete method for this item?
		if ( m_pTreeView->CanRemoveServer() == S_FALSE )
		{
			EnableMenuItem( hMenuPopup, ID_POPUP_DELETE, MF_BYCOMMAND | MF_GRAYED );
			EnableMenuItem( hMenuPopup, ID_POPUP_RENAME, MF_BYCOMMAND | MF_GRAYED );
		}

		HTREEITEM hItemSel = TreeView_GetSelection( m_pTreeView->m_wndTree.m_hWnd );

		// Nothing selected in the tree view
		if ( (hItemSel == NULL) || (hItemSel == TreeView_GetRoot(m_pTreeView->m_wndTree.m_hWnd)) )
		{
			EnableMenuItem( hMenuPopup, ID_POPUP_PROPERTIES, MF_BYCOMMAND | MF_GRAYED );
			EnableMenuItem( hMenuPopup, ID_POPUP_RENAME, MF_BYCOMMAND | MF_GRAYED );
			EnableMenuItem( hMenuPopup, ID_POPUP_REFRESH, MF_BYCOMMAND | MF_GRAYED );
			EnableMenuItem( hMenuPopup, ID_POPUP_CREATE, MF_BYCOMMAND | MF_GRAYED );
		}

		int nRet = TrackPopupMenu(	hMenuPopup,
									TPM_LEFTALIGN | TPM_TOPALIGN | TPM_RETURNCMD | TPM_RIGHTBUTTON,
									pt.x, pt.y,
									0, m_hWnd, NULL );

		// Process command
		switch ( nRet )
		{
			// Rename the selected item
			case ID_POPUP_RENAME:		m_pTreeView->RenameServer();					break;
			case ID_POPUP_CREATE:		m_pTreeView->m_pIConfExplorer->Create( NULL );	break;
			case ID_POPUP_NEW_FOLDER:	m_pTreeView->AddLocation( NULL );				break;
			case ID_POPUP_NEW_SERVER:	m_pTreeView->AddServer( NULL );					break;
			case ID_POPUP_DELETE:		m_pTreeView->RemoveServer( NULL, NULL );		break;
			case ID_POPUP_REFRESH:		m_pTreeView->m_pIConfExplorer->Refresh();		break;
		}
	}

	// Clean up
	if ( hMenu ) DestroyMenu( hMenu );

	return 0;
}

LRESULT CExpTreeView::OnSelChanged(WPARAM wParam, LPNMHDR lpnmHdr, BOOL& bHandled)
{
	if ( m_pTreeView )
	{
		bHandled = true;
		return m_pTreeView->OnSelChanged( lpnmHdr );
	}

	return 0;
}

LRESULT CExpTreeView::OnEndLabelEdit(WPARAM wParam, LPNMHDR lpnmHdr, BOOL& bHandled)
{
	if ( m_pTreeView )
	{
		bHandled = true;
		return m_pTreeView->OnEndLabelEdit( (TV_DISPINFO *) lpnmHdr );
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\exptreeview.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////
// ExpTreeView.h
//

#ifndef __EXPTREEVIEW_H__
#define __EXPTREEVIEW_H__

class CExpTreeView :
	public CWindowImpl<CExpTreeView>
{
public:
	CExpTreeView();

// Members
public:
	CConfExplorerTreeView		*m_pTreeView;
	bool						m_bCapture;


BEGIN_MSG_MAP(CExpTreeView)
	MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
	MESSAGE_HANDLER(WM_RBUTTONDOWN, OnRButtonDown)
	NOTIFY_CODE_HANDLER(TVN_SELCHANGED, OnSelChanged)
	NOTIFY_CODE_HANDLER(TVN_ENDLABELEDIT, OnEndLabelEdit)
END_MSG_MAP()

	LRESULT OnRButtonDown(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
	LRESULT OnContextMenu(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
	LRESULT OnSelChanged(WPARAM wParam, LPNMHDR lpnmHdr, BOOL& bHandled);
	LRESULT OnEndLabelEdit(WPARAM wParam, LPNMHDR lpnmHdr, BOOL& bHandled);
};

#endif // __EXPTREEVIEW_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\genntfy.h ===
// GenNtfy.h : Declaration of the CGeneralNotification

#ifndef __GENERALNOTIFICATION_H_
#define __GENERALNOTIFICATION_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CGeneralNotification
class ATL_NO_VTABLE CGeneralNotification : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CGeneralNotification, &CLSID_GeneralNotification>,
	public IGeneralNotification
{
public:
	CGeneralNotification()
	{
	}

DECLARE_NOT_AGGREGATABLE(CGeneralNotification)

BEGIN_COM_MAP(CGeneralNotification)
	COM_INTERFACE_ENTRY(IGeneralNotification)
END_COM_MAP()

// IGeneralNotification
public:
	STDMETHOD(SelectConfParticipant)(IParticipant *pParticipant);
	STDMETHOD(DeleteAllConfParticipants)();
	STDMETHOD(UpdateConfParticipant)(MyUpdateType nType, IParticipant *pParticipant, BSTR bstrText);
	STDMETHOD(UpdateConfRootItem)(BSTR bstrNewText);
	STDMETHOD(AddSpeedDial)(BSTR bstrName, BSTR bstrAddress, CallManagerMedia cmm);
	STDMETHOD(NotifySiteServerStateChange)(BSTR bstrName, ServerState nState);
	STDMETHOD(RemoveSiteServer)(BSTR bstrName);
	STDMETHOD(AddSiteServer)(BSTR bstrServer);
	STDMETHOD(ResolveAddressEx)(BSTR bstrAddress, long lAddressType, DialerMediaType nMedia, DialerLocationType nLocation, BSTR *pbstrName, BSTR *pbstrAddress, BSTR *pbstrUser1, BSTR *pbstrUser2);
	STDMETHOD(AddUser)(BSTR bstrName, BSTR bstrAddress, BSTR bstrPhoneNumber);
	STDMETHOD(ClearUserList)();
	STDMETHOD(ResolveAddress)(BSTR bstrAddress, BSTR *pbstrName, BSTR *pbstrUser1, BSTR *pbstrUser2);
	STDMETHOD(IsReminderSet)(BSTR bstrServer, BSTR bstrName);
};

#endif //__GENERALNOTIFICATION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\mystdafx.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlwin.cpp>
#include <stdio.h>
#include <atlctl.cpp>

void GetToken( int nInd, LPCTSTR szDelim, LPTSTR szText, LPTSTR szToken )
{
	_ASSERT( szDelim && szText && szToken );

	LPTSTR lpszStart = szText;
	bool bInQuotes = false;

	// Null out token string
	*szToken = NULL;

	// Look for token # nInd, ignore delimeter if in quotes
	while ( szText )
	{
		szText = _tcspbrk( szText, szDelim );
		if ( szText )
		{
			if ( *szText == _T('\"') )
			{
				bInQuotes = !bInQuotes;
			}
			else if ( !bInQuotes )
			{
				nInd--;
				if ( !nInd ) break;
				lpszStart = szText + 1;
			}

			szText++;
		}
	}

	// Grab token and strip any quotes off of it
	if ( *lpszStart == _T('\"') ) lpszStart++;

	if ( szText )
	{
		_tcsncpy( szToken, lpszStart, szText - lpszStart );
		szToken[szText - lpszStart] = NULL;
	}
	else
	{
		_tcscpy( szToken, lpszStart );
	}

	if ( szToken[_tcslen(szToken) - 1] == _T('\"') )
		szToken[_tcslen(szToken) - 1] = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\pageaddress.h ===
// PageAddress.h : Declaration of the CPageAddress

#ifndef __PAGEADDRESS_H_
#define __PAGEADDRESS_H_

#include "resource.h"       // main symbols
#include "DlgBase.h"
#include "PageTerm.h"

EXTERN_C const CLSID CLSID_PageAddress;

/////////////////////////////////////////////////////////////////////////////
// CPageAddress
class ATL_NO_VTABLE CPageAddress :
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CPageAddress, &CLSID_PageAddress>,
	public IPropertyPageImpl<CPageAddress>,
	public CDialogImpl<CPageAddress>
{

public:
	CPageAddress();
	~CPageAddress();

	enum {IDD = IDD_PAGEADDRESS};

	DECLARE_MY_HELP;

// Members
public:
	HIMAGELIST				m_hIml;
	static CPageTerminals	*m_pPageTerminals;


// Attributes
public:
	int				GetPreferredDevice() const;
	void			SetPreferredDevice( DWORD dwAddressType );


DECLARE_REGISTRY_RESOURCEID(IDR_PAGEADDRESS)
DECLARE_NOT_AGGREGATABLE(CPageAddress)

BEGIN_COM_MAP(CPageAddress) 
	COM_INTERFACE_ENTRY_IMPL(IPropertyPage)
END_COM_MAP()

// Implementation
public:
BEGIN_MSG_MAP(CPageAddress)
	CHAIN_MSG_MAP(IPropertyPageImpl<CPageAddress>)
	MESSAGE_HANDLER(WM_PAINT, OnPaint)
	COMMAND_RANGE_HANDLER(IDC_RDO_PREFER_POTS, IDC_RDO_PREFER_INTERNET, OnSelChange)
	COMMAND_CODE_HANDLER(CBN_SELCHANGE, OnSelChange)
	COMMAND_ID_HANDLER(IDC_BTN_TELEPHONY_CPL, OnTelephonyCPL )
	MESSAGE_MY_HELP;
END_MSG_MAP()

	LRESULT OnButtonClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnSelChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnTelephonyCPL(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

// Interface overrides
public:
	STDMETHOD(Apply)();
	STDMETHOD(Activate)( /* [in] */ HWND hWndParent,
						 /* [in] */ LPCRECT pRect,
						 /* [in] */ BOOL bModal);
	STDMETHOD(Deactivate)();

};

#endif //__PAGEADDRESS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\genntfy.cpp ===
// GenNtfy.cpp : Implementation of CGeneralNotification
#include "stdafx.h"
#include "TapiDialer.h"
#include "GenNtfy.h"

/////////////////////////////////////////////////////////////////////////////
// CGeneralNotification


STDMETHODIMP CGeneralNotification::IsReminderSet(BSTR bstrServer, BSTR bstrName)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CGeneralNotification::ResolveAddress(BSTR bstrAddress, BSTR * pbstrName, BSTR * pbstrUser1, BSTR * pbstrUser2)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CGeneralNotification::ClearUserList()
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CGeneralNotification::AddUser(BSTR bstrName, BSTR bstrAddress, BSTR bstrPhoneNumber)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CGeneralNotification::ResolveAddressEx(BSTR bstrAddress, long lAddressType, DialerMediaType nMedia, DialerLocationType nLocation, BSTR * pbstrName, BSTR * pbstrAddress, BSTR * pbstrUser1, BSTR * pbstrUser2)
{
	// TODO: Add your implementation code here

	return S_OK;
}


STDMETHODIMP CGeneralNotification::AddSiteServer(BSTR bstrServer)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CGeneralNotification::RemoveSiteServer(BSTR bstrName)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CGeneralNotification::NotifySiteServerStateChange(BSTR bstrName, ServerState nState)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CGeneralNotification::AddSpeedDial(BSTR bstrName, BSTR bstrAddress, CallManagerMedia cmm)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CGeneralNotification::UpdateConfRootItem(BSTR bstrNewText)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CGeneralNotification::UpdateConfParticipant(MyUpdateType nType, IParticipant * pParticipant, BSTR bstrText)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CGeneralNotification::DeleteAllConfParticipants()
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CGeneralNotification::SelectConfParticipant(IParticipant * pParticipant)
{
	// TODO: Add your implementation code here

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\pageterm.cpp ===
// PageTerminals.cpp : Implementation of CPageTerminals
#include "stdafx.h"
#include "PageTerm.h"
#include "AVTapi.h"
#include "PageAddress.h"

#define IMAGE_WIDTH		16
#define IMAGE_MARGIN	5

static	HWND hWnds[5];

/////////////////////////////////////////////////////////////////////////////
// CPageTerminals

IMPLEMENT_MY_HELP(CPageTerminals)

CPageTerminals::CPageTerminals()
{
	m_dwTitleID = IDS_TITLEPageTerminals;
	m_dwHelpFileID = IDS_HELPFILEPageTerminals;
	m_dwDocStringID = IDS_DOCSTRINGPageTerminals;

	m_hIml = NULL;
	m_hImlMedia = NULL;
	m_dwAddressType = LINEADDRESSTYPE_IPADDRESS;
    m_bUSBPresent = FALSE;
    m_bstrUSBCaptureTerm = NULL;
    m_bstrUSBRenderTerm = NULL;
}

CPageTerminals::~CPageTerminals()
{
	if ( m_hIml )		ImageList_Destroy( m_hIml );
	if ( m_hImlMedia )	ImageList_Destroy( m_hImlMedia );

    if( m_bstrUSBCaptureTerm )
    {
        SysFreeString( m_bstrUSBCaptureTerm );
        m_bstrUSBCaptureTerm = NULL;
    }

    if( m_bstrUSBRenderTerm )
    {
        SysFreeString( m_bstrUSBRenderTerm );
        m_bstrUSBRenderTerm = NULL;
    }

}

int	CPageTerminals::ItemFromAddressType( DWORD dwAddressType )
{
	switch ( dwAddressType )
	{
		case LINEADDRESSTYPE_SDP:				return IMAGE_CONFERENCE;
		case LINEADDRESSTYPE_PHONENUMBER:		return IMAGE_TELEPHONE;
	}

	return IMAGE_COMPUTER;
}

STDMETHODIMP CPageTerminals::Apply()
{
	ATLTRACE(_T("CPageTerminals::Apply\n"));

	// Validate dialog data....
	TCHAR szNum[100];
	::GetWindowText( GetDlgItem(IDC_EDT_MAX_WINDOWS), szNum, ARRAYSIZE(szNum) - 1 );
	DWORD dwTemp = _ttol( szNum );
	if ( dwTemp > MAX_VIDEO )
		_Module.DoMessageBox( IDS_ER_MAX_VIDEO_EXCEEDED, MB_ICONINFORMATION, true );
	
	IAVTapi *pAVTapi;
	if ( SUCCEEDED(m_ppUnk[0]->QueryInterface(IID_IAVTapi, (void **) &pAVTapi)) )
	{
		pAVTapi->UnpopulateTerminalsDialog( m_dwAddressType, hWnds );
		pAVTapi->Release();
	}

    //
    // Let save the USB value into registry
    //
    UINT uCheck = ::IsDlgButtonChecked(m_hWnd, IDC_CHK_USBALWAYS);
    USBCheckChanged( (uCheck>0) ? FALSE : TRUE);

    //
    // Try to change the phone settings
    //
    IAVTapi2* pAVTapi2 = NULL;
    if( SUCCEEDED(m_ppUnk[0]->QueryInterface(IID_IAVTapi2, (void**)&pAVTapi2)) )
    {
        if( (m_bUSBPresent == TRUE) && (m_bDirty == TRUE) )
        {
            HRESULT hr = pAVTapi2->USBSetHandling( (uCheck>0) );
            if( FAILED(hr) )
            {
                // Go back to the previous status
                BOOL bUSBAlways = FALSE;
                pAVTapi2->USBGetDefaultUse( &bUSBAlways );
                UINT uCheck = bUSBAlways ? BST_CHECKED : BST_UNCHECKED;
                ::CheckDlgButton( m_hWnd, IDC_CHK_USBALWAYS, uCheck);
                USBCheckChanged( (uCheck>0) ? FALSE : TRUE);
            
            }
        }

        pAVTapi2->Release();
    }


    //
    // Let save the AEC into registry
    //
    uCheck = ::IsDlgButtonChecked(m_hWnd, IDC_CHK_AEC);
    SetAECRegistryValue( (uCheck == BST_CHECKED) );
    
    m_bDirty = FALSE;
	return S_OK;
}

STDMETHODIMP CPageTerminals::Activate( /* [in] */ HWND hWndParent,
									 /* [in] */ LPCRECT pRect,
									 /* [in] */ BOOL bModal)
{
	CPageAddress::m_pPageTerminals = this;

	ATLTRACE(_T(".enter.CPageTerminals::Activate().\n"));

	// Create image lists
	m_hIml = ImageList_LoadBitmap( _Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_TERMINAL_TYPES), IMAGE_WIDTH, 0, RGB(255, 0, 255) );
	m_hImlMedia = ImageList_LoadBitmap( _Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_MEDIA_TYPES), IMAGE_WIDTH, 0, RGB(255, 0, 255) );

	HRESULT hr = IPropertyPageImpl<CPageTerminals>::Activate(hWndParent, pRect, bModal);

	if ( SUCCEEDED(hr) )
	{
		// Popuplate combo box with call types
		TCHAR szText[255];
		UINT nIDS[] = { IDS_TELEPHONE_CALLS, IDS_INTERNET_CALLS, IDS_INTERNET_CONFS };
		DWORD dwType[] = { LINEADDRESSTYPE_PHONENUMBER, LINEADDRESSTYPE_IPADDRESS, LINEADDRESSTYPE_SDP };

		for ( int i = 0; i < ARRAYSIZE(nIDS); i++ )
		{
			LoadString( _Module.GetResourceInstance(), nIDS[i], szText, ARRAYSIZE(szText) );
			int nInd = (int) SendDlgItemMessage( IDC_CBO_CALLTYPE, CB_ADDSTRING, 0, (LPARAM) szText );
			if ( nInd >= 0 )
				SendDlgItemMessage( IDC_CBO_CALLTYPE, CB_SETITEMDATA, nInd, dwType[i] );
		}

		// Load combo boxes with terminal information based on selected call type
		hWnds[0] = GetDlgItem(IDC_CBO_AUDIO_IN);
		hWnds[1] = GetDlgItem(IDC_CBO_AUDIO_OUT);
		hWnds[2] = GetDlgItem(IDC_CBO_VIDEO_IN);
		hWnds[3] = GetDlgItem(IDC_CHK_VIDEO_OUT);
		hWnds[4] = GetDlgItem(IDC_EDT_MAX_WINDOWS);

		IAVTapi *pAVTapi;
		if ( SUCCEEDED(m_ppUnk[0]->QueryInterface(IID_IAVTapi, (void **) &pAVTapi)) )
		{
			// Select the media from the list box
			pAVTapi->get_dwPreferredMedia( &m_dwAddressType );
			SendDlgItemMessage( IDC_CBO_CALLTYPE, CB_SETCURSEL, ItemFromAddressType(m_dwAddressType), 0 );

			pAVTapi->PopulateTerminalsDialog( m_dwAddressType, hWnds );

            //
            // Disable/Enable the check box for the USBPhones
            //
            IAVTapi2* pAVTapi2 = NULL;
            if( SUCCEEDED(pAVTapi->QueryInterface( IID_IAVTapi2, (void**)&pAVTapi2)) )
            {
                // Is USB present
                BOOL bUSBPresent = FALSE;
                pAVTapi2->USBIsPresent( &bUSBPresent );

                // Terminals
                pAVTapi2->USBGetTerminalName( AVTERM_CAPTURE, &m_bstrUSBCaptureTerm );
                pAVTapi2->USBGetTerminalName( AVTERM_RENDER, &m_bstrUSBRenderTerm );

                // Clean-up
                pAVTapi2->Release();

                m_bUSBPresent = bUSBPresent;

                ::EnableWindow(GetDlgItem(IDC_CHK_USBALWAYS), bUSBPresent);
            }

			pAVTapi->Release();
		}

		// Max Video Windows only valid for Multi-cast conferences
		::ShowWindow( GetDlgItem(IDC_EDT_MAX_WINDOWS), (m_dwAddressType == LINEADDRESSTYPE_SDP) ? SW_SHOW : SW_HIDE );
		::ShowWindow( GetDlgItem(IDC_LBL_MAX_WINDOWS), (m_dwAddressType == LINEADDRESSTYPE_SDP) ? SW_SHOW : SW_HIDE );

		::EnableWindow(GetDlgItem(IDC_EDT_MAX_WINDOWS), IsDlgButtonChecked(IDC_CHK_VIDEO_OUT));

		// Put the multimedia control panel icon on the button
		SendDlgItemMessage( IDC_BTN_MMSYS_CPL, BM_SETIMAGE, IMAGE_ICON, (LPARAM) LoadIcon(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDI_MULTIMEDIA)) );

        //
        // Try to get the USB use flag
        //
        IAVTapi2* pAVTapi2 = NULL;
        BOOL bUSBAlways = FALSE;
        if( SUCCEEDED(m_ppUnk[0]->QueryInterface(IID_IAVTapi2, (void**)&pAVTapi2)) )
        {
            pAVTapi2->USBGetDefaultUse( &bUSBAlways );
            pAVTapi2->Release();
        }

        UINT uCheck = bUSBAlways ? BST_CHECKED : BST_UNCHECKED;
        ::CheckDlgButton( m_hWnd, IDC_CHK_USBALWAYS, uCheck);
        USBCheckChanged( (uCheck>0) ? FALSE : TRUE);

        // AEC registry value
        BOOL bAEC = GetAECRegistryValue();
        uCheck = bAEC ? BST_CHECKED : BST_UNCHECKED;
        ::CheckDlgButton( m_hWnd, IDC_CHK_AEC, uCheck);

	}
	
	return hr;
}

STDMETHODIMP CPageTerminals::Deactivate()
{
	CPageAddress::m_pPageTerminals = NULL;
	return IPropertyPageImpl<CPageTerminals>::Deactivate();
}

LRESULT CPageTerminals::OnSelChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	if ( hWndCtl == GetDlgItem(IDC_CBO_CALLTYPE) )
	{
		HCURSOR hCursorOld = SetCursor( LoadCursor(NULL, IDC_WAIT) );
		int nInd = (int) ::SendMessage( hWndCtl, CB_GETCURSEL, 0, 0 );

		if ( nInd >= 0 )
		{
			// Load combo boxes with terminal information based on selected call type
			IAVTapi *pAVTapi;
			if ( SUCCEEDED(m_ppUnk[0]->QueryInterface(IID_IAVTapi, (void **) &pAVTapi)) )
			{
				// Store current terminal information
				pAVTapi->UnpopulateTerminalsDialog( m_dwAddressType, hWnds );
				
				// Load terminal information for selected address
				m_dwAddressType = ::SendMessage( hWndCtl, CB_GETITEMDATA, nInd, 0 );

				// Max Video Windows only valid for Multi-cast conferences
				::ShowWindow( GetDlgItem(IDC_EDT_MAX_WINDOWS), (m_dwAddressType == LINEADDRESSTYPE_SDP) ? SW_SHOW : SW_HIDE );
				::ShowWindow( GetDlgItem(IDC_LBL_MAX_WINDOWS), (m_dwAddressType == LINEADDRESSTYPE_SDP) ? SW_SHOW : SW_HIDE );

				pAVTapi->PopulateTerminalsDialog( m_dwAddressType, hWnds );
				pAVTapi->Release();

				// Re-paint selected call type bitmap
				RECT rc;
				::GetWindowRect( GetDlgItem(IDC_LBL_CALLTYPE), &rc );
				OffsetRect( &rc, -(IMAGE_WIDTH + IMAGE_MARGIN), 0 );
				rc.right = rc.left + IMAGE_WIDTH;
				rc.bottom = rc.top + IMAGE_WIDTH;
				ScreenToClient( &rc );
				InvalidateRect( &rc );

				::EnableWindow(GetDlgItem(IDC_EDT_MAX_WINDOWS), IsDlgButtonChecked(IDC_CHK_VIDEO_OUT));
			}
		}

        if( bHandled )
        {
            UINT uCheck = ::IsDlgButtonChecked(m_hWnd, IDC_CHK_USBALWAYS);
            USBCheckChanged( (uCheck>0) ? FALSE : TRUE);
        }

		SetCursor( hCursorOld );
		bHandled = true;
	}
	else
	{
		// Dirty property page
		SetDirty( TRUE );
	}

	return 0;
}

LRESULT CPageTerminals::OnPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	// Must have valid image list to work
	if ( !m_hIml ) return 0;

	PAINTSTRUCT ps;
	HDC hDC = BeginPaint( &ps );
	if ( !hDC ) return 0;

	// IDS of items to paint
	UINT nID[] = { IDC_LBL_AUDIO_IN,
				   IDC_LBL_AUDIO_OUT,
				   IDC_LBL_VIDEO_IN,
				   IDC_CHK_VIDEO_OUT,
                   IDC_CHK_USBALWAYS,
                   IDC_CHK_AEC};

	RECT rc;
	
	// Paint bitmaps next to corresponding images
	for ( int i = 0; i < ARRAYSIZE(nID); i++ )
	{
		::GetWindowRect( GetDlgItem(nID[i]), &rc );
		ScreenToClient( &rc );

		// Paint image of rect
		ImageList_Draw( m_hIml, i, hDC, rc.left - (IMAGE_WIDTH + IMAGE_MARGIN), rc.top, ILD_NORMAL );
	}

	// Paint bitmap next to selected style of media
	int nInd = SendDlgItemMessage( IDC_CBO_CALLTYPE, CB_GETCURSEL, 0, 0 );
	if ( nInd >= 0 )
	{
		::GetWindowRect( GetDlgItem(IDC_LBL_CALLTYPE), &rc );
		ScreenToClient( &rc );

		ImageList_Draw( m_hImlMedia, ItemFromAddressType(SendDlgItemMessage(IDC_CBO_CALLTYPE, CB_GETITEMDATA, nInd, 0)),
						hDC, rc.left - (IMAGE_WIDTH + IMAGE_MARGIN), rc.top, ILD_NORMAL );
	}

	EndPaint( &ps );
	bHandled = true;
	return 0;
}


LRESULT CPageTerminals::OnEdtChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	SetDirty( true );
	return 0;
}

LRESULT CPageTerminals::OnBnClick(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	switch ( wID )
	{
		case IDC_BTN_MMSYS_CPL:
			return OnMMSysCPL( wNotifyCode, wID, hWndCtl, bHandled );
			break;

		case IDC_CHK_VIDEO_OUT:
			::EnableWindow(GetDlgItem(IDC_EDT_MAX_WINDOWS), IsDlgButtonChecked(IDC_CHK_VIDEO_OUT));
			break;

        case IDC_CHK_USBALWAYS:
            {
                UINT uCheck = ::IsDlgButtonChecked(m_hWnd, IDC_CHK_USBALWAYS);
                USBCheckChanged( (uCheck>0) ? FALSE : TRUE);
            }
            break;
	}


	SetDirty( true );
	return 0;
}

LRESULT CPageTerminals::OnMMSysCPL(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	TCHAR szControl[MAX_PATH];
	TCHAR szCPL[MAX_PATH];

	LoadString( _Module.GetResourceInstance(), IDN_CONTROL_PANEL_EXE, szControl, ARRAYSIZE(szControl) );
	LoadString( _Module.GetResourceInstance(), IDN_CONTROL_MMSYS_CPL, szCPL, ARRAYSIZE(szCPL) );

	return (LRESULT) ShellExecute( GetParent(), NULL, szControl, szCPL, NULL, SW_SHOW );
}

void CPageTerminals::UpdateSel()
{
	HWND hWndCtl = GetDlgItem( IDC_CBO_CALLTYPE );

	if ( hWndCtl )
	{
		BOOL bHandled = FALSE;
		OnSelChange(0, 0, hWndCtl, bHandled);
	}
}

BOOL CPageTerminals::GetAECRegistryValue(
    )
{
    BOOL bAEC = FALSE;
    //
    // Read the registry for the previous 
    // setting for AEC
    //

    TCHAR szText[255], szType[255];
	LoadString( _Module.GetResourceInstance(), IDN_REG_REDIAL_KEY, szText, ARRAYSIZE(szText) );

	CRegKey regKey;
	if( regKey.Open( HKEY_CURRENT_USER, szText, KEY_READ )!= ERROR_SUCCESS)
    {
        return bAEC;
    };

    //
    // Read data
    //

    DWORD dwValue = 0;
	LoadString( _Module.GetResourceInstance(), IDN_REG_REDIAL_AEC, szType, ARRAYSIZE(szType) );
    if( regKey.QueryValue(dwValue, szType) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    return (BOOL)dwValue;
}

HRESULT CPageTerminals::SetAECRegistryValue(
    IN  BOOL bAEC
    )
{
	CRegKey regKey;
    TCHAR szText[255], szType[255];

	LoadString( _Module.GetResourceInstance(), IDN_REG_REDIAL_KEY, szText, ARRAYSIZE(szText) );
	LoadString( _Module.GetResourceInstance(), IDN_REG_REDIAL_AEC, szType, ARRAYSIZE(szType) );

    if( regKey.Create( HKEY_CURRENT_USER, szText) != ERROR_SUCCESS)
    {
        return E_FAIL;
    }

    // Set the value
    if( regKey.SetValue((DWORD)bAEC, szType) != ERROR_SUCCESS)
    {
        return E_FAIL;
    }

    return S_OK;
}


HRESULT CPageTerminals::USBCheckChanged( 
    IN  BOOL bStandard
    )
{
    // Is USB present?
    if( !m_bUSBPresent )
    {
        // We don't have an USB, that's it!
        return S_OK;
    }

    // Enable or disable the comboboxs  
    HWND hWnds[3];
    hWnds[0] = GetDlgItem(IDC_CBO_CALLTYPE);
	hWnds[1] = GetDlgItem(IDC_CBO_AUDIO_IN);
	hWnds[2] = GetDlgItem(IDC_CBO_AUDIO_OUT);

    for( int nWnd = 1; nWnd < 3; nWnd++)
    {
        ::EnableWindow( hWnds[ nWnd ], bStandard);
    }

    if( bStandard )
    {
        BOOL bHandled = FALSE;
        OnSelChange( 0, 0, hWnds[0], bHandled);

        return S_OK;
    }

    //
    // Select the USB handset terminals
    //

    // Capture
    LRESULT res = ::SendMessage( hWnds[1],
        CB_FINDSTRING,
        (WPARAM)-1,
        (LPARAM)m_bstrUSBCaptureTerm);

    if( res != CB_ERR && res != (LRESULT)-1)
    {
        // Change the selectiion in the combobox
        ::SendMessage( hWnds[1], CB_SETCURSEL, (WPARAM)res,0);
    }
    
    // Render
    res = ::SendMessage( hWnds[2],
        CB_FINDSTRING,
        (WPARAM)-1,
        (LPARAM)m_bstrUSBRenderTerm);

    if( res != CB_ERR && res != (LRESULT)-1)
    {
        // Change the selectiion in the combobox
        ::SendMessage( hWnds[2], CB_SETCURSEL, (WPARAM)res,0);
    }


    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\pageaddr.cpp ===
// PageAddress.cpp : Implementation of CPageAddress
#include "stdafx.h"
#include "PageAddress.h"
#include "TapiDialer.h"
#include "AVTapi.h"
#include "PageTerm.h"

#define IMAGE_WIDTH		16
#define IMAGE_MARGIN	5

/////////////////////////////////////////////////////////////////////////////
// CPageAddress

// Static for simplicity, note that this won't scale well.
CPageTerminals *CPageAddress::m_pPageTerminals = NULL;

IMPLEMENT_MY_HELP(CPageAddress)

CPageAddress::CPageAddress()
{
	m_dwTitleID = IDS_TITLEPageAddress;
	m_dwHelpFileID = IDS_HELPFILEPageAddress;
	m_dwDocStringID = IDS_DOCSTRINGPageAddress;

	m_hIml = NULL;
}

CPageAddress::~CPageAddress()
{
	if ( m_hIml )	ImageList_Destroy( m_hIml );
}

int CPageAddress::GetPreferredDevice() const
{
	if ( IsDlgButtonChecked(IDC_RDO_PREFER_POTS) ) return LINEADDRESSTYPE_PHONENUMBER;

	return LINEADDRESSTYPE_IPADDRESS;
}

void CPageAddress::SetPreferredDevice( DWORD dwAddressType )
{
#define CASE_HELP(_CASE_,_IDC_,_CBO_)	case _CASE_:	nCheck = _IDC_; nIDCBO = _CBO_; break;

	// Enable only radio buttons that have a device on them
	int i;
	UINT nIDS[] = { IDC_CBO_POTS, IDC_CBO_IPTELEPHONY, IDC_CBO_IPCONF };
	for ( i = 0; i < ARRAYSIZE(nIDS) - 1; i++ )
		::EnableWindow( GetDlgItem(IDC_RDO_PREFER_POTS + i), ::IsWindowEnabled(GetDlgItem(nIDS[i])) );

	// Which one should be checked?
	UINT nCheck, nIDCBO;
	switch ( dwAddressType )
	{
		CASE_HELP( LINEADDRESSTYPE_SDP,			IDC_RDO_PREFER_CONF, IDC_CBO_IPCONF)
		CASE_HELP( LINEADDRESSTYPE_PHONENUMBER,	IDC_RDO_PREFER_POTS, IDC_CBO_POTS )
		default: nCheck = IDC_RDO_PREFER_INTERNET;	nIDCBO = IDC_CBO_IPTELEPHONY;	break;
	}

	// If the window has no items supported, lets look for one that does
	if ( !::IsWindowEnabled(GetDlgItem(nIDCBO)) )
	{
		for ( i = 0; i < ARRAYSIZE(nIDS) - 1; i++ )
			if ( ::IsWindowEnabled(GetDlgItem(nIDS[i])) )
				nCheck = IDC_RDO_PREFER_POTS + i;
	}

	// Now put the check in place
	CheckRadioButton(IDC_RDO_PREFER_POTS, IDC_RDO_PREFER_INTERNET, nCheck);
}

STDMETHODIMP CPageAddress::Apply()
{
	ATLTRACE(_T("CPageAddress::Apply\n"));

	IAVTapi *pAVTapi;
	if ( SUCCEEDED(m_ppUnk[0]->QueryInterface(IID_IAVTapi, (void **) &pAVTapi)) )
	{
		pAVTapi->UnpopulateAddressDialog( GetPreferredDevice(), GetDlgItem(IDC_CBO_POTS), GetDlgItem(IDC_CBO_IPTELEPHONY), GetDlgItem(IDC_CBO_IPCONF) );
		pAVTapi->Release();
	}

	// Make sure that the terminals property page updates it's list of terminals
	if ( m_pPageTerminals )
		m_pPageTerminals->UpdateSel();

	m_bDirty = FALSE;
	return S_OK;
}

STDMETHODIMP CPageAddress::Activate( /* [in] */ HWND hWndParent,
									 /* [in] */ LPCRECT pRect,
									 /* [in] */ BOOL bModal)
{
	ATLTRACE(_T(".enter.CPageAddress::Activate().\n"));

	// Set the title of the property sheet
	HWND hWndSheet = ::GetParent(hWndParent);
	if ( hWndSheet )
	{
		TCHAR szText[255];
		LoadString( _Module.GetResourceInstance(), IDS_PROPSHEET_TITLE, szText, ARRAYSIZE(szText) );
		::SetWindowText( hWndSheet, szText );

		ConvertPropSheetHelp( hWndSheet );
	}
	
	// Create the image list
	m_hIml = ImageList_LoadBitmap( _Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_MEDIA_TYPES), IMAGE_WIDTH, 0, RGB(255, 0, 255) );

	// Stock processing of message
	HRESULT hr = IPropertyPageImpl<CPageAddress>::Activate(hWndParent, pRect, bModal);

	// Populate the drop lists with the appropriate information
	if ( SUCCEEDED(hr) )
	{
		IAVTapi *pAVTapi;
		if ( SUCCEEDED(m_ppUnk[0]->QueryInterface(IID_IAVTapi, (void **) &pAVTapi)) )
		{
			DWORD dwPreferred;
			pAVTapi->PopulateAddressDialog( &dwPreferred, GetDlgItem(IDC_CBO_POTS), GetDlgItem(IDC_CBO_IPTELEPHONY), GetDlgItem(IDC_CBO_IPCONF) );
			SetPreferredDevice( dwPreferred );
			pAVTapi->Release();
		}
	}

	// Put the telephony control panel icon on the button
	SendDlgItemMessage( IDC_BTN_TELEPHONY_CPL, BM_SETIMAGE, IMAGE_ICON, (LPARAM) LoadIcon(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDI_TELEPHONY_CPL)) );
	
	return hr;
}

STDMETHODIMP CPageAddress::Deactivate()
{
	// Delete everything that's allocated
	UINT nID[] = { IDC_CBO_POTS, IDC_CBO_IPTELEPHONY, IDC_CBO_IPCONF };
	for ( int i = 0; i < ARRAYSIZE(nID); i++ )
	{
		HWND hWnd = GetDlgItem( nID[i] );

		// Clean out each combobox
		long lCount = ::SendMessage(hWnd, CB_GETCOUNT, 0, 0 );
		for ( long j = 0; j < lCount; j++ )
		{
			CMyAddressID *pMyID = (CMyAddressID *) ::SendMessage( hWnd, CB_GETITEMDATA, j, 0 );
			if ( pMyID ) delete pMyID;
		}
	}

	return IPropertyPageImpl<CPageAddress>::Deactivate();
}

LRESULT CPageAddress::OnSelChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	SetDirty( TRUE );
	return 0;
}

LRESULT CPageAddress::OnPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	// Must have valid image list to work
	if ( !m_hIml ) return 0;

	PAINTSTRUCT ps;
	HDC hDC = BeginPaint( &ps );
	if ( !hDC ) return 0;

	// IDS of items to paint
	UINT nID[] = { IDC_RDO_PREFER_POTS,
				   IDC_RDO_PREFER_INTERNET,
				   IDC_RDO_PREFER_CONF };

	UINT nIDLabel[] = { IDC_LBL_POTS,
						IDC_LBL_INTERNET,
						IDC_LBL_CONF };
	
	// Paint bitmaps next to corresponding images
	for ( int j = 0; j < 2; j++ )
	{
		for ( int i = 0; i < ARRAYSIZE(nID); i++ )
		{	
			HWND hWnd = GetDlgItem( (j == 0) ? nID[i] : nIDLabel[i] );
			if ( ::IsWindow(hWnd) )
			{
				RECT rc;
				::GetWindowRect( hWnd, &rc );
				ScreenToClient( &rc );

				// Paint image of rect
				ImageList_Draw( m_hIml, i, hDC, rc.left - (IMAGE_WIDTH + IMAGE_MARGIN), rc.top, ILD_NORMAL );
			}
		}
	}

	EndPaint( &ps );
	bHandled = true;
	return 0;
	
}

LRESULT CPageAddress::OnTelephonyCPL(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	TCHAR szControl[MAX_PATH];
	TCHAR szCPL[MAX_PATH];

	LoadString( _Module.GetResourceInstance(), IDN_CONTROL_PANEL_EXE, szControl, ARRAYSIZE(szControl) );
	LoadString( _Module.GetResourceInstance(), IDN_CONTROL_TELEPHON_CPL, szCPL, ARRAYSIZE(szCPL) );

	return (LRESULT) ShellExecute( GetParent(), NULL, szControl, szCPL, NULL, SW_SHOW );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\pageterm.h ===
// PageTerminals.h : Declaration of the CPageTerminals

#ifndef __PAGETERMINALS_H_
#define __PAGETERMINALS_H_

#include "resource.h"       // main symbols
#include "DlgBase.h"
#include "TapiDialer.h"

EXTERN_C const CLSID CLSID_PageTerminals;

/////////////////////////////////////////////////////////////////////////////
// CPageTerminals
class ATL_NO_VTABLE CPageTerminals :
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CPageTerminals, &CLSID_PageTerminals>,
	public IPropertyPageImpl<CPageTerminals>,
	public CDialogImpl<CPageTerminals>
{
public:
	CPageTerminals();
	~CPageTerminals();

	enum {IDD = IDD_PAGETERMINALS};
	enum { IMAGE_TELEPHONE,
		   IMAGE_COMPUTER,
		   IMAGE_CONFERENCE };

	DECLARE_MY_HELP

// Members
public:
	HIMAGELIST		m_hIml;
	HIMAGELIST		m_hImlMedia;
	DWORD			m_dwAddressType;
    BOOL            m_bUSBPresent;
    BSTR            m_bstrUSBCaptureTerm;
    BSTR            m_bstrUSBRenderTerm;

// Attributes
public:
	static int		ItemFromAddressType( DWORD dwAddressType );

// Operations
public:
	void			UpdateSel();

DECLARE_REGISTRY_RESOURCEID(IDR_PAGETERMINALS)
DECLARE_NOT_AGGREGATABLE(CPageTerminals)

BEGIN_COM_MAP(CPageTerminals) 
	COM_INTERFACE_ENTRY_IMPL(IPropertyPage)
END_COM_MAP()

// Implementation
public:
BEGIN_MSG_MAP(CPageTerminals)
	CHAIN_MSG_MAP(IPropertyPageImpl<CPageTerminals>)
	COMMAND_CODE_HANDLER(CBN_SELCHANGE, OnSelChange)
	COMMAND_CODE_HANDLER(EN_CHANGE, OnEdtChange)
	COMMAND_CODE_HANDLER(BN_CLICKED, OnBnClick)
	MESSAGE_HANDLER(WM_PAINT, OnPaint)
	MESSAGE_MY_HELP
END_MSG_MAP()

	LRESULT OnSelChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnEdtChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnBnClick(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnMMSysCPL(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

// Interface overrides
public:
	STDMETHOD(Apply)();
	STDMETHOD(Activate)( /* [in] */ HWND hWndParent,
						 /* [in] */ LPCRECT pRect,
						 /* [in] */ BOOL bModal);
	STDMETHOD(Deactivate)();

private:
    HRESULT USBCheckChanged( 
        IN  BOOL bValue
        );

    BOOL GetAECRegistryValue(
        );

    HRESULT SetAECRegistryValue(
        IN  BOOL bAEC
        );
};

#endif //__PAGETERMINALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\particip.cpp ===
// Particip.cpp : Implementation of CParticipant
#include "stdafx.h"
#include "TapiDialer.h"
#include "avTapi.h"
#include "Particip.h"

/////////////////////////////////////////////////////////////////////////////
// CParticipant

CParticipant::CParticipant()
{
	m_pParticipant = NULL;
}

CParticipant::~CParticipant()
{
}

void CParticipant::FinalRelease()
{
	ATLTRACE(_T(".enter.CParticipant::FinalRelease().\n") );

#ifdef _DEBUG
	USES_CONVERSION;
	if ( m_pParticipant )
	{
		BSTR bstrName = NULL;
		m_pParticipant->AddRef();
		get_bstrDisplayName( NAMESTYLE_PARTICIPANT, &bstrName );
		ATLTRACE(_T(".1.CParticipant::FinalRelease() -- participant %s ref @ %ld.\n"), OLE2CT(bstrName), m_pParticipant->Release() );
	}
#endif

	put_ITParticipant( NULL );
}

STDMETHODIMP CParticipant::get_ITParticipant(ITParticipant **ppVal)
{
	HRESULT hr = E_FAIL;
	*ppVal = NULL;

	Lock();
	if ( m_pParticipant )
		hr = m_pParticipant->QueryInterface( IID_ITParticipant, (void **) ppVal );
	Unlock();

	return hr;
}

STDMETHODIMP CParticipant::put_ITParticipant(ITParticipant * newVal)
{
	HRESULT hr = S_OK;

	Lock();
	RELEASE( m_pParticipant );
	if ( newVal )
		hr = newVal->QueryInterface( IID_ITParticipant, (void **) &m_pParticipant );
	Unlock();

	return hr;
}

STDMETHODIMP CParticipant::get_bstrDisplayName(long nStyle, BSTR *pbstrName )
{
	USES_CONVERSION;
	*pbstrName = NULL;

	// Retrieve name from participant info
	Lock();
	if ( m_pParticipant )
   {
		m_pParticipant->get_ParticipantTypedInfo( PTI_NAME, pbstrName );
      if (!*pbstrName || !SysStringLen(*pbstrName))
      {
         if ( *pbstrName ) SysFreeString( *pbstrName );
   		m_pParticipant->get_ParticipantTypedInfo( PTI_CANONICALNAME, pbstrName );
      }
   }

	Unlock();

	// Use default name in absensce of real name
	if ( nStyle && (!*pbstrName || !SysStringLen(*pbstrName)) )
	{
		TCHAR szText[255];
		UINT nIDS = (nStyle == (long) NAMESTYLE_UNKNOWN) ? IDS_UNKNOWN : IDS_PARTICIPANT;
		LoadString( _Module.GetResourceInstance(), nIDS, szText, ARRAYSIZE(szText) );
		*pbstrName = SysAllocString( T2COLE(szText) );
	}
	
	return S_OK;
}

STDMETHODIMP CParticipant::get_bStreamingVideo(VARIANT_BOOL * pVal)
{
	HRESULT hr;
	long lMediaType = 0;

	ITParticipant *pParticipant;
	if ( SUCCEEDED(hr = get_ITParticipant(&pParticipant)) )
	{
       	pParticipant->get_MediaTypes( &lMediaType );
		pParticipant->Release();
	}

	*pVal = (VARIANT_BOOL) ((lMediaType & TAPIMEDIATYPE_VIDEO) != 0);
	return hr;
}

HRESULT StreamFromParticipant( ITParticipant *pParticipant, long nReqType, TERMINAL_DIRECTION nReqDir, ITStream **ppStream )
{
	_ASSERT( ppStream );
	*ppStream = NULL;

	HRESULT hr;
	bool bContinue = true;
	IEnumStream *pEnum;
	if ( SUCCEEDED(hr = pParticipant->EnumerateStreams(&pEnum)) )
	{
		ITStream *pStream;
		while ( bContinue && ((hr = pEnum->Next(1, &pStream, NULL)) == S_OK) )
		{
			long nMediaType;
			TERMINAL_DIRECTION nDir;

			pStream->get_MediaType( &nMediaType );
			if ( nMediaType == nReqType )
			{
				pStream->get_Direction( &nDir );
				if ( nDir == nReqDir )
				{
					hr = pStream->QueryInterface( IID_ITStream, (void **) ppStream );
					bContinue = false;
				}
			}
			pStream->Release();
		}

		// Didn't find a stream of the requested type
		if ( bContinue && (hr == S_FALSE) ) 
			hr = E_FAIL;

		pEnum->Release();
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\pedtlsvw.h ===
// PEDtlsVw.h : Declaration of the CPersonExplorerDetailsView

#ifndef __PERSONEXPLORERDETAILSVIEW_H_
#define __PERSONEXPLORERDETAILSVIEW_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CPersonExplorerDetailsView
class ATL_NO_VTABLE CPersonExplorerDetailsView : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CPersonExplorerDetailsView, &CLSID_PersonExplorerDetailsView>,
	public IPersonExplorerDetailsView
{
public:
	CPersonExplorerDetailsView()
	{
	}

DECLARE_NOT_AGGREGATABLE(CPersonExplorerDetailsView)

BEGIN_COM_MAP(CPersonExplorerDetailsView)
	COM_INTERFACE_ENTRY(IPersonExplorerDetailsView)
END_COM_MAP()

// IPersonExplorerDetailsView
public:
};

#endif //__PERSONEXPLORERDETAILSVIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\pedtlsvw.cpp ===
// PEDtlsVw.cpp : Implementation of CPersonExplorerDetailsView
#include "stdafx.h"
#include "TapiDialer.h"
#include "PEDtlsVw.h"

/////////////////////////////////////////////////////////////////////////////
// CPersonExplorerDetailsView
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\persexp.cpp ===
// PersExp.cpp : Implementation of CPersonExplorer
#include "stdafx.h"
#include "TapiDialer.h"
#include "PersExp.h"

/////////////////////////////////////////////////////////////////////////////
// CPersonExplorer


STDMETHODIMP CPersonExplorer::UnShow()
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CPersonExplorer::Show(HWND hWndTree, HWND hWndDetails)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CPersonExplorer::get_DetailsView(IPersonExplorerDetailsView **ppVal)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CPersonExplorer::get_TreeView(IPersonExplorerTreeView **ppVal)
{
	// TODO: Add your implementation code here

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\petreeview.cpp ===
// PETreeView.cpp : Implementation of CPersonExplorerTreeView
#include "stdafx.h"
#include "TapiDialer.h"
#include "PETreeView.h"

/////////////////////////////////////////////////////////////////////////////
// CPersonExplorerTreeView
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\particip.h ===
// Particip.h : Declaration of the CParticipant

#ifndef __PARTICIPANT_H_
#define __PARTICIPANT_H_

#include "resource.h"       // main symbols
#include "tapi3if.h"
#include <list>
using namespace std;

HRESULT StreamFromParticipant( ITParticipant *pParticipant, long nReqType, TERMINAL_DIRECTION nReqDir, ITStream **ppStream );

/////////////////////////////////////////////////////////////////////////////
// CParticipant
class ATL_NO_VTABLE CParticipant : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CParticipant, &CLSID_Participant>,
	public IParticipant
{
// Enums
public:
	typedef enum tag_NameStyle_t
	{
		NAMESTYLE_NULL,
		NAMESTYLE_UNKNOWN,
		NAMESTYLE_PARTICIPANT,
	} NameStyle;

// Construction / Destruction
public:
	CParticipant();
	virtual ~CParticipant();

	void FinalRelease();

// Attributes
public:
	ITParticipant	*m_pParticipant;

DECLARE_NOT_AGGREGATABLE(CParticipant)

BEGIN_COM_MAP(CParticipant)
	COM_INTERFACE_ENTRY(IParticipant)
END_COM_MAP()

// IParticipant
public:
	STDMETHOD(get_bStreamingVideo)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(get_bstrDisplayName)(long nStyle, /*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_ITParticipant)(/*[out, retval]*/ ITParticipant * *pVal);
	STDMETHOD(put_ITParticipant)(/*[in]*/ ITParticipant * newVal);
};

typedef list<IParticipant *>	PARTICIPANTLIST;

#endif //__PARTICIPANT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\persexp.h ===
// PersExp.h : Declaration of the CPersonExplorer

#ifndef __PERSONEXPLORER_H_
#define __PERSONEXPLORER_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CPersonExplorer
class ATL_NO_VTABLE CPersonExplorer : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CPersonExplorer, &CLSID_PersonExplorer>,
	public IPersonExplorer
{
public:
	CPersonExplorer()
	{
	}

DECLARE_NOT_AGGREGATABLE(CPersonExplorer)

BEGIN_COM_MAP(CPersonExplorer)
	COM_INTERFACE_ENTRY(IPersonExplorer)
END_COM_MAP()

// IPersonExplorer
public:
	STDMETHOD(get_TreeView)(/*[out, retval]*/ IPersonExplorerTreeView **ppVal);
	STDMETHOD(get_DetailsView)(/*[out, retval]*/ IPersonExplorerDetailsView **ppVal);
	STDMETHOD(Show)(HWND hWndTree, HWND hWndDetails);
	STDMETHOD(UnShow)();
};

#endif //__PERSONEXPLORER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\petreeview.h ===
// PETreeView.h : Declaration of the CPersonExplorerTreeView

#ifndef __PERSONEXPLORERTREEVIEW_H_
#define __PERSONEXPLORERTREEVIEW_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CPersonExplorerTreeView
class ATL_NO_VTABLE CPersonExplorerTreeView : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CPersonExplorerTreeView, &CLSID_PersonExplorerTreeView>,
	public IPersonExplorerTreeView
{
public:
	CPersonExplorerTreeView()
	{
	}

DECLARE_NOT_AGGREGATABLE(CPersonExplorerTreeView)

BEGIN_COM_MAP(CPersonExplorerTreeView)
	COM_INTERFACE_ENTRY(IPersonExplorerTreeView)
END_COM_MAP()

// IPersonExplorerTreeView
public:
};

#endif //__PERSONEXPLORERTREEVIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by TapiDialer.rc
//
#define IDC_BTN_ADD_NEW_FOLDER          1
#define IDS_PROJNAME                    100
#define IDR_AVTAPI                      101
#define IDD_DLGPLACECALL                102
#define IDS_PLACECALL_IDLE              106
#define IDR_CALLNOTIFICATION            113
#define IDR_CONFEXPLORER                118
#define IDR_CONFEXPLORERTREEVIEW        119
#define IDR_CONFEXPLORERDETAILSVIEW     120
#define IDS_EXPLORE_COLUMN_NAME         121
#define IDS_EXPLORE_COLUMN_PURPOSE      122
#define IDS_EXPLORE_COLUMN_STARTS       123
#define IDS_EXPLORE_COLUMN_ENDS         124
#define IDS_EXPLORE_COLUMN_ORIGINATOR   125
#define IDS_EXPLORE_COLUMN_SERVER       127
#define ID_LST_CONFTREE                 128
#define IDD_DLGTEST                     129
#define IDS_CONFSERV_ROOT               129
#define IDR_AVTAPINOTIFICATION          130
#define IDR_AVTAPICALL                  131
#define IDN_REG_REDIAL_INDEX            132
#define IDN_REG_REDIAL_MAX              133
#define IDN_REG_REDIAL_ENTRY            134
#define IDN_REG_REDIAL_KEY              135
#define IDS_MSG_DUPLICATE_CONF          136
#define IDR_TAPINOTIFICATION            137
#define IDR_CONFROOM                    144
#define IDR_CONFROOMTREEVIEW            145
#define IDW_TALKER                      147
#define IDW_MEMBERS                     148
#define IDD_DLGTESTCONF                 149
#define IDW_RESERVED1                   150
#define IDD_DLGADDCONFSERVER            151
#define IDD_DLGCONFROOMTALKER           153
#define IDB_STOCK_FEED                  154
#define IDC_AVI_PLAYER                  155
#define IDS_TITLEPageAddress            157
#define IDS_HELPFILEPageAddress         158
#define IDS_DOCSTRINGPageAddress        159
#define IDD_DLGJOINCONFERENCE           160
#define IDD_PAGEADDRESS                 161
#define IDS_TITLEPageTerminals          162
#define IDS_HELPFILEPageTerminals       163
#define IDS_DOCSTRINGPageTerminals      164
#define IDR_PAGETERMINALS               165
#define IDS_PROPSHEET_TITLE             165
#define IDD_PAGETERMINALS               166
#define IDS_TITLEPagePhone              166
#define IDS_DOCSTRINGPagePhone          167
#define IDS_TITLEPageNet                168
#define IDR_AVGENERALNOTIFICATION       169
#define IDS_DOCSTRINGPageNet            169
#define IDR_PERSONEXPLORER              170
#define CONFROOM_TOOLTIP                173
#define IDS_TITLEPageConf               176
#define IDS_HELPFILEPageConf            177
#define IDS_DOCSTRINGPageConf           178
#define IDR_PAGECONF                    179
#define IDD_PAGECONF                    180
#define IDD_DLGGETADDRESS               181
#define IDD_DLGGENERAL                  182
#define IDS_TITLEPageGeneral            183
#define IDS_HELPFILEPageGeneral         184
#define IDS_DOCSTRINGPageGeneral        185
#define IDR_PAGEGENERAL                 186
#define IDD_PAGEGENERAL                 187
#define IDN_REG_MEDIATYPE_POTS          200
#define IDC_BTN_EXPLORE                 201
#define IDN_REG_MEDIATYPE_INTERNET      201
#define IDI_PLACECALL                   202
#define IDN_REG_MEDIATYPE_CONFERENC     202
#define IDC_CBO_ADDRESS                 204
#define IDC_CBO_ADDRESS_TYPE            205
#define IDC_LBL_WELCOME                 206
#define IDC_ICO_ACTION                  207
#define IDC_EDT_NAME                    208
#define IDB_SM_PHONE                    208
#define IDC_EDT_DESCRIPTION             209
#define IDB_SM_CONFERENCE               209
#define IDB_SM_MACHINE                  210
#define IDB_SM_IPADDRESS                211
#define IDC_TREE1                       211
#define IDB_SM_EMAIL                    212
#define IDC_LST_CONFS                   212
#define IDB_LST_CONFSERV                213
#define IDB_LST_CONFSERV_MASK           214
#define IDR_POPUP_CONFSERV_DETAILS      214
#define IDR_POPUP_CONFSERV_TREE         215
#define IDC_TALKER                      216
#define IDR_POPUP_CONFROOM_DETAILS      216
#define IDB_VIDEO                       217
#define IDR_POPUP_CONFROOM_TREE         217
#define IDC_BTN_SECURITY                218
#define IDC_EDT_LOCATION                218
#define IDB_LST_CONFROOM                218
#define IDB_LST_CONFROOM_MASK           219
#define IDC_RADIO_ADMIN                 220
#define IDC_LBL_CALLERID                220
#define IDC_RADIO_PARTICIPATE           221
#define IDC_ANIMATE                     221
#define IDC_RADIO_MONITOR               222
#define IDC_LBL_STATUS                  222
#define IDB_DISCONNECTED                222
#define IDC_BTN_ADD                     223
#define IDC_BTN_REMOVE                  224
#define IDC_RADIO_DENIED                225
#define IDC_CBO_POTS                    225
#define IDC_CBO_TRUSTEE                 226
#define IDR_AVI_CONNECTED               226
#define IDC_CBO_IPTELEPHONY             226
#define IDC_CBO_IPCONF                  227
#define IDC_CBO_PREFERRED               228
#define IDC_RDO_POTS                    228
#define IDC_RDO_INTERNET                229
#define IDC_RDO_CONF                    230
#define IDR_PAGEADDRESS                 232
#define IDC_CBO_CALLTYPE                232
#define IDC_FRA_CALLTYPE                233
#define IDC_CBO_AUDIO_IN                234
#define IDB_MEDIA_TYPES                 234
#define IDC_CBO_AUDIO_OUT               235
#define IDB_TERMINAL_TYPES              235
#define IDC_CBO_VIDEO_IN                236
#define IDI_TELEPHONY_CPL               236
#define IDC_LBL_AUDIO_IN                237
#define IDI_MULTIMEDIA                  237
#define IDC_LBL_AUDIO_OUT               238
#define IDB_CONFDETAILS                 238
#define IDC_LBL_VIDEO_IN                239
#define IDB_CONFDETAILS_STATE           239
#define IDC_LBL_POTS                    240
#define IDC_LBL_INTERNET                241
#define IDC_LBL_CONF                    242
#define IDC_LBL_CALLTYPE                243
#define IDC_CBO_LOCATION                247
#define IDC_BTN_TELEPHONY_CPL           248
#define IDC_CHK_VIDEO_OUT               249
#define IDN_REG_ADDRTYPE_CONFERENCE     250
#define IDC_LBL_MAX_WINDOWS             250
#define IDN_REG_ADDRTYPE_SMTP           251
#define IDN_REG_ADDRTYPE_TCPIP          252
#define IDN_REG_ADDRTYPE_MACHINE        253
#define IDN_REG_ADDRTYPE_PHONENUMBER    254
#define IDC_BTN_MMSYS_CPL               254
#define IDC_LBL_WELCOME_PAGEADDRESS     255
#define IDC_LBL_WELCOME_PAGETERMINALS   256
#define IDC_BTN_PLACECALL               257
#define IDC_LBL_WELCOME_JOIN            258
#define IDC_BTN_JOIN_CONFERENCE         259
#define IDC_ICO_WELCOME_JOIN            260
#define IDC_BTN_ADD_ILS_SERVER          261
#define IDC_RDO_PREFER_POTS             262
#define IDC_RDO_PREFER_INTERNET         263
#define IDC_RDO_PREFER_CONF             264
#define IDC_BTN_ADD_ACE                 265
#define IDC_EDT_ADDRESS                 267
#define IDC_CBO_LINE                    268
#define IDC_LBL_LINE                    269
#define IDC_CHK_ADD_SPEEDDIAL           270
#define IDC_FRM_SCOPE                   276
#define IDC_LBL_SCOPE                   277
#define IDC_LST_SCOPE                   278
#define IDC_CHK_USBALWAYS               279
#define IDC_CHK_AEC                     280
#define IDN_REG_CONFSERV_KEY            300
#define IDN_REG_CONFSERV_VIEW_KEY       301
#define IDN_REG_CONFSERV_ENTRY          302
#define IDN_REG_CONFSERV_SORT_COLUMN    303
#define IDN_REG_CONFSERV_SORT_ASCENDING 304
#define IDN_REG_CONFROOM_VIEW_KEY       305
#define IDN_REG_CONFROOM_VIDEOSIZE      306
#define IDN_REG_CONFROOM_SHOWNAMES      307
#define IDN_REG_CONFROOM_SHOWNAMES_NUMLINES 308
#define IDN_REG_CONFSERV_REFRESHINTERVAL 309
#define IDN_REG_DLGJOINCONF_SORT_COLUMN 310
#define IDN_REG_DLGJOINCONF_SORT_ASCENDING 311
#define IDN_REG_DLGJOINCONF_ENTRY       312
#define IDN_REG_DLGJOINCONF_VIEW_KEY    313
#define IDN_REG_REDIAL_PREFERRED_MEDIA  314
#define IDN_REG_REDIAL_ADDRESS_POTS     315
#define IDN_REG_REDIAL_ADDRESS_INTERNET 316
#define IDN_REG_REDIAL_ADDRESS_CONF     317
#define IDN_REG_REDIAL_TERMINAL_AUDIO_CAPTURE 318
#define IDN_REG_REDIAL_TERMINAL_AUDIO_RENDER 319
#define IDN_REG_REDIAL_TERMINAL_VIDEO_CAPTURE 320
#define IDN_REG_REDIAL_TERMINAL_VIDEO_RENDER 321
#define IDN_REG_REDIAL_TERMINAL_MAX_VIDEO 322
#define IDN_REG_REDIAL_ADDRESS_POTS_ADDR 323
#define IDN_REG_REDIAL_ADDRESS_INTERNET_ADDR 324
#define IDN_REG_REDIAL_ADDRESS_CONF_ADDR 325
#define IDN_REG_DIRECTORY_ILSSERVERS    326
#define IDN_REG_DIRECTORY_ILS_ENTRY     327
#define IDN_REG_CONFROOM_TALKER_SCALE   328
#define IDN_REG_CONFSERV_DEFAULTSERVER  329
#define IDN_REG_AUTOCLOSECALLS          330
#define IDN_REG_DIALER_KEY              331
#define IDN_REG_REDIAL_USBALWAYS        332
#define IDN_REG_REDIAL_AEC              333
#define IDN_REG_REDIAL_USBTERMS         334
#define IDN_REG_REDIAL_USBCAPTURE       335
#define IDN_REG_REDIAL_USBRENDER        336
#define IDR_ANIMATION                   400
#define IDN_CONTROL_PANEL_EXE           500
#define IDN_CONTROL_TELEPHON_CPL        501
#define IDN_CONTROL_MMSYS_CPL           502
#define IDS_ER_PLACECALL                1000
#define IDS_ER_COINITIALIZE             1001
#define IDS_ER_FIRE_NEW_CALL            1002
#define IDS_ER_ALLOC                    1003
#define IDS_ER_ANSWER_CALL              1004
#define IDS_ER_GET_ADDRESS              1005
#define IDS_ER_CREATE_CALL              1006
#define IDS_ER_CREATE_THREAD            1007
#define IDS_ER_ATL_ADVISE               1008
#define IDS_ER_SET_TAPI_NOTIFICATION    1009
#define IDS_ER_ENUM_VOICE_ADDRESSES     1010
#define IDS_ER_REGISTER_CALL_TYPES      1011
#define IDS_ER_INIT_TAPI                1012
#define IDS_ER_CREATE_TAPI_OBJECT       1013
#define IDS_ER_INITIALIZE_TAPI          1014
#define IDS_ER_CREATE_TAPI_NOTIFICATION_OBJECT 1015
#define IDS_ER_UNMARSHAL                1016
#define IDS_ER_THREAD_MSG_PROCESS       1017
#define IDS_ER_CALL_DISCONNECT          1018
#define IDS_ER_CALL_ENTERCONFROOM       1019
#define IDS_ER_CONVERT_CONF_ADDRESS     1020
#define IDS_ER_CALLING_CONNECT          1021
#define IDS_ER_GENERAL_OPERATION        1022
#define IDS_ER_GENERAL_DETAILS          1023
#define IDS_ER_VIDEOWINDOW_MANIPULATION 1024
#define IDS_ER_ENUMERATEDS              1025
#define IDS_ER_CREATETERMINALS          1026
#define IDS_ER_SELECTTERMINALS          1027
#define IDS_ER_NO_LINES_OPEN            1028
#define IDS_ER_CREATE_TERMINALS         1029
#define IDS_ER_CREATE_VIDEO_RENDER      1030
#define IDS_ER_QUERY_AVCALL             1031
#define IDS_ER_QUERY_VIDEOWINDOW        1032
#define IDS_ER_CREATE_AUDIO_CAPTURE     1033
#define IDS_ER_CREATE_AUDIO_RENDER      1034
#define IDS_ER_CREATE_VIDEO_CAPTURE     1035
#define IDS_ER_CREATE_CONF              1036
#define IDS_ER_GET_RENDEZVOUS           1037
#define IDS_ER_ACCESS_ILS_SERVER        1038
#define IDS_ER_ADD_CONF_TO_SERVER       1039
#define IDS_NO_VALID_SELECTION          1040
#define IDS_ER_NO_VALID_SELECTION       1040
#define IDS_ER_TRANSLATE_ADDRESS        1041
#define IDS_ER_TRANSLATING_ADDRESS      1042
#define IDS_ER_CREATE_TERMINAL_FAILED   1043
#define IDS_ER_ADD_ILS_USER             1044
#define IDS_ER_ADD_ACCESS_ILS_SERVER    1045
#define IDS_ER_CONFERENCE_ROOM_LIMIT_EXCEEDED 1046
#define IDS_ER_RENAME_TREEVIEW_ITEM     1047
#define IDS_ER_RENAME_UNALLOWED_IN_QUERY 1048
#define IDS_ER_EDIT_CONFERENCE          1049
#define IDS_ER_GET_CONFERENCE_OBJECT    1050
#define IDS_ER_MODIFY_CONF              1051
#define IDS_ER_MAX_VIDEO_EXCEEDED       1052
#define IDS_ER_CREATE_WINDOWS           1053
#define IDS_ER_CONF_DELETE              1054
#define IDS_ER_QUERYINTERFACE           1055
#define IDS_ER_DELETE_FROM_SERVER       1056
#define IDS_ER_CONNECT_CALL             1057
#define IDS_ER_CALL_TRANSFER            1058
#define IDS_ER_SWAPHOLD                 1059
#define IDS_ER_SWAPHOLD_FIND_CANDIDATE  1060
#define IDS_ER_SWAPHOLD_EXECUTE         1061
#define IDS_ER_TAPI_ANSWER_CALL         1062
#define IDS_ER_CALLMEDIA                1063
#define IDS_ER_CALLMEDIA_STREAMFAIL     1064
#define IDS_ER_CALLMEDIA_TERMINALFAIL   1065
#define IDS_ER_CMC_BADDEVICE            1066
#define IDS_ER_CMC_CONNECT_FAIL         1067
#define IDS_ER_CMC_REMOTE_REQUEST       1068
#define IDS_ER_CMC_MEDIA_TIMEOUT        1069
#define IDS_ER_CMC_MEDIA_RECOVERED      1070
#define IDS_ER_ADD_CONF_FAIL_DUPLICATE  1071
#define IDS_ER_ADD_CONF_FAIL_ACCESSDENIED_TRYAGAIN 1072
#define IDS_DEFAULT_SERVER              2000
#define IDS_CONFROOM_CONF_CONNECTED     2001
#define IDS_CONFROOM_CONF_DISCONNECTED  2002
#define IDS_CONFIRM_REMOVE_SERVER       2003
#define IDS_CONFIRM_CONFROOM_DISCONNECT 2004
#define IDS_CONFROOM_ROOT               2005
#define IDS_CONFROOM_ME                 2006
#define IDS_PLACECALL_BTN_JOIN          2007
#define IDS_PLACECALL_BTN_PLACECALL     2008
#define IDS_CONFROOM_NO_CALLERID        2009
#define IDS_CONFROOM_CONF_DISCONNECTING 2010
#define IDS_CONFROOM_PARTICIPANT_NAME   2011
#define IDS_CONFROOM_NODETAILS          2011
#define IDS_CONFROOM_DETAILS            2012
#define IDS_CONFROOM_MEDIA_AUDIO        2013
#define IDS_CONFROOM_MEDIA_VIDEO        2014
#define IDS_CONFROOM_MEDIA_AUDIO_VIDEO  2015
#define IDS_CONFROOM_CONF_DIALING       2016
#define IDS_CONFROOM_CONF_INPROGRESS    2017
#define IDS_CONFROOM_CONF_ABORT         2018
#define IDS_CONFEXP_SERVEREXISTS        2019
#define IDS_PLACECALL_FETCH_ADDRESS     2500
#define IDS_PLACECALL_DIALING           2501
#define IDS_PLACECALL_FAILED            2502
#define IDS_PLACECALL_DISCONNECT_BUSY   2503
#define IDS_PLACECALL_DISCONNECT_REJECTED 2504
#define IDS_PLACECALL_CONNECTED         2505
#define IDS_PLACECALL_INPROGRESS        2506
#define IDS_PLACECALL_DISCONNECT_NOANSWER 2507
#define IDS_PLACECALL_DISCONNECT_FAILED 2508
#define IDS_PLACECALL_DISCONNECT_BADADDRESS 2509
#define IDS_PLACECALL_CONNECTED_NAME    2510
#define IDS_PLACECALL_OFFERING          2511
#define IDS_PLACECALL_OFFERING_ANSWER   2512
#define IDS_PLACECALL_CONFATTACH        2513
#define IDS_PLACECALL_DISCONNECTING     2514
#define IDS_PLACECALL_UNHOLDING         2515
#define IDS_PLACECALL_CONNECT_CONFSERVER 2516
#define IDS_PLACECALL_DISCONNECT_CANCELLED 2517
#define IDS_PLACECALL_DISCONNECT_UNAVAIL 2518
#define IDS_NO_ITEMS_TO_SHOW            2700
#define IDS_SERVER_NOT_RESPONDING       2701
#define IDS_SERVER_QUERYING             2702
#define IDS_SERVER_UNKNOWN              2703
#define IDS_SERVER_INVALID              2704
#define IDS_MSG_NO_CONFS_SCHEDULED      3001
#define IDS_MSG_NO_CONFS                3002
#define IDS_JOINCONF_SELECTALL          3003
#define IDS_DEFAULT_LINENAME            3004
#define IDS_NO_LINES                    3005
#define IDS_NO_DEVICES                  3006
#define IDS_TELEPHONE_CALLS             3007
#define IDS_INTERNET_CALLS              3008
#define IDS_INTERNET_CONFS              3009
#define IDS_NO_LINE_SUPPORTING_CALL_TYPE 3010
#define IDS_PREFERRED_DEVICE            3011
#define IDS_MSG_PLACECALL_GETADDRESS    3015
#define IDS_MSG_PLACECALL_GETTERMINAL   3016
#define IDS_PARTICIPANT                 3017
#define IDS_UNKNOWN                     3018
#define IDS_NONE_DEVICE                 3019
#define IDS_MSG_NO_CONFS_MATCHED        3020
#define IDS_NO_PARTICIPANT              3021
#define IDS_RENDER                      3022
#define IDS_CAPTURE                     3023
#define IDS_BOTH                        3024
#define IDS_LINENOTFOUND                3025
#define IDS_DLG_PHONENUMBER             3026
#define IDS_DLG_INTERNETCALL            3027
#define IDI_CONFJOIN                    4000
#define IDS_GENERAL                     5001
#define IDS_PERMISSIONS                 5002
#define IDS_CONFPROP                    5003
#define IDS_CONFPROP_DATEFORMAT         5004
#define IDS_CONFPROP_TIMEFORMAT         5005
#define IDS_CONFPROP_UNTITLED           5006
#define IDS_CONFPROP_UNTITLED_DEFAULT_APPEND 5006
#define IDS_CONFPROP_NONAME             5007
#define IDS_CONFPROP_DUPNAME            5008
#define IDS_CONFPROP_BADNAME            5009
#define IDS_VIDEOPREVIEW                5010
#define IDS_STR_PHONE_PARTS             5011
#define IDS_STR_EMAIL_PARTS             5012
#define IDS_STR_TCPIP_PARTS             5013
#define IDS_STR_MACHINENAME_PARTS       5014
#define IDS_HELP_PATH                   5015
#define IDS_FAILED_TO_LAUNCH_HELP       5016
#define IDS_OPTIONS_TITLE               5017
#define IDS_ACE_COLUMN_NAME             5018
#define IDS_CONFERENCE                  5019
#define IDS_CONFPROP_PERMISSIONS_PAGE   5019
#define IDS_CONFPROP_PERMISSIONS_OBJECT 5020
#define IDS_CONFPROP_FAILURE            5021
#define IDS_PRIV_READ                   5022
#define IDS_PRIV_MODIFY                 5023
#define IDS_PRIV_DELETE                 5024
#define IDS_PRIV_ALL                    5025
#define IDS_TD_CAPTURE                  5026
#define IDS_TD_RENDER                   5027
#define IDS_ER_USB                      5050
#define IDS_ER_USB_OPEN                 5051
#define IDS_ER_USB_INITIALIZE           5052
#define IDS_ER_USB_CLOSE                5053
#define IDS_CONFPROP_INVALIDTIME        5100
#define IDD_CONFPROP_GENERAL            5101
#define IDS_CONFPROP_INVALIDNAME        5101
#define IDS_CONFPROP_INVALIDOWNER       5102
#define IDS_CONFPROP_INVALIDDESCRIPTION 5103
#define IDD_CONFPROP_PERMISSIONS        5104
#define IDS_CONFPROP_INVALIDSDP         5104
#define IDS_CONFPROP_MDHCP_FAILED       5105
#define IDS_CONFPROP_CREATE_FAILED      5106
#define IDS_MSG_NOADDRESSESTODIAL       5107
#define IDS_CONFPROP_ENUMERATING_SCOPES 5108
#define IDI_CONFPROP_PERMISSIONS        5109
#define IDS_CONFPROP_SCOPEENUMFAILED    5109
#define IDI_CONFPROP                    5110
#define IDS_CONFPROP_DATECHANGE_MDHCP   5110
#define IDB_STARTTIME                   5115
#define IDB_STOPTIME                    5116
#define IDB_ENCRYPT                     5117
#define IDC_EDIT_NAME                   5205
#define IDC_EDIT_DESCRIPTION            5206
#define IDC_CHECK_ENCRYPT               5207
#define IDC_EDIT_OWNER                  5208
#define IDC_STATIC_OWNER                5209
#define IDC_DTP_STARTDATE               5219
#define IDC_DTP_STARTTIME               5220
#define IDC_DTP_STOPTIME                5221
#define IDC_DTP_STOPDATE                5222
#define IDC_LST_PERMISSIONS             5223
#define IDC_RDO_ADMIN                   5224
#define IDC_RDO_PARTICIPANT             5225
#define IDC_RDO_EXCLUDE                 5226
#define IDC_BTN_ADDACE                  5227
#define IDC_BTN_REMOVEACE               5228
#define IDD_ADDACE                      5230
#define IDC_EDT_TRUSTEE                 5231
#define IDD_DLGADDLOCATION              5231
#define IDC_RDO_ADDADMIN                5232
#define IDC_RDO_ADDPARTICIPANT          5233
#define IDC_RDO_ADDEXCLUDE              5234
#define IDC_EDT_MAX_WINDOWS             5240
#define ID_APPLY_NOW                    0x3021
#define ID_POPUP_JOIN                   32769
#define ID_POPUP_CREATE                 32770
#define ID_POPUP_DELETE                 32771
#define ID_POPUP_PROPERTIES             32772
#define ID_POPUP_SORTBY_NAME            32773
#define ID_POPUP_SORTBY_PURPOSE         32774
#define ID_POPUP_SORTBY_STARTTIME       32775
#define ID_POPUP_SORTBY_ENDTIME         32776
#define ID_POPUP_SORTBY_ORIGINATOR      32777
#define ID_POPUP_REFRESH                32778
#define ID_POPUP_NEW                    32779
#define ID_POPUP_NEW_FOLDER             32779
#define ID_POPUP_FIND                   32783
#define ID_POPUP_RENAME                 32784
#define ID_POPUP_SORTBY_DESCENDINGORDER 32785
#define ID_POPUP_SORTBY_ASCENDING       32785
#define ID_POPUP_DISCONNECT             32789
#define ID_POPUP_FULLSIZEVIDEO          32790
#define ID_POPUP_SHOWNAMES              32794
#define ID_POPUP_SORTBY_DESCENDING      32796
#define ID_POPUP_NEW_SERVER             32797
#define ID_POPUP_FASTVIDEO              32798
#define ID_ADD_SPEEDDIAL                32800
#define ID_POPUP_SELECTEDVIDEOSCALE_100 32804
#define ID_POPUP_SELECTEDVIDEOSCALE_150 32805
#define ID_POPUP_SELECTEDVIDEOSCALE_200 32806

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        249
#define _APS_NEXT_COMMAND_VALUE         32807
#define _APS_NEXT_CONTROL_VALUE         281
#define _APS_NEXT_SYMED_VALUE           190
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\tapinotify.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// TapiNotification.h : Declaration of the CTapiNotification

#ifndef __TAPINOTIFICATION_H_
#define __TAPINOTIFICATION_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CTapiNotification
class ATL_NO_VTABLE CTapiNotification : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CTapiNotification, &CLSID_TapiNotification>,
    public ITapiNotification,
    public ITTAPIEventNotification
{
public:
    CTapiNotification();
    void FinalRelease();

// Members
public:
    IUnknown                *m_pUnkCP;
private:
    DWORD                    m_dwCookie;
    long                    m_lTapiRegister;

// Implementation
protected:
    HRESULT CallState_Event( CAVTapi *pAVTapi, IDispatch *pEvent );
    HRESULT CallNotification_Event( CAVTapi *pAVTapi, IDispatch *pEvent );
    HRESULT Request_Event( CAVTapi *pAVTapi, IDispatch *pEvent );
    HRESULT CallInfoChange_Event( CAVTapi *pAVTapi, IDispatch *pEvent );
    HRESULT Private_Event( CAVTapi *pAVTapi, IDispatch *pEvent );
    HRESULT CallMedia_Event( CAVTapi *pAVTapi, IDispatch *pEvent );
    HRESULT Address_Event( CAVTapi *pAVTapi, IDispatch *pEvent );
    HRESULT Phone_Event( CAVTapi *pAVTapi, IDispatch *pEvent );
    HRESULT TapiObject_Event( CAVTapi *pAVTapi, IDispatch *pEvent );

public:
DECLARE_NOT_AGGREGATABLE(CTapiNotification)

BEGIN_COM_MAP(CTapiNotification)
    COM_INTERFACE_ENTRY(ITapiNotification)
    COM_INTERFACE_ENTRY(ITTAPIEventNotification)
END_COM_MAP()

// ITapiNotification
public:
    STDMETHOD(Shutdown)();
    STDMETHOD(Init)(ITTAPI *pITTapi, long *pErrorInfo );
    STDMETHOD(ListenOnAllAddresses)( long *pErrorInfo );

// ITTapiEventNotification
public:
    STDMETHOD(Event)(TAPI_EVENT TapiEvent, IDispatch *pEvent);

private:
    // --- Helper function ---

    HRESULT GetCallerAddressType(
        IN  ITCallInfo*     pCall,
        OUT DWORD*          pAddressType);

};

#endif //__TAPINOTIFICATION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\stdafx.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\tapidialer.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// TapiDialer.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f TapiDialerps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "TapiDialer.h"

#include "TapiDialer_i.c"
#include "confpriv.h"
#include "AVTapi.h"
#include "PageAddress.h"
#include "PageTerm.h"
#include "VideoFeed.h"
#include "GenNtfy.h"
#include "AVGenNtfy.h"
#include "PersExp.h"
#include "PETreeView.h"
#include "PEDtlsVw.h"
#include "EnumSite.h"
CTapiModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_AVTapi, CAVTapi)
	OBJECT_ENTRY(CLSID_AVGeneralNotification, CAVGeneralNotification)
	OBJECT_ENTRY(CLSID_PageAddress, CPageAddress)
	OBJECT_ENTRY(CLSID_PageTerminals, CPageTerminals)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object
	return _Module.RegisterServer(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avtapi\tapinotify.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// TapiNotification.cpp : Implementation of CTapiNotification
#include "stdafx.h"
#include "TapiDialer.h"
#include "AVTapi.h"
#include "AVTapiCall.h"
#include "TapiNotify.h"

/////////////////////////////////////////////////////////////////////////////
// CTapiNotification

CTapiNotification::CTapiNotification()
{
    m_dwCookie = NULL;
    m_pUnkCP = NULL;
    m_lTapiRegister = 0;
}

void CTapiNotification::FinalRelease()
{
    ATLTRACE(_T(".enter.CTapiNotification::FinalRelease().\n") );
    Shutdown();
    CComObjectRootEx<CComMultiThreadModel>::FinalRelease();
}

STDMETHODIMP CTapiNotification::Init(ITTAPI *pITTapi, long *pErrorInfo )
{
    ATLTRACE(_T(".enter.CTapiNotification::Init(ref=%ld).\n"), m_dwRef);

    _ASSERT( pErrorInfo );
    _ASSERT( !m_pUnkCP && !m_dwCookie );        // should only initialize once

    HRESULT hr = E_FAIL;
    CErrorInfo *per = (CErrorInfo *) pErrorInfo;

    Lock();

    if ( !m_dwCookie && SUCCEEDED(hr = pITTapi->QueryInterface(IID_IUnknown, (void **) &m_pUnkCP)) )
    {
        // Register notification object
        per->set_Details( IDS_ER_ATL_ADVISE );
        if ( SUCCEEDED(hr = per->set_hr(AtlAdvise(pITTapi, GetUnknown(), IID_ITTAPIEventNotification, &m_dwCookie))) )
        {
            if ( FAILED(hr = ListenOnAllAddresses(pErrorInfo)) )
            {
                Unlock();
                Shutdown();
                Lock();
            }
        }
    }

    Unlock();

    ATLTRACE(_T(".exit.CTapiNotification::Init(%lx, ref=%ld).\n"), hr, m_dwRef);
    return hr;
}

STDMETHODIMP CTapiNotification::Shutdown()
{
    ATLTRACE(_T(".enter.CTapiNotification::Shutdown(ref=%ld).\n"), m_dwRef);

    Lock();

    // Unregister with TAPI
    CAVTapi *pAVTapi;
    if ( m_lTapiRegister && SUCCEEDED(_Module.GetAVTapi(&pAVTapi)) )
    {
        if ( pAVTapi->m_pITTapi )
        {
            pAVTapi->m_pITTapi->UnregisterNotifications( m_lTapiRegister );
            m_lTapiRegister = 0;
        }

        (dynamic_cast<IUnknown *> (pAVTapi))->Release();
    }
    
    // Unregister with connection point    
    if ( m_dwCookie )
    {
        AtlUnadvise( m_pUnkCP, IID_ITTAPIEventNotification, m_dwCookie );
        m_dwCookie = 0;
    }

    // Release connection point unknown
    RELEASE( m_pUnkCP );

    Unlock();

    ATLTRACE(_T(".exit.CTapiNotification::Shutdown(ref=%ld).\n"), m_dwRef);
    return S_OK;
}

STDMETHODIMP CTapiNotification::ListenOnAllAddresses( long *pErrorInfo )
{
    _ASSERT( pErrorInfo );
    CErrorInfo *per = (CErrorInfo *) pErrorInfo;
    per->set_Details( IDS_ER_SET_TAPI_NOTIFICATION );

    // Make sure that TAPI is running
    CAVTapi *pAVTapi;
    if ( FAILED(_Module.GetAVTapi(&pAVTapi)) ) return per->set_hr(E_PENDING);

    // Create the safe array
    long lCount = 0;
    HRESULT hr;

    per->set_Details( IDS_ER_ENUM_VOICE_ADDRESSES );
    IEnumAddress *pIEnumAddresses;
    if ( SUCCEEDED(hr = per->set_hr(pAVTapi->m_pITTapi->EnumerateAddresses(&pIEnumAddresses))) )
    {
        ITAddress *pITAddress = NULL;
        while ( (pIEnumAddresses->Next(1, &pITAddress, NULL) == S_OK) && pITAddress )
        {
            BSTR bstrAddressName;
#ifdef _DEBUG
            USES_CONVERSION;
            pITAddress->get_AddressName( &bstrAddressName );
#endif
            ITMediaSupport *pITMediaSupport;
            if ( SUCCEEDED(hr = pITAddress->QueryInterface(IID_ITMediaSupport, (void **) &pITMediaSupport)) )
            {
                // Address must support Audio In/Out (interactive voice)
                long lMediaModes;
                if ( SUCCEEDED(hr = pITMediaSupport->get_MediaTypes(&lMediaModes)) )
                {
                    ATLTRACE(_T(".1.ListenOnAllAddresses() -- %s has mediamodes %lx.\n"), OLE2CT(bstrAddressName), lMediaModes );
                    lMediaModes &= TAPIMEDIATYPE_AUDIO | TAPIMEDIATYPE_VIDEO;
                    if ( lMediaModes )
                    {
                        per->set_Details( IDS_ER_REGISTER_CALL_TYPES );

                        if ( SUCCEEDED(hr = per->set_hr(pAVTapi->m_pITTapi->RegisterCallNotifications(pITAddress, FALSE, TRUE, lMediaModes, m_dwCookie, &m_lTapiRegister))) )
                        {
                            ATLTRACE(_T(".1.ListenOnAllAddresses() -- open %s as OWNER.\n"), OLE2CT(bstrAddressName) );
                            lCount++;
                        }
                        else if ( SUCCEEDED(hr = per->set_hr(pAVTapi->m_pITTapi->RegisterCallNotifications(pITAddress, TRUE, FALSE, lMediaModes, m_dwCookie, &m_lTapiRegister))) )
                        {
                            ATLTRACE(_T(".1.ListenOnAllAddresses() -- open %s as MONITOR.\n"), OLE2CT(bstrAddressName) );
                            lCount++;
                        }
                        else
                        {
                            ATLTRACE(_T(".error.ListenOnAllAddresses() -- open %s FAILED.\n"), OLE2CT(bstrAddressName) );
                        }
                    }
                }
                else
                {
                    ATLTRACE(_T(".error.ListenOnAllAddresses() -- %s has GetMediaModes returned=%lx.\n"), OLE2CT(bstrAddressName), hr );
                }
                pITMediaSupport->Release();
            }
            else
            {
                ATLTRACE(_T(".error.ListenOnAllAddresses() -- %s has QueryInterfaceMediaModes returned=%lx.\n"), OLE2CT(bstrAddressName), hr );
            }
            pITAddress->Release();
#ifdef _DEBUG
        SysFreeString( bstrAddressName );
#endif
        }
        pIEnumAddresses->Release();
    }

    // Only flag error if no drivers are found.
    hr = S_OK;
    if ( !lCount )
    {
        ATLTRACE(_T(".error.CTapiNotification::ListenOnAllAddresses() -- did not open any lines.\n"));
        per->set_Details( IDS_ER_NO_LINES_OPEN );
        hr = per->set_hr( E_FAIL );
    }

    (dynamic_cast<IUnknown *> (pAVTapi))->Release();

    ATLTRACE(_T(".exit.CTapiNotification::ListenOnAllAddresses(0x%08lx).\n"), hr );    
    return hr;
}

STDMETHODIMP CTapiNotification::Event( TAPI_EVENT TapiEvent, IDispatch *pEvent )
{
    CAVTapi *pAVTapi;
    if ( FAILED(_Module.GetAVTapi(&pAVTapi)) )    return S_OK;    // Tapi object doesnt exist

    HRESULT hr = S_OK;
    switch( TapiEvent )
    {
        // Notification of a new call
        case TE_CALLNOTIFICATION:       hr = CallNotification_Event( pAVTapi, pEvent );     break;
        case TE_CALLSTATE:              hr = CallState_Event( pAVTapi, pEvent );            break;
        case TE_PRIVATE:                hr = Private_Event( pAVTapi, pEvent );              break;
        case TE_REQUEST:                hr = Request_Event( pAVTapi, pEvent );              break;
        case TE_CALLINFOCHANGE:         hr = CallInfoChange_Event( pAVTapi, pEvent );       break;
        case TE_CALLMEDIA:              hr = CallMedia_Event( pAVTapi, pEvent );            break;
        case TE_ADDRESS:                hr = Address_Event( pAVTapi, pEvent );              break;
        case TE_PHONEEVENT:             hr = Phone_Event( pAVTapi, pEvent );                break;
        case TE_TAPIOBJECT:             hr = TapiObject_Event( pAVTapi, pEvent);            break;

        //    Hmmm.....    
        default:
            ATLTRACE(_T(".warning.CTapiNotification::Event(%d) event unhandled.\n"), TapiEvent );
            break;
    }

    (dynamic_cast<IUnknown *> (pAVTapi))->Release();
    return hr;
}

HRESULT CTapiNotification::CallNotification_Event( CAVTapi *pAVTapi, IDispatch *pEvent )
{
    HRESULT hr;

    ITCallNotificationEvent *pCallNotify;
    if ( SUCCEEDED(hr = pEvent->QueryInterface(IID_ITCallNotificationEvent, (void **) &pCallNotify)) )
    {
        ITCallInfo *pCallInfo;
        if ( SUCCEEDED(hr = pCallNotify->get_Call(&pCallInfo)) )
        {
            //
            // Handle the call in the old way
            //
            ITAddress *pITAddress;
            if ( SUCCEEDED(hr = pCallInfo->get_Address(&pITAddress)) )
            {
                // Retrieve address type for caller info
                long lAddressType;

                if ( SUCCEEDED(hr = GetCallerAddressType(pCallInfo, (DWORD*)&lAddressType)) )
                {
                    AVCallType nType = AV_VOICE_CALL;
                    long nSize = 0;

                    byte * pBuffer;
                    hr = pCallInfo->GetCallInfoBuffer( CIB_USERUSERINFO, (DWORD*)&nSize, &pBuffer );
                    if ( SUCCEEDED(hr) )    CoTaskMemFree( pBuffer );

                    // Simple check for now
                    if ( nSize == sizeof(MyUserUserInfo) ) nType = AV_DATA_CALL;

                    // Create new call notification dialog
                    IAVTapiCall *pAVCall;
                    if ( SUCCEEDED(hr = pAVTapi->fire_NewCall(pITAddress, lAddressType, 0, pCallInfo, nType, &pAVCall)) )
                    {
                        // Set the address type for the call
                        DWORD dwAddressType = LINEADDRESSTYPE_IPADDRESS;

                        GetCallerAddressType(pCallInfo, &dwAddressType);
                        pAVCall->put_dwAddressType( dwAddressType );
                        ATLTRACE(_T(".1.CTapiNotification::CallNotification_Event() -- address identified as %lx.\n"), dwAddressType );

                        // Retrieve the caller ID for this call
                        pAVCall->GetCallerIDInfo( pCallInfo );

                        // Automatically answer data calls
                        if ( nType == AV_DATA_CALL )
                        {
                            long lCallID;
                            pAVCall->get_lCallID( &lCallID );
                            pAVTapi->ActionSelected( lCallID, CM_ACTIONS_TAKECALL );
                        }

                        pAVCall->Release();
                    }
                    pITAddress->Release();
                }
            }
            pCallInfo->Release();
        }     
        pCallNotify->Release();
    }

    return hr;
}

HRESULT CTapiNotification::CallState_Event( CAVTapi *pAVTapi, IDispatch *pEvent )
{
    ATLTRACE(_T(".enter.CTapiNotification::CallState_Event().\n"));
    HRESULT hr;
    bool bReleaseEvent = true;

    // Rummage through interfaces to get to the CallControl object
    ITCallStateEvent *pITCallStateEvent;
    if ( SUCCEEDED(hr = pEvent->QueryInterface(IID_ITCallStateEvent, (void **) &pITCallStateEvent)) )
    {
#ifdef _DEBUG
        CALL_STATE nState;
        pITCallStateEvent->get_State(&nState);
        ATLTRACE(_T(".1.CTapiNotification::CallState_Event(%d).\n"), nState);
#endif
        ITCallInfo *pInfo;
        if ( SUCCEEDED(hr = pITCallStateEvent->get_Call(&pInfo)) && pInfo )
        {
            ITBasicCallControl *pControl = NULL;
            if ( SUCCEEDED(hr = pInfo->QueryInterface(IID_ITBasicCallControl, (void **) &pControl)) )
            {    
                // Must be a call other than the one in the confroom
                IAVTapiCall *pAVCall = pAVTapi->FindAVTapiCall( pControl );
                if ( pAVCall )
                {
                    if ( SUCCEEDED(pAVCall->PostMessage(WM_CALLSTATE, (WPARAM) pITCallStateEvent)) )
                    {
                        bReleaseEvent = false;
                    }
                    else
                    {
                        long lCallID = 0;
                        pAVCall->get_lCallID( &lCallID );
                        if ( lCallID )
                            hr = pAVTapi->fire_SetCallState( lCallID, pITCallStateEvent, pAVCall );
                    }

                    pAVCall->Release();
                }
                pControl->Release();
            }
            pInfo->Release();
        }

        // Only release in the case that the post thread message failed
        if ( bReleaseEvent )
            pITCallStateEvent->Release();
    }

    ATLTRACE(_T(".exit.CTapiNotification::CallState_Event().\n"));
    return hr;
}

HRESULT CTapiNotification::CallMedia_Event( CAVTapi *pAVTapi, IDispatch *pEvent )
{
    USES_CONVERSION;
    TCHAR szText[255], szDir[255], szMessage[512];
    CALL_MEDIA_EVENT_CAUSE nCause;
    BSTR bstrName = NULL;
    TERMINAL_DIRECTION nDir;
    CErrorInfo er;

    ITCallMediaEvent *pMediaEvent;
    if ( SUCCEEDED(pEvent->QueryInterface(IID_ITCallMediaEvent, (void **) &pMediaEvent)) )
    {
        CALL_MEDIA_EVENT cme;
        if ( SUCCEEDED(pMediaEvent->get_Event(&cme)) && ((cme == CME_STREAM_ACTIVE) || (cme == CME_STREAM_INACTIVE)) )
        {
            switch ( cme )
            {
                // Notify the user of the terminal failing event
                case CME_TERMINAL_FAIL:
                    {
                        ITTerminal *pTerminal;
                        if ( SUCCEEDED(pMediaEvent->get_Terminal(&pTerminal)) )
                        {
                            pTerminal->get_Name( &bstrName );
                            pTerminal->get_Direction( &nDir );
                            LoadString( _Module.GetResourceInstance(), (nDir == TD_CAPTURE) ? IDS_TD_CAPTURE : IDS_TD_RENDER, szDir, ARRAYSIZE(szDir) );
                            LoadString( _Module.GetResourceInstance(), IDS_ER_CALLMEDIA_STREAMFAIL, szText, ARRAYSIZE(szText) );

                            _sntprintf( szMessage, ARRAYSIZE(szMessage), szText, OLE2CT(bstrName), szDir );
                            SysReAllocString( &er.m_bstrOperation, T2COLE(szMessage) );

                            pMediaEvent->get_Cause( &nCause );
                            switch ( nCause )
                            {
                                case CMC_CONNECT_FAIL:        er.set_Details( IDS_ER_CMC_CONNECT_FAIL );        break;
                                case CMC_REMOTE_REQUEST:    er.set_Details( IDS_ER_CMC_REMOTE_REQUEST );    break;
                                case CMC_MEDIA_TIMEOUT:        er.set_Details( IDS_ER_CMC_MEDIA_TIMEOUT );        break;
                                case CMC_MEDIA_RECOVERED:    er.set_Details( IDS_ER_CMC_MEDIA_RECOVERED );    break;
                                case CMC_BAD_DEVICE:        er.set_Details( IDS_ER_CMC_BADDEVICE );            break;
                                default:                    er.set_Details( IDS_ER_CMC_BADDEVICE );            break;
                            }

                            // flag and notify of the error
                            er.set_hr( E_FAIL );
                            pTerminal->Release();
                        }
                    }
                    break;

                // Notify the user of the stream failing event.
                case CME_STREAM_FAIL:
                    {
                        ITStream *pStream;
                        if ( SUCCEEDED(pMediaEvent->get_Stream(&pStream)) )
                        {
                            pStream->get_Name( &bstrName );
                            pStream->get_Direction( &nDir );
                            LoadString( _Module.GetResourceInstance(), (nDir == TD_CAPTURE) ? IDS_TD_CAPTURE : IDS_TD_RENDER, szDir, ARRAYSIZE(szDir) );
                            LoadString( _Module.GetResourceInstance(), IDS_ER_CALLMEDIA_STREAMFAIL, szText, ARRAYSIZE(szText) );

                            _sntprintf( szMessage, ARRAYSIZE(szMessage), szText, OLE2CT(bstrName), szDir );
                            SysReAllocString( &er.m_bstrOperation, T2COLE(szMessage) );

                            pMediaEvent->get_Cause( &nCause );
                            switch ( nCause )
                            {
                                case CMC_CONNECT_FAIL:        er.set_Details( IDS_ER_CMC_CONNECT_FAIL );        break;
                                case CMC_REMOTE_REQUEST:    er.set_Details( IDS_ER_CMC_REMOTE_REQUEST );    break;
                                case CMC_MEDIA_TIMEOUT:        er.set_Details( IDS_ER_CMC_MEDIA_TIMEOUT );        break;
                                case CMC_MEDIA_RECOVERED:    er.set_Details( IDS_ER_CMC_MEDIA_RECOVERED );    break;
                                case CMC_BAD_DEVICE:        er.set_Details( IDS_ER_CMC_BADDEVICE );            break;
                                default:                    er.set_Details( IDS_ER_CMC_BADDEVICE );            break;
                            }

                            // flag and notify of the error
                            er.set_hr( E_FAIL );
                            pStream->Release();
                        }
                    }
                    break;

                // Stream is starting or stopping here.
                case CME_STREAM_ACTIVE:
                case CME_STREAM_INACTIVE:
                    //
                    // We should initialize local variable
                    //
                    long lMediaType = 0;
                    TERMINAL_DIRECTION nDir = TD_CAPTURE;

                    ITStream *pITStream;
                    if ( SUCCEEDED(pMediaEvent->get_Stream(&pITStream)) )
                    {
                        pITStream->get_Direction( &nDir );
                        pITStream->get_MediaType( &lMediaType );

                        pITStream->Release();
                    }

                    // Only post message in the case of video preview!
                    if ( (lMediaType & TAPIMEDIATYPE_VIDEO) != 0 )
                    {
                        ITCallInfo *pCallInfo = NULL;
                        if ( SUCCEEDED(pMediaEvent->get_Call(&pCallInfo)) && pCallInfo )
                        {
                            IAVTapiCall *pAVCall;
                            if ( SUCCEEDED(pAVTapi->FindAVTapiCallFromCallInfo(pCallInfo, &pAVCall)) )
                            {
                                if ( nDir == TD_CAPTURE )
                                    pAVCall->PostMessage( 0, (cme == CME_STREAM_ACTIVE) ? CAVTapiCall::TI_STREAM_ACTIVE : CAVTapiCall::TI_STREAM_INACTIVE );
                                else
                                    pAVCall->PostMessage( 0, (cme == CME_STREAM_ACTIVE) ? CAVTapiCall::TI_RCV_VIDEO_ACTIVE : CAVTapiCall::TI_RCV_VIDEO_INACTIVE );

                                pAVCall->Release();
                            }
                            pCallInfo->Release();
                        }
                    }
                    break;
            }

        }
        pMediaEvent->Release();
    }

    SysFreeString( bstrName );
    return S_OK;
}



HRESULT CTapiNotification::Request_Event( CAVTapi *pAVTapi, IDispatch *pEvent )
{
    ITRequestEvent *pRequestEvent;
    if ( SUCCEEDED(pEvent->QueryInterface(IID_ITRequestEvent, (void **) &pRequestEvent)) )
    {
        USES_CONVERSION;
        CComPtr<IAVTapi> pAVTapi;
        if ( SUCCEEDED(_Module.get_AVTapi(&pAVTapi)) )
        {
            BSTR bstrCalledParty = NULL, bstrAddress = NULL, bstrAppName = NULL, bstrComment = NULL;
                
            pRequestEvent->get_CalledParty( &bstrCalledParty );
            pRequestEvent->get_DestAddress( &bstrAddress );
            pRequestEvent->get_AppName( &bstrAppName );
            pRequestEvent->get_Comment( &bstrComment );

            DWORD dwAddressType = _Module.GuessAddressType( OLE2CT(bstrAddress) );

            // Work around for assisted telehpony
            if ( (dwAddressType == LINEADDRESSTYPE_DOMAINNAME) &&
                 (SysStringLen(bstrAddress) > 1) &&
                 ((bstrAddress[0] == _L('P')) || (bstrAddress[0] == _L('T'))) )
            {
                BSTR bstrTemp = SysAllocString( &bstrAddress[1] );
                if ( bstrTemp )
                {
                    dwAddressType = LINEADDRESSTYPE_PHONENUMBER;
                    SysFreeString( bstrAddress );
                    bstrAddress = bstrTemp;
                }
            }

            pAVTapi->CreateCallEx( bstrCalledParty, bstrAddress, bstrAppName, bstrComment, dwAddressType );

            SysFreeString( bstrCalledParty );
            SysFreeString( bstrAddress );
            SysFreeString( bstrAppName );
            SysFreeString( bstrComment );
        }

        // Clean-up
        pRequestEvent->Release();
    }

    return S_OK;
}

HRESULT CTapiNotification::CallInfoChange_Event( CAVTapi *pAVTapi, IDispatch *pEvent )
{
    USES_CONVERSION;

    ITCallInfoChangeEvent *pCallInfoEvent;
    if ( SUCCEEDED(pEvent->QueryInterface(IID_ITCallInfoChangeEvent, (void **) &pCallInfoEvent)) )
    {
        ITCallInfo *pCallInfo = NULL;
        if ( SUCCEEDED(pCallInfoEvent->get_Call(&pCallInfo)) && pCallInfo )
        {
            CComPtr<IAVTapi> pAVTapi;
            if ( SUCCEEDED(_Module.get_AVTapi(&pAVTapi)) )
            {
                CALLINFOCHANGE_CAUSE nCause;
                pCallInfoEvent->get_Cause( &nCause );
                ATLTRACE(_T(".1.CTapiNotification::CallInfoChange_Event() -- received %d.\n"), nCause );

                IAVTapiCall *pAVCall;
                if ( SUCCEEDED(pAVTapi->FindAVTapiCallFromCallInfo(pCallInfo, &pAVCall)) )
                {
                    switch ( nCause )
                    {
                        case CIC_CALLID:
                        case CIC_RELATEDCALLID:
                        case CIC_CALLERID:
                        case CIC_CALLEDID:
                        case CIC_CONNECTEDID:
                        case CIC_REDIRECTIONID:
                        case CIC_REDIRECTINGID:
                            // What caller info has changed?
                            pAVCall->GetCallerIDInfo( pCallInfo );
                            break;

                        case CIC_CALLDATA:
                            break;

                        case CIC_USERUSERINFO:
                            pAVCall->PostMessage( NULL, CAVTapiCall::TI_USERUSERINFO );
                            break;

                    }

                    pAVCall->Release();
                }
            }
            pCallInfo->Release();
        }
        pCallInfoEvent->Release();
    }

    return S_OK;
}

HRESULT CTapiNotification::Private_Event( CAVTapi *pAVTapi, IDispatch *pEvent )
{
    ITPrivateEvent *pPrivateEvent;
    if ( SUCCEEDED(pEvent->QueryInterface(IID_ITPrivateEvent, (void **) &pPrivateEvent)) )
    {
        IDispatch *pDispatch;
        if ( SUCCEEDED(pPrivateEvent->get_EventInterface(&pDispatch)))
        {
            // Is this a participant event for the conference room?
            ITParticipantEvent *pParticipantEvent;
            if ( SUCCEEDED(pDispatch->QueryInterface(IID_ITParticipantEvent, (void **) &pParticipantEvent)) )
            {
                PARTICIPANT_EVENT nEvent;
                ITParticipant *pParticipant = NULL;
                ITCallInfo *pCallInfo = NULL;
                IAVTapiCall *pAVCall = NULL;

                if ( SUCCEEDED(pParticipantEvent->get_Event(&nEvent)) &&
                     SUCCEEDED(pParticipantEvent->get_Participant(&pParticipant)) && 
                     SUCCEEDED(pPrivateEvent->get_Call(&pCallInfo)) &&
                     SUCCEEDED(pAVTapi->FindAVTapiCallFromCallInfo(pCallInfo, &pAVCall)) )
                {
                    switch ( nEvent )
                    {
                        case PE_NEW_PARTICIPANT:        // Participant joining
                            if ( SUCCEEDED(pAVCall->PostMessage(WM_ADDPARTICIPANT, (WPARAM) pParticipant)) )
                                pParticipant->AddRef();
                            break;

                        case PE_PARTICIPANT_LEAVE:      // Participant leaving
                            if ( SUCCEEDED(pAVCall->PostMessage(WM_REMOVEPARTICIPANT, (WPARAM) pParticipant)) )
                                pParticipant->AddRef();
                            break;

                        case PE_INFO_CHANGE:            // Participant info change
                            if ( SUCCEEDED(pAVCall->PostMessage(WM_UPDATEPARTICIPANT, (WPARAM) pParticipant)) )
                                pParticipant->AddRef();
                            break;


                        /////////////////////////////////////////////////
                        // video stream starting or stoping
                        case PE_SUBSTREAM_MAPPED:
                        case PE_SUBSTREAM_UNMAPPED:
                            if ( SUCCEEDED(pAVCall->PostMessage(WM_STREAM_EVENT, (WPARAM) pParticipantEvent)) )
                                pParticipantEvent->AddRef();
                            break;
                    }
                }

                RELEASE( pAVCall );
                RELEASE( pCallInfo );
                RELEASE( pParticipant );

                pParticipantEvent->Release();
            }
            pDispatch->Release();
        }
        pPrivateEvent->Release();
    }

    return S_OK;
}

/*++
GetCallerAddressType

Description:
    Used by CallNotification_Event to get the right caller address type,
    instead ITCallInfo::get_CallInfoLong(CIL_CALEERADDRESSTYPE) that
    returns failed

Parameters:
    [in]    ITCallInfo - the callinfo interface
    [out]   DWORD* - the caller address type

Return:
    Success code
--*/
HRESULT CTapiNotification::GetCallerAddressType(
    IN  ITCallInfo*     pCall,
    OUT DWORD*          pAddressType
    )
{
    //
    // Validates parameters
    //

    if( NULL == pCall)
        return E_INVALIDARG;

    if( IsBadWritePtr(pAddressType, sizeof(DWORD)) )
        return E_POINTER;

    //
    // Get the ITAddress interface
    //

    ITAddress* pTAddress = NULL;
    HRESULT hr = pCall->get_Address(&pTAddress);
    if( FAILED(hr) )
        return E_UNEXPECTED;

    //
    // Get ITAddressCapabilities
    //

    ITAddressCapabilities* pTAddressCap = NULL;
    hr = pTAddress->QueryInterface(IID_ITAddressCapabilities, (void**)&pTAddressCap);
    pTAddress->Release();   //That's all, release ITAddress
    if( FAILED(hr) )
        return E_UNEXPECTED;

    //
    // Get the protocol
    //

    BSTR bstrProtocol;
    hr = pTAddressCap->get_AddressCapabilityString(ACS_PROTOCOL, &bstrProtocol);
    pTAddressCap->Release();    // That's all, release ITAddressCapabilities
    if( FAILED(hr) )
        return hr;

    CLSID clsidProtocol;
    hr = CLSIDFromString(bstrProtocol, &clsidProtocol);
    SysFreeString(bstrProtocol);
    if( FAILED(hr) )
    {
        return hr;
    }

    //
    // OK, let's see what we got here
    //

    if( TAPIPROTOCOL_H323 == clsidProtocol )
    {
        // Internet call
        *pAddressType = LINEADDRESSTYPE_IPADDRESS;
        return S_OK;
    }
    else if ( TAPIPROTOCOL_Multicast == clsidProtocol )
    {
        // Conference
        *pAddressType = LINEADDRESSTYPE_SDP;
        return S_OK;
    }
    else if ( TAPIPROTOCOL_PSTN == clsidProtocol )
    {
        // Phone call
        *pAddressType = LINEADDRESSTYPE_PHONENUMBER;
        return S_OK;
    }

    //Badluck
    return E_FAIL;
}

HRESULT CTapiNotification::Address_Event( CAVTapi *pAVTapi, IDispatch *pEvent )
{
    USES_CONVERSION;

    ITAddressEvent *pAddressEvent;
    if ( SUCCEEDED(pEvent->QueryInterface(IID_ITAddressEvent, (void **) &pAddressEvent)) )
    {
        ADDRESS_EVENT ae;
        if ( SUCCEEDED(pAddressEvent->get_Event(&ae)) && 
            ((ae == AE_NEWTERMINAL) || (ae == AE_REMOVETERMINAL) /*||
             (ae == AE_NEWPHONE) || (ae == AE_REMOVEPHONE)*/) )
        {
            switch ( ae )
            {
                // A terminal has arrived via PNP
                case AE_NEWTERMINAL:
                    {
                        ATLTRACE(_T(".1.CTapiNotification::Address_Event() -- received AE_NEWTERMINAL.\n"));

                        ITTerminal *pTerminal;
                        if ( SUCCEEDED(pAddressEvent->get_Terminal(&pTerminal)) )
                        {
                            ITAddress *pAddress;

                            if ( SUCCEEDED(pAddressEvent->get_Address(&pAddress)) )
                            {
                                IEnumCall *             pEnumCall;
                                HRESULT                 hr;
                                ITCallInfo *            pCallInfo;
                                IAVTapiCall *           pAVTapiCall;

                                //
                                // enumerate the current calls
                                //
                                if ( SUCCEEDED(pAddress->EnumerateCalls( &pEnumCall )) )
                                {
                                    //
                                    // go through the list
                                    //
                                    while (TRUE)
                                    {
                                        hr = pEnumCall->Next( 1, &pCallInfo, NULL);

                                        if (S_OK != hr)
                                        {
                                            break;
                                        }

                                        if ( SUCCEEDED( pAVTapi->FindAVTapiCallFromCallInfo(pCallInfo, &pAVTapiCall) ) )
                                        {
                                            pAVTapiCall->TerminalArrival(pTerminal);

                                            pAVTapiCall->Release();
                                        }

                                        //
                                        // release this reference
                                        //
                                        pCallInfo->Release();
                                    }
                                    pEnumCall->Release();
                                }
                                pAddress->Release();
                            }
                            pTerminal->Release();
                        }            
                    }
                    break;

                // A terminal has been removed via PNP
                case AE_REMOVETERMINAL:
                    {
                        ATLTRACE(_T(".1.CTapiNotification::Address_Event() -- received AE_REMOVETERMINAL.\n"));

                        ITTerminal *pTerminal;
                        if ( SUCCEEDED(pAddressEvent->get_Terminal(&pTerminal)) )
                        {
                            ITAddress *pAddress;

                            if ( SUCCEEDED(pAddressEvent->get_Address(&pAddress)) )
                            {
                                IEnumCall *             pEnumCall;
                                HRESULT                 hr;
                                ITCallInfo *            pCallInfo;
                                IAVTapiCall *           pAVTapiCall;

                                //
                                // enumerate the current calls
                                //
                                if ( SUCCEEDED(pAddress->EnumerateCalls( &pEnumCall )) )
                                {
                                    //
                                    // go through the list
                                    //
                                    while (TRUE)
                                    {
                                        hr = pEnumCall->Next( 1, &pCallInfo, NULL);

                                        if (S_OK != hr)
                                        {
                                            break;
                                        }

                                        if ( SUCCEEDED( pAVTapi->FindAVTapiCallFromCallInfo(pCallInfo, &pAVTapiCall) ) )
                                        {
                                            pAVTapiCall->TerminalRemoval(pTerminal);

                                            pAVTapiCall->Release();
                                        }

                                        //
                                        // release this reference
                                        //
                                        pCallInfo->Release();
                                    }
                                    pEnumCall->Release();
                                }
                                pAddress->Release();
                            }
                            pTerminal->Release();
                        }            
                    }
                    break;
            }

        }
        pAddressEvent->Release();
    }

    return S_OK;
}

HRESULT CTapiNotification::Phone_Event( 
    IN  CAVTapi *pAVTapi, 
    IN  IDispatch *pEvent )
{
    // We should have an USB phone
    BOOL bUSBPresent = FALSE;
    pAVTapi->USBIsPresent(&bUSBPresent);
    if( !bUSBPresent )
    {
        return S_OK;
    }

    //
    // We should have checked the USB checkbox
    //
    BOOL bUSBCheckbox = FALSE;
    pAVTapi->USBGetDefaultUse( &bUSBCheckbox );
    if( !bUSBCheckbox )
    {
        return S_OK;
    }


    // Get ITPhone event interface
    ITPhoneEvent* pPhoneEvent = NULL;
    HRESULT hr = E_FAIL;

    hr = pEvent->QueryInterface( IID_ITPhoneEvent, (void**)&pPhoneEvent);
    if( FAILED(hr) )
    {
        return hr;
    }

    // Get the subevent code
    PHONE_EVENT    PECode;
    hr = pPhoneEvent->get_Event(&PECode);
    if( FAILED(hr) )
    {
        pPhoneEvent->Release();
        return hr;
    }

    // So let's see what happened
    switch( PECode) 
    {
    case PE_ANSWER:
        {
            pAVTapi->USBAnswer();
        }
        break;
    case PE_HOOKSWITCH:
        {
            // Get the hook state
            PHONE_HOOK_SWITCH_STATE HookState;
            hr = pPhoneEvent->get_HookSwitchState(&HookState);
            if( FAILED(hr) )
            {
                break;
            }

            PHONE_HOOK_SWITCH_DEVICE HookDevice;
            hr = pPhoneEvent->get_HookSwitchDevice(&HookDevice);
            if( FAILED(hr) )
            {
                break;
            }

            if( HookDevice != PHSD_HANDSET)
            {
                break;
            }
            
            switch( HookState )
            {
            case PHSS_OFFHOOK:
                // +++ FIXBUF 100830 +++
                // we popuup 'PlaceCall' dialog 
                // just when a key 