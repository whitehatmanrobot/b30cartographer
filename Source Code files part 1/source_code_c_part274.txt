ant to keep the same selected index
            // CurrencyManager will provide the PositionChanged event
            // it will be provided before changing the list though...
            if (this.DataManager != null) {
                SendMessage(NativeMethods.CB_SETCURSEL, DataManager.Position, 0);

                // if set_SelectedIndexChanged did not fire OnSelectedValueChanged
                // then we have to fire it ourselves, cos the list changed anyway
                if (!selectedValueChangedFired) {
                    OnSelectedValueChanged(EventArgs.Empty);
                    selectedValueChangedFired = false;
                }
            }

            EndUpdate();
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.SetItemCore"]/*' />
        protected override void SetItemCore(int index, object value) {
            Items.SetItemInternal(index, value);
        }
        
        private bool ShouldSerializeDropDownWidth() {
            return(Properties.ContainsInteger(PropDropDownWidth));
        }

        /// <devdoc>
        ///     Indicates whether the itemHeight property should be persisted.
        /// </devdoc>
        private bool ShouldSerializeItemHeight() {
            return(Properties.ContainsInteger(PropItemHeight));
        }
        
        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.ShouldSerializeText"]/*' />
        /// <devdoc>
        ///     Determines if the Text property needs to be persisted.
        /// </devdoc>
        internal override bool ShouldSerializeText() {
            return SelectedIndex==-1 && base.ShouldSerializeText();
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.ToString"]/*' />
        /// <devdoc>
        ///     Provides some interesting info about this control in String form.
        /// </devdoc>
        /// <internalonly/>
        public override string ToString() {

            string s = base.ToString();
            return s + ", Items.Count: " + ((itemsCollection == null) ? 0.ToString() : itemsCollection.Count.ToString());
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private void UpdateDropDownHeight() {
            if (dropDownHandle != IntPtr.Zero) {
                int itemCount = (itemsCollection == null) ? 0 : itemsCollection.Count;
                int count = Math.Min(Math.Max(itemCount, 1), maxDropDownItems);
                SafeNativeMethods.SetWindowPos(new HandleRef(this, dropDownHandle), NativeMethods.NullHandleRef, 0, 0, DropDownWidth, ItemHeight * count + 2,
                                     NativeMethods.SWP_NOMOVE | NativeMethods.SWP_NOZORDER);
            }
        }

        /// <devdoc>
        ///     Manufactures a MeasureItemEventArgs for each item in the list to simulate
        ///     the combobox requesting the info. This gives the effect of allowing the
        ///     measureitem info to be updated at anytime.
        /// </devdoc>
        /// <internalonly/>
        private void UpdateItemHeight() {
            if (DrawMode == DrawMode.OwnerDrawFixed) {
                SendMessage(NativeMethods.CB_SETITEMHEIGHT, -1, ItemHeight);
                SendMessage(NativeMethods.CB_SETITEMHEIGHT, 0, ItemHeight);
            }
            else if (DrawMode == DrawMode.OwnerDrawVariable) {
                SendMessage(NativeMethods.CB_SETITEMHEIGHT, -1, ItemHeight);
                Graphics graphics = CreateGraphicsInternal();
                for (int i=0; i<Items.Count; i++) {
                    int original = (int)SendMessage(NativeMethods.CB_GETITEMHEIGHT, i, 0);
                    MeasureItemEventArgs mievent = new MeasureItemEventArgs(graphics, i, original);
                    OnMeasureItem(mievent);
                    if (mievent.ItemHeight != original) {
                        SendMessage(NativeMethods.CB_SETITEMHEIGHT, i, mievent.ItemHeight);
                    }
                }
                graphics.Dispose();
            }
        }

        /// <devdoc>
        ///     Forces the text to be updated based on the current selection.
        /// </devdoc>
        /// <internalonly/>
        private void UpdateText() {
            // V#45724 - Fire text changed for dropdown combos when the selection
            //           changes, since the text really does change.  We've got
            //           to do this asynchronously because the actual edit text
            //           isn't updated until a bit later (V#51240).
            //
            string s = "";
            
            if (SelectedIndex != -1) {
                object item = Items[SelectedIndex];
                if (item != null) {
                    s = GetItemText(item);
                }
            }
            
            Text = s;

            if (DropDownStyle == ComboBoxStyle.DropDown) {
                if (editHandle != IntPtr.Zero) {
                    UnsafeNativeMethods.SendMessage(new HandleRef(this, editHandle), NativeMethods.WM_SETTEXT, IntPtr.Zero, s);
                }
            }
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private void WmEraseBkgnd(ref Message m) {
            if (DropDownStyle == ComboBoxStyle.Simple && ParentInternal != null) {
                NativeMethods.RECT rect = new NativeMethods.RECT();
                SafeNativeMethods.GetClientRect(new HandleRef(this, Handle), ref rect);
                Control p = ParentInternal;
                Graphics graphics = Graphics.FromHdcInternal(m.WParam);
                if (p != null) {
                    Brush brush = new SolidBrush(p.BackColor);
                    graphics.FillRectangle(brush, rect.left, rect.top,
                                           rect.right - rect.left, rect.bottom - rect.top);
                    brush.Dispose();
                }
                else {
                    graphics.FillRectangle(SystemBrushes.Control, rect.left, rect.top,
                                           rect.right - rect.left, rect.bottom - rect.top);
                }
                graphics.Dispose();
                m.Result = (IntPtr)1;
                return;
            }
            base.WndProc(ref m);
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private void WmParentNotify(ref Message m) {
            base.WndProc(ref m);
            if ((int)m.WParam == (NativeMethods.WM_CREATE | 1000 << 16)) {
                dropDownHandle = m.LParam;
            }
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private void WmReflectCommand(ref Message m) {
            switch ((int)m.WParam >> 16) {
                case NativeMethods.CBN_DBLCLK:
                    //OnDoubleClick(EventArgs.Empty);
                    break;
                case NativeMethods.CBN_DROPDOWN:
                    OnDropDown(EventArgs.Empty);
                    UpdateDropDownHeight();
                    break;
                case NativeMethods.CBN_EDITCHANGE:
                    OnTextChanged(EventArgs.Empty);
                    break;
                case NativeMethods.CBN_SELCHANGE:
                    UpdateText();
                    OnSelectedIndexChanged(EventArgs.Empty);
                    break;
                case NativeMethods.CBN_SELENDOK:
                    OnSelectionChangeCommitted(EventArgs.Empty);
                    break;
            }
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private void WmReflectDrawItem(ref Message m) {
            NativeMethods.DRAWITEMSTRUCT dis = (NativeMethods.DRAWITEMSTRUCT)m.GetLParam(typeof(NativeMethods.DRAWITEMSTRUCT));
            IntPtr oldPal = SetUpPalette(dis.hDC, false /*force*/, false /*realize*/);
            try {
                Graphics g = Graphics.FromHdcInternal(dis.hDC);

                try {
                    OnDrawItem(new DrawItemEventArgs(g, Font, Rectangle.FromLTRB(dis.rcItem.left, dis.rcItem.top, dis.rcItem.right, dis.rcItem.bottom),
                                                     dis.itemID, (DrawItemState)dis.itemState, ForeColor, BackColor));
                }
                finally {
                    g.Dispose();
                }
            }
            finally {
                if (oldPal != IntPtr.Zero) {
                    SafeNativeMethods.SelectPalette(new HandleRef(this, dis.hDC), new HandleRef(null, oldPal), 0);
                }
            }
            m.Result = (IntPtr)1;
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private void WmReflectMeasureItem(ref Message m) {
            NativeMethods.MEASUREITEMSTRUCT mis = (NativeMethods.MEASUREITEMSTRUCT)m.GetLParam(typeof(NativeMethods.MEASUREITEMSTRUCT));

            // Determine if message was sent by a combo item or the combo edit field
            if (DrawMode == DrawMode.OwnerDrawVariable && mis.itemID >= 0) {
                Graphics graphics = CreateGraphicsInternal();
                MeasureItemEventArgs mie = new MeasureItemEventArgs(graphics, mis.itemID, ItemHeight);
                OnMeasureItem(mie);
                mis.itemHeight = mie.ItemHeight;
                graphics.Dispose();
            }
            else {
                // Message was sent by the combo edit field
                mis.itemHeight = ItemHeight;
            }
            Marshal.StructureToPtr(mis, m.LParam, false);
            m.Result = (IntPtr)1;
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.WndProc"]/*' />
        /// <devdoc>
        ///     The comboboxs window procedure.  Inheritng classes can override this
        ///     to add extra functionality, but should not forget to call
        ///     base.wndProc(m); to ensure the combo continues to function properly.
        /// </devdoc>
        /// <internalonly/>
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        protected override void WndProc(ref Message m) {
            switch (m.Msg) {
                // We don't want to fire the focus events twice -
                // once in the combobox and once in the ChildWndProc.
                case NativeMethods.WM_SETFOCUS:
                    try {
                        fireSetFocus = false;
                        base.WndProc(ref m);
                    }
                    finally {
                        fireSetFocus = true;
                    }
                    break;
                case NativeMethods.WM_KILLFOCUS:
                    try {
                        fireLostFocus = false;
                        base.WndProc(ref m);
                    }
                    finally {
                        fireLostFocus = true;
                    }
                    break;
                case NativeMethods.WM_COMPAREITEM:
                case NativeMethods.WM_DELETEITEM:
                case NativeMethods.WM_DRAWITEM:
                case NativeMethods.WM_MEASUREITEM:
                    DefWndProc(ref m);
                    break;
                case NativeMethods.WM_CTLCOLOREDIT:
                case NativeMethods.WM_CTLCOLORLISTBOX:
                    m.Result = InitializeDCForWmCtlColor(m.WParam, m.Msg);
                    break;
                case NativeMethods.WM_ERASEBKGND:
                    WmEraseBkgnd(ref m);
                    break;
                case NativeMethods.WM_PARENTNOTIFY:
                    WmParentNotify(ref m);
                    break;
                case NativeMethods.WM_REFLECT + NativeMethods.WM_COMMAND:
                    WmReflectCommand(ref m);
                    break;
                case NativeMethods.WM_REFLECT + NativeMethods.WM_DRAWITEM:
                    WmReflectDrawItem(ref m);
                    break;
                case NativeMethods.WM_REFLECT + NativeMethods.WM_MEASUREITEM:
                    WmReflectMeasureItem(ref m);
                    break;
                case NativeMethods.WM_LBUTTONDOWN:
                    mouseEvents = true;
                    base.WndProc(ref m);
                    break;
                case NativeMethods.WM_LBUTTONUP:
                    // Get the mouse location
                    //
                    NativeMethods.RECT r = new NativeMethods.RECT();
                    UnsafeNativeMethods.GetWindowRect(new HandleRef(this, Handle), ref r);
                    Rectangle ClientRect = new Rectangle(r.left, r.top, r.right - r.left, r.bottom - r.top);
                    
                    
                    int x = (int)(short)m.LParam;
                    int y = (int)m.LParam >> 16;
                    Point pt = new Point(x,y);
                    pt = PointToScreen(pt);
                    //mouseEvents is used to keep the check that we get the WM_LBUTTONUP after 
                    //WM_LBUTTONDOWN or WM_LBUTTONDBLBCLK
                    // combo box gets a WM_LBUTTONUP for focus change ...
                    //
                    if (mouseEvents && !ValidationCancelled) {
                        mouseEvents = false;
                        bool captured = Capture;
                        if (captured && ClientRect.Contains(pt)) {
                            OnClick(EventArgs.Empty);
                        }
                        base.WndProc(ref m);
                    }
                    else {
                         CaptureInternal = false;
                         DefWndProc(ref m);
                    }
                    break;
                
                case NativeMethods.WM_MOUSELEAVE:
                    DefWndProc(ref m);
                    NativeMethods.RECT rect = new NativeMethods.RECT();
                    UnsafeNativeMethods.GetWindowRect(new HandleRef(this, Handle), ref rect);
                    Rectangle Rect = new Rectangle(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top);
                    Point p = MousePosition;
                    if (!Rect.Contains (p)) {
                        OnMouseLeave(EventArgs.Empty);
                        mouseInEdit = false;
                    }
                    break;
                
                default:
                    if (m.Msg == NativeMethods.WM_MOUSEENTER) {
                        DefWndProc(ref m);
                        if (!mouseInEdit) {
                            OnMouseEnter(EventArgs.Empty);
                            mouseInEdit = true;
                        }
                        break;
                    }
                    base.WndProc(ref m);
                    break;
            }
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private class ChildWindow {
            internal WeakReference reference;

            internal ChildWindow(ComboBox comboBox) {
                reference = new WeakReference(comboBox, false);
            }

            public IntPtr Callback(IntPtr hWnd, int msg, IntPtr wparam, IntPtr lparam) {
                Message m = Message.Create(hWnd, msg, wparam, lparam);
                try {
                    ((ComboBox)reference.Target).ChildWndProc(ref m);
                }
                catch (Exception e) {
                    Application.OnThreadException(e);
                }
                return m.Result;
            }
        }

        private sealed class ItemComparer : System.Collections.IComparer {
            private ComboBox comboBox;

            public ItemComparer(ComboBox comboBox) {
                this.comboBox = comboBox;
            }

            public int Compare(object item1, object item2) {
                if (item1 == null) {
                    if (item2 == null)
                        return 0; //both null, then they are equal

                    return -1; //item1 is null, but item2 is valid (greater)
                }
                if (item2 == null)
                    return 1; //item2 is null, so item 1 is greater

                String itemName1 = comboBox.GetItemText(item1);
                String itemName2 = comboBox.GetItemText(item2);

                CompareInfo compInfo = (Application.CurrentCulture).CompareInfo;
                return compInfo.Compare(itemName1, itemName2, CompareOptions.StringSort);
            }
        }

        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.ObjectCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [ListBindable(false)]
        public class ObjectCollection : IList {

            private ComboBox owner;
            private ArrayList innerList;
            private IComparer comparer;

            /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.ObjectCollection.ObjectCollection"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public ObjectCollection(ComboBox owner) {
                this.owner = owner;
            }
            
            private IComparer Comparer {
                get {
                    if (comparer == null) {
                        comparer = new ItemComparer(owner);
                    }
                    return comparer;
                }
            }
            
            private ArrayList InnerList {
                get {
                    if (innerList == null) {
                        innerList = new ArrayList();
                    }
                    return innerList;
                }
            }

            /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.ObjectCollection.Count"]/*' />
            /// <devdoc>
            ///     Retrieves the number of items.
            /// </devdoc>
            public int Count {
                get {
                    return InnerList.Count;
                }
            }

            /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ObjectCollection.ICollection.SyncRoot"]/*' />
            /// <internalonly/>
            object ICollection.SyncRoot {
                get {
                    return this;
                }
            }

            /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ObjectCollection.ICollection.IsSynchronized"]/*' />
            /// <internalonly/>
            bool ICollection.IsSynchronized {
                get {
                    return false;
                }
            }

            /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ObjectCollection.IList.IsFixedSize"]/*' />
            /// <internalonly/>
            bool IList.IsFixedSize {
                get {
                    return false;
                }
            }
            
            /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.ObjectCollection.IsReadOnly"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool IsReadOnly {
                get {
                    return false;
                }
            }
        
            /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.ObjectCollection.Add"]/*' />
            /// <devdoc>
            ///     Adds an item to the combo box. For an unsorted combo box, the item is
            ///     added to the end of the existing list of items. For a sorted combo box,
            ///     the item is inserted into the list according to its sorted position.
            ///     The item's toString() method is called to obtain the string that is
            ///     displayed in the combo box.
            ///     A SystemException occurs if there is insufficient space available to
            ///     store the new item.
            /// </devdoc>
            public int Add(object item) {
                owner.CheckNoDataSource();
                
                if (item == null) {
                    throw new ArgumentNullException("item");
                }
                
                InnerList.Add(item);
                int index = -1;
                bool successful = false;
                
                try {
                    if (owner.sorted) {
                        InnerList.Sort(Comparer);
                        index = InnerList.IndexOf(item);
                        if (owner.IsHandleCreated) {
                            owner.NativeInsert(index, item);
                        }
                    }
                    else {
                        index = InnerList.Count - 1;
                        if (owner.IsHandleCreated) {
                            owner.NativeAdd(item);
                        }
                    }
                    successful = true;
                }
                finally {
                    if (!successful) {
                        InnerList.Remove(item);
                    }
                }
                
                return index;
            }
            
            /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ObjectCollection.IList.Add"]/*' />
            /// <internalonly/>
            int IList.Add(object item) {
                return Add(item);
            }
            
            /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.ObjectCollection.AddRange"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public void AddRange(object[] items) {
                owner.CheckNoDataSource();
                AddRangeInternal(items);
            }
            
            internal void AddRangeInternal(IList items) {

                if (items == null) {
                    throw new ArgumentNullException("items");
                }
                
                if (owner.sorted) {
                
                    // Add everything to the array list first, then
                    // sort, and then add to the hwnd according to
                    // index.
                
                    foreach(object item in items) {
                        if (item == null) {
                            throw new ArgumentNullException("item");
                        }
                    }
                    
                    InnerList.AddRange(items);
                    InnerList.Sort(Comparer);
                    
                    if (owner.IsHandleCreated) {
                        Exception failureException = null;
                    
                        // We must pull the new items out in sort order.
                        //
                        object[] sortedArray = new object[items.Count];
                        items.CopyTo(sortedArray, 0);
                        Array.Sort(sortedArray, Comparer);
                        
                        foreach(object item in sortedArray) {
                            if (failureException == null) {
                                try {
                                    int index = InnerList.IndexOf(item);
                                    Debug.Assert(index != -1, "Lost track of item");
                                    owner.NativeInsert(index, item);
                                }
                                catch(Exception ex) {
                                    failureException = ex;
                                    InnerList.Remove(item);
                                }
                            }
                            else {
                                InnerList.Remove(item);
                            }
                        }

                        if (failureException != null) {
                            throw failureException;
                        }
                    }
                }
                else {
                
                    // Non sorted add.  Just throw them in here.
                    
                    foreach(object item in items) {
                        if (item == null) {
                            throw new ArgumentNullException("item");
                        }
                    }

                    InnerList.AddRange(items);

                    // Add each item to the actual list.  If we got
                    // an error while doing it, stop adding and switch
                    // to removing items from the actual list. Then
                    // throw.
                    //
                    if (owner.IsHandleCreated) {
                        Exception failureException = null;

                        foreach(object item in items) {

                            if (failureException == null) {
                                try {
                                    owner.NativeAdd(item);
                                }
                                catch(Exception ex) {
                                    failureException = ex;
                                    InnerList.Remove(item);
                                }
                            }
                            else {
                                InnerList.Remove(item);
                            }
                        }

                        if (failureException != null) {
                            throw failureException;
                        }
                    }
                }
            }

            /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.ObjectCollection.this"]/*' />
            /// <devdoc>
            ///     Retrieves the item with the specified index.
            /// </devdoc>
            [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
            public virtual object this[int index] {
                get {
                    if (index < 0 || index >= InnerList.Count) {
                        throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument, "index", (index).ToString()));
                    }
                    
                    return InnerList[index];
                }
                set {
                    owner.CheckNoDataSource();
                    SetItemInternal(index, value);
                }
            }
            
            /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.ObjectCollection.Clear"]/*' />
            /// <devdoc>
            ///     Removes all items from the ComboBox.
            /// </devdoc>
            public void Clear() {
                owner.CheckNoDataSource();
                ClearInternal();
            }
            
            internal void ClearInternal() {
                
                if (owner.IsHandleCreated) {
                    owner.NativeClear();
                }
                
                InnerList.Clear();
                owner.selectedIndex = -1;
            }

            /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.ObjectCollection.Contains"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool Contains(object value) {
                return IndexOf(value) != -1;
            }

            /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.ObjectCollection.CopyTo"]/*' />
            /// <devdoc>
            ///     Copies the ComboBox Items collection to a destination array.
            /// </devdoc>
            public void CopyTo(object[] dest, int arrayIndex) {
                InnerList.CopyTo(dest, arrayIndex);
            }

            /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ObjectCollection.ICollection.CopyTo"]/*' />
            /// <internalonly/>
            void ICollection.CopyTo(Array dest, int index) {
                InnerList.CopyTo(dest, index);
            }

            /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.ObjectCollection.GetEnumerator"]/*' />
            /// <devdoc>
            ///     Returns an enumerator for the ComboBox Items collection.
            /// </devdoc>
            public IEnumerator GetEnumerator() {
                return InnerList.GetEnumerator();
            }

            /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.ObjectCollection.IndexOf"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public int IndexOf(object value) {
                if (value == null) {
                    throw new ArgumentNullException(SR.GetString(SR.InvalidArgument, "value", "null"));
                }
                
                return InnerList.IndexOf(value);
            }

            /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.ObjectCollection.Insert"]/*' />
            /// <devdoc>
            ///     Adds an item to the combo box. For an unsorted combo box, the item is
            ///     added to the end of the existing list of items. For a sorted combo box,
            ///     the item is inserted into the list according to its sorted position.
            ///     The item's toString() method is called to obtain the string that is
            ///     displayed in the combo box.
            ///     A SystemException occurs if there is insufficient space available to
            ///     store the new item.
            /// </devdoc>
            public void Insert(int index, object item) {
                owner.CheckNoDataSource();
                
                if (item == null) {
                    throw new ArgumentNullException("item");
                }
                
                if (index < 0 || index > InnerList.Count) {
                    throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,
                                                              "index", (index).ToString()));
                }
                
                // If the combo box is sorted, then nust treat this like an add
                // because we are going to twiddle the index anyway.
                //
                if (owner.sorted) {
                    Add(item);
                }
                else {
                    InnerList.Insert(index, item);
                    if (owner.IsHandleCreated) {
                    
                        bool successful = false;
                        
                        try {
                            owner.NativeInsert(index, item);
                            successful = true;
                        }
                        finally {
                            if (!successful) {
                                InnerList.RemoveAt(index);
                            }
                        }
                    }
                }
            }

            /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.ObjectCollection.RemoveAt"]/*' />
            /// <devdoc>
            ///     Removes an item from the ComboBox at the given index.
            /// </devdoc>
            public void RemoveAt(int index) {
                owner.CheckNoDataSource();
                
                if (index < 0 || index >= InnerList.Count) {
                    throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,
                                                              "index", (index).ToString()));
                }
                
                if (owner.IsHandleCreated) {
                    owner.NativeRemoveAt(index);
                }
                
                InnerList.RemoveAt(index);
                if (!owner.IsHandleCreated && index < owner.selectedIndex) {
                    owner.selectedIndex--;
                }
            }

            /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ComboBox.ObjectCollection.Remove"]/*' />
            /// <devdoc>
            ///     Removes the given item from the ComboBox, provided that it is
            ///     actually in the list.
            /// </devdoc>
            public void Remove(object value) {
            
                int index = InnerList.IndexOf(value);
                
                if (index != -1) {
                    RemoveAt(index);
                }
            }
        
            internal void SetItemInternal(int index, object value) {
                if (value == null) {
                    throw new ArgumentNullException("value");
                }
                
                if (index < 0 || index >= InnerList.Count) {
                    throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument, "index", (index).ToString()));
                }
                
                InnerList[index] = value;
                
                if (owner.IsHandleCreated) {
                    bool selected = (index == owner.SelectedIndex);
                    owner.NativeRemoveAt(index);
                    owner.NativeInsert(index, value);
                    if (selected) {
                        owner.SelectedIndex = index;
                        owner.UpdateText();
                    }
                }
            }

        } // end ObjectCollection
        
        /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ChildAccessibleObject"]/*' />
        /// <internalonly/>
        [ComVisible(true)]        
        public class ChildAccessibleObject : AccessibleObject {

            ComboBox owner;
            
            /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ChildAccessibleObject.ChildAccessibleObject"]/*' />
            public ChildAccessibleObject(ComboBox owner, IntPtr handle) {
                Debug.Assert(owner != null && owner.Handle != IntPtr.Zero, "ComboBox's handle hasn't been created");
            
                this.owner = owner;
                UseStdAccessibleObjects(handle);
            }
            
            /// <include file='doc\ComboBox.uex' path='docs/doc[@for="ChildAccessibleObject.Name"]/*' />
            public override string Name {
                get {
                    return owner.AccessibilityObject.Name;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\convertevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="ConvertEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;

    /// <include file='doc\ConvertEvent.uex' path='docs/doc[@for="ConvertEventArgs"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class ConvertEventArgs : EventArgs {

        private object value;
        private Type desiredType;

        /// <include file='doc\ConvertEvent.uex' path='docs/doc[@for="ConvertEventArgs.ConvertEventArgs"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ConvertEventArgs(object value, Type desiredType) {
            this.value = value;
            this.desiredType = desiredType;
        }

        /// <include file='doc\ConvertEvent.uex' path='docs/doc[@for="ConvertEventArgs.Value"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object Value {
            get {
                return value;
            }
            set {
                this.value = value;
            }
        }

        /// <include file='doc\ConvertEvent.uex' path='docs/doc[@for="ConvertEventArgs.DesiredType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Type DesiredType {
            get {
                return desiredType;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\controlstyles.cs ===
//------------------------------------------------------------------------------
// <copyright file="ControlStyles.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    using System.ComponentModel;

    using System.Diagnostics;
    using System;

    /// <include file='doc\ControlStyles.uex' path='docs/doc[@for="ControlStyles"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies control functionality.
    ///       
    ///    </para>
    /// </devdoc>
    [Flags]
    public enum ControlStyles {
        /// <include file='doc\ControlStyles.uex' path='docs/doc[@for="ControlStyles.ContainerControl"]/*' />
        /// <devdoc>
        ///     Indicates whether the control is a container-like control.
        /// </devdoc>
        ContainerControl= 0x00000001,
        /// <include file='doc\ControlStyles.uex' path='docs/doc[@for="ControlStyles.UserPaint"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The control paints itself; WM_PAINT and WM_ERASEBKGND messages are not passed 
        ///       on to the underlying NativeWindow.
        ///    </para>
        ///    <para>
        ///       This style only applies to subclasses of Control.
        ///    </para>
        /// </devdoc>
        UserPaint       = 0x00000002,
        /// <include file='doc\ControlStyles.uex' path='docs/doc[@for="ControlStyles.Opaque"]/*' />
        /// <devdoc>
        ///    <para>
        ///       If specified, a PaintBackground event will not be raised, OnPaintBackground will not be called,
        ///       and Invalidate() will not invalidate the background of the HWND.
        ///    </para>
        /// </devdoc>
        Opaque          = 0x00000004,
        /// <include file='doc\ControlStyles.uex' path='docs/doc[@for="ControlStyles.ResizeRedraw"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The control is completely redrawn when it is resized.
        ///    </para>
        /// </devdoc>
        ResizeRedraw   = 0x00000010,
        /// <include file='doc\ControlStyles.uex' path='docs/doc[@for="ControlStyles.FixedWidth"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The control has a fixed width.
        ///    </para>
        /// </devdoc>
        FixedWidth     = 0x00000020,
        /// <include file='doc\ControlStyles.uex' path='docs/doc[@for="ControlStyles.FixedHeight"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The control has a fixed height.
        ///    </para>
        /// </devdoc>
        FixedHeight    = 0x00000040,
        /// <include file='doc\ControlStyles.uex' path='docs/doc[@for="ControlStyles.StandardClick"]/*' />
        /// <devdoc>
        ///    <para>
        ///        If set, windows forms calls OnClick and raises the Click event when the control is clicked
        ///        (unless it's the second click of a double-click and StandardDoubleClick is specified).
        ///        Regardless of this style, the control may call OnClick directly.
        ///    </para>
        /// </devdoc>
        StandardClick        = 0x00000100,
        /// <include file='doc\ControlStyles.uex' path='docs/doc[@for="ControlStyles.Selectable"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The control can get the focus.
        ///    </para>
        /// </devdoc>
        Selectable = 0x00000200,
        /// <include file='doc\ControlStyles.uex' path='docs/doc[@for="ControlStyles.UserMouse"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The control does its own mouse processing; WM_MOUSEDOWN, WM_MOUSEMOVE, and WM_MOUSEUP messages are not passed 
        ///       on to the underlying NativeWindow.
        ///    </para>
        /// </devdoc>
        UserMouse       = 0x00000400,
        /// <include file='doc\ControlStyles.uex' path='docs/doc[@for="ControlStyles.SupportsTransparentBackColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       If the BackColor is set to a color whose alpha component is
        ///       less than 255 (i.e., BackColor.A &lt; 255), OnPaintBackground will simulate transparency
        ///       by asking its parent control to paint our background.  This is not true transparency --
        ///       if there is another control between us and our parent, we will not show the control in the middle.
        ///    </para>
        ///    <para>
        ///       This style only applies to subclasses of Control.  It only works if UserPaint is set,
        ///       and the parent control is a Control.
        ///    </para>
        /// </devdoc>
        SupportsTransparentBackColor          = 0x00000800,
        /// <include file='doc\ControlStyles.uex' path='docs/doc[@for="ControlStyles.StandardDoubleClick"]/*' />
        /// <devdoc>
        ///    <para>
        ///        If set, windows forms calls OnDoubleClick and raises the DoubleClick event when the control is double clicked.
        ///        Regardless of whether it is set, the control may call OnDoubleClick directly.
        ///        This style is ignored if StandardClick is not set.
        ///    </para>
        /// </devdoc>
        StandardDoubleClick                   = 0x00001000,
        /// <include file='doc\ControlStyles.uex' path='docs/doc[@for="ControlStyles.AllPaintingInWmPaint"]/*' />
        /// <devdoc>
        ///    <para>
        ///        If true, WM_ERASEBKGND is ignored, and both OnPaintBackground and OnPaint are called directly from
        ///        WM_PAINT.  This generally reduces flicker, but can cause problems if other controls
        ///        send WM_ERASEBKGND messages to us.  (This is sometimes done to achieve a pseudo-transparent effect similar to
        ///        ControlStyles.SupportsTransparentBackColor; for instance, ToolBar with flat appearance does this).
        ///        This style only makes sense if UserPaint is true.
        ///    </para>
        /// </devdoc>
        AllPaintingInWmPaint                  = 0x00002000,
        /// <include file='doc\ControlStyles.uex' path='docs/doc[@for="ControlStyles.CacheText"]/*' />
        /// <devdoc>
        ///    <para>
        ///         If true, the control keeps a copy of the text rather than going to the hWnd for the
        ///         text every time. This improves performance but makes it difficult to keep the control
        ///         and hWnd's text synchronized. 
        ///         This style defaults to false.
        ///    </para>
        /// </devdoc>
        CacheText                           = 0x00004000, 
        /// <include file='doc\ControlStyles.uex' path='docs/doc[@for="ControlStyles.EnableNotifyMessage"]/*' />
        /// <devdoc>
        ///    <para>
        ///         If true, the OnNotifyMessage method will be called for every message sent to 
        ///         the control's WndProc. 
        ///         This style defaults to false.
        ///    </para>
        /// </devdoc>
        EnableNotifyMessage                 = 0x00008000, 
        /// <include file='doc\ControlStyles.uex' path='docs/doc[@for="ControlStyles.DoubleBuffer"]/*' />
        /// <devdoc>
        ///    <para>
        ///         If set, all control painting will be double buffered. You must also
        ///         set the UserPaint and AllPaintingInWmPaint style.
        ///    </para>
        /// </devdoc>
        DoubleBuffer                        = 0x00010000, 
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\currencymanager.cs ===
//------------------------------------------------------------------------------
// <copyright file="CurrencyManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System;
    using Microsoft.Win32;
    using System.Diagnostics;    
    using System.ComponentModel;
    using System.Collections;

    /// <include file='doc\ListManager.uex' path='docs/doc[@for="CurrencyManager"]/*' />
    /// <devdoc>
    ///    <para>Manages the position and bindings of a
    ///       list.</para>
    /// </devdoc>
    public class CurrencyManager : BindingManagerBase {

        private Object dataSource;
        private IList list;
        
        private bool bound = false;
        private bool shouldBind = true;
        
        /// <include file='doc\ListManager.uex' path='docs/doc[@for="CurrencyManager.listposition"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected int listposition = -1;

        private int lastGoodKnownRow = -1;
        private bool pullingData = false;

        private bool inChangeRecordState = false;
        private bool suspendPushDataInCurrentChanged = false;
        // private bool onItemChangedCalled = false;
        // private EventHandler onCurrentChanged;
        // private CurrentChangingEventHandler onCurrentChanging;
        private ItemChangedEventHandler onItemChanged;
        private ItemChangedEventArgs resetEvent = new ItemChangedEventArgs(-1);
        private EventHandler onMetaDataChangedHandler;
        
        /// <include file='doc\ListManager.uex' path='docs/doc[@for="CurrencyManager.finalType"]/*' />
        /// <devdoc>
        ///    <para>Gets the type of the list.</para>
        /// </devdoc>
        protected Type finalType;

        /*
        /// <summary>
        ///    <para>Occurs after the current item changes.</para>
        /// </summary>
        /// <remarks>
        /// <para>The <see cref='System.Windows.Forms.ListManager.CurrentChanged'/> and <see cref='System.Windows.Forms.ListManager.PositionChanged'/> events are similar: both will occur when the
        /// <see cref='System.Windows.Forms.ListManager.Position'/> property changes. However, if you apply a new 
        ///    filter to a <see cref='T:System.Data.DataView'/> by setting the <see cref='P:System.Data.DataView.RowFilter'/> property, it's possible that only
        ///    the <see cref='System.Windows.Forms.ListManager.CurrentChanged'/> event will occur while the <see cref='System.Windows.Forms.ListManager.Position'/> will will not. For example, if the <see cref='System.Windows.Forms.ListManager.Position'/> is 0, and a filter is applied, the <see cref='System.Windows.Forms.ListManager.Position'/> will remain 0, but the <see cref='System.Windows.Forms.ListManager.CurrentChanged'/> event will occur
        ///    because the current item has changed.</para>
        /// </remarks>
        /// <example>
        /// <para>The following example adds event handlers for the <see cref='System.Windows.Forms.ListManager.CurrentChanging'/>, <see cref='System.Windows.Forms.ListManager.CurrentChanged'/>, <see cref='System.Windows.Forms.ListManager.ItemChanged'/>, and <see cref='System.Windows.Forms.ListManager.PositionChanged'/> events.</para>
        /// <code lang='C#'>private void BindControl(DataTable myTable){
        ///    // Bind A TextBox control to a DataTable column in a DataSet.
        ///    textBox1.Bindings.Add("Text", myTable, "CompanyName");
        ///    // Specify the ListManager for the DataTable.
        ///    myListManager = this.BindingManager[myTable, ""];
        ///    // Add event handlers.
        ///    myListManager.CurrentChanged+=new System.EventHandler(ListManager_CurrentChanged);
        ///    myListManager.CurrentChanging+= new System.Windows.Forms.CurrentChangingEventHandler(ListManager_CurrentChanging);
        ///    myListManager.ItemChanged+=new System.Windows.Forms.ItemChangedEventHandler(ListManager_ItemChanged);
        ///    myListManager.PositionChanged+= new System.EventHandler(ListManager_PositionChanged);
        ///    // Set the initial Position of the control.
        ///    myListManager.Position = 0;
        /// }
        /// 
        /// private void ListManager_PositionChanged(object sender, System.EventArgs e){
        ///    ListManager lm = (ListManager) sender;
        ///    Console.WriteLine("Position Changed " + lm.Position);
        /// }
        /// 
        /// private void ListManager_ItemChanged(object sender, System.Windows.Forms.ItemChangedEventArgs e){
        ///    ListManager lm = (ListManager) sender;
        ///    Console.WriteLine("Item Changed " + lm.Position);
        /// }
        /// private void ListManager_CurrentChanging(object sender, System.Windows.Forms.CurrentChangingEventArgs e) {
        ///    ListManager lm = (ListManager) sender;
        ///    Console.WriteLine("Current Changing " + lm.Position);
        /// }
        /// 
        /// private void ListManager_CurrentChanged(object sender, System.EventArgs e){
        ///    ListManager lm = (ListManager) sender;
        ///    Console.WriteLine("Current Changed " + lm.Position);
        /// }
        /// </code>
        /// <code lang='VB'>Private Sub BindControl(ByVal myTable As DataTable)
        ///    ' Bind A TextBox control to a DataTable column in a DataSet.
        ///    TextBox1.Bindings.Add("Text", myTable, "CompanyName")
        ///    ' Specify the ListManager for the DataTable.
        ///    myListManager = this.BindingManager(myTable, "")
        ///    ' Add event handlers.
        ///    myListManager.CurrentChanged+=new System.EventHandler(ListManager_CurrentChanged)
        ///    myListManager.CurrentChanging+= new System.Windows.Forms.CurrentChangingEventHandler(ListManager_CurrentChanging)
        ///    myListManager.ItemChanged+=new System.Windows.Forms.ItemChangedEventHandler(ListManager_ItemChanged)
        ///    myListManager.PositionChanged+= new System.EventHandler(ListManager_PositionChanged)
        ///    ' Set the initial Position of the control.
        ///    myListManager.Position = 0
        /// End Sub
        /// 
        /// Private Sub ListManager_PositionChanged(ByVal sender As object, ByVal e As System.EventArgs)
        ///    Dim lm As ListManager = CType(sender, ListManager)
        ///    Console.WriteLine("Position Changed " + lm.Position)
        /// End Sub
        /// 
        /// Private Sub ListManager_ItemChanged(ByVal sender As object, ByVal e As System.Windows.Forms.ItemChangedEventArgs)
        ///    Dim lm As ListManager = CType(sender, ListManager)
        ///    Console.WriteLine("Item Changed " + lm.Position)
        /// End Sub
        /// Private Sub ListManager_CurrentChanging(ByVal sender As object, ByVal e As System.Windows.Forms.CurrentChangingEventArgs) 
        ///    Dim lm As ListManager = CType(sender, ListManager)
        ///    Console.WriteLine("Current Changing " + lm.Position)
        /// End Sub
        /// 
        /// Private Sub ListManager_CurrentChanged(ByVal sender As object, ByVal e As System.EventArgs)
        ///    Dim lm As ListManager = CType(sender, ListManager)
        ///    Console.WriteLine("Current Changed " + lm.Position)
        /// End Sub
        /// </code>
        /// </example>
        /// <seealso cref='System.Windows.Forms.ListManager.CurrentChanging'/>
        /// <seealso cref='System.Windows.Forms.ListManager.ItemChanged'/>
        [SRCategory(SR.CatData)]
        public event EventHandler CurrentChanged {
            get {
                return onCurrentChanged;
            }
            set {
                onCurrentChanged = value;
            }
        }
        */

        /*
        /// <summary>
        ///    <para>Occurs when the current position is changing.</para>
        /// </summary>
        /// <remarks>
        /// <para>The <see cref='System.Windows.Forms.ListManager.CurrentChanging'/> and <see cref='System.Windows.Forms.ListManager.PositionChanged'/> events are similar: both will occur when the
        /// <see cref='System.Windows.Forms.ListManager.Position'/> property changes. However, if you apply a new 
        ///    filter to a <see cref='T:System.Data.DataView'/> by setting the <see cref='P:System.Data.DataView.RowFilter'/> property, it's possible that only the
        /// <see cref='System.Windows.Forms.ListManager.CurrentChanging'/> event will occur while the <see cref='System.Windows.Forms.ListManager.Position'/> will will not. For example, if the <see cref='System.Windows.Forms.ListManager.Position'/> is 0, and a filter is applied, the <see cref='System.Windows.Forms.ListManager.Position'/> will remain 0, but the <see cref='System.Windows.Forms.ListManager.CurrentChanging'/> event will occur
        ///    because the current item is changing.</para>
        /// </remarks>
        /// <example>
        /// <para>The following example adds event handlers for the <see cref='System.Windows.Forms.ListManager.CurrentChanging'/>, <see cref='System.Windows.Forms.ListManager.CurrentChanged'/>, <see cref='System.Windows.Forms.ListManager.ItemChanged'/>, and <see cref='System.Windows.Forms.ListManager.PositionChanged'/> events.</para>
        /// <code lang='C#'>private void BindControl(DataTable myTable){
        ///    // Bind A TextBox control to a DataTable column in a DataSet.
        ///    textBox1.Bindings.Add("Text", myTable, "CompanyName");
        ///    // Specify the ListManager for the DataTable.
        ///    myListManager = this.BindingManager[myTable, ""];
        ///    // Add event handlers.
        ///    myListManager.CurrentChanged+=new System.EventHandler(ListManager_CurrentChanged);
        ///    myListManager.CurrentChanging+= new System.Windows.Forms.CurrentChangingEventHandler(ListManager_CurrentChanging);
        ///    myListManager.ItemChanged+=new System.Windows.Forms.ItemChangedEventHandler(ListManager_ItemChanged);
        ///    myListManager.PositionChanged+= new System.EventHandler(ListManager_PositionChanged);
        ///    // Set the initial Position of the control.
        ///    myListManager.Position = 0;
        /// }
        /// 
        /// private void ListManager_PositionChanged(object sender, System.EventArgs e){
        ///    ListManager lm = (ListManager) sender;
        ///    Console.WriteLine("Position Changed " + lm.Position);
        /// }
        /// 
        /// private void ListManager_ItemChanged(object sender, System.Windows.Forms.ItemChangedEventArgs e){
        ///    ListManager lm = (ListManager) sender;
        ///    Console.WriteLine("Item Changed " + lm.Position);
        /// }
        /// private void ListManager_CurrentChanging(object sender, System.Windows.Forms.CurrentChangingEventArgs e) {
        ///    ListManager lm = (ListManager) sender;
        ///    Console.WriteLine("Current Changing " + lm.Position);
        /// }
        /// 
        /// private void ListManager_CurrentChanged(object sender, System.EventArgs e){
        ///    ListManager lm = (ListManager) sender;
        ///    Console.WriteLine("Current Changed " + lm.Position);
        /// }
        /// </code>
        /// <code lang='VB'>Private Sub BindControl(ByVal myTable As DataTable)
        ///    ' Bind A TextBox control to a DataTable column in a DataSet.
        ///    TextBox1.Bindings.Add("Text", myTable, "CompanyName")
        ///    ' Specify the ListManager for the DataTable.
        ///    myListManager = this.BindingManager(myTable, "")
        ///    ' Add event handlers.
        ///    myListManager.CurrentChanged+=new System.EventHandler(ListManager_CurrentChanged)
        ///    myListManager.CurrentChanging+= new System.Windows.Forms.CurrentChangingEventHandler(ListManager_CurrentChanging)
        ///    myListManager.ItemChanged+=new System.Windows.Forms.ItemChangedEventHandler(ListManager_ItemChanged)
        ///    myListManager.PositionChanged+= new System.EventHandler(ListManager_PositionChanged)
        ///    ' Set the initial Position of the control.
        ///    myListManager.Position = 0
        /// End Sub
        /// 
        /// Private Sub ListManager_PositionChanged(ByVal sender As object, ByVal e As System.EventArgs)
        ///    Dim lm As ListManager = CType(sender, ListManager)
        ///    Console.WriteLine("Position Changed " + lm.Position)
        /// End Sub
        /// 
        /// Private Sub ListManager_ItemChanged(ByVal sender As object, ByVal e As System.Windows.Forms.ItemChangedEventArgs)
        ///    Dim lm As ListManager = CType(sender, ListManager)
        ///    Console.WriteLine("Item Changed " + lm.Position)
        /// End Sub
        /// Private Sub ListManager_CurrentChanging(ByVal sender As object, ByVal e As System.Windows.Forms.CurrentChangingEventArgs) 
        ///    Dim lm As ListManager = CType(sender, ListManager)
        ///    Console.WriteLine("Current Changing " + lm.Position)
        /// End Sub
        /// 
        /// Private Sub ListManager_CurrentChanged(ByVal sender As object, ByVal e As System.EventArgs)
        ///    Dim lm As ListManager = CType(sender, ListManager)
        ///    Console.WriteLine("Current Changed " + lm.Position)
        /// End Sub
        /// </code>
        /// </example>
        /// <seealso cref='System.Windows.Forms.ListManager.CurrentChanged'/>
        /// <seealso cref='System.Windows.Forms.ListManager.ItemChanged'/>
        [SRCategory(SR.CatData)]
        public event CurrentChangingEventHandler CurrentChanging {
            get {
                return onCurrentChanging;
            }
            set {
                onCurrentChanging = value;
            }
        }
        */

        /// <include file='doc\ListManager.uex' path='docs/doc[@for="CurrencyManager.ItemChanged"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the
        ///       current item has been
        ///       altered.</para>
        /// </devdoc>
        [SRCategory(SR.CatData)]
        public event ItemChangedEventHandler ItemChanged {
            add {
                onItemChanged += value;
            }
            remove {
                onItemChanged -= value;
            }
        }

        /// <include file='doc\ListManager.uex' path='docs/doc[@for="CurrencyManager.CurrencyManager"]/*' />
        /// <devdoc>
        /// </devdoc>
        internal CurrencyManager(Object dataSource) {
            SetDataSource(dataSource);
        }

        /// <devdoc>
        ///    <para>Gets a value indicating
        ///       whether items can be added to the list.</para>
        /// </devdoc>
        internal bool AllowAdd {
            get {
                if (list is IBindingList) {
                    return ((IBindingList)list).AllowNew;
                }
                if (list == null)
                    return false;
                return !list.IsReadOnly && !list.IsFixedSize;
            }
        }
        
        /// <devdoc>
        ///    <para>Gets a value
        ///       indicating whether edits to the list are allowed.</para>
        /// </devdoc>
        internal bool AllowEdit {
            get {
                if (list is IBindingList) {
                    return ((IBindingList)list).AllowEdit;
                }
                if (list == null)
                    return false;
                return !list.IsReadOnly;
            }
        }
        
        /// <devdoc>
        ///    <para>Gets a value indicating whether items can be removed from the list.</para>
        /// </devdoc>
        internal bool AllowRemove {
            get {
                if (list is IBindingList) {
                    return ((IBindingList)list).AllowRemove;
                }
                if (list == null)
                    return false;
                return !list.IsReadOnly && !list.IsFixedSize;
            }
        }
        
        /*
        /// <summary>
        ///    <para>Gets the collection of bindings for the list.</para>
        /// </summary>
        /// <value>
        /// <para>A <see cref='System.Windows.Forms.BindingsCollection'/> which contains <see cref='System.Windows.Forms.ListBinding'/>
        /// objects.</para>
        /// </value>
        /// <remarks>
        /// <para>Use the <see cref='System.Windows.Forms.ListManager.Bindings'/> property to determine what other controls are 
        ///    bound to the same list.</para>
        /// </remarks>
        /// <example>
        /// <para>The following example gets the <see cref='System.Windows.Forms.ListManager'/> of 
        ///    a <see cref='System.Windows.Forms.TextBox'/> control, and then uses the <see cref='System.Windows.Forms.ListManager.Bindings'/> property to determine how many other controls
        ///    are bound to the same list.</para>
        /// <code lang='C#'>private void GetBindingsCollection() {
        ///    ListManager myListManager;
        ///    BindingsCollection myBindings;
        ///    myListManager= textBox1.Bindings[0].ListManager;
        ///    myBindings = myListManager.Bindings;
        ///    foreach(ListBinding lb in myBindings) {
        ///       Console.WriteLine(lb.Control.ToString());
        ///    }
        /// }
        /// </code>
        /// <code lang='VB'>Private Sub GetBindingsCollection()
        ///    Dim myListManager As ListManager
        ///    Dim myBindings As BindingsCollection
        ///    myListManager= textBox1.Bindings(0).ListManager
        ///    myBindings = myListManager.Bindings
        ///    Dim lb As ListBinding
        ///    For Each lb in myBindings
        ///       Console.WriteLine(lb.Control.ToString())
        ///    Next
        /// End Sub
        /// </code>
        /// </example>
        public BindingsCollection Bindings {
            get {
                if (bindings == null)
                    bindings = new ListManagerBindingsCollection(this);
                return bindings;
            }
        }
        */

        /// <include file='doc\ListManager.uex' path='docs/doc[@for="CurrencyManager.Count"]/*' />
        /// <devdoc>
        ///    <para>Gets the number of items in the list.</para>
        /// </devdoc>
        public override int Count {
            get {
                if (list == null)
                    return 0;
                else
                    return list.Count;
            }
        }
        
        /// <include file='doc\ListManager.uex' path='docs/doc[@for="CurrencyManager.Current"]/*' />
        /// <devdoc>
        ///    <para>Gets the current item in the list.</para>
        /// </devdoc>
        public override Object Current {
            get {
                return this[Position];
            }
        }

        internal override Type BindType {
            get {
                return finalType;
            }
        }
        
        /// <devdoc>
        ///    <para>Gets the data source of the list.</para>
        /// </devdoc>
        internal override Object DataSource {
            get {
                return dataSource;
            }
        }

        internal override void SetDataSource(Object dataSource) {
            if (this.dataSource != dataSource) {
                Release();
                this.dataSource = dataSource;
                this.list = null;
                this.finalType = null;
                
                Object tempList = dataSource;
                if (tempList is Array) {
                    finalType = tempList.GetType();
                    tempList = (Array)tempList;
                }
                
                if (tempList is IListSource) {
                    tempList = ((IListSource)tempList).GetList();                    
                }
            
                if (tempList is IList) {
                    if (finalType == null) {
                        finalType = tempList.GetType();
                    }
                    this.list = (IList)tempList;
                    WireEvents(list);
                    if (list.Count > 0 )
                        listposition = 0;
                    else
                        listposition = -1;
                    OnItemChanged(resetEvent);
                    UpdateIsBinding();
                }
                else {
                    if (tempList == null) {
                        throw new ArgumentNullException("dataSource");
                    }
                    throw new ArgumentException(SR.GetString(SR.ListManagerSetDataSource, tempList.GetType().FullName), "dataSource");
                }

            }
        }

        /// <include file='doc\ListManager.uex' path='docs/doc[@for="CurrencyManager.IsBinding"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Gets a value indicating whether the list is bound to a data source.</para>
        /// </devdoc>
        internal override bool IsBinding {
            get {
                return bound;
            }
        }

        /// <include file='doc\ListManager.uex' path='docs/doc[@for="CurrencyManager.List"]/*' />
        /// <devdoc>
        ///    <para>Gets the list as an object.</para>
        /// </devdoc>
        public IList List {
            get {
                // NOTE: do not change this to throw an exception if the list is not IBindingList.
                // doing this will cause a major performance hit when wiring the 
                // dataGrid to listen for MetaDataChanged events from the IBindingList
                // (basically we would have to wrap all calls to CurrencyManager::List with
                // a try/catch block.)
                //
                return list;
            }
        }

        /// <include file='doc\ListManager.uex' path='docs/doc[@for="CurrencyManager.Position"]/*' />
        /// <devdoc>
        ///    <para> Gets or sets the position you are at within the list.</para>
        /// </devdoc>
        public override int Position {
            get {
                return listposition;
            }
            set {
                if (listposition == -1)
                    return;

                if (value < 0)
                    value = 0;
                int count = list.Count;
                if (value >= count)
                    value = count - 1;

                ChangeRecordState(value, listposition != value, true, true, false);       // true for endCurrentEdit
                                                                                          // true for firingPositionChange notification
                                                                                          // data will be pulled from controls anyway.
            }
        }

        /// <devdoc>
        ///    <para>Gets or sets the object at the specified index.</para>
        /// </devdoc>
        internal Object this[int index] {
            get {
                if (index < 0 || index >= list.Count) {
                    throw new IndexOutOfRangeException(SR.GetString(SR.ListManagerNoValue, index.ToString()));
                }
                return list[index];
            }
            set {
                if (index < 0 || index >= list.Count) {
                    throw new IndexOutOfRangeException(SR.GetString(SR.ListManagerNoValue, index.ToString()));
                }
                list[index] = value;
            }
        }
        
        /// <include file='doc\ListManager.uex' path='docs/doc[@for="CurrencyManager.AddNew"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void AddNew() {
            if (list is IBindingList)
                ((IBindingList)list).AddNew();
            else {
                // If the list is not IBindingList, then throw an exception:
                throw new NotSupportedException();
                // list.Add(null);
            }

            ChangeRecordState(list.Count - 1, true, (Position != list.Count - 1), true, true);      // true for validating
                                                                                                    // true for firingPositionChangeNotification
                                                                                                    // true for pulling data from the controls
        }

        /// <include file='doc\ListManager.uex' path='docs/doc[@for="CurrencyManager.CancelCurrentEdit"]/*' />
        /// <devdoc>
        ///    <para>Cancels the current edit operation.</para>
        /// </devdoc>
        public override void CancelCurrentEdit() {
            if (Count > 0) {
                Object item = list[Position];

                // onItemChangedCalled = false;

                if (item is IEditableObject) {
                    ((IEditableObject)item).CancelEdit();
                }

                OnItemChanged(new ItemChangedEventArgs(Position));
            }
        }

        private void ChangeRecordState(int newPosition, bool validating, bool endCurrentEdit, bool firePositionChange, bool pullData) {
            if (newPosition == -1 && list.Count == 0) {
                if (listposition != -1) {
                    this.listposition = -1;
                    OnPositionChanged(EventArgs.Empty);
                }
                return;
            }
            
            if ((newPosition < 0 || newPosition >= Count) && this.IsBinding) {
                throw new IndexOutOfRangeException(SR.GetString(SR.ListManagerBadPosition));
            }
            
            // if PushData fails in the OnCurrentChanged and there was a lastGoodKnownRow
            // then the position does not change, so we should not fire the OnPositionChanged
            // event;
            // this is why we have to cache the old position and compare that w/ the position that
            // the user will want to navigate to
            int oldPosition = listposition;
            if (endCurrentEdit) {
                // Do not PushData when pro. See ASURT 65095.
                inChangeRecordState = true;
                try {
                    EndCurrentEdit();
                } finally {
                    inChangeRecordState = false;
                }
            }

            // we pull the data from the controls only when the ListManager changes the list. when the backEnd changes the list we do not 
            // pull the data from the controls
            if (validating && pullData) {
                CurrencyManager_PullData();
            }

            this.listposition = newPosition;

            if (validating) {
                OnCurrentChanged(EventArgs.Empty);
            }
                
            bool positionChanging = (oldPosition != listposition);
            if (positionChanging && firePositionChange) {
                OnPositionChanged(EventArgs.Empty);
            }                
        }

        /// <include file='doc\ListManager.uex' path='docs/doc[@for="CurrencyManager.CheckEmpty"]/*' />
        /// <devdoc>
        ///    <para>Throws an exception if there is no list.</para>
        /// </devdoc>
        protected void CheckEmpty() {
            if (dataSource == null || list == null || list.Count == 0) {
                throw new InvalidOperationException(SR.GetString(SR.ListManagerEmptyList));
            }
        }

        // will return true if this function changes the position in the list
        private bool CurrencyManager_PushData() {
            if (pullingData)
                return false;

            int initialPosition = listposition;
            if (lastGoodKnownRow == -1) {
                try {
                    PushData();
                } catch (Exception) {
                    // get the first item in the list that is good to push data
                    // for now, we assume that there is a row in the backEnd
                    // that is good for all the bindings.
                    FindGoodRow();
                }
                lastGoodKnownRow = listposition;
            } else {
                try {
                    PushData();
                } catch (Exception) {
                    listposition = lastGoodKnownRow;
                    PushData();
                }
                lastGoodKnownRow = listposition;
            }

            return initialPosition != listposition;
        }

        private void CurrencyManager_PullData() {
            pullingData = true;
            try {
                PullData();
            } finally {
                pullingData = false;
            }
        }

        /// <include file='doc\ListManager.uex' path='docs/doc[@for="CurrencyManager.RemoveAt"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void RemoveAt(int index) {
            list.RemoveAt(index);
        }

        /// <include file='doc\ListManager.uex' path='docs/doc[@for="CurrencyManager.EndCurrentEdit"]/*' />
        /// <devdoc>
        ///    <para>Ends the current edit operation.</para>
        /// </devdoc>
        public override void EndCurrentEdit() {
            if (Count > 0) {
                CurrencyManager_PullData();
                Object item = list[Position];
                if (item is IEditableObject) {
                    ((IEditableObject)item).EndEdit();
                }
            }
        }

        private void FindGoodRow() {
            int rowCount = this.list.Count;
            for (int i = 0; i < rowCount; i++) {
                listposition = i;
                try {
                    PushData();
                } catch (Exception) {
                    continue;
                }
                listposition = i;
                return;
            }
            // if we got here, the list did not contain any rows suitable for the bindings
            // suspend binding and throw an exception
            SuspendBinding();
            throw new Exception(SR.GetString(SR.DataBindingPushDataException));
        }

        /// <devdoc>
        ///    <para>Sets the column to sort by, and the direction of the sort.</para>
        /// </devdoc>
        internal void SetSort(PropertyDescriptor property, ListSortDirection sortDirection) {
            if (list is IBindingList && ((IBindingList)list).SupportsSorting) {
                ((IBindingList)list).ApplySort(property, sortDirection);
            }
        }
        
        /// <devdoc>
        /// <para>Gets a <see cref='System.ComponentModel.PropertyDescriptor'/> for a CurrencyManager.</para>
        /// </devdoc>
        internal PropertyDescriptor GetSortProperty() {
            if ((list is IBindingList) && ((IBindingList)list).SupportsSorting) {
                return ((IBindingList)list).SortProperty;
            }
            return null;
        }

        /// <devdoc>
        ///    <para>Gets the sort direction of a list.</para>
        /// </devdoc>
        internal ListSortDirection GetSortDirection() {
            if ((list is IBindingList) && ((IBindingList)list).SupportsSorting) {
                return ((IBindingList)list).SortDirection;
            }
            return ListSortDirection.Ascending;
        }
                
        /// <devdoc>
        ///    <para>Find the position of a desired list item.</para>
        /// </devdoc>
        internal int Find(PropertyDescriptor property, Object key, bool keepIndex) {
            if (key == null)
                throw new ArgumentNullException("key");

            if (property != null && (list is IBindingList) && ((IBindingList)list).SupportsSearching) {
                return ((IBindingList)list).Find(property, key);
            }

            for (int i = 0; i < list.Count; i++) {
                object value = property.GetValue(list[i]);
                if (key.Equals(value)) {
                    return i; 
                }
            }

            return -1;
        }

        /// <devdoc>
        ///    <para>Gets the name of the list.</para>
        /// </devdoc>
        internal override string GetListName() {
            if (list is ITypedList) {
                return ((ITypedList)list).GetListName(null);
            }
            else {
                return finalType.Name;
            }
        }

        /// <include file='doc\ListManager.uex' path='docs/doc[@for="CurrencyManager.GetListName1"]/*' />
        /// <devdoc>
        ///    <para>Gets the name of the specified list.</para>
        /// </devdoc>
        protected internal override string GetListName(ArrayList listAccessors) {
            if (list is ITypedList) {
                PropertyDescriptor[] properties = new PropertyDescriptor[listAccessors.Count];
                listAccessors.CopyTo(properties, 0);
                return ((ITypedList)list).GetListName(properties);
            }
            return "";            
        }
        
        
        /// <include file='doc\ListManager.uex' path='docs/doc[@for="CurrencyManager.GetItemProperties"]/*' />
        /// <devdoc>
        /// <para>Gets the <see cref='T:System.ComponentModel.PropertyDescriptorCollection'/> for
        ///    the list.</para>
        /// </devdoc>
        public override PropertyDescriptorCollection GetItemProperties() {
            if (typeof(Array).IsAssignableFrom(finalType)) {
                return TypeDescriptor.GetProperties(finalType.GetElementType());
            }

            if (list is ITypedList) {
                return ((ITypedList)list).GetItemProperties(null);
            }
            else {
                // switch to real reflection for indexed property.
                System.Reflection.PropertyInfo[] props = finalType.GetProperties();
                for (int i = 0; i < props.Length; i++) {
                    if ("Item".Equals(props[i].Name) && props[i].PropertyType != typeof(object)) {
                        // get all the properties that are not marked as Browsable(false)
                        // this to avoid returning properties for the ISite property ( on something inheriting from Component)
                        //
                        return TypeDescriptor.GetProperties(props[i].PropertyType, new Attribute[] {new BrowsableAttribute(true)});
                    }
                }
            }

            // If we got to here, return the type of the first element in the list
            if (this.List.Count > 0) {
                return TypeDescriptor.GetProperties(this.List[0], new Attribute[] {new BrowsableAttribute(true)});
            }

            return new PropertyDescriptorCollection(null);
        }

        /// <devdoc>
        /// <para>Gets the <see cref='T:System.ComponentModel.PropertyDescriptorCollection'/> for the specified list.</para>
        /// </devdoc>
        private void List_ListChanged(Object sender, System.ComponentModel.ListChangedEventArgs e) {
            // If you change the assert below, better change the 
            // code in the OnCurrentChanged that deals w/ firing the OnCurrentChanged event
            Debug.Assert(lastGoodKnownRow == -1 || lastGoodKnownRow == listposition, "if we have a valid lastGoodKnownRow, then it should equal the position in the list");
            if (inChangeRecordState)
                return;
            UpdateLastGoodKnownRow(e);
            UpdateIsBinding();
            if (list.Count == 0) {
                listposition = -1;

                if (e.ListChangedType == System.ComponentModel.ListChangedType.Reset && e.NewIndex == -1)
                    // if the list is reset, then let our users know about it.
                    OnItemChanged(resetEvent);

                // we should still fire meta data change notification even when the list is empty
                if (e.ListChangedType == System.ComponentModel.ListChangedType.PropertyDescriptorAdded ||
                    e.ListChangedType == System.ComponentModel.ListChangedType.PropertyDescriptorDeleted ||
                    e.ListChangedType == System.ComponentModel.ListChangedType.PropertyDescriptorChanged)
                    OnMetaDataChanged(EventArgs.Empty);
                return;
            }
            
            suspendPushDataInCurrentChanged = true;
            try {
                switch (e.ListChangedType) {
                    case System.ComponentModel.ListChangedType.Reset:
                        Debug.WriteLineIf(CompModSwitches.DataCursor.TraceVerbose, "System.ComponentModel.ListChangedType.Reset Position: " + Position + " Count: " + list.Count);
                        if (listposition == -1 && list.Count > 0)
                            ChangeRecordState(0, true, false, true, false);     // last false: we don't pull the data from the control when DM changes
                        else 
                            ChangeRecordState(Math.Min(listposition,list.Count - 1), true, false, true, false);
                        UpdateIsBinding();
                        OnItemChanged(resetEvent);
                        break;
                    case System.ComponentModel.ListChangedType.ItemAdded:
                        Debug.WriteLineIf(CompModSwitches.DataCursor.TraceVerbose, "System.ComponentModel.ListChangedType.ItemAdded " + e.NewIndex.ToString());
                        if (e.NewIndex <= listposition && listposition < list.Count - 1) {
                            // this means the current row just moved down by one.
                            // the position changes, so end the current edit
                            ChangeRecordState(listposition + 1, true, true, listposition != list.Count - 2, false);
                            UpdateIsBinding();
                            // 85426: refresh the list after we got the item added event
                            OnItemChanged(resetEvent);
                            // 84460: when we get the itemAdded, and the position was at the end
                            // of the list, do the right thing and notify the positionChanged after refreshing the list
                            if (listposition == list.Count - 1)
                                OnPositionChanged(EventArgs.Empty);
                            break;
                        }
                        if (listposition == -1) {
                            // do not call EndEdit on a row that was not there ( position == -1)
                            ChangeRecordState(0, false, false, true, false);
                        }
                        UpdateIsBinding();
                        // put the call to OnItemChanged after setting the position, so the
                        // controls would use the actual position.
                        // if we have a control bound to a dataView, and then we add a row to a the dataView, 
                        // then the control will use the old listposition to get the data. and this is bad.
                        //
                        OnItemChanged(resetEvent);
                        break;
                    case System.ComponentModel.ListChangedType.ItemDeleted:
                        Debug.WriteLineIf(CompModSwitches.DataCursor.TraceVerbose, "System.ComponentModel.ListChangedType.ItemDeleted " + e.NewIndex.ToString());
                        if (e.NewIndex == listposition) {
                            // this means that the current row got deleted.
                            // cannot end an edit on a row that does not exist anymore
                            ChangeRecordState(Math.Min(listposition, Count - 1), true, false, true, false);
                            // put the call to OnItemChanged after setting the position
                            // in the currencyManager, so controls will use the actual position
                            OnItemChanged(resetEvent);
                            break;
                           
                        }
                        if (e.NewIndex < listposition) {
                            // this means the current row just moved up by one.
                            // cannot end an edit on a row that does not exist anymore
                            ChangeRecordState(listposition - 1, true, false, true, false);
                            // put the call to OnItemChanged after setting the position
                            // in the currencyManager, so controls will use the actual position
                            OnItemChanged(resetEvent);
                            break;
                        }
                        OnItemChanged(resetEvent);
                        break;
                    case System.ComponentModel.ListChangedType.ItemChanged:
                        Debug.WriteLineIf(CompModSwitches.DataCursor.TraceVerbose, "System.ComponentModel.ListChangedType.ItemChanged " + e.NewIndex.ToString());
                        OnItemChanged(new ItemChangedEventArgs(e.NewIndex));
                        break;
                    case System.ComponentModel.ListChangedType.ItemMoved:
                        Debug.WriteLineIf(CompModSwitches.DataCursor.TraceVerbose, "System.ComponentModel.ListChangedType.ItemMoved " + e.NewIndex.ToString());
                        if (e.OldIndex == listposition) { // current got moved.
                            // the position changes, so end the current edit. Make sure there is something that we can end edit...
                            ChangeRecordState(e.NewIndex, true, this.Position > -1 && this.Position < list.Count, true, false);
                        }
                        else if (e.OldIndex > listposition && e.NewIndex <= listposition) { // current pushed down one.
                            // the position changes, so end the current edit. Make sure there is something that we can end edit
                            ChangeRecordState(listposition - 1, true, this.Position > -1 && this.Position < list.Count, true, false);
                        }
                        OnItemChanged(resetEvent);
                        break;
                    case System.ComponentModel.ListChangedType.PropertyDescriptorAdded:
                    case System.ComponentModel.ListChangedType.PropertyDescriptorDeleted:
                    case System.ComponentModel.ListChangedType.PropertyDescriptorChanged:
                        OnMetaDataChanged(EventArgs.Empty);
                        break;
                }
            } finally {
                suspendPushDataInCurrentChanged = false;
            }
        }

        /// <include file='doc\ListManager.uex' path='docs/doc[@for="CurrencyManager.MetaDataChanged"]/*' />
        [SRCategory(SR.CatData)]
        public event EventHandler MetaDataChanged {
            add {
                onMetaDataChangedHandler += value;
            }
            remove {
                onMetaDataChangedHandler -= value;
            }
        }

        /// <include file='doc\ListManager.uex' path='docs/doc[@for="CurrencyManager.OnCurrentChanged"]/*' />
        /// <devdoc>
        /// <para>Causes the CurrentChanged event to occur. </para>
        /// </devdoc>
        internal protected override void OnCurrentChanged(EventArgs e) {
            if (!inChangeRecordState) {
                Debug.WriteLineIf(CompModSwitches.DataView.TraceVerbose, "OnCurrentChanged() " + e.ToString());
                int curLastGoodKnownRow = lastGoodKnownRow;
                bool positionChanged = false;
                if (!suspendPushDataInCurrentChanged)
                    positionChanged = CurrencyManager_PushData();
                if (Count > 0) {
                    Object item = list[Position];
                    if (item is IEditableObject) {
                        ((IEditableObject)item).BeginEdit();
                    }
                }
                try {
                    // if currencyManager changed position then we have two cases:
                    // 1. the previous lastGoodKnownRow was valid: in that case we fell back so do not fire onCurrentChanged
                    // 2. the previous lastGoodKnownRow was invalid: we have two cases:
                    //      a. FindGoodRow actually found a good row, so it can't be the one before the user changed the position: fire the onCurrentChanged
                    //      b. FindGoodRow did not find a good row: we should have gotten an exception so we should not even execute this code
                    if (onCurrentChangedHandler != null && !positionChanged ||(positionChanged && curLastGoodKnownRow != -1))
                        onCurrentChangedHandler(this, e);
                }
                catch (Exception) {
                    // Console.WriteLine("Exception in currentChanged: " + ex.ToString());
                }                    
            }
        }
        
        /// <include file='doc\ListManager.uex' path='docs/doc[@for="CurrencyManager.OnItemChanged"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected virtual void OnItemChanged(ItemChangedEventArgs e) {
            // It is possible that CurrencyManager_PushData will change the position
            // in the list. in that case we have to fire OnPositionChanged event
            bool positionChanged = false;

            // We should not push the data when we suspend the changeEvents.
            // but we should still fire the OnItemChanged event that we get when processing the EndCurrentEdit method.
            if (e.Index == listposition || (e.Index == -1 && Position < Count) && !inChangeRecordState)
                positionChanged = CurrencyManager_PushData();
            Debug.WriteLineIf(CompModSwitches.DataView.TraceVerbose, "OnItemChanged(" + e.Index.ToString() + ") " + e.ToString());
            try {
                if (onItemChanged != null)
                    onItemChanged(this, e);
            }
            catch (Exception) {
            }

            if (positionChanged)
                OnPositionChanged(EventArgs.Empty);
            // onItemChangedCalled = true;
        }

        // private because RelatedCurrencyManager does not need to fire this event
        private void OnMetaDataChanged(EventArgs e) {
            if (onMetaDataChangedHandler != null)
                onMetaDataChangedHandler(this,e);
        }

        /// <include file='doc\ListManager.uex' path='docs/doc[@for="CurrencyManager.OnPositionChanged"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected virtual void OnPositionChanged(EventArgs e) {
            // if (!inChangeRecordState) {
                Debug.WriteLineIf(CompModSwitches.DataView.TraceVerbose, "OnPositionChanged(" + listposition.ToString() + ") " + e.ToString());
                try {
                    if (onPositionChangedHandler != null)
                        onPositionChangedHandler(this, e);
                }
                catch (Exception) {
                }
            // }
        }

        /// <include file='doc\ListManager.uex' path='docs/doc[@for="CurrencyManager.Refresh"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Forces a repopulation of the CurrencyManager
        ///    </para>
        /// </devdoc>
        public void Refresh() {
            List_ListChanged(list, new System.ComponentModel.ListChangedEventArgs(System.ComponentModel.ListChangedType.Reset, -1));
        }
        
        internal void Release() {
            UnwireEvents(list);
        }

        /// <include file='doc\ListManager.uex' path='docs/doc[@for="CurrencyManager.ResumeBinding"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Resumes binding of component properties to list items.</para>
        /// </devdoc>
        public override void ResumeBinding() {
            lastGoodKnownRow = -1;
            try {
                if (!shouldBind) {
                    shouldBind = true;
                    // we need to put the listPosition at the beginning of the list if the list is not empty
                    this.listposition = (this.list != null && this.list.Count != 0) ? 0:-1;
                    UpdateIsBinding();
                }
            }
            catch (Exception e) {
                shouldBind = false;
                UpdateIsBinding();
                throw e;
            }
        }

        /// <include file='doc\ListManager.uex' path='docs/doc[@for="CurrencyManager.SuspendBinding"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Suspends binding.</para>
        /// </devdoc>
        public override void SuspendBinding() {
            lastGoodKnownRow = -1;
            if (shouldBind) {
                shouldBind = false;
                UpdateIsBinding();
            }
        }

        internal void UnwireEvents(IList list) {
            if ((list is IBindingList) && ((IBindingList)list).SupportsChangeNotification) {
                ((IBindingList)list).ListChanged -= new System.ComponentModel.ListChangedEventHandler(List_ListChanged);
                /*
                ILiveList liveList = (ILiveList) list;
                liveList.TableChanged -= new TableChangedEventHandler(List_TableChanged);
                */
            }
        }
        
        /// <include file='doc\ListManager.uex' path='docs/doc[@for="CurrencyManager.UpdateIsBinding"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void UpdateIsBinding() {
            UpdateIsBinding(false);
        }

        private void UpdateIsBinding(bool force) {
            bool newBound = list != null && list.Count > 0 && shouldBind && listposition != -1;
            if (list != null)
            if (bound != newBound || force) {
                // we will call end edit when moving from bound state to unbounded state
                //
                //bool endCurrentEdit = bound && !newBound;
                bound = newBound;
                int newPos = newBound ? 0 : -1;
                ChangeRecordState(newPos, bound, (Position != newPos), true, false);
                int numLinks = Bindings.Count;
                for (int i = 0; i < numLinks; i++) {
                    Bindings[i].UpdateIsBinding();
                }
                OnItemChanged(resetEvent);
            }
        }

        private void UpdateLastGoodKnownRow(System.ComponentModel.ListChangedEventArgs e) {
            switch (e.ListChangedType) {
                case System.ComponentModel.ListChangedType.ItemDeleted:
                    if (e.NewIndex == lastGoodKnownRow)
                        lastGoodKnownRow = -1;
                    break;
                case System.ComponentModel.ListChangedType.Reset:
                    lastGoodKnownRow = -1;
                    break;
                case System.ComponentModel.ListChangedType.ItemAdded:
                    if (e.NewIndex <= lastGoodKnownRow)
                        lastGoodKnownRow ++;
                    break;
                case System.ComponentModel.ListChangedType.ItemMoved:
                    if (e.OldIndex == lastGoodKnownRow)
                        lastGoodKnownRow = e.NewIndex;
                    break;
                case System.ComponentModel.ListChangedType.ItemChanged:
                    if (e.NewIndex == lastGoodKnownRow)
                        lastGoodKnownRow = -1;
                    break;
            }
        }

        internal void WireEvents(IList list) {
            if ((list is IBindingList) && ((IBindingList)list).SupportsChangeNotification) {
                ((IBindingList)list).ListChanged += new System.ComponentModel.ListChangedEventHandler(List_ListChanged);
                /*
                ILiveList liveList = (ILiveList) list;
                liveList.TableChanged += new TableChangedEventHandler(List_TableChanged);
                */
            }
        }        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\createparams.cs ===
//------------------------------------------------------------------------------
// <copyright file="CreateParams.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;
    using System.Text;
    using System;

    /// <include file='doc\CreateParams.uex' path='docs/doc[@for="CreateParams"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class CreateParams {
        string className;
        string caption;
        int style;
        int exStyle;
        int classStyle;
        int x;
        int y;
        int width;
        int height;
        IntPtr parent;
        object param;

        /// <include file='doc\CreateParams.uex' path='docs/doc[@for="CreateParams.ClassName"]/*' />
        /// <devdoc>
        ///     Name of the window class to subclass. The default value for this field
        ///     is null, indicating that the window is not a subclass of an existing
        ///     window class. To subclass an existing window class, store the window
        ///     class name in this field. For example, to subclass the standard edit
        ///     control, set this field to "EDIT".
        /// </devdoc>
        public string ClassName {
            get { return className; }
            set { className = value; }
        }

        /// <include file='doc\CreateParams.uex' path='docs/doc[@for="CreateParams.Caption"]/*' />
        /// <devdoc>
        ///     The initial caption your control will have.
        /// </devdoc>
        public string Caption {
            get { return caption; }
            set { caption = value; }
        }

        /// <include file='doc\CreateParams.uex' path='docs/doc[@for="CreateParams.Style"]/*' />
        /// <devdoc>
        ///     Window style bits. This must be a combination of WS_XXX style flags and
        ///     other control-specific style flags.
        /// </devdoc>
        public int Style {
            get { return style; }
            set { style = value; }
        }

        /// <include file='doc\CreateParams.uex' path='docs/doc[@for="CreateParams.ExStyle"]/*' />
        /// <devdoc>
        ///     Extended window style bits. This must be a combination of WS_EX_XXX
        ///     style flags.
        /// </devdoc>
        public int ExStyle {
            get { return exStyle; }
            set { exStyle = value; }
        }

        /// <include file='doc\CreateParams.uex' path='docs/doc[@for="CreateParams.ClassStyle"]/*' />
        /// <devdoc>
        ///     Class style bits. This must be a combination of CS_XXX style flags. This
        ///     field is ignored if the className field is not null.
        /// </devdoc>
        public int ClassStyle {
            get { return classStyle; }
            set { classStyle = value; }
        }

        /// <include file='doc\CreateParams.uex' path='docs/doc[@for="CreateParams.X"]/*' />
        /// <devdoc>
        ///     The left portion of the initial proposed location.
        /// </devdoc>
        public int X {
            get { return x; }
            set { x = value; }
        }

        /// <include file='doc\CreateParams.uex' path='docs/doc[@for="CreateParams.Y"]/*' />
        /// <devdoc>
        ///     The top portion of the initial proposed location.
        /// </devdoc>
        public int Y {
            get { return y; }
            set { y = value; }
        }

        /// <include file='doc\CreateParams.uex' path='docs/doc[@for="CreateParams.Width"]/*' />
        /// <devdoc>
        ///     The initially proposed width.
        /// </devdoc>
        public int Width {
            get { return width; }
            set { width = value; }
        }

        /// <include file='doc\CreateParams.uex' path='docs/doc[@for="CreateParams.Height"]/*' />
        /// <devdoc>
        ///     The initially proposed height.
        /// </devdoc>
        public int Height {
            get { return height; }
            set { height = value; }
        }

        /// <include file='doc\CreateParams.uex' path='docs/doc[@for="CreateParams.Parent"]/*' />
        /// <devdoc>
        ///     The controls parent.
        /// </devdoc>
        public IntPtr Parent {
            get { return parent; }
            set { parent = value; }
        }

        /// <include file='doc\CreateParams.uex' path='docs/doc[@for="CreateParams.Param"]/*' />
        /// <devdoc>
        ///     Any extra information that the underlying handle might want.
        /// </devdoc>
        public object Param {
            get { return param; }
            set { param = value; }
        }

        /// <include file='doc\CreateParams.uex' path='docs/doc[@for="CreateParams.ToString"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override string ToString() {
            StringBuilder sb = new StringBuilder(64);
            sb.Append("CreateParams {'");
            sb.Append(className);
            sb.Append("', '");
            sb.Append(caption);
            sb.Append("', 0x");
            sb.Append(Convert.ToString(style, 16));
            sb.Append(", 0x");
            sb.Append(Convert.ToString(exStyle, 16));
            sb.Append(", {");
            sb.Append(x);
            sb.Append(", ");
            sb.Append(y);
            sb.Append(", ");
            sb.Append(width);
            sb.Append(", ");
            sb.Append(height);
            sb.Append("}");
            sb.Append("}");
            return sb.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\converteventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="ConvertEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    /// <include file='doc\ConvertEventHandler.uex' path='docs/doc[@for="ConvertEventHandler"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public delegate void ConvertEventHandler(object sender, ConvertEventArgs e);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\cursor.cs ===
//------------------------------------------------------------------------------
// <copyright file="Cursor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;
    using System.Drawing;
    using System.Drawing.Design;
    using CodeAccessPermission = System.Security.CodeAccessPermission;
    using System.Security.Permissions;  
    using System.ComponentModel;
    using System.IO;
    using Microsoft.Win32;
    using System.Runtime.Serialization;
    using System.Globalization;

    /// <include file='doc\Cursor.uex' path='docs/doc[@for="Cursor"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the image used to paint the mouse pointer.
    ///       Different cursor shapes are used to inform the user what operation the mouse will
    ///       have.
    ///    </para>
    /// </devdoc>
    // CONSIDER: rewrite entire class without oleaut
    [
    TypeConverterAttribute(typeof(CursorConverter)),
    Serializable,
    Editor("System.Drawing.Design.CursorEditor, " + AssemblyRef.SystemDrawingDesign, typeof(UITypeEditor))
    ]
    public sealed class Cursor : IDisposable, ISerializable {
        private static Size cursorSize = System.Drawing.Size.Empty;

        private SafeNativeMethods.IPicture picture;
        private IntPtr handle = IntPtr.Zero;       // handle to loaded image
        private bool ownHandle = true;
        private int    resourceId = 0;

        /**
         * Constructor used in deserialization
         */
        internal Cursor(SerializationInfo info, StreamingContext context) {
            SerializationInfoEnumerator sie = info.GetEnumerator();
            if (sie == null) {
                return;
            }
            for (; sie.MoveNext();) {
                if (String.Compare(sie.Name, "CursorData", true, CultureInfo.InvariantCulture) == 0) {
                    try {
                        byte[] dat = (byte[])sie.Value;
                        if (dat != null) {
                            Initialize(LoadPicture(new UnsafeNativeMethods.ComStreamFromDataStream(new MemoryStream(dat))));
                        }
                    }
                    catch (Exception e) {
                        Debug.Fail("failure: " + e.ToString());
                    }
                }
                else if (String.Compare(sie.Name, "CursorResourceId", true, CultureInfo.InvariantCulture) == 0) {
                    LoadFromResourceId((int)sie.Value);
                }
            }
        }

        /// <devdoc>
        ///     Private constructor. If you want a standard system cursor, use one of the
        ///     definitions in the Cursors class.
        /// </devdoc>
        // CONSIDER: Make this private
        internal Cursor(int nResourceId, int dummy) {
            LoadFromResourceId(nResourceId);
        }

        // Private constructor.  We have a private constructor here for
        // static cursors that are loaded through resources.  The only reason
        // to use the private constructor is so that we can assert, rather
        // than throw, if the cursor couldn't be loaded.  Why?  Because
        // throwing in <clinit/> is really rude and will prevent any of windows forms
        // from initializing.  This seems extreme just because we fail to
        // load a cursor.
        internal Cursor(string resource, int dummy) {
            try {
                Stream stream = null;

                stream = typeof(Cursor).Module.Assembly.GetManifestResourceStream(typeof(Cursor), resource);
                Debug.Assert(stream != null, "couldn't get stream for resource " + resource);
                Initialize(LoadPicture(new UnsafeNativeMethods.ComStreamFromDataStream(stream)));
            }
            catch (Exception e) {
                Debug.Fail(e.ToString());
            }
        }

        /// <include file='doc\Cursor.uex' path='docs/doc[@for="Cursor.Cursor1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.Cursor'/> class with the specified handle.
        ///    </para>
        /// </devdoc>
        public Cursor(IntPtr handle) {
            IntSecurity.UnmanagedCode.Demand();
            if (handle == IntPtr.Zero) {
                throw new ArgumentException(SR.GetString(SR.InvalidGDIHandle, (typeof(Cursor)).Name));
            }

            this.handle = handle;
            this.ownHandle = false;
        }

        /// <include file='doc\Cursor.uex' path='docs/doc[@for="Cursor.Cursor2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.Cursor'/>
        ///       class with
        ///       the specified filename.
        ///    </para>
        /// </devdoc>
        public Cursor(string fileName) {
            //Filestream demands the correct FILEIO access here
            //
            FileStream f = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read);
            try {
                Initialize(LoadPicture(new UnsafeNativeMethods.ComStreamFromDataStream(f)));
            }
            finally {
                f.Close();
            }
        }

        /// <include file='doc\Cursor.uex' path='docs/doc[@for="Cursor.Cursor3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.Cursor'/> class from the specified resource.
        ///    </para>
        /// </devdoc>
        public Cursor(Type type, string resource) : this(type.Module.Assembly.GetManifestResourceStream(type,resource)) {
        }

        /// <include file='doc\Cursor.uex' path='docs/doc[@for="Cursor.Cursor4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.Cursor'/> class from the
        ///       specified data stream.
        ///    </para>
        /// </devdoc>
        public Cursor(Stream stream) {
            Initialize(LoadPicture(new UnsafeNativeMethods.ComStreamFromDataStream(stream)));
        }

        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.Cursor'/> class from a
        ///       COM stream.
        ///    </para>
        /// </devdoc>
        private Cursor(SafeNativeMethods.IPicture picture) {
            Initialize(picture);
        }

        /// <include file='doc\Cursor.uex' path='docs/doc[@for="Cursor.Clip"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or
        ///       sets a <see cref='System.Drawing.Rectangle'/> that represents the current clipping rectangle for this <see cref='System.Windows.Forms.Cursor'/> in
        ///       screen coordinates.
        ///    </para>
        /// </devdoc>
        public static Rectangle Clip {
            get {
                NativeMethods.RECT r = new NativeMethods.RECT();
                SafeNativeMethods.GetClipCursor(ref r);
                return Rectangle.FromLTRB(r.left, r.top, r.right, r.bottom);
            }
            set {
                if (value.IsEmpty) {
                    UnsafeNativeMethods.ClipCursor(null);
                }
                else {
                    Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "AdjustCursorClip Demanded");
                    IntSecurity.AdjustCursorClip.Demand();
                    NativeMethods.RECT rcClip = NativeMethods.RECT.FromXYWH(value.X, value.Y, value.Width, value.Height);
                    UnsafeNativeMethods.ClipCursor(ref rcClip);
                }
            }
        }

        /// <include file='doc\Cursor.uex' path='docs/doc[@for="Cursor.Current"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or
        ///       sets a <see cref='System.Windows.Forms.Cursor'/> that
        ///       represents the current mouse cursor. The value is NULL if the current mouse cursor is not visible.
        ///    </para>
        /// </devdoc>
        public static Cursor Current {
            get {
                return CurrentInternal;
            }

            set {
                Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "ModifyCursor Demanded");
                IntSecurity.ModifyCursor.Demand();
                CurrentInternal = value;
            }
        }

        internal static Cursor CurrentInternal {
            get {
                IntPtr curHandle = SafeNativeMethods.GetCursor();
                IntSecurity.UnmanagedCode.Assert();
                return Cursors.KnownCursorFromHCursor( curHandle );
            }
            set {
                IntPtr handle = (value == null) ? IntPtr.Zero : value.handle;
                UnsafeNativeMethods.SetCursor(new HandleRef(value, handle));
            }
        }

        /// <include file='doc\Cursor.uex' path='docs/doc[@for="Cursor.Handle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       the Win32 handle for this <see cref='System.Windows.Forms.Cursor'/> .
        ///    </para>
        /// </devdoc>
        public IntPtr Handle {
            get {
                if (handle == IntPtr.Zero) {
                    throw new ObjectDisposedException(SR.GetString(SR.ObjectDisposed, GetType().Name));
                }
                return handle;
            }
        }

        /// <include file='doc\Cursor.uex' path='docs/doc[@for="Cursor.Position"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a <see cref='System.Drawing.Point'/> that specifies the current cursor
        ///       position in screen coordinates.
        ///    </para>
        /// </devdoc>
        public static Point Position {
            get {
                NativeMethods.POINT p = new NativeMethods.POINT();
                UnsafeNativeMethods.GetCursorPos(p);
                return new Point(p.x, p.y);
            }
            set {
                IntSecurity.AdjustCursorPosition.Demand();
                UnsafeNativeMethods.SetCursorPos(value.X, value.Y);
            }
        }

        /// <include file='doc\Cursor.uex' path='docs/doc[@for="Cursor.Size"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       the size of this <see cref='System.Windows.Forms.Cursor'/> object.
        ///    </para>
        /// </devdoc>
        public Size Size {
            get {
                if (cursorSize.IsEmpty)
                    cursorSize = new Size(
                                         UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CXCURSOR),
                                         UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CYCURSOR)
                                         );
                return cursorSize;
            }
        }

        /// <include file='doc\Cursor.uex' path='docs/doc[@for="Cursor.CopyHandle"]/*' />
        /// <devdoc>
        ///    Duplicates this the Win32 handle of this <see cref='System.Windows.Forms.Cursor'/>.
        /// </devdoc>
        public IntPtr CopyHandle() {
            Size sz = Size;
            return SafeNativeMethods.CopyImage(new HandleRef(this, Handle), NativeMethods.IMAGE_CURSOR, sz.Width, sz.Height, 0);
        }

        /// <devdoc>
        ///    Destroys the Win32 handle of this <see cref='System.Windows.Forms.Cursor'/>, if the
        /// <see cref='System.Windows.Forms.Cursor'/> 
        /// owns the handle
        /// </devdoc>
        private void DestroyHandle() {
            if (ownHandle) {
                UnsafeNativeMethods.DestroyCursor(new HandleRef(this, handle));
            }
        }

        /// <include file='doc\Cursor.uex' path='docs/doc[@for="Cursor.Dispose"]/*' />
        /// <devdoc>
        ///     Cleans up the resources allocated by this object.  Once called, the cursor
        ///     object is no longer useful.
        /// </devdoc>
        public void Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        void Dispose(bool disposing) {
            if (picture != null) {
                picture = null;

                // If we have no message loop, OLE may block on this call.
                // Let pent up SendMessage calls go through here.
                //
                NativeMethods.MSG msg = new NativeMethods.MSG();
                UnsafeNativeMethods.PeekMessage(ref msg, NativeMethods.NullHandleRef, 0, 0, NativeMethods.PM_NOREMOVE | NativeMethods.PM_NOYIELD);
            }

            if (handle != IntPtr.Zero) {
                DestroyHandle();
                handle = IntPtr.Zero;
            }
        }

        /// <devdoc>
        ///     Draws this image to a graphics object.  The drawing command originates on the graphics
        ///     object, but a graphics object generally has no idea how to render a given image.  So,
        ///     it passes the call to the actual image.  This version crops the image to the given
        ///     dimensions and allows the user to specify a rectangle within the image to draw.
        /// </devdoc>
        // This method is way more powerful than what we expose, but I'll leave it in place.
        private void DrawImageCore(Graphics graphics, Rectangle imageRect, Rectangle targetRect, bool stretch) {
            // Support GDI+ Translate method
            targetRect.X += (int) graphics.Transform.OffsetX;
            targetRect.Y += (int) graphics.Transform.OffsetY;

            int rop = 0xcc0020; // RasterOp.SOURCE.GetRop();
            IntPtr dc = graphics.GetHdc();

            try { // want finally clause to release dc
                int imageX = 0;
                int imageY = 0;
                int imageWidth;
                int imageHeight;
                int targetX = 0;
                int targetY = 0;
                int targetWidth = 0;
                int targetHeight = 0;

                Size cursorSize = Size;

                // compute the dimensions of the icon, if needed
                //
                if (!imageRect.IsEmpty) {
                    imageX = imageRect.X;
                    imageY = imageRect.Y;
                    imageWidth = imageRect.Width;
                    imageHeight = imageRect.Height;
                }
                else {
                    imageWidth = cursorSize.Width;
                    imageHeight = cursorSize.Height;
                }

                if (!targetRect.IsEmpty) {
                    targetX = targetRect.X;
                    targetY = targetRect.Y;
                    targetWidth = targetRect.Width;
                    targetHeight = targetRect.Height;
                }
                else {
                    targetWidth = cursorSize.Width;
                    targetHeight = cursorSize.Height;
                }

                int drawWidth, drawHeight;
                int clipWidth, clipHeight;

                if (stretch) {
                    // Short circuit the simple case of blasting an icon to the
                    // screen
                    //
                    if (targetWidth == imageWidth && targetHeight == imageHeight
                        && imageX == 0 && imageY == 0 && rop == NativeMethods.SRCCOPY
                        && imageWidth == cursorSize.Width && imageHeight == cursorSize.Height) {
                        SafeNativeMethods.DrawIcon(new HandleRef(graphics, dc), targetX, targetY, new HandleRef(this, handle));
                        return;
                    }

                    drawWidth = cursorSize.Width * targetWidth / imageWidth;
                    drawHeight = cursorSize.Height * targetHeight / imageHeight;
                    clipWidth = targetWidth;
                    clipHeight = targetHeight;
                }
                else {
                    // Short circuit the simple case of blasting an icon to the
                    // screen
                    //
                    if (imageX == 0 && imageY == 0 && rop == NativeMethods.SRCCOPY
                        && cursorSize.Width <= targetWidth && cursorSize.Height <= targetHeight
                        && cursorSize.Width == imageWidth && cursorSize.Height == imageHeight) {
                        SafeNativeMethods.DrawIcon(new HandleRef(graphics, dc), targetX, targetY, new HandleRef(this, handle));
                        return;
                    }

                    drawWidth = cursorSize.Width;
                    drawHeight = cursorSize.Height;
                    clipWidth = targetWidth < imageWidth ? targetWidth : imageWidth;
                    clipHeight = targetHeight < imageHeight ? targetHeight : imageHeight;
                }

                if (rop == NativeMethods.SRCCOPY) {
                    // The ROP is SRCCOPY, so we can be simple here and take
                    // advantage of clipping regions.  Drawing the cursor
                    // is merely a matter of offsetting and clipping.
                    //
                    SafeNativeMethods.IntersectClipRect(new HandleRef(this, Handle), targetX, targetY, targetX+clipWidth, targetY+clipHeight);
                    SafeNativeMethods.DrawIconEx(new HandleRef(graphics, dc), targetX - imageX, targetY - imageY,
                                       new HandleRef(this, handle), drawWidth, drawHeight, 0, NativeMethods.NullHandleRef, NativeMethods.DI_NORMAL);
                    // Let GDI+ restore clipping
                    return;
                }

                Debug.Fail("Cursor.Draw does not support raster ops.  How did you even pass one in?");
            }
            finally {
                graphics.ReleaseHdcInternal(dc);
            }
        }

        /// <include file='doc\Cursor.uex' path='docs/doc[@for="Cursor.Draw"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draws this <see cref='System.Windows.Forms.Cursor'/> to a <see cref='System.Drawing.Graphics'/>.
        ///    </para>
        /// </devdoc>
        public void Draw(Graphics g, Rectangle targetRect) {
            DrawImageCore(g, Rectangle.Empty, targetRect, false);
        }

        /// <include file='doc\Cursor.uex' path='docs/doc[@for="Cursor.DrawStretched"]/*' />
        /// <devdoc>
        ///    Draws this <see cref='System.Windows.Forms.Cursor'/> to a <see cref='System.Drawing.Graphics'/>.
        /// </devdoc>
        public void DrawStretched(Graphics g, Rectangle targetRect) {
            DrawImageCore(g, Rectangle.Empty, targetRect, true);
        }

        /// <include file='doc\Cursor.uex' path='docs/doc[@for="Cursor.Finalize"]/*' />
        /// <devdoc>
        ///    Cleans up Windows resources for this object.
        /// </devdoc>
        ~Cursor() {
            Dispose(false);
        }

        /// <include file='doc\Cursor.uex' path='docs/doc[@for="Cursor.ISerializable.GetObjectData"]/*' />
        /// <devdoc>
        /// ISerializable private implementation
        /// </devdoc>
        /// <internalonly/>
        void ISerializable.GetObjectData(SerializationInfo si, StreamingContext context) {
            if (picture != null) {
                MemoryStream stream = new MemoryStream();
                SavePicture(stream);
                si.AddValue("CursorData", stream.ToArray(), typeof(byte[]));
            }
            else if (resourceId != 0) {
                si.AddValue("CursorResourceId", resourceId, typeof(int));
            }
            else {
                Debug.Fail("Why are we trying to serialize an empty cursor?");
                throw new SerializationException(SR.GetString(SR.CursorNonSerializableHandle));
            }
        }

        /// <include file='doc\Cursor.uex' path='docs/doc[@for="Cursor.Hide"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Hides the cursor. For every call to Cursor.hide() there must be a
        ///       balancing call to Cursor.show().
        ///    </para>
        /// </devdoc>
        public static void Hide() {
            Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "AdjustCursorClip Demanded");
            IntSecurity.AdjustCursorClip.Demand();

            UnsafeNativeMethods.ShowCursor(false);
        }

        /// <devdoc>
        ///     Initializes this image for the first time.  This should only be called once.
        /// </devdoc>
        private void Initialize(SafeNativeMethods.IPicture picture) {
            if (this.picture != null) {
                throw new InvalidOperationException(SR.GetString(SR.IllegalState, GetType().Name));
            }

            this.picture = picture;
            
            // SECUNDONE : Assert shouldn't be needed, however we can't put SuppressUnmanagedCode
            //           : on the IPicture interface, so we must do an Assert.
            //
            new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Assert();
            
            try {
                if (picture != null && picture.GetPictureType() == NativeMethods.Ole.PICTYPE_ICON) {
                    handle = picture.GetHandle();
                    ownHandle = false;
                }
                else {
                    throw new ArgumentException(SR.GetString(SR.InvalidPictureType,
                                                      "picture",
                                                      "Cursor"), "picture");
                }
            }
            finally {
                CodeAccessPermission.RevertAssert();
            }
            
        }

        private void LoadFromResourceId(int nResourceId) {
            ownHandle = false;  // we don't delete stock cursors.

           // We assert here on exception -- this constructor is used during clinit,
           // and it would be a shame if we failed to initialize all of windows forms just
           // just because a cursor couldn't load.
           //
           try {
               resourceId = nResourceId;
               handle = SafeNativeMethods.LoadCursor(NativeMethods.NullHandleRef, nResourceId);
           }
           catch (Exception e) {
               handle = IntPtr.Zero;
               Debug.Fail(e.ToString());
           }
        }

        /// <devdoc>
        ///     Loads an image from a datastream.  This will return a bitmap, icon,
        ///     cursor or metafile object depending on the type of data in the stream.
        /// </devdoc>
        private static Cursor LoadImage(Stream stream) {
            return LoadImage(new UnsafeNativeMethods.ComStreamFromDataStream(stream));
        }

        /// <devdoc>
        ///     Loads an image from a COM stream.  This will return a bitmap, icon,
        ///     cursor or metafile object depending on the type of data in the stream.
        /// </devdoc>
        unsafe private static Cursor LoadImage(UnsafeNativeMethods.IStream stream) {
            Cursor cursor = null;
            SafeNativeMethods.IPicture picture = LoadPicture(stream);
            if (picture.GetPictureType() == NativeMethods.Ole.PICTYPE_ICON) {
                // black magic stolen from oleaut.
                stream.Seek(2, NativeMethods.STREAM_SEEK_SET);
                byte b = 0;
                int numRead = stream.Read((IntPtr)(int)&b, 1);

                Debug.Assert(numRead == 1, "Could read 1 byte from the stream!!!");

                if (numRead == 1 && b == 2) {
                    cursor = new Cursor(picture);
                }
                // Otherwise, it's really an Icon.
            }

            if (cursor != null)
                return cursor;
            else {
                throw new ArgumentException(SR.GetString(SR.InvalidPictureType,
                                                  "picture",
                                                  "Cursor"), "stream");
            }
        }

        /// <devdoc>
        ///     Loads a picture from the requested stream.
        /// </devdoc>
        private static SafeNativeMethods.IPicture LoadPicture(UnsafeNativeMethods.IStream stream) {
            SafeNativeMethods.IPicture picture = null;
            if (stream == null) {
                throw new ArgumentException(SR.GetString(SR.InvalidArgument, "stream", "null"));
            }
            try {
                Guid g = typeof(SafeNativeMethods.IPicture).GUID;
                picture = SafeNativeMethods.OleLoadPicture(stream,0,false, ref g);
            }
            catch (Exception e) {
                Debug.Fail(e.ToString());
                throw new ArgumentException(SR.GetString(SR.InvalidPictureFormat), "stream");
            }
            return picture;
        }

        /// <devdoc>
        ///     Saves a picture from the requested stream.
        /// </devdoc>
        internal void SavePicture(Stream stream) {
            if (stream == null) {
                throw new ArgumentException(SR.GetString(SR.InvalidArgument, "stream", "null"));
            }
            try {
                int temp;
                picture.SaveAsFile(new UnsafeNativeMethods.ComStreamFromDataStream(stream), -1, out temp);
            }
            catch (Exception e) {
                Debug.Fail(e.ToString());
                throw new InvalidOperationException(SR.GetString(SR.InvalidPictureFormat));
            }
        }

        /// <include file='doc\Cursor.uex' path='docs/doc[@for="Cursor.Show"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Displays the cursor. For every call to Cursor.show() there must have been
        ///       a previous call to Cursor.hide().
        ///    </para>
        /// </devdoc>
        public static void Show() {
            UnsafeNativeMethods.ShowCursor(true);
        }

        /// <include file='doc\Cursor.uex' path='docs/doc[@for="Cursor.ToString"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Retrieves a human readable string representing this
        ///    <see cref='System.Windows.Forms.Cursor'/>
        ///    .
        /// </para>
        /// </devdoc>
        public override string ToString() {
            string s = null;
            
            if (!this.ownHandle)
                s = TypeDescriptor.GetConverter(typeof(Cursor)).ConvertToString(this);
            else
                s = base.ToString();
            
            return "[Cursor: " + s + "]";
        }
        
        /// <include file='doc\Cursor.uex' path='docs/doc[@for="Cursor.operatorEQ"]/*' />
        public static bool operator ==(Cursor left, Cursor right) {
            if (object.ReferenceEquals(left, null) != object.ReferenceEquals(right, null)) {
                return false;
            }
            
            if (!object.ReferenceEquals(left, null)) {
                return (left.handle == right.handle);
            }
            else {
                return true;
            }
        }
        
        /// <include file='doc\Cursor.uex' path='docs/doc[@for="Cursor.operatorNE"]/*' />
        public static bool operator !=(Cursor left, Cursor right) {
            return !(left == right);
        }
        
        /// <include file='doc\Cursor.uex' path='docs/doc[@for="Cursor.GetHashCode"]/*' />
        public override int GetHashCode() {
            return (int)handle;
        }
        
        /// <include file='doc\Cursor.uex' path='docs/doc[@for="Cursor.Equals"]/*' />
        public override bool Equals(object obj) {
            return (this == (Cursor)obj);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\cursorconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="CursorConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;
    using Microsoft.Win32;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design.Serialization;
    using System.Globalization;
    using System.Reflection;
    using System.IO;

    /// <include file='doc\CursorConverter.uex' path='docs/doc[@for="CursorConverter"]/*' />
    /// <devdoc>
    ///      CursorConverter is a class that can be used to convert
    ///      colors from one data type to another.  Access this
    ///      class through the TypeDescriptor.
    /// </devdoc>
    public class CursorConverter : TypeConverter {
    
        private StandardValuesCollection values;

        /// <include file='doc\CursorConverter.uex' path='docs/doc[@for="CursorConverter.CanConvertFrom"]/*' />
        /// <devdoc>
        ///      Determines if this converter can convert an object in the given source
        ///      type to the native type of the converter.
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string) || sourceType == typeof(byte[])) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }

        /// <include file='doc\CursorConverter.uex' path='docs/doc[@for="CursorConverter.CanConvertTo"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this converter can
        ///       convert an object to the given destination type using the context.</para>
        /// </devdoc>
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
            if (destinationType == typeof(InstanceDescriptor) || destinationType == typeof(byte[])) {
                return true;
            }

            return base.CanConvertTo(context, destinationType);
        }
        
        /// <include file='doc\CursorConverter.uex' path='docs/doc[@for="CursorConverter.ConvertFrom"]/*' />
        /// <devdoc>
        ///      Converts the given object to the converter's native type.
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
        
            if (value is string) {
                string text = ((string)value).Trim();
                
                PropertyInfo[] props = GetProperties();
                for (int i = 0; i < props.Length; i++) {
                    PropertyInfo prop = props[i];
                    if (string.Compare(prop.Name, text, true, CultureInfo.InvariantCulture) == 0) {
                        object[] tempIndex = null;
                        return prop.GetValue(null, tempIndex);
                    }
                }
            }
            
            if (value is byte[]) {
                MemoryStream ms = new MemoryStream((byte[])value);
                return new Cursor(ms);
            }

            return base.ConvertFrom(context, culture, value);
        }

        /// <include file='doc\CursorConverter.uex' path='docs/doc[@for="CursorConverter.ConvertTo"]/*' />
        /// <devdoc>
        ///      Converts the given object to another type.  The most common types to convert
        ///      are to and from a string object.  The default implementation will make a call
        ///      to ToString on the object if the object is valid and if the destination
        ///      type is string.  If this cannot convert to the desitnation type, this will
        ///      throw a NotSupportedException.
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(string) && value != null) {
                PropertyInfo[] props = GetProperties();
                int bestMatch = -1;

                for (int i = 0; i < props.Length; i++) {
                    PropertyInfo prop = props[i];
                    object[] tempIndex = null;
                    Cursor c = (Cursor)prop.GetValue(null, tempIndex);
                    if (c == (Cursor)value) {
                        if (Object.ReferenceEquals(c, value)) {
                            return prop.Name;
                        }
                        else {
                            bestMatch = i;
                        }
                    }
                }

                if (bestMatch != -1) {
                    return props[bestMatch].Name;
                }
                
                // We throw here because we cannot meaningfully convert a custom
                // cursor into a string. In fact, the ResXResourceWriter will use
                // this exception to indicate to itself that this object should
                // be serialized through ISeriazable instead of a string.
                //
                throw new FormatException(SR.GetString(SR.CursorCannotCovertToString));
            }

            if (destinationType == typeof(InstanceDescriptor) && value is Cursor) {
                PropertyInfo[] props = GetProperties();
                foreach(PropertyInfo prop in props) {
                    if (prop.GetValue(null, null) == value) {
                        return new InstanceDescriptor(prop, null);
                    }
                }
            }
            
            if (destinationType == typeof(byte[])) {
                if (value != null) {
                    MemoryStream ms = new MemoryStream();
                    Cursor cursor = (Cursor)value;
                    cursor.SavePicture(ms);
                    ms.Close();
                    return ms.ToArray();
                }
                else 
                    return new byte[0];
            }

            return base.ConvertTo(context, culture, value, destinationType);
        }
        
        /// <include file='doc\CursorConverter.uex' path='docs/doc[@for="CursorConverter.GetProperties"]/*' />
        /// <devdoc>
        ///      Retrieves the properties for the available cursors.
        /// </devdoc>
        private PropertyInfo[] GetProperties() {
            return typeof(Cursors).GetProperties(BindingFlags.Static | BindingFlags.Public);
        }

        /// <include file='doc\CursorConverter.uex' path='docs/doc[@for="CursorConverter.GetStandardValues"]/*' />
        /// <devdoc>
        ///      Retrieves a collection containing a set of standard values
        ///      for the data type this validator is designed for.  This
        ///      will return null if the data type does not support a
        ///      standard set of values.
        /// </devdoc>
        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) {
            if (values == null) {
                ArrayList list = new ArrayList();
                PropertyInfo[] props = GetProperties();
                for (int i = 0; i < props.Length; i++) {
                    PropertyInfo prop = props[i];
                    object[] tempIndex = null;
                    Debug.Assert(prop.GetValue(null, tempIndex) != null, "Property " + prop.Name + " returned NULL");
                    list.Add(prop.GetValue(null, tempIndex));
                }
                
                values = new StandardValuesCollection(list.ToArray());
            }
            
            return values;
        }

        /// <include file='doc\CursorConverter.uex' path='docs/doc[@for="CursorConverter.GetStandardValuesSupported"]/*' />
        /// <devdoc>
        ///      Determines if this object supports a standard set of values
        ///      that can be picked from a list.
        /// </devdoc>
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context) {
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\datagridaddnewrow.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGridAddNewRow.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    using System.Runtime.Remoting;

    using System.Diagnostics;

    using System;
    
    using System.Windows.Forms;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;

    /// <devdoc>
    ///      This class fully encapsulates the painting logic for an addnew row
    ///      appearing in a DataGrid.
    /// </devdoc>
    internal class DataGridAddNewRow : DataGridRow {

        private bool dataBound = false;

        public DataGridAddNewRow(DataGrid dGrid, DataGridTableStyle gridTable, int rowNum)
            : base(dGrid, gridTable, rowNum) {
        }

        // =------------------------------------------------------------------
        // =        Methods
        // =------------------------------------------------------------------

        /// <devdoc>
        ///      Since the DataView does not return a valid DataRow for
        ///      a newly added row, the DataGrid sets this property to
        ///      true to signal that the AddNewRow can safely render
        ///      row contents and permit editing, etc because a DataRecord
        ///      exists in the cursor that created this row.
        /// </devdoc>
        public bool DataBound {
            get {
                return dataBound;
            }
            set {
                dataBound = value;
            }
        }

        public override void OnEdit() {
            if (!DataBound) {
                DataGrid.AddNewRow();
            }
        }

        public override void OnRowLeave() {
            if (DataBound)
                DataBound = false;
        }

        // the addNewRow has nothing to do with losing focus
        //
        internal override void LoseChildFocus(Rectangle rowHeader, bool alignToRight)
        {
        }

        // the newDataRow has nothing to do with TAB keys
        //
        internal override bool ProcessTabKey(Keys keyData, Rectangle rowHeaders, bool alignToRight)
        {
            return false;
        }

        /// <devdoc>
        ///      Paints the row.
        /// </devdoc>
        public override int Paint(Graphics g, Rectangle bounds, Rectangle trueRowBounds, int firstVisibleColumn, int columnCount)
        {
            return Paint(g, bounds, trueRowBounds, firstVisibleColumn, columnCount, false);
        }

        public override int Paint(Graphics g,
                                  Rectangle bounds,
                                  Rectangle trueRowBounds,
                                  int firstVisibleColumn,
                                  int columnCount,
                                  bool alignToRight) {
            Rectangle dataBounds = bounds;
            DataGridLineStyle gridStyle;
            if (this.dgTable.IsDefault)
                gridStyle = this.DataGrid.GridLineStyle;
            else
                gridStyle = this.dgTable.GridLineStyle;
            int bWidth = this.DataGrid == null ? 0 : gridStyle == DataGridLineStyle.Solid ? 1 : 0;
            dataBounds.Height -= bWidth;
            int cx = base.PaintData(g, dataBounds, firstVisibleColumn, columnCount, alignToRight);

            if (bWidth > 0)
                PaintBottomBorder(g, bounds, cx, bWidth, alignToRight);
            return cx;
        }

        protected override void PaintCellContents(Graphics g, Rectangle cellBounds, DataGridColumnStyle column,
                                                  Brush backBr, Brush foreBrush, bool alignToRight) {
            if (DataBound) {
                CurrencyManager listManager = DataGrid.ListManager;
                column.Paint(g, cellBounds, listManager, this.RowNumber, alignToRight);
            }
            else {
                base.PaintCellContents(g, cellBounds, column, backBr, foreBrush, alignToRight);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\dataformats.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataFormats.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Text;
    using System.Configuration.Assemblies;
    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using System.Runtime.InteropServices;
    using System.Globalization;

    /// <include file='doc\DataFormats.uex' path='docs/doc[@for="DataFormats"]/*' />
    /// <devdoc>
    ///    <para>Translates
    ///       between Win Forms text-based
    ///    <see cref='System.Windows.Forms.Clipboard'/> formats and <see langword='Microsoft.Win32'/> 32-bit signed integer-based 
    ///       clipboard formats. Provides <see langword='static '/> methods to create new <see cref='System.Windows.Forms.Clipboard'/> formats and add
    ///       them to the Windows Registry.</para>
    /// </devdoc>
    public class DataFormats {
        /// <include file='doc\DataFormats.uex' path='docs/doc[@for="DataFormats.Text"]/*' />
        /// <devdoc>
        /// <para>Specifies the standard ANSI text format. This <see langword='static '/> 
        /// field is read-only.</para>
        /// </devdoc>
        public static readonly string Text          = "Text";

        /// <include file='doc\DataFormats.uex' path='docs/doc[@for="DataFormats.UnicodeText"]/*' />
        /// <devdoc>
        ///    <para>Specifies the standard Windows Unicode text format. This 
        ///    <see langword='static '/>
        ///    field is read-only.</para>
        /// </devdoc>
        public static readonly string UnicodeText   = "UnicodeText";

        /// <include file='doc\DataFormats.uex' path='docs/doc[@for="DataFormats.Dib"]/*' />
        /// <devdoc>
        ///    <para>Specifies the Windows Device Independent Bitmap (DIB) 
        ///       format. This <see langword='static '/>
        ///       field is read-only.</para>
        /// </devdoc>
        public static readonly string Dib           = "DeviceIndependentBitmap";

        /// <include file='doc\DataFormats.uex' path='docs/doc[@for="DataFormats.Bitmap"]/*' />
        /// <devdoc>
        /// <para>Specifies a Windows bitmap format. This <see langword='static '/> field is read-only.</para>
        /// </devdoc>
        public static readonly string Bitmap        = "Bitmap";

        /// <include file='doc\DataFormats.uex' path='docs/doc[@for="DataFormats.EnhancedMetafile"]/*' />
        /// <devdoc>
        ///    <para>Specifies the Windows enhanced metafile format. This 
        ///    <see langword='static '/> field is read-only.</para>
        /// </devdoc>
        public static readonly string EnhancedMetafile   = "EnhancedMetafile";

        /// <include file='doc\DataFormats.uex' path='docs/doc[@for="DataFormats.MetafilePict"]/*' />
        /// <devdoc>
        ///    <para>Specifies the Windows metafile format, which Win Forms 
        ///       does not directly use. This <see langword='static '/>
        ///       field is read-only.</para>
        /// </devdoc>
        public static readonly string MetafilePict  = "MetaFilePict";

        /// <include file='doc\DataFormats.uex' path='docs/doc[@for="DataFormats.SymbolicLink"]/*' />
        /// <devdoc>
        ///    <para>Specifies the Windows symbolic link format, which Win 
        ///       Forms does not directly use. This <see langword='static '/>
        ///       field is read-only.</para>
        /// </devdoc>
        public static readonly string SymbolicLink          = "SymbolicLink";

        /// <include file='doc\DataFormats.uex' path='docs/doc[@for="DataFormats.Dif"]/*' />
        /// <devdoc>
        ///    <para>Specifies the Windows data interchange format, which Win 
        ///       Forms does not directly use. This <see langword='static '/>
        ///       field is read-only.</para>
        /// </devdoc>
        public static readonly string Dif           = "DataInterchangeFormat";

        /// <include file='doc\DataFormats.uex' path='docs/doc[@for="DataFormats.Tiff"]/*' />
        /// <devdoc>
        ///    <para>Specifies the Tagged Image File Format (TIFF), which Win 
        ///       Forms does not directly use. This <see langword='static '/>
        ///       field is read-only.</para>
        /// </devdoc>
        public static readonly string Tiff          = "TaggedImageFileFormat";

        /// <include file='doc\DataFormats.uex' path='docs/doc[@for="DataFormats.OemText"]/*' />
        /// <devdoc>
        ///    <para>Specifies the standard Windows original equipment 
        ///       manufacturer (OEM) text format. This <see langword='static '/> field is read-only.</para>
        /// </devdoc>
        public static readonly string OemText       = "OEMText";
        /// <include file='doc\DataFormats.uex' path='docs/doc[@for="DataFormats.Palette"]/*' />
        /// <devdoc>
        /// <para>Specifies the Windows palette format. This <see langword='static '/> 
        /// field is read-only.</para>
        /// </devdoc>
        public static readonly string Palette       = "Palette";

        /// <include file='doc\DataFormats.uex' path='docs/doc[@for="DataFormats.PenData"]/*' />
        /// <devdoc>
        ///    <para>Specifies the Windows pen data format, which consists of 
        ///       pen strokes for handwriting software; Win Forms does not use this format. This
        ///    <see langword='static '/> 
        ///    field is read-only.</para>
        /// </devdoc>
        public static readonly string PenData       = "PenData";

        /// <include file='doc\DataFormats.uex' path='docs/doc[@for="DataFormats.Riff"]/*' />
        /// <devdoc>
        ///    <para>Specifies the Resource Interchange File Format (RIFF) 
        ///       audio format, which Win Forms does not directly use. This <see langword='static '/> field is read-only.</para>
        /// </devdoc>
        public static readonly string Riff          = "RiffAudio";

        /// <include file='doc\DataFormats.uex' path='docs/doc[@for="DataFormats.WaveAudio"]/*' />
        /// <devdoc>
        ///    <para>Specifies the wave audio format, which Win Forms does not 
        ///       directly use. This <see langword='static '/> field is read-only.</para>
        /// </devdoc>
        public static readonly string WaveAudio          = "WaveAudio";

        /// <include file='doc\DataFormats.uex' path='docs/doc[@for="DataFormats.FileDrop"]/*' />
        /// <devdoc>
        ///    <para>Specifies the Windows file drop format, which Win Forms 
        ///       does not directly use. This <see langword='static '/>
        ///       field is read-only.</para>
        /// </devdoc>
        public static readonly string FileDrop         = "FileDrop";

        /// <include file='doc\DataFormats.uex' path='docs/doc[@for="DataFormats.Locale"]/*' />
        /// <devdoc>
        ///    <para>Specifies the Windows culture format, which Win Forms does 
        ///       not directly use. This <see langword='static '/> field is read-only.</para>
        /// </devdoc>
        public static readonly string Locale        = "Locale";

        /// <include file='doc\DataFormats.uex' path='docs/doc[@for="DataFormats.Html"]/*' />
        /// <devdoc>
        ///    <para>Specifies text consisting of HTML data. This 
        ///    <see langword='static '/> field is read-only.</para>
        /// </devdoc>
        public static readonly string Html          = "HTML Format";

        /// <include file='doc\DataFormats.uex' path='docs/doc[@for="DataFormats.Rtf"]/*' />
        /// <devdoc>
        ///    <para>Specifies text consisting of Rich Text Format (RTF) data. This 
        ///    <see langword='static '/> field is read-only.</para>
        /// </devdoc>
        public static readonly string Rtf       = "Rich Text Format";

        /// <include file='doc\DataFormats.uex' path='docs/doc[@for="DataFormats.CommaSeparatedValue"]/*' />
        /// <devdoc>
        ///    <para>Specifies a comma-separated value (CSV) format, which is a 
        ///       common interchange format used by spreadsheets. This format is not used directly
        ///       by Win Forms. This <see langword='static '/>
        ///       field is read-only.</para>
        /// </devdoc>
        public static readonly string CommaSeparatedValue           = "Csv";

        /// <include file='doc\DataFormats.uex' path='docs/doc[@for="DataFormats.StringFormat"]/*' />
        /// <devdoc>
        ///    <para>Specifies the Win Forms string class format, which Win 
        ///       Forms uses to store string objects. This <see langword='static '/>
        ///       field is read-only.</para>
        /// </devdoc>
        // I'm sure upper case "String" is a reserved word in some language that matters
        public static readonly string StringFormat   = typeof(string).FullName;
        //C#r: public static readonly String CF_STRINGCLASS   = typeof(String).Name;

        /// <include file='doc\DataFormats.uex' path='docs/doc[@for="DataFormats.Serializable"]/*' />
        /// <devdoc>
        ///    <para>Specifies a format that encapsulates any type of Win Forms 
        ///       object. This <see langword='static '/> field is read-only.</para>
        /// </devdoc>
        public static readonly string Serializable     = Application.WindowsFormsVersion + "PersistentObject";

        
        private static Format[] formatList;
        private static int formatCount = 0;

        // not creatable...
        //
        private DataFormats() {
        }

        /// <include file='doc\DataFormats.uex' path='docs/doc[@for="DataFormats.GetFormat"]/*' />
        /// <devdoc>
        /// <para>Gets a <see cref='System.Windows.Forms.DataFormats.Format'/> with the Windows Clipboard numeric ID and name for the specified format.</para>
        /// </devdoc>
        public static Format GetFormat(string format) {
            lock(typeof(DataFormats)) {
                EnsurePredefined();

                // It is much faster to do a case sensitive search here.  So do 
                // the case sensitive compare first, then the expensive one.
                //
                for (int n = 0; n < formatCount; n++) {
                    if (formatList[n].Name.Equals(format))
                        return formatList[n];
                }
                
                for (int n = 0; n < formatCount; n++) {
                    if (String.Compare(formatList[n].Name, format, true, CultureInfo.InvariantCulture) == 0)
                        return formatList[n];
                }
        
                // need to add this format string
                //
                int formatId = SafeNativeMethods.RegisterClipboardFormat(format);
                if (0 == formatId) {
                    throw new Win32Exception(Marshal.GetLastWin32Error(), SR.GetString(SR.RegisterCFFailed));
                }
        

                EnsureFormatSpace(1);
                formatList[formatCount] = new Format(format, formatId);
                return formatList[formatCount++];
            }
        }

        /// <include file='doc\DataFormats.uex' path='docs/doc[@for="DataFormats.GetFormat1"]/*' />
        /// <devdoc>
        /// <para>Gets a <see cref='System.Windows.Forms.DataFormats.Format'/> with the Windows Clipboard numeric
        ///    ID and name for the specified ID.</para>
        /// </devdoc>
        public static Format GetFormat(int id) {
            return InternalGetFormat( null, id );
        }

        /// <include file='doc\DataFormats.uex' path='docs/doc[@for="DataFormats.InternalGetFormat"]/*' />
        /// <devdoc>
        ///     Allows a the new format name to be specified if the requested format is not
        ///     in the list
        /// </devdoc>
        /// <internalonly/>
        private static Format InternalGetFormat(string strName, int id) {
            lock(typeof(DataFormats)) {
                EnsurePredefined();

                for (int n = 0; n < formatCount; n++) {
                    if (formatList[n].Id == id)
                        return formatList[n];
                }

                StringBuilder s = new StringBuilder(128);

                // This can happen if windows adds a standard format that we don't know about,
                // so we should play it safe.
                //
                if (0 == SafeNativeMethods.GetClipboardFormatName(id, s, s.Capacity)) {
                    s.Length = 0;
                    if (strName == null) {
                        s.Append( "Format" ).Append( id );
                    }
                    else {
                        s.Append( strName );
                    }
                }

                EnsureFormatSpace(1);
                formatList[formatCount] = new Format(s.ToString(), id);

                return formatList[formatCount++];
            }
        }


        /// <include file='doc\DataFormats.uex' path='docs/doc[@for="DataFormats.EnsureFormatSpace"]/*' />
        /// <devdoc>
        ///     ensures that we have enough room in our format list
        /// </devdoc>
        /// <internalonly/>
        private static void EnsureFormatSpace(int size) {
            if (null == formatList || formatList.Length <= formatCount + size) {
                int newSize = formatCount + 20;

                Format[] newList = new Format[newSize];

                for (int n = 0; n < formatCount; n++) {
                    newList[n] = formatList[n];
                }
                formatList = newList;
            }                   
        }

        /// <include file='doc\DataFormats.uex' path='docs/doc[@for="DataFormats.EnsurePredefined"]/*' />
        /// <devdoc>
        ///     ensures that the Win32 predefined formats are setup in our format list.  This
        ///     is called anytime we need to search the list
        /// </devdoc>
        /// <internalonly/>
        private static void EnsurePredefined() {

            if (0 == formatCount) {

                /* not used
                int standardText;

                // We must handle text differently for Win 95 and NT.  We should put
                // UnicodeText on the clipboard for NT, and Text for Win 95.
                // So, we figure it out here theh first time someone asks for format info
                //
                if (1 == Marshal.SystemDefaultCharSize) {
                    standardText = NativeMethods.CF_TEXT;
                }
                else {
                    standardText = NativeMethods.CF_UNICODETEXT;
                }
                */

                formatList = new Format [] {
                    //         Text name        Win32 format ID      Data stored as a Win32 handle?
                    new Format(UnicodeText,  NativeMethods.CF_UNICODETEXT),
                    new Format(Text,         NativeMethods.CF_TEXT),
                    new Format(Bitmap,       NativeMethods.CF_BITMAP),
                    new Format(MetafilePict, NativeMethods.CF_METAFILEPICT),
                    new Format(EnhancedMetafile,  NativeMethods.CF_ENHMETAFILE),
                    new Format(Dif,          NativeMethods.CF_DIF),
                    new Format(Tiff,         NativeMethods.CF_TIFF),
                    new Format(OemText,      NativeMethods.CF_OEMTEXT),
                    new Format(Dib,          NativeMethods.CF_DIB),
                    new Format(Palette,      NativeMethods.CF_PALETTE),
                    new Format(PenData,      NativeMethods.CF_PENDATA),
                    new Format(Riff,         NativeMethods.CF_RIFF),
                    new Format(WaveAudio,    NativeMethods.CF_WAVE),
                    new Format(SymbolicLink, NativeMethods.CF_SYLK),
                    new Format(FileDrop,     NativeMethods.CF_HDROP),
                    new Format(Locale,       NativeMethods.CF_LOCALE)
                };

                formatCount = formatList.Length;
            }
        }

        /// <include file='doc\DataFormats.uex' path='docs/doc[@for="DataFormats.Format"]/*' />
        /// <devdoc>
        ///    <para>Represents a format type.</para>
        /// </devdoc>
        public class Format {
            readonly string name;
            readonly int id;
            
            /// <include file='doc\DataFormats.uex' path='docs/doc[@for="DataFormats.Format.Name"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Specifies the
            ///       name of this format. This field is read-only.
            ///       
            ///    </para>
            /// </devdoc>
            public string Name {
                get {
                    return name;
                }
            }

            /// <include file='doc\DataFormats.uex' path='docs/doc[@for="DataFormats.Format.Id"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Specifies the ID
            ///       number for this format. This field is read-only.
            ///    </para>
            /// </devdoc>
            public int Id {
                get {
                    return id;
                }
            }

            /// <include file='doc\DataFormats.uex' path='docs/doc[@for="DataFormats.Format.Format"]/*' />
            /// <devdoc>
            /// <para>Initializes a new instance of the <see cref='System.Windows.Forms.DataFormats.Format'/> class and specifies whether a
            /// <see langword='Win32 '/> 
            /// handle is expected with this format.</para>
            /// </devdoc>
            public Format(string name, int id) {
                this.name = name;
                this.id = id;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\cursors.cs ===
//------------------------------------------------------------------------------
// <copyright file="Cursors.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Drawing;


    /// <include file='doc\Cursors.uex' path='docs/doc[@for="Cursors"]/*' />
    /// <devdoc>
    ///     Standard cursors
    /// </devdoc>
    public sealed class Cursors {
        private static  Cursor appStarting = null;
        private static  Cursor arrow       = null;
        private static  Cursor cross       = null;
        private static  Cursor defaultCursor = null;
        private static  Cursor iBeam       = null;
        private static  Cursor no          = null;
        private static  Cursor sizeAll     = null;
        private static  Cursor sizeNESW    = null;
        private static  Cursor sizeNS      = null;
        private static  Cursor sizeNWSE    = null;
        private static  Cursor sizeWE      = null;
        private static  Cursor upArrow     = null;
        private static  Cursor wait        = null;
        private static  Cursor help        = null;
        private static  Cursor hSplit      = null;
        private static  Cursor vSplit      = null;
        private static  Cursor noMove2D    = null;
        private static  Cursor noMoveHoriz = null;
        private static  Cursor noMoveVert  = null;
        private static  Cursor panEast     = null;
        private static  Cursor panNE       = null;
        private static  Cursor panNorth    = null;
        private static  Cursor panNW       = null;
        private static  Cursor panSE       = null;
        private static  Cursor panSouth    = null;
        private static  Cursor panSW       = null;
        private static  Cursor panWest     = null;
        private static  Cursor hand        = null;

        private Cursors() {
        }

        internal static Cursor KnownCursorFromHCursor( IntPtr handle ) {
            if (handle == IntPtr.Zero) {
                return null;
            }
            else {
                return new Cursor(handle);
            }
            
            // if (handle == Cursors.AppStarting.Handle)   return Cursors.AppStarting;
            // if (handle == Cursors.Arrow.Handle)         return Cursors.Arrow;
            // if (handle == Cursors.IBeam.Handle)         return Cursors.IBeam;
            // if (handle == Cursors.Cross.Handle)         return Cursors.Cross;
            // if (handle == Cursors.Default.Handle)       return Cursors.Default;
            // if (handle == Cursors.No.Handle)            return Cursors.No;
            // if (handle == Cursors.SizeAll.Handle)       return Cursors.SizeAll;
            // if (handle == Cursors.SizeNS.Handle)        return Cursors.SizeNS;
            // if (handle == Cursors.SizeWE.Handle)        return Cursors.SizeWE;
            // if (handle == Cursors.SizeNWSE.Handle)      return Cursors.SizeNWSE;
            // if (handle == Cursors.SizeNESW.Handle)      return Cursors.SizeNESW;
            // if (handle == Cursors.VSplit.Handle)        return Cursors.VSplit;
            // if (handle == Cursors.HSplit.Handle)        return Cursors.HSplit;
            // if (handle == Cursors.WaitCursor.Handle)    return Cursors.WaitCursor;
            // if (handle == Cursors.Help.Handle)          return Cursors.Help;
            // if (handle == IntPtr.Zero)     return null;
            
            //         appStarting = new Cursor(NativeMethods.IDC_APPSTARTING,0);
            //         arrow = new Cursor(NativeMethods.IDC_ARROW,0);
            //         cross = new Cursor(NativeMethods.IDC_CROSS,0);
            //         defaultCursor = new Cursor(NativeMethods.IDC_ARROW,0);
            //         iBeam = new Cursor(NativeMethods.IDC_IBEAM,0);
            //         no = new Cursor(NativeMethods.IDC_NO,0);
            //         sizeAll = new Cursor(NativeMethods.IDC_SIZEALL,0);
            //         sizeNESW = new Cursor(NativeMethods.IDC_SIZENESW,0);
            //         sizeNS      = new Cursor(NativeMethods.IDC_SIZENS,0);
            //         sizeNWSE    = new Cursor(NativeMethods.IDC_SIZENWSE,0);
            //         sizeWE      = new Cursor(NativeMethods.IDC_SIZEWE,0);
            //         upArrow     = new Cursor(NativeMethods.IDC_UPARROW,0);
            //         wait        = new Cursor(NativeMethods.IDC_WAIT,0);
            //         help        = new Cursor(NativeMethods.IDC_HELP,0);
        }
        
        /// <include file='doc\Cursors.uex' path='docs/doc[@for="Cursors.AppStarting"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Cursor AppStarting {
            get {
                if (appStarting == null)
                    appStarting = new Cursor(NativeMethods.IDC_APPSTARTING,0);
                return appStarting;
            }
        }

        /// <include file='doc\Cursors.uex' path='docs/doc[@for="Cursors.Arrow"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Cursor Arrow {
            get {
                if (arrow == null)
                    arrow = new Cursor(NativeMethods.IDC_ARROW,0);
                return arrow;
            }
        }

        /// <include file='doc\Cursors.uex' path='docs/doc[@for="Cursors.Cross"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Cursor Cross {
            get {
                if (cross == null)
                    cross = new Cursor(NativeMethods.IDC_CROSS,0);
                return cross;
            }
        }

        /// <include file='doc\Cursors.uex' path='docs/doc[@for="Cursors.Default"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Cursor Default {
            get {
                if (defaultCursor == null)
                    defaultCursor = new Cursor(NativeMethods.IDC_ARROW,0);
                return defaultCursor;
            }
        }

        /// <include file='doc\Cursors.uex' path='docs/doc[@for="Cursors.IBeam"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Cursor IBeam {
            get {
                if (iBeam == null)
                    iBeam = new Cursor(NativeMethods.IDC_IBEAM,0);
                return iBeam;
            }
        }

        /// <include file='doc\Cursors.uex' path='docs/doc[@for="Cursors.No"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Cursor No {
            get {
                if (no == null)
                    no = new Cursor(NativeMethods.IDC_NO,0);
                return no;
            }
        }

        /// <include file='doc\Cursors.uex' path='docs/doc[@for="Cursors.SizeAll"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Cursor SizeAll {
            get {
                if (sizeAll == null)
                    sizeAll = new Cursor(NativeMethods.IDC_SIZEALL,0);
                return sizeAll;
            }
        }

        /// <include file='doc\Cursors.uex' path='docs/doc[@for="Cursors.SizeNESW"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Cursor SizeNESW {
            get {
                if (sizeNESW == null)
                    sizeNESW = new Cursor(NativeMethods.IDC_SIZENESW,0);
                return sizeNESW;
            }
        }

        /// <include file='doc\Cursors.uex' path='docs/doc[@for="Cursors.SizeNS"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Cursor SizeNS {
            get {
                if (sizeNS == null)
                    sizeNS      = new Cursor(NativeMethods.IDC_SIZENS,0);
                return sizeNS;
            }
        }

        /// <include file='doc\Cursors.uex' path='docs/doc[@for="Cursors.SizeNWSE"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Cursor SizeNWSE {
            get {
                if (sizeNWSE == null)
                    sizeNWSE    = new Cursor(NativeMethods.IDC_SIZENWSE,0);
                return sizeNWSE;
            }
        }

        /// <include file='doc\Cursors.uex' path='docs/doc[@for="Cursors.SizeWE"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Cursor SizeWE {
            get {
                if (sizeWE == null)
                    sizeWE      = new Cursor(NativeMethods.IDC_SIZEWE,0);
                return sizeWE;
            }
        }

        /// <include file='doc\Cursors.uex' path='docs/doc[@for="Cursors.UpArrow"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Cursor UpArrow {
            get {
                if (upArrow == null)
                    upArrow     = new Cursor(NativeMethods.IDC_UPARROW,0);
                return upArrow;
            }
        }

        /// <include file='doc\Cursors.uex' path='docs/doc[@for="Cursors.WaitCursor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Cursor WaitCursor {
            get {
                if (wait == null)
                    wait        = new Cursor(NativeMethods.IDC_WAIT,0);
                return wait;
            }
        }

        /// <include file='doc\Cursors.uex' path='docs/doc[@for="Cursors.Help"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Cursor Help {
            get {
                if (help == null)
                    help        = new Cursor(NativeMethods.IDC_HELP,0);
                return help;
            }
        }

        /// <include file='doc\Cursors.uex' path='docs/doc[@for="Cursors.HSplit"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Cursor HSplit {
            get {
                if (hSplit == null)
                    hSplit      = new Cursor("hsplit.cur", 0);
                return hSplit;
            }
        }

        /// <include file='doc\Cursors.uex' path='docs/doc[@for="Cursors.VSplit"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Cursor VSplit {
            get {
                if (vSplit == null)
                    vSplit      = new Cursor("vsplit.cur", 0);
                return vSplit;
            }
        }

        /// <include file='doc\Cursors.uex' path='docs/doc[@for="Cursors.NoMove2D"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Cursor NoMove2D {
            get {
                if (noMove2D == null)
                    noMove2D    = new Cursor("nomove2d.cur", 0);
                return noMove2D;
            }
        }

        /// <include file='doc\Cursors.uex' path='docs/doc[@for="Cursors.NoMoveHoriz"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Cursor NoMoveHoriz {
            get {
                if (noMoveHoriz == null)
                    noMoveHoriz = new Cursor("nomoveh.cur", 0);
                return noMoveHoriz;
            }
        }

        /// <include file='doc\Cursors.uex' path='docs/doc[@for="Cursors.NoMoveVert"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Cursor NoMoveVert {
            get {
                if (noMoveVert == null)
                    noMoveVert  = new Cursor("nomovev.cur", 0);
                return noMoveVert;
            }
        }

        /// <include file='doc\Cursors.uex' path='docs/doc[@for="Cursors.PanEast"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Cursor PanEast {
            get {
                if (panEast == null)
                    panEast     = new Cursor("east.cur", 0);
                return panEast;
            }
        }

        /// <include file='doc\Cursors.uex' path='docs/doc[@for="Cursors.PanNE"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Cursor PanNE {
            get {
                if (panNE == null)
                    panNE       = new Cursor("ne.cur", 0);
                return panNE;
            }
        }

        /// <include file='doc\Cursors.uex' path='docs/doc[@for="Cursors.PanNorth"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Cursor PanNorth {
            get {
                if (panNorth == null)
                    panNorth    = new Cursor("north.cur", 0);
                return panNorth;
            }
        }

        /// <include file='doc\Cursors.uex' path='docs/doc[@for="Cursors.PanNW"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Cursor PanNW {
            get {
                if (panNW == null)
                    panNW       = new Cursor("nw.cur", 0);
                return panNW;
            }
        }

        /// <include file='doc\Cursors.uex' path='docs/doc[@for="Cursors.PanSE"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Cursor PanSE {
            get {
                if (panSE == null)
                    panSE       = new Cursor("se.cur", 0);
                return panSE;
            }
        }

        /// <include file='doc\Cursors.uex' path='docs/doc[@for="Cursors.PanSouth"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Cursor PanSouth {
            get {
                if (panSouth == null)
                    panSouth    = new Cursor("south.cur", 0);
                return panSouth;
            }
        }

        /// <include file='doc\Cursors.uex' path='docs/doc[@for="Cursors.PanSW"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Cursor PanSW {
            get {
                if (panSW == null)
                    panSW       = new Cursor("sw.cur", 0);
                return panSW;
            }
        }

        /// <include file='doc\Cursors.uex' path='docs/doc[@for="Cursors.PanWest"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Cursor PanWest {
            get {
                if (panWest == null)
                    panWest     = new Cursor("west.cur", 0);
                return panWest;
            }
        }

        /// <include file='doc\Cursors.uex' path='docs/doc[@for="Cursors.Hand"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Cursor Hand {
            get {
                if (hand == null)
                    hand        = new Cursor("hand.cur", 0);
                return hand;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\datagrid.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGrid.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    using System.Text;
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.ComponentModel;
    using System.Security;
    using System.Security.Permissions;
    using System;
    using System.Collections;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;    
    using System.ComponentModel.Design;
    using System.Drawing;
    
    using Microsoft.Win32;
    using System.Windows.Forms.ComponentModel;
    using System.Diagnostics;

    /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid"]/*' />
    /// <devdoc>
    ///    <para>Displays ADO.NET data in a scrollable
    ///       grid.</para>
    /// </devdoc>
    [
    Designer("System.Windows.Forms.Design.DataGridDesigner, " + AssemblyRef.SystemDesign),
    DefaultProperty("DataSource"),
    DefaultEvent("Navigate"),
    ]
    public class DataGrid : Control, ISupportInitialize, IDataGridEditingService {
#if DEBUG
        internal TraceSwitch DataGridAcc = new TraceSwitch("DataGridAcc", "Trace Windows Forms DataGrid Accessibility");
#else
        internal TraceSwitch DataGridAcc = null;
#endif    

        private const int               GRIDSTATE_allowSorting                  = 0x00000001;
        private const int               GRIDSTATE_columnHeadersVisible          = 0x00000002;
        private const int               GRIDSTATE_rowHeadersVisible             = 0x00000004;
        private const int               GRIDSTATE_trackColResize                = 0x00000008;
        private const int               GRIDSTATE_trackRowResize                = 0x00000010;
        private const int               GRIDSTATE_isLedgerStyle                 = 0x00000020;
        private const int               GRIDSTATE_isFlatMode                    = 0x00000040;
        private const int               GRIDSTATE_listHasErrors                 = 0x00000080;
        private const int               GRIDSTATE_dragging                      = 0x00000100;
        private const int               GRIDSTATE_inListAddNew                  = 0x00000200;
        private const int               GRIDSTATE_inDeleteRow                   = 0x00000400;
        private const int               GRIDSTATE_canFocus                      = 0x00000800;
        private const int               GRIDSTATE_readOnlyMode                  = 0x00001000;
        private const int               GRIDSTATE_allowNavigation               = 0x00002000;
        private const int               GRIDSTATE_isNavigating                  = 0x00004000;
        private const int               GRIDSTATE_isEditing                     = 0x00008000;
        private const int               GRIDSTATE_editControlChanging           = 0x00010000;
        private const int               GRIDSTATE_isScrolling                   = 0x00020000;
        private const int               GRIDSTATE_overCaption                   = 0x00040000;
        private const int               GRIDSTATE_childLinkFocused              = 0x00080000;
        private const int               GRIDSTATE_inAddNewRow                   = 0x00100000;
        private const int               GRIDSTATE_inSetListManager              = 0x00200000;
        private const int               GRIDSTATE_metaDataChanged               = 0x00400000;
        private const int               GRIDSTATE_exceptionInPaint              = 0x00800000;

        // PERF: take all the bools and put them into a state variable
        private System.Collections.Specialized.BitVector32 gridState;                  // see GRIDSTATE_ consts above

        // for column widths
        private const int NumRowsForAutoResize = 10;

        private const int       errorRowBitmapWidth         = 15;

        private const  DataGridParentRowsLabelStyle    defaultParentRowsLabelStyle  = DataGridParentRowsLabelStyle.Both;

        private const BorderStyle defaultBorderStyle    = BorderStyle.Fixed3D;

        private const bool defaultCaptionVisible = true;

        private const bool defaultParentRowsVisible = true;

        private DataGridTableStyle defaultTableStyle = new DataGridTableStyle(true);

        // private bool allowSorting = true;

        private SolidBrush alternatingBackBrush = DefaultAlternatingBackBrush;

        // private bool columnHeadersVisible = true;

        private SolidBrush gridLineBrush = DefaultGridLineBrush;

        private const DataGridLineStyle defaultGridLineStyle = DataGridLineStyle.Solid;
        private DataGridLineStyle gridLineStyle = defaultGridLineStyle;

        private SolidBrush headerBackBrush = DefaultHeaderBackBrush;

        private Font headerFont = null; // this is ambient property to Font value

        private SolidBrush headerForeBrush = DefaultHeaderForeBrush;
        private Pen headerForePen = DefaultHeaderForePen;

        private SolidBrush linkBrush = DefaultLinkBrush;

        private const int defaultPreferredColumnWidth = 75;
        private int preferredColumnWidth = defaultPreferredColumnWidth;

        private static int defaultFontHeight = Control.DefaultFont.Height;
        private int prefferedRowHeight = defaultFontHeight + 3;

        // private bool rowHeadersVisible = true;
        private const int defaultRowHeaderWidth = 35;
        private int rowHeaderWidth = defaultRowHeaderWidth;
        private int minRowHeaderWidth;

        private SolidBrush selectionBackBrush = DefaultSelectionBackBrush;
        private SolidBrush selectionForeBrush = DefaultSelectionForeBrush;

        // parent rows
        //
        private DataGridParentRows    parentRows = null;
        // Set_ListManager uses the originalState to determine
        // if the grid should disconnect from all the MetaDataChangedEvents
        // keep "originalState != null" when navigating back and forth in the grid
        // and use Add/RemoveMetaDataChanged methods.
        private DataGridState         originalState = null;

        // ui state
        //
        // Don't use dataGridRows, use the accessor!!!
        private DataGridRow[]        dataGridRows     = new DataGridRow[0];
        private int                  dataGridRowsLength = 0;

        // for toolTip
        private int toolTipId = 0;
        private DataGridToolTip toolTipProvider = null;

        private  DataGridAddNewRow    addNewRow        = null;
        private LayoutData            layout           = new LayoutData();
        private  NativeMethods.RECT[]               cachedScrollableRegion = null;

        // header namespace goo
        //

        // these are actually get/set by ColumnBehavior
        internal bool           allowColumnResize  = true;

        internal bool allowRowResize = true;

        internal DataGridParentRowsLabelStyle parentRowsLabels     = defaultParentRowsLabelStyle;

        // information for col/row resizing
        // private bool       trackColResize         = false;
        private int        trackColAnchor         = 0;
        private int        trackColumn         = 0;
        // private bool       trackRowResize         = false;
        private int        trackRowAnchor         = 0;
        private int        trackRow            = 0;
        private PropertyDescriptor         trackColumnHeader   = null;
        private MouseEventArgs lastSplitBar        = null;

        // private bool isLedgerStyle = true;
        // private bool isFlatMode    = false;
        private Font              linkFont             = null;

        private SolidBrush        backBrush            = DefaultBackBrush;
        private SolidBrush        foreBrush            = DefaultForeBrush;
        private SolidBrush        backgroundBrush      = DefaultBackgroundBrush;

        // font cacheing info
        private int               fontHeight           = -1;
        private int               linkFontHeight       = -1;
        private int               captionFontHeight    = -1;
        private int               headerFontHeight     = -1;

        // the preffered height of the row.

        // if the list has items with errors
        // private bool listHasErrors = false;

        // caption
        private DataGridCaption caption;

        // Border
        //
        private BorderStyle borderStyle;

        // data binding
        //
        private object dataSource = null;
        private string dataMember = "";
        private CurrencyManager listManager = null;

        // persistent data state
        //
        internal GridTableStylesCollection dataGridTables = null;
        // SET myGridTable in SetDataGridTable ONLY
        internal DataGridTableStyle myGridTable = null;
        internal bool checkHierarchy = true;
        internal bool inInit = false;

        // Selection
        internal int  currentRow = 0;
        internal int  currentCol = 0;
        private  int  numSelectedRows = 0;
        private  int lastRowSelected = -1;

        // dragging:
        // private bool dragging = false;

        // addNewRow
        // private bool inAddNewRow = false;
        // delete Row
        // private bool inDeleteRow = false;

        // when we leave, we call CommitEdit
        // if we leave, then do not focus the dataGrid.
        // so we can't focus the grid at the following moments:
        // 1. while processing the OnLayout event
        // 2. while processing the OnLeave event
        // private bool canFocus = true;

        // for CurrentCell
#if DEBUG
        private bool inDataSource_PositionChanged = false;
        private bool inCurrentCellChange = false;
#endif // DEBUG

        // Policy
        // private bool   readOnlyMode = false;
        private Policy policy = new Policy();
        // private bool allowNavigation = true;

        // editing
        // private bool isNavigating = false;
        // private bool isEditing = false;
        // private bool editControlChanging = false;
        private DataGridColumnStyle  editColumn = null;
        private DataGridRow     editRow = null;

        // scrolling
        //
        private ScrollBar horizScrollBar  = new HScrollBar();
        private ScrollBar vertScrollBar   = new VScrollBar();

        // the sum of the widths of the columns preceding the firstVisibleColumn
        //
        private int       horizontalOffset = 0;

        // the number of pixels of the firstVisibleColumn which are not visible
        //
        private int       negOffset = 0;

        private int       wheelDelta = 0;
        // private bool      isScrolling = false;

        // Visibility
        //
        internal int firstVisibleRow       = 0;
        internal int firstVisibleCol       = 0;
        private  int numVisibleRows        = 0;
        // the number of columns which are visible
        private  int numVisibleCols        = 0;
        private  int numTotallyVisibleRows = 0;
        private  int lastTotallyVisibleCol = 0;

        // mouse move hot-tracking
        //
        private int oldRow = -1;
        // private bool overCaption = true;

        // child relationships focused
        //
        // private bool childLinkFocused = false;

        // private static readonly object EVENT_COLUMNHEADERCLICK = new object();
        private static readonly object EVENT_CURRENTCELLCHANGED = new object();
        // private static readonly object EVENT_COLUMNRESIZE = new object();
        // private static readonly object EVENT_LINKCLICKED = new object();
        private static readonly object EVENT_NODECLICKED = new object();
        // private static readonly object EVENT_ROWRESIZE = new object();
        private static readonly object EVENT_SCROLL = new object();
        private static readonly object EVENT_BACKBUTTONCLICK = new object();
        private static readonly object EVENT_DOWNBUTTONCLICK = new object();


        // event handlers
        //
        private ItemChangedEventHandler itemChangedHandler;
        private EventHandler positionChangedHandler;
        private EventHandler currentChangedHandler;
        private EventHandler metaDataChangedHandler;

        // we have to know when the collection of dataGridTableStyles changes
        private CollectionChangeEventHandler dataGridTableStylesCollectionChanged;

        private EventHandler backButtonHandler;
        private EventHandler downButtonHandler;

        private NavigateEventHandler onNavigate;

        private EventHandler onRowHeaderClick;

        // forDebug
        //
        // private int forDebug = 0;

        // =-----------------------------------------------------------------


        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.DataGrid"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Windows.Forms.DataGrid'/>
        /// class.</para>
        /// </devdoc>
        public DataGrid() : base() {
            SetStyle(ControlStyles.UserPaint, true);
            SetStyle(ControlStyles.Opaque, false);
            SetStyle(ControlStyles.SupportsTransparentBackColor, false);
            SetStyle(ControlStyles.UserMouse, true);

            this.gridState = new System.Collections.Specialized.BitVector32(0x00042827);

            dataGridTables = new GridTableStylesCollection(this);
            layout = CreateInitialLayoutState();
            parentRows = new DataGridParentRows(this);

            horizScrollBar.Top = ClientRectangle.Height - horizScrollBar.Height;
            horizScrollBar.Left = 0;
            horizScrollBar.Visible = false;
            horizScrollBar.Scroll += new ScrollEventHandler(GridHScrolled);
            Controls.Add(horizScrollBar);

            vertScrollBar.Top = 0;
            vertScrollBar.Left = ClientRectangle.Width - vertScrollBar.Width;
            vertScrollBar.Visible = false;
            vertScrollBar.Scroll += new ScrollEventHandler(GridVScrolled);
            Controls.Add(vertScrollBar);

            BackColor = DefaultBackBrush.Color;
            ForeColor = DefaultForeBrush.Color;
            BorderStyle = defaultBorderStyle;

            // create the event handlers
            //
            currentChangedHandler  = new EventHandler(DataSource_RowChanged);
            positionChangedHandler = new EventHandler(DataSource_PositionChanged);
            itemChangedHandler     = new ItemChangedEventHandler(DataSource_ItemChanged);
            metaDataChangedHandler = new EventHandler(DataSource_MetaDataChanged);
            dataGridTableStylesCollectionChanged = new CollectionChangeEventHandler(TableStylesCollectionChanged);
            this.dataGridTables.CollectionChanged += dataGridTableStylesCollectionChanged;

            SetDataGridTable(this.defaultTableStyle, true);

            backButtonHandler        = new EventHandler(OnBackButtonClicked);
            downButtonHandler        = new EventHandler(OnShowParentDetailsButtonClicked);

            caption = new DataGridCaption(this);
            caption.BackwardClicked += backButtonHandler;
            caption.DownClicked += downButtonHandler;

            RecalculateFonts();
            Size = new Size(130, 80);
            Invalidate();
            PerformLayout();
        }

        // =------------------------------------------------------------------
        // =        Properties
        // =------------------------------------------------------------------

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.AllowSorting"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value indicating whether the grid can be resorted by clicking on
        ///       a column header.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(true),
        SRDescription(SR.DataGridAllowSortingDescr)
        ]
        public bool AllowSorting {
            get {
                return gridState[GRIDSTATE_allowSorting];
            }
            set {
                if (AllowSorting != value) {
                    gridState[GRIDSTATE_allowSorting] = value;
                    if (!value && this.listManager != null) {
                        IList list = this.listManager.List;
                        if (list is IBindingList)
                            ((IBindingList) list).RemoveSort();
                    }
                }
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.AlternatingBackColor"]/*' />
        [
         SRCategory(SR.CatColors),
         SRDescription(SR.DataGridAlternatingBackColorDescr)
        ]
        public Color AlternatingBackColor {
            get {
                return alternatingBackBrush.Color;
            }
            set {
                if (value.IsEmpty) {
                    throw new ArgumentException(SR.GetString(SR.DataGridEmptyColor,
                                                              "AlternatingBackColor"));
                }
                if (IsTransparentColor(value))
                    throw new ArgumentException(SR.GetString(SR.DataGridTransparentAlternatingBackColorNotAllowed));
                if (!alternatingBackBrush.Color.Equals(value)) {
                    alternatingBackBrush = new SolidBrush(value);
                    InvalidateInside();
                }
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ResetAlternatingBackColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ResetAlternatingBackColor() {
            if (ShouldSerializeAlternatingBackColor()) {
                AlternatingBackColor = DefaultAlternatingBackBrush.Color;
                InvalidateInside();
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ShouldSerializeAlternatingBackColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual bool ShouldSerializeAlternatingBackColor()
        {
            return !AlternatingBackBrush.Equals(DefaultAlternatingBackBrush);
        }

        internal Brush AlternatingBackBrush {
            get {
                return alternatingBackBrush;
            }
        }

        // overrode those properties just to move the BackColor and the ForeColor 
        // from the Appearance group onto the Color Group
        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.BackColor"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the background color of the grid.</para>
        /// </devdoc>
        [
         SRCategory(SR.CatColors),
         SRDescription(SR.ControlBackColorDescr)
        ]
        public override Color BackColor {
            // overrode those properties just to move the BackColor and the ForeColor 
            // from the Appearance group onto the Color Group
            get {
                return base.BackColor;
            }
            set {
                if (IsTransparentColor(value))
                    throw new ArgumentException(SR.GetString(SR.DataGridTransparentBackColorNotAllowed));
                base.BackColor = value;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ResetBackColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void ResetBackColor() {
            if (!this.BackColor.Equals(DefaultBackBrush.Color)) {
                this.BackColor = DefaultBackBrush.Color;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ForeColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
         SRCategory(SR.CatColors),
         SRDescription(SR.ControlForeColorDescr)
        ]
        public override Color ForeColor {
            get {
                return base.ForeColor;
            }
            set {
                base.ForeColor = value;
            }
        }
        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ResetForeColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void ResetForeColor() {
            if (!this.ForeColor.Equals(DefaultForeBrush.Color)) {
                this.ForeColor = DefaultForeBrush.Color;
            }
        }

        /// <devdoc>
        ///    <para>
        ///       Gets a value
        ///       indicating whether the <see cref='System.Windows.Forms.DataGrid.AlternatingBackColor'/> property should be
        ///       persisted.
        ///    </para>
        /// </devdoc>
        internal SolidBrush BackBrush {
            get {
                return backBrush;
            }
        }

        internal SolidBrush ForeBrush {
            get {
                return foreBrush;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.BorderStyle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or
        ///       sets the border style.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DefaultValue(defaultBorderStyle),
        DispId(NativeMethods.ActiveX.DISPID_BORDERSTYLE),
        SRDescription(SR.DataGridBorderStyleDescr)
        ]
        public BorderStyle BorderStyle {
            get {
                return borderStyle;
            }
            set {
                if (!Enum.IsDefined(typeof(BorderStyle), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(BorderStyle));
                }
                if (borderStyle != value) {
                    borderStyle = value;
                    PerformLayout();
                    Invalidate();
                    OnBorderStyleChanged(EventArgs.Empty);
                }
            }
        }

        private static readonly object EVENT_BORDERSTYLECHANGED = new object();

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.BorderStyleChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.DataGridOnBorderStyleChangedDescr)]
        public event EventHandler BorderStyleChanged {
            add {
                Events.AddHandler(EVENT_BORDERSTYLECHANGED, value);
            }
            remove {
                Events.RemoveHandler(EVENT_BORDERSTYLECHANGED, value);
            }
        }

        private int BorderWidth {
            get {
                if (BorderStyle == BorderStyle.Fixed3D) {
                    return SystemInformation.Border3DSize.Width;
                }
                else if (BorderStyle == BorderStyle.FixedSingle) {
                    return 2;
                }
                else {
                    return 0;
                }
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.DefaultSize"]/*' />
        protected override Size DefaultSize {
            get {
                return new Size(130, 80);
            }
        }

        private static SolidBrush DefaultSelectionBackBrush {
            get {
                return (SolidBrush)SystemBrushes.ActiveCaption;
            }
        }
        private static SolidBrush DefaultSelectionForeBrush {
            get {
                return (SolidBrush)SystemBrushes.ActiveCaptionText;
            }
        }
        internal static SolidBrush DefaultBackBrush {
            get {
                return (SolidBrush)SystemBrushes.Window;
            }
        }
        internal static SolidBrush DefaultForeBrush {
            get {
                return (SolidBrush)SystemBrushes.WindowText;
            }
        }
        private static SolidBrush DefaultBackgroundBrush {
            get {
                return (SolidBrush)SystemBrushes.AppWorkspace;
            }
        }
        internal static SolidBrush DefaultParentRowsForeBrush {
            get {
                return (SolidBrush)SystemBrushes.WindowText;
            }
        }
        internal static SolidBrush DefaultParentRowsBackBrush {
            get {
                return (SolidBrush)SystemBrushes.Control;
            }
        }
        internal static SolidBrush DefaultAlternatingBackBrush {
            get {
                return (SolidBrush)SystemBrushes.Window;
            }
        }
        private static SolidBrush DefaultGridLineBrush {
            get {
                return (SolidBrush)SystemBrushes.Control;
            }
        }
        private static SolidBrush DefaultHeaderBackBrush {
            get {
                return (SolidBrush)SystemBrushes.Control;
            }
        }
        private static SolidBrush DefaultHeaderForeBrush {
            get {
                return (SolidBrush)SystemBrushes.ControlText;
            }
        }
        private static Pen DefaultHeaderForePen {
            get {
                 return new Pen(SystemColors.ControlText);
            }
        }
        private static SolidBrush DefaultLinkBrush {
            get {
                return (SolidBrush)SystemBrushes.HotTrack;
            }
        }

        private bool ListHasErrors {
            get {
                return gridState[GRIDSTATE_listHasErrors];
            }
            set {
                if (ListHasErrors != value)
                {
                    gridState[GRIDSTATE_listHasErrors] = value;
                    ComputeMinimumRowHeaderWidth();
                    if (!layout.RowHeadersVisible)
                        return;
                    if (value) {
                        if (myGridTable.IsDefault)
                            this.RowHeaderWidth += errorRowBitmapWidth;
                        else
                            this.myGridTable.RowHeaderWidth += errorRowBitmapWidth;
                    }
                    else {
                        if (myGridTable.IsDefault)
                            this.RowHeaderWidth -= errorRowBitmapWidth;
                        else
                            this.myGridTable.RowHeaderWidth -= errorRowBitmapWidth;
                    }
                }
            }
        }

        private bool Bound {
            get {
                return !(listManager == null || myGridTable == null);
            }
        }

        internal DataGridCaption Caption {
            get {
                return caption;
            }
        }


        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.CaptionBackColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the background color of the caption area.
        ///    </para>
        /// </devdoc>
        [
         SRCategory(SR.CatColors),
         SRDescription(SR.DataGridCaptionBackColorDescr)
        ]
        public Color CaptionBackColor {
            get {
                return Caption.BackColor;
            }
            set {
                if (IsTransparentColor(value))
                    throw new ArgumentException(SR.GetString(SR.DataGridTransparentCaptionBackColorNotAllowed));
                Caption.BackColor = value;
            }
        }

        private void ResetCaptionBackColor() {
            Caption.ResetBackColor();
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ShouldSerializeCaptionBackColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value
        ///       indicating whether the <see cref='System.Windows.Forms.DataGrid.CaptionBackColor'/> property should be
        ///       persisted.
        ///    </para>
        /// </devdoc>
        protected virtual bool ShouldSerializeCaptionBackColor()
        {
            return Caption.ShouldSerializeBackColor();
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.CaptionForeColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       or sets the foreground color
        ///       of the caption area.
        ///    </para>
        /// </devdoc>
        [
         SRCategory(SR.CatColors),
         SRDescription(SR.DataGridCaptionForeColorDescr)
        ]
        public Color CaptionForeColor {
            get {
                return Caption.ForeColor;
            }
            set {
                Caption.ForeColor = value;
            }
        }

        private void ResetCaptionForeColor() {
            Caption.ResetForeColor();
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ShouldSerializeCaptionForeColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value
        ///       indicating whether the <see cref='System.Windows.Forms.DataGrid.CaptionForeColor'/> property should be
        ///       persisted.
        ///    </para>
        /// </devdoc>
        protected virtual bool ShouldSerializeCaptionForeColor()
        {
            return Caption.ShouldSerializeForeColor();
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.CaptionFont"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the font of the grid's caption.
        ///    </para>
        /// </devdoc>
        [
         SRCategory(SR.CatAppearance),
         Localizable(true),
         AmbientValue(null),
         SRDescription(SR.DataGridCaptionFontDescr)
        ]
        public Font CaptionFont {
            get {
                return Caption.Font;
            }
            set {
                Caption.Font = value;
            }
        }

        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the
        ///       caption's font is persisted.
        ///    </para>
        /// </devdoc>
        private bool ShouldSerializeCaptionFont() {
            return Caption.ShouldSerializeFont();
        }

        private void ResetCaptionFont() {
            Caption.ResetFont();
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.CaptionText"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the text of the grid's caption.
        ///    </para>
        /// </devdoc>
        [
         SRCategory(SR.CatAppearance),
         DefaultValue(""),
         Localizable(true),
         SRDescription(SR.DataGridCaptionTextDescr)
        ]
        public string CaptionText {
            get {
                return Caption.Text;
            }
            set {
                Caption.Text = value;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.CaptionVisible"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value that indicates
        ///       whether the grid's caption is visible.
        ///    </para>
        /// </devdoc>
        [
         DefaultValue(true),
         SRCategory(SR.CatDisplay),
         SRDescription(SR.DataGridCaptionVisibleDescr)        
        ]
        public bool CaptionVisible {
            get {
                return layout.CaptionVisible;
            }
            set {
                if (layout.CaptionVisible != value) {
                    layout.CaptionVisible = value;
                    PerformLayout();
                    Invalidate();
                    OnCaptionVisibleChanged(EventArgs.Empty);
                }
            }
        }

        private static readonly object EVENT_CAPTIONVISIBLECHANGED = new object();

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.CaptionVisibleChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.DataGridOnCaptionVisibleChangedDescr)]
        public event EventHandler CaptionVisibleChanged {
            add {
                Events.AddHandler(EVENT_CAPTIONVISIBLECHANGED, value);
            }
            remove {
                Events.RemoveHandler(EVENT_CAPTIONVISIBLECHANGED, value);
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.CurrentCell"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets which cell has the focus. Not available at design time.
        ///    </para>
        /// </devdoc>
        [
         Browsable(false),
         DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
         SRDescription(SR.DataGridCurrentCellDescr)
        ]
        public DataGridCell CurrentCell {
            get {
                return new DataGridCell(currentRow, currentCol);
            }
            set {
                // if the OnLayout event was not set in the grid, then we can't
                // reliably set the currentCell on the grid.
                if (layout.dirty)
                    throw new Exception(SR.GetString(SR.DataGridSettingCurrentCellNotGood));
                if (value.RowNumber == currentRow && value.ColumnNumber == currentCol)
                    return;

                // should we throw an exception, maybe?
                if (DataGridRowsLength == 0 || this.myGridTable.GridColumnStyles == null || this.myGridTable.GridColumnStyles.Count == 0)
                    return;
                EnsureBound();

                int currentRowSaved = currentRow;
                int currentColSaved = currentCol;
                bool wasEditing = gridState[GRIDSTATE_isEditing];
                bool cellChanged = false;

                // if the position in the listManager changed under the DataGrid, 
                // then do not edit after setting the current cell
                bool doNotEdit = false;

                int newCol = value.ColumnNumber;
                int newRow = value.RowNumber;

                try {
                    int columnCount = myGridTable.GridColumnStyles.Count;
                    if (newCol < 0)
                        newCol = 0;
                    if (newCol >= columnCount)
                        newCol = columnCount - 1;

                    int localGridRowsLength = DataGridRowsLength;
                    DataGridRow[] localGridRows = DataGridRows;

                    if (newRow < 0) {
                        newRow = 0;
                    }
                    if (newRow >= localGridRowsLength) {
                        newRow = localGridRowsLength - 1;
                    }

                    // Current Column changing
                    //
                    if (currentCol != newCol) {
                        cellChanged = true;
                        EndEdit();

                        currentCol = newCol;
                        InvalidateRow(currentRow);
                    }

                    // Current Row changing
                    //
                    if (currentRow != newRow) {
                        cellChanged = true;
                        EndEdit();

                        if (currentRow < localGridRowsLength)
                            localGridRows[currentRow].OnRowLeave();
                        localGridRows[newRow].OnRowEnter();
                        currentRow = newRow;
                        if (currentRowSaved < localGridRowsLength)
                            InvalidateRow(currentRowSaved);
                        InvalidateRow(currentRow);

                        if (currentRowSaved != listManager.Position) {
                            // not in sync
#if DEBUG
                            Debug.Assert(inDataSource_PositionChanged, "currentRow and listManager.Position can be out of sync only when the listManager changes its position under the DataGrid or when navigating back");
                            Debug.Assert(ListManager.Position == currentRow || listManager.Position == -1, "DataSource_PositionChanged changes the position in the grid to the position in the listManager");
#endif //DEBUG
                            doNotEdit = true;
                            if (gridState[GRIDSTATE_isEditing])
                                AbortEdit();
                        } else if (gridState[GRIDSTATE_inAddNewRow]) {
#if DEBUG
                            int currentRowCount = this.DataGridRowsLength;
#endif // debug
                            // cancelCurrentEdit will change the position in the list 
                            // to the last element in the list. and the grid will get an on position changed
                            // event, and will set the current cell to the last element in the dataSource.
                            // so unhook the PositionChanged event from the listManager;
                            this.ListManager.PositionChanged -= positionChangedHandler;
                            this.ListManager.CancelCurrentEdit();
                            this.ListManager.Position = this.currentRow;
                            this.ListManager.PositionChanged += positionChangedHandler;
#if DEBUG

                            Debug.Assert(currentRowSaved > currentRow, "we can only go up when we are inAddNewRow");
                            Debug.Assert(currentRowCount == this.DataGridRowsLength, "the number of rows in the dataGrid should not change");
                            Debug.Assert(currentRowCount == this.ListManager.Count + 1, "the listManager should have one less record");
#endif // debug
                            localGridRows[DataGridRowsLength - 1] = new DataGridAddNewRow(this, this.myGridTable, DataGridRowsLength-1);
                            SetDataGridRows(localGridRows, DataGridRowsLength);
                            gridState[GRIDSTATE_inAddNewRow] = false;
                        } else {
                            ListManager.EndCurrentEdit();
                            // some special care must be given when setting the
                            // position in the listManager.
                            // if EndCurrentEdit() deleted the current row
                            //  ( because of some filtering problem, say )
                            // then we cannot go over the last row
                            //
                            if (localGridRowsLength != DataGridRowsLength)
                            {
                                Debug.Assert(localGridRowsLength == DataGridRowsLength + 1, "this is the only change that could have happened");
                                currentRow = (currentRow == localGridRowsLength - 1) ? DataGridRowsLength - 1 : currentRow;
                            }

                            if (currentRow == dataGridRowsLength - 1 && policy.AllowAdd) {
                                // it may be case ( see previous comment )
                                // that listManager.EndCurrentEdit changed the number of rows
                                // in the grid. in this case, we should not be using the old
                                // localGridRows in our assertion, cause they are outdated now
                                //
                                Debug.Assert(this.DataGridRows[currentRow] is DataGridAddNewRow, "the last row is the DataGridAddNewRow");
                                this.AddNewRow();
                                Debug.Assert(ListManager.Position == currentRow || listManager.Position == -1, "the listManager should be positioned at the last row");
                            } else {

#if DEBUG
                                inCurrentCellChange = true;
#endif // DEBUG
                                ListManager.Position = currentRow;
#if DEBUG
                                inCurrentCellChange = false;
#endif // DEBUG
                            }
                        }

                    }

                }
                catch (Exception e) {
                    DialogResult result = MessageBox.Show(SR.GetString(SR.DataGridPushedIncorrectValueIntoColumn, e.Message), SR.GetString(SR.DataGridErrorMessageBoxCaption), MessageBoxButtons.YesNo);
                    if (result == DialogResult.Yes) {
                        currentRow = currentRowSaved;
                        currentCol = currentColSaved;
                        Debug.Assert(currentRow == ListManager.Position || listManager.Position == -1, "the position in the list manager (" + ListManager.Position + ") is out of sync with the currentRow (" + currentRow + ")" + " and the exception is " + e.ToString());
                        // this will make sure the newRow will not paint the
                        // row selector.
                        InvalidateRowHeader(newRow);
                        // also, make sure that we get the row selector on the currentrow, too
                        InvalidateRowHeader(currentRow);
                        if (wasEditing)
                            Edit();
                    } else {
                        // if the user committed a row that used to be addNewRow and the backEnd rejects it, 
                        // and then it tries to navigate down then we should stay in the addNewRow
                        // in this particular scenario, CancelCurrentEdit will cause the last row to be deleted,
                        // and this will ultimately call InvalidateRow w/ a row number larger than the number of rows
                        // so set the currentRow here:
                        if (currentRow == this.DataGridRowsLength - 1 && currentRowSaved == this.DataGridRowsLength - 2 && DataGridRows[currentRow] is DataGridAddNewRow)
                            newRow = currentRowSaved;
                        currentRow = newRow;
                        Debug.Assert(result == DialogResult.No, "we only put cancel and ok on the error message box");
                        this.listManager.PositionChanged -= positionChangedHandler;
                        this.listManager.CancelCurrentEdit();
                        this.listManager.Position = newRow;
                        this.listManager.PositionChanged += positionChangedHandler;
                        currentRow = newRow;
                        currentCol = newCol;
                        if (wasEditing)
                            Edit();
                    }
                }
                
                if (cellChanged) {
                    EnsureVisible(currentRow, currentCol);
                    OnCurrentCellChanged(EventArgs.Empty);

                    // if the user changed the current cell using the UI, edit the new cell
                    // but if the user changed the current cell by changing the position in the
                    // listManager, then do not continue the edit
                    //
                    if (!doNotEdit)
                    {
#if DEBUG
                        Debug.Assert(!inDataSource_PositionChanged, "if the user changed the current cell using the UI, then do not edit");
#endif // debug
                        Edit();
                    }
                    else {
                        AccessibilityNotifyClients(AccessibleEvents.Focus, myGridTable.GridColumnStyles.Count + currentRow);
                        AccessibilityNotifyClients(AccessibleEvents.Selection, myGridTable.GridColumnStyles.Count + currentRow); 
                    }
                }

                Debug.Assert(currentRow == ListManager.Position || listManager.Position == -1, "the position in the list manager is out of sync with the currentRow");
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.CurrentCellChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.DataGridOnCurrentCellChangedDescr)]
        public event EventHandler CurrentCellChanged {
            add {
                Events.AddHandler(EVENT_CURRENTCELLCHANGED, value);
            }
            remove {
                Events.RemoveHandler(EVENT_CURRENTCELLCHANGED, value);
            }
        }

        private int CurrentColumn {
            get {
                return CurrentCell.ColumnNumber;
            }
            set {
                this.CurrentCell = new DataGridCell(currentRow, value);
            }
        }

        private int CurrentRow {
            get {
                return CurrentCell.RowNumber;
            }
            set {
                CurrentCell = new DataGridCell(value, currentCol);
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.SelectionBackColor"]/*' />
        [
         SRCategory(SR.CatColors),
         SRDescription(SR.DataGridSelectionBackColorDescr)
        ]
        public Color SelectionBackColor {
            get {
                return selectionBackBrush.Color;
            }
            set {
                if (value.IsEmpty)
                    throw new ArgumentException(SR.GetString(SR.DataGridEmptyColor, "SelectionBackColor"));
                if (IsTransparentColor(value))
                    throw new ArgumentException(SR.GetString(SR.DataGridTransparentSelectionBackColorNotAllowed));
                if (!value.Equals(selectionBackBrush.Color)) {
                    selectionBackBrush = new SolidBrush(value);

                    InvalidateInside();
                }
            }
        }

        internal SolidBrush SelectionBackBrush {
            get {
                return this.selectionBackBrush;
            }
        }

        internal SolidBrush SelectionForeBrush {
            get {
                return this.selectionForeBrush;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ShouldSerializeSelectionBackColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected bool ShouldSerializeSelectionBackColor()
        {
            return !DefaultSelectionBackBrush.Equals(selectionBackBrush);
        }
        
        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ResetSelectionBackColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ResetSelectionBackColor() {
            if (ShouldSerializeSelectionBackColor())
                SelectionBackColor = DefaultSelectionBackBrush.Color;
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.SelectionForeColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
         SRCategory(SR.CatColors),
         SRDescription(SR.DataGridSelectionForeColorDescr)        
        ]
        public Color SelectionForeColor {
            get {
                return selectionForeBrush.Color;
            }
            set {
                if (value.IsEmpty)
                    throw new ArgumentException(SR.GetString(SR.DataGridEmptyColor, "SelectionForeColor"));
                if (!value.Equals(selectionForeBrush.Color)) {
                    selectionForeBrush = new SolidBrush(value);

                    InvalidateInside();
                }
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ShouldSerializeSelectionForeColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual bool ShouldSerializeSelectionForeColor()
        {
            return !SelectionForeBrush.Equals(DefaultSelectionForeBrush);
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ResetSelectionForeColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ResetSelectionForeColor() {
            if (ShouldSerializeSelectionForeColor())
                SelectionForeColor = DefaultSelectionForeBrush.Color;
        }

        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        internal override bool ShouldSerializeForeColor()
        {
            return !DefaultForeBrush.Color.Equals(this.ForeColor);
        }

        /// <devdoc>
        /// <para>Indicates whether the <see cref='System.Windows.Forms.DataGrid.BackColor'/> property should be 
        ///    persisted.</para>
        /// </devdoc>
        internal override bool ShouldSerializeBackColor()
        {
            return !DefaultBackBrush.Color.Equals(this.BackColor);
        }

        // Don't use dataGridRows, use the accessor!!!
        internal DataGridRow[] DataGridRows {
            get {
                if (dataGridRows == null)
                    CreateDataGridRows();
                return dataGridRows;
            }
        }

        // ToolTipping
        internal DataGridToolTip ToolTipProvider {
            get {
                return toolTipProvider;
            }
        }

        internal int ToolTipId {
            get {
                return toolTipId;
            }
            set {
                toolTipId = value;
            }
        }

        private void ResetToolTip()
        {
            ToolTipProvider.Destroy();
            ToolTipProvider.CreateToolTipHandle();
            // part 4: add toolTips for the backButton and 
            // details button on the caption.
            if (!this.parentRows.IsEmpty()) {
                bool alignRight = this.isRightToLeft();
                int detailsButtonWidth = this.Caption.GetDetailsButtonWidth();
                Rectangle backButton = this.Caption.GetBackButtonRect(this.layout.Caption, alignRight, detailsButtonWidth);
                Rectangle detailsButton = this.Caption.GetDetailsButtonRect(this.layout.Caption, alignRight);

                // mirror the buttons wrt RTL property
                backButton.X = MirrorRectangle(backButton, layout.Inside, isRightToLeft());
                detailsButton.X = MirrorRectangle(detailsButton, layout.Inside, isRightToLeft());

                ToolTipProvider.AddToolTip(SR.GetString(SR.DataGridCaptionBackButtonToolTip), new IntPtr(0), backButton);
                ToolTipProvider.AddToolTip(SR.GetString(SR.DataGridCaptionDetailsButtonToolTip), new IntPtr(1), detailsButton);
                ToolTipId = 2;
            } else {
                ToolTipId = 0;
            }
        }

        /// <devdoc>
        ///      Given a cursor, this will Create the right DataGridRows
        /// </devdoc>
        private void CreateDataGridRows() {
            CurrencyManager listManager = ListManager;
            DataGridTableStyle dgt = this.myGridTable;

            InitializeColumnWidths();

            if (listManager == null) {
                SetDataGridRows(new DataGridRow[0], 0);
                return;
            }

            int nDataGridRows = listManager.Count;
            if (policy.AllowAdd)
                nDataGridRows++;

            DataGridRow[] rows = new DataGridRow[nDataGridRows];
            for (int r = 0; r < listManager.Count; r++) {
                rows[r] = new DataGridRelationshipRow(this, dgt,r);
            }

            if (policy.AllowAdd) {
                this.addNewRow = new DataGridAddNewRow(this, dgt, nDataGridRows - 1);
                rows[nDataGridRows - 1] = addNewRow;
            }
            else {
                addNewRow = null;
            }
            // SetDataGridRows(rows, rows.Length);
            SetDataGridRows(rows, nDataGridRows);
        }

        private void RecreateDataGridRows() {
            int nDataGridRows = 0;
            CurrencyManager listManager = ListManager;
            if (listManager != null) {
                nDataGridRows = listManager.Count;
                if (policy.AllowAdd) {
                    nDataGridRows++;
                }
            }
            SetDataGridRows(null, nDataGridRows);
        }

        /// <devdoc>
        ///      Sets the array of DataGridRow objects used for
        ///      all row-related logic in the DataGrid.
        /// </devdoc>
        internal void SetDataGridRows(DataGridRow[] newRows, int newRowsLength) {
            dataGridRows = newRows;
            dataGridRowsLength = newRowsLength;

            // update the vertical scroll bar
            vertScrollBar.Maximum = Math.Max(0, DataGridRowsLength - 1);
            if (firstVisibleRow > newRowsLength) {
                vertScrollBar.Value = 0;
                firstVisibleRow = 0;
            }

            ResetUIState();
#if DEBUG
            // sanity check: all the rows should have the same
            // dataGridTable
            if (newRows != null && newRowsLength > 0) {
                DataGridTableStyle dgTable = newRows[0].DataGridTableStyle;
                for (int i = 0; i < newRowsLength; i ++) {
                    Debug.Assert(dgTable == newRows[i].DataGridTableStyle, "how can two rows have different tableStyles?");
                    
                }
            }
#endif // DEBUG
            Debug.WriteLineIf(CompModSwitches.DataGridCursor.TraceVerbose, "DataGridCursor: There are now " + DataGridRowsLength.ToString() + " rows.");
        }

        internal int DataGridRowsLength {
            get {
                return dataGridRowsLength;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.DataSource"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the data source that the grid is displaying data for.</para>
        /// </devdoc>
        [
         DefaultValue(null),
         SRCategory(SR.CatData),
         RefreshProperties(RefreshProperties.Repaint),
         TypeConverterAttribute("System.Windows.Forms.Design.DataSourceConverter, " + AssemblyRef.SystemDesign),
         SRDescription(SR.DataGridDataSourceDescr)
        ]
        public object DataSource {
            get {
                return dataSource;
            }

            set {
                if (value != null && !(value is IList || value is IListSource))
                    throw new Exception(SR.GetString(SR.BadDataSourceForComplexBinding));
                if (dataSource != null && dataSource.Equals(value))
                {
                    return;
                }

                // when the designer resets the dataSource to null, set the dataMember to null, too
                if ((value == null || value == Convert.DBNull) && !"".Equals(this.DataMember)) {
                    this.dataSource = null;
                    this.DataMember = "";
                    return;
                }

                // if we are setting the dataSource and the dataMember is not a part
                // of the properties in the dataSource, then set the dataMember to ""
                //
                if (value != null)
                    EnforceValidDataMember(value);

                Debug.WriteLineIf(CompModSwitches.DataGridCursor.TraceVerbose, "DataGridCursor: DataSource being set to " + ((value == null) ? "null" : value.ToString()));

                // when we change the dataSource, we need to clear the parent rows.
                // the same goes for all the caption UI: reset it when the datasource changes.
                //
                parentRows.Clear();
                originalState = null;
                caption.BackButtonActive = caption.DownButtonActive = caption.BackButtonVisible = false;
                caption.SetDownButtonDirection(!layout.ParentRowsVisible);

                Set_ListManager(value, this.DataMember, false);
            }
        }

        private static readonly object EVENT_DATASOURCECHANGED = new object();

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.DataSourceChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.DataGridOnDataSourceChangedDescr)]
        public event EventHandler DataSourceChanged {
            add {
                Events.AddHandler(EVENT_DATASOURCECHANGED, value);
            }
            remove {
                Events.RemoveHandler(EVENT_DATASOURCECHANGED, value);
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.DataMember"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the specific table in a DataSource for the control.
        ///    </para>
        /// </devdoc>
        [
         DefaultValue(null),
         SRCategory(SR.CatData),
         Editor("System.Windows.Forms.Design.DataMemberListEditor, " + AssemblyRef.SystemDesign, typeof(System.Drawing.Design.UITypeEditor)),
         SRDescription(SR.DataGridDataMemberDescr)
        ]
        public string DataMember {
            get {
                return dataMember;
            }
            set {
                if (dataMember != null && dataMember.Equals(value))
                    return;
                Debug.WriteLineIf(CompModSwitches.DataGridCursor.TraceVerbose, "DataGridCursor: DataSource being set to " + ((value == null) ? "null" : value.ToString()));
                // when we change the dataMember, we need to clear the parent rows.
                // the same goes for all the caption UI: reset it when the datamember changes.
                //
                parentRows.Clear();
                originalState = null;
                caption.BackButtonActive = caption.DownButtonActive = caption.BackButtonVisible = false;
                caption.SetDownButtonDirection(!layout.ParentRowsVisible);

                Set_ListManager(this.DataSource, value, false);
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.SetDataBinding"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void SetDataBinding(object dataSource, string dataMember) {
            parentRows.Clear();
            originalState = null;
            caption.BackButtonActive = caption.DownButtonActive = caption.BackButtonVisible = false;
            caption.SetDownButtonDirection(!layout.ParentRowsVisible);

            Set_ListManager(dataSource, dataMember, false);
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ListManager"]/*' />
        [
         Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced),
         SRDescription(SR.DataGridListManagerDescr)
        ]
        internal protected CurrencyManager ListManager {
            get {
                //try to return something useful:
                if (listManager == null && this.BindingContext != null && this.DataSource != null)
                    return (CurrencyManager) this.BindingContext[this.DataSource, this.DataMember];
                else
                    return listManager;
            }
            set {
                throw new NotSupportedException(SR.GetString(SR.DataGridSetListManager));
            }
        }

        internal void Set_ListManager(object newDataSource, string newDataMember, bool force) {
            Set_ListManager(newDataSource, newDataMember, force, true);        // true for forcing column creation
        }

        //
        // prerequisite: the dataMember and the dataSource should be set to the new values
        //
        // will do the following:
        // call EndEdit on the current listManager, will unWire the listManager events, will set the listManager to the new
        // reality, will wire the new listManager, will update the policy, will set the dataGridTable, will reset the ui state.
        //
        internal void Set_ListManager(object newDataSource, string newDataMember, bool force, bool forceColumnCreation)
        {
            bool dataSourceChanged = this.DataSource != newDataSource;
            bool dataMemberChanged = this.DataMember != newDataMember;

            // if nothing happened, then why do any work?
            if (!force && !dataSourceChanged && !dataMemberChanged && gridState[GRIDSTATE_inSetListManager])
                return;

            gridState[GRIDSTATE_inSetListManager] = true;
            bool beginUpdateInternal = true;
            try {
                // will endEdit on the current listManager
                UpdateListManager();

                // unwire the events:
                if (this.listManager != null)
                    UnWireDataSource();

                CurrencyManager oldListManager = listManager;
                bool listManagerChanged = false;
                // set up the new listManager
                // CAUTION: we need to set up the listManager in the grid before setting the dataSource/dataMember props
                // in the grid. the reason is that if the BindingContext was not yet requested, and it is created in the BindingContext prop
                // then the grid will call Set_ListManager again, and eventually that means that the dataGrid::listManager will
                // be hooked up twice to all the events (PositionChanged, ItemChanged, CurrentChanged)
                if (newDataSource != null && this.BindingContext != null && !(newDataSource == Convert.DBNull))
                    this.listManager = (CurrencyManager) this.BindingContext[newDataSource, newDataMember];
                else
                    listManager = null;

                // update the dataSource and the dateMember
                this.dataSource = newDataSource;
                this.dataMember = newDataMember == null ? "" : newDataMember;

                listManagerChanged = (listManager != oldListManager);

                // wire the events
                if (listManager != null) {
                    WireDataSource();
                    // update the policy
                    policy.UpdatePolicy(this.listManager, this.ReadOnly);
                }

                if (!Initializing)
                {
                    if (listManager == null)
                    {
                        SetDataGridRows(null, 0);
                        SetDataGridTable(this.defaultTableStyle, forceColumnCreation);
                    }
                }

                // PERF: if the listManager did not change, then do not:
                //      1. create new rows
                //      2. create new columns
                //      3. compute the errors in the list
                //
                // when the metaDataChanges, we need to recreate
                // the rows and the columns
                //
                if (listManagerChanged || gridState[GRIDSTATE_metaDataChanged]) {
                    BeginUpdateInternal();

                    if (listManager != null)
                    {
                        // get rid of the old gridColumns
                        // we need to clear the old column collection even when navigating to 
                        // a list that has a table style associated w/ it. Why? because the
                        // old column collection will be used by the parent rows to paint
                        this.defaultTableStyle.GridColumnStyles.ResetDefaultColumnCollection();

                        DataGridTableStyle newGridTable = this.dataGridTables[listManager.GetListName()];
                        if (newGridTable == null) {
                            SetDataGridTable(this.defaultTableStyle, forceColumnCreation);
                        } else {
                            SetDataGridTable(newGridTable, forceColumnCreation);
                        }

                        // set the currentRow in ssync w/ the position in the listManager
                        currentRow = listManager.Position == -1 ? 0 : listManager.Position;
                    }

                    // when we create the rows we need to use the current dataGridTable
                    //
                    RecreateDataGridRows();
                    EndUpdateInternal();
                    beginUpdateInternal = false;

                    ComputeMinimumRowHeaderWidth();
                    if (this.myGridTable.IsDefault)
                        this.RowHeaderWidth = Math.Max(this.minRowHeaderWidth, this.RowHeaderWidth);
                    else
                        this.myGridTable.RowHeaderWidth = Math.Max(this.minRowHeaderWidth, this.RowHeaderWidth);

                    ListHasErrors = DataGridSourceHasErrors();

                    // build the list of columns and relationships
                    // wipe out the now invalid states
                    //ResetMouseState();

                    ResetUIState();

                    //layout.CaptionVisible = dataCursor == null ? false : true;

                    OnDataSourceChanged(EventArgs.Empty);
                }

            } finally {
                gridState[GRIDSTATE_inSetListManager] = false;
                // start painting again
                if (beginUpdateInternal) EndUpdateInternal();
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.CurrentRowIndex"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets index of the selected row.</para>
        /// </devdoc>
        // will set the position in the ListManager
        //
        [
         DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
         Browsable(false),
         SRDescription(SR.DataGridSelectedIndexDescr)         
        ]
        public int CurrentRowIndex {
            get {
                if (originalState == null)
                    return this.ListManager == null ? - 1 : this.ListManager.Position;
                else {
                    if (this.BindingContext == null)
                        return -1;
                    CurrencyManager originalListManager = (CurrencyManager) this.BindingContext[originalState.DataSource, originalState.DataMember];
                    return originalListManager.Position;
                }
            }
            set {
                if (this.ListManager == null)
                    throw new InvalidOperationException(SR.GetString(SR.DataGridSetSelectIndex));

                if (originalState == null) {
                    this.ListManager.Position = value;
                    currentRow = value;
                    return;
                }

                // if we have a this.ListManager, then this.BindingManager cannot be null
                //
                CurrencyManager originalListManager = (CurrencyManager) this.BindingContext[originalState.DataSource, originalState.DataMember];
                originalListManager.Position = value;

                // this is for parent rows
                originalState.LinkingRow = originalState.DataGridRows[value];

                // Invalidate everything
                Invalidate();
            }
        }


        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.TableStyles"]/*' />
        /// <devdoc>
        ///    <para>Gets the collection of tables for the grid.</para>
        /// </devdoc>
        [
         SRCategory(SR.CatData),
         DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
         Localizable(true),
         SRDescription(SR.DataGridGridTablesDescr)
        ]
        public GridTableStylesCollection TableStyles {
            get {
                return dataGridTables;
            }
        }

        internal new int FontHeight {
            get {
                return fontHeight;
            }
        }

        internal AccessibleObject ParentRowsAccessibleObject {
            get {
                return parentRows.AccessibleObject;
            }
        }

        internal Rectangle ParentRowsBounds {
            get {
                return layout.ParentRows;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.GridLineColor"]/*' />
        /// <devdoc>
         ///    <para>Gets or sets the color of the grid lines.</para>
         /// </devdoc>
        [
         SRCategory(SR.CatColors),
         SRDescription(SR.DataGridGridLineColorDescr)
        ]
        public Color GridLineColor {
            get {
                return gridLineBrush.Color;
            }
            set {
                if (gridLineBrush.Color != value) {
                    if (value.IsEmpty)
                        throw new ArgumentException(SR.GetString(SR.DataGridEmptyColor, "GridLineColor"));
                    gridLineBrush = new SolidBrush(value);

                    Invalidate(layout.Data);
                }
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ShouldSerializeGridLineColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual bool ShouldSerializeGridLineColor()
        {
            return !GridLineBrush.Equals(DefaultGridLineBrush);
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ResetGridLineColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ResetGridLineColor() {
            if (ShouldSerializeGridLineColor()) {
                GridLineColor = DefaultGridLineBrush.Color;
            }
        }

        internal SolidBrush GridLineBrush {
            get {
                return gridLineBrush;
            }
        }

         /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.GridLineStyle"]/*' />
         /// <devdoc>
         ///    <para>
         ///       Gets or sets the line style of the grid.
         ///    </para>
         /// </devdoc>
        [
         SRCategory(SR.CatAppearance),
         DefaultValue(defaultGridLineStyle),
         SRDescription(SR.DataGridGridLineStyleDescr)
        ]
        public DataGridLineStyle GridLineStyle {
            get {
                return gridLineStyle;
            }
            set {
                if (!Enum.IsDefined(typeof(DataGridLineStyle), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(DataGridLineStyle));
                }
                if (gridLineStyle != value) {
                    gridLineStyle = value;
                    this.myGridTable.ResetRelationsUI();
                    Invalidate(layout.Data);
                }
            }
        }

        internal int GridLineWidth {
            get {
                Debug.Assert(this.GridLineStyle == DataGridLineStyle.Solid || this.GridLineStyle == DataGridLineStyle.None, "are there any other styles?");
                return GridLineStyle == DataGridLineStyle.Solid ? 1 : 0;
            }
        }

         /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ParentRowsLabelStyle"]/*' />
         /// <devdoc>
         ///    <para>
         ///       Gets or
         ///       sets the
         ///       way parent row labels are displayed.
         ///    </para>
         /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
         DefaultValue(defaultParentRowsLabelStyle),
         SRCategory(SR.CatDisplay),
         SRDescription(SR.DataGridParentRowsLabelStyleDescr)
        ]
        public DataGridParentRowsLabelStyle ParentRowsLabelStyle {
            get {
                return parentRowsLabels;
            }

            set {
                if (!Enum.IsDefined(typeof(DataGridParentRowsLabelStyle), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(DataGridParentRowsLabelStyle));
                }

                if (parentRowsLabels != value)
                {
                    parentRowsLabels = value;
                    Invalidate(layout.ParentRows);
                    OnParentRowsLabelStyleChanged(EventArgs.Empty);
                }
            }
        }

        private static readonly object EVENT_PARENTROWSLABELSTYLECHANGED = new object();

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ParentRowsLabelStyleChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.DataGridOnParentRowsLabelStyleChangedDescr)]
        public event EventHandler ParentRowsLabelStyleChanged {
            add {
                Events.AddHandler(EVENT_PARENTROWSLABELSTYLECHANGED, value);
            }
            remove {
                Events.RemoveHandler(EVENT_PARENTROWSLABELSTYLECHANGED, value);
            }
        }

        internal bool Initializing {
            get {
                return inInit;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.FirstVisibleColumn"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the index of the first visible column in a grid.
        ///    </para>
        /// </devdoc>
        [
         Browsable(false),
         SRDescription(SR.DataGridFirstVisibleColumnDescr)
        ]
        public int FirstVisibleColumn {
            get {
                return firstVisibleCol;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.FlatMode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the grid displays in flat mode.
        ///    </para>
        /// </devdoc>
        [
         DefaultValue(false),
         SRCategory(SR.CatAppearance),
         SRDescription(SR.DataGridFlatModeDescr)
        ]
        public bool FlatMode {
            get {
                return gridState[GRIDSTATE_isFlatMode];
            }
            set {
                if (value != FlatMode) {
                    gridState[GRIDSTATE_isFlatMode] = value;
                    Invalidate(layout.Inside);
                    OnFlatModeChanged(EventArgs.Empty);
                }
            }
        }

        private static readonly object EVENT_FLATMODECHANGED = new object();

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.FlatModeChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.DataGridOnFlatModeChangedDescr)]
        public event EventHandler FlatModeChanged {
            add {
                Events.AddHandler(EVENT_FLATMODECHANGED, value);
            }
            remove {
                Events.RemoveHandler(EVENT_FLATMODECHANGED, value);
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.HeaderBackColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or
        ///       sets the background color of all row and column headers.
        ///    </para>
        /// </devdoc>
        [
         SRCategory(SR.CatColors),
         SRDescription(SR.DataGridHeaderBackColorDescr)         
        ]
        public Color HeaderBackColor {
            get {
                return headerBackBrush.Color;
            }
            set {
                if (value.IsEmpty)
                    throw new ArgumentException(SR.GetString(SR.DataGridEmptyColor, "HeaderBackColor"));
                if (IsTransparentColor(value))
                    throw new ArgumentException(SR.GetString(SR.DataGridTransparentHeaderBackColorNotAllowed));
                if (!value.Equals(headerBackBrush.Color)) {
                    headerBackBrush = new SolidBrush(value);

                    if (layout.RowHeadersVisible)
                        Invalidate(layout.RowHeaders);
                    if (layout.ColumnHeadersVisible)
                        Invalidate(layout.ColumnHeaders);
                    Invalidate(layout.TopLeftHeader);
                }
            }
        }

        internal SolidBrush HeaderBackBrush {
            get {
                return headerBackBrush;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ShouldSerializeHeaderBackColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual bool ShouldSerializeHeaderBackColor()
        {
            return !HeaderBackBrush.Equals(DefaultHeaderBackBrush);
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ResetHeaderBackColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ResetHeaderBackColor() {
            if(ShouldSerializeHeaderBackColor()) {
                HeaderBackColor = DefaultHeaderBackBrush.Color;
            }
        }
        internal SolidBrush BackgroundBrush {
            get {
                return backgroundBrush;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ShouldSerializeBackgroundColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual bool ShouldSerializeBackgroundColor()
        {
            return !BackgroundBrush.Equals(DefaultBackgroundBrush);
        }


        // using this property, the user can set the backGround color 
        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.BackgroundColor"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the background color of the grid.</para>
        /// </devdoc>
        [
         SRCategory(SR.CatColors),
         SRDescription(SR.DataGridBackgroundColorDescr)         
        ]
        public Color BackgroundColor {
            get {
                return backgroundBrush.Color;
            }
            set {
                if (value.IsEmpty)
                    throw new ArgumentException(SR.GetString(SR.DataGridEmptyColor, "BackgroundColor"));
                if (!value.Equals(backgroundBrush.Color)) {
                    backgroundBrush = new SolidBrush(value);

                    Invalidate(layout.Inside);
                    OnBackgroundColorChanged(EventArgs.Empty);
                }
            }
        }

        private static readonly object EVENT_BACKGROUNDCOLORCHANGED = new object();

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.BackgroundColorChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.DataGridOnBackgroundColorChangedDescr)]
        public event EventHandler BackgroundColorChanged {
            add {
                Events.AddHandler(EVENT_BACKGROUNDCOLORCHANGED, value);
            }
            remove {
                Events.RemoveHandler(EVENT_BACKGROUNDCOLORCHANGED, value);
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.HeaderFont"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates whether the <see cref='System.Windows.Forms.DataGrid.HeaderFont'/> property should be persisted.
        ///    </para>
        /// </devdoc>
        [
         SRCategory(SR.CatAppearance),
         SRDescription(SR.DataGridHeaderFontDescr)
        ]
        public Font HeaderFont {
            get {
                return(headerFont == null ? this.Font : headerFont);
            }
            set {
                if (value == null)
                    throw new ArgumentNullException("HeaderFont");
                if (!value.Equals(headerFont)) {
                    headerFont = value;
                    RecalculateFonts();
                    PerformLayout();
                    Invalidate(layout.Inside);
                }
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ShouldSerializeHeaderFont"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected bool ShouldSerializeHeaderFont() {
            return(headerFont != null);
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ResetHeaderFont"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ResetHeaderFont() {
            if (headerFont != null) {
                headerFont = null;
                RecalculateFonts();
                PerformLayout();
                Invalidate(layout.Inside);
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.HeaderForeColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Resets the <see cref='System.Windows.Forms.DataGrid.HeaderFont'/> property to its default value.
        ///    </para>
        /// </devdoc>
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the foreground color of the grid's headers.
        ///    </para>
        /// </devdoc>
        [
         SRCategory(SR.CatColors),
         SRDescription(SR.DataGridHeaderForeColorDescr)         
        ]
        public Color HeaderForeColor {
            get {
                return headerForePen.Color;
            }
            set {
                if (value.IsEmpty)
                    throw new ArgumentException(SR.GetString(SR.DataGridEmptyColor, "HeaderForeColor"));
                if (!value.Equals(headerForePen.Color)) {
                    headerForePen = new Pen(value);
                    headerForeBrush = new SolidBrush(value);

                    if (layout.RowHeadersVisible)
                        Invalidate(layout.RowHeaders);
                    if (layout.ColumnHeadersVisible)
                        Invalidate(layout.ColumnHeaders);
                    Invalidate(layout.TopLeftHeader);
                }
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ShouldSerializeHeaderForeColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual bool ShouldSerializeHeaderForeColor()
        {
            return !HeaderForePen.Equals(DefaultHeaderForePen);
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ResetHeaderForeColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ResetHeaderForeColor() {
            if(ShouldSerializeHeaderForeColor()) {
                HeaderForeColor = DefaultHeaderForeBrush.Color;
            }
        }

        internal SolidBrush HeaderForeBrush {
            get {
                return this.headerForeBrush;
            }
        }

        internal Pen HeaderForePen {
            get {
                return headerForePen;
            }
        }
        private void ResetHorizontalOffset() {
            horizontalOffset = 0;
            negOffset = 0;
            firstVisibleCol = 0;
            numVisibleCols = 0;
            lastTotallyVisibleCol = 0;
        }

        internal int HorizontalOffset {
            get {
                return horizontalOffset;
            }
            set {
                //if (CompModSwitches.DataGridScrolling.TraceVerbose) Debug.WriteLine("DataGridScrolling: Set_HorizontalOffset, value = " + value.ToString());
                if (value < 0)
                    value = 0;

                //
                //  if the dataGrid is not bound ( listManager == null || gridTable == null)
                //  then use ResetHorizontalOffset();
                //

                int totalWidth = GetColumnWidthSum();
                int widthNotVisible = totalWidth - layout.Data.Width;
                if (value > widthNotVisible && widthNotVisible > 0)
                    value = widthNotVisible;

                if (value == horizontalOffset)
                    return;

                int change = horizontalOffset - value;
                horizScrollBar.Value = value;
                Rectangle scroll = layout.Data;
                if (layout.ColumnHeadersVisible)
                    scroll = Rectangle.Union(scroll, layout.ColumnHeaders);
                horizontalOffset = value;

                this.firstVisibleCol = ComputeFirstVisibleColumn();
                // update the lastTotallyVisibleCol
                ComputeVisibleColumns();

                if (gridState[GRIDSTATE_isScrolling])
                {
                    // if the user did not click on the grid yet, then do not put the edit
                    // control when scrolling
                    if (currentCol >= firstVisibleCol && currentCol < firstVisibleCol + numVisibleCols - 1 && (gridState[GRIDSTATE_isEditing] || gridState[GRIDSTATE_isNavigating]))
                        Edit();
                    else
                        EndEdit();

                    // isScrolling is set to TRUE when the user scrolls.
                    // once we move the edit box, we finished processing the scroll event, so set isScrolling to FALSE
                    // to set isScrolling to TRUE, we need another scroll event.
                    gridState[GRIDSTATE_isScrolling] = false;
                }
                else
                {
                    EndEdit();
                }

                NativeMethods.RECT[] rects = CreateScrollableRegion(scroll);
                ScrollRectangles(rects, change);
                OnScroll(EventArgs.Empty);
            }
        }

        private void ScrollRectangles(NativeMethods.RECT[] rects, int change) {
            NativeMethods.RECT scroll;
            if (isRightToLeft()) change = -change;
            for (int r = 0; r < rects.Length; r++) {
                scroll = rects[r];
                SafeNativeMethods.ScrollWindow(new HandleRef(this, Handle),
                                     change,
                                     0,
                                     ref scroll,
                                     ref scroll);
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.HorizScrollBar"]/*' />
        /// <devdoc>
        /// </devdoc>
        [
         SRDescription(SR.DataGridHorizScrollBarDescr)        
        ]
        protected ScrollBar HorizScrollBar {
            get {
                return horizScrollBar;
            }
        }

        /// <devdoc>
        ///    <para>
        ///       Retrieves a value indicating whether odd and even
        ///       rows are painted using a different background color.
        ///    </para>
        /// </devdoc>
        // CUT by 53973 - Cleanup eventually to be static.
        internal bool LedgerStyle {
            get {
                return gridState[GRIDSTATE_isLedgerStyle];
            }
            /*
            set {
                if (isLedgerStyle != value) {
                    isLedgerStyle = value;
                    InvalidateInside();
                }
            }
            */
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.LinkColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates whether the <see cref='System.Windows.Forms.DataGrid.LinkColor'/> property should be persisted.
        ///    </para>
        /// </devdoc>
        [
         SRCategory(SR.CatColors),
         SRDescription(SR.DataGridLinkColorDescr)
        ]
        public Color LinkColor {
            get {
                return linkBrush.Color;
            }
            set {
                if (value.IsEmpty)
                    throw new ArgumentException(SR.GetString(SR.DataGridEmptyColor, "LinkColor"));
                if (!linkBrush.Color.Equals(value)) {
                    linkBrush = new SolidBrush(value);
                    Invalidate(layout.Data);
                }
            }
        }

        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        internal virtual bool ShouldSerializeLinkColor()
        {
            return !LinkBrush.Equals(DefaultLinkBrush);
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ResetLinkColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ResetLinkColor() {
            if (ShouldSerializeLinkColor())
                LinkColor = DefaultLinkBrush.Color;
        }

        internal Brush LinkBrush {
            get {
                return linkBrush;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.LinkHoverColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       or sets the color a link changes to when
        ///       the mouse pointer moves over it.
        ///    </para>
        /// </devdoc>
        [
         SRDescription(SR.DataGridLinkHoverColorDescr),
         SRCategory(SR.CatColors),
         Browsable(false),
         EditorBrowsable(EditorBrowsableState.Never),
         ComVisible(false)
        ]
        public Color LinkHoverColor {
            get {
                return this.LinkColor;
            }
            set {
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ShouldSerializeLinkHoverColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual bool ShouldSerializeLinkHoverColor()
        {
            return false;
            // return !LinkHoverBrush.Equals(defaultLinkHoverBrush);
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ResetLinkHoverColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ResetLinkHoverColor() { 
            /*
            if (ShouldSerializeLinkHoverColor())
                LinkHoverColor = defaultLinkHoverBrush.Color;*/
        }

        /// <devdoc>
        ///    <para>
        ///       Indicates whether the <see cref='System.Windows.Forms.DataGrid.LinkHoverColor'/> property should be
        ///       persisted.
        ///    </para>
        /// </devdoc>

        internal Font LinkFont {
            get {
                return linkFont;
            }
        }

        internal int LinkFontHeight {
            get {
                return linkFontHeight;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.AllowNavigation"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value
        ///       that specifies which links are shown and in what context.</para>
        /// </devdoc>
        [
         DefaultValue(true),
         SRDescription(SR.DataGridNavigationModeDescr),
         SRCategory(SR.CatBehavior)
        ]
        public bool AllowNavigation {
            get {
                return gridState[GRIDSTATE_allowNavigation];
            }
            set {
                if (AllowNavigation != value) {
                    gridState[GRIDSTATE_allowNavigation] = value;
                    // let the Caption know about this:
                    this.Caption.BackButtonActive = !parentRows.IsEmpty() && (value);
                    this.Caption.BackButtonVisible = this.Caption.BackButtonActive;
                    RecreateDataGridRows();

                    OnAllowNavigationChanged(EventArgs.Empty);
                }
            }
        }

        private static readonly object EVENT_ALLOWNAVIGATIONCHANGED = new object();

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.AllowNavigationChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.DataGridOnNavigationModeChangedDescr)]
        public event EventHandler AllowNavigationChanged {
            add {
                Events.AddHandler(EVENT_ALLOWNAVIGATIONCHANGED, value);
            }
            remove {
                Events.RemoveHandler(EVENT_ALLOWNAVIGATIONCHANGED, value);
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.Cursor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
            Browsable(false), EditorBrowsable(EditorBrowsableState.Never)
        ]
        public override Cursor Cursor {
            // get the cursor out of the propertyGrid.
            get {
                return base.Cursor;
            }

            set {
                base.Cursor = value;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.CursorChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler CursorChanged {
            add {
                base.CursorChanged += value;
            }
            remove {
                base.CursorChanged -= value;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.BackgroundImage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
            Browsable(false), EditorBrowsable(EditorBrowsableState.Never)
        ]
        public override Image BackgroundImage {
            // get the BackgroundImage out of the propertyGrid.
            get {
                return base.BackgroundImage;
            }

            set {
                base.BackgroundImage = value;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.BackgroundImageChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler BackgroundImageChanged {
            add {
                base.BackgroundImageChanged += value;
            }
            remove {
                base.BackgroundImageChanged -= value;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ParentRowsBackColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the background color of parent rows.
        ///    </para>
        /// </devdoc>
        [
         SRCategory(SR.CatColors),
         SRDescription(SR.DataGridParentRowsBackColorDescr)
        ]
        public Color ParentRowsBackColor {
            get {
                return parentRows.BackColor;
            }
            set {
                if (IsTransparentColor(value))
                    throw new ArgumentException(SR.GetString(SR.DataGridTransparentParentRowsBackColorNotAllowed));
                this.parentRows.BackColor = value;
            }
        }

        internal SolidBrush ParentRowsBackBrush {
            get {
                return parentRows.BackBrush;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ShouldSerializeParentRowsBackColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates whether the <see cref='System.Windows.Forms.DataGrid.ParentRowsBackColor'/> property should be
        ///       persisted.
        ///    </para>
        /// </devdoc>
        protected virtual bool ShouldSerializeParentRowsBackColor()
        {
            return !ParentRowsBackBrush.Equals(DefaultParentRowsBackBrush);
        }

        private void ResetParentRowsBackColor() {
            if (ShouldSerializeParentRowsBackColor())
                parentRows.BackBrush = DefaultParentRowsBackBrush;
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ParentRowsForeColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the foreground color of parent rows.
        ///    </para>
        /// </devdoc>
        [
         SRCategory(SR.CatColors),
         SRDescription(SR.DataGridParentRowsForeColorDescr)         
        ]
        public Color ParentRowsForeColor {
            get {
                return parentRows.ForeColor;
            }
            set {
                this.parentRows.ForeColor = value;
            }
        }

        internal SolidBrush ParentRowsForeBrush {
            get {
                return parentRows.ForeBrush;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ShouldSerializeParentRowsForeColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates whether the <see cref='System.Windows.Forms.DataGrid.ParentRowsForeColor'/> property should be
        ///       persisted.
        ///    </para>
        /// </devdoc>
        protected virtual bool ShouldSerializeParentRowsForeColor()
        {
            return !ParentRowsForeBrush.Equals(DefaultParentRowsForeBrush);
        }

        private void ResetParentRowsForeColor() { 
            if (ShouldSerializeParentRowsForeColor())
                parentRows.ForeBrush = DefaultParentRowsForeBrush;
        }


        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.PreferredColumnWidth"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       or sets the default width of the grid columns in
        ///       pixels.
        ///    </para>
        /// </devdoc>
        [
         DefaultValue(defaultPreferredColumnWidth),
         SRCategory(SR.CatLayout),
         SRDescription(SR.DataGridPreferredColumnWidthDescr),
         TypeConverter(typeof(DataGridPreferredColumnWidthTypeConverter))
        ]
        public int PreferredColumnWidth {
            get {
                return preferredColumnWidth;
            }
            set {
                if (value < 0)
                    throw new ArgumentException(SR.GetString(SR.DataGridColumnWidth), "PreferredColumnWidth");
                if (preferredColumnWidth != value) {
                    preferredColumnWidth = value;
                }
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.PreferredRowHeight"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the preferred row height for the <see cref='System.Windows.Forms.DataGrid'/> control.
        ///    </para>
        /// </devdoc>
        [
         SRCategory(SR.CatLayout),
         SRDescription(SR.DataGridPreferredRowHeightDescr)
        ]
        public int PreferredRowHeight {
            get {
                return prefferedRowHeight;
            }
            set {
                if (value < 0)
                    throw new ArgumentException(SR.GetString(SR.DataGridRowRowHeight));
                prefferedRowHeight = value;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ShouldSerializePreferredRowHeight"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected bool ShouldSerializePreferredRowHeight()
        {
            return prefferedRowHeight != defaultFontHeight + 3;
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ReadOnly"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value indicating whether the grid
        ///       is in read-only mode.</para>
        /// </devdoc>
        [
         DefaultValue(false),
         SRCategory(SR.CatBehavior),
         SRDescription(SR.DataGridReadOnlyDescr)
        ]
        public bool ReadOnly {
            get {
                return gridState[GRIDSTATE_readOnlyMode];
            }
            set {
                if (ReadOnly != value) {
                    bool recreateRows = false;
                    if (value) {
                        // AllowAdd happens to have the same boolean value as whether we need to recreate rows.
                        recreateRows = policy.AllowAdd;

                        policy.AllowRemove = false;
                        policy.AllowEdit = false;
                        policy.AllowAdd  = false;
                    }
                    else {
                        recreateRows |= policy.UpdatePolicy(this.ListManager, value);
                    }
                    gridState[GRIDSTATE_readOnlyMode] = value;
                    DataGridRow[] dataGridRows = this.DataGridRows;
                    if (recreateRows) {
                        RecreateDataGridRows();

                        // keep the selected rows
                        DataGridRow[] currentDataGridRows = this.DataGridRows;
                        int rowCount = Math.Min(currentDataGridRows.Length, dataGridRows.Length);
                        for (int i = 0; i < rowCount; i++) {
                            if (dataGridRows[i].Selected)
                                currentDataGridRows[i].Selected = true;
                        }
                    }

                    // the addnew row needs to be updated.
                    PerformLayout();
                    InvalidateInside();
                    OnReadOnlyChanged(EventArgs.Empty);
                }
            }
        }

        private static readonly object EVENT_READONLYCHANGED = new object();

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ReadOnlyChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.DataGridOnReadOnlyChangedDescr)]
        public event EventHandler ReadOnlyChanged {
            add {
                Events.AddHandler(EVENT_READONLYCHANGED, value);
            }
            remove {
                Events.RemoveHandler(EVENT_READONLYCHANGED, value);
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ColumnHeadersVisible"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       or sets a value indicating if the grid's column headers are visible.
        ///    </para>
        /// </devdoc>
        [
         SRCategory(SR.CatDisplay),
         DefaultValue(true),
         SRDescription(SR.DataGridColumnHeadersVisibleDescr)
        ]
        public bool ColumnHeadersVisible {
            get {
                return gridState[GRIDSTATE_columnHeadersVisible];
            }
            set {
                if (ColumnHeadersVisible != value) {
                    gridState[GRIDSTATE_columnHeadersVisible] = value;
                    layout.ColumnHeadersVisible = value;
                    PerformLayout();
                    InvalidateInside();
                }
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ParentRowsVisible"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the parent rows of a table are
        ///       visible.
        ///    </para>
        /// </devdoc>
        [
         SRCategory(SR.CatDisplay),
         DefaultValue(true),
         SRDescription(SR.DataGridParentRowsVisibleDescr)        
        ]
        public bool ParentRowsVisible {
            get {
                return layout.ParentRowsVisible;
            }
            set {
                if (layout.ParentRowsVisible != value) {
                    SetParentRowsVisibility(value);

                    // update the caption: parentDownVisible == false corresponds to DownButtonDown == true;
                    //
                    caption.SetDownButtonDirection(!value);

                    OnParentRowsVisibleChanged(EventArgs.Empty);
                }
            }
        }

        private static readonly object EVENT_PARENTROWSVISIBLECHANGED = new object();

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ParentRowsVisibleChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.DataGridOnParentRowsVisibleChangedDescr)]
        public event EventHandler ParentRowsVisibleChanged {
            add {
                Events.AddHandler(EVENT_PARENTROWSVISIBLECHANGED, value);
            }
            remove {
                Events.RemoveHandler(EVENT_PARENTROWSVISIBLECHANGED, value);
            }
        }

        internal bool ParentRowsIsEmpty() {
            return parentRows.IsEmpty();
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.RowHeadersVisible"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the data grid's row headers are
        ///       visible.
        ///    </para>
        /// </devdoc>
        [
         SRCategory(SR.CatDisplay),
         DefaultValue(true),
         SRDescription(SR.DataGridRowHeadersVisibleDescr)
        ]
        public bool RowHeadersVisible {
            get {
                return gridState[GRIDSTATE_rowHeadersVisible];
            }
            set {
                if (RowHeadersVisible != value) {
                    gridState[GRIDSTATE_rowHeadersVisible] = value;
                    PerformLayout();
                    InvalidateInside();
                }
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.RowHeaderWidth"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
         SRCategory(SR.CatLayout),
         DefaultValue(defaultRowHeaderWidth),
         SRDescription(SR.DataGridRowHeaderWidthDescr)
        ]
        public int RowHeaderWidth {
            get {
                return rowHeaderWidth;
            }
            set {
                value = Math.Max(this.minRowHeaderWidth, value);
                if (rowHeaderWidth != value)
                {
                    rowHeaderWidth = value;
                    if (layout.RowHeadersVisible)
                    {
                        PerformLayout();
                        InvalidateInside();
                    }
                }
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.Text"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the width of headers.
        ///    </para>
        /// </devdoc>
        
        [
         Browsable(false), EditorBrowsable(EditorBrowsableState.Never),
         DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
         Bindable(false)
        ]
        public override string Text {
            get {
                return base.Text;
            }
            set {
                base.Text = value;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.TextChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler TextChanged {
            add {
                base.TextChanged += value;
            }
            remove {
                base.TextChanged -= value;
            }
        }
        
        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.VertScrollBar"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the vertical scroll bar of the control.
        ///    </para>
        /// </devdoc>
        [
         Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced),
         SRDescription(SR.DataGridVertScrollBarDescr)
        ]
        protected ScrollBar VertScrollBar {
            get {
                return vertScrollBar;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.VisibleColumnCount"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the number of visible columns.
        ///    </para>
        /// </devdoc>
        [
         Browsable(false),
         SRDescription(SR.DataGridVisibleColumnCountDescr)
        ]
        public int VisibleColumnCount {
            get {
                return Math.Min(numVisibleCols, this.myGridTable == null ? 0 : this.myGridTable.GridColumnStyles.Count);
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.VisibleRowCount"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the number of rows visible.
        ///    </para>
        /// </devdoc>
        [
         Browsable(false),
         SRDescription(SR.DataGridVisibleRowCountDescr)
        ]
        public int VisibleRowCount {
            get {
                return numVisibleRows;
            }
        }


        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.this"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the value of the cell at
        ///       the specified the row and column.</para>
        /// </devdoc>
        public object this[int rowIndex, int columnIndex] {
            get {
                EnsureBound();
                if (rowIndex < 0 || rowIndex >= DataGridRowsLength)
                    throw new ArgumentOutOfRangeException("rowIndex");
                if (columnIndex < 0 || columnIndex >= myGridTable.GridColumnStyles.Count)
                    throw new ArgumentOutOfRangeException("columnIndex");
                CurrencyManager listManager = this.ListManager;
                DataGridColumnStyle column = myGridTable.GridColumnStyles[columnIndex];
                return column.GetColumnValueAtRow(listManager, rowIndex);
            }
            set {
                EnsureBound();
                if (rowIndex < 0 || rowIndex >= DataGridRowsLength)
                    throw new ArgumentOutOfRangeException("rowIndex");
                if (columnIndex < 0 || columnIndex >= myGridTable.GridColumnStyles.Count)
                    throw new ArgumentOutOfRangeException("columnIndex");
                CurrencyManager listManager = this.ListManager;
                if (listManager.Position != rowIndex)
                    listManager.Position = rowIndex;
                DataGridColumnStyle column = myGridTable.GridColumnStyles[columnIndex];
                column.SetColumnValueAtRow(listManager, rowIndex, value);

                // invalidate the bounds of the cell only if the cell is visible
                if (columnIndex >= firstVisibleCol && columnIndex <= firstVisibleCol+ numVisibleCols - 1 &&
                    rowIndex >= firstVisibleRow && rowIndex <= firstVisibleRow + numVisibleRows) {
                    Rectangle bounds = GetCellBounds(rowIndex, columnIndex);
                    this.Invalidate(bounds);
                }
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.this1"]/*' />
        /// <devdoc>
        /// <para>Gets or sets the value of a specified <see cref='System.Windows.Forms.DataGridCell'/>.</para>
        /// </devdoc>
        public object this[DataGridCell cell] {
            get {
                return this[cell.RowNumber, cell.ColumnNumber];
            }
            set {
                this[cell.RowNumber, cell.ColumnNumber] = value;
            }
        }

        private void WireTableStylePropChanged(DataGridTableStyle gridTable) {
            gridTable.GridLineColorChanged += new EventHandler(GridLineColorChanged);
            gridTable.GridLineStyleChanged += new EventHandler(GridLineStyleChanged);
            gridTable.HeaderBackColorChanged += new EventHandler(HeaderBackColorChanged);
            gridTable.HeaderFontChanged += new EventHandler(HeaderFontChanged);
            gridTable.HeaderForeColorChanged += new EventHandler(HeaderForeColorChanged);
            gridTable.LinkColorChanged += new EventHandler(LinkColorChanged);
            gridTable.LinkHoverColorChanged += new EventHandler(LinkHoverColorChanged);
            gridTable.PreferredColumnWidthChanged += new EventHandler(PreferredColumnWidthChanged);
            gridTable.RowHeadersVisibleChanged += new EventHandler(RowHeadersVisibleChanged);
            gridTable.ColumnHeadersVisibleChanged += new EventHandler(ColumnHeadersVisibleChanged);
            gridTable.RowHeaderWidthChanged += new EventHandler(RowHeaderWidthChanged);
            gridTable.AllowSortingChanged += new EventHandler(AllowSortingChanged);
        }

        private void UnWireTableStylePropChanged(DataGridTableStyle gridTable) {
            gridTable.GridLineColorChanged -= new EventHandler(GridLineColorChanged);
            gridTable.GridLineStyleChanged -= new EventHandler(GridLineStyleChanged);
            gridTable.HeaderBackColorChanged -= new EventHandler(HeaderBackColorChanged);
            gridTable.HeaderFontChanged -= new EventHandler(HeaderFontChanged);
            gridTable.HeaderForeColorChanged -= new EventHandler(HeaderForeColorChanged);
            gridTable.LinkColorChanged -= new EventHandler(LinkColorChanged);
            gridTable.LinkHoverColorChanged -= new EventHandler(LinkHoverColorChanged);
            gridTable.PreferredColumnWidthChanged -= new EventHandler(PreferredColumnWidthChanged);
            gridTable.RowHeadersVisibleChanged -= new EventHandler(RowHeadersVisibleChanged);
            gridTable.ColumnHeadersVisibleChanged -= new EventHandler(ColumnHeadersVisibleChanged);
            gridTable.RowHeaderWidthChanged -= new EventHandler(RowHeaderWidthChanged);
            gridTable.AllowSortingChanged -= new EventHandler(AllowSortingChanged);
        }

        /// <devdoc>
        ///      DataSource events are handled
        /// </devdoc>
        private void WireDataSource() {
            Debug.WriteLineIf(CompModSwitches.DataGridCursor.TraceVerbose, "DataGridCursor: WireDataSource");
            Debug.Assert(listManager!= null, "Can't wire up to a null DataSource");
            listManager.CurrentChanged += currentChangedHandler;
            listManager.PositionChanged += positionChangedHandler;
            listManager.ItemChanged += itemChangedHandler;
            listManager.MetaDataChanged += metaDataChangedHandler;
        }

        private void UnWireDataSource() {
            Debug.WriteLineIf(CompModSwitches.DataGridCursor.TraceVerbose, "DataGridCursor: UnWireDataSource");
            Debug.Assert(listManager != null, "Can't un wire from a null DataSource");
            listManager.CurrentChanged -= currentChangedHandler;
            listManager.PositionChanged -= positionChangedHandler;
            listManager.ItemChanged -= itemChangedHandler;
            listManager.MetaDataChanged -= metaDataChangedHandler;
        }

        // This is called after a row has been added.  And I think whenever
        // a row gets deleted, etc.
        // We recreate our datagrid rows at this point.
        private void DataSource_Changed(object sender, EventArgs ea) {
            Debug.WriteLineIf(CompModSwitches.DataGridCursor.TraceVerbose, "DataGridCursor: DataSource_Changed");

            // the grid will receive the dataSource_Changed event when
            // allowAdd changes on the dataView.
            policy.UpdatePolicy(this.ListManager, this.ReadOnly);
            if (gridState[GRIDSTATE_inListAddNew]) {
                // we are adding a new row
                // keep the old rows, w/ their height, expanded/collapsed information
                //
                Debug.Assert(policy.AllowAdd, "how can we add a new row if the policy does not allow this?");
                Debug.Assert(DataGridRowsLength == DataGridRows.Length, "how can this fail?");

                DataGridRow[] gridRows = DataGridRows;
                int currentRowCount = DataGridRowsLength;
                // put the added row:
                //
                gridRows[currentRowCount - 1] = new DataGridRelationshipRow(this, this.myGridTable, currentRowCount - 1);
                SetDataGridRows(gridRows, currentRowCount);
            } else if (gridState[GRIDSTATE_inAddNewRow] && !gridState[GRIDSTATE_inDeleteRow]) {
                // when the backEnd adds a row and we are still inAddNewRow
                listManager.CancelCurrentEdit();
                gridState[GRIDSTATE_inAddNewRow] = false;
                RecreateDataGridRows();
            } else if (!gridState[GRIDSTATE_inDeleteRow]) {
                RecreateDataGridRows();
                currentRow = Math.Min(currentRow, this.listManager.Count);
            }

            bool oldListHasErrors = ListHasErrors;
            ListHasErrors = DataGridSourceHasErrors();
            // if we changed the ListHasErrors, then the grid is already invalidated
            if (oldListHasErrors == ListHasErrors)
                InvalidateInside();
        }

        private void GridLineColorChanged(object sender, EventArgs e) {
            Invalidate(layout.Data);
        }
        private void GridLineStyleChanged(object sender, EventArgs e) {
            this.myGridTable.ResetRelationsUI();
            Invalidate(layout.Data);
        }
        private void HeaderBackColorChanged(object sender, EventArgs e) {
            if (layout.RowHeadersVisible)
                Invalidate(layout.RowHeaders);
            if (layout.ColumnHeadersVisible)
                Invalidate(layout.ColumnHeaders);
            Invalidate(layout.TopLeftHeader);
        }
        private void HeaderFontChanged(object sender, EventArgs e) {
            RecalculateFonts();
            PerformLayout();
            Invalidate(layout.Inside);
        }
        private void HeaderForeColorChanged(object sender, EventArgs e) {
            if (layout.RowHeadersVisible)
                Invalidate(layout.RowHeaders);
            if (layout.ColumnHeadersVisible)
                Invalidate(layout.ColumnHeaders);
            Invalidate(layout.TopLeftHeader);
        }
        private void LinkColorChanged(object sender, EventArgs e) {
            Invalidate(layout.Data);
        }
        private void LinkHoverColorChanged(object sender, EventArgs e) {
            Invalidate(layout.Data);
        }
        private void PreferredColumnWidthChanged(object sender, EventArgs e) {
            // reset the dataGridRows
            SetDataGridRows(null, this.DataGridRowsLength);
            // layout the horizontal scroll bar
            PerformLayout();
            // invalidate everything
            Invalidate();
        }
        private void RowHeadersVisibleChanged(object sender, EventArgs e) {
            layout.RowHeadersVisible = this.myGridTable == null ? false : this.myGridTable.RowHeadersVisible;
            PerformLayout();
            InvalidateInside();
        }
        private void ColumnHeadersVisibleChanged(object sender, EventArgs e) {
            layout.ColumnHeadersVisible = this.myGridTable == null ? false : this.myGridTable.ColumnHeadersVisible;
            PerformLayout();
            InvalidateInside();
        }
        private void RowHeaderWidthChanged(object sender, EventArgs e) {
            if (layout.RowHeadersVisible)
            {
                PerformLayout();
                InvalidateInside();
            }
        }
        private void AllowSortingChanged(object sender, EventArgs e) {
            if (!this.myGridTable.AllowSorting && this.listManager != null) { 
                IList list = this.ListManager.List;
                if (list is IBindingList)
                    ((IBindingList) list).RemoveSort();
            }
        }

        private void DataSource_RowChanged(object sender, EventArgs ea) {
            Debug.WriteLineIf(CompModSwitches.DataGridCursor.TraceVerbose, "DataGridCursor: DataSource_RowChanged");
            InvalidateRow(currentRow);
        }

        /// <devdoc>
        ///    <para>
        ///       Fired by the DataSource when row position moves.
        ///    </para>
        /// </devdoc>
        private void DataSource_PositionChanged(object sender, EventArgs ea) {
#if DEBUG
            inDataSource_PositionChanged = true;
#endif
            Debug.WriteLineIf(CompModSwitches.DataGridCursor.TraceVerbose, "DataGridCursor: DataSource_PositionChanged to " + listManager.Position.ToString());
            // the grid will get the PositionChanged event 
            // before the OnItemChanged event when a row will be deleted in the backEnd;
            // we still want to keep the old rows when the user deletes the rows using the grid
            // and we do not want to do the same work twice when the user adds a row via the grid
            if (this.DataGridRowsLength > this.listManager.Count + (policy.AllowAdd?1:0) && !gridState[GRIDSTATE_inDeleteRow]) {
                Debug.Assert(!gridState[GRIDSTATE_inAddNewRow] && !gridState[GRIDSTATE_inListAddNew], "how can the list decrease when we are adding a row?");
                RecreateDataGridRows();
            }
            if (this.ListManager.Position != currentRow) {
                CurrentCell = new DataGridCell(listManager.Position, currentCol);

#if DEBUG
                inCurrentCellChange = inCurrentCellChange; // avoid build error
                // Debug.Assert(!inCurrentCellChange, "when we change the position in the list thru the currentCell, then the position in the list and the currentRow in the dataGrid should be the same");
#endif
            }
#if DEBUG
            inDataSource_PositionChanged = false;
#endif
        }

        internal void DataSource_MetaDataChanged(object sender, EventArgs e) {
            MetaDataChanged();
        }

        private bool DataGridSourceHasErrors()
        {
            if (this.ListManager == null)
                return false;
            for (int i = 0; i < this.listManager.Count; i++)
            {
                object errObj = this.listManager[i];
                if (errObj is IDataErrorInfo)
                {
                    string errString = ((IDataErrorInfo)errObj).Error;
                    if (errString != null && errString.Length != 0)
                        return true;
                }
            }
            return false;
        }

        private void TableStylesCollectionChanged(object sender, CollectionChangeEventArgs ccea) {
            // if the users changed the collection of tableStyles
            if (sender != this.dataGridTables)
                return;
            if (this.listManager == null)
                return;

            if (ccea.Action == CollectionChangeAction.Add) {
                DataGridTableStyle tableStyle = (DataGridTableStyle) ccea.Element;
                if (this.listManager.GetListName().Equals(tableStyle.MappingName)) {
                    Debug.Assert(this.myGridTable.IsDefault, "if the table is not default, then it had a name. how can one add another table to the collection w/ the same name and not throw an exception");
                    SetDataGridTable(tableStyle, true);                // true for forcing column creation
                    SetDataGridRows(null, 0);
                }
            } else if (ccea.Action == CollectionChangeAction.Remove) {
                DataGridTableStyle tableStyle = (DataGridTableStyle) ccea.Element;
                if (this.myGridTable.MappingName.Equals(tableStyle.MappingName)) {
                    Debug.Assert(this.myGridTable.IsDefault, "if the table is not default, then it had a name. how can one add another table to the collection w/ the same name and not throw an exception");
                    this.defaultTableStyle.GridColumnStyles.ResetDefaultColumnCollection();
                    SetDataGridTable(this.defaultTableStyle, true);    // true for forcing column creation
                    SetDataGridRows(null, 0);
                }
            } else {
                Debug.Assert(ccea.Action == CollectionChangeAction.Refresh, "what else is possible?");
                // we have to search to see if the collection of table styles contains one
                // w/ the same name as the list in the dataGrid

                DataGridTableStyle newGridTable = this.dataGridTables[listManager.GetListName()];
                if (newGridTable == null) {
                    if (!this.myGridTable.IsDefault) {
                        // get rid of the old gridColumns
                        this.defaultTableStyle.GridColumnStyles.ResetDefaultColumnCollection();
                        SetDataGridTable(this.defaultTableStyle, true);    // true for forcing column creation
                        SetDataGridRows(null, 0);
                    }
                } else {
                    SetDataGridTable(newGridTable, true);              // true for forcing column creation
                    SetDataGridRows(null, 0);
                }
            }
        }

        private void DataSource_ItemChanged(object sender, ItemChangedEventArgs ea) {
            Debug.WriteLineIf(CompModSwitches.DataGridCursor.TraceVerbose, "DataGridCursor: DataSource_ItemChanged at index " + ea.Index.ToString());

            // if ea.Index == -1, then we invalidate all rows.
            if (ea.Index == -1)
            {
                DataSource_Changed(sender, EventArgs.Empty);
                /*
                // if there are rows which are invisible, it is more efficient to invalidata layout.Data
                if (numVisibleRows <= dataGridRowsLength)
                    Invalidate(layout.Data);
                else
                {
                    Debug.Assert(firstVisibleRow == 0, "if all rows are visible, then how come that first row is not visible?");
                    for (int i = 0; i < numVisibleRows; i++)
                        InvalidateRow(firstVisibleRow + numVisibleRows);
                }
                */
            }
            else 
            {
                // let's see how we are doing w/ the errors
                object errObj = this.listManager[ea.Index];
                bool oldListHasErrors = ListHasErrors;
                if (errObj is IDataErrorInfo)
                {
                    if (((IDataErrorInfo)errObj).Error.Length != 0)
                        ListHasErrors = true;
                    else if (ListHasErrors)
                    {
                        // maybe there was an error that now is fixed
                        ListHasErrors = DataGridSourceHasErrors();
                    }
                }

                // Invalidate the row only if we did not change the ListHasErrors
                if (oldListHasErrors == ListHasErrors)
                    InvalidateRow(ea.Index);

                // we need to update the edit box:
                // we update the text in the edit box only when the currentRow
                // equals the ea.Index
                if (editColumn != null && ea.Index == currentRow)
                    editColumn.UpdateUI(this.ListManager, ea.Index, null);
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnBorderStyleChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnBorderStyleChanged(EventArgs e) {
            EventHandler eh = Events[EVENT_BORDERSTYLECHANGED] as EventHandler;
            if (eh != null) {
                 eh(this, e);
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnCaptionVisibleChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnCaptionVisibleChanged(EventArgs e) {
            EventHandler eh = Events[EVENT_CAPTIONVISIBLECHANGED] as EventHandler;
            if (eh != null) {
                 eh(this, e);
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnCurrentCellChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnCurrentCellChanged(EventArgs e) {
            EventHandler eh = Events[EVENT_CURRENTCELLCHANGED] as EventHandler;
            if (eh != null) {
                 eh(this, e);
            }
        }

        /*
        /// <summary>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.DataGrid.ColumnHeaderClick'/> event.
        ///    </para>
        /// </summary>
        /// <param name='e'>
        ///    An <see cref='System.EventArgs'/> that contains the event data.
        /// </param>
        /// <remarks>
        ///    <para>
        ///       Raising an event invokes the event-handling method through a delegate. For an
        ///       overview, see <see topic='cpconProvidingEventFunctionality'/>.
        ///    </para>
        /// <see langword='Notes to Inheritors '/>When overriding <see cref='System.Windows.Forms.DataGrid.OnColumnHeaderClick'/> in an 
        ///    derived class, be sure to call the base class's <see cref='System.Windows.Forms.DataGrid.OnColumnHeaderClick'/> method.
        /// </remarks>
        protected void OnColumnHeaderClick(EventArgs e) {
            RaiseEvent(EVENT_COLUMNHEADERCLICK, e);
        }
        */

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnFlatModeChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnFlatModeChanged(EventArgs e) {
            EventHandler eh = Events[EVENT_FLATMODECHANGED] as EventHandler;
            if (eh != null) {
                 eh(this, e);
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnBackgroundColorChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnBackgroundColorChanged(EventArgs e) {
            EventHandler eh = Events[EVENT_BACKGROUNDCOLORCHANGED] as EventHandler;
            if (eh != null) {
                 eh(this, e);
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnAllowNavigationChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnAllowNavigationChanged(EventArgs e) {
            EventHandler eh = Events[EVENT_ALLOWNAVIGATIONCHANGED] as EventHandler;
            if (eh != null) {
                 eh(this, e);
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnParentRowsVisibleChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnParentRowsVisibleChanged(EventArgs e) {
            EventHandler eh = Events[EVENT_PARENTROWSVISIBLECHANGED] as EventHandler;
            if (eh != null) {
                 eh(this, e);
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnParentRowsLabelStyleChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnParentRowsLabelStyleChanged(EventArgs e) {
            EventHandler eh = Events[EVENT_PARENTROWSLABELSTYLECHANGED] as EventHandler;
            if (eh != null) {
                 eh(this, e);
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnReadOnlyChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnReadOnlyChanged(EventArgs e) {
            EventHandler eh = Events[EVENT_READONLYCHANGED] as EventHandler;
            if (eh != null) {
                 eh(this, e);
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnNavigate"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.DataGrid.Navigate'/>
        ///       event.
        ///    </para>
        /// </devdoc>
        protected void OnNavigate(NavigateEventArgs e) {
            if (onNavigate != null)
                onNavigate(this, e);
        }

        /*
        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnNodeClick"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.DataGrid.ColumnResize'/> event.
        ///    </para>
        /// </devdoc>
        protected void OnColumnResize(EventArgs e) {
            RaiseEvent(EVENT_COLUMNRESIZE, e);
        }

        internal void OnLinkClick(EventArgs e) {
            RaiseEvent(EVENT_LINKCLICKED, e);
        }
        */

        internal void OnNodeClick(EventArgs e) {
            // if we expanded/collapsed the RelationshipRow
            // then we need to layout the vertical scroll bar
            //
            PerformLayout();


            // also, we need to let the hosted edit control that its
            // boundaries possibly changed. do this with a call to Edit()
            // do this only if the firstVisibleColumn is the editColumn
            //
            GridColumnStylesCollection columns = this.myGridTable.GridColumnStyles;
            if (firstVisibleCol > -1 && firstVisibleCol < columns.Count && columns[firstVisibleCol] == editColumn)
                Edit();

            // Raise the event for the event listeners
            EventHandler handler = (EventHandler)Events[EVENT_NODECLICKED];
            if (handler != null) {
                handler(this, e);
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnRowHeaderClick"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.DataGrid.RowHeaderClick'/> event.</para>
        /// </devdoc>
        protected void OnRowHeaderClick(EventArgs e) {
            if (onRowHeaderClick != null) 
                onRowHeaderClick(this, e);
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnScroll"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.DataGrid.Scroll'/> event.
        ///    </para>
        /// </devdoc>
        protected void OnScroll(EventArgs e) {
            // reset the toolTip information
            if (ToolTipProvider != null)
                ResetToolTip();

            EventHandler handler = (EventHandler)Events[EVENT_SCROLL];
            if (handler != null) {
                handler(this, e);
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.GridHScrolled"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Listens
        ///       for the horizontal scrollbar's scroll
        ///       event.
        ///    </para>
        /// </devdoc>
        protected virtual void GridHScrolled(object sender, ScrollEventArgs se) {
            if (!Enabled)
                return;
            if (DataSource == null) {
                Debug.Fail("Horizontal Scrollbar should be disabled without a DataSource.");
                return;
            }

            gridState[GRIDSTATE_isScrolling] = true;

#if DEBUG

            Debug.WriteLineIf(CompModSwitches.DataGridScrolling.TraceVerbose, "DataGridScrolling: in GridHScrolled: the scroll event type:");
            switch (se.Type)
            {
            case ScrollEventType.SmallIncrement:
                Debug.WriteLineIf(CompModSwitches.DataGridScrolling.TraceVerbose, "small increment");
                break;
            case ScrollEventType.SmallDecrement:
                Debug.WriteLineIf(CompModSwitches.DataGridScrolling.TraceVerbose, "small decrement");
                break;
            case ScrollEventType.LargeIncrement:
                Debug.WriteLineIf(CompModSwitches.DataGridScrolling.TraceVerbose, "Large decrement");
                break;
            case ScrollEventType.LargeDecrement:
                Debug.WriteLineIf(CompModSwitches.DataGridScrolling.TraceVerbose, "small decrement");
                break;
            case ScrollEventType.ThumbPosition:
                Debug.WriteLineIf(CompModSwitches.DataGridScrolling.TraceVerbose, "Thumb Position");
                break;
            case ScrollEventType.ThumbTrack:
                Debug.WriteLineIf(CompModSwitches.DataGridScrolling.TraceVerbose, "Thumb Track");
                break;
            case ScrollEventType.First:
                Debug.WriteLineIf(CompModSwitches.DataGridScrolling.TraceVerbose, "First");
                break;
            case ScrollEventType.Last:
                Debug.WriteLineIf(CompModSwitches.DataGridScrolling.TraceVerbose, "Last");
                break;
            case ScrollEventType.EndScroll:
                Debug.WriteLineIf(CompModSwitches.DataGridScrolling.TraceVerbose, "EndScroll");
                break;
            }

#endif // DEBUG

            if (se.Type == ScrollEventType.SmallIncrement ||
                se.Type == ScrollEventType.SmallDecrement)
            {
                int dCols = (se.Type == ScrollEventType.SmallIncrement)? 1:-1;
                ScrollRight(dCols);
                se.NewValue = HorizontalOffset;
            }
            else if (se.Type != ScrollEventType.EndScroll)
            {
                HorizontalOffset = se.NewValue;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.GridVScrolled"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Listens
        ///       for the vertical scrollbar's scroll event.
        ///    </para>
        /// </devdoc>
        protected virtual void GridVScrolled(object sender, ScrollEventArgs se) {
            if (!Enabled)
                return;
            if (DataSource == null) {
                Debug.Fail("Vertical Scrollbar should be disabled without a DataSource.");
                return;
            }

            gridState[GRIDSTATE_isScrolling] = true;

            se.NewValue = Math.Min(se.NewValue, DataGridRowsLength - numTotallyVisibleRows);
            int dRows = se.NewValue - firstVisibleRow;
            ScrollDown(dRows);
        }

        private void HandleEndCurrentEdit() {
            int currentRowSaved = currentRow;
            int currentColSaved = currentCol;
            try {
                listManager.EndCurrentEdit();
            } catch (Exception e) {
                DialogResult result = MessageBox.Show(SR.GetString(SR.DataGridPushedIncorrectValueIntoColumn, e.Message), SR.GetString(SR.DataGridErrorMessageBoxCaption), MessageBoxButtons.YesNo);
                if (result == DialogResult.Yes) {
                    currentRow = currentRowSaved;
                    currentCol = currentColSaved;
                    Debug.Assert(currentRow == ListManager.Position || listManager.Position == -1, "the position in the list manager (" + ListManager.Position + ") is out of sync with the currentRow (" + currentRow + ")" + " and the exception is " + e.ToString());
                    // also, make sure that we get the row selector on the currentrow, too
                    InvalidateRowHeader(currentRow);
                    Edit();
                } else {
                    // if the user committed a row that used to be addNewRow and the backEnd rejects it, 
                    // and then it tries to navigate down then we should stay in the addNewRow
                    // in this particular scenario, CancelCurrentEdit will cause the last row to be deleted,
                    // and this will ultimately call InvalidateRow w/ a row number larger than the number of rows
                    // so set the currentRow here:
                    Debug.Assert(result == DialogResult.No, "we only put cancel and ok on the error message box");
                    this.listManager.PositionChanged -= positionChangedHandler;
                    this.listManager.CancelCurrentEdit();
                    this.listManager.Position = currentRow;
                    this.listManager.PositionChanged += positionChangedHandler;
                }
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnBackButtonClicked"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Listens
        ///       for the caption's back button clicked event.
        ///    </para>
        /// </devdoc>
        protected void OnBackButtonClicked(object sender, EventArgs e) {
            NavigateBack();

            EventHandler handler = (EventHandler)Events[EVENT_BACKBUTTONCLICK];
            if (handler != null) handler(this,e);
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnBackColorChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnBackColorChanged(EventArgs e) {
            backBrush = new SolidBrush(BackColor);
            Invalidate();
            
            base.OnBackColorChanged(e);
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnBindingContextChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnBindingContextChanged(EventArgs e) {
            if (this.DataSource != null && !gridState[GRIDSTATE_inSetListManager])
                try {
                    Set_ListManager(this.DataSource, this.DataMember, true, false);     // we do not want to create columns
                                                                                        // if the columns are already created
                                                                                        // the grid should not rely on OnBindingContextChanged
                                                                                        // to create columns.
                } catch {
                    // at runtime we will rethrow the exception
                    if (this.Site == null || !this.Site.DesignMode)
                        throw;

                    MessageBox.Show(SR.GetString(SR.DataGridExceptionInPaint));
                    BeginUpdateInternal();

                    parentRows.Clear();
                    caption.BackButtonActive = caption.DownButtonActive = caption.BackButtonVisible = false;
                    caption.SetDownButtonDirection(!layout.ParentRowsVisible);
                    originalState = null;

                    Set_ListManager(null, String.Empty, true);
                    EndUpdateInternal();
            }
            base.OnBindingContextChanged(e);
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnDataSourceChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnDataSourceChanged(EventArgs e) {
            EventHandler eh = Events[EVENT_DATASOURCECHANGED] as EventHandler;
            if (eh != null) {
                 eh(this, e);
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnShowParentDetailsButtonClicked"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Listens for
        ///       the caption's down button clicked event.
        ///    </para>
        /// </devdoc>
        protected void OnShowParentDetailsButtonClicked(object sender, EventArgs e) {
            // we need to fire the ParentRowsVisibleChanged event
            // and the ParentRowsVisible property just calls SetParentRowsVisibility and
            // then fires the event.
            this.ParentRowsVisible = !caption.ToggleDownButtonDirection();

            EventHandler handler = (EventHandler)Events[EVENT_DOWNBUTTONCLICK];
            if (handler != null) handler(this,e);
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnForeColorChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnForeColorChanged(EventArgs e) {
            foreBrush = new SolidBrush(ForeColor);
            Invalidate();
            
            base.OnForeColorChanged(e);
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnFontChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnFontChanged(EventArgs e) {
            // let the caption know about the event changed
            //
            this.Caption.OnGridFontChanged();
            RecalculateFonts();
            RecreateDataGridRows();
            // get all the rows in the parentRows stack, and modify their height
            if (originalState != null) {
                Debug.Assert(!parentRows.IsEmpty(), "if the originalState is not null, then parentRows contains at least one row");
                Stack parentStack = new Stack();
                // this is a huge performance hit: 
                // everytime we get/put something from/to
                // the parentRows, the buttons in the dataGridCaption
                // are invalidated
                while (!parentRows.IsEmpty()) {
                    DataGridState dgs = parentRows.PopTop();
                    int rowCount = dgs.DataGridRowsLength;
                    for(int i = 0; i < rowCount; i++) {
                        // performance hit: this will cause to invalidate a bunch of
                        // stuff
                        dgs.DataGridRows[i].Height = dgs.DataGridRows[i].MinimumRowHeight(dgs.GridColumnStyles);
                    }
                    parentStack.Push(dgs);
                }

                while(parentStack.Count != 0) {
                    parentRows.AddParent((DataGridState)parentStack.Pop());
                }
            }
            
            base.OnFontChanged(e);
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnPaintBackground"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.Control.PaintBackground'/>
        ///       event.
        ///    </para>
        /// </devdoc>
        protected override void OnPaintBackground(PaintEventArgs ebe) {
            // null body
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnLayout"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.Control.Layout'/> event which
        ///       repositions controls
        ///       and updates scroll bars.
        ///    </para>
        /// </devdoc>
        protected override void OnLayout(LayoutEventArgs levent) {
            // if we get a OnLayout event while the editControl changes, then just
            // ignore it
            //
            if (gridState[GRIDSTATE_editControlChanging]) return;

            Debug.WriteLineIf(CompModSwitches.DataGridLayout.TraceVerbose, "DataGridLayout: OnLayout");
            base.OnLayout(levent);

            gridState[GRIDSTATE_canFocus] = false;
            try {
                if (IsHandleCreated) {
                    if (layout.ParentRowsVisible)
                        parentRows.OnLayout();

                    // reset the toolTip information
                    if (ToolTipProvider != null)
                        ResetToolTip();

                    ComputeLayout();
                }
            } finally {
                gridState[GRIDSTATE_canFocus] = true;
            }

        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnHandleCreated"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.Control.CreateHandle'/>
        ///       event.
        ///    </para>
        /// </devdoc>
        protected override void OnHandleCreated(EventArgs e) {
            base.OnHandleCreated(e);

            // toolTipping
            toolTipProvider = new DataGridToolTip(this);
            toolTipProvider.CreateToolTipHandle();
            toolTipId = 0;

            PerformLayout();
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnHandleDestroyed"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.Control.DestroyHandle'/>
        ///       event.
        ///    </para>
        /// </devdoc>
        protected override void OnHandleDestroyed(EventArgs e)
        {
            base.OnHandleDestroyed(e);

            // toolTipping
            toolTipProvider.Destroy();
            toolTipProvider = null;
            toolTipId = 0;
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnEnter"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.Enter'/>
        /// event.</para>
        /// </devdoc>
        protected override void OnEnter(EventArgs e) {
            if (gridState[GRIDSTATE_canFocus] && !gridState[GRIDSTATE_editControlChanging]) {
                if (Bound)
                {
                    Edit();
                }
                base.OnEnter(e);
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnLeave"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.Leave'/>
        /// event.</para>
        /// </devdoc>
        protected override void OnLeave(EventArgs e) {
            if (this.Disposing || this.IsDisposed || !IsHandleCreated)
                OnLeave_Grid();
            else if (!this.gridState[GRIDSTATE_editControlChanging] && IsHandleCreated)
                BeginInvoke(new MethodInvoker(OnLeave_Grid));
            base.OnLeave(e);
        }

        private void OnLeave_Grid() {
            gridState[GRIDSTATE_canFocus] = false;
            try {
                EndEdit();
                if (this.listManager != null && !this.gridState[GRIDSTATE_editControlChanging]) {
                    if (gridState[GRIDSTATE_inAddNewRow]) {
                        // if the user did not type anything
                        // in the addNewRow, then cancel the currentedit
                        this.listManager.CancelCurrentEdit();
                        // set the addNewRow back
                        DataGridRow[] localGridRows = this.DataGridRows;
                        localGridRows[DataGridRowsLength - 1] = new DataGridAddNewRow(this, this.myGridTable, DataGridRowsLength-1);
                        SetDataGridRows(localGridRows, DataGridRowsLength);
                    } else {
                        // this.listManager.EndCurrentEdit();
                        HandleEndCurrentEdit();
                    }
                }
            } finally {
                gridState[GRIDSTATE_canFocus] = true;
                // inAddNewRow should be set to false if the control was
                // not changing
                if (!this.gridState[GRIDSTATE_editControlChanging])
                    gridState[GRIDSTATE_inAddNewRow] = false;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnKeyDown"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.Control.KeyDown'/>
        ///       event.
        ///    </para>
        /// </devdoc>
        protected override void OnKeyDown(KeyEventArgs ke) {
            Debug.WriteLineIf(CompModSwitches.DataGridKeys.TraceVerbose, "DataGridKeys: OnKeyDown ");
            base.OnKeyDown(ke);
            ProcessGridKey(ke);
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnKeyPress"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.KeyPress'/> event.</para>
        /// </devdoc>
        protected override void OnKeyPress(KeyPressEventArgs kpe) {
            Debug.WriteLineIf(CompModSwitches.DataGridKeys.TraceVerbose, "DataGridKeys: OnKeyPress " + TypeDescriptor.GetConverter(typeof(Keys)).ConvertToString(kpe.KeyChar));

            base.OnKeyPress(kpe);
            GridColumnStylesCollection coll = this.myGridTable.GridColumnStyles;
            if (coll != null && currentCol > 0 && currentCol < coll.Count) {
                if (!coll[currentCol].ReadOnly)
                    if (kpe.KeyChar > 32) {
                        Edit(new string(new char [] { (char) kpe.KeyChar}));
                    }
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnMouseDown"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.MouseDown'/> event.</para>
        /// </devdoc>
        protected override void OnMouseDown(MouseEventArgs e) {
            base.OnMouseDown(e);
            
            gridState[GRIDSTATE_childLinkFocused] = false;
            gridState[GRIDSTATE_dragging] = false;
            if (listManager == null)
                return;

            HitTestInfo location    = HitTest(e.X, e.Y);
            Keys   nModifier     = ModifierKeys;
            bool      isControlDown = (nModifier & Keys.Control) == Keys.Control && (nModifier & Keys.Alt) == 0;
            bool      isShiftDown   = (nModifier & Keys.Shift)  == Keys.Shift;

            // Only left clicks for now
            if (e.Button != MouseButtons.Left)
                return;

            // Check column resize
            if (location.type == HitTestType.ColumnResize) {
                if (e.Clicks > 1) {
                    ColAutoResize(location.col);
                }
                else
                    ColResizeBegin(e, location.col);
                return;
            }

            // Check row resize
            if (location.type == HitTestType.RowResize)
            {
                if (e.Clicks > 1)
                {
                    RowAutoResize(location.row);
                }
                else
                {
                    RowResizeBegin(e, location.row);
                }
                return;
            }

            // Check column headers
            if (location.type == HitTestType.ColumnHeader) {
                trackColumnHeader = this.myGridTable.GridColumnStyles[location.col].PropertyDescriptor;
                return;
            }

            if (location.type == HitTestType.Caption) {
                Rectangle captionRect = layout.Caption;
                caption.MouseDown(e.X - captionRect.X, e.Y - captionRect.Y);
                return;
            }

            if (layout.Data.Contains(e.X, e.Y) || layout.RowHeaders.Contains(e.X, e.Y)) {
                // Check with the row underneath the mouse
                int row = GetRowFromY(e.Y);
                if (row > -1) {
                    Point p = NormalizeToRow(e.X, e.Y, row);
                    DataGridRow[] localGridRows = DataGridRows;
                    if (localGridRows[row].OnMouseDown(p.X, p.Y,
                                                       layout.RowHeaders,
                                                       isRightToLeft())) {
                        CommitEdit();

                        // possibly this was the last row, so then the link may not
                        // be visible. make it visible, by making the row visible.
                        // how can we be sure that the user did not click
                        // on a relationship and navigated to the child rows?
                        // check if the row is expanded: if the row is expanded, then the user clicked
                        // on the node. when we navigate to child rows the rows are recreated
                        // and are initially collapsed
                        localGridRows = this.DataGridRows;
                        if (row < DataGridRowsLength && (localGridRows[row] is DataGridRelationshipRow) && ((DataGridRelationshipRow)localGridRows[row]).Expanded)
                            EnsureVisible(row, 0);

                        // show the edit box
                        //
                        Edit();
                        return;
                    }
                }
            }

            // Check row headers
            //
            if (location.type == HitTestType.RowHeader) {
                EndEdit();
                if (!(DataGridRows[location.row] is DataGridAddNewRow))
                    CurrentCell = new DataGridCell(location.row, currentCol);
                if (isControlDown) {
                    if (IsSelected(location.row))
                        UnSelect(location.row);
                    else
                        Select(location.row);
                }
                else {
                    if (lastRowSelected == -1 || !isShiftDown)
                    {
                        ResetSelection();
                        Select(location.row);
                    }
                    else
                    {
                        int lowerRow = Math.Min(lastRowSelected, location.row);
                        int upperRow = Math.Max(lastRowSelected, location.row);

                        // we need to reset the old SelectedRows.
                        // ResetSelection() will also reset lastRowSelected, so we 
                        // need to save it
                        int saveLastRowSelected = lastRowSelected;
                        ResetSelection();
                        lastRowSelected = saveLastRowSelected;

                        DataGridRow[] rows = DataGridRows;
                        for (int i = lowerRow; i <= upperRow; i++)
                        {
                            rows[i].Selected = true;
                            numSelectedRows ++;
                        }

                        // hide the edit box:
                        //
                        EndEdit();
                        return;
                    }
                }

                lastRowSelected = location.row;
                // OnRowHeaderClick(EventArgs.Empty);
                return;
            }

            // Check parentRows
            //
            if (location.type == HitTestType.ParentRows)
            {
                EndEdit();
                parentRows.OnMouseDown(e.X, e.Y, isRightToLeft());
            }

            // Check cell clicks
            //
            if (location.type == HitTestType.Cell) {
                if (this.myGridTable.GridColumnStyles[location.col].MouseDown(location.row, e.X, e.Y))
                    return;
                DataGridCell target = new DataGridCell(location.row, location.col);
                if (policy.AllowEdit && CurrentCell.Equals(target)) {
                    ResetSelection();
                    //
                    // what if only a part of the current cell is visible?
                    //
                    EnsureVisible(currentRow, currentCol);
                    Edit();
                }
                else {
                    ResetSelection();
                    CurrentCell = target;
                }
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnMouseLeave"]/*' />
        /// <devdoc>
        /// <para>Creates the <see cref='System.Windows.Forms.Control.MouseLeave'/>
        /// event.</para>
        /// </devdoc>
        protected override void OnMouseLeave(EventArgs e) {
            base.OnMouseLeave(e);
            if (oldRow != -1) {
                DataGridRow[] localGridRows = DataGridRows;
                localGridRows[oldRow].OnMouseLeft(layout.RowHeaders, isRightToLeft());
            }
            if (gridState[GRIDSTATE_overCaption]) {
                caption.MouseLeft();
            }
            // when the mouse leaves the grid control, reset the cursor to arrow
            Cursor = null;
        }

        internal void TextBoxOnMouseWheel(MouseEventArgs e) {
            this.OnMouseWheel(e);
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnMouseMove"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.MouseMove'/>
        /// event.</para>
        /// </devdoc>
        protected override void OnMouseMove(MouseEventArgs e) {
            base.OnMouseMove(e);
            if (listManager == null)
                return;

            HitTestInfo location = HitTest(e.X, e.Y);

            bool alignToRight = isRightToLeft();

            // We need to give UI feedback when the user is resizing a column
            if (gridState[GRIDSTATE_trackColResize]) {
                ColResizeMove(e);
            }

            if (gridState[GRIDSTATE_trackRowResize])
            {
                RowResizeMove(e);
            }

            if (gridState[GRIDSTATE_trackColResize] || location.type == HitTestType.ColumnResize)
            {
                Cursor = Cursors.SizeWE;
                return;
            }
            else if ( gridState[GRIDSTATE_trackRowResize] || location.type == HitTestType.RowResize)
            {
                Cursor = Cursors.SizeNS;
                return;
            }
            else
            {
                Cursor = null;
            }

            if ((layout.Data.Contains(e.X, e.Y)
                || (layout.RowHeadersVisible && layout.RowHeaders.Contains(e.X, e.Y)))) {
                // && (isNavigating || isEditing)) {
                DataGridRow[] localGridRows = DataGridRows;
                // If we are over a row, let it know about the mouse move.
                int rowOver = GetRowFromY(e.Y);
                // set the dragging bit:
                if (lastRowSelected != -1 && !gridState[GRIDSTATE_dragging]) {
                    int topRow = GetRowTop(lastRowSelected);
                    int bottomRow = topRow + localGridRows[lastRowSelected].Height;
                    int dragHeight = SystemInformation.DragSize.Height;
                    gridState[GRIDSTATE_dragging] = ((e.Y - topRow < dragHeight && topRow - e.Y < dragHeight) || (e.Y - bottomRow < dragHeight && bottomRow - e.Y < dragHeight));
                }
                if (rowOver > -1) {
                    Point p = NormalizeToRow(e.X, e.Y, rowOver);
                    if (!localGridRows[rowOver].OnMouseMove(p.X, p.Y, layout.RowHeaders, alignToRight) && gridState[GRIDSTATE_dragging]) {
                        // if the row did not use this, see if selection can use it
                        MouseButtons mouse = MouseButtons;
                        if (lastRowSelected != -1 && (mouse & MouseButtons.Left) == MouseButtons.Left
                            && !(((Control.ModifierKeys & Keys.Control) == Keys.Control) && (Control.ModifierKeys & Keys.Alt) == 0)){
                            // ResetSelection() will reset the lastRowSelected too
                            //
                            int saveLastRowSelected = lastRowSelected;
                            ResetSelection();
                            lastRowSelected = saveLastRowSelected;

                            int lowerRow = Math.Min(lastRowSelected, rowOver);
                            int upperRow = Math.Max(lastRowSelected, rowOver);

                            DataGridRow[] rows = DataGridRows;
                            for (int i = lowerRow; i <= upperRow; i++)
                            {
                                rows[i].Selected = true;
                                numSelectedRows ++;
                            }
                        }
                    }
                }

                if (oldRow != rowOver && oldRow != -1) {
                    localGridRows[oldRow].OnMouseLeft(layout.RowHeaders, alignToRight);
                }
                oldRow = rowOver;
            }

            // check parentRows
            //
            if (location.type == HitTestType.ParentRows)
            {
                if (parentRows != null)
                {
                    parentRows.OnMouseMove(e.X, e.Y);
                }
            }

            if (location.type == HitTestType.Caption) {
                gridState[GRIDSTATE_overCaption] = true;
                Rectangle captionRect = layout.Caption;
                caption.MouseOver(e.X - captionRect.X, e.Y - captionRect.Y);
                return;
            }
            else {
                if (gridState[GRIDSTATE_overCaption]) {
                    gridState[GRIDSTATE_overCaption] = false;
                    caption.MouseLeft();
                }
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnMouseUp"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.MouseUp'/> event.</para>
        /// </devdoc>
        protected override void OnMouseUp(MouseEventArgs e) {
            base.OnMouseUp(e);
            gridState[GRIDSTATE_dragging] = false;
            if (listManager == null || myGridTable == null)
                return;
            if (gridState[GRIDSTATE_trackColResize]) {
                ColResizeEnd(e);
            }

            if (gridState[GRIDSTATE_trackRowResize])
            {
                RowResizeEnd(e);
            }

            gridState[GRIDSTATE_trackColResize] = false;
            gridState[GRIDSTATE_trackRowResize] = false;

            HitTestInfo ci = HitTest(e.X, e.Y);
            if ((ci.type & HitTestType.Caption) == HitTestType.Caption) {
                caption.MouseUp(e.X, e.Y);
            }

            // Check column headers
            if (ci.type == HitTestType.ColumnHeader) {
                PropertyDescriptor prop = this.myGridTable.GridColumnStyles[ci.col].PropertyDescriptor;
                if (prop == trackColumnHeader) {
                    ColumnHeaderClicked(trackColumnHeader);
                }
            }

            trackColumnHeader = null;
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnMouseWheel"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.MouseWheel'/> event.</para>
        /// </devdoc>
        protected override void OnMouseWheel(MouseEventArgs e) {
            base.OnMouseWheel(e);
            bool wheelingDown = true;
            if ((ModifierKeys & Keys.Control) != 0)
                wheelingDown = false;

            if (listManager == null || myGridTable == null)
                return;
            ScrollBar sb = wheelingDown ? vertScrollBar : horizScrollBar;
            if (!sb.Visible)
                return;

            // so we scroll. we have to know this, cause otherwise we will call EndEdit
            // and that would be wrong.
            gridState[GRIDSTATE_isScrolling] = true;
            wheelDelta += e.Delta;
            float movePerc = (float)wheelDelta / (float)NativeMethods.WHEEL_DELTA;
            int move = (int)((float)SystemInformation.MouseWheelScrollLines * movePerc);
            if (move != 0) {
                wheelDelta = 0;
                Debug.WriteLineIf(CompModSwitches.DataGridLayout.TraceVerbose, "DataGridLayout: OnMouseWheel move="+move.ToString());
                if (wheelingDown) {
                    int newRow = firstVisibleRow - move;
                    newRow = Math.Max(0, Math.Min(newRow, DataGridRowsLength - numTotallyVisibleRows));
                    ScrollDown(newRow - firstVisibleRow);
                }
                else {
                    int newValue = horizScrollBar.Value + (move < 0 ? 1 : -1) * horizScrollBar.LargeChange;
                    HorizontalOffset = newValue;
                }
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnPaint"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.Paint'/>
        /// event.</para>
        /// </devdoc>
        protected override void OnPaint(PaintEventArgs pe) {
            try {
                CheckHierarchyState();

                if (this.layout.dirty)
                    ComputeLayout();

                Graphics g = pe.Graphics;

                Region clipRegion = g.Clip;
                if (layout.CaptionVisible)
                    caption.Paint(g, layout.Caption, isRightToLeft());

                if (layout.ParentRowsVisible) {
                    Debug.WriteLineIf(CompModSwitches.DataGridParents.TraceVerbose, "DataGridParents: Painting ParentRows " + layout.ParentRows.ToString());
                    g.FillRectangle(SystemBrushes.AppWorkspace, layout.ParentRows);
                    parentRows.Paint(g, layout.ParentRows, isRightToLeft());
                }

                Rectangle gridRect = layout.Data;
                if (layout.RowHeadersVisible)
                    gridRect = Rectangle.Union(gridRect, layout.RowHeaders);
                if (layout.ColumnHeadersVisible)
                    gridRect = Rectangle.Union(gridRect, layout.ColumnHeaders);

                g.SetClip(gridRect);
                PaintGrid(g, gridRect);
                g.Clip = clipRegion;
                clipRegion.Dispose();
                PaintBorder(g, layout.ClientRectangle);

                g.FillRectangle(DefaultHeaderBackBrush, layout.ResizeBoxRect);

                base.OnPaint(pe); // raise paint event
            } catch (Exception) {
                // at runtime we will rethrow the exception
                if (this.Site == null || !this.Site.DesignMode)
                    throw;
                gridState[GRIDSTATE_exceptionInPaint] = true;
                try {
                    MessageBox.Show(SR.GetString(SR.DataGridExceptionInPaint));
                    BeginUpdateInternal();

                    parentRows.Clear();
                    caption.BackButtonActive = caption.DownButtonActive = caption.BackButtonVisible = false;
                    caption.SetDownButtonDirection(!layout.ParentRowsVisible);
                    originalState = null;

                    Set_ListManager(null, String.Empty, true);
                } finally {
                    gridState[GRIDSTATE_exceptionInPaint] = false;
                    EndUpdateInternal();
                }
                
            }
        }

        // Since Win32 only invalidates the area that gets uncovered,
        // we have to manually invalidate the old border area
        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.OnResize"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.Resize'/> event.</para>
        /// </devdoc>
        protected override void OnResize(EventArgs e) {
            Debug.WriteLineIf(CompModSwitches.DataGridLayout.TraceVerbose, "DataGridLayout: OnResize");

            if (layout.CaptionVisible)
                Invalidate(layout.Caption);
            if (layout.ParentRowsVisible)
                parentRows.OnResize(layout.ParentRows);

            int borderWidth = BorderWidth;
            Rectangle right;
            Rectangle bottom;
            Rectangle oldClientRectangle = layout.ClientRectangle;

            right = new Rectangle(oldClientRectangle.X + oldClientRectangle.Width - borderWidth,
                                  oldClientRectangle.Y,
                                  borderWidth,
                                  oldClientRectangle.Height);
            bottom = new Rectangle(oldClientRectangle.X,
                                   oldClientRectangle.Y + oldClientRectangle.Height - borderWidth,
                                   oldClientRectangle.Width,
                                   borderWidth);

            Rectangle newClientRectangle = this.ClientRectangle;
            if (newClientRectangle.Width != oldClientRectangle.Width) {
                Invalidate(right);
                right = new Rectangle(newClientRectangle.X + newClientRectangle.Width - borderWidth,
                                      newClientRectangle.Y,
                                      borderWidth,
                                      newClientRectangle.Height);
                Invalidate(right);
            }
            if (newClientRectangle.Height != oldClientRectangle.Height) {
                Invalidate(bottom);
                bottom = new Rectangle(newClientRectangle.X,
                                       newClientRectangle.Y + newClientRectangle.Height - borderWidth,
                                       newClientRectangle.Width,
                                       borderWidth);
                Invalidate(bottom);
            }

            //also, invalidate the ResizeBoxRect
            if (!this.layout.ResizeBoxRect.IsEmpty)
                Invalidate(layout.ResizeBoxRect);

            layout.ClientRectangle = newClientRectangle;

            int oldFirstVisibleRow = firstVisibleRow;
            base.OnResize(e);
            if (isRightToLeft() || oldFirstVisibleRow != firstVisibleRow)
                Invalidate();
        }

        internal void OnRowHeightChanged(DataGridRow row) {
            ClearRegionCache();
            int cy = GetRowTop(row.RowNumber);
            if (cy > 0) {
                Rectangle refresh = new Rectangle();
                refresh.Y = cy;
                refresh.X = layout.Inside.X;
                refresh.Width = layout.Inside.Width;
                refresh.Height = layout.Inside.Bottom - cy;
                Invalidate(refresh);
            }
        }

        internal void ParentRowsDataChanged() {
            Debug.Assert(originalState != null, "how can we get a list changed event from another listmanager/list while not navigating");

            // do the reset work that is done in SetDataBindings, set_DataSource, set_DataMember;
            parentRows.Clear();
            caption.BackButtonActive = caption.DownButtonActive = caption.BackButtonVisible = false;
            caption.SetDownButtonDirection(!layout.ParentRowsVisible);
            object dSource = originalState.DataSource;
            string dMember = originalState.DataMember;
            // we don't need to set the GRIDSTATE_metaDataChanged bit, cause
            // the listManager from the originalState should be different from the current listManager 
            //
            // set the originalState to null so that Set_ListManager knows that 
            // it has to unhook the MetaDataChanged events
            originalState = null;
            Set_ListManager(dSource, dMember, true);
        }


        // =------------------------------------------------------------------
        // =        Methods
        // =------------------------------------------------------------------

        private void AbortEdit() {
            Debug.WriteLineIf(CompModSwitches.DataGridEditing.TraceVerbose, "DataGridEditing: \t! AbortEdit");
            Debug.Assert(gridState[GRIDSTATE_isEditing], "Can't abort an edit that is not happening!");

            // the same rules from editColumn.OnEdit
            // while changing the editControl's visibility, do not 
            // PerformLayout on the entire DataGrid
            gridState[GRIDSTATE_editControlChanging] = true;

            editColumn.Abort(editRow.RowNumber);

            // reset the editControl flag:
            gridState[GRIDSTATE_editControlChanging] = false;

            gridState[GRIDSTATE_isEditing] = false;
            editRow = null;
            editColumn = null;
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.Navigate"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the user navigates to a new table.</para>
        /// </devdoc>
        [SRCategory(SR.CatAction), SRDescription(SR.DataGridNavigateEventDescr)]
        public event NavigateEventHandler Navigate {
            add {
                onNavigate += value;
            }
            remove {
                onNavigate -= value;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.RowHeaderClick"]/*' />
        /// <devdoc>
        ///    <para>Occurs when a row header is clicked.</para>
        /// </devdoc>
        protected event EventHandler RowHeaderClick {
            add {
                onRowHeaderClick += value;
            }
            remove {
                onRowHeaderClick -= value;
            }
        }

        /// <devdoc>
        ///    <para>
        ///       Adds an event handler for the 'System.Windows.Forms.DataGrid.OnNodeClick'
        ///       event.
        ///    </para>
        /// </devdoc>
        [SRCategory(SR.CatAction), SRDescription(SR.DataGridNodeClickEventDescr)]
        internal event EventHandler NodeClick {
            add {
                Events.AddHandler(EVENT_NODECLICKED, value);
            }
            remove {
                Events.RemoveHandler(EVENT_NODECLICKED, value);
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.Scroll"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs when the user scrolls the <see cref='System.Windows.Forms.DataGrid'/> control.
        ///    </para>
        /// </devdoc>
        [SRCategory(SR.CatAction), SRDescription(SR.DataGridScrollEventDescr)]
        public event EventHandler Scroll {
            add {
                Events.AddHandler(EVENT_SCROLL, value);
            }
            remove {
                Events.RemoveHandler(EVENT_SCROLL, value);
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.Site"]/*' />
        public override ISite Site {
            get {
                return base.Site;
            }
            set {
                ISite temp = this.Site;
                base.Site = value;
                if (value != temp) {
                    // we should site the tables and the columns
                    // only when our site changes
                    SubObjectsSiteChange(false);
                    SubObjectsSiteChange(true);
                }
            }
        }

        internal void AddNewRow() {
            EnsureBound();
            ResetSelection();
            // EndEdit();
            UpdateListManager();
            gridState[GRIDSTATE_inListAddNew] = true;
            gridState[GRIDSTATE_inAddNewRow] = true;
            try {
                this.ListManager.AddNew();
            } catch (Exception e) {
                gridState[GRIDSTATE_inListAddNew] = false;
                gridState[GRIDSTATE_inAddNewRow] = false;
                PerformLayout();
                InvalidateInside();
                throw e;
            }
            gridState[GRIDSTATE_inListAddNew] = false;
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.BeginEdit"]/*' />
        /// <devdoc>
        ///    <para>Attempts to
        ///       put the grid into a state where editing is
        ///       allowed.</para>
        /// </devdoc>
        public bool BeginEdit(DataGridColumnStyle gridColumn, int rowNumber) {
            if (this.DataSource == null || this.myGridTable == null)
                return false;

            // We deny edit requests if we are already editing a cell.
            if (gridState[GRIDSTATE_isEditing])
                return false;
            else {
                int col = -1;
                if ((col = this.myGridTable.GridColumnStyles.IndexOf(gridColumn)) < 0)
                    return false;
                CurrentCell = new DataGridCell(rowNumber, col);
                ResetSelection();
                Edit();
                return true;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.BeginInit"]/*' />
        /// <devdoc>
        ///    <para>Specifies the beginning of the initialization code.</para>
        /// </devdoc>
        public void BeginInit() {
            if (inInit)
                throw new InvalidOperationException(SR.GetString(SR.DataGridBeginInit));
            inInit = true;
        }

        private Rectangle CalcRowResizeFeedbackRect(MouseEventArgs e) {
            Rectangle inside = layout.Data;
            Rectangle r = new Rectangle(inside.X, e.Y, inside.Width, 3);
            r.Y = Math.Min(inside.Bottom - 3, r.Y);
            r.Y = Math.Max(r.Y , 0);
            return r;
        }

        private Rectangle CalcColResizeFeedbackRect(MouseEventArgs e) {
            Rectangle inside = layout.Data;
            Rectangle r = new Rectangle(e.X, inside.Y, 3, inside.Height);
            r.X = Math.Min(inside.Right - 3, r.X);
            r.X = Math.Max(r.X , 0);
            return r;
        }

        private void CancelCursorUpdate() {
            Debug.WriteLineIf(CompModSwitches.DataGridCursor.TraceVerbose, "DataGridCursor: Requesting CancelEdit()");
            if (listManager != null) {
                EndEdit();
                listManager.CancelCurrentEdit();
            }
        }

        private void CheckHierarchyState() {
            if (checkHierarchy && this.ListManager != null && this.myGridTable != null) {
                if (myGridTable == null)
                    // there was nothing to check
                    return;

                for (int j = 0; j < myGridTable.GridColumnStyles.Count; j++) {
                    DataGridColumnStyle gridColumn = myGridTable.GridColumnStyles[j];
                }

                checkHierarchy = false;
            }
        }

        /// <devdoc>
        ///      The DataGrid caches an array of rectangular areas
        ///      which represent the area which scrolls left to right.
        ///      This method is invoked whenever the DataGrid's
        ///      scrollable regions change in such a way as to require
        ///      a re-recalculation.
        /// </devdoc>
        private void ClearRegionCache() {
            cachedScrollableRegion = null;
        }

        /// <devdoc>
        ///      Determines the best fit size for the given column.
        /// </devdoc>
        private void ColAutoResize(int col) {
            Debug.WriteLineIf(CompModSwitches.DataGridLayout.TraceVerbose, "DataGridLayout: ColAutoResize");
            EndEdit();
            CurrencyManager listManager = this.ListManager;
            if (listManager == null)
                return;

            int size;
            Graphics g = CreateGraphicsInternal();
            try {
                DataGridColumnStyle column = myGridTable.GridColumnStyles[col];
                string columnName = column.HeaderText;

                Font headerFont;
                if (this.myGridTable.IsDefault)
                    headerFont = this.HeaderFont;
                else
                    headerFont = this.myGridTable.HeaderFont;
                size = (int) g.MeasureString(columnName, headerFont).Width + layout.ColumnHeaders.Height + 1; // This is not a bug, the sort triangle's width is equal to it's height.
                int rowCount = listManager.Count;
                for (int row = 0; row < rowCount; ++row) {
                    object value = column.GetColumnValueAtRow(listManager, row);
                    int width = column.GetPreferredSize(g, value).Width;
                    if (width > size)
                        size = width;
                }

                if (column.Width != size) {
                    column.width = size;

                    // needed to refresh scrollbar properties
                    PerformLayout();

                    Rectangle rightArea = layout.Data;
                    if (layout.ColumnHeadersVisible)
                        rightArea = Rectangle.Union(rightArea, layout.ColumnHeaders);
                    int left = GetColBeg(col);
                    rightArea.Width -= rightArea.X - left;
                    rightArea.X = left;
                    Invalidate(rightArea);
                }
            }
            finally {
                g.Dispose();
            }
            // OnColumnResize(EventArgs.Empty);
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.Collapse"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Collapses child relations, if any exist for all rows, or for a
        ///       specified row.
        ///    </para>
        /// </devdoc>
        public void Collapse(int row) {
            SetRowExpansionState(row, false);
        }

        private void ColResizeBegin(MouseEventArgs e, int col) {
            Debug.WriteLineIf(CompModSwitches.DataGridLayout.TraceVerbose, "DataGridLayout: ColResizeBegin");
            Debug.Assert(myGridTable != null, "Column resizing operations can't be called when myGridTable == null.");

            int x = e.X;
            EndEdit();
            Rectangle clip = Rectangle.Union(layout.ColumnHeaders, layout.Data);
            if (isRightToLeft())
            {
                clip.Width = GetColBeg(col) - layout.Data.X - 2;
            }
            else
            {
                int leftEdge = GetColBeg(col);
                clip.X  = leftEdge + 3;
                clip.Width = layout.Data.X + layout.Data.Width - leftEdge - 2;
            }

            IntSecurity.AdjustCursorClip.Assert();
            try {
                CaptureInternal = true;
                Cursor.Clip  = RectangleToScreen(clip);
            }
            finally {
                CodeAccessPermission.RevertAssert();
            }
            gridState[GRIDSTATE_trackColResize] = true;
            trackColAnchor = x;
            trackColumn = col;

            DrawColSplitBar(e);
            lastSplitBar = e;
        }

        private void ColResizeMove(MouseEventArgs e) {
            if (lastSplitBar != null) {
                DrawColSplitBar(lastSplitBar);
                lastSplitBar = e;
            }
            DrawColSplitBar(e);
        }

        private void ColResizeEnd(MouseEventArgs e) {
            Debug.WriteLineIf(CompModSwitches.DataGridLayout.TraceVerbose, "DataGridLayout: ColResizeEnd");
            Debug.Assert(myGridTable != null, "Column resizing operations can't be called when myGridTable == null.");

            try {
                if (lastSplitBar != null) {
                    DrawColSplitBar(lastSplitBar);
                    lastSplitBar = null;
                }

                bool rightToLeft = isRightToLeft();

                int x = rightToLeft ? Math.Max(e.X, layout.Data.X) : Math.Min(e.X, layout.Data.Right + 1);
                int delta = x - GetColEnd(trackColumn);
                if (rightToLeft) delta = -delta;

                if (trackColAnchor != x && delta != 0) {
                    DataGridColumnStyle column = myGridTable.GridColumnStyles[trackColumn];
                    int proposed = column.Width + delta;
                    proposed = Math.Max(proposed, 3);
                    column.Width = proposed;

                    // needed to refresh scrollbar properties
                    PerformLayout();

                    Rectangle rightArea = Rectangle.Union(layout.ColumnHeaders, layout.Data);
                    int left = GetColBeg(trackColumn);
                    rightArea.Width -= rightToLeft ? rightArea.Right - left : left - rightArea.X;
                    rightArea.X = rightToLeft ? layout.Data.X : left;
                    Invalidate(rightArea);
                }
            }
            finally {
                Cursor.Clip = Rectangle.Empty;
                CaptureInternal = false;
            }
            // OnColumnResize(EventArgs.Empty);
        }

        private void MetaDataChanged() {
            // when we reset the Binding in the grid, we need to clear the parent rows.
            // the same goes for all the caption UI: reset it when the datasource changes.
            //
            parentRows.Clear();
            caption.BackButtonActive = caption.DownButtonActive = caption.BackButtonVisible = false;
            caption.SetDownButtonDirection(!layout.ParentRowsVisible);

            gridState[GRIDSTATE_metaDataChanged] = true;
            try {
                if (originalState != null) {
                    // set the originalState to null so that Set_ListManager knows that 
                    // it has to unhook the MetaDataChanged events
                    Set_ListManager(originalState.DataSource, originalState.DataMember, true);
                    originalState = null;
                } else {
                    Set_ListManager(this.DataSource, this.DataMember, true);
                }
            } finally {
                gridState[GRIDSTATE_metaDataChanged] = false;
            }
        }


        // =------------------------------------------------------------------
        // =        Functions to resize rows
        // =------------------------------------------------------------------

        // will autoResize "row"
        private void RowAutoResize(int row)
        {
            Debug.WriteLineIf(CompModSwitches.DataGridLayout.TraceVerbose, "DataGridLayout: RowAutoResize");

            EndEdit();
            CurrencyManager listManager = this.ListManager;
            if (listManager == null)
                return;

            Graphics g = CreateGraphicsInternal();
            try
            {
                GridColumnStylesCollection columns = myGridTable.GridColumnStyles;
                DataGridRow resizeRow = DataGridRows[row];
                int rowCount = listManager.Count;
                int resizeHeight = 0;

                // compute the height that we should resize to:
                int columnsCount = columns.Count;
                for (int col = 0; col < columnsCount; col++) {
                    object value = columns[col].GetColumnValueAtRow(listManager, row);
                    resizeHeight = Math.Max(resizeHeight, columns[col].GetPreferredHeight(g, value));
                }

                if (resizeRow.Height != resizeHeight)
                {
                    resizeRow.Height = resizeHeight;

                    // needed to refresh scrollbar properties
                    PerformLayout();

                    Rectangle rightArea = layout.Data;
                    if (layout.RowHeadersVisible)
                        rightArea = Rectangle.Union(rightArea, layout.RowHeaders);
                    int top = GetRowTop(row);
                    rightArea.Height -= rightArea.Y - top;
                    rightArea.Y = top;
                    Invalidate(rightArea);
                }
            }
            finally
            {
                g.Dispose();
            }

            // OnRowResize(EventArgs.Empty);
            return;
        }



        private void RowResizeBegin(MouseEventArgs e, int row)
        {
            Debug.WriteLineIf(CompModSwitches.DataGridLayout.TraceVerbose, "DataGridLayout: RowResizeBegin");
            Debug.Assert(myGridTable != null, "Row resizing operations can't be called when myGridTable == null.");

            int y = e.Y;
            EndEdit();
            Rectangle clip = Rectangle.Union(layout.RowHeaders, layout.Data);
            int topEdge = GetRowTop(row);
            clip.Y  = topEdge + 3;
            clip.Height = layout.Data.Y + layout.Data.Height - topEdge - 2;

            IntSecurity.AdjustCursorClip.Assert();
            try {
                CaptureInternal = true;
                Cursor.Clip  = RectangleToScreen(clip);
            }
            finally {
                CodeAccessPermission.RevertAssert();
            }
            gridState[GRIDSTATE_trackRowResize] = true;
            trackRowAnchor = y;
            trackRow = row;

            DrawRowSplitBar(e);
            lastSplitBar = e;
        }

        private void RowResizeMove(MouseEventArgs e)
        {
            if (lastSplitBar != null) {
                DrawRowSplitBar(lastSplitBar);
                lastSplitBar = e;
            }
            DrawRowSplitBar(e);
        }

        private void RowResizeEnd(MouseEventArgs e)
        {
            Debug.WriteLineIf(CompModSwitches.DataGridLayout.TraceVerbose, "DataGridLayout: RowResizeEnd");
            Debug.Assert(myGridTable != null, "Row resizing operations can't be called when myGridTable == null.");

            try {
                if (lastSplitBar != null) {
                    DrawRowSplitBar(lastSplitBar);
                    lastSplitBar = null;
                }

                int y = Math.Min(e.Y, layout.Data.Y + layout.Data.Height + 1);
                int delta = y - GetRowBottom(trackRow);
                if (trackRowAnchor != y && delta != 0) {
                    DataGridRow row = DataGridRows[trackRow];
                    int proposed = row.Height + delta;
                    proposed = Math.Max(proposed, 3);
                    row.Height = proposed;


                    // needed to refresh scrollbar properties
                    PerformLayout();

                    Rectangle rightArea = Rectangle.Union(layout.RowHeaders, layout.Data);
                    int top = GetRowTop(trackRow);
                    rightArea.Height -= rightArea.Y - top;
                    rightArea.Y = top;
                    Invalidate(rightArea);
                }
            } 
            finally {
                Cursor.Clip = Rectangle.Empty;
                CaptureInternal = false;
            }
            // OnRowResize(EventArgs.Empty);
        }

        /// <devdoc>
        ///      Fires the ColumnHeaderClicked event and handles column
        ///      sorting.
        /// </devdoc>
        private void ColumnHeaderClicked(PropertyDescriptor prop) {
            if (!CommitEdit())
                return;

            // OnColumnHeaderClick(EventArgs.Empty);
            bool allowSorting;
            if (this.myGridTable.IsDefault)
                allowSorting = this.AllowSorting;
            else
                allowSorting = myGridTable.AllowSorting;

            if (!allowSorting)
                return;

            // if (CompModSwitches.DataGridCursor.OutputVerbose) Debug.WriteLine("DataGridCursor: We are about to sort column " + col.ToString());
            ListSortDirection direction = this.ListManager.GetSortDirection();
            PropertyDescriptor sortColumn = this.ListManager.GetSortProperty();
            if (sortColumn != null && sortColumn.Equals(prop))
                direction = (direction == ListSortDirection.Ascending) ? ListSortDirection.Descending : ListSortDirection.Ascending;
            else
                // defaultSortDirection : ascending
                direction = ListSortDirection.Ascending;

            if (listManager.Count == 0)
                return;

            this.ListManager.SetSort(prop, direction);
            ResetSelection();

            InvalidateInside();
        }

        /// <devdoc>
        ///      Attempts to commit editing if a cell is being edited.
        ///      Return true if successfully commited editing.
        ///      Return false if editing can not be completed and the gird must
        ///      remain in our current Edit state.
        /// </devdoc>
        private bool CommitEdit() {
            
            Debug.WriteLineIf(CompModSwitches.DataGridEditing.TraceVerbose, "DataGridEditing: \t  CommitEdit " + (editRow == null ? "" : editRow.RowNumber.ToString()));


            if (!gridState[GRIDSTATE_isEditing] && !gridState[GRIDSTATE_isNavigating] || gridState[GRIDSTATE_editControlChanging])
                return true;

            // the same rules from editColumn.OnEdit
            // flag that we are editing the Edit control, so if we get a OnLayout on the 
            // datagrid side of things while the edit control changes its visibility and bounds
            // the datagrid does not perform a layout
            gridState[GRIDSTATE_editControlChanging] = true;

            if (editColumn.ReadOnly || gridState[GRIDSTATE_inAddNewRow]) {
                if (gridState[GRIDSTATE_canFocus])
                    this.FocusInternal();
                editColumn.ConcedeFocus();

                // set the focus back to the grid
                if (gridState[GRIDSTATE_canFocus] && CanFocus && !Focused)
                    this.FocusInternal();

                // reset the editControl flag
                gridState[GRIDSTATE_editControlChanging] = false;
                return true;
            }

            bool retVal = editColumn.Commit(ListManager, currentRow);

            // reset the editControl flag
            gridState[GRIDSTATE_editControlChanging] = false;

            if (retVal)
                gridState[GRIDSTATE_isEditing] = false;

            return retVal;
        }

        /// <devdoc>
        ///      Computes the number of pixels to scroll to scroll from one
        ///      column to another.
        /// </devdoc>
        private int ComputeColumnDelta(int from, int to) {
            int first = from;
            int last = to;
            int sign = -1;
            if (first > last) {
                first = to;
                last = from;
                sign = 1;
            }

            int delta = 0;
            GridColumnStylesCollection visibleColumns = myGridTable.GridColumnStyles;
            for (int col = first; col < last; ++col) {
#if DEBUG
                if (visibleColumns[col].PropertyDescriptor == null)
                    Debug.Assert(!this.myGridTable.IsDefault && !visibleColumns[col].IsDefault, "default tables and default columns should have propertyDEscriptors");
#endif // DEBUG
                // if (visibleColumns[col].Visible && visibleColumns[col].PropertyDescriptor != null)
                if (visibleColumns[col].PropertyDescriptor != null)
                    delta += visibleColumns[col].Width;
            }
            return sign * delta;
        }

        /// <devdoc>
        ///      Figure out how many rows we need to scroll down
        ///      to move targetRow into visibility.
        /// </devdoc>
        private int ComputeDeltaRows(int targetRow) {
            //Debug.WriteLineIf(CompModSwitches.DataGridScrolling.TraceVerbose, "DataGridScrolling: ComputeDeltaRows, firstVisibleRow = "
            //                  + firstVisibleRow.ToString() + ", "
            //                  + "targetRow = " + targetRow.ToString());

            if (firstVisibleRow == targetRow)
                return 0;

            int dRows = 0;
            int firstVisibleRowLogicalTop = -1;
            int targetRowLogicalTop = -1;
            int nRows = DataGridRowsLength;
            int cy = 0;
            DataGridRow[] localGridRows = DataGridRows;

            for (int row = 0; row < nRows; ++row) {
                if (row == firstVisibleRow)
                    firstVisibleRowLogicalTop = cy;
                if (row == targetRow)
                    targetRowLogicalTop = cy;
                if (targetRowLogicalTop != -1 && firstVisibleRowLogicalTop != -1)
                    break;
                cy += localGridRows[row].Height;
            }

            int targetRowLogicalBottom = targetRowLogicalTop + localGridRows[targetRow].Height;
            int dataLogicalBottom = layout.Data.Height + firstVisibleRowLogicalTop;
            if (targetRowLogicalBottom > dataLogicalBottom) {
                // we need to move down.
                int downDelta = targetRowLogicalBottom - dataLogicalBottom;
                firstVisibleRowLogicalTop += downDelta;
            }
            else if (firstVisibleRowLogicalTop < targetRowLogicalTop) {
                // we don't need to move
                return 0;
            }
            else {
                // we need to move up.
                int upDelta = firstVisibleRowLogicalTop - targetRowLogicalTop;
                firstVisibleRowLogicalTop -= upDelta;
            }
            int newFirstRow = ComputeFirstVisibleRow(firstVisibleRowLogicalTop);
            dRows = (newFirstRow - firstVisibleRow);
            //Debug.WriteLineIf(CompModSwitches.DataGridScrolling.TraceVerbose, "DataGridScrolling: ComputeDeltaRows returning " + dRows.ToString());
            return dRows;
        }

        /// <devdoc>
        ///      Given the a logical vertical offset, figure out
        ///      which row number should be the first fully visible
        ///      row on or after the offset.
        /// </devdoc>
        private int ComputeFirstVisibleRow(int firstVisibleRowLogicalTop) {
            int first;
            int nRows = DataGridRowsLength;
            int cy = 0;
            DataGridRow[] localGridRows = DataGridRows;
            for (first = 0; first < nRows; ++first) {
                if (cy >= firstVisibleRowLogicalTop)
                    break;
                cy += localGridRows[first].Height;
            }
            return first;
        }

        /// <devdoc>
        ///      Constructs an updated Layout object.
        /// </devdoc>
        private void ComputeLayout() {
            Debug.WriteLineIf(CompModSwitches.DataGridLayout.TraceVerbose, "DataGridLayout: ComputeLayout");

            bool alignLeft = ! isRightToLeft();
            Rectangle oldResizeRect = this.layout.ResizeBoxRect;

            // hide the EditBox
            EndEdit();

            ClearRegionCache();

            // NOTE : Since Rectangles are structs, then assignment is a 
            //      : copy. Therefore, after saying "Rectangle inside = newLayout.Inside",
            //      : we must always assign back to newLayout.Inside.
            //

            // Important since all of the visibility flags will move
            // to the new layout here.
            LayoutData newLayout = new LayoutData(layout);

            // Inside
            newLayout.Inside = ClientRectangle;
            Rectangle inside = newLayout.Inside;
            int borderWidth = BorderWidth;
            inside.Inflate(-borderWidth, -borderWidth);

            Rectangle insideLeft = inside;

            // Caption
            if (layout.CaptionVisible) {
                int captionHeight = captionFontHeight + 6;
                Rectangle cap     =   newLayout.Caption;
                cap               =   insideLeft;
                cap.Height        =   captionHeight;
                insideLeft.Y      +=  captionHeight;
                insideLeft.Height -=  captionHeight;

                newLayout.Caption = cap;
            }
            else {
                newLayout.Caption = Rectangle.Empty;
            }

            // Parent Rows
            if (layout.ParentRowsVisible) {
                Rectangle parents      = newLayout.ParentRows;
                int       parentHeight = parentRows.Height;
                parents           =  insideLeft;
                parents.Height    =  parentHeight;
                insideLeft.Y      += parentHeight;
                insideLeft.Height -= parentHeight;

                newLayout.ParentRows = parents;
            }
            else {
                newLayout.ParentRows = Rectangle.Empty;
            }

            // Headers
            //
            int columnHeaderHeight = headerFontHeight + 6;
            if (layout.ColumnHeadersVisible) {
                Rectangle colHeaders = newLayout.ColumnHeaders;
                colHeaders        =  insideLeft;
                colHeaders.Height =  columnHeaderHeight;
                insideLeft.Y      += columnHeaderHeight;
                insideLeft.Height -= columnHeaderHeight;

                newLayout.ColumnHeaders = colHeaders;
            }
            else {
                newLayout.ColumnHeaders = Rectangle.Empty;
            }

            bool newRowHeadersVisible = this.myGridTable.IsDefault ? this.RowHeadersVisible : this.myGridTable.RowHeadersVisible;
            int newRowHeaderWidth = this.myGridTable.IsDefault ? this.RowHeaderWidth : this.myGridTable.RowHeaderWidth;
            newLayout.RowHeadersVisible = newRowHeadersVisible;
            if (this.myGridTable != null && newRowHeadersVisible) {
                Rectangle rowHeaders = newLayout.RowHeaders;
                if (alignLeft)
                {
                    rowHeaders = insideLeft;
                    rowHeaders.Width = newRowHeaderWidth;
                    insideLeft.X += newRowHeaderWidth;
                    insideLeft.Width -= newRowHeaderWidth;
                }
                else
                {
                    rowHeaders = insideLeft;
                    rowHeaders.Width = newRowHeaderWidth;
                    rowHeaders.X = insideLeft.Right - newRowHeaderWidth;
                    insideLeft.Width -= newRowHeaderWidth;
                }
                newLayout.RowHeaders = rowHeaders;

                if (layout.ColumnHeadersVisible) {
                    Rectangle topLeft    = newLayout.TopLeftHeader;
                    Rectangle colHeaders = newLayout.ColumnHeaders;
                    if (alignLeft)
                    {
                        topLeft   =  colHeaders;
                        topLeft.Width    =  newRowHeaderWidth;
                        colHeaders.Width -= newRowHeaderWidth;
                        colHeaders.X     += newRowHeaderWidth;
                    }
                    else
                    {
                        topLeft   =  colHeaders;
                        topLeft.Width    =  newRowHeaderWidth;
                        topLeft.X        =  colHeaders.Right - newRowHeaderWidth;
                        colHeaders.Width -= newRowHeaderWidth;
                    }

                    newLayout.TopLeftHeader = topLeft;
                    newLayout.ColumnHeaders = colHeaders;
                }
                else {
                    newLayout.TopLeftHeader = Rectangle.Empty;
                }
            }
            else {
                newLayout.RowHeaders = Rectangle.Empty;
                newLayout.TopLeftHeader = Rectangle.Empty;
            }

            // The Data region
            newLayout.Data = insideLeft;
            newLayout.Inside = inside;

            this.layout = newLayout;

            LayoutScrollBars();

            // if the user shrank the grid client area, then OnResize invalidated the old
            // resize area. however, we need to invalidate the left upper corner in the new ResizeArea
            // note that we can't take the Invalidate call from the OnResize method, because if the
            // user enlarges the form then the old area will not be invalidated.
            // 
            if (!oldResizeRect.Equals(this.layout.ResizeBoxRect) && !this.layout.ResizeBoxRect.IsEmpty)
                Invalidate(this.layout.ResizeBoxRect);

            this.layout.dirty = false;
            Debug.WriteLineIf(CompModSwitches.DataGridLayout.TraceVerbose, "DataGridLayout: " + layout.ToString());
        }

        /// <devdoc>
        ///      Computes the number of pixels to scroll to scroll from one
        ///      row to another.
        /// </devdoc>
        private int ComputeRowDelta(int from, int to) {
            int first = from;
            int last = to;
            int sign = -1;
            if (first > last) {
                first = to;
                last = from;
                sign = 1;
            }
            DataGridRow[] localGridRows = DataGridRows;
            int delta = 0;
            for (int row = first; row < last; ++row) {
                delta += localGridRows[row].Height;
            }
            return sign * delta;
        }

        internal int MinimumRowHeaderWidth() {
            return minRowHeaderWidth;
        }

        internal void ComputeMinimumRowHeaderWidth() {
            minRowHeaderWidth = 0;
            minRowHeaderWidth = errorRowBitmapWidth; // the size of the pencil, star and row selector images are the same as the image for the error bitmap
            if (this.ListHasErrors)
                minRowHeaderWidth += errorRowBitmapWidth;
            if (this.myGridTable != null && this.myGridTable.RelationsList.Count != 0)
                minRowHeaderWidth += 15; // the size of the plus/minus glyph and spacing around it
        }

        /// <internalonly/>
        /// <devdoc>
        ///      Updates the internal variables with the number of columns visible
        ///      inside the Grid's client rectangle.
        /// </devdoc>
        private void ComputeVisibleColumns() {
            Debug.WriteLineIf(CompModSwitches.DataGridLayout.TraceVerbose, "DataGridLayout: ComputeVisibleColumns");
            EnsureBound();

            GridColumnStylesCollection columns = myGridTable.GridColumnStyles;

            int nGridCols = columns.Count;
            int cx = - negOffset;
            int visibleColumns = 0;
            int visibleWidth = layout.Data.Width;
            int curCol = firstVisibleCol;

            // the same problem with negative numbers:
            // if the width passed in is negative, then return 0
            //
            // added the check for the columns.Count == 0 ( danielhe, November 14, 2000)
            //
            if (visibleWidth < 0 || columns.Count == 0)
            {
                numVisibleCols = firstVisibleCol = lastTotallyVisibleCol = 0;
                return;
            }

            while (cx < visibleWidth && curCol < nGridCols)
            {
                // if (columns.Visible && columns.PropertyDescriptor != null)
                if (columns[curCol].PropertyDescriptor != null)
                    cx += columns[curCol].Width;
                curCol++;
                visibleColumns ++;
            }

            numVisibleCols = visibleColumns;

            // if we inflate the data area
            // then we paint columns to the left of firstVisibleColumn
            if (cx < visibleWidth)
            {
                for (int i = firstVisibleCol -1; i > 0; i--)
                {
                    if (cx + columns[i].Width > visibleWidth)
                        break;
                    // if (columns.Visible && columns.PropertyDescriptor != null)
                    if (columns[i].PropertyDescriptor != null)
                        cx += columns[i].Width;
                    visibleColumns ++;
                    firstVisibleCol --;
                }

                if (numVisibleCols != visibleColumns)
                {
                    Debug.Assert(numVisibleCols < visibleColumns, "the number of visible columns can only grow");
                    // is there space for more columns than were visible?
                    // if so, then we need to repaint Data and ColumnHeaders
                    Invalidate(layout.Data);
                    Invalidate(layout.ColumnHeaders);

                    // update the number of visible columns to the new reality
                    numVisibleCols = visibleColumns;
                }
            }

            lastTotallyVisibleCol = firstVisibleCol + numVisibleCols - 1;
            if (cx > layout.Data.Width)
                lastTotallyVisibleCol--;
        }

        /// <devdoc>
        ///      Determines which column is the first visible given
        ///      the object's horizontalOffset.
        /// </devdoc>
        private int ComputeFirstVisibleColumn() {
            int first = 0;
            if (this.horizontalOffset == 0) {
                negOffset = 0;
                return 0;
            }

            // we will check to see if myGridTables.GridColumns.Count != 0
            // because when we reset the dataGridTable, we don't have any columns, and we still
            // call HorizontalOffset = 0, and that will call ComputeFirstVisibleColumn with an empty collection of columns.
            if (myGridTable != null && myGridTable.GridColumnStyles != null && myGridTable.GridColumnStyles.Count != 0) {
                GridColumnStylesCollection columns = myGridTable.GridColumnStyles;
                int cx = 0;
                int nGridCols = columns.Count;

                if (columns[0].Width == -1) {
                    // the columns are not initialized yet
                    //
#if DEBUG
                    for (int i = 0; i < nGridCols; i++) {
                        Debug.Assert(columns[i].Width == -1, "the columns' widths should not be initialized");
                    }
#endif // DEBUG
                    negOffset = 0;
                    return 0;
                }

                for (first = 0; first < nGridCols; first++) {
                    // if (columns[first].Visible && columns[first].PropertyDescriptor != null);
                    if (columns[first].PropertyDescriptor != null)
                        cx += columns[first].Width;
                    if (cx > horizontalOffset)
                        break;
                }
                // first may actually be the number of columns
                // in that case all the columns fit in the layout data
                if (first == nGridCols) {
                    Debug.Assert(cx <= horizontalOffset, "look at the for loop before: we only exit that loop early if the cx is over the horizontal offset");
                    negOffset = 0;
                    return 0;
                }
                negOffset = columns[first].Width - (cx - horizontalOffset);
                //Debug.WriteLineIf(CompModSwitches.DataGridScrolling.TraceVerbose, "DataGridScrolling: ComputeFirstVisibleColumn, ret = " + first.ToString() + ", negOffset = " + negOffset.ToString());
            }
            return first;
        }

        /// <devdoc>
        ///      Updates the internal variables with the number of rows visible
        ///      in a given DataGrid Layout.
        /// </devdoc>
        private void ComputeVisibleRows() {
            Debug.WriteLineIf(CompModSwitches.DataGridLayout.TraceVerbose, "DataGridLayout: ComputeVisibleRows");
            EnsureBound();

            Rectangle data = layout.Data;
            int visibleHeight = data.Height;
            int cy = 0;
            int visibleRows = 0;
            DataGridRow[] localGridRows = DataGridRows;
            int numRows = DataGridRowsLength;

            // when minimizing the dataGrid window, we will get negative values for the
            // layout.Data.Width and layout.Data.Height ( is this a bug or not? if layout.Data.Height == 0 in that case,
            // the old code would have worked )
            //
            // if this is the case, then set numVisibleRows = numTotallyVisibleRows = 0;
            //
            if (visibleHeight < 0)
            {
                numVisibleRows = numTotallyVisibleRows = 0;
                return;
            }

            for (int i = firstVisibleRow; i < numRows; ++i) {
                if (cy > visibleHeight)
                    break;
                cy += localGridRows[i].Height;
                visibleRows++;
            }

            if (cy < visibleHeight) {
                for (int i = firstVisibleRow-1; i >= 0; i--) {
                    int height = localGridRows[i].Height;
                    if (cy + height > visibleHeight)
                        break;
                    cy += height;
                    firstVisibleRow--;
                    visibleRows++;
                }
            }

            numVisibleRows = numTotallyVisibleRows = visibleRows;
            if (cy > visibleHeight)
                numTotallyVisibleRows--;

            Debug.Assert(numVisibleRows >= 0, "the number of visible rows can't be negative");
            Debug.Assert(numTotallyVisibleRows >= 0, "the number of totally visible rows can't be negative");
        }


        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.CreateAccessibilityInstance"]/*' />
        /// <devdoc>
        ///     Constructs the new instance of the accessibility object for this control. Subclasses
        ///     should not call base.CreateAccessibilityObject.
        /// </devdoc>
        protected override AccessibleObject CreateAccessibilityInstance() {
            AccessibleName = "DataGrid";
            AccessibleRole = AccessibleRole.Table;
            return new DataGridAccessibleObject(this);
        }


        /// <internalonly/>
        /// <devdoc>
        ///      Creates a DataGridState representing the child table retrieved
        ///      from the passed DataRelation.
        /// </devdoc>
        private DataGridState CreateChildState(string relationName, DataGridRow source) {
            DataGridState dgs = new DataGridState();

            string newDataMember;
            if (this.DataMember == null || this.DataMember.Equals(String.Empty))
            {
                newDataMember = relationName;
            }
            else
            {
                newDataMember = this.DataMember + "." + relationName;
            }

            CurrencyManager childLM = (CurrencyManager) this.BindingContext[this.DataSource, newDataMember];

            dgs.DataSource = this.DataSource;
            dgs.DataMember = newDataMember;
            dgs.ListManager = childLM;

            dgs.DataGridRows = null;
            dgs.DataGridRowsLength = childLM.Count + (policy.AllowAdd ? 1 : 0);

            return dgs;
        }


        /// <devdoc>
        ///      Constructs a Layout object containing the state
        ///      for a newly constructed DataGrid.
        /// </devdoc>
        private LayoutData CreateInitialLayoutState() {
            Debug.WriteLineIf(CompModSwitches.DataGridLayout.TraceVerbose, "DataGridLayout: CreateInitialLayoutState");
            LayoutData newLayout = new LayoutData();
            newLayout.Inside               = new Rectangle();
            newLayout.TopLeftHeader        = new Rectangle();
            newLayout.ColumnHeaders        = new Rectangle();
            newLayout.RowHeaders           = new Rectangle();
            newLayout.Data                 = new Rectangle();
            newLayout.Caption              = new Rectangle();
            newLayout.ParentRows           = new Rectangle();
            newLayout.ResizeBoxRect        = new Rectangle();
            newLayout.ColumnHeadersVisible = true;
            newLayout.RowHeadersVisible    = true;
            newLayout.CaptionVisible       = defaultCaptionVisible;
            newLayout.ParentRowsVisible    = defaultParentRowsVisible;
            newLayout.ClientRectangle           = ClientRectangle;
            return newLayout;
        }

        /// <devdoc>
        ///      The DataGrid caches an array of rectangular areas
        ///      which represent the area which scrolls left to right.
        ///      This method is invoked whenever the DataGrid needs
        ///      this scrollable region.
        /// </devdoc>
        private NativeMethods.RECT[] CreateScrollableRegion(Rectangle scroll) {
            if (cachedScrollableRegion != null) {
                return cachedScrollableRegion;
            }

            bool alignToRight = isRightToLeft();

            Region region = new Region(scroll);
            int nRows = numVisibleRows;
            int cy = layout.Data.Y;
            int cx = layout.Data.X;
            DataGridRow[] localGridRows = DataGridRows;
            for (int r = firstVisibleRow; r < nRows; r++) {
                int rowHeight = localGridRows[r].Height;
                Rectangle rowExclude = localGridRows[r].GetNonScrollableArea();
                rowExclude.X += cx;
                rowExclude.X = MirrorRectangle(rowExclude, layout.Data, alignToRight);
                if (!rowExclude.IsEmpty) {
                     region.Exclude(new Rectangle(rowExclude.X,
                                                  rowExclude.Y + cy,
                                                  rowExclude.Width,
                                                  rowExclude.Height));
                }
                cy += rowHeight;
            }
            
            Graphics graphics = CreateGraphicsInternal();
            IntPtr handle = region.GetHrgn(graphics);
            graphics.Dispose();
            cachedScrollableRegion = RegionCracker.CrackRegionData(handle);
            SafeNativeMethods.DeleteObject(new HandleRef(this, handle));

            return cachedScrollableRegion;
         }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.Dispose"]/*' />
        /// <devdoc>
        ///    Disposes of the resources (other than memory) used
        ///    by the <see cref='System.Windows.Forms.DataGrid'/>.
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                if (vertScrollBar != null)
                    vertScrollBar.Dispose();
                if (horizScrollBar != null)
                    horizScrollBar.Dispose();

                GridTableStylesCollection tables = this.TableStyles;
                if (tables != null) {
#if DEBUG
                    Debug.Assert(this.myGridTable == null || this.myGridTable.IsDefault || tables.Contains(this.myGridTable), "how come that the currentTable is not in the list of tables?");
#endif // DEBUG
                    for (int i = 0; i < tables.Count; i++)
                        tables[i].Dispose();
                }
            }
            base.Dispose(disposing);
        }

        /// <devdoc>
        ///      Draws an XOR region to give UI feedback for Column Resizing.
        ///      This looks just like the Splitter control's UI when resizing.
        /// </devdoc>
        private void DrawColSplitBar(MouseEventArgs e)
        {
            Rectangle r = CalcColResizeFeedbackRect(e);
            DrawSplitBar(r);
        }

        /// <devdoc>
        ///      Draws an XOR region to give UI feedback for Row Resizing.
        ///      This looks just like the Splitter control's UI when resizing.
        /// </devdoc>
        private void DrawRowSplitBar(MouseEventArgs e)
        {
            Rectangle r = CalcRowResizeFeedbackRect(e);
            DrawSplitBar(r);
        }

        /// <devdoc>
        ///      Draws an XOR region to give UI feedback for Column/Row Resizing.
        ///      This looks just like the Splitter control's UI when resizing.
        /// </devdoc>
        private void DrawSplitBar(Rectangle r)
        {
            IntPtr parentHandle = Handle;
            IntPtr dc = UnsafeNativeMethods.GetDCEx(new HandleRef(this, parentHandle), NativeMethods.NullHandleRef, NativeMethods.DCX_CACHE | NativeMethods.DCX_LOCKWINDOWUPDATE);
            IntPtr halftone = ControlPaint.CreateHalftoneHBRUSH();
            IntPtr saveBrush = SafeNativeMethods.SelectObject(new HandleRef(this, dc), new HandleRef(null, halftone));
            SafeNativeMethods.PatBlt(new HandleRef(this, dc), r.X, r.Y, r.Width, r.Height, NativeMethods.PATINVERT);
            SafeNativeMethods.SelectObject(new HandleRef(this, dc), new HandleRef(null, saveBrush));
            SafeNativeMethods.DeleteObject(new HandleRef(null, halftone));
            UnsafeNativeMethods.ReleaseDC(new HandleRef(this, parentHandle), new HandleRef(this, dc));
        }

        /// <devdoc>
        ///      Begin in-place editing of a cell.  Any editing is commited
        ///      before the new edit takes place.
        ///
        ///      This will always edit the currentCell
        ///      If you want to edit another cell than the current one, just reset CurrentCell
        /// </devdoc>
        private void Edit() {
            Edit(null);
        }

        private void Edit(string instantText) {
            EnsureBound();

            // we want to be able to edit a cell which is not visible, as in the case with editing and scrolling
            // at the same time. So do not call Ensure Visible
            // 
            // EnsureVisible(currentRow, currentCol);

            bool cellIsVisible = true;

            // whoever needs to call ResetSelection should not rely on 
            // Edit() to call it;
            //
            // ResetSelection();

            EndEdit();

            Debug.WriteLineIf(CompModSwitches.DataGridEditing.TraceVerbose, "DataGridEditing: Edit, currentRow = " + currentRow.ToString() +
                                                                           ", currentCol = " + currentCol.ToString() + (instantText != null ? ", instantText= " + instantText : ""));

            /* allow navigation even if the policy does not allow editing
            if (!policy.AllowEdit)
                return;
            */

            DataGridRow[] localGridRows = DataGridRows;

            // what do you want to edit when there are no rows?
            if (DataGridRowsLength == 0)
                return;

            localGridRows[currentRow].OnEdit();
            editRow = localGridRows[currentRow];

            // if the list has no columns, then what good is an edit?
            if (this.myGridTable.GridColumnStyles.Count == 0)
                return;

            // what if the currentCol does not have a propDesc?
            editColumn = myGridTable.GridColumnStyles[currentCol];
            if(editColumn.PropertyDescriptor == null)
                return;


            Rectangle cellBounds = Rectangle.Empty;
            if (currentRow < firstVisibleRow || currentRow > firstVisibleRow + numVisibleRows ||
                currentCol < firstVisibleCol || currentCol > firstVisibleCol + numVisibleCols - 1 || 
                (currentCol == firstVisibleCol && negOffset != 0))
            {
                cellIsVisible = false;
            }
            else
            {
                cellBounds = GetCellBounds(currentRow, currentCol);
            }

            gridState[GRIDSTATE_isNavigating] = true;
            gridState[GRIDSTATE_isEditing] = false;

            // once we call editColumn.Edit on a DataGridTextBoxColumn
            // the edit control will become visible, and its bounds will get set.
            // both actions cause Edit.Parent.OnLayout
            // so we flag this change, cause we don't want to PerformLayout on the entire DataGrid
            // everytime the edit column gets edited
            gridState[GRIDSTATE_editControlChanging] = true;

            editColumn.Edit(this.ListManager,
                              currentRow,
                              cellBounds,
                              myGridTable.ReadOnly || this.ReadOnly || !policy.AllowEdit,
                              instantText,
                              cellIsVisible);

            // reset the editControlChanging to false
            gridState[GRIDSTATE_editControlChanging] = false;
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.EndEdit"]/*' />
        /// <devdoc>
        ///    <para>Requests an end to an edit operation taking place on the
        ///    <see cref='System.Windows.Forms.DataGrid'/>
        ///    control.</para>
        /// </devdoc>
        public bool EndEdit(DataGridColumnStyle gridColumn, int rowNumber, bool shouldAbort) {
            bool ret = false;
            if (gridState[GRIDSTATE_isEditing]) {
                if (gridColumn != editColumn) {
                    Debug.WriteLineIf(CompModSwitches.DataGridEditing.TraceVerbose, "DataGridEditing: EndEdit requested on a column we are not editing.");
                }
                if (rowNumber != editRow.RowNumber) {
                    Debug.WriteLineIf(CompModSwitches.DataGridEditing.TraceVerbose, "DataGridEditing: EndEdit requested on a row we are not editing.");
                }
                if (shouldAbort) {
                    AbortEdit();
                    ret = true;
                }
                else
                    ret = CommitEdit();

            }
            return ret;
        }

        /// <devdoc>
        ///      Ends any editing in progress by attempting to commit and then
        ///      aborting if not possible.
        /// </devdoc>
        private void EndEdit() {
            Debug.WriteLineIf(CompModSwitches.DataGridEditing.TraceVerbose, "DataGridEditing: EndEdit");

            if (!gridState[GRIDSTATE_isEditing] && !gridState[GRIDSTATE_isNavigating])
                return;

            if (!CommitEdit()) {
                AbortEdit();
            }
        }

        // PERF: we attempt to create a ListManager for the DataSource/DateMember combination
        // we do this in order to check for a valid DataMember
        // if the check succeeds, then it means that we actully put the listManager in the BindingContext's
        // list of BindingManagers. this is fine, cause if the check succeds, then Set_ListManager
        // will be called, and this will get the listManager from the bindingManagerBase hashTable kept in the BindingContext
        //
        // this will work if the dataMember does not contain any dots ('.')
        // if the dataMember contains dots, then it will be more complicated: maybe part of the binding path
        // is valid w/ the new dataSource
        // but we can leave w/ this, cause in the designer the dataMember will be only a column name. and the DataSource/DataMember
        // properties are for use w/ the designer.
        //
        private void EnforceValidDataMember(object value) {
            Debug.Assert(value != null, "we should not have a null dataSource when we want to check for a valid dataMember");
            if ("".Equals(DataMember))
                return;
            if (this.BindingContext == null)
                return;
            //
            try {
                BindingManagerBase bm = this.BindingContext[value, this.dataMember];
            } catch (Exception) {
                this.dataMember = "";
            }
        }

        // will be used by the columns to tell the grid that
        // editing is taken place (ie, the grid is no longer in the
        // editOrNavigateMode)
        //
        // also, tell the current row to lose child focus
        //
        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ColumnStartedEditing"]/*' />
        internal protected virtual void ColumnStartedEditing(Rectangle bounds) {
            Debug.Assert( currentRow >= firstVisibleRow && currentRow <= firstVisibleRow +  numVisibleRows, "how can one edit a row which is invisible?");
            DataGridRow[] localGridRows = DataGridRows;

            if (gridState[GRIDSTATE_inAddNewRow]) {
                int currentRowCount = this.DataGridRowsLength;
                DataGridRow[] newDataGridRows = new DataGridRow[currentRowCount + 1];
                for (int i = 0; i < currentRowCount; i++) {
                    newDataGridRows[i] = localGridRows[i];
                }


                // put the AddNewRow
                newDataGridRows[currentRowCount] = new DataGridAddNewRow(this, this.myGridTable, currentRowCount);
                SetDataGridRows(newDataGridRows, currentRowCount + 1);

                Edit();
                // put this after the call to edit so that 
                // CommitEdit knows that the inAddNewRow is true;
                gridState[GRIDSTATE_inAddNewRow] = false;
                gridState[GRIDSTATE_isEditing] = true;
                gridState[GRIDSTATE_isNavigating] = false;
                return;
            }

            gridState[GRIDSTATE_isEditing] = true;
            gridState[GRIDSTATE_isNavigating] = false;
            InvalidateRowHeader(this.currentRow);

            // tell the current row to lose the childFocuse
            localGridRows[currentRow].LoseChildFocus(layout.RowHeaders, isRightToLeft());
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ColumnStartedEditing1"]/*' />
        internal protected virtual void ColumnStartedEditing(Control editingControl) {
            this.ColumnStartedEditing(editingControl.Bounds);
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.Expand"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Displays child relations, if any exist, for all rows or a
        ///       specific row.
        ///    </para>
        /// </devdoc>
        public void Expand(int row) {
            SetRowExpansionState(row, true);
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.CreateGridColumn"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a <see cref='System.Windows.Forms.DataGridColumnStyle'/> using the specified <see cref='System.ComponentModel.PropertyDescriptor'/>.
        ///    </para>
        /// </devdoc>
        // protected and virtual because the SimpleDropdownDataGrid will override this
        protected virtual DataGridColumnStyle CreateGridColumn(PropertyDescriptor prop, bool isDefault) {
            return myGridTable == null ? null : myGridTable.CreateGridColumn(prop, isDefault);
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.CreateGridColumn1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual DataGridColumnStyle CreateGridColumn(PropertyDescriptor prop)
        {
            return myGridTable == null ? null : myGridTable.CreateGridColumn(prop);
        }


#if PARENT_LINKS

        private ListManager ListManagerForChildColumn(ListManager childListManager, PropertyDescriptor prop)
        {
            /*
            DataKey key;
            RelationsCollection relCollection = dataColumn.Table.ParentRelations;
            */

            // this will give us the list of properties of the child
            PropertyDescriptorCollection propCollection = childListManager.GetItemProperties();

            int relCount = propCollection.Count;
            for (int i=0;i<relCount;i++)
            {
                PropertyDescriptor currRelation = propCollection[i];
                if (typeof(IList).IsAssignableFrom(currRelation.PropertyType))
                {
                    object childRelation = currRelation.GetValue(childListManager.Current);
                    ListManager childTable = this.BindingContexgt == null ? null : this.BindingManager[childRelation, ""];
                    if (childTable == null)
                        continue;

                    // now loop thru all properties in the childTable...
                    PropertyDescriptorCollection childProps = childTable.GetItemProperties();
                    int colCount = childProps.Count;
                    for (int j = 0; j < colCount; j++)
                    {
                        PropertyDescriptor currCol = childProps[j];
                        if (currCol.Name != null && currCol.Name.Equals(prop.Name))
                            // there is a column in the parent with the same name
                            return childTable;
                    }
                }

                /*
                DataColumn[] childCols = relCollection[i].ChildColumns;
                DataColumn[] parentCols = relCollection[i].ParentColumns;

                // if the relationship involves more than one column in the child
                // table, then look at the next relationship
                if (childCols.Count != 1)
                    continue;

                // if the relationship involves more than one column in the parent 
                // table, then look at the next relationship
                if (parentCols.Count != 1)
                    continue;

                if (childCols[0] == dataColumn)
                {
                    dataColumn = parentCols[0];
                    return new DataSource(relCollection[i].ParentTable);
                }
                */
            }

            return null;
        }

#endif

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.EndInit"]/*' />
        /// <devdoc>
        ///    <para>Specifies the end of the initialization code.</para>
        /// </devdoc>
        public void EndInit() {
            inInit = false;
            if (myGridTable == null && this.ListManager != null) {
                SetDataGridTable(this.TableStyles[this.ListManager.GetListName()], true);      // true for forcing column creation
            }
            if (myGridTable != null)
                myGridTable.DataGrid = this;
        }

        /// <devdoc>
        ///      Given a x coordinate, returns the column it is over.
        /// </devdoc>
        private int GetColFromX(int x) {
            if (myGridTable == null)
                return -1;

            Rectangle inside = layout.Data;
            Debug.Assert(x >= inside.X && x < inside.Right, "x must be inside the horizontal bounds of layout.Data");

            x = MirrorPoint(x, inside, isRightToLeft());

            GridColumnStylesCollection columns = myGridTable.GridColumnStyles;
            int columnCount = columns.Count;

            int cx = inside.X - negOffset;
            int col = firstVisibleCol;
            while (cx < inside.Width  + inside.X && col < columnCount) {
                // if (columns[col].Visible && columns[col].PropertyDescriptor != null)
                if (columns[col].PropertyDescriptor != null)
                    cx += columns[col].Width;
                if (cx > x)
                    return col;
                ++col;
            }
            return -1;
        }

        /// <devdoc>
        ///      Returns the coordinate of the left edge of the given column
        ///      Bi-Di: if the grid has the RightToLeft property set to RightToLeft.Yes, this will
        ///      return what appears as the right edge of the column
        /// </devdoc>
        internal int GetColBeg(int col) {
            Debug.Assert(myGridTable != null, "GetColBeg can't be called when myGridTable == null.");

            int offset = layout.Data.X - negOffset;
            GridColumnStylesCollection columns = myGridTable.GridColumnStyles;

            int lastCol = Math.Min(col, columns.Count);
            for (int i = firstVisibleCol; i < lastCol; ++i) {
                // if (columns[i].Visible && columns[i].PropertyDescriptor != null)
                if (columns[i].PropertyDescriptor != null)
                    offset += columns[i].Width;
            }
            return MirrorPoint(offset, layout.Data, isRightToLeft());
        }

        /// <devdoc>
        ///      Returns the coordinate of the right edge of the given column
        ///      Bi-Di: if the grid has the RightToLeft property set to RightToLeft.Yes, this will
        ///      return what appears as the left edge of the column
        /// </devdoc>
        internal int GetColEnd(int col) {
            // return MirrorPoint(GetColBeg(col) + myGridTable.GridColumnStyles[col].Width, layout.Data, isRightToLeft());
            int colBeg = GetColBeg(col);
            Debug.Assert(myGridTable.GridColumnStyles[col].PropertyDescriptor != null, "why would we need the coordinate of a column that is not visible?");
            int width = myGridTable.GridColumnStyles[col].Width;
            return isRightToLeft() ? colBeg - width : colBeg + width;
        }

        private int GetColumnWidthSum() {
            int sum = 0;
            if (myGridTable != null && myGridTable.GridColumnStyles != null) {
                GridColumnStylesCollection columns = myGridTable.GridColumnStyles;

                int columnsCount = columns.Count;
                for (int i = 0; i < columnsCount; i++)
                    // if (columns[i].Visible && columns[i].PropertyDescriptor != null)
                    if (columns[i].PropertyDescriptor != null)
                        sum += columns[i].Width;
            }
            return sum;
        }

        /// <devdoc>
        ///      Not all rows in the DataGrid are expandable,
        ///      this computes which ones are and returns an array
        ///      of references to them.
        /// </devdoc>
        private DataGridRelationshipRow[] GetExpandableRows() {
            int nExpandableRows = DataGridRowsLength;
            DataGridRow[] localGridRows = DataGridRows;
            if (policy.AllowAdd)
                nExpandableRows = Math.Max(nExpandableRows-1,0);
            DataGridRelationshipRow[] expandableRows = new DataGridRelationshipRow[nExpandableRows];
            for (int i = 0; i < nExpandableRows; i++)
                expandableRows[i] = (DataGridRelationshipRow)localGridRows[i];
            return expandableRows;
        }

        /// <devdoc>
        ///      Returns the row number underneath the given y coordinate.
        /// </devdoc>
        /// <internalonly/>
        private int GetRowFromY(int y) {
            Rectangle inside = layout.Data;
            Debug.Assert(y >= inside.Y && y < inside.Bottom, "y must be inside the vertical bounds of the data");

            int cy = inside.Y;
            int row = firstVisibleRow;
            int rowCount = DataGridRowsLength;
            DataGridRow[] localGridRows = DataGridRows;
            int bottom = inside.Bottom;
            while (cy < bottom && row < rowCount) {
                cy += localGridRows[row].Height;
                if (cy > y) {
                    return row;
                }
                ++row;
            }
            return -1;
        }

        internal Rectangle GetRowHeaderRect() {
            return layout.RowHeaders;
        }

        internal Rectangle GetColumnHeadersRect() {
            return layout.ColumnHeaders;
        }

        /// <devdoc>
        ///      Determines where on the control's ClientRectangle a given row is
        ///      painting to.
        /// </devdoc>
        private Rectangle GetRowRect(int rowNumber) {
            Rectangle inside = layout.Data;
            int cy = inside.Y;
            DataGridRow[] localGridRows = DataGridRows;
            for (int row = firstVisibleRow; row <= rowNumber; ++row) {
                if (cy > inside.Bottom) {
                    break;
                }
                if (row == rowNumber) {
                    Rectangle rowRect = new Rectangle(inside.X,
                                                      cy,
                                                      inside.Width,
                                                      localGridRows[row].Height);
                    if (layout.RowHeadersVisible) {
                        rowRect.Width += layout.RowHeaders.Width;
                        rowRect.X     -= isRightToLeft() ? 0 : layout.RowHeaders.Width;
                    }
                    return rowRect;
                }
                cy += localGridRows[row].Height;
            }
            return Rectangle.Empty;
        }

        /// <devdoc>
        ///      Returns the coordinate of the top edge of the given row
        /// </devdoc>
        private int GetRowTop(int row) {
            DataGridRow[] localGridRows = DataGridRows;
            int offset = layout.Data.Y;
            int lastRow = Math.Min(row, DataGridRowsLength);
            for (int i = firstVisibleRow; i < lastRow; ++i) {
                offset += localGridRows[i].Height;
            }
            for (int i=firstVisibleRow; i > lastRow; i--) {
                offset -= localGridRows[i].Height;
            }
            return offset;
        }

        /// <devdoc>
        ///      Returns the coordinate of the bottom edge of the given row
        /// </devdoc>
        private int GetRowBottom(int row) {
            DataGridRow[] localGridRows = DataGridRows;

            return GetRowTop(row) + localGridRows[row].Height;
        }

        /// <devdoc>
        ///      This method is called on methods that need the grid
        ///      to be bound to a DataTable to work.
        /// </devdoc>
        private void EnsureBound() {
            if (!Bound) {
                throw new InvalidOperationException(SR.GetString(SR.DataGridUnbound));
            }
        }

        private void EnsureVisible(int row, int col) {
            bool scrollToRequired = false;
            int  scrollToRow =  firstVisibleRow;
            int  scrollToCol = firstVisibleCol;
            if (row < firstVisibleRow
                || row >= firstVisibleRow + numTotallyVisibleRows) {
                scrollToRequired = true;
                scrollToRow = row;
            }

            if (col < firstVisibleCol
                || col == firstVisibleCol && negOffset != 0
                || col > firstVisibleCol && col > lastTotallyVisibleCol) {
                scrollToRequired = true;
                scrollToCol = col;
            }

            if (scrollToRequired) {
                ScrollTo(scrollToRow, scrollToCol);
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.GetCurrentCellBounds"]/*' />
        /// <devdoc>
        /// <para>Gets a <see cref='T:System.Drawing.Rectangle'/>
        /// that specifies the four corners of the selected cell.</para>
        /// </devdoc>
        public Rectangle GetCurrentCellBounds() {
            DataGridCell current = this.CurrentCell;
            return GetCellBounds(current.RowNumber, current.ColumnNumber);
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.GetCellBounds"]/*' />
        /// <devdoc>
        /// <para>Gets the <see cref='T:System.Drawing.Rectangle'/> of the cell specified by row and column number.</para>
        /// </devdoc>
        public Rectangle GetCellBounds(int row, int col) {
            DataGridRow[] localGridRows = DataGridRows;
            Rectangle cellBounds = localGridRows[row].GetCellBounds(col);
            cellBounds.Y += GetRowTop(row);
            cellBounds.X += layout.Data.X - negOffset;
            cellBounds.X = MirrorRectangle(cellBounds, layout.Data, isRightToLeft());
            return cellBounds;
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.GetCellBounds1"]/*' />
        /// <devdoc>
        /// <para>Gets the <see cref='T:System.Drawing.Rectangle'/> of the cell specified by <see cref='System.Windows.Forms.DataGridCell'/>.</para>
        /// </devdoc>
        public Rectangle GetCellBounds(DataGridCell dgc) {
            return GetCellBounds(dgc.RowNumber, dgc.ColumnNumber);
        }

        // UNDONE : ChrisAn, 10/27/00 - using internal hack to expose data for 
        //        : Accessibility, is there a cleaner way to do this?
        //
        internal Rectangle GetRowBounds(DataGridRow row) {
            Rectangle rowBounds = new Rectangle();
            rowBounds.Y = GetRowTop(row.RowNumber);
            rowBounds.X = layout.Data.X;
            rowBounds.Height = row.Height;
            rowBounds.Width = layout.Data.Width;
            return rowBounds;
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.HitTest"]/*' />
        /// <devdoc>
        ///    <para>Gets information, such as row and column number of a
        ///       clicked point on
        ///       the grid,
        ///       using the x
        ///       and y coordinate passed to the method.</para>
        /// </devdoc>
        public HitTestInfo HitTest(int x, int y) {
            int topOfData = layout.Data.Y;
            HitTestInfo ci = new HitTestInfo();

            if (layout.CaptionVisible && layout.Caption.Contains(x,y)) {
                ci.type = HitTestType.Caption;
                return ci;
            }
            if (layout.ParentRowsVisible && layout.ParentRows.Contains(x,y)) {
                ci.type = HitTestType.ParentRows;
                return ci;
            }

            if (!layout.Inside.Contains(x,y))
                return ci;

            if (layout.TopLeftHeader.Contains(x,y))
                return ci;

            // check for column resize
            if (layout.ColumnHeaders.Contains(x,y)) {
                ci.type = HitTestType.ColumnHeader;
                ci.col = GetColFromX(x);
                if (ci.col < 0)
                    return HitTestInfo.Nowhere;
                int right = GetColBeg(ci.col + 1);
                bool rightToLeft = isRightToLeft();
                if ((rightToLeft && x - right < 8) || (!rightToLeft && right - x < 8)) {
                    ci.type = HitTestType.ColumnResize;
                }
                return(allowColumnResize ? ci : HitTestInfo.Nowhere);
            }

            //check for RowResize:
            if (layout.RowHeaders.Contains(x,y)) {
                ci.type = HitTestType.RowHeader;
                ci.row = GetRowFromY(y);
                if (ci.row < 0)
                    return HitTestInfo.Nowhere;

                // find out if the click was a RowResize click
                DataGridRow[] localGridRows = DataGridRows;
                int bottomBorder = GetRowTop(ci.row) + localGridRows[ci.row].Height;
                if (bottomBorder - y - BorderWidth < 2 && !(localGridRows[ci.row] is DataGridAddNewRow)) {
                    ci.type = HitTestType.RowResize;
                }

                return (allowRowResize ? ci : HitTestInfo.Nowhere);
            }

            if (layout.Data.Contains(x,y)) {
                ci.type = HitTestType.Cell;
                ci.col = GetColFromX(x);
                ci.row = GetRowFromY(y);
                if (ci.col < 0 || ci.row < 0) return HitTestInfo.Nowhere;
                return ci;
            }
            return ci;
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.HitTest1"]/*' />
        /// <devdoc>
        ///    <para>Gets information, such as row and column number of a
        ///       clicked point on the grid, about the
        ///       grid using a specific
        ///    <see cref='System.Drawing.Point'/>.</para>
        /// </devdoc>
        public HitTestInfo HitTest(Point position) {
            return HitTest(position.X, position.Y);
        }

        /// <internalonly/>
        /// <devdoc>
        ///      Initializes the values for column widths in the table.
        /// </devdoc>
        private void InitializeColumnWidths() {
            if (myGridTable == null)
                return;

            GridColumnStylesCollection columns = myGridTable.GridColumnStyles;
            int numCols = columns.Count;

            // Resize the columns to a approximation of a best fit.
            // We find the best fit width of NumRowsForAutoResize rows
            // and use it for each column.
            int preferredColumnWidth = this.myGridTable.IsDefault ? this.PreferredColumnWidth : this.myGridTable.PreferredColumnWidth;
            // if we set the PreferredColumnWidth to something else than AutoColumnSize
            // then use that value
            //
            for (int col = 0; col < numCols; col++) {
                // if the column width is not -1, then this column was initialized already
                if (columns[col].width != -1) continue;

                columns[col].width = preferredColumnWidth;
            }
        }

        /// <devdoc>
        ///      Invalidates the scrollable area of the DataGrid.
        /// </devdoc>
        internal void InvalidateInside() {
            Invalidate(layout.Inside);
        }

        /// <devdoc>
        ///      Invalidates the caption area of the DataGrid.
        /// </devdoc>
        internal void InvalidateCaption() {
            if (layout.CaptionVisible)
                Invalidate(layout.Caption);
        }

        /// <devdoc>
        ///      Invalidates a rectangle normalized to the caption's
        ///      visual bounds.
        /// </devdoc>
        internal void InvalidateCaptionRect(Rectangle r) {
            if (layout.CaptionVisible) {
                Invalidate(r);
            }
        }

        /// <devdoc>
        ///      Invalidates the display region of a given DataGridColumn.
        /// </devdoc>
        internal void InvalidateColumn(int column) {
            GridColumnStylesCollection gridColumns = this.myGridTable.GridColumnStyles;
            if (column < 0 || gridColumns == null || gridColumns.Count <= column)
                return;

            Debug.Assert(gridColumns[column].PropertyDescriptor != null, "how can we invalidate a column that is invisible?");
            // bail if the column is not visible.
            if (column < firstVisibleCol || column > firstVisibleCol + numVisibleCols - 1)
                return;

            Rectangle columnArea = new Rectangle();
            columnArea.Height = layout.Data.Height;
            columnArea.Width = gridColumns[column].Width;
            columnArea.Y = layout.Data.Y;

            int x = layout.Data.X - negOffset;
            int gridColumnsCount = gridColumns.Count;
            for (int i = firstVisibleCol; i < gridColumnsCount; ++i) {
                if (i == column)
                    break;
                x += gridColumns[i].Width;
            }
            columnArea.X = x;
            columnArea.X = MirrorRectangle(columnArea, layout.Data, isRightToLeft());
            Invalidate(columnArea);
        }

        /// <devdoc>
        ///      Invalidates the parent rows area of the DataGrid
        /// </devdoc>
        internal void InvalidateParentRows() {
            if (layout.ParentRowsVisible)
                Invalidate(layout.ParentRows);
        }

        /// <devdoc>
        ///      Invalidates a rectangle normalized to the parent
        ///      rows area's visual bounds.
        /// </devdoc>
        internal void InvalidateParentRowsRect(Rectangle r) {
            Rectangle parentRowsRect = layout.ParentRows;
            Invalidate(r);
            if (!parentRowsRect.IsEmpty) {
                //Invalidate(new Rectangle(parentRowsRect.X + r.X, parentRowsRect.Y + r.Y,
                                         // r.Width, r.Height));
            }
        }

        /// <devdoc>
        ///      Invalidate the painting region for the row specified.
        /// </devdoc>
        internal void InvalidateRow(int rowNumber) {
            Rectangle rowRect = GetRowRect(rowNumber);
            if (!rowRect.IsEmpty) {
                Debug.WriteLineIf(CompModSwitches.DataGridPainting.TraceVerbose, "DataGridPainting: Invalidating row " + rowNumber.ToString());
                Invalidate(rowRect);
            }
        }

        private void InvalidateRowHeader(int rowNumber) {
            if (rowNumber >= firstVisibleRow && rowNumber < firstVisibleRow + numVisibleRows) {
                if (!layout.RowHeadersVisible)
                    return;

                Rectangle invalid = new Rectangle();
                invalid.Y = GetRowTop(rowNumber);
                invalid.X = layout.RowHeaders.X;
                invalid.Width = layout.RowHeaders.Width;
                invalid.Height = this.DataGridRows[rowNumber].Height;
                Invalidate(invalid);
            }
        }

        // NOTE:
        // because of Rtl, we assume that the only place that calls InvalidateRowRect is 
        // the DataGridRelationshipRow
        internal void InvalidateRowRect(int rowNumber, Rectangle r) {
            Rectangle rowRect = GetRowRect(rowNumber);
            if (!rowRect.IsEmpty) {
                Debug.WriteLineIf(CompModSwitches.DataGridPainting.TraceVerbose, "DataGridPainting: Invalidating a rect in row " + rowNumber.ToString());
                Rectangle inner = new Rectangle(rowRect.X + r.X, rowRect.Y + r.Y, r.Width, r.Height);
                if (vertScrollBar.Visible && isRightToLeft())
                    inner.X -= vertScrollBar.Width;
                Invalidate(inner);
            }
        }
        
        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.IsExpanded"]/*' />
        /// <devdoc>
        ///    <para>Gets a value that indicates whether a specified row's node is expanded or collapsed.</para>
        /// </devdoc>
        public bool IsExpanded(int rowNumber) {
            if (rowNumber < 0 || rowNumber > DataGridRowsLength)
                throw new ArgumentOutOfRangeException("rowNumber");
            DataGridRow[] localGridRows = DataGridRows;

            // CONSIDER: this works, but is not solid code. Potentially, we may add other
            //           DataGridRow types.  Perhaps Expand, Collapse, etc. should be
            //           moved into the DataGridRow base.
            DataGridRow row = localGridRows[rowNumber];
            if (row is DataGridRelationshipRow) {
                DataGridRelationshipRow relRow = (DataGridRelationshipRow)row;
                return relRow.Expanded;
            }
            else
                return false;
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.IsSelected"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether a
        ///       specified row is selected.
        ///    </para>
        /// </devdoc>
        public bool IsSelected(int row) {
            DataGridRow[] localGridRows = DataGridRows;
            return localGridRows[row].Selected;
        }

        internal static bool IsTransparentColor(Color color) {
            return color.A < 255;
        }

        /// <devdoc>
        ///      Determines if Scrollbars should be visible,
        ///      updates their bounds and the bounds of all
        ///      other regions in the DataGrid's Layout.
        /// </devdoc>
        private void LayoutScrollBars() {
            // if we set the dataSource to null, then take away the scrollbars.
            if (listManager == null || myGridTable == null) {
                horizScrollBar.Visible = false;
                vertScrollBar.Visible = false;
                return;
            }

            // Scrollbars are a tricky issue.
            // We need to see if we can cram our columns and rows
            // in without scrollbars and if they don't fit, we make
            // scrollbars visible and then fixup our regions for the
            // data and headers.
            bool needHorizScrollbar = false;
            bool needVertScrollbar = false;
            bool recountRows = false;
            bool alignToRight = isRightToLeft();

            int nGridCols = myGridTable.GridColumnStyles.Count;

            // if we call LayoutScrollBars before CreateDataGridRows
            // then the columns will have their default width ( 100 )
            // CreateDataGridRows will possibly change the columns' width
            //
            // and anyway, ComputeVisibleRows will call the DataGridRows accessor
            // 
            DataGridRow[] gridRows = this.DataGridRows;

            int totalWidth = GetColumnWidthSum();

            if (totalWidth > layout.Data.Width && !needHorizScrollbar) {
                int horizHeight = horizScrollBar.Height;
                layout.Data.Height -= horizHeight;
                if (layout.RowHeadersVisible)
                    layout.RowHeaders.Height -= horizHeight;
                needHorizScrollbar = true;
            }

            int oldFirstVisibleRow = firstVisibleRow;

            ComputeVisibleRows();
            if (numTotallyVisibleRows != DataGridRowsLength && !needVertScrollbar) {
                int vertWidth = vertScrollBar.Width;
                layout.Data.Width -= vertWidth;
                if (layout.ColumnHeadersVisible)
                {
                    if (alignToRight)
                        layout.ColumnHeaders.X += vertWidth;

                    layout.ColumnHeaders.Width -= vertWidth;
                }
                needVertScrollbar = true;
            }

            this.firstVisibleCol = ComputeFirstVisibleColumn();
            // we compute the number of visible columns only after we set up the vertical scroll bar.
            ComputeVisibleColumns();

            if (needVertScrollbar && totalWidth > layout.Data.Width && !needHorizScrollbar) {
                firstVisibleRow = oldFirstVisibleRow;
                int horizHeight = horizScrollBar.Height;
                layout.Data.Height -= horizHeight;
                if (layout.RowHeadersVisible)
                    layout.RowHeaders.Height -= horizHeight;
                needHorizScrollbar = true;
                recountRows = true;
            }

            if (recountRows) {
                ComputeVisibleRows();
                if (numTotallyVisibleRows != DataGridRowsLength && !needVertScrollbar) {
                    int vertWidth = vertScrollBar.Width;
                    layout.Data.Width -= vertWidth;
                    if (layout.ColumnHeadersVisible)
                    {
                        if (alignToRight)
                            layout.ColumnHeaders.X += vertWidth;

                        layout.ColumnHeaders.Width -= vertWidth;
                    }
                    needVertScrollbar = true;
                }
            }

            layout.ResizeBoxRect = new Rectangle();
            if (needVertScrollbar && needHorizScrollbar) {
                Rectangle data = layout.Data;
                layout.ResizeBoxRect = new Rectangle(alignToRight ? data.X : data.Right,
                                               data.Bottom,
                                               vertScrollBar.Width,
                                               horizScrollBar.Height);
            }


            if (needHorizScrollbar && nGridCols > 0) {
                //Debug.WriteLineIf(CompModSwitches.DataGridScrolling.TraceVerbose, "DataGridScrolling: foo");

                int widthNotVisible = totalWidth - layout.Data.Width;

                horizScrollBar.Minimum      = 0;
                horizScrollBar.Maximum      = totalWidth;
                horizScrollBar.SmallChange  = 1;
                horizScrollBar.LargeChange  = Math.Max(totalWidth - widthNotVisible, 0);
                horizScrollBar.Enabled      = this.Enabled;
                horizScrollBar.RightToLeft  = RightToLeft;
                horizScrollBar.Bounds       = new Rectangle(alignToRight ? layout.Inside.X + layout.ResizeBoxRect.Width : layout.Inside.X,
                                                            layout.Data.Bottom,
                                                            layout.Inside.Width - layout.ResizeBoxRect.Width,
                                                            horizScrollBar.Height);
                horizScrollBar.Visible      = true;
            }
            else if (horizScrollBar.Visible) {
                HorizontalOffset = 0;
                horizScrollBar.Visible = false;
            }

            if (needVertScrollbar) {
                int vertScrollBarTop = layout.Data.Y;
                if (layout.ColumnHeadersVisible)
                    vertScrollBarTop = layout.ColumnHeaders.Y;
                // if numTotallyVisibleRows == 0 ( the height of the row is bigger than the height of
                // the grid ) then scroll in increments of 1.
                vertScrollBar.LargeChange = numTotallyVisibleRows != 0 ? numTotallyVisibleRows : 1;
                vertScrollBar.Bounds = new Rectangle(alignToRight ? layout.Data.X : layout.Data.Right,
                                                     vertScrollBarTop,
                                                     vertScrollBar.Width,
                                                     layout.Data.Height + layout.ColumnHeaders.Height);
                vertScrollBar.Enabled = this.Enabled;
                vertScrollBar.Visible = true;
                if (alignToRight)
                    layout.Data.X += vertScrollBar.Width;
            }
            else if (vertScrollBar.Visible) {
                vertScrollBar.Visible = false;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.NavigateBack"]/*' />
        /// <devdoc>
        ///    <para>Navigates back to the table previously displayed in the grid.</para>
        /// </devdoc>
        public void NavigateBack() {
            if (!CommitEdit() || parentRows.IsEmpty())
                return;
            // when navigating back, if the grid is inAddNewRow state, cancel the currentEdit.
            // we do not need to recreate the rows cause we are navigating back.
            // the grid will catch any exception that happens.
            if (gridState[GRIDSTATE_inAddNewRow]) {
                gridState[GRIDSTATE_inAddNewRow] = false;
                try {
                    listManager.CancelCurrentEdit();
                } catch {
                }
            } else {
                UpdateListManager();
            }

            
            DataGridState newState = parentRows.PopTop();

            ResetMouseState();

            newState.PullState(this, false);                // we do not want to create columns when navigating back

            // we need to have originalState != null when we process
            // Set_ListManager in the NavigateBack/NavigateTo methods.
            // otherwise the DataSource_MetaDataChanged event will not get registered
            // properly
            if (parentRows.GetTopParent() == null)
                originalState = null;

            DataGridRow[] localGridRows = this.DataGridRows;
            // what if the user changed the ReadOnly property
            // on the grid while the user was navigating to the child rows?
            //
            // what if the policy does not allow for allowAdd?
            //
            if ((this.ReadOnly || !policy.AllowAdd) == (localGridRows[DataGridRowsLength -1] is DataGridAddNewRow)) {
                int newDataGridRowsLength = (ReadOnly || !policy.AllowAdd) ? DataGridRowsLength - 1 : DataGridRowsLength + 1;
                DataGridRow[] newDataGridRows = new DataGridRow[newDataGridRowsLength];
                for (int i = 0; i < Math.Min(newDataGridRowsLength, DataGridRowsLength); i++) {
                    newDataGridRows[i] = DataGridRows[i];
                }
                if(!this.ReadOnly && policy.AllowAdd)
                    newDataGridRows[newDataGridRowsLength - 1] = new DataGridAddNewRow(this, this.myGridTable, newDataGridRowsLength-1);
                SetDataGridRows(newDataGridRows, newDataGridRowsLength);
            }

            // when we navigate back from a child table, 
            // it may be the case that in between the user added a tableStyle that is different
            // from the one that is currently in the grid
            // in that case, we need to reset the dataGridTableStyle in the rows
            localGridRows = this.DataGridRows;
            if (localGridRows != null && localGridRows.Length != 0) {
                DataGridTableStyle dgTable = localGridRows[0].DataGridTableStyle;
                if (dgTable != this.myGridTable) {
                    for (int i = 0; i < localGridRows.Length; i ++)
                        localGridRows[i].DataGridTableStyle = this.myGridTable;
                }
            }

            // if we have the default table, when we navigate back
            // we also have the default gridColumns, w/ width = -1
            // we need to set the width on the new gridColumns
            //
            if (this.myGridTable.GridColumnStyles.Count > 0 && this.myGridTable.GridColumnStyles[0].Width == -1) {
#if DEBUG
                GridColumnStylesCollection cols = this.myGridTable.GridColumnStyles;
                for (int i = 0; i < cols.Count; i++) {
                    Debug.Assert(cols[i].Width == -1, "Sanity check");
                }
                Debug.Assert(this.myGridTable.IsDefault, "when we navigate to the parent rows and the columns have widths -1 we are using the default table");
#endif // DEBUG
                InitializeColumnWidths();
            }

            // reset the currentRow to the old position in the listmanager:
            currentRow = this.ListManager.Position == -1 ? 0 : this.ListManager.Position;

            // if the AllowNavigation changed while the user was navigating the 
            // child tables, so that the new navigation mode does not allow childNavigation anymore
            // then reset the rows
            if (!AllowNavigation) {
                RecreateDataGridRows();
            }

            caption.BackButtonActive = (parentRows.GetTopParent() != null) && AllowNavigation;
            caption.BackButtonVisible = caption.BackButtonActive;
            caption.DownButtonActive = (parentRows.GetTopParent() != null);

            PerformLayout();
            Invalidate();
            // reposition the scroll bar
            if (vertScrollBar.Visible)
                vertScrollBar.Value = firstVisibleRow;
            if (horizScrollBar.Visible)
                horizScrollBar.Value = HorizontalOffset + negOffset;
            Edit();
            OnNavigate(new NavigateEventArgs(false));
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.NavigateTo"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Navigates to the table specified by row and relation
        ///       name.
        ///    </para>
        /// </devdoc>
        public void NavigateTo(int rowNumber, String relationName) {
            // do not navigate if AllowNavigation is set to false
            if (!AllowNavigation)
                return;
            DataGridRow[] localGridRows = DataGridRows;
            if (rowNumber < 0 || rowNumber > DataGridRowsLength - (policy.AllowAdd ? 2:1)) {
                throw new ArgumentOutOfRangeException("rowNumber");
            }
            EnsureBound();

            DataGridRow source = localGridRows[rowNumber];

            NavigateTo(relationName, source, false);
        }

        internal void NavigateTo(string relationName, DataGridRow source, bool fromRow) {
            // do not navigate if AllowNavigation is set to false
            if (!AllowNavigation)
                return;
            // Commit the edit if possible
            if (!CommitEdit())
                return;

            DataGridState childState;
            try {
                childState = CreateChildState(relationName, source);
            } catch (Exception) {
                // if we get an error when creating the RelatedCurrencyManager
                // then navigateBack and ignore the exception.
                //
                NavigateBack();
                return;
            }

            // call EndCurrentEdit before navigating.
            // if we get an exception, we do not navigate.
            //
            try {
                this.listManager.EndCurrentEdit();
            }
            catch (Exception) {
                return;
            }

            // Preserve our current state
            // we need to do this after the EndCurrentEdit, otherwise the
            // DataGridState will get the listChanged event from the EndCurrentEdit
            DataGridState dgs = new DataGridState(this);
            dgs.LinkingRow = source;

            // we need to update the Position in the ListManager
            // ( the RelatedListManager uses only the position in the parentManager
            //   to create the childRows
            //
            // before the code was calling CurrentCell = this and such
            // we should only call EndCurrentEdit ( which the code was doing anyway )
            // and then set the position in the listManager to the new row.
            //
            if (source.RowNumber != CurrentRow)
                this.listManager.Position = source.RowNumber;

            // We save our state if the parent rows stack is empty.
            if (parentRows.GetTopParent() == null) {
                originalState = dgs;
            }

            parentRows.AddParent(dgs);

            NavigateTo(childState);

            OnNavigate(new NavigateEventArgs(true));
            if (fromRow) {
                // OnLinkClick(EventArgs.Empty);
            }
        }

        private void NavigateTo(DataGridState childState) {
            // we are navigating... better stop editing.
            EndEdit();

            // also, we are no longer in editOrNavigate mode either
            gridState[GRIDSTATE_isNavigating] = false;

            // reset hot tracking
            ResetMouseState();

            // Retrieve the child state
            childState.PullState(this, true);               // true for creating columns when we navigate to child rows

            if (this.listManager.Position != this.currentRow) {
                this.currentRow = listManager.Position == -1 ? 0 : listManager.Position;
            }

            if (parentRows.GetTopParent() != null) {
                caption.BackButtonActive = AllowNavigation;
                caption.BackButtonVisible = caption.BackButtonActive;
                caption.DownButtonActive = true;
            }

            HorizontalOffset = 0;
            PerformLayout();
            Invalidate();
        }


        /// <devdoc>
        ///      Given a coordinate in the control this method returns
        ///      the equivalent point for a row.
        /// </devdoc>
        private Point NormalizeToRow(int x, int y, int row) {
            Debug.Assert(row >= firstVisibleRow && row < firstVisibleRow + numVisibleRows,
                         "Row " + row.ToString() + "is not visible! firstVisibleRow = " +
                         firstVisibleRow.ToString() + ", numVisibleRows = " +
                         numVisibleRows.ToString());
            Point origin = new Point(0, layout.Data.Y);

            DataGridRow[] localGridRows = DataGridRows;
            for (int r = firstVisibleRow; r < row; ++r) {
                origin.Y += localGridRows[r].Height;
            }
            // when hittesting for the PlusMinus, the code in the DataGridRelationshipRow
            // will use real X coordinate ( the one from layout.RowHeaders ) to paint the glyph
            // 
            return new Point(x, y - origin.Y);
        }

        internal void OnColumnCollectionChanged(object sender, CollectionChangeEventArgs e) {
            DataGridTableStyle table = (DataGridTableStyle)sender;
            if (table.Equals(this.myGridTable)) {
                // if we changed the column collection, then we need to set the property
                // descriptors in the column collection.
                // unless the user set the propertyDescriptor in the columnCollection
                //
                if (!this.myGridTable.IsDefault) {
                    // if the element in the collectionChangeEventArgs is not null
                    // and the action is refresh, then it means that the user
                    // set the propDesc. we do not want to override this.
                    if (e.Action != CollectionChangeAction.Refresh || e.Element == null)
                        PairTableStylesAndGridColumns(this.listManager, this.myGridTable, false);
                }
                Invalidate();
                PerformLayout();
            }
        }

        /// <devdoc>
        ///      Paints column headers.
        /// </devdoc>
        private void PaintColumnHeaders(Graphics g) {

            bool alignToLeft = isRightToLeft();
            Rectangle boundingRect = layout.ColumnHeaders;
            if (!alignToLeft)
                boundingRect.X -= negOffset;
            boundingRect.Width += negOffset;

            int columnHeaderWidth = PaintColumnHeaderText(g, boundingRect);

            if (alignToLeft)
                boundingRect.X = boundingRect.Right - columnHeaderWidth;

            boundingRect.Width = columnHeaderWidth;
            if (!FlatMode) {
                ControlPaint.DrawBorder3D(g, boundingRect, Border3DStyle.RaisedInner);
                boundingRect.Inflate(-1, -1);
                // g.SetPen(OldSystemPens.Control);
                // g.OldBrush = (OldSystemBrushes.Hollow);
                boundingRect.Width --;
                boundingRect.Height--;
                g.DrawRectangle(SystemPens.Control, boundingRect);
            }
        }

        private int PaintColumnHeaderText(Graphics g, Rectangle boundingRect) {
            int cx = 0;
            Rectangle textBounds = boundingRect;
            GridColumnStylesCollection gridColumns = this.myGridTable.GridColumnStyles;
            bool alignRight = isRightToLeft();


            int nGridCols = gridColumns.Count;
            // for sorting
            PropertyDescriptor sortProperty = null;
            sortProperty = this.ListManager.GetSortProperty();

            // Now paint the column header text!
            for (int col = firstVisibleCol; col < nGridCols; ++col) {
                if (gridColumns[col].PropertyDescriptor == null)
                    continue;

                if (cx > boundingRect.Width)
                    break;

                bool columnSorted = sortProperty != null && sortProperty.Equals(gridColumns[col].PropertyDescriptor);
                TriangleDirection whichWay = TriangleDirection.Up;
                if (columnSorted)
                {
                    ListSortDirection direction = this.ListManager.GetSortDirection();
                    if (direction == ListSortDirection.Descending)
                        whichWay = TriangleDirection.Down;
                }

                if (alignRight)
                {
                    textBounds.Width = gridColumns[col].Width -
                                       (columnSorted ? textBounds.Height : 0);
                    textBounds.X = boundingRect.Right - cx - textBounds.Width;
                }
                else
                {
                    textBounds.X = boundingRect.X + cx;
                    textBounds.Width = gridColumns[col].Width -
                                       (columnSorted ? textBounds.Height : 0);
                }

                // at the moment we paint some pixels twice.
                // we should not call FilLRectangle, once the real GDI+ is there, we will have no need to do that

                // if the user set the HeaderBackBrush property on the 
                // dataGrid, then use that property
                Brush headerBrush;
                if (this.myGridTable.IsDefault)
                    headerBrush = HeaderBackBrush;
                else
                    headerBrush = this.myGridTable.HeaderBackBrush;
                
                g.FillRectangle(headerBrush, textBounds);
                // granted, the code would be a lot cleaner if we were using a "new Rectangle"
                // but like this will be faster
                if (alignRight)
                {
                    textBounds.X -= 2; textBounds.Y += 2;
                }
                else
                {
                    textBounds.X += 2; textBounds.Y += 2;
                }
                           
                StringFormat format = new StringFormat();

                // the columnHeaderText alignment should be the same as
                // the alignment in the column
                //
                HorizontalAlignment colAlignment = gridColumns[col].Alignment;
                format.Alignment = colAlignment == HorizontalAlignment.Right ?   StringAlignment.Far : 
                                   colAlignment == HorizontalAlignment.Center ?  StringAlignment.Center :
                                                                                 StringAlignment.Near;

                // part 1, section 1: the column headers should not wrap
                format.FormatFlags |= StringFormatFlags.NoWrap;

                if (alignRight) {
                    format.FormatFlags |= StringFormatFlags.DirectionRightToLeft;
                    format.Alignment = StringAlignment.Near;
                }
                g.DrawString(gridColumns[col].HeaderText,
                             this.myGridTable.IsDefault ? this.HeaderFont : this.myGridTable.HeaderFont,
                             this.myGridTable.IsDefault ? this.HeaderForeBrush : this.myGridTable.HeaderForeBrush,
                             textBounds,
                             format);
                format.Dispose();
                
                if (alignRight)
                {
                    textBounds.X += 2; textBounds.Y -= 2;
                }
                else
                {
                    textBounds.X -= 2; textBounds.Y -= 2;
                }

                if (columnSorted) {
                    // CONSIDER: This triangle painting is pretty unclean
                    //           perhaps this should be a bitmap?
                    Rectangle triBounds = new Rectangle(alignRight ? textBounds.X  - textBounds.Height : textBounds.Right,
                                                        textBounds.Y,
                                                        textBounds.Height,
                                                        textBounds.Height);

                    g.FillRectangle(headerBrush, triBounds);
                    int deflateValue = Math.Max(0,(textBounds.Height - 5) / 2);
                    triBounds.Inflate(-deflateValue, -deflateValue);

                    Pen pen1 = new Pen(this.BackgroundBrush);
                    Pen pen2 = new Pen(this.myGridTable.BackBrush);
                    Triangle.Paint(g, triBounds, whichWay, headerBrush, pen1, pen2, pen1, true);
                    pen1.Dispose();
                    pen2.Dispose();
                }
                int paintedWidth = textBounds.Width + (columnSorted ? textBounds.Height : 0);

                if (!FlatMode) {
                    if (alignRight && columnSorted)
                        textBounds.X -= textBounds.Height;
                    textBounds.Width = paintedWidth;

                    ControlPaint.DrawBorder3D(g, textBounds, Border3DStyle.RaisedInner);
                }
                cx += paintedWidth;
            }

            // paint the possible exposed portion to the right ( or left, as the case may be)
            if (cx < boundingRect.Width) {
                textBounds = boundingRect;

                if (!alignRight)
                    textBounds.X += cx;

                textBounds.Width -= cx;
                g.FillRectangle(backgroundBrush, textBounds);
            }
            return cx;
        }

        
        /// <devdoc>
        ///      Paints a border around the bouding rectangle given
        /// </devdoc>
        private void PaintBorder(Graphics g, Rectangle bounds)
        {
            if (BorderStyle == BorderStyle.None)
                return;
            if (BorderStyle == BorderStyle.Fixed3D) {
                Border3DStyle style = Border3DStyle.Sunken;
                ControlPaint.DrawBorder3D(g, bounds, style );
            }
            else if (BorderStyle == BorderStyle.FixedSingle) {
                Brush br;

                if (this.myGridTable.IsDefault)
                    br = this.HeaderForeBrush;
                else
                    br = this.myGridTable.HeaderForeBrush;
                g.FillRectangle(br, bounds.X, bounds.Y, bounds.Width + 2, 2);
                g.FillRectangle(br, bounds.Right - 2, bounds.Y, 2, bounds.Height + 2);
                g.FillRectangle(br, bounds.X, bounds.Bottom - 2, bounds.Width + 2, 2);
                g.FillRectangle(br, bounds.X, bounds.Y, 2, bounds.Height + 2);
            }
            else {
                Pen pen = SystemPens.WindowFrame;
                bounds.Width --;
                bounds.Height--;
                g.DrawRectangle(pen, bounds);
            }
        }

        /// <devdoc>
        ///      Paints the grid in the bounding rectangle given.
        ///      This includes the column headers and each visible row.
        /// </devdoc>
        private void PaintGrid(Graphics g, Rectangle gridBounds) {
            Debug.WriteLineIf(CompModSwitches.DataGridPainting.TraceVerbose, "DataGridPainting: PaintGrid on " + gridBounds.ToString());

            Rectangle rc = gridBounds;

            if (this.listManager != null) {
                if (layout.ColumnHeadersVisible) {
                    Region r = g.Clip;
                    g.SetClip(layout.ColumnHeaders);
                    PaintColumnHeaders(g);
                    g.Clip = r;
                    r.Dispose();
                    int columnHeaderHeight = layout.ColumnHeaders.Height;
                    rc.Y += columnHeaderHeight;
                    rc.Height -= columnHeaderHeight;
                }

                if (layout.TopLeftHeader.Width > 0) {
                    if (this.myGridTable.IsDefault)
                        g.FillRectangle(this.HeaderBackBrush, layout.TopLeftHeader);
                    else
                        g.FillRectangle(this.myGridTable.HeaderBackBrush, layout.TopLeftHeader);

                    if (!FlatMode) {
                        ControlPaint.DrawBorder3D(g, layout.TopLeftHeader, Border3DStyle.RaisedInner);
                    }
                }

                PaintRows(g, ref rc) ;
            }

            // paint the possible exposed portion below
            if (rc.Height > 0) {
                g.FillRectangle(backgroundBrush, rc);
            }
        }

        private void DeleteDataGridRows(int deletedRows) {
            if (deletedRows == 0)
                return;

            int currentRowCount = DataGridRowsLength;
            int newDataGridRowsLength = currentRowCount - deletedRows + (gridState[GRIDSTATE_inAddNewRow] ? 1:0);
            DataGridRow[] newDataGridRows = new DataGridRow[newDataGridRowsLength];
            DataGridRow[] gridRows = DataGridRows;

            // the number of selected entries so far in the array
            int selectedEntries = 0;

            for (int i = 0; i < currentRowCount; i++) {
                if (gridRows[i].Selected) {
                    selectedEntries ++;
                } else {
                    newDataGridRows[i - selectedEntries] = gridRows[i];
                    newDataGridRows[i - selectedEntries].number = i - selectedEntries;
                }
            }

            if (gridState[GRIDSTATE_inAddNewRow]) {
                newDataGridRows[currentRowCount - selectedEntries] = new DataGridAddNewRow(this, this.myGridTable, currentRowCount - selectedEntries);
                gridState[GRIDSTATE_inAddNewRow] = false;
            }

            Debug.Assert(selectedEntries == deletedRows, "all the rows that would have been deleted should have been selected: selectedGridEntries " + selectedEntries.ToString() + " deletedRows " + deletedRows.ToString());

            SetDataGridRows(newDataGridRows, newDataGridRowsLength);
        }

        /// <devdoc>
        ///      Paints the visible rows on the grid.
        /// </devdoc>
        private void PaintRows(Graphics g, ref Rectangle boundingRect) {
            int cy = 0;
            bool alignRight = isRightToLeft();
            Rectangle rowBounds = boundingRect;
            Rectangle dataBounds = Rectangle.Empty;
            bool paintRowHeaders = layout.RowHeadersVisible;
            Rectangle headerBounds = Rectangle.Empty;


            int numRows = DataGridRowsLength;
            DataGridRow[] localGridRows = DataGridRows;
            int numCols = myGridTable.GridColumnStyles.Count - firstVisibleCol;

            for (int row = firstVisibleRow; row < numRows; row++) {
                if (cy > boundingRect.Height)
                    break;

                rowBounds = boundingRect;
                rowBounds.Height = localGridRows[row].Height;
                rowBounds.Y = boundingRect.Y + cy;

                // will add some errors
#if false
                if (forDebug == 0 || forDebug == 1)
                {
                    object dRowView = listManager[row];
                    DataRow dRow= ((DataRowView) dRowView).Row;
                    // dRow.RowError = "Error " + forDebug.ToString();
                    dRow.SetColumnError(forDebug, "another error " + forDebug.ToString());

                    /*
                    if (localGridRows[row].DataRow != null)
                    {
                        localGridRows[row].DataRow.RowError = "error " + forDebug.ToString();
                        localGridRows[row].DataRow.SetColumnError(forDebug, "another error " + forDebug.ToString());
                    }
                    */
                    forDebug ++;
                }
#endif // false
                if (paintRowHeaders) {
                    headerBounds = rowBounds;
                    headerBounds.Width  = layout.RowHeaders.Width;

                    if (alignRight)
                    {
                        headerBounds.X = rowBounds.Right - headerBounds.Width;
                    }
                    
                    if (g.IsVisible(headerBounds)) {
                        localGridRows[row].PaintHeader(g, headerBounds, alignRight, gridState[GRIDSTATE_isEditing]);
                        g.ExcludeClip(headerBounds);
                    }

                    if (!alignRight)
                        rowBounds.X += headerBounds.Width;
                    rowBounds.Width -= headerBounds.Width;
                }
                if (g.IsVisible(rowBounds)) {
                    dataBounds = rowBounds;
                    if (!alignRight)
                        dataBounds.X -= negOffset;
                    dataBounds.Width += negOffset;

                    localGridRows[row].Paint(g, dataBounds, rowBounds, firstVisibleCol, numCols, alignRight);
                }
                cy += rowBounds.Height;
            }
            boundingRect.Y += cy;
            boundingRect.Height -= cy;
        }


        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ProcessDialogKey"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value that indicates whether a key should be processed
        ///       further.
        ///    </para>
        /// </devdoc>
        protected override bool ProcessDialogKey(Keys keyData) {
            Debug.WriteLineIf(CompModSwitches.DataGridKeys.TraceVerbose, "DataGridKeys: ProcessDialogKey " + TypeDescriptor.GetConverter(typeof(Keys)).ConvertToString(keyData));
            DataGridRow[] localGridRows = DataGridRows;
            if (listManager  != null && DataGridRowsLength > 0 && localGridRows[currentRow].OnKeyPress(keyData)) {
                Debug.WriteLineIf(CompModSwitches.DataGridKeys.TraceVerbose, "DataGridKeys: Current Row ate the keystroke");
                return true;
            }

            switch (keyData & Keys.KeyCode) {
                case Keys.Tab:
                case Keys.Up:
                case Keys.Down:
                case Keys.Left:
                case Keys.Right:
                case Keys.Next:
                case Keys.Prior:
                case Keys.Enter:
                case Keys.Escape:
                case Keys.Oemplus:
                case Keys.Add:
                case Keys.OemMinus:
                case Keys.Subtract:
                case Keys.Space:
                case Keys.Delete:
                case Keys.A:
                    KeyEventArgs ke = new KeyEventArgs(keyData);
                    if (ProcessGridKey(ke))
                        return true;
                    break;

                case Keys.C:
                    if ((keyData & Keys.Control) != 0 && (keyData & Keys.Alt) == 0)
                    {
                        // the user pressed Ctrl-C
                        if (!Bound)
                            break;

                        // need to distinguish between selecting a set of rows, and
                        // selecting just one column.
                        if (numSelectedRows == 0)
                        {
                            // copy the data from one column only
                            if (currentRow < ListManager.Count)
                            {
                                GridColumnStylesCollection columns = myGridTable.GridColumnStyles;
                                DataGridColumnStyle column = columns[currentCol];
                                string text = column.GetDisplayText(column.GetColumnValueAtRow(ListManager, currentRow));

                                // copy the data to the clipboard
                                Clipboard.SetDataObject(text);
                                return true;
                            }

                        }
                        else
                        {
                            // the user selected a set of rows to copy the data from

                            int numRowsOutputted = 0;           // the number of rows written to "text"
                            string text = "";

                            for (int i = 0; i < DataGridRowsLength; ++i)
                            {
                                if (localGridRows[i].Selected)
                                {
                                    GridColumnStylesCollection columns = myGridTable.GridColumnStyles;
                                    int numCols = columns.Count;
                                    for (int j = 0; j < numCols; j++)
                                    {
                                        DataGridColumnStyle column = columns[j];
                                        text += column.GetDisplayText(column.GetColumnValueAtRow(ListManager, i));

                                        // do not put the delimiter at the end of the last column
                                        if ( j < numCols - 1)
                                        {
                                            text += GetOutputTextDelimiter();
                                        }
                                    }

                                    // put the hard enter "\r\n" only if this is not the last selected row
                                    if (numRowsOutputted < numSelectedRows - 1)
                                    {
                                        text += "\r\n";
                                    }

                                    numRowsOutputted ++;
                                }
                            }

                            // copy the data to the clipboard
                            Clipboard.SetDataObject(text);
                            return true;
                        }

                    }
                    break;
            }
            return base.ProcessDialogKey(keyData);
        }

        private void DeleteRows(DataGridRow[] localGridRows) {
            int rowsDeleted = 0;
            BeginUpdateInternal();
            try {
                if (this.ListManager != null) {
                    for (int i = 0; i < this.DataGridRowsLength; i++) {
                        if (localGridRows[i].Selected) {
                            if (localGridRows[i] is DataGridAddNewRow) {
                                Debug.Assert(i == DataGridRowsLength - 1, "the location of addNewRow is " + i.ToString() + " and there are " + DataGridRowsLength.ToString() + " rows ");
                                localGridRows[i].Selected = false;
                            }
                            else {
                                this.ListManager.RemoveAt(i - rowsDeleted);
                                rowsDeleted ++;
                            }
                        }
                    }
                }
            } catch (Exception ex) {
                // if we got an exception from the back end
                // when deleting the rows then we should reset
                // our rows and re-throw the exception
                //
                RecreateDataGridRows();
                gridState[GRIDSTATE_inDeleteRow] = false;
                EndUpdateInternal();
                throw ex;
            }
            // keep the copy of the old rows in place
            //
            DeleteDataGridRows(rowsDeleted);
            gridState[GRIDSTATE_inDeleteRow] = false;
            EndUpdateInternal();
        }


        // convention:
        // if we return -1 it means that the user was going left and there were no visible columns to the left of the current one
        // if we return cols.Count + 1 it means that the user was going right and there were no visible columns to the right of the currrent
        private int MoveLeftRight(GridColumnStylesCollection cols, int startCol, bool goRight) {
            int i;
            if (goRight) {
                for (i = startCol + 1; i < cols.Count; i++) {
                    // if (cols[i].Visible && cols[i].PropertyDescriptor != null)
                    if (cols[i].PropertyDescriptor != null)
                        return i;
                }
                return i;
            } else {
                for (i = startCol - 1; i>=0; i--) {
                    // if (cols[i].Visible && cols[i].PropertyDescriptor != null)
                    if (cols[i].PropertyDescriptor != null)
                        return i;
                }
                return i;
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ProcessGridKey"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Processes keys for grid navigation.
        ///    </para>
        /// </devdoc>
        [
            SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)
        ]
        protected bool ProcessGridKey(KeyEventArgs ke) {
            Debug.WriteLineIf(CompModSwitches.DataGridKeys.TraceVerbose, "DataGridKeys: ProcessGridKey "+ TypeDescriptor.GetConverter(typeof(Keys)).ConvertToString(ke.KeyCode));
            if (listManager == null || myGridTable == null)
                return false;

            DataGridRow[] localGridRows = DataGridRows;
            KeyEventArgs biDiKe = ke;
            // check for Bi-Di
            //
            if (isRightToLeft())
            {
                switch(ke.KeyCode) {
                    case Keys.Left:
                        biDiKe = new KeyEventArgs((Keys.Right | ke.Modifiers));
                        break;
                    case Keys.Right:
                        biDiKe = new KeyEventArgs((Keys.Left | ke.Modifiers));
                        break;
                    default:
                        break;
                }
            }

            GridColumnStylesCollection cols = this.myGridTable.GridColumnStyles;
            int firstColumnMarkedVisible = 0;
            int lastColumnMarkedVisible = cols.Count;
            for (int i = 0; i < cols.Count; i++) {
                if (cols[i].PropertyDescriptor != null) {
                    firstColumnMarkedVisible = i;
                    break;
                }
            }

            for (int i = cols.Count - 1 ; i >= 0; i--) {
                if (cols[i].PropertyDescriptor != null) {
                    lastColumnMarkedVisible = i;
                    break;
                }
            }

            switch (biDiKe.KeyCode) {
                case Keys.Tab:
                    return ProcessTabKey(biDiKe.KeyData);
                case Keys.Up:
                    gridState[GRIDSTATE_childLinkFocused] = false;
                    if (biDiKe.Control && !biDiKe.Alt)
                    {
                        if (biDiKe.Shift)
                        {
                            DataGridRow [] gridRows = DataGridRows;

                            int savedCurrentRow = currentRow;
                            CurrentRow = 0;

                            ResetSelection();

                            for (int i = 0; i <= savedCurrentRow; i ++)
                                gridRows[i].Selected = true;
                            numSelectedRows = savedCurrentRow + 1;
                            // hide the edit box
                            //
                            EndEdit();
                            return true;
                        }
                        // do not make the parentRowsVisible = false;
                        // ParentRowsVisible = false;
                        ResetSelection();
                        CurrentRow = 0;
                        Debug.Assert(ListManager.Position == CurrentCell.RowNumber || listManager.Count == 0, "current row out of ssync with DataSource");
                        return true;
                    }
                    else if (biDiKe.Shift)
                    {
                        DataGridRow [] gridRows = DataGridRows;
                        // keep a continous selected region
                        if (gridRows[currentRow].Selected) {
                            if (currentRow >= 1) {
                                if (gridRows[currentRow - 1].Selected) {
                                    if (currentRow >= DataGridRowsLength - 1 || !gridRows[currentRow+1].Selected) {
                                        numSelectedRows --;
                                        gridRows[currentRow].Selected = false;
                                    }
                                } else {
                                    numSelectedRows += gridRows[currentRow -1].Selected ? 0:1;
                                    gridRows[currentRow - 1].Selected = true;
                                }
                                CurrentRow --;
                            }
                        } else {
                            numSelectedRows ++;
                            gridRows[currentRow].Selected = true;
                            if (currentRow >= 1) {
                                numSelectedRows += gridRows[currentRow-1].Selected ? 0:1;
                                gridRows[currentRow-1].Selected = true;
                                CurrentRow --;
                            }
                        }

                        // hide the edit box:
                        // 
                        EndEdit();
                        Debug.Assert(ListManager.Position == CurrentCell.RowNumber || listManager.Count == 0, "current row out of ssync with DataSource");
                        return true;
                    }
                    else if (biDiKe.Alt)
                    {
                        // will need to collapse all child table links
                        // -1 is for all rows, and false is for collapsing the rows
                        SetRowExpansionState(-1, false);
                        Debug.Assert(ListManager.Position == CurrentCell.RowNumber || listManager.Count == 0, "current row out of ssync with DataSource");
                        return true;
                    }
                    ResetSelection();
                    CurrentRow = CurrentRow - 1;
                    Debug.Assert(ListManager.Position == CurrentCell.RowNumber || listManager.Count == 0, "current row out of ssync with DataSource");
                    break;
                case Keys.Down:
                    gridState[GRIDSTATE_childLinkFocused] = false;
                    if (biDiKe.Control && !biDiKe.Alt)
                    {
                        if (biDiKe.Shift)
                        {
                            int savedCurrentRow = currentRow;
                            CurrentRow = Math.Max(0, DataGridRowsLength - (policy.AllowAdd ? 2:1));
                            DataGridRow [] gridRows = DataGridRows;

                            ResetSelection();

                            for (int i = savedCurrentRow; i <= currentRow; i++)
                                gridRows[i].Selected = true;

                            numSelectedRows = currentRow - savedCurrentRow + 1;
                            // hide the edit box
                            //
                            EndEdit();
                            return true;
                        }
                        // do not make the parentRowsVisible = true;
                        // ParentRowsVisible = true;
                        ResetSelection();
                        CurrentRow = Math.Max(0, DataGridRowsLength - (policy.AllowAdd ? 2 : 1));
                        Debug.Assert(ListManager.Position == CurrentCell.RowNumber || listManager.Count == 0, "current row out of ssync with DataSource");
                        return true;
                    }
                    else if (biDiKe.Shift)
                    {
                        DataGridRow [] gridRows = DataGridRows;

                        // keep a continous selected region
                        if (gridRows[currentRow].Selected) {

                            // -1 because we index from 0
                            if (currentRow < DataGridRowsLength - (policy.AllowAdd ? 1:0) - 1) {
                                if (gridRows[currentRow + 1].Selected) {
                                    if (currentRow == 0 || !gridRows[currentRow - 1].Selected) {
                                        numSelectedRows --;
                                        gridRows[currentRow].Selected = false;
                                    }
                                } else {
                                    numSelectedRows += gridRows[currentRow + 1].Selected ? 0:1;
                                    gridRows[currentRow + 1].Selected = true;
                                }

                                CurrentRow ++;
                            }
                        } else {
                            numSelectedRows ++;
                            gridRows[currentRow].Selected = true;
                            // -1 because we index from 0, and -1 so this is not the last row
                            // so it adds to -2
                            if (currentRow < DataGridRowsLength - (policy.AllowAdd ? 1:0) - 1) {
                                CurrentRow ++;
                                numSelectedRows += gridRows[currentRow].Selected ? 0:1;
                                gridRows[currentRow].Selected = true;
                            }
                        }

                        // hide the edit box:
                        //
                        EndEdit();
                        Debug.Assert(ListManager.Position == CurrentCell.RowNumber || listManager.Count == 0, "current row out of ssync with DataSource");
                        return true;
                    }
                    else if (biDiKe.Alt)
                    {
                        // will need to expande all child table links
                        // -1 is for all rows, and true is for expanding the rows
                        SetRowExpansionState(-1, true);
                        return true;
                    }
                    ResetSelection();
                    CurrentRow = CurrentRow + 1;
                    Debug.Assert(ListManager.Position == CurrentCell.RowNumber || listManager.Count == 0, "current row out of ssync with DataSource");
                    break;
                case Keys.OemMinus:
                case Keys.Subtract:
                    gridState[GRIDSTATE_childLinkFocused] = false;
                    if (biDiKe.Control && !biDiKe.Alt)
                    {
                        SetRowExpansionState(-1, false);
                        return true;
                    }
                    return false;
                case Keys.Oemplus:
                case Keys.Add:
                    gridState[GRIDSTATE_childLinkFocused] = false;
                    if (biDiKe.Control)
                    {
                        SetRowExpansionState(-1, true);
                        // hide the edit box
                        //
                        EndEdit();
                        return true;
                    }
                    return false;
                case Keys.Space:
                    gridState[GRIDSTATE_childLinkFocused] = false;
                    if (biDiKe.Shift)
                    {
                        ResetSelection();
                        EndEdit();
                        DataGridRow [] gridRows = DataGridRows;
                        gridRows[currentRow].Selected = true;
                        numSelectedRows = 1;

                        return true;
                    }
                    return false;
                case Keys.Next:
                    gridState[GRIDSTATE_childLinkFocused] = false;
                    if (biDiKe.Shift)
                    {
                        int savedCurrentRow = currentRow;
                        CurrentRow = Math.Min(DataGridRowsLength - (policy.AllowAdd ? 2:1), currentRow + numTotallyVisibleRows);

                        DataGridRow [] gridRows = DataGridRows;
                        for (int i = savedCurrentRow; i <= currentRow; i++)
                        {
                            if (!gridRows[i].Selected)
                            {
                                gridRows[i].Selected = true;
                                numSelectedRows ++;
                            }
                        }
                        // hide edit box
                        //
                        EndEdit();
                    } else if (biDiKe.Control && !biDiKe.Alt) {
                        // map ctrl-pageDown to show the parentRows
                        ParentRowsVisible = true;
                    }
                    else
                    {
                        ResetSelection();
                        CurrentRow = Math.Min(DataGridRowsLength - (policy.AllowAdd ? 2:1),
                                              CurrentRow + numTotallyVisibleRows);
                    }
                    break;
                case Keys.Prior:
                    gridState[GRIDSTATE_childLinkFocused] = false;
                    if (biDiKe.Shift)
                    {
                        int savedCurrentRow = currentRow;
                        CurrentRow = Math.Max(0, CurrentRow - numTotallyVisibleRows);

                        DataGridRow [] gridRows = DataGridRows;
                        for (int i = savedCurrentRow; i >= currentRow; i--)
                        {
                            if ( !gridRows[i].Selected)
                            {
                                gridRows[i].Selected = true;
                                numSelectedRows ++;
                            }
                        }

                        // hide the edit box
                        //
                        EndEdit();
                    } else if (biDiKe.Control && !biDiKe.Alt) {
                        // map ctrl-pageUp to hide the parentRows
                        ParentRowsVisible = false;
                    }
                    else
                    {
                        ResetSelection();
                        CurrentRow = Math.Max(0,
                                              CurrentRow - numTotallyVisibleRows);
                    }
                    break;
                case Keys.Left:
                    gridState[GRIDSTATE_childLinkFocused] = false;
                    ResetSelection();
                    if ((biDiKe.Modifiers & Keys.Modifiers) == Keys.Alt)
                    {
                        if (Caption.BackButtonVisible)
                            NavigateBack();
                        return true;
                    }

                    if ((biDiKe.Modifiers & Keys.Control) == Keys.Control)
                    {
                        // we should navigate to the first visible column
                        CurrentColumn = firstColumnMarkedVisible;
                        break;
                    }

                    if (currentCol == firstColumnMarkedVisible && currentRow != 0)
                    {
                        CurrentRow = CurrentRow - 1;
                        int newCol = MoveLeftRight(this.myGridTable.GridColumnStyles, this.myGridTable.GridColumnStyles.Count, false);
                        Debug.Assert(newCol != -1, "there should be at least a visible column, right?");
                        CurrentColumn = newCol;
                    }
                    else {
                        int newCol = MoveLeftRight(this.myGridTable.GridColumnStyles, currentCol, false);
                        if (newCol == -1) {
                            if (currentRow == 0)
                                return true;
                            else {
                                // go to the previous row:
                                CurrentRow = CurrentRow - 1;
                                CurrentColumn = lastColumnMarkedVisible;
                            }
                        } else {
                            CurrentColumn = newCol;
                        }
                    }
                    break;
                case Keys.Right:
                    gridState[GRIDSTATE_childLinkFocused] = false;
                    ResetSelection();
                    if ((biDiKe.Modifiers & Keys.Control) == Keys.Control && !biDiKe.Alt)
                    {
                        // we should navigate to the last column that is marked as Visible
                        CurrentColumn = lastColumnMarkedVisible;
                        break;
                    }

                    if (currentCol == lastColumnMarkedVisible && currentRow != DataGridRowsLength - 1)
                    {
                        CurrentRow = CurrentRow + 1;
                        // navigate to the first visible column
                        CurrentColumn = firstColumnMarkedVisible;
                    }
                    else {
                        int newCol = MoveLeftRight(this.myGridTable.GridColumnStyles, this.currentCol, true);
                        if (newCol == cols.Count + 1) {
                            // navigate to the first visible column
                            // and the next row
                            //
                            CurrentColumn = firstColumnMarkedVisible;
                            CurrentRow ++;
                        }
                        else 
                            CurrentColumn = newCol;
                    }
                    break;
                case Keys.F2:
                    gridState[GRIDSTATE_childLinkFocused] = false;
                    ResetSelection();
                    Edit();
                    break;
#if DEBUG
                case Keys.F12:
                    gridState[GRIDSTATE_childLinkFocused] = false;
                    AddNewRow();
                    break;
#endif
                case Keys.Home:
                    gridState[GRIDSTATE_childLinkFocused] = false;
                    ResetSelection();
                    CurrentColumn = 0;
                    if (biDiKe.Control && !biDiKe.Alt) {
                        int currentRowSaved = currentRow;
                        CurrentRow = 0;

                        if (biDiKe.Shift)
                        {
                            // Ctrl-Shift-Home will select all the rows up to the first one
                            DataGridRow[] gridRows = DataGridRows;
                            for (int i = 0; i <= currentRowSaved; i++)
                            {
                                gridRows[i].Selected = true;
                                numSelectedRows ++;
                            }
                            // hide the edit box:
                            EndEdit();
                        }
                        Debug.Assert(ListManager.Position == CurrentCell.RowNumber || listManager.Count == 0, "current row out of ssync with DataSource");
                        return true;
                    }
                    Debug.Assert(ListManager.Position == CurrentCell.RowNumber || listManager.Count == 0, "current row out of ssync with DataSource");
                    break;
                case Keys.Delete:
                    gridState[GRIDSTATE_childLinkFocused] = false;
                    if (policy.AllowRemove && numSelectedRows > 0) {
                        #if DEBUG
                        // when the list is empty, then the position
                        // in the listManager is -1, and the currentPosition in the grid is 0
                        if (ListManager != null && ListManager.Count > 0) {
                            Debug.Assert(ListManager.Position == this.currentRow,
                                            "Current row out of sync with DataSource",
                                            "The DataSource's Position property should be mirrored by the CurrentCell.RowNumber of the DataGrid.");
                        }
                        #endif // DEBUG

                        gridState[GRIDSTATE_inDeleteRow] = true;
                        DeleteRows(localGridRows);
                        // set the currentRow to the position in the list
                        this.currentRow = this.listManager.Count == 0 ? 0 : this.listManager.Position;
                        numSelectedRows = 0;
                    } else {
                        // if we did not use the the Delete key, let the dataGridTextBox use it
                        return false;
                    }
                    break;
                case Keys.End:
                    gridState[GRIDSTATE_childLinkFocused] = false;
                    ResetSelection();
                    // go the the last visible column
                    CurrentColumn = lastColumnMarkedVisible;

                    if (biDiKe.Control && !biDiKe.Alt) {
                        int savedCurrentRow = currentRow;
                        CurrentRow = Math.Max(0, DataGridRowsLength - (policy.AllowAdd ? 2:1));

                        if (biDiKe.Shift)
                        {
                            // Ctrl-Shift-Home will select all the rows up to the first one
                            DataGridRow[] gridRows = DataGridRows;
                            for (int i = savedCurrentRow; i <= currentRow; i++)
                            {
                                gridRows[i].Selected = true;
                            }
                            numSelectedRows = currentRow - savedCurrentRow + 1;
                            // hide the edit box
                            //
                            EndEdit();
                        }
                        Debug.Assert(ListManager.Position == CurrentCell.RowNumber || listManager.Count == 0, "current row out of ssync with DataSource");
                        return true;
                    }
                    Debug.Assert(ListManager.Position == CurrentCell.RowNumber || listManager.Count == 0, "current row out of ssync with DataSource");
                    break;
                case Keys.Enter:
                    gridState[GRIDSTATE_childLinkFocused] = false;
                    ResetSelection();

                    // yield the return key if there is no editing
                    if (!gridState[GRIDSTATE_isEditing])
                        return false;

                    // Ctrl-Enter will call EndCurrentEdit
                    if ((biDiKe.Modifiers & Keys.Control) != 0 && !biDiKe.Alt)
                    {
                        EndEdit();
                        HandleEndCurrentEdit();
                        Edit();                 // put the edit box on the screen
                    }
                    else
                    {
                        // Do not commit the edit, cause reseting the 
                        // current cell will do that
                        //
                        // CommitEdit();

                        CurrentRow = currentRow + 1;
                    }

                    break;
                case Keys.A:
                    gridState[GRIDSTATE_childLinkFocused] = false;
                    if (biDiKe.Control && !biDiKe.Alt)
                    {
                        DataGridRow [] gridRows = DataGridRows;
                        for (int i = 0; i < DataGridRowsLength; i++)
                            if (gridRows[i] is DataGridRelationshipRow) gridRows[i].Selected = true;

                        numSelectedRows = DataGridRowsLength - (policy.AllowAdd ? 1 : 0);
                        // hide the edit box
                        //
                        EndEdit();
                        return true;
                    }
                    return false;
                case Keys.Escape:
                    gridState[GRIDSTATE_childLinkFocused] = false;
                    ResetSelection();
                    if (gridState[GRIDSTATE_isEditing])
                    {
                        // rollback 
                        AbortEdit();

                        // we have to invalidate the row header ( make it display the row selector instead of the pencil )
                        if (layout.RowHeadersVisible && this.currentRow > -1) {
                            Rectangle rowHdrRect = GetRowRect(this.currentRow);
                            rowHdrRect.Width = layout.RowHeaders.Width;
                            Invalidate(rowHdrRect);
                        }

                        // now put the edit column back on the screen
                        Edit();
                    }
                    else {
                        // add this protected virtual method for the XML designer team
                        CancelEditing();
                        Edit();
                        return false;
                    }
                    break;
            }
            return true;
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ProcessKeyPreview"]/*' />
        /// <devdoc>
        ///    <para>Previews a keyboard message and returns a value indicating if the key was
        ///       consumed.</para>
        /// </devdoc>
        [
            SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)
        ]
        protected override bool ProcessKeyPreview(ref Message m) {
            if (m.Msg == NativeMethods.WM_KEYDOWN) {
                KeyEventArgs ke = new KeyEventArgs((Keys)((int)m.WParam) | ModifierKeys);
                switch (ke.KeyCode) {
                    case Keys.Up:
                    case Keys.Down:
                    case Keys.Prior:
                    case Keys.Next:
                    case Keys.Right:
                    case Keys.Left:
                    case Keys.Tab:
                    case Keys.Escape:
                    case Keys.Enter:
                    case Keys.OemMinus:
                    case Keys.Subtract:
                    case Keys.Oemplus:
                    case Keys.Add:
                    case Keys.Space:
                    case Keys.Home:
                    case Keys.End:
                    case Keys.F2:
                    case Keys.Delete:
                    case Keys.A:
                        return ProcessGridKey(ke);
                }
            // Ctrl-Tab will be sent as a tab paired w/ a control on the KeyUp message
            //
            } else if (m.Msg == NativeMethods.WM_KEYUP) {
                KeyEventArgs ke = new KeyEventArgs((Keys)((int)m.WParam) | ModifierKeys);
                if (ke.KeyCode == Keys.Tab)
                    return ProcessGridKey(ke);
            }

            return base.ProcessKeyPreview(ref m);
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ProcessTabKey"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the Tab key should be processed.
        ///    </para>
        /// </devdoc>
        [UIPermission(SecurityAction.LinkDemand, Window=UIPermissionWindow.AllWindows)]
        protected bool ProcessTabKey(Keys keyData) {
            if (this.ListManager == null || myGridTable == null)
                return false;
            bool wasEditing = false;
            int columnCount = myGridTable.GridColumnStyles.Count;
            bool biDi = isRightToLeft();
            ResetSelection();

            // Try to commit changes to cell if we were editing
            if (gridState[GRIDSTATE_isEditing]) {
                wasEditing = true;
                if (!CommitEdit()) {
                    //MessageBox.Show("Could not commit changes!  Press Escape to abort edit");
                    Edit();         // if we can't commit the value put the edit box so that the user sees where the focus is
                    return true;
                }
            }

            if ((keyData & Keys.Control) == Keys.Control)
            {
                // when the user hits ctrl-alt-tab just ignore it.
                if ((keyData & Keys.Alt) == Keys.Alt)
                    return true;

                // navigate to the next control in the form
                Keys ke = keyData & ~(Keys.Control);
                EndEdit();

                bool ret = false;
                IntSecurity.ModifyFocus.Assert();
                try {
                    ret = base.ProcessDialogKey(ke);
                }
                finally {
                    CodeAccessPermission.RevertAssert();
                }
                return ret;
            }

            // see if the child relationships can use this TAB key
            DataGridRow[] localRows = DataGridRows;
            GridColumnStylesCollection cols = this.myGridTable.GridColumnStyles;

            int lastColumnMarkedVisible = 0;
            int firstColumnMarkedVisible = cols.Count-1;
            // bug 70492: if we do not have any rows, then tab should move focus to the next control
            //
            if (localRows.Length == 0) {
                EndEdit();

                bool ret = false;

                IntSecurity.ModifyFocus.Assert();
                try {
                    ret = base.ProcessDialogKey(keyData);
                }
                finally {
                    CodeAccessPermission.RevertAssert();
                }

                return ret;
            }

            for (int i = 0; i < cols.Count; i ++) {
                // if (cols[i].Visible && cols[i].PropertyDescriptor != null) {
                if (cols[i].PropertyDescriptor != null) {
                    firstColumnMarkedVisible = i;
                    break;
                }
            }
            for (int i = cols.Count - 1; i >= 0; i --) {
                // if (cols[i].Visible && cols[i].PropertyDescriptor != null) {
                if (cols[i].PropertyDescriptor != null) {
                    lastColumnMarkedVisible = i;
                    break;
                }
            }

            if (CurrentColumn == lastColumnMarkedVisible)
            {
                if (gridState[GRIDSTATE_childLinkFocused] || (!gridState[GRIDSTATE_childLinkFocused] && (keyData & Keys.Shift) != Keys.Shift)) {
                    if (localRows[CurrentRow].ProcessTabKey(keyData, layout.RowHeaders, isRightToLeft()))
                    {
                        if (cols.Count > 0)
                            cols[CurrentColumn].ConcedeFocus();
                        gridState[GRIDSTATE_childLinkFocused] = true;
                        // let the grid regain focus
                        // introduced because of that BeginInvoke thing in the OnLeave method....
                        if (gridState[GRIDSTATE_canFocus] && CanFocus && !Focused)
                            this.FocusInternal();
                        return true;
                    }
                }

                // actually, it turns out that we should leave the 
                // control if we are in the last row
                if ((this.currentRow == this.DataGridRowsLength -1) && ((keyData & Keys.Shift) == 0)) {

                    EndEdit();
                    bool ret = false;

                    IntSecurity.ModifyFocus.Assert();
                    try {
                        ret = base.ProcessDialogKey(keyData);
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }

                    return ret;
                }
            }


            if (CurrentColumn == firstColumnMarkedVisible)
            {
                // if the childLink is focused, then navigate within the relations
                // in the row, otherwise expand the relations list for the row above
                if (!gridState[GRIDSTATE_childLinkFocused]) {
                    if (CurrentRow != 0 && (keyData & Keys.Shift) == Keys.Shift)
                    {
                        if (localRows[CurrentRow - 1].ProcessTabKey(keyData, layout.RowHeaders, isRightToLeft()))
                        {
                            CurrentRow --;
                            if (cols.Count > 0)
                                cols[CurrentColumn].ConcedeFocus();
                            gridState[GRIDSTATE_childLinkFocused] = true;
                            // let the grid regain focus
                            // introduced because of that BeginInvoke thing in the OnLeave method....
                            if (gridState[GRIDSTATE_canFocus] && CanFocus && !Focused)
                                this.FocusInternal();
                            return true;
                        }
                    }
                } else {
                    if (localRows[CurrentRow].ProcessTabKey(keyData, layout.RowHeaders, isRightToLeft())) {
                        return true;
                    } else {
                        // we were on the firstColumn, previously the link was focused
                        // we have to navigate to the last column
                        gridState[GRIDSTATE_childLinkFocused] = false;
                        CurrentColumn = lastColumnMarkedVisible;
                        return true;
                    }
                }

                // if we are on the first cell ( not on the addNewRow )
                // then shift - tab should move to the next control on the form
                if (this.currentRow == 0 && ((keyData & Keys.Shift) == Keys.Shift)) {
                    EndEdit();
                    bool ret = false;

                    IntSecurity.ModifyFocus.Assert();
                    try {
                        ret = base.ProcessDialogKey(keyData);
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }

                    return ret;
                }
            }

            // move
            if ((keyData & Keys.Shift) != Keys.Shift) {
                // forward
                if (CurrentColumn == lastColumnMarkedVisible) {
                    if (CurrentRow != DataGridRowsLength - 1)
                        CurrentColumn = firstColumnMarkedVisible;
                    CurrentRow = CurrentRow + 1;
                }
                else {
                    int nextCol = MoveLeftRight(cols, currentCol, true);        // true for going right;
                    Debug.Assert(nextCol < cols.Count, "we already checked that we are not at the lastColumnMarkedVisible");
                    CurrentColumn = nextCol;
                }
            }
            else {
                // backward
                if (CurrentColumn == firstColumnMarkedVisible) {
                    if (CurrentRow != 0)
                    {
                        CurrentColumn = lastColumnMarkedVisible;
                    }
                    if (!gridState[GRIDSTATE_childLinkFocused])             // bug 86803
                        CurrentRow --;
                } else if (gridState[GRIDSTATE_childLinkFocused] && CurrentColumn == lastColumnMarkedVisible) {
                    // part deux: when we hilite the childLink and then press shift-tab, we
                    // don't want to navigate at the second to last column
                    InvalidateRow(this.currentRow);
                    Edit();
                } else {
                    int prevCol = MoveLeftRight(cols, currentCol, false);       // false for going left
                    Debug.Assert(prevCol != -1, "we already checked that we are not at the first columnMarked visible");
                    CurrentColumn = prevCol;
                }
            }

            // if we got here, then invalidate childLinkFocused
            //
            gridState[GRIDSTATE_childLinkFocused] = false;

            // Begin another edit if we were editing before
            if (wasEditing) {
                ResetSelection();
                Edit();
            }
            return true;
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.CancelEditing"]/*' />
        virtual protected void CancelEditing() {
            CancelCursorUpdate();
            // yield the escape key if there is no editing
            // make the last row a DataGridAddNewRow
            if (gridState[GRIDSTATE_inAddNewRow]) {
                gridState[GRIDSTATE_inAddNewRow] = false;
                DataGridRow[] localGridRows = this.DataGridRows;

                localGridRows[DataGridRowsLength-1] = new DataGridAddNewRow(this, this.myGridTable, DataGridRowsLength -1);
                SetDataGridRows(localGridRows, DataGridRowsLength);
            }
        }

        internal void RecalculateFonts() {
            try {
                linkFont = new Font(Font, FontStyle.Underline);
            } catch (Exception) {}
            fontHeight = Font.Height;
            linkFontHeight = LinkFont.Height;
            captionFontHeight = CaptionFont.Height;

            if (this.myGridTable == null || this.myGridTable.IsDefault)
                headerFontHeight = this.HeaderFont.Height;
            else
                headerFontHeight = myGridTable.HeaderFont.Height;
        }

        // the BackButtonClicked event:
        //
        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.BackButtonClick"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the BackButton is clicked.</para>
        /// </devdoc>
        [
         SRCategory(SR.CatAction),
         SRDescription(SR.DataGridBackButtonClickDescr)
        ]
        public event EventHandler BackButtonClick {
            add {
                Events.AddHandler(EVENT_BACKBUTTONCLICK, value);
            }
            remove {
                Events.RemoveHandler(EVENT_BACKBUTTONCLICK, value);
            }
        }

        // the DownButtonClick event
        //
        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ShowParentDetailsButtonClick"]/*' />
        /// <devdoc>
        ///    Occurs when the Down button is clicked.
        /// </devdoc>
        [
         SRCategory(SR.CatAction),
         SRDescription(SR.DataGridDownButtonClickDescr)
        ]
        public event EventHandler ShowParentDetailsButtonClick {
            add {
                Events.AddHandler(EVENT_DOWNBUTTONCLICK, value);
            }
            remove {
                Events.RemoveHandler(EVENT_DOWNBUTTONCLICK, value);
            }
        }

        private void ResetMouseState() {
            oldRow = -1;
            gridState[GRIDSTATE_overCaption] = true;
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.ResetSelection"]/*' />
        /// <devdoc>
        ///      Turns off selection for all rows that are selected.
        /// </devdoc>
        protected void ResetSelection() {
            if (numSelectedRows > 0) {
                DataGridRow[] localGridRows = DataGridRows;
                for (int i = 0; i < DataGridRowsLength; ++i)
                    if (localGridRows[i].Selected)
                        localGridRows[i].Selected = false;
            }
            numSelectedRows = 0;
            lastRowSelected = -1;
        }

        /// <devdoc>
        ///      Re-initializes all UI related state.
        /// </devdoc>
        private void ResetUIState() {
            gridState[GRIDSTATE_childLinkFocused] = false;
            ResetSelection();
            ResetMouseState();
            PerformLayout();
            Invalidate();               // we want to invalidate after we set up the scrollbars

            // invalidate the horizontalscrollbar and the vertical scrollbar
            //
            if (horizScrollBar.Visible)
                horizScrollBar.Invalidate();
            if (vertScrollBar.Visible)
                vertScrollBar.Invalidate();
        }

        /// <devdoc>
        ///      Scrolls the datagrid down an arbritrary number of rows.
        /// </devdoc>
        private void ScrollDown(int rows) {
            //Debug.WriteLineIf(CompModSwitches.DataGridScrolling.TraceVerbose, "DataGridScrolling: ScrollDown, rows = " + rows.ToString());
            if (rows != 0) {
                ClearRegionCache();

                // we should put "dataGridRowsLength -1"
                int newFirstRow = Math.Max(0, Math.Min(firstVisibleRow + rows, this.DataGridRowsLength -1));
                int oldFirstRow = firstVisibleRow;
                firstVisibleRow = newFirstRow;
                vertScrollBar.Value = newFirstRow;
                bool wasEditing = this.gridState[GRIDSTATE_isEditing];
                ComputeVisibleRows();

                if (gridState[GRIDSTATE_isScrolling]) {
                    Edit();
                    // isScrolling is set to TRUE when the user scrolls.
                    // once we move the edit box, we finished processing the scroll event, so set isScrolling to FALSE
                    // to set isScrolling to TRUE, we need another scroll event.
                    gridState[GRIDSTATE_isScrolling] = false;
                } else {
                    EndEdit();
                }

                int deltaY = ComputeRowDelta(oldFirstRow, newFirstRow);
                Rectangle rowsRect = layout.Data;
                if (layout.RowHeadersVisible)
                    rowsRect = Rectangle.Union(rowsRect, layout.RowHeaders);
                NativeMethods.RECT scrollArea = NativeMethods.RECT.FromXYWH(rowsRect.X, rowsRect.Y, rowsRect.Width, rowsRect.Height);
                SafeNativeMethods.ScrollWindow(new HandleRef(this, Handle), 0, deltaY, ref scrollArea, ref scrollArea);
                OnScroll(EventArgs.Empty);

                if (wasEditing) {
                    // invalidate the rowHeader for the 
                    InvalidateRowHeader(currentRow);
                }
            }
        }

        /// <devdoc>
        ///      Scrolls the datagrid right an arbritrary number of columns.
        /// </devdoc>
        private void ScrollRight(int columns) {
            Debug.WriteLineIf(CompModSwitches.DataGridScrolling.TraceVerbose, "DataGridScrolling: ScrollRight, columns = " + columns.ToString());
            int newCol = firstVisibleCol + columns;

            GridColumnStylesCollection gridColumns = myGridTable.GridColumnStyles;
            int newColOffset = 0;
            int nGridCols = gridColumns.Count;
            int nVisibleCols = 0;

            // if we try to scroll past the last totally visible column,
            // then the toolTips will dissapear
            if (this.myGridTable.IsDefault)
                nVisibleCols = nGridCols;
            else
                for (int i = 0; i < nGridCols; i++)
                    if (gridColumns[i].PropertyDescriptor != null)
                        nVisibleCols ++;

            if (this.lastTotallyVisibleCol == nVisibleCols - 1 && columns > 0 ||
                this.firstVisibleCol == 0 && columns < 0 && negOffset == 0)
                return;

            newCol = Math.Min(newCol, nGridCols - 1);

            for (int i = 0; i < newCol; i++)
                // if (gridColumns[i].Visible && gridColumns[i].PropertyDescriptor != null)
                if (gridColumns[i].PropertyDescriptor != null)
                    newColOffset += gridColumns[i].Width;
            
            HorizontalOffset = newColOffset;
        }

        /// <devdoc>
        ///      Scrolls a given row and column pair into visibility.
        /// </devdoc>
        private void ScrollTo(int targetRow, int targetCol) {
            //Debug.WriteLineIf(CompModSwitches.DataGridScrolling.TraceVerbose, "DataGridScrolling: ScrollTo, row = " +
            //                  targetRow.ToString() + ", " + targetCol.ToString());

            int dRows = ComputeDeltaRows(targetRow);
            ScrollDown(dRows);

            // do not flush the columns to the left
            // so, scroll only as many columns as is necessary.
            // CONSIDER: after doing a sort, maybe the user would like to have
            // selected column flushed to the left
            int dCols = targetCol - firstVisibleCol;

            if (targetCol > lastTotallyVisibleCol)
                dCols = targetCol - lastTotallyVisibleCol;

            // if only part of the currentCol is visible
            // then we should still scroll
            if (dCols != 0 || negOffset != 0)
                ScrollRight(dCols);
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.Select"]/*' />
        /// <devdoc>
        ///      Selects a given row
        /// </devdoc>
        public void Select(int row) {
            Debug.WriteLineIf(CompModSwitches.DataGridSelection.TraceVerbose, "Selecting row " + row.ToString());
            DataGridRow[] localGridRows = DataGridRows;
            if (!localGridRows[row].Selected) {
                localGridRows[row].Selected = true;
                numSelectedRows++;
            }

            // when selecting a row, hide the edit box
            //
            EndEdit();
        }

        // this function will pair the listManager w/ a table from the TableStylesCollection.
        // and for each column in the TableStylesCollection will pair them w/ a propertyDescriptor
        // from the listManager
        //
        // prerequisite: the current table is either the default table, or has the same name as the
        // list in the listManager.
        //
        private void PairTableStylesAndGridColumns(CurrencyManager lm, DataGridTableStyle gridTable, bool forceColumnCreation) {
            PropertyDescriptorCollection props = lm.GetItemProperties();
            GridColumnStylesCollection gridCols = gridTable.GridColumnStyles;

            // ]it is possible to have a dataTable w/ an empty string for a name.
            if (!gridTable.IsDefault && String.Compare(lm.GetListName(), gridTable.MappingName, true) == 0) {
                // we will force column creation only at runtime
                if (gridTable.GridColumnStyles.Count == 0 && !DesignMode) {
                    // we have to create some default columns for each of the propertyDescriptors
                    //
                    if (forceColumnCreation)
                        gridTable.SetGridColumnStylesCollection(lm);
                    else 
                        gridTable.SetRelationsList(lm);
                } else {
                    // it may the case that the user will have two lists w/ the same name.
                    // When switching binding between those different lists, we need to invalidate
                    // the propertyDescriptors from the current gridColumns
                    //
                    for (int i = 0; i < gridCols.Count; i ++)
                        gridCols[i].PropertyDescriptor = null;

                    // pair the propertyDescriptor from each column to the actual property descriptor
                    // from the listManager
                    //
                    for (int i = 0; i < props.Count; i ++) {
                        DataGridColumnStyle col = gridCols.MapColumnStyleToPropertyName(props[i].Name);
                        if (col != null) {
                            col.PropertyDescriptor = props[i];
                        }
                    }
                    // TableStyle::SetGridColumnStylesCollection will also set the
                    // relations list in the tableStyle.
                    gridTable.SetRelationsList(lm);
                }
            } else {
                // we should put an assert, that this is the default Table Style
#if DEBUG
                Debug.Assert(gridTable.IsDefault, "if we don't have a match, then the dataGRid should have the default table");
#endif // DEBUG
                gridTable.SetGridColumnStylesCollection(lm);
                if (gridTable.GridColumnStyles.Count > 0 && gridTable.GridColumnStyles[0].Width == -1) {
#if DEBUG
                    GridColumnStylesCollection cols = gridTable.GridColumnStyles;
                    for (int i = 0; i < cols.Count; i++) {
                        Debug.Assert(cols[i].Width == -1, "if one column's width is not initialized, the same should be happening for the rest of the columns");
                    }
#endif // DEBUG
                    InitializeColumnWidths();
                }
            }
        }

        /// <devdoc>
        ///      Sets the current GridTable for the DataGrid.
        ///      This GridTable is the table which is currently
        ///      being displayed on the grid.
        /// </devdoc>
        internal void SetDataGridTable(DataGridTableStyle newTable, bool forceColumnCreation)
        {
            // we have to listen to the dataGridTable for the propertyChangedEvent
            if(this.myGridTable != null) {
                // unwire the propertyChanged event
                UnWireTableStylePropChanged(myGridTable);

                if (myGridTable.IsDefault) {
                    // reset the propertyDescriptors on the default table.
                    myGridTable.GridColumnStyles.ResetPropertyDescriptors();

                    // reset the relationship list from the default table
                    myGridTable.ResetRelationsList();
                }
            }

            myGridTable = newTable;
            
            WireTableStylePropChanged(myGridTable);

            this.layout.RowHeadersVisible = newTable.IsDefault ? this.RowHeadersVisible : newTable.RowHeadersVisible;

            // we need to force the grid into the dataGridTableStyle
            // this way the controls in the columns will be parented
            // consider this scenario: when the user finished InitializeComponent, it added 
            // a bunch of tables. all of those tables will have the DataGrid property set to this
            // grid. however, in InitializeComponent the tables will not have parented the
            // edit controls w/ the grid.
            //
            // the code in DataGridTextBoxColumn already checks to see if the edits are parented
            // before parenting them.
            //
            if (newTable != null)
                newTable.DataGrid = this;

            // pair the tableStyles and GridColumns
            //
            if (this.ListManager != null)
                PairTableStylesAndGridColumns(this.ListManager, this.myGridTable, forceColumnCreation);

            // reset the relations UI on the newTable
            if (newTable != null)
                newTable.ResetRelationsUI();

            // set the isNavigating to false
            gridState[GRIDSTATE_isNavigating] = false;

            horizScrollBar.Value = 0;
            firstVisibleRow = 0;
            currentCol = 0;
            // if we add a tableStyle that mapps to the
            // current listName, then we should set the currentRow to the
            // position in the listManager
            if (this.listManager == null)
                currentRow = 0;
            else
                currentRow = this.listManager.Position == -1 ? 0 : listManager.Position;
            ResetHorizontalOffset();
            negOffset = 0;
            ResetUIState();

            // check the hierarchy
            checkHierarchy = true;
        }

        /// <devdoc>
        ///      Scrolls the data area down to make room for the parent rows
        ///      and lays out the different regions of the DataGrid.
        /// </devdoc>
        internal void SetParentRowsVisibility(bool visible) {
            Rectangle parentRowsRect = layout.ParentRows;
            Rectangle underParentRows = layout.Data;

            if (layout.RowHeadersVisible) {
                underParentRows.X -= isRightToLeft() ? 0 : layout.RowHeaders.Width;
                underParentRows.Width += layout.RowHeaders.Width;
            }
            if (layout.ColumnHeadersVisible) {
                underParentRows.Y -= layout.ColumnHeaders.Height;
                underParentRows.Height += layout.ColumnHeaders.Height;
            }

            // hide the Edit Box
            EndEdit();

            if (visible) {
                /*
                RECT scrollArea = RECT.FromXYWH(underParentRows.X, underParentRows.Y, underParentRows.Width, underParentRows.Height);

                Debug.WriteLineIf(CompModSwitches.DataGridParents.TraceVerbose, "DataGridParents: Making parent rows visible.");
                SafeNativeMethods.ScrollWindow(this.Handle, 0, parentRowsRect.Height,
                                     ref scrollArea, ref scrollArea);
                */

                layout.ParentRowsVisible = true;

                PerformLayout();

                Invalidate();

            }
            else {
                // Rectangle scrollArea = Rectangle.Union(layout.ParentRows, underParentRows);
                // RECT scrollRECT = RECT.FromXYWH(scrollArea.X, scrollArea.Y, scrollArea.Width, scrollArea.Height);

                NativeMethods.RECT scrollRECT = NativeMethods.RECT.FromXYWH(underParentRows.X, underParentRows.Y - layout.ParentRows.Height, underParentRows.Width, underParentRows.Height + layout.ParentRows.Height);

                SafeNativeMethods.ScrollWindow(new HandleRef(this, Handle), 0, -parentRowsRect.Height, ref scrollRECT, ref scrollRECT);

                // If the vertical scrollbar was visible before and not after
                // the ScrollWindow call, then we will not get invalidated
                // completely.  We need to translate the visual bounds of
                // the scrollbar's old location up and invalidate.
                //
                if (vertScrollBar.Visible) {
                    Rectangle fixupRect = vertScrollBar.Bounds;
                    fixupRect.Y -= parentRowsRect.Height;
                    fixupRect.Height += parentRowsRect.Height;
                    Invalidate(fixupRect);
                }

                Debug.WriteLineIf(CompModSwitches.DataGridParents.TraceVerbose, "DataGridParents: Making parent rows invisible.");
                layout.ParentRowsVisible = false;
                PerformLayout();
            }
        }

        /// <devdoc>
        ///      Sets whether a row is expanded or not.
        /// </devdoc>
        private void SetRowExpansionState(int row, bool expanded) {
            if (row < -1 || row > DataGridRowsLength - (policy.AllowAdd ? 2:1)) {
                throw new ArgumentOutOfRangeException("row");
            }

            DataGridRow[] localGridRows = DataGridRows;
            if (row == -1) {
                DataGridRelationshipRow[] expandableRows = GetExpandableRows();
                bool repositionEditControl = false;

                for (int r = 0; r < expandableRows.Length; ++r) {
                    if (expandableRows[r].Expanded != expanded)
                    {
                        expandableRows[r].Expanded = expanded;
                        repositionEditControl = true;
                    }
                }
                if (repositionEditControl)
                {
                    // we need to reposition the edit control
                    if (gridState[GRIDSTATE_isNavigating] || gridState[GRIDSTATE_isEditing])
                    {
                        ResetSelection();
                        Edit();
                    }
                }
            }
            else if (localGridRows[row] is DataGridRelationshipRow) {
                DataGridRelationshipRow expandableRow = (DataGridRelationshipRow)localGridRows[row];
                if (expandableRow.Expanded != expanded)
                {
                    // we need to reposition the edit control
                    if (gridState[GRIDSTATE_isNavigating] || gridState[GRIDSTATE_isEditing])
                    {
                        ResetSelection();
                        Edit();
                    }

                    expandableRow.Expanded = expanded;
                }
            }
        }

        private void ObjectSiteChange(IContainer container, IComponent component, bool site) {
            if (site) {
                if (component.Site == null) {
                    container.Add(component);
                }
            }
            else {
                if (component.Site != null && component.Site.Container == container) {
                    container.Remove(component);
                }
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.SubObjectsSiteChange"]/*' />
        /// <internalonly/>
        public void SubObjectsSiteChange(bool site) {
            DataGrid dgrid = this;
            if (dgrid.DesignMode && dgrid.Site != null) {
                IDesignerHost host = (IDesignerHost)dgrid.Site.GetService(typeof(IDesignerHost));
                if (host != null) {
                    DesignerTransaction trans = host.CreateTransaction();
                    try {
                        IContainer container = dgrid.Site.Container;
                        
                        DataGridTableStyle[] tables = new DataGridTableStyle[dgrid.TableStyles.Count];
                        dgrid.TableStyles.CopyTo(tables, 0);
                        
                        for (int i = 0; i < tables.Length; i++) {
                            DataGridTableStyle table = tables[i];
                            ObjectSiteChange(container, table, site);
                            
                            DataGridColumnStyle[] columns = new DataGridColumnStyle[table.GridColumnStyles.Count];
                            table.GridColumnStyles.CopyTo(columns, 0);
                            
                            for (int j = 0; j < columns.Length; j++) {
                                DataGridColumnStyle column = columns[j];
                                ObjectSiteChange(container, column, site);
                            }
                        }
                    }
                    finally {
                        trans.Commit();
                    }
                }
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.UnSelect"]/*' />
        /// <devdoc>
        ///      Unselects a given row
        /// </devdoc>
        public void UnSelect(int row) {
            Debug.WriteLineIf(CompModSwitches.DataGridSelection.TraceVerbose, "DataGridSelection: Unselecting row " + row.ToString());
            DataGridRow[] localGridRows = DataGridRows;
            if (localGridRows[row].Selected) {
                localGridRows[row].Selected = false;
                numSelectedRows--;
            }
        }

        /// <devdoc>
        ///      Asks the cursor to update.
        /// </devdoc>
        private void UpdateListManager() {
            Debug.WriteLineIf(CompModSwitches.DataGridCursor.TraceVerbose, "DataGridCursor: Requesting EndEdit()");
            try {
                if (this.listManager != null) {
                    EndEdit();
                    this.listManager.EndCurrentEdit();
                }
            }
            catch (Exception) {
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.GetOutputTextDelimiter"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Will return the string that will be used as a delimiter between columns
        ///    when copying rows contents to the Clipboard.
        ///    At the moment, return "\t"
        /// </devdoc>
        protected virtual string GetOutputTextDelimiter() {
            return "\t";
        }

        /// <devdoc>
        ///     The accessible object class for a DataGrid. The child accessible objects
        ///     are accessible objects corresponding to the propertygrid entries.        
        /// </devdoc>
        [System.Runtime.InteropServices.ComVisible(true)]        
        internal class DataGridAccessibleObject : ControlAccessibleObject {
            /// <devdoc>
            ///     Construct a PropertyGridViewAccessibleObject
            /// </devdoc>
            public DataGridAccessibleObject(DataGrid owner) : base(owner) {
            }

            internal DataGrid DataGrid {
                get {
                    return (DataGrid)Owner;
                }
            }

            private int ColumnCount {
                get {
                    return ((DataGrid)Owner).myGridTable.GridColumnStyles.Count;
                }
            }

            private int RowCount {
                get {
                    return ((DataGrid)Owner).dataGridRows.Length;
                }
            }

            public override AccessibleObject GetChild(int index) {
                DataGrid dataGrid = (DataGrid)Owner;

                int cols = ColumnCount;
                int rows = RowCount;

                if (dataGrid.dataGridRows == null) {
                    dataGrid.CreateDataGridRows();
                }

                if (index < 1) {
                    return dataGrid.ParentRowsAccessibleObject;
                }
                else {
                    index -= 1;
                    if (index < cols) {
                        return dataGrid.myGridTable.GridColumnStyles[index].HeaderAccessibleObject;
                    }
                    else {
                        index -= cols;
    
                        if (index < rows) {
                            Debug.Assert(dataGrid.dataGridRows[index].RowNumber == index, "Row number is wrong!");
                            return dataGrid.dataGridRows[index].AccessibleObject;
                        }
                        else {
                            index -= rows;
                            if (index == 1 || (index == 0 && !dataGrid.horizScrollBar.Visible)) {
                                return dataGrid.vertScrollBar.AccessibilityObject;
                            }
                            else if (index == 0) {
                                return dataGrid.horizScrollBar.AccessibilityObject;
                            }
                        }
                    }
                }

                return null;
            }

            public override int GetChildCount() {
                int n = 1 + ColumnCount + ((DataGrid)Owner).DataGridRowsLength;
                if (DataGrid.horizScrollBar.Visible) {
                    n++;
                }
                if (DataGrid.vertScrollBar.Visible) {
                    n++;
                }
                return n;
            }

            public override AccessibleObject GetFocused() {
                if (DataGrid.Focused) {
                    return GetSelected();
                }

                return null;
            }
         
            public override AccessibleObject GetSelected() {
                DataGridCell cell = DataGrid.CurrentCell;
                return GetChild(1 + ColumnCount + cell.RowNumber).GetChild(cell.ColumnNumber);
            }
         
            public override AccessibleObject HitTest(int x, int y) {
                Point client = DataGrid.PointToClient(new Point(x, y));
                HitTestInfo hti = DataGrid.HitTest(client.X, client.Y);

                switch (hti.Type) {
                    case HitTestType.RowHeader:
                        return GetChild(1 + ColumnCount + hti.Row);
                    case HitTestType.Cell:
                        return GetChild(1 + ColumnCount + hti.Row).GetChild(hti.Column);
                    case HitTestType.ColumnHeader:
                        return GetChild(1 + hti.Column);
                    case HitTestType.ParentRows:
                        return DataGrid.ParentRowsAccessibleObject;
                    case HitTestType.None:
                    case HitTestType.ColumnResize:
                    case HitTestType.RowResize:
                    case HitTestType.Caption:
                        break;
                }

                return null;
            }

            public override AccessibleObject Navigate(AccessibleNavigation navdir) {
                // We're only handling FirstChild and LastChild here
                if (GetChildCount() > 0) {
                    switch(navdir) {
                        case AccessibleNavigation.FirstChild:
                            return GetChild(0);
                        case AccessibleNavigation.LastChild:
                            return GetChild(GetChildCount() - 1);
                    }
                }

                return null;    // Perform default behavior
            }
        }



        // <summary>
        //      This simple data structure holds all of the layout information
        //      for the DataGrid.
        // </summary>
        internal class LayoutData {
            internal bool dirty = true;
            // region inside the Control's borders.
            public Rectangle Inside = Rectangle.Empty;

            public Rectangle RowHeaders = Rectangle.Empty;

            public Rectangle TopLeftHeader = Rectangle.Empty;
            public Rectangle ColumnHeaders = Rectangle.Empty;
            public Rectangle Data = Rectangle.Empty;

            public Rectangle Caption = Rectangle.Empty;
            public Rectangle ParentRows = Rectangle.Empty;

            public Rectangle ResizeBoxRect = Rectangle.Empty;

            public bool ColumnHeadersVisible;
            public bool RowHeadersVisible;
            public bool CaptionVisible;
            public bool ParentRowsVisible;

            // used for resizing.
            public Rectangle ClientRectangle = Rectangle.Empty;

            public LayoutData() {
            }

            public LayoutData(LayoutData src) {
                GrabLayout(src);
            }

            private void GrabLayout(LayoutData src) {
                this.Inside               = src.Inside;
                this.TopLeftHeader        = src.TopLeftHeader;
                this.ColumnHeaders        = src.ColumnHeaders;
                this.RowHeaders           = src.RowHeaders;
                this.Data                 = src.Data;
                this.Caption              = src.Caption;
                this.ParentRows           = src.ParentRows;
                this.ResizeBoxRect        = src.ResizeBoxRect;
                this.ColumnHeadersVisible = src.ColumnHeadersVisible;
                this.RowHeadersVisible    = src.RowHeadersVisible;
                this.CaptionVisible       = src.CaptionVisible;
                this.ParentRowsVisible    = src.ParentRowsVisible;
                this.ClientRectangle      = src.ClientRectangle;
            }

            public override string ToString() {
                StringBuilder sb = new StringBuilder(200);
                sb.Append(base.ToString());
                sb.Append(" { \n");
                sb.Append("Inside = ");
                sb.Append(Inside.ToString());
                sb.Append('\n');
                sb.Append("TopLeftHeader = ");
                sb.Append(TopLeftHeader.ToString());
                sb.Append('\n');
                sb.Append("ColumnHeaders = ");
                sb.Append(ColumnHeaders.ToString());
                sb.Append('\n');
                sb.Append("RowHeaders = ");
                sb.Append(RowHeaders.ToString());
                sb.Append('\n');
                sb.Append("Data = ");
                sb.Append(Data.ToString());
                sb.Append('\n');
                sb.Append("Caption = ");
                sb.Append(Caption.ToString());
                sb.Append('\n');
                sb.Append("ParentRows = ");
                sb.Append(ParentRows.ToString());
                sb.Append('\n');
                sb.Append("ResizeBoxRect = ");
                sb.Append(ResizeBoxRect.ToString());
                sb.Append('\n');
                sb.Append("ColumnHeadersVisible = ");
                sb.Append(ColumnHeadersVisible.ToString());
                sb.Append('\n');
                sb.Append("RowHeadersVisible = ");
                sb.Append(RowHeadersVisible.ToString());
                sb.Append('\n');
                sb.Append("CaptionVisible = ");
                sb.Append(CaptionVisible.ToString());
                sb.Append('\n');
                sb.Append("ParentRowsVisible = ");
                sb.Append(ParentRowsVisible.ToString());
                sb.Append('\n');
                sb.Append("ClientRectangle = ");
                sb.Append(ClientRectangle.ToString());
                sb.Append(" } ");
                return sb.ToString();
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.HitTestInfo"]/*' />
        /// <devdoc>
        ///    <para>Contains information
        ///       about the part of the <see cref='System.Windows.Forms.DataGrid'/> control the user
        ///       has clicked. This class cannot be inherited.</para>
        /// </devdoc>
        public sealed class HitTestInfo {
            internal HitTestType type = HitTestType.None;

            internal int row;
            internal int col;

            /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.HitTestInfo.Nowhere"]/*' />
            /// <devdoc>
            /// <para>Allows the <see cref='System.Windows.Forms.DataGrid.HitTestInfo'/> object to inform you the 
            ///    extent of the grid.</para>
            /// </devdoc>
            public static readonly HitTestInfo Nowhere = new HitTestInfo();

            internal HitTestInfo() {
                type = (HitTestType)0;
                row = col = -1;
            }

            internal HitTestInfo(HitTestType type) {
                this.type = type;
                row = col = -1;
            }

            /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.HitTestInfo.Column"]/*' />
            /// <devdoc>
            ///    <para>Gets the number of the clicked column.</para>
            /// </devdoc>
            public int Column {
                get {
                    return col;
                }
            }

            /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.HitTestInfo.Row"]/*' />
            /// <devdoc>
            ///    <para>Gets the
            ///       number of the clicked row.</para>
            /// </devdoc>
            public int Row {
                get {
                    return row;
                }
            }

            /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.HitTestInfo.Type"]/*' />
            /// <devdoc>
            /// <para>Gets the part of the <see cref='System.Windows.Forms.DataGrid'/> control, other than the row or column, that was 
            ///    clicked.</para>
            /// </devdoc>
            public HitTestType Type {
                get {
                    return type;
                }
            }

            /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.HitTestInfo.Equals"]/*' />
            /// <devdoc>
            ///    <para>Indicates whether two objects are identical.</para>
            /// </devdoc>
            public override bool Equals(object value) {
                if (value is HitTestInfo) {
                    HitTestInfo ci =(HitTestInfo) value;
                    return(type == ci.type &&
                           row  == ci.row &&
                           col  == ci.col);
                }
                return false;
            }

            /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.HitTestInfo.GetHashCode"]/*' />
            /// <devdoc>
            /// <para>Gets the hash code for the <see cref='System.Windows.Forms.DataGrid.HitTestInfo'/> instance.</para>
            /// </devdoc>
            public override int GetHashCode() {
                return(int)type +(row << 8) +(col << 16);
            }

            /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.HitTestInfo.ToString"]/*' />
            /// <devdoc>
            ///    <para>Gets the type, row number, and column number.</para>
            /// </devdoc>
            public override string ToString() {
                return "{ " + ((type).ToString()) + "," + row.ToString() + "," + col.ToString() + "}";
            }
        }

        /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.HitTestType"]/*' />
        /// <devdoc>
        /// <para>Specifies the part of the <see cref='System.Windows.Forms.DataGrid'/> control the user has clicked.</para>
        /// </devdoc>
        [Flags]
        public enum HitTestType {
            /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.HitTestType.None"]/*' />
            None         = 0x00000000,

            /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.HitTestType.Cell"]/*' />
            Cell         = 0x00000001,

            /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.HitTestType.ColumnHeader"]/*' />
            ColumnHeader = 0x00000002,

            /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.HitTestType.RowHeader"]/*' />
            RowHeader    = 0x00000004,

            /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.HitTestType.ColumnResize"]/*' />
            ColumnResize = 0x00000008,

            /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.HitTestType.RowResize"]/*' />
            RowResize    = 0x00000010,

            /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.HitTestType.Caption"]/*' />
            Caption      = 0x00000020,

            /// <include file='doc\DataGrid.uex' path='docs/doc[@for="DataGrid.HitTestType.ParentRows"]/*' />
            ParentRows   = 0x00000040
        }

        /// <devdoc>
        ///      Holds policy information for what the grid can and cannot do.
        /// </devdoc>
        private class Policy {

            private bool allowAdd = true;
            private bool allowEdit = true;
            private bool allowRemove = true;

            public Policy() {
            }

            public bool AllowAdd {
                get {
                    return allowAdd;
                }
                set {
                    if (allowAdd != value) {
                        allowAdd = value;
                    }
                }
            }

            public bool AllowEdit {
                get {
                    return allowEdit;
                }
                set {
                    if (allowEdit != value) {
                        allowEdit = value;
                    }
                }
            }

            public bool AllowRemove {
                get {
                    return allowRemove;
                }
                set {
                    if (allowRemove != value) {
                        allowRemove = value;
                    }
                }
            }

            // returns true if the UI needs to be updated (here because addnew has changed)
            public bool UpdatePolicy(CurrencyManager listManager, bool gridReadOnly)
            {
                bool change = false;
                // only IBindingList can have an AddNewRow
                IBindingList bl = listManager == null ? null : listManager.List as IBindingList;
                if (listManager == null) {
                    if (!allowAdd)
                        change = true;
                    allowAdd = allowEdit = allowRemove = true;
                }
                else {
                    if (AllowAdd != listManager.AllowAdd && !gridReadOnly)
                        change = true;
                    AllowAdd= listManager.AllowAdd && !gridReadOnly && bl != null && bl.SupportsChangeNotification;
                    AllowEdit= listManager.AllowEdit && !gridReadOnly;
                    AllowRemove = listManager.AllowRemove && !gridReadOnly && bl != null && bl.SupportsChangeNotification;     // bug 86061
                }
                return change;
            }
        }

        /// <devdoc>
        ///      Since we don't have a nice managed interfact to GetRegionData(),
        ///      I wrote this piece to do it.
        /// </devdoc>
        private class  RegionCracker {
             public static NativeMethods.RECT[] CrackRegionData(IntPtr hRgn) {
                NativeMethods.RECT[] ret = new NativeMethods.RECT[0] {};
                try {
                    byte[] buffer;
                    int nBytes;

                    nBytes = SafeNativeMethods.GetRegionData(new HandleRef(null, hRgn), 0, null);
                    buffer = new byte[nBytes];
                    if (nBytes != SafeNativeMethods.GetRegionData(new HandleRef(null, hRgn), nBytes, buffer))
                        throw new InvalidOperationException(SR.GetString(SR.DataGridFailedToGetRegionInfo));

                    /*

                    buffer layout:

                    DWORD dwSize   specifies the size in bytes of the header
                    DWORD
                    DWORD nCount
                    DWORD nRgnSize
                    RECT  rcBound  (the bounding rectangle)

                    */

                    int cbHeader = ToInt(buffer, 0);
                    int nCount   = ToInt(buffer, 8);

                    ret = GetRects(buffer, cbHeader, nCount);
                }
                catch (Exception) {
                    throw new Win32Exception();
                }
                return ret;
            }

            private static NativeMethods.RECT[] GetRects(byte[] buffer, int cbHeader, int nCount) {
                NativeMethods.RECT[] ret = new NativeMethods.RECT[nCount];
                int offset = cbHeader;
                for (int i = 0; i < nCount; i++, offset += 16) {
                    int l, t, r, b;
                    l = ToInt(buffer, offset);
                    t = ToInt(buffer, offset + 4);
                    r = ToInt(buffer, offset + 8);
                    b = ToInt(buffer, offset + 12);
                    ret[i] = new NativeMethods.RECT(l,t,r,b);
                }
                return ret;
            }

            private static int ToInt(byte[] buffer, int offset) {
                int ret = buffer[offset];
                ret |= (buffer[offset + 1] << 8);
                ret |= (buffer[offset + 2] << 16);
                ret |= (buffer[offset + 3] << 24);
                return ret;
            }

        }
 
        // 
        //  Given the x coordinate  and the Width of rectangle R1 inside rectangle rect,
        //  this function returns the x coordinate of the rectangle that
        //  corresponds to the Bi-Di transformation
        //
        private int MirrorRectangle(Rectangle R1, Rectangle rect, bool rightToLeft)
        {
            if (rightToLeft)
                return rect.Right + rect.X - R1.Right;
            else
                return R1.X;
        }

        // 
        //  Given the x coordinate of a point inside rectangle rect,
        //  this function returns the x coordinate of the point that 
        //  corresponds to the Bi-Di transformation
        //
        private int MirrorPoint(int x, Rectangle rect, bool rightToLeft)
        {
            if (rightToLeft)
                return rect.Right + rect.X - x;
            else
                return x;
        }

        // This function will return true if the RightToLeft property of the dataGrid is 
        // set to YES
        private bool isRightToLeft()
        {
            return ( RightToLeft == RightToLeft.Yes);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\datagridboolcolumn.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGridBoolColumn.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    
    using System.Windows.Forms;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;

    /// <include file='doc\DataGridBoolColumn.uex' path='docs/doc[@for="DataGridBoolColumn"]/*' />
    /// <devdoc>
    ///    <para>Specifies a column in
    ///       which each cell contains a check box for representing
    ///       a boolean value.</para>
    /// </devdoc>
    public class DataGridBoolColumn : DataGridColumnStyle {
        private static readonly int idealCheckSize = 14;

        private bool isEditing = false;
        private bool isSelected = false;
        private bool allowNull = true;
        private int  editingRow = -1;
        private object currentValue = Convert.DBNull;
        
        private object trueValue = true;
        private object falseValue = false;
        private object nullValue = Convert.DBNull;

        private static readonly object  EventTrueValue      = new object();
        private static readonly object  EventFalseValue     = new object();
        private static readonly object  EventAllowNull      = new object();
        
        /// <include file='doc\DataGridBoolColumn.uex' path='docs/doc[@for="DataGridBoolColumn.DataGridBoolColumn"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Windows.Forms.DataGridBoolColumn'/> class.</para>
        /// </devdoc>
        public DataGridBoolColumn() : base() {}

        /// <include file='doc\DataGridBoolColumn.uex' path='docs/doc[@for="DataGridBoolColumn.DataGridBoolColumn1"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of a <see cref='System.Windows.Forms.DataGridBoolColumn'/> with the specified <see cref='System.Data.DataColumn'/>.</para>
        /// </devdoc>
        public DataGridBoolColumn(PropertyDescriptor prop)
            : base(prop) {}

        /// <include file='doc\DataGridBoolColumn.uex' path='docs/doc[@for="DataGridBoolColumn.DataGridBoolColumn2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DataGridBoolColumn(PropertyDescriptor prop, bool isDefault)
            : base(prop, isDefault){}

        /// <include file='doc\DataGridBoolColumn.uex' path='docs/doc[@for="DataGridBoolColumn.TrueValue"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the actual value used when setting the 
        ///       value of the column to <see langword='true'/> .</para>
        /// </devdoc>
        [TypeConverterAttribute(typeof(StringConverter))]
        public object TrueValue {
            get {
                return trueValue;
            }
            set {
                if (!trueValue.Equals(value)) {
                    this.trueValue = value;
                    OnTrueValueChanged(EventArgs.Empty);
                    Invalidate();
                }
            }
        }

        /// <include file='doc\DataGridBoolColumn.uex' path='docs/doc[@for="DataGridBoolColumn.TrueValueChanged"]/*' />
        public event EventHandler TrueValueChanged { 
            add {
                Events.AddHandler(EventTrueValue, value);
            }
            remove {
                Events.RemoveHandler(EventTrueValue, value);
            }
        }
        
        /// <include file='doc\DataGridBoolColumn.uex' path='docs/doc[@for="DataGridBoolColumn.FalseValue"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the actual value used when setting the value of the column to 
        ///    <see langword='false'/>.</para>
        /// </devdoc>
        [TypeConverterAttribute(typeof(StringConverter))]
        public object FalseValue {
            get {
                return falseValue;
            }
            set {
                if (!falseValue.Equals(value)) {
                    this.falseValue = value;
                    OnFalseValueChanged(EventArgs.Empty);
                    Invalidate();
                }
            }
        }
        
        /// <include file='doc\DataGridBoolColumn.uex' path='docs/doc[@for="DataGridBoolColumn.FalseValueChanged"]/*' />
        public event EventHandler FalseValueChanged { 
            add {
                Events.AddHandler(EventFalseValue, value);
            }
            remove {
                Events.RemoveHandler(EventFalseValue, value);
            }
        }
        
        /// <include file='doc\DataGridBoolColumn.uex' path='docs/doc[@for="DataGridBoolColumn.NullValue"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the actual value used when setting the value of the column to 
        ///    <see langword='null'/>.</para>
        /// </devdoc>
        [TypeConverterAttribute(typeof(StringConverter))]
        public object NullValue {
            get {
                return nullValue;
            }
            set {
                if (!nullValue.Equals(value)) {
                    this.nullValue = value;
                    OnFalseValueChanged(EventArgs.Empty);
                    Invalidate();
                }
            }
        }
        
        // =------------------------------------------------------------------
        // =        Methods
        // =------------------------------------------------------------------

        // when the grid is in addNewRow it means that the user did not start typing
        // so there is no data to be pushed back into the backEnd.
        // make isEditing false so that in the Commit call we do not do any work.
        //
        /// <include file='doc\DataGridBoolColumn.uex' path='docs/doc[@for="DataGridBoolColumn.ConcedeFocus"]/*' />
        protected internal override void ConcedeFocus() {
            base.ConcedeFocus();
            this.isSelected = false;
            this.isEditing = false;
        }

        private Rectangle GetCheckBoxBounds(Rectangle bounds, bool alignToRight) {
            if (alignToRight)
                return new Rectangle(bounds.X +((bounds.Width - idealCheckSize) /2),
                                     bounds.Y +((bounds.Height - idealCheckSize) / 2),
                                     bounds.Width < idealCheckSize ? bounds.Width : idealCheckSize,
                                     idealCheckSize);
            else
                return new Rectangle(Math.Max(0,bounds.X +((bounds.Width - idealCheckSize) /2)),
                                     Math.Max(0,bounds.Y +((bounds.Height - idealCheckSize) / 2)),
                                     bounds.Width < idealCheckSize ? bounds.Width : idealCheckSize,
                                     idealCheckSize);
        }

        /// <include file='doc\DataGridBoolColumn.uex' path='docs/doc[@for="DataGridBoolColumn.GetColumnValueAtRow"]/*' />
        /// <devdoc>
        ///    <para>Gets the value at the specified row.</para>
        /// </devdoc>
        protected internal override object GetColumnValueAtRow(CurrencyManager lm, int row) {
            object baseValue = base.GetColumnValueAtRow(lm, row);
            object value = Convert.DBNull;
            if (baseValue.Equals(trueValue)) {
                value = true;
            }
            else if (baseValue.Equals(falseValue)) {
                value = false;
            }
            return value;
        }

        private bool IsReadOnly() {
            bool ret = this.ReadOnly;
            if (this.DataGridTableStyle != null) {
                ret = ret || this.DataGridTableStyle.ReadOnly;
                if (this.DataGridTableStyle.DataGrid != null)
                    ret = ret || this.DataGridTableStyle.DataGrid.ReadOnly;
            }
            return ret;
        }

        /// <include file='doc\DataGridBoolColumn.uex' path='docs/doc[@for="DataGridBoolColumn.SetColumnValueAtRow"]/*' />
        /// <devdoc>
        ///    <para>Sets the value a a specified row.</para>
        /// </devdoc>
        protected internal override void SetColumnValueAtRow(CurrencyManager lm, int row, object value) {
            object baseValue = null;
            if (true.Equals(value)) {
                baseValue = TrueValue;
            }
            else if (false.Equals(value)) {
                baseValue = FalseValue;
            }
            else if (Convert.IsDBNull(value)) {
                baseValue = NullValue;
            }
            currentValue = baseValue;
            base.SetColumnValueAtRow(lm, row, baseValue);
        }
        
        /// <include file='doc\DataGridBoolColumn.uex' path='docs/doc[@for="DataGridBoolColumn.GetPreferredSize"]/*' />
        /// <devdoc>
        ///    <para>Gets the optimum width and height of a cell given
        ///       a specific value to contain.</para>
        /// </devdoc>
        protected internal override Size GetPreferredSize(Graphics g, object value) {
            return new Size(idealCheckSize+2, idealCheckSize+2);
        }

        /// <include file='doc\DataGridBoolColumn.uex' path='docs/doc[@for="DataGridBoolColumn.GetMinimumHeight"]/*' />
        /// <devdoc>
        ///    <para>Gets
        ///       the height of a cell in a column.</para>
        /// </devdoc>
        protected internal override int GetMinimumHeight() {
            return idealCheckSize+2;
        }

        /// <include file='doc\DataGridBoolColumn.uex' path='docs/doc[@for="DataGridBoolColumn.GetPreferredHeight"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the height used when resizing columns.
        ///    </para>
        /// </devdoc>
        protected internal override int GetPreferredHeight(Graphics g, object value)
        {
            return idealCheckSize + 2;
        }

        /// <include file='doc\DataGridBoolColumn.uex' path='docs/doc[@for="DataGridBoolColumn.Abort"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initiates a request to interrupt an edit procedure.
        ///    </para>
        /// </devdoc>
        protected internal override void Abort(int rowNum) {
            isSelected = false;
            isEditing = false;
            Invalidate();
            return;
        }

        /// <include file='doc\DataGridBoolColumn.uex' path='docs/doc[@for="DataGridBoolColumn.Commit"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initiates a request to complete an editing procedure.
        ///    </para>
        /// </devdoc>
        protected internal override bool Commit(CurrencyManager dataSource, int rowNum) {
            isSelected = false;
            if (!isEditing)
                return true;

            SetColumnValueAtRow(dataSource, rowNum, currentValue);
            isEditing = false;
            Invalidate();
            return true;
        }

        /// <include file='doc\DataGridBoolColumn.uex' path='docs/doc[@for="DataGridBoolColumn.Edit"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Prepares the cell for editing a value.
        ///    </para>
        /// </devdoc>
        protected internal override void Edit(CurrencyManager source,
                                    int rowNum,
                                    Rectangle bounds,
                                    bool readOnly,
                                    string instantText,
                                    bool cellIsVisible)
        {
            // toggle state right now...
            isSelected = true;

            // move the focus away from the previous column and give it to the grid
            //
            DataGrid grid = this.DataGridTableStyle.DataGrid;
            if (!grid.Focused)
                grid.FocusInternal();

            if (!readOnly && !IsReadOnly()) {
                editingRow = rowNum;
                currentValue = GetColumnValueAtRow(source, rowNum);
            }

            base.Invalidate();
        }

        /// <devdoc>
        ///    <para>
        ///       Provides a handler for determining which key was pressed, and whether to
        ///       process it.
        ///    </para>
        /// </devdoc>
        internal override bool KeyPress(int rowNum, Keys keyData) {
            if (isSelected && editingRow == rowNum && !IsReadOnly()) {
                if ((keyData & Keys.KeyCode) == Keys.Space) {
                    ToggleValue();
                    Invalidate();
                    return true;
                }
            }
            return base.KeyPress(rowNum, keyData);
        }

        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Indicates whether the a mouse down event occurred at the specified row, at
        ///       the specified x and y coordinates.
        ///    </para>
        /// </devdoc>
        internal override bool MouseDown(int rowNum, int x, int y) {
            base.MouseDown(rowNum, x, y);
            if (isSelected && editingRow == rowNum && !IsReadOnly()) {
                ToggleValue();
                Invalidate();
                return true;
            }
            return false;
        }

        private void OnTrueValueChanged(EventArgs e) {
            EventHandler eh = this.Events[EventTrueValue] as EventHandler;
            if (eh != null)
                eh(this, e);
        }
        private void OnFalseValueChanged(EventArgs e) {
            EventHandler eh = this.Events[EventFalseValue] as EventHandler;
            if (eh != null)
                eh(this, e);
        }
        private void OnAllowNullChanged(EventArgs e) {
            EventHandler eh = this.Events[EventAllowNull] as EventHandler;
            if (eh != null)
                eh(this, e);
        }

        /// <include file='doc\DataGridBoolColumn.uex' path='docs/doc[@for="DataGridBoolColumn.Paint"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Draws the <see cref='System.Windows.Forms.DataGridBoolColumn'/>
        /// with the given <see cref='System.Drawing.Graphics'/>,
        /// <see cref='System.Drawing.Rectangle'/> and row number.</para>
        /// </devdoc>
        protected internal override void Paint(Graphics g, Rectangle bounds, CurrencyManager source, int rowNum)
        {
            Paint(g,bounds,source, rowNum, false);
        }

        /// <include file='doc\DataGridBoolColumn.uex' path='docs/doc[@for="DataGridBoolColumn.Paint1"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Draws the <see cref='System.Windows.Forms.DataGridBoolColumn'/>
        /// with the given <see cref='System.Drawing.Graphics'/>, <see cref='System.Drawing.Rectangle'/>,
        /// row number, and alignment settings. </para>
        /// </devdoc>
        protected internal override void Paint(Graphics g, Rectangle bounds, CurrencyManager source, int rowNum, bool alignToRight) {
            Paint(g,bounds,source, rowNum, this.DataGridTableStyle.BackBrush, this.DataGridTableStyle.ForeBrush, alignToRight);
        }

        /// <include file='doc\DataGridBoolColumn.uex' path='docs/doc[@for="DataGridBoolColumn.Paint2"]/*' />
        /// <devdoc>
        /// <para>Draws the <see cref='System.Windows.Forms.DataGridBoolColumn'/> with the given <see cref='System.Drawing.Graphics'/>, <see cref='System.Drawing.Rectangle'/>,
        ///    row number, <see cref='System.Drawing.Brush'/>, and <see cref='System.Drawing.Color'/>. </para>
        /// </devdoc>
        protected internal override void Paint(Graphics g, Rectangle bounds, CurrencyManager source, int rowNum,
                                     Brush backBrush, Brush foreBrush,
                                     bool alignToRight) {
            object value = (isEditing && editingRow == rowNum) ? currentValue : GetColumnValueAtRow(source, rowNum);
            ButtonState checkedState = ButtonState.Inactive;
            if (!Convert.IsDBNull(value)) {
                checkedState = ((bool)value ? ButtonState.Checked : ButtonState.Normal);
            }

            Rectangle box = GetCheckBoxBounds(bounds, alignToRight);

            Region r = g.Clip;
            g.ExcludeClip(box);

            System.Drawing.Brush selectionBrush = this.DataGridTableStyle.IsDefault ? this.DataGridTableStyle.DataGrid.SelectionBackBrush : this.DataGridTableStyle.SelectionBackBrush;
            if (isSelected && editingRow == rowNum && !IsReadOnly()) {
                g.FillRectangle(selectionBrush, bounds);
            }
            else
                g.FillRectangle(backBrush, bounds);
            g.Clip = r;

            if (checkedState == ButtonState.Inactive) {
                ControlPaint.DrawMixedCheckBox(g, box, ButtonState.Checked);
            } else {
                ControlPaint.DrawCheckBox(g, box, checkedState);
            }

            // if the column is read only we should still show selection
            if (IsReadOnly() && isSelected && source.Position == rowNum) {
                bounds.Inflate(-1,-1);
                System.Drawing.Pen pen = new System.Drawing.Pen(selectionBrush);
                pen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dash;
                g.DrawRectangle(pen, bounds);
                pen.Dispose();
                // restore the bounds rectangle
                bounds.Inflate(1,1);
            }
        }

        /// <include file='doc\DataGridBoolColumn.uex' path='docs/doc[@for="DataGridBoolColumn.AllowNull"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value indicating whether null values are allowed.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(true),
        SRDescription(SR.DataGridBoolColumnAllowNullValue)
        ]
        public bool AllowNull {
            get {
                return allowNull;
            }
            set {
                if (allowNull != value)
                {
                    allowNull = value;
                    // if we do not allow null, and the gridColumn had
                    // a null in it, discard it
                    if (!value && Convert.IsDBNull(currentValue))
                    {
                        currentValue = false;
                        Invalidate();
                    }
                    OnAllowNullChanged(EventArgs.Empty);
                }
            }
        }

        /// <include file='doc\DataGridBoolColumn.uex' path='docs/doc[@for="DataGridBoolColumn.AllowNullChanged"]/*' />
        public event EventHandler AllowNullChanged { 
            add {
                Events.AddHandler(EventAllowNull, value);
            }
            remove {
                Events.RemoveHandler(EventAllowNull, value);
            }
        }
        
        /// <include file='doc\DataGridBoolColumn.uex' path='docs/doc[@for="DataGridBoolColumn.EnterNullValue"]/*' />
        /// <devdoc>
        /// <para>Enters a <see langword='null'/> into the column.</para>
        /// </devdoc>
        protected internal override void EnterNullValue()
        {
            // do not throw an exception when the column is marked as readOnly or
            // does not allowNull
            if (!this.AllowNull || IsReadOnly())
                return;
            if (currentValue != Convert.DBNull) {
                currentValue = Convert.DBNull;
                Invalidate();
            }
        }

        private void ToggleValue() {
         
            if (currentValue is bool && ((bool)currentValue) == false) {
                currentValue = true;
            }
            else {
                if (AllowNull) {
                    if (Convert.IsDBNull(currentValue)) {
                        currentValue = false;
                    }
                    else {
                        currentValue = Convert.DBNull;
                    }
                }
                else {
                    currentValue = false;
                }
            }
            // we started editing
            isEditing = true;
            // tell the dataGrid that things are changing
            // we put Rectangle.Empty cause toggle will invalidate the row anyhow
            this.DataGridTableStyle.DataGrid.ColumnStartedEditing(Rectangle.Empty);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\datagridcolumncollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGridColumnCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


namespace System.Windows.Forms {
    using System.Runtime.Remoting;

    using System.Diagnostics;

    using System;
    using System.Collections;
    using System.Drawing.Design;
    using System.Windows.Forms;
    using System.ComponentModel;
    using System.Globalization;

    /// <include file='doc\DataGridColumnCollection.uex' path='docs/doc[@for="GridColumnStylesCollection"]/*' />
    /// <devdoc>
    /// <para>Represents a collection of System.Windows.Forms.DataGridColumnStyle objects in the <see cref='System.Windows.Forms.DataGrid'/>
    /// control.</para>
    /// </devdoc>
    [
    Editor("System.Windows.Forms.Design.DataGridColumnCollectionEditor, " + AssemblyRef.SystemDesign, typeof(UITypeEditor)),
    ListBindable(false)
    ]
    public class GridColumnStylesCollection : BaseCollection, IList {
        CollectionChangeEventHandler onCollectionChanged;
        ArrayList        items = new ArrayList();
        DataGridTableStyle    owner = null;
        private     bool isDefault = false;

        // we have to implement IList for the Collection editor to work
        //
        /// <include file='doc\DataGridColumnCollection.uex' path='docs/doc[@for="GridColumnStylesCollection.IList.Add"]/*' />
        /// <internalonly/>
        int IList.Add(object value) {
            return this.Add((DataGridColumnStyle) value);            
        }

        /// <include file='doc\DataGridColumnCollection.uex' path='docs/doc[@for="GridColumnStylesCollection.IList.Clear"]/*' />
        /// <internalonly/>
        void IList.Clear() {
            this.Clear();
        }

        /// <include file='doc\DataGridColumnCollection.uex' path='docs/doc[@for="GridColumnStylesCollection.IList.Contains"]/*' />
        /// <internalonly/>
        bool IList.Contains(object value) {
            return items.Contains(value);
        }

        /// <include file='doc\DataGridColumnCollection.uex' path='docs/doc[@for="GridColumnStylesCollection.IList.IndexOf"]/*' />
        /// <internalonly/>
        int IList.IndexOf(object value) {
            return items.IndexOf(value);
        }

        /// <include file='doc\DataGridColumnCollection.uex' path='docs/doc[@for="GridColumnStylesCollection.IList.Insert"]/*' />
        /// <internalonly/>
        void IList.Insert(int index, object value) {
            throw new NotSupportedException();
        }

        /// <include file='doc\DataGridColumnCollection.uex' path='docs/doc[@for="GridColumnStylesCollection.IList.Remove"]/*' />
        /// <internalonly/>
        void IList.Remove(object value) {
            this.Remove((DataGridColumnStyle)value);
        }

        /// <include file='doc\DataGridColumnCollection.uex' path='docs/doc[@for="GridColumnStylesCollection.IList.RemoveAt"]/*' />
        /// <internalonly/>
        void IList.RemoveAt(int index) {
            this.RemoveAt(index);
        }

        /// <include file='doc\DataGridColumnCollection.uex' path='docs/doc[@for="GridColumnStylesCollection.IList.IsFixedSize"]/*' />
        /// <internalonly/>
        bool IList.IsFixedSize {
            get {return false;}
        }

        /// <include file='doc\DataGridColumnCollection.uex' path='docs/doc[@for="GridColumnStylesCollection.IList.IsReadOnly"]/*' />
        /// <internalonly/>
        bool IList.IsReadOnly {
            get {return false;}
        }

        /// <include file='doc\DataGridColumnCollection.uex' path='docs/doc[@for="GridColumnStylesCollection.IList.this"]/*' />
        /// <internalonly/>
        object IList.this[int index] {
            get { return items[index]; }
            set { throw new NotSupportedException(); }
        }

        /// <include file='doc\DataGridColumnCollection.uex' path='docs/doc[@for="GridColumnStylesCollection.ICollection.CopyTo"]/*' />
        /// <internalonly/>
        void ICollection.CopyTo(Array array, int index) {
            this.items.CopyTo(array, index);
        }

        /// <include file='doc\DataGridColumnCollection.uex' path='docs/doc[@for="GridColumnStylesCollection.ICollection.Count"]/*' />
        /// <internalonly/>
        int ICollection.Count {
            get {return this.items.Count;}
        }

        /// <include file='doc\DataGridColumnCollection.uex' path='docs/doc[@for="GridColumnStylesCollection.ICollection.IsSynchronized"]/*' />
        /// <internalonly/>
        bool ICollection.IsSynchronized {
            get {return false;}
        }

        /// <include file='doc\DataGridColumnCollection.uex' path='docs/doc[@for="GridColumnStylesCollection.ICollection.SyncRoot"]/*' />
        /// <internalonly/>
        object ICollection.SyncRoot {
            get {return this;}
        }

        /// <include file='doc\DataGridColumnCollection.uex' path='docs/doc[@for="GridColumnStylesCollection.IEnumerable.GetEnumerator"]/*' />
        /// <internalonly/>
        IEnumerator IEnumerable.GetEnumerator() {
            return items.GetEnumerator();
        }

        internal GridColumnStylesCollection(DataGridTableStyle table) {
            owner = table;
        }

        internal GridColumnStylesCollection(DataGridTableStyle table, bool isDefault) : this(table) {
            this.isDefault = isDefault;
        }

        /// <include file='doc\DataGridColumnCollection.uex' path='docs/doc[@for="GridColumnStylesCollection.List"]/*' />
        /// <devdoc>
        ///    <para>Gets the list of items in the collection.</para>
        /// </devdoc>
        protected override ArrayList List {
            get {
                return items;
            }
        }
        
        /* implemented in BaseCollection
        /// <summary>
        ///    <para>
        ///       Gets the number of System.Windows.Forms.DataGridColumnStyle objects in the collection.
        ///    </para>
        /// </summary>
        /// <value>
        ///    <para>
        ///       The number of System.Windows.Forms.DataGridColumnStyle objects in the System.Windows.Forms.GridColumnsStyleCollection .
        ///    </para>
        /// </value>
        /// <example>
        ///    <para>
        ///       The following example uses the <see cref='System.Windows.Forms.GridColumnsCollection.Count'/>
        ///       property to determine how many System.Windows.Forms.DataGridColumnStyle objects are in a System.Windows.Forms.GridColumnsStyleCollection, and uses that number to iterate through the
        ///       collection.
        ///    </para>
        ///    <code lang='VB'>
        /// Private Sub PrintGridColumns()
        ///    Dim colsCount As Integer
        ///    colsCount = DataGrid1.GridColumns.Count
        ///    Dim i As Integer
        ///    For i = 0 to colsCount - 1
        ///       Debug.Print DataGrid1.GridColumns(i).GetType.ToString
        ///    Next i
        /// End Sub
        ///    </code>
        /// </example>
        /// <seealso cref='System.Windows.Forms.GridColumnsCollection.Add'/>
        /// <seealso cref='System.Windows.Forms.GridColumnsCollection.Remove'/>
        public override int Count {
            get {
                return items.Count;
            }
        }
        */

        /// <include file='doc\DataGridColumnCollection.uex' path='docs/doc[@for="GridColumnStylesCollection.this"]/*' />
        /// <devdoc>
        /// <para>Gets the System.Windows.Forms.DataGridColumnStyle at a specified index.</para>
        /// </devdoc>
        public DataGridColumnStyle this[int index] {
            get {
                return (DataGridColumnStyle)items[index];
            }
        }

        /// <include file='doc\DataGridColumnCollection.uex' path='docs/doc[@for="GridColumnStylesCollection.this1"]/*' />
        /// <devdoc>
        /// <para>Gets the System.Windows.Forms.DataGridColumnStyle
        /// with the specified name.</para>
        /// </devdoc>
        public DataGridColumnStyle this[string columnName] {
            get {
                int itemCount = items.Count;
                for (int i = 0; i < itemCount; ++i) {
                    DataGridColumnStyle column = (DataGridColumnStyle)items[i];
                    // NOTE: case-insensitive
                    if (0 == String.Compare(column.MappingName, columnName, true, CultureInfo.InvariantCulture))
                        return column;
                }
                return null;
            }
        }

        internal DataGridColumnStyle MapColumnStyleToPropertyName(string mappingName) {
            int itemCount = items.Count;
            for (int i = 0; i < itemCount; ++i) {
                DataGridColumnStyle column = (DataGridColumnStyle)items[i];
                // NOTE: case-insensitive
                if (0 == String.Compare(column.MappingName, mappingName, true, CultureInfo.InvariantCulture))
                    return column;
            }
            return null;
        }

        /// <include file='doc\DataGridColumnCollection.uex' path='docs/doc[@for="GridColumnStylesCollection.this2"]/*' />
        /// <devdoc>
        /// <para>Gets the System.Windows.Forms.DataGridColumnStyle associated with the
        ///    specified <see cref='System.Data.DataColumn'/>.</para>
        /// </devdoc>
        public DataGridColumnStyle this[PropertyDescriptor propDesc] {
            get {
                int itemCount = items.Count;
                for (int i = 0; i < itemCount; ++i) {
                    DataGridColumnStyle column = (DataGridColumnStyle)items[i];
                    if (propDesc.Equals(column.PropertyDescriptor))
                        return column;
                }
                return null;
            }
        }

        internal DataGridTableStyle DataGridTableStyle {
            get {
                return this.owner;
            }
        }

        /// <devdoc>
        /// <para>Adds a System.Windows.Forms.DataGridColumnStyle to the System.Windows.Forms.GridColumnStylesCollection</para>
        /// </devdoc>

        internal void CheckForMappingNameDuplicates(DataGridColumnStyle column) {
            if (column.MappingName.Equals(String.Empty))
                return;
            for (int i = 0; i < items.Count; i++)
                if ( ((DataGridColumnStyle)items[i]).MappingName.Equals(column.MappingName) && column != items[i])
                    throw new ArgumentException(SR.GetString(SR.DataGridColumnStyleDuplicateMappingName), "column");
        }

        private void ColumnStyleMappingNameChanged(object sender, EventArgs pcea) {
            OnCollectionChanged(new CollectionChangeEventArgs(CollectionChangeAction.Refresh, null));
        }

        private void ColumnStylePropDescChanged(object sender, EventArgs pcea) {
            OnCollectionChanged(new CollectionChangeEventArgs(CollectionChangeAction.Refresh, (DataGridColumnStyle) sender));
        }

        /// <include file='doc\DataGridColumnCollection.uex' path='docs/doc[@for="GridColumnStylesCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual int Add(DataGridColumnStyle column) {
            if (this.isDefault) {
                throw new ArgumentException(SR.GetString(SR.DataGridDefaultColumnCollectionChanged));
            }

            CheckForMappingNameDuplicates(column);

            column.SetDataGridTableInColumn(owner, true);
            column.MappingNameChanged += new EventHandler(ColumnStyleMappingNameChanged);
            column.PropertyDescriptorChanged += new EventHandler(ColumnStylePropDescChanged);

            // columns which are not the default should have a default
            // width of DataGrid.PreferredColumnWidth
            if (this.DataGridTableStyle != null && column.Width == -1)
                column.width = this.DataGridTableStyle.PreferredColumnWidth;
#if false
            column.AddOnPropertyChanged(owner.OnColumnChanged);
#endif
            int index = items.Add(column);
            OnCollectionChanged(new CollectionChangeEventArgs(CollectionChangeAction.Add, column));
            return index;
        }
        
        /// <include file='doc\DataGridColumnCollection.uex' path='docs/doc[@for="GridColumnStylesCollection.AddRange"]/*' />
        public void AddRange(DataGridColumnStyle[] columns) {
            if (columns == null) {
                throw new ArgumentNullException("columns");
            }
            for (int i = 0; i < columns.Length; i++) {
                Add(columns[i]);            
            }
        }

        // the dataGrid will need to add default columns to a default
        // table when there is no match for the listName in the tableStyle
        internal void AddDefaultColumn(DataGridColumnStyle column) {
#if DEBUG
            Debug.Assert(this.isDefault, "we should be calling this function only for default tables");
            Debug.Assert(column.IsDefault, "we should be a default column");
#endif // DEBUG
            column.SetDataGridTableInColumn(owner, true);
            this.items.Add(column);
        }

        internal void ResetDefaultColumnCollection() {
            Debug.Assert(this.isDefault, "we should be calling this function only for default tables");
            // unparent the edit controls
            for (int i = 0; i < Count; i++) {
                this[i].ReleaseHostedControl();
            }

            // get rid of the old list and get a new empty list
            items.Clear();
        }

        /// <include file='doc\DataGridColumnCollection.uex' path='docs/doc[@for="GridColumnStylesCollection.CollectionChanged"]/*' />
        /// <devdoc>
        /// <para>Occurs when a change is made to the System.Windows.Forms.GridColumnStylesCollection.</para>
        /// </devdoc>
        public event CollectionChangeEventHandler CollectionChanged {
            add {
                onCollectionChanged += value;
            }
            remove {
                onCollectionChanged -= value;
            }
        }
        
        /// <include file='doc\DataGridColumnCollection.uex' path='docs/doc[@for="GridColumnStylesCollection.Clear"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Clear() {
            // unparent the edit controls
            for (int i = 0; i < Count; i++) {
                this[i].ReleaseHostedControl();
            }
            items.Clear();
            OnCollectionChanged(new CollectionChangeEventArgs(CollectionChangeAction.Refresh, null));
        }

        /// <include file='doc\DataGridColumnCollection.uex' path='docs/doc[@for="GridColumnStylesCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the System.Windows.Forms.GridColumnStylesCollection contains a System.Windows.Forms.DataGridColumnStyle associated with the
        ///       specified <see cref='System.Data.DataColumn'/>.
        ///    </para>
        /// </devdoc>
        public bool Contains(PropertyDescriptor propDesc) {
            return this[propDesc] != null;
        }

        /// <include file='doc\DataGridColumnCollection.uex' path='docs/doc[@for="GridColumnStylesCollection.Contains1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the System.Windows.Forms.GridColumnsStyleCollection contains the specified System.Windows.Forms.DataGridColumnStyle.
        ///    </para>
        /// </devdoc>
        public bool Contains(DataGridColumnStyle column) {
            int index = items.IndexOf(column);
            return index != -1;
        }

        /// <include file='doc\DataGridColumnCollection.uex' path='docs/doc[@for="GridColumnStylesCollection.Contains2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the System.Windows.Forms.GridColumnsStyleCollection contains the System.Windows.Forms.DataGridColumnStyle with the specified name.
        ///    </para>
        /// </devdoc>
        public bool Contains(string name) {
            IEnumerator e = items.GetEnumerator();
            while (e.MoveNext()) {
                DataGridColumnStyle column = (DataGridColumnStyle)e.Current;
                // NOTE: case-insensitive
                if (String.Compare(column.MappingName, name, true, CultureInfo.InvariantCulture) == 0)
                    return true;
            }
            return false;
        }

        /* implemented at BaseCollection
        /// <overload>
        ///    <para>
        ///       Gets an enumerator for the System.Windows.Forms.GridColumnsStyleCollection.
        ///    </para>
        /// </overload>
        /// <summary>
        ///    <para>
        ///       Gets an enumerator for the System.Windows.Forms.GridColumnsStyleCollection.
        ///    </para>
        /// </summary>
        /// <returns>
        ///    <para>
        ///       An <see cref='System.Collections.IEnumerator'/>
        ///       that can be used to iterate through the collection.
        ///    </para>
        /// </returns>
        /// <example>
        ///    <para>
        ///       The following example gets an <see cref='System.Collections.IEnumerator'/> that iterates through the System.Windows.Forms.GridColumnsStyleCollection. and prints the
        ///    <see cref='System.Windows.Forms.GridColumnsCollection.Caption'/> of each <see cref='System.Data.DataColumn'/> 
        ///    associated with the object.
        /// </para>
        /// <code lang='VB'>
        /// Private Sub EnumerateThroughGridColumns()
        ///    Dim ie As System.Collections.IEnumerator
        ///    Dim dgCol As DataGridColumn
        ///    Set ie = DataGrid1.GridColumns.GetEnumerator
        ///    Do While ie.GetNext = True
        ///       Set dgCol = ie.GetObject
        ///       Debug.Print dgCol.DataColumn.Caption
        ///    Loop
        /// End Sub
        /// </code>
        /// </example>
        /// <seealso cref='System.Data.DataColumn'/>
        /// <seealso cref='System.Collections.IEnumerator'/>
        /// <seealso cref='System.Windows.Forms.IEnumerator.GetNext'/>
        /// <seealso cref='System.Windows.Forms.IEnumerator.GetObject'/>
        public override IEnumerator GetEnumerator() {
            return items.GetEnumerator();
        }

        /// <summary>
        ///    <para>
        ///       Gets an enumerator for the System.Windows.Forms.GridColumnsStyleCollection
        ///       .
        ///    </para>
        /// </summary>
        /// <param name='allowRemove'>
        /// <para>A value that indicates if the enumerator can remove elements. <see langword='true'/>, if removals are allowed; otherwise, <see langword='false'/>. The default is <see langword='false'/>.</para>
        /// </param>
        /// <returns>
        ///    <para>
        ///       An <see cref='System.Collections.IEnumerator'/> that can be used to iterate through the
        ///       collection.
        ///    </para>
        /// </returns>
        /// <exception cref='NotSupportedException'>
        ///    An attempt was made to remove the System.Windows.Forms.DataGridColumnStyle through the <see cref='System.Collections.Enumerator'/> object's <see cref='System.Windows.Forms.Enumerator.Remove'/> method. Use the System.Windows.Forms.GridColumnsStyleCollection object's <see cref='System.Windows.Forms.GridColumnsCollection.Remove'/> method instead.
        /// </exception>
        /// <remarks>
        ///    <para>
        ///       Because this implementation doesn't support the removal
        ///       of System.Windows.Forms.DataGridColumnStyle objects through the <see cref='System.Collections.Enumerator'/>
        ///       class's <see cref='System.Windows.Forms.Enumerator.Remove'/> method, you must use the <see cref='System.Windows.Forms.DataGridCollection'/> class's <see cref='System.Windows.Forms.GridColumnsCollection.Remove'/>
        ///       method instead.
        ///    </para>
        /// </remarks>
        /// <example>
        ///    <para>
        ///       The following example gets an <see cref='System.Collections.IEnumerator'/> for that iterates through the System.Windows.Forms.GridColumnsStyleCollection. If a column in the collection is of type <see cref='System.Windows.Forms.DataGridBoolColumn'/>, it is deleted.
        ///    </para>
        ///    <code lang='VB'>
        /// Private Sub RemoveBoolColumns()
        ///    Dim ie As System.Collections.IEnumerator
        ///    Dim dgCol As DataGridColumn
        ///    Set ie = DataGrid1.GridColumns.GetEnumerator(true)
        ///    Do While ie.GetNext
        ///       Set dgCol = ie.GetObject
        ///       
        ///       If dgCol.ToString = "DataGridBoolColumn" Then
        ///          DataGrid1.GridColumns.Remove dgCol
        ///       End If
        ///    Loop
        /// End If
        ///    </code>
        /// </example>
        /// <seealso cref='System.Collections.IEnumerator'/>
        /// <seealso cref='System.Windows.Forms.IEnumerator.GetNext'/>
        /// <seealso cref='System.Windows.Forms.IEnumerator.GetObject'/>
        /// <seealso cref='System.Windows.Forms.GridColumnsCollection.Remove'/>
        public override IEnumerator GetEnumerator(bool allowRemove) {
            if (!allowRemove)
                return GetEnumerator();
            else
                throw new NotSupportedException(SR.GetString(SR.DataGridColumnCollectionGetEnumerator));
        }
        */

        /// <include file='doc\DataGridColumnCollection.uex' path='docs/doc[@for="GridColumnStylesCollection.IndexOf"]/*' />
        /// <devdoc>
        /// <para>Gets the index of a specified System.Windows.Forms.DataGridColumnStyle.</para>
        /// </devdoc>
        public int IndexOf(DataGridColumnStyle element) {
            int itemCount = items.Count;
            for (int i = 0; i < itemCount; ++i) {
                DataGridColumnStyle column = (DataGridColumnStyle)items[i];
                if (element == column)
                    return i;
            }
            return -1;
        }

        /// <include file='doc\DataGridColumnCollection.uex' path='docs/doc[@for="GridColumnStylesCollection.OnCollectionChanged"]/*' />
        /// <devdoc>
        /// <para>Raises the System.Windows.Forms.GridColumnsCollection.CollectionChanged event.</para>
        /// </devdoc>
        protected void OnCollectionChanged(CollectionChangeEventArgs ccevent) {
            if (onCollectionChanged != null)
                onCollectionChanged(this, ccevent);

            DataGrid grid = owner.DataGrid;
            if (grid != null) {
                grid.checkHierarchy = true;
            }
        }

        /// <include file='doc\DataGridColumnCollection.uex' path='docs/doc[@for="GridColumnStylesCollection.Remove"]/*' />
        /// <devdoc>
        /// <para>Removes the specified System.Windows.Forms.DataGridColumnStyle from the System.Windows.Forms.GridColumnsStyleCollection.</para>
        /// </devdoc>
        public void Remove(DataGridColumnStyle column) {
            if (this.isDefault) {
                throw new ArgumentException(SR.GetString(SR.DataGridDefaultColumnCollectionChanged));
            }

            int columnIndex = -1;
            int itemsCount = items.Count;
            for (int i = 0; i < itemsCount; ++i)
                if (items[i] == column) {
                    columnIndex = i;
                    break;
                }
            if (columnIndex == -1)
                throw new InvalidOperationException(SR.GetString(SR.DataGridColumnCollectionMissing));
            else
                RemoveAt(columnIndex);
        }

        /// <include file='doc\DataGridColumnCollection.uex' path='docs/doc[@for="GridColumnStylesCollection.RemoveAt"]/*' />
        /// <devdoc>
        /// <para>Removes the System.Windows.Forms.DataGridColumnStyle with the specified index from the System.Windows.Forms.GridColumnsStyleCollection.</para>
        /// </devdoc>
        public void RemoveAt(int index) {
            if (this.isDefault) {
                throw new ArgumentException(SR.GetString(SR.DataGridDefaultColumnCollectionChanged));
            }

            DataGridColumnStyle toRemove = (DataGridColumnStyle)items[index];
            toRemove.SetDataGridTableInColumn(null, true);
            toRemove.MappingNameChanged -= new EventHandler(ColumnStyleMappingNameChanged);
            toRemove.PropertyDescriptorChanged -= new EventHandler(ColumnStylePropDescChanged);
#if false
            toRemove.RemoveOnPropertyChange(owner.OnColumnChanged);
#endif
            items.RemoveAt(index);
            OnCollectionChanged(new CollectionChangeEventArgs(CollectionChangeAction.Remove, toRemove));
        }

        /// <include file='doc\DataGridColumnCollection.uex' path='docs/doc[@for="GridColumnStylesCollection.ResetPropertyDescriptors"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ResetPropertyDescriptors() {
            for (int i = 0; i < this.Count; i++) {
                this[i].PropertyDescriptor = null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\datagridcolumn.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGridColumn.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms{
    using System.Runtime.Remoting;
    using System.ComponentModel;
    using System;
    using System.Collections;
    using System.Windows.Forms;
    using System.Drawing;
    using System.Diagnostics;
    using Microsoft.Win32;
    using System.Runtime.InteropServices;

    /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="IDataGridColumnStyleEditingNotificationService"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public interface IDataGridColumnStyleEditingNotificationService {
        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="IDataGridColumnStyleEditingNotificationService.ColumnStartedEditing"]/*' />
        void ColumnStartedEditing(Control editingControl);
    }

    /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle"]/*' />
    /// <devdoc>
    ///    <para>Specifies the appearance and text formatting and behavior of
    ///       a <see cref='System.Windows.Forms.DataGrid'/> control column.</para>
    /// </devdoc>
    [
    ToolboxItem(false),
    DesignTimeVisible(false),
    DefaultProperty("Header")
    ]
    public abstract class DataGridColumnStyle : Component, IDataGridColumnStyleEditingNotificationService {

        private HorizontalAlignment alignment            = HorizontalAlignment.Left;
        // private SolidBrush         alternatingBackBrush = null;
        // private SolidBrush     backBrush            = null;
        // SolidBrush    foreBrush            = null;
        private PropertyDescriptor propertyDescriptor = null;
        private DataGridTableStyle dataGridTableStyle        = null;
        private Font         font                 = null;
        internal int         fontHeight           = -1;
        private string       mappingName       = "";
        private string       headerName       = "";
        private bool         invalid              = false;
        private string       nullText            = SR.GetString(SR.DataGridNullText);
        private bool         readOnly             = false;
        private bool         updating             = false;
        //private bool        visible              = true;
        internal int         width                = -1;
        private bool         isDefault            = false;
        AccessibleObject     headerAccessibleObject = null;

        private static readonly object EventAlignment                   = new object();
        private static readonly object EventPropertyDescriptor          = new object();
        private static readonly object EventFont                        = new object();
        private static readonly object EventHeaderText                  = new object();
        private static readonly object EventMappingName                 = new object();
        private static readonly object EventNullText                    = new object();
        private static readonly object EventReadOnly                    = new object();
        private static readonly object EventWidth                       = new object();

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.DataGridColumnStyle"]/*' />
        /// <devdoc>
        ///    <para>In a derived class,
        ///       initializes a new instance of the <see cref='System.Windows.Forms.DataGridColumnStyle'/> class.</para>
        /// </devdoc>
        public DataGridColumnStyle() {
        }
        
        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.DataGridColumnStyle1"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Windows.Forms.DataGridColumnStyle'/> class with the specified <see cref='T:System.ComponentModel.PropertyDescriptor'/>.</para>
        /// </devdoc>
        public DataGridColumnStyle(PropertyDescriptor prop) : this() {
            this.PropertyDescriptor = prop;
            if (prop != null)
                this.readOnly = prop.IsReadOnly;
        }

        internal DataGridColumnStyle(PropertyDescriptor prop, bool isDefault) : this(prop) {
            this.isDefault = isDefault;
            if (isDefault) {
                // take the header name from the property name
                this.headerName = prop.Name;
                this.mappingName = prop.Name;
            }
        }

#if DEBUG
        internal bool IsDefault {
            get {
                return this.isDefault;
            }
        }
#endif // debug

        // =------------------------------------------------------------------
        // =        Properties
        // =------------------------------------------------------------------
        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.Alignment"]/*' />
        /// <devdoc>
        ///       Gets or sets the alignment of text in a column.
        /// </devdoc>
        [SRCategory(SR.CatDisplay),
        Localizable(true),
        DefaultValue(HorizontalAlignment.Left)]
        public virtual HorizontalAlignment Alignment {        
            get {
                return alignment;
            }
            set {
               if (!Enum.IsDefined(typeof(HorizontalAlignment), value)) {
                   throw new InvalidEnumArgumentException("value", (int)value, typeof(DataGridLineStyle));
               }
                if (alignment != value) {
                    alignment = value;
                    OnAlignmentChanged(EventArgs.Empty);
                    Invalidate();
                 }
            }
        }

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.AlignmentChanged"]/*' />
        public event EventHandler AlignmentChanged {
            add {
                Events.AddHandler(EventAlignment, value);
            }
            remove {
                Events.RemoveHandler(EventAlignment, value);
            }
        }

        /*
        /// <summary>
        ///    <para>Gets or sets the background color of alternating rows for a ledger
        ///       appearance.</para>
        /// </summary>
        /// <value>
        /// <para>A <see cref='System.Drawing.Color'/> that represents the alternating background
        ///    color. The default is the <see cref='System.Windows.Forms.DataGrid.AlternatingBackColor'/> of the
        ///    control.</para>
        /// </value>
        /// <remarks>
        ///    <para>Use this property to set a custom alternating color for each column displayed 
        ///       in the <see cref='System.Drawing.DataGrid'/> control.</para>
        /// </remarks>
        /// <example>
        /// <para>The following example sets the <see cref='System.Windows.Forms.DataGridColumnStyle.AlternatingBackColor'/> property of a specific <see cref='System.Windows.Forms.DataGridColumnStyle'/>
        /// to yellow.</para>
        /// <code lang='VB'>Private Sub SetColumnAlternatingBackColor()
        ///    ' Create a color object.
        ///    Dim c As System.Drawing.Color
        ///    c = System.Drawing.Color.Yellow
        ///    ' Declare an object variable for the DataGridColumnStyle.      
        ///    Dim myGridColumn As DataGridColumnStyle
        ///    myGridColumn = DataGrid1.GridColumns(0)
        ///    ' Set the AlternatingBackColor to the color object.
        ///    myGridColumn.AlternatingBackColor = c
        /// End Sub
        /// </code>
        /// </example>
        /// <seealso cref='System.Windows.Forms.DataGrid.AlternatingBackColor'/>
        /// <seealso cref='System.Windows.Forms.DataGridColumnStyle.BackColor'/>
        [SRCategory(SR.CatColors)]
        public virtual Color AlternatingBackColor {
            get {
                if (alternatingBackBrush != null) {
                    return alternatingBackBrush.Color;
                }
                DataGrid grid = DataGrid;
                if (grid != null) {
                    return this.DataGridTableStyle.AlternatingBackColor;
                }
                return System.Windows.Forms.DataGridTableStyle.defaultAlternatingBackBrush.Color;
            }
            set {
                if (value != Color.Empty && alternatingBackBrush != null && value.Equals(alternatingBackBrush.Color)) {
                    return;
                }
                this.alternatingBackBrush = new SolidBrush(value);
                RaisePropertyChanged(EventArgs.Empty"AlternatingBackColor");
                Invalidate();
            }
        }
        */

        /*
        /// <summary>
        /// <para>Indicates whether the <see cref='System.Windows.Forms.DataGridColumnStyle.AlternatingBackColor'/>
        /// property should be persisted.</para>
        /// </summary>
        /// <returns>
        /// <para><see langword='true '/>if the property 
        ///    value has been changed from its default; otherwise,
        /// <see langword='false'/>.</para>
        /// </returns>
        /// <remarks>
        ///    <para>You typically use this method only if you are either
        ///       creating a designer for the <see cref='System.Windows.Forms.DataGrid'/>, or creating your own control
        ///       incorporating the <see cref='System.Windows.Forms.DataGrid'/>.</para>
        /// <para>You can use the <see cref='System.Windows.Forms.DataGridColumnStyle.ShouldSerializeAlternatingBackColor'/> method to
        ///    determine whether the property value has changed from its default.</para>
        /// </remarks>
        /// <seealso cref='System.Drawing.DataGridColumnStyle.AlternatingBackColor'/>
        internal bool ShouldSerializeAlternatingBackColor() {
            return alternatingBackBrush != null;
        }
        */

        /*
        /// <summary>
        ///    <para>
        ///       Resets the <see cref='System.Windows.Forms.DataGridColumnStyle.AlternatingBackColor'/>
        ///       property to its default value.
        ///    </para>
        /// </summary>
        /// <remarks>
        ///    <para>
        ///       You typically use this method only if you are either creating a designer for
        ///       the <see cref='System.Windows.Forms.DataGrid'/>, or creating your own control incorporating the
        ///    <see cref='System.Windows.Forms.DataGrid'/>. 
        ///    </para>
        ///    <para>
        ///       You can use the <see cref='System.Windows.Forms.DataGridColumnStyle.ShouldSerializeAlternatingBackColor'/>
        ///       method to determine whether the property value has changed from its default.
        ///    </para>
        ///    <para>
        ///       The OnPropertyChanged
        ///       event occurs when the property value changes.
        ///    </para>
        /// </remarks>
        public void ResetAlternatingBackColor() {
            if (alternatingBackBrush != null) {
                this.alternatingBackBrush = null;
                RaisePropertyChanged(EventArgs.Empty"AlternatingBackColor");
                Invalidate();
            }
        }
        */

        /*
        /// <summary>
        ///    <para>
        ///       Gets either the <see cref='System.Windows.Forms.DataGridColumnStyle.BackColor'/> or the <see cref='System.Windows.Forms.DataGridColumnStyle.AlternatingBackColor'/> of
        ///       a specified row.
        ///    </para>
        /// </summary>
        /// <returns>
        ///    <para>
        ///       A <see cref='System.Drawing.Color'/> that represents the background color.
        ///    </para>
        /// </returns>
        /// <seealso cref='System.Windows.Forms.DataGridColumnStyle.AlternatingBackColor'/>
        /// <seealso cref='System.Windows.Forms.DataGridColumnStyle.BackColor'/>
        /// <seealso cref='System.Windows.Forms.DataGridColumnStyle.GetBackColor'/>
        /// <keyword term=''/>
        public Color GetBackColor(int rowNum) {
            DataGrid grid = DataGrid;
            if (rowNum % 2 == 1 && (grid != null && grid.LedgerStyle))
                return AlternatingBackColor;
            else
                return BackColor;
        }
        */

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.UpdateUI"]/*' />
        /// <devdoc>
        ///    <para>When overridden in a derived class, updates the value of a specified row with 
        ///       the given text.</para>
        /// </devdoc>
        protected internal virtual void UpdateUI(CurrencyManager source, int rowNum, string instantText)
        {
        }

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.HeaderAccessibleObject"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       [To Editor: I think this is going away.]
        ///    </para>
        ///    <para>
        ///       Gets or sets the background color of the column.
        ///    </para>
        /// </devdoc>
        [Browsable(false)]
        public AccessibleObject HeaderAccessibleObject {
            get {
                if (headerAccessibleObject == null) {
                    headerAccessibleObject = CreateHeaderAccessibleObject();
                }
                return headerAccessibleObject;
            }
        }

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.PropertyDescriptor"]/*' />
        /// <devdoc>
        /// <para>Gets or sets the <see cref='System.Data.DataColumn'/> that determines the
        ///    attributes of data displayed by the <see cref='System.Windows.Forms.DataGridColumnStyle'/>.</para>
        /// </devdoc>
        [DefaultValue(null), Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced)]
        public virtual PropertyDescriptor PropertyDescriptor {
            get {
                return propertyDescriptor;
            }
            set {
                if (propertyDescriptor != value) {
                    propertyDescriptor = value;
                    OnPropertyDescriptorChanged(EventArgs.Empty);
                    /*
                    // CONSIDER: change Header to dataColumn.ColumnName on property set
                    if (propertyDescriptor != null && gridColumnName.Length == 0)
                        gridColumnName = propertyDescriptor.Name;
                    */
                }
            }
        }

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.PropertyDescriptorChanged"]/*' />
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced)]
        public event EventHandler PropertyDescriptorChanged {
            add {
                Events.AddHandler(EventPropertyDescriptor, value);
            }
            remove {
                Events.RemoveHandler(EventPropertyDescriptor, value);
            }
        }

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.CreateHeaderAccessibleObject"]/*' />
        /// <devdoc>
        /// <para>Gets the <see cref='System.Windows.Forms.DataGrid'/> control that the <see cref='System.Windows.Forms.DataGridColumnStyle'/> belongs to.</para>
        /// </devdoc>
        /*
        protected virtual DataGrid DataGrid {
            get {
                DataGridTableStyle gridTable = DataGridTableStyle;
                if (gridTable == null)
                    return null;
                return gridTable.DataGrid;
            }
        }
        */

        protected virtual AccessibleObject CreateHeaderAccessibleObject() {
            return new DataGridColumnHeaderAccessibleObject(this);
        }

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.SetDataGrid"]/*' />
        /// <devdoc>
        /// <para>When overridden in a derived class, sets the <see cref='System.Windows.Forms.DataGrid'/> control that this column 
        ///    belongs to.</para>
        /// </devdoc>
        protected virtual void SetDataGrid(DataGrid value)
        {
            SetDataGridInColumn(value);
        }

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.SetDataGridInColumn"]/*' />
        /// <devdoc>
        ///    <para>
        ///       When overridden in a derived class,
        ///       sets the <see cref='System.Windows.Forms.DataGrid'/> for the column.
        ///    </para>
        /// </devdoc>
        protected virtual void SetDataGridInColumn(DataGrid value) {
            // we need to set up the PropertyDescriptor
            if (this.PropertyDescriptor == null && value != null)
            {
                CurrencyManager lm = value.ListManager;
                if (lm == null) return;
                PropertyDescriptorCollection propCollection = lm.GetItemProperties();
                int propCount = propCollection.Count;
                for (int i = 0; i < propCollection.Count; i++)
                {
                    PropertyDescriptor prop = propCollection[i];
                    if (!typeof(IList).IsAssignableFrom(prop.PropertyType) && prop.Name.Equals(this.HeaderText))
                    {
                        this.PropertyDescriptor = prop;
                        return;
                    }
                }
            }
        }

        internal void SetDataGridInternalInColumn(DataGrid value) {
            if (value == null || value.Initializing)
                return;
            SetDataGridInColumn(value);
        }

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.DataGridTableStyle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the System.Windows.Forms.DataGridTableStyle for the column.
        ///    </para>
        /// </devdoc>
        [Browsable(false)]
        public virtual DataGridTableStyle DataGridTableStyle {
            get {
                return dataGridTableStyle;
            }
        }

        internal void SetDataGridTableInColumn(DataGridTableStyle value, bool force) {
            if (dataGridTableStyle != null && dataGridTableStyle.Equals(value) && !force)
                return;
            if (value != null) {
                if (value.DataGrid != null && !value.DataGrid.Initializing) {
                    this.SetDataGridInColumn(value.DataGrid);
                }
            }
            dataGridTableStyle = value;
        }

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.FontHeight"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the height of the column's font.
        ///    </para>
        /// </devdoc>
        protected int FontHeight {
            get {
                if (fontHeight != -1) {
                    return fontHeight;
                }
                else if (DataGridTableStyle!= null) {
                    return DataGridTableStyle.DataGrid.FontHeight;
                }
                else {
                    return DataGridTableStyle.defaultFontHeight;
                }
            }
        }

        /// <devdoc>
        ///    <para>
        ///       Indicates whether the Font property should be persisted.
        ///    </para>
        /// </devdoc>
        private bool ShouldSerializeFont() {
            return font != null;
        }

        /// <devdoc>
        ///    <para>
        ///       Resets the System.Windows.Forms.DataGridColumnStyle.Font property to its default value.
        ///    </para>
        /// </devdoc>
        private void ResetFont() {
            if (font != null) {
                font = null;
                OnFontChanged(EventArgs.Empty);
                Invalidate();
            }
        }

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.FontChanged"]/*' />
        public event EventHandler FontChanged {
            add {
                Events.AddHandler(EventFont, value);
            }
            remove {
                Events.RemoveHandler(EventFont, value);
            }
        }


        /*
        /// <summary>
        ///    <para>
        ///       Gets or sets the foreground color of the column.
        ///    </para>
        /// </summary>
        /// <value>
        ///    <para>
        ///       A <see cref='System.Drawing.Color'/> that represents the foreground color. The
        ///       default is the foreground color of the <see cref='System.Windows.Forms.DataGrid'/> control.
        ///    </para>
        /// </value>
        /// <remarks>
        ///    <para>
        ///       The OnPropertyChanged event occurs when the property value
        ///       changes.
        ///    </para>
        /// </remarks>
        /// <example>
        ///    <para>
        ///       The following example sets the <see cref='System.Windows.Forms.DataGridColumnStyle.ForeColor'/> property of
        ///       a given <see cref='System.Windows.Forms.DataGridColumnStyle'/>.
        ///    </para>
        ///    <code lang='VB'>
        /// Dim c As System.Drawing.Color
        /// Dim dgCol As DataGridColumnStyle
        /// c = System.Drawing.CadetBlue
        /// Set dgCol = DataGrid1.GridColumns(0)
        /// dgCol.ForeColor = c
        ///       </code>
        /// </example>
        /// <seealso cref='System.Windows.Forms.DataGridColumnStyle.AlternatingBackColor'/>
        /// <seealso cref='System.Windows.Forms.DataGridColumnStyle.BackColor'/>
        /// <seealso cref='System.Windows.Forms.DataGridColumnStyle.GetBackColor'/>
        /// <keyword term=''/>
        public virtual Color ForeColor {
            get {
                if (foreBrush != null) {
                    return foreBrush.Color;
                }
                DataGrid grid = DataGrid;
                if (grid != null) {
                    return grid.ForeColor;
                }
                return DataGrid.defaultForeBrush.Color;
            }
            set {
                if (value != Color.Empty && foreBrush != null && value.Equals(foreBrush.Color))
                    return;
                this.foreBrush = new SolidBrush(value);
                RaisePropertyChanged(EventArgs.Empty"ForeColor");
                Invalidate();
            }
        }

        // used by the DataGridRow
        internal SolidBrush ForeBrush {
            get {
                if (foreBrush != null) {
                    return foreBrush;
                }
                DataGrid grid = DataGrid;
                if (grid != null) {
                    return grid.ForeBrush;
                }
                return DataGrid.defaultForeBrush;
            }
        }
        */

        /*
        /// <summary>
        ///    <para>
        ///       Indicates if the <see cref='System.Windows.Forms.DataGridColumnStyle.ForeColor'/> property should be
        ///       persisted.
        ///    </para>
        /// </summary>
        /// <returns>
        ///    <para>
        ///    <see langword='true '/>if the property value has been changed from its 
        ///       default; otherwise, <see langword='false'/> .
        ///    </para>
        /// </returns>
        /// <remarks>
        ///    <para>
        ///       You typically use this method only if you are either creating a designer for
        ///       the <see cref='System.Windows.Forms.DataGrid'/>, or creating your own control incorporating the
        ///    <see cref='System.Windows.Forms.DataGrid'/>. 
        ///    </para>
        /// </remarks>
        internal bool ShouldSerializeForeColor() {
            return foreBrush != null;
        }
        */

        /*
        /// <summary>
        ///    <para>
        ///       Resets the <see cref='System.Windows.Forms.DataGridColumnStyle.ForeColor'/> property to its default value.
        ///    </para>
        /// </summary>
        /// <remarks>
        ///    <para>
        ///       You typically use this method if you are either creating a designer for
        ///       the <see cref='System.Windows.Forms.DataGrid'/>, or creating your own control incorporating the
        ///    <see cref='System.Windows.Forms.DataGrid'/>. 
        ///    </para>
        ///    <para>
        ///       You can use the <see cref='System.Windows.Forms.DataGridColumnStyle.ShouldSerializeForeColor'/> method to
        ///       determine whether the property value has changed from its default.
        ///    </para>
        ///    <para>
        ///       The OnPropertyChanged event occurs when the property
        ///       value changes.
        ///    </para>
        /// </remarks>
        public void ResetForeColor() {
            if (foreBrush != null) {
                foreBrush = null;
                RaisePropertyChanged(EventArgs.Empty"ForeColor");
                Invalidate();
            }
        }
        */

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.HeaderText"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the text of the column header.
        ///    </para>
        /// </devdoc>
        [
        Localizable(true),
        SRCategory(SR.CatDisplay)
        ]
        public virtual string HeaderText {
            get {
                return headerName; 
            }
            set {
                if (value == null)
                    value = "";

                if (headerName.Equals(value))
                    return;

                headerName = value;
                OnHeaderTextChanged(EventArgs.Empty);
                // we only invalidate columns that are visible ( ie, their propertyDescriptor is not null)
                if (this.PropertyDescriptor != null)
                    Invalidate();
            }
        }

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.HeaderTextChanged"]/*' />
        public event EventHandler HeaderTextChanged {
            add {
                Events.AddHandler(EventHeaderText, value);
            }
            remove {
                Events.RemoveHandler(EventHeaderText, value);
            }
        }

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.MappingName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        Editor("System.Windows.Forms.Design.DataGridColumnStyleMappingNameEditor, " + AssemblyRef.SystemDesign, typeof(System.Drawing.Design.UITypeEditor)),
        Localizable(true)
        ]
        public string MappingName {
            get {
                return mappingName;
            }
            set {
                if (value == null)
                    value = "";
                if (mappingName.Equals(value))
                    return;
                string originalMappingName = mappingName;
                // this may throw
                mappingName = value;
                try {
                    if (this.dataGridTableStyle != null)
                        this.dataGridTableStyle.GridColumnStyles.CheckForMappingNameDuplicates(this);
                } catch {
                    mappingName = originalMappingName;
                    throw;
                }
                OnMappingNameChanged(EventArgs.Empty);
            }
        }

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.MappingNameChanged"]/*' />
        public event EventHandler MappingNameChanged {
            add {
                Events.AddHandler(EventMappingName, value);
            }
            remove {
                Events.RemoveHandler(EventMappingName, value);
            }
        }

        /// <devdoc>
        ///    <para>
        ///       Indicates whether the System.Windows.Forms.DataGridColumnStyle.Header property should be
        ///       persisted.
        ///    </para>
        /// </devdoc>
        private bool ShouldSerializeHeaderText() {
            return(headerName.Length != 0);
        }

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.ResetHeader"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Resets the System.Windows.Forms.DataGridColumnStyle.Header to its default value
        ///       (<see langword='null'/> ).
        ///    </para>
        /// </devdoc>
        public void ResetHeaderText() {
            HeaderText = "";
        }

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.NullText"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the text that is displayed when the column contains a null
        ///       value.</para>
        /// </devdoc>
        [
        Localizable(true),
        SRCategory(SR.CatDisplay)
        ]
        public virtual string NullText {
            get {
                return nullText;
            }
            set {
                if (nullText != null && nullText.Equals(value))
                    return;
                nullText = value;
                OnNullTextChanged(EventArgs.Empty);
                Invalidate();
            }
        }

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.NullTextChanged"]/*' />
        public event EventHandler NullTextChanged {
            add {
                Events.AddHandler(EventNullText, value);
            }
            remove {
                Events.RemoveHandler(EventNullText, value);
            }
        }

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.ReadOnly"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value indicating whether the data in the column cannot be edited.</para>
        /// </devdoc>
        [DefaultValue(false)]
        public virtual bool ReadOnly {
            get {
                return readOnly;
            }
            set {
                if (readOnly != value) {
                    readOnly = value;
                    OnReadOnlyChanged(EventArgs.Empty);
                }
            }
        }

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.ReadOnlyChanged"]/*' />
        public event EventHandler ReadOnlyChanged {
            add {
                Events.AddHandler(EventReadOnly, value);
            }
            remove {
                Events.RemoveHandler(EventReadOnly, value);
            }
        }

#if false
        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.Visible"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the column is visible.
        ///    </para>
        /// </devdoc>
        [DefaultValue(true)]
        public virtual bool Visible {
            get {
                return visible;
            }
            set {
                if (visible == value)
                    return;
                visible = value;
                RaisePropertyChanged(EventArgs.Empty"Visible");
                Invalidate();
            }
        }
#endif

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.Width"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the width of the column.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatLayout),
        Localizable(true),
        DefaultValue(100)
        ]
        public virtual int Width {
            get {
                return width;
            }
            set {
                if (width != value) {
                    width = value;
                    DataGrid grid = this.DataGridTableStyle == null ? null : DataGridTableStyle.DataGrid;
                    if (grid != null) {
                        // rearrange the scroll bars
                        grid.PerformLayout();

                        // force the grid to repaint
                        grid.InvalidateInside();
                    }
                    OnWidthChanged(EventArgs.Empty);
                }
            }
        }

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.WidthChanged"]/*' />
        public event EventHandler WidthChanged {
            add {
                Events.AddHandler(EventWidth, value);
            }
            remove {
                Events.RemoveHandler(EventWidth, value);
            }
        }

        // =------------------------------------------------------------------
        // =        Methods
        // =------------------------------------------------------------------

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.BeginUpdate"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Suspends the painting of the column until the <see cref='System.Windows.Forms.DataGridColumnStyle.EndUpdate'/>
        ///       method is called.
        ///    </para>
        /// </devdoc>
        protected void BeginUpdate() {
            updating = true;
        }

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.EndUpdate"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Resumes the painting of columns suspended by calling the
        ///    <see cref='System.Windows.Forms.DataGridColumnStyle.BeginUpdate'/> 
        ///    method.
        /// </para>
        /// </devdoc>
        protected void EndUpdate() {
            updating = false;
            if (invalid) {
                invalid = false;
                Invalidate();
            }
        }

        internal virtual bool WantArrows {
            get {
                return false;
            }
        }


        internal virtual string GetDisplayText(object value) {
            return value.ToString();
        }

        private bool ShouldSerializeNullText() {
            return (!SR.GetString(SR.DataGridNullText).Equals(nullText));
        }

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.GetPreferredSize"]/*' />
        /// <devdoc>
        ///    <para>When overridden in a derived class,
        ///       gets the optimum width and height of the specified value.</para>
        /// </devdoc>
        protected internal abstract Size GetPreferredSize(Graphics g, object value);

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.GetMinimumHeight"]/*' />
        /// <devdoc>
        ///    <para>Gets the minimum height of a row.</para>
        /// </devdoc>
        protected internal abstract int GetMinimumHeight();

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.GetPreferredHeight"]/*' />
        /// <devdoc>
        ///    <para>When
        ///       overridden in a derived class, gets the height to be used in for automatically resizing columns.</para>
        /// </devdoc>
        protected internal abstract int GetPreferredHeight(Graphics g, object value);

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.GetColumnValueAtRow"]/*' />
        /// <devdoc>
        ///    <para>Gets the value in the specified row from the specified 
        ///    System.Windows.Forms.ListManager.</para>
        /// </devdoc>
        protected internal virtual object GetColumnValueAtRow(CurrencyManager source, int rowNum) {
            CheckValidDataSource(source);
            if (PropertyDescriptor == null) {
                throw new InvalidOperationException(SR.GetString(SR.DataGridColumnNoPropertyDescriptor));
            }
            object value = PropertyDescriptor.GetValue(source[rowNum]);
            return value;
        }

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.Invalidate"]/*' />
        /// <devdoc>
        ///    <para>Redraws the column and causes a paint
        ///       message to be sent to the control.</para>
        /// </devdoc>
        protected virtual void Invalidate() {
            if (updating) {
                invalid = true;
                return;
            }
            DataGridTableStyle table = this.DataGridTableStyle;
            if (table != null)
                table.InvalidateColumn(this);
        }

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.CheckValidDataSource"]/*' />
        /// <devdoc>
        /// <para>Checks if the specified DataView is valid.</para>
        /// </devdoc>
        protected void CheckValidDataSource(CurrencyManager value) {
            if (value == null) {
                throw new ArgumentNullException("value", "DataGridColumnStyle.CheckValidDataSource(DataSource value), value == null");
            }
            // the code may delete a gridColumn that was editing
            // in that case, we still have to push the value into the backEnd
            // and we only need the propertyDescriptor to push the value.
            // (take a look at gridEditAndDeleteEditColumn)
            //
            // DataGridTableStyle myTable = this.DataGridTableStyle;
            PropertyDescriptor myPropDesc = this.PropertyDescriptor;
            if (myPropDesc == null) {
                throw new InvalidOperationException(SR.GetString(SR.DataGridColumnUnbound, HeaderText));
            }

#if false
            DataTable myDataTable = myTable.DataTable;
            if (myDataColumn.Table != myDataTable) {
                throw new InvalidOperationException(SR.GetString(SR.DataGridColumnDataSourceMismatch, Header));
            }

            /* FOR DEMO: danielhe: DataGridColumnStyle::CheckValidDataSource: make the check better */
            if (((DataView) value.DataSource).Table == null) {
                throw new InvalidOperationException(SR.GetString(SR.DataGridColumnNoDataTable, Header));
            }
            else {
                /* FOR DEMO: danielhe: DataGridColumnStyle::CheckValidDataSource: make the check better */
                if (!myTable.DataTable.Equals(((DataView) value.DataSource).Table)) {
                    throw new InvalidOperationException(SR.GetString(SR.DataGridColumnNoDataSource, Header, myTable.DataTable.TableName));
                }
            }
#endif // false
        }

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.Abort"]/*' />
        /// <devdoc>
        ///    <para>
        ///       When overridden in a derived class, initiates a
        ///       request to interrrupt an edit procedure.
        ///    </para>
        /// </devdoc>
        protected internal abstract void Abort(int rowNum);

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.Commit"]/*' />
        /// <devdoc>
        ///    <para>When overridden in a derived class, inititates a request to complete an
        ///       editing procedure.</para>
        /// </devdoc>
        protected internal abstract bool Commit(CurrencyManager dataSource, int rowNum);

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.Edit"]/*' />
        /// <devdoc>
        ///    <para>When overridden in a deriving class, prepares a cell for editing.</para>
        /// </devdoc>
        protected internal virtual void Edit(CurrencyManager source,
                                             int rowNum,
                                             Rectangle bounds,
                                             bool readOnly) {
            Edit(source, rowNum, bounds, readOnly, null, true);
        }

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.Edit1"]/*' />
        /// <devdoc>
        ///    <para>Prepares the
        ///       cell for editing, passing the specified <see cref='System.Data.DataView'/>, row number, <see cref='System.Drawing.Rectangle'/>, argument
        ///       indicating whether the column is read-only, and the
        ///       text to display in the new control.</para>
        /// </devdoc>
        protected internal virtual void Edit(CurrencyManager source,
                                   int rowNum,
                                   Rectangle bounds,
                                   bool readOnly,
                                   string instantText) {
            Edit(source, rowNum, bounds, readOnly, instantText, true);
        }

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.Edit2"]/*' />
        /// <devdoc>
        ///    <para>When overridden in a deriving class, prepares a cell for editing.</para>
        /// </devdoc>
        protected internal abstract void Edit(CurrencyManager source,
                                    int rowNum,
                                    Rectangle bounds,
                                    bool readOnly,
                                    string instantText,
                                    bool cellIsVisible);

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.MouseDown"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Indicates whether the a mouse down event occurred at the specified row, at
        ///       the specified x and y coordinates.</para>
        /// </devdoc>
        internal virtual bool MouseDown(int rowNum, int x, int y) {
            return false;
        }

        // this function mainly serves Alt0 functionality
        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.EnterNullValue"]/*' />
        /// <devdoc>
        /// <para>When overriden in a derived class, enters a <see cref='T:System.DBNull.Value' qualify='true'/>
        /// into the column.</para>
        /// </devdoc>
        protected internal virtual void EnterNullValue() {
        }

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.KeyPress"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Provides a handler for determining which key was pressed,
        ///       and whether to process it.
        ///    </para>
        /// </devdoc>
        internal virtual bool KeyPress(int rowNum, Keys keyData) {
            // if this is read only then do not do anything
            if (this.ReadOnly || (this.DataGridTableStyle != null && this.DataGridTableStyle.DataGrid != null && this.DataGridTableStyle.DataGrid.ReadOnly))
                return false;
            if (keyData == (Keys.Control | Keys.NumPad0) || keyData == (Keys.Control| Keys.D0)) {
                EnterNullValue();
                return true;
            }
            return false;
        }

        // will cause the edit control to become invisible when 
        // the user navigates to a focused relation child
        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.ConcedeFocus"]/*' />
        /// <devdoc>
        ///    <para>When overridden in a derived class, directs the column to concede focus with an appropriate action.</para>
        /// </devdoc>
        protected internal virtual void ConcedeFocus() {
        }

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.Paint"]/*' />
        /// <devdoc>
        /// <para>Paints the a <see cref='System.Windows.Forms.DataGridColumnStyle'/> with the specified <see cref='System.Drawing.Graphics'/>,
        /// <see cref='System.Drawing.Rectangle'/>, System.Windows.Forms.CurrencyManager, and row number.</para>
        /// </devdoc>
        protected internal abstract void Paint(Graphics g, Rectangle bounds, CurrencyManager source, int rowNum);

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.Paint1"]/*' />
        /// <devdoc>
        ///    <para>When overridden in a derived class,
        ///       paints a <see cref='System.Windows.Forms.DataGridColumnStyle'/> with the specified <see cref='System.Drawing.Graphics'/>, <see cref='System.Drawing.Rectangle'/>, see Rectangle, row number, and
        ///       alignment.</para>
        /// </devdoc>
        protected internal abstract void Paint(Graphics g, Rectangle bounds, CurrencyManager source, int rowNum, bool alignToRight);

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.Paint2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Paints a <see cref='System.Windows.Forms.DataGridColumnStyle'/> with the specified <see cref='System.Drawing.Graphics'/>, <see cref='System.Drawing.Rectangle'/>, see System.Data.DataView, row number, background color, foreground color, and alignment.
        ///    </para>
        /// </devdoc>
        protected internal virtual void Paint(Graphics g, Rectangle bounds, CurrencyManager source, int rowNum,
                                    Brush backBrush, Brush foreBrush, bool alignToRight) {
            Paint(g, bounds, source, rowNum, alignToRight);
        }

        private void OnPropertyDescriptorChanged(EventArgs e) {
            EventHandler eh = Events[EventPropertyDescriptor] as EventHandler;
            if (eh != null)
                eh(this, e);
        }
        private void OnAlignmentChanged(EventArgs e) {
            EventHandler eh = Events[EventAlignment] as EventHandler;
            if (eh != null)
                eh(this, e);
        }
        private void OnFontChanged(EventArgs e) {
            EventHandler eh = Events[EventFont] as EventHandler;
            if (eh != null)
                eh(this, e);
        }
        private void OnHeaderTextChanged(EventArgs e) {
            EventHandler eh = Events[EventHeaderText] as EventHandler;
            if (eh != null)
                eh(this, e);
        }
        private void OnMappingNameChanged(EventArgs e) {
            EventHandler eh = Events[EventMappingName] as EventHandler;
            if (eh != null)
                eh(this, e);
        }
        private void OnReadOnlyChanged(EventArgs e) {
            EventHandler eh = Events[EventReadOnly] as EventHandler;
            if (eh != null)
                eh(this, e);
        }
        private void OnNullTextChanged(EventArgs e) {
            EventHandler eh = Events[EventNullText] as EventHandler;
            if (eh != null)
                eh(this, e);
        }
        private void OnWidthChanged(EventArgs e) {
            EventHandler eh = Events[EventWidth] as EventHandler;
            if (eh != null)
                eh(this, e);
        }

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.SetColumnValueAtRow"]/*' />
        /// <devdoc>
        ///    <para>Sets
        ///       the value in a specified row
        ///       with the value from a specified see DataView.</para>
        /// </devdoc>
        protected internal virtual void SetColumnValueAtRow(CurrencyManager source, int rowNum, object value) {
            CheckValidDataSource(source);

            if (source.Position != rowNum)
                throw new ArgumentException(SR.GetString(SR.DataGridColumnListManagerPosition), "rowNum");
            if (source[rowNum] is IEditableObject)
                ((IEditableObject)source[rowNum]).BeginEdit();
            this.PropertyDescriptor.SetValue(source[rowNum], value);
        }

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.ColumnStartedEditing"]/*' />
        internal protected virtual void ColumnStartedEditing(Control editingControl) {
            this.DataGridTableStyle.DataGrid.ColumnStartedEditing(editingControl);
        }

        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.IDataGridColumnStyleEditingNotificationService.ColumnStartedEditing"]/*' />
        /// <internalonly/>
        void IDataGridColumnStyleEditingNotificationService.ColumnStartedEditing(Control editingControl) {
            this.ColumnStartedEditing(editingControl);
        }


        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.ReleaseHostedControl"]/*' />
        protected internal virtual void ReleaseHostedControl() {
        }
        
        // TODO: VSDataGrid relies on this switch. Ideally it should not be exposed.
        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.CompModSwitches"]/*' />
        /// <internalonly/>
        protected class CompModSwitches {
            private static TraceSwitch dgEditColumnEditing;                                                                
            
            /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.CompModSwitches.DGEditColumnEditing"]/*' />
            public static TraceSwitch DGEditColumnEditing {
                get {
                    if (dgEditColumnEditing == null) {
                        dgEditColumnEditing = new TraceSwitch("DGEditColumnEditing", "Editing related tracing");
                    }
                    return dgEditColumnEditing;
                }
            }
        }

        
        /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.DataGridColumnHeaderAccessibleObject"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>        
        [System.Runtime.InteropServices.ComVisible(true)]                                                    
        protected class DataGridColumnHeaderAccessibleObject : AccessibleObject {
            DataGridColumnStyle owner = null;

            /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.DataGridColumnHeaderAccessibleObject.DataGridColumnHeaderAccessibleObject"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public DataGridColumnHeaderAccessibleObject(DataGridColumnStyle owner) : base() {
                Debug.Assert(owner != null, "DataGridColumnHeaderAccessibleObject must have a valid owner DataGridColumn");
                this.owner = owner;

            }

            /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.DataGridColumnHeaderAccessibleObject.Bounds"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override Rectangle Bounds {
                get {
                    // we need to get the width and the X coordinate of this column on the screen
                    // we can't just cache this, cause the column may be moved in the collection
                    if (this.owner.PropertyDescriptor == null)
                        return Rectangle.Empty;

                    DataGrid dg = this.DataGrid;
                    if (dg.DataGridRowsLength == 0)
                        return Rectangle.Empty;

                    // we need to find this column's offset in the gridColumnCollection...
                    GridColumnStylesCollection cols = this.owner.dataGridTableStyle.GridColumnStyles;
                    int offset = -1;
                    for (int i = 0; i < cols.Count; i++)
                        if (cols[i] == this.owner) {
                            offset = i;
                            break;
                        }
                    Debug.Assert(offset >= 0, "this column must be in a collection, otherwise its bounds are useless");
                    Rectangle rect = dg.GetCellBounds(0, offset);
                    // now add the Y coordinate of the datagrid.Layout.Data. it should be the same as 
                    // dataGrid.Layout.ColumnHeaders
                    rect.Y = dg.GetColumnHeadersRect().Y;
                    return dg.RectangleToScreen(rect);
                }
            }

            /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.DataGridColumnHeaderAccessibleObject.Name"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override string Name {
                get {
                    return Owner.headerName;
                }
            }

            /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.DataGridColumnHeaderAccessibleObject.Owner"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            protected DataGridColumnStyle Owner {
                get {
                    return owner;
                }
            }

            /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.DataGridColumnHeaderAccessibleObject.Parent"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override AccessibleObject Parent {
                get {
                    return DataGrid.AccessibilityObject;
                }
            }

            private DataGrid DataGrid {
                get {
                    return owner.dataGridTableStyle.dataGrid;
                }
            }

            /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.DataGridColumnHeaderAccessibleObject.Role"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override AccessibleRole Role {
                get {
                    return AccessibleRole.ColumnHeader;
                }
            }

            /// <include file='doc\DataGridColumn.uex' path='docs/doc[@for="DataGridColumnStyle.DataGridColumnHeaderAccessibleObject.Navigate"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override AccessibleObject Navigate(AccessibleNavigation navdir) {
                switch (navdir) {
                    case AccessibleNavigation.Right:
                    case AccessibleNavigation.Next:
                    case AccessibleNavigation.Down:
                        return Parent.GetChild(1 + Owner.dataGridTableStyle.GridColumnStyles.IndexOf(Owner) + 1);
                    case AccessibleNavigation.Up:
                    case AccessibleNavigation.Left:
                    case AccessibleNavigation.Previous:
                        return Parent.GetChild(1 + Owner.dataGridTableStyle.GridColumnStyles.IndexOf(Owner) - 1);

                }

                return null;

            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\datagridcaption.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGridCaption.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    
    using System.Windows.Forms;
    using System.ComponentModel;
    using System.Drawing;
    using System.Drawing.Imaging;
    
    using Microsoft.Win32;

    /// <devdoc>
    ///    <para>
    ///       Represents a caption in the DataGrid control.
    ///    </para>
    /// </devdoc>
    internal class DataGridCaption {
    
        internal EventHandlerList events;

        private const int xOffset = 3;
        private const int yOffset = 1;
        private const int textPadding = 2;
        private const int buttonToText = 4;
        private static ColorMap[] colorMap = new ColorMap[] {new ColorMap()};


        private static readonly Point minimumBounds = new Point(50, 30);

        private DataGrid dataGrid = null;
        private bool backButtonVisible = false;
        private bool downButtonVisible = false;

        private SolidBrush backBrush             = DefaultBackBrush;
        private SolidBrush foreBrush         = DefaultForeBrush;
        private Pen        textBorderPen     = DefaultTextBorderPen;

        private string text = "";
        private bool   textBorderVisible = false;
        private Font   textFont = null;

        // use the datagridFont when the textFont is not set
        // we cache this font ( cause we have to make it bold every time we paint the caption )
        //
        private Font   dataGridFont = null;

        private bool backActive = false;
        private bool downActive = false;
        private bool backPressed = false;
        private bool downPressed = false;

        // if the downButton should point down or not
        private bool downButtonDown = false;

        private static Bitmap leftButtonBitmap;
        private static Bitmap leftButtonBitmap_bidi;
        private static Bitmap magnifyingGlassBitmap;

        private Rectangle backButtonRect = new Rectangle();
        private Rectangle downButtonRect = new Rectangle();
        private Rectangle textRect       = new Rectangle();

        private CaptionLocation lastMouseLocation = CaptionLocation.Nowhere;

        private EventEntry eventList;
        private static readonly object EVENT_BACKWARDCLICKED = new object();
        private static readonly object EVENT_DOWNCLICKED = new object();
        private static readonly object EVENT_CAPTIONCLICKED = new object();

        internal DataGridCaption(DataGrid dataGrid) {
            this.dataGrid = dataGrid;
            this.downButtonVisible = dataGrid.ParentRowsVisible;
            colorMap[0].OldColor = Color.White;
            colorMap[0].NewColor = this.ForeColor;
            OnGridFontChanged();
        }

        internal void OnGridFontChanged() {
            if (dataGridFont == null || !dataGridFont.Equals(dataGrid.Font)) {
                try {
                    this.dataGridFont = new Font(dataGrid.Font, FontStyle.Bold);
                } catch (Exception){}
            }
        }

        // =------------------------------------------------------------------
        // =        Properties
        // =------------------------------------------------------------------

        internal bool BackButtonActive {
            get {
                return backActive;
            }
            set {
                if (backActive != value) {
                    backActive = value;
                    InvalidateCaptionRect(backButtonRect);
                }
            }
        }

        internal bool DownButtonActive {
            get {
                return downActive;
            }
            set {
                if (downActive != value) {
                    downActive = value;
                    InvalidateCaptionRect(downButtonRect);
                }
            }
        }

        internal static SolidBrush DefaultBackBrush {
            get {
                return (SolidBrush)SystemBrushes.ActiveCaption;
            }
        }
        internal static Pen DefaultTextBorderPen {
            get {
                return new Pen(SystemColors.ActiveCaptionText);
            }
        }
        internal static SolidBrush DefaultForeBrush {
            get {
                return (SolidBrush)SystemBrushes.ActiveCaptionText;
            }
        }
        internal Color BackColor {
            get {
                return backBrush.Color;
            }
            set {
                if (!backBrush.Color.Equals(value)) {
                    if (value.IsEmpty)
                        throw new ArgumentException(SR.GetString(SR.DataGridEmptyColor, "Caption BackColor"));
                    backBrush = new SolidBrush(value);
                    Invalidate();
                }
            }
        }
        
        internal EventHandlerList Events {
            get {
                if (events == null) {
                    events = new EventHandlerList();
                }
                return events;
            }
        }


        internal Font Font {
            get {
                // use the dataGridFont only if the user 
                // did not set the CaptionFont
                //
                if (textFont == null)
                    return this.dataGridFont;
                else
                    return textFont;
            }
            set {
                if (textFont == null || !textFont.Equals(value)) {
                    textFont = value;
                    // this property gets called in the constructor before dataGrid has a caption
                    // and we don't need this special-handling then...
                    if (dataGrid.Caption != null) {
                        dataGrid.RecalculateFonts();
                        dataGrid.PerformLayout();
                        dataGrid.Invalidate(); // smaller invalidate rect?
                    }
                }
            }
        }

        internal bool ShouldSerializeFont() {
            return textFont != null && !textFont.Equals(this.dataGridFont);
        }

        internal bool ShouldSerializeBackColor() {
            return !backBrush.Equals(DefaultBackBrush);
        }
        
        internal void ResetBackColor() {
            if (ShouldSerializeBackColor()) {
                backBrush = DefaultBackBrush;
                Invalidate();
            }
        }

        internal void ResetForeColor() {
            if (ShouldSerializeForeColor()) {
                foreBrush = DefaultForeBrush;
                Invalidate();
            }
        }

        internal bool ShouldSerializeForeColor() {
            return !foreBrush.Equals(DefaultForeBrush);
        }

        internal void ResetFont() {
            textFont = null;
            Invalidate();
        }

        internal string Text {
            get {
                return text;
            }
            set {
                if (value == null)
                    text = "";
                else
                    text = value;
                Invalidate();
            }
        }

        internal bool TextBorderVisible {
            get {
                return textBorderVisible;
            }
            set {
                textBorderVisible = value;
                Invalidate();
            }
        }

        internal Color ForeColor {
            get {
                return foreBrush.Color;
            }
            set {
                if (value.IsEmpty)
                    throw new ArgumentException(SR.GetString(SR.DataGridEmptyColor, "Caption ForeColor"));
                foreBrush = new SolidBrush(value);
                colorMap[0].NewColor = this.ForeColor;
                Invalidate();
            }
        }

        internal Point MinimumBounds {
            get {
                return minimumBounds;
            }
        }

        internal bool BackButtonVisible {
            get {
                return backButtonVisible;
            }
            set {
                if (backButtonVisible != value) {
                    backButtonVisible = value;
                    Invalidate();
                }
            }
        }

        internal bool DownButtonVisible {
            get {
                return downButtonVisible;
            }
            set {
                if (downButtonVisible != value) {
                    downButtonVisible = value;
                    Invalidate();
                }
            }
        }

        // =------------------------------------------------------------------
        // =        Methods
        // =------------------------------------------------------------------

        protected virtual void AddEventHandler(object key, Delegate handler) {
            lock(this) {
                if (handler == null) return;
                for (EventEntry e = eventList; e != null; e = e.next) {
                    if (e.key == key) {
                        e.handler = Delegate.Combine(e.handler, handler);
                        return;
                    }
                }
                eventList = new EventEntry(eventList, key, handler);
            }
        }

        /// <devdoc>
        ///     Adds a listener for the BackwardClicked event.
        /// </devdoc>
        internal event EventHandler BackwardClicked {
            add {
                Events.AddHandler(EVENT_BACKWARDCLICKED, value);
            }
            remove {
                Events.RemoveHandler(EVENT_BACKWARDCLICKED, value);
            }
        }


        /// <devdoc>
        ///     Adds a listener for the CaptionClicked event.
        /// </devdoc>
        internal event EventHandler CaptionClicked {
            add {
                Events.AddHandler(EVENT_CAPTIONCLICKED, value);
            }
            remove {
                Events.RemoveHandler(EVENT_CAPTIONCLICKED, value);
            }
        }

        internal event EventHandler DownClicked {
            add {
                Events.AddHandler(EVENT_DOWNCLICKED, value);
            }
            remove {
                Events.RemoveHandler(EVENT_DOWNCLICKED, value);
            }
        }

        private void Invalidate() {
            if (dataGrid != null)
                dataGrid.InvalidateCaption();
        }

        private void InvalidateCaptionRect(Rectangle r) {
            if (dataGrid != null)
                dataGrid.InvalidateCaptionRect(r);
        }

        private void InvalidateLocation(CaptionLocation loc) {
            Rectangle r;
            switch (loc) {
                case CaptionLocation.BackButton:
                    r = backButtonRect;
                    r.Inflate(1,1);
                    InvalidateCaptionRect(r);
                    break;
                case CaptionLocation.DownButton:
                    r = downButtonRect;
                    r.Inflate(1,1);
                    InvalidateCaptionRect(r);
                    break;
            }
        }

        protected void OnBackwardClicked(EventArgs e) {
            if (backActive) {
                EventHandler handler = (EventHandler)Events[EVENT_BACKWARDCLICKED];
                if (handler != null) handler(this,e);
            }
        }

        protected void OnCaptionClicked(EventArgs e) {
            EventHandler handler = (EventHandler)Events[EVENT_CAPTIONCLICKED];
            if (handler != null) handler(this,e);
        }

        protected void OnDownClicked(EventArgs e) {
            if (downActive && downButtonVisible) {        
                EventHandler handler = (EventHandler)Events[EVENT_DOWNCLICKED];
                if (handler != null) handler(this,e);
            }
        }

        private Bitmap GetBitmap(string bitmapName) {
            Bitmap b = null;
            try {
                b = new Bitmap(typeof(DataGridCaption), bitmapName);
                b.MakeTransparent();
            }
            catch (Exception e) {
                Debug.Fail("Failed to load bitmap: " + bitmapName, e.ToString());
            }
            return b;
        }

        private Bitmap GetBackButtonBmp(bool alignRight) {
            if (alignRight) {
                if (leftButtonBitmap_bidi == null)
                    leftButtonBitmap_bidi = GetBitmap("DataGridCaption.backarrow_bidi.bmp");
                return leftButtonBitmap_bidi;
            } else {
                if (leftButtonBitmap == null)
                    leftButtonBitmap = GetBitmap("DataGridCaption.backarrow.bmp");
                return leftButtonBitmap;
            }
        }

        private Bitmap GetDetailsBmp() {
            if (magnifyingGlassBitmap == null)
                magnifyingGlassBitmap = GetBitmap("DataGridCaption.Details.bmp");
            return magnifyingGlassBitmap;
        }

        protected virtual Delegate GetEventHandler(object key) {
            lock(this) {
                for (EventEntry e = eventList; e != null; e = e.next) {
                    if (e.key == key) return e.handler;
                }
                return null;
            }
        }

        internal Rectangle GetBackButtonRect(Rectangle bounds, bool alignRight, int downButtonWidth) {
            Bitmap backButtonBmp = GetBackButtonBmp(false);
            Size backButtonSize;
            lock (backButtonBmp) {
                backButtonSize = backButtonBmp.Size;
            }
            return new Rectangle( bounds.Right - xOffset * 4 - downButtonWidth - backButtonSize.Width,
                                  bounds.Y + yOffset + textPadding,
                                  backButtonSize.Width,
                                  backButtonSize.Height);
        }

        internal int GetDetailsButtonWidth() {
            int width = 0;
            Bitmap detailsBmp = GetDetailsBmp();
            lock (detailsBmp) {
                width = detailsBmp.Size.Width;
            }
            return width;
        }

        internal Rectangle GetDetailsButtonRect(Rectangle bounds, bool alignRight) {
            Size downButtonSize;
            Bitmap detailsBmp = GetDetailsBmp();
            lock (detailsBmp) {
                downButtonSize = detailsBmp.Size;
            }
            int downButtonWidth = downButtonSize.Width;
            return new Rectangle( bounds.Right - xOffset * 2 - downButtonWidth,
                                  bounds.Y + yOffset + textPadding,
                                  downButtonWidth,
                                  downButtonSize.Height);
        }

        /// <devdoc>
        ///      Called by the dataGrid when it needs the caption
        ///      to repaint.
        /// </devdoc>
        internal void Paint(Graphics g, Rectangle bounds, bool alignRight) {
            Size textSize = new Size((int) g.MeasureString(text, this.Font).Width + 2, this.Font.Height + 2);

            downButtonRect = GetDetailsButtonRect(bounds, alignRight);
            int downButtonWidth = GetDetailsButtonWidth();
            backButtonRect = GetBackButtonRect(bounds, alignRight, downButtonWidth);

            int backButtonArea = backButtonVisible ? backButtonRect.Width + xOffset + buttonToText : 0;
            int downButtonArea = downButtonVisible && !dataGrid.ParentRowsIsEmpty() ? downButtonWidth + xOffset + buttonToText : 0;

            int textWidthLeft = bounds.Width - xOffset - backButtonArea - downButtonArea;


            textRect = new Rectangle(
                                    bounds.X,
                                    bounds.Y + yOffset,
                                    Math.Min(textWidthLeft, 2 * textPadding + textSize.Width),
                                    2 * textPadding + textSize.Height);

            // align the caption text box, downButton, and backButton
            // if the RigthToLeft property is set to true
            if (alignRight) {
                textRect.X = bounds.Right - textRect.Width;
                backButtonRect.X = bounds.X + xOffset * 4 + downButtonWidth;
                downButtonRect.X = bounds.X + xOffset * 2;
            }

            Debug.WriteLineIf(CompModSwitches.DGCaptionPaint.TraceVerbose, "text size = " + textSize.ToString());
            Debug.WriteLineIf(CompModSwitches.DGCaptionPaint.TraceVerbose, "downButtonWidth = " + downButtonWidth.ToString());
            Debug.WriteLineIf(CompModSwitches.DGCaptionPaint.TraceVerbose, "textWidthLeft = " + textWidthLeft.ToString());
            Debug.WriteLineIf(CompModSwitches.DGCaptionPaint.TraceVerbose, "backButtonRect " + backButtonRect.ToString());
            Debug.WriteLineIf(CompModSwitches.DGCaptionPaint.TraceVerbose, "textRect " + textRect.ToString());
            Debug.WriteLineIf(CompModSwitches.DGCaptionPaint.TraceVerbose, "downButtonRect " + downButtonRect.ToString());

            // we should use the code that is commented out
            // with today's code, there are pixels on the backButtonRect and the downButtonRect
            // that are getting painted twice
            //
            g.FillRectangle(backBrush, bounds);

            if (backButtonVisible) {
                PaintBackButton(g, backButtonRect, alignRight);
                if (backActive) {
                    if (lastMouseLocation == CaptionLocation.BackButton) {
                        backButtonRect.Inflate(1,1);
                        ControlPaint.DrawBorder3D(g, backButtonRect,
                                                  backPressed ? Border3DStyle.SunkenInner : Border3DStyle.RaisedInner);
                    }
                }
            }
            PaintText(g, textRect, alignRight);

            if (downButtonVisible && !dataGrid.ParentRowsIsEmpty()) {
                PaintDownButton(g, downButtonRect);
                // the rules have changed, yet again.
                // now: if we show the parent rows and the mouse is 
                // not on top of this icon, then let the icon be depressed.
                // if the mouse is pressed over the icon, then show the icon pressed
                // if the mouse is over the icon and not pressed, then show the icon SunkenInner;
                //
                if (lastMouseLocation == CaptionLocation.DownButton)
                {
                    downButtonRect.Inflate(1,1);
                    ControlPaint.DrawBorder3D(g, downButtonRect,
                                              downPressed ? Border3DStyle.SunkenInner : Border3DStyle.RaisedInner);
                }
            }
        }

        private void PaintIcon(Graphics g, Rectangle bounds, Bitmap b) {
            ImageAttributes attr = new ImageAttributes();
            attr.SetRemapTable(colorMap, ColorAdjustType.Bitmap);
            g.DrawImage(b, bounds, 0, 0, bounds.Width, bounds.Height,GraphicsUnit.Pixel, attr);
            attr.Dispose();
        }

        private void PaintBackButton(Graphics g, Rectangle bounds, bool alignRight) {
            Bitmap backButtonBmp = GetBackButtonBmp(alignRight);
            lock (backButtonBmp) {
                PaintIcon(g, bounds, backButtonBmp);
            }
        }

        private void PaintDownButton(Graphics g, Rectangle bounds) {
            Bitmap detailsBmp = GetDetailsBmp();
            lock (detailsBmp) {
                PaintIcon(g, bounds, detailsBmp);
            }
        }

        private void PaintText(Graphics g, Rectangle bounds, bool alignToRight) {
            Rectangle textBounds = bounds;

            if (textBounds.Width <= 0 || textBounds.Height <= 0)
                return;

            if (textBorderVisible) {
                g.DrawRectangle(this.textBorderPen, textBounds.X, textBounds.Y, textBounds.Width - 1, textBounds.Height - 1);
                textBounds.Inflate(-1,-1);
            }

            if (textPadding > 0) {
                Rectangle border = textBounds;
                border.Height = textPadding;
                g.FillRectangle(this.backBrush, border);

                border.Y = textBounds.Bottom - textPadding;
                g.FillRectangle(this.backBrush, border);

                border = new Rectangle(textBounds.X, textBounds.Y + textPadding,
                                       textPadding, textBounds.Height - 2*textPadding);
                g.FillRectangle(this.backBrush, border);

                border.X = textBounds.Right - textPadding;
                g.FillRectangle(this.backBrush, border);
                textBounds.Inflate(-textPadding, -textPadding);
            }

            g.FillRectangle(this.backBrush, textBounds);

            // Brush foreBrush = new SolidBrush(dataGrid.CaptionForeColor);
            StringFormat format = new StringFormat();
            if (alignToRight) {
                format.FormatFlags |= StringFormatFlags.DirectionRightToLeft;
                format.Alignment = StringAlignment.Far;
            }
            g.DrawString(text, this.Font, foreBrush, textBounds, format);
            format.Dispose();
            // foreBrush.Dispose();
        }

        private CaptionLocation FindLocation(int x, int y) {
            if (!backButtonRect.IsEmpty) {
                if (backButtonRect.Contains(x,y))
                    return CaptionLocation.BackButton;
            }
            if (!downButtonRect.IsEmpty) {
                if (downButtonRect.Contains(x,y))
                    return CaptionLocation.DownButton;
            }
            if (!textRect.IsEmpty) {
                if (textRect.Contains(x,y))
                    return CaptionLocation.Text;
            }
            return CaptionLocation.Nowhere;
        }

        private bool DownButtonDown {
            get {
                return downButtonDown;
            }
            set {
                if (downButtonDown != value)
                {
                    downButtonDown = value;
                    InvalidateLocation(CaptionLocation.DownButton);
                }
            }
        }

        internal bool GetDownButtonDirection() {
            return DownButtonDown;
        }

        /// <devdoc>
        ///      Called by the dataGrid when the mouse is pressed
        ///      inside the caption.
        /// </devdoc>
        internal void MouseDown(int x, int y) {
            CaptionLocation loc = FindLocation(x, y);
            switch (loc) {
                case CaptionLocation.BackButton:
                    backPressed = true;
                    InvalidateLocation(loc);
                    break;
                case CaptionLocation.DownButton:
                    downPressed = true;
                    InvalidateLocation(loc);
                    break;
                case CaptionLocation.Text:
                    OnCaptionClicked(EventArgs.Empty);
                    break;
            }
        }

        /// <devdoc>
        ///      Called by the dataGrid when the mouse is released
        ///      inside the caption.
        /// </devdoc>
        internal void MouseUp(int x, int y) {
            CaptionLocation loc = FindLocation(x, y);
            switch (loc) {
                case CaptionLocation.DownButton:
                    if (downPressed == true) {
                        downPressed = false;
                        OnDownClicked(EventArgs.Empty);
                    }
                    break;
                case CaptionLocation.BackButton:
                    if (backPressed == true) {
                        backPressed = false;
                        OnBackwardClicked(EventArgs.Empty);
                    }
                    break;
            }
        }

        /// <devdoc>
        ///      Called by the dataGrid when the mouse leaves
        ///      the caption area.
        /// </devdoc>
        internal void MouseLeft() {
            CaptionLocation oldLoc = lastMouseLocation;
            lastMouseLocation = CaptionLocation.Nowhere;
            InvalidateLocation(oldLoc);
        }

        /// <devdoc>
        ///      Called by the dataGrid when the mouse is
        ///      inside the caption.
        /// </devdoc>
        internal void MouseOver(int x, int y) {
            CaptionLocation newLoc = FindLocation(x, y);

            InvalidateLocation(lastMouseLocation);
            InvalidateLocation(newLoc);
            lastMouseLocation = newLoc;
        }

        protected virtual void RaiseEvent(object key, EventArgs e) {
            Delegate handler = GetEventHandler(key);
            if (handler != null)((EventHandler)handler)(this, e);
        }

        protected virtual void RemoveEventHandler(object key, Delegate handler) {
            lock(this) {
                if (handler == null) return;
                for (EventEntry e = eventList, prev = null; e != null; prev = e, e = e.next) {
                    if (e.key == key) {
                        e.handler = Delegate.Remove(e.handler, handler);
                        if (e.handler == null) {
                            if (prev == null) {
                                eventList = e.next;
                            }
                            else {
                                prev.next = e.next;
                            }
                        }
                        return;
                    }
                }
            }
        }

        protected virtual void RemoveEventHandlers() {
            eventList = null;
        }

        internal void SetDownButtonDirection(bool pointDown)
        {
            DownButtonDown = pointDown;
        }

        /// <devdoc>
        ///      Toggles the direction the "Down Button" is pointing.
        /// </devdoc>
        internal bool ToggleDownButtonDirection() {
            DownButtonDown = !DownButtonDown;
            return DownButtonDown;
        }
        internal enum CaptionLocation {
            Nowhere,
            BackButton,
            DownButton,
            Text
        }

        private sealed class EventEntry {
            internal EventEntry next;
            internal object key;
            internal Delegate handler;

            internal EventEntry(EventEntry next, object key, Delegate handler) {
                this.next = next;
                this.key = key;
                this.handler = handler;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\datagriddefaultcolumnwidthtypeconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGridDefaultColumnWidthTypeConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System;
    using System.IO;
    using System.ComponentModel;
    using Microsoft.Win32;
    using System.Globalization;

    /// <include file='doc\DataGridDefaultColumnWidthTypeConverter.uex' path='docs/doc[@for="DataGridPreferredColumnWidthTypeConverter"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class DataGridPreferredColumnWidthTypeConverter : TypeConverter {
        /// <include file='doc\DataGridDefaultColumnWidthTypeConverter.uex' path='docs/doc[@for="DataGridPreferredColumnWidthTypeConverter.CanConvertFrom"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
        {
            if (sourceType == typeof(string) || sourceType == typeof(int))
                return true;
            else
                return false;
        }

        /// <include file='doc\DataGridDefaultColumnWidthTypeConverter.uex' path='docs/doc[@for="DataGridPreferredColumnWidthTypeConverter.ConvertTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
        {
            if (destinationType == typeof(string))
            {
                if (value.GetType() == typeof(int))
                {
                    int pulica = (int) value;
                    if (pulica == - 1)
                        return "AutoColumnResize (-1)";
                    else
                        return pulica.ToString();
                }
                else
                {
                    return base.ConvertTo(context, culture, value, destinationType);
                }
            }
            else
                return base.ConvertTo(context, culture, value, destinationType);
        }

        /// <include file='doc\DataGridDefaultColumnWidthTypeConverter.uex' path='docs/doc[@for="DataGridPreferredColumnWidthTypeConverter.ConvertFrom"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
        {
            if (value.GetType() == typeof(string))
            {
                string text = value.ToString();
                if (text.Equals("AutoColumnResize (-1)"))
                    return -1;
                else
                    return Int32.Parse(text);
            }
            else if (value.GetType() == typeof(int))
            {
                return (int)value;
            }
            else
            {
                throw GetConvertFromException(value);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\datagridlinestyle.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGridLineStyle.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;
    /// <include file='doc\DataGridLineStyle.uex' path='docs/doc[@for="DataGridLineStyle"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the style of gridlines in a <see cref='System.Windows.Forms.DataGrid'/>.
    ///    </para>
    /// </devdoc>
    public enum DataGridLineStyle {
        /// <include file='doc\DataGridLineStyle.uex' path='docs/doc[@for="DataGridLineStyle.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       No gridlines between cells.
        ///    </para>
        /// </devdoc>
        None,
        /// <include file='doc\DataGridLineStyle.uex' path='docs/doc[@for="DataGridLineStyle.Solid"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Solid gridlines between cells.
        ///    </para>
        /// </devdoc>
        Solid
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\datagridcell.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGridCell.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;
    using System;
    
    /// <include file='doc\DataGridCell.uex' path='docs/doc[@for="DataGridCell"]/*' />
    /// <devdoc>
    ///    <para>Identifies a cell in the grid.</para>
    /// </devdoc>
    public struct DataGridCell {
        private int rowNumber;
        private int columnNumber;

        /// <include file='doc\DataGridCell.uex' path='docs/doc[@for="DataGridCell.ColumnNumber"]/*' />
        /// <devdoc>
        /// <para>Gets or sets the number of a column in the <see cref='System.Windows.Forms.DataGrid'/> control.</para>
        /// </devdoc>
        public int ColumnNumber {
            get {
                return columnNumber;
            }
            set {
                columnNumber = value;
            }
        }
        
        /// <include file='doc\DataGridCell.uex' path='docs/doc[@for="DataGridCell.RowNumber"]/*' />
        /// <devdoc>
        /// <para>Gets or sets the number of a row in the <see cref='System.Windows.Forms.DataGrid'/> control.</para>
        /// </devdoc>
        public int RowNumber {
            get {
                return rowNumber;
            }
            set {
                rowNumber = value;
            }
        }                
        
        /// <include file='doc\DataGridCell.uex' path='docs/doc[@for="DataGridCell.DataGridCell"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.DataGridCell'/> class.
        ///    </para>
        /// </devdoc>
        public DataGridCell(int r, int c) {
            this.rowNumber = r;
            this.columnNumber = c;
        }
        
        /// <include file='doc\DataGridCell.uex' path='docs/doc[@for="DataGridCell.Equals"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the <see cref='System.Windows.Forms.DataGridCell'/> is identical to a second
        ///    <see cref='System.Windows.Forms.DataGridCell'/>.
        ///    </para>
        /// </devdoc>
        public override bool Equals(object o) {
            if (o is DataGridCell) {
                DataGridCell rhs = (DataGridCell)o;
                return (rhs.RowNumber == RowNumber && rhs.ColumnNumber == ColumnNumber);
            }
            else
                return false;
        }
        
        /// <include file='doc\DataGridCell.uex' path='docs/doc[@for="DataGridCell.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       a hash value that uniquely identifies the cell.
        ///    </para>
        /// </devdoc>
        public override int GetHashCode() {
            return ((~rowNumber * (columnNumber+1)) & 0x00ffff00) >> 8;
       }

        /// <include file='doc\DataGridCell.uex' path='docs/doc[@for="DataGridCell.ToString"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the row number and column number of the cell.
        ///    </para>
        /// </devdoc>
        public override string ToString() {
            return "DataGridCell {RowNumber = " + RowNumber.ToString() + 
                   ", ColumnNumber = " + ColumnNumber.ToString() + "}";
        }
        
    }
                                                                                        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\datagridparentrowslabel.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGridParentRowsLabel.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
        /// <include file='doc\DataGridParentRowsLabel.uex' path='docs/doc[@for="DataGridParentRowsLabelStyle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies how parent row labels of a DataGrid
        ///       control are displayed.
        ///    </para>
        /// </devdoc>
        public enum DataGridParentRowsLabelStyle {
            /// <include file='doc\DataGridParentRowsLabel.uex' path='docs/doc[@for="DataGridParentRowsLabelStyle.None"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Display no parent row labels.
            ///    </para>
            /// </devdoc>
            None              = 0,
            /// <include file='doc\DataGridParentRowsLabel.uex' path='docs/doc[@for="DataGridParentRowsLabelStyle.TableName"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Displaya the parent table name.
            ///    </para>
            /// </devdoc>
            TableName            = 1,
            /// <include file='doc\DataGridParentRowsLabel.uex' path='docs/doc[@for="DataGridParentRowsLabelStyle.ColumnName"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Displaya the parent column name.
            ///    </para>
            /// </devdoc>
            ColumnName           = 2,
            /// <include file='doc\DataGridParentRowsLabel.uex' path='docs/doc[@for="DataGridParentRowsLabelStyle.Both"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Displays
            ///       both the parent table and column names.
            ///    </para>
            /// </devdoc>
            Both  = 3,
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\datagridrow.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGridRow.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    using System.Runtime.Remoting;

    using System.Diagnostics;

    using System;
    using System.Runtime.InteropServices;
    
    using System.Windows.Forms;
    using System.ComponentModel;
    using System.Drawing;
    using System.Drawing.Imaging;
    using Microsoft.Win32;
    using System.Collections;

    /// <include file='doc\DataGridRow.uex' path='docs/doc[@for="DataGridRow"]/*' />
    /// <devdoc>
    ///    <para>Encapsulates the painting logic for a new row added to a 
    ///    <see cref='System.Windows.Forms.DataGrid'/> 
    ///    control.</para>
    /// </devdoc>
    internal abstract class DataGridRow : MarshalByRefObject {
        internal protected int       number;             // row number
        private bool      selected;
        private int       height;
        // protected DataRow   dataRow;
        private IntPtr       tooltipID = new IntPtr(-1);
        private string    tooltip = String.Empty;
        AccessibleObject  accessibleObject;

        // for accessibility...
        //
        // internal DataGrid  dataGrid;

        // will need this for the painting information ( row header color )
        // 
        protected DataGridTableStyle dgTable;

        // we will be mapping only the black color to 
        // the HeaderForeColor
        //
        private static ColorMap[] colorMap = new ColorMap[] {new ColorMap()};

        // bitmaps
        //
        private static Bitmap rightArrow = null;
        private static Bitmap leftArrow = null;
        private static Bitmap errorBmp = null;
        private static Bitmap pencilBmp = null;
        private static Bitmap starBmp = null;
        protected const int xOffset = 3;
        protected const int yOffset = 2;


        /// <include file='doc\DataGridRow.uex' path='docs/doc[@for="DataGridRow.DataGridRow"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of a <see cref='System.Windows.Forms.DataGridRow'/> . </para>
        /// </devdoc>
        public DataGridRow(DataGrid dataGrid, DataGridTableStyle dgTable, int rowNumber) {
            if (dataGrid == null || dgTable.DataGrid == null)
                throw new ArgumentNullException("dataGrid");
            if (rowNumber < 0)
                throw new ArgumentException(SR.GetString(SR.DataGridRowRowNumber), "rowNumber");
            // this.dataGrid = dataGrid;
            this.number = rowNumber;

            // map the black color in the pictures to the DataGrid's HeaderForeColor
            //
            colorMap[0].OldColor = Color.Black;
            colorMap[0].NewColor = dgTable.HeaderForeColor;

            this.dgTable = dgTable;
            height = MinimumRowHeight(dgTable);
        }

        public AccessibleObject AccessibleObject {
            get {
                if (accessibleObject == null) {
                    accessibleObject = CreateAccessibleObject();
                }
                return accessibleObject;
            }
        }

        protected virtual AccessibleObject CreateAccessibleObject() {
            return new DataGridRowAccessibleObject(this);
        }

        internal protected virtual int MinimumRowHeight(DataGridTableStyle dgTable) {
            return MinimumRowHeight(dgTable.GridColumnStyles);
        }

        internal protected virtual int MinimumRowHeight(GridColumnStylesCollection columns) {
            int h = dgTable.IsDefault ? this.DataGrid.PreferredRowHeight : dgTable.PreferredRowHeight;

            try {
                if (this.dgTable.DataGrid.DataSource != null) {
                    int nCols = columns.Count;
                    for (int i = 0; i < nCols; ++i) {
                        // if (columns[i].Visible && columns[i].PropertyDescriptor != null)
                        if (columns[i].PropertyDescriptor != null)
                            h = Math.Max(h, columns[i].GetMinimumHeight());
                    }
                }
            } catch (Exception) {
            }
            return h;
        }

        // =------------------------------------------------------------------
        // =        Properties
        // =------------------------------------------------------------------

        /// <include file='doc\DataGridRow.uex' path='docs/doc[@for="DataGridRow.DataGrid"]/*' />
        /// <devdoc>
        /// <para>Gets the <see cref='System.Windows.Forms.DataGrid'/> control the row belongs to.</para>
        /// </devdoc>
        public DataGrid DataGrid {
            get {
                return this.dgTable.DataGrid;
            }
        }

        internal DataGridTableStyle DataGridTableStyle {
            get {
                return this.dgTable;
            }
            set {
                dgTable = value;
            }
        }

        /*
        public DataGridTable DataGridTable {
            get {
                return dgTable;
            }
        }
        */

        /*
        public DataRow DataRow {
            get {
                return dataRow;
            }
        }
        */

        /// <include file='doc\DataGridRow.uex' path='docs/doc[@for="DataGridRow.Height"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the height of the row.</para>
        /// </devdoc>
        public virtual int Height {
            get {
                return height;
            }
            set {
                // the height of the row should be at least 0.
                // this way, if the row has a relationship list and the user resizes the row such that
                // the new height does not accomodate the height of the relationship list
                // the row will at least show the relationship list ( and not paint on the portion of the row above this one )
                height = Math.Max(0, value);
                // when we resize the row, or when we set the PreferredRowHeigth on the
                // DataGridTableStyle, we change the height of the Row, which will cause to invalidate,
                // then the grid itself will do another invalidate call.
                this.dgTable.DataGrid.OnRowHeightChanged(this);
            }
        }

        /// <include file='doc\DataGridRow.uex' path='docs/doc[@for="DataGridRow.RowNumber"]/*' />
        /// <devdoc>
        ///    <para>Gets the row's number.</para>
        /// </devdoc>
        public int RowNumber {
            get {
                return this.number;
            }
        }

        /// <include file='doc\DataGridRow.uex' path='docs/doc[@for="DataGridRow.Selected"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value indicating whether the row is selected.</para>
        /// </devdoc>
        public virtual bool Selected {
            get {
                return selected;
            }
            set {
                selected = value;
                InvalidateRow();
            }
        }

        // =------------------------------------------------------------------
        // =        Methods
        // =------------------------------------------------------------------

        /// <include file='doc\DataGridRow.uex' path='docs/doc[@for="DataGridRow.GetBitmap"]/*' />
        /// <devdoc>
        ///    <para>Gets the bitmap associated with the row.</para>
        /// </devdoc>
        protected Bitmap GetBitmap(string bitmapName) {
            Bitmap b = null;
            try {
                b = new Bitmap(typeof(DataGridCaption), bitmapName);
                b.MakeTransparent();
            }
            catch(Exception e) {
                Debug.Fail("Failed to load bitmap: " + bitmapName, e.ToString());
                throw e;
            }
            return b;
        }

        /// <include file='doc\DataGridRow.uex' path='docs/doc[@for="DataGridRow.GetCellBounds"]/*' />
        /// <devdoc>
        /// <para>When overridden in a derived class, gets the <see cref='System.Drawing.Rectangle'/> 
        /// where a cell's contents gets painted.</para>
        /// </devdoc>
        public virtual Rectangle GetCellBounds(int col) {
            int firstVisibleCol = this.dgTable.DataGrid.FirstVisibleColumn;
            int cx = 0;
            Rectangle cellBounds = new Rectangle();
            GridColumnStylesCollection columns = this.dgTable.GridColumnStyles;
            if (columns != null) {
                for (int i = firstVisibleCol; i < col; i++)
                    if (columns[i].PropertyDescriptor != null)
                        cx += columns[i].Width;

                int borderWidth = this.dgTable.GridLineWidth;
                cellBounds = new Rectangle(cx,
                                     0,
                                     columns[col].Width - borderWidth,
                                     Height - borderWidth);
            }
            return cellBounds;
        }

        /// <include file='doc\DataGridRow.uex' path='docs/doc[@for="DataGridRow.GetNonScrollableArea"]/*' />
        /// <devdoc>
        /// <para>When overridden in a derived class, gets the <see cref='System.Drawing.Rectangle'/> of the non-scrollable area of 
        ///    the row.</para>
        /// </devdoc>
        public virtual Rectangle GetNonScrollableArea() {
            return Rectangle.Empty;
        }

        /// <include file='doc\DataGridRow.uex' path='docs/doc[@for="DataGridRow.GetStarBitmap"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the bitmap displayed in the row header of a new row.</para>
        /// </devdoc>
        protected Bitmap GetStarBitmap() {
            if (starBmp == null)
                starBmp = GetBitmap("DataGridRow.star.bmp");
            return starBmp;
        }

        /// <include file='doc\DataGridRow.uex' path='docs/doc[@for="DataGridRow.GetPencilBitmap"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the bitmap displayed in the row header that indicates a row can 
        ///       be edited.</para>
        /// </devdoc>
        protected Bitmap GetPencilBitmap() {
            if (pencilBmp == null)
                pencilBmp = GetBitmap("DataGridRow.pencil.bmp");
            return pencilBmp;
        }

        /// <include file='doc\DataGridRow.uex' path='docs/doc[@for="DataGridRow.GetErrorBitmap"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the bitmap displayed on a row with an error.</para>
        /// </devdoc>
        protected Bitmap GetErrorBitmap() {
            if (errorBmp == null)
                errorBmp = GetBitmap("DataGridRow.error.bmp");
            errorBmp.MakeTransparent();
            return errorBmp;
        }

        protected Bitmap GetLeftArrowBitmap() {
            if (leftArrow == null)
                leftArrow = GetBitmap("DataGridRow.left.bmp");
            return leftArrow;
        }

        protected Bitmap GetRightArrowBitmap() {
            if (rightArrow == null)
                rightArrow = GetBitmap("DataGridRow.right.bmp");
            return rightArrow;
        }

        public virtual void InvalidateRow() {
            this.dgTable.DataGrid.InvalidateRow(number);
        }

        public virtual void InvalidateRowRect(Rectangle r) {
            this.dgTable.DataGrid.InvalidateRowRect(number, r);
        }

        /// <include file='doc\DataGridRow.uex' path='docs/doc[@for="DataGridRow.OnEdit"]/*' />
        /// <devdoc>
        ///    <para>When overridden in a derived class, notifies the grid that an edit will 
        ///       occur.</para>
        /// </devdoc>
        public virtual void OnEdit() {
        }

        /// <include file='doc\DataGridRow.uex' path='docs/doc[@for="DataGridRow.OnKeyPress"]/*' />
        /// <devdoc>
        /// <para>When overridden in a derived class, called by the <see cref='System.Windows.Forms.DataGrid'/> control when a key press occurs on a row with focus.</para>
        /// </devdoc>
        public virtual bool OnKeyPress(Keys keyData) {
            int currentColIndex = this.dgTable.DataGrid.CurrentCell.ColumnNumber;
            GridColumnStylesCollection columns = this.dgTable.GridColumnStyles;
            if (columns != null && currentColIndex >= 0 && currentColIndex < columns.Count) {
                DataGridColumnStyle currentColumn = columns[currentColIndex];
                if (currentColumn.KeyPress(this.RowNumber, keyData)) {
                    return true;
                }
            }
            return false;
        }

        /// <include file='doc\DataGridRow.uex' path='docs/doc[@for="DataGridRow.OnMouseDown"]/*' />
        /// <devdoc>
        /// <para> Called by the <see cref='System.Windows.Forms.DataGrid'/> when a click occurs in the row's client area 
        ///    specifed by the x and y coordinates and the specified <see cref='System.Drawing.Rectangle'/>
        ///    .</para>
        /// </devdoc>
        public virtual bool OnMouseDown(int x, int y, Rectangle rowHeaders)
        {
            return OnMouseDown(x,y,rowHeaders, false);
        }

        /// <include file='doc\DataGridRow.uex' path='docs/doc[@for="DataGridRow.OnMouseDown1"]/*' />
        /// <devdoc>
        /// <para>When overridden in a derived class, is called by the <see cref='System.Windows.Forms.DataGrid'/> when a click occurs 
        ///    in the row's
        ///    client area, specified by x and y coordinates.</para>
        /// </devdoc>
        public virtual bool OnMouseDown(int x, int y, Rectangle rowHeaders, bool alignToRight) {
            // if we call base.OnMouseDown, then the row could not use this 
            // mouse click at all. in that case LoseChildFocus, so the edit control 
            // will become visible
            LoseChildFocus(rowHeaders, alignToRight);

            // we did not use this click at all.
            return false;
        }

        /// <include file='doc\DataGridRow.uex' path='docs/doc[@for="DataGridRow.OnMouseMove"]/*' />
        /// <devdoc>
        /// </devdoc>
        public virtual bool OnMouseMove(int x, int y, Rectangle rowHeaders) {
            return false;
        }
        
        /// <include file='doc\DataGridRow.uex' path='docs/doc[@for="DataGridRow.OnMouseMove1"]/*' />
        /// <devdoc>
        /// <para>When overridden in a derived class, is called by the <see cref='System.Windows.Forms.DataGrid'/> when 
        ///    the mouse moves within the row's client area.</para>
        /// </devdoc>
        public virtual bool OnMouseMove(int x, int y, Rectangle rowHeaders, bool alignToRight) {
            return false;
        }

        /// <include file='doc\DataGridRow.uex' path='docs/doc[@for="DataGridRow.OnMouseLeft"]/*' />
        /// <devdoc>
        /// </devdoc>
        public virtual void OnMouseLeft(Rectangle rowHeaders, bool alignToRight) {
        }

        public virtual void OnMouseLeft() {
        }

        /// <include file='doc\DataGridRow.uex' path='docs/doc[@for="DataGridRow.OnRowEnter"]/*' />
        /// <devdoc>
        ///    <para>When overridden in a derived class, causes the RowEnter event to occur.</para>
        /// </devdoc>
        public virtual void OnRowEnter() {}
        public virtual void OnRowLeave() {}

        // processes the Tab Key
        // returns TRUE if the TAB key is swallowed
        internal abstract bool ProcessTabKey(Keys keyData, Rectangle rowHeaders, bool alignToRight);

        // tells the dataGridRow that it lost the focus
        internal abstract void LoseChildFocus(Rectangle rowHeaders, bool alignToRight);

        /// <include file='doc\DataGridRow.uex' path='docs/doc[@for="DataGridRow.Paint"]/*' />
        /// <devdoc>
        ///      Paints the row.
        /// </devdoc>
        public abstract int Paint(Graphics g,
                                 Rectangle dataBounds,
                                 Rectangle rowBounds,
                                 int firstVisibleColumn,
                                 int numVisibleColumns);

        public abstract int Paint(Graphics g,
                                  Rectangle dataBounds,
                                  Rectangle rowBounds,
                                  int firstVisibleColumn,
                                  int numVisibleColumns,
                                  bool alignToRight);

        /// <include file='doc\DataGridRow.uex' path='docs/doc[@for="DataGridRow.PaintBottomBorder"]/*' />
        /// <devdoc>
        ///      Draws a border on the bottom DataGrid.GridLineWidth pixels
        ///      of the bounding rectangle passed in.
        /// </devdoc>
        protected virtual void PaintBottomBorder(Graphics g, Rectangle bounds, int dataWidth)
        {
            PaintBottomBorder(g, bounds, dataWidth, this.dgTable.GridLineWidth, false);
        }

        protected virtual void PaintBottomBorder(Graphics g, Rectangle bounds, int dataWidth, int borderWidth, bool alignToRight) {
            // paint bottom border
            Rectangle bottomBorder = new Rectangle(alignToRight ? bounds.Right - dataWidth : bounds.X,
                                                   bounds.Bottom - borderWidth,
                                                   dataWidth,
                                                   borderWidth);

            g.FillRectangle(this.dgTable.IsDefault ? this.DataGrid.GridLineBrush : this.dgTable.GridLineBrush, bottomBorder);

            // paint any exposed region to the right
            if (dataWidth < bounds.Width) {
                g.FillRectangle(this.dgTable.DataGrid.BackgroundBrush,
                                alignToRight ? bounds.X: bottomBorder.Right,
                                bottomBorder.Y,
                                bounds.Width - bottomBorder.Width,
                                borderWidth);
            }
        }

        /// <include file='doc\DataGridRow.uex' path='docs/doc[@for="DataGridRow.PaintData"]/*' />
        /// <devdoc>
        ///      Paints the row.
        /// </devdoc>
        public virtual int PaintData(Graphics g,
                                     Rectangle bounds,
                                     int firstVisibleColumn,
                                     int columnCount)
        {
            return PaintData(g, bounds, firstVisibleColumn, columnCount, false);
        }

        public virtual int PaintData(Graphics g,
                                     Rectangle bounds,
                                     int firstVisibleColumn,
                                     int columnCount,
                                     bool alignToRight) {
            Debug.WriteLineIf(CompModSwitches.DGRowPaint.TraceVerbose, "Painting DataGridAddNewRow: bounds = " + bounds.ToString());

            Rectangle cellBounds   = bounds;
            int       bWidth       = this.dgTable.IsDefault ? this.DataGrid.GridLineWidth : this.dgTable.GridLineWidth;
            int       cx           = 0;

            DataGridCell current = this.dgTable.DataGrid.CurrentCell;

            GridColumnStylesCollection columns = dgTable.GridColumnStyles;
            int nCols = columns.Count;
            for (int col = firstVisibleColumn; col < nCols; ++col) {
                if (cx > bounds.Width)
                    break;

                // if (!columns[col].Visible || columns[col].PropertyDescriptor == null)
                if (columns[col].PropertyDescriptor == null || columns[col].Width <= 0)
                    continue;

                cellBounds.Width = columns[col].Width - bWidth;

                if (alignToRight)
                    cellBounds.X = bounds.Right - cx - cellBounds.Width;
                else
                    cellBounds.X = bounds.X + cx;

                // Paint the data with the the DataGridColumn
                Brush backBr = BackBrushForDataPaint(ref current, columns[col], col);
                Brush foreBrush = ForeBrushForDataPaint(ref current, columns[col], col);

                PaintCellContents(g,
                                  cellBounds,
                                  columns[col],
                                  backBr,
                                  foreBrush,
                                  alignToRight);

                // Paint the border to the right of each cell
                if (bWidth > 0) {
                    g.FillRectangle(this.dgTable.IsDefault ? this.DataGrid.GridLineBrush : this.dgTable.GridLineBrush,
                                    alignToRight ? cellBounds.X - bWidth : cellBounds.Right,
                                    cellBounds.Y,
                                    bWidth,
                                    cellBounds.Height);
                }
                cx += cellBounds.Width + bWidth;
            }

            // Paint any exposed area to the right ( or left ) of the data cell area
            if (cx < bounds.Width) {
                g.FillRectangle(this.dgTable.DataGrid.BackgroundBrush,
                                alignToRight ? bounds.X : bounds.X + cx,
                                bounds.Y,
                                bounds.Width - cx,
                                bounds.Height);
            }
            return cx;
        }

        protected virtual void PaintCellContents(Graphics g, Rectangle cellBounds, DataGridColumnStyle column,
                                                 Brush backBr, Brush foreBrush)
        {
            PaintCellContents(g, cellBounds, column, backBr, foreBrush, false);
        }

        protected virtual void PaintCellContents(Graphics g, Rectangle cellBounds, DataGridColumnStyle column,
                                                 Brush backBr, Brush foreBrush, bool alignToRight) {
            g.FillRectangle(backBr, cellBounds);
        }

        /// <include file='doc\DataGridRow.uex' path='docs/doc[@for="DataGridRow.PaintPositionArrow"]/*' />
        /// <devdoc>
        ///      Paints a selection arrow onto the graphics context and
        ///      returns the width of the area painted.
        /// </devdoc>
        protected int PaintPositionArrow(Graphics g, Rectangle bounds, Brush backBrush, bool alignToRight) {
            Bitmap arrowBmp = alignToRight ? GetLeftArrowBitmap() : GetRightArrowBitmap();

            lock (arrowBmp) {
                Size glyphSize = arrowBmp.Size;
                Rectangle glyphRect = new Rectangle(alignToRight ? bounds.Right - xOffset - glyphSize.Width : bounds.X + xOffset,
                    bounds.Y + yOffset,
                    glyphSize.Width,
                    glyphSize.Height);
                if (this.dgTable.IsDefault)
                    g.FillRectangle(this.DataGrid.HeaderBackBrush, bounds);
                else
                    g.FillRectangle(this.dgTable.HeaderBackBrush, bounds);
                if (RowNumber == this.DataGrid.CurrentCell.RowNumber) {
                    colorMap[0].NewColor = this.dgTable.HeaderForeColor;
                    ImageAttributes attr = new ImageAttributes();
                    attr.SetRemapTable(colorMap, ColorAdjustType.Bitmap);
                    g.DrawImage(arrowBmp, glyphRect, glyphRect.X, glyphRect.Y, glyphRect.Width, glyphRect.Height,GraphicsUnit.Pixel, attr);
                    // g.DrawImage(arrowBmp, glyphRect);
                    attr.Dispose();

                    // we need to be smarter about this
                    // and not paint the same pixels twice....
                    //g.ExcludeClip(glyphRect);
                }

                return glyphSize.Width;
            }
        }

        //
        // This function will do the following: if paintIcon is set to true, then
        // will draw the image on the RowHeader. if paintIcon is set to false, 
        // then this function will fill the rectangle on which otherwise will
        // have been drawn the image
        //
        // will return the rectangle that includes the Icon
        // UNDONE: danielhe: we are painting some pixels twice.
        protected Rectangle PaintIcon(Graphics g, Rectangle visualBounds, bool paintIcon, bool alignToRight, Bitmap bmp) {
            return PaintIcon(g, visualBounds, paintIcon, alignToRight, bmp, 
                             this.dgTable.IsDefault ? this.DataGrid.HeaderBackBrush : this.dgTable.HeaderBackBrush);
        }
        protected Rectangle PaintIcon(Graphics g, Rectangle visualBounds, bool paintIcon, bool alignToRight, Bitmap bmp, Brush backBrush) {
            Size bmpSize = bmp.Size;
            Rectangle bmpRect = new Rectangle(alignToRight ? visualBounds.Right - xOffset - bmpSize.Width : visualBounds.X + xOffset,
                                              visualBounds.Y + yOffset,
                                              bmpSize.Width,
                                              bmpSize.Height);
            g.FillRectangle(backBrush, visualBounds);
            if (paintIcon)
            {
                colorMap[0].NewColor = this.dgTable.IsDefault ? this.DataGrid.HeaderForeColor : this.dgTable.HeaderForeColor;
                colorMap[0].OldColor = Color.Black;
                ImageAttributes attr = new ImageAttributes();
                attr.SetRemapTable(colorMap, ColorAdjustType.Bitmap);
                g.DrawImage(bmp, bmpRect, 0, 0, bmpRect.Width, bmpRect.Height,GraphicsUnit.Pixel, attr);
                // g.DrawImage(bmp, bmpRect);
                attr.Dispose();
            }

            return bmpRect;
        }

        // assume that the row is not aligned to right, and that the row is not dirty
        public virtual void PaintHeader(Graphics g, Rectangle visualBounds) {
            PaintHeader(g, visualBounds, false);
        }

        // assume that the row is not dirty
        public virtual void PaintHeader(Graphics g, Rectangle visualBounds, bool alignToRight) {
            PaintHeader(g,visualBounds, alignToRight, false);
        }

        public virtual void PaintHeader(Graphics g, Rectangle visualBounds, bool alignToRight, bool rowIsDirty) {
            Rectangle bounds = visualBounds;

            // paint the first part of the row header: the Arror or Pencil/Star
            Bitmap bmp;
            if (this is DataGridAddNewRow)
            {
                bmp = GetStarBitmap();
                lock (bmp) {
                    bounds.X += PaintIcon(g, bounds, true, alignToRight, bmp).Width + xOffset;
                }
                return;
            }
            else if (rowIsDirty)
            {
                bmp = GetPencilBitmap();
                lock (bmp) {
                    bounds.X += PaintIcon(g, bounds, RowNumber == this.DataGrid.CurrentCell.RowNumber, alignToRight, bmp).Width + xOffset;
                }
            }
            else
            {
                bmp = alignToRight ? GetLeftArrowBitmap() : GetRightArrowBitmap();
                lock (bmp) {
                    bounds.X += PaintIcon(g, bounds, RowNumber == this.DataGrid.CurrentCell.RowNumber, alignToRight, bmp).Width + xOffset;
                }
            }

            // Paint the error icon
            //
            object errorInfo = DataGrid.ListManager[this.number];
            if (!(errorInfo is IDataErrorInfo))
                return;

            string errString = ((IDataErrorInfo) errorInfo).Error;
            if (errString == null)
                errString = String.Empty;

            if (tooltip != errString) {
                if (tooltip.Length > 0) {
                    DataGrid.ToolTipProvider.RemoveToolTip(tooltipID);
                    tooltip = String.Empty;
                    tooltipID = new IntPtr(-1);
                }
            }

            if (errString.Length == 0)
                return;

            // we now have an error string: paint the errorIcon and add the tooltip
            Rectangle errRect;
            bmp = GetErrorBitmap();
            lock (bmp) {
                errRect = PaintIcon(g, bounds, true, alignToRight, bmp);
            }
            bounds.X += errRect.Width + xOffset;

            tooltip = errString;
            tooltipID = (IntPtr)((int)DataGrid.ToolTipId++);
            DataGrid.ToolTipProvider.AddToolTip(tooltip, tooltipID, errRect);
        }

        protected Brush GetBackBrush() {
            Brush br = this.dgTable.IsDefault ? DataGrid.BackBrush : this.dgTable.BackBrush;
            if (DataGrid.LedgerStyle && (RowNumber % 2 == 1)) {
                br = this.dgTable.IsDefault ? this.DataGrid.AlternatingBackBrush : this.dgTable.AlternatingBackBrush;
            }
            return br;
        }

        /// <include file='doc\DataGridRow.uex' path='docs/doc[@for="DataGridRow.BackBrushForDataPaint"]/*' />
        /// <devdoc>
        ///      Returns the BackColor and TextColor  that the Graphics object should use
        ///      for the appropriate values for a given row and column when painting the data.
        ///
        /// </devdoc>
        protected Brush BackBrushForDataPaint(ref DataGridCell current, DataGridColumnStyle gridColumn, int column) {
            Brush backBr = this.GetBackBrush();

            if (Selected) {
                backBr = this.dgTable.IsDefault ? this.DataGrid.SelectionBackBrush : this.dgTable.SelectionBackBrush;
            }            
            /*
            if (RowNumber == current.RowNumber && column == current.ColumnNumber) {
                backBr = grid.CurrentCellBackBrush;
            }
            */
            return backBr;
        }

        protected Brush ForeBrushForDataPaint(ref DataGridCell current, DataGridColumnStyle gridColumn, int column) {
            // Brush foreBrush = gridColumn.ForeBrush;
            Brush foreBrush = this.dgTable.IsDefault ? this.DataGrid.ForeBrush : this.dgTable.ForeBrush;

            if (Selected) {
                foreBrush = this.dgTable.IsDefault ? this.DataGrid.SelectionForeBrush : this.dgTable.SelectionForeBrush;
            }
            /*
            if (RowNumber == current.RowNumber && column == current.ColumnNumber) {
                foreColor = grid.CurrentCellForeColor;
            }
            */
            return foreBrush;
        }

        [ComVisible(true)]
        protected class DataGridRowAccessibleObject : AccessibleObject {
            ArrayList cells;

            DataGridRow owner = null;

            internal static string CellToDisplayString(DataGrid grid, int row, int column) {
                if (column < grid.myGridTable.GridColumnStyles.Count) {
                    return grid.myGridTable.GridColumnStyles[column].PropertyDescriptor.Converter.ConvertToString(grid[row, column]);
                }
                else {
                    return "";
                }
            }

            internal static object DisplayStringToCell(DataGrid grid, int row, int column, string value) {
                if (column < grid.myGridTable.GridColumnStyles.Count) {
                    return grid.myGridTable.GridColumnStyles[column].PropertyDescriptor.Converter.ConvertFromString(value);
                }
                // ignore...
                //
                return null;
            }

            public DataGridRowAccessibleObject(DataGridRow owner) : base() {
                Debug.Assert(owner != null, "DataGridRowAccessibleObject must have a valid owner DataGridRow");
                this.owner = owner;
                DataGrid grid = DataGrid;
                Debug.WriteLineIf(DataGrid.DataGridAcc.TraceVerbose, "Create row accessible object");

                EnsureChildren();
            }

            private void EnsureChildren() {
                if (cells == null) {
                    // default size... little extra for relationships...
                    //
                    cells = new ArrayList(DataGrid.myGridTable.GridColumnStyles.Count + 2);
                    AddChildAccessibleObjects(cells);
                }
            }

            protected virtual void AddChildAccessibleObjects(IList children) {
                Debug.WriteLineIf(DataGrid.DataGridAcc.TraceVerbose, "Create row's accessible children");
                Debug.Indent();
                GridColumnStylesCollection cols = DataGrid.myGridTable.GridColumnStyles;
                int len = cols.Count;
                Debug.WriteLineIf(DataGrid.DataGridAcc.TraceVerbose, len + " columns present");
                for (int i=0; i<len; i++) {
                    children.Add(CreateCellAccessibleObject(i));
                }
                Debug.Unindent();
            }

            protected virtual AccessibleObject CreateCellAccessibleObject(int column) {
                return new DataGridCellAccessibleObject(owner, column);
            }

            public override Rectangle Bounds {
                get {
                    return DataGrid.RectangleToScreen(DataGrid.GetRowBounds(owner));
                }
            }

            public override string Name {
                get {
                    if (owner is DataGridAddNewRow) {
                        return SR.GetString(SR.AccDGNewRow);
                    }
                    else {
                        return DataGridRowAccessibleObject.CellToDisplayString(DataGrid, owner.RowNumber, 0);
                    }
                }
            }

            protected DataGridRow Owner {
                get {
                    return owner;
                }
            }

            public override AccessibleObject Parent {
                get {
                    return DataGrid.AccessibilityObject;
                }
            }

            private DataGrid DataGrid {
                get {
                    return owner.DataGrid;
                }
            }

            public override AccessibleRole Role {
                get {
                    return AccessibleRole.Row;
                }
            }

            public override AccessibleStates State {
                get {
                    AccessibleStates state = AccessibleStates.Selectable | AccessibleStates.Focusable;

                    // Determine focus
                    //
                    if (DataGrid.CurrentCell.RowNumber == owner.RowNumber) {
                        state |= AccessibleStates.Focused;
                    }

                    // Determine selected
                    //
                    if (DataGrid.CurrentRowIndex == owner.RowNumber) {
                        state |= AccessibleStates.Selected;
                    }

                    return state;
                }
            }

            public override string Value {
                get {
                    return Name;
                }
            }
            
            public override AccessibleObject GetChild(int index) {
                if (index < cells.Count) {
                    return (AccessibleObject)cells[index];
                }

                return null;
            }

            public override int GetChildCount() {
                return cells.Count;
            }

            /// <include file='doc\DataGridRow.uex' path='docs/doc[@for="DataGridRow.DataGridRowAccessibleObject.GetFocused"]/*' />
            /// <devdoc>
            ///      Returns the currently focused child, if any.
            ///      Returns this if the object itself is focused.
            /// </devdoc>
            public override AccessibleObject GetFocused() {
                if (DataGrid.Focused) {
                    DataGridCell cell = DataGrid.CurrentCell;
                    if (cell.RowNumber == owner.RowNumber) {
                        return (AccessibleObject)cells[cell.ColumnNumber];
                    }
                }

                return null;
            }


            /// <include file='doc\DataGridRow.uex' path='docs/doc[@for="DataGridRow.DataGridRowAccessibleObject.Navigate"]/*' />
            /// <devdoc>
            ///      Navigate to the next or previous grid entry.entry.
            /// </devdoc>
            public override AccessibleObject Navigate(AccessibleNavigation navdir) {
                switch (navdir) {
                    case AccessibleNavigation.Down:
                    case AccessibleNavigation.Right:
                    case AccessibleNavigation.Next:
                        return DataGrid.AccessibilityObject.GetChild(1 + owner.dgTable.GridColumnStyles.Count + owner.RowNumber + 1);

                    case AccessibleNavigation.Up:
                    case AccessibleNavigation.Left:
                    case AccessibleNavigation.Previous:
                        return DataGrid.AccessibilityObject.GetChild(1 + owner.dgTable.GridColumnStyles.Count + owner.RowNumber - 1);

                    case AccessibleNavigation.FirstChild:
                        if (GetChildCount() > 0) {
                            return GetChild(0);
                        }
                        break;
                    case AccessibleNavigation.LastChild:
                        if (GetChildCount() > 0) {
                            return GetChild(GetChildCount() - 1);
                        }
                        break;
                }

                return null;

            }

            public override void Select(AccessibleSelection flags) {
                // Focus the PropertyGridView window
                //
                if ( (flags & AccessibleSelection.TakeFocus) == AccessibleSelection.TakeFocus) {
                    DataGrid.Focus();
                }

                // Select the grid entry
                //
                if ( (flags & AccessibleSelection.TakeSelection) == AccessibleSelection.TakeSelection) {
                    DataGrid.CurrentRowIndex = owner.RowNumber;
                }
            }

        }

        [ComVisible(true)]
        protected class DataGridCellAccessibleObject : AccessibleObject {
            DataGridRow owner = null;
            int column;

            public DataGridCellAccessibleObject(DataGridRow owner, int column) : base() {
                Debug.Assert(owner != null, "DataGridColumnAccessibleObject must have a valid owner DataGridRow");
                this.owner = owner;
                this.column = column;
                Debug.WriteLineIf(DataGrid.DataGridAcc.TraceVerbose, "Create cell accessible object");
            }

            public override Rectangle Bounds {
                get {
                    return DataGrid.RectangleToScreen(DataGrid.GetCellBounds(new DataGridCell(owner.RowNumber, column)));
                }
            }

            public override string Name {
                get {
                    return DataGrid.myGridTable.GridColumnStyles[column].HeaderText;
                }
            }

            protected DataGridRow Owner {
                get {
                    return owner;
                }
            }

            public override AccessibleObject Parent {
                get {
                    return owner.AccessibleObject;
                }
            }

            protected DataGrid DataGrid {
                get {
                    return owner.DataGrid;
                }
            }

            public override string DefaultAction {
                get {
                    return SR.GetString(SR.AccDGEdit);
                }
            }

            public override AccessibleRole Role {
                get {
                    return AccessibleRole.Cell;
                }
            }

            public override AccessibleStates State {
                get {
                    AccessibleStates state = AccessibleStates.Selectable | AccessibleStates.Focusable;

                    // Determine focus
                    //
                    if (DataGrid.CurrentCell.RowNumber == owner.RowNumber
                        && DataGrid.CurrentCell.ColumnNumber == column) {
                        if (DataGrid.Focused) {
                            state |= AccessibleStates.Focused;
                        }
                        state |= AccessibleStates.Selected;
                    }

                    return state;
                }
            }

            public override string Value {
                get {
                    if (owner is DataGridAddNewRow) {
                        return null;
                    }
                    else {
                        return DataGridRowAccessibleObject.CellToDisplayString(DataGrid, owner.RowNumber, column);
                    }
                }
                set {
                    if (!(owner is DataGridAddNewRow)) {
                        object realValue =  DataGridRowAccessibleObject.DisplayStringToCell(DataGrid, owner.RowNumber, column, value);
                        DataGrid[owner.RowNumber, column] = realValue;
                    }
                }
            }

            public override void DoDefaultAction() {
                Select(AccessibleSelection.TakeFocus | AccessibleSelection.TakeSelection);
            }

            /// <include file='doc\DataGridRow.uex' path='docs/doc[@for="DataGridRow.DataGridCellAccessibleObject.GetFocused"]/*' />
            /// <devdoc>
            ///      Returns the currently focused child, if any.
            ///      Returns this if the object itself is focused.
            /// </devdoc>
            public override AccessibleObject GetFocused() {
                // Datagrid always returns the cell as the focused thing... so do we!
                //
                return DataGrid.AccessibilityObject.GetFocused();
            }


            /// <include file='doc\DataGridRow.uex' path='docs/doc[@for="DataGridRow.DataGridCellAccessibleObject.Navigate"]/*' />
            /// <devdoc>
            ///      Navigate to the next or previous grid entry.
            /// </devdoc>
            public override AccessibleObject Navigate(AccessibleNavigation navdir) {
                switch (navdir) {
                    case AccessibleNavigation.Right:
                    case AccessibleNavigation.Next:
                        if (column < owner.AccessibleObject.GetChildCount() - 1) {
                            return owner.AccessibleObject.GetChild(column + 1);
                        }
                        else {
                            AccessibleObject o = DataGrid.AccessibilityObject.GetChild(1 + owner.dgTable.GridColumnStyles.Count + owner.RowNumber + 1);
                            if (o != null) {
                                return o.Navigate(AccessibleNavigation.FirstChild);
                            }
                        }
                        break;
                    case AccessibleNavigation.Down:
                        return DataGrid.AccessibilityObject.GetChild(1 + owner.dgTable.GridColumnStyles.Count + owner.RowNumber + 1).Navigate(AccessibleNavigation.FirstChild);
                    case AccessibleNavigation.Up:
                        return DataGrid.AccessibilityObject.GetChild(1 + owner.dgTable.GridColumnStyles.Count + owner.RowNumber - 1).Navigate(AccessibleNavigation.FirstChild);
                    case AccessibleNavigation.Left:
                    case AccessibleNavigation.Previous:
                        if (column > 0) {
                            return owner.AccessibleObject.GetChild(column - 1);
                        }
                        else {
                            AccessibleObject o = DataGrid.AccessibilityObject.GetChild(1 + owner.dgTable.GridColumnStyles.Count + owner.RowNumber - 1);
                            if (o != null) {
                                return o.Navigate(AccessibleNavigation.LastChild);
                            }
                        }
                        break;

                    case AccessibleNavigation.FirstChild:
                    case AccessibleNavigation.LastChild:

                        break;
                }

                return null;

            }

            public override void Select(AccessibleSelection flags) {
                // Focus the PropertyGridView window
                //
                if ( (flags & AccessibleSelection.TakeFocus) == AccessibleSelection.TakeFocus) {
                    DataGrid.Focus();
                }

                // Select the grid entry
                //
                if ( (flags & AccessibleSelection.TakeSelection) == AccessibleSelection.TakeSelection) {
                    DataGrid.CurrentCell = new DataGridCell(owner.RowNumber, column);
                }
            }

        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\datagridrelationshiprow.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGridRelationshipRow.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    using System.Runtime.Remoting;

    using System;
    using System.Runtime.InteropServices;
    
    using System.Windows.Forms;
    using System.ComponentModel;
    using System.Drawing;
    
    using Microsoft.Win32;
    using System.Diagnostics;
    using System.Collections;

    /// <include file='doc\DataGridRelationshipRow.uex' path='docs/doc[@for="DataGridRelationshipRow"]/*' />
    /// <devdoc>
    ///      This class fully encapsulates the painting logic for a row
    ///      appearing in a DataGrid.
    /// </devdoc>
    internal class DataGridRelationshipRow : DataGridRow {
        private const bool defaultOpen         = false;
        private const int  expandoBoxWidth     = 14;
        private const int  indentWidth         = 20;
        // private const int  relationshipSpacing = 1;
        private const int  triangleSize        = 5;

        private bool expanded         = defaultOpen;
        // private bool hasRelationships = false;
        // private Font linkFont = null;
        // private new DataGrid dataGrid; // Currently used only to obtain a Graphics object for measuring text

        // private Rectangle relationshipRect   = Rectangle.Empty;
        // private int       relationshipHeight = 0;

        // relationships
        // we should get this directly from the dgTable.
        // private ArrayList     relationships;
        // private int            focusedRelation = -1;
        // private int          focusedTextWidth;

        public DataGridRelationshipRow(DataGrid dataGrid, DataGridTableStyle dgTable, int rowNumber)
        : base(dataGrid, dgTable, rowNumber) {
            // this.dataGrid = dataGrid;
            // linkFont = dataGrid.LinkFont;
            // relationshipHeight = dataGrid.LinkFontHeight + this.dgTable.relationshipSpacing;

            // if (DataGrid.AllowNavigation) {
            //     hasRelationships = dgTable.RelationsList.Count > 0;
            // }
        }

        internal protected override int MinimumRowHeight(GridColumnStylesCollection cols) {
            /*
            if (DataGrid != null && DataGrid.LinkFontHeight + this.dgTable.relationshipSpacing != relationshipHeight) {
                relationshipRect = Rectangle.Empty;
                relationshipHeight = DataGrid.LinkFontHeight + this.dgTable.relationshipSpacing;
            }
            */

            return base.MinimumRowHeight(cols) + (this.expanded ? GetRelationshipRect().Height : 0);
        }

        internal protected override int MinimumRowHeight(DataGridTableStyle dgTable) {
            /*
            if (DataGrid != null && DataGrid.LinkFontHeight + this.dgTable.relationshipSpacing != relationshipHeight) {
                relationshipRect = Rectangle.Empty;
                relationshipHeight = DataGrid.LinkFontHeight + this.dgTable.relationshipSpacing;
            }
            */

            return base.MinimumRowHeight(dgTable) + (this.expanded ? GetRelationshipRect().Height : 0);
        }

        // =------------------------------------------------------------------
        // =        Properties
        // =------------------------------------------------------------------

        public virtual bool Expanded {
            get {
                return expanded;
            }
            set {
                if (expanded == value)
                    return;
                if (expanded)
                    Collapse();
                else
                    Expand();
            }
        }

        /*
        private Color BorderColor {
            get {
                if (DataGrid == null)
                    return Color.Empty;
                return DataGrid.GridLineColor;
            }
        }
        */

#if FALSE
        private int BorderWidth {
            get {
                DataGrid dataGrid = this.DataGrid;
                if (dataGrid == null)
                    return 0;
                // if the user set the GridLineStyle property on the dataGrid.
                // then use the value of that property
                DataGridLineStyle gridStyle;
                int gridLineWidth;
                if (this.dgTable.IsDefault) {
                    gridStyle = this.DataGrid.GridLineStyle;
                    gridLineWidth = this.DataGrid.GridLineWidth;
                } else {
                    gridStyle = this.dgTable.GridLineStyle;
                    gridLineWidth = this.dgTable.GridLineWidth;
                }

                if (gridStyle == DataGridLineStyle.None)
                    return 0;

                return gridLineWidth;
            }
        }
#endif //FALSE

        private int FocusedRelation {
            get {
                return this.dgTable.FocusedRelation;
            }
            set {
                dgTable.FocusedRelation = value;
            }
        }

        // =------------------------------------------------------------------
        // =        Methods
        // =------------------------------------------------------------------

        private void Collapse() {
            Debug.Assert(this.dgTable.DataGrid.AllowNavigation, "how can the user collapse the relations if the grid does not allow navigation?");
            if (expanded) {
                expanded = false;
                // relationshipRect = Rectangle.Empty;
                FocusedRelation = -1;
                DataGrid.OnRowHeightChanged(this);
            }
        }
        
        protected override AccessibleObject CreateAccessibleObject() {
            return new DataGridRelationshipRowAccessibleObject(this);
        }


        private void Expand() {
            Debug.Assert(this.dgTable.DataGrid.AllowNavigation, "how can the user expand the relations if the grid does not allow navigation?");
            if (expanded == false
                && DataGrid != null
                && this.dgTable != null
                && this.dgTable.RelationsList.Count > 0) {
                expanded = true;
                FocusedRelation = -1;

                // relationshipRect = Rectangle.Empty;
                DataGrid.OnRowHeightChanged(this);
            }
        }

        public override int Height {
            get {
                int height = base.Height;
                if (expanded)
                    return height + GetRelationshipRect().Height;
                else
                    return height;
            }
            set {
                // we should use the RelationshipRect only when the row is expanded
                if (expanded)
                    base.Height = value - GetRelationshipRect().Height;
                else
                    base.Height = value;
            }
        }

        // so the edit box will not paint under the 
        // grid line of the row
        public override Rectangle GetCellBounds(int col) {
            Rectangle cellBounds = base.GetCellBounds(col);
            // decrement base.Height by 1, so the edit box will not 
            // paint over the bottom line.
            cellBounds.Height = base.Height - 1;
            return cellBounds;
        }

        /// <include file='doc\DataGridRelationshipRow.uex' path='docs/doc[@for="DataGridRelationshipRow.GetOutlineRect"]/*' />
        /// <devdoc>
        ///      Given a point that describes an origin, this procedure returns
        ///      a rectangle that describes the location of an outline box.
        /// </devdoc>
        /// <internalonly/>
        private Rectangle GetOutlineRect(Point p) {
            return GetOutlineRect(p.X, p.Y);
        }

        private Rectangle GetOutlineRect(int xOrigin, int yOrigin) {
            Rectangle outline = new Rectangle(xOrigin + 2,
                                              yOrigin + 2,
                                              9,
                                              9);
            return outline;
        }

        public override Rectangle GetNonScrollableArea() {
            if (expanded) {
                return GetRelationshipRect();
            }
            else
                return Rectangle.Empty;
        }

        private Rectangle GetRelationshipRect() {
            Debug.Assert(this.expanded, "we should need this rectangle only when the row is expanded");
            Rectangle ret = this.dgTable.RelationshipRect;
            ret.Y = base.Height - this.dgTable.BorderWidth;
            return ret;
        }

#if FALSE
        private Rectangle GetRelationshipRect() {
            if (relationshipRect.IsEmpty) {
                Debug.WriteLineIf(CompModSwitches.DGRelationShpRowLayout.TraceVerbose, "GetRelationshipRect grinding away");
                if (!expanded) {
                    return(relationshipRect = new Rectangle(0,0,0,0));
                }
                Graphics g = DataGrid.CreateGraphicsInternal();
                relationshipRect = new Rectangle();
                relationshipRect.X = 0; //indentWidth;
                relationshipRect.Y = base.Height - this.dgTable.BorderWidth;

                // Determine the width of the widest relationship name
                int longestRelationship = 0;
                for (int r = 0; r < this.dgTable.RelationsList.Count; ++r) {
                    int rwidth = (int) Math.Ceiling(g.MeasureString(((string) this.dgTable.RelationsList[r]), this.DataGrid.LinkFont).Width);
                    if (rwidth > longestRelationship)
                        longestRelationship = rwidth;
                }

                g.Dispose();

                relationshipRect.Width = longestRelationship + 5;
                relationshipRect.Width += 2; // relationshipRect border;
                relationshipRect.Height = this.dgTable.BorderWidth + relationshipHeight * this.dgTable.RelationsList.Count;
                relationshipRect.Height += 2; // relationship border
                if (this.dgTable.RelationsList.Count > 0)
                    relationshipRect.Height += 2 * System.Windows.Forms.DataGridTableStyle.relationshipSpacing;
            }
            return relationshipRect;
        }

#endif// FALSE

        private Rectangle GetRelationshipRectWithMirroring() {
            Rectangle relRect = GetRelationshipRect();
            bool rowHeadersVisible = this.dgTable.IsDefault ? this.DataGrid.RowHeadersVisible : this.dgTable.RowHeadersVisible;
            if (rowHeadersVisible) {
                int rowHeaderWidth = this.dgTable.IsDefault ? this.DataGrid.RowHeaderWidth : this.dgTable.RowHeaderWidth;
                relRect.X += DataGrid.GetRowHeaderRect().X + rowHeaderWidth;
            }
            relRect.X = MirrorRelationshipRectangle(relRect, DataGrid.GetRowHeaderRect(), DataGrid.RightToLeft == RightToLeft.Yes);
            return relRect;
        }

        /// <include file='doc\DataGridRelationshipRow.uex' path='docs/doc[@for="DataGridRelationshipRow.OnMouseDown"]/*' />
        /// <devdoc>
        ///      Called by the DataGrid when a click occurs in the row's client
        ///      area.  The coordinates are normalized to the rectangle's top
        ///      left point.
        /// </devdoc>
        private bool PointOverPlusMinusGlyph(int x, int y, Rectangle rowHeaders, bool alignToRight) {
            if (dgTable == null || dgTable.DataGrid == null || !dgTable.DataGrid.AllowNavigation)
                return false;
            Rectangle insideRowHeaders = rowHeaders;
            if (!this.DataGrid.FlatMode) {
                insideRowHeaders.Inflate(-1,-1);
            }

            Rectangle outline = GetOutlineRect(insideRowHeaders.Right - expandoBoxWidth, 0);

            outline.X = MirrorRectangle(outline.X, outline.Width, insideRowHeaders, alignToRight);

            return outline.Contains(x,y);
        }

        public override bool OnMouseDown(int x, int y, Rectangle rowHeaders, bool alignToRight) {
            bool rowHeadersVisible = this.dgTable.IsDefault ? this.DataGrid.RowHeadersVisible : this.dgTable.RowHeadersVisible;
            if (rowHeadersVisible) {
                if (PointOverPlusMinusGlyph(x,y,rowHeaders, alignToRight)) {
                    if (this.dgTable.RelationsList.Count == 0) {
                        return false;
                    }
                    else if (expanded) {
                        Collapse();
                    }
                    else {
                        Expand();
                    }
                    DataGrid.OnNodeClick(EventArgs.Empty);
                    return true;
                }
            }

            if (!expanded)
                return base.OnMouseDown(x, y, rowHeaders, alignToRight);

            // hit test for relationships
            Rectangle relRect = GetRelationshipRectWithMirroring();

            if (relRect.Contains(x, y)) {
                int r = RelationFromY(y);
                if (r != -1) {
                    // first, reset the FocusedRelation
                    FocusedRelation = -1;
                    DataGrid.NavigateTo(((string)this.dgTable.RelationsList[r]), this, true);
                }
                // DataGrid.OnLinkClick(EventArgs.Empty);
                return true;
            }

            return base.OnMouseDown(x, y, rowHeaders, alignToRight);
        }

        public override bool OnMouseMove(int x, int y, Rectangle rowHeaders, bool alignToRight) {
            if (!expanded)
                return false;

            Rectangle relRect = GetRelationshipRectWithMirroring();

            if (relRect.Contains(x, y)) {
                this.DataGrid.Cursor = Cursors.Hand;
                return true;
            }

            this.DataGrid.Cursor = Cursors.Default;
            return base.OnMouseMove(x, y, rowHeaders, alignToRight);
        }

        // this function will not invalidate all of the 
        // row
        public override void OnMouseLeft(Rectangle rowHeaders, bool alignToRight) {
            if (!expanded)
                return;

            Rectangle relRect = GetRelationshipRect();
            relRect.X += rowHeaders.X + this.dgTable.RowHeaderWidth;
            relRect.X = MirrorRelationshipRectangle(relRect, rowHeaders, alignToRight);

            if (FocusedRelation != -1) {
                InvalidateRowRect(relRect);
                FocusedRelation = -1;
            }
        }

        public override void OnMouseLeft() {
            if (!expanded)
                return;

            if (FocusedRelation != -1) {
                InvalidateRow();
                FocusedRelation = -1;
            }
            base.OnMouseLeft();
        }

        /// <include file='doc\DataGridRelationshipRow.uex' path='docs/doc[@for="DataGridRelationshipRow.OnKeyPress"]/*' />
        /// <devdoc>
        ///      Called by the DataGrid when a keypress occurs on a row with "focus."
        /// </devdoc>
        public override bool OnKeyPress(Keys keyData) {
            // ignore the shift key if it is not paired w/ the TAB key
            if ((keyData & Keys.Modifiers) == Keys.Shift && (keyData & Keys.KeyCode) != Keys.Tab)
                return false;

            switch (keyData & Keys.KeyCode) {
                case Keys.F5:
                    if (dgTable == null || dgTable.DataGrid == null || !dgTable.DataGrid.AllowNavigation)
                        return false;
                    if (expanded)
                        Collapse();
                    else
                        Expand();
                    FocusedRelation = -1;
                    return true;

                // to make the gridTest run w/ the numLock key on
                //
                case Keys.NumLock:
                    if (FocusedRelation != -1)
                        return false;
                    else
                        return base.OnKeyPress(keyData);
                case Keys.Enter:
                    if (FocusedRelation != -1) {
                        // somebody set the relation number up already
                        // navigate to the relation
                        DataGrid.NavigateTo(((string)this.dgTable.RelationsList[FocusedRelation]), this, true);

                        // now reset the FocusedRelation
                        FocusedRelation = -1;
                        return true;
                    }
                    else
                        return false;

                case Keys.Tab:
                    return false;

                default:
                    FocusedRelation = -1;
                    return base.OnKeyPress(keyData);
            }
        }

        // will reset the FocusedRelation and will invalidate the 
        // rectangle so that the linkFont is no longer shown
        internal override void LoseChildFocus(Rectangle rowHeaders, bool alignToRight) {
            // we only invalidate stuff if the row is expanded.
            if (FocusedRelation == -1 || !expanded)
                return;

            FocusedRelation = -1;
            Rectangle relRect = GetRelationshipRect();
            relRect.X += rowHeaders.X + this.dgTable.RowHeaderWidth;
            relRect.X = MirrorRelationshipRectangle(relRect, rowHeaders, alignToRight);
            InvalidateRowRect(relRect);
        }

        // here is the logic for FOCUSED:
        //
        // first the dataGrid gets the KeyPress.
        // the dataGrid passes it to the currentRow. if it is anything other
        // than Enter or TAB, the currentRow resets the FocusedRelation variable.
        //
        // Then the dataGrid takes another look at the TAB key and if it is the case
        // it passes it to the row. If the dataRelationshipRow can become focused,
        // then it eats the TAB key, otherwise it will give it back to the dataGrid.
        //
        internal override bool ProcessTabKey(Keys keyData, Rectangle rowHeaders, bool alignToRight) {
            Debug.Assert((keyData & Keys.Control) != Keys.Control, "the DataGridRelationshipRow only handles TAB and TAB-SHIFT");
            Debug.Assert((keyData & Keys.Alt) != Keys.Alt, "the DataGridRelationshipRow only handles TAB and TAB-SHIFT");

            // if there are no relationships, this row can't do anything with the 
            // key
            if (this.dgTable.RelationsList.Count == 0 || dgTable.DataGrid == null || !dgTable.DataGrid.AllowNavigation)
                return false;

            // expand the relationship box
            if (!expanded)
                Expand();

            if ((keyData & Keys.Shift) == Keys.Shift) {
                if (FocusedRelation == 0) {
                    // if user hits TAB-SHIFT and the focus was on the first relationship then
                    // reset FocusedRelation and let the dataGrid use the key
                    //
                    // consider: DANIELHE: if the relationships box is expanded, should we collapse it on leave?
                    FocusedRelation = -1;
                    return false;
                }

                // we need to invalidate the relationshipRectangle, and cause the linkFont to move
                // to the next relation
                Rectangle relRect = GetRelationshipRect();
                relRect.X += rowHeaders.X + this.dgTable.RowHeaderWidth;
                relRect.X = MirrorRelationshipRectangle(relRect, rowHeaders, alignToRight);
                InvalidateRowRect(relRect);

                if (FocusedRelation == -1)
                    // is the first time that the user focuses on this
                    // set of relationships
                    FocusedRelation = this.dgTable.RelationsList.Count - 1;
                else
                    FocusedRelation --;
                return true;
            }
            else {
                if (FocusedRelation == this.dgTable.RelationsList.Count - 1) {
                    // if the user hits TAB and the focus was on the last relationship then
                    // reset FocusedRelation and let the dataGrid use the key
                    //
                    // consider: DANIELHE: if the relationships box is expanded, should we collapse it on leave?
                    FocusedRelation = -1;
                    return false;
                }

                // we need to invalidate the relationshipRectangle, and cause the linkFont to move
                // to the next relation
                Rectangle relRect = GetRelationshipRect();
                relRect.X += rowHeaders.X + this.dgTable.RowHeaderWidth;
                relRect.X = MirrorRelationshipRectangle(relRect, rowHeaders, alignToRight);
                InvalidateRowRect(relRect);

                FocusedRelation ++;
                return true;
            }
        }

        /// <include file='doc\DataGridRelationshipRow.uex' path='docs/doc[@for="DataGridRelationshipRow.Paint"]/*' />
        /// <devdoc>
        ///      Paints the row.
        /// </devdoc>
        public override int Paint(Graphics g, Rectangle bounds, Rectangle trueRowBounds, int firstVisibleColumn, int numVisibleColumns) {
            return Paint(g, bounds, trueRowBounds, firstVisibleColumn, numVisibleColumns, false);
        }

        public override int Paint(Graphics g,
                                  Rectangle bounds,          // negative offsetted row bounds
                                  Rectangle trueRowBounds,   // real row bounds.
                                  int firstVisibleColumn,
                                  int numVisibleColumns,
                                  bool alignToRight) {
            if (CompModSwitches.DGRelationShpRowPaint.TraceVerbose) Debug.WriteLine("Painting row " + RowNumber.ToString() + " with bounds " + bounds.ToString());
            int bWidth = this.dgTable.BorderWidth;

            // paint the data cells
            Rectangle dataBounds = bounds;
            dataBounds.Height = base.Height - bWidth;
            int dataWidth = PaintData(g, dataBounds, firstVisibleColumn, numVisibleColumns, alignToRight);
            int dataWidthOffsetted = dataWidth + bounds.X - trueRowBounds.X;

            dataBounds.Offset(0, bWidth);       // use bWidth, not 1
            if (bWidth > 0)
                PaintBottomBorder(g, dataBounds, dataWidth, bWidth, alignToRight);

            if (expanded && this.dgTable.RelationsList.Count > 0) {
                // paint the relationships
                Rectangle relationBounds = new Rectangle(trueRowBounds.X,
                                                         dataBounds.Bottom,
                                                         trueRowBounds.Width,
                                                         trueRowBounds.Height - dataBounds.Height - 2 * bWidth);
                PaintRelations(g, relationBounds, trueRowBounds, dataWidthOffsetted,
                               firstVisibleColumn, numVisibleColumns, alignToRight);
                relationBounds.Height += 1;
                if (bWidth > 0)
                    PaintBottomBorder(g, relationBounds, dataWidthOffsetted, bWidth, alignToRight);
            }

            return dataWidth;
        }

        protected override void PaintCellContents(Graphics g, Rectangle cellBounds, DataGridColumnStyle column,
                                                  Brush backBr, Brush foreBrush, bool alignToRight) {
            CurrencyManager listManager = DataGrid.ListManager;

            // painting the error..
            //
            string errString = String.Empty;
            Rectangle bounds = cellBounds;
            object errInfo = DataGrid.ListManager[this.number];
            if (errInfo is IDataErrorInfo)
                errString = ((IDataErrorInfo) errInfo)[column.PropertyDescriptor.Name];

            if (errString != null && !errString.Equals(String.Empty)) {
                Bitmap bmp = GetErrorBitmap();
                Rectangle errRect;
                lock (bmp) {
                    errRect = PaintIcon(g, bounds, true, alignToRight, bmp, backBr);
                }
                // paint the errors correctly when RTL = true
                if (alignToRight)
                    bounds.Width -= errRect.Width + xOffset;
                else
                    bounds.X += errRect.Width + xOffset;
                DataGrid.ToolTipProvider.AddToolTip(errString, (IntPtr)(DataGrid.ToolTipId ++), errRect);
            }

            column.Paint(g, bounds, listManager, this.RowNumber, backBr, foreBrush, alignToRight);
        }

        public override void PaintHeader(Graphics g, Rectangle bounds, bool alignToRight, bool isDirty) {

            DataGrid grid = this.DataGrid;

            Rectangle insideBounds = bounds;

            if (!grid.FlatMode) {
                ControlPaint.DrawBorder3D(g, insideBounds, Border3DStyle.RaisedInner);
                insideBounds.Inflate(-1,-1);
            }

            if (this.dgTable.IsDefault)
                PaintHeaderInside(g, insideBounds, this.DataGrid.HeaderBackBrush, alignToRight, isDirty);
            else
                PaintHeaderInside(g, insideBounds, this.dgTable.HeaderBackBrush, alignToRight, isDirty);
        }

        public void PaintHeaderInside(Graphics g, Rectangle bounds, Brush backBr, bool alignToRight) {
            PaintHeaderInside(g, bounds, backBr, alignToRight, false);
        }

        public void PaintHeaderInside(Graphics g, Rectangle bounds, Brush backBr, bool alignToRight, bool isDirty) {
            // paint the row header
            bool paintPlusMinus = dgTable.RelationsList.Count > 0 && dgTable.DataGrid.AllowNavigation;
            int rowHeaderBoundsX = MirrorRectangle(bounds.X,
                                                   bounds.Width - (paintPlusMinus ? expandoBoxWidth : 0),
                                                   bounds, alignToRight);

            if (!alignToRight) Debug.Assert(bounds.X == rowHeaderBoundsX, "what's up doc?");

            Rectangle rowHeaderBounds = new Rectangle(rowHeaderBoundsX,
                                                      bounds.Y,
                                                      bounds.Width - (paintPlusMinus ? expandoBoxWidth : 0),
                                                      bounds.Height);

            base.PaintHeader(g, rowHeaderBounds, alignToRight, isDirty);

            // Paint the expando on the right
            int expandoBoxX = MirrorRectangle(bounds.X + rowHeaderBounds.Width, expandoBoxWidth, bounds, alignToRight);

            if (!alignToRight) Debug.Assert(rowHeaderBounds.Right == expandoBoxX, "what's up doc?");

            Rectangle expandoBox = new Rectangle(expandoBoxX,
                                                 bounds.Y,
                                                 expandoBoxWidth,
                                                 bounds.Height);
            if (paintPlusMinus) {
                PaintPlusMinusGlyph(g, expandoBox, backBr, alignToRight);
            }

        }

        /// <include file='doc\DataGridRelationshipRow.uex' path='docs/doc[@for="DataGridRelationshipRow.PaintRelations"]/*' />
        /// <devdoc>
        ///      Paints the relationships below the data area.
        /// </devdoc>
        private void PaintRelations(Graphics g, Rectangle bounds, Rectangle trueRowBounds,
                                    int dataWidth, int firstCol, int nCols, bool alignToRight) {

            // Calculate the relationship rect.
            // relationshipRect = Rectangle.Empty;
            Rectangle relRect = GetRelationshipRect();
            //relRect.Offset(trueRowBounds.X, trueRowBounds.Y);
            relRect.X = alignToRight ? bounds.Right - relRect.Width : bounds.X;
            relRect.Y = bounds.Y;
            int paintedWidth = Math.Max(dataWidth, relRect.Width);

            // Paint the stuff to the right , or left (Bi-Di) of the relationship rect.
            Region r = g.Clip;
            g.ExcludeClip(relRect);

            g.FillRectangle(GetBackBrush(),
                            alignToRight ? bounds.Right - dataWidth : bounds.X,
                            bounds.Y,
                            dataWidth,
                            bounds.Height);

            // Paint the relations' text
            g.SetClip(bounds);

            relRect.Height -= this.dgTable.BorderWidth;     // use bWidth not 1
            g.DrawRectangle(SystemPens.ControlText, relRect.X, relRect.Y, relRect.Width - 1, relRect.Height - 1);
            relRect.Inflate(-1, -1);

            int cy = PaintRelationText(g, relRect, alignToRight);

            if (cy < relRect.Height) {
                g.FillRectangle(GetBackBrush(), relRect.X, relRect.Y + cy, relRect.Width, relRect.Height - cy);
            }

            g.Clip = r;

            // paint any exposed area to the right or to the left (BI-DI)
            if (paintedWidth < bounds.Width) {
                int bWidth;
                if (this.dgTable.IsDefault)
                    bWidth = this.DataGrid.GridLineWidth;
                else
                    bWidth = this.dgTable.GridLineWidth;
                g.FillRectangle(DataGrid.BackgroundBrush,
                                alignToRight ? bounds.X : bounds.X + paintedWidth,
                                bounds.Y,
                                bounds.Width - paintedWidth - bWidth + 1, // + 1 cause the relationship rectangle was deflated
                                bounds.Height);

                // Paint the border to the right of each cell
                if (bWidth > 0) {
                    Brush br;
                    // if the user changed the gridLineColor on the dataGrid
                    // from the defaultValue, then use that value;
                    if (this.dgTable.IsDefault)
                        br = this.DataGrid.GridLineBrush;
                    else
                        br = this.dgTable.GridLineBrush;
                    g.FillRectangle(br,
                                    alignToRight ? bounds.Right - bWidth - paintedWidth : bounds.X + paintedWidth - bWidth,
                                    bounds.Y,
                                    bWidth,
                                    bounds.Height);
                }
            }

        }

        private int PaintRelationText(Graphics g, Rectangle bounds, bool alignToRight) {
            g.FillRectangle(GetBackBrush(), bounds.X, bounds.Y, bounds.Width, System.Windows.Forms.DataGridTableStyle.relationshipSpacing);

            int relationshipHeight = this.dgTable.RelationshipHeight;
            Rectangle textBounds = new Rectangle(bounds.X, bounds.Y + System.Windows.Forms.DataGridTableStyle.relationshipSpacing,
                                                 bounds.Width,
                                                 relationshipHeight);
            int cy = System.Windows.Forms.DataGridTableStyle.relationshipSpacing;
            for (int r = 0; r < this.dgTable.RelationsList.Count; ++r) {
                if (cy > bounds.Height)
                    break;

                Brush textBrush = this.dgTable.IsDefault ? this.DataGrid.LinkBrush : this.dgTable.LinkBrush;

                Font textFont = this.DataGrid.Font;
                textBrush = this.dgTable.IsDefault ? this.DataGrid.LinkBrush : this.dgTable.LinkBrush;
                textFont = this.DataGrid.LinkFont;
                
                g.FillRectangle(GetBackBrush(), textBounds);

                StringFormat format = new StringFormat();
                if (alignToRight) {
                    format.FormatFlags |= StringFormatFlags.DirectionRightToLeft;
                    format.Alignment = StringAlignment.Far;
                }
                g.DrawString(((string)this.dgTable.RelationsList[r]), textFont, textBrush, textBounds,
                             format);
                if (r == FocusedRelation && this.number == this.DataGrid.CurrentCell.RowNumber) {
                    textBounds.Width = this.dgTable.FocusedTextWidth;
                    ControlPaint.DrawFocusRectangle(g, textBounds, ((SolidBrush)textBrush).Color, ((SolidBrush)GetBackBrush()).Color);
                    textBounds.Width = bounds.Width;
                }
                format.Dispose();

                textBounds.Y += relationshipHeight;
                cy += textBounds.Height;
            }
            return cy;
        }

        /// <include file='doc\DataGridRelationshipRow.uex' path='docs/doc[@for="DataGridRelationshipRow.PaintPlusMinusGlyph"]/*' />
        /// <internalonly/>
        private void PaintPlusMinusGlyph(Graphics g, Rectangle bounds, Brush backBr, bool alignToRight) {
            if (CompModSwitches.DGRelationShpRowPaint.TraceVerbose) Debug.WriteLine("PlusMinusGlyph painting in bounds    -> " + bounds.ToString());
            Rectangle outline = GetOutlineRect(bounds.X, bounds.Y);

            outline = Rectangle.Intersect(bounds, outline);
            if (outline.IsEmpty)
                return;

            g.FillRectangle(backBr, bounds);

            if (CompModSwitches.DGRelationShpRowPaint.TraceVerbose) Debug.WriteLine("Painting PlusMinusGlyph with outline -> " + outline.ToString());
            // draw the +/- box
            Pen drawPen = this.dgTable.IsDefault ? this.DataGrid.HeaderForePen : this.dgTable.HeaderForePen;
            g.DrawRectangle(drawPen, outline.X, outline.Y, outline.Width - 1, outline.Height - 1);

            int indent = 2;
            // draw the -
            g.DrawLine(drawPen,
                       outline.X + indent, outline.Y + outline.Width / 2,
                       outline.Right - indent - 1, outline.Y + outline.Width/2);        // -1 on the y coordinate

            if (!expanded) {
                // draw the vertical line to make +
                g.DrawLine(drawPen,
                           outline.X + outline.Height/2, outline.Y + indent,
                           outline.X + outline.Height/2, outline.Bottom - indent - 1); // -1... hinting
            }
            else {
                Point[] points = new Point[3];
                points[0] = new Point(outline.X + outline.Height/2, outline.Bottom);

                points[1] = new Point(points[0].X, bounds.Y + 2*indent + base.Height);

                points[2] = new Point(alignToRight ? bounds.X : bounds.Right,
                                      points[1].Y);
                g.DrawLines(drawPen, points);
            }
        }

        private int RelationFromXY(int x, int y) {
            Rectangle relRect = GetRelationshipRectWithMirroring();

            if (relRect.Contains(x, y)) {
                return RelationFromY(y);
            }
            return -1;
        }

        private int RelationFromY(int y) {
            int relation = -1;
            int relationshipHeight = this.dgTable.RelationshipHeight;
            Rectangle relRect = GetRelationshipRect();
            int cy = base.Height - this.dgTable.BorderWidth + System.Windows.Forms.DataGridTableStyle.relationshipSpacing;
            while (cy < relRect.Bottom) {
                if (cy > y)
                    break;
                cy += relationshipHeight;
                relation++;
            }
            if (relation >= this.dgTable.RelationsList.Count)
                return -1;
            return relation;
        }

        // given the relRect and the rowHeader, this function will return the 
        // X coordinate of the relationship rectangle as it should appear on the screen
        private int MirrorRelationshipRectangle(Rectangle relRect, Rectangle rowHeader, bool alignToRight) {
            if (alignToRight)
                return rowHeader.X - relRect.Width;
            else
                return relRect.X;
           
        }

        // given the X and Width of a rectangle R1 contained in rect, 
        // this will return the X coordinate of the rectangle that corresponds to R1 in Bi-Di transformation
        private int MirrorRectangle(int x, int width, Rectangle rect, bool alignToRight) {
            if (alignToRight)
                return rect.Right + rect.X - width - x;
            else
                return x;
        }

        [ComVisible(true)]                                               
        protected class DataGridRelationshipRowAccessibleObject : DataGridRowAccessibleObject {
            public DataGridRelationshipRowAccessibleObject(DataGridRow owner) : base(owner) {
            }


            protected override void AddChildAccessibleObjects(IList children) {
                base.AddChildAccessibleObjects(children);
                DataGridRelationshipRow row = (DataGridRelationshipRow)Owner;
                if (row.dgTable.RelationsList!= null) {
                    for (int i=0; i<row.dgTable.RelationsList.Count; i++) {
                        children.Add(new DataGridRelationshipAccessibleObject(row, i));
                    }
                }
            }

            private DataGridRelationshipRow Row {
                get {
                    return (DataGridRelationshipRow)Owner;
                }
            }

            public override string DefaultAction {
                get {
                    if (Row.dgTable.RelationsList.Count > 0) {
                        if (Row.Expanded) {
                            return SR.GetString(SR.AccDGCollapse);
                        }
                        else {
                            return SR.GetString(SR.AccDGExpand);
                        }
                    }
                    return null;
                }
            }

            public override AccessibleStates State {
                get {
                    AccessibleStates state = base.State;
                    if (Row.dgTable.RelationsList.Count > 0) {
                        if (((DataGridRelationshipRow)Owner).Expanded) {
                            state |= AccessibleStates.Expanded;
                        }
                        else {
                            state |= AccessibleStates.Collapsed;
                        }
                    }
                    return state;
                }
            }

            public override void DoDefaultAction() {
                if (Row.dgTable.RelationsList.Count > 0) {
                    ((DataGridRelationshipRow)Owner).Expanded = !((DataGridRelationshipRow)Owner).Expanded;
                }
            }

            public override AccessibleObject GetFocused() {
                DataGridRelationshipRow row = (DataGridRelationshipRow)Owner;
                int focusRel = row.dgTable.FocusedRelation;
                if (focusRel == -1) {
                    return base.GetFocused();
                }
                else {
                    return GetChild(GetChildCount() - row.dgTable.RelationsList.Count + focusRel);
                }
            }
        }

        [ComVisible(true)]
        protected class DataGridRelationshipAccessibleObject : AccessibleObject {
            DataGridRelationshipRow owner = null;
            int relationship;

            public DataGridRelationshipAccessibleObject(DataGridRelationshipRow owner, int relationship) : base() {
                Debug.Assert(owner != null, "DataGridRelationshipAccessibleObject must have a valid owner DataGridRow");
                this.owner = owner;
                this.relationship = relationship;
            }

            public override Rectangle Bounds {
                get {
                    Rectangle rowBounds = DataGrid.GetRowBounds(owner);

                    Rectangle bounds = owner.Expanded ? owner.GetRelationshipRectWithMirroring() : Rectangle.Empty;
                    bounds.Y += owner.dgTable.RelationshipHeight * relationship;
                    bounds.Height = owner.Expanded ? owner.dgTable.RelationshipHeight : 0;      // when the row is collapsed the height of the relationship object should be 0
                    // GetRelationshipRectWithMirroring will use the row headers width
                    if (!owner.Expanded)
                        bounds.X += rowBounds.X;
                    bounds.Y += rowBounds.Y;

                    return owner.DataGrid.RectangleToScreen(bounds);
                }
            }

            public override string Name {
                get {
                    return (string)owner.dgTable.RelationsList[relationship];
                }
            }

            protected DataGridRelationshipRow Owner {
                get {
                    return owner;
                }
            }

            public override AccessibleObject Parent {
                get {
                    return owner.AccessibleObject;
                }
            }

            protected DataGrid DataGrid {
                get {
                    return owner.DataGrid;
                }
            }

            public override AccessibleRole Role {
                get {
                    return AccessibleRole.Link;
                }
            }

            public override AccessibleStates State {
                get {
                    AccessibleStates state = AccessibleStates.Selectable 
                        | AccessibleStates.Focusable 
                        | AccessibleStates.Linked;

                    if (!owner.Expanded) {
                        state |= AccessibleStates.Invisible;
                    }

                    if (DataGrid.Focused && Owner.dgTable.FocusedRelation == relationship) {
                        state |= AccessibleStates.Focused;
                    }

                    return state;
                }
            }

            public override string Value {
                get {
                    return (string)owner.dgTable.RelationsList[relationship];
                }
                set {
                    // not supported
                }
            }

            public override string DefaultAction {
                get {
                    return SR.GetString(SR.AccDGNavigate);
                }
            }

            public override void DoDefaultAction() {
                ((DataGridRelationshipRow)Owner).Expanded = true;
                owner.FocusedRelation = -1;
                DataGrid.NavigateTo((string)owner.dgTable.RelationsList[relationship], owner, true);
            }

            /// <include file='doc\DataGridRelationshipRow.uex' path='docs/doc[@for="DataGridRelationshipRow.DataGridRelationshipAccessibleObject.Navigate"]/*' />
            /// <devdoc>
            ///      Navigate to the next or previous grid entry.
            /// </devdoc>
            public override AccessibleObject Navigate(AccessibleNavigation navdir) {
                switch (navdir) {
                    case AccessibleNavigation.Right:
                    case AccessibleNavigation.Next:
                    case AccessibleNavigation.Down:
                        if (relationship + 1 < owner.dgTable.RelationsList.Count) {
                            return Parent.GetChild(Parent.GetChildCount() - owner.dgTable.RelationsList.Count + relationship + 1);
                        }
                        break;
                    case AccessibleNavigation.Up:
                    case AccessibleNavigation.Left:
                    case AccessibleNavigation.Previous:
                        if (relationship > 0) {
                            return Parent.GetChild(Parent.GetChildCount() - owner.dgTable.RelationsList.Count + relationship - 1);
                        }
                        break;
                }

                return null;

            }

            public override void Select(AccessibleSelection flags) {
                // Focus the PropertyGridView window
                //
                if ( (flags & AccessibleSelection.TakeFocus) == AccessibleSelection.TakeFocus) {
                    DataGrid.Focus();
                }

                if ( (flags & AccessibleSelection.TakeSelection) == AccessibleSelection.TakeSelection) {
                    Owner.FocusedRelation = relationship;
                }
            }

        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\datagridstate.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGridState.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Text;
    using System.Runtime.InteropServices;
    using System.Windows.Forms;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;

    /// <include file='doc\DataGridState.uex' path='docs/doc[@for="DataGridState"]/*' />
    /// <devdoc>
    ///      Encapsulates the state of a DataGrid that changes when the
    ///      user navigates back and forth through ADO.NET data relations.
    /// </devdoc>
    internal sealed class DataGridState : ICloneable {
        // fields
        //
        public object DataSource = null;
        public string DataMember = null;
        public CurrencyManager ListManager = null;
        public DataGridRow[] DataGridRows    = new DataGridRow[0];
        public DataGrid DataGrid;
        public int DataGridRowsLength = 0;
        public GridColumnStylesCollection GridColumnStyles = null;

        public int           FirstVisibleRow = 0;
        public int           FirstVisibleCol = 0;

        public int           CurrentRow      = 0;
        public int           CurrentCol      = 0;

        public DataGridRow   LinkingRow      = null;
        AccessibleObject         parentRowAccessibleObject;

        public DataGridState() {
        }

        public DataGridState(DataGrid dataGrid) {
            PushState(dataGrid);
        }
        
        internal AccessibleObject ParentRowAccessibleObject {
            get {
                if (parentRowAccessibleObject == null) {
                    parentRowAccessibleObject = new DataGridStateParentRowAccessibleObject(this);
                }
                return parentRowAccessibleObject;
            }
        }

        // methods
        //

        public object Clone() {
            DataGridState dgs = new DataGridState();
            dgs.DataGridRows = DataGridRows;
            dgs.DataSource = DataSource;
            dgs.DataMember = DataMember;
            dgs.FirstVisibleRow = FirstVisibleRow;
            dgs.FirstVisibleCol = FirstVisibleCol;
            dgs.CurrentRow = CurrentRow;
            dgs.CurrentCol = CurrentCol;
            dgs.GridColumnStyles = GridColumnStyles;
            dgs.ListManager = ListManager;
            dgs.DataGrid = DataGrid;
            return dgs;
        }

        /// <include file='doc\DataGridState.uex' path='docs/doc[@for="DataGridState.PushState"]/*' />
        /// <devdoc>
        ///      Called by a DataGrid when it wishes to preserve its
        ///      transient state in the current DataGridState object.
        /// </devdoc>
        public void PushState(DataGrid dataGrid) {
            this.DataSource = dataGrid.DataSource;
            this.DataMember = dataGrid.DataMember;
            this.DataGrid = dataGrid;
            this.DataGridRows = dataGrid.DataGridRows;
            this.DataGridRowsLength = dataGrid.DataGridRowsLength;
            this.FirstVisibleRow = dataGrid.firstVisibleRow;
            this.FirstVisibleCol = dataGrid.firstVisibleCol;
            this.CurrentRow = dataGrid.currentRow;
            this.GridColumnStyles = new GridColumnStylesCollection(dataGrid.myGridTable);
            
            this.GridColumnStyles.Clear();
            foreach(DataGridColumnStyle style in dataGrid.myGridTable.GridColumnStyles) {
                this.GridColumnStyles.Add(style);
            }
            
            this.ListManager = dataGrid.ListManager;
            this.ListManager.ItemChanged += new ItemChangedEventHandler(DataSource_Changed);
            this.ListManager.MetaDataChanged += new EventHandler(DataSource_MetaDataChanged);
            this.CurrentCol = dataGrid.currentCol;
        }

        // this is needed so that the parent rows will remove notification from the list
        // when the datagridstate is no longer needed;
        public void RemoveChangeNotification() {
            this.ListManager.ItemChanged -= new ItemChangedEventHandler(DataSource_Changed);
            this.ListManager.MetaDataChanged -= new EventHandler(DataSource_MetaDataChanged);
        }

        /// <include file='doc\DataGridState.uex' path='docs/doc[@for="DataGridState.PullState"]/*' />
        /// <devdoc>
        ///      Called by a grid when it wishes to match its transient
        ///      state with the current DataGridState object.
        /// </devdoc>
        public void PullState(DataGrid dataGrid, bool createColumn) {
            // dataGrid.DataSource = DataSource;
            // dataGrid.DataMember = DataMember;
            dataGrid.Set_ListManager(DataSource, DataMember, true, createColumn);   // true for forcing new listManager,

            /*
            if (DataSource.Table.ParentRelations.Count > 0)
                dataGrid.PopulateColumns();
            */

            dataGrid.firstVisibleRow = FirstVisibleRow;
            dataGrid.firstVisibleCol = FirstVisibleCol;
            dataGrid.currentRow = CurrentRow;
            dataGrid.currentCol = CurrentCol;
            dataGrid.SetDataGridRows(DataGridRows, DataGridRowsLength);
        }

        private void DataSource_Changed(object sender, ItemChangedEventArgs e) {
            if (this.DataGrid != null)
                DataGrid.ParentRowsDataChanged();
        }

        private void DataSource_MetaDataChanged(object sender, EventArgs e) {
            if (this.DataGrid != null)
                DataGrid.ParentRowsDataChanged();
        }


        [ComVisible(true)]
        internal class DataGridStateParentRowAccessibleObject : AccessibleObject {
            DataGridState owner = null;

            public DataGridStateParentRowAccessibleObject(DataGridState owner) : base() {
                Debug.Assert(owner != null, "DataGridRowAccessibleObject must have a valid owner DataGridRow");
                this.owner = owner;
            }

            public override Rectangle Bounds {
                get {
                    DataGridParentRows dataGridParentRows = ((DataGridParentRows.DataGridParentRowsAccessibleObject)this.Parent).Owner;
                    DataGrid g = owner.LinkingRow.DataGrid;
                    Rectangle r = dataGridParentRows.GetBoundsForDataGridStateAccesibility(owner);
                    r.Y += g.ParentRowsBounds.Y;
                    return g.RectangleToScreen(r);
                }
            }

            public override string Name {
                get {
                    return SR.GetString(SR.AccDGParentRow);
                }
            }

            public override AccessibleObject Parent {
                get {
                    return owner.LinkingRow.DataGrid.ParentRowsAccessibleObject;
                }
            }

            public override AccessibleRole Role {
                get {
                    return AccessibleRole.ListItem;
                }
            }

            public override string Value {
                get {
                    StringBuilder sb = new StringBuilder();

                    CurrencyManager source = (CurrencyManager)owner.LinkingRow.DataGrid.BindingContext[owner.DataSource, owner.DataMember];
                    int row = owner.LinkingRow.RowNumber;

                    sb.Append(owner.ListManager.GetListName());
                    sb.Append(": ");

                    bool needComma = false;
                    foreach (DataGridColumnStyle col in owner.GridColumnStyles) {
                        if (needComma) {
                            sb.Append(", ");
                        }

                        string colName = col.HeaderText;
                        string cellValue = col.PropertyDescriptor.Converter.ConvertToString(col.PropertyDescriptor.GetValue(source[row]));
                        sb.Append(colName);
                        sb.Append(": ");
                        sb.Append(cellValue);
                        needComma = true;
                    }

                    return sb.ToString();
                }
            }

            /// <include file='doc\DataGridState.uex' path='docs/doc[@for="DataGridState.DataGridStateParentRowAccessibleObject.Navigate"]/*' />
            /// <devdoc>
            ///      Navigate to the next or previous grid entry.
            /// </devdoc>
            public override AccessibleObject Navigate(AccessibleNavigation navdir) {
                DataGridParentRows.DataGridParentRowsAccessibleObject parentAcc = (DataGridParentRows.DataGridParentRowsAccessibleObject)Parent;

                switch (navdir) {
                    case AccessibleNavigation.Down:
                    case AccessibleNavigation.Right:
                    case AccessibleNavigation.Next:
                        return parentAcc.GetNext(this);
                    case AccessibleNavigation.Up:
                    case AccessibleNavigation.Left:
                    case AccessibleNavigation.Previous:
                        return parentAcc.GetPrev(this);
                }

                return null;

            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\datagridparentrows.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGridParentRows.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    using System.Text;
    using System.Runtime.Remoting;

    using System;
    using System.Collections;
    
    using System.Windows.Forms;
    
    using System.ComponentModel;
    using System.Drawing;
    using System.Drawing.Imaging;
    using Microsoft.Win32;
    
    using System.Runtime.InteropServices;
    using System.Diagnostics;

    internal class DataGridParentRows {
        // siting
        //
        private DataGrid dataGrid;

        // ui
        //
        // private Color backColor = DataGrid.defaultParentRowsBackColor;
        // private Color foreColor = DataGrid.defaultParentRowsForeColor;

        private SolidBrush backBrush = DataGrid.DefaultParentRowsBackBrush;
        private SolidBrush foreBrush = DataGrid.DefaultParentRowsForeBrush;

        private int borderWidth = 1;
        // private Color borderColor = SystemColors.WindowFrame;
        private Brush borderBrush = new SolidBrush(SystemColors.WindowFrame);

        private static Bitmap rightArrow = null;
        private static Bitmap leftArrow = null;

        private ColorMap[] colorMap = new ColorMap[] {new ColorMap()};

        // private bool gridLineDots = false;
        // private Color gridLineColor = SystemColors.Control;
        // private Brush gridLineBrush = SystemBrushes.Control;
        private Pen gridLinePen = SystemPens.Control;

        private int totalHeight = 0;
        private int textRegionHeight = 0;


        // now that we have left and right arrows, we also have layout
        private Layout layout = new Layout();

        // mouse info
        //
        // private bool overLeftArrow = false;
        // private bool overRightArrow = false;
        private bool downLeftArrow = false;
        private bool downRightArrow = false;

        // a horizOffset of 0 means that the layout for the parent
        // rows is left aligned.
        // a horizOffset of 1 means that the leftmost unit of information ( let it be a 
        // table name, a column name or a column value ) is not visible.
        // a horizOffset of 2 means that the leftmost 2 units of information are not visible, and so on
        //
        private int horizOffset = 0;

        // storage for parent row states
        //
        private ArrayList parents = new ArrayList();
        private int parentsCount = 0;
        private ArrayList rowHeights = new ArrayList();
        AccessibleObject accessibleObject;

        internal DataGridParentRows(DataGrid dataGrid) {
            this.colorMap[0].OldColor = Color.Black;
            this.dataGrid = dataGrid;
            // UpdateGridLinePen();
        }

        // =------------------------------------------------------------------
        // =        Properties
        // =------------------------------------------------------------------

        public AccessibleObject AccessibleObject {
            get {
                if (accessibleObject == null) {
                    accessibleObject = new DataGridParentRowsAccessibleObject(this);
                }
                return accessibleObject;
            }
        }

        internal Color BackColor {
            get {
                return backBrush.Color;
            }
            set {
                if (value.IsEmpty)
                    throw new ArgumentException(SR.GetString(SR.DataGridEmptyColor, "Parent Rows BackColor"));
                if (value != backBrush.Color) {
                    backBrush = new SolidBrush(value);
                    Invalidate();
                }
            }
        }

        internal SolidBrush BackBrush {
            get {
                return backBrush;
            }
            set {
                if (value != backBrush) {
                    CheckNull(value, "BackBrush");
                    backBrush = value;
                    Invalidate();
                }
            }
        }

        internal SolidBrush ForeBrush {
            get {
                return foreBrush;
            }
            set {
                if (value != foreBrush) {
                    CheckNull(value, "BackBrush");
                    foreBrush = value;
                    Invalidate();
                }
            }
        }

        // since the layout of the parentRows is computed on every paint message,
        // we can actually return true ClientRectangle coordinates
        internal Rectangle GetBoundsForDataGridStateAccesibility(DataGridState dgs) {
            Rectangle ret = Rectangle.Empty;
            int rectY = 0;
            for (int i = 0; i < parentsCount; i++) {
                int height = (int) rowHeights[i];
                if (parents[i] == dgs) {
                    ret.X = layout.leftArrow.IsEmpty ? layout.data.X : layout.leftArrow.Right;
                    ret.Height = height;
                    ret.Y = rectY;
                    ret.Width = layout.data.Width;
                    return ret;
                }
                rectY += height;
            }
            return ret;
        }

        /*
        internal Color BorderColor {
            get {
                return borderColor;
            }
            set {
                if (value != borderColor) {
                    borderColor = value;
                    Invalidate();
                }
            }
        }
        */

        internal Brush BorderBrush {
            get {
                return borderBrush;
            }
            set {
                if (value != borderBrush) {
                    borderBrush = value;
                    Invalidate();
                }
            }
        }

        /*
        internal Brush GridLineBrush {
            get {
                return gridLineBrush;
            }
            set {
                if (value != gridLineBrush) {
                    gridLineBrush = value;
                    UpdateGridLinePen();
                    Invalidate();
                }
            }
        }

        internal bool GridLineDots {
            get {
                return gridLineDots;
            }
            set {
                if (gridLineDots != value) {
                    gridLineDots = value;
                    UpdateGridLinePen();
                    Invalidate();
                }
            }
        }
        */

        internal int Height {
            get {
                return totalHeight;
            }
        }

        internal Color ForeColor {
            get {
                return foreBrush.Color;
            }
            set {
                if (value.IsEmpty)
                    throw new ArgumentException(SR.GetString(SR.DataGridEmptyColor, "Parent Rows ForeColor"));
                if (value != foreBrush.Color) {
                    foreBrush = new SolidBrush(value);
                    Invalidate();
                }
            }
        }

        internal bool Visible {
            get {
                return dataGrid.ParentRowsVisible;
            }
            set {
                dataGrid.ParentRowsVisible = value;
            }
        }

        // =------------------------------------------------------------------
        // =        Methods
        // =------------------------------------------------------------------

        /// <include file='doc\DataGridParentRows.uex' path='docs/doc[@for="DataGridParentRows.AddParent"]/*' />
        /// <devdoc>
        ///      Adds a DataGridState object to the top of the list of parents.
        /// </devdoc>
        internal void AddParent(DataGridState dgs) {
            CurrencyManager childDataSource = (CurrencyManager) dataGrid.BindingContext[dgs.DataSource, dgs.DataMember];
            parents.Add(dgs);
            SetParentCount(parentsCount + 1);
            Debug.Assert(GetTopParent() != null, "we should have a parent at least");
        }

        internal void Clear() {
            for (int i = 0; i < parents.Count; i++) {
                DataGridState dgs = parents[i] as DataGridState;
                dgs.RemoveChangeNotification();
            }
            parents.Clear();
            rowHeights.Clear();
            totalHeight = 0;
            SetParentCount(0);
        }

        internal void SetParentCount(int count) {
            parentsCount = count;
            dataGrid.Caption.BackButtonVisible = (parentsCount > 0) && (dataGrid.AllowNavigation);
        }

        internal void CheckNull(object value, string propName) {
            if (value == null)
                throw new ArgumentNullException(propName);
        }

        internal void Dispose() {
            gridLinePen.Dispose();
        }

        /// <include file='doc\DataGridParentRows.uex' path='docs/doc[@for="DataGridParentRows.GetTopParent"]/*' />
        /// <devdoc>
        ///      Retrieves the top most parent in the list of parents.
        /// </devdoc>
        internal DataGridState GetTopParent() {
            if (parentsCount < 1) {
                return null;
            }
            return(DataGridState)(((ICloneable)(parents[parentsCount-1])).Clone());
        }

        /// <include file='doc\DataGridParentRows.uex' path='docs/doc[@for="DataGridParentRows.IsEmpty"]/*' />
        /// <devdoc>
        ///      Determines if there are any parent rows contained in this object.
        /// </devdoc>
        internal bool IsEmpty() {
            return parentsCount == 0;
        }

        /// <include file='doc\DataGridParentRows.uex' path='docs/doc[@for="DataGridParentRows.PopTop"]/*' />
        /// <devdoc>
        ///      Similar to GetTopParent() but also removes it.
        /// </devdoc>
        internal DataGridState PopTop() {
            if (parentsCount < 1) {
                return null;
            }

            SetParentCount(parentsCount - 1);
            DataGridState ret = (DataGridState)parents[parentsCount];            
            ret.RemoveChangeNotification();
            parents.RemoveAt(parentsCount);           
            return ret;
        }

        internal void Invalidate() {
            if (dataGrid != null)
                dataGrid.InvalidateParentRows();
        }

        internal void InvalidateRect(Rectangle rect)
        {
            if (dataGrid != null)
            {
                Rectangle r = new Rectangle(rect.X, rect.Y, rect.Width + borderWidth, rect.Height + borderWidth);
                dataGrid.InvalidateParentRowsRect(r);
            }
        }

        // called from DataGrid::OnLayout
        internal void OnLayout() {
            if (parentsCount == rowHeights.Count)
                return;

            int height = 0;
            if (totalHeight == 0) {
                totalHeight += 2 * borderWidth;
            }

            // figure out how tall each row's text will be
            //
            textRegionHeight = (int)dataGrid.Font.Height + 2;

            // make the height of the Column.Font count for the height 
            // of the parentRows;
            //
            // if the user wants to programatically
            // navigate to a relation in the constructor of the form
            // ( ie, when the form does not process PerformLayout )
            // the grid will receive an OnLayout message when there is more
            // than one parent in the grid
            if (parentsCount > rowHeights.Count) {
                Debug.Assert(parentsCount == rowHeights.Count + 1 || rowHeights.Count == 0, "see bug 82808 for more info, or the comment above");
                int rowHeightsCount = this.rowHeights.Count;
                for (int i = rowHeightsCount; i < parentsCount; i++) {
                    DataGridState dgs = (DataGridState) parents[i];
                    GridColumnStylesCollection cols = dgs.GridColumnStyles;

                    int colsHeight = 0;

                    for (int j=0; j<cols.Count; j++) {
                        colsHeight = Math.Max(colsHeight, cols[j].GetMinimumHeight());
                    }
                    height = Math.Max(colsHeight, textRegionHeight);

                    // the height of the bottom border
                    height ++;
                    rowHeights.Add(height);

                    totalHeight += height;
                }
            } else {
                Debug.Assert(parentsCount == rowHeights.Count - 1, "we do layout only for push/popTop");
                if (parentsCount == 0)
                    totalHeight = 0;
                else
                    totalHeight -= (int) rowHeights[rowHeights.Count-1];
                rowHeights.RemoveAt(rowHeights.Count - 1);
            }
        }

        private int CellCount() {
            int cellCount = 0;
            cellCount = ColsCount();

            if (dataGrid.ParentRowsLabelStyle == DataGridParentRowsLabelStyle.TableName ||
                dataGrid.ParentRowsLabelStyle == DataGridParentRowsLabelStyle.Both) {
                cellCount ++;
            }

            return cellCount;
        }

        private void ResetMouseInfo()
        {
            // overLeftArrow = false;
            // overRightArrow = false;
            downLeftArrow = false;
            downRightArrow = false;
        }

        private void LeftArrowClick(int cellCount) {
            if (horizOffset > 0) {
                ResetMouseInfo();
                horizOffset -= 1;
                Invalidate();
            }
            else
            {
                ResetMouseInfo();
                InvalidateRect(layout.leftArrow);
            }
        }

        private void RightArrowClick(int cellCount) {
            if (horizOffset < cellCount - 1) {
                ResetMouseInfo();
                horizOffset += 1;
                Invalidate();
            }
            else
            {
                ResetMouseInfo();
                InvalidateRect(layout.rightArrow);
            }
        }

        // the only mouse clicks that are handled are
        // the mouse clicks on the LeftArrow and RightArrow
        //
        internal void OnMouseDown(int x, int y, bool alignToRight) {
            if (layout.rightArrow.IsEmpty) {
                Debug.Assert(layout.leftArrow.IsEmpty, "we can't have the leftArrow w/o the rightArrow");
                return;
            }

            int cellCount = CellCount();

            if (layout.rightArrow.Contains(x,y)) {
                // draw a nice sunken border around the right arrow area
                // we want to keep a cell on the screen

                downRightArrow = true;

                if (alignToRight)
                    LeftArrowClick(cellCount);
                else
                    RightArrowClick(cellCount);
            }
            else if (layout.leftArrow.Contains(x,y)) {
                downLeftArrow = true;

                if (alignToRight)
                    RightArrowClick(cellCount);
                else
                    LeftArrowClick(cellCount);
            }
            else 
            {
                if (downLeftArrow)
                {
                    downLeftArrow = false;
                    InvalidateRect(layout.leftArrow);
                }
                if (downRightArrow)
                {
                    downRightArrow = false;
                    InvalidateRect(layout.rightArrow);
                }
            }
        }

        internal void OnMouseLeave() {
            if (downLeftArrow)
            {
                downLeftArrow = false;
                InvalidateRect(layout.leftArrow);
            }
            if (downRightArrow)
            {
                downRightArrow = false;
                InvalidateRect(layout.rightArrow);
            }
        }

        internal void OnMouseMove(int x, int y) {
            /*
            if (!layout.leftArrow.IsEmpty && layout.leftArrow.Contains(x,y))
            {
                ResetMouseInfo();
                overLeftArrow = true;
                InvalidateRect(layout.leftArrow);
                return;
            }
            if (!layout.rightArrow.IsEmpty && layout.rightArrow.Contains(x,y))
            {
                ResetMouseInfo();
                overRightArrow = true;
                InvalidateRect(layout.rightArrow);
                return;
            }
            */

            if (downLeftArrow)
            {
                downLeftArrow = false;
                InvalidateRect(layout.leftArrow);
            }
            if (downRightArrow)
            {
                downRightArrow = false;
                InvalidateRect(layout.rightArrow);
            }
        }

        internal void OnMouseUp(int x, int y) {
            ResetMouseInfo();
            if (!layout.rightArrow.IsEmpty && layout.rightArrow.Contains(x,y))
            {
                InvalidateRect(layout.rightArrow);
                return;
            }
            if (!layout.leftArrow.IsEmpty && layout.leftArrow.Contains(x,y))
            {
                InvalidateRect(layout.leftArrow);
                return;
            }
        }

        internal void OnResize(Rectangle oldBounds) {
            Invalidate();
            // TODO: implement optimized invalidation code for
            //   : painting the right border correctly on resize
        }

        /// <include file='doc\DataGridParentRows.uex' path='docs/doc[@for="DataGridParentRows.Paint"]/*' />
        /// <devdoc>
        ///      Paints the parent rows
        /// </devdoc>
        internal void Paint(Graphics g, Rectangle visualbounds, bool alignRight) {
            Rectangle bounds = visualbounds;
            // Paint the border around our bounds
            if (borderWidth > 0) {
                PaintBorder(g, bounds);
                bounds.Inflate(-borderWidth, -borderWidth);
            }

            PaintParentRows(g, bounds, alignRight);
        }

        private void PaintBorder(Graphics g, Rectangle bounds) {
            Rectangle border = bounds;

            // top
            border.Height = borderWidth;
            g.FillRectangle(borderBrush, border);

            // bottom
            border.Y = bounds.Bottom - borderWidth;
            g.FillRectangle(borderBrush, border);

            // left
            border = new Rectangle(bounds.X, bounds.Y + borderWidth,
                                   borderWidth, bounds.Height - 2*borderWidth);
            g.FillRectangle(borderBrush, border);

            // right
            border.X = bounds.Right - borderWidth;
            g.FillRectangle(borderBrush, border);
        }

        // will return the width of the text box that will fit all the 
        // tables names
        private int GetTableBoxWidth(Graphics g, Font font) {
            // try to make the font BOLD
            Font textFont = font;
            try {
                textFont = new Font(font, FontStyle.Bold);
            } catch (Exception) { }
            int width = 0;
            for (int row = 0; row < parentsCount; row ++) {
                DataGridState dgs = (DataGridState) parents[row];
                // Graphics.MeasureString(...) returns different results for ": " than for " :"
                //
                string displayTableName = dgs.ListManager.GetListName() + " :";
                int size = (int) g.MeasureString(displayTableName, textFont).Width;
                width = Math.Max(size, width);
            }

            return width;
        }

        // will return the width of the text box that will
        // fit all the column names
        private int GetColBoxWidth(Graphics g, Font font, int colNum) {
            int width = 0;

            for (int  row = 0; row < parentsCount; row ++) {
                DataGridState dgs = (DataGridState) parents[row];
                GridColumnStylesCollection columns = dgs.GridColumnStyles;
                if (colNum < columns.Count) {
                    // Graphics.MeasureString(...) returns different results for ": " than for " :"
                    //
                    string colName = columns[colNum].HeaderText + " :";
                    int size = (int) g.MeasureString(colName, font).Width;
                    width = Math.Max(size, width);
                }
            }

            return width;
        }


        // will return the width of the best fit for the column
        //
        private int GetColDataBoxWidth(Graphics g, int colNum) {
            int width = 0;
            for (int row = 0; row < parentsCount; row ++) {
                DataGridState dgs = (DataGridState) parents[row];
                GridColumnStylesCollection columns = dgs.GridColumnStyles;
                if (colNum < columns.Count) {
                    object value = columns[colNum].GetColumnValueAtRow((CurrencyManager) dataGrid.BindingContext[dgs.DataSource, dgs.DataMember],
                                                                        dgs.LinkingRow.RowNumber);
                    int size = columns[colNum].GetPreferredSize(g, value).Width;
                    width = Math.Max(size, width);
                }
            }
            return width;
        }

        // will return the count of the table with the largest number of columns
        private int ColsCount() {
            int colNum = 0;
            for (int row = 0; row < parentsCount; row ++) {
                DataGridState dgs = (DataGridState) parents[row];
                colNum = Math.Max(colNum, dgs.GridColumnStyles.Count);
            }
            return colNum;
        }

        // will return the total width required to paint the parentRows
        private int TotalWidth(int tableNameBoxWidth, int[] colsNameWidths, int[] colsDataWidths) {
            int totalWidth = 0;
            totalWidth += tableNameBoxWidth;
            Debug.Assert(colsNameWidths.Length == colsDataWidths.Length, "both arrays are as long as the largest column count in dgs");
            for (int i = 0; i < colsNameWidths.Length; i ++) {
                totalWidth += colsNameWidths[i];
                totalWidth += colsDataWidths[i];
            }

            // let 3 pixels in between datacolumns
            // see DonnaWa
            totalWidth += 3 * (colsNameWidths.Length - 1);
            return totalWidth;
        }

        // computes the layout for the parent rows
        //
        private void ComputeLayout(Rectangle bounds, int tableNameBoxWidth, int[] colsNameWidths, int[] colsDataWidths) {
            int totalWidth = TotalWidth(tableNameBoxWidth, colsNameWidths, colsDataWidths);
            if (totalWidth > bounds.Width) {
                layout.leftArrow = new Rectangle(bounds.X, bounds.Y, 15, bounds.Height);
                layout.data = new Rectangle(layout.leftArrow.Right, bounds.Y, bounds.Width - 30, bounds.Height);
                layout.rightArrow = new Rectangle(layout.data.Right, bounds.Y, 15, bounds.Height);
            }
            else {
                layout.data = bounds;
                layout.leftArrow = Rectangle.Empty;
                layout.rightArrow = Rectangle.Empty;
            }
        }

        private void PaintParentRows(Graphics g, Rectangle bounds, bool alignToRight) {
            // variables needed for aligning the table and column names
            int tableNameBoxWidth = 0;
            int numCols = ColsCount();
            int[] colsNameWidths = new int[numCols];
            int[] colsDataWidths = new int[numCols];

            // compute the size of the box that will contain the tableName
            //
            if (dataGrid.ParentRowsLabelStyle == DataGridParentRowsLabelStyle.TableName ||
                dataGrid.ParentRowsLabelStyle == DataGridParentRowsLabelStyle.Both) {
                tableNameBoxWidth = GetTableBoxWidth(g, dataGrid.Font);
            }

            // initialiaze the arrays that contain the column names and the column size
            //
            for (int i = 0; i < numCols; i++) {
                if (dataGrid.ParentRowsLabelStyle == DataGridParentRowsLabelStyle.ColumnName ||
                    dataGrid.ParentRowsLabelStyle == DataGridParentRowsLabelStyle.Both) {
                    colsNameWidths[i] = GetColBoxWidth(g, dataGrid.Font, i);
                }
                else {
                    colsNameWidths[i] = 0;
                }
                colsDataWidths[i] = GetColDataBoxWidth(g, i);
            }

            // compute the layout
            //
            ComputeLayout(bounds, tableNameBoxWidth, colsNameWidths, colsDataWidths);

            // paint the navigation arrows, if necessary
            //
            if (!layout.leftArrow.IsEmpty)
            {
                g.FillRectangle(BackBrush, layout.leftArrow);
                PaintLeftArrow(g, layout.leftArrow, alignToRight);
            }

            // paint the parent rows:
            //
            Rectangle rowBounds = layout.data;
            for (int row = 0; row < parentsCount; ++row) {
                rowBounds.Height = (int) rowHeights[row];
                if (rowBounds.Y > bounds.Bottom)
                    break;
                int paintedWidth = PaintRow(g, rowBounds, row, dataGrid.Font, alignToRight, tableNameBoxWidth, colsNameWidths, colsDataWidths);
                if (row == parentsCount-1)
                    break;

                // draw the grid line below
                g.DrawLine(gridLinePen, rowBounds.X, rowBounds.Bottom,
                           rowBounds.X + paintedWidth,
                           rowBounds.Bottom);
                rowBounds.Y += rowBounds.Height;
            }

            if (!layout.rightArrow.IsEmpty)
            {
                g.FillRectangle(BackBrush, layout.rightArrow);
                PaintRightArrow(g, layout.rightArrow, alignToRight);
            }
        }

        private Bitmap GetBitmap(string bitmapName, Color transparentColor) {
            Bitmap b = null;
            try {
                b = new Bitmap(typeof(DataGridParentRows), bitmapName);
                b.MakeTransparent(transparentColor);
            }
            catch (Exception e) {
                Debug.Fail("Failed to load bitmap: " + bitmapName, e.ToString());
            }
            return b;
        }

        private Bitmap GetRightArrowBitmap()
        {
            if (rightArrow == null)
                rightArrow = GetBitmap("DataGridParentRows.RightArrow.bmp", Color.White);
            return rightArrow;
        }

        private Bitmap GetLeftArrowBitmap()
        {
            if (leftArrow == null)
                leftArrow = GetBitmap("DataGridParentRows.LeftArrow.bmp", Color.White);
            return leftArrow;
        }

        private void PaintBitmap(Graphics g, Bitmap b, Rectangle bounds)
        {
            // center the bitmap in the bounds:
            int bmpX = bounds.X + (bounds.Width - b.Width) / 2;
            int bmpY = bounds.Y + (bounds.Height - b.Height) / 2;
            Rectangle bmpRect = new Rectangle(bmpX, bmpY, b.Width, b.Height);

            g.FillRectangle(BackBrush, bmpRect);

            // now draw the bitmap
            ImageAttributes attr = new ImageAttributes();
            this.colorMap[0].NewColor = this.ForeColor;
            attr.SetRemapTable(colorMap, ColorAdjustType.Bitmap);
            g.DrawImage(b, bmpRect, 0, 0, bmpRect.Width, bmpRect.Height,GraphicsUnit.Pixel, attr);
            attr.Dispose();
        }

        /*
        private void PaintOverButton(Graphics g, Rectangle bounds)
        {
        }
        */

        private void PaintDownButton(Graphics g, Rectangle bounds)
        {
            g.DrawLine(Pens.Black, bounds.X, bounds.Y, bounds.X + bounds.Width, bounds.Y);  // the top
            g.DrawLine(Pens.White, bounds.X + bounds.Width, bounds.Y, bounds.X + bounds.Width, bounds.Y + bounds.Height);  // the right side 
            g.DrawLine(Pens.White, bounds.X + bounds.Width, bounds.Y + bounds.Height, bounds.X, bounds.Y + bounds.Height);  // the right side 
            g.DrawLine(Pens.Black, bounds.X, bounds.Y + bounds.Height, bounds.X, bounds.Y);  // the left side 
        }

        private void PaintLeftArrow(Graphics g, Rectangle bounds, bool alignToRight)
        {
            Bitmap bmp = GetLeftArrowBitmap();
            // paint the border around this bitmap if this is the case
            //
            /*
            if (overLeftArrow)
            {
                Debug.Assert(!downLeftArrow, "can both of those happen?");
                PaintOverButton(g, bounds);
                layout.leftArrow.Inflate(-1,-1);
            }
            */
            if (downLeftArrow)
            {
                PaintDownButton(g, bounds);
                layout.leftArrow.Inflate(-1,-1);
                lock (bmp) {
                    PaintBitmap(g, bmp, bounds);
                }
                layout.leftArrow.Inflate(1,1);
            }
            else {
                lock (bmp) {
                    PaintBitmap(g, bmp, bounds);
                }
            }
        }

        private void PaintRightArrow(Graphics g, Rectangle bounds, bool alignToRight)
        {
            Bitmap bmp = GetRightArrowBitmap();
            // paint the border around this bitmap if this is the case
            //
            /*
            if (overRightArrow)
            {
                Debug.Assert(!downRightArrow, "can both of those happen?");
                PaintOverButton(g, bounds);
                layout.rightArrow.Inflate(-1,-1);
            }
            */
            if (downRightArrow)
            {
                PaintDownButton(g, bounds);
                layout.rightArrow.Inflate(-1,-1);
                lock (bmp) {
                    PaintBitmap(g, bmp, bounds);
                }
                layout.rightArrow.Inflate(1,1);
            }
            else {
                lock (bmp) {
                    PaintBitmap(g, bmp, bounds);
                }
            }
        }

        private int PaintRow(Graphics g, Rectangle bounds, int row, Font font, bool alignToRight,
                             int tableNameBoxWidth, int[] colsNameWidths, int[] colsDataWidths) {
            DataGridState dgs = (DataGridState) parents[row];
            Rectangle paintBounds = bounds;
            Rectangle rowBounds = bounds;
            paintBounds.Height = (int) rowHeights[row];
            rowBounds.Height = (int) rowHeights[row];

            int paintedWidth = 0;
            // used for scrolling: when paiting, we will skip horizOffset cells in the dataGrid ParentRows
            int skippedCells = 0;

            // paint the table name
            if ( dataGrid.ParentRowsLabelStyle == DataGridParentRowsLabelStyle.TableName ||
                 dataGrid.ParentRowsLabelStyle == DataGridParentRowsLabelStyle.Both) {
                if (skippedCells < horizOffset) {
                    // skip this
                    skippedCells ++;
                }
                else {
                    paintBounds.Width = Math.Min(paintBounds.Width, tableNameBoxWidth);
                    paintBounds.X = MirrorRect(bounds, paintBounds, alignToRight);
                    string displayTableName = dgs.ListManager.GetListName() + ": ";
                    PaintText(g, paintBounds, displayTableName, font, true, alignToRight);      // true is for painting bold
                    paintedWidth += paintBounds.Width;
                }
            }

            if (paintedWidth >= bounds.Width)
                return bounds.Width;        // we painted everything

            rowBounds.Width -= paintedWidth;
            rowBounds.X += alignToRight ? 0 : paintedWidth;
            paintedWidth += PaintColumns(g, rowBounds, dgs, font, alignToRight, colsNameWidths, colsDataWidths, skippedCells);

            // paint the possible space left after columns
            if (paintedWidth < bounds.Width) {
                paintBounds.X = bounds.X + paintedWidth;
                paintBounds.Width = bounds.Width - paintedWidth;
                paintBounds.X = MirrorRect(bounds, paintBounds, alignToRight);
                g.FillRectangle(BackBrush, paintBounds);
            }
            return paintedWidth;
        }

        private int PaintColumns(Graphics g, Rectangle bounds, DataGridState dgs, Font font, bool alignToRight,
                                 int[] colsNameWidths, int[] colsDataWidths, int skippedCells) {
            Rectangle paintBounds = bounds;
            Rectangle rowBounds = bounds;
            GridColumnStylesCollection cols = dgs.GridColumnStyles;
            int cx = 0;

            for (int i = 0; i < cols.Count; i ++) {
                if (cx >= bounds.Width)
                    break;

                // paint the column name, if we have to
                if (dataGrid.ParentRowsLabelStyle == DataGridParentRowsLabelStyle.ColumnName ||
                    dataGrid.ParentRowsLabelStyle == DataGridParentRowsLabelStyle.Both) {
                    if (skippedCells < horizOffset) {
                        // skip this column
                    }
                    else {
                        paintBounds.X = bounds.X + cx;
                        paintBounds.Width = Math.Min(bounds.Width - cx, colsNameWidths[i]);
                        paintBounds.X = MirrorRect(bounds, paintBounds, alignToRight);

                        string colName = cols[i].HeaderText + ": ";
                        PaintText(g, paintBounds, colName, font, false, alignToRight);      // false is for not painting bold

                        cx += paintBounds.Width;
                    }
                }

                if (cx >= bounds.Width)
                    break;

                if (skippedCells < horizOffset) {
                    // skip this cell
                    skippedCells ++;
                } else {
                    // paint the cell contents
                    paintBounds.X = bounds.X + cx;
                    paintBounds.Width = Math.Min(bounds.Width - cx, colsDataWidths[i]);
                    paintBounds.X = MirrorRect(bounds, paintBounds, alignToRight);

                    // when we paint the data grid parent rows, we want to paint the data at the position 
                    // stored in the currency manager.
                    cols[i].Paint(g, paintBounds, (CurrencyManager) dataGrid.BindingContext[dgs.DataSource, dgs.DataMember],
                                    dataGrid.BindingContext[dgs.DataSource, dgs.DataMember].Position, BackBrush, ForeBrush, alignToRight);

                    cx += paintBounds.Width;

                    // draw the line to the right (or left, according to alignRight)
                    //
                    g.DrawLine(new Pen(SystemColors.ControlDark),
                               alignToRight ? paintBounds.X : paintBounds.Right,
                               paintBounds.Y,
                               alignToRight ? paintBounds.X : paintBounds.Right,
                               paintBounds.Bottom);

                    // this is how wide the line is....
                    cx++;

                    // put 3 pixels in between columns
                    // see DonnaWa
                    //
                    if ( i < cols.Count - 1)
                    {
                        paintBounds.X = bounds.X + cx;
                        paintBounds.Width = Math.Min(bounds.Width - cx, 3);
                        paintBounds.X = MirrorRect(bounds, paintBounds, alignToRight);

                        g.FillRectangle(BackBrush, paintBounds);
                        cx += 3;
                    }
                }
            }

            return cx;
        }

        /// <include file='doc\DataGridParentRows.uex' path='docs/doc[@for="DataGridParentRows.PaintText"]/*' />
        /// <devdoc>
        ///      Draws on the screen the text. It is used only to paint the Table Name and the column Names
        ///      Returns the width of bounding rectangle that was passed in
        /// </devdoc>
        private int PaintText(Graphics g, Rectangle textBounds, string text, Font font, bool bold, bool alignToRight) {
            Font textFont = font;
            if (bold)
                try {
                    textFont = new Font(font, FontStyle.Bold);
                } catch {}
            else
                textFont = font;

            // right now, we paint the entire box, cause it will be used anyway
            g.FillRectangle(BackBrush, textBounds);
            StringFormat format = new StringFormat();
            if (alignToRight) {
                format.FormatFlags |= StringFormatFlags.DirectionRightToLeft;
                format.Alignment = StringAlignment.Far;
            }
            format.FormatFlags |= StringFormatFlags.NoWrap;
            // part 1, section 3: put the table and the column name in the 
            // parent rows at the same height as the dataGridTextBoxColumn draws the string
            //
            textBounds.Offset(0, 2);
            textBounds.Height -= 2;
            g.DrawString(text, textFont, ForeBrush, textBounds, format);
            format.Dispose();
            return textBounds.Width;

        }

        // will return the X coordinate of the containedRect mirrored within the surroundingRect
        // according to the value of alignToRight
        private int MirrorRect(Rectangle surroundingRect, Rectangle containedRect, bool alignToRight) {
            Debug.Assert(containedRect.X >= surroundingRect.X && containedRect.Right <= surroundingRect.Right, "containedRect is not contained in surroundingRect");
            if (alignToRight)
                return surroundingRect.Right - containedRect.Right + surroundingRect.X;
            else
                return containedRect.X;
        }

        private class Layout {
            public Rectangle data;
            public Rectangle leftArrow;
            public Rectangle rightArrow;

            public Layout() {
                data = Rectangle.Empty;
                leftArrow = Rectangle.Empty;
                rightArrow = Rectangle.Empty;
            }

            public override string ToString() {
                StringBuilder sb = new StringBuilder(200);
                sb.Append("ParentRows Layout: \n");
                sb.Append("data = ");
                sb.Append(data.ToString());
                sb.Append("\n leftArrow = ");
                sb.Append(leftArrow.ToString());
                sb.Append("\n rightArrow = ");
                sb.Append(rightArrow.ToString());
                sb.Append("\n");

                return sb.ToString();
            }
        }

        [ComVisible(true)]
        protected internal class DataGridParentRowsAccessibleObject : AccessibleObject {
            DataGridParentRows owner = null;

            public DataGridParentRowsAccessibleObject(DataGridParentRows owner) : base() {
                Debug.Assert(owner != null, "DataGridParentRowsAccessibleObject must have a valid owner");
                this.owner = owner;
            }

            internal DataGridParentRows Owner {
                get {
                    return owner;
                }
            }

            public override Rectangle Bounds {
                get {
                    return owner.dataGrid.RectangleToScreen(owner.dataGrid.ParentRowsBounds);
                }
            }

            public override string DefaultAction {
                get {
                    return SR.GetString(SR.AccDGNavigateBack);
                }
            }

            public override string Name {
                get {
                    return SR.GetString(SR.AccDGParentRows);
                }
            }

            public override AccessibleObject Parent {
                get {
                    return owner.dataGrid.AccessibilityObject;
                }
            }

            private DataGrid DataGrid {
                get {
                    return owner.dataGrid;
                }
            }

            public override AccessibleRole Role {
                get {
                    return AccessibleRole.List;
                }
            }

            public override AccessibleStates State {
                get {
                    AccessibleStates state = AccessibleStates.ReadOnly;

                    if (owner.parentsCount == 0) {
                        state |= AccessibleStates.Invisible;
                    }
                    if (owner.dataGrid.ParentRowsVisible) {
                        state |= AccessibleStates.Expanded;
                    }
                    else {
                        state |= AccessibleStates.Collapsed;
                    }

                    return state;
                }
            }

            public override string Value {
                get {
                    return null;
                }
            }
            
            public override void DoDefaultAction() {
                owner.dataGrid.NavigateBack();
            }

            public override AccessibleObject GetChild(int index) {
                return ((DataGridState)owner.parents[index]).ParentRowAccessibleObject;
            }

            public override int GetChildCount() {
                return owner.parentsCount;
            }

            /// <include file='doc\DataGridParentRows.uex' path='docs/doc[@for="DataGridParentRows.DataGridParentRowsAccessibleObject.GetFocused"]/*' />
            /// <devdoc>
            ///      Returns the currently focused child, if any.
            ///      Returns this if the object itself is focused.
            /// </devdoc>
            public override AccessibleObject GetFocused() {
                return null;
            }

            internal AccessibleObject GetNext(AccessibleObject child) {
                int children = GetChildCount();
                bool hit = false;

                for (int i=0; i<children; i++) {
                    if (hit) {
                        return GetChild(i);
                    }
                    if (GetChild(i) == child) {
                        hit = true;
                    }
                }

                return null;
            }

            internal AccessibleObject GetPrev(AccessibleObject child) {
                int children = GetChildCount();
                bool hit = false;

                for (int i=children-1; i>=0; i--) {
                    if (hit) {
                        return GetChild(i);
                    }
                    if (GetChild(i) == child) {
                        hit = true;
                    }
                }

                return null;
            }


            /// <include file='doc\DataGridParentRows.uex' path='docs/doc[@for="DataGridParentRows.DataGridParentRowsAccessibleObject.Navigate"]/*' />
            /// <devdoc>
            ///      Navigate to the next or previous grid entry.
            /// </devdoc>
            public override AccessibleObject Navigate(AccessibleNavigation navdir) {
                switch (navdir) {
                    case AccessibleNavigation.Right:
                    case AccessibleNavigation.Next:
                    case AccessibleNavigation.Down:
                        return Parent.GetChild(1);
                    case AccessibleNavigation.Up:
                    case AccessibleNavigation.Left:
                    case AccessibleNavigation.Previous:
                        return Parent.GetChild(GetChildCount() - 1);
                    case AccessibleNavigation.FirstChild:
                        if (GetChildCount() > 0) {
                            return GetChild(0);
                        }
                        break;
                    case AccessibleNavigation.LastChild:
                        if (GetChildCount() > 0) {
                            return GetChild(GetChildCount() - 1);
                        }
                        break;

                }

                return null;

            }

            public override void Select(AccessibleSelection flags) {
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\datagridtextbox.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGridTextBox.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms{
    using System.Runtime.Remoting;
    using System;
    using System.Security.Permissions;
    using System.Windows.Forms;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;

    /// <include file='doc\DataGridTextBox.uex' path='docs/doc[@for="DataGridTextBox"]/*' />
    /// <devdoc>
    /// <para>Represents a <see cref='System.Windows.Forms.TextBox'/> control that is hosted in a 
    /// <see cref='System.Windows.Forms.DataGridTextBoxColumn'/> .</para>
    /// </devdoc>
    [
    ToolboxItem(false),
    DesignTimeVisible(false),
    DefaultProperty("GridEditName")
    ]
    public class DataGridTextBox : TextBox {

        private bool isInEditOrNavigateMode = true;

        // only needed to signal the dataGrid that an edit
        // takes place
        private DataGrid dataGrid;

        /// <include file='doc\DataGridTextBox.uex' path='docs/doc[@for="DataGridTextBox.DataGridTextBox"]/*' />
        public DataGridTextBox() : base () { 
            TabStop = false;
        }
        /// <include file='doc\DataGridTextBox.uex' path='docs/doc[@for="DataGridTextBox.SetDataGrid"]/*' />
        /// <devdoc>
        /// <para>Sets the <see cref='System.Windows.Forms.DataGrid'/> to which this <see cref='System.Windows.Forms.TextBox'/> control belongs.</para>
        /// </devdoc>
        public void SetDataGrid(DataGrid parentGrid)
        {
            dataGrid = parentGrid;
        }

        /// <include file='doc\DataGridTextBox.uex' path='docs/doc[@for="DataGridTextBox.WndProc"]/*' />
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        protected override void WndProc(ref Message m) {
            // but what if we get a CtrlV?
            // what about deleting from the menu?
            if (m.Msg == NativeMethods.WM_PASTE || m.Msg == NativeMethods.WM_CUT || m.Msg == NativeMethods.WM_CLEAR) {
                IsInEditOrNavigateMode = false;
                dataGrid.ColumnStartedEditing(Bounds);
            }

            base.WndProc(ref m);

        }

        /// <include file='doc\DataGridTextBox.uex' path='docs/doc[@for="DataGridTextBox.OnMouseWheel"]/*' />
        protected override void OnMouseWheel(MouseEventArgs e) {
            dataGrid.TextBoxOnMouseWheel(e);
        }

        /// <include file='doc\DataGridTextBox.uex' path='docs/doc[@for="DataGridTextBox.OnKeyPress"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnKeyPress(KeyPressEventArgs e)
        {
            base.OnKeyPress(e);

            // Shift-Space should not cause the grid to 
            // be put in edit mode
            if (e.KeyChar == ' ' && (Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                return;

            // if the edit box is in ReadOnly mode, then do not tell the DataGrid about the 
            // edit
            if (this.ReadOnly)
                return;

            // Ctrl-* should not put the grid in edit mode
            if ((Control.ModifierKeys & Keys.Control) == Keys.Control && ((Control.ModifierKeys & Keys.Alt) == 0))
                return;
            IsInEditOrNavigateMode = false;

            // let the DataGrid know about the edit
            dataGrid.ColumnStartedEditing(Bounds);
        }

        /// <include file='doc\DataGridTextBox.uex' path='docs/doc[@for="DataGridTextBox.ProcessKeyMessage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
            SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)
        ]
        protected internal override bool ProcessKeyMessage(ref Message m)
        {
            Keys key = (Keys)(int)m.WParam;
            Keys modifierKeys = ModifierKeys;

            if ((key | modifierKeys) == Keys.Enter || (key | modifierKeys) == Keys.Escape || ((key | modifierKeys) == (Keys.Enter | Keys.Control))
            )
            {
                // enter and escape keys are sent directly to the DataGrid
                // for those keys, eat the WM_CHAR part of the KeyMessage
                //
                if (m.Msg == NativeMethods.WM_CHAR)
                    return true;
                return ProcessKeyPreview(ref m);
            }

            if (m.Msg == NativeMethods.WM_CHAR) {
                if (key == Keys.LineFeed)           // eat the LineFeed we get when the user presses Ctrl-Enter in a gridTextBox
                    return true;
                return ProcessKeyEventArgs(ref m);
            }

            // now the edit control will be always on top of the grid
            // we only want to process the WM_KEYUP message ( the same way the grid was doing when the grid was getting all
            // the keys )
            if (m.Msg == NativeMethods.WM_KEYUP)
                return true;

            Keys keyData = key & Keys.KeyCode;

            switch (keyData)
            {
                case Keys.Right:
                    // here is the deal with Keys.Right:
                    // if the end of the selection is at the end of the string
                    // send this character to the dataGrid
                    // else, process the KeyEvent
                    //
                    if (SelectionStart + SelectionLength == Text.Length)
                        return ProcessKeyPreview(ref m);
                    return ProcessKeyEventArgs(ref m);
                case Keys.Left:
                    // if the end of the selection is at the begining of the string
                    // or if the entire text is selected and we did not start editing
                    // send this character to the dataGrid
                    // else, process the KeyEvent
                    // 
                    if (SelectionStart + SelectionLength == 0 ||
                        (this.IsInEditOrNavigateMode && this.SelectionLength == Text.Length))
                        return ProcessKeyPreview(ref m);
                    return ProcessKeyEventArgs(ref m);
                case Keys.Down:
                    // if the end of the selection is on the last line of the text then 
                    // send this character to the dataGrid
                    // else, process the KeyEvent
                    //
                    int end = SelectionStart + SelectionLength;
                    if (Text.IndexOf("\r\n", end) == -1)
                        return ProcessKeyPreview(ref m);
                    return ProcessKeyEventArgs(ref m);
                case Keys.Up:
                    // if the end of the selection is on the first line of the text then 
                    // send this character to the dataGrid
                    // else, process the KeyEvent
                    //
                    if ( Text.IndexOf("\r\n") < 0 || SelectionStart + SelectionLength  < Text.IndexOf("\r\n"))
                        return ProcessKeyPreview(ref m);
                    return ProcessKeyEventArgs(ref m);
                case Keys.Home:
                case Keys.End:
                    if (SelectionLength == Text.Length)
                        return ProcessKeyPreview(ref m);
                    else
                        return ProcessKeyEventArgs(ref m);
                case Keys.Prior:
                case Keys.Next:
                case Keys.Oemplus:
                case Keys.Add:
                case Keys.OemMinus:
                case Keys.Subtract:
                    if (IsInEditOrNavigateMode)
                    {
                        // this will ultimately call parent's ProcessKeyPreview
                        // in our case, DataGrid's ProcessKeyPreview
                        return ProcessKeyPreview(ref m);
                    }
                    else
                    {
                        return ProcessKeyEventArgs(ref m);
                    }
                case Keys.Space:
                    if (IsInEditOrNavigateMode && (Control.ModifierKeys & Keys.Shift) == Keys.Shift)
                    {
                            // when we get a SHIFT-SPACEBAR message, disregard the WM_CHAR part of the message
                            if (m.Msg == NativeMethods.WM_CHAR) return true;

                            // if the user pressed the SHIFT key at the same time with 
                            // the space key, send the key message to the DataGrid
                            return ProcessKeyPreview(ref m);
                    }
                    return ProcessKeyEventArgs(ref m);
                case Keys.A:
                    if (IsInEditOrNavigateMode && (Control.ModifierKeys & Keys.Control) == Keys.Control)
                    {
                            // when we get a Control-A message, disregard the WM_CHAR part of the message
                            if (m.Msg == NativeMethods.WM_CHAR) return true;

                            // if the user pressed the Control key at the same time with 
                            // the space key, send the key message to the DataGrid
                            return ProcessKeyPreview(ref m);
                    }
                    return ProcessKeyEventArgs(ref m);
                case Keys.F2:
                    IsInEditOrNavigateMode = false;
                    // do not select all the text, but
                    // position the caret at the end of the text
                    SelectionStart = Text.Length;
                    return true;
                case Keys.Delete:
                    if (IsInEditOrNavigateMode) {
                        // pass the delete to the parent, in our case, the DataGrid
                        // if the dataGrid used the key, then we aren't gonne
                        // use it anymore, else we are
                        if (ProcessKeyPreview(ref m))
                            return true;
                        else {
                            // the edit control will use the 
                            // delete key: we are in Edit mode now:
                            IsInEditOrNavigateMode = false;
                            dataGrid.ColumnStartedEditing(Bounds);

                            return ProcessKeyEventArgs(ref m);
                        }
                    }
                    else
                        return ProcessKeyEventArgs(ref m);
                case Keys.Tab:
                    // the TextBox gets the Control-Tab messages,
                    // not the parent
                    if ((ModifierKeys & Keys.Control) == Keys.Control)
                        return ProcessKeyPreview(ref m);
                    else
                        return ProcessKeyEventArgs(ref m);
                default:
                    return ProcessKeyEventArgs(ref m);
            }
        }

        /// <include file='doc\DataGridTextBox.uex' path='docs/doc[@for="DataGridTextBox.IsInEditOrNavigateMode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsInEditOrNavigateMode {
            get {
                return isInEditOrNavigateMode;
            }
            set {
                isInEditOrNavigateMode = value;
                if (value)
                    SelectAll();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\datagridtablesfactory.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGridTablesFactory.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    using System.Text;
    using System.Runtime.Remoting;

    using System.Diagnostics;
    using System;
    using System.Collections;
    using System.ComponentModel;

    using System.Data;
    using System.Windows.Forms;
    using Microsoft.Win32;

    /// <include file='doc\DataGridTablesFactory.uex' path='docs/doc[@for="GridTablesFactory"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class GridTablesFactory {
        // private static DataTableComparer dtComparer = new DataTableComparer();

        // not creatable...
        //
        private GridTablesFactory() {
        }


        /// <include file='doc\DataGridTablesFactory.uex' path='docs/doc[@for="GridTablesFactory.CreateGridTables"]/*' />
        /// <devdoc>
        ///      Takes a DataView and creates an intelligent mapping of
        ///      DataView storage types into available DataColumn types.
        /// </devdoc>
        public static DataGridTableStyle[]
            CreateGridTables(DataGridTableStyle gridTable, object dataSource, string dataMember, BindingContext bindingManager)
        {
            return new DataGridTableStyle[] {gridTable};
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\datagridtablecollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGridTableCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Collections;
    using System.Windows.Forms;
    using System.ComponentModel;
    using System.Globalization;
    
    /// <include file='doc\DataGridTableCollection.uex' path='docs/doc[@for="GridTableStylesCollection"]/*' />
    /// <devdoc>
    /// <para>Represents a collection of <see cref='System.Windows.Forms.DataGridTableStyle'/> objects in the <see cref='System.Windows.Forms.DataGrid'/> 
    /// control.</para>
    /// </devdoc>
    [ListBindable(false)]
    public class GridTableStylesCollection : BaseCollection ,IList {
        CollectionChangeEventHandler onCollectionChanged;
        ArrayList        items = new ArrayList();
        DataGrid         owner  = null;

        /// <include file='doc\DataGridTableCollection.uex' path='docs/doc[@for="GridTableStylesCollection.IList.Add"]/*' />
        /// <internalonly/>
        int IList.Add(object value) {
            return this.Add((DataGridTableStyle) value);            
        }

        /// <include file='doc\DataGridTableCollection.uex' path='docs/doc[@for="GridTableStylesCollection.IList.Clear"]/*' />
        /// <internalonly/>
        void IList.Clear() {
            this.Clear();
        }

        /// <include file='doc\DataGridTableCollection.uex' path='docs/doc[@for="GridTableStylesCollection.IList.Contains"]/*' />
        /// <internalonly/>
        bool IList.Contains(object value) {
            return items.Contains(value);
        }

        /// <include file='doc\DataGridTableCollection.uex' path='docs/doc[@for="GridTableStylesCollection.IList.IndexOf"]/*' />
        /// <internalonly/>
        int IList.IndexOf(object value) {
            return items.IndexOf(value);
        }

        /// <include file='doc\DataGridTableCollection.uex' path='docs/doc[@for="GridTableStylesCollection.IList.Insert"]/*' />
        /// <internalonly/>
        void IList.Insert(int index, object value) {
            throw new NotSupportedException();
        }

        /// <include file='doc\DataGridTableCollection.uex' path='docs/doc[@for="GridTableStylesCollection.IList.Remove"]/*' />
        /// <internalonly/>
        void IList.Remove(object value) {
            this.Remove((DataGridTableStyle)value);
        }

        /// <include file='doc\DataGridTableCollection.uex' path='docs/doc[@for="GridTableStylesCollection.IList.RemoveAt"]/*' />
        /// <internalonly/>
        void IList.RemoveAt(int index) {
            this.RemoveAt(index);
        }

        /// <include file='doc\DataGridTableCollection.uex' path='docs/doc[@for="GridTableStylesCollection.IList.IsFixedSize"]/*' />
        /// <internalonly/>
        bool IList.IsFixedSize {
            get {return false;}
        }

        /// <include file='doc\DataGridTableCollection.uex' path='docs/doc[@for="GridTableStylesCollection.IList.IsReadOnly"]/*' />
        /// <internalonly/>
        bool IList.IsReadOnly {
            get {return false;}
        }

        /// <include file='doc\DataGridTableCollection.uex' path='docs/doc[@for="GridTableStylesCollection.IList.this"]/*' />
        /// <internalonly/>
        object IList.this[int index] {
            get { return items[index]; }
            set { throw new NotSupportedException(); }
        }

        /// <include file='doc\DataGridTableCollection.uex' path='docs/doc[@for="GridTableStylesCollection.ICollection.CopyTo"]/*' />
        /// <internalonly/>
        void ICollection.CopyTo(Array array, int index) {
            this.items.CopyTo(array, index);
        }

        /// <include file='doc\DataGridTableCollection.uex' path='docs/doc[@for="GridTableStylesCollection.ICollection.Count"]/*' />
        /// <internalonly/>
        int ICollection.Count {
            get {return this.items.Count;}
        }

        /// <include file='doc\DataGridTableCollection.uex' path='docs/doc[@for="GridTableStylesCollection.ICollection.IsSynchronized"]/*' />
        /// <internalonly/>
        bool ICollection.IsSynchronized {
            get {return false;}
        }

        /// <include file='doc\DataGridTableCollection.uex' path='docs/doc[@for="GridTableStylesCollection.ICollection.SyncRoot"]/*' />
        /// <internalonly/>
        object ICollection.SyncRoot {
            get {return this;}
        }

        /// <include file='doc\DataGridTableCollection.uex' path='docs/doc[@for="GridTableStylesCollection.IEnumerable.GetEnumerator"]/*' />
        /// <internalonly/>
        IEnumerator IEnumerable.GetEnumerator() {
            return items.GetEnumerator();
        }

        internal GridTableStylesCollection(DataGrid grid) {
            owner = grid;
        }

        /// <include file='doc\DataGridTableCollection.uex' path='docs/doc[@for="GridTableStylesCollection.List"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override ArrayList List {
            get {
                return items;
            }
        }
        
        /* implemented in BaseCollection
        /// <summary>
        ///      Retrieves the number of GridTables in the collection.
        /// </summary>
        /// <returns>
        ///      The number of GridTables in the collection.
        /// </returns>
        public override int Count {
            get {
                return items.Count;
            }
        }
        */

        /// <include file='doc\DataGridTableCollection.uex' path='docs/doc[@for="GridTableStylesCollection.this"]/*' />
        /// <devdoc>
        ///      Retrieves the DataGridTable with the specified index.
        /// </devdoc>
        public DataGridTableStyle this[int index] {
            get {
                return (DataGridTableStyle)items[index];
            }
        }

        /// <include file='doc\DataGridTableCollection.uex' path='docs/doc[@for="GridTableStylesCollection.this1"]/*' />
        /// <devdoc>
        ///      Retrieves the DataGridTable with the name provided.
        /// </devdoc>
        public DataGridTableStyle this[string tableName] {
            get {
                if (tableName == null)
                    throw new ArgumentNullException("tableName");
                int itemCount = items.Count;
                for (int i = 0; i < itemCount; ++i) {
                    DataGridTableStyle table = (DataGridTableStyle)items[i];
                    // NOTE: case-insensitive
                    if (0 == String.Compare(table.MappingName, tableName, true, CultureInfo.InvariantCulture))
                        return table;
                }
                return null;
            }
        }

        internal void CheckForMappingNameDuplicates(DataGridTableStyle table) {
            if (table.MappingName.Equals(String.Empty))
                return;
            for (int i = 0; i < items.Count; i++)
                if ( ((DataGridTableStyle)items[i]).MappingName.Equals(table.MappingName) && table != items[i])
                    throw new ArgumentException(SR.GetString(SR.DataGridTableStyleDuplicateMappingName), "table");
        }

        /// <include file='doc\DataGridTableCollection.uex' path='docs/doc[@for="GridTableStylesCollection.Add"]/*' />
        /// <devdoc>
        /// <para>Adds a <see cref='System.Windows.Forms.DataGridTableStyle'/> to this collection.</para>
        /// </devdoc>
        public virtual int Add(DataGridTableStyle table) {
            // set the rowHeaderWidth on the newly added table to at least the minimum value
            // on its owner
            if (this.owner != null && this.owner.MinimumRowHeaderWidth() > table.RowHeaderWidth)
                table.RowHeaderWidth = this.owner.MinimumRowHeaderWidth();

            if (table.DataGrid != owner && table.DataGrid != null)
                throw new ArgumentException(SR.GetString(SR.DataGridTableStyleCollectionAddedParentedTableStyle), "table");
            table.DataGrid = owner;
            CheckForMappingNameDuplicates(table);
            table.MappingNameChanged += new EventHandler(TableStyleMappingNameChanged);
            int index = items.Add(table);
            OnCollectionChanged(new CollectionChangeEventArgs(CollectionChangeAction.Add, table));
            
            return index;
        }
        
        private void TableStyleMappingNameChanged(object sender, EventArgs pcea) {
            OnCollectionChanged(new CollectionChangeEventArgs(CollectionChangeAction.Refresh, null));
        }
        
        /// <include file='doc\DataGridTableCollection.uex' path='docs/doc[@for="GridTableStylesCollection.AddRange"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void AddRange(DataGridTableStyle[] tables) {
            if (tables == null) {
                throw new ArgumentNullException("tables");
            }
            foreach(DataGridTableStyle table in tables) {
                table.DataGrid = owner;
                table.MappingNameChanged += new EventHandler(TableStyleMappingNameChanged);
                items.Add(table);
            }
            OnCollectionChanged(new CollectionChangeEventArgs(CollectionChangeAction.Refresh, null));
        }

        /// <include file='doc\DataGridTableCollection.uex' path='docs/doc[@for="GridTableStylesCollection.CollectionChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event CollectionChangeEventHandler CollectionChanged {
            add {
                onCollectionChanged += value;
            }
            remove {
                onCollectionChanged -= value;
            }
        }
        
        /// <include file='doc\DataGridTableCollection.uex' path='docs/doc[@for="GridTableStylesCollection.Clear"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Clear() {
            for (int i = 0; i < items.Count; i++) {
                DataGridTableStyle element = (DataGridTableStyle)items[i];
                element.MappingNameChanged -= new EventHandler(TableStyleMappingNameChanged);
            }

            items.Clear();
            OnCollectionChanged(new CollectionChangeEventArgs(CollectionChangeAction.Refresh, null));
        }

        /// <include file='doc\DataGridTableCollection.uex' path='docs/doc[@for="GridTableStylesCollection.Contains"]/*' />
        /// <devdoc>
        ///      Checks to see if a DataGridTableStyle is contained in this collection.
        /// </devdoc>
        public bool Contains(DataGridTableStyle table) {
            int index = items.IndexOf(table);
            return index != -1;
        }

        /// <include file='doc\DataGridTableCollection.uex' path='docs/doc[@for="GridTableStylesCollection.Contains1"]/*' />
        /// <devdoc>
        /// <para>Checks to see if a <see cref='System.Windows.Forms.DataGridTableStyle'/> with the given name
        ///    is contained in this collection.</para>
        /// </devdoc>
        public bool Contains(string name) {
            int itemCount = items.Count;
            for (int i = 0; i < itemCount; ++i) {
                DataGridTableStyle table = (DataGridTableStyle)items[i];
                // NOTE: case-insensitive
                if (String.Compare(table.MappingName, name, true, CultureInfo.InvariantCulture) == 0)
                    return true;
            }
            return false;
        }

        /*
        public override IEnumerator GetEnumerator() {
            return items.GetEnumerator();
        }

        public override IEnumerator GetEnumerator(bool allowRemove) {
            if (!allowRemove)
                return GetEnumerator();
            else
                throw new NotSupportedException(SR.GetString(SR.DataGridTableCollectionGetEnumerator));
        }
        */

        /// <include file='doc\DataGridTableCollection.uex' path='docs/doc[@for="GridTableStylesCollection.OnCollectionChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void OnCollectionChanged(CollectionChangeEventArgs ccevent) {
            if (onCollectionChanged != null)
                onCollectionChanged(this, ccevent);

            DataGrid grid = owner;
            if (grid != null) {
                /* FOR DEMO: danielhe: TableStylesCollection::OnCollectionChanged: set the datagridtble
                DataView dataView = ((DataView) grid.DataSource);
                if (dataView != null) {
                    DataTable dataTable = dataView.Table;
                    if (dataTable != null) {
                        if (Contains(dataTable)) {
                            grid.SetDataGridTable(this[dataTable]);
                        }
                    }
                }
                */
                grid.checkHierarchy = true;
            }
        }

        /// <include file='doc\DataGridTableCollection.uex' path='docs/doc[@for="GridTableStylesCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Remove(DataGridTableStyle table) {
            int tableIndex = -1;
            int itemsCount = items.Count;
            for (int i = 0; i < itemsCount; ++i)
                if (items[i] == table) {
                    tableIndex = i;
                    break;
                }
            if (tableIndex == -1)
                throw new ArgumentException(SR.GetString(SR.DataGridTableCollectionMissingTable), "table");
            else
                RemoveAt(tableIndex);
        }

        /// <include file='doc\DataGridTableCollection.uex' path='docs/doc[@for="GridTableStylesCollection.RemoveAt"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void RemoveAt(int index) {
            DataGridTableStyle element = (DataGridTableStyle)items[index];
            element.MappingNameChanged -= new EventHandler(TableStyleMappingNameChanged);
            items.RemoveAt(index);
            OnCollectionChanged(new CollectionChangeEventArgs(CollectionChangeAction.Remove, element));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\datagridtooltip.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGridToolTip.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.Drawing;
    
    using System.Windows.Forms;
    using Microsoft.Win32;
    using System.Diagnostics;
    using System.ComponentModel;

    // this class is basically a NativeWindow that does toolTipping
    // should be one for the entire grid
    internal class DataGridToolTip : MarshalByRefObject {
        // the toolTip control
        private NativeWindow tipWindow = null;

        // the dataGrid which contains this toolTip
        private DataGrid dataGrid = null;

        // CONSTRUCTOR
        public DataGridToolTip(DataGrid dataGrid)
        {
            Debug.Assert(dataGrid!= null, "can't attach a tool tip to a null grid");
            this.dataGrid = dataGrid;
        }

        // will ensure that the toolTip window was created
        public void CreateToolTipHandle()
        {
            if (tipWindow == null || tipWindow.Handle == IntPtr.Zero)
            {
                NativeMethods.INITCOMMONCONTROLSEX icc = new NativeMethods.INITCOMMONCONTROLSEX();
                icc.dwICC = NativeMethods.ICC_TAB_CLASSES;
                icc.dwSize = Marshal.SizeOf(icc);
                SafeNativeMethods.InitCommonControlsEx(icc);
                CreateParams cparams = new CreateParams();
                cparams.Parent = dataGrid.Handle;
                cparams.ClassName = NativeMethods.TOOLTIPS_CLASS;
                cparams.Style = NativeMethods.TTS_ALWAYSTIP;
                tipWindow = new NativeWindow();
                tipWindow.CreateHandle(cparams);

                UnsafeNativeMethods.SendMessage(new HandleRef(tipWindow, tipWindow.Handle), NativeMethods.TTM_SETMAXTIPWIDTH, 0, SystemInformation.MaxWindowTrackSize.Width);
                SafeNativeMethods.SetWindowPos(new HandleRef(tipWindow, tipWindow.Handle), NativeMethods.HWND_NOTOPMOST, 0, 0, 0, 0, NativeMethods.SWP_NOSIZE | NativeMethods.SWP_NOMOVE | NativeMethods.SWP_NOACTIVATE);
                UnsafeNativeMethods.SendMessage(new HandleRef(tipWindow, tipWindow.Handle), NativeMethods.TTM_SETDELAYTIME, NativeMethods.TTDT_INITIAL, 0);
            }
        }

        // this function will add a toolTip to the
        // windows system
        public void AddToolTip(String toolTipString, IntPtr toolTipId, Rectangle iconBounds)
        {
            Debug.Assert(tipWindow != null && tipWindow.Handle != IntPtr.Zero, "the tipWindow was not initialized, bailing out");

            if (toolTipString == null)
                throw new ArgumentNullException(SR.GetString(SR.DataGridToolTipNull));
            if (iconBounds.IsEmpty)
                throw new ArgumentNullException(SR.GetString(SR.DataGridToolTipEmptyIcon));

            NativeMethods.TOOLINFO_T toolInfo = new NativeMethods.TOOLINFO_T();
            toolInfo.cbSize = Marshal.SizeOf(toolInfo);
            toolInfo.hwnd = dataGrid.Handle;
            toolInfo.uId = toolTipId;
            toolInfo.lpszText = toolTipString;
            toolInfo.rect = NativeMethods.RECT.FromXYWH(iconBounds.X, iconBounds.Y, iconBounds.Width, iconBounds.Height);
            toolInfo.uFlags = NativeMethods.TTF_SUBCLASS;
            UnsafeNativeMethods.SendMessage(new HandleRef(tipWindow, tipWindow.Handle), NativeMethods.TTM_ADDTOOL, 0, toolInfo);
        }

        public void RemoveToolTip(IntPtr toolTipId)
        {
            NativeMethods.TOOLINFO_T toolInfo = new NativeMethods.TOOLINFO_T();
            toolInfo.cbSize = Marshal.SizeOf(toolInfo);
            toolInfo.hwnd = dataGrid.Handle;
            toolInfo.uId = toolTipId;
            UnsafeNativeMethods.SendMessage(new HandleRef(tipWindow, tipWindow.Handle), NativeMethods.TTM_DELTOOL, 0, toolInfo);
        }

        // this function will deactivate this tool tip
        public void DeactivateToolTip()
        {
            Debug.Assert(tipWindow != null && tipWindow.Handle != IntPtr.Zero, "the tipWindow was not initialized, bailing out");

            // the first 0 is for false, the second 0 is not used
            UnsafeNativeMethods.SendMessage(new HandleRef(tipWindow, tipWindow.Handle), NativeMethods.TTM_ACTIVATE, 0, 0);
        }
        
        // will destroy the tipWindow
        public void Destroy()
        {
            Debug.Assert(tipWindow != null, "how can one destroy a null window");
            tipWindow.DestroyHandle();
            tipWindow = null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\datagridtextboxcolumn.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataGridTextBoxColumn.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    using System.Runtime.Remoting;

    using System;
    
    using System.Windows.Forms;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Windows.Forms.ComponentModel;
    using System.Drawing;
    
    using Microsoft.Win32;
    using System.Diagnostics;

    /// <include file='doc\DataGridTextBoxColumn.uex' path='docs/doc[@for="DataGridTextBoxColumn"]/*' />
    /// <devdoc>
    /// <para>Hosts a System.Windows.Forms.TextBox control in a cell of a System.Windows.Forms.DataGridColumnStyle for editing strings.</para>
    /// </devdoc>
    public class DataGridTextBoxColumn : DataGridColumnStyle {

        // ui State
        private int   xMargin =           2;
        private int   yMargin =           1;
        private NativeMethods.RECT  rect    =           new NativeMethods.RECT();
        // private int   fontHandle =        0;
        private string format = null;
        private TypeConverter typeConverter;
        private IFormatProvider formatInfo = null;
        private System.Reflection.MethodInfo parseMethod;

        // hosted control
        private DataGridTextBox edit;

        // editing state
        private string oldValue = null;
        private int editRow = -1;

        /// <include file='doc\DataGridTextBoxColumn.uex' path='docs/doc[@for="DataGridTextBoxColumn.DataGridTextBoxColumn"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the System.Windows.Forms.DataGridTextBoxColumn
        /// class.</para>
        /// </devdoc>
        public DataGridTextBoxColumn() : this(null, null) {
        }

        /// <include file='doc\DataGridTextBoxColumn.uex' path='docs/doc[@for="DataGridTextBoxColumn.DataGridTextBoxColumn1"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of a System.Windows.Forms.DataGridTextBoxColumn with
        ///    a specified System.Data.DataColumn.</para>
        /// </devdoc>
        public DataGridTextBoxColumn(PropertyDescriptor prop)
        : this(prop, null, false) {
        }

        /// <include file='doc\DataGridTextBoxColumn.uex' path='docs/doc[@for="DataGridTextBoxColumn.DataGridTextBoxColumn2"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of a System.Windows.Forms.DataGridTextBoxColumn. with
        ///    the specified System.Data.DataColumn and System.Windows.Forms.ComponentModel.Format.</para>
        /// </devdoc>
        public DataGridTextBoxColumn(PropertyDescriptor prop, string format) : this(prop, format, false){}

        /// <include file='doc\DataGridTextBoxColumn.uex' path='docs/doc[@for="DataGridTextBoxColumn.DataGridTextBoxColumn3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DataGridTextBoxColumn(PropertyDescriptor prop, string format, bool isDefault) : base(prop, isDefault) {
            edit = new DataGridTextBox();
            edit.BorderStyle = BorderStyle.None;
            edit.Multiline = true;
            edit.AcceptsReturn = true;
            edit.Visible = false;
            this.Format = format;
        }

        /// <include file='doc\DataGridTextBoxColumn.uex' path='docs/doc[@for="DataGridTextBoxColumn.DataGridTextBoxColumn4"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DataGridTextBoxColumn(PropertyDescriptor prop, bool isDefault) : this(prop, null, isDefault) {}


        // =------------------------------------------------------------------
        // =        Properties
        // =------------------------------------------------------------------

        /// <include file='doc\DataGridTextBoxColumn.uex' path='docs/doc[@for="DataGridTextBoxColumn.TextBox"]/*' />
        /// <devdoc>
        /// <para>Gets the hosted System.Windows.Forms.TextBox control.</para>
        /// </devdoc>
        [Browsable(false)]
        public virtual TextBox TextBox {
            get {
                return edit;
            }
        }

        /// <include file='doc\DataGridTextBoxColumn.uex' path='docs/doc[@for="DataGridTextBoxColumn.KeyPress"]/*' />
        internal override bool KeyPress(int rowNum, Keys keyData) {
            if (edit.IsInEditOrNavigateMode)
                return base.KeyPress(rowNum, keyData);

            // if the edit box is editing, then
            // pass this keystroke to the edit box
            //
            return false;
        }

        /// <include file='doc\DataGridTextBoxColumn.uex' path='docs/doc[@for="DataGridTextBoxColumn.SetDataGridInColumn"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds a System.Windows.Forms.TextBox control to the System.Windows.Forms.DataGrid control's System.Windows.Forms.Control.ControlCollection
        ///       .
        ///    </para>
        /// </devdoc>
        protected override void SetDataGridInColumn(DataGrid value) {
            base.SetDataGridInColumn(value);
            if (edit.ParentInternal != null) {
                edit.ParentInternal.Controls.Remove(edit);
            }
            if (value != null) {
                value.Controls.Add(edit);
            }

            // we have to tell the edit control about its dataGrid
            edit.SetDataGrid(value);
        }

        /* CUT as part of the new DataGridTableStyleSheet thing
        public override Font Font {
            set {
                base.Font = value;
                Font f = base.Font;
                edit.Font = f;
                // if (f != null) {
                    // fontHandle = f.Handle;
                // }
            }
        }
        */

        /// <include file='doc\DataGridTextBoxColumn.uex' path='docs/doc[@for="DataGridTextBoxColumn.PropertyDescriptor"]/*' />
        /// <devdoc>
        /// <para>Gets or sets the System.Windows.Forms.ComponentModel.Format for the System.Windows.Forms.DataGridTextBoxColumn
        /// .</para>
        /// </devdoc>
        [
        SRDescription(SR.FormatControlFormatDescr),
        DefaultValue(null)
        ]
        public override PropertyDescriptor PropertyDescriptor {
            set {
                base.PropertyDescriptor = value;
                if (this.PropertyDescriptor != null) {
                    if (this.PropertyDescriptor.PropertyType != typeof(object)) {
                        this.typeConverter = TypeDescriptor.GetConverter(this.PropertyDescriptor.PropertyType);
                        this.parseMethod = this.PropertyDescriptor.PropertyType.GetMethod("Parse", new Type[]{typeof(string), typeof(IFormatProvider)});
                    }
                }
            }
        }

        // add the corresponding value Editor: rip one from the valueEditor for the DisplayMember in the 
        // format object
        /// <include file='doc\DataGridTextBoxColumn.uex' path='docs/doc[@for="DataGridTextBoxColumn.Format"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Editor("System.Windows.Forms.Design.DataGridColumnStyleFormatEditor, " + AssemblyRef.SystemDesign, typeof(System.Drawing.Design.UITypeEditor))]
        public string Format {
            get {
                return format;
            }
            set {
                if (value == null)
                    value = "";
                if (format == null || !format.Equals(value)) {
                    this.format = value;

                    // if the associated typeConverter cannot convert from string,
                    // then we can't modify the column value. hence, make it readOnly
                    //
                    if (format.Length == 0) {
                        if (this.typeConverter != null && !typeConverter.CanConvertFrom(typeof(string)))
                            this.ReadOnly = true;
                    }

                    Invalidate();
                }
            }
        }

        /// <include file='doc\DataGridTextBoxColumn.uex' path='docs/doc[@for="DataGridTextBoxColumn.FormatInfo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced)]
        public IFormatProvider FormatInfo {
            get {
                return this.formatInfo;
            }
            set {
                if (this.formatInfo == null || !this.formatInfo.Equals(value))
                    this.formatInfo = value;
            }
        }

        /// <include file='doc\DataGridTextBoxColumn.uex' path='docs/doc[@for="DataGridTextBoxColumn.ReadOnly"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool ReadOnly {
            get {
                return base.ReadOnly;
            }
            set {
                // if the gridColumn is can't convert the string to 
                // the backGround propertyDescriptor, then make the column ReadOnly
                if (!value && "".Equals(format)) {
                    if (this.typeConverter != null && !this.typeConverter.CanConvertFrom(typeof(string)))
                        return;
                }
                base.ReadOnly = value;
            }
        }

        // =------------------------------------------------------------------
        // =        Methods
        // =------------------------------------------------------------------

        private void DebugOut(string s) {
            Debug.WriteLineIf(CompModSwitches.DGEditColumnEditing.TraceVerbose, "DGEditColumnEditing: " + s);
        }

        // will hide the edit control
        /// <include file='doc\DataGridTextBoxColumn.uex' path='docs/doc[@for="DataGridTextBoxColumn.ConcedeFocus"]/*' />
        /// <devdoc>
        ///    <para>Informs the column the focus is being conceded.</para>
        /// </devdoc>
        protected internal override void ConcedeFocus() {
            edit.Bounds = Rectangle.Empty;
            // edit.Visible = false;
            // HideEditBox();
        }

        /// <include file='doc\DataGridTextBoxColumn.uex' path='docs/doc[@for="DataGridTextBoxColumn.HideEditBox"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Hides the System.Windows.Forms.TextBox
        ///       control and moves the focus to the System.Windows.Forms.DataGrid
        ///       control.
        ///    </para>
        /// </devdoc>
        protected void HideEditBox() {
            bool wasFocused = edit.Focused;
            edit.Visible = false;

            // it seems that edit.Visible = false will take away the focus from
            // the edit control. And this means that we will not give the focus to the grid
            // If all the columns would have an edit control this would not be bad
            // ( or if the grid is the only control on the form ),
            // but when we have a DataGridBoolColumn then the focus will be taken away
            // by the next control in the form.
            //
            // if (edit.Focused && this.DataGridTableStyle.DataGrid.CanFocus) {

            // when the user deletes the current ( ie active ) column from the
            // grid, the grid should still call EndEdit ( so that the changes that the user made
            // before deleting the column will go to the backEnd)
            // however, in that situation, we are left w/ the editColumn which is not parented.
            // the grid will call Edit to reset the EditColumn
            if (wasFocused && this.DataGridTableStyle != null && this.DataGridTableStyle.DataGrid != null && this.DataGridTableStyle.DataGrid.CanFocus) {
                this.DataGridTableStyle.DataGrid.FocusInternal();
                Debug.Assert(!edit.Focused, "the edit control just conceeded focus to the dataGrid");
            }
        }

        /// <include file='doc\DataGridTextBoxColumn.uex' path='docs/doc[@for="DataGridTextBoxColumn.UpdateUI"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected internal override void UpdateUI(CurrencyManager source, int rowNum, string instantText)
        {
            edit.Text = GetText(GetColumnValueAtRow(source, rowNum));
            if (!edit.ReadOnly && instantText != null)
                edit.Text = instantText;

        }

        /// <include file='doc\DataGridTextBoxColumn.uex' path='docs/doc[@for="DataGridTextBoxColumn.EndEdit"]/*' />
        /// <devdoc>
        /// <para>Ends an edit operation on the System.Windows.Forms.DataGridColumnStyle
        /// .</para>
        /// </devdoc>
        protected void EndEdit() {
            edit.IsInEditOrNavigateMode = true;
            DebugOut("Ending Edit");
            Invalidate();
        }

        /// <include file='doc\DataGridTextBoxColumn.uex' path='docs/doc[@for="DataGridTextBoxColumn.GetPreferredSize"]/*' />
        /// <devdoc>
        ///    <para>Returns the optimum width and
        ///       height of the cell in a specified row relative
        ///       to the specified value.</para>
        /// </devdoc>
        protected internal override Size GetPreferredSize(Graphics g, object value) {
            Size extents = Size.Ceiling(g.MeasureString(GetText(value), DataGridTableStyle.DataGrid.Font));
            extents.Width += xMargin*2 + this.DataGridTableStyle.GridLineWidth;
            extents.Height += yMargin;
            return extents;
        }

        /// <include file='doc\DataGridTextBoxColumn.uex' path='docs/doc[@for="DataGridTextBoxColumn.GetMinimumHeight"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the height of a cell in a System.Windows.Forms.DataGridColumnStyle
        ///       .
        ///    </para>
        /// </devdoc>
        protected internal override int GetMinimumHeight() {
            // why + 3? cause we have to give some way to the edit box.
            return FontHeight + yMargin + 3;
        }

        /// <include file='doc\DataGridTextBoxColumn.uex' path='docs/doc[@for="DataGridTextBoxColumn.GetPreferredHeight"]/*' />
        /// <devdoc>
        ///    <para>Gets the height to be used in for automatically resizing columns.</para>
        /// </devdoc>
        protected internal override int GetPreferredHeight(Graphics g, object value) {
            int newLineIndex = 0;
            int newLines = 0;
            string valueString = GetText(value);
            while (newLineIndex != -1 && newLineIndex < valueString.Length)
            {
                newLineIndex = valueString.IndexOf("\r\n", newLineIndex + 1);
                newLines ++;
            }

            return FontHeight * newLines + yMargin;
        }

        /// <include file='doc\DataGridTextBoxColumn.uex' path='docs/doc[@for="DataGridTextBoxColumn.Abort"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initiates a request to interrupt an edit procedure.
        ///    </para>
        /// </devdoc>
        protected internal override void Abort(int rowNum) {
            RollBack();
            HideEditBox();
            EndEdit();
        }

        // used for Alt0 functionality
        /// <include file='doc\DataGridTextBoxColumn.uex' path='docs/doc[@for="DataGridTextBoxColumn.EnterNullValue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Enters a <see langword='null '/>in the column.
        ///    </para>
        /// </devdoc>
        protected internal override void EnterNullValue() {
            if (this.ReadOnly)
                return;

            // if the edit box is not visible, then
            // do not put the edit text in it
            if (!edit.Visible)
                return;

            // if we are editing, then we should be able to enter alt-0 in a cell.
            //
            if (!edit.IsInEditOrNavigateMode)
                return;

            edit.Text = NullText;
            // edit.Visible = true;
            edit.IsInEditOrNavigateMode = false;
            // tell the dataGrid that there is an edit:
            if (this.DataGridTableStyle != null && this.DataGridTableStyle.DataGrid != null)
                this.DataGridTableStyle.DataGrid.ColumnStartedEditing(edit.Bounds);
        }

        /// <include file='doc\DataGridTextBoxColumn.uex' path='docs/doc[@for="DataGridTextBoxColumn.Commit"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Inititates a request to complete an editing procedure.
        ///    </para>
        /// </devdoc>
        protected internal override bool Commit(CurrencyManager dataSource, int rowNum) {
            // always hide the edit box
            // HideEditBox();
            edit.Bounds = Rectangle.Empty;

            if (edit.IsInEditOrNavigateMode)
                return true;

            try {
                object value = edit.Text;
                if (NullText.Equals(value)) {
                    value = Convert.DBNull;
                    edit.Text = NullText;
                } else if (format != null && format.Length != 0 && this.parseMethod != null && this.FormatInfo != null) {
                    // use reflection to get the Parse method on the
                    // type of the propertyDescriptor.
                    value = (object) parseMethod.Invoke(null, new object[] {edit.Text, this.FormatInfo});
                    if (value is IFormattable) {
                        edit.Text = ((IFormattable)value).ToString(format, formatInfo);
                    }else 
                        edit.Text = value.ToString();
                } else if (typeConverter != null && typeConverter.CanConvertFrom(typeof(string))) {
                    value = typeConverter.ConvertFromString(edit.Text);
                    edit.Text = typeConverter.ConvertToString(value);
                }

                SetColumnValueAtRow(dataSource, rowNum, value);
            }
            catch (Exception) {
             // MessageBox.Show("There was an error caught setting field \""
             //                 + this.PropertyDescriptor.Name + "\" to the value \"" + edit.Text + "\"\n"
             //                 + "The value is being rolled back to the original.\n"
             //                 + "The error was a '" + e.Message + "' "  + e.StackTrace
             //                 , "Error commiting changes...", MessageBox.IconError);
             // Debug.WriteLine(e.GetType().Name);
                RollBack();
                return false;
            }
            DebugOut("OnCommit completed without Exception.");
            EndEdit();
            return true;
        }

        /// <include file='doc\DataGridTextBoxColumn.uex' path='docs/doc[@for="DataGridTextBoxColumn.Edit"]/*' />
        /// <devdoc>
        ///    <para>Prepares a cell for editing.</para>
        /// </devdoc>
        protected internal override void Edit(CurrencyManager source,
                                    int rowNum,
                                    Rectangle bounds,
                                    bool readOnly,
                                    string instantText,
                                    bool cellIsVisible) {
            DebugOut("Begining Edit, rowNum :" + rowNum.ToString());

            Rectangle originalBounds = bounds;

            edit.ReadOnly = readOnly || ReadOnly || this.DataGridTableStyle.ReadOnly;

            edit.Text = GetText(GetColumnValueAtRow(source, rowNum));
            if (!edit.ReadOnly && instantText != null) {
                // tell the grid that we are changing stuff
                this.DataGridTableStyle.DataGrid.ColumnStartedEditing(bounds);
                // tell the edit control that the user changed it
                this.edit.IsInEditOrNavigateMode = false;
                edit.Text = instantText;
            }

            if (cellIsVisible) {
                bounds.Offset(xMargin, 2 * yMargin);
                bounds.Width  -= xMargin;
                bounds.Height -= 2 * yMargin;
                DebugOut("edit bounds: " + bounds.ToString());
                edit.Bounds = bounds;

                edit.Visible = true;

                edit.TextAlign = this.Alignment;
            }
            else {
                edit.Bounds = originalBounds;
                edit.Visible = false;
            }

            edit.RightToLeft = this.DataGridTableStyle.DataGrid.RightToLeft;

            edit.FocusInternal();

            editRow = rowNum;

            if (!edit.ReadOnly) {
                oldValue = edit.Text;
            }

            // select the text even if the text box is read only
            // because the navigation code in the DataGridTextBox::ProcessKeyMessage
            // uses the SelectedText property 
            if (instantText == null)
                edit.SelectAll();
            else {
                int end = edit.Text.Length;
                edit.Select(end, 0);
            }

            if (edit.Visible)
                DataGridTableStyle.DataGrid.Invalidate(originalBounds);
        }

        internal override string GetDisplayText(object value) {
            return GetText(value);
        }

        private string GetText(object value) {
            if (value is System.DBNull)
                return NullText;
            else if (format != null && format.Length != 0 && (value is IFormattable)) {
                try {
                    return ((IFormattable)value).ToString(format, this.formatInfo);
                } catch (Exception) {
                    // CONSIDER: maybe we should fall back to using the typeConverter?
                }
            } else {
                // use the typeConverter:
                if (this.typeConverter != null && this.typeConverter.CanConvertTo(typeof(string)))
                    return (string)this.typeConverter.ConvertTo(value, typeof(string));
            }
            return(value != null ? value.ToString() : "");
        }

        /// <include file='doc\DataGridTextBoxColumn.uex' path='docs/doc[@for="DataGridTextBoxColumn.Paint"]/*' />
        /// <devdoc>
        /// <para>Paints the a System.Windows.Forms.DataGridColumnStyle with the specified System.Drawing.Graphics,
        /// System.Drawing.Rectangle, DataView.Rectangle, and row number. </para>
        /// </devdoc>
        protected internal override void Paint(Graphics g, Rectangle bounds, CurrencyManager source, int rowNum) {
            Paint(g, bounds, source, rowNum, false);
        }

        /// <include file='doc\DataGridTextBoxColumn.uex' path='docs/doc[@for="DataGridTextBoxColumn.Paint1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Paints a System.Windows.Forms.DataGridColumnStyle with the specified System.Drawing.Graphics, System.Drawing.Rectangle, DataView, row number, and alignment.
        ///    </para>
        /// </devdoc>
        protected internal override void Paint(Graphics g, Rectangle bounds, CurrencyManager source, int rowNum, bool alignToRight) {
            string text = GetText(GetColumnValueAtRow(source, rowNum));
            PaintText(g, bounds, text, alignToRight);
        }

        /// <include file='doc\DataGridTextBoxColumn.uex' path='docs/doc[@for="DataGridTextBoxColumn.Paint2"]/*' />
        /// <devdoc>
        /// <para>Paints a System.Windows.Forms.DataGridColumnStyle with the specified System.Drawing.Graphics,
        /// System.Drawing.Rectangle, DataView.Rectangle, row number, background color, 
        ///    and foreground color..</para>
        /// </devdoc>
        protected internal override void Paint(Graphics g, Rectangle bounds, CurrencyManager source, int rowNum,
                                     Brush backBrush, Brush foreBrush, bool alignToRight) {
            string text = GetText(GetColumnValueAtRow(source, rowNum));
            PaintText(g, bounds, text, backBrush, foreBrush, alignToRight);
        }

        /// <include file='doc\DataGridTextBoxColumn.uex' path='docs/doc[@for="DataGridTextBoxColumn.PaintText"]/*' />
        /// <devdoc>
        ///    <para>Draws the text and
        ///       rectangle at the given location with the specified alignment.</para>
        /// </devdoc>
        protected void PaintText(Graphics g, Rectangle bounds, string text, bool alignToRight) {
            PaintText(g, bounds, text, this.DataGridTableStyle.BackBrush, this.DataGridTableStyle.ForeBrush, alignToRight);
        }

        /// <include file='doc\DataGridTextBoxColumn.uex' path='docs/doc[@for="DataGridTextBoxColumn.PaintText1"]/*' />
        /// <devdoc>
        ///    <para>Draws the text and rectangle at the specified location with the
        ///       specified colors and alignment.</para>
        /// </devdoc>
        protected void PaintText(Graphics g, Rectangle textBounds, string text, Brush backBrush, Brush foreBrush, bool alignToRight) {
            /*
            if (edit.Visible)
                g.BackColor = BackColor;
            */

            Rectangle rect = textBounds;

            StringFormat format = new StringFormat();
            if (alignToRight) {
                format.FormatFlags |= StringFormatFlags.DirectionRightToLeft;
            }

            format.Alignment = this.Alignment == HorizontalAlignment.Left ? StringAlignment.Near : this.Alignment == HorizontalAlignment.Center ? StringAlignment.Center : StringAlignment.Far;

            // do not wrap the text
            //
            format.FormatFlags |= StringFormatFlags.NoWrap;

            g.FillRectangle(backBrush, rect);
            // by design, painting  leaves a little padding around the rectangle.
            // so do not deflate the rectangle.
            rect.Offset(0,2 * yMargin);
            rect.Height -= 2 * yMargin;
            g.DrawString(text, this.DataGridTableStyle.DataGrid.Font, foreBrush, rect, format);
            format.Dispose();
        }

        private void RollBack() {
            Debug.Assert(!edit.IsInEditOrNavigateMode, "Must be editing to rollback changes...");
            edit.Text = oldValue;
        }

        /// <include file='doc\DataGridTextBoxColumn.uex' path='docs/doc[@for="DataGridTextBoxColumn.ReleaseHostedControl"]/*' />
        protected internal override void ReleaseHostedControl() {
            if (edit.ParentInternal != null) {
                edit.ParentInternal.Controls.Remove(edit);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\dateboldeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="DateBoldEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;


    /// <include file='doc\DateBoldEventHandler.uex' path='docs/doc[@for="DateBoldEventHandler"]/*' />
    /// <internalonly/>
    /// <devdoc>
    /// </devdoc>
    public delegate void DateBoldEventHandler(object sender, DateBoldEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\datagridtable.cs ===
// <copyright file="DataGridTable.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


namespace System.Windows.Forms {
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System;
    using System.Text;
    using System.Collections;
    using System.Windows.Forms;
    using System.Windows.Forms.ComponentModel;
    using System.Drawing;
    using System.Runtime.InteropServices;

    using Microsoft.Win32;

    /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle"]/*' />
    /// <devdoc>
    /// <para>Represents the table drawn by the <see cref='System.Windows.Forms.DataGrid'/> control at run time.</para>
    /// </devdoc>
    [
    ToolboxItem(false),
    DesignTimeVisible(false),
    //DefaultProperty("GridTableName")
    ]
    public class DataGridTableStyle : Component, IDataGridEditingService {

        // internal for DataGridColumn accessibility...
        //
        internal DataGrid                 dataGrid    = null;

        // relationship UI
        private int         relationshipHeight = 0;
        internal const int  relationshipSpacing = 1;
        private Rectangle   relationshipRect = Rectangle.Empty;
        private int         focusedRelation = -1;
        private int         focusedTextWidth;

        // will contain a list of relationships that this table has
        private ArrayList relationsList = new ArrayList(2);

        // the name of the table
        private string mappingName = "";
        private GridColumnStylesCollection    gridColumns = null;
        private bool                     readOnly    = false;
        private bool                     isDefaultTableStyle = false;

        private static readonly object EventAllowSorting               = new object();
        private static readonly object EventGridLineColor              = new object();
        private static readonly object EventGridLineStyle              = new object();
        private static readonly object EventHeaderBackColor            = new object();
        private static readonly object EventHeaderForeColor            = new object();
        private static readonly object EventHeaderFont                 = new object();
        private static readonly object EventLinkColor                  = new object();
        private static readonly object EventLinkHoverColor             = new object();
        private static readonly object EventPreferredColumnWidth       = new object();
        private static readonly object EventPreferredRowHeight         = new object();
        private static readonly object EventColumnHeadersVisible       = new object();
        private static readonly object EventRowHeaderWidth             = new object();
        private static readonly object EventSelectionBackColor         = new object();
        private static readonly object EventSelectionForeColor         = new object();
        private static readonly object EventMappingName                = new object();
        private static readonly object EventAlternatingBackColor       = new object();
        private static readonly object EventBackColor                  = new object();
        private static readonly object EventForeColor                  = new object();
        private static readonly object EventReadOnly                   = new object();
        private static readonly object EventRowHeadersVisible          = new object();

        // add a bunch of properties, taken from the dataGrid
        //

        // default values
        //
        private const bool defaultAllowSorting = true;
        private const  DataGridLineStyle  defaultGridLineStyle    = DataGridLineStyle.Solid;
        private const int       defaultPreferredColumnWidth = 75;
        private const int       defaultRowHeaderWidth       = 35;
        internal static readonly Font      defaultFont                 = Control.DefaultFont;
        internal static readonly int       defaultFontHeight           = defaultFont.Height;


        // the actual place holders for properties
        //
        private bool              allowSorting = defaultAllowSorting;
        private SolidBrush        alternatingBackBrush = DefaultAlternatingBackBrush;
        private SolidBrush        backBrush = DefaultBackBrush;
        private SolidBrush        foreBrush = DefaultForeBrush;
        private SolidBrush        gridLineBrush        = DefaultGridLineBrush;
        private DataGridLineStyle gridLineStyle    = defaultGridLineStyle;
        internal SolidBrush       headerBackBrush   = DefaultHeaderBackBrush;
        internal Font             headerFont        = null; // this is ambient property to Font value.
        internal SolidBrush       headerForeBrush   = DefaultHeaderForeBrush;
        internal Pen            headerForePen     = DefaultHeaderForePen;
        private SolidBrush             linkBrush            = DefaultLinkBrush;
        internal int            preferredColumnWidth = defaultPreferredColumnWidth;
        private int               prefferedRowHeight   = defaultFontHeight + 3;
        private SolidBrush        selectionBackBrush  = DefaultSelectionBackBrush;
        private SolidBrush        selectionForeBrush    = DefaultSelectionForeBrush;
        private int               rowHeaderWidth = defaultRowHeaderWidth;
        private bool              rowHeadersVisible = true;
        private bool              columnHeadersVisible = true;

        // the dataGrid would need to know when the ColumnHeaderVisible, RowHeadersVisible, RowHeaderWidth
        // and preferredColumnWidth, preferredRowHeight properties are changed in the current dataGridTableStyle
        // also: for GridLineStyle, GridLineColor, ForeColor, BackColor, HeaderBackColor, HeaderFont, HeaderForeColor
        // LinkColor, LinkHoverColor
        //

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.AllowSorting"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(defaultAllowSorting),
        SRDescription(SR.DataGridAllowSortingDescr)
        ]
        public bool AllowSorting {
            get {
                return allowSorting;
            }
            set {
                if (this.isDefaultTableStyle) {
                    throw new ArgumentException(SR.GetString(SR.DataGridDefaultTableSet, "AllowSorting"));
                }

                if (allowSorting != value) {
                    allowSorting = value;
                    OnAllowSortingChanged(EventArgs.Empty);
                }
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.AllowSortingChanged"]/*' />
        /// <devdoc>
        /// <para>[To be  supplied]</para>
        /// </devdoc>
        public event EventHandler AllowSortingChanged {
            add {
                Events.AddHandler(EventAllowSorting, value);
            }
            remove {
                Events.RemoveHandler(EventAllowSorting, value);
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.AlternatingBackColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
         SRCategory(SR.CatColors),
         SRDescription(SR.DataGridAlternatingBackColorDescr)
        ]
        public Color AlternatingBackColor {
            get {
                return alternatingBackBrush.Color;
            }
            set {
                if (this.isDefaultTableStyle) {
                    throw new ArgumentException(SR.GetString(SR.DataGridDefaultTableSet, "AlternatingBackColor"));
                }

                if (System.Windows.Forms.DataGrid.IsTransparentColor(value))
                    throw new ArgumentException(SR.GetString(SR.DataGridTableStyleTransparentAlternatingBackColorNotAllowed));
                if (value.IsEmpty) {
                    throw new ArgumentException(SR.GetString(SR.DataGridEmptyColor,
                                                              "AlternatingBackColor"));
                }
                if (!alternatingBackBrush.Color.Equals(value)) {
                    alternatingBackBrush = new SolidBrush(value);
                    InvalidateInside();
                    OnAlternatingBackColorChanged(EventArgs.Empty);
                }
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.AlternatingBackColorChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event EventHandler AlternatingBackColorChanged {
            add {
                Events.AddHandler(EventAlternatingBackColor, value);
            }
            remove {
                Events.RemoveHandler(EventAlternatingBackColor, value);
            }
        }
        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.ResetAlternatingBackColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ResetAlternatingBackColor() {
            if (ShouldSerializeAlternatingBackColor()) {
                AlternatingBackColor = DefaultAlternatingBackBrush.Color;
                InvalidateInside();
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.ShouldSerializeAlternatingBackColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual bool ShouldSerializeAlternatingBackColor()
        {
            return !AlternatingBackBrush.Equals(DefaultAlternatingBackBrush);
        }

        internal SolidBrush AlternatingBackBrush {
            get {
                return alternatingBackBrush;
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.ShouldSerializeBackColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected bool ShouldSerializeBackColor() {
            return !System.Windows.Forms.DataGridTableStyle.DefaultBackBrush.Equals(this.backBrush);
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.ShouldSerializeForeColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected bool ShouldSerializeForeColor() {
            return !System.Windows.Forms.DataGridTableStyle.DefaultForeBrush.Equals(this.foreBrush);
        }

        internal SolidBrush BackBrush {
            get {
                return this.backBrush;
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.BackColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
         SRCategory(SR.CatColors),
         SRDescription(SR.ControlBackColorDescr)
        ]
        public Color BackColor {
            get {
                return this.backBrush.Color;
            }
            set {
                if (this.isDefaultTableStyle) {
                    throw new ArgumentException(SR.GetString(SR.DataGridDefaultTableSet, "BackColor"));
                }

                if (System.Windows.Forms.DataGrid.IsTransparentColor(value))
                    throw new ArgumentException(SR.GetString(SR.DataGridTableStyleTransparentBackColorNotAllowed));
                if (value.IsEmpty) {
                    throw new ArgumentException(SR.GetString(SR.DataGridEmptyColor,
                                                              "BackColor"));
                }
                if (!backBrush.Color.Equals(value)) {
                    this.backBrush = new SolidBrush(value);
                    InvalidateInside();
                    OnBackColorChanged(EventArgs.Empty);
                }
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.BackColorChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event EventHandler BackColorChanged {
            add {
                Events.AddHandler(EventBackColor, value);
            }
            remove {
                Events.RemoveHandler(EventBackColor, value);
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.ResetBackColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ResetBackColor() {
            if (!this.backBrush.Equals(DefaultBackBrush)) {
                this.BackColor = DefaultBackBrush.Color;
            }
        }

        internal int BorderWidth {
            get {
                DataGrid dataGrid = this.DataGrid;
                if (dataGrid == null)
                    return 0;
                // if the user set the GridLineStyle property on the dataGrid.
                // then use the value of that property
                DataGridLineStyle gridStyle;
                int gridLineWidth;
                if (this.IsDefault) {
                    gridStyle = this.DataGrid.GridLineStyle;
                    gridLineWidth = this.DataGrid.GridLineWidth;
                } else {
                    gridStyle = this.GridLineStyle;
                    gridLineWidth = this.GridLineWidth;
                }

                if (gridStyle == DataGridLineStyle.None)
                    return 0;

                return gridLineWidth;
            }
        }

        internal static SolidBrush DefaultAlternatingBackBrush {
            get {
                return (SolidBrush)SystemBrushes.Window;
            }
        }
        internal static SolidBrush DefaultBackBrush {
            get {
                return (SolidBrush)SystemBrushes.Window;
            }
        }
        internal static SolidBrush DefaultForeBrush {
            get {
                return (SolidBrush)SystemBrushes.WindowText;
            }
        }
        private static SolidBrush DefaultGridLineBrush {
            get {
                return (SolidBrush)SystemBrushes.Control;
            }
        }
        private static SolidBrush DefaultHeaderBackBrush {
            get {
                return (SolidBrush)SystemBrushes.Control;
            }
        }
        private static SolidBrush DefaultHeaderForeBrush {
            get {
                return (SolidBrush)SystemBrushes.ControlText;
            }
        }
        private static Pen DefaultHeaderForePen {
            get {
                return new Pen(SystemColors.ControlText);
            }
        }
        private static SolidBrush DefaultLinkBrush {
            get {
                return (SolidBrush)SystemBrushes.HotTrack;
            }
        }
        private static SolidBrush DefaultSelectionBackBrush {
            get {
                return (SolidBrush)SystemBrushes.ActiveCaption;
            }
        }
        private static SolidBrush DefaultSelectionForeBrush {
            get {
                return (SolidBrush)SystemBrushes.ActiveCaptionText;
            }
        }

        internal int FocusedRelation {
            get {
                return focusedRelation;
            }
            set {
                if (focusedRelation != value) {
                    focusedRelation = value;
                    if (focusedRelation == -1) {
                        focusedTextWidth = 0;
                    } else {
                        Graphics g = DataGrid.CreateGraphicsInternal();
                        focusedTextWidth = (int) Math.Ceiling(g.MeasureString(((string) RelationsList[focusedRelation]), DataGrid.LinkFont).Width);
                        g.Dispose();
                    }
                }
            }
        }

        internal int FocusedTextWidth {
            get {
                return this.focusedTextWidth;
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.ForeColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
         SRCategory(SR.CatColors),
         SRDescription(SR.ControlForeColorDescr)
        ]
        public Color ForeColor {
            get {
                return this.foreBrush.Color;
            }
            set {
                if (this.isDefaultTableStyle) {
                    throw new ArgumentException(SR.GetString(SR.DataGridDefaultTableSet, "ForeColor"));
                }

                if (value.IsEmpty) {
                    throw new ArgumentException(SR.GetString(SR.DataGridEmptyColor,
                                                              "BackColor"));
                }
                if (!foreBrush.Color.Equals(value)) {
                    this.foreBrush = new SolidBrush(value);
                    InvalidateInside();
                    OnForeColorChanged(EventArgs.Empty);
                }
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.ForeColorChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event EventHandler ForeColorChanged {
            add {
                Events.AddHandler(EventForeColor, value);
            }
            remove {
                Events.RemoveHandler(EventForeColor, value);
            }
        }

        internal SolidBrush ForeBrush {
            get {
                return this.foreBrush;
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.ResetForeColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ResetForeColor() {
            if (!this.foreBrush.Equals(DefaultForeBrush)) {
                this.ForeColor = DefaultForeBrush.Color;
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.GridLineColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
         SRCategory(SR.CatColors),
         SRDescription(SR.DataGridGridLineColorDescr)
        ]
        public Color GridLineColor {
            get {
                return gridLineBrush.Color;
            }
            set {
                if (this.isDefaultTableStyle) {
                    throw new ArgumentException(SR.GetString(SR.DataGridDefaultTableSet, "GridLineColor"));
                }

                if (gridLineBrush.Color != value) {
                    if (value.IsEmpty)
                        throw new ArgumentException(SR.GetString(SR.DataGridEmptyColor, "GridLineColor"));
                    gridLineBrush = new SolidBrush(value);

                    // Invalidate(layout.Data);
                    OnGridLineColorChanged(EventArgs.Empty);
                }
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.GridLineColorChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event EventHandler GridLineColorChanged {
            add {
                Events.AddHandler(EventGridLineColor, value);
            }
            remove {
                Events.RemoveHandler(EventGridLineColor, value);
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.ShouldSerializeGridLineColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual bool ShouldSerializeGridLineColor()
        {
            return !GridLineBrush.Equals(DefaultGridLineBrush);
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.ResetGridLineColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ResetGridLineColor() {
            if (ShouldSerializeGridLineColor()) {
                GridLineColor = DefaultGridLineBrush.Color;
            }
        }

        internal SolidBrush GridLineBrush {
            get {
                return gridLineBrush;
            }
        }

        internal int GridLineWidth {
            get {
                Debug.Assert(this.GridLineStyle == DataGridLineStyle.Solid || this.GridLineStyle == DataGridLineStyle.None, "are there any other styles?");
                return GridLineStyle == DataGridLineStyle.Solid ? 1 : 0;
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.GridLineStyle"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
         SRCategory(SR.CatAppearance),
         DefaultValue(defaultGridLineStyle),
         SRDescription(SR.DataGridGridLineStyleDescr)
        ]
        public DataGridLineStyle GridLineStyle {
            get {
                return gridLineStyle;
            }
            set {
                if (this.isDefaultTableStyle) {
                    throw new ArgumentException(SR.GetString(SR.DataGridDefaultTableSet, "GridLineStyle"));
                }

                if (!Enum.IsDefined(typeof(DataGridLineStyle), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(DataGridLineStyle));
                }
                if (gridLineStyle != value) {
                    gridLineStyle = value;
                    // Invalidate(layout.Data);
                    OnGridLineStyleChanged(EventArgs.Empty);
                }
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.GridLineStyleChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event EventHandler GridLineStyleChanged {
            add {
                Events.AddHandler(EventGridLineStyle, value);
            }
            remove {
                Events.RemoveHandler(EventGridLineStyle, value);
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.HeaderBackColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
         SRCategory(SR.CatColors),
         SRDescription(SR.DataGridHeaderBackColorDescr)         
        ]
        public Color HeaderBackColor {
            get {
                return headerBackBrush.Color;
            }
            set {
                if (this.isDefaultTableStyle) {
                    throw new ArgumentException(SR.GetString(SR.DataGridDefaultTableSet, "HeaderBackColor"));
                }

                if (System.Windows.Forms.DataGrid.IsTransparentColor(value))
                    throw new ArgumentException(SR.GetString(SR.DataGridTableStyleTransparentHeaderBackColorNotAllowed));
                if (value.IsEmpty)
                    throw new ArgumentException(SR.GetString(SR.DataGridEmptyColor, "HeaderBackColor"));
                if (!value.Equals(headerBackBrush.Color)) {
                    headerBackBrush = new SolidBrush(value);

                    /*
                    if (layout.RowHeadersVisible)
                        Invalidate(layout.RowHeaders);
                    if (layout.ColumnHeadersVisible)
                        Invalidate(layout.ColumnHeaders);
                    Invalidate(layout.TopLeftHeader);
                    */
                    OnHeaderBackColorChanged(EventArgs.Empty);
                }
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.HeaderBackColorChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event EventHandler HeaderBackColorChanged {
            add {
                Events.AddHandler(EventHeaderBackColor, value);
            }
            remove {
                Events.RemoveHandler(EventHeaderBackColor, value);
            }
        }

        internal SolidBrush HeaderBackBrush {
            get {
                return headerBackBrush;
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.ShouldSerializeHeaderBackColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual bool ShouldSerializeHeaderBackColor()
        {
            return !HeaderBackBrush.Equals(DefaultHeaderBackBrush);
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.ResetHeaderBackColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ResetHeaderBackColor() {
            if(ShouldSerializeHeaderBackColor()) {
                HeaderBackColor = DefaultHeaderBackBrush.Color;
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.HeaderFont"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
         SRCategory(SR.CatAppearance),
         Localizable(true),
         AmbientValue(null),
         SRDescription(SR.DataGridHeaderFontDescr)
        ]
        public Font HeaderFont {
            get {
                return(headerFont == null ? (this.DataGrid == null ? Control.DefaultFont : this.DataGrid.Font) : headerFont);
            }
            set {
                if (this.isDefaultTableStyle) {
                    throw new ArgumentException(SR.GetString(SR.DataGridDefaultTableSet, "HeaderFont"));
                }

                if (value == null && headerFont != null || (value != null && !value.Equals(headerFont))) {
                    headerFont = value;
                    /*
                    RecalculateFonts();
                    PerformLayout();
                    Invalidate(layout.Inside);
                    */
                    OnHeaderFontChanged(EventArgs.Empty);
                }
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.HeaderFontChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event EventHandler HeaderFontChanged {
            add {
                Events.AddHandler(EventHeaderFont, value);
            }
            remove {
                Events.RemoveHandler(EventHeaderFont, value);
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.ShouldSerializeHeaderFont"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        private bool ShouldSerializeHeaderFont() {
            return(headerFont != null);
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.ResetHeaderFont"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ResetHeaderFont() {
            if (headerFont != null) {
                headerFont = null;
                /*
                RecalculateFonts();
                PerformLayout();
                Invalidate(layout.Inside);
                */
                OnHeaderFontChanged(EventArgs.Empty);
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.HeaderForeColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
         SRCategory(SR.CatColors),
         SRDescription(SR.DataGridHeaderForeColorDescr)         
        ]
        public Color HeaderForeColor {
            get {
                return headerForePen.Color;
            }
            set {
                if (this.isDefaultTableStyle) {
                    throw new ArgumentException(SR.GetString(SR.DataGridDefaultTableSet, "HeaderForeColor"));
                }

                if (value.IsEmpty)
                    throw new ArgumentException(SR.GetString(SR.DataGridEmptyColor, "HeaderForeColor"));
                if (!value.Equals(headerForePen.Color)) {
                    headerForePen = new Pen(value);
                    headerForeBrush = new SolidBrush(value);

                    /*
                    if (layout.RowHeadersVisible)
                        Invalidate(layout.RowHeaders);
                    if (layout.ColumnHeadersVisible)
                        Invalidate(layout.ColumnHeaders);
                    Invalidate(layout.TopLeftHeader);
                    */
                    OnHeaderForeColorChanged(EventArgs.Empty);
                }
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.HeaderForeColorChanged"]/*' />
        public event EventHandler HeaderForeColorChanged {
            add {
                Events.AddHandler(EventHeaderForeColor, value);
            }
            remove {
                Events.RemoveHandler(EventHeaderForeColor, value);
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.ShouldSerializeHeaderForeColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual bool ShouldSerializeHeaderForeColor()
        {
            return !HeaderForePen.Equals(DefaultHeaderForePen);
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.ResetHeaderForeColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ResetHeaderForeColor() {
            if(ShouldSerializeHeaderForeColor()) {
                HeaderForeColor = DefaultHeaderForeBrush.Color;
            }
        }

        internal SolidBrush HeaderForeBrush {
            get {
                return this.headerForeBrush;
            }
        }

        internal Pen HeaderForePen {
            get {
                return headerForePen;
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.LinkColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
         SRCategory(SR.CatColors),
         SRDescription(SR.DataGridLinkColorDescr)
        ]
        public Color LinkColor {
            get {
                return linkBrush.Color;
            }
            set {
                if (this.isDefaultTableStyle) {
                    throw new ArgumentException(SR.GetString(SR.DataGridDefaultTableSet, "LinkColor"));
                }

                if (value.IsEmpty)
                    throw new ArgumentException(SR.GetString(SR.DataGridEmptyColor, "LinkColor"));
                if (!linkBrush.Color.Equals(value)) {
                    linkBrush = new SolidBrush(value);
                    // Invalidate(layout.Data);
                    OnLinkColorChanged(EventArgs.Empty);
                }
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.LinkColorChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event EventHandler LinkColorChanged {
            add {
                Events.AddHandler(EventLinkColor, value);
            }
            remove {
                Events.RemoveHandler(EventLinkColor, value);
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.ShouldSerializeLinkColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual bool ShouldSerializeLinkColor()
        {
            return !LinkBrush.Equals(DefaultLinkBrush);
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.ResetLinkColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ResetLinkColor() {
            if (ShouldSerializeLinkColor())
                LinkColor = DefaultLinkBrush.Color;
        }

        internal Brush LinkBrush {
            get {
                return linkBrush;
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.LinkHoverColor"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
         SRDescription(SR.DataGridLinkHoverColorDescr),
         SRCategory(SR.CatColors),
         Browsable(false),
         EditorBrowsable(EditorBrowsableState.Never),
         ComVisible(false)
        ]
        public Color LinkHoverColor {
            get {
                return this.LinkColor;
            }
            set {
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.LinkHoverColorChanged"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event EventHandler LinkHoverColorChanged {
            add {
                Events.AddHandler(EventLinkHoverColor, value);
            }
            remove {
                Events.RemoveHandler(EventLinkHoverColor, value);
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.ShouldSerializeLinkHoverColor"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual bool ShouldSerializeLinkHoverColor()
        {
            return false;
            // return !LinkHoverBrush.Equals(defaultLinkHoverBrush);
        }

        internal Rectangle RelationshipRect {
            get {
                if (this.relationshipRect.IsEmpty) {
                    ComputeRelationshipRect();
                }
                return this.relationshipRect;
            }
            // do we really need the set....
            set {
                relationshipRect = value;
            }
        }

        private Rectangle ComputeRelationshipRect() {
            if (relationshipRect.IsEmpty && DataGrid.AllowNavigation) {
                Debug.WriteLineIf(CompModSwitches.DGRelationShpRowLayout.TraceVerbose, "GetRelationshipRect grinding away");
                Graphics g = DataGrid.CreateGraphicsInternal();
                relationshipRect = new Rectangle();
                relationshipRect.X = 0; //indentWidth;
                // relationshipRect.Y = base.Height - BorderWidth;

                // Determine the width of the widest relationship name
                int longestRelationship = 0;
                for (int r = 0; r < this.RelationsList.Count; ++r) {
                    int rwidth = (int) Math.Ceiling(g.MeasureString(((string) this.RelationsList[r]), this.DataGrid.LinkFont).Width)
;
                    if (rwidth > longestRelationship)
                        longestRelationship = rwidth;
                }

                g.Dispose();

                relationshipRect.Width = longestRelationship + 5;
                relationshipRect.Width += 2; // relationshipRect border;
                relationshipRect.Height = BorderWidth + relationshipHeight * this.RelationsList.Count;
                relationshipRect.Height += 2; // relationship border
                if (this.RelationsList.Count > 0)
                    relationshipRect.Height += 2 * relationshipSpacing;
            }
            return relationshipRect;
        }

        internal void ResetRelationsUI() {
            this.relationshipRect = Rectangle.Empty;
            this.focusedRelation = -1;
            this.relationshipHeight = this.dataGrid.LinkFontHeight + relationshipSpacing;
        }

        internal int RelationshipHeight {
            get {
                return this.relationshipHeight;
            }
            // do we really need the set....
            set {
                relationshipHeight = value;
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.ResetLinkHoverColor"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ResetLinkHoverColor() { 
            /*if (ShouldSerializeLinkHoverColor())
                LinkHoverColor = defaultLinkHoverBrush.Color;*/
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.PreferredColumnWidth"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
         DefaultValue(defaultPreferredColumnWidth),
         SRCategory(SR.CatLayout),
         Localizable(true),
         SRDescription(SR.DataGridPreferredColumnWidthDescr),
         TypeConverter(typeof(DataGridPreferredColumnWidthTypeConverter))
        ]
        public int PreferredColumnWidth {
            get {
                return preferredColumnWidth;
            }
            set {
                if (this.isDefaultTableStyle) {
                    throw new ArgumentException(SR.GetString(SR.DataGridDefaultTableSet, "PreferredColumnWidth"));
                }

                if (value < 0)
                    throw new ArgumentException(SR.GetString(SR.DataGridColumnWidth), "PreferredColumnWidth");
                if (preferredColumnWidth != value) {
                    preferredColumnWidth = value;

                    /*
                    // reset the dataGridRows
                    SetDataGridRows(null, this.DataGridRowsLength);
                    // layout the horizontal scroll bar
                    PerformLayout();
                    // invalidate everything
                    Invalidate();
                    */

                    OnPreferredColumnWidthChanged(EventArgs.Empty);
                }
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.PreferredColumnWidthChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event EventHandler PreferredColumnWidthChanged {
            add {
                Events.AddHandler(EventPreferredColumnWidth, value);
            }
            remove {
                Events.RemoveHandler(EventPreferredColumnWidth, value);
            }
        }
        
        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.PreferredRowHeight"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
         SRCategory(SR.CatLayout),
         Localizable(true),
         SRDescription(SR.DataGridPreferredRowHeightDescr)
        ]
        public int PreferredRowHeight {
            get {
                return prefferedRowHeight;
            }
            set {
                if (this.isDefaultTableStyle) {
                    throw new ArgumentException(SR.GetString(SR.DataGridDefaultTableSet, "PrefferedRowHeight"));
                }

                if (value < 0)
                    throw new ArgumentException(SR.GetString(SR.DataGridRowRowHeight));
                prefferedRowHeight = value;

                /*
                bool needToRedraw = false;
                DataGridRow[] rows = DataGridRows;

                for (int i = 0; i < DataGridRowsLength; i++)
                {
                    if (rows[i].Height != value) needToRedraw = false;
                    rows[i].Height = value;
                }

                // if all rows' height was equal to "value" before setting it, then
                // there is no need to redraw.
                if (!needToRedraw)
                    return;

                // need to layout the scroll bars:
                PerformLayout();

                // invalidate the entire area...
                Rectangle rightArea = Rectangle.Union(layout.RowHeaders, layout.Data);
                Invalidate(rightArea);
                */
                OnPreferredRowHeightChanged(EventArgs.Empty);
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.PreferredRowHeightChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event EventHandler PreferredRowHeightChanged {
            add {
                Events.AddHandler(EventPreferredRowHeight, value);
            }
            remove {
                Events.RemoveHandler(EventPreferredRowHeight, value);
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.ShouldSerializePreferredRowHeight"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected bool ShouldSerializePreferredRowHeight()
        {
            return prefferedRowHeight != defaultFontHeight + 3;
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.ColumnHeadersVisible"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
         SRCategory(SR.CatDisplay),
         DefaultValue(true),
         SRDescription(SR.DataGridColumnHeadersVisibleDescr)
        ]
        public bool ColumnHeadersVisible {
            get {
                return columnHeadersVisible;
            }
            set {
                if (columnHeadersVisible != value) {
                    columnHeadersVisible = value;
                    /*
                    PerformLayout();
                    InvalidateInside();
                    */
                    OnColumnHeadersVisibleChanged(EventArgs.Empty);
                }
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.ColumnHeadersVisibleChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event EventHandler ColumnHeadersVisibleChanged {
            add {
                Events.AddHandler(EventColumnHeadersVisible, value);
            }
            remove {
                Events.RemoveHandler(EventColumnHeadersVisible, value);
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.RowHeadersVisible"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
         SRCategory(SR.CatDisplay),
         DefaultValue(true),
         SRDescription(SR.DataGridRowHeadersVisibleDescr)
        ]
        public bool RowHeadersVisible {
            get {
                return rowHeadersVisible;
            }
            set {
                if (rowHeadersVisible != value) {
                    rowHeadersVisible = value;
                    /*
                    PerformLayout();
                    InvalidateInside();
                    */
                    OnRowHeadersVisibleChanged(EventArgs.Empty);
                }
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.RowHeadersVisibleChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event EventHandler RowHeadersVisibleChanged {
            add {
                Events.AddHandler(EventRowHeadersVisible, value);
            }
            remove {
                Events.RemoveHandler(EventRowHeadersVisible, value);
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.RowHeaderWidth"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
         SRCategory(SR.CatLayout),
         DefaultValue(defaultRowHeaderWidth),
         Localizable(true),
         SRDescription(SR.DataGridRowHeaderWidthDescr)
        ]
        public int RowHeaderWidth {
            get {
                return rowHeaderWidth;
            }
            set {
                if (this.DataGrid != null)
                    value = Math.Max(this.DataGrid.MinimumRowHeaderWidth(), value);
                if (rowHeaderWidth != value)
                {
                    rowHeaderWidth = value;
                    /*
                    if (layout.RowHeadersVisible)
                    {
                        PerformLayout();
                        InvalidateInside();
                    }
                    */
                    OnRowHeaderWidthChanged(EventArgs.Empty);
                }
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.RowHeaderWidthChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event EventHandler RowHeaderWidthChanged {
            add {
                Events.AddHandler(EventRowHeaderWidth, value);
            }
            remove {
                Events.RemoveHandler(EventRowHeaderWidth, value);
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.SelectionBackColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
         SRCategory(SR.CatColors),
         SRDescription(SR.DataGridSelectionBackColorDescr)
        ]
        public Color SelectionBackColor {
            get {
                return selectionBackBrush.Color;
            }
            set {
                if (this.isDefaultTableStyle) {
                    throw new ArgumentException(SR.GetString(SR.DataGridDefaultTableSet, "SelectionBackColor"));
                }

                if (System.Windows.Forms.DataGrid.IsTransparentColor(value))
                    throw new ArgumentException(SR.GetString(SR.DataGridTableStyleTransparentSelectionBackColorNotAllowed));
                if (value.IsEmpty)
                    throw new ArgumentException(SR.GetString(SR.DataGridEmptyColor, "SelectionBackColor"));
                if (!value.Equals(selectionBackBrush.Color)) {
                    selectionBackBrush = new SolidBrush(value);

                    InvalidateInside();

                    OnSelectionBackColorChanged(EventArgs.Empty);
                }
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.SelectionBackColorChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event EventHandler SelectionBackColorChanged {
            add {
                Events.AddHandler(EventSelectionBackColor, value);
            }
            remove {
                Events.RemoveHandler(EventSelectionBackColor, value);
            }
        }

        internal SolidBrush SelectionBackBrush {
            get {
                return this.selectionBackBrush;
            }
        }

        internal SolidBrush SelectionForeBrush {
            get {
                return this.selectionForeBrush;
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.ShouldSerializeSelectionBackColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected bool ShouldSerializeSelectionBackColor()
        {
            return !DefaultSelectionBackBrush.Equals(selectionBackBrush);
        }
        
        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.ResetSelectionBackColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ResetSelectionBackColor() {
            if (ShouldSerializeSelectionBackColor())
                SelectionBackColor = DefaultSelectionBackBrush.Color;
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.SelectionForeColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
         Description("The foreground color for the current data grid row"),
         SRCategory(SR.CatColors),
         SRDescription(SR.DataGridSelectionForeColorDescr)        
        ]
        public Color SelectionForeColor {
            get {
                return selectionForeBrush.Color;
            }
            set {
                if (this.isDefaultTableStyle) {
                    throw new ArgumentException(SR.GetString(SR.DataGridDefaultTableSet, "SelectionForeColor"));
                }

                if (value.IsEmpty)
                    throw new ArgumentException(SR.GetString(SR.DataGridEmptyColor, "SelectionForeColor"));
                if (!value.Equals(selectionForeBrush.Color)) {
                    selectionForeBrush = new SolidBrush(value);

                    InvalidateInside();

                    OnSelectionForeColorChanged(EventArgs.Empty);
                }
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.SelectionForeColorChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event EventHandler SelectionForeColorChanged {
            add {
                Events.AddHandler(EventSelectionForeColor, value);
            }
            remove {
                Events.RemoveHandler(EventSelectionForeColor, value);
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.ShouldSerializeSelectionForeColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual bool ShouldSerializeSelectionForeColor()
        {
            return !SelectionForeBrush.Equals(DefaultSelectionForeBrush);
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.ResetSelectionForeColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ResetSelectionForeColor() {
            if (ShouldSerializeSelectionForeColor())
                SelectionForeColor = DefaultSelectionForeBrush.Color;
        }

        // will need this function from the dataGrid
        //
        private void InvalidateInside() {
            if (this.DataGrid != null)
                this.DataGrid.InvalidateInside();
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.DefaultTableStyle"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static DataGridTableStyle DefaultTableStyle = new DataGridTableStyle(true);


        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.DataGridTableStyle"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Windows.Forms.DataGridTableStyle'/> class.</para>
        /// </devdoc>
        public DataGridTableStyle(bool isDefaultTableStyle) {
            gridColumns = new GridColumnStylesCollection(this, isDefaultTableStyle);
            gridColumns.CollectionChanged += new CollectionChangeEventHandler(this.OnColumnCollectionChanged);
            this.isDefaultTableStyle = isDefaultTableStyle;
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.DataGridTableStyle1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DataGridTableStyle() : this(false) {
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.DataGridTableStyle2"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Windows.Forms.DataGridTableStyle'/> class with the specified
        /// <see cref='System.Windows.Forms.CurrencyManager'/>.</para>
        /// </devdoc>
        public DataGridTableStyle(CurrencyManager listManager) : this() {
            Debug.Assert(listManager != null, "the DataGridTabel cannot use a null listManager");
            this.MappingName = listManager.GetListName();
            // set up the Relations and the columns
            SetGridColumnStylesCollection(listManager);
        }

        internal void SetRelationsList(CurrencyManager listManager) {
            PropertyDescriptorCollection propCollection = listManager.GetItemProperties();
            Debug.Assert(!this.IsDefault, "the grid can set the relations only on a table that was manually added by the user");
            int propCount = propCollection.Count;
            if (relationsList.Count > 0)
                relationsList.Clear();
            for (int i = 0; i < propCount; i++) {
                PropertyDescriptor prop = propCollection[i];
                Debug.Assert(prop != null, "prop is null: how that happened?");
                if (this.PropertyDescriptorIsARelation(prop)) {
                    // relation
                    relationsList.Add(prop.Name);
                }
            }
        }

        internal void SetGridColumnStylesCollection(CurrencyManager listManager) {
            // when we are setting the gridColumnStyles, do not handle any gridColumnCollectionChanged events
            gridColumns.CollectionChanged -= new CollectionChangeEventHandler(this.OnColumnCollectionChanged);

            PropertyDescriptorCollection propCollection = listManager.GetItemProperties();

            // we need to clear the relations list
            if (relationsList.Count > 0)
                relationsList.Clear();

            Debug.Assert(propCollection != null, "propCollection is null: how that happened?");
            int propCount = propCollection.Count;
            for (int i = 0; i < propCount; i++) {
                PropertyDescriptor prop = propCollection[i];
                Debug.Assert(prop != null, "prop is null: how that happened?");
                // do not take into account the properties that are browsable.
                if (!prop.IsBrowsable)
                    continue;
                if (this.PropertyDescriptorIsARelation(prop)) {
                    // relation
                    relationsList.Add(prop.Name);
                }
                else
                {
                    // column
                    DataGridColumnStyle col = this.CreateGridColumn(prop, this.isDefaultTableStyle);
                    if (this.isDefaultTableStyle)
                        gridColumns.AddDefaultColumn(col);
                    else {
                        col.MappingName = prop.Name;
                        col.HeaderText = prop.Name;
                        gridColumns.Add(col);
                    }
                }
            }

            // now we are able to handle the collectionChangeEvents
            gridColumns.CollectionChanged += new CollectionChangeEventHandler(this.OnColumnCollectionChanged);
        }

        private bool PropertyDescriptorIsARelation(PropertyDescriptor prop) {
            return typeof(IList).IsAssignableFrom(prop.PropertyType) && !typeof(Array).IsAssignableFrom(prop.PropertyType);
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.CreateGridColumn"]/*' />
        internal protected virtual DataGridColumnStyle CreateGridColumn(PropertyDescriptor prop) {
            return this.CreateGridColumn(prop, false);
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.CreateGridColumn1"]/*' />
        internal protected virtual DataGridColumnStyle CreateGridColumn(PropertyDescriptor prop, bool isDefault) {
            DataGridColumnStyle ret = null;
            Type dataType = prop.PropertyType;

            if (dataType.Equals(typeof(bool)))
                ret = new DataGridBoolColumn(prop, isDefault);
            else if (dataType.Equals(typeof(string)))
                ret = new DataGridTextBoxColumn(prop, isDefault);
            else if (dataType.Equals(typeof(DateTime)))
                ret = new DataGridTextBoxColumn(prop, "d", isDefault);

            else if (dataType.Equals(typeof(Int16)) ||
                     dataType.Equals(typeof(Int32)) ||
                     dataType.Equals(typeof(Int64)) ||
                     dataType.Equals(typeof(UInt16)) ||
                     dataType.Equals(typeof(UInt32)) ||
                     dataType.Equals(typeof(UInt64)) ||
                     dataType.Equals(typeof(Decimal)) ||
                     dataType.Equals(typeof(Double)) ||
                     dataType.Equals(typeof(Single)) ||
                     dataType.Equals(typeof(Byte)) ||
                     dataType.Equals(typeof(SByte))) {
                ret = new DataGridTextBoxColumn(prop, "G", isDefault);
            }
            else
            {
                ret = new DataGridTextBoxColumn(prop, isDefault);
            }
            return ret;
        }

        internal void ResetRelationsList() {
            if (this.isDefaultTableStyle) {
                relationsList.Clear();
            }
        }

        // =------------------------------------------------------------------
        // =        Properties
        // =------------------------------------------------------------------

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.MappingName"]/*' />
        /// <devdoc>
        ///    <para>Gets the name of this grid table.</para>
        /// </devdoc>
        [Editor("System.Windows.Forms.Design.DataGridTableStyleMappingNameEditor, " + AssemblyRef.SystemDesign, typeof(System.Drawing.Design.UITypeEditor))]
        public string MappingName {
            get {
                return mappingName;
            }
            set {
                if (value == null)
                    value = "";
                if (value.Equals(mappingName))
                    return;
                string originalMappingName = this.MappingName;
                mappingName = value;

                // this could throw
                try {
                    if (this.DataGrid != null)
                        this.DataGrid.TableStyles.CheckForMappingNameDuplicates(this);
                } catch {
                    this.mappingName = originalMappingName;
                    throw;
                }
                OnMappingNameChanged(EventArgs.Empty);
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.MappingNameChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event EventHandler MappingNameChanged {
            add {
                Events.AddHandler(EventMappingName, value);
            }
            remove {
                Events.RemoveHandler(EventMappingName, value);
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.RelationsList"]/*' />
        /// <devdoc>
        ///    <para>Gets the
        ///       list of relation objects for the grid table.</para>
        /// </devdoc>
        internal ArrayList RelationsList {
            get {
                return relationsList;
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.GridColumnStyles"]/*' />
        /// <devdoc>
        ///    <para>Gets the collection of columns drawn for this table.</para>
        /// </devdoc>
        [
        Localizable(true),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content)
        ]
        public virtual GridColumnStylesCollection GridColumnStyles {
            get {
                return gridColumns;
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.SetInternalDataGrid"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the <see cref='System.Windows.Forms.DataGrid'/>
        ///       control displaying the table.
        ///    </para>
        /// </devdoc>

        internal void SetInternalDataGrid(DataGrid dG, bool force)
        {
            if (dataGrid != null && dataGrid.Equals(dG) && !force)
                return;
            else {
                dataGrid = dG;
                if (dG != null && dG.Initializing)
                    return;
                int nCols = gridColumns.Count;
                for (int i = 0; i < nCols; i++)
                    gridColumns[i].SetDataGridInternalInColumn(dG);
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.DataGrid"]/*' />
        /// <devdoc>
        /// <para>Gets or sets the <see cref='System.Windows.Forms.DataGrid'/> control for the drawn table.</para>
        /// </devdoc>
        [Browsable(false)]
        public virtual DataGrid DataGrid {
            get {
                return dataGrid;
            }
            set {
                SetInternalDataGrid(value, true);
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.ReadOnly"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value indicating whether columns can be
        ///       edited.</para>
        /// </devdoc>
        [DefaultValue(false)]
        public virtual bool ReadOnly {
            get {
                return readOnly;
            }
            set {
                if (readOnly != value) {
                    readOnly = value;
                    OnReadOnlyChanged(EventArgs.Empty);
                }
            }
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.ReadOnlyChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event EventHandler ReadOnlyChanged {
            add {
                Events.AddHandler(EventReadOnly, value);
            }
            remove {
                Events.RemoveHandler(EventReadOnly, value);
            }
        }

        // =------------------------------------------------------------------
        // =        Methods
        // =------------------------------------------------------------------

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.BeginEdit"]/*' />
        /// <devdoc>
        ///    <para>Requests an edit operation.</para>
        /// </devdoc>
        public bool BeginEdit(DataGridColumnStyle gridColumn, int rowNumber) {
            DataGrid grid = this.DataGrid;
            if (grid == null)
                return false;
            else
                return grid.BeginEdit(gridColumn, rowNumber);
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.EndEdit"]/*' />
        /// <devdoc>
        ///    <para> Requests an end to an edit
        ///       operation.</para>
        /// </devdoc>
        public bool EndEdit(DataGridColumnStyle gridColumn, int rowNumber, bool shouldAbort) {
            DataGrid grid = this.DataGrid;
            if (grid == null)
                return false;
            else
                return grid.EndEdit(gridColumn, rowNumber, shouldAbort);
        }

        internal void InvalidateColumn(DataGridColumnStyle column) {
            int index = GridColumnStyles.IndexOf(column);
            if (index >= 0 && DataGrid != null)
                DataGrid.InvalidateColumn(index);
        }


        private void OnColumnCollectionChanged(object sender, CollectionChangeEventArgs e) {
            gridColumns.CollectionChanged -= new CollectionChangeEventHandler(this.OnColumnCollectionChanged);

            try {
                DataGrid grid = this.DataGrid;
                DataGridColumnStyle col = e.Element as DataGridColumnStyle;
                if (e.Action == CollectionChangeAction.Add) {
                    if (col != null)
                        col.SetDataGridInternalInColumn(grid);
                } else if (e.Action == CollectionChangeAction.Remove) {
                    if (col != null)
                        col.SetDataGridInternalInColumn(null);
                } else {
                    // refresh
                    Debug.Assert(e.Action == CollectionChangeAction.Refresh, "there are only Add, Remove and Refresh in the CollectionChangeAction");
                    // if we get a column in this collectionChangeEventArgs it means
                    // that the propertyDescriptor in that column changed.
                    if (e.Element != null)
                        for (int i = 0; i < gridColumns.Count; i++ )
                            gridColumns[i].SetDataGridInternalInColumn(null);
                }

                if (grid != null)
                    grid.OnColumnCollectionChanged(this, e);
            } finally {
                gridColumns.CollectionChanged += new CollectionChangeEventHandler(this.OnColumnCollectionChanged);
            }
        }

#if false
        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.OnColumnChanged"]/*' />
        /// <devdoc>
        ///      The DataColumnCollection class actually wires up this
        ///      event handler to the PropertyChanged events of
        ///      a DataGridTable's columns.
        /// </devdoc>
        internal void OnColumnChanged(object sender, PropertyChangedEvent event) {
            if (event.PropertyName.Equals("Visible"))
                GenerateVisibleColumnsCache();
        }
#endif
        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.OnReadOnlyChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnReadOnlyChanged(EventArgs e) {
            EventHandler eh = Events[EventReadOnly] as EventHandler;
            if (eh != null)
                eh(this, e);
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.OnMappingNameChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnMappingNameChanged(EventArgs e) {
            EventHandler eh = Events[EventMappingName] as EventHandler;
            if (eh != null)
                eh(this, e);
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.OnAlternatingBackColorChanged"]/*' />
        protected virtual void OnAlternatingBackColorChanged(EventArgs e) {
            EventHandler eh = Events[EventAlternatingBackColor] as EventHandler;
            if (eh != null)
                eh(this, e);
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.OnForeColorChanged"]/*' />
        protected virtual void OnForeColorChanged(EventArgs e) {
            EventHandler eh = Events[EventBackColor] as EventHandler;
            if (eh != null)
                eh(this, e);
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.OnBackColorChanged"]/*' />
        protected virtual void OnBackColorChanged(EventArgs e) {
            EventHandler eh = Events[EventForeColor] as EventHandler;
            if (eh != null)
                eh(this, e);
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.OnAllowSortingChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnAllowSortingChanged(EventArgs e) {
            EventHandler eh = Events[EventAllowSorting] as EventHandler;
            if (eh != null)
                eh(this, e);
        }
        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.OnGridLineColorChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnGridLineColorChanged(EventArgs e) {
            EventHandler eh = Events[EventGridLineColor] as EventHandler;
            if (eh != null)
                eh(this, e);
        }
        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.OnGridLineStyleChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnGridLineStyleChanged(EventArgs e) {
            EventHandler eh = Events[EventGridLineStyle] as EventHandler;
            if (eh != null)
                eh(this, e);
        }
        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.OnHeaderBackColorChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnHeaderBackColorChanged(EventArgs e) {
            EventHandler eh = Events[EventHeaderBackColor] as EventHandler;
            if (eh != null)
                eh(this, e);
        }
        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.OnHeaderFontChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnHeaderFontChanged(EventArgs e) {
            EventHandler eh = Events[EventHeaderFont] as EventHandler;
            if (eh != null)
                eh(this, e);
        }
        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.OnHeaderForeColorChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnHeaderForeColorChanged(EventArgs e) {
            EventHandler eh = Events[EventHeaderForeColor] as EventHandler;
            if (eh != null)
                eh(this, e);
        }
        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.OnLinkColorChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnLinkColorChanged(EventArgs e) {
            EventHandler eh = Events[EventLinkColor] as EventHandler;
            if (eh != null)
                eh(this, e);
        }
        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.OnLinkHoverColorChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnLinkHoverColorChanged(EventArgs e) {
            EventHandler eh = Events[EventLinkHoverColor] as EventHandler;
            if (eh != null)
                eh(this, e);
        }
        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.OnPreferredRowHeightChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnPreferredRowHeightChanged(EventArgs e) {
            EventHandler eh = Events[EventPreferredRowHeight] as EventHandler;
            if (eh != null)
                eh(this, e);
        }
        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.OnPreferredColumnWidthChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnPreferredColumnWidthChanged(EventArgs e) {
            EventHandler eh = Events[EventPreferredColumnWidth] as EventHandler;
            if (eh != null)
                eh(this, e);
        }
        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.OnColumnHeadersVisibleChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnColumnHeadersVisibleChanged(EventArgs e) {
            EventHandler eh = Events[EventColumnHeadersVisible] as EventHandler;
            if (eh != null)
                eh(this, e);
        }
        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.OnRowHeadersVisibleChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnRowHeadersVisibleChanged(EventArgs e) {
            EventHandler eh = Events[EventRowHeadersVisible] as EventHandler;
            if (eh != null)
                eh(this, e);
        }
        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.OnRowHeaderWidthChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnRowHeaderWidthChanged(EventArgs e) {
            EventHandler eh = Events[EventRowHeaderWidth] as EventHandler;
            if (eh != null)
                eh(this, e);
        }
        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.OnSelectionForeColorChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnSelectionForeColorChanged(EventArgs e) {
            EventHandler eh = Events[EventSelectionForeColor] as EventHandler;
            if (eh != null)
                eh(this, e);
        }
        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.OnSelectionBackColorChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnSelectionBackColorChanged(EventArgs e) {
            EventHandler eh = Events[EventSelectionBackColor] as EventHandler;
            if (eh != null)
                eh(this, e);
        }

        /// <include file='doc\DataGridTable.uex' path='docs/doc[@for="DataGridTableStyle.Dispose"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                GridColumnStylesCollection cols = this.GridColumnStyles;
                if (cols != null) {
                    for (int i = 0; i < cols.Count; i++)
                        cols[i].Dispose();
                }
            }
            base.Dispose(disposing);
        }

        internal bool IsDefault {
            get {
                return this.isDefaultTableStyle;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\datastreamfromcomstream.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataStreamFromComStream.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    using System.Runtime.InteropServices;

    using System.Diagnostics;
    using System;
    using System.IO;
    

    /// <include file='doc\DataStreamFromComStream.uex' path='docs/doc[@for="DataStreamFromComStream"]/*' />
    /// <internalonly/>
    /// <devdoc>
    /// </devdoc>
    internal class DataStreamFromComStream : Stream {

        private UnsafeNativeMethods.IStream comStream;

        public DataStreamFromComStream(UnsafeNativeMethods.IStream comStream) : base() {
            this.comStream = comStream;
        }

        public override long Position {
            get {
                return Seek(0, SeekOrigin.Current);
            }

            set {
                Seek(value, SeekOrigin.Begin);
            }
        }

        public override bool CanWrite {
            get {
                return true;
            }
        }

        public override bool CanSeek {
            get {
                return true;
            }
        }

        public override bool CanRead {
            get {
                return true;
            }
        }

        public override long Length {
            get {
                long curPos = this.Position;
                long endPos = Seek(0, SeekOrigin.End);
                this.Position = curPos;
                return endPos - curPos;
            }
        }

        private void _NotImpl(string message) {
            NotSupportedException ex = new NotSupportedException(message, new ExternalException("", NativeMethods.E_NOTIMPL));
            throw ex;
        }

        private unsafe int _Read(void* handle, int bytes) {
            return comStream.Read((IntPtr)(int)handle, bytes);
        }

        private unsafe int _Write(void* handle, int bytes) {
            return comStream.Write((IntPtr)(int)handle, bytes);
        }

        public override void Flush() {
        }

        public unsafe override int Read(byte[] buffer, int index, int count) {
            int bytesRead = 0;
            if (count > 0 && index >= 0 && (count + index) <= buffer.Length) {
                fixed (byte* ch = buffer) {
                    bytesRead = _Read((void*)(ch + index), count); 
                }
            }
            return bytesRead;
        }

        public override void SetLength(long value) {
            comStream.SetSize(value);
        }

        public override long Seek(long offset, SeekOrigin origin) {
            return comStream.Seek(offset, (int)origin);
        }

        public unsafe override void Write(byte[] buffer, int index, int count) {
            int bytesWritten = 0;
            if (count > 0 && index >= 0 && (count + index) <= buffer.Length) {
                try {
                    fixed (byte* b = buffer) {
                        bytesWritten = _Write((void*)(b + index), count);
                    }
                }
                catch {
                }
            }
            if (bytesWritten < count) {
                throw new IOException(SR.GetString(SR.DataStreamWrite));
            }
        }

        public override void Close() {
            if (comStream != null) {
                try {
                    comStream.Commit(NativeMethods.STGC_DEFAULT);
                }
                catch(Exception) {
                }
                comStream = null;
            }
        }

        ~DataStreamFromComStream() {
            comStream = null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\dateboldevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="DateBoldEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Windows.Forms;
    using System.Drawing;
    using Microsoft.Win32;

    /// <include file='doc\DateBoldEvent.uex' path='docs/doc[@for="DateBoldEventArgs"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///     The month calendar control fires this event to request information
    ///     about how the days within the visible months should be displayed.
    /// </devdoc>
    //
    // CONSIDER: Make this a private class inside MonthCalendar
    public class DateBoldEventArgs : EventArgs {
        readonly DateTime   startDate;  //the starting date
        readonly int        size; // requested length of array
        int[]            daysToBold = null;

        internal DateBoldEventArgs(DateTime start, int size) {
            startDate = start;
            this.size = size;
        }
        /// <include file='doc\DateBoldEvent.uex' path='docs/doc[@for="DateBoldEventArgs.StartDate"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DateTime StartDate {
            get { return startDate; }
        }
        /// <include file='doc\DateBoldEvent.uex' path='docs/doc[@for="DateBoldEventArgs.Size"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Size {
            get { return size; }
        }
        /// <include file='doc\DateBoldEvent.uex' path='docs/doc[@for="DateBoldEventArgs.DaysToBold"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int[] DaysToBold {
            get { return daysToBold; }
            set { daysToBold = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\daterangeeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="DateRangeEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;


    /// <include file='doc\DateRangeEventHandler.uex' path='docs/doc[@for="DateRangeEventHandler"]/*' />
    /// <devdoc>
    /// </devdoc>
    public delegate void DateRangeEventHandler(object sender, DateRangeEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\daterangeevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="DateRangeEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Windows.Forms;
    using System.Drawing;
    using Microsoft.Win32;

    /// <include file='doc\DateRangeEvent.uex' path='docs/doc[@for="DateRangeEventArgs"]/*' />
    /// <devdoc>
    ///     The SelectEvent is fired when the user makes an explicit date
    ///     selection within a month calendar control.
    /// </devdoc>
    public class DateRangeEventArgs : EventArgs {

        readonly DateTime start; // The date for the first day in the user's selection range.
        readonly DateTime end;   // The date for the last day in the user's selection range.

        /// <include file='doc\DateRangeEvent.uex' path='docs/doc[@for="DateRangeEventArgs.DateRangeEventArgs"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DateRangeEventArgs(DateTime start, DateTime end) {
            this.start = start;
            this.end = end;
        }

        /// <include file='doc\DateRangeEvent.uex' path='docs/doc[@for="DateRangeEventArgs.Start"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DateTime Start {
            get { return start; }
        }
        /// <include file='doc\DateRangeEvent.uex' path='docs/doc[@for="DateRangeEventArgs.End"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DateTime End {
            get { return end; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\control.cs ===
//------------------------------------------------------------------------------
// <copyright file="Control.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------
/*
 */
namespace System.Windows.Forms {
    using Accessibility;
    using Microsoft.Win32;
    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.ComponentModel.Design.Serialization;
    using System.Configuration.Assemblies;
    using System.Diagnostics;
    using System.Drawing;
    using System.Drawing.Drawing2D;
    using System.Globalization;
    using System.Security.Permissions;
    using System.Security;
    using System.IO;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.Runtime.Serialization;
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Serialization.Formatters.Binary;
    using System.Text;
    using System.Threading;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;    
    using Encoding = System.Text.Encoding;

    /// <include file='doc\Control.uex' path='docs/doc[@for="Control"]/*' />
    /// <devdoc>
    ///    <para>Defines the base class for controls, which are components
    ///       with visual representation.</para>
    /// </devdoc>
    [
    DefaultProperty("Text"),
    DefaultEvent("Click"),
    Designer("System.Windows.Forms.Design.ControlDesigner, " + AssemblyRef.SystemDesign),
    DesignerSerializer("System.Windows.Forms.Design.ControlCodeDomSerializer, " + AssemblyRef.SystemDesign, "System.ComponentModel.Design.Serialization.CodeDomSerializer, " + AssemblyRef.SystemDesign),
    ToolboxItemFilter("System.Windows.Forms")
    ]
    public class Control :
    Component,
    UnsafeNativeMethods.IOleControl,
    UnsafeNativeMethods.IOleObject,
    UnsafeNativeMethods.IOleInPlaceObject,
    UnsafeNativeMethods.IOleInPlaceActiveObject,
    UnsafeNativeMethods.IOleWindow,
    UnsafeNativeMethods.IViewObject,
    UnsafeNativeMethods.IViewObject2,
    UnsafeNativeMethods.IPersist,
    UnsafeNativeMethods.IPersistStreamInit,
    UnsafeNativeMethods.IPersistPropertyBag,
    UnsafeNativeMethods.IPersistStorage,
    UnsafeNativeMethods.IQuickActivate,
    ISynchronizeInvoke,
    IWin32Window {

#if FINALIZATION_WATCH
        static readonly TraceSwitch ControlFinalization = new TraceSwitch("ControlFinalization", "Tracks the creation and destruction of finalization");
        internal static string GetAllocationStack() {
            if (ControlFinalization.TraceVerbose) {
                new EnvironmentPermission(PermissionState.Unrestricted).Assert(); 
                try {
                    return Environment.StackTrace;
                }
                finally {
                    CodeAccessPermission.RevertAssert();
                }
            }
            else {
                return "Enable 'ControlFinalization' switch to see stack of allocation";
            }
        }
        private string allocationSite = Control.GetAllocationStack();
#endif

#if DEBUG        
        internal static readonly TraceSwitch PaletteTracing = new TraceSwitch("PaletteTracing", "Debug Palette code");
        internal static readonly TraceSwitch ControlKeyboardRouting = new TraceSwitch("ControlKeyboardRouting", "Debug Keyboard routing for controls");
        private static readonly BooleanSwitch AssertOnControlCreateSwitch = new BooleanSwitch("AssertOnControlCreate", "Assert when anything directly deriving from control is created.");
#else
        internal static readonly TraceSwitch ControlKeyboardRouting;
        internal static readonly TraceSwitch PaletteTracing;
#endif


#if DEBUG
        internal static readonly BooleanSwitch BufferPinkRect = new BooleanSwitch("BufferPinkRect", "Renders a pink rectangle with painting double buffered controls");
        internal static readonly BooleanSwitch BufferDisabled = new BooleanSwitch("BufferDisabled", "Makes double buffered controls non-double buffered");
#else
        internal static readonly BooleanSwitch BufferPinkRect;
#endif

        private static int WM_GETCONTROLNAME;

        static Control() {
#if DEBUG
            DebugHandleTracker.Initialize();
#endif
            WM_GETCONTROLNAME = SafeNativeMethods.RegisterWindowMessage("WM_GETCONTROLNAME");
        }

        internal const int STATE_CREATED                = 0x00000001;
        internal const int STATE_VISIBLE                = 0x00000002;
        internal const int STATE_ENABLED                = 0x00000004;
        internal const int STATE_TABSTOP                = 0x00000008;
        internal const int STATE_RECREATE               = 0x00000010;
        internal const int STATE_MODAL                  = 0x00000020;
        internal const int STATE_ALLOWDROP              = 0x00000040;
        internal const int STATE_DROPTARGET             = 0x00000080;
        internal const int STATE_NOZORDER               = 0x00000100;
        internal const int STATE_LAYOUTDEFERRED         = 0x00000200;
        internal const int STATE_NOT_USED1              = 0x00000400;
        internal const int STATE_DISPOSED               = 0x00000800;
        internal const int STATE_DISPOSING              = 0x00001000;
        internal const int STATE_MOUSEENTERPENDING      = 0x00002000;
        internal const int STATE_TRACKINGMOUSEEVENT     = 0x00004000;
        internal const int STATE_THREADMARSHALLPENDING  = 0x00008000;
        internal const int STATE_SIZELOCKEDBYOS         = 0x00010000;
        internal const int STATE_CAUSESVALIDATION       = 0x00020000;
        internal const int STATE_CREATINGHANDLE         = 0x00040000;
        internal const int STATE_TOPLEVEL               = 0x00080000;
        internal const int STATE_ISACCESSIBLE           = 0x00100000;
        internal const int STATE_OWNCTLBRUSH            = 0x00200000;
        internal const int STATE_EXCEPTIONWHILEPAINTING = 0x00400000;
        internal const int STATE_NOT_USED2              = 0x00800000;
        internal const int STATE_CHECKEDHOST            = 0x01000000;
        internal const int STATE_HOSTEDINDIALOG         = 0x02000000;
        internal const int STATE_DOUBLECLICKFIRED       = 0x04000000;
        internal const int STATE_MOUSEPRESSED           = 0x08000000;
        internal const int STATE_VALIDATIONCANCELLED    = 0x10000000;

        private static readonly object EventKeyDown                   = new object();
        private static readonly object EventKeyPress                  = new object();
        private static readonly object EventKeyUp                     = new object();
        private static readonly object EventMouseDown                 = new object();
        private static readonly object EventMouseEnter                = new object();
        private static readonly object EventMouseLeave                = new object();
        private static readonly object EventMouseHover                = new object();
        private static readonly object EventMouseMove                 = new object();
        private static readonly object EventMouseUp                   = new object();
        private static readonly object EventMouseWheel                = new object();
        private static readonly object EventClick                     = new object();
        private static readonly object EventDoubleClick               = new object();
        private static readonly object EventMove                      = new object();
        private static readonly object EventResize                    = new object();
        private static readonly object EventLayout                    = new object();
        private static readonly object EventGotFocus                  = new object();
        private static readonly object EventLostFocus                 = new object();
        private static readonly object EventEnabledChanged            = new object();
        private static readonly object EventEnter                     = new object();
        private static readonly object EventLeave                     = new object();
        private static readonly object EventHandleCreated             = new object();
        private static readonly object EventHandleDestroyed           = new object();
        private static readonly object EventVisibleChanged            = new object();
        private static readonly object EventControlAdded              = new object();
        private static readonly object EventControlRemoved            = new object();
        private static readonly object EventChangeUICues              = new object();
        private static readonly object EventSystemColorsChanged       = new object();
        private static readonly object EventValidating                = new object();
        private static readonly object EventValidated                 = new object();
        private static readonly object EventStyleChanged              = new object();
        private static readonly object EventImeModeChanged            = new object();

        private static readonly object EventHelpRequested             = new object();
        private static readonly object EventPaint                     = new object();
        private static readonly object EventInvalidated               = new object();
        private static readonly object EventQueryContinueDrag         = new object();
        private static readonly object EventGiveFeedback              = new object();
        private static readonly object EventDragEnter                 = new object();
        private static readonly object EventDragLeave                 = new object();
        private static readonly object EventDragOver                  = new object();
        private static readonly object EventDragDrop                  = new object();
        private static readonly object EventQueryAccessibilityHelp    = new object();
        private static readonly object EventBackgroundImage           = new object();
        private static readonly object EventBindingContext            = new object();
        private static readonly object EventBackColor                 = new object();
        private static readonly object EventParent                    = new object();
        private static readonly object EventVisible                   = new object();
        private static readonly object EventText                      = new object();
        private static readonly object EventTabStop                   = new object();
        private static readonly object EventTabIndex                  = new object();
        private static readonly object EventSize                      = new object();
        private static readonly object EventRightToLeft               = new object();
        private static readonly object EventLocation                  = new object();
        private static readonly object EventForeColor                 = new object();
        private static readonly object EventFont                      = new object();
        private static readonly object EventEnabled                   = new object();
        private static readonly object EventDock                      = new object();
        private static readonly object EventCursor                    = new object();
        private static readonly object EventContextMenu               = new object();
        private static readonly object EventCausesValidation          = new object();

        #if WIN95_SUPPORT
        private static int mouseWheelMessage = NativeMethods.WM_MOUSEWHEEL;
        private static bool mouseWheelRoutingNeeded;
        private static bool mouseWheelInit;
        #endif

        private static int threadCallbackMessage;

        private static FontHandleWrapper defaultFontHandleWrapper;

        private const int DragDropSDrop    = 0x00040100;
        private const int DragDropSCancel  = 0x00040101;
        private const int DragDropSUseDefaultCursors = 0x00040102;
        private const int AdjustLeft   = 1;
        private const int AdjustTop    = 2;
        private const int AdjustRight  = 4;
        private const int AdjustBottom = 8;
        private const short PaintLayerBackground = 1;
        private const short PaintLayerForeground = 2;

        private static int[] anchorAdjustments = new int[] {
            0,                                                         // TOPLEFT
            AdjustLeft  | AdjustRight,                                 // TOPRIGHT
            AdjustTop   | AdjustBottom,                                // BOTTOMLEFT
            AdjustLeft  | AdjustTop   | AdjustRight | AdjustBottom,    // BOTTOMRIGHT
            AdjustBottom,                                              // LEFT
            AdjustRight,                                               // TOP
            AdjustLeft  | AdjustRight | AdjustBottom,                  // BOTTOM
            AdjustTop   | AdjustRight | AdjustBottom,                  // RIGHT
            AdjustRight | AdjustBottom                                 // CENTER
        };

        private static Font defaultFont;

        private static Hashtable imeModeConversionBits;

        // Tables of conversions from IME context bits to IME mode
        //
        // warning private const int ImeNotAvailable = 0;
        private const int ImeDisabled = 1;
        // warning private const int ImeNotNativeKeyboard = 2;
        private const int ImeClosed = 3;
        private const int ImeNativeFullHiragana = 4;
        private const int ImeNativeHalfHiragana = 5;
        private const int ImeNativeFullKatakana = 6;
        private const int ImeNativeHalfKatakana = 7;
        private const int ImeAlphaFull = 8;
        private const int ImeAlphaHalf = 9;

        private static ImeMode[] japaneseTable = {
            ImeMode.Disable,
            ImeMode.Disable, 
            ImeMode.Off,  
            ImeMode.Off,  
            ImeMode.Hiragana,  
            ImeMode.Hiragana,  
            ImeMode.Katakana,  
            ImeMode.KatakanaHalf,
            ImeMode.AlphaFull,
            ImeMode.Alpha
        };
        private static ImeMode[] koreanTable = {
            ImeMode.Disable,
            ImeMode.Disable,
            ImeMode.Alpha, 
            ImeMode.Alpha, 
            ImeMode.HangulFull,  
            ImeMode.Hangul,   
            ImeMode.HangulFull,  
            ImeMode.Hangul,   
            ImeMode.AlphaFull,
            ImeMode.Alpha
        };
        private static ImeMode[] chineseTable = {
            ImeMode.Off,
            ImeMode.Off, 
            ImeMode.Off,  
            ImeMode.Off,  
            ImeMode.On, 
            ImeMode.On,
            ImeMode.On,
            ImeMode.On,
            ImeMode.On,
            ImeMode.Off
        };

        private static IntPtr defaultImeContext;
        
        // Property store keys for properties.  The property store allocates most efficiently
        // in groups of four, so we try to lump properties in groups of four based on how
        // likely they are going to be used in a group.
        //
        private static readonly int PropName                                = PropertyStore.CreateKey();
        private static readonly int PropBackBrush                           = PropertyStore.CreateKey();
        private static readonly int PropFontHeight                          = PropertyStore.CreateKey();
        private static readonly int PropGraphicsBufferManager               = PropertyStore.CreateKey();
                                                                            
        private static readonly int PropControlsCollection                  = PropertyStore.CreateKey();
        private static readonly int PropBackColor                           = PropertyStore.CreateKey();
        private static readonly int PropForeColor                           = PropertyStore.CreateKey();
        private static readonly int PropLayoutInfo                          = PropertyStore.CreateKey();
        
        private static readonly int PropBackgroundImage                     = PropertyStore.CreateKey();
        private static readonly int PropFont                                = PropertyStore.CreateKey();
        private static readonly int PropFontHandleWrapper                   = PropertyStore.CreateKey();
        private static readonly int PropUserData                            = PropertyStore.CreateKey();

        private static readonly int PropContextMenu                         = PropertyStore.CreateKey();
        private static readonly int PropCursor                              = PropertyStore.CreateKey();
        private static readonly int PropRightToLeft                         = PropertyStore.CreateKey();
        private static readonly int PropThreadCallbackList                  = PropertyStore.CreateKey();
        
        private static readonly int PropRegion                              = PropertyStore.CreateKey();
        private static readonly int PropCharsToIgnore                       = PropertyStore.CreateKey();
        private static readonly int PropImeMode                             = PropertyStore.CreateKey();
        private static readonly int PropPreviousImeMode                     = PropertyStore.CreateKey();

        private static readonly int PropBindings                            = PropertyStore.CreateKey();
        private static readonly int PropBindingManager                      = PropertyStore.CreateKey();
        private static readonly int PropAccessibleDefaultActionDescription  = PropertyStore.CreateKey();
        private static readonly int PropAccessibleDescription               = PropertyStore.CreateKey();
        
        private static readonly int PropAccessibility                       = PropertyStore.CreateKey();
        private static readonly int PropAccessibleName                      = PropertyStore.CreateKey();
        private static readonly int PropAccessibleRole                      = PropertyStore.CreateKey();
        private static readonly int PropAccessibleHelpProvider              = PropertyStore.CreateKey();
                                                                            
        private static readonly int PropPaintingException                   = PropertyStore.CreateKey();
        private static readonly int PropActiveXImpl                         = PropertyStore.CreateKey();
        private static readonly int PropControlVersionInfo                  = PropertyStore.CreateKey();
        private static readonly int PropAmbientPropertiesService            = PropertyStore.CreateKey();

        private static readonly int PropCurrentAmbientFont                  = PropertyStore.CreateKey();

        ///////////////////////////////////////////////////////////////////////
        // Control per instance members
        //
        // Note: Do not add anything to this list unless absolutely neccessary.
        //       Every control on a form has the overhead of all of these
        //       variables!
        //
        // Begin Members {

        // List of properties that are generally set, so we keep them directly on
        // control.
        //       
        internal ControlNativeWindow          window;                 // AxHost needs to have access to this.
        private Control                       parent;
        private CreateParams                  createParams;
        private int                           x;                      // CONSIDER: changing this to short
        private int                           y;  
        private int                           width;
        private int                           height;
        private int                           clientWidth;
        private int                           clientHeight;
        private int                           state;                  // See STATE_ constants above
        private ControlStyles                 controlStyle;           // User supplied control style
        private int                           tabIndex;
        private string                        text;                   // See ControlStyles.CacheText for usage notes
        private byte                          layoutSuspendCount;
        private PropertyStore                 propertyStore;          // Contains all properties that are not always set.
        private NativeMethods.TRACKMOUSEEVENT trackMouseEvent;
        private short                         updateCount;
        private short                         bitsPerPixel;
        
        // } End Members
        ///////////////////////////////////////////////////////////////////////

#if DEBUG
        internal int LayoutSuspendCount {
            get {
                return layoutSuspendCount;
            }
        }
        void AssertLayoutSuspendCount(int value) {
            Debug.Assert(value == layoutSuspendCount, "Suspend/Resume layout mismatch!");
        }

/*
example usage

#if DEBUG
        int dbgLayoutCheck = LayoutSuspendCount;
#endif
#if DEBUG
        AssertLayoutSuspendCount(dbgLayoutCheck);
#endif
*/

#endif



        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Control"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Windows.Forms.Control'/> class.</para>
        /// </devdoc>
        public Control() : base() {
#if DEBUG
            if (AssertOnControlCreateSwitch.Enabled) {
                Debug.Assert(this.GetType().BaseType != typeof(Control), "Direct derivative of Control Created: " + this.GetType().FullName);
                Debug.Assert(this.GetType() != typeof(Control), "Control Created!");
            }
#endif

            propertyStore = new PropertyStore();

            window = new ControlNativeWindow(this);
            tabIndex = -1;
            
            state = STATE_VISIBLE | STATE_ENABLED | STATE_TABSTOP | STATE_CAUSESVALIDATION;
            SetStyle(ControlStyles.AllPaintingInWmPaint | 
                     ControlStyles.UserPaint | 
                     ControlStyles.StandardClick | 
                     ControlStyles.StandardDoubleClick | 
                     ControlStyles.Selectable,true);
                     
#if WIN95_SUPPORT         
            InitMouseWheelSupport();
#endif 

            // Compute our default size.
            //
            Size defaultSize = DefaultSize;
            width = defaultSize.Width;
            height = defaultSize.Height;
            
            if (width != 0 && height != 0) {
                NativeMethods.RECT rect = new NativeMethods.RECT();
                rect.left = rect.right = rect.top = rect.bottom = 0;
    
                CreateParams cp = CreateParams;
    
                SafeNativeMethods.AdjustWindowRectEx(ref rect, cp.Style, false, cp.ExStyle);
                clientWidth = width - (rect.right - rect.left);
                clientHeight = height - (rect.bottom - rect.top);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Control1"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Windows.Forms.Control'/> class.</para>
        /// </devdoc>
        public Control( string text ) : this( (Control) null, text ) {
        }
        
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Control2"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Windows.Forms.Control'/> class.</para>
        /// </devdoc>
        public Control( string text, int left, int top, int width, int height ) :
                    this( (Control) null, text, left, top, width, height ) {
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Control3"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Windows.Forms.Control'/> class.</para>
        /// </devdoc>
        public Control( Control parent, string text ) : this() {
            this.Parent = parent;
            this.Text = text;
        }
        
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Control4"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Windows.Forms.Control'/> class.</para>
        /// </devdoc>
        public Control( Control parent, string text, int left, int top, int width, int height ) : this( parent, text ) {
            this.Location = new Point( left, top );
            this.Size = new Size( width, height );
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.AccessibilityObject"]/*' />
        /// <devdoc>
        ///      The Accessibility Object for this Control
        /// </devdoc>
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ControlAccessibilityObjectDescr)
        ]
        public AccessibleObject AccessibilityObject {
            get {
                AccessibleObject accessibleObject = (AccessibleObject)Properties.GetObject(PropAccessibility);
                if (accessibleObject == null) {
                    accessibleObject = CreateAccessibilityInstance();
                    Properties.SetObject(PropAccessibility, accessibleObject);
                }
                
                Debug.Assert(accessibleObject != null, "Failed to create accessibility object");
                return accessibleObject;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.AccessibleDefaultActionDescription"]/*' />
        /// <devdoc>
        ///      The default action description of the control
        /// </devdoc>
        [
        SRCategory(SR.CatAccessibility),
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced), 
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ControlAccessibleDefaultActionDescr)
        ]
        public string AccessibleDefaultActionDescription {
            get {
                return (string)Properties.GetObject(PropAccessibleDefaultActionDescription);
            }
            set {
                Properties.SetObject(PropAccessibleDefaultActionDescription, value);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.AccessibleDescription"]/*' />
        /// <devdoc>
        ///      The accessible description of the control
        /// </devdoc>
        [
        SRCategory(SR.CatAccessibility),
        DefaultValue(null),
        Localizable(true),
        SRDescription(SR.ControlAccessibleDescriptionDescr)
        ]
        public string AccessibleDescription {
            get {
                return (string)Properties.GetObject(PropAccessibleDescription);
            }
            set {
                Properties.SetObject(PropAccessibleDescription, value);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.AccessibleName"]/*' />
        /// <devdoc>
        ///      The accessible name of the control
        /// </devdoc>
        [
        SRCategory(SR.CatAccessibility),
        DefaultValue(null),
        Localizable(true),
        SRDescription(SR.ControlAccessibleNameDescr)
        ]
        public string AccessibleName {
            get {
                return (string)Properties.GetObject(PropAccessibleName);
            }

            set {
                Properties.SetObject(PropAccessibleName, value);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.AccessibleRole"]/*' />
        /// <devdoc>
        ///      The accessible role of the control
        /// </devdoc>
        [
        SRCategory(SR.CatAccessibility),
        DefaultValue(AccessibleRole.Default),
        SRDescription(SR.ControlAccessibleRoleDescr)
        ]
        public AccessibleRole AccessibleRole {

            get {
                bool found;
                int role = Properties.GetInteger(PropAccessibleRole, out found);
                if (found) {
                    return (AccessibleRole)role;
                }
                else {
                    return AccessibleRole.Default;
                }
            }

            set {
                if (!Enum.IsDefined(typeof(AccessibleRole), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(AccessibleRole));
                }
                Properties.SetInteger(PropAccessibleRole, (int)value);
            }


        }

        /// <devdoc>
        ///     Helper method for retrieving an ActiveX property.  We abstract these
        ///     to another method so we do not force JIT the ActiveX codebase.
        /// </devdoc>
        private Color ActiveXAmbientBackColor {
            get {
                return ActiveXInstance.AmbientBackColor;
            }
        }

        /// <devdoc>
        ///     Helper method for retrieving an ActiveX property.  We abstract these
        ///     to another method so we do not force JIT the ActiveX codebase.
        /// </devdoc>
        private Color ActiveXAmbientForeColor {
            get {
                return ActiveXInstance.AmbientForeColor;
            }
        }

        /// <devdoc>
        ///     Helper method for retrieving an ActiveX property.  We abstract these
        ///     to another method so we do not force JIT the ActiveX codebase.
        /// </devdoc>
        private Font ActiveXAmbientFont {
            get {
                return ActiveXInstance.AmbientFont;
            }
        }

        /// <devdoc>
        ///     Helper method for retrieving an ActiveX property.  We abstract these
        ///     to another method so we do not force JIT the ActiveX codebase.
        /// </devdoc>
        private bool ActiveXEventsFrozen {
            get {
                return ActiveXInstance.EventsFrozen;
            }
        }

        /// <devdoc>
        ///     Helper method for retrieving an ActiveX property.  We abstract these
        ///     to another method so we do not force JIT the ActiveX codebase.
        /// </devdoc>
        private IntPtr ActiveXHWNDParent {
            get {
                return ActiveXInstance.HWNDParent;
            }
        }

        /// <devdoc>
        ///      Retrieves the ActiveX control implementation for
        ///      this control.  This will demand create the implementation
        ///      if it does not already exist.
        /// </devdoc>
        private ActiveXImpl ActiveXInstance {
            get {
                ActiveXImpl activeXImpl = (ActiveXImpl)Properties.GetObject(PropActiveXImpl);
                if (activeXImpl == null) {

                    // Don't allow top level objects to be hosted
                    // as activeX controls.
                    //
                    if (GetState(STATE_TOPLEVEL)) {
                        throw new NotSupportedException(SR.GetString(SR.AXTopLevelSource));
                    }

                    activeXImpl = new ActiveXImpl(this);
                    Properties.SetObject(PropActiveXImpl, activeXImpl);
                }
                
                return activeXImpl;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.AllowDrop"]/*' />
        /// <devdoc>
        ///     The AllowDrop property. If AllowDrop is set to true then
        ///     this control will allow drag and drop operations and events to be used.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(false),
        SRDescription(SR.ControlAllowDropDescr)
        ]
        public virtual bool AllowDrop {
            get {
                return GetState(STATE_ALLOWDROP);
            }

            set {
                if (GetState(STATE_ALLOWDROP) != value) {
                    // Since we won't call SetAcceptDrops without a handle,
                    // we do the security demand here. Without this demand
                    // we are still safe, but you get the exception at an
                    // odd time. This gives a better experience.
                    //
                    if (value && !IsHandleCreated) {
                        IntSecurity.ClipboardRead.Demand();
                    }

                    SetState(STATE_ALLOWDROP, value);

                    if (IsHandleCreated) {
                        try {
                            SetAcceptDrops(value);
                        }
                        catch {
                            // If there is an error, back out the AllowDrop state...
                            //
                            SetState(STATE_ALLOWDROP, !value);
                            throw;
                        }
                    }
                }
            }
        }

        // Queries the Site for AmbientProperties.  May return null.
        // Do not confuse with inheritedProperties -- the service is turned to
        // after we've exhausted inheritedProperties.
        private AmbientProperties AmbientPropertiesService {
            get {
                bool contains;
                AmbientProperties props = (AmbientProperties)Properties.GetObject(PropAmbientPropertiesService, out contains);
                if (!contains && Site != null) {
                    props = (AmbientProperties)Site.GetService(typeof(AmbientProperties));
                    Properties.SetObject(PropAmbientPropertiesService, props);
                }
                return props;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Anchor"]/*' />
        /// <devdoc>
        ///     The current value of the anchor property. The anchor property
        ///     determines which edges of the control are anchored to the container's
        ///     edges.
        /// </devdoc>
        [
        SRCategory(SR.CatLayout),
        Localizable(true),
        DefaultValue(AnchorStyles.Top | AnchorStyles.Left),
        SRDescription(SR.ControlAnchorDescr),
        RefreshProperties(RefreshProperties.Repaint)
        ]
        public virtual AnchorStyles Anchor {
            get {
                LayoutInfo layout = (LayoutInfo)Properties.GetObject(PropLayoutInfo);
                
                if (layout == null || layout.IsDock) {
                    return AnchorStyles.Top | AnchorStyles.Left;
                }
                else {
                    return layout.Anchor;
                }
            }
            set {
                if (Anchor != value) {
                
                    // Cancel dock if it is set.
                    //
                    LayoutInfo layout = (LayoutInfo)Properties.GetObject(PropLayoutInfo);
                    
                    if (layout != null && layout.IsDock) {
                        Dock = DockStyle.None;
                    }
                
                    // If the value being set is the default, then
                    // null layout.
                    //
                    if (value == (AnchorStyles.Top | AnchorStyles.Left)) {
                        Properties.SetObject(PropLayoutInfo, null);
                    }
                    else {
                        layout = new LayoutInfo(value);
                        Properties.SetObject(PropLayoutInfo, layout);
                        LayoutManager.UpdateAnchorInfo(this);
                    }
                    
                    if (ParentInternal != null) ParentInternal.PerformLayout(this, "Anchor");
                }
            }
        }

        /// <devdoc>
        ///     The GDI brush for our background color.
        /// </devdoc>
        private IntPtr BackBrush {
            get {
                object customBackBrush = Properties.GetObject(PropBackBrush);
                if (customBackBrush != null) {
                
                    // We already have a valid brush.  Unbox, and return.
                    //
                    return (IntPtr)customBackBrush;
                }
                
                if (!Properties.ContainsObject(PropBackColor)) {
                
                    // No custom back color.  See if we can get to our parent.
                    // The color check here is to account for parents and children who
                    // override the BackColor property.
                    //
                    if (parent != null && parent.BackColor == BackColor) {
                        return parent.BackBrush;
                    }
                }
                
                // No parent, or we have a custom back color.  Either way, we need to
                // create our own.
                //
                Color color = BackColor;
                IntPtr backBrush;
                
                if (ColorTranslator.ToOle(color) < 0) {
                    backBrush = SafeNativeMethods.GetSysColorBrush(ColorTranslator.ToOle(color) & 0xFF);
                    SetState(STATE_OWNCTLBRUSH, false);
                }
                else {
                    backBrush = SafeNativeMethods.CreateSolidBrush(ColorTranslator.ToWin32(color));
                    SetState(STATE_OWNCTLBRUSH, true);
                }
                
                Debug.Assert(backBrush != IntPtr.Zero, "Failed to create brushHandle");
                Properties.SetObject(PropBackBrush, backBrush);
                
                return backBrush;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.BackColor"]/*' />
        /// <devdoc>
        ///     The background color of this control. This is an ambient property and
        ///     will always return a non-null value.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DispId(NativeMethods.ActiveX.DISPID_BACKCOLOR),
        SRDescription(SR.ControlBackColorDescr)
        ]
        public virtual Color BackColor {
            get {
                Color c = RawBackColor; // inheritedProperties.BackColor
                if (!c.IsEmpty)
                    return c;

                Control p = ParentInternal;
                if (p != null && p.CanAccessProperties) {
                    return p.BackColor;
                }


                if (IsActiveX) {
                    c = ActiveXAmbientBackColor;
                }

                if (c.IsEmpty) {
                    AmbientProperties ambient = AmbientPropertiesService;
                    if (ambient != null)
                        c = ambient.BackColor;
                }

                if (!c.IsEmpty)
                    return c;
                else
                    return DefaultBackColor;
            }

            set {
                if (!value.Equals(Color.Empty) && !GetStyle(ControlStyles.SupportsTransparentBackColor) && value.A < 255)
                    throw new ArgumentException(SR.GetString(SR.TransparentBackColorNotAllowed));

                Color c = BackColor;
                if (!value.IsEmpty || Properties.ContainsObject(PropBackColor)) {
                    Properties.SetObject(PropBackColor, value);
                }

                if (!c.Equals(BackColor)) {
                    OnBackColorChanged(EventArgs.Empty);
                }
            }
        }
        
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.BackColorChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.ControlOnBackColorChangedDescr)]
        public event EventHandler BackColorChanged {
            add {
                Events.AddHandler(EventBackColor, value);
            }
            remove {
                Events.RemoveHandler(EventBackColor, value);
            }
        }
        
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.BackgroundImage"]/*' />
        /// <devdoc>
        ///     The background image of the control.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DefaultValue(null),
        Localizable(true),
        SRDescription(SR.ControlBackgroundImageDescr)
        ]
        public virtual Image BackgroundImage {
            get {
                return (Image)Properties.GetObject(PropBackgroundImage);
            }
            set {
                if (BackgroundImage != value) {
                    Properties.SetObject(PropBackgroundImage, value);
                    OnBackgroundImageChanged(EventArgs.Empty);
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.BackgroundImageChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.ControlOnBackgroundImageChangedDescr)]
        public event EventHandler BackgroundImageChanged {
            add {
                Events.AddHandler(EventBackgroundImage, value);
            }
            remove {
                Events.RemoveHandler(EventBackgroundImage, value);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.DataBindings"]/*' />
        /// <devdoc>
        ///     Retrieves the bindings for this control.
        /// </devdoc>
        [
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        SRCategory(SR.CatData),
        SRDescription(SR.ControlBindingsDescr),
        RefreshProperties(RefreshProperties.All),
        ParenthesizePropertyName(true)
        ]
        public ControlBindingsCollection DataBindings {
            get {
                ControlBindingsCollection bindings = (ControlBindingsCollection)Properties.GetObject(PropBindings);
                if (bindings == null) {
                    bindings = new ControlBindingsCollection(this);
                    Properties.SetObject(PropBindings, bindings);
                }
                return bindings;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ShouldSerializeBindings"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal bool ShouldSerializeBindings() {
            ControlBindingsCollection bindings = (ControlBindingsCollection)Properties.GetObject(PropBindings);
            return bindings != null && bindings.Count > 0;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ResetBindings"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public void ResetBindings() {
            ControlBindingsCollection bindings = (ControlBindingsCollection)Properties.GetObject(PropBindings);
            if (bindings != null) {
                bindings.Clear();
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.BindingContext"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced), 
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ControlBindingContextDescr)
        ]
        public virtual BindingContext BindingContext {
            get {
                // See if we have locally overridden the binding manager.
                //
                BindingContext context = (BindingContext)Properties.GetObject(PropBindingManager);
                if (context != null) {
                    return context;
                }

                // Otherwise, see if the parent has one for us.
                //
                Control p = ParentInternal;
                if (p != null && p.CanAccessProperties) {
                    return p.BindingContext;
                }

                // Otherwise, we have no binding manager available.
                //
                return null;
            }
            set {
                if (Properties.GetObject(PropBindingManager) != value) {
                    Properties.SetObject(PropBindingManager, value);
                    
                    // the property change will wire up the bindings.
                    //
                    OnBindingContextChanged(EventArgs.Empty);
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.BindingContextChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.ControlOnBindingContextChangedDescr)]
        public event EventHandler BindingContextChanged {
            add {
                Events.AddHandler(EventBindingContext, value);
            }
            remove {
                Events.RemoveHandler(EventBindingContext, value);
            }
        }

        private short BitsPerPixel {
            get {
                if (bitsPerPixel == 0) {
                    new EnvironmentPermission(PermissionState.Unrestricted).Assert();
                    try {
                        foreach (Screen s in Screen.AllScreens) {
                            if (bitsPerPixel == 0) {
                                bitsPerPixel = (short)s.BitDepth;
                            }
                            else {
                                bitsPerPixel = (short)Math.Min(s.BitDepth, bitsPerPixel);
                            }
                        }
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }                    
                }
                return bitsPerPixel;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Bottom"]/*' />
        /// <devdoc>
        ///    <para>The bottom coordinate of this control.</para>
        /// </devdoc>
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced), 
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ControlBottomDescr),
        SRCategory(SR.CatLayout)
        ]
        public int Bottom {
            get {
                return y + height;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Bounds"]/*' />
        /// <devdoc>
        ///     The bounds of this control. This is the window coordinates of the
        ///     control in parent client coordinates.
        /// </devdoc>
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ControlBoundsDescr),
        SRCategory(SR.CatLayout)
        ]
        public Rectangle Bounds {
            get {
                return new Rectangle(x, y, width, height);
            }

            set {
                SetBounds(value.X, value.Y, value.Width, value.Height, BoundsSpecified.All);
            }
        }
        
        internal ImeMode CachedImeMode {
            get {
                Debug.WriteLineIf(CompModSwitches.ImeMode.TraceInfo, "Getting CachedImeMode: this = " + this.GetType().ToString());
                
                // Get the ImeMode from the propertys store
                //
                bool found;
                ImeMode cachedImeMode = (ImeMode)Properties.GetInteger(PropImeMode, out found);
                if (!found) {
                    cachedImeMode = DefaultImeMode;
                    Debug.WriteLineIf(CompModSwitches.ImeMode.TraceInfo, "     using DefaultImeMode == " + cachedImeMode.ToString()); 
                }
                else {        
                    Debug.WriteLineIf(CompModSwitches.ImeMode.TraceInfo, "     using property store ImeMode == " + cachedImeMode.ToString()); 
                }
                
                // If inherited, get the mode from this control's parent
                //
                if (cachedImeMode == ImeMode.Inherit) {
                    Control parent = ParentInternal;
                    if (parent != null) {
                        cachedImeMode = parent.CachedImeMode;
                        Debug.WriteLineIf(CompModSwitches.ImeMode.TraceInfo, "         inherited from parent = " + parent.GetType().ToString());
                    }
                    else {
                        cachedImeMode = ImeMode.NoControl;
                    }
                }
                
                Debug.WriteLineIf(CompModSwitches.ImeMode.TraceInfo, "     returning CachedImeMode == " + cachedImeMode.ToString()); 
                return cachedImeMode;
            }
        }
        
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        internal virtual bool CanAccessProperties {
            get {
                return true;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.CanFocus"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the control can receive focus. This 
        ///       property is read-only.</para>
        /// </devdoc>
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced), 
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRCategory(SR.CatFocus),
        SRDescription(SR.ControlCanFocusDescr)
        ]
        public bool CanFocus {
            get {
                return window.Handle != IntPtr.Zero
                && SafeNativeMethods.IsWindowVisible(new HandleRef(window, window.Handle))
                && SafeNativeMethods.IsWindowEnabled(new HandleRef(window, window.Handle));
            }
        }

        /// <devdoc>
        ///     Determines if events can be fired on the control.
        /// </devdoc>
        /// <internalonly/>
        private bool CanRaiseEvents {
            get {
                if (IsActiveX) {
                    return !ActiveXEventsFrozen;
                }
                
                return true;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.CanSelect"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Indicates whether the control can be selected. This property
        ///       is read-only.</para>
        /// </devdoc>
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced), 
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRCategory(SR.CatFocus),
        SRDescription(SR.ControlCanSelectDescr)
        ]
        public bool CanSelect {
            // We implement this to allow only AxHost to override canSelectCore, but still
            // expose the method publicly
            //
            get {
                return CanSelectCore();
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Capture"]/*' />
        /// <devdoc>
        ///    <para> Indicates whether the control has captured the mouse.</para>
        /// </devdoc>
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced), 
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRCategory(SR.CatFocus),
        SRDescription(SR.ControlCaptureDescr)
        ]
        public bool Capture {
            get {
                return CaptureInternal;
            }

            set {
                if (value) {
                    Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "GetCapture Demanded");
                    IntSecurity.GetCapture.Demand();
                }
                CaptureInternal = value;
            }
        }

        internal bool CaptureInternal {
            get {
                return window.Handle != IntPtr.Zero && UnsafeNativeMethods.GetCapture() == window.Handle;
            }
            set {
                if (CaptureInternal != value) {
                    if (value) {
                        UnsafeNativeMethods.SetCapture(new HandleRef(this, Handle));
                    }
                    else {
                        SafeNativeMethods.ReleaseCapture();
                    }
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.CausesValidation"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Indicates whether entering the control causes validation on the controls requiring validation.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatFocus),
        DefaultValue(true),
        SRDescription(SR.ControlCausesValidationDescr)
        ]
        public bool CausesValidation {
            get {
                return GetState(STATE_CAUSESVALIDATION);
            }
            set {
                if (value != this.CausesValidation) {
                    SetState(STATE_CAUSESVALIDATION, value);
                    OnCausesValidationChanged(EventArgs.Empty);
                }
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.CausesValidationChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.ControlOnCausesValidationChangedDescr)]
        public event EventHandler CausesValidationChanged {
            add {
                Events.AddHandler(EventCausesValidation, value);
            }
            remove {
                Events.RemoveHandler(EventCausesValidation, value);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ClientRectangle"]/*' />
        /// <devdoc>
        ///     The client rect of the control.
        /// </devdoc>
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced), 
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRCategory(SR.CatLayout),
        SRDescription(SR.ControlClientRectangleDescr)
        ]
        public Rectangle ClientRectangle {
            get {
                return new Rectangle(0, 0, clientWidth, clientHeight);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ClientSize"]/*' />
        /// <devdoc>
        ///     The size of the clientRect.
        /// </devdoc>
        [
        SRCategory(SR.CatLayout),
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ControlClientSizeDescr)
        ]
        public Size ClientSize {
            get {
                return new Size(clientWidth, clientHeight);
            }

            set {
                SetClientSizeCore(value.Width, value.Height);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.CompanyName"]/*' />
        /// <devdoc>
        ///     Retrieves the company name of this specific component.
        /// </devdoc>
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced), 
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        DescriptionAttribute("ControlCompanyNameDescr")
        ]
        public string CompanyName {
            get {
                return VersionInfo.CompanyName;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ContainsFocus"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the control or one of its children currently has the system 
        ///       focus. This property is read-only.</para>
        /// </devdoc>
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced), 
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ControlContainsFocusDescr)
        ]
        public bool ContainsFocus {
            get {
                if (!IsHandleCreated) {
                    return false;
                }

                IntPtr focusHwnd = UnsafeNativeMethods.GetFocus();

                while (focusHwnd != Handle && focusHwnd != IntPtr.Zero) {
                    focusHwnd = UnsafeNativeMethods.GetWindowLong(new HandleRef(null, focusHwnd), NativeMethods.GWL_HWNDPARENT);
                }

                if (focusHwnd != IntPtr.Zero) {
                    return true;
                }
                return false;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ContextMenu"]/*' />
        /// <devdoc>
        ///     The contextMenu associated with this control. The contextMenu
        ///     will be shown when the user right clicks the mouse on the control.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(null),
        SRDescription(SR.ControlContextMenuDescr)
        ]
        public virtual ContextMenu ContextMenu {
            get {
                return (ContextMenu)Properties.GetObject(PropContextMenu);
            }
            set {
                ContextMenu oldValue = (ContextMenu)Properties.GetObject(PropContextMenu);

                if (oldValue != value) {
                    EventHandler disposedHandler = new EventHandler(DetachContextMenu);

                    if (oldValue != null) {
                        oldValue.Disposed -= disposedHandler;
                    }

                    Properties.SetObject(PropContextMenu, value);

                    if (value != null) {
                        value.Disposed += disposedHandler;
                    }

                    OnContextMenuChanged(EventArgs.Empty);
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ContextMenuChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.ControlOnContextMenuChangedDescr)]
        public event EventHandler ContextMenuChanged {
            add {
                Events.AddHandler(EventContextMenu, value);
            }
            remove {
                Events.RemoveHandler(EventContextMenu, value);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Controls"]/*' />
        /// <devdoc>
        ///     Collection of child controls.
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        SRDescription(SR.ControlControlsDescr)
        ]
        public ControlCollection Controls {
            get {
                ControlCollection controlsCollection = (ControlCollection)Properties.GetObject(PropControlsCollection);
                
                if (controlsCollection == null) {
                    controlsCollection = CreateControlsInstance();
                    Properties.SetObject(PropControlsCollection, controlsCollection);
                }
                return controlsCollection;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Created"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the control has been created. This property is read-only.</para>
        /// </devdoc>
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced), 
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ControlCreatedDescr)
        ]
        public bool Created {
            get {
                return(state & STATE_CREATED) != 0;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.CreateParams"]/*' />
        /// <devdoc>
        ///     Returns the CreateParams used to create the handle for this control.
        ///     Inheriting classes should call base.CreateParams in the manor
        ///     below:
        /// </devdoc>
        protected virtual CreateParams CreateParams {
            [
                SecurityPermission(SecurityAction.InheritanceDemand, Flags=SecurityPermissionFlag.UnmanagedCode),
                SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)
            ]
            get {
            
                // In a typical control this is accessed ten times to create and show a control.
                // It is a net memory savings, then, to maintain a copy on control.
                //
                if (createParams == null) {
                    createParams = new CreateParams();
                }
                
                CreateParams cp = createParams;
                cp.Style = 0;
                cp.ExStyle = 0;
                cp.ClassStyle = 0;
                cp.Caption = text;

                cp.X = x;
                cp.Y = y;
                cp.Width = width;
                cp.Height = height;

                cp.Style = NativeMethods.WS_CLIPCHILDREN;
                if (GetStyle(ControlStyles.ContainerControl)) {
                    cp.ExStyle |= NativeMethods.WS_EX_CONTROLPARENT;
                }
                cp.ClassStyle = NativeMethods.CS_DBLCLKS;

                if ((state & STATE_TOPLEVEL) == 0) {
                    // When the window is actually created, we will parent WS_CHILD windows to the 
                    // parking form if cp.parent == 0.
                    //
                    cp.Parent = parent == null ? IntPtr.Zero : parent.window.Handle;
                    cp.Style |= NativeMethods.WS_CHILD | NativeMethods.WS_CLIPSIBLINGS;
                }
                else {
                    cp.Parent = IntPtr.Zero;
                }

                if ((state & STATE_TABSTOP) != 0) cp.Style |= NativeMethods.WS_TABSTOP;
                if ((state & STATE_VISIBLE) != 0) cp.Style |= NativeMethods.WS_VISIBLE;

                // Unlike Visible, Windows doesn't correctly inherit disabledness from its parent -- an enabled child
                // of a disabled parent will look enabled but not get mouse events
                if (!Enabled) cp.Style |= NativeMethods.WS_DISABLED;

                // If we are being hosted as an Ax control, try to prevent the parking window
                // from being created by pre-filling the window handle here.
                //
                if (cp.Parent == IntPtr.Zero && IsActiveX) {
                    cp.Parent = ActiveXHWNDParent;
                }

                // Set Rtl bits
                if (RightToLeft == RightToLeft.Yes) {
                    cp.ExStyle |= NativeMethods.WS_EX_RTLREADING;
                    cp.ExStyle |= NativeMethods.WS_EX_RIGHT;
                    cp.ExStyle |= NativeMethods.WS_EX_LEFTSCROLLBAR;
                }

                return cp;
            }
        }

        [PermissionSetAttribute(SecurityAction.InheritanceDemand, Name="FullTrust")]
        [PermissionSetAttribute(SecurityAction.LinkDemand, Name="FullTrust")]
        internal virtual void NotifyValidationResult(object sender, CancelEventArgs ev) {
            this.ValidationCancelled = ev.Cancel ;
        }
        
        internal bool ValidationCancelled {
            set {
                SetState(STATE_VALIDATIONCANCELLED, value);
            }
            get {
                if (GetState(STATE_VALIDATIONCANCELLED))
                    return true;
                else
                    return false;
            }
        }

        /*C#r*/internal int _CreateThreadId {
            get {
                return CreateThreadId;
            }
        }

        /// <devdoc>
        ///     Retrieves the Win32 thread ID of the thread that created the
        ///     handle for this control.  If the control's handle hasn't been
        ///     created yet, this method will return the current thread's ID.
        /// </devdoc>
        /// <internalonly/>
        internal int CreateThreadId {
            get {
                if (IsHandleCreated) {
                    int pid;
                    return SafeNativeMethods.GetWindowThreadProcessId(new HandleRef(this, Handle), out pid);
                }
                else {
                    return SafeNativeMethods.GetCurrentThreadId();
                }
            }
        }
        
        internal ImeMode CurrentImeContextMode {
            get {
                return GetImeModeFromIMEContext(this.Handle);
            }
            set {
                SetImeModeToIMEContext(value, this.Handle);
            }
        }
        
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Cursor"]/*' />
        /// <devdoc>
        ///     Retrieves the cursor that will be displayed when the mouse is over this
        ///     control.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        SRDescription(SR.ControlCursorDescr),
        AmbientValue(null)
        ]
        public virtual Cursor Cursor {
            get {
                Cursor cursor = (Cursor)Properties.GetObject(PropCursor);
                if (cursor != null) {
                    return cursor;
                }

                // We only do ambients for things with "Cursors.Default" 
                // as their default.
                //
                Cursor localDefault = DefaultCursor;
                if (localDefault != Cursors.Default) {
                    return localDefault;
                }

                Control p = ParentInternal;
                if (p != null) {
                    return p.Cursor;
                }

                AmbientProperties ambient = AmbientPropertiesService;
                if (ambient != null && ambient.Cursor != null)
                    return ambient.Cursor;

                return localDefault;
            }
            set {

                Cursor localCursor = (Cursor)Properties.GetObject(PropCursor);
                Cursor resolvedCursor = Cursor;
                if (localCursor != value) {
                    Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "ModifyCursor Demanded");
                    IntSecurity.ModifyCursor.Demand();
                    
                    Properties.SetObject(PropCursor, value);
                }

                // Other things can change the cursor... we
                // really want to force the correct cursor always...
                //
                if (IsHandleCreated) {
                    // We want to instantly change the cursor if the mouse is within our bounds.
                    // This includes the case where the mouse is over one of our children
                    NativeMethods.POINT p = new NativeMethods.POINT();
                    NativeMethods.RECT r = new NativeMethods.RECT();
                    UnsafeNativeMethods.GetCursorPos(p);
                    UnsafeNativeMethods.GetWindowRect(new HandleRef(this, Handle), ref r);

                    if ((r.left <= p.x && p.x < r.right && r.top <= p.y && p.y < r.bottom) || UnsafeNativeMethods.GetCapture() == Handle)
                        SendMessage(NativeMethods.WM_SETCURSOR, Handle, (IntPtr)NativeMethods.HTCLIENT);
                }

                if (!resolvedCursor.Equals(value)) {
                    OnCursorChanged(EventArgs.Empty);
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.CursorChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.ControlOnCursorChangedDescr)]
        public event EventHandler CursorChanged {
            add {
                Events.AddHandler(EventCursor, value);
            }
            remove {
                Events.RemoveHandler(EventCursor, value);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.DefaultBackColor"]/*' />
        /// <devdoc>
        ///     The default BackColor of a generic top-level Control.  Subclasses may have
        ///     different defaults.
        /// </devdoc>
        public static Color DefaultBackColor {
            get { return SystemColors.Control;}
        }
        
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.DefaultCursor"]/*' />
        /// <devdoc>
        ///     Deriving classes can override this to configure a default cursor for their control.
        ///     This is more efficient than setting the cursor in the control's constructor, 
        ///     and gives automatic support for ShouldSerialize and Reset in the designer.
        /// </devdoc>
        internal virtual Cursor DefaultCursor {
            get {
                return Cursors.Default;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.DefaultFont"]/*' />
        /// <devdoc>
        ///     The default Font of a generic top-level Control.  Subclasses may have
        ///     different defaults.
        /// </devdoc>
        public static Font DefaultFont {
            get {
                if (defaultFont == null) {
                    
                    //JPN NT4 machines need to use a specific font
                    //
                    new EnvironmentPermission(PermissionState.Unrestricted).Assert();
                    try {
                        if (Environment.OSVersion.Platform == System.PlatformID.Win32NT &&
                            Environment.OSVersion.Version.Major <= 4) {

                            if((SafeNativeMethods.GetSystemDefaultLCID() & 0x3ff) == 0x0011) {
                                try {
                                    defaultFont = new Font("MS UI Gothic", 9);
                                }
                                catch {
                                    //fall through here if this asserts and we'll get the default
                                    //font via the DEFAULT_GUI method
                                }
                            }
                        }
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                    
                    // first, try DEFAULT_GUI font
                    //
                    if (defaultFont == null) {
                        IntPtr handle = UnsafeNativeMethods.GetStockObject(NativeMethods.DEFAULT_GUI_FONT);        
                        try {
                            Font fontInWorldUnits = null;
    
                            // SECREVIEW : We know that we got the handle from the stock object,
                            //           : so this is always safe.
                            //
                            IntSecurity.ObjectFromWin32Handle.Assert();
                            try {
                                fontInWorldUnits = Font.FromHfont(handle);
                            }
                            finally {
                                CodeAccessPermission.RevertAssert();
                            }
                            defaultFont = ControlPaint.FontInPoints(fontInWorldUnits);
                            fontInWorldUnits.Dispose();
                        }
                        catch (ArgumentException) {
                            defaultFont = null;
                        }
                    }

                    // If DEFAULT_GUI didn't work, we try Tahoma.
                    //
                    if (defaultFont == null) {
                        try {
                            defaultFont = new Font("Tahoma", 8);
                        }
                        catch (ArgumentException) {
                            defaultFont = null;
                        }
                    }

                    // Last resort, we use the GenericSansSerif - this will
                    // always work.
                    //
                    if (defaultFont == null) {
                        defaultFont = new Font(FontFamily.GenericSansSerif, 8);
                    }

                    Debug.Assert(defaultFont != null, "defaultFont wasn't set!");
                }

                return defaultFont;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.DefaultForeColor"]/*' />
        /// <devdoc>
        ///     The default ForeColor of a generic top-level Control.  Subclasses may have
        ///     different defaults.
        /// </devdoc>
        public static Color DefaultForeColor {
            get { return SystemColors.ControlText;}
        }
        
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.DefaultImeMode"]/*' />
        protected virtual ImeMode DefaultImeMode {
            get {
                return ImeMode.Inherit;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.DefaultSize"]/*' />
        /// <devdoc>
        ///     Deriving classes can override this to configure a default size for their control.
        ///     This is more efficient than setting the size in the control's constructor.
        /// </devdoc>
        protected virtual Size DefaultSize {
            get {
                return new Size(0, 0);
            }
        }
        
        private RightToLeft DefaultRightToLeft {
            get {
                return RightToLeft.No;
            }
        }

        private void DetachContextMenu(object sender, EventArgs e) {
            ContextMenu = null;
        }

        // The color to use when drawing disabled text.  Normally we use BackColor,
        // but that obviously won't work if we're transparent.
        internal Color DisabledColor {
            get {
                Color color = BackColor;
                if (color.A == 0) {
                    Control control = ParentInternal;
                    while (color.A == 0) {
                        if (control == null) {
                            // Don't know what to do, this seems good as anything
                            color = SystemColors.Control; 
                            break;
                        }
                        color = control.BackColor;
                        control = control.ParentInternal;
                    }
                }
                return color;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.DisplayRectangle"]/*' />
        /// <devdoc>
        ///     Returns the client rect of the display area of the control.
        ///     For the base control class, this is identical to getClientRect.
        ///     However, inheriting controls may want to change this if their client
        ///     area differs from their display area.
        /// </devdoc>
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced), 
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ControlDisplayRectangleDescr)
        ]
        public virtual Rectangle DisplayRectangle {
            get {
                return new Rectangle(0, 0, clientWidth, clientHeight);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Disposed"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the control has been disposed. This 
        ///       property is read-only.</para>
        /// </devdoc>
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced), 
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ControlDisposedDescr)
        ]
        public bool IsDisposed {
            get {
                return GetState(STATE_DISPOSED);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Disposing"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the control is in the process of being disposed. This 
        ///       property is read-only.</para>
        /// </devdoc>
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced), 
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ControlDisposingDescr)
        ]
        public bool Disposing {
            get {
                return GetState(STATE_DISPOSING);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Dock"]/*' />
        /// <devdoc>
        ///     The dock property. The dock property controls to which edge
        ///     of the container this control is docked to. For example, when docked to
        ///     the top of the container, the control will be displayed flush at the
        ///     top of the container, extending the length of the container.
        /// </devdoc>
        [
        SRCategory(SR.CatLayout),
        Localizable(true),
        RefreshProperties(RefreshProperties.Repaint),
        DefaultValue(DockStyle.None),
        SRDescription(SR.ControlDockDescr)
        ]
        public virtual DockStyle Dock {
            get {
                LayoutInfo layout = (LayoutInfo)Properties.GetObject(PropLayoutInfo);
                
                if (layout == null || !layout.IsDock) {
                    return DockStyle.None;
                }
                else {
                    return layout.Dock;
                }
            }
            set {
                if (Dock != value) {

                    if (!Enum.IsDefined(typeof(DockStyle), value)) {
                        throw new InvalidEnumArgumentException("value", (int)value, typeof(DockStyle));
                    }
    
#if DEBUG
        int dbgLayoutCheck = LayoutSuspendCount;
#endif
                    SuspendLayout();
                    try {
                    
                        LayoutInfo layout = (LayoutInfo)Properties.GetObject(PropLayoutInfo);
                        
                        // Cancel anchor if it is set.
                        //
                        if (layout != null && !layout.IsDock) {
                            Anchor = AnchorStyles.Top | AnchorStyles.Left;
                            
                            // Re-get layout because changing Anchor may have cleared it.
                            //
                            layout = (LayoutInfo)Properties.GetObject(PropLayoutInfo);
                        }
                        
                        if (value == DockStyle.None) {
                            if (layout != null) {
                                Debug.Assert(layout.IsDock, "Canceling Anchor should have cleared this.");
                                int x = layout.OriginalX;
                                int y = layout.OriginalY;
                                int width = layout.OriginalWidth;
                                int height = layout.OriginalHeight;
                                Properties.SetObject(PropLayoutInfo, null);
                                SetBoundsCore(x, y, width, height, BoundsSpecified.None);
                            }
                        }
                        else {
                            if (layout == null) {
                                // First time we've been docked.  Remember our bounds.
                                //
                                layout = new LayoutInfo(value, Left, Top, Width, Height);
                            }
                            else {
                                // Not the frist time; just change the mode and use the
                                // previously saved bounds.
                                //
                                layout.Dock = value;
                            }
                            
                            Properties.SetObject(PropLayoutInfo, layout);
                            
                            // Now setup the new bounds.
                            //
                            SetBoundsCore(layout.OriginalX, layout.OriginalY, layout.OriginalWidth, layout.OriginalHeight, BoundsSpecified.All);
                        }
                        
                        if (ParentInternal != null) ParentInternal.PerformLayout(this, "Dock");
                        OnDockChanged(EventArgs.Empty);
                    }
                    finally {
                        ResumeLayout();
#if DEBUG
        AssertLayoutSuspendCount(dbgLayoutCheck);
#endif
                    }
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.DockChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.ControlOnDockChangedDescr)]
        public event EventHandler DockChanged {
            add {
                Events.AddHandler(EventDock, value);
            }
            remove {
                Events.RemoveHandler(EventDock, value);
            }
        }

        private bool DoubleBufferingEnabled {
            get {
                return GetStyle(ControlStyles.DoubleBuffer | ControlStyles.UserPaint);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Enabled"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the control is currently enabled.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        Localizable(true),
        DispId(NativeMethods.ActiveX.DISPID_ENABLED),
        SRDescription(SR.ControlEnabledDescr)
        ]
        public bool Enabled {
            get {
                // We are only enabled if our parent is enabled
                if (!GetState(STATE_ENABLED))
                    return false;
                else if (ParentInternal == null)
                    return true;
                else
                    return ParentInternal.Enabled;
            }

            set {
                bool oldValue = Enabled;
                SetState(STATE_ENABLED, value);

                if (oldValue != value) {
                    if (!value) {
                        SelectNextIfFocused();
                    }

                    OnEnabledChanged(EventArgs.Empty);
                }
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.EnabledChanged"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the control is enabled.</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.ControlOnEnabledChangedDescr)]
        public event EventHandler EnabledChanged {
            add {
                Events.AddHandler(EventEnabled, value);
            }
            remove {
                Events.RemoveHandler(EventEnabled, value);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Focused"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the control has focus. This property is read-only.</para>
        /// </devdoc>
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced), 
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ControlFocusedDescr)
        ]
        public virtual bool Focused {
            get {
                return window.Handle != IntPtr.Zero && UnsafeNativeMethods.GetFocus() == window.Handle;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Font"]/*' />
        /// <devdoc>
        ///     Retrieves the current font for this control. This will be the font used
        ///     by default for painting and text in the control.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        Localizable(true),
        DispId(NativeMethods.ActiveX.DISPID_FONT),
        AmbientValue(null),
        SRDescription(SR.ControlFontDescr)
        ]
        public virtual Font Font {
            [return : MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ActiveXFontMarshaler))]
            get {
                Font font = (Font)Properties.GetObject(PropFont);
                if (font != null) {
                    return font;
                }

                Font f = GetParentFont();
                if (f != null) {
                    return f;
                }

                if (IsActiveX) {
                    f = ActiveXAmbientFont;
                    if (f != null) {
                        return f;
                    }
                }

                AmbientProperties ambient = AmbientPropertiesService;
                if (ambient != null && ambient.Font != null) {
                    return ambient.Font;
                }
                
                return DefaultFont;
            }
            [param : MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(ActiveXFontMarshaler))]
            set {
                Font local = (Font)Properties.GetObject(PropFont);
                Font resolved = Font;

                bool localChanged = false;
                if (value == null) {
                    if (local != null) {
                        localChanged = true;
                    }
                }
                else {
                    if (local == null) {
                        localChanged = true;
                    }
                    else {
                        localChanged = !value.Equals(local);
                    }
                }

                if (localChanged) {
                    // Store new local value
                    //
                    Properties.SetObject(PropFont, value);

                    // Cleanup any font handle wrapper... 
                    //
                    if (Properties.ContainsObject(PropFontHandleWrapper)) {
                        Properties.SetObject(PropFontHandleWrapper, null);
                    }

                    // We only fire the Changed event if the "resolved" value
                    // changed, however we must update the font if the local
                    // value changed... 
                    //
                    if (!resolved.Equals(value)) {
                        if (Properties.ContainsInteger(PropFontHeight)) {
                            Properties.SetInteger(PropFontHeight, (value == null) ? -1 : value.Height);
                        }
                        OnFontChanged(EventArgs.Empty);
                    }
                    else {
                        if (IsHandleCreated && !GetStyle(ControlStyles.UserPaint)) {
                            SendMessage(NativeMethods.WM_SETFONT, FontHandle, 0);
                        }
                    }
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.FontChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.ControlOnFontChangedDescr)]
        public event EventHandler FontChanged {
            add {
                Events.AddHandler(EventFont, value);
            }
            remove {
                Events.RemoveHandler(EventFont, value);
            }
        }

        internal IntPtr FontHandle {
            get { 
                Font font = (Font)Properties.GetObject(PropFont);
                
                if (font != null) {
                    FontHandleWrapper fontHandle = (FontHandleWrapper)Properties.GetObject(PropFontHandleWrapper);
                    if (fontHandle == null) {
                        fontHandle = new FontHandleWrapper(font);
                        Properties.SetObject(PropFontHandleWrapper, fontHandle);
                    }
                    
                    return fontHandle.Handle;
                }
                
                if (parent != null) {
                    return parent.FontHandle;
                }

                AmbientProperties ambient = AmbientPropertiesService;

                if (ambient != null && ambient.Font != null) {

                    FontHandleWrapper fontHandle = null;
                    
                    Font currentAmbient = (Font)Properties.GetObject(PropCurrentAmbientFont);
                    
                    if (currentAmbient != null && currentAmbient == ambient.Font) {
                        fontHandle = (FontHandleWrapper)Properties.GetObject(PropFontHandleWrapper);
                    }
                    else {
                        Properties.SetObject(PropCurrentAmbientFont, ambient.Font);
                    }

                    if (fontHandle == null) {
                        font =  ambient.Font;
                        fontHandle = new FontHandleWrapper(font);
                        Properties.SetObject(PropFontHandleWrapper, fontHandle);
                    }

                    return fontHandle.Handle;
                }
                
                return GetDefaultFontHandleWrapper().Handle;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.FontHeight"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected int FontHeight {
            get {   
                bool found;
                int fontHeight = Properties.GetInteger(PropFontHeight, out found);
                if (found && fontHeight != -1) {
                    return fontHeight;
                }
                else {
                    Font font = (Font)Properties.GetObject(PropFont);
                    if (font != null) {
                        fontHeight = font.Height;
                        Properties.SetInteger(PropFontHeight, fontHeight);
                        return fontHeight;
                    }
                }

                //ask the parent if it has the font height
                int localFontHeight = -1;

                if (ParentInternal != null && ParentInternal.CanAccessProperties) {
                    localFontHeight = ParentInternal.FontHeight;
                }

                //if we still have a bad value, then get the actual font height
                if (localFontHeight == -1) {
                    localFontHeight = Font.Height;
                    Properties.SetInteger(PropFontHeight, localFontHeight);
                }

                return localFontHeight;
            }
            set {
                Properties.SetInteger(PropFontHeight, value);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ForeColor"]/*' />
        /// <devdoc>
        ///     The foreground color of the control.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DispId(NativeMethods.ActiveX.DISPID_FORECOLOR),
        SRDescription(SR.ControlForeColorDescr)
        ]
        public virtual Color ForeColor {
            get {
                object color = Properties.GetObject(PropForeColor);
                if (color != null && !((Color)color).IsEmpty) {
                    return (Color)color;
                }
                
                Control p = ParentInternal;
                if (p != null && p.CanAccessProperties) {
                    return p.ForeColor;
                }

                Color c = Color.Empty;

                if (IsActiveX) {
                    c = ActiveXAmbientForeColor;
                }

                if (c.IsEmpty) {
                    AmbientProperties ambient = AmbientPropertiesService;
                    if (ambient != null)
                        c = ambient.ForeColor;
                }

                if (!c.IsEmpty)
                    return c;
                else
                    return DefaultForeColor;
            }

            set {
                Color c = ForeColor;
                if (!value.IsEmpty || Properties.ContainsObject(PropForeColor)) {
                    Properties.SetObject(PropForeColor, value);
                }
                if (!c.Equals(ForeColor)) {
                    OnForeColorChanged(EventArgs.Empty);
                }
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ForeColorChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.ControlOnForeColorChangedDescr)]
        public event EventHandler ForeColorChanged {
            add {
                Events.AddHandler(EventForeColor, value);
            }
            remove {
                Events.RemoveHandler(EventForeColor, value);
            }
        }

        private Font GetParentFont() {
            if (ParentInternal  != null && ParentInternal.CanAccessProperties)
                return ParentInternal.Font;
            else
                return null;
        }



        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Handle"]/*' />
        /// <devdoc>
        ///     The HWND handle that this control is bound to. If the handle
        ///     has not yet been created, this will force handle creation.
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        DispId(NativeMethods.ActiveX.DISPID_HWND),
        SRDescription(SR.ControlHandleDescr)
        ]
        public IntPtr Handle {
            get {
                if (window.Handle == IntPtr.Zero) CreateHandle();
                return window.Handle;
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.HasChildren"]/*' />
        /// <devdoc>
        ///     True if this control has child controls in its collection.  This 
        ///     is more efficient than checking for Controls.Count > 0, but has the
        ///     same effect.
        /// </devdoc>
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced), 
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ControlHasChildrenDescr)
        ]
        public bool HasChildren {
            get {
                ControlCollection controls = (ControlCollection)Properties.GetObject(PropControlsCollection);
                return controls != null && controls.Count > 0;
            }
        }

        internal virtual bool HasMenu {
            get {
                return false;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Height"]/*' />
        /// <devdoc>
        ///     The height of this control
        /// </devdoc>
        [
        SRCategory(SR.CatLayout),
        Browsable(false), EditorBrowsable(EditorBrowsableState.Always),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ControlHeightDescr)
        ]
        public int Height {
            get {
                return height;
            }
            set{
                SetBounds(x, y, width, value, BoundsSpecified.Height);
            }
        }

        internal bool HostedInWin32DialogManager {
            get {
                if (!GetState(STATE_CHECKEDHOST)) {
                    Control topMost = TopMostParent;
                    if (this != topMost) {
                        SetState(STATE_HOSTEDINDIALOG, topMost.HostedInWin32DialogManager);
                    }
                    else {
                        IntPtr parentHandle = UnsafeNativeMethods.GetParent(new HandleRef(this, Handle));
                        IntPtr lastParentHandle = parentHandle;

                        StringBuilder sb = new StringBuilder(32);

                        SetState(STATE_HOSTEDINDIALOG, false);

                        while (parentHandle != IntPtr.Zero) {
                            int len = UnsafeNativeMethods.GetClassName(new HandleRef(null, lastParentHandle), null, 0);
                            if (len > sb.Capacity) {
                                sb.Capacity = len + 5;
                            }
                            UnsafeNativeMethods.GetClassName(new HandleRef(null, lastParentHandle), sb, sb.Capacity);

                            if (sb.ToString() == "#32770") {
                                SetState(STATE_HOSTEDINDIALOG, true);
                                break;
                            }

                            lastParentHandle = parentHandle;
                            parentHandle = UnsafeNativeMethods.GetParent(new HandleRef(null, parentHandle));
                        }
                    }

                    SetState(STATE_CHECKEDHOST, true);

                }

                return GetState(STATE_HOSTEDINDIALOG);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.IsHandleCreated"]/*' />
        /// <devdoc>
        ///     Whether or not this control has a handle associated with it.
        /// </devdoc>
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced), 
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ControlHandleCreatedDescr)
        ]
        public bool IsHandleCreated {
            get { return window.Handle != IntPtr.Zero; }
        }

        internal bool IsWindowObscured {
            get {
                if (!IsHandleCreated || !Visible) {
                    return false;
                }

                bool emptyRegion = false;

                NativeMethods.RECT temp = new NativeMethods.RECT();
                Region working;
                Control parent = ParentInternal;
                if (parent != null) {
                    while (parent.ParentInternal != null ) {
                        parent = parent.ParentInternal;
                    }
                }

                UnsafeNativeMethods.GetWindowRect(new HandleRef(this, Handle), ref temp);
                working = new Region(Rectangle.FromLTRB(temp.left, temp.top, temp.right, temp.bottom));

                try {
                    IntPtr prev;
                    IntPtr next;
                    IntPtr start;
                    if (parent != null) {
                        start = parent.Handle;
                    }
                    else {
                        start = Handle;
                    }

                    for (prev = start;
                         (next = UnsafeNativeMethods.GetWindow(new HandleRef(null, prev), NativeMethods.GW_HWNDPREV)) != IntPtr.Zero;
                         prev = next) {

                        UnsafeNativeMethods.GetWindowRect(new HandleRef(null, next), ref temp);
                        Rectangle current = Rectangle.FromLTRB(temp.left, temp.top, temp.right, temp.bottom);

                        if (SafeNativeMethods.IsWindowVisible(new HandleRef(null, next))) {
                            working.Exclude(current);
                        }
                    }


                    Graphics g = CreateGraphics();
                    try {
                        emptyRegion = working.IsEmpty(g);
                    }
                    finally {
                        g.Dispose();
                    }
                }
                finally {
                    working.Dispose();
                }

                return emptyRegion;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ImeMode"]/*' />
        /// <devdoc>
        ///     Specifies a value that determines the IME (Input Method Editor) status of the 
        ///     object when that object is selected.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        Localizable(true),
        AmbientValue(ImeMode.Inherit),
        SRDescription(SR.ControlIMEModeDescr)
        ]
        public ImeMode ImeMode {
            get {
                if (!DesignMode && Focused && CachedImeMode != ImeMode.NoControl) {
                    UpdateCachedImeMode(this.Handle);
                }
                
                return CachedImeMode;
            }
            set {
                if (!Enum.IsDefined(typeof(ImeMode), value)) {
                    throw new InvalidEnumArgumentException("ImeMode", (int)value, typeof(ImeMode));
                }
                
#if DEBUG                
                Debug.WriteLineIf(CompModSwitches.ImeMode.TraceInfo, "Setting ImeMode to " + value.ToString() + ", this = " + this.GetType().ToString());
#endif                

                ImeMode oldImeMode = CachedImeMode;
                
                Properties.SetInteger(PropImeMode, (int)value);
                if (!DesignMode && CachedImeMode != ImeMode.NoControl) {
                    if (Focused) {
                        CurrentImeContextMode = CachedImeMode;
                    }
                    else if (ContainsFocus) {
                        Control ctl = FromChildHandleInternal(UnsafeNativeMethods.GetFocus());
                        ctl.CurrentImeContextMode = ctl.CachedImeMode;
                    }
                }
                
                if (CachedImeMode != oldImeMode) {
                    OnImeModeChanged(EventArgs.Empty);
                }
            }
        }
        
        private static Hashtable ImeModeConversionBits {
            get {
                if (imeModeConversionBits == null) {

                    // Create ImeModeConversionBits dictionary
                    imeModeConversionBits = new Hashtable(7);
                    ImeModeConversion conversion;                                       

                    // Hiragana
                    //                   
                    conversion.setBits = NativeMethods.IME_CMODE_FULLSHAPE | NativeMethods.IME_CMODE_NATIVE;
                    conversion.clearBits = NativeMethods.IME_CMODE_KATAKANA;
                    imeModeConversionBits.Add(ImeMode.Hiragana, conversion);

                    // Katakana
                    //
                    conversion.setBits = NativeMethods.IME_CMODE_FULLSHAPE | NativeMethods.IME_CMODE_KATAKANA | NativeMethods.IME_CMODE_NATIVE;
                    conversion.clearBits = 0;
                    imeModeConversionBits.Add(ImeMode.Katakana, conversion);

                    // KatakanaHalf
                    //
                    conversion.setBits = NativeMethods.IME_CMODE_KATAKANA | NativeMethods.IME_CMODE_NATIVE;
                    conversion.clearBits = NativeMethods.IME_CMODE_FULLSHAPE;
                    imeModeConversionBits.Add(ImeMode.KatakanaHalf, conversion);

                    // AlphaFull
                    //
                    conversion.setBits = NativeMethods.IME_CMODE_FULLSHAPE;
                    conversion.clearBits = NativeMethods.IME_CMODE_KATAKANA | NativeMethods.IME_CMODE_NATIVE;
                    imeModeConversionBits.Add(ImeMode.AlphaFull, conversion);

                    // Alpha
                    //
                    conversion.setBits = 0;
                    conversion.clearBits = NativeMethods.IME_CMODE_FULLSHAPE | NativeMethods.IME_CMODE_KATAKANA | NativeMethods.IME_CMODE_NATIVE;
                    imeModeConversionBits.Add(ImeMode.Alpha, conversion);

                    // HangulFull
                    //
                    conversion.setBits = NativeMethods.IME_CMODE_FULLSHAPE | NativeMethods.IME_CMODE_NATIVE;
                    conversion.clearBits = 0;
                    imeModeConversionBits.Add(ImeMode.HangulFull, conversion);

                    // Hangul
                    //
                    conversion.setBits = NativeMethods.IME_CMODE_NATIVE;
                    conversion.clearBits = NativeMethods.IME_CMODE_FULLSHAPE;
                    imeModeConversionBits.Add(ImeMode.Hangul, conversion);               
                }

                return imeModeConversionBits;
            }
        }


        /// <devdoc>
        ///     Returns the current value of the handle. This may be zero if the handle
        ///     has not been created.
        /// </devdoc>
        internal IntPtr InternalHandle {
            get {
                return window.Handle;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.InvokeRequired"]/*' />
        /// <devdoc>
        ///     Determines if the caller must call invoke when making method
        ///     calls to this control.  Controls in windows forms are bound to a specific thread,
        ///     and are not thread safe.  Therefore, if you are calling a control's method
        ///     from a different thread, you must use the control's invoke method
        ///     to marshal the call to the proper thread.  This function can be used to
        ///     determine if you must call invoke, which can be handy if you don't know
        ///     what thread owns a control.
        ///
        ///     There are five functions on a control that are safe to call from any
        ///     thread:  GetInvokeRequired, Invoke, BeginInvoke, EndInvoke and 
        ///     CreateGraphics.  For all other metohd calls, you should use one of the 
        ///     invoke methods.
        /// </devdoc>
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ControlInvokeRequiredDescr)
        ]
        public bool InvokeRequired {
            get {
                HandleRef hwnd;
                if (IsHandleCreated) {
                    hwnd = new HandleRef(this, Handle);
                }
                else {
                    Control marshalingControl = FindMarshalingControl();

                    if (!marshalingControl.IsHandleCreated) {
                        return false;
                    }

                    hwnd = new HandleRef(marshalingControl, marshalingControl.Handle);
                }

                int pid;
                int hwndThread = SafeNativeMethods.GetWindowThreadProcessId(hwnd, out pid);
                int currentThread = SafeNativeMethods.GetCurrentThreadId();
                return(hwndThread != currentThread);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.IsAccessible"]/*' />
        /// <devdoc>
        ///      Indicates whether or not this control is an accessible control
        ///      i.e. whether it should be visible to accessibility applications.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ControlIsAccessibleDescr)
        ]
        public bool IsAccessible {
            get {
                return GetState(STATE_ISACCESSIBLE);
            }
            set {
                SetState(STATE_ISACCESSIBLE, value);
            }
        }

        /// <devdoc>
        ///     Used to tell if this control is being hosted as an ActiveX control.
        /// </devdoc>
        private bool IsActiveX {
            get {
                return (Properties.GetObject(PropActiveXImpl) != null);
            }
        }

        // This is an internal flag moved over with bindings changed.
        // could be used if SUspend/ResumeBindings is added.
        internal bool IsBinding {
            get {
                return this.Created;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Left"]/*' />
        /// <devdoc>
        ///     The left coordinate of this control.
        /// </devdoc>
        [
        SRCategory(SR.CatLayout),
        Browsable(false), EditorBrowsable(EditorBrowsableState.Always),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ControlLeftDescr)
        ]
        public int Left {
            get {
                return x;
            }
            set {
                SetBounds(value, y, width, height, BoundsSpecified.X);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Location"]/*' />
        /// <devdoc>
        ///     The location of this control.
        /// </devdoc>
        [
        SRCategory(SR.CatLayout),
        Localizable(true),
        SRDescription(SR.ControlLocationDescr)
        ]
        public Point Location {
            get {
                return new Point(x, y);
            }
            set {
                SetBounds(value.X, value.Y, width, height, BoundsSpecified.Location);
            }
        }
        

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.LocationChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.ControlOnLocationChangedDescr)]
        public event EventHandler LocationChanged {
            add {
                Events.AddHandler(EventLocation, value);
            }
            remove {
                Events.RemoveHandler(EventLocation, value);
            }
        }
        
        /// <devdoc>
        ///     Retrieves the mnemonic, if any, for this control.  If the text
        ///     has no mnemonic, this will return 0
        /// </devdoc>
        internal char Mnemonic {
            get {
                string text = Text;
                char mnemonic = (char)0;
                
                if (text != null) {
                    int len = text.Length;
                    for (int i = 0; i < len - 1; i++) {
                        if (text[i] == '&' && text[i+1] != '&') {
                            mnemonic = Char.ToLower(text[i+1], CultureInfo.CurrentCulture);
                            break;
                        }
                    }
                }
                
                return mnemonic;
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ModifierKeys"]/*' />
        /// <devdoc>
        ///     Retrieves the current state of the modifier keys. This will check the
        ///     current state of the shift, control, and alt keys.
        /// </devdoc>
        public static Keys ModifierKeys {
            get {
                Keys modifiers = 0;
                // SECURITYNOTE : only let state of Shift-Control-Alt out... 
                //
                if (UnsafeNativeMethods.GetKeyState((int)Keys.ShiftKey) < 0) modifiers |= Keys.Shift;
                if (UnsafeNativeMethods.GetKeyState((int)Keys.ControlKey) < 0) modifiers |= Keys.Control;
                if (UnsafeNativeMethods.GetKeyState((int)Keys.Menu) < 0) modifiers |= Keys.Alt;
                return modifiers;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.MouseButtons"]/*' />
        /// <devdoc>
        ///     The current state of the mouse buttons. This will check the
        ///     current state of the left, right, and middle mouse buttons.
        /// </devdoc>
        public static MouseButtons MouseButtons {
            get {
                MouseButtons buttons = (MouseButtons)0;
                // SECURITYNOTE : only let state of MouseButtons out... 
                //
                if (UnsafeNativeMethods.GetKeyState((int)Keys.LButton) < 0) buttons |= MouseButtons.Left;
                if (UnsafeNativeMethods.GetKeyState((int)Keys.RButton) < 0) buttons |= MouseButtons.Right;
                if (UnsafeNativeMethods.GetKeyState((int)Keys.MButton) < 0) buttons |= MouseButtons.Middle;
                if (UnsafeNativeMethods.GetKeyState((int)Keys.XButton1) < 0) buttons |= MouseButtons.XButton1;
                if (UnsafeNativeMethods.GetKeyState((int)Keys.XButton2) < 0) buttons |= MouseButtons.XButton2;
                return buttons;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.MousePosition"]/*' />
        /// <devdoc>
        ///     The current position of the mouse in screen coordinates.
        /// </devdoc>
        public static Point MousePosition {
            get {
                // SECREVIEW : verify it is OK to skip this demand
                //
                // Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "ScreenLocationOfThings Demanded");
                // IntSecurity.ScreenLocationOfThings.Demand();

                NativeMethods.POINT pt = new NativeMethods.POINT();
                UnsafeNativeMethods.GetCursorPos(pt);
                return new Point(pt.x, pt.y);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Name"]/*' />
        /// <devdoc>
        ///     Name of this control. The designer will set this to the same
        ///     as the programatic Id "(name)" of the control - however this
        ///     property has no bearing on the runtime aspects of this control.
        /// </devdoc>
        [Browsable(false)]
        public string Name {
            get {
                string name = (string)Properties.GetObject(PropName);
                if (name == null || name.Length == 0) {
                    if (Site != null) {
                        name = Site.Name;
                    }

                    if (name == null) {
                        name = "";
                    }
                }

                return name;
            }
            set {
                if (value == null || value.Length == 0) {
                    Properties.SetObject(PropName, null);
                }
                else {
                    Properties.SetObject(PropName, value);
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Parent"]/*' />
        /// <devdoc>
        ///     The parent of this control.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ControlParentDescr)
        ]
        public Control Parent {
            get {
                Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "GetParent Demanded");
                IntSecurity.GetParent.Demand();

                return ParentInternal;
            }
            set {
                ParentInternal = value;                
            }
        }

        internal virtual Control ParentInternal {
            get {
                return parent;
            }
            set {
                if (parent != value) {
                    if (value != null) {
                        value.Controls.Add(this);
                    }
                    else {
                        parent.Controls.Remove(this);
                    }
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ProductName"]/*' />
        /// <devdoc>
        ///     Retrieves the product name of this specific component.
        /// </devdoc>
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ControlProductNameDescr)
        ]
        public string ProductName {
            get {
                return VersionInfo.ProductName;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ProductVersion"]/*' />
        /// <devdoc>
        ///     Retrieves the product version of this specific component.
        /// </devdoc>
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ControlProductVersionDescr)
        ]
        public string ProductVersion {
            get {
                return VersionInfo.ProductVersion;
            }
        }
        
        /// <devdoc>
        ///     Retrieves our internal property storage object. If you have a property
        ///     whose value is not always set, you should store it in here to save
        ///     space.
        /// </devdoc>
        internal PropertyStore Properties {
            get {
                return propertyStore;
            }
        }

        // Returns the value of the backColor field -- no asking the parent with its color is, etc.
        internal Color RawBackColor {
            get {
                object color = Properties.GetObject(PropBackColor);
                if (color != null) {
                    return (Color)color;
                }
                else {
                    return Color.Empty;
                }
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.RecreatingHandle"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the control is currently recreating its handle. This 
        ///       property is read-only.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ControlRecreatingHandleDescr)
        ]
        public bool RecreatingHandle {
            get {
                return(state & STATE_RECREATE) != 0;
            }
        }                     

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Region"]/*' />
        /// <devdoc>
        ///     The Region associated with this control.  (defines the
        ///     outline/silhouette/boundary of control)
        /// </devdoc>
        [
        SRCategory(SR.CatLayout),
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ControlRegionDescr)
        ]
        public Region Region {
            get { 
                return (Region)Properties.GetObject(PropRegion);
            }
            set {
                if (GetState(STATE_TOPLEVEL)) {
                    Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "ChangeWindowRegion Demanded");
                    IntSecurity.ChangeWindowRegionForTopLevel.Demand();
                }

                Region oldRegion = Region;
                Properties.SetObject(PropRegion, value);
                
                if (oldRegion != null) {
                    oldRegion.Dispose();
                }

                if (IsHandleCreated) {
                    IntPtr regionHandle = IntPtr.Zero;
                    if (value != null) {
                        regionHandle = GetHRgn(value);
                    }

                    if (IsActiveX) {
                        regionHandle = ActiveXMergeRegion(regionHandle);
                    }

                    UnsafeNativeMethods.SetWindowRgn(new HandleRef(this, Handle), new HandleRef(this, regionHandle), SafeNativeMethods.IsWindowVisible(new HandleRef(this, Handle)));
                }
            }
        }

        // Helper function for Rtl
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.RenderRightToLeft"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected bool RenderRightToLeft {
            get {
                return true;
            }
        }

        /// <devdoc>
        ///     Determines if the parent's background will be rendered on the label control.
        /// </devdoc>
        internal bool RenderTransparent {
            get {
                return GetStyle(ControlStyles.SupportsTransparentBackColor) && BackColor.A < 255;
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ResizeRedraw"]/*' />
        /// <devdoc>
        ///     Indicates whether the control should redraw itself when resized.
        /// </devdoc>
        [
        SRDescription(SR.ControlResizeRedrawDescr)
        ]
        protected bool ResizeRedraw {
            get {
                return GetStyle( ControlStyles.ResizeRedraw );
            }
            set {
                SetStyle( ControlStyles.ResizeRedraw, value );
            }
        }
        
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Right"]/*' />
        /// <devdoc>
        ///    <para>The right coordinate of the control.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatLayout),
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ControlRightDescr)
        ]
        public int Right {
            get {
                return x + width;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.RightToLeft"]/*' />
        /// <devdoc>
        ///     This is used for international applications where the language
        ///     is written from RightToLeft. When this property is true,
        ///     control placement and text will be from right to left.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        Localizable(true),
        AmbientValue(RightToLeft.Inherit),
        SRDescription(SR.ControlRightToLeftDescr)
        ]
        public virtual RightToLeft RightToLeft {
            get {
                bool found;
                int rightToLeft = Properties.GetInteger(PropRightToLeft, out found);
                if (!found) {
                    rightToLeft = (int)RightToLeft.Inherit;
                }
                
                if (((RightToLeft)rightToLeft) == RightToLeft.Inherit) {
                    Control parent = ParentInternal;
                    if (parent != null) {
                        rightToLeft = (int)parent.RightToLeft;
                    }
                    else {
                        rightToLeft = (int)DefaultRightToLeft;
                    }
                }
                return (RightToLeft)rightToLeft;                
            }
            
            set {
                if (!Enum.IsDefined(typeof(RightToLeft), value)) {
                    throw new InvalidEnumArgumentException("RightToLeft", (int)value, typeof(RightToLeft));
                }
                
                RightToLeft oldValue = RightToLeft;
                
                if (Properties.ContainsInteger(PropRightToLeft) || value != RightToLeft.Inherit) {
                    Properties.SetInteger(PropRightToLeft, (int)value);
                }
                
                if (oldValue != RightToLeft) {
                    OnRightToLeftChanged(EventArgs.Empty);
                }
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.RightToLeftChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.ControlOnRightToLeftChangedDescr)]
        public event EventHandler RightToLeftChanged {
            add {
                Events.AddHandler(EventRightToLeft, value);
            }
            remove {
                Events.RemoveHandler(EventRightToLeft, value);
            }
        }
        
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Site"]/*' />
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        public override ISite Site {
            get {
                return base.Site;
            }
            set {
                AmbientProperties oldAmbients = AmbientPropertiesService;
                AmbientProperties newAmbients = null;
                
                if (value != null) {
                    newAmbients = (AmbientProperties)value.GetService(typeof(AmbientProperties));
                }
                
                
                // If the ambients changed, compare each property.
                //
                if (oldAmbients != newAmbients) {
                    bool checkFont = !Properties.ContainsObject(PropFont);
                    bool checkBackColor = !Properties.ContainsObject(PropBackColor);
                    bool checkForeColor = !Properties.ContainsObject(PropForeColor);
                    bool checkCursor = !Properties.ContainsObject(PropCursor);
                    
                    Font oldFont = null;
                    Color oldBackColor = Color.Empty;
                    Color oldForeColor = Color.Empty;
                    Cursor oldCursor = null;
                    
                    if (checkFont) {
                        oldFont = Font;
                    }
                    
                    if (checkBackColor) {
                        oldBackColor = BackColor;
                    }
                    
                    if (checkForeColor) {
                        oldForeColor = ForeColor;
                    }
                    
                    if (checkCursor) {
                        oldCursor = Cursor;
                    }
                    
                    Properties.SetObject(PropAmbientPropertiesService, newAmbients);
                    base.Site = value;
                    
                    if (checkFont && !oldFont.Equals(Font)) {
                        OnFontChanged(EventArgs.Empty);
                    }
                    if (checkForeColor && !oldForeColor.Equals(ForeColor)) {
                        OnForeColorChanged(EventArgs.Empty);
                    }
                    if (checkBackColor && !oldBackColor.Equals(BackColor)) {
                        OnBackColorChanged(EventArgs.Empty);
                    }
                    if (checkCursor && oldCursor.Equals(Cursor)) {
                        OnCursorChanged(EventArgs.Empty);
                    }
                }
                else {
                    // If the ambients haven't changed, we just set a new site.
                    //
                    base.Site = value;
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Size"]/*' />
        /// <devdoc>
        ///    <para>The size of the control.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatLayout),
        Localizable(true),
        SRDescription(SR.ControlSizeDescr)
        ]
        public Size Size {
            get {
                return new Size(width, height);
            }
            set {
                SetBounds(x, y, value.Width, value.Height, BoundsSpecified.Size);
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.SizeChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.ControlOnSizeChangedDescr)]
        public event EventHandler SizeChanged {
            add {
                Events.AddHandler(EventSize, value);
            }
            remove {
                Events.RemoveHandler(EventSize, value);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.TabIndex"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       The tab index of
        ///       this control.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        Localizable(true),
        MergableProperty(false),
        SRDescription(SR.ControlTabIndexDescr)
        ]
        public int TabIndex {
            get {
                return tabIndex == -1 ? 0 : tabIndex;
            }
            set {
                if (value < 0) {
                    throw new ArgumentException(SR.GetString(SR.InvalidLowBoundArgumentEx, "TabIndex", value.ToString(), "0"));
                }

                if (tabIndex != value) {
                    tabIndex = value;
                    OnTabIndexChanged(EventArgs.Empty);
                }
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.TabIndexChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.ControlOnTabIndexChangedDescr)]
        public event EventHandler TabIndexChanged {
            add {
                Events.AddHandler(EventTabIndex, value);
            }
            remove {
                Events.RemoveHandler(EventTabIndex, value);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.TabStop"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the user can give the focus to this control using the TAB 
        ///       key. This property is read-only.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(true),
        DispId(NativeMethods.ActiveX.DISPID_TABSTOP),
        SRDescription(SR.ControlTabStopDescr)
        ]
        public bool TabStop {
            get {
                return(state & STATE_TABSTOP) != 0;
            }
            set {
                if (TabStop != value) {
                    SetState(STATE_TABSTOP, value);
                    if (window.Handle != IntPtr.Zero) SetWindowStyle(NativeMethods.WS_TABSTOP, value);
                    OnTabStopChanged(EventArgs.Empty);
                }
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.TabStopChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.ControlOnTabStopChangedDescr)]
        public event EventHandler TabStopChanged {
            add {
                Events.AddHandler(EventTabStop, value);
            }
            remove {
                Events.RemoveHandler(EventTabStop, value);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Tag"]/*' />
        [
        SRCategory(SR.CatData),
        Localizable(false),
        Bindable(true),
        SRDescription(SR.ControlTagDescr),
        DefaultValue(null),
        TypeConverter(typeof(StringConverter)),
        ]
        public object Tag {
            get {
                return Properties.GetObject(PropUserData);
            }
            set {
                Properties.SetObject(PropUserData, value);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Text"]/*' />
        /// <devdoc>
        ///     The current text associated with this control.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        Localizable(true),
        Bindable(true),
        DispId(NativeMethods.ActiveX.DISPID_TEXT),
        SRDescription(SR.ControlTextDescr)
        ]
        public virtual string Text {
            get {
                if (GetStyle(ControlStyles.CacheText)) {
                    return(text == null) ? "" : text;
                }
                else {
                    return WindowText;
                }
            }

            set {
                if (value == null) {
                    value = "";
                }
                
                if (value == Text) {
                    return;
                }

                if (GetStyle(ControlStyles.CacheText)) {
                    text = value;       
                }
                WindowText = value;

                OnTextChanged(EventArgs.Empty);
            }
        }
        
        internal string TextWithoutMnemonics {
            get {
                string txt = Text;
                int index = txt.IndexOf('&');
                if (index == -1) {
                    return txt;
                }
                
                // Remove mnemonics
                //
                StringBuilder str = new StringBuilder(txt.Substring(0, index));
                for(; index < txt.Length; ++index) {
                    if (txt[index] == '&') {
                        index++;    // Skip this & and copy the next character instead
                    }
                    if (index < txt.Length) {
                        str.Append(txt[index]);
                    }
                }
                
                return str.ToString();
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.TextChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.ControlOnTextChangedDescr)]
        public event EventHandler TextChanged {
            add {
                Events.AddHandler(EventText, value);
            }
            remove {
                Events.RemoveHandler(EventText, value);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Top"]/*' />
        /// <devdoc>
        ///     Top coordinate of this control.
        /// </devdoc>
        [
        SRCategory(SR.CatLayout),
        Browsable(false), EditorBrowsable(EditorBrowsableState.Always),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ControlTopDescr)
        ]
        public int Top {
            get {
                return y;
            }
            set {
                SetBounds(x, value, width, height, BoundsSpecified.Y);
            }
        }
        
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.TopLevelControl"]/*' />
        /// <devdoc>
        ///     The top level control that contains this control. This doesn't
        ///     have to be the same as the value returned from getForm since forms
        ///     can be parented to other controls.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ControlTopLevelControlDescr)
        ]
        public Control TopLevelControl {
            get {
                Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "GetParent Demanded");
                IntSecurity.GetParent.Demand();
                return TopLevelControlInternal;
            }
        }

        internal Control TopLevelControlInternal {
            get {
                Control control = this;
                while (control != null && !control.GetTopLevel()) {
                    control = control.ParentInternal;
                }
                return control;
            }
        }

        internal Control TopMostParent {
            get {
                Control control = this;
                while (control.ParentInternal != null) {
                    control = control.ParentInternal;
                }
                return control;
            }
        }

        internal GraphicsBufferManager BufferManager {
            get {
                Control top = TopMostParent;
                if (top == null || top == this) {
                    GraphicsBufferManager buffer = (GraphicsBufferManager)Properties.GetObject(PropGraphicsBufferManager);
                    if (buffer == null) {
                        buffer = GraphicsBufferManager.CreateOptimal();
                        Properties.SetObject(PropGraphicsBufferManager, buffer);
                    }
                    return buffer;
                }
                return top.BufferManager;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ShowKeyboardCues"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the user interface is in a state to show or hide keyboard 
        ///       accelerators. This property is read-only.</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        protected bool ShowKeyboardCues {
            get {
                // Controls in design mode always draw their accellerators.
                if (!IsHandleCreated || DesignMode) {
                    return true;
                    // would be nice to query SystemParametersInfo, but have trouble
                    // getting this to work and this should not really be called before
                    // handle created anyway
                }
                else if (GetTopLevel() || parent == null) {
                    return ((int)SendMessage(NativeMethods.WM_QUERYUISTATE, 0, 0) & NativeMethods.UISF_HIDEACCEL) == 0;
                }
                else {
                    return parent.ShowKeyboardCues;
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ShowFocusCues"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the user interface is in a state to show or hide focus 
        ///       rectangles. This property is read-only.</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        protected virtual bool ShowFocusCues {
            get {
                if (!IsHandleCreated) {
                    return true;
                    // would be nice to query SystemParametersInfo, but have trouble
                    // getting this to work and this should not really be called before
                    // handle created anyway
                }
                else if (GetTopLevel() || parent == null) {
                    return ((int)SendMessage(NativeMethods.WM_QUERYUISTATE, 0, 0) & NativeMethods.UISF_HIDEFOCUS) == 0;
                }
                else
                    return parent.ShowFocusCues;
            }
        }
        
        // The parameter used in the call to ShowWindow for this control
        //
        internal virtual int ShowParams {
            [StrongNameIdentityPermissionAttribute(SecurityAction.LinkDemand, Name="System.Windows.Forms", PublicKey="0x00000000000000000400000000000000")]
            [StrongNameIdentityPermissionAttribute(SecurityAction.InheritanceDemand, Name="System.Windows.Forms", PublicKey="0x00000000000000000400000000000000")]
            get {
                return NativeMethods.SW_SHOW;
            }
        }

        private ControlVersionInfo VersionInfo {
            get {
                ControlVersionInfo info = (ControlVersionInfo)Properties.GetObject(PropControlVersionInfo);
                if (info == null) {
                    info = new ControlVersionInfo(this);
                    Properties.SetObject(PropControlVersionInfo, info);
                }
                return info;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Visible"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the control is visible.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        Localizable(true),
        SRDescription(SR.ControlVisibleDescr)
        ]
        public bool Visible {
            get {
                return GetVisibleCore();
            }
            set {
                SetVisibleCore(value);
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.VisibleChanged"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the control becomes visible.</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.ControlOnVisibleChangedDescr)]
        public event EventHandler VisibleChanged {
            add {
                Events.AddHandler(EventVisible, value);
            }
            remove {
                Events.RemoveHandler(EventVisible, value);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Width"]/*' />
        /// <devdoc>
        ///     The width of this control.
        /// </devdoc>
        [
        SRCategory(SR.CatLayout),
        Browsable(false), EditorBrowsable(EditorBrowsableState.Always),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ControlWidthDescr)
        ]
        public int Width {
            get {
                return width;
            }
            set {
                SetBounds(x, y, value, height, BoundsSpecified.Width);
            }
        }

        /// <devdoc>
        ///     The current exStyle of the hWnd
        /// </devdoc>
        /// <internalonly/>
        private int WindowExStyle {
            get {
                return (int) UnsafeNativeMethods.GetWindowLong(new HandleRef(this, Handle), NativeMethods.GWL_EXSTYLE);
            }
            set {
                UnsafeNativeMethods.SetWindowLong(new HandleRef(this, Handle), NativeMethods.GWL_EXSTYLE, new HandleRef(null, (IntPtr)value));
            }
        }

        /// <devdoc>
        ///     The current style of the hWnd
        /// </devdoc>
        /// <internalonly/>
        private int WindowStyle {
            get {
                return (int) UnsafeNativeMethods.GetWindowLong(new HandleRef(this, Handle), NativeMethods.GWL_STYLE);
            }
            set {
                UnsafeNativeMethods.SetWindowLong(new HandleRef(this, Handle), NativeMethods.GWL_STYLE, new HandleRef(null, (IntPtr)value));
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.WindowTarget"]/*' />
        /// <devdoc>
        ///     The target of Win32 window messages.
        /// </devdoc>
        /// <internalonly/>
        [
        SRCategory(SR.CatBehavior),
        Browsable(false), EditorBrowsable(EditorBrowsableState.Never),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ControlWindowTargetDescr)
        ]
        public IWindowTarget WindowTarget {
            [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
            get {
                return window.WindowTarget;
            }
            [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
            set {
                window.WindowTarget = value;
            }
        }

        /// <devdoc>
        ///     The current text of the Window; if the window has not yet been created, stores it in the control.
        ///     If the window has been created, stores the text in the underlying win32 control.
        ///     This property should be used whenever you want to get at the win32 control's text. For all other cases,
        ///     use the Text property - but note that this is overridable, and any of your code that uses it will use
        ///     the overridden version in controls that subclass your own.
        /// </devdoc>
        internal virtual string WindowText {
            [PermissionSetAttribute(SecurityAction.InheritanceDemand, Name="FullTrust")]
            [PermissionSetAttribute(SecurityAction.LinkDemand, Name="FullTrust")]
            get {

                if (window.Handle == IntPtr.Zero) {
                    if (text == null) {
                        return "";
                    }
                    else {
                        return text;
                    }
                }

                int textLen = SafeNativeMethods.GetWindowTextLength(new HandleRef(window, window.Handle));
                StringBuilder sb = new StringBuilder(textLen+1);
                UnsafeNativeMethods.GetWindowText(new HandleRef(window, window.Handle), sb, sb.Capacity);

                return sb.ToString();

            }
            
            [PermissionSetAttribute(SecurityAction.InheritanceDemand, Name="FullTrust")]
            [PermissionSetAttribute(SecurityAction.LinkDemand, Name="FullTrust")]
            set {
                if (value == null) value = "";
                if (!WindowText.Equals(value)) {
                    if (window.Handle != IntPtr.Zero) {
                        UnsafeNativeMethods.SetWindowText(new HandleRef(window, window.Handle), value);
                    }
                    else {
                        if (value.Length == 0) {
                            text = null;
                        }
                        else {
                            text = value;
                        }
                    }
                }
            }
        }



        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Click"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the control is clicked.</para>
        /// </devdoc>
        [SRCategory(SR.CatAction), SRDescription(SR.ControlOnClickDescr)]
        public event EventHandler Click {
            add { 
                Events.AddHandler(EventClick, value); 
            }
            remove {
                Events.RemoveHandler(EventClick, value);
            }
        }



        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ControlAdded"]/*' />
        /// <devdoc>
        ///    <para>Occurs when a new control is added.</para>
        /// </devdoc>
        [SRCategory(SR.CatPrivate), Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced), SRDescription(SR.ControlOnControlAddedDescr)]
        public event ControlEventHandler ControlAdded {
            add {
                Events.AddHandler(EventControlAdded, value);
            }
            remove {
                Events.RemoveHandler(EventControlAdded, value);
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ControlRemoved"]/*' />
        /// <devdoc>
        ///    <para>Occurs when a control is removed.</para>
        /// </devdoc>
        [SRCategory(SR.CatPrivate), Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced), SRDescription(SR.ControlOnControlRemovedDescr)]
        public event ControlEventHandler ControlRemoved {
            add {
                Events.AddHandler(EventControlRemoved, value);
            }
            remove {
                Events.RemoveHandler(EventControlRemoved, value);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.DragDrop"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatDragDrop), SRDescription(SR.ControlOnDragDropDescr)]
        public event DragEventHandler DragDrop {
            add {
                Events.AddHandler(EventDragDrop, value);
            }
            remove {
                Events.RemoveHandler(EventDragDrop, value);
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.DragEnter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatDragDrop), SRDescription(SR.ControlOnDragEnterDescr)]
        public event DragEventHandler DragEnter {
            add {
                Events.AddHandler(EventDragEnter, value);
            }
            remove {
                Events.RemoveHandler(EventDragEnter, value);
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.DragOver"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatDragDrop), SRDescription(SR.ControlOnDragOverDescr)]
        public event DragEventHandler DragOver {
            add {
                Events.AddHandler(EventDragOver, value);
            }
            remove {
                Events.RemoveHandler(EventDragOver, value);
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.DragLeave"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatDragDrop), SRDescription(SR.ControlOnDragLeaveDescr)]
        public event EventHandler DragLeave {
            add {
                Events.AddHandler(EventDragLeave, value);
            }
            remove {
                Events.RemoveHandler(EventDragLeave, value);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.GiveFeedback"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatDragDrop), SRDescription(SR.ControlOnGiveFeedbackDescr)]
        public event GiveFeedbackEventHandler GiveFeedback {
            add {
                Events.AddHandler(EventGiveFeedback, value);
            }
            remove {
                Events.RemoveHandler(EventGiveFeedback, value);
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.HandleCreated"]/*' />
        /// <devdoc>
        ///    <para>Occurs when a handle is created for the control.</para>
        /// </devdoc>
        [SRCategory(SR.CatPrivate), Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced), SRDescription(SR.ControlOnCreateHandleDescr)]
        public event EventHandler HandleCreated {
            add {
                Events.AddHandler(EventHandleCreated, value);
            }
            remove {
                Events.RemoveHandler(EventHandleCreated, value);
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.HandleDestroyed"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the control's handle is destroyed.</para>
        /// </devdoc>
        [SRCategory(SR.CatPrivate), Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced), SRDescription(SR.ControlOnDestroyHandleDescr)]
        public event EventHandler HandleDestroyed {
            add {
                Events.AddHandler(EventHandleDestroyed, value);
            }
            remove {
                Events.RemoveHandler(EventHandleDestroyed, value);
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.HelpRequested"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.ControlOnHelpDescr)]
        public event HelpEventHandler HelpRequested {
            add {
                Events.AddHandler(EventHelpRequested, value);
            }
            remove {
                Events.RemoveHandler(EventHelpRequested, value);
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Invalidated"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatAppearance), Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced), SRDescription(SR.ControlOnInvalidateDescr)]
        public event InvalidateEventHandler Invalidated {
            add {
                Events.AddHandler(EventInvalidated, value);
            }
            remove {
                Events.RemoveHandler(EventInvalidated, value);
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Paint"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatAppearance), SRDescription(SR.ControlOnPaintDescr)]
        public event PaintEventHandler Paint {
            add {
                Events.AddHandler(EventPaint, value);
            }
            remove {
                Events.RemoveHandler(EventPaint, value);
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.QueryContinueDrag"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatDragDrop), SRDescription(SR.ControlOnQueryContinueDragDescr)]
        public event QueryContinueDragEventHandler QueryContinueDrag {
            add {
                Events.AddHandler(EventQueryContinueDrag, value);
            }
            remove {
                Events.RemoveHandler(EventQueryContinueDrag, value);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.QueryAccessibilityHelp"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.ControlOnQueryAccessibilityHelpDescr)]
        public event QueryAccessibilityHelpEventHandler QueryAccessibilityHelp {
            add {
                Events.AddHandler(EventQueryAccessibilityHelp, value);
            }
            remove {
                Events.RemoveHandler(EventQueryAccessibilityHelp, value);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.DoubleClick"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the control is double clicked.</para>
        /// </devdoc>
        [SRCategory(SR.CatAction), SRDescription(SR.ControlOnDoubleClickDescr)]
        public event EventHandler DoubleClick {
            add {
                Events.AddHandler(EventDoubleClick, value);
            }
            remove {
                Events.RemoveHandler(EventDoubleClick, value);
            }
        }
        
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Enter"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the control is entered.</para>
        /// </devdoc>
        [SRCategory(SR.CatFocus), SRDescription(SR.ControlOnEnterDescr)]
        public event EventHandler Enter {
            add {
                Events.AddHandler(EventEnter, value);
            }
            remove {
                Events.RemoveHandler(EventEnter, value);
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.GotFocus"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the control receives focus.</para>
        /// </devdoc>
        [SRCategory(SR.CatFocus), SRDescription(SR.ControlOnGotFocusDescr), Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced)]
        public event EventHandler GotFocus {
            add {
                Events.AddHandler(EventGotFocus, value);
            }
            remove {
                Events.RemoveHandler(EventGotFocus, value);
            }
        }
        
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ImeModeChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [WinCategory("Behavior"), SRDescription(SR.ControlOnImeModeChangedDescr)]
        public event EventHandler ImeModeChanged {
            add {
                Events.AddHandler(EventImeModeChanged, value);
            }
            remove {
                Events.RemoveHandler(EventImeModeChanged, value);
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.KeyDown"]/*' />
        /// <devdoc>
        ///    <para>Occurs when a key is pressed down while the control has focus.</para>
        /// </devdoc>
        [SRCategory(SR.CatKey), SRDescription(SR.ControlOnKeyDownDescr)]
        public event KeyEventHandler KeyDown {
            add {
                Events.AddHandler(EventKeyDown, value);
            }
            remove {
                Events.RemoveHandler(EventKeyDown, value);
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.KeyPress"]/*' />
        /// <devdoc>
        ///    <para> Occurs when a key is pressed while the control has focus.</para>
        /// </devdoc>
        [SRCategory(SR.CatKey), SRDescription(SR.ControlOnKeyPressDescr)]
        public event KeyPressEventHandler KeyPress {
            add {
                Events.AddHandler(EventKeyPress, value);
            }
            remove {
                Events.RemoveHandler(EventKeyPress, value);
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.KeyUp"]/*' />
        /// <devdoc>
        ///    <para> Occurs when a key is released while the control has focus.</para>
        /// </devdoc>
        [SRCategory(SR.CatKey), SRDescription(SR.ControlOnKeyUpDescr)]
        public event KeyEventHandler KeyUp {
            add {
                Events.AddHandler(EventKeyUp, value);
            }
            remove {
                Events.RemoveHandler(EventKeyUp, value);
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Layout"]/*' />
        /// <devdoc>
        /// </devdoc>
        [SRCategory(SR.CatLayout), SRDescription(SR.ControlOnLayoutDescr)]
        public event LayoutEventHandler Layout {
            add {
                Events.AddHandler(EventLayout, value);
            }
            remove {
                Events.RemoveHandler(EventLayout, value);
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Leave"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the control is left.</para>
        /// </devdoc>
        [SRCategory(SR.CatFocus), SRDescription(SR.ControlOnLeaveDescr)]
        public event EventHandler Leave {
            add {
                Events.AddHandler(EventLeave, value);
            }
            remove {
                Events.RemoveHandler(EventLeave, value);
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.LostFocus"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the control loses focus.</para>
        /// </devdoc>
        [SRCategory(SR.CatFocus), SRDescription(SR.ControlOnLostFocusDescr), Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced)]
        public event EventHandler LostFocus {
            add {
                Events.AddHandler(EventLostFocus, value);
            }
            remove {
                Events.RemoveHandler(EventLostFocus, value);
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.MouseDown"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the mouse pointer is over the control and a mouse button is 
        ///       pressed.</para>
        /// </devdoc>
        [SRCategory(SR.CatMouse), SRDescription(SR.ControlOnMouseDownDescr)]
        public event MouseEventHandler MouseDown {
            add {
                Events.AddHandler(EventMouseDown, value);
            }
            remove {
                Events.RemoveHandler(EventMouseDown, value);
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.MouseEnter"]/*' />
        /// <devdoc>
        ///    <para> Occurs when the mouse pointer enters the control.</para>
        /// </devdoc>
        [SRCategory(SR.CatMouse), SRDescription(SR.ControlOnMouseEnterDescr)]
        public event EventHandler MouseEnter {
            add {
                Events.AddHandler(EventMouseEnter, value);
            }
            remove {
                Events.RemoveHandler(EventMouseEnter, value);
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.MouseLeave"]/*' />
        /// <devdoc>
        ///    <para> Occurs when the mouse pointer leaves the control.</para>
        /// </devdoc>
        [SRCategory(SR.CatMouse), SRDescription(SR.ControlOnMouseLeaveDescr)]
        public event EventHandler MouseLeave {
            add {
                Events.AddHandler(EventMouseLeave, value);
            }
            remove {
                Events.RemoveHandler(EventMouseLeave, value);
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.MouseHover"]/*' />
        /// <devdoc>
        ///    <para> Occurs when the mouse pointer hovers over the contro.</para>
        /// </devdoc>
        [SRCategory(SR.CatMouse), SRDescription(SR.ControlOnMouseHoverDescr)]
        public event EventHandler MouseHover {
            add {
                Events.AddHandler(EventMouseHover, value);
            }
            remove {
                Events.RemoveHandler(EventMouseHover, value);
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.MouseMove"]/*' />
        /// <devdoc>
        ///    <para> Occurs when the mouse pointer is moved over the control.</para>
        /// </devdoc>
        [SRCategory(SR.CatMouse), SRDescription(SR.ControlOnMouseMoveDescr)]
        public event MouseEventHandler MouseMove {
            add {
                Events.AddHandler(EventMouseMove, value);
            }
            remove {
                Events.RemoveHandler(EventMouseMove, value);
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.MouseUp"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the mouse pointer is over the control and a mouse button is released.</para>
        /// </devdoc>
        [SRCategory(SR.CatMouse), SRDescription(SR.ControlOnMouseUpDescr)]
        public event MouseEventHandler MouseUp {
            add {
                Events.AddHandler(EventMouseUp, value);
            }
            remove {
                Events.RemoveHandler(EventMouseUp, value);
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.MouseWheel"]/*' />
        /// <devdoc>
        ///    <para> Occurs when the mouse wheel moves while the control has focus.</para>
        /// </devdoc>
        [SRCategory(SR.CatMouse), SRDescription(SR.ControlOnMouseWheelDescr), Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced)]
        public event MouseEventHandler MouseWheel {
            add {
                Events.AddHandler(EventMouseWheel, value);
            }
            remove {
                Events.RemoveHandler(EventMouseWheel, value);
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Move"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the control is moved.</para>
        /// </devdoc>
        [SRCategory(SR.CatLayout), SRDescription(SR.ControlOnMoveDescr)]
        public event EventHandler Move {
            add {
                Events.AddHandler(EventMove, value);
            }
            remove {
                Events.RemoveHandler(EventMove, value);
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Resize"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the control is resized.</para>
        /// </devdoc>
        [SRCategory(SR.CatLayout), SRDescription(SR.ControlOnResizeDescr)]
        public event EventHandler Resize {
            add {
                Events.AddHandler(EventResize, value);
            }
            remove {
                Events.RemoveHandler(EventResize, value);
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ChangeUICues"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.ControlOnChangeUICuesDescr)]
        public event UICuesEventHandler ChangeUICues {
            add {
                Events.AddHandler(EventChangeUICues, value);
            }
            remove {
                Events.RemoveHandler(EventChangeUICues, value);
            }
        }
        
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.StyleChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.ControlOnStyleChangedDescr)]
        public event EventHandler StyleChanged {
            add {
                Events.AddHandler(EventStyleChanged, value);
            }
            remove {
                Events.RemoveHandler(EventStyleChanged, value);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.SystemColorsChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.ControlOnSystemColorsChangedDescr)]
        public event EventHandler SystemColorsChanged {
            add {
                Events.AddHandler(EventSystemColorsChanged, value);
            }
            remove {
                Events.RemoveHandler(EventSystemColorsChanged, value);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Validating"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the control is validating.</para>
        /// </devdoc>
        [SRCategory(SR.CatFocus), SRDescription(SR.ControlOnValidatingDescr)]
        public event CancelEventHandler Validating {
            add {
                Events.AddHandler(EventValidating, value);
            }
            remove {
                Events.RemoveHandler(EventValidating, value);
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Validated"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the control is done validating.</para>
        /// </devdoc>
        [SRCategory(SR.CatFocus), SRDescription(SR.ControlOnValidatedDescr)]
        public event EventHandler Validated {
            add {
                Events.AddHandler(EventValidated, value);
            }
            remove {
                Events.RemoveHandler(EventValidated, value);
            }
        }
        
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.AccessibilityNotifyClients"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected void AccessibilityNotifyClients(AccessibleEvents accEvent, int childID) {
            UnsafeNativeMethods.NotifyWinEvent((int)accEvent, new HandleRef(this, Handle), NativeMethods.OBJID_CLIENT, childID + 1);
        }

        /// <devdoc>
        ///     Helper method for retrieving an ActiveX property.  We abstract these
        ///     to another method so we do not force JIT the ActiveX codebase.
        /// </devdoc>
        private IntPtr ActiveXMergeRegion(IntPtr region) {
            return ActiveXInstance.MergeRegion(region);
        }

        /// <devdoc>
        ///     Helper method for retrieving an ActiveX property.  We abstract these
        ///     to another method so we do not force JIT the ActiveX codebase.
        /// </devdoc>
        private void ActiveXOnFocus(bool focus) {
            ActiveXInstance.OnFocus(focus);
        }

        #if ACTIVEX_SOURCING
        
        //
        // This has been cut from the product.
        //
        
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ActiveXRegister"]/*' />
        /// <devdoc>
        ///     This is called by regasm to register a control as an ActiveX control.
        /// </devdoc>
        [ComRegisterFunction()]
        protected static void ActiveXRegister(Type type) {
        
            if (type == null) {
                throw new ArgumentNullException("type");
            }

            // If the user is not registering an AX control, then
            // bail now.
            //
            if (!typeof(Control).IsAssignableFrom(type)) {
                return;
            }

            // Add the flags that define us as a control to the rest of the
            // world.
            //
            RegistryKey clsidKey = Registry.ClassesRoot.OpenSubKey("CLSID", true).CreateSubKey("{" + type.GUID.ToString() + "}");
            RegistryKey key = clsidKey.CreateSubKey("Control");
            key.Close();

            key = clsidKey.CreateSubKey("Implemented Categories");
            RegistryKey subKey = key.CreateSubKey("{40FC6ED4-2438-11CF-A3DB-080036F12502}"); // CATID_Control
            subKey.Close();
            key.Close();

            // Calculate MiscStatus bits.  Note that this is a static version
            // of GetMiscStatus in ActiveXImpl below.  Keep them in sync!
            //
            int miscStatus = NativeMethods.OLEMISC_ACTIVATEWHENVISIBLE | 
                             NativeMethods.OLEMISC_INSIDEOUT | 
                             NativeMethods.OLEMISC_SETCLIENTSITEFIRST |
                             NativeMethods.OLEMISC_RECOMPOSEONRESIZE;
            if (typeof(IButtonControl).IsAssignableFrom(type)) {
                miscStatus |= NativeMethods.OLEMISC_ACTSLIKEBUTTON;
            }

            key = clsidKey.CreateSubKey("MiscStatus");
            key.SetValue("", miscStatus.ToString());
            key.Close();

            // Now add the typelib information.  Many containers don't 
            // host Active X controls without a typelib in the registry
            // (visual basic won't even show it in the control dialog).  
            //
            Guid typeLibGuid = Marshal.GetTypeLibGuidForAssembly(type.Assembly);
            Version assemblyVer = type.Assembly.GetName().Version;
            
            if (typeLibGuid != Guid.Empty) {
                key = clsidKey.CreateSubKey("TypeLib");
                key.SetValue("", "{" + typeLibGuid.ToString() + "}");
                key.Close();
                key = clsidKey.CreateSubKey("Version");
                key.SetValue("", assemblyVer.Major.ToString() + "." + assemblyVer.Minor.ToString());
                key.Close();
            }

            clsidKey.Close();
        }
        #endif

        /// <devdoc>
        ///     Helper method for retrieving an ActiveX property.  We abstract these
        ///     to another method so we do not force JIT the ActiveX codebase.
        /// </devdoc>
        private void ActiveXUpdateBounds(ref int x, ref int y, ref int width, ref int height, int flags) {
            ActiveXInstance.UpdateBounds(ref x, ref y, ref width, ref height, flags);
        }

        #if ACTIVEX_SOURCING
        
        //
        // This has been cut from the product.
        //
        
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ActiveXUnregister"]/*' />
        /// <devdoc>
        ///     This is called by regasm to un-register a control as an ActiveX control.
        /// </devdoc>
        [ComUnregisterFunction()]
        protected static void ActiveXUnregister(Type type) {

            if (type == null) {
                throw new ArgumentNullException("type");
            }

            // If the user is not unregistering an AX control, then
            // bail now.
            //
            if (!typeof(Control).IsAssignableFrom(type)) {
                return;
            }

            RegistryKey clsidKey = null;

            // Unregistration should be very robust and unregister what it can.  We eat all exceptions here.
            //
            try {
                clsidKey = Registry.ClassesRoot.OpenSubKey("CLSID", true).CreateSubKey("{" + type.GUID.ToString() + "}");

                try {
                    clsidKey.DeleteSubKeyTree("Control");
                }
                catch {
                }
                try {
                    clsidKey.DeleteSubKeyTree("Implemented Categories");
                }
                catch {
                }
                try {
                    clsidKey.DeleteSubKeyTree("MiscStatus");
                }
                catch {
                }
                try {
                    clsidKey.DeleteSubKeyTree("TypeLib");
                }
                catch {
                }
            }
            finally {
                if (clsidKey != null) {
                    clsidKey.Close();
                }
            }
        }
        #endif

        /// <devdoc>
        ///     Assigns a new parent control. Sends out the appropriate property change
        ///     notifications for properties that are affected by the change of parent.
        /// </devdoc>
        [UIPermission(SecurityAction.LinkDemand, Window=UIPermissionWindow.AllWindows)]
        [UIPermission(SecurityAction.InheritanceDemand, Window=UIPermissionWindow.AllWindows)]
        internal virtual void AssignParent(Control value) {
            if (CanAccessProperties) {
                // Store the old values for these properties
                //
                Font oldFont = Font;
                Color oldForeColor = ForeColor;
                Color oldBackColor = BackColor;
                RightToLeft oldRtl = RightToLeft;
                bool oldEnabled = Enabled;
                bool oldVisible = Visible;
                
                // Update the parent
                //
                parent = value;
                OnParentChanged(EventArgs.Empty);

                if (GetAnyDisposingInHierarchy()) {
                    return;
                }

                // Compare property values with new parent to old values
                //
                if (oldEnabled != Enabled) {
                    OnEnabledChanged(EventArgs.Empty);
                }
                if (oldVisible != Visible) {
                    OnVisibleChanged(EventArgs.Empty);
                }
                if (!oldFont.Equals(Font)) {
                    OnFontChanged(EventArgs.Empty);
                }
                if (!oldForeColor.Equals(ForeColor)) {
                    OnForeColorChanged(EventArgs.Empty);
                }
                if (!oldBackColor.Equals(BackColor)) {
                    OnBackColorChanged(EventArgs.Empty);
                }
                if (oldRtl != RightToLeft) {
                    OnRightToLeftChanged(EventArgs.Empty);
                }
                if (Properties.GetObject(PropBindingManager) == null && this.Created) {
                    // We do not want to call our parent's BindingContext property here.
                    // We have no idea if us or any of our children are using data binding,
                    // and invoking the property would just create the binding manager, which
                    // we don't need.  We just blindly notify that the binding manager has
                    // changed, and if anyone cares, they will do the comparison at that time.
                    //
                    OnBindingContextChanged(EventArgs.Empty);
                }
            }
            else {
                parent = value;
                OnParentChanged(EventArgs.Empty);
            }

            SetState(STATE_CHECKEDHOST, false);

            LayoutInfo layout = (LayoutInfo)Properties.GetObject(PropLayoutInfo);
            if (layout != null && !layout.IsDock) LayoutManager.UpdateAnchorInfo(this);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ParentChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.ControlOnParentChangedDescr)]
        public event EventHandler ParentChanged {
            add {
                Events.AddHandler(EventParent, value);
            }
            remove {
                Events.RemoveHandler(EventParent, value);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.BeginInvoke"]/*' />
        /// <devdoc>
        ///     Executes the given delegate on the thread that owns this Control's
        ///     underlying window handle.  The delegate is called asynchronously and this
        ///     method returns immediately.  You may call this from any thread, even the
        ///     thread that owns the control's handle.  If the control's handle doesn't
        ///     exist yet, this will follow up the control's parent chain until it finds a
        ///     control or form that does have a window handle.  If no appropriate handle
        ///     can be found, BeginInvoke will throw an exception.  Exceptions within the
        ///     delegate method are considered untrapped and will be sent to the
        ///     application's untrapped exception handler.
        ///
        ///     There are five functions on a control that are safe to call from any
        ///     thread:  GetInvokeRequired, Invoke, BeginInvoke, EndInvoke and CreateGraphics.  
        ///     For all other metohd calls, you should use one of the invoke methods to marshal
        ///     the call to the control's thread.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        public IAsyncResult BeginInvoke(Delegate method) {
            return BeginInvoke(method, null);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.BeginInvoke1"]/*' />
        /// <devdoc>
        ///     Executes the given delegate on the thread that owns this Control's
        ///     underlying window handle.  The delegate is called asynchronously and this
        ///     method returns immediately.  You may call this from any thread, even the
        ///     thread that owns the control's handle.  If the control's handle doesn't
        ///     exist yet, this will follow up the control's parent chain until it finds a
        ///     control or form that does have a window handle.  If no appropriate handle
        ///     can be found, BeginInvoke will throw an exception.  Exceptions within the
        ///     delegate method are considered untrapped and will be sent to the
        ///     application's untrapped exception handler.
        ///
        ///     There are five functions on a control that are safe to call from any
        ///     thread:  GetInvokeRequired, Invoke, BeginInvoke, EndInvoke and CreateGraphics.  
        ///     For all other metohd calls, you should use one of the invoke methods to marshal
        ///     the call to the control's thread.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        public IAsyncResult BeginInvoke(Delegate method, Object[] args) {
            Control marshaler = FindMarshalingControl();
            return(IAsyncResult)marshaler.MarshaledInvoke(this, method, args, false);
        }           

        internal void BeginUpdateInternal() {
            if (!IsHandleCreated) {
                return;
            }
            if (updateCount == 0) SendMessage(NativeMethods.WM_SETREDRAW, 0, 0);
            updateCount++;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.BringToFront"]/*' />
        /// <devdoc>
        ///     Brings this control to the front of the zorder.
        /// </devdoc>
        public void BringToFront() {
            if (parent != null) {
                parent.Controls.SetChildIndex(this, 0);
            }
            else if (window.Handle != IntPtr.Zero && GetTopLevel() && SafeNativeMethods.IsWindowEnabled(new HandleRef(window, window.Handle))) {
                SafeNativeMethods.SetWindowPos(new HandleRef(window, window.Handle), NativeMethods.HWND_TOP, 0, 0, 0, 0,
                                               NativeMethods.SWP_NOMOVE | NativeMethods.SWP_NOSIZE);
            }
        }

        internal bool CanProcessMnemonic() {
            for (Control ctl = this; ctl != null; ctl = ctl.parent) {

                if (!ctl.Enabled || !ctl.Visible) {
                    return false;
                }
            }
            return true;
        }

        // Package scope to allow AxHost to override
        //
        internal virtual bool CanSelectCore() {
            if ((controlStyle & ControlStyles.Selectable) != ControlStyles.Selectable) {
                return false;
            }

            return CanProcessMnemonic();
        }
        
        /// <devdoc>
        ///     Searches the parent/owner tree for bottom to find any instance
        ///     of toFind in the parent/owner tree.
        /// </devdoc>
        internal static void CheckParentingCycle(Control bottom, Control toFind) {
            Form lastOwner = null;
            Control lastParent = null;

            for (Control ctl = bottom; ctl != null; ctl = ctl.ParentInternal) {
                lastParent = ctl;
                if (ctl == toFind) {
                    throw new ArgumentException(SR.GetString(SR.CircularOwner));
                }
            }

            if (lastParent != null) {
                if (lastParent is Form) {
                    Form f = (Form)lastParent;
                    for (Form form = f; form != null; form = form.OwnerInternal) {
                        lastOwner = form;
                        if (form == toFind) {
                            throw new ArgumentException(SR.GetString(SR.CircularOwner));
                        }
                    }
                }
            }

            if (lastOwner != null) {
                if (lastOwner.ParentInternal != null) {
                    CheckParentingCycle(lastOwner.ParentInternal, toFind);
                }
            }
        }
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        internal void ChildGotFocus(Control child) {
            if (IsActiveX) {
                ActiveXOnFocus(true);
            }
            if (parent != null) {
                parent.ChildGotFocus(child);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Contains"]/*' />
        /// <devdoc>
        ///    <para>Verifies if a control is a child of this control.</para>
        /// </devdoc>
        public bool Contains(Control ctl) {
            while (ctl != null) {
                ctl = ctl.ParentInternal;
                if (ctl == null) {
                    return false;
                }
                if (ctl == this) {
                    return true;
                }
            }
            return false;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.CreateAccessibilityInstance"]/*' />
        /// <devdoc>
        ///     constructs the new instance of the accessibility object for this control. Subclasses
        ///     should not call base.CreateAccessibilityObject.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual AccessibleObject CreateAccessibilityInstance() {
            return new ControlAccessibleObject(this);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.CreateControlsInstance"]/*' />
        /// <devdoc>
        ///     Constructs the new instance of the Controls collection objects. Subclasses
        ///     should not call base.CreateControlsInstance.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual ControlCollection CreateControlsInstance() {
            return new System.Windows.Forms.Control.ControlCollection(this);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.CreateGraphics"]/*' />
        /// <devdoc>
        ///     Creates a Graphics for this control. The control's brush, font, foreground
        ///     color and background color become the default values for the Graphics.
        ///     The returned Graphics must be disposed through a call to its dispose()
        ///     method when it is no longer needed.  The Graphics Object is only valid for
        ///     the duration of the current window's message.
        /// </devdoc>
        public System.Drawing.Graphics CreateGraphics() {
            Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "CreateGraphicsForControl Demanded");
            IntSecurity.CreateGraphicsForControl.Demand();
            return CreateGraphicsInternal();
        }

        internal System.Drawing.Graphics CreateGraphicsInternal() {
            return Graphics.FromHwndInternal(this.Handle);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.CreateHandle"]/*' />
        /// <devdoc>
        ///     Creates a handle for this control. This method is called by the .NET Framework, this should
        ///     not be called. Inheriting classes should always call base.createHandle when
        ///     overriding this method.
        /// </devdoc>
        [
        EditorBrowsable(EditorBrowsableState.Advanced),
        UIPermission(SecurityAction.InheritanceDemand, Window=UIPermissionWindow.AllWindows)
        ]
        protected virtual void CreateHandle() {

            if (GetState(STATE_DISPOSED)) {
                throw new System.ObjectDisposedException(GetType().Name);
            }
            Debug.Assert(GetState(STATE_CREATINGHANDLE) == false, "circular CreateHandle calls -- that can't be good");
            SetState(STATE_CREATINGHANDLE, true);

            try {
                CreateParams cp = CreateParams;

                // Adjust for scrolling of parent...
                //
                if (parent != null) {
                    Rectangle parentClient = parent.ClientRectangle;

                    if (!parentClient.IsEmpty) {
                        if (cp.X != NativeMethods.CW_USEDEFAULT) {
                            cp.X -= parentClient.X;
                        }
                        if (cp.Y != NativeMethods.CW_USEDEFAULT) {
                            cp.Y -= parentClient.Y;
                        }
                    }
                }

                // And if we are WS_CHILD, ensure we have a parent handle.
                //
                if (cp.Parent == IntPtr.Zero && (cp.Style & NativeMethods.WS_CHILD) != 0) {
                    Debug.Assert((cp.ExStyle & NativeMethods.WS_EX_MDICHILD) == 0, "Can't put MDI child forms on the parking form");
                    cp.Parent = Application.GetParkingWindow(this).Handle;
                }

                window.CreateHandle(cp);
            }
            finally {
                SetState(STATE_CREATINGHANDLE, false);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.CreateControl"]/*' />
        /// <devdoc>
        ///     Forces the creation of the control. This includes the creation of the handle,
        ///     and any child controls.
        /// </devdoc>
        public void CreateControl() {
            CreateControl(false);

            if (Properties.GetObject(PropBindingManager) == null && ParentInternal != null) {
                // We do not want to call our parent's BindingContext property here.
                // We have no idea if us or any of our children are using data binding,
                // and invoking the property would just create the binding manager, which
                // we don't need.  We just blindly notify that the binding manager has
                // changed, and if anyone cares, they will do the comparison at that time.
                //
                OnBindingContextChanged(EventArgs.Empty);
            }
        }

        /// <devdoc>
        ///     Forces the creation of the control. This includes the creation of the handle,
        ///     and any child controls.
        /// <param name='fIgnoreVisible'>
        ///     Determines whether we should create the handle after checking the Visible
        ///     property of the control or not.
        /// </param>
        /// </devdoc>
        internal void CreateControl(bool fIgnoreVisible) {
            bool ready = (state & STATE_CREATED) == 0;

            // PERF: Only "create" the control if it is
            //     : visible. This has the effect of delayed handle creation of
            //     : hidden controls.
            //
            ready = ready && Visible;

            if (ready || fIgnoreVisible) {
                state |= STATE_CREATED;
                bool createdOK = false;
                try {
                    if (window.Handle == IntPtr.Zero) CreateHandle();

                    // 58041 - must snapshot this array because
                    // z-order updates from Windows may rearrange it!
                    //
                    ControlCollection controlsCollection = (ControlCollection)Properties.GetObject(PropControlsCollection);
                    
                    if (controlsCollection != null) {
                        Control[] controlSnapshot = new Control[controlsCollection.Count];
                        controlsCollection.CopyTo(controlSnapshot, 0);
                        
                        foreach(Control ctl in controlSnapshot) {
                            if (ctl.IsHandleCreated) {
                                ctl.SetParentHandle(window.Handle);
                            }
                            ctl.CreateControl(fIgnoreVisible);
                        }
                    }
                    
                    createdOK = true;
                }
                finally {
                    // unlike try/catch, we don't lose stack trace information
                    if (!createdOK)
                        state &= (~STATE_CREATED);
                }
                OnCreateControl();
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.DefWndProc"]/*' />
        /// <devdoc>
        ///     Sends the message to the default window proc.
        /// </devdoc>
        /* Primarily here for Form to override */
        [
            SecurityPermission(SecurityAction.InheritanceDemand, Flags=SecurityPermissionFlag.UnmanagedCode),
            SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode),
            EditorBrowsable(EditorBrowsableState.Advanced)
        ]
        protected virtual void DefWndProc(ref Message m) {
            window.DefWndProc(ref m);
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.DestroyHandle"]/*' />
        /// <devdoc>
        ///     Destroys the handle associated with this control. Inheriting classes should
        ///     always call base.destroyHandle.
        /// </devdoc>
        [
            SecurityPermission(SecurityAction.InheritanceDemand, Flags=SecurityPermissionFlag.UnmanagedCode),
            UIPermission(SecurityAction.LinkDemand, Window=UIPermissionWindow.AllWindows),
            EditorBrowsable(EditorBrowsableState.Advanced)
        ]
        protected virtual void DestroyHandle() {

            if (RecreatingHandle) {
                Queue threadCallbackList = (Queue)Properties.GetObject(PropThreadCallbackList);
                
                if (threadCallbackList != null) {
                    // See if we have a thread marshaling request pending.  If so, we will need to
                    // re-post it after recreating the handle.
                    //
                    lock (threadCallbackList) {
                        if (threadCallbackMessage != 0) {
                            NativeMethods.MSG msg = new NativeMethods.MSG();
                            if (UnsafeNativeMethods.PeekMessage(ref msg, new HandleRef(this, Handle), threadCallbackMessage,
                                                          threadCallbackMessage, NativeMethods.PM_NOREMOVE)) {
    
                                SetState(STATE_THREADMARSHALLPENDING, true);
                            }
                        }
                    }
                }
            }

            // If we're not recreating the handle, then any items in the thread callback list will
            // be orphaned.  An orphaned item is bad, because it will cause the thread to never
            // wake up.  So, we put exceptions into all these items and wake up all threads.
            // If we are recreating the handle, then we're fine because recreation will re-post
            // the thread callback message to the new handle for us.
            //
            if (!RecreatingHandle) {
                Queue threadCallbackList = (Queue)Properties.GetObject(PropThreadCallbackList);
                if (threadCallbackList != null) {
                    lock (threadCallbackList) {
                        Exception ex = new System.ObjectDisposedException(GetType().Name);
                    
                        while (threadCallbackList.Count > 0) {
                            ThreadMethodEntry entry = (ThreadMethodEntry)threadCallbackList.Dequeue();
                            entry.exception = ex;
                            entry.Complete();
                        }
                    }
                }
            }
            
            if (0 != (NativeMethods.WS_EX_MDICHILD & (int)UnsafeNativeMethods.GetWindowLong(new HandleRef(window, window.Handle), NativeMethods.GWL_EXSTYLE))) {
                UnsafeNativeMethods.DefMDIChildProc(window.Handle, NativeMethods.WM_CLOSE, IntPtr.Zero, IntPtr.Zero);
            }
            else {
                window.DestroyHandle();
            }

            trackMouseEvent = null;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Dispose"]/*' />
        /// <devdoc>
        ///    <para>Disposes of the resources (other than memory) used by the 
        ///    <see cref='System.Windows.Forms.Control'/> 
        ///    .</para>
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (GetState(STATE_OWNCTLBRUSH)) {
                object backBrush = Properties.GetObject(PropBackBrush);
                if (backBrush != null) {
                    IntPtr p = (IntPtr)backBrush;
                    if (p != IntPtr.Zero) {
                        SafeNativeMethods.DeleteObject(new HandleRef(this, p));
                    }
                    Properties.SetObject(PropBackBrush, null);
                }
            }
            
            if (disposing) {
                if (GetState(STATE_DISPOSING)) {
                    return;
                }

                if (GetState(STATE_CREATINGHANDLE)) {
                    throw new InvalidOperationException(SR.GetString(SR.ClosingWhileCreatingHandle, "Dispose"));
                    // I imagine most subclasses will get themselves in a half disposed state
                    // if this exception is thrown, but things will be equally screwed up if we ignore this error,
                    // and this way at least the user knows what they did wrong.
                }

                SetState(STATE_DISPOSING, true);

                try {
                    DisposeAxControls();

                    ContextMenu contextMenu = (ContextMenu)Properties.GetObject(PropContextMenu);
                    if (contextMenu != null) {
                        contextMenu.Disposed -= new EventHandler(DetachContextMenu);                        
                    }

                    if (window.Handle != IntPtr.Zero) DestroyHandle();
                    if (parent != null) parent.Controls.Remove(this);

                    ControlCollection controlsCollection = (ControlCollection)Properties.GetObject(PropControlsCollection);

                    if (controlsCollection != null) {
                    
                        // PERFNOTE: This is more efficient than using Foreach.  Foreach 
                        // forces the creation of an array subset enum each time we
                        // enumerate
                        for(int i = 0; i < controlsCollection.Count; i++) {
                            Control ctl = controlsCollection[i];
                            ctl.parent = null;
                            ctl.Dispose();
                        }
                        Properties.SetObject(PropControlsCollection, null);
                    }

                    base.Dispose(disposing);
                }
                finally {
                    SetState(STATE_DISPOSING, false);
                    SetState(STATE_DISPOSED, true);
                }
            }
            else {

#if FINALIZATION_WATCH
                if (!GetState(STATE_DISPOSED)) {
                    Debug.Fail("Control of type '" + GetType().FullName +"' is being finalized that wasn't disposed\n" + allocationSite);
                }
#endif
                // This same post is done in ControlNativeWindow's finalize method, so if you change
                // it, change it there too.
                //
                if (window != null && window.Handle != IntPtr.Zero) {
                    UnsafeNativeMethods.PostMessage(new HandleRef(window, window.Handle), NativeMethods.WM_CLOSE, 0, 0);
                    window.ReleaseHandle();
                }
                base.Dispose(disposing);
            }
        }

        // Package scope to allow AxHost to override.
        //
        internal virtual void DisposeAxControls() {
            ControlCollection controlsCollection = (ControlCollection)Properties.GetObject(PropControlsCollection);
            
            if (controlsCollection != null) {
                // PERFNOTE: This is more efficient than using Foreach.  Foreach 
                // forces the creation of an array subset enum each time we
                // enumerate
                for(int i = 0; i < controlsCollection.Count; i++) {
                    controlsCollection[i].DisposeAxControls();
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.DoDragDrop"]/*' />
        /// <devdoc>
        ///     Begins a drag operation. The allowedEffects determine which
        ///     drag operations can occur. If the drag operation needs to interop
        ///     with applications in another process, data should either be
        ///     a base managed class (String, Bitmap, or Metafile) or some Object
        ///     that implements System.Runtime.Serialization.ISerializable. data can also be any Object that
        ///     implements System.Windows.Forms.IDataObject.
        /// </devdoc>
        public DragDropEffects DoDragDrop(Object data, DragDropEffects allowedEffects) {
            int[] finalEffect = new int[] {(int)DragDropEffects.None};
            UnsafeNativeMethods.IOleDropSource dropSource = new DropSource( this );
            UnsafeNativeMethods.IOleDataObject dataObject = null;

            if (data is UnsafeNativeMethods.IOleDataObject) {
                dataObject = (UnsafeNativeMethods.IOleDataObject)data;
            }
            else {

                DataObject iwdata = null;
                if (data is IDataObject) {
                    iwdata = new DataObject((IDataObject)data);
                }
                else {
                    iwdata = new DataObject();
                    iwdata.SetData(data);
                }
                dataObject = (UnsafeNativeMethods.IOleDataObject)iwdata;
            }

            try {
                SafeNativeMethods.DoDragDrop(dataObject, dropSource, (int)allowedEffects, finalEffect);
            }
            catch (Exception) {
            }
            return(DragDropEffects)finalEffect[0];
        }
        
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.EndInvoke"]/*' />
        /// <devdoc>
        ///     Retrieves the return value of the asynchronous operation
        ///     represented by the IAsyncResult interface passed. If the
        ///     async operation has not been completed, this function will
        ///     block until the result is available. 
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        public Object EndInvoke(IAsyncResult asyncResult) {
            if (asyncResult == null)
                throw new ArgumentNullException("asyncResult");

            if (!(asyncResult is ThreadMethodEntry))
                throw new ArgumentException("asyncResult");

            ThreadMethodEntry entry = (ThreadMethodEntry)asyncResult;                
            Debug.Assert(this == entry.caller, "Called BeginInvoke on one control, and the corresponding EndInvoke on a different control");

            if (!asyncResult.IsCompleted) {
                int pid; // ignored
                Control marshaler = FindMarshalingControl();
                if (SafeNativeMethods.GetWindowThreadProcessId(new HandleRef(marshaler, marshaler.Handle), out pid) == SafeNativeMethods.GetCurrentThreadId())
                    marshaler.InvokeMarshaledCallbacks();
                else
                    asyncResult.AsyncWaitHandle.WaitOne();
            }

            Debug.Assert(asyncResult.IsCompleted, "Why isn't this asyncResult done yet?");
            if (entry.exception != null)
                throw entry.exception;

            return entry.retVal;                                               
        }
        
        internal bool EndUpdateInternal() {
            return EndUpdateInternal(true);
        }
        
        internal bool EndUpdateInternal(bool invalidate) {
            if (updateCount > 0) {
                Debug.Assert(IsHandleCreated, "Handle should be created by now");
                updateCount--;
                if (updateCount == 0) {
                    SendMessage(NativeMethods.WM_SETREDRAW, -1, 0);
                    if (invalidate) {
                        Invalidate();
                    }
                }
                return true;
            }
            else {
                return false;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.FindForm"]/*' />
        /// <devdoc>
        ///     Retrieves the form that this control is on. The control's parent
        ///     may not be the same as the form.
        /// </devdoc>
        [UIPermission(SecurityAction.Demand, Window=UIPermissionWindow.AllWindows)]
        public Form FindForm() {
            return FindFormInternal();
        }

        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        internal Form FindFormInternal() {
            Control cur = this;
            while (cur != null && !(cur is Form) ) {
                cur = cur.ParentInternal;
            }
            return (Form)cur;
        }

        /// <devdoc>
        ///     Attempts to find a control Object that we can use to marshal
        ///     calls.  We must marshal calls to a control with a window
        ///     handle, so we traverse up the parent chain until we find one.
        ///     Failing that, we just return ouselves.
        /// </devdoc>
        /// <internalonly/>
        private Control FindMarshalingControl() {
            lock(this) {
                Control c = this;

                while (c != null && !c.IsHandleCreated) {
                    Control p = c.ParentInternal;
                    c = p;
                }

                if (c != null) {
                    Debug.Assert(c.IsHandleCreated, "FindMarshalingControl chose a bad control.");

                    // If we found a control with a handle, then
                    // use it's parking control.  Parking controls have
                    // the advantage that their handles are not
                    // recreated, so this simplifies our lives a bit.
                    //
                    Control parkingWindow = Application.GetParkingWindow(c);
                    if (parkingWindow != null && parkingWindow.IsHandleCreated) {
                        c = parkingWindow;
                    }
                }

                if (c == null) {
                    // No control with a created handle.  We
                    // just use our own control.  MarshaledInvoke
                    // will throw an exception because there
                    // is no handle.
                    //
                    c = this;
                }

                return(Control)c;
            }
        }
        
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.GetTopLevel"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected bool GetTopLevel() {
            return(state & STATE_TOPLEVEL) != 0;
        }

        /// <devdoc>
        ///     Used by AxHost to fire the CreateHandle event.
        /// </devdoc>
        /// <internalonly/>
        internal void RaiseCreateHandleEvent(EventArgs e) {
            EventHandler handler = (EventHandler)Events[EventHandleCreated];
            if (handler != null) handler(this, e);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.RaiseKeyEvent"]/*' />
        /// <devdoc>
        ///     Raises the event associated with key with the event data of
        ///     e and a sender of this control.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected void RaiseKeyEvent(object key, KeyEventArgs e) {
            KeyEventHandler handler = (KeyEventHandler)Events[key];
            if (handler != null) handler(this, e);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.RaiseMouseEvent"]/*' />
        /// <devdoc>
        ///     Raises the event associated with key with the event data of
        ///     e and a sender of this control.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected void RaiseMouseEvent(object key, MouseEventArgs e) {
            MouseEventHandler handler = (MouseEventHandler)Events[key];
            if (handler != null) handler(this, e);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Focus"]/*' />
        /// <devdoc>
        ///    <para> Sets focus to the control.</para>
        ///    <para>Attempts to set focus to this control.</para>
        /// </devdoc>
        public bool Focus() {
            Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "ModifyFocus Demanded");
            IntSecurity.ModifyFocus.Demand();

            //here, we call our internal method (which form overrides)
            //see comments in FocusInternal
            //
            return FocusInternal();
        }

        /// <devdoc>
        ///    Internal method for setting focus to the control.
        ///    Form overrides this method - because MDI child forms
        ///    need to be focused by calling the MDIACTIVATE message.
        /// </devdoc>
        internal virtual bool FocusInternal() {
            if (CanFocus) UnsafeNativeMethods.SetFocus(new HandleRef(this, Handle));
            if (Focused && this.ParentInternal != null) {
                IContainerControl c = this.ParentInternal.GetContainerControlInternal();

                if (c != null) {
                    if (c is ContainerControl) {
                        ((ContainerControl)c).SetActiveControlInternal(this);
					}
                    else {
                        c.ActiveControl = this;
                    }
                }
            }


            return Focused;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.FromChildHandle"]/*' />
        /// <devdoc>
        ///     Returns the control that is currently associated with handle.
        ///     This method will search up the HWND parent chain until it finds some
        ///     handle that is associated with with a control. This method is more
        ///     robust that fromHandle because it will correctly return controls
        ///     that own more than one handle.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        public static Control FromChildHandle(IntPtr handle) {
            Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "ControlFromHandleOrLocation Demanded");
            IntSecurity.ControlFromHandleOrLocation.Demand();
            return FromChildHandleInternal(handle);
        }

        // FromChildHandle without the security check.  This makes a noticeable difference 
        // for FromHandle, but to be honest I never profiled this method.
        internal static Control FromChildHandleInternal(IntPtr handle) {
            while (handle != IntPtr.Zero) {
                Control ctl = FromHandleInternal(handle);
                if (ctl != null) return ctl;
                handle = UnsafeNativeMethods.GetParent(new HandleRef(null, handle));
            }
            return null;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.FromHandle"]/*' />
        /// <devdoc>
        ///     Returns the control that is currently associated with handle.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        public static Control FromHandle(IntPtr handle) {
            Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "ControlFromHandleOrLocation Demanded");
            IntSecurity.ControlFromHandleOrLocation.Demand();
            return FromHandleInternal(handle);
        }

        // FromHandle without the security check, which adds about 1% to our running time, also avoiods the
        // check for things in this assembly
        internal static Control FromHandleInternal(IntPtr handle) {
            NativeWindow w = NativeWindow.FromHandle(handle);
            while (w != null && !(w is ControlNativeWindow)) {
                w = w.PreviousWindow;
            }

            if (w is ControlNativeWindow) {
                return((ControlNativeWindow)w).GetControl();
            }
            return null;
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.GetChildAtPoint"]/*' />
        /// <devdoc>
        ///     Retrieves the child control that is located at the specified client
        ///     coordinates.
        /// </devdoc>
        public Control GetChildAtPoint(Point pt) {
            IntPtr hwnd = UnsafeNativeMethods.ChildWindowFromPoint(new HandleRef(this, Handle), pt.X, pt.Y);
            Control ctl = FromChildHandle(hwnd);
            if (!IsDescendant(ctl)) {
                Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "ControlFromHandleOrLocation Demanded");
                IntSecurity.ControlFromHandleOrLocation.Demand();
            }

            return(ctl == this) ? null : ctl;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.GetContainerControl"]/*' />
        /// <devdoc>
        ///     Returns the closest ContainerControl in the control's chain of
        ///     parent controls and forms.
        /// </devdoc>
        public IContainerControl GetContainerControl() {
            Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "GetParent Demanded");
            IntSecurity.GetParent.Demand();
            return GetContainerControlInternal();
        }

        internal static bool IsFocusManagingContainerControl(Control ctl) {
            return ((ctl.controlStyle & ControlStyles.ContainerControl) == ControlStyles.ContainerControl && ctl is IContainerControl);
        }

        internal IContainerControl GetContainerControlInternal() {
            Control c = this;
            while (c != null && (!IsFocusManagingContainerControl(c))) {
                c = c.ParentInternal;
            }
            return (IContainerControl)c;
        }

        // Essentially an Hfont; see inner class for details.
        private static FontHandleWrapper GetDefaultFontHandleWrapper() {
            if (defaultFontHandleWrapper == null) {
                defaultFontHandleWrapper = new FontHandleWrapper(DefaultFont);
            }

            return defaultFontHandleWrapper;
        }

        internal IntPtr GetHRgn(Region region) {
            Graphics graphics = CreateGraphicsInternal();
            IntPtr handle = region.GetHrgn(graphics);
            graphics.Dispose();
            return handle;
        }

        private MouseButtons GetXButton(int wparam) {
            switch (wparam) {
            case NativeMethods.XBUTTON1:
                return MouseButtons.XButton1;
            case NativeMethods.XBUTTON2:
                return MouseButtons.XButton2;
            }
            Debug.Fail("Unknown XButton: " + wparam);
            return MouseButtons.None;
        }
        
        internal virtual bool GetVisibleCore() {
            // We are only visible if our parent is visible
            if (!GetState(STATE_VISIBLE))
                return false;
            else if (ParentInternal == null)
                return true;
            else
                return ParentInternal.GetVisibleCore();
        }
        
        // Disable the IME
        //
        private static void IMEDisable(IntPtr handle) {

            // Close the IME if necessary
            //
            if (IMEIsOpen(handle)) {
                IMESetOpenStatus(false, handle);              
            }

            // Disable the IME
            //
            Debug.WriteLineIf(CompModSwitches.ImeMode.TraceInfo, "ImmAssociateContext(" + handle.ToString() + ", null)");
            
            IntPtr oldContext = UnsafeNativeMethods.ImmAssociateContext(new HandleRef(null, handle), NativeMethods.NullHandleRef);
            if (oldContext != IntPtr.Zero) {
                defaultImeContext = oldContext;
            }
        }

        // Enable the IME
        //
        private static void IMEEnable(IntPtr handle) {
        
            Debug.WriteLineIf(CompModSwitches.ImeMode.TraceInfo, "ImmGetContext(" + handle.ToString() + ")");
            
            IntPtr inputContext = UnsafeNativeMethods.ImmGetContext(new HandleRef(null, handle));
            
            Debug.WriteLineIf(CompModSwitches.ImeMode.TraceInfo, "context = " + inputContext.ToString());
            
            if (inputContext == IntPtr.Zero) {
            
                if (defaultImeContext == IntPtr.Zero) {
            
                    Debug.WriteLineIf(CompModSwitches.ImeMode.TraceInfo, "ImmCreateContext()");
                    inputContext = UnsafeNativeMethods.ImmCreateContext();
                    if (inputContext != IntPtr.Zero) {
                        Debug.WriteLineIf(CompModSwitches.ImeMode.TraceInfo, "ImmAssociateContext(" + handle.ToString() + ", " + inputContext.ToString() + ")");
                        UnsafeNativeMethods.ImmAssociateContext(new HandleRef(null, handle), new HandleRef(null, inputContext));
                    }
                }
                else {
                    UnsafeNativeMethods.ImmAssociateContext(new HandleRef(null, handle), new HandleRef(null, defaultImeContext));
                }                
            }
            else {
                Debug.WriteLineIf(CompModSwitches.ImeMode.TraceInfo, "ImmReleaseContext(" + handle.ToString() + ", " + inputContext.ToString() + ")");
                UnsafeNativeMethods.ImmReleaseContext(new HandleRef(null, handle), new HandleRef(null, inputContext));
            }
        }
        
        internal void ImeSetFocus() {
            if (!DesignMode) {
                ImeMode currentImeContextMode = CurrentImeContextMode;
                if (currentImeContextMode != ImeMode.Inherit) {
                    Debug.WriteLineIf(CompModSwitches.ImeMode.TraceInfo, "Saving previous IME mode: " + currentImeContextMode.ToString() + ", this = " + this.GetType().ToString());
                    Properties.SetInteger(PropPreviousImeMode, (int)currentImeContextMode);
                    if (CachedImeMode != ImeMode.NoControl) {
                        CurrentImeContextMode = CachedImeMode;
                    }
                }
            }
        }

        // Returns true if the IME is currently open
        //                   
        private static bool IMEIsOpen(IntPtr handle) {

            Debug.WriteLineIf(CompModSwitches.ImeMode.TraceInfo, "ImmGetContext(" + handle.ToString() + ")");
            IntPtr inputContext = UnsafeNativeMethods.ImmGetContext(new HandleRef(null, handle));
            Debug.WriteLineIf(CompModSwitches.ImeMode.TraceInfo, "context = " + inputContext.ToString());

            if (inputContext != IntPtr.Zero) {
                Debug.WriteLineIf(CompModSwitches.ImeMode.TraceInfo, "ImmGetOpenStatus(" + inputContext.ToString() + ")");
                bool retval = UnsafeNativeMethods.ImmGetOpenStatus(new HandleRef(null, inputContext));
                Debug.WriteLineIf(CompModSwitches.ImeMode.TraceInfo, "ImmReleaseContext(" + handle.ToString() + ", " + inputContext.ToString() + ")");
                UnsafeNativeMethods.ImmReleaseContext(new HandleRef(null, handle), new HandleRef(null, inputContext));
                return retval;
            }
            else {
                return false;
            }
        }
        
        private static ImeMode[] IMECountryTable() {
            InputLanguage inputLanguage = InputLanguage.CurrentInputLanguage;
            int lcid = (int)inputLanguage.Handle & 0xFFFF;
            switch (lcid) {
                case 0x0404:    // Chinese (Taiwan)
                case 0x0804:    // Chinese (PRC)
                case 0x0c04:    // Chinese (Hong Kong SAR, PRC)
                case 0x1004:    // Chinese (Singapore)
                case 0x1404:    // Chinese (Macau SAR)
                    return chineseTable;

                case 0x0412:    // Korean
                case 0x0812:    // Korean (Johab)
                    return koreanTable; 

                case 0x0411:    // Japanese
                    return japaneseTable;
            }
            
            return null;
        }

        internal static ImeMode GetImeModeFromIMEContext(IntPtr handle) {

            // Get the right table for the current keyboard layout
            //
            ImeMode[] countryTable = IMECountryTable();
            
            if (countryTable == null) {
                return ImeMode.Inherit;
            }

            ImeMode retval = ImeMode.NoControl;

            Debug.WriteLineIf(CompModSwitches.ImeMode.TraceInfo, "ImmGetContext(" + handle.ToString() + ")");
            IntPtr inputContext = UnsafeNativeMethods.ImmGetContext(new HandleRef(null, handle));
            Debug.WriteLineIf(CompModSwitches.ImeMode.TraceInfo, "context = " + inputContext.ToString());
            
            if (inputContext == IntPtr.Zero) {
                return countryTable[ImeDisabled];
            }
            if (!IMEIsOpen(handle)) {
                retval = countryTable[ImeClosed];
                goto cleanup;
            }


            // Determine the IME mode from the conversion status
            //

            int conversion = 0;     // Combination of conversion mode values                                                                         
            int sentence = 0;       // Sentence mode value

            Debug.WriteLineIf(CompModSwitches.ImeMode.TraceInfo, "ImmGetConversionStatus(" + inputContext.ToString() + ", conversion, sentence)");
            UnsafeNativeMethods.ImmGetConversionStatus(new HandleRef(null, inputContext), ref conversion, ref sentence);                                                  

            Debug.Assert(countryTable != null, "countryTable is null");

            if ((conversion & NativeMethods.IME_CMODE_NATIVE) != 0) {
                if ((conversion & NativeMethods.IME_CMODE_KATAKANA) != 0) {
                    retval = ((conversion & NativeMethods.IME_CMODE_FULLSHAPE) != 0)
                             ? countryTable[ImeNativeFullKatakana] 
                             : countryTable[ImeNativeHalfKatakana];
                    goto cleanup;
                }
                else { // ! Katakana
                    retval = ((conversion & NativeMethods.IME_CMODE_FULLSHAPE) != 0)
                             ? countryTable[ImeNativeFullHiragana] 
                             : countryTable[ImeNativeHalfHiragana];
                    goto cleanup;
                }
            }
            else { // ! IME_CMODE_NATIVE
                retval = ((conversion & NativeMethods.IME_CMODE_FULLSHAPE) != 0)
                         ? countryTable[ImeAlphaFull] 
                         : countryTable[ImeAlphaHalf];
            }

            cleanup:
            Debug.WriteLineIf(CompModSwitches.ImeMode.TraceInfo, "ImmReleaseContext(" + handle.ToString() + ", " + inputContext.ToString() + ")");
            UnsafeNativeMethods.ImmReleaseContext(new HandleRef(null, handle), new HandleRef(null, inputContext));    

            return retval;
        }

        internal static void SetImeModeToIMEContext(ImeMode imeMode, IntPtr handle) {
        
            Debug.WriteLineIf(CompModSwitches.ImeMode.TraceInfo, "Inside SetImeModeToIMEContext(" + imeMode.ToString() + "), handle = " + handle.ToString());

            Debug.Assert(imeMode != ImeMode.Inherit, "ImeMode.Inherit is an invalid argument to SetImeModeToIMEContext");
            if (imeMode == ImeMode.Inherit || imeMode == ImeMode.NoControl) {
                return;     // No action required
            }
            
            if (IMECountryTable() == null) {
                return;     // We only support Japanese, Korean and Chinese IME.
            }
            
            int conversion = 0;     // Combination of conversion mode values                                                                         
            int sentence = 0;       // Sentence mode value
            
            Debug.WriteLineIf(CompModSwitches.ImeMode.TraceInfo, "\tSetting IME mode to " + imeMode.ToString());

            if (imeMode == ImeMode.Disable) {
                IMEDisable(handle);
            }
            else {
                IMEEnable(handle);
            }

            switch (imeMode) {
                case ImeMode.NoControl:
                case ImeMode.Disable:
                    break;     // No action required

                case ImeMode.On:
                    IMESetOpenStatus(true, handle);
                    break;
                case ImeMode.Off:
                    IMESetOpenStatus(false, handle);
                    break;

                default:
                    if (ImeModeConversionBits.Contains(imeMode)) {

                        // Update the conversion status
                        //
                        ImeModeConversion conversionEntry = (ImeModeConversion)ImeModeConversionBits[imeMode];                        

                        IMESetOpenStatus(true, handle);

                        Debug.WriteLineIf(CompModSwitches.ImeMode.TraceInfo, "ImmGetContext(" + handle.ToString() + ")");
                        IntPtr inputContext = UnsafeNativeMethods.ImmGetContext(new HandleRef(null, handle));
                        Debug.WriteLineIf(CompModSwitches.ImeMode.TraceInfo, "context = " + inputContext.ToString());
                        Debug.WriteLineIf(CompModSwitches.ImeMode.TraceInfo, "ImmGetConversionStatus(" + inputContext.ToString() + ", conversion, sentence)");
                        UnsafeNativeMethods.ImmGetConversionStatus(new HandleRef(null, inputContext), ref conversion, ref sentence);                                                  

                        conversion |= conversionEntry.setBits;
                        conversion &= ~conversionEntry.clearBits;                                                  

                        Debug.WriteLineIf(CompModSwitches.ImeMode.TraceInfo, "ImmSetConversionStatus(" + inputContext.ToString() + ", conversion, sentence)");
                        bool retval = UnsafeNativeMethods.ImmSetConversionStatus(new HandleRef(null, inputContext), conversion, sentence);
                        Debug.WriteLineIf(CompModSwitches.ImeMode.TraceInfo, "ImmReleaseContext(" + handle.ToString() + ", " + inputContext.ToString() + ")");
                        UnsafeNativeMethods.ImmReleaseContext(new HandleRef(null, handle), new HandleRef(null, inputContext));
                    }
                    break;
            }
        }

        private static void IMESetOpenStatus(bool open, IntPtr handle) {
            Debug.WriteLineIf(CompModSwitches.ImeMode.TraceInfo, "ImmGetContext(" + handle.ToString() + ")");
            IntPtr inputContext = UnsafeNativeMethods.ImmGetContext(new HandleRef(null, handle));
            Debug.WriteLineIf(CompModSwitches.ImeMode.TraceInfo, "context = " + inputContext.ToString());

            if (inputContext != IntPtr.Zero) {
                Debug.WriteLineIf(CompModSwitches.ImeMode.TraceInfo, "ImmSetOpenStatus(" + inputContext.ToString() + ", " + open.ToString() + ")");
                bool succeeded = UnsafeNativeMethods.ImmSetOpenStatus(new HandleRef(null, inputContext), open);
                if (!succeeded) {
                    throw new Win32Exception();
                }
                
                Debug.WriteLineIf(CompModSwitches.ImeMode.TraceInfo, "ImmReleaseContext(" + handle.ToString() + ", " + inputContext.ToString() + ")");
                succeeded = UnsafeNativeMethods.ImmReleaseContext(new HandleRef(null, handle), new HandleRef(null, inputContext));
                if (!succeeded) {
                    throw new Win32Exception();
                }
            }
        }

        internal bool GetAnyDisposingInHierarchy() {
            Control up = this;
            bool isDisposing = false;
            while (up != null) {
                if (up.Disposing) {
                    isDisposing = true;
                    break;
                }
                up = up.parent;
            }
            return isDisposing;
        }

        private MenuItem GetMenuItemFromHandleId(IntPtr hmenu, int item) {
            MenuItem mi = null;
            int id = UnsafeNativeMethods.GetMenuItemID(new HandleRef(null, hmenu), item);
            if (id == unchecked((int)0xFFFFFFFF)) {
                IntPtr childMenu = IntPtr.Zero;
                childMenu = UnsafeNativeMethods.GetSubMenu(new HandleRef(null, hmenu), item);
                int count = UnsafeNativeMethods.GetMenuItemCount(new HandleRef(null, childMenu));
                MenuItem found = null;
                for (int i=0; i<count; i++) {
                    found = GetMenuItemFromHandleId(childMenu, i);
                    if (found != null) {
                        Menu parent = found.Parent;
                        if (parent != null && parent is MenuItem) {
                            found = (MenuItem)parent;
                            break;
                        }
                        found = null;
                    }
                }

                mi = found;
            }
            else {
                Command cmd = Command.GetCommandFromID(id);
                if (cmd != null) {
                    Object reference = cmd.Target;
                    if (reference != null && reference is MenuItem.MenuItemData) {
                        mi = ((MenuItem.MenuItemData)reference).baseItem;
                    }
                }
            }
            return mi;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.GetNextControl"]/*' />
        /// <devdoc>
        ///     Retrieves the next control in the tab order of child controls.
        /// </devdoc>
        public Control GetNextControl(Control ctl, bool forward) {
            if (!Contains(ctl)) {
                ctl = this;
            }

            if (forward) {
                ControlCollection ctlControls = (ControlCollection)ctl.Properties.GetObject(PropControlsCollection);
                
                if (ctlControls != null && ctlControls.Count > 0 && (ctl == this || !IsFocusManagingContainerControl(ctl))) {
                    Control found = null;

                    // Cycle through the controls in z-order looking for the lowest tab index.
                    //
                    for (int c = 0; c < ctlControls.Count; c++) {
                        if (found == null || found.tabIndex > ctlControls[c].tabIndex) {
                            found = ctlControls[c];
                        }
                    }
                    return found;
                }

                while (ctl != this) {
                    int targetIndex = ctl.tabIndex;
                    bool hitCtl = false;
                    Control found = null;
                    Control p = ctl.parent;

                    // Cycle through the controls in z-order looking for the one with the next highest
                    // tab index.  Because there can be dups, we have to start with the existing tab index and
                    // remember to exclude the current control.
                    //
                    int parentControlCount = 0;
                    
                    ControlCollection parentControls = (ControlCollection)p.Properties.GetObject(PropControlsCollection);
                    
                    if (parentControls != null) {
                        parentControlCount = parentControls.Count;
                    }
                    
                    for (int c = 0; c < parentControlCount; c++) {

                        // The logic for this is a bit lengthy, so I have broken it into separate
                        // caluses:

                        // We are not interested in ourself.
                        //
                        if (parentControls[c] != ctl) {

                            // We are interested in controls with >= tab indexes to ctl.  We must include those
                            // controls with equal indexes to account for duplicate indexes.
                            //
                            if (parentControls[c].tabIndex >= targetIndex) {

                                // Check to see if this control replaces the "best match" we've already
                                // found.
                                //
                                if (found == null || found.tabIndex > parentControls[c].tabIndex) {

                                    // Finally, check to make sure that if this tab index is the same as ctl,
                                    // that we've already encountered ctl in the z-order.  If it isn't the same,
                                    // than we're more than happy with it.
                                    //
                                    if (parentControls[c].tabIndex != targetIndex || hitCtl) {
                                        found = parentControls[c];
                                    }
                                }
                            }
                        }
                        else {
                            // We track when we have encountered "ctl".  We never want to select ctl again, but
                            // we want to know when we've seen it in case we find another control with the same tab index.
                            //
                            hitCtl = true;
                        }
                    }

                    if (found != null) {
                        return found;
                    }

                    ctl = ctl.parent;
                }
            }
            else {
                if (ctl != this) {

                    int targetIndex = ctl.tabIndex;
                    bool hitCtl = false;
                    Control found = null;
                    Control p = ctl.parent;

                    // Cycle through the controls in reverse z-order looking for the next lowest tab index.  We must
                    // start with the same tab index as ctl, because there can be dups.
                    //
                    int parentControlCount = 0;
                    
                    ControlCollection parentControls = (ControlCollection)p.Properties.GetObject(PropControlsCollection);
                    
                    if (parentControls != null) {
                        parentControlCount = parentControls.Count;
                    }
                    
                    for (int c = parentControlCount - 1; c >= 0; c--) {

                        // The logic for this is a bit lengthy, so I have broken it into separate
                        // caluses:

                        // We are not interested in ourself.
                        //
                        if (parentControls[c] != ctl) {

                            // We are interested in controls with <= tab indexes to ctl.  We must include those
                            // controls with equal indexes to account for duplicate indexes.
                            //
                            if (parentControls[c].tabIndex <= targetIndex) {

                                // Check to see if this control replaces the "best match" we've already
                                // found.
                                //
                                if (found == null || found.tabIndex < parentControls[c].tabIndex) {

                                    // Finally, check to make sure that if this tab index is the same as ctl,
                                    // that we've already encountered ctl in the z-order.  If it isn't the same,
                                    // than we're more than happy with it.
                                    //
                                    if (parentControls[c].tabIndex != targetIndex || hitCtl) {
                                        found = parentControls[c];
                                    }
                                }
                            }
                        }
                        else {
                            // We track when we have encountered "ctl".  We never want to select ctl again, but
                            // we want to know when we've seen it in case we find another control with the same tab index.
                            //
                            hitCtl = true;
                        }
                    }

                    // If we were unable to find a control we should return the control's parent.  However, if that parent is us, return
                    // NULL.
                    //
                    if (found != null) {
                        ctl = found;
                    }
                    else {
                        if (p == this) {
                            return null;
                        }
                        else {
                            return p;
                        }
                    }
                }

                // We found a control.  Walk into this control to find the proper sub control within it to select.
                //
                ControlCollection ctlControls = (ControlCollection)ctl.Properties.GetObject(PropControlsCollection);
                
                while (ctlControls != null && ctlControls.Count > 0 && (ctl == this || !IsFocusManagingContainerControl(ctl))) {

                    Control found = null;

                    // Cycle through the controls in reverse z-order looking for the one with the highest
                    // tab index.
                    //
                    for (int c = ctlControls.Count - 1; c >= 0; c--) {
                        if (found == null || found.tabIndex < ctlControls[c].tabIndex) {
                            found = ctlControls[c];
                        }
                    }
                    ctl = found;
                    
                    ctlControls = (ControlCollection)ctl.Properties.GetObject(PropControlsCollection);
                }
            }

            return ctl == this? null: ctl;
        }

        /// <devdoc>
        ///     Retrieves the current value of the specified bit in the control's state.
        /// </devdoc>
        internal bool GetState(int flag) {
            return(state & flag) != 0;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.GetStyle"]/*' />
        /// <devdoc>
        ///     Retrieves the current value of the specified bit in the control's style.
        ///     NOTE: This is control style, not the Win32 style of the hWnd.
        /// </devdoc>
        protected bool GetStyle(ControlStyles flag) {
            return (controlStyle & flag) == flag;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Hide"]/*' />
        /// <devdoc>
        ///     Hides the control by setting the visible property to false;
        /// </devdoc>
        public void Hide() {
            Visible = false;
        }


        /// <devdoc>
        ///     Sets up the TrackMouseEvent for listening for the
        ///     mouse leave event.
        /// </devdoc>
        /// <internalonly/>
        private void HookMouseEvent() {
            if (!GetState(STATE_TRACKINGMOUSEEVENT)) {
                SetState(STATE_TRACKINGMOUSEEVENT, true);
                
                if (trackMouseEvent == null) {
                    trackMouseEvent = new NativeMethods.TRACKMOUSEEVENT();
                    trackMouseEvent.dwFlags = NativeMethods.TME_LEAVE | NativeMethods.TME_HOVER;
                    trackMouseEvent.hwndTrack = Handle;
                }

                SafeNativeMethods.TrackMouseEvent(trackMouseEvent);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.InitLayout"]/*' />
        /// <devdoc>
        ///     Called after the control has been added to another container.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void InitLayout() {
            LayoutInfo layout = (LayoutInfo)Properties.GetObject(PropLayoutInfo);
            if (layout != null && !layout.IsDock) LayoutManager.UpdateAnchorInfo(this);
        }

        // Sets the text and background colors of the DC, and returns the background HBRUSH.
        // This gets called from some variation on WM_CTLCOLOR...
        // Virtual because Scrollbar insists on being different.
        //
        // NOTE: this message may not have originally been sent to this HWND.
        //
        internal virtual IntPtr InitializeDCForWmCtlColor(IntPtr dc, int msg) {

            if (!GetStyle(ControlStyles.UserPaint)) {
                
                SafeNativeMethods.SetTextColor(new HandleRef(null, dc), ColorTranslator.ToWin32(ForeColor));
                SafeNativeMethods.SetBkColor(new HandleRef(null, dc), ColorTranslator.ToWin32(BackColor));
                return BackBrush;
            }
            else {
                return UnsafeNativeMethods.GetStockObject(NativeMethods.HOLLOW_BRUSH);
            }
        }

        #if WIN95_SUPPORT
        /// <devdoc>
        ///     Initializes mouse wheel support. This may involve registering some windows
        ///     messages on older operating systems.
        /// </devdoc>
        /// <internalonly/>
        private void InitMouseWheelSupport() {
            if (!mouseWheelInit) {
                // If we are running on less than NT4 or less that Win98 then we must use
                // the manual mousewheel stuff...
                //
                mouseWheelRoutingNeeded = !SystemInformation.NativeMouseWheelSupport;

                if (mouseWheelRoutingNeeded) {
                    IntPtr hwndMouseWheel = IntPtr.Zero;

                    // Check for the MouseZ "service". This is a little app that generated the
                    // MSH_MOUSEWHEEL messages by monitoring the hardware. If this app isn't
                    // found, then there is no support for MouseWheels on the system.
                    //
                    hwndMouseWheel = UnsafeNativeMethods.FindWindow(NativeMethods.MOUSEZ_CLASSNAME, NativeMethods.MOUSEZ_TITLE);

                    if (hwndMouseWheel != IntPtr.Zero) {

                        // Register the MSH_MOUSEWHEEL message... we look for this in the
                        // wndProc, and treat it just like WM_MOUSEWHEEL.
                        //
                        int message = SafeNativeMethods.RegisterWindowMessage(NativeMethods.MSH_MOUSEWHEEL);

                        if (message != 0) {
                            mouseWheelMessage = message;
                        }
                    }
                }
                mouseWheelInit = true;
            }
        }
        #endif
        
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Invalidate"]/*' />
        /// <devdoc>
        ///     Invalidates a region of the control and causes a paint message
        ///     to be sent to the control. This will not force a synchronous paint to
        ///     occur, calling update after invalidate will force a
        ///     synchronous paint.
        /// </devdoc>
        public void Invalidate(Region region) {
            Invalidate(region, false);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Invalidate1"]/*' />
        /// <devdoc>
        ///     Invalidates a region of the control and causes a paint message
        ///     to be sent to the control. This will not force a synchronous paint to
        ///     occur, calling update after invalidate will force a
        ///     synchronous paint.
        /// </devdoc>
        public void Invalidate(Region region, bool invalidateChildren) {
            if (region == null) {
                Invalidate(invalidateChildren);
            }
            else if (IsHandleCreated) {
                IntPtr regionHandle = GetHRgn(region);
                
                try {
                    Debug.Assert(regionHandle != IntPtr.Zero, "Region wasn't null but HRGN is?");
                    if (invalidateChildren) {
                        SafeNativeMethods.RedrawWindow(new HandleRef(this, Handle),
                                                       null, new HandleRef(region, regionHandle),
                                                       NativeMethods.RDW_INVALIDATE |
                                                       NativeMethods.RDW_ERASE |
                                                       NativeMethods.RDW_ALLCHILDREN);
                    }
                    else {
                        SafeNativeMethods.InvalidateRgn(new HandleRef(this, Handle), new HandleRef(region, regionHandle), !GetStyle(ControlStyles.Opaque));
                    }
                }
                finally {
                    SafeNativeMethods.DeleteObject(new HandleRef(region, regionHandle));
                }
                
                // gpr: We shouldn't have to create a Graphics for this...
                Graphics graphics = CreateGraphicsInternal();
                Rectangle bounds = Rectangle.Ceiling(region.GetBounds(graphics));
                graphics.Dispose();
                OnInvalidated(new InvalidateEventArgs(bounds));
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Invalidate2"]/*' />
        /// <devdoc>
        ///     Invalidates the control and causes a paint message to be sent to the control.
        ///     This will not force a synchronous paint to occur, calling update after
        ///     invalidate will force a synchronous paint.
        /// </devdoc>
        public void Invalidate() {
            Invalidate(false);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Invalidate3"]/*' />
        /// <devdoc>
        ///     Invalidates the control and causes a paint message to be sent to the control.
        ///     This will not force a synchronous paint to occur, calling update after
        ///     invalidate will force a synchronous paint.
        /// </devdoc>
        public void Invalidate(bool invalidateChildren) {
            if (window.Handle != IntPtr.Zero) {
                if (invalidateChildren) {
                    SafeNativeMethods.RedrawWindow(new HandleRef(window, window.Handle),
                                                   null, NativeMethods.NullHandleRef,
                                                   NativeMethods.RDW_INVALIDATE |
                                                   NativeMethods.RDW_ERASE |
                                                   NativeMethods.RDW_ALLCHILDREN);
                }
                else {
                    SafeNativeMethods.InvalidateRect(new HandleRef(window, window.Handle), null, (controlStyle & ControlStyles.Opaque) != ControlStyles.Opaque);
                }
                NotifyInvalidate(this.ClientRectangle);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Invalidate4"]/*' />
        /// <devdoc>
        ///     Invalidates a rectangular region of the control and causes a paint message
        ///     to be sent to the control. This will not force a synchronous paint to
        ///     occur, calling update after invalidate will force a
        ///     synchronous paint.
        /// </devdoc>
        public void Invalidate(Rectangle rc) {
            Invalidate(rc, false);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Invalidate5"]/*' />
        /// <devdoc>
        ///     Invalidates a rectangular region of the control and causes a paint message
        ///     to be sent to the control. This will not force a synchronous paint to
        ///     occur, calling update after invalidate will force a
        ///     synchronous paint.
        /// </devdoc>
        public void Invalidate(Rectangle rc, bool invalidateChildren) {
            if (rc.IsEmpty) {
                Invalidate(invalidateChildren);
            }
            else if (window.Handle != IntPtr.Zero) {
                if (invalidateChildren) {
                    NativeMethods.RECT rcArea = NativeMethods.RECT.FromXYWH(rc.X, rc.Y, rc.Width, rc.Height);
                    SafeNativeMethods.RedrawWindow(new HandleRef(window, window.Handle),
                                                   ref rcArea, NativeMethods.NullHandleRef,
                                                   NativeMethods.RDW_INVALIDATE |
                                                   NativeMethods.RDW_ERASE |
                                                   NativeMethods.RDW_ALLCHILDREN);
                }
                else {
                    NativeMethods.RECT rcArea = NativeMethods.RECT.FromXYWH(rc.X, rc.Y, rc.Width, rc.Height);
                    SafeNativeMethods.InvalidateRect(new HandleRef(window, window.Handle), ref rcArea, (controlStyle & ControlStyles.Opaque) != ControlStyles.Opaque);
                }
                NotifyInvalidate(rc);
            }
        }
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Invoke"]/*' />
        /// <devdoc>
        ///     Executes the given delegate on the thread that owns this Control's
        ///     underlying window handle.  It is an error to call this on the same thread that
        ///     the control belongs to.  If the control's handle doesn't exist yet, this will
        ///     follow up the control's parent chain until it finds a control or form that does
        ///     have a window handle.  If no appropriate handle can be found, invoke will throw
        ///     an exception.  Exceptions that are raised during the call will be
        ///     propapgated back to the caller.
        ///
        ///     There are five functions on a control that are safe to call from any
        ///     thread:  GetInvokeRequired, Invoke, BeginInvoke, EndInvoke and CreateGraphics.  
        ///     For all other metohd calls, you should use one of the invoke methods to marshal
        ///     the call to the control's thread.
        /// </devdoc>
        public Object Invoke(Delegate method) {
            return Invoke(method, null);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Invoke1"]/*' />
        /// <devdoc>
        ///     Executes the given delegate on the thread that owns this Control's
        ///     underlying window handle.  It is an error to call this on the same thread that
        ///     the control belongs to.  If the control's handle doesn't exist yet, this will
        ///     follow up the control's parent chain until it finds a control or form that does
        ///     have a window handle.  If no appropriate handle can be found, invoke will throw
        ///     an exception.  Exceptions that are raised during the call will be
        ///     propapgated back to the caller.
        ///
        ///     There are five functions on a control that are safe to call from any
        ///     thread:  GetInvokeRequired, Invoke, BeginInvoke, EndInvoke and CreateGraphics.  
        ///     For all other metohd calls, you should use one of the invoke methods to marshal
        ///     the call to the control's thread.
        /// </devdoc>
        public Object Invoke(Delegate method, Object[] args) {
            Control marshaler = FindMarshalingControl();
            return marshaler.MarshaledInvoke(this, method, args, true);
        }

        /// <devdoc>
        ///     Called on the control's owning thread to perform the actual callback.
        ///     This empties this control's callback queue, propagating any excpetions
        ///     back as needed.
        /// </devdoc>
        private void InvokeMarshaledCallbacks() {
            ThreadMethodEntry current = null;
            Queue threadCallbackList = (Queue)Properties.GetObject(PropThreadCallbackList);
            lock(threadCallbackList) {
                if (threadCallbackList.Count > 0) {
                    current = (ThreadMethodEntry)threadCallbackList.Dequeue();
                }
            }

            // Now invoke on all the queued items.
            //
            while (current != null) {
                if (current.method != null) {

                    // Get the old compressed stack from the thread and store it away/
                    // Also, reset the compressed stack on that thread, so we can set ours.
                    //
                    CompressedStack oldCompressedStack = null;
                    if (current.compressedStack != null) {
                        oldCompressedStack = Thread.CurrentThread.GetCompressedStack();
                        if (oldCompressedStack != null) {
                            Thread.CurrentThread.SetCompressedStack(null);
                        }
                    }

                    try {
                        try {
                            // Assign the security stack information from the thread that called
                            // the Invoke() to the thread that is executing the Invoke().
                            //
                            if (current.compressedStack != null) {
                                Thread.CurrentThread.SetCompressedStack(current.compressedStack);
                            }

                            // We short-circuit a couple of common cases for speed.
                            //
                            if (current.method is EventHandler) {
                                ((EventHandler)current.method)(current.caller, EventArgs.Empty);
                            }
                            else if (current.method is MethodInvoker) {
                                ((MethodInvoker)current.method)();
                            }
                            else {
                                current.retVal = current.method.DynamicInvoke(current.args);
                            }                        
                        }
                        catch (Exception t) {
                            current.exception = t.GetBaseException();
                        }
                    }
                    finally {
                        if (current.compressedStack != null) {
                            Thread.CurrentThread.SetCompressedStack(null);
                            if (oldCompressedStack != null) {
                                Thread.CurrentThread.SetCompressedStack(oldCompressedStack);
                            }
                        }

                        current.Complete();

                        if (current.exception != null && !current.synchronous) {
                            Application.OnThreadException(current.exception);                                                                          
                        }
                    }
                }

                lock (threadCallbackList) {
                    if (threadCallbackList.Count > 0) {
                        current = (ThreadMethodEntry)threadCallbackList.Dequeue();
                    }
                    else {
                        current = null;
                    }               
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.InvokePaint"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void InvokePaint(Control c, PaintEventArgs e) {
            c.OnPaint(e);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.InvokePaintBackground"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void InvokePaintBackground(Control c, PaintEventArgs e) {
            c.OnPaintBackground(e);
        }

        /// <devdoc>
        ///     WARNING! The meaning of this method is not what it appears.
        ///     The method returns true if "descendant" (the argument) is a descendant
        ///     of "this". I'd expect it to be the other way around, but oh well too late.
        /// </devdoc>
        /// <internalonly/>
        internal bool IsDescendant(Control descendant) {
            Control control = descendant;
            while (control != null) {
                if (control == this)
                    return true;
                control = control.ParentInternal;
            }
            return false;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.IsInputChar"]/*' />
        /// <devdoc>
        ///     Determines if charCode is an input character that the control
        ///     wants. This method is called during window message pre-processing to
        ///     determine whether the given input character should be pre-processed or
        ///     sent directly to the control. If isInputChar returns true, the
        ///     given character is sent directly to the control. If isInputChar
        ///     returns false, the character is pre-processed and only sent to the
        ///     control if it is not consumed by the pre-processing phase. The
        ///     pre-processing of a character includes checking whether the character
        ///     is a mnemonic of another control.
        /// </devdoc>
        [UIPermission(SecurityAction.InheritanceDemand, Window=UIPermissionWindow.AllWindows)]
        protected virtual bool IsInputChar(char charCode) {
            Debug.WriteLineIf(ControlKeyboardRouting.TraceVerbose, "Control.IsInputChar 0x" + ((int)charCode).ToString("X"));

            int mask = 0;
            if (charCode == (char)(int)Keys.Tab) {
                mask = NativeMethods.DLGC_WANTCHARS | NativeMethods.DLGC_WANTALLKEYS | NativeMethods.DLGC_WANTTAB;
            }
            else {
                mask = NativeMethods.DLGC_WANTCHARS | NativeMethods.DLGC_WANTALLKEYS;
            }
            return((int)SendMessage(NativeMethods.WM_GETDLGCODE, 0, 0) & mask) != 0;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.IsInputKey"]/*' />
        /// <devdoc>
        ///     Determines if keyData is an input key that the control wants.
        ///     This method is called during window message pre-processing to determine
        ///     whether the given input key should be pre-processed or sent directly to
        ///     the control. If isInputKey returns true, the given key is sent
        ///     directly to the control. If isInputKey returns false, the key is
        ///     pre-processed and only sent to the control if it is not consumed by the
        ///     pre-processing phase. Keys that are pre-processed include TAB, RETURN,
        ///     ESCAPE, and arrow keys.
        /// </devdoc>
        [UIPermission(SecurityAction.InheritanceDemand, Window=UIPermissionWindow.AllWindows)]
        protected virtual bool IsInputKey(Keys keyData) {
            Debug.WriteLineIf(ControlKeyboardRouting.TraceVerbose, "Control.IsInputKey " + keyData.ToString());

            if ((keyData & Keys.Alt) == Keys.Alt) return false;
            int mask = NativeMethods.DLGC_WANTALLKEYS;
            switch (keyData & Keys.KeyCode) {
                case Keys.Tab:
                    mask = NativeMethods.DLGC_WANTALLKEYS | NativeMethods.DLGC_WANTTAB;
                    break;
                case Keys.Left:
                case Keys.Right:
                case Keys.Up:
                case Keys.Down:
                    mask = NativeMethods.DLGC_WANTALLKEYS | NativeMethods.DLGC_WANTARROWS;
                    break;
            }

            if (IsHandleCreated) {
                return((int)SendMessage(NativeMethods.WM_GETDLGCODE, 0, 0) & mask) != 0;
            }
            else {
                return false;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.IsMnemonic"]/*' />
        /// <devdoc>
        ///     Determines if charCode is the mnemonic character in text.
        ///     The mnemonic character is the character imediately following the first
        ///     instance of "&amp;" in text
        /// </devdoc>
        [UIPermission(SecurityAction.InheritanceDemand, Window=UIPermissionWindow.AllWindows)]
        public static bool IsMnemonic(char charCode, string text) {
#if DEBUG
            if (ControlKeyboardRouting.TraceVerbose) {
                Debug.Write("Control.IsMnemonic(" + charCode.ToString() + ", ");

                if (text != null) {
                    Debug.Write(text);
                }
                else {
                    Debug.Write("null");
                }
                Debug.WriteLine(")");
            }
#endif

            //Special case handling:
            if (charCode=='&') {
                Debug.WriteLineIf(ControlKeyboardRouting.TraceVerbose, "   ...returning false");
                return false;
            } //if
            

            if (text != null) {
                int pos = -1; // start with -1 to handle double &'s
                char c2 = Char.ToUpper(charCode, CultureInfo.CurrentCulture);                    
                for (;;) {
                    if (pos + 1 >= text.Length)
                        break;
                    pos = text.IndexOf('&', pos + 1) + 1;
                    if (pos <= 0 || pos >= text.Length)
                        break;
                    char c1 = Char.ToUpper(text[pos], CultureInfo.CurrentCulture);
                    Debug.WriteLineIf(ControlKeyboardRouting.TraceVerbose, "   ...& found... char=" + c1.ToString());
                    if (c1 == c2 || Char.ToLower(c1, CultureInfo.CurrentCulture) == Char.ToLower(c2, CultureInfo.CurrentCulture)) {
                        Debug.WriteLineIf(ControlKeyboardRouting.TraceVerbose, "   ...returning true");
                        return true;
                    }
                }
                Debug.WriteLineIf(ControlKeyboardRouting.TraceVerbose && pos == 0, "   ...no & found");
            }
            Debug.WriteLineIf(ControlKeyboardRouting.TraceVerbose, "   ...returning false");
            return false;
        }

        private Object MarshaledInvoke(Control caller, Delegate method, Object[] args, bool synchronous) {

            // Marshaling an invoke occurs in three steps:
            //
            // 1.  Create a ThreadMethodEntry that contains the packet of information
            //     about this invoke.  This TME is placed on a linked list of entries because
            //     we have a gap between the time we PostMessage and the time it actually
            //     gets processed, and this gap may allow other invokes to come in.  Access
            //     to this linked list is always synchronized.
            //
            // 2.  Post ourselves a message.  Our caller has already determined the
            //     best control to call us on, and we should almost always have a handle.
            //
            // 3.  If we're synchronous, wait for the message to get processed.  We don't do
            //     a SendMessage here so we're compatible with OLE, which will abort many
            //     types of calls if we're within a SendMessage.
            //

            if (!IsHandleCreated) {
                throw new InvalidOperationException(SR.GetString(SR.ErrorNoMarshalingThread));
            }

            // We have to demand unmanaged code permission here for the control hosted in
            // the browser case. Without this check, we will expose a security hole, because
            // ActiveXImpl.OnMessage() will assert unmanaged code for everyone as part of
            // its implementation.
            // The right fix is to remove the Assert() on top of the ActiveXImpl class, and
            // visit each method to see if it needs unmanaged code permission, and if so, add
            // the permission just to that method(s).
            //
            ActiveXImpl activeXImpl = (ActiveXImpl)Properties.GetObject(PropActiveXImpl);
            if (activeXImpl != null) {
                IntSecurity.UnmanagedCode.Demand();
            }

            // We don't want to wait if we're on the same thread, or else we'll deadlock.
            // It is important that syncSameThread always be false for asynchronous calls.
            //
            bool syncSameThread = false;
            int pid; // ignored
            if (SafeNativeMethods.GetWindowThreadProcessId(new HandleRef(this, Handle), out pid) == SafeNativeMethods.GetCurrentThreadId()) {
                if (synchronous)
                    syncSameThread = true;
            }

            //convert args to an Object array, then pass them to the ThreadMethodEntry constructor...
            Object[] objectArgs=null;

            if (args != null) {
                objectArgs = new Object[args.Length];

                for (int i = 0; i < objectArgs.Length; i++)
                    objectArgs[i] = args[i];
            }

            // Store the compressed stack information from the thread that is calling the Invoke()
            // so we can assign the same security context to the thread that will actually execute
            // the delegate being passed.
            //
            CompressedStack compressedStack = null;
            if (!syncSameThread)
                compressedStack = CompressedStack.GetCompressedStack();
            ThreadMethodEntry tme = new ThreadMethodEntry(caller, method, objectArgs, synchronous, compressedStack);

            Queue threadCallbackList;
            
            lock (this) {
                threadCallbackList = (Queue)Properties.GetObject(PropThreadCallbackList);
                if (threadCallbackList == null) {
                    threadCallbackList = new Queue();
                    Properties.SetObject(PropThreadCallbackList, threadCallbackList);
                }
            }

            lock (threadCallbackList) {
                if (threadCallbackMessage == 0) {
                    threadCallbackMessage = SafeNativeMethods.RegisterWindowMessage(Application.WindowMessagesVersion + "_ThreadCallbackMessage");
                }
                threadCallbackList.Enqueue(tme);
            }           

            if (syncSameThread)
                InvokeMarshaledCallbacks();
            else
                UnsafeNativeMethods.PostMessage(new HandleRef(this, Handle), threadCallbackMessage, IntPtr.Zero, IntPtr.Zero);

            if (synchronous) {
                if (!tme.IsCompleted) {
                    tme.AsyncWaitHandle.WaitOne();
                }
                if (tme.exception != null) {
                    throw tme.exception;
                }
                return tme.retVal;
            }
            else {
                return(IAsyncResult)tme;
            }
        }

        /// <devdoc>
        ///     Repositions a control in the list.
        /// </devdoc>
        private static void MoveControl(Control[] ctlList, Control child, int fromIndex, int toIndex) {
            int delta = toIndex - fromIndex;

            switch (delta) {
                case -1:
                case 1:
                    // simple swap
                    ctlList[fromIndex] = ctlList[toIndex];
                    break;

                default:
                    int start = 0;
                    int dest = 0;

                    // which direction are we moving?
                    if (delta > 0) {
                        // shift down by the delta to open the new spot
                        start = fromIndex + 1;
                        dest  = fromIndex;
                    }
                    else {
                        // shift up by the delta to open the new spot
                        start = toIndex;
                        dest  = toIndex + 1;

                        // make it positive
                        delta *= -1;
                    }
                    Array.Copy(ctlList, start, ctlList, dest, delta);
                    break;
            }
            ctlList[toIndex] = child;
        }

        // Used by form to notify the control that it has been "entered"
        //
        internal void NotifyEnter() {
            OnEnter(EventArgs.Empty);
        }

        // Used by form to notify the control that it has been "left"
        //
        internal void NotifyLeave() {
            OnLeave(EventArgs.Empty);
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.NotifyInvalidate"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Propagates the invalidation event, notifying the control that
        ///    some part of it is being invalidated and will subsequently need
        ///    to repaint.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void NotifyInvalidate(Rectangle invalidatedArea) {
            OnInvalidated(new InvalidateEventArgs(invalidatedArea));
        }

        // Used by form to notify the control that it is validating.
        //
        internal bool NotifyValidating() {
            CancelEventArgs ev = new CancelEventArgs();
            OnValidating(ev);
            return ev.Cancel;
        }

        // Used by form to notify the control that it has been validated.
        //
        internal void NotifyValidated() {
            OnValidated(EventArgs.Empty);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.InvokeOnClick"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.Click'/> event.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected void InvokeOnClick(Control toInvoke, EventArgs e) {
            toInvoke.OnClick(e);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnBackColorChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnBackColorChanged(EventArgs e) {
            if (GetAnyDisposingInHierarchy()) {
                return;
            }

            object backBrush = Properties.GetObject(PropBackBrush);
            if (backBrush != null) {
                if (GetState(STATE_OWNCTLBRUSH)) {
                    IntPtr p = (IntPtr)backBrush;
                    if (p != IntPtr.Zero) {
                        SafeNativeMethods.DeleteObject(new HandleRef(this, p));
                    }
                }
                Properties.SetObject(PropBackBrush, null);
            }
                    
            Invalidate();
            
            if (CanRaiseEvents) {
                EventHandler eh = Events[EventBackColor] as EventHandler;
                if (eh != null) {
                     eh(this, e);
                }
            }

            ControlCollection controlsCollection = (ControlCollection)Properties.GetObject(PropControlsCollection);
            if (controlsCollection != null) {
                // PERFNOTE: This is more efficient than using Foreach.  Foreach 
                // forces the creation of an array subset enum each time we
                // enumerate
                for(int i = 0; i < controlsCollection.Count; i++) {
                    controlsCollection[i].OnParentBackColorChanged(e);
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnBackgroundImageChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnBackgroundImageChanged(EventArgs e) {
            if (GetAnyDisposingInHierarchy()) {
                return;
            }

            Invalidate();
            
            if (CanRaiseEvents) {
                EventHandler eh = Events[EventBackgroundImage] as EventHandler;
                if (eh != null) {
                     eh(this, e);
                }
            }

            ControlCollection controlsCollection = (ControlCollection)Properties.GetObject(PropControlsCollection);
            if (controlsCollection != null) {
                // PERFNOTE: This is more efficient than using Foreach.  Foreach 
                // forces the creation of an array subset enum each time we
                // enumerate
                for(int i = 0; i < controlsCollection.Count; i++) {
                    controlsCollection[i].OnParentBackgroundImageChanged(e);
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnBindingContextChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnBindingContextChanged(EventArgs e) {
            if (Properties.GetObject(PropBindings) != null) {
                UpdateBindings();
            }
            
            if (CanRaiseEvents) {
                EventHandler eh = Events[EventBindingContext] as EventHandler;
                if (eh != null) {
                     eh(this, e);
                }
            }

            ControlCollection controlsCollection = (ControlCollection)Properties.GetObject(PropControlsCollection);
            if (controlsCollection != null) {
                // PERFNOTE: This is more efficient than using Foreach.  Foreach 
                // forces the creation of an array subset enum each time we
                // enumerate
                for(int i = 0; i < controlsCollection.Count; i++) {
                    controlsCollection[i].OnParentBindingContextChanged(e);
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnCausesValidationChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnCausesValidationChanged(EventArgs e) {
            if (CanRaiseEvents) {
                EventHandler eh = Events[EventCausesValidation] as EventHandler;
                if (eh != null) {
                     eh(this, e);
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnContextMenuChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnContextMenuChanged(EventArgs e) {
            if (CanRaiseEvents) {
                EventHandler eh = Events[EventContextMenu] as EventHandler;
                if (eh != null) {
                     eh(this, e);
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnCursorChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnCursorChanged(EventArgs e) {
            if (CanRaiseEvents) {
                EventHandler eh = Events[EventCursor] as EventHandler;
                if (eh != null) {
                     eh(this, e);
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnDockChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnDockChanged(EventArgs e) {
            if (CanRaiseEvents) {
                EventHandler eh = Events[EventDock] as EventHandler;
                if (eh != null) {
                     eh(this, e);
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnEnabledChanged"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.Enabled'/> event.</para>
        /// <para>Inheriting classes should override this method to handle this event.
        ///    Call base.OnEnabled to send this event to any registered event listeners.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnEnabledChanged(EventArgs e) {
            if (GetAnyDisposingInHierarchy()) {
                return;
            }

            if (window.Handle != IntPtr.Zero) {
                SafeNativeMethods.EnableWindow(new HandleRef(this, Handle), Enabled);

                // User-paint controls should repaint when their enabled state changes
                //                              
                if (GetStyle(ControlStyles.UserPaint)) {
                    Invalidate();
                    Update();
                }
            }

            if (CanRaiseEvents) {
                EventHandler eh = Events[EventEnabled] as EventHandler;
                if (eh != null) {
                     eh(this, e);
                }
            }

            ControlCollection controlsCollection = (ControlCollection)Properties.GetObject(PropControlsCollection);
            if (controlsCollection != null) {
                // PERFNOTE: This is more efficient than using Foreach.  Foreach 
                // forces the creation of an array subset enum each time we
                // enumerate
                for(int i = 0; i < controlsCollection.Count; i++) {
                    controlsCollection[i].OnParentEnabledChanged(e);
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnFontChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnFontChanged(EventArgs e) {
            // bail if disposing
            //
            if (GetAnyDisposingInHierarchy()) {
                return;
            }

            Invalidate();
            
            if (Properties.ContainsInteger(PropFontHeight)) {
                Properties.SetInteger(PropFontHeight, -1);
            }
            
            // Cleanup any font handle wrapper... 
            //
            if (Properties.ContainsObject(PropFontHandleWrapper)) {
                Properties.SetObject(PropFontHandleWrapper, null);
            }

            if (IsHandleCreated && !GetStyle(ControlStyles.UserPaint)) {
                SendMessage(NativeMethods.WM_SETFONT, FontHandle, 0);
            }
            
            if (CanRaiseEvents) {
                EventHandler eh = Events[EventFont] as EventHandler;
                if (eh != null) {
                     eh(this, e);
                }
            }
        
            ControlCollection controlsCollection = (ControlCollection)Properties.GetObject(PropControlsCollection);
            if (controlsCollection != null) {
                // PERFNOTE: This is more efficient than using Foreach.  Foreach 
                // forces the creation of an array subset enum each time we
                // enumerate
                for(int i = 0; i < controlsCollection.Count; i++) {
                    controlsCollection[i].OnParentFontChanged(e);
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnForeColorChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnForeColorChanged(EventArgs e) {
            if (GetAnyDisposingInHierarchy()) {
                return;
            }

            Invalidate();
            
            if (CanRaiseEvents) {
                EventHandler eh = Events[EventForeColor] as EventHandler;
                if (eh != null) {
                     eh(this, e);
                }
            }
        
            ControlCollection controlsCollection = (ControlCollection)Properties.GetObject(PropControlsCollection);
            if (controlsCollection != null) {
                // PERFNOTE: This is more efficient than using Foreach.  Foreach 
                // forces the creation of an array subset enum each time we
                // enumerate
                for(int i = 0; i < controlsCollection.Count; i++) {
                    controlsCollection[i].OnParentForeColorChanged(e);
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnRightToLeftChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnRightToLeftChanged(EventArgs e) {
            if (GetAnyDisposingInHierarchy()) {
                return;
            }

            RecreateHandle();
            
            if (CanRaiseEvents) {
                EventHandler eh = Events[EventRightToLeft] as EventHandler;
                if (eh != null) {
                     eh(this, e);
                }
            }

            ControlCollection controlsCollection = (ControlCollection)Properties.GetObject(PropControlsCollection);
            if (controlsCollection != null) {
                // PERFNOTE: This is more efficient than using Foreach.  Foreach 
                // forces the creation of an array subset enum each time we
                // enumerate
                for(int i = 0; i < controlsCollection.Count; i++) {
                    controlsCollection[i].OnParentRightToLeftChanged(e);
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnNotifyMessage"]/*' />
        /// <devdoc>
        ///    OnNotifyMessage is called if the ControlStyles.EnableNotifyMessage
        ///    bit is set. This allows for semi-trusted controls to listen to 
        ///    window messages, without allowing them to actually modify the
        ///    message.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnNotifyMessage(Message m) {
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnParentBackColorChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnParentBackColorChanged(EventArgs e) {
            object backColor = Properties.GetObject(PropBackColor);
            if (backColor == null || ((Color)backColor).IsEmpty) {
                OnBackColorChanged(e);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnParentBackgroundImageChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnParentBackgroundImageChanged(EventArgs e) {
            OnBackgroundImageChanged(e);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnParentBindingContextChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnParentBindingContextChanged(EventArgs e) {
            if (Properties.GetObject(PropBindingManager) == null) {
                OnBindingContextChanged(e);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnParentEnabledChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnParentEnabledChanged(EventArgs e) {
            if (GetState(STATE_ENABLED)) {
                OnEnabledChanged(e);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnParentFontChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnParentFontChanged(EventArgs e) {
            if (Properties.GetObject(PropFont) == null) {
                OnFontChanged(e);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnParentForeColorChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnParentForeColorChanged(EventArgs e) {
            object foreColor = Properties.GetObject(PropForeColor);
            if (foreColor == null || ((Color)foreColor).IsEmpty) {
                OnForeColorChanged(e);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnParentRightToLeftChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnParentRightToLeftChanged(EventArgs e) {
            if (!Properties.ContainsInteger(PropRightToLeft) || ((RightToLeft)Properties.GetInteger(PropRightToLeft)) == RightToLeft.Inherit) {
                OnRightToLeftChanged(e);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnParentVisibleChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnParentVisibleChanged(EventArgs e) {
            if (GetState(STATE_VISIBLE)) {
                OnVisibleChanged(e);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnTabIndexChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnTabIndexChanged(EventArgs e) {
            if (CanRaiseEvents) {
                EventHandler eh = Events[EventTabIndex] as EventHandler;
                if (eh != null) {
                     eh(this, e);
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnTabStopChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnTabStopChanged(EventArgs e) {
            if (CanRaiseEvents) {
                EventHandler eh = Events[EventTabStop] as EventHandler;
                if (eh != null) {
                     eh(this, e);
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnTextChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnTextChanged(EventArgs e) {
            if (CanRaiseEvents) {
                EventHandler eh = Events[EventText] as EventHandler;
                if (eh != null) {
                     eh(this, e);
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnVisibleChanged"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.Visible'/> event.</para>
        /// <para>Inheriting classes should override this method to handle this event.
        ///    Call base.OnVisible to send this event to any registered event listeners.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnVisibleChanged(EventArgs e) {
            if (parent != null && Visible && !Created) {
                bool isDisposing = GetAnyDisposingInHierarchy();
                if (!isDisposing) {
                    // Usually the control is created by now, but in a few corner cases 
                    // exercised by the PropertyGrid dropdowns, it isn't
                    CreateControl(); 
                }
            }
            
            if (CanRaiseEvents) {
                EventHandler eh = Events[EventVisible] as EventHandler;
                if (eh != null) {
                     eh(this, e);
                }
            }

            ControlCollection controlsCollection = (ControlCollection)Properties.GetObject(PropControlsCollection);
            if (controlsCollection != null) {
                // PERFNOTE: This is more efficient than using Foreach.  Foreach 
                // forces the creation of an array subset enum each time we
                // enumerate
                for(int i = 0; i < controlsCollection.Count; i++) {
                    Control ctl = controlsCollection[i];
                    if (ctl.Visible) {
                        ctl.OnParentVisibleChanged(e);
                    }
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnParentChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnParentChanged(EventArgs e) {
            if (CanRaiseEvents) {
                EventHandler eh = Events[EventParent] as EventHandler;
                if (eh != null) {
                     eh(this, e);
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnClick"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.Click'/> 
        /// event.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnClick(EventArgs e) {
            if (CanRaiseEvents) {
                EventHandler handler = (EventHandler)Events[EventClick];
                if (handler != null) handler(this, e);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnControlAdded"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.ControlAdded'/> event.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnControlAdded(ControlEventArgs e) {
            if (CanRaiseEvents) {
                ControlEventHandler handler = (ControlEventHandler)Events[EventControlAdded];
                if (handler != null) handler(this, e);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnControlRemoved"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.ControlRemoved'/> event.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnControlRemoved(ControlEventArgs e) {
            if (CanRaiseEvents) {
                ControlEventHandler handler = (ControlEventHandler)Events[EventControlRemoved];
                if (handler != null) handler(this, e);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnCreateControl"]/*' />
        /// <devdoc>
        ///    <para>Called when the control is first created.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnCreateControl() {
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnHandleCreated"]/*' />
        /// <devdoc>
        ///     Inheriting classes should override this method to find out when the
        ///     handle has been created.
        ///     Call base.OnHandleCreated first.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnHandleCreated(EventArgs e) {

            // Setting fonts is for some reason incredibly expensive.
            // (Even if you exclude font handle creation)
            if (!GetStyle(ControlStyles.UserPaint))
                SendMessage(NativeMethods.WM_SETFONT, FontHandle, new IntPtr(0)); // actually faster than IntPtr.Zero
            
            // Restore dragdrop status. Ole Initialize happens
            // when the ThreadContext in Application is created
            //
            SetAcceptDrops(AllowDrop);

            Region region = (Region)Properties.GetObject(PropRegion);
            if (region != null) {
                IntPtr regionHandle = GetHRgn(region);

                if (IsActiveX) {
                    regionHandle = ActiveXMergeRegion(regionHandle);
                }

                UnsafeNativeMethods.SetWindowRgn(new HandleRef(this, Handle), new HandleRef(this, regionHandle), SafeNativeMethods.IsWindowVisible(new HandleRef(this, Handle)));
            }

            // Update accessbility information
            ControlAccessibleObject accObj = Properties.GetObject(PropAccessibility) as ControlAccessibleObject;
            if (accObj != null) {
                accObj.Handle = Handle;
            }

            if (text != null && text.Length != 0) {
                UnsafeNativeMethods.SetWindowText(new HandleRef(this, Handle), text);
            }

            if (CanRaiseEvents) {
                EventHandler handler = (EventHandler)Events[EventHandleCreated];
                if (handler != null) handler(this, e);
            }

            // Now, repost the thread callback message if we found it.  We should do
            // this last, so we're as close to the same state as when the message
            // was placed.
            //
            if (GetState(STATE_THREADMARSHALLPENDING)) {
                UnsafeNativeMethods.PostMessage(new HandleRef(this, Handle), threadCallbackMessage, IntPtr.Zero, IntPtr.Zero);
                SetState(STATE_THREADMARSHALLPENDING, false);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnLocationChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnLocationChanged(EventArgs e) {
            OnMove(EventArgs.Empty);

            if (CanRaiseEvents) {
                EventHandler eh = Events[EventLocation] as EventHandler;
                if (eh != null) {
                    eh(this,e);
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnHandleDestroyed"]/*' />
        /// <devdoc>
        ///     Inheriting classes should override this method to find out when the
        ///     handle is about to be destroyed.
        ///     Call base.OnHandleDestroyed last.
        /// <para>Raises the <see cref='System.Windows.Forms.Control.HandleDestroyed'/> event.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnHandleDestroyed(EventArgs e) {
            if (CanRaiseEvents) {
                EventHandler handler = (EventHandler)Events[EventHandleDestroyed];
                if (handler != null) handler(this, e);
            }

            if (!RecreatingHandle) {
                if (GetState(STATE_OWNCTLBRUSH)) {
                    object backBrush = Properties.GetObject(PropBackBrush);
                    if (backBrush != null) {
                        IntPtr p = (IntPtr)backBrush;
                        if (p != IntPtr.Zero) {
                            SafeNativeMethods.DeleteObject(new HandleRef(this, p));
                        }
                        Properties.SetObject(PropBackBrush, null);
                    }
                }

                GraphicsBufferManager buffer = (GraphicsBufferManager)Properties.GetObject(PropGraphicsBufferManager);
                if (buffer != null) {
                    buffer.Dispose();
                    Properties.SetObject(PropGraphicsBufferManager, null);
                }
            }

            // this code is important -- it is critical that we stash away
            // the value of the text for controls such as edit, button,
            // label, etc. Without this processing, any time you change a
            // property that forces handle recreation, you lose your text!
            // See the above code in wmCreate
            //

            try {
                if (!GetAnyDisposingInHierarchy()) {
                    text = Text;
                    if (text != null && text.Length == 0) text = null;
                }
                SetAcceptDrops(false);
            }
            catch(Exception) {
                // Some ActiveX controls throw exceptions when 
                // you ask for the text property after you have destroyed their handle. We
                // don't want those exceptions to bubble all the way to the top, since
                // we leave our state in a mess. See ASURT 49990.
                //
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnDoubleClick"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.DoubleClick'/> event.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnDoubleClick(EventArgs e) {

            if (CanRaiseEvents) {
                EventHandler handler = (EventHandler)Events[EventDoubleClick];
                if (handler != null) handler(this,e);
            }
        }
        
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnDragEnter"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.Enter'/> event.</para>
        /// <para>Inheriting classes should override this method to handle this event.
        ///    Call base.onEnter to send this event to any registered event listeners.</para>
        /// </devdoc>
        /// <devdoc>
        ///     Inheriting classes should override this method to handle this event.
        ///     Call base.onDragEnter to send this event to any registered event listeners.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnDragEnter(DragEventArgs drgevent) {
            if (CanRaiseEvents) {
                DragEventHandler handler = (DragEventHandler)Events[EventDragEnter];
                if (handler != null) handler(this,drgevent);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnDragOver"]/*' />
        /// <devdoc>
        ///     Inheriting classes should override this method to handle this event.
        ///     Call base.onDragOver to send this event to any registered event listeners.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnDragOver(DragEventArgs drgevent) {
            if (CanRaiseEvents) {
                DragEventHandler handler = (DragEventHandler)Events[EventDragOver];
                if (handler != null) handler(this,drgevent);
            }
        }
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnDragLeave"]/*' />
        /// <devdoc>
        ///     Inheriting classes should override this method to handle this event.
        ///     Call base.onDragLeave to send this event to any registered event listeners.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnDragLeave(EventArgs e) {
            if (CanRaiseEvents) {
                EventHandler handler = (EventHandler)Events[EventDragLeave];
                if (handler != null) handler(this,e);
            }
        }
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnDragDrop"]/*' />
        /// <devdoc>
        ///     Inheriting classes should override this method to handle this event.
        ///     Call base.onDragDrop to send this event to any registered event listeners.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnDragDrop(DragEventArgs drgevent) {
            if (CanRaiseEvents) {
                DragEventHandler handler = (DragEventHandler)Events[EventDragDrop];
                if (handler != null) handler(this,drgevent);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnGiveFeedback"]/*' />
        /// <devdoc>
        ///     Inheriting classes should override this method to handle this event.
        ///     Call base.onGiveFeedback to send this event to any registered event listeners.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnGiveFeedback(GiveFeedbackEventArgs gfbevent) {
            if (CanRaiseEvents) {
                GiveFeedbackEventHandler handler = (GiveFeedbackEventHandler)Events[EventGiveFeedback];
                if (handler != null) handler(this,gfbevent);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnEnter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnEnter(EventArgs e) {
            if (CanRaiseEvents) {
                EventHandler handler = (EventHandler)Events[EventEnter];
                if (handler != null) handler(this,e);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.InvokeGotFocus"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.GotFocus'/> event.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected void InvokeGotFocus(Control toInvoke, EventArgs e) {
            toInvoke.OnGotFocus(e);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnGotFocus"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.GotFocus'/> event.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnGotFocus(EventArgs e) {
        
            if (IsActiveX) {
                ActiveXOnFocus(true);
            }
            if (parent != null)
                parent.ChildGotFocus(this);

            if (CanRaiseEvents) {
                EventHandler handler = (EventHandler)Events[EventGotFocus];
                if (handler != null) handler(this,e);
            }            
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnHelpRequested"]/*' />
        /// <devdoc>
        ///     Inheriting classes should override this method to handle this event.
        ///     Call base.onHelp to send this event to any registered event listeners.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnHelpRequested(HelpEventArgs hevent) {
            if (CanRaiseEvents) {
                HelpEventHandler handler = (HelpEventHandler)Events[EventHelpRequested];
                if (handler != null) handler(this,hevent);
            }

            if (!hevent.Handled) {
                if (ParentInternal != null) {
                    ParentInternal.OnHelpRequested(hevent);
                }
            }
        }
        
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnImeModeChanged"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.OnImeModeChanged'/> 
        /// event.</para>
        /// </devdoc>
        protected virtual void OnImeModeChanged(EventArgs e) {
            if (CanRaiseEvents) {
                EventHandler handler = (EventHandler)Events[EventImeModeChanged];
                if (handler != null) handler(this, e);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnInvalidated"]/*' />
        /// <devdoc>
        ///     Inheriting classes should override this method to handle this event.
        ///     Call base.OnInvalidate to send this event to any registered event listeners.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnInvalidated(InvalidateEventArgs e) {
            // Transparent control support
            ControlCollection controls = (ControlCollection)Properties.GetObject(PropControlsCollection);
            if (controls != null) {
                // PERFNOTE: This is more efficient than using Foreach.  Foreach 
                // forces the creation of an array subset enum each time we
                // enumerate
                for(int i = 0; i < controls.Count; i++) {
                    controls[i].OnParentInvalidated(e);
                }
            }
        
            if (CanRaiseEvents) {
                InvalidateEventHandler handler = (InvalidateEventHandler)Events[EventInvalidated];
                if (handler != null) handler(this, e);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnKeyDown"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.KeyDown'/> event.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnKeyDown(KeyEventArgs e) {
            if (CanRaiseEvents) {
                KeyEventHandler handler = (KeyEventHandler)Events[EventKeyDown];
                if (handler != null) handler(this,e);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnKeyPress"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.KeyPress'/> event.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnKeyPress(KeyPressEventArgs e) {
            if (CanRaiseEvents) {
                KeyPressEventHandler handler = (KeyPressEventHandler)Events[EventKeyPress];
                if (handler != null) handler(this,e);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnKeyUp"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.KeyUp'/> event.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnKeyUp(KeyEventArgs e) {
            if (CanRaiseEvents) {
                KeyEventHandler handler = (KeyEventHandler)Events[EventKeyUp];
                if (handler != null) handler(this,e);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnLayout"]/*' />
        /// <devdoc>
        ///     Core layout logic. Inheriting controls should override this function
        ///     to do any custom layout logic. It is not neccessary to call
        ///     base.layoutCore, however for normal docking and anchoring
        ///     functions to work, base.layoutCore must be called.
        /// <para>Raises the <see cref='System.Windows.Forms.Control.Layout'/> event.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnLayout(LayoutEventArgs levent) {
            if (CanRaiseEvents) {
                LayoutEventHandler handler = (LayoutEventHandler)Events[EventLayout];
                if (handler != null) handler(this, levent);
            }
        
            LayoutManager.OnLayout(this, levent);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnLeave"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.Leave'/> event.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnLeave(EventArgs e) {
            if (CanRaiseEvents) {
                EventHandler handler = (EventHandler)Events[EventLeave];
                if (handler != null) handler(this, e);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.InvokeLostFocus"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected void InvokeLostFocus(Control toInvoke, EventArgs e) {
            toInvoke.OnLostFocus(e);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnLostFocus"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.LostFocus'/> event.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnLostFocus(EventArgs e) {

            if (IsActiveX) {
                ActiveXOnFocus(false);
            }

            if (CanRaiseEvents) {
                EventHandler handler = (EventHandler)Events[EventLostFocus];
                if (handler != null) handler(this, e);
            }                        
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnMouseDown"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.MouseDown'/> event.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnMouseDown(MouseEventArgs e) {
           if (CanRaiseEvents) {
                MouseEventHandler handler = (MouseEventHandler)Events[EventMouseDown];
                if (handler != null) handler(this, e);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnMouseEnter"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.MouseEnter'/> event.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnMouseEnter(EventArgs e) {
            if (CanRaiseEvents) {
                EventHandler handler = (EventHandler)Events[EventMouseEnter];
                if (handler != null) handler(this, e);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnMouseLeave"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.MouseLeave'/> event.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnMouseLeave(EventArgs e) {
            if (CanRaiseEvents) {
                EventHandler handler = (EventHandler)Events[EventMouseLeave];
                if (handler != null) handler(this, e);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnMouseHover"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.MouseHover'/> event.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnMouseHover(EventArgs e) {
            if (CanRaiseEvents) {
                EventHandler handler = (EventHandler)Events[EventMouseHover];
                if (handler != null) handler(this, e);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnMouseMove"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.MouseMove'/> event.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnMouseMove(MouseEventArgs e) {
            if (CanRaiseEvents) {
                MouseEventHandler handler = (MouseEventHandler)Events[EventMouseMove];
                if (handler != null) handler(this, e);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnMouseUp"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.MouseUp'/> event.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnMouseUp(MouseEventArgs e) {
            if (CanRaiseEvents) {
                MouseEventHandler handler = (MouseEventHandler)Events[EventMouseUp];
                if (handler != null) handler(this, e);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnMouseWheel"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.MouseWheel'/> event.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnMouseWheel(MouseEventArgs e) {
            if (CanRaiseEvents) {
                MouseEventHandler handler = (MouseEventHandler)Events[EventMouseWheel];
                if (handler != null) handler(this, e);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnMove"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.Move'/> event.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnMove(EventArgs e) {
            if (CanRaiseEvents) {
                EventHandler handler = (EventHandler)Events[EventMove];
                if (handler != null) handler(this, e);
            }
            
            if (RenderTransparent)
                Invalidate();
        }
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnPaint"]/*' />
        /// <devdoc>
        ///     Inheriting classes should override this method to handle this event.
        ///     Call base.onPaint to send this event to any registered event listeners.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnPaint(PaintEventArgs e) {
            if (CanRaiseEvents) {
                PaintEventHandler handler = (PaintEventHandler)Events[EventPaint];
                if (handler != null) handler(this, e);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnPaintBackground"]/*' />
        /// <devdoc>
        ///     Inheriting classes should override this method to handle the erase
        ///     background request from windows. It is not necessary to call
        ///     base.onPaintBackground, however if you do not want the default
        ///     Windows behavior you must set event.handled to true.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnPaintBackground(PaintEventArgs pevent) {
            PaintBackground(pevent, pevent.ClipRectangle);
        }

        // Transparent control support
        private void OnParentInvalidated(InvalidateEventArgs e) {
            if (!RenderTransparent) return;

            if (this.IsHandleCreated) {
                // move invalid rect into child space
                Rectangle cliprect = e.InvalidRect;
                Point offs = this.Location;
                cliprect.Offset(-offs.X,-offs.Y);
                cliprect = Rectangle.Intersect(this.ClientRectangle, cliprect);

                // if we don't intersect at all, do nothing
                if (cliprect.IsEmpty) return;
                this.Invalidate(cliprect);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnQueryContinueDrag"]/*' />
        /// <devdoc>
        ///     Inheriting classes should override this method to handle this event.
        ///     Call base.onQueryContinueDrag to send this event to any registered event listeners.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnQueryContinueDrag(QueryContinueDragEventArgs qcdevent) {
            if (CanRaiseEvents) {
                QueryContinueDragEventHandler handler = (QueryContinueDragEventHandler)Events[EventQueryContinueDrag];
                if (handler != null) handler(this, qcdevent);
            }
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnResize"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.Resize'/> event.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnResize(EventArgs e) {
            if ((controlStyle & ControlStyles.ResizeRedraw) == ControlStyles.ResizeRedraw
                || GetState(STATE_EXCEPTIONWHILEPAINTING)) {
                Invalidate();
            }
            PerformLayout(this, "Bounds");

            if (CanRaiseEvents) {
                EventHandler handler = (EventHandler)Events[EventResize];
                if (handler != null) handler(this, e);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnSizeChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnSizeChanged(EventArgs e) {
            OnResize(EventArgs.Empty);
            
            if (CanRaiseEvents) {
                EventHandler eh = Events[EventSize] as EventHandler;
                if (eh != null) {
                    eh(this,e);
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnChangeUICues"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.ChangeUICues'/> 
        /// event.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnChangeUICues(UICuesEventArgs e) {
            if (CanRaiseEvents) {
                UICuesEventHandler handler = (UICuesEventHandler)Events[EventChangeUICues];
                if (handler != null) handler(this, e);
            }
        }
        
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnStyleChanged"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.OnStyleChanged'/> 
        /// event.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnStyleChanged(EventArgs e) {
            if (CanRaiseEvents) {
                EventHandler handler = (EventHandler)Events[EventStyleChanged];
                if (handler != null) handler(this, e);
            }
        }
        
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnSystemColorsChanged"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.SystemColorsChanged'/> 
        /// event.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnSystemColorsChanged(EventArgs e) {
            ControlCollection controlsCollection = (ControlCollection)Properties.GetObject(PropControlsCollection);
            if (controlsCollection != null) {
                // PERFNOTE: This is more efficient than using Foreach.  Foreach 
                // forces the creation of an array subset enum each time we
                // enumerate
                for(int i = 0; i < controlsCollection.Count; i++) {
                    controlsCollection[i].OnSystemColorsChanged(EventArgs.Empty);
                }
            }
            Invalidate();
            
            if (CanRaiseEvents) {
                EventHandler handler = (EventHandler)Events[EventSystemColorsChanged];
                if (handler != null) handler(this, e);
            }                        
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnValidating"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.Validating'/> 
        /// event.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnValidating(CancelEventArgs e) {
            if (CanRaiseEvents) {
                CancelEventHandler handler = (CancelEventHandler)Events[EventValidating];
                if (handler != null) handler(this, e);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.OnValidated"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.Validated'/> event.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnValidated(EventArgs e) {
            if (CanRaiseEvents) {
                EventHandler handler = (EventHandler)Events[EventValidated];
                if (handler != null) handler(this, e);
            }
        }
        
        // This is basically OnPaintBackground, put in a separate method for ButtonBase,
        // which does all painting under OnPaint, and tries very hard to avoid double-painting the border pixels.
        internal void PaintBackground(PaintEventArgs e, Rectangle rectangle) {
            if (RenderTransparent) {
                PaintTransparentBackground(e, rectangle);
            }

            // The rest of this won't do much if BackColor is transparent and there is no BackgroundImage,
            // but we need to call it in the partial alpha case.

            // CONSIDER: it would be faster if we cached this stuff, but then we would need to invalidate
            // the cached brush when entering/leaving high contrast mode.
            if (BackgroundImage != null && !SystemInformation.HighContrast) {
                TextureBrush textureBrush = new TextureBrush(BackgroundImage, WrapMode.Tile);

                try {
                    // Make sure the brush origin matches the display rectangle, not the client rectangle,
                    // so the background image scrolls on AutoScroll forms.
                    Matrix transform = textureBrush.Transform;
                    transform.Translate(DisplayRectangle.X, DisplayRectangle.Y);
                    textureBrush.Transform = transform;
                    e.Graphics.FillRectangle(textureBrush, rectangle);
                }
                finally {
                    textureBrush.Dispose();
                }
            }
            else {
                // Common case of just painting the background.  For this, we
                // use GDI because it is faster for simple things than creating
                // a graphics object, brush, etc.  Also, we may be able to 
                // use a system brush, avoiding the brush create altogether.
                //
                Color color = BackColor;

                // Note: PaintEvent.HDC == 0 if GDI+ has used the HDC -- it wouldn't be safe for us
                // to use it without enough bookkeeping to negate any performance gain of using GDI.
                bool painted = false;
                if (color.A == 255 && e.HDC != IntPtr.Zero) {
                    
                    if (BitsPerPixel > 8) {
                        NativeMethods.RECT r = new NativeMethods.RECT(rectangle.X, rectangle.Y, rectangle.Right, rectangle.Bottom);
                        SafeNativeMethods.FillRect(new HandleRef(e, e.HDC), ref r, new HandleRef(this, BackBrush));
                        painted = true;
                    }
                }

                if (!painted) {
                    // don't paint anything from 100% transparent background
                    //
                    if (color.A > 0) {
                        if (color.A == 255) {
                            color = e.Graphics.GetNearestColor(color);
                        }

                        // Color has some transparency or we have no HDC, so we must
                        // fall back to using GDI+.
                        //
                        using (Brush brush = new SolidBrush(color)) {
                            e.Graphics.FillRectangle(brush, rectangle);
                        }
                    }
                }
            }
        }

        // Paints a red rectangle with a red X, painted on a white background
        private void PaintException(PaintEventArgs e) {
#if DEBUG
            StringFormat stringFormat = ControlPaint.StringFormatForAlignment(ContentAlignment.TopLeft);
            string exceptionText = Properties.GetObject(PropPaintingException).ToString();
            stringFormat.SetMeasurableCharacterRanges(new CharacterRange[] {new CharacterRange(0, exceptionText.Length)});

            // rendering calculations...
            //
            int penThickness = 2;
            Size glyphSize = SystemInformation.IconSize;
            int marginX = penThickness * 2;
            int marginY = penThickness * 2;

            Rectangle clientRectangle = ClientRectangle;
            
            Rectangle borderRectangle = ClientRectangle;
            borderRectangle.X++;
            borderRectangle.Y++;
            borderRectangle.Width -=2;
            borderRectangle.Height-=2;
            
            Rectangle imageRect = new Rectangle(marginX, marginY, glyphSize.Width, glyphSize.Height);
            
            Rectangle textRect = clientRectangle;
            textRect.X = imageRect.X + imageRect.Width + 2 * marginX;
            textRect.Y = imageRect.Y;
            textRect.Width -= (textRect.X + marginX + penThickness);
            textRect.Height -= (textRect.Y + marginY + penThickness);

            using (Font errorFont = new Font(Font.FontFamily, Math.Max(SystemInformation.ToolWindowCaptionHeight - SystemInformation.BorderSize.Height - 2, Font.Height), GraphicsUnit.Pixel)) {

                using(Region textRegion = e.Graphics.MeasureCharacterRanges(exceptionText, errorFont, textRect, stringFormat)[0]) {
                    // paint contents... clipping optimizations for less flicker...
                    //
                    Region originalClip = e.Graphics.Clip;

                    e.Graphics.ExcludeClip(textRegion);
                    e.Graphics.ExcludeClip(imageRect);
                    try {
                        e.Graphics.FillRectangle(Brushes.White, clientRectangle);
                    }
                    finally {
                        e.Graphics.Clip = originalClip;
                    }

                    using (Pen pen = new Pen(Color.Red, penThickness)) {
                        e.Graphics.DrawRectangle(pen, borderRectangle);
                    }

                    Icon err = SystemIcons.Error;

                    e.Graphics.FillRectangle(Brushes.White, imageRect);
                    e.Graphics.DrawIcon(err, imageRect.X, imageRect.Y);

                    textRect.X++;
                    e.Graphics.IntersectClip(textRegion);
                    try {
                        e.Graphics.FillRectangle(Brushes.White, textRect);
                        e.Graphics.DrawString(exceptionText, errorFont, new SolidBrush(ForeColor), textRect, stringFormat);
                    }
                    finally {
                        e.Graphics.Clip = originalClip;
                    }
                }
            }
#else
            int penThickness = 2;
            Pen pen = new Pen(Color.Red, penThickness);
            Rectangle clientRectangle = ClientRectangle;
            Rectangle rectangle = clientRectangle;
            rectangle.X++;
            rectangle.Y++;
            rectangle.Width--;
            rectangle.Height--;

            e.Graphics.DrawRectangle(pen, rectangle.X, rectangle.Y, rectangle.Width - 1, rectangle.Height - 1);
            rectangle.Inflate(-1, -1);
            e.Graphics.FillRectangle(Brushes.White, rectangle);
            e.Graphics.DrawLine(pen, clientRectangle.Left, clientRectangle.Top, 
                                clientRectangle.Right, clientRectangle.Bottom);
            e.Graphics.DrawLine(pen, clientRectangle.Left, clientRectangle.Bottom, 
                                clientRectangle.Right, clientRectangle.Top);
            pen.Dispose();
  
#endif
        }

        // Trick our parent into painting our background for us, or paint some default
        // color if that doesn't work.
        //
        // This method is the hardest part of implementing transparent controls;
        // call this in your OnPaintBackground method, and away you go.
        internal void PaintTransparentBackground(PaintEventArgs e, Rectangle rectangle) {
            Graphics g = e.Graphics;
            Control parent = this.ParentInternal;

            if (parent != null) {

                // Offset the graphics origin to match the parent.
                //
                NativeMethods.POINT p = new NativeMethods.POINT();
                p.x = p.y = 0;
                UnsafeNativeMethods.MapWindowPoints(new HandleRef(this, Handle), new HandleRef(parent, parent.Handle), p, 1);

                rectangle.Offset(p.x, p.y);                      // offset the cliprect into parent space

                PaintEventArgs np = new PaintEventArgs(g, rectangle);

                GraphicsState state = g.Save();

                try 
                {
                    g.TranslateTransform(-p.x, -p.y);
                    InvokePaintBackground(parent, np);             // get the parent to erase our background

                    // Set it up again in case OnPaintBackground screwed it up
                    g.Restore(state);
                    state = g.Save();
                    g.TranslateTransform(-p.x, -p.y);

                    InvokePaint(parent, np);                       // tell the parent to paint its foreground
                }
                finally {
                    g.Restore(state);
                }
            }
            else {
                // For whatever reason, our parent can't paint our background, but we need some kind of background
                // since we're transparent.
                g.FillRectangle(SystemBrushes.Control, rectangle);
            }
        }

        // Exceptions during painting are nasty, because paint events happen so often.
        // So if user painting code blows up, we make sure never to call it again,
        // so as not to spam the end-user with exception dialogs.
        // CONSIDER: extend this mechanism to other frequent messages like WM_MOUSEMOVE?
        private void PaintWithErrorHandling(PaintEventArgs e, short layer, bool disposeEventArgs) {
            try {
                if (GetState(STATE_EXCEPTIONWHILEPAINTING)) {
                    if (layer == PaintLayerBackground)
                        PaintException(e);
                }
                else {
                    try {
                        switch (layer) {
                            case PaintLayerForeground:
                                OnPaint(e);
                                break;
                            case PaintLayerBackground:
                                if (!GetStyle(ControlStyles.Opaque)) {
                                    OnPaintBackground(e);
                                }
                                break;
                            default:
                                Debug.Fail("Unknown PaintLayer " + layer);
                                break;
                        }
                    }
                    catch (Exception ex) {
                        SetState(STATE_EXCEPTIONWHILEPAINTING, true);
                        Properties.SetObject(PropPaintingException, ex);
                        Invalidate();
                        throw;
                    }
                }
            }
            finally {
                if (disposeEventArgs)
                    e.Dispose();
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.PerformLayout"]/*' />
        /// <devdoc>
        ///     Forces the control to apply layout logic to all of the child controls.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        public void PerformLayout() {
            PerformLayout(null, null);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.PerformLayout1"]/*' />
        /// <devdoc>
        ///     Forces the control to apply layout logic to all of the child controls.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        public void PerformLayout(Control affectedControl, string affectedProperty) {
            if (GetAnyDisposingInHierarchy()) {
                return;
            }

            if (layoutSuspendCount > 0) {
                state |= STATE_LAYOUTDEFERRED;
                return;
            }
            layoutSuspendCount = 1;
            try {
                OnLayout(new LayoutEventArgs(affectedControl, affectedProperty));
            }
            finally {
                state &= ~STATE_LAYOUTDEFERRED;
                layoutSuspendCount = 0;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.PointToClient"]/*' />
        /// <devdoc>
        ///     Computes the location of the screen point p in client coords.
        /// </devdoc>
        public Point PointToClient(Point p) {
            // SECREVIEW : verify it is OK to skip this demand
            //
            // Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "ScreenLocationOfThings Demanded");
            // IntSecurity.ScreenLocationOfThings.Demand();
            return PointToClientInternal(p);
        }
        internal Point PointToClientInternal(Point p) {
            // ASURT 42367.
            // Win9x reports incorrect values if you go outside the 16-bit range.
            // We're not going to do anything about it, though -- it's esoteric, it clutters up the code,
            // and potentially causes problems on systems that do support 32-bit coordinates.

            NativeMethods.POINT point = new NativeMethods.POINT(p.X, p.Y);
            UnsafeNativeMethods.MapWindowPoints(NativeMethods.NullHandleRef, new HandleRef(this, Handle), point, 1);
            return new Point(point.x, point.y);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.PointToScreen"]/*' />
        /// <devdoc>
        ///     Computes the location of the client point p in screen coords.
        /// </devdoc>
        public Point PointToScreen(Point p) {
            // SECREVIEW : verify it is OK to skip this demand
            //
            // Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "ScreenLocationOfThings Demanded");
            // IntSecurity.ScreenLocationOfThings.Demand();

            NativeMethods.POINT point = new NativeMethods.POINT(p.X, p.Y);
            UnsafeNativeMethods.MapWindowPoints(new HandleRef(this, Handle), NativeMethods.NullHandleRef, point, 1);
            return new Point(point.x, point.y);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.PreProcessMessage"]/*' />
        /// <devdoc>
        ///     <para>
        ///     This method is called by the application's message loop to pre-process
        ///     input messages before they are dispatched. Possible values for the
        ///     msg.message field are WM_KEYDOWN, WM_SYSKEYDOWN, WM_CHAR, and WM_SYSCHAR.
        ///     If this method processes the message it must return true, in which case
        ///     the message loop will not dispatch the message.
        ///     </para>
        ///     <para>
        /// For WM_KEYDOWN and WM_SYSKEYDOWN messages, preProcessMessage() first
        ///     calls processCmdKey() to check for command keys such as accelerators and
        ///     menu shortcuts. If processCmdKey() doesn't process the message, then
        ///     isInputKey() is called to check whether the key message represents an
        ///     input key for the control. Finally, if isInputKey() indicates that the
        ///     control isn't interested in the key message, then processDialogKey() is
        ///     called to check for dialog keys such as TAB, arrow keys, and mnemonics.
        ///     </para>
        ///     <para>
        /// For WM_CHAR messages, preProcessMessage() first calls isInputChar() to
        ///     check whether the character message represents an input character for
        ///     the control. If isInputChar() indicates that the control isn't interested
        ///     in the character message, then processDialogChar() is called to check for
        ///     dialog characters such as mnemonics.
        ///     </para>
        ///     <para>
        /// For WM_SYSCHAR messages, preProcessMessage() calls processDialogChar()
        ///     to check for dialog characters such as mnemonics.
        ///     </para>
        ///     <para>
        /// When overriding preProcessMessage(), a control should return true to
        ///     indicate that it has processed the message. For messages that aren't
        ///     processed by the control, the result of "base.preProcessMessage()"
        ///     should be returned. Controls will typically override one of the more
        ///     specialized methods (isInputChar(), isInputKey(), processCmdKey(),
        ///     processDialogChar(), or processDialogKey()) instead of overriding
        ///     preProcessMessage().
        ///     </para>
        /// </devdoc>
        [SecurityPermission(SecurityAction.InheritanceDemand, Flags=SecurityPermissionFlag.UnmanagedCode), 
            SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public virtual bool PreProcessMessage(ref Message msg) {
            Debug.WriteLineIf(ControlKeyboardRouting.TraceVerbose, "Control.PreProcessMessage " + msg.ToString());

            bool ret;

            if (msg.Msg == NativeMethods.WM_KEYDOWN || msg.Msg == NativeMethods.WM_SYSKEYDOWN) {
                ProcessUICues(ref msg);

                Keys keyData = (Keys)(int)msg.WParam | ModifierKeys;
                if (ProcessCmdKey(ref msg, keyData)) {
                    ret = true;
                }
                else if (IsInputKey(keyData)) {
                    ret = false;
                }
                else {
                    IntSecurity.ModifyFocus.Assert();
                    try {
                        ret = ProcessDialogKey(keyData);
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                }
            }
            else if (msg.Msg == NativeMethods.WM_CHAR || msg.Msg == NativeMethods.WM_SYSCHAR) {
                if (msg.Msg == NativeMethods.WM_CHAR && IsInputChar((char)msg.WParam)) {
                    ret = false;
                }
                else {
                    ret = ProcessDialogChar((char)msg.WParam);            
                }
            }
            else {
                ret = false;
            }

            return ret;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ProcessCmdKey"]/*' />
        /// <devdoc>
        ///     <para>
        ///     Processes a command key. This method is called during message
        ///     pre-processing to handle command keys. Command keys are keys that always
        ///     take precedence over regular input keys. Examples of command keys
        ///     include accelerators and menu shortcuts. The method must return true to
        ///     indicate that it has processed the command key, or false to indicate
        ///     that the key is not a command key.
        ///     </para>
        ///     <para>
        /// processCmdKey() first checks if the control has a context menu, and if
        ///     so calls the menu's processCmdKey() to check for menu shortcuts. If the
        ///     command key isn't a menu shortcut, and if the control has a parent, the
        ///     key is passed to the parent's processCmdKey() method. The net effect is
        ///     that command keys are "bubbled" up the control hierarchy.
        ///     </para>
        ///     <para>
        /// When overriding processCmdKey(), a control should return true to
        ///     indicate that it has processed the key. For keys that aren't processed by
        ///     the control, the result of "base.processCmdKey()" should be returned.
        ///     </para>
        ///     <para>
        /// Controls will seldom, if ever, need to override this method.
        ///     </para>
        /// </devdoc>
        [
            SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode),
            SecurityPermission(SecurityAction.InheritanceDemand, Flags=SecurityPermissionFlag.UnmanagedCode)
        ]
        protected virtual bool ProcessCmdKey(ref Message msg, Keys keyData) {
            Debug.WriteLineIf(ControlKeyboardRouting.TraceVerbose, "Control.ProcessCmdKey " + msg.ToString());
            ContextMenu contextMenu = (ContextMenu)Properties.GetObject(PropContextMenu);
            if (contextMenu != null && contextMenu.ProcessCmdKey(ref msg, keyData)) {
                return true;
            }

            return parent == null ? false : parent.ProcessCmdKey(ref msg, keyData);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ProcessDialogChar"]/*' />
        /// <devdoc>
        ///     <para>
        ///     Processes a dialog character. This method is called during message
        ///     pre-processing to handle dialog characters, such as control mnemonics.
        ///     This method is called only if the isInputChar() method indicates that
        ///     the control isn't interested in the character.
        ///     </para>
        ///     <para>
        /// processDialogChar() simply sends the character to the parent's
        ///     processDialogChar() method, or returns false if the control has no
        ///     parent. The Form class overrides this method to perform actual
        ///     processing of dialog characters.
        ///     </para>
        ///     <para>
        /// When overriding processDialogChar(), a control should return true to
        ///     indicate that it has processed the character. For characters that aren't
        ///     processed by the control, the result of "base.processDialogChar()"
        ///     should be returned.
        ///     </para>
        ///     <para>
        /// Controls will seldom, if ever, need to override this method.
        ///     </para>
        /// </devdoc>
        [UIPermission(SecurityAction.InheritanceDemand, Window=UIPermissionWindow.AllWindows)]
        protected virtual bool ProcessDialogChar(char charCode) {
            Debug.WriteLineIf(ControlKeyboardRouting.TraceVerbose, "Control.ProcessDialogChar [" + charCode.ToString() + "]");
            return parent == null? false: parent.ProcessDialogChar(charCode);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ProcessDialogKey"]/*' />
        /// <devdoc>
        ///     <para>
        ///     Processes a dialog key. This method is called during message
        ///     pre-processing to handle dialog characters, such as TAB, RETURN, ESCAPE,
        ///     and arrow keys. This method is called only if the isInputKey() method
        ///     indicates that the control isn't interested in the key.
        ///     </para>
        ///     <para>
        /// processDialogKey() simply sends the character to the parent's
        ///     processDialogKey() method, or returns false if the control has no
        ///     parent. The Form class overrides this method to perform actual
        ///     processing of dialog keys.
        ///     </para>
        ///     <para>
        /// When overriding processDialogKey(), a control should return true to
        ///     indicate that it has processed the key. For keys that aren't processed
        ///     by the control, the result of "base.processDialogChar()" should be
        ///     returned.
        ///     </para>
        ///     <para>
        /// Controls will seldom, if ever, need to override this method.
        ///     </para>
        /// </devdoc>
        [UIPermission(SecurityAction.InheritanceDemand, Window=UIPermissionWindow.AllWindows)]
        protected virtual bool ProcessDialogKey(Keys keyData) {
            Debug.WriteLineIf(ControlKeyboardRouting.TraceVerbose, "Control.ProcessDialogKey " + keyData.ToString());
            return parent == null? false: parent.ProcessDialogKey(keyData);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ProcessKeyEventArgs"]/*' />
        /// <devdoc>
        ///     <para>
        ///     Processes a key message. This method is called when a control receives a
        ///     keyboard message. The method is responsible for generating the appropriate
        ///     key events for the message by calling OnKeyPress(), onKeyDown(), or
        ///     onKeyUp(). The m parameter contains the window message that must
        ///     be processed. Possible values for the m.msg field are WM_CHAR,
        ///     WM_KEYDOWN, WM_SYSKEYDOWN, WM_KEYUP, WM_SYSKEYUP, and WM_IMECHAR.
        ///     </para>
        ///     <para>
        /// When overriding processKeyEventArgs(), a control should return true to
        ///     indicate that it has processed the key. For keys that aren't processed
        ///     by the control, the result of "base.processKeyEventArgs()" should be
        ///     returned.
        ///     </para>
        ///     <para>
        /// Controls will seldom, if ever, need to override this method.
        ///     </para>
        /// </devdoc>
        [
            SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode),
            SecurityPermission(SecurityAction.InheritanceDemand, Flags=SecurityPermissionFlag.UnmanagedCode)
        ]
        protected virtual bool ProcessKeyEventArgs(ref Message m) {
            Debug.WriteLineIf(ControlKeyboardRouting.TraceVerbose, "Control.ProcessKeyEventArgs " + m.ToString());
            KeyEventArgs ke = null;
            KeyPressEventArgs kpe = null;

            if (m.Msg == NativeMethods.WM_CHAR || m.Msg == NativeMethods.WM_SYSCHAR) {
                int charsToIgnore = Properties.GetInteger(PropCharsToIgnore);
                
                if (charsToIgnore > 0) {
                    charsToIgnore--;
                    
                    Properties.SetInteger(PropCharsToIgnore, charsToIgnore);
                    return false;
                }
                else {
                    kpe = new KeyPressEventArgs((char)m.WParam);
                    OnKeyPress(kpe);
                }
            }
            else if (m.Msg == NativeMethods.WM_IME_CHAR) {
                int charsToIgnore = Properties.GetInteger(PropCharsToIgnore);
                
                charsToIgnore += (3 - Marshal.SystemDefaultCharSize);
                Properties.SetInteger(PropCharsToIgnore, charsToIgnore);
                
                if (Marshal.SystemDefaultCharSize == 1) {
                    // On Win9X we get the MBCS value... we must convert it to
                    // UNICODE...
                    //
                    byte[] b = new byte[] {(byte)((int)m.WParam >> 8), (byte)m.WParam};
                    string s = Encoding.Default.GetString(b);
                    kpe = new KeyPressEventArgs((char)s[0]);
                }
                else {
                    kpe = new KeyPressEventArgs((char)m.WParam);
                }
                OnKeyPress(kpe);
            }
            else {
                ke = new KeyEventArgs((Keys)((int)m.WParam) | ModifierKeys);
                if (m.Msg == NativeMethods.WM_KEYDOWN || m.Msg == NativeMethods.WM_SYSKEYDOWN) {
                    OnKeyDown(ke);
                }
                else {
                    OnKeyUp(ke);
                }
            }

            if (kpe != null) {
                Debug.WriteLineIf(ControlKeyboardRouting.TraceVerbose, "    processkeyeventarg returning: " + kpe.Handled);
                return kpe.Handled;
            }
            else {
                Debug.WriteLineIf(ControlKeyboardRouting.TraceVerbose, "    processkeyeventarg returning: " + ke.Handled);
                return ke.Handled;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ProcessKeyMessage"]/*' />
        /// <devdoc>
        ///     Processes a key message. This method is called when a control receives a
        ///     keyboard message. The method first checks if the control has a parent,
        ///     and if so calls the parent's processKeyPreview() method. If the parent's
        ///     processKeyPreview() method doesn't consume the message then
        ///     processKeyEventArgs() is called to generate the appropriate keyboard events.
        ///     The m parameter contains the window message that must be
        ///     processed. Possible values for the m.msg field are WM_CHAR,
        ///     WM_KEYDOWN, WM_SYSKEYDOWN, WM_KEYUP, and WM_SYSKEYUP.
        /// When overriding processKeyMessage(), a control should return true to
        ///     indicate that it has processed the key. For keys that aren't processed
        ///     by the control, the result of "base.processKeyMessage()" should be
        ///     returned.
        /// Controls will seldom, if ever, need to override this method.
        /// </devdoc>
        [
            SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode),
            SecurityPermission(SecurityAction.InheritanceDemand, Flags=SecurityPermissionFlag.UnmanagedCode)
        ]
        protected internal virtual bool ProcessKeyMessage(ref Message m) {
            Debug.WriteLineIf(ControlKeyboardRouting.TraceVerbose, "Control.ProcessKeyMessage " + m.ToString());
            if (parent != null && parent.ProcessKeyPreview(ref m)) return true;
            return ProcessKeyEventArgs(ref m);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ProcessKeyPreview"]/*' />
        /// <devdoc>
        ///     <para>
        ///     Previews a keyboard message. This method is called by a child control
        ///     when the child control receives a keyboard message. The child control
        ///     calls this method before generating any keyboard events for the message.
        ///     If this method returns true, the child control considers the message
        ///     consumed and does not generate any keyboard events. The m
        ///     parameter contains the window message to preview. Possible values for
        ///     the m.msg field are WM_CHAR, WM_KEYDOWN, WM_SYSKEYDOWN, WM_KEYUP,
        ///     and WM_SYSKEYUP.
        ///     </para>
        ///     <para>
        /// processKeyPreview() simply sends the character to the parent's
        ///     processKeyPreview() method, or returns false if the control has no
        ///     parent. The Form class overrides this method to perform actual
        ///     processing of dialog keys.
        ///     </para>
        ///     <para>
        /// When overriding processKeyPreview(), a control should return true to
        ///     indicate that it has processed the key. For keys that aren't processed
        ///     by the control, the result of "base.processKeyEventArgs()" should be
        ///     returned.
        ///     </para>
        /// </devdoc>
        [
            SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode),
            SecurityPermission(SecurityAction.InheritanceDemand, Flags=SecurityPermissionFlag.UnmanagedCode)
        ]
        protected virtual bool ProcessKeyPreview(ref Message m) {
            Debug.WriteLineIf(ControlKeyboardRouting.TraceVerbose, "Control.ProcessKeyPreview " + m.ToString());
            return parent == null? false: parent.ProcessKeyPreview(ref m);
        }

        /*C#r*/internal bool _ProcessMnemonic(char charCode) {
            Debug.WriteLineIf(ControlKeyboardRouting.TraceVerbose, "Control._ProcessMnemonic 0x" + ((int)charCode).ToString("X"));
            return ProcessMnemonic(charCode);
        }
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ProcessMnemonic"]/*' />
        /// <devdoc>
        ///     <para>
        ///     Processes a mnemonic character. This method is called to give a control
        ///     the opportunity to process a mnemonic character. The method should check
        ///     if the control is in a state to process mnemonics and if the given
        ///     character represents a mnemonic. If so, the method should perform the
        ///     action associated with the mnemonic and return true. If not, the method
        ///     should return false.
        ///     </para>
        ///     <para>
        /// Implementations of this method often use the isMnemonic() method to
        ///     check if the given character matches a mnemonic in the control's text,
        ///     for example:
        /// <code>
        ///     if (canSelect() &amp;&amp; isMnemonic(charCode, getText()) {
        ///     // perform action associated with mnemonic
        ///     }
        /// </code>
        ///     </para>
        ///     <para>
        /// This default implementation of processMnemonic() simply returns false
        ///     to indicate that the control has no mnemonic.
        ///     </para>
        /// </devdoc>
        [UIPermission(SecurityAction.InheritanceDemand, Window=UIPermissionWindow.AllWindows)]
        protected virtual bool ProcessMnemonic(char charCode) {
#if DEBUG        
            Debug.WriteLineIf(ControlKeyboardRouting.TraceVerbose, "Control.ProcessMnemonic [0x" + ((int)charCode).ToString("X") + "]");
#endif            
            return false;
        }

        /// <devdoc>
        ///     Preprocess keys which affect focus indicators and keyboard cues.
        /// </devdoc>
        private void ProcessUICues(ref Message msg) {
            Keys keyCode = (Keys)((int)msg.WParam) & Keys.KeyCode;
            int current = (int)SendMessage(NativeMethods.WM_QUERYUISTATE, 0, 0);
            int toClear = 0;

            if (keyCode == Keys.F10 || keyCode == Keys.Menu) {
                if ((current & NativeMethods.UISF_HIDEACCEL) != 0) {
                    toClear |= NativeMethods.UISF_HIDEACCEL;
                }
            }

            if (keyCode == Keys.Tab) {
                if ((current & NativeMethods.UISF_HIDEFOCUS) != 0) {
                    toClear |= NativeMethods.UISF_HIDEFOCUS;
                }
            }

            if (toClear != 0) {
                UnsafeNativeMethods.SendMessage(new HandleRef(TopMostParent, TopMostParent.Handle), 
                                                NativeMethods.WM_UPDATEUISTATE, 
                                                (IntPtr)(NativeMethods.UIS_CLEAR | (toClear << 16)),
                                                IntPtr.Zero);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.RaiseDragEvent"]/*' />
        /// <devdoc>
        ///     Raises the event associated with key with the event data of
        ///     e and a sender of this control.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected void RaiseDragEvent(Object key, DragEventArgs e) {
            DragEventHandler handler = (DragEventHandler)Events[key];
            if (handler != null) handler(this, e);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.RaisePaintEvent"]/*' />
        /// <devdoc>
        ///     Raises the event associated with key with the event data of
        ///     e and a sender of this control.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected void RaisePaintEvent(Object key, PaintEventArgs e) {
            PaintEventHandler handler = (PaintEventHandler)Events[EventPaint];
            if (handler != null) handler(this, e);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ResetBackColor"]/*' />
        /// <devdoc>
        ///     Resets the back color to be based on the parent's back color.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public virtual void ResetBackColor() {
            BackColor = Color.Empty;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ResetCursor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public virtual void ResetCursor() {
            Cursor = null;
        }
        
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ResetFont"]/*' />
        /// <devdoc>
        ///     Resets the font to be based on the parent's font.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public virtual void ResetFont() {
            Font = null;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ResetForeColor"]/*' />
        /// <devdoc>
        ///     Resets the fore color to be based on the parent's fore color.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public virtual void ResetForeColor() {
            ForeColor = Color.Empty;
        }
        
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ResetImeMode"]/*' />
        /// <devdoc>
        ///     Resets the Ime mode.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public void ResetImeMode() {
            ImeMode = DefaultImeMode;
        }
        
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ResetRightToLeft"]/*' />
        /// <devdoc>
        ///     Resets the RightToLeft to be the default.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public virtual void ResetRightToLeft() {
            RightToLeft = RightToLeft.Inherit;
        }
        
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.RecreateHandle"]/*' />
        /// <devdoc>
        ///     Forces the recreation of the handle for this control. Inheriting controls
        ///     must call base.RecreateHandle.
        /// </devdoc>
        [
        EditorBrowsable(EditorBrowsableState.Advanced)
        ]
        protected void RecreateHandle() {
            RecreateHandleCore();
        }
        
        internal virtual void RecreateHandleCore() {
            lock(this) {
                if (window.Handle != IntPtr.Zero) {

                    bool focused = ContainsFocus;

#if DEBUG
                    if (CoreSwitches.PerfTrack.Enabled) {
                        Debug.Write("RecreateHandle: ");
                        Debug.Write(GetType().FullName);
                        Debug.Write(" [Text=");
                        Debug.Write(Text);
                        Debug.Write("]");
                        Debug.WriteLine("");
                    }
#endif
                    bool created = (state & STATE_CREATED) != 0;
                    if (GetState(STATE_TRACKINGMOUSEEVENT)) {
                        SetState(STATE_MOUSEENTERPENDING, true);
                        UnhookMouseEvent();
                    }

                    state |= STATE_RECREATE;
                    try {
                        DestroyHandle();
                        CreateHandle();
                    }
                    finally {
                        state &= ~STATE_RECREATE;
                    }
                    if (created) CreateControl();

                    // Restore control focus
                    if (focused) {
                        FocusInternal();
                    }
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.RectangleToClient"]/*' />
        /// <devdoc>
        ///     Computes the location of the screen rectangle r in client coords.
        /// </devdoc>
        public Rectangle RectangleToClient(Rectangle r) {
            // SECREVIEW : verify it is OK to skip this demand
            //
            // Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "ScreenLocationOfThings Demanded");
            // IntSecurity.ScreenLocationOfThings.Demand();

            NativeMethods.RECT rect = NativeMethods.RECT.FromXYWH(r.X, r.Y, r.Width, r.Height);
            UnsafeNativeMethods.MapWindowPoints(NativeMethods.NullHandleRef, new HandleRef(this, Handle), ref rect, 2);
            return Rectangle.FromLTRB(rect.left, rect.top, rect.right, rect.bottom);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.RectangleToScreen"]/*' />
        /// <devdoc>
        ///     Computes the location of the client rectangle r in screen coords.
        /// </devdoc>
        public Rectangle RectangleToScreen(Rectangle r) {
            // SECREVIEW : verify it is OK to skip this demand
            //
            // Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "ScreenLocationOfThings Demanded");
            // IntSecurity.ScreenLocationOfThings.Demand();

            NativeMethods.RECT rect = NativeMethods.RECT.FromXYWH(r.X, r.Y, r.Width, r.Height);
            UnsafeNativeMethods.MapWindowPoints(new HandleRef(this, Handle), NativeMethods.NullHandleRef, ref rect, 2);
            return Rectangle.FromLTRB(rect.left, rect.top, rect.right, rect.bottom);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ReflectMessage"]/*' />
        /// <devdoc>
        ///     Reflects the specified message to the control that is bound to hWnd.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected static bool ReflectMessage(IntPtr hWnd, ref Message m) {
            Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "SendMessages Demanded");
            IntSecurity.SendMessages.Demand();
            return ReflectMessageInternal(hWnd, ref m);
        }

        internal static bool ReflectMessageInternal(IntPtr hWnd, ref Message m) {
            Control control = Control.FromHandleInternal(hWnd);
            if (control == null) return false;
            m.Result = control.SendMessage(NativeMethods.WM_REFLECT + m.Msg, m.WParam, m.LParam);
            return true;
        }

        

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Refresh"]/*' />
        /// <devdoc>
        ///     Forces the control to invalidate and immediately
        ///     repaint itself and any children.
        /// </devdoc>
        public virtual void Refresh() {
            Invalidate(true);
            Update();
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ResetMouseEventArgs"]/*' />
        /// <devdoc>
        ///     Resets the mouse leave listeners.
        /// </devdoc>
        /// <internalonly/>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected void ResetMouseEventArgs() {
            if (GetState(STATE_TRACKINGMOUSEEVENT)) {
                UnhookMouseEvent();
                HookMouseEvent();
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ResetText"]/*' />
        /// <devdoc>
        ///     Resets the text to it's default value.
        /// </devdoc>
        public virtual void ResetText() {
            Text = "";
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ResumeLayout"]/*' />
        /// <devdoc>
        ///     Resumes normal layout logic. This will force a layout immediately
        ///     if there are any pending layout requests.
        /// </devdoc>
        public void ResumeLayout() {
            ResumeLayout(true);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ResumeLayout1"]/*' />
        /// <devdoc>
        ///     Resumes normal layout logic. If performLayout is set to true then
        ///     this will force a layout immediately if there are any pending layout requests.
        /// </devdoc>
        public void ResumeLayout(bool performLayout) {
            Debug.WriteLineIf(CompModSwitches.RichLayout.TraceInfo, GetType().Name + "::ResumeLayout(" + performLayout + ", " + layoutSuspendCount + ")");
            Debug.Assert(layoutSuspendCount > 0, "unbalanance suspend/resume layout");

            if (layoutSuspendCount > 0) {
                layoutSuspendCount--;
                if (layoutSuspendCount == 0
                    && (state & STATE_LAYOUTDEFERRED) != 0
                    && performLayout) {
                    PerformLayout();
                }
            }

            if (!performLayout) {
                ControlCollection controlsCollection = (ControlCollection)Properties.GetObject(PropControlsCollection);

                // PERFNOTE: This is more efficient than using Foreach.  Foreach 
                // forces the creation of an array subset enum each time we
                // enumerate
                if (controlsCollection != null) {
                    for (int i = 0; i < controlsCollection.Count; i++) {
                        LayoutManager.UpdateAnchorInfo(controlsCollection[i]);
                    }
                }
            }
        }

        /// <devdoc>
        ///     Used to actually register the control as a drop target.
        /// </devdoc>
        /// <internalonly/>
        internal void SetAcceptDrops(bool accept) {
            if (accept != GetState(STATE_DROPTARGET) && IsHandleCreated) {
                try {
                    if (Application.OleRequired() != System.Threading.ApartmentState.STA) {
                        throw new ThreadStateException(SR.GetString(SR.ThreadMustBeSTA));
                    }
                    if (accept) {
                        IntSecurity.ClipboardRead.Demand();

                        Debug.WriteLineIf(CompModSwitches.DragDrop.TraceInfo, "Registering as drop target: " + Handle.ToString());
                        // Register
                        int n = UnsafeNativeMethods.RegisterDragDrop(new HandleRef(this, Handle), (UnsafeNativeMethods.IOleDropTarget)(new DropTarget(this)));
                        Debug.WriteLineIf(CompModSwitches.DragDrop.TraceInfo, "   ret:" + n.ToString());
                        if (n != 0 && n != NativeMethods.DRAGDROP_E_ALREADYREGISTERED) {
                            throw new Win32Exception(n);
                        }
                    }
                    else {
                        Debug.WriteLineIf(CompModSwitches.DragDrop.TraceInfo, "Revoking drop target: " + Handle.ToString());
                        // Revoke
                        int n = UnsafeNativeMethods.RevokeDragDrop(new HandleRef(this, Handle));
                        Debug.WriteLineIf(CompModSwitches.DragDrop.TraceInfo, "   ret:" + n.ToString());
                        if (n != 0 && n != NativeMethods.DRAGDROP_E_NOTREGISTERED) {
                            throw new Win32Exception(n);
                        }
                    }
                    SetState(STATE_DROPTARGET, accept);
                }
                catch (Exception e) {
                    throw new InvalidOperationException(SR.GetString(SR.DragDropRegFailed), e);
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Scale"]/*' />
        /// <devdoc>
        ///     Scales to entire control and any child controls.
        /// </devdoc>
        public void Scale(float ratio) {
            ScaleCore(ratio, ratio);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Scale1"]/*' />
        /// <devdoc>
        ///     Scales the entire control and any child controls.
        /// </devdoc>
        public void Scale(float dx, float dy) {
#if DEBUG
        int dbgLayoutCheck = LayoutSuspendCount;
#endif
            SuspendLayout();
            try {
                ScaleCore(dx, dy);
            }
            finally {
                ResumeLayout();
#if DEBUG
        AssertLayoutSuspendCount(dbgLayoutCheck);
#endif
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ScaleCore"]/*' />
        /// <devdoc>
        ///     Performs the work of scaling the entire control and any child controls.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void ScaleCore(float dx, float dy) {
            Debug.WriteLineIf(CompModSwitches.RichLayout.TraceInfo, GetType().Name + "::ScaleCore(" + dx + ", " + dy + ")");
#if DEBUG
        int dbgLayoutCheck = LayoutSuspendCount;
#endif
            SuspendLayout();
            try {
                float xAdjust;
                float yAdjust;
                if (x < 0) {
                    xAdjust = -0.5f;
                }
                else {
                    xAdjust = 0.5f;
                }
                if (y < 0) {
                    yAdjust = -0.5f;
                }
                else {
                    yAdjust = 0.5f;
                }
                int sx = (int)(x * dx + xAdjust);
                int sy = (int)(y * dy + yAdjust);
                int sw = width;
                if ((controlStyle & ControlStyles.FixedWidth) != ControlStyles.FixedWidth) {
                    sw = (int)((x + width) * dx + 0.5f) - sx;
                }
                int sh = height;
                if ((controlStyle & ControlStyles.FixedHeight) != ControlStyles.FixedHeight) {
                    sh = (int)((y + height) * dy + 0.5f) - sy;
                }
                SetBounds(sx, sy, sw, sh, BoundsSpecified.All);
                
                ControlCollection controlsCollection = (ControlCollection)Properties.GetObject(PropControlsCollection);
                
                if (controlsCollection != null) {
                    // PERFNOTE: This is more efficient than using Foreach.  Foreach 
                    // forces the creation of an array subset enum each time we
                    // enumerate
                    for(int i = 0; i < controlsCollection.Count; i++) {
                        controlsCollection[i].Scale(dx, dy);
                    }
                }
            }
            finally {
                ResumeLayout();
#if DEBUG
        AssertLayoutSuspendCount(dbgLayoutCheck);
#endif
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Select"]/*' />
        /// <devdoc>
        ///     Activates this control.
        /// </devdoc>
        public void Select() {
            Select(false, false);
        }

        // used by Form
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Select1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void Select(bool directed, bool forward) {
            IContainerControl c = GetContainerControlInternal();

            if (c != null) {
                c.ActiveControl = this;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.SelectNextControl"]/*' />
        /// <devdoc>
        ///     Selects the next control following ctl.
        /// </devdoc>
        public bool SelectNextControl(Control ctl, bool forward, bool tabStopOnly,
                                      bool nested, bool wrap) {

            if (!Contains(ctl) || !nested && ctl.parent != this) ctl = null;
            Control start = ctl;
            do {
                ctl = GetNextControl(ctl, forward);
                if (ctl == null) {
                    if (!wrap) break;
                }
                else {
                    if (ctl.CanSelect
                        && (!tabStopOnly || ctl.TabStop)
                        && (nested || ctl.parent == this)) {

                        ctl.Select(true, forward);
                        return true;
                    }
                }
            } while (ctl != start);
            return false;
        }

        /// <devdoc>
        ///     This is called recursively when visibility is changed for a control, this
        ///     forces focus to be moved to a visible control.
        /// </devdoc>
        private bool SelectNextIfFocused() {
            // V#32437 - We want to move focus away from hidden controls, so this
            //           function was added.
            //
            if (ContainsFocus && ParentInternal != null) {
                IContainerControl c = ParentInternal.GetContainerControlInternal();

                if (c != null) {
                    IntSecurity.ModifyFocus.Assert();
                    try {
                        ((Control)c).SelectNextControl(this, true, true, true, true);
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                }

                return true;
            }
            return false;
        }

        /// <devdoc>
        ///     Sends a Win32 message to this control.  If the control does not yet
        ///     have a handle, it will be created.
        /// </devdoc>
        internal IntPtr SendMessage(int msg, int wparam, int lparam) {
            Debug.Assert(IsHandleCreated, "Performance alert!  Calling Control::SendMessage and forcing handle creation.  Re-work control so handle creation is not required to set properties.  If there is no work around, wrap the call in an IsHandleCreated check.");
            return UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), msg, wparam, lparam);
        }

        /// <devdoc>
        ///     Sends a Win32 message to this control.  If the control does not yet
        ///     have a handle, it will be created.
        /// </devdoc>
        internal IntPtr SendMessage(int msg, ref short wparam, ref short lparam) {
            Debug.Assert(IsHandleCreated, "Performance alert!  Calling Control::SendMessage and forcing handle creation.  Re-work control so handle creation is not required to set properties.  If there is no work around, wrap the call in an IsHandleCreated check.");
            return UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), msg, ref wparam, ref lparam);
        }
        internal IntPtr SendMessage(int msg, int wparam, IntPtr lparam) {
            Debug.Assert(IsHandleCreated, "Performance alert!  Calling Control::SendMessage and forcing handle creation.  Re-work control so handle creation is not required to set properties.  If there is no work around, wrap the call in an IsHandleCreated check.");
            return UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), msg, (IntPtr)wparam, lparam);
        }
        
        internal IntPtr SendMessage(int msg, IntPtr wparam, IntPtr lparam) {
            Debug.Assert(IsHandleCreated, "Performance alert!  Calling Control::SendMessage and forcing handle creation.  Re-work control so handle creation is not required to set properties.  If there is no work around, wrap the call in an IsHandleCreated check.");
            return UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), msg, wparam, lparam);
        }
        
        internal IntPtr SendMessage(int msg, IntPtr wparam, int lparam) {
            Debug.Assert(IsHandleCreated, "Performance alert!  Calling Control::SendMessage and forcing handle creation.  Re-work control so handle creation is not required to set properties.  If there is no work around, wrap the call in an IsHandleCreated check.");
            return UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), msg, wparam, (IntPtr)lparam);
        }

        /// <devdoc>
        ///     Sends a Win32 message to this control.  If the control does not yet
        ///     have a handle, it will be created.
        /// </devdoc>
        internal IntPtr SendMessage(int msg, int wparam, ref NativeMethods.RECT lparam) {
            Debug.Assert(IsHandleCreated, "Performance alert!  Calling Control::SendMessage and forcing handle creation.  Re-work control so handle creation is not required to set properties.  If there is no work around, wrap the call in an IsHandleCreated check.");
            return UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), msg, wparam, ref lparam);
        }
        
        /// <devdoc>
        ///     Sends a Win32 message to this control.  If the control does not yet
        ///     have a handle, it will be created.
        /// </devdoc>
        internal IntPtr SendMessage(int msg, bool wparam, int lparam) {
            Debug.Assert(IsHandleCreated, "Performance alert!  Calling Control::SendMessage and forcing handle creation.  Re-work control so handle creation is not required to set properties.  If there is no work around, wrap the call in an IsHandleCreated check.");
            return UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), msg, wparam, lparam);
        }

        /// <devdoc>
        ///     Sends a Win32 message to this control.  If the control does not yet
        ///     have a handle, it will be created.
        /// </devdoc>
        internal IntPtr SendMessage(int msg, int wparam, string lparam) {            
            Debug.Assert(IsHandleCreated, "Performance alert!  Calling Control::SendMessage and forcing handle creation.  Re-work control so handle creation is not required to set properties.  If there is no work around, wrap the call in an IsHandleCreated check.");
            return UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), msg, wparam, lparam);
        }
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.SendToBack"]/*' />
        /// <devdoc>        
        ///     sends this control to the back of the z-order
        /// </devdoc>
        public void SendToBack() {
            if (parent != null) {
                parent.Controls.SetChildIndex(this, -1);
            }
            else if (window.Handle != IntPtr.Zero && GetTopLevel()) {
                SafeNativeMethods.SetWindowPos(new HandleRef(window, window.Handle), NativeMethods.HWND_BOTTOM, 0, 0, 0, 0,
                                               NativeMethods.SWP_NOMOVE | NativeMethods.SWP_NOSIZE);
            }

        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.SetBounds"]/*' />
        /// <devdoc>
        ///     Sets the bounds of the control.
        /// </devdoc>
        public void SetBounds(int x, int y, int width, int height) {
            if (this.x != x || this.y != y || this.width != width ||
                this.height != height) {
                SetBoundsCore(x, y, width, height, BoundsSpecified.All);
                if (parent != null) parent.PerformLayout(this, "Bounds");
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.SetBounds1"]/*' />
        /// <devdoc>
        ///     Sets the bounds of the control.
        /// </devdoc>
        public void SetBounds(int x, int y, int width, int height, BoundsSpecified specified) {
            if ((specified & BoundsSpecified.X) == BoundsSpecified.None) x = this.x;
            if ((specified & BoundsSpecified.Y) == BoundsSpecified.None) y = this.y;
            if ((specified & BoundsSpecified.Width) == BoundsSpecified.None) width = this.width;
            if ((specified & BoundsSpecified.Height) == BoundsSpecified.None) height = this.height;
            if (this.x != x || this.y != y || this.width != width ||
                this.height != height) {
                SetBoundsCore(x, y, width, height, specified);
                if (parent != null) parent.PerformLayout(this, "Bounds");
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.SetBoundsCore"]/*' />
        /// <devdoc>
        ///     Performs the work of setting the bounds of this control. Inheriting
        ///     classes can overide this function to add size restrictions. Inheriting
        ///     classes must call base.setBoundsCore to actually cause the bounds
        ///     of the control to change.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void SetBoundsCore(int x, int y, int width, int height, BoundsSpecified specified) {
            if (this.x != x || this.y != y || this.width != width ||
                this.height != height) {
                if (window.Handle != IntPtr.Zero) {
                    if (!GetState(STATE_SIZELOCKEDBYOS)) {
                        int flags = NativeMethods.SWP_NOZORDER | NativeMethods.SWP_NOACTIVATE;

                        if (this.x == x && this.y == y) {
                            flags |= NativeMethods.SWP_NOMOVE;
                        }
                        if (this.width == width && this.height == height) {
                            flags |= NativeMethods.SWP_NOSIZE;
                        }

                        SafeNativeMethods.SetWindowPos(new HandleRef(window, window.Handle), NativeMethods.NullHandleRef, x, y, width, height, flags);
                    }
                }
                else {
                    UpdateBounds(x, y, width, height);
                }
            }
            
            LayoutInfo layout = (LayoutInfo)Properties.GetObject(PropLayoutInfo);
            
            if (layout != null && layout.IsDock) {
                if ((specified & BoundsSpecified.X) != 0)
                    layout.OriginalX = Left;
                if ((specified & BoundsSpecified.Y) != 0)
                    layout.OriginalY = Top;
                if ((specified & BoundsSpecified.Width) != 0)
                    layout.OriginalWidth = Width;
                if ((specified & BoundsSpecified.Height) != 0)
                    layout.OriginalHeight = Height;
            }

            // If the user has specified bounds for the control, update anchor info
            if (specified != BoundsSpecified.None) {
                if (layout != null && !layout.IsDock) LayoutManager.UpdateAnchorInfo(this);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.SetClientSizeCore"]/*' />
        /// <devdoc>
        ///     Performs the work of setting the size of the client area of the control.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void SetClientSizeCore(int x, int y) {
            NativeMethods.RECT rect = new NativeMethods.RECT(0, 0, x, y);
            CreateParams cp = CreateParams;
            SafeNativeMethods.AdjustWindowRectEx(ref rect, cp.Style, HasMenu, cp.ExStyle);
            Size = new Size(rect.right - rect.left, rect.bottom - rect.top);
            clientWidth = x;
            clientHeight = y;
        }

        private void SetHandle(IntPtr value) {
            if (value == IntPtr.Zero) {
                SetState(STATE_CREATED, false);
            }
            UpdateRoot();
        }

        private void SetParentHandle(IntPtr value) {
            Debug.Assert(value != NativeMethods.InvalidIntPtr, "Outdated call to SetParentHandle");

            if (window.Handle != IntPtr.Zero) {
                IntPtr parentHandle = UnsafeNativeMethods.GetParent(new HandleRef(window, window.Handle));

                if (parentHandle != value || (parentHandle == IntPtr.Zero && !GetTopLevel())) {
                    Debug.Assert(window.Handle != value, "Cycle created in SetParentHandle");

                    bool topLevel = GetTopLevel();
                    bool recreate = (parentHandle == IntPtr.Zero && !topLevel)
                            || (value == IntPtr.Zero && topLevel);

                    if (recreate) {
                        // We will recreate later, when the MdiChild's visibility
                        // is set to true (see bug 124232)
                        Form f = this as Form;
                        if (f != null) {
                            if (f.IsMdiChildAndNotVisible) {
                                recreate = false;
                            }
                        }
                    }

                    if (recreate) {
                        RecreateHandle();
                    }
                    if (!GetTopLevel()) {
                        if (value == IntPtr.Zero) {
                            UnsafeNativeMethods.SetParent(new HandleRef(window, window.Handle), new HandleRef(Application.GetParkingWindow(this), Application.GetParkingWindow(this).Handle));
                            UpdateRoot();
                        }
                        else {
                            UnsafeNativeMethods.SetParent(new HandleRef(window, window.Handle), new HandleRef(null, value));
                            if (parent != null) {
                                parent.UpdateChildZOrder(this);
                            }
                        }
                    }
                }
            }
        }

        // Form, UserControl, AxHost usage
        internal void SetState(int flag, bool value) {
            state = value? state | flag: state & ~flag;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.SetStyle"]/*' />
        /// <devdoc>
        ///     Sets the current value of the specified bit in the control's style.
        ///     NOTE: This is control style, not the Win32 style of the hWnd.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected void SetStyle(ControlStyles flag, bool value) {
            // WARNING: if we ever add argument checking to "flag", we will need
            // to move private styles like Layered to State.
            controlStyle = value? controlStyle | flag: controlStyle & ~flag;
        }

        internal static IntPtr SetUpPalette(IntPtr dc, bool force, bool realizePalette) {
            Debug.WriteLineIf(Control.PaletteTracing.TraceVerbose, "SetUpPalette(force:=" + force + ", ralizePalette:=" + realizePalette + ")");

            IntPtr halftonePalette = Graphics.GetHalftonePalette();
            
            Debug.WriteLineIf(Control.PaletteTracing.TraceVerbose, "select palette " + !force);
            IntPtr result = SafeNativeMethods.SelectPalette(new HandleRef(null, dc), new HandleRef(null, halftonePalette), (force ? 0 : 1));

            if (result != IntPtr.Zero && realizePalette) {
                SafeNativeMethods.RealizePalette(new HandleRef(null, dc));
            }

            return result;
        }
        
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.SetTopLevel"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void SetTopLevel(bool value) {
            if (value && IsActiveX) {
                throw new InvalidOperationException(SR.GetString(SR.TopLevelNotAllowedIfActiveX));
            }
            else {
                if (value) {
                    if (this is Form) { 
                        Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "TopLevelWindow Demanded");
                        IntSecurity.TopLevelWindow.Demand();
                    }
                    else {
                        Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "UnrestrictedWindows Demanded");
                        IntSecurity.UnrestrictedWindows.Demand();
                    }
                }

                if (GetTopLevel() != value) {
                    if (parent != null) {
                        throw new ArgumentException(SR.GetString(SR.TopLevelParentedControl), "value");
                    }
                    SetState(STATE_TOPLEVEL, value);
                    SetParentHandle(IntPtr.Zero);
                    if (value && Visible) CreateControl();
                    UpdateRoot();
                }
            }
        }
        
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.SetVisibleCore"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void SetVisibleCore(bool value) {
            if (GetVisibleCore() != value) {
                if (!value) {
                    SelectNextIfFocused();
                }
    
                bool fireChange = false;
                
                if (GetTopLevel()) {
    
                    // The processing of WmShowWindow will set the visibility
                    // bit and call CreateControl()
                    //
                    if (window.Handle != IntPtr.Zero || value) {
                        SafeNativeMethods.ShowWindow(new HandleRef(this, Handle), value ? ShowParams: NativeMethods.SW_HIDE);
                    }
                }
                else if (window.Handle != IntPtr.Zero || value && parent != null && parent.Created) {
    
                    // We want to mark the control as visible so that CreateControl
                    // knows that we are going to be displayed... however in case
                    // an exception is thrown, we need to back the change out.
                    //
                    SetState(STATE_VISIBLE, value);
                    fireChange = true;
                    try {
                        if (value) CreateControl();
                        SafeNativeMethods.SetWindowPos(new HandleRef(window, window.Handle), 
                                                       NativeMethods.NullHandleRef, 
                                                       0, 0, 0, 0, 
                                                       NativeMethods.SWP_NOSIZE 
                                                       | NativeMethods.SWP_NOMOVE 
                                                       | NativeMethods.SWP_NOZORDER 
                                                       | NativeMethods.SWP_NOACTIVATE 
                                                       | (value? NativeMethods.SWP_SHOWWINDOW: NativeMethods.SWP_HIDEWINDOW));
                    }
                    catch (Exception e) {
                        SetState(STATE_VISIBLE, !value);
                        throw e;
                    }
                }
                if (GetVisibleCore() != value) {
                    SetState(STATE_VISIBLE, value);
                    fireChange = true;
                }
                if (fireChange) {
                    OnVisibleChanged(EventArgs.Empty);
                    
                    // We do not do this in the OnPropertyChanged event for visible
                    // Lots of things could cause us to become visible, including a
                    // parent window.  We do not want to indescriminiately layout
                    // due to this, but we do want to layout if the user changed
                    // our visibility.
                    //
                    if (parent != null) parent.PerformLayout(this, "Visible");
                }
                UpdateRoot();
            }
            else { // value of Visible property not changed, but raw bit may have
                SetState(STATE_VISIBLE, value);
    
                // If the handle is already created, we need to update the window style.
                // This situation occurs when the parent control is not currently visible,
                // but the child control has already been created.
                //
                if (IsHandleCreated) {
                    SafeNativeMethods.SetWindowPos(
                                                      new HandleRef(window, window.Handle), NativeMethods.NullHandleRef, 0, 0, 0, 0, NativeMethods.SWP_NOSIZE |
                                                      NativeMethods.SWP_NOMOVE | NativeMethods.SWP_NOZORDER | NativeMethods.SWP_NOACTIVATE |
                                                      (value? NativeMethods.SWP_SHOWWINDOW: NativeMethods.SWP_HIDEWINDOW));
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ShouldSerializeBackColor"]/*' />
        /// <devdoc>
        ///     Returns true if the backColor should be persisted in code gen.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal virtual bool ShouldSerializeBackColor() {
            object backColor = Properties.GetObject(PropBackColor);
            return backColor != null && !((Color)backColor).IsEmpty;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ShouldSerializeCursor"]/*' />
        /// <devdoc>
        ///     Returns true if the cursor should be persisted in code gen.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal virtual bool ShouldSerializeCursor() {
            bool found;
            object cursor = Properties.GetObject(PropCursor, out found);
            return (found && cursor != null);
        }

        /// <devdoc>
        ///     Returns true if the enabled property should be persisted in code gen.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Never)]
        private bool ShouldSerializeEnabled() {
            return (!GetState(STATE_ENABLED));
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ShouldSerializeForeColor"]/*' />
        /// <devdoc>
        ///     Returns true if the foreColor should be persisted in code gen.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal virtual bool ShouldSerializeForeColor() {
            object foreColor = Properties.GetObject(PropForeColor);
            return foreColor != null && !((Color)foreColor).IsEmpty;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ShouldSerializeFont"]/*' />
        /// <devdoc>
        ///     Returns true if the font should be persisted in code gen.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal virtual bool ShouldSerializeFont() {
            bool found;
            object font = Properties.GetObject(PropFont, out found);
            return (found && font != null);
        }
        
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ShouldSerializeImeMode"]/*' />
        /// <devdoc>
        ///     Returns true if the ImeMode should be persisted in code gen.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal virtual bool ShouldSerializeImeMode() {
            bool found;
            int imeMode = Properties.GetInteger(PropImeMode, out found);
            
            return (found && imeMode != (int)DefaultImeMode);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ShouldSerializeRightToLeft"]/*' />
        /// <devdoc>
        ///     Returns true if the RightToLeft should be persisted in code gen.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal virtual bool ShouldSerializeRightToLeft() {
            bool found;
            int rtl = Properties.GetInteger(PropRightToLeft, out found);
            return (found && rtl != (int)RightToLeft.Inherit);
        }

        /// <devdoc>
        ///     Returns true if the visible property should be persisted in code gen.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Never)]
        private bool ShouldSerializeVisible() {
            return (!GetState(STATE_VISIBLE));
        }

        // Helper function - translates text alignment for Rtl controls
        // Read TextAlign as Left == Near, Right == Far
        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.RtlTranslateAlignment"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected HorizontalAlignment RtlTranslateAlignment(HorizontalAlignment align) {
            return RtlTranslateHorizontal(align);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.RtlTranslateAlignment1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected LeftRightAlignment RtlTranslateAlignment(LeftRightAlignment align) {
            return RtlTranslateLeftRight(align);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.RtlTranslateAlignment2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected ContentAlignment RtlTranslateAlignment(ContentAlignment align) {
            return RtlTranslateContent(align);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.RtlTranslateHorizontal"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected HorizontalAlignment RtlTranslateHorizontal(HorizontalAlignment align) {

            if (RightToLeft.Yes == RightToLeft && RenderRightToLeft) {
                if (HorizontalAlignment.Left == align) {
                    return HorizontalAlignment.Right;
                }
                else if (HorizontalAlignment.Right == align) {
                    return HorizontalAlignment.Left;
                }
            }

            return align;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.RtlTranslateLeftRight"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected LeftRightAlignment RtlTranslateLeftRight(LeftRightAlignment align) {

            if (RightToLeft.Yes == RightToLeft && RenderRightToLeft) {
                if (LeftRightAlignment.Left == align) {
                    return LeftRightAlignment.Right;
                }
                else if (LeftRightAlignment.Right == align) {
                    return LeftRightAlignment.Left;
                }
            }

            return align;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.RtlTranslateContent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected ContentAlignment RtlTranslateContent(ContentAlignment align) {
            
            ContentAlignment[][] mapping = new ContentAlignment[3][];
            mapping[0] = new ContentAlignment[2] { ContentAlignment.TopLeft, ContentAlignment.TopRight };
            mapping[1] = new ContentAlignment[2] { ContentAlignment.MiddleLeft, ContentAlignment.MiddleRight };
            mapping[2] = new ContentAlignment[2] { ContentAlignment.BottomLeft, ContentAlignment.BottomRight };
                 
            if (RightToLeft.Yes == RightToLeft && RenderRightToLeft) {
                for(int i=0; i < 3; ++i) {
                    if (mapping[i][0] == align) {
                        return mapping[i][1];
                    }
                    else if (mapping[i][1] == align) {
                        return mapping[i][0];
                    }
                }
            }
            return align;
        }
        
        private void SetWindowExStyle(int flag, bool value) {
            int styleFlags = (int) UnsafeNativeMethods.GetWindowLong(new HandleRef(this, Handle), NativeMethods.GWL_EXSTYLE);
            UnsafeNativeMethods.SetWindowLong(new HandleRef(this, Handle), NativeMethods.GWL_EXSTYLE, new HandleRef(null, (IntPtr)(value? styleFlags | flag: styleFlags & ~flag)));
        }

        private void SetWindowStyle(int flag, bool value) {
            int styleFlags = (int) UnsafeNativeMethods.GetWindowLong(new HandleRef(this, Handle), NativeMethods.GWL_STYLE);
            UnsafeNativeMethods.SetWindowLong(new HandleRef(this, Handle), NativeMethods.GWL_STYLE, new HandleRef(null, (IntPtr)(value? styleFlags | flag: styleFlags & ~flag)));
        }


        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Show"]/*' />
        /// <devdoc>
        ///     Makes the control display by setting the visible property to true
        /// </devdoc>
        public void Show() {
            Visible = true;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ShouldSerializeSize"]/*' />
        /// <devdoc>
        /// <para>Determines if the <see cref='System.Windows.Forms.Control.Size'/> property needs to be persisted.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal virtual bool ShouldSerializeSize() {
            Size s = DefaultSize;
            return width != s.Width || height != s.Height;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ShouldSerializeText"]/*' />
        /// <devdoc>
        /// <para>Determines if the <see cref='System.Windows.Forms.Control.Text'/> property needs to be persisted.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal virtual bool ShouldSerializeText() {
            return Text.Length != 0;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.SuspendLayout"]/*' />
        /// <devdoc>
        ///     Suspends the layout logic for the control.
        /// </devdoc>
        public void SuspendLayout() {
            Debug.WriteLineIf(CompModSwitches.RichLayout.TraceInfo, GetType().Name + "::SuspendLayout(" + layoutSuspendCount + ")");
            layoutSuspendCount++;
        }

        /// <devdoc>
        ///     Stops listening for the mouse leave event.
        /// </devdoc>
        /// <internalonly/>
        private void UnhookMouseEvent() {
            SetState(STATE_TRACKINGMOUSEEVENT, false);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.Update"]/*' />
        /// <devdoc>
        ///     Forces the control to paint any currently invalid areas.
        /// </devdoc>
        public void Update() {
            SafeNativeMethods.UpdateWindow(new HandleRef(window, window.Handle));
        }

        internal void _UpdateBounds() {
            UpdateBounds();
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.UpdateBounds"]/*' />
        /// <devdoc>
        ///     Updates the bounds of the control based on the handle the control is
        ///     bound to.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected void UpdateBounds() {
            NativeMethods.RECT rect = new NativeMethods.RECT();
            UnsafeNativeMethods.GetClientRect(new HandleRef(window, window.Handle), ref rect);
            int clientWidth = rect.right;
            int clientHeight = rect.bottom;
            UnsafeNativeMethods.GetWindowRect(new HandleRef(window, window.Handle), ref rect);
            if (!GetTopLevel()) {
                UnsafeNativeMethods.MapWindowPoints(NativeMethods.NullHandleRef, new HandleRef(null, UnsafeNativeMethods.GetParent(new HandleRef(window, window.Handle))), ref rect, 2);
            }
            UpdateBounds(rect.left, rect.top, rect.right - rect.left,
                         rect.bottom - rect.top, clientWidth, clientHeight);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.UpdateBounds1"]/*' />
        /// <devdoc>
        ///     Updates the bounds of the control based on the bounds passed in.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected void UpdateBounds(int x, int y, int width, int height) {
            Debug.Assert(!IsHandleCreated, "Don't call this method when handle is created!!");

            // reverse-engineer the AdjustWindowRectEx call to figure out
            // the appropriate clientWidth and clientHeight
            NativeMethods.RECT rect = new NativeMethods.RECT();
            rect.left = rect.right = rect.top = rect.bottom = 0;

            CreateParams cp = CreateParams;

            SafeNativeMethods.AdjustWindowRectEx(ref rect, cp.Style, false, cp.ExStyle);
            int clientWidth = width - (rect.right - rect.left);
            int clientHeight = height - (rect.bottom - rect.top);
            UpdateBounds(x, y, width, height, clientWidth, clientHeight);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.UpdateBounds2"]/*' />
        /// <devdoc>
        ///     Updates the bounds of the control based on the bounds passed in.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected void UpdateBounds(int x, int y, int width, int height, int clientWidth, int clientHeight) {
            bool newLocation = this.x != x || this.y != y;
            bool newSize = this.Width != width || this.Height != height ||
                           this.clientWidth != clientWidth || this.clientHeight != clientHeight;

            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.clientWidth = clientWidth;
            this.clientHeight = clientHeight;

            if (newLocation) {
                OnLocationChanged(EventArgs.Empty);
            }
            if (newSize) {
                OnSizeChanged(EventArgs.Empty);
            }
        }

        /// <devdoc>
        ///     Updates the binding manager bindings when the binding proeprty changes.
        ///     We have the code here, rather than in PropertyChagned, so we don't pull
        ///     in the data assembly if it's not used.
        /// </devdoc>
        private void UpdateBindings() {
            for (int i = 0; i < DataBindings.Count; i++) {
                BindingContext.UpdateBinding(BindingContext, DataBindings[i]);
            }
        }

        internal void UpdateCachedImeMode(IntPtr handle) {
            Debug.Assert(!DesignMode, "Shouldn't be updating cached ime mode at design-time");            
            
            ImeMode oldImeMode = CachedImeMode;
            
            if (oldImeMode == ImeMode.NoControl) {
                return;         // Don't update the ImeMode when ImeMode == ImeMode.NoControl
            }
            
            ImeMode fromContext = GetImeModeFromIMEContext(handle);
            if (fromContext != ImeMode.Inherit) {
                Debug.WriteLineIf(CompModSwitches.ImeMode.TraceInfo, "Updating ImeMode to " + fromContext.ToString()); 
                Properties.SetInteger(PropImeMode, (int)fromContext);
                
                if (fromContext != oldImeMode) {
                    OnImeModeChanged(EventArgs.Empty);
                }
            }
        }

        /// <devdoc>
        ///     Updates the child control's position in the control array to correctly
        ///     reflect it's index.
        /// </devdoc>
        private void UpdateChildControlIndex(Control ctl) {
            int newIndex = 0;
            int curIndex = this.Controls.GetChildIndex(ctl);
            IntPtr hWnd = ctl.window.Handle;
            while ((hWnd = UnsafeNativeMethods.GetWindow(new HandleRef(null, hWnd), NativeMethods.GW_HWNDPREV)) != IntPtr.Zero) {
                Control c = FromHandleInternal(hWnd);
                if (c != null) {
                    newIndex = this.Controls.GetChildIndex(c, false) + 1;
                    break;
                }
            }
            if (newIndex > curIndex) {
                newIndex--;
            }

            this.Controls.SetChildIndex(ctl, newIndex);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.UpdateZOrder"]/*' />
        /// <devdoc>
        ///     Updates this control in it's parent's zorder.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected void UpdateZOrder() {
            if (parent != null) {
                parent.UpdateChildZOrder(this);
            }
        }

        /// <devdoc>
        ///     Syncs the ZOrder of child control to the index we want it to be.
        /// </devdoc>
        private void UpdateChildZOrder(Control ctl) {
            if (window.Handle == IntPtr.Zero || ctl.window.Handle == IntPtr.Zero || ctl.parent != this) return;
            IntPtr prevHandle = (IntPtr)NativeMethods.HWND_TOP;
            for (int i = this.Controls.GetChildIndex(ctl); --i >= 0;) {
                Control c = Controls[i];
                if (c.window.Handle != IntPtr.Zero && c.parent == this) {
                    prevHandle = c.window.Handle;
                    break;
                }
            }
            if (UnsafeNativeMethods.GetWindow(new HandleRef(ctl.window, ctl.window.Handle), NativeMethods.GW_HWNDPREV) != prevHandle) {
                state |= STATE_NOZORDER;
                try {
                    SafeNativeMethods.SetWindowPos(new HandleRef(ctl.window, ctl.window.Handle), new HandleRef(null, prevHandle), 0, 0, 0, 0,
                                                   NativeMethods.SWP_NOMOVE | NativeMethods.SWP_NOSIZE);
                }
                finally {
                    state &= ~STATE_NOZORDER;
                }
            }
        }

        /// <devdoc>
        ///     Updates the rootRefence in the bound window.
        ///     (Used to prevent visible top-level controls from being garbage collected)
        /// </devdoc>
        private void UpdateRoot() {
            window.LockReference(GetTopLevel() && Visible);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.UpdateStyles"]/*' />
        /// <devdoc>
        ///     Forces styles to be reapplied to the handle. This function will call
        ///     CreateParams to get the styles to apply.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected void UpdateStyles() {
            UpdateStylesCore();
            
            OnStyleChanged(EventArgs.Empty);
        }

        internal virtual void UpdateStylesCore() {
            if (IsHandleCreated) {
                CreateParams cp = CreateParams;
                int winStyle = WindowStyle;
                int exStyle = WindowExStyle;

                // resolve the Form's lazy visibility.
                if ((state & STATE_VISIBLE) != 0) cp.Style |= NativeMethods.WS_VISIBLE;

                if (winStyle != cp.Style) {
                    WindowStyle = cp.Style;
                }
                if (exStyle != cp.ExStyle) {
                    WindowExStyle = cp.ExStyle;
                }

                SafeNativeMethods.SetWindowPos(
                                              new HandleRef(this, Handle), NativeMethods.NullHandleRef, 0, 0, 0, 0,
                                              NativeMethods.SWP_DRAWFRAME | NativeMethods.SWP_NOACTIVATE | NativeMethods.SWP_NOMOVE
                                              | NativeMethods.SWP_NOSIZE | NativeMethods.SWP_NOZORDER);

                Invalidate(true);
            }            
        }
        
        private void UserPreferenceChanged(object sender, UserPreferenceChangedEventArgs pref) {
            if (pref.Category == UserPreferenceCategory.Color) {
            
                SystemEvents.UserPreferenceChanged -= new UserPreferenceChangedEventHandler(this.UserPreferenceChanged);
            
                defaultFont = null;  
                bitsPerPixel = 0;
                //# fixes WM_SYSCOLORCHANGE passing for comctl controls
                OnSystemColorsChanged(EventArgs.Empty);
            }
        }
        
        private bool IsDialogWindow(IntPtr handle) {
            StringBuilder sb = new StringBuilder(32);
            int len = UnsafeNativeMethods.GetClassName(new HandleRef(null, handle), sb, sb.Capacity);
            if (len > 0 && sb.ToString() == "#32770") {
                return true;
            }
            return false;
        }

        private void WmClose(ref Message m) {

            // More generic fix for KB article Q125644... 
            //
            IntPtr parentHandle = Handle;
            IntPtr lastParentHandle = parentHandle;

            while (parentHandle != IntPtr.Zero) {
                lastParentHandle = parentHandle;
                parentHandle = UnsafeNativeMethods.GetParent(new HandleRef(null, parentHandle));

                int style = (int)UnsafeNativeMethods.GetWindowLong(new HandleRef(null, lastParentHandle), NativeMethods.GWL_STYLE);
                if ((style & NativeMethods.WS_CHILD) == 0) {
                    break;
                }

            }

            if (lastParentHandle != IntPtr.Zero && Control.FromHandleInternal(lastParentHandle) == null
                    && IsDialogWindow(lastParentHandle)) {
                UnsafeNativeMethods.PostMessage(new HandleRef(null, lastParentHandle), NativeMethods.WM_CLOSE, IntPtr.Zero, IntPtr.Zero);
            }
            DefWndProc(ref m);
        }
        /// <devdoc>
        ///     Handles the WM_COMMAND message
        /// </devdoc>
        /// <internalonly/>
        private void WmCommand(ref Message m) {
            if (IntPtr.Zero == m.LParam) {
                if (Command.DispatchID((int)m.WParam & 0xFFFF)) return;
            }
            else {
                if (ReflectMessageInternal(m.LParam, ref m)) {
                    return;
                }
            }
            DefWndProc(ref m);
        }

        /// <devdoc>
        ///     Handles the WM_CONTEXTMENU message
        /// </devdoc>
        /// <internalonly/>
        private void WmContextMenu(ref Message m) {
            ContextMenu contextMenu = (ContextMenu)Properties.GetObject(PropContextMenu);
            if (contextMenu != null) {
                int x = (int)(short)m.LParam;
                int y = (int)m.LParam >> 16;
                Point client;

                // lparam will be exactly -1 when the user invokes the context menu
                // with the keyboard.
                //
                if ((int)m.LParam == -1) {
                    client = new Point(Width/2, Height/2);
                }
                else {
                    client = PointToClientInternal(new Point(x, y));
                }

                // VisualStudio7 # 156, only show the context menu when clicked in the client area
                if (ClientRectangle.Contains( client ))
                    contextMenu.Show(this, client);
                else
                    DefWndProc( ref m );
            }
            else {
                DefWndProc(ref m);
            }
        }

        /// <devdoc>
        ///     Handles the WM_CTLCOLOR message
        /// </devdoc>
        /// <internalonly/>
        private void WmCtlColorControl(ref Message m) {
            // We could simply reflect the message, but it's faster to handle it here if possible.
            Control control = Control.FromHandleInternal(m.LParam);
            if (control != null) {
                m.Result = control.InitializeDCForWmCtlColor(m.WParam, m.Msg);
                if (m.Result != IntPtr.Zero) {
                    return;
                }
            }
            
            DefWndProc(ref m);
        }

        void WmDisplayChange(ref Message m) {
            GraphicsBufferManager buffer = (GraphicsBufferManager)Properties.GetObject(PropGraphicsBufferManager);
            if (buffer != null) {
                buffer.Dispose();
                Properties.SetObject(PropGraphicsBufferManager, null);
            }
            DefWndProc(ref m);
        }

        /// <devdoc>
        ///     WM_DRAWITEM handler
        /// </devdoc>
        /// <internalonly/>
        private void WmDrawItem(ref Message m) {

            // If the wparam is zero, then the message was sent by a menu.
            // See WM_DRAWITEM in MSDN.
            if (m.WParam == IntPtr.Zero) {
                WmDrawItemMenuItem(ref m);
            }
            else {
                WmOwnerDraw(ref m);
            }
        }

        private void WmDrawItemMenuItem(ref Message m) {
            // Obtain the menu item object
            NativeMethods.DRAWITEMSTRUCT dis = (NativeMethods.DRAWITEMSTRUCT)m.GetLParam(typeof(NativeMethods.DRAWITEMSTRUCT));

            // A pointer to the correct MenuItem is stored in the draw item
            // information sent with the message.
            // (See MenuItem.CreateMenuItemInfo)
            MenuItem menuItem = MenuItem.GetMenuItemFromUniqueID((int)dis.itemData);

            // Delegate this message to the menu item
            if (menuItem != null) {
                menuItem.WmDrawItem(ref m);                
            }
        }

        /// <devdoc>
        ///     Handles the WM_ERASEBKGND message
        /// </devdoc>
        /// <internalonly/>
        private void WmEraseBkgnd(ref Message m) {
            if (GetStyle(ControlStyles.UserPaint)) {
                // When possible, it's best to do all painting directly from WM_PAINT.
                if (!GetStyle(ControlStyles.AllPaintingInWmPaint)) {
                    IntPtr dc = m.WParam;
                    if (dc == IntPtr.Zero) {	// This happens under extreme stress conditions
                        m.Result = (IntPtr)0;
                        return;
                    }
                    NativeMethods.RECT rc = new NativeMethods.RECT();
                    UnsafeNativeMethods.GetClientRect(new HandleRef(this, Handle), ref rc);
                    PaintEventArgs pevent = new PaintEventArgs(dc, this, Rectangle.FromLTRB(rc.left, rc.top, rc.right, rc.bottom));
                    PaintWithErrorHandling(pevent, PaintLayerBackground, /* dispose pevent */ true);
                    

                }
                m.Result = (IntPtr)1;
            }
            else {
                DefWndProc(ref m);
            }
        }

        /// <devdoc>
        ///     Handles the WM_GETCONTROLNAME message. Returns the name of the control.
        /// </devdoc>
        /// <internalonly/>
        private void WmGetControlName(ref Message m) {
            string name;

            if (this.Site != null) {
                name = this.Site.Name;
            }
            else {
                name = this.Name;
            }

            if (name == null)
                name = "";

            if (m.LParam == IntPtr.Zero) {
                m.Result = (IntPtr)((name.Length + 1) * Marshal.SystemDefaultCharSize);
                return;
            }

            if ((int)m.WParam < name.Length + 1) {
                m.Result = (IntPtr)(-1);
                return;
            }

            // Copy the name into the given IntPtr
            //
            char[] nullChar = new char[] {(char)0};
            byte[] nullBytes;
            byte[] bytes;

            if (Marshal.SystemDefaultCharSize == 1) {
                bytes = Encoding.Default.GetBytes(name);
                nullBytes = Encoding.Default.GetBytes(nullChar);
            }
            else {
                bytes = Encoding.Unicode.GetBytes(name);
                nullBytes = Encoding.Unicode.GetBytes(nullChar);
            }

            Marshal.Copy(bytes, 0, m.LParam, bytes.Length);
            Marshal.Copy(nullBytes, 0, (IntPtr)((int)m.LParam + bytes.Length), nullBytes.Length);

            m.Result = (IntPtr)((bytes.Length + nullBytes.Length)/Marshal.SystemDefaultCharSize);
        }

        /// <devdoc>
        ///     Handles the WM_GETOBJECT message. Used for accessibility.
        /// </devdoc>
        /// <internalonly/>
        private void WmGetObject(ref Message m) {
            Debug.WriteLineIf(CompModSwitches.MSAA.TraceInfo, "In WmGetObject, this = " + this.GetType().FullName + ", lParam = " + m.LParam.ToString());                            
                
            // See "How to Handle WM_GETOBJECT" in MSDN
            if (NativeMethods.OBJID_CLIENT == (int)m.LParam) {
                
                // Get the IAccessible GUID
                //
                Guid IID_IAccessible = new Guid(NativeMethods.uuid_IAccessible);

                // Get an Lresult for the accessibility Object for this control
                //
                IntPtr punkAcc;
                try {
                    IAccessible iacc = (IAccessible)this.AccessibilityObject;                    
                    if (iacc == null) {
                        // Accessibility is not supported on this control
                        //
                        Debug.WriteLineIf(CompModSwitches.MSAA.TraceInfo, "AccessibilityObject returned null");
                        m.Result = (IntPtr)0;                    
                    }                    
                    else {
                        // Obtain the Lresult
                        //
                        punkAcc = Marshal.GetIUnknownForObject(iacc);
                        
                        try {
                            m.Result = UnsafeNativeMethods.LresultFromObject(ref IID_IAccessible, m.WParam, new HandleRef(this.AccessibilityObject, punkAcc));
                            Debug.WriteLineIf(CompModSwitches.MSAA.TraceInfo, "LresultFromObject returned " + m.Result.ToString());
                        }
                        finally {
                            Marshal.Release(punkAcc);
                        }                    
                    }
                }
                catch (Exception e) {
                    throw new InvalidOperationException(SR.GetString(SR.RichControlLresult), e);
                }
            }
            else {  // m.lparam != OBJID_CLIENT, so do default message processing
                DefWndProc(ref m);
            }
        }

        /// <devdoc>
        ///     Handles the WM_HELP message
        /// </devdoc>
        /// <internalonly/>
        private void WmHelp(ref Message m) {
            NativeMethods.HELPINFO info = (NativeMethods.HELPINFO)m.GetLParam(typeof(NativeMethods.HELPINFO));

            IComponent comp = null;
            if (info.iContextType == NativeMethods.HELPINFO_WINDOW) {
                comp = Control.FromHandleInternal(info.hItemHandle);
            }

            HelpEventArgs hevent = new HelpEventArgs(new Point(info.MousePos.x, info.MousePos.y));
            OnHelpRequested(hevent);
            if (!hevent.Handled) {
                DefWndProc(ref m);
            }
        }

        /// <devdoc>
        ///     Handles the WM_INITMENUPOPUP message
        /// </devdoc>
        /// <internalonly/>
        private void WmInitMenuPopup(ref Message m) {
            ContextMenu contextMenu = (ContextMenu)Properties.GetObject(PropContextMenu);
            if (contextMenu != null) {

                if (RightToLeft == RightToLeft.Yes) {
                    contextMenu.UpdateRtl();
                }

                if (contextMenu.ProcessInitMenuPopup(m.WParam))
                    return;
            }
            DefWndProc(ref m);
        }

        /// <devdoc>
        ///     Handles the WM_INPUTLANGCHANGE message
        /// </devdoc>
        /// <internalonly/>
        private void WmInputLangChange(ref Message m) {
            if (FindFormInternal() != null) {
                InputLanguageChangedEventArgs e = InputLanguage.CreateInputLanguageChangedEventArgs(m);
                FindFormInternal().PerformOnInputLanguageChanged(e);
            }

            DefWndProc(ref m);
            
            Debug.WriteLineIf(CompModSwitches.ImeMode.TraceInfo, "Inside WmInputLangChange(), this = " + this.ToString());
            
            if (!DesignMode && Focused && CachedImeMode != ImeMode.NoControl) {
                CurrentImeContextMode = CachedImeMode;
            }
        }

        /// <devdoc>
        ///     Handles the WM_INPUTLANGCHANGEREQUEST message
        /// </devdoc>
        /// <internalonly/>
        private void WmInputLangChangeRequest(ref Message m) {
            InputLanguageChangingEventArgs e = InputLanguage.CreateInputLanguageChangingEventArgs(m);
            if (FindFormInternal() != null) {
                FindFormInternal().PerformOnInputLanguageChanging(e);
            }
            if (!e.Cancel) {
                DefWndProc(ref m);
            }
            else {
                m.Result = IntPtr.Zero;
            }
        }

        /// <devdoc>
        ///     WM_MEASUREITEM handler
        /// </devdoc>
        /// <internalonly/>
        private void WmMeasureItem(ref Message m) {

            // If the wparam is zero, then the message was sent by a menu.
            // See WM_MEASUREITEM in MSDN.
            if (m.WParam == IntPtr.Zero) {

                // Obtain the menu item object
                NativeMethods.MEASUREITEMSTRUCT mis = (NativeMethods.MEASUREITEMSTRUCT)m.GetLParam(typeof(NativeMethods.MEASUREITEMSTRUCT));

                Debug.Assert(m.LParam != IntPtr.Zero, "m.lparam is null");

                // A pointer to the correct MenuItem is stored in the measure item
                // information sent with the message.
                // (See MenuItem.CreateMenuItemInfo)
                MenuItem menuItem = MenuItem.GetMenuItemFromUniqueID((int)mis.itemData);
                Debug.Assert(menuItem != null, "UniqueID is not associated with a menu item");

                // Delegate this message to the menu item
                if (menuItem != null) {
                    menuItem.WmMeasureItem(ref m);
                }
            }
            else {
                WmOwnerDraw(ref m);
            }
        }

        /// <devdoc>
        ///     Handles the WM_MENUCHAR message
        /// </devdoc>
        /// <internalonly/>
        private void WmMenuChar(ref Message m) {
            Menu menu = ContextMenu;
            if (menu != null) {
                menu.WmMenuChar(ref m);
                if (m.Result != IntPtr.Zero) {
                    // This char is a mnemonic on our menu.
                    return;
                }
            }
        }

        /// <devdoc>
        ///     Handles the WM_MENUSELECT message
        /// </devdoc>
        /// <internalonly/>
        private void WmMenuSelect(ref Message m) {
            int item = NativeMethods.Util.LOWORD(m.WParam);
            int flags = NativeMethods.Util.HIWORD(m.WParam);
            IntPtr hmenu = m.LParam;
            MenuItem mi = null;

            if ((flags & NativeMethods.MF_SYSMENU) != 0) {
                // nothing
            }
            else if ((flags & NativeMethods.MF_POPUP) == 0) {
                Command cmd = Command.GetCommandFromID(item);
                if (cmd != null) {
                    Object reference = cmd.Target;
                    if (reference != null && reference is MenuItem.MenuItemData) {
                        mi = ((MenuItem.MenuItemData)reference).baseItem;
                    }
                }
            }
            else {
                mi = GetMenuItemFromHandleId(hmenu, item);
            }

            if (mi != null) {
                mi.PerformSelect();
            }

            DefWndProc(ref m);
        }

        /// <devdoc>
        ///     Handles the WM_CREATE message
        /// </devdoc>
        /// <internalonly/>
        private void WmCreate(ref Message m) {

            DefWndProc(ref m);
            
            // Controls in design mode always draw their accellerators.
            if (DesignMode) {
                SendMessage(NativeMethods.WM_CHANGEUISTATE, NativeMethods.UIS_CLEAR | (NativeMethods.UISF_HIDEACCEL << 16), 0);
            }
            else {
                SendMessage(NativeMethods.WM_CHANGEUISTATE, NativeMethods.UIS_INITIALIZE, 0);
            }
            
            if (parent != null) {
                parent.UpdateChildZOrder(this);
            }
            UpdateBounds();

            // Let any interested sites know that we've now created a handle
            //
            OnHandleCreated(EventArgs.Empty);

            // this code is important -- it is critical that we stash away
            // the value of the text for controls such as edit, button,
            // label, etc. Without this processing, any time you change a
            // property that forces handle recreation, you lose your text!
            // See the below code in wmDestroy
            //
            if (!GetStyle(ControlStyles.CacheText)) {
                text = null;
            }
        }

        /// <devdoc>
        ///     Handles the WM_DESTROY message
        /// </devdoc>
        /// <internalonly/>
        private void WmDestroy(ref Message m) {
            // Let any interested sites know that we're destroying our handle
            //
            Debug.Assert(IsHandleCreated, "Need to have the handle here");

            OnHandleDestroyed(EventArgs.Empty);

            if (!Disposing) {
                // If we are not recreating the handle, set our created state
                // back to false so we can be rebuilt if we need to be.
                //
                if (!RecreatingHandle) {
                    SetState(STATE_CREATED, false);
                }
            }
            else {
                SetState(STATE_VISIBLE, false);
            }

            DefWndProc(ref m);
        }
   
        /// <devdoc>
        ///     Handles the WM_IMECHAR message
        /// </devdoc>
        /// <internalonly/>
        private void WmIMEChar(ref Message m) {
            ProcessKeyEventArgs(ref m);
            DefWndProc(ref m);
        }


        /// <devdoc>
        ///     Handles the WM_CHAR, WM_KEYDOWN, WM_SYSKEYDOWN, WM_KEYUP, and
        ///     WM_SYSKEYUP messages.
        /// </devdoc>
        /// <internalonly/>
        private void WmKeyChar(ref Message m) {
            if (ProcessKeyMessage(ref m)) return;
            DefWndProc(ref m);
        }

        /// <devdoc>
        ///     Handles the WM_KILLFOCUS message
        /// </devdoc>
        /// <internalonly/>
        private void WmKillFocus(ref Message m) {
        
            if (!DesignMode) {
                if (CachedImeMode != ImeMode.NoControl) {
                    UpdateCachedImeMode(this.Handle);
                
                    bool found = false;
                    ImeMode previousImeMode = (ImeMode)Properties.GetInteger(PropPreviousImeMode, out found);
                    if (found) {
                        Debug.WriteLineIf(CompModSwitches.ImeMode.TraceInfo, "Restoring previous IME mode: " + previousImeMode.ToString() + ", this = " + this.GetType().ToString());
                        CurrentImeContextMode = previousImeMode;
                    }
                }
            }
        
            if (Properties.ContainsInteger(PropCharsToIgnore)) {
                Properties.SetInteger(PropCharsToIgnore, 0);
            }
            DefWndProc(ref m);
            OnLostFocus(EventArgs.Empty);
        }

        /// <devdoc>
        ///     Handles the WM_MOUSEDOWN message
        /// </devdoc>
        /// <internalonly/>
        private void WmMouseDown(ref Message m, MouseButtons button, int clicks) {
            // If this is a "real" mouse event (not just WM_LBUTTONDOWN, etc) then
            // we need to see if something happens during processing of
            // user code that changed the state of the buttons (i.e. bringing up
            // a dialog) to keep the control in a consistent state... 
            //
            MouseButtons realState = MouseButtons;
            SetState(STATE_MOUSEPRESSED, true);

            // If the UserMouse style is set, the control does its own processing
            // of mouse messages
            //
            if (!GetStyle(ControlStyles.UserMouse)) {
                DefWndProc(ref m);
            }
            else {
                // DefWndProc would normally set the focus to this control, but
                // since we're skipping DefWndProc, we need to do it ourselves.
                if (button == MouseButtons.Left && GetStyle(ControlStyles.Selectable)) {
                    FocusInternal();
                }
            }

            if (realState != MouseButtons) {
                return;
            }
            
            //CaptureInternal is set always in MouseDown
            CaptureInternal = true;

            if (realState != MouseButtons) {
                return;
            }

            // control should be enabled when this method is entered, but may have become
            // disabled during its lifetime (e.g. through a Click or Focus listener)
            if (Enabled) {
                OnMouseDown(new MouseEventArgs(button, clicks, (int)(short)m.LParam, (int)m.LParam >> 16, 0));
            }
        }

        /// <devdoc>
        ///     Handles the WM_MOUSEENTER message
        /// </devdoc>
        /// <internalonly/>
        private void WmMouseEnter(ref Message m) {
            DefWndProc(ref m);
            OnMouseEnter(EventArgs.Empty);
        }

        /// <devdoc>
        ///     Handles the WM_MOUSELEAVE message
        /// </devdoc>
        /// <internalonly/>
        private void WmMouseLeave(ref Message m) {
            DefWndProc(ref m);
            OnMouseLeave(EventArgs.Empty);
        }

        /// <devdoc>
        ///     Handles the "WM_MOUSEHOVER" message... until we get actuall OS support
        ///     for this, it is implemented as a custom message.
        /// </devdoc>
        /// <internalonly/>
        private void WmMouseHover(ref Message m) {
            DefWndProc(ref m);
            OnMouseHover(EventArgs.Empty);
        }

        /// <devdoc>
        ///     Handles the WM_MOUSEMOVE message
        /// </devdoc>
        /// <internalonly/>
        private void WmMouseMove(ref Message m) {
            // If the UserMouse style is set, the control does its own processing
            // of mouse messages
            //
            if (!GetStyle(ControlStyles.UserMouse)) {
                DefWndProc(ref m);
            }
            OnMouseMove(new MouseEventArgs(MouseButtons, 0, (int)(short)m.LParam, (int)m.LParam >> 16, 0));
        }

        /// <devdoc>
        ///     Handles the WM_MOUSEUP message
        /// </devdoc>
        /// <internalonly/>
        private void WmMouseUp(ref Message m, MouseButtons button, int clicks) {
            // Get the mouse location
            //
            try {
                int x = (int)(short)m.LParam;
                int y = (int)m.LParam >> 16;
                Point pt = new Point(x,y);
                pt = PointToScreen(pt);
    
                // If the UserMouse style is set, the control does its own processing
                // of mouse messages
                //
                if (!GetStyle(ControlStyles.UserMouse)) {
                    DefWndProc(ref m);
                }
                else {
                    // DefWndProc would normally trigger a context menu here 
                    // (for a right button click), but since we're skipping DefWndProc
                    // we have to do it ourselves.
                    if (button == MouseButtons.Right) {
                        SendMessage(NativeMethods.WM_CONTEXTMENU, this.Handle, NativeMethods.Util.MAKELPARAM(pt.X, pt.Y));
                    }
                }
    
                bool fireClick = false;
    
                if ((controlStyle & ControlStyles.StandardClick) == ControlStyles.StandardClick) {
                    if (GetState(STATE_MOUSEPRESSED) && !IsDisposed && UnsafeNativeMethods.WindowFromPoint(pt.X, pt.Y) == Handle) {
                    fireClick = true;
                    }
                }
                
                if (fireClick && !ValidationCancelled) {
                    if (!GetState(STATE_DOUBLECLICKFIRED)) 
                        OnClick(EventArgs.Empty);
                    else
                        OnDoubleClick(EventArgs.Empty);
                }
                //call the MouseUp Finally...
                OnMouseUp(new MouseEventArgs(button, clicks, (int)(short)m.LParam, (int)m.LParam >> 16, 0));
            }
            finally {
                //Always Reset the STATE_DOUBLECLICKFIRED in UP.. Since we get UP - DOWN - DBLCLK - UP sequqnce
                //The Flag is set in L_BUTTONDBLCLK in the controls WndProc() ...
                //
                SetState(STATE_DOUBLECLICKFIRED, false);
                SetState(STATE_MOUSEPRESSED, false);
                SetState(STATE_VALIDATIONCANCELLED, false);
                //CaptureInternal is Resetted while exiting the MouseUp
                CaptureInternal = false;
            }
        }

        /// <devdoc>
        ///     Handles the WM_MOUSEWHEEL message
        /// </devdoc>
        /// <internalonly/>
        private void WmMouseWheel(ref Message m) {
            DefWndProc(ref m);
            Point p = new Point((int)(short)m.LParam, (int)m.LParam >> 16);
            p = PointToClient(p);
            OnMouseWheel(new MouseEventArgs(MouseButtons.None,
                                            0,
                                            p.X,
                                            p.Y,
                                            (int)m.WParam >> 16));
        }

        /// <devdoc>
        ///     Handles the WM_MOVE message.  We must do this in
        ///     addition to WM_WINDOWPOSCHANGED because windows may
        ///     send WM_MOVE directly.
        /// </devdoc>
        /// <internalonly/>
        private void WmMove(ref Message m) {
            DefWndProc(ref m);
            UpdateBounds();
        }

        /// <devdoc>
        ///     Handles the WM_NOTIFY message
        /// </devdoc>
        /// <internalonly/>
        private unsafe void WmNotify(ref Message m) {
            NativeMethods.NMHDR* nmhdr = (NativeMethods.NMHDR*)m.LParam;
            if (!ReflectMessageInternal(nmhdr->hwndFrom,ref m)) {
                DefWndProc(ref m);
            }
        }

        /// <devdoc>
        ///     Handles the WM_NOTIFYFORMAT message
        /// </devdoc>
        /// <internalonly/>
        private void WmNotifyFormat(ref Message m) {
            if (!ReflectMessageInternal(m.WParam, ref m)) {
                DefWndProc(ref m);
            }
        }

        /// <devdoc>
        ///     Handles the WM_OWNERDRAW message
        /// </devdoc>
        /// <internalonly/>
        private void WmOwnerDraw(ref Message m) {
            bool reflectCalled = false;
            if (!ReflectMessageInternal(m.WParam, ref m)) {
                //Additional Check For Control .... TabControl truncates the Hwnd value...
                IntPtr handle = window.GetHandleFromID((short)m.WParam);
                if (handle != IntPtr.Zero) {
                    Control control = Control.FromHandleInternal(handle);
                    if (control != null) {
                        m.Result = control.SendMessage(NativeMethods.WM_REFLECT + m.Msg, handle, m.LParam);
                        reflectCalled = true;
                    }
                }
            }
            else
                reflectCalled = true;

            if (!reflectCalled) {
              DefWndProc(ref m);
            }
        }

        /// <devdoc>
        ///     Handles the WM_PAINT messages.  This should only be called
        ///     for userpaint controls.
        /// </devdoc>
        /// <internalonly/>
        private void WmPaint(ref Message m) {
            bool doubleBuffered = GetStyle(ControlStyles.AllPaintingInWmPaint) && DoubleBufferingEnabled;
#if DEBUG
            if (BufferDisabled.Enabled) {
                doubleBuffered = false;
            }
#endif
            if (doubleBuffered) {
                NativeMethods.PAINTSTRUCT ps = new NativeMethods.PAINTSTRUCT();
                IntPtr dc;
                bool disposeDc = false;
                Rectangle clip;
                if (m.WParam == IntPtr.Zero) {
                    dc = UnsafeNativeMethods.BeginPaint(new HandleRef(this, Handle), ref ps);
                    clip = new Rectangle(ps.rcPaint_left, ps.rcPaint_top,
                                         ps.rcPaint_right - ps.rcPaint_left,
                                         ps.rcPaint_bottom - ps.rcPaint_top);
                    disposeDc = true;
                }
                else {
                    dc = m.WParam;
                    clip = ClientRectangle;
                }
                
                IntPtr oldPal = SetUpPalette(dc, false, false);
                try {
                    if (clip.Width > 0 && clip.Height > 0) {
#if BANDING_BUFFERING
                        const int BandSize = 100;
                        int remaining = Height;
                        int start = 0;
                        while (remaining > 0) {
                            int localBand = BandSize;
                            if (remaining < BandSize) {
                                localBand = remaining;
                            }

                            Rectangle band = new Rectangle(0, start, Width, localBand);

                            if (band.IntersectsWith(clip)) {
                                if (BufferPinkRect.Enabled) {
                                    using (GraphicsBuffer buffer = BufferManager.AllocBuffer(dc, band)) {
                                        buffer.Graphics.FillRectangle(new SolidBrush(Color.Red), band);
                                    }
                                    Thread.Sleep(200);
                                }

                                using (GraphicsBuffer buffer = BufferManager.AllocBuffer(dc, band)) {
                                    Graphics g = buffer.Graphics;
                                    g.SetClip(band);
                                    GraphicsState state = g.Save();
                                    PaintEventArgs e = new PaintEventArgs(g, band);
                                    PaintWithErrorHandling(e, PaintLayerBackground, /* dispose pevent */ false);
                                    g.Restore(state);
                                    PaintWithErrorHandling(e, PaintLayerForeground, /* dispose pevent */ false);
                                }
                            }

                            start += localBand;
                            remaining -= localBand;
                        }
#else
                        Rectangle band = ClientRectangle;

#if DEBUG
                        if (BufferPinkRect.Enabled) {
                            using (GraphicsBuffer buffer = BufferManager.AllocBuffer(dc, band)) {
                                buffer.Graphics.FillRectangle(new SolidBrush(Color.Red), band);
                            }
                            Thread.Sleep(50);
                        }
#endif

                        using (GraphicsBuffer buffer = BufferManager.AllocBuffer(dc, band)) {
                            Graphics g = buffer.Graphics;
                            g.SetClip(clip);
                            GraphicsState state = g.Save();

                            PaintEventArgs e = new PaintEventArgs(g, clip);
                            PaintWithErrorHandling(e, PaintLayerBackground, /* dispose pevent */ false);

                            g.Restore(state);
                            PaintWithErrorHandling(e, PaintLayerForeground, /* dispose pevent */ false);
                        }
#endif
                    }
                }
                finally {
                    if (oldPal != IntPtr.Zero) {
                        SafeNativeMethods.SelectPalette(new HandleRef(null, dc), new HandleRef(null, oldPal), 0);
                    }
                }

                if (disposeDc) {
                    UnsafeNativeMethods.EndPaint(new HandleRef(this, Handle), ref ps);
                }
            }
            else {
                if (m.WParam == IntPtr.Zero) {
                    NativeMethods.PAINTSTRUCT ps = new NativeMethods.PAINTSTRUCT();                  
                    IntPtr dc = UnsafeNativeMethods.BeginPaint(new HandleRef(this, Handle), ref ps);
                    IntPtr oldPal = SetUpPalette(dc, false, false);
                    try {
                        PaintEventArgs pevent = new PaintEventArgs(dc, this, new Rectangle(ps.rcPaint_left, ps.rcPaint_top,
                                                                                     ps.rcPaint_right - ps.rcPaint_left,
                                                                                     ps.rcPaint_bottom - ps.rcPaint_top));
                        try {
                            if (GetStyle(ControlStyles.AllPaintingInWmPaint)) {
                                PaintWithErrorHandling(pevent, PaintLayerBackground, /* dispose pevent */ false);
                                pevent.ResetGraphics();
                            }

                            PaintWithErrorHandling(pevent, PaintLayerForeground, /* dispose pevent */ false);
                        }
                        finally {
                            pevent.Dispose();
                            UnsafeNativeMethods.EndPaint(new HandleRef(this, Handle), ref ps);
                        }
                    }
                    finally {
                        if (oldPal != IntPtr.Zero) {
                            SafeNativeMethods.SelectPalette(new HandleRef(null, dc), new HandleRef(null, oldPal), 0);
                        }
                    }
                }
                else {
                    PaintEventArgs pevent = new PaintEventArgs(m.WParam, this, ClientRectangle);
                    PaintWithErrorHandling(pevent, PaintLayerForeground, /* dispose pevent */ true);
                }
            }
        }

        /// <devdoc>
        ///     Handles the WM_PRINTCLIENT messages.  This should only be called 
        ///     for userpaint controls.
        /// </devdoc>
        /// <internalonly/>
        private void WmPrintClient(ref Message m) {
            if (this.Visible) {
                PaintEventArgs e = new PaintEventArgs(m.WParam, this, ClientRectangle);

                // Theme support on Windows XP requires that we paint the background
                // and foreground to support semi-transparent children
                //

                PaintWithErrorHandling(e, PaintLayerBackground, /* dispose pevent */ false);
                e.ResetGraphics();

                PaintWithErrorHandling(e, PaintLayerForeground, /* dispose pevent */ true);
            }
        }

        private void WmQueryNewPalette(ref Message m) {
            Debug.WriteLineIf(Control.PaletteTracing.TraceVerbose, Handle + ": WM_QUERYNEWPALETTE");
            IntPtr dc = UnsafeNativeMethods.GetDC(new HandleRef(this, Handle));
            try {
                SetUpPalette(dc, true /*force*/, true/*realize*/);
            }
            finally {
                // Let WmPaletteChanged do any necessary invalidation
                UnsafeNativeMethods.ReleaseDC(new HandleRef(this, Handle), new HandleRef(null, dc));
            }
            Invalidate(true);
            m.Result = (IntPtr)1;
            DefWndProc(ref m);
        }


        /// <devdoc>
        ///     Handles the WM_SETCURSOR message
        /// </devdoc>
        /// <internalonly/>
        private void WmSetCursor(ref Message m) {

            // Accessing through the Handle property has side effects that break this
            // logic. You must use InternalHandle.
            //
            if (m.WParam == InternalHandle && ((int)m.LParam & 0x0000FFFF) == NativeMethods.HTCLIENT) {
                Cursor.CurrentInternal = Cursor;
            }
            else {
                DefWndProc(ref m);
            }

        }
        
        /// <devdoc>
        ///     Handles the WM_WINDOWPOSCHANGING message
        /// </devdoc>
        /// <internalonly/>
        private unsafe void WmWindowPosChanging(ref Message m) {

            // We let this fall through to defwndproc unless we are being surfaced as
            // an ActiveX control.  In that case, we must let the ActiveX side of things
            // manipulate our bounds here.
            //
            if (IsActiveX) {
                NativeMethods.WINDOWPOS* wp = (NativeMethods.WINDOWPOS *)m.LParam;
                // Only call UpdateBounds if the new bounds are different.
                //
                bool different = false;

                if ((wp->flags & NativeMethods.SWP_NOMOVE) == 0 && (wp->x != Left || wp->y != Top)) {
                    different = true;
                }
                if ((wp->flags & NativeMethods.SWP_NOSIZE) == 0 && (wp->cx != Width || wp->cy != Height)) {
                    different = true;
                }

                if (different) {
                    ActiveXUpdateBounds(ref wp->x, ref wp->y, ref wp->cx, ref wp->cy, wp->flags);
                }
            }

            DefWndProc(ref m);
        }


        /// <devdoc>
        ///     Handles the WM_PARENTNOTIFY message
        /// </devdoc>
        /// <internalonly/>
        private void WmParentNotify(ref Message m) {
            int msg = NativeMethods.Util.LOWORD((int)m.WParam);
            IntPtr hWnd = IntPtr.Zero;
            switch (msg) {
                case NativeMethods.WM_CREATE:
                    hWnd = m.LParam;
                    break;
                case NativeMethods.WM_DESTROY:
                    break;
                default:
                    hWnd = UnsafeNativeMethods.GetDlgItem(new HandleRef(this, Handle), NativeMethods.Util.HIWORD((int)m.WParam));
                    break;
            }
            if (hWnd == IntPtr.Zero || !ReflectMessageInternal(hWnd, ref m)) {
                DefWndProc(ref m);
            }
        }

        /// <devdoc>
        ///     Handles the WM_SETFOCUS message
        /// </devdoc>
        /// <internalonly/>
        private void WmSetFocus(ref Message m) {
            ImeSetFocus();

            if (!HostedInWin32DialogManager) {
                IContainerControl c = GetContainerControlInternal();
                if (c != null) {
                    bool activateSucceed;

                    ContainerControl knowncontainer = c as ContainerControl;
                    if (knowncontainer != null) {
                        activateSucceed = knowncontainer.ActivateControlInternal(this);
                    }
                    else {
                        // SECREVIEW : Taking focus and activating a control is response
                        //           : to a user gesture (WM_SETFOCUS) is OK.
                        //
                        IntSecurity.ModifyFocus.Assert();
                        try {
                            activateSucceed = c.ActivateControl(this);
                        }
                        finally {
                            CodeAccessPermission.RevertAssert();
                        }
                    }

                    if (!activateSucceed) {
                        return;
                    }
                }
            }

            DefWndProc(ref m);
   	    OnGotFocus(EventArgs.Empty);
        }

        /// <devdoc>
        ///     Handles the WM_SHOWWINDOW message
        /// </devdoc>
        /// <internalonly/>
        private void WmShowWindow(ref Message m) {
            // We get this message for each control, even if their parent is not visible.

            DefWndProc(ref m);

            if ((state & STATE_RECREATE) == 0) {

                bool visible = m.WParam != IntPtr.Zero;
                bool oldVisibleProperty = Visible;

                if (visible) {
                    bool oldVisibleBit = GetState(STATE_VISIBLE);
                    SetState(STATE_VISIBLE, true);
                    bool executedOk = false;
                    try {
                        CreateControl();
                        executedOk = true;
                    }

                    finally {
                        if (!executedOk) {
                            // We do it this way instead of a try/catch because catching and rethrowing
                            // an exception loses call stack information
                            SetState(STATE_VISIBLE, oldVisibleBit);
                        }
                    }
                }
                else { // not visible
                    // If Windows tells us it's visible, that's pretty unambiguous.
                    // But if it tells us it's not visible, there's more than one explanation --
                    // maybe the container control became invisible.  So we look at the parent
                    // and take a guess at the reason.

                    // We do not want to update state if we are on the parking window.
                    bool parentVisible = GetTopLevel();
                    if (ParentInternal != null) {
                        Control parkingWindow = Application.GetParkingWindow(this);
                        if (!parkingWindow.IsHandleCreated 
                            || UnsafeNativeMethods.GetParent(new HandleRef(window, window.Handle)) != parkingWindow.Handle) {
                            parentVisible = ParentInternal.Visible;
                        }
                    }

                    if (parentVisible) {
                        SetState(STATE_VISIBLE, false);
                    }
                }
                
                if (oldVisibleProperty != visible) {
                    OnVisibleChanged(EventArgs.Empty);
                }
            }
        }

        /// <devdoc>
        ///     Handles the WM_SYSCOLORCHANGE message
        /// </devdoc>
        /// <internalonly/>
        private void WmSysColorChange(ref Message m) {        
            SystemEvents.UserPreferenceChanged += new UserPreferenceChangedEventHandler(this.UserPreferenceChanged);                      
            DefWndProc(ref m);                        
        }

        /// <devdoc>
        ///     Handles the WM_UPDATEUISTATE message
        /// </devdoc>
        /// <internalonly/>
        private void WmUpdateUIState(ref Message m) {
            bool keyboard = ShowKeyboardCues;
            bool focus = ShowFocusCues;
            
            DefWndProc(ref m);
            
            int cmd = NativeMethods.Util.LOWORD((int)m.WParam);

            if (cmd == NativeMethods.UIS_INITIALIZE) {
                return;
            }

            UICues UIcues = UICues.None;
            if ((NativeMethods.Util.HIWORD((int)m.WParam) & NativeMethods.UISF_HIDEACCEL) != 0) {
                if (cmd == NativeMethods.UIS_CLEAR) {
                    if (keyboard) {
                        UIcues |= UICues.ChangeKeyboard;
                        UIcues |= UICues.ShowKeyboard;
                    }
                }
                else {
                    if (!keyboard) {
                        UIcues |= UICues.ChangeKeyboard;
                    }
                }
            }
            if ((NativeMethods.Util.HIWORD((int)m.WParam) & NativeMethods.UISF_HIDEFOCUS) != 0) {
                if (cmd == NativeMethods.UIS_CLEAR) {
                    if (focus) {
                        UIcues |= UICues.ChangeFocus;
                        UIcues |= UICues.ShowFocus;
                    }
                }
                else {
                    if (!focus) {
                        UIcues |= UICues.ChangeFocus;
                    }
                }
            }

            
            if ((UIcues & UICues.Changed) != 0) {
                OnChangeUICues(new UICuesEventArgs(UIcues));
                Invalidate(true);
            }
        }

        /// <devdoc>
        ///     Handles the WM_WINDOWPOSCHANGED message
        /// </devdoc>
        /// <internalonly/>
        private unsafe void WmWindowPosChanged(ref Message m) {
            DefWndProc(ref m);
            // Update new size / position
            UpdateBounds();
            if (parent != null && UnsafeNativeMethods.GetParent(new HandleRef(window, window.Handle)) == parent.window.Handle &&
                (state & STATE_NOZORDER) == 0) {

                NativeMethods.WINDOWPOS* wp = (NativeMethods.WINDOWPOS *)m.LParam;
                if ((wp->flags & NativeMethods.SWP_NOZORDER) == 0) {
                    parent.UpdateChildControlIndex(this);
                }
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.WndProc"]/*' />
        /// <devdoc>
        ///     Base wndProc. All messages are sent to wndProc after getting filtered
        ///     through the preProcessMessage function. Inheriting controls should
        ///     call base.wndProc for any messages that they don't handle.
        /// </devdoc>
        [
            SecurityPermission(SecurityAction.InheritanceDemand, Flags=SecurityPermissionFlag.UnmanagedCode),
            SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)
        ]
        protected virtual void WndProc(ref Message m) {
            // inlined code from GetStyle(...) to ensure no perf hit 
            // for a method call...
            //
            if ((controlStyle & ControlStyles.EnableNotifyMessage) == ControlStyles.EnableNotifyMessage) {
                // pass message *by value* to avoid the possibility
                // of the OnNotifyMessage modifying the message.
                //
                OnNotifyMessage(m);
            }

            /*
            * If you add any new messages below (or change the message handling code for any messages)
            * please make sure that you also modify AxHost.wndProc to do the right thing and intercept
            * messages which the Ocx would own before passing them onto Control.wndProc.
            */
            switch (m.Msg) {
                case NativeMethods.WM_GETOBJECT:
                    WmGetObject(ref m);
                    break;

                case NativeMethods.WM_COMMAND:
                    WmCommand(ref m);
                    break;
                case NativeMethods.WM_CLOSE:
                    WmClose(ref m);
                    break;
                case NativeMethods.WM_CONTEXTMENU:
                    WmContextMenu(ref m);
                    break;
                case NativeMethods.WM_DISPLAYCHANGE:
                    WmDisplayChange(ref m);
                    break;
                case NativeMethods.WM_DRAWITEM:
                    WmDrawItem(ref m);
                    break;
                case NativeMethods.WM_ERASEBKGND:
                    WmEraseBkgnd(ref m);
                    break;

                case NativeMethods.WM_HELP:
                    WmHelp(ref m);
                    break;

                case NativeMethods.WM_PAINT:
                    if (GetStyle(ControlStyles.UserPaint)) {
                        WmPaint(ref m);
                    }
                    else {
                        DefWndProc(ref m);
                    }
                    break;
                
                case NativeMethods.WM_PRINTCLIENT:
                    if (GetStyle(ControlStyles.UserPaint)) {
                        WmPrintClient(ref m);
                    }
                    else {
                        DefWndProc(ref m);
                    }
                    break;

                case NativeMethods.WM_INITMENUPOPUP:
                    WmInitMenuPopup(ref m);
                    break;

                case NativeMethods.WM_INPUTLANGCHANGE:
                    WmInputLangChange(ref m);
                    break;

                case NativeMethods.WM_INPUTLANGCHANGEREQUEST:
                    WmInputLangChangeRequest(ref m);
                    break;

                case NativeMethods.WM_MEASUREITEM:
                    WmMeasureItem(ref m);
                    break;
                case NativeMethods.WM_MENUCHAR:
                    WmMenuChar(ref m);
                    break;

                case NativeMethods.WM_MENUSELECT:
                    WmMenuSelect(ref m);
                    break;

                case NativeMethods.WM_SETCURSOR:
                    WmSetCursor(ref m);
                    break;

                case NativeMethods.WM_WINDOWPOSCHANGING:
                    WmWindowPosChanging(ref m);
                    break;

                case NativeMethods.WM_CHAR:
                case NativeMethods.WM_KEYDOWN:
                case NativeMethods.WM_SYSKEYDOWN:
                case NativeMethods.WM_KEYUP:
                case NativeMethods.WM_SYSKEYUP:
                    WmKeyChar(ref m);
                    break;
                case NativeMethods.WM_CREATE:
                    WmCreate(ref m);
                    break;
                case NativeMethods.WM_DESTROY:
                    WmDestroy(ref m);
                    break;
 

                case NativeMethods.WM_CTLCOLOR:
                case NativeMethods.WM_CTLCOLORBTN:
                case NativeMethods.WM_CTLCOLORDLG:
                case NativeMethods.WM_CTLCOLORMSGBOX:
                case NativeMethods.WM_CTLCOLORSCROLLBAR:
                case NativeMethods.WM_CTLCOLOREDIT:
                case NativeMethods.WM_CTLCOLORLISTBOX:
                case NativeMethods.WM_CTLCOLORSTATIC:
                    WmCtlColorControl(ref m);
                    break;
                case NativeMethods.WM_HSCROLL:
                case NativeMethods.WM_VSCROLL:
                case NativeMethods.WM_DELETEITEM:
                case NativeMethods.WM_VKEYTOITEM:
                case NativeMethods.WM_CHARTOITEM:
                case NativeMethods.WM_COMPAREITEM:
                    if (!ReflectMessageInternal(m.LParam, ref m)) {
                        DefWndProc(ref m);
                    }
                    break;
                case NativeMethods.WM_IME_CHAR:
                    WmIMEChar(ref m);
                    break;
                case NativeMethods.WM_KILLFOCUS:
                    WmKillFocus(ref m);
                    break;
                case NativeMethods.WM_LBUTTONDBLCLK:
                    WmMouseDown(ref m, MouseButtons.Left, 2);
                    if (GetStyle(ControlStyles.StandardDoubleClick)) {
                        SetState(STATE_DOUBLECLICKFIRED, true);
                    }
                    break;
                case NativeMethods.WM_LBUTTONDOWN:
                    WmMouseDown(ref m, MouseButtons.Left, 1);
                    break;
                case NativeMethods.WM_LBUTTONUP:
                    WmMouseUp(ref m, MouseButtons.Left, 1);
                    break;
                case NativeMethods.WM_MBUTTONDBLCLK:
                    WmMouseDown(ref m, MouseButtons.Middle, 2);
                    if (GetStyle(ControlStyles.StandardDoubleClick)) {
                        SetState(STATE_DOUBLECLICKFIRED, true);
                    }
                    break;
                case NativeMethods.WM_MBUTTONDOWN:
                    WmMouseDown(ref m, MouseButtons.Middle, 1);
                    break;
                case NativeMethods.WM_MBUTTONUP:
                    WmMouseUp(ref m, MouseButtons.Middle, 1);
                    break;
                case NativeMethods.WM_XBUTTONDOWN:
                    WmMouseDown(ref m, GetXButton(NativeMethods.Util.HIWORD(m.WParam)), 1);
                    break;            
                case NativeMethods.WM_XBUTTONUP:
                    WmMouseUp(ref m, GetXButton(NativeMethods.Util.HIWORD(m.WParam)), 1);
                    break;
                case NativeMethods.WM_XBUTTONDBLCLK:
                    WmMouseDown(ref m, GetXButton(NativeMethods.Util.HIWORD(m.WParam)), 2);
                    if (GetStyle(ControlStyles.StandardDoubleClick)) {
                        SetState(STATE_DOUBLECLICKFIRED, true);
                    }
                    break;
                case NativeMethods.WM_MOUSELEAVE:
                    WmMouseLeave(ref m);
                    break;
                case NativeMethods.WM_MOUSEMOVE:
                    WmMouseMove(ref m);
                    break;
                case NativeMethods.WM_MOUSEWHEEL:
                    WmMouseWheel(ref m);
                    break;
                case NativeMethods.WM_MOVE:
                    WmMove(ref m);
                    break;
                case NativeMethods.WM_NOTIFY:
                    WmNotify(ref m);
                    break;
                case NativeMethods.WM_NOTIFYFORMAT:
                    WmNotifyFormat(ref m);
                    break;
                case NativeMethods.WM_REFLECT + NativeMethods.WM_NOTIFYFORMAT:
                    m.Result = (IntPtr)(Marshal.SystemDefaultCharSize == 1 ? NativeMethods.NFR_ANSI : NativeMethods.NFR_UNICODE);
                    break;
                case NativeMethods.WM_SHOWWINDOW:
                    WmShowWindow(ref m);
                    break;
                case NativeMethods.WM_RBUTTONDBLCLK:
                    WmMouseDown(ref m, MouseButtons.Right, 2);
                    if (GetStyle(ControlStyles.StandardDoubleClick)) {
                        SetState(STATE_DOUBLECLICKFIRED, true);
                    }
                    break;
                case NativeMethods.WM_RBUTTONDOWN:
                    WmMouseDown(ref m, MouseButtons.Right, 1);
                    break;
                case NativeMethods.WM_RBUTTONUP:
                    WmMouseUp(ref m, MouseButtons.Right, 1);
                    break;
                case NativeMethods.WM_SETFOCUS:
                    WmSetFocus(ref m);
                    break;
                case NativeMethods.WM_SYSCOLORCHANGE:
                    WmSysColorChange(ref m);
                    break;
                case NativeMethods.WM_MOUSEHOVER:
                    WmMouseHover(ref m);
                    break;
                case NativeMethods.WM_WINDOWPOSCHANGED:
                    WmWindowPosChanged(ref m);
                    break;
                case NativeMethods.WM_QUERYNEWPALETTE: 
                    WmQueryNewPalette(ref m);
                    break;
                case NativeMethods.WM_UPDATEUISTATE:
                    WmUpdateUIState(ref m);
                    break;
                case NativeMethods.WM_PARENTNOTIFY:
                    WmParentNotify(ref m);
                    break;
                default:
                    // If we received a thread execute message, then execute it.
                    //
                    if (m.Msg == threadCallbackMessage && m.Msg != 0) {
                        InvokeMarshaledCallbacks();
                        return;
                    }
                    else if (m.Msg == Control.WM_GETCONTROLNAME) {
                        WmGetControlName(ref m);
                        return;
                    }
                    
                    #if WIN95_SUPPORT
                    // If we have to route the mousewheel messages, do it (this logic was taken
                    // from the MFC sources...)
                    //
                    if (mouseWheelRoutingNeeded) {
                        if (m.Msg == mouseWheelMessage) {
                            Keys keyState = Keys.None;
                            keyState |= (Keys)((UnsafeNativeMethods.GetKeyState((int)Keys.ControlKey) < 0) ? NativeMethods.MK_CONTROL : 0);
                            keyState |= (Keys)((UnsafeNativeMethods.GetKeyState((int)Keys.ShiftKey) < 0) ? NativeMethods.MK_SHIFT : 0);

                            IntPtr hwndFocus = UnsafeNativeMethods.GetFocus();

                            if (hwndFocus == IntPtr.Zero) {
                                SendMessage(m.Msg, (IntPtr)(((int)m.WParam << 16) | (int)keyState), m.LParam);
                            }
                            else {
                                IntPtr result = IntPtr.Zero;
                                IntPtr hwndDesktop = UnsafeNativeMethods.GetDesktopWindow();

                                while (result == IntPtr.Zero && hwndFocus != IntPtr.Zero && hwndFocus != hwndDesktop) {
                                    result = UnsafeNativeMethods.SendMessage(new HandleRef(null, hwndFocus),
                                                                       NativeMethods.WM_MOUSEWHEEL,
                                                                       ((int)m.WParam << 16) | (int)keyState,
                                                                       m.LParam);
                                    hwndFocus = UnsafeNativeMethods.GetParent(new HandleRef(null, hwndFocus));
                                }
                            }
                        }
                    }
                    #endif

                    if (m.Msg == NativeMethods.WM_MOUSEENTER) {
                        WmMouseEnter(ref m);
                        break;
                    }

                    DefWndProc(ref m);
                    break;
            }

        }

        /// <devdoc>
        ///      Called when an exception occurs in dispatching messages through
        ///      the main window procedure.
        /// </devdoc>
        private void WndProcException(Exception e) {
            Application.OnThreadException(e);
        }

        /// <devdoc>
        /// </devdoc>
        internal sealed class ControlNativeWindow : NativeWindow, IWindowTarget {
            private Control         control;
            private GCHandle        rootRef;   // We will root the control when we do not want to be elligible for garbage collection.
            internal IWindowTarget  target;

            internal ControlNativeWindow(Control control) {
                this.control = control;
                target = this;
            }
            
            ~ControlNativeWindow() {
            
                // This same post is done in Control's Dispose method, so if you change
                // it, change it there too.
                //
                if (Handle != IntPtr.Zero) {
                    UnsafeNativeMethods.PostMessage(new HandleRef(this, Handle), NativeMethods.WM_CLOSE, 0, 0);
                }
                
                // This releases the handle from our window proc, re-routing it back to
                // the system.
                //
            }

            public Control GetControl() {
                return control;
            }

            protected override void OnHandleChange() {
                target.OnHandleChange(this.Handle);
            }

            // IWindowTarget method
            public void OnHandleChange(IntPtr newHandle) {
                control.SetHandle(newHandle);
            }

            public void LockReference(bool locked) {
                if (locked) {
                    if (!rootRef.IsAllocated) {
                        rootRef = GCHandle.Alloc(GetControl(), GCHandleType.Normal);
                    }
                }
                else {
                    if (rootRef.IsAllocated) {
                        rootRef.Free();
                    }
                }
            }

            protected override void OnThreadException(Exception e) {
                control.WndProcException(e);
            }

            // IWindowTarget method
            public void OnMessage(ref Message m) {
                control.WndProc(ref m);
            }

            public IWindowTarget WindowTarget {
                get {
                    return target;
                }
                set {
                    target = value;
                }
            }

            #if DEBUG
            // We override ToString so in debug asserts that fire for
            // non-released controls will show what control wasn't released.
            //
            public override string ToString() {
                if (control != null) {
                    return control.GetType().FullName;
                }
                return base.ToString();
            }
            #endif

            protected override void WndProc(ref Message m) {
                // There are certain messages that we want to process
                // regardless of what window target we are using.  These
                // messages cause other messages or state transitions
                // to occur within control.
                //
                switch (m.Msg) {
                    case NativeMethods.WM_MOUSELEAVE:
                        control.UnhookMouseEvent();
                        break;

                    case NativeMethods.WM_MOUSEMOVE:
                        if (!control.GetState(Control.STATE_TRACKINGMOUSEEVENT)) {
                            control.HookMouseEvent();
                            if (!control.GetState(Control.STATE_MOUSEENTERPENDING)) {
                                control.SendMessage(NativeMethods.WM_MOUSEENTER, 0, 0);
                            }
                            else {
                                control.SetState(Control.STATE_MOUSEENTERPENDING, false);
                            }
                        }
                        break;

                    case NativeMethods.WM_MOUSEWHEEL:
                        // TrackMouseEvent's mousehover implementation doesn't watch the wheel
                        // correctly...
                        //
                        control.ResetMouseEventArgs();
                        break;
                }

                target.OnMessage(ref m);
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ControlCollection"]/*' />
        /// <devdoc>
        ///     Collection of controls...
        /// </devdoc>
        [
            ListBindable(false),
            DesignerSerializer("System.Windows.Forms.Design.ControlCollectionCodeDomSerializer, " + AssemblyRef.SystemDesign, "System.ComponentModel.Design.Serialization.CodeDomSerializer, " + AssemblyRef.SystemDesign),
        ]
        public class ControlCollection : IList, ICloneable {

            private Control owner;
            private Control[] controls;             // Control list in z-order (0 = top of z-order)
            private int controlCount;

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ControlCollection.ControlCollection"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public ControlCollection(Control owner) {
                this.owner = owner;
            }
            
            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ControlCollection.Count"]/*' />
            /// <devdoc>
            ///     Retrieves the number of child controls.
            /// </devdoc>
            public int Count {
                get {
                    return controlCount;
                }
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="ControlCollection.ICollection.SyncRoot"]/*' />
            /// <internalonly/>
            object ICollection.SyncRoot {
                get {
                    return this;
                }
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="ControlCollection.ICollection.IsSynchronized"]/*' />
            /// <internalonly/>
            bool ICollection.IsSynchronized {
                get {
                    return false;
                }
            }
            
            /// <include file='doc\Control.uex' path='docs/doc[@for="ControlCollection.IList.IsFixedSize"]/*' />
            /// <internalonly/>
            bool IList.IsFixedSize {
                get {
                    return false;
                }
            }
            
            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ControlCollection.IsReadOnly"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool IsReadOnly {
                get {
                    return false;
                }
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ControlCollection.Add"]/*' />
            /// <devdoc>
            ///    <para>Adds a child control to this control. The control becomes the last control in 
            ///       the child control list. If the control is already a child of another control it
            ///       is first removed from that control.</para>
            /// </devdoc>
            public virtual void Add(Control value) {
                if (value == null)
                    return;
                if (value.GetTopLevel()) {
                    throw new ArgumentException(SR.GetString(SR.TopLevelControlAdd));
                }

                // Verify that the control being added is on the same thread as
                // us...or our parent chain.
                //
                if (owner.CreateThreadId != value.CreateThreadId) {
                    throw new ArgumentException(SR.GetString(SR.AddDifferentThreads));
                }

                CheckParentingCycle(owner, value);

                if (value.parent == owner) {
                    value.SendToBack();
                    return;
                }

                // Increase control array size if necessary to accomodate new control
                //
                if (controls == null) {
                    controls = new Control[4];
                }
                else if (controls.Length == controlCount) {
                    Control[] newControls = new Control[controlCount * 2];
                    Array.Copy(controls, 0, newControls, 0, controlCount);
                    controls = newControls;
                }

                // Remove the new control from its old parent (if any)
                //
                if (value.parent != null) {
                    value.parent.Controls.Remove(value);
                }

                // Add the control
                //
                controls[controlCount] = value;

                if (value.tabIndex == -1) {

                    // Find the next highest tab index
                    //
                    int nextTabIndex = 0;
                    for (int c = 0; c < controlCount; c++) {
                        int t = controls[c].TabIndex;
                        if (nextTabIndex <= t) {
                            nextTabIndex = t + 1;
                        }
                    }
                    value.tabIndex = nextTabIndex;
                }

                // if we don't suspend layout, AssignParent will indirectly trigger a layout event 
                // before we're ready (AssignParent will fire a PropertyChangedEvent("Visible"), which calls PerformLayout)
                //
#if DEBUG
        int dbgLayoutCheck = owner.LayoutSuspendCount;
#endif
                owner.SuspendLayout();
                controlCount++;

                try {
                    value.AssignParent(owner);

                    if ((owner.state & STATE_CREATED) != 0) {
                        value.SetParentHandle(owner.window.Handle);
                        if (value.Visible) {
                            value.CreateControl();
                        }
                    }

                    value.InitLayout();
                }
                finally {
                    owner.ResumeLayout(false);
#if DEBUG
        owner.AssertLayoutSuspendCount(dbgLayoutCheck);
#endif
                }

                owner.PerformLayout(value, "Parent");
                owner.OnControlAdded(new ControlEventArgs(value));
            }
            
            /// <include file='doc\Control.uex' path='docs/doc[@for="ControlCollection.IList.Add"]/*' />
            /// <internalonly/>
            int IList.Add(object control) {
                if (control is Control) {
                    Add((Control)control);
                    return IndexOf((Control)control);
                }
                else {
                    throw new ArgumentException("control");
                }
            }
            
            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ControlCollection.AddRange"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public virtual void AddRange(Control[] controls) {
                if (controls == null) {
                    throw new ArgumentNullException("controls");
                }
                if (controls.Length > 0) {
#if DEBUG
        int dbgLayoutCheck = owner.LayoutSuspendCount;
#endif
                    owner.SuspendLayout();
                    for(int i=0;i < controls.Length; ++i) {
                        Add(controls[i]);
                    }
                    owner.ResumeLayout(true);
#if DEBUG
        owner.AssertLayoutSuspendCount(dbgLayoutCheck);
#endif
                }
            }
            
            /// <include file='doc\Control.uex' path='docs/doc[@for="ControlCollection.ICloneable.Clone"]/*' />
            /// <internalonly/>
            object ICloneable.Clone() {
                ControlCollection ccOther = owner.CreateControlsInstance();
                if (controls != null) {
                    ccOther.controls = new Control[controls.Length];
                    Array.Copy(controls, 0, ccOther.controls, 0, controls.Length);
                }
                return ccOther;
            }
            
            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ControlCollection.Contains"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool Contains(Control control) {
                return IndexOf(control) != -1;
            }
            
            /// <include file='doc\Control.uex' path='docs/doc[@for="ControlCollection.IList.Contains"]/*' />
            /// <internalonly/>
            bool IList.Contains(object control) {
                if (control is Control) {
                    return Contains((Control)control);
                }
                else { 
                    return false;
                }
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ControlCollection.CopyTo"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public void CopyTo(Array dest, int index) {
                if (controlCount > 0) {
                    System.Array.Copy(controls, 0, dest, index, controlCount);
                }
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ControlCollection.Equals"]/*' />
            /// <internalonly/>
            public override bool Equals(object other) {
                ControlCollection ccOther = other as ControlCollection;

                if (ccOther == null) {
                    return false;
                }

                if (((controls == null) != (ccOther.controls == null)) || (controls != null && controls.Length != ccOther.controls.Length)) {
                    return false;
                }

                if (controls == null) {
                    Debug.Assert(ccOther.controls == null, "How did that fairly easy looking condition above fail?");
                    return true;
                }

                for (int i = 0; i < controls.Length; i++) {
                    if (controls[i] != ccOther.controls[i]) {
                        return false;
                    }
                }
                return true;
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ControlCollection.GetHashCode"]/*' />
            /// <internalonly/>
            public override int GetHashCode() {
                return base.GetHashCode();
            }
            
            
            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ControlCollection.IndexOf"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public int IndexOf(Control control) {
                for(int index=0; index < controlCount; ++index) {
                    if (this[index] == control) {
                        return index;
                    }
                }
                return -1;
            }
            
            /// <include file='doc\Control.uex' path='docs/doc[@for="ControlCollection.IList.IndexOf"]/*' />
            /// <internalonly/>
            int IList.IndexOf(object control) {
                if (control is Control) {
                    return IndexOf((Control)control);
                }
                else { 
                    return -1;
                }
            }
            
            /// <include file='doc\Control.uex' path='docs/doc[@for="ControlCollection.IList.Insert"]/*' />
            /// <internalonly/>
            void IList.Insert(int index, object value) {
                throw new NotSupportedException();
            }
            
            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ControlCollection.Remove"]/*' />
            /// <devdoc>
            ///     Removes control from this control. Inheriting controls should call
            ///     base.remove to ensure that the control is removed.
            /// </devdoc>
            public virtual void Remove(Control value) {
            
                // Sanity check parameter
                //
                if (value == null) {
                    return;     // Don't do anything
                }
                
                bool notifyRemove = (value.ParentInternal == owner);

                if (value.parent == owner) {
                    value.SetParentHandle(IntPtr.Zero);
                    
                    // Remove the control from the internal control array
                    //
                    int i = GetChildIndex(value);
                    System.Array.Copy(controls, i + 1, controls, i, controlCount - i - 1);
                    controlCount--;
                    controls[controlCount] = null;
                    value.AssignParent(null);

                    owner.PerformLayout(value, "Parent");
                    owner.OnControlRemoved(new ControlEventArgs(value));
                }

                if (notifyRemove) {
                    Debug.Assert(owner != null);
                    ContainerControl cc = owner.GetContainerControlInternal() as ContainerControl;
                    if (cc != null)
                    {
                        cc.AfterControlRemoved(value);
                    }
                }

            }
            
            /// <include file='doc\Control.uex' path='docs/doc[@for="ControlCollection.IList.Remove"]/*' />
            /// <internalonly/>
            void IList.Remove(object control) {
                if (control is Control) {
                    Remove((Control)control);
                }                
            }
            
            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ControlCollection.RemoveAt"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public void RemoveAt(int index) {
                Remove(this[index]);
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ControlCollection.this"]/*' />
            /// <devdoc>
            ///     Retrieves the child control with the specified index.
            /// </devdoc>
            public virtual Control this[int index] {
                get {
                    //do some bounds checking here...
                    if (index < 0 || index >= controlCount) {
                        throw new ArgumentOutOfRangeException(SR.GetString(SR.IndexOutOfRange, index.ToString()));
                    }

                    return controls[index];
                }
            }
            
            /// <include file='doc\Control.uex' path='docs/doc[@for="ControlCollection.IList.this"]/*' />
            /// <internalonly/>
            object IList.this[int index] {
                get {
                    return this[index];
                }
                set {
                    throw new NotSupportedException();
                }
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ControlCollection.Clear"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public virtual void Clear() {
                while (Count != 0)
                    RemoveAt( Count - 1 );
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ControlCollection.GetChildIndex"]/*' />
            /// <devdoc>
            ///     Retrieves the index of the specified
            ///     child control in this array.  An ArgumentException
            ///     is thrown if child is not parented to this
            ///     Control.
            /// </devdoc>
            public int GetChildIndex(Control child) {
                return GetChildIndex(child, true);
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ControlCollection.GetChildIndex1"]/*' />
            /// <devdoc>
            ///     Retrieves the index of the specified
            ///     child control in this array.  An ArgumentException
            ///     is thrown if child is not parented to this
            ///     Control.
            /// </devdoc>
            public int GetChildIndex(Control child, bool throwException) {
                int index = Array.IndexOf(controls, child, 0, controlCount);
                if (index == -1 && throwException) {
                    throw new ArgumentException(SR.GetString(SR.ControlNotChild));
                }
                return index;
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ControlCollection.GetEnumerator"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public IEnumerator GetEnumerator() {
                return new WindowsFormsUtils.ArraySubsetEnumerator(controls, controlCount);
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ControlCollection.SetChildIndex"]/*' />
            /// <devdoc>
            ///     Sets the index of the specified
            ///     child control in this array.  An ArgumentException
            ///     is thrown if child is not parented to this
            ///     Control.
            /// </devdoc>
            public void SetChildIndex(Control child, int newIndex) {
            
                // Sanity check parameters
                //
                if (child == null) {
                    throw new ArgumentNullException("child");
                }
            
                int currentIndex = GetChildIndex(child);

                if (currentIndex == newIndex) {
                    return;
                }

                if (newIndex >= controlCount || newIndex == -1) {
                    newIndex = controlCount - 1;
                }

                Control.MoveControl(controls, child, currentIndex, newIndex);
                child.UpdateZOrder();

                owner.PerformLayout();
            }

        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.UnsafeNativeMethods.IOleControl.GetControlInfo"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        int UnsafeNativeMethods.IOleControl.GetControlInfo(NativeMethods.tagCONTROLINFO pCI) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:GetControlInfo");

            pCI.cb = Marshal.SizeOf(typeof(NativeMethods.tagCONTROLINFO));
            pCI.hAccel = IntPtr.Zero;
            pCI.cAccel = 0;
            pCI.dwFlags = 0;

            if (IsInputKey(Keys.Return)) {
                pCI.dwFlags |= NativeMethods.CTRLINFO_EATS_RETURN;
            }
            if (IsInputKey(Keys.Escape)) {
                pCI.dwFlags |= NativeMethods.CTRLINFO_EATS_ESCAPE;
            }

            ActiveXInstance.GetControlInfo(pCI);
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.UnsafeNativeMethods.IOleControl.OnMnemonic"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        int UnsafeNativeMethods.IOleControl.OnMnemonic(ref NativeMethods.MSG pMsg) {

            // If we got a mnemonic here, then the appropriate control will focus itself which
            // will cause us to become UI active.
            //
            bool processed = ProcessMnemonic((char)pMsg.wParam);
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:OnMnemonic processed: " + processed.ToString());
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.UnsafeNativeMethods.IOleControl.OnAmbientPropertyChange"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        int UnsafeNativeMethods.IOleControl.OnAmbientPropertyChange(int dispID) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:OnAmbientPropertyChange.  Dispid: " + dispID);
            Debug.Indent();
            ActiveXInstance.OnAmbientPropertyChange(dispID);
            Debug.Unindent();
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.UnsafeNativeMethods.IOleControl.FreezeEvents"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        int UnsafeNativeMethods.IOleControl.FreezeEvents(int bFreeze) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:FreezeEvents.  Freeze: " + bFreeze);
            ActiveXInstance.EventsFrozen = (bFreeze != 0);
            Debug.Assert(ActiveXInstance.EventsFrozen == (bFreeze != 0), "Failed to set EventsFrozen correctly");
            return NativeMethods.S_OK;
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        int UnsafeNativeMethods.IOleInPlaceActiveObject.GetWindow(out IntPtr hwnd) {
            return((UnsafeNativeMethods.IOleInPlaceObject)this).GetWindow(out hwnd);
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        void UnsafeNativeMethods.IOleInPlaceActiveObject.ContextSensitiveHelp(int fEnterMode) {
            ((UnsafeNativeMethods.IOleInPlaceObject)this).ContextSensitiveHelp(fEnterMode);
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        int UnsafeNativeMethods.IOleInPlaceActiveObject.TranslateAccelerator(ref NativeMethods.MSG lpmsg) {
            return ActiveXInstance.TranslateAccelerator(ref lpmsg);
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        void UnsafeNativeMethods.IOleInPlaceActiveObject.OnFrameWindowActivate(int fActivate) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:OnFrameWindowActivate");
            // return NativeMethods.S_OK;
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        void UnsafeNativeMethods.IOleInPlaceActiveObject.OnDocWindowActivate(int fActivate) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:OnDocWindowActivate.  Activate: " + fActivate.ToString());
            Debug.Indent();
            ActiveXInstance.OnDocWindowActivate(fActivate);
            Debug.Unindent();
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        void UnsafeNativeMethods.IOleInPlaceActiveObject.ResizeBorder(NativeMethods.COMRECT prcBorder, UnsafeNativeMethods.IOleInPlaceUIWindow pUIWindow, int fFrameWindow) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:ResizesBorder");
            // return NativeMethods.S_OK;
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        void UnsafeNativeMethods.IOleInPlaceActiveObject.EnableModeless(int fEnable) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:EnableModeless");
            // return NativeMethods.S_OK;
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        int UnsafeNativeMethods.IOleInPlaceObject.GetWindow(out IntPtr hwnd) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:GetWindow");
            int hr = ActiveXInstance.GetWindow(out hwnd);
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "\twin == " + hwnd);
            return hr;
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        void UnsafeNativeMethods.IOleInPlaceObject.ContextSensitiveHelp(int fEnterMode) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:ContextSensitiveHelp.  Mode: " + fEnterMode.ToString());
            if (fEnterMode != 0) {
                OnHelpRequested(new HelpEventArgs(Control.MousePosition));
            }
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        void UnsafeNativeMethods.IOleInPlaceObject.InPlaceDeactivate() {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:InPlaceDeactivate");
            Debug.Indent();
            ActiveXInstance.InPlaceDeactivate();
            Debug.Unindent();
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        int UnsafeNativeMethods.IOleInPlaceObject.UIDeactivate() {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:UIDeactivate");
            return ActiveXInstance.UIDeactivate();
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        void UnsafeNativeMethods.IOleInPlaceObject.SetObjectRects(NativeMethods.COMRECT lprcPosRect, NativeMethods.COMRECT lprcClipRect) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:SetObjectRects(" + lprcClipRect.left + ", " + lprcClipRect.top + ", " + lprcClipRect.right + ", " + lprcClipRect.bottom + ")");
            Debug.Indent();
            ActiveXInstance.SetObjectRects(lprcPosRect, lprcClipRect);
            Debug.Unindent();
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        void UnsafeNativeMethods.IOleInPlaceObject.ReactivateAndUndo() {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:ReactivateAndUndo");
            // return NativeMethods.S_OK;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.UnsafeNativeMethods.IOleObject.SetClientSite"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        int UnsafeNativeMethods.IOleObject.SetClientSite(UnsafeNativeMethods.IOleClientSite pClientSite) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:SetClientSite");
            ActiveXInstance.SetClientSite(pClientSite);
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.UnsafeNativeMethods.IOleObject.GetClientSite"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        UnsafeNativeMethods.IOleClientSite UnsafeNativeMethods.IOleObject.GetClientSite() {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:GetClientSite");
            return ActiveXInstance.GetClientSite();
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.UnsafeNativeMethods.IOleObject.SetHostNames"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        int UnsafeNativeMethods.IOleObject.SetHostNames(string szContainerApp, string szContainerObj) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:SetHostNames");
            // Since ActiveX controls never "open" for editing, we shouldn't need
            // to store these.
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.UnsafeNativeMethods.IOleObject.Close"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        int UnsafeNativeMethods.IOleObject.Close(int dwSaveOption) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:Close. Save option: " + dwSaveOption);
            ActiveXInstance.Close(dwSaveOption);
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.UnsafeNativeMethods.IOleObject.SetMoniker"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        int UnsafeNativeMethods.IOleObject.SetMoniker(int dwWhichMoniker, Object pmk) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:SetMoniker");
            return NativeMethods.E_NOTIMPL;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.UnsafeNativeMethods.IOleObject.GetMoniker"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        int UnsafeNativeMethods.IOleObject.GetMoniker(int dwAssign, int dwWhichMoniker, out Object moniker) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:GetMoniker");
            moniker = null;
            return NativeMethods.E_NOTIMPL;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.UnsafeNativeMethods.IOleObject.InitFromData"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        int UnsafeNativeMethods.IOleObject.InitFromData(UnsafeNativeMethods.IOleDataObject pDataObject, int fCreation, int dwReserved) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:InitFromData");
            return NativeMethods.E_NOTIMPL;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.UnsafeNativeMethods.IOleObject.GetClipboardData"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        int UnsafeNativeMethods.IOleObject.GetClipboardData(int dwReserved, out UnsafeNativeMethods.IOleDataObject data) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:GetClipboardData");
            data = null;
            return NativeMethods.E_NOTIMPL;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.UnsafeNativeMethods.IOleObject.DoVerb"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        int UnsafeNativeMethods.IOleObject.DoVerb(int iVerb, IntPtr lpmsg, UnsafeNativeMethods.IOleClientSite pActiveSite, int lindex, IntPtr hwndParent, NativeMethods.COMRECT lprcPosRect) {

            // In Office they are internally casting an iverb to a short and not
            // doing the proper sign extension.  So, we do it here.
            //
            short sVerb = unchecked((short)iVerb);
            iVerb = (int)sVerb;

#if DEBUG
            if (CompModSwitches.ActiveX.TraceInfo) {
                Debug.WriteLine("AxSource:DoVerb {");
                Debug.WriteLine("     verb: " + iVerb);
                Debug.WriteLine("     msg: " + lpmsg);
                Debug.WriteLine("     activeSite: " + pActiveSite);
                Debug.WriteLine("     index: " + lindex);
                Debug.WriteLine("     hwndParent: " + hwndParent);
                Debug.WriteLine("     posRect: " + lprcPosRect);
            }
#endif
            Debug.Indent();
            try {
                ActiveXInstance.DoVerb(iVerb, lpmsg, pActiveSite, lindex, hwndParent, lprcPosRect);
            }
            catch (Exception e) {
                Debug.Fail("Exception occured during DoVerb(" + iVerb + ") " + e.ToString());
                throw e;
            }
            finally {
                Debug.Unindent();
                Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "}");
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.UnsafeNativeMethods.IOleObject.EnumVerbs"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        int UnsafeNativeMethods.IOleObject.EnumVerbs(out UnsafeNativeMethods.IEnumOLEVERB e) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:EnumVerbs");
            return ActiveXImpl.EnumVerbs(out e);
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.UnsafeNativeMethods.IOleObject.OleUpdate"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        int UnsafeNativeMethods.IOleObject.OleUpdate() {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:OleUpdate");
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.UnsafeNativeMethods.IOleObject.IsUpToDate"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        int UnsafeNativeMethods.IOleObject.IsUpToDate() {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:IsUpToDate");
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.UnsafeNativeMethods.IOleObject.GetUserClassID"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        int UnsafeNativeMethods.IOleObject.GetUserClassID(ref Guid pClsid) {
            pClsid = GetType().GUID;
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:GetUserClassID.  ClassID: " + pClsid.ToString());
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.UnsafeNativeMethods.IOleObject.GetUserType"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        int UnsafeNativeMethods.IOleObject.GetUserType(int dwFormOfType, out string userType) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:GetUserType");
            if (dwFormOfType == NativeMethods.USERCLASSTYPE_FULL) {
                userType = GetType().FullName;
            }
            else {
                userType = GetType().Name;
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.UnsafeNativeMethods.IOleObject.SetExtent"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        int UnsafeNativeMethods.IOleObject.SetExtent(int dwDrawAspect, NativeMethods.tagSIZEL pSizel) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:SetExtent(" + pSizel.cx + ", " + pSizel.cy + ")");
            Debug.Indent();
            ActiveXInstance.SetExtent(dwDrawAspect, pSizel);
            Debug.Unindent();
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.UnsafeNativeMethods.IOleObject.GetExtent"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        int UnsafeNativeMethods.IOleObject.GetExtent(int dwDrawAspect, NativeMethods.tagSIZEL pSizel) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:GetExtent.  Aspect: " + dwDrawAspect.ToString());
            Debug.Indent();
            ActiveXInstance.GetExtent(dwDrawAspect, pSizel);
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "value: " + pSizel.cx + ", " + pSizel.cy);
            Debug.Unindent();
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.UnsafeNativeMethods.IOleObject.Advise"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        int UnsafeNativeMethods.IOleObject.Advise(UnsafeNativeMethods.IAdviseSink pAdvSink, out int cookie) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:Advise");
            cookie = ActiveXInstance.Advise(pAdvSink);
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.UnsafeNativeMethods.IOleObject.Unadvise"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        int UnsafeNativeMethods.IOleObject.Unadvise(int dwConnection) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:Unadvise");
            Debug.Indent();
            ActiveXInstance.Unadvise(dwConnection);
            Debug.Unindent();
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.UnsafeNativeMethods.IOleObject.EnumAdvise"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        int UnsafeNativeMethods.IOleObject.EnumAdvise(out UnsafeNativeMethods.IEnumSTATDATA e) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:EnumAdvise");
            e = null;
            return NativeMethods.E_NOTIMPL;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.UnsafeNativeMethods.IOleObject.GetMiscStatus"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        int UnsafeNativeMethods.IOleObject.GetMiscStatus(int dwAspect, out int cookie) {
            if ((dwAspect & NativeMethods.DVASPECT_CONTENT) != 0) {
                int status = NativeMethods.OLEMISC_ACTIVATEWHENVISIBLE | NativeMethods.OLEMISC_INSIDEOUT | NativeMethods.OLEMISC_SETCLIENTSITEFIRST;

                if (GetStyle(ControlStyles.ResizeRedraw)) {
                    status |= NativeMethods.OLEMISC_RECOMPOSEONRESIZE;
                }

                if (this is IButtonControl) {
                    status |= NativeMethods.OLEMISC_ACTSLIKEBUTTON;
                }

                Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:GetMiscStatus. Status: " + status.ToString());
                cookie = status;
            }
            else {
                Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:GetMiscStatus.  Status: ERROR, wrong aspect.");
                cookie = 0;
                return NativeMethods.DV_E_DVASPECT;
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.UnsafeNativeMethods.IOleObject.SetColorScheme"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        int UnsafeNativeMethods.IOleObject.SetColorScheme(NativeMethods.tagLOGPALETTE pLogpal) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:SetColorScheme");
            return NativeMethods.S_OK;
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        int UnsafeNativeMethods.IOleWindow.GetWindow(out IntPtr hwnd) {
            return((UnsafeNativeMethods.IOleInPlaceObject)this).GetWindow(out hwnd);
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        void UnsafeNativeMethods.IOleWindow.ContextSensitiveHelp(int fEnterMode) {
            ((UnsafeNativeMethods.IOleInPlaceObject)this).ContextSensitiveHelp(fEnterMode);
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        void UnsafeNativeMethods.IPersist.GetClassID(out Guid pClassID) {
            pClassID = GetType().GUID;
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:IPersist.GetClassID.  ClassID: " + pClassID.ToString());
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        void UnsafeNativeMethods.IPersistPropertyBag.InitNew() {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:IPersistPropertyBag.InitNew");
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        void UnsafeNativeMethods.IPersistPropertyBag.GetClassID(out Guid pClassID) {
            pClassID = GetType().GUID;
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:IPersistPropertyBag.GetClassID.  ClassID: " + pClassID.ToString());
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        void UnsafeNativeMethods.IPersistPropertyBag.Load(UnsafeNativeMethods.IPropertyBag pPropBag, UnsafeNativeMethods.IErrorLog pErrorLog) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:Load (IPersistPropertyBag)");
            Debug.Indent();
            ActiveXInstance.Load(pPropBag, pErrorLog);
            Debug.Unindent();
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        void UnsafeNativeMethods.IPersistPropertyBag.Save(UnsafeNativeMethods.IPropertyBag pPropBag, bool fClearDirty, bool fSaveAllProperties) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:Save (IPersistPropertyBag)");
            Debug.Indent();
            ActiveXInstance.Save(pPropBag, fClearDirty, fSaveAllProperties);
            Debug.Unindent();
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        void UnsafeNativeMethods.IPersistStorage.GetClassID(out Guid pClassID) {
            pClassID = GetType().GUID;
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:IPersistStorage.GetClassID.  ClassID: " + pClassID.ToString());
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        int UnsafeNativeMethods.IPersistStorage.IsDirty() {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:IPersistStorage.IsDirty");
            return ActiveXInstance.IsDirty();
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        void UnsafeNativeMethods.IPersistStorage.InitNew(UnsafeNativeMethods.IStorage pstg) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:IPersistStorage.InitNew");
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        int UnsafeNativeMethods.IPersistStorage.Load(UnsafeNativeMethods.IStorage pstg) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:IPersistStorage.Load");
            Debug.Indent();
            ActiveXInstance.Load(pstg);
            Debug.Unindent();
            return NativeMethods.S_OK;
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        void UnsafeNativeMethods.IPersistStorage.Save(UnsafeNativeMethods.IStorage pstg, int fSameAsLoad) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:IPersistStorage.Save");
            Debug.Indent();
            ActiveXInstance.Save(pstg, fSameAsLoad);
            Debug.Unindent();
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        void UnsafeNativeMethods.IPersistStorage.SaveCompleted(UnsafeNativeMethods.IStorage pStgNew) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:IPersistStorage.SaveCompleted");
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        void UnsafeNativeMethods.IPersistStorage.HandsOffStorage() {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:IPersistStorage.HandsOffStorage");
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        void UnsafeNativeMethods.IPersistStreamInit.GetClassID(out Guid pClassID) {
            pClassID = GetType().GUID;
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:IPersistStreamInit.GetClassID.  ClassID: " + pClassID.ToString());
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        int UnsafeNativeMethods.IPersistStreamInit.IsDirty() {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:IPersistStreamInit.IsDirty");
            return ActiveXInstance.IsDirty();
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        void UnsafeNativeMethods.IPersistStreamInit.Load(UnsafeNativeMethods.IStream pstm) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:IPersistStreamInit.Load");
            Debug.Indent();
            ActiveXInstance.Load(pstm);
            Debug.Unindent();
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        void UnsafeNativeMethods.IPersistStreamInit.Save(UnsafeNativeMethods.IStream pstm, bool fClearDirty) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:IPersistStreamInit.Save");
            Debug.Indent();
            ActiveXInstance.Save(pstm, fClearDirty);
            Debug.Unindent();
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        void UnsafeNativeMethods.IPersistStreamInit.GetSizeMax(long pcbSize) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:GetSizeMax");
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        void UnsafeNativeMethods.IPersistStreamInit.InitNew() {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:IPersistStreamInit.InitNew");
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        void UnsafeNativeMethods.IQuickActivate.QuickActivate(UnsafeNativeMethods.tagQACONTAINER pQaContainer, UnsafeNativeMethods.tagQACONTROL pQaControl) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:QuickActivate");
            Debug.Indent();
            ActiveXInstance.QuickActivate(pQaContainer, pQaControl);
            Debug.Unindent();
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        void UnsafeNativeMethods.IQuickActivate.SetContentExtent(NativeMethods.tagSIZEL pSizel) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:SetContentExtent");
            Debug.Indent();
            ActiveXInstance.SetExtent(NativeMethods.DVASPECT_CONTENT, pSizel);
            Debug.Unindent();
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        void UnsafeNativeMethods.IQuickActivate.GetContentExtent(NativeMethods.tagSIZEL pSizel) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:GetContentExtent");
            Debug.Indent();
            ActiveXInstance.GetExtent(NativeMethods.DVASPECT_CONTENT, pSizel);
            Debug.Unindent();
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        void UnsafeNativeMethods.IViewObject.Draw(int dwDrawAspect, int lindex, IntPtr pvAspect, NativeMethods.tagDVTARGETDEVICE ptd,
                                            IntPtr hdcTargetDev, IntPtr hdcDraw, NativeMethods.COMRECT lprcBounds, NativeMethods.COMRECT lprcWBounds,
                                            IntPtr pfnContinue, int dwContinue) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:Draw");
            Debug.Indent();
            ActiveXInstance.Draw(dwDrawAspect, lindex, pvAspect, ptd, hdcTargetDev,
                                 hdcDraw, lprcBounds, lprcWBounds, pfnContinue, dwContinue);
            Debug.Unindent();
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        int UnsafeNativeMethods.IViewObject.GetColorSet(int dwDrawAspect, int lindex, IntPtr pvAspect, NativeMethods.tagDVTARGETDEVICE ptd,
                                                   IntPtr hicTargetDev, NativeMethods.tagLOGPALETTE ppColorSet) {

            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:GetColorSet");

            // GDI+ doesn't do palettes.
            //
            return NativeMethods.E_NOTIMPL;
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        int UnsafeNativeMethods.IViewObject.Freeze(int dwDrawAspect, int lindex, IntPtr pvAspect, IntPtr pdwFreeze) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:Freezes");
            return NativeMethods.E_NOTIMPL;
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        int UnsafeNativeMethods.IViewObject.Unfreeze(int dwFreeze) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:Unfreeze");
            return NativeMethods.E_NOTIMPL;
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        void UnsafeNativeMethods.IViewObject.SetAdvise(int aspects, int advf, UnsafeNativeMethods.IAdviseSink pAdvSink) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:SetAdvise");
            ActiveXInstance.SetAdvise(aspects, advf, pAdvSink);
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        void UnsafeNativeMethods.IViewObject.GetAdvise(int[] paspects, int[] padvf, UnsafeNativeMethods.IAdviseSink[] pAdvSink) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:GetAdvise");
            ActiveXInstance.GetAdvise(paspects, padvf, pAdvSink);
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        void UnsafeNativeMethods.IViewObject2.Draw(int dwDrawAspect, int lindex, IntPtr pvAspect, NativeMethods.tagDVTARGETDEVICE ptd,
                                             IntPtr hdcTargetDev, IntPtr hdcDraw, NativeMethods.COMRECT lprcBounds, NativeMethods.COMRECT lprcWBounds,
                                             IntPtr pfnContinue, int dwContinue) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:Draw");
            Debug.Indent();
            ActiveXInstance.Draw(dwDrawAspect, lindex, pvAspect, ptd, hdcTargetDev,
                                 hdcDraw, lprcBounds, lprcWBounds, pfnContinue, dwContinue);
            Debug.Unindent();
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        int UnsafeNativeMethods.IViewObject2.GetColorSet(int dwDrawAspect, int lindex, IntPtr pvAspect, NativeMethods.tagDVTARGETDEVICE ptd,
                                                    IntPtr hicTargetDev, NativeMethods.tagLOGPALETTE ppColorSet) {

            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:GetColorSet");

            // GDI+ doesn't do palettes.
            //
            return NativeMethods.E_NOTIMPL;
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        int UnsafeNativeMethods.IViewObject2.Freeze(int dwDrawAspect, int lindex, IntPtr pvAspect, IntPtr pdwFreeze) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:Freezes");
            return NativeMethods.E_NOTIMPL;
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        int UnsafeNativeMethods.IViewObject2.Unfreeze(int dwFreeze) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:Unfreeze");
            return NativeMethods.E_NOTIMPL;
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        void UnsafeNativeMethods.IViewObject2.SetAdvise(int aspects, int advf, UnsafeNativeMethods.IAdviseSink pAdvSink) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:SetAdvise");
            ActiveXInstance.SetAdvise(aspects, advf, pAdvSink);
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        void UnsafeNativeMethods.IViewObject2.GetAdvise(int[] paspects, int[] padvf, UnsafeNativeMethods.IAdviseSink[] pAdvSink) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:GetAdvise");
            ActiveXInstance.GetAdvise(paspects, padvf, pAdvSink);
        }

        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        void UnsafeNativeMethods.IViewObject2.GetExtent(int dwDrawAspect, int lindex, NativeMethods.tagDVTARGETDEVICE ptd, NativeMethods.tagSIZEL lpsizel) {
            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:GetExtent (IViewObject2)");
            // we already have an implementation of this [from IOleObject]
            //
            ((UnsafeNativeMethods.IOleObject)this).GetExtent(dwDrawAspect, lpsizel);
        }

        /// <devdoc>
        ///      This class holds all of the state data for an ActiveX control and
        ///      supplies the implementation for many of the non-trivial methods.
        /// </devdoc>
        /// <internalonly/>
        [SecurityPermission(SecurityAction.Assert, Flags=SecurityPermissionFlag.UnmanagedCode)]
        private class ActiveXImpl : MarshalByRefObject, IWindowTarget {
            // SECUNDONE : This call is private and is only used to expose a WinForm control as
            //           : an ActiveX control. This class needs more review.
            //


            private static readonly int     hiMetricPerInch = 2540;
            private static readonly int     viewAdviseOnlyOnce = BitVector32.CreateMask();
            private static readonly int     viewAdvisePrimeFirst = BitVector32.CreateMask(viewAdviseOnlyOnce);
            private static readonly int     eventsFrozen = BitVector32.CreateMask(viewAdvisePrimeFirst);
            private static readonly int     changingExtents = BitVector32.CreateMask(eventsFrozen);
            private static readonly int     saving = BitVector32.CreateMask(changingExtents);
            private static readonly int     isDirty = BitVector32.CreateMask(saving);
            private static readonly int     inPlaceActive = BitVector32.CreateMask(isDirty);
            private static readonly int     inPlaceVisible = BitVector32.CreateMask(inPlaceActive);
            private static readonly int     uiActive = BitVector32.CreateMask(inPlaceVisible);
            private static readonly int     uiDead = BitVector32.CreateMask(uiActive);
            private static readonly int     adjustingRect = BitVector32.CreateMask(uiDead);

            private static Point            logPixels = Point.Empty;
            private static NativeMethods.tagOLEVERB[]     axVerbs;

            private static int              globalActiveXCount = 0;
            private static bool             checkedIE;
            private static bool             isIE;
            
            #if ACTIVEX_SOURCING
            
            //
            // This has been cut from the product.
            //
            
            private static ActiveXPropPage  propPage;
            
            #endif

            private Control                 control;
            private IWindowTarget           controlWindowTarget;
            private IntPtr                  clipRegion;
            private UnsafeNativeMethods.IOleClientSite          clientSite;
            private UnsafeNativeMethods.IOleInPlaceUIWindow     inPlaceUiWindow;
            private UnsafeNativeMethods.IOleInPlaceFrame        inPlaceFrame;
            private ArrayList               adviseList;
            private UnsafeNativeMethods.IAdviseSink             viewAdviseSink;
            private BitVector32             activeXState;
            private AmbientProperty[]       ambientProperties;
            private IntPtr                  hwndParent;
            private IntPtr                  accelTable;
            private short                   accelCount = -1;
            private NativeMethods.COMRECT   adjustRect; // temporary rect used during OnPosRectChange && SetObjectRects

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ActiveXImpl.ActiveXImpl"]/*' />
            /// <devdoc>
            ///      Creates a new ActiveXImpl.
            /// </devdoc>
            public ActiveXImpl(Control control) {
                this.control = control;

                // We replace the control's window target with our own.  We
                // do this so we can handle the UI Dead ambient property.
                //
                controlWindowTarget = control.WindowTarget;
                control.WindowTarget = this;

                adviseList = new ArrayList();
                activeXState = new BitVector32();
                ambientProperties = new AmbientProperty[] {
                    new AmbientProperty("Font", NativeMethods.ActiveX.DISPID_AMBIENT_FONT),
                    new AmbientProperty("BackColor", NativeMethods.ActiveX.DISPID_AMBIENT_BACKCOLOR),
                    new AmbientProperty("ForeColor", NativeMethods.ActiveX.DISPID_AMBIENT_FORECOLOR)
                };
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ActiveXImpl.AmbientBackColor"]/*' />
            /// <devdoc>
            ///      Retrieves the ambient back color for the control.
            /// </devdoc>
            [Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
            public Color AmbientBackColor {
                get {
                    AmbientProperty prop = LookupAmbient(NativeMethods.ActiveX.DISPID_AMBIENT_BACKCOLOR);

                    if (prop.Empty) {
                        Object obj = null;
                        if (GetAmbientProperty(NativeMethods.ActiveX.DISPID_AMBIENT_BACKCOLOR, ref obj)) {
                            if (obj != null) {
                                try {
                                    Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "Object color type=" + obj.GetType().FullName);
                                    prop.Value = ColorTranslator.FromOle(Convert.ToInt32(obj));
                                }
                                catch (Exception e) {
                                    Debug.Fail("Failed to massage ambient back color to a Color", e.ToString());
                                }
                            }
                        }
                    }

                    if (prop.Value == null) {
                        return Color.Empty;
                    }
                    else {
                        return(Color)prop.Value;
                    }
                }
            }

            /// <devdoc>
            ///      Retrieves the ambient font for the control.
            /// </devdoc>
            [Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
            public Font AmbientFont {
                get {
                    AmbientProperty prop = LookupAmbient(NativeMethods.ActiveX.DISPID_AMBIENT_FONT);

                    if (prop.Empty) {
                        Object obj = null;
                        if (GetAmbientProperty(NativeMethods.ActiveX.DISPID_AMBIENT_FONT, ref obj)) {
                            try {
                                Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "Object font type=" + obj.GetType().FullName);
                                Debug.Assert(obj != null, "GetAmbientProperty failed");
                                IntPtr hfont = IntPtr.Zero;

                                SafeNativeMethods.IFont ifont = (SafeNativeMethods.IFont)obj;
                                hfont = ifont.GetHFont();
                                Font font = Font.FromHfont(hfont);
                                prop.Value = font;
                            }
                            catch (Exception) {
                                // Do NULL, so we just defer to the default font
                                prop.Value = null;
                            }
                        }
                    }

                    return(Font)prop.Value;
                }
            }

            /// <devdoc>
            ///      Retrieves the ambient back color for the control.
            /// </devdoc>
            [Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
            public Color AmbientForeColor {
                get {
                    AmbientProperty prop = LookupAmbient(NativeMethods.ActiveX.DISPID_AMBIENT_FORECOLOR);

                    if (prop.Empty) {
                        Object obj = null;
                        if (GetAmbientProperty(NativeMethods.ActiveX.DISPID_AMBIENT_FORECOLOR, ref obj)) {
                            if (obj != null) {
                                try {
                                    Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "Object color type=" + obj.GetType().FullName);
                                    prop.Value = ColorTranslator.FromOle(Convert.ToInt32(obj));
                                }
                                catch (Exception e) {
                                    Debug.Fail("Failed to massage ambient fore color to a Color", e.ToString());
                                }
                            }
                        }
                    }

                    if (prop.Value == null) {
                        return Color.Empty;
                    }
                    else {
                        return(Color)prop.Value;
                    }
                }
            }

            /// <devdoc>
            ///     Determines if we're in design or run mode.
            /// </devdoc>
            private bool DesignMode {
                get {
                    object obj = null;
                    if (GetAmbientProperty(NativeMethods.ActiveX.DISPID_AMBIENT_USERMODE, ref obj)) {
                        if (obj is bool) {
                            return((bool)obj);
                        }
                    }
                    return false;
                }
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ActiveXImpl.EventsFrozen"]/*' />
            /// <devdoc>
            ///      Determines if events should be frozen.
            /// </devdoc>
            [Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
            public bool EventsFrozen {
                get {
                    return activeXState[eventsFrozen];
                }
                set {
                    activeXState[eventsFrozen] = value;
                }
            }

            /// <devdoc>
            ///     Provides access to the parent window handle
            ///     when we are UI active
            /// </devdoc>
            public IntPtr HWNDParent {
                get {
                    return hwndParent;
                }
            }

            /// <devdoc>
            ///     Returns true if this app domain is running inside of IE.  The
            ///     control must be sited for this to succeed (it will assert and
            ///     return false if the control is not sited).
            /// </devdoc>
            private bool IsIE {
                get {
                    if (!checkedIE) {
                        if (clientSite == null) {
                            Debug.Fail("Do not reference IsIE property unless control is sited.");
                            return false;
                        }

                        // First, is this a managed EXE?  If so, it will correctly shut down
                        // the runtime.
                        if (Assembly.GetEntryAssembly() == null) {
                            // Now check for IHTMLDocument2
                            if (clientSite.GetContainer() is NativeMethods.IHTMLDocument) {
                                isIE = true;
                                Debug.WriteLineIf(CompModSwitches.ActiveX.TraceVerbose, "AxSource:IsIE running under IE");
                            }
                        }

                        checkedIE = true;
                    }

                    return isIE;
                }
            }

            /// <devdoc>
            ///      Retrieves the number of logical pixels per inch on the
            ///      primary monitor.
            /// </devdoc>
            private Point LogPixels {
                get {

                    if (logPixels.IsEmpty) {
                        logPixels = new Point();
                        IntPtr dc = UnsafeNativeMethods.GetDC(NativeMethods.NullHandleRef);
                        logPixels.X = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(null, dc), NativeMethods.LOGPIXELSX);
                        logPixels.Y = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(null, dc), NativeMethods.LOGPIXELSY);
                        UnsafeNativeMethods.ReleaseDC(NativeMethods.NullHandleRef, new HandleRef(null, dc));
                    }
                    return logPixels;
                }
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ActiveXImpl.Advise"]/*' />
            /// <devdoc>
            ///      Implements IOleObject::Advise
            /// </devdoc>
            public int Advise(UnsafeNativeMethods.IAdviseSink pAdvSink) {
                adviseList.Add(pAdvSink);
                return adviseList.Count;
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ActiveXImpl.Close"]/*' />
            /// <devdoc>
            ///      Implements IOleObject::Close
            /// </devdoc>
            public void Close(int dwSaveOption) {
                if (activeXState[inPlaceActive]) {
                    InPlaceDeactivate();
                }

                if ((dwSaveOption == NativeMethods.OLECLOSE_SAVEIFDIRTY ||
                     dwSaveOption == NativeMethods.OLECLOSE_PROMPTSAVE) &&
                    activeXState[isDirty]) {

                    if (clientSite != null) {
                        clientSite.SaveObject();
                    }
                    SendOnSave();
                }
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ActiveXImpl.DoVerb"]/*' />
            /// <devdoc>
            ///      Implements IOleObject::DoVerb
            /// </devdoc>
            public void DoVerb(int iVerb, IntPtr lpmsg, UnsafeNativeMethods.IOleClientSite pActiveSite, int lindex, IntPtr hwndParent, NativeMethods.COMRECT lprcPosRect) {
                Debug.WriteLineIf(CompModSwitches.ActiveX.TraceVerbose, "AxSource:ActiveXImpl:DoVerb(" + iVerb + ")");
                switch (iVerb) {
                    case NativeMethods.OLEIVERB_SHOW:
                    case NativeMethods.OLEIVERB_INPLACEACTIVATE:
                    case NativeMethods.OLEIVERB_UIACTIVATE:
                    case NativeMethods.OLEIVERB_PRIMARY:
                        Debug.WriteLineIf(CompModSwitches.ActiveX.TraceVerbose, "DoVerb:Show, InPlaceActivate, UIActivate");
                        InPlaceActivate(iVerb);

                        // Now that we're active, send the lpmsg to the control if it
                        // is valid.
                        //
                        if (lpmsg != IntPtr.Zero) {
                            NativeMethods.MSG msg = (NativeMethods.MSG)UnsafeNativeMethods.PtrToStructure(lpmsg, typeof(NativeMethods.MSG));
                            Control target = control;

                            if (msg.hwnd != control.Handle && msg.message >= NativeMethods.WM_MOUSEFIRST && msg.message <= NativeMethods.WM_MOUSELAST) {

                                // Must translate message coordniates over to our HWND.  We first try
                                // 
                                IntPtr hwndMap = msg.hwnd == IntPtr.Zero ? hwndParent : msg.hwnd;
                                NativeMethods.POINT pt = new NativeMethods.POINT();
                                pt.x = NativeMethods.Util.LOWORD(msg.lParam);
                                pt.y = NativeMethods.Util.HIWORD(msg.lParam);
                                UnsafeNativeMethods.MapWindowPoints(new HandleRef(null, hwndMap), new HandleRef(control, control.Handle), pt, 1);

                                // check to see if this message should really go to a child
                                //  control, and if so, map the point into that child's window
                                //  coordinates
                                //
                                Control realTarget = target.GetChildAtPoint(new Point(pt.x, pt.y));
                                if (realTarget != null && realTarget != target) {
                                    UnsafeNativeMethods.MapWindowPoints(new HandleRef(target, target.Handle), new HandleRef(realTarget, realTarget.Handle), pt, 1);
                                    target = realTarget;
                                }

                                msg.lParam = NativeMethods.Util.MAKELPARAM(pt.x, pt.y);
                            }

#if DEBUG
                            if (CompModSwitches.ActiveX.TraceVerbose) {
                                Message m = Message.Create(msg.hwnd, msg.message, msg.wParam, msg.lParam);
                                Debug.WriteLine("Valid message pointer passed, sending to control: " + m.ToString());
                            }
#endif // DEBUG

                            if (msg.message == NativeMethods.WM_KEYDOWN && msg.wParam == (IntPtr)NativeMethods.VK_TAB) {
                                target.SelectNextControl(null, Control.ModifierKeys != Keys.Shift, true, true, true);
                            }
                            else {
                                target.SendMessage(msg.message, msg.wParam, msg.lParam);
                            }
                        }
                        break;

                        // These effect our visibility
                        //
                    case NativeMethods.OLEIVERB_HIDE:
                        Debug.WriteLineIf(CompModSwitches.ActiveX.TraceVerbose, "DoVerb:Hide");
                        UIDeactivate();
                        if (activeXState[inPlaceVisible]) {
                            SetInPlaceVisible(false);
                        }
                        break;

                    #if ACTIVEX_SOURCING
                    
                    //
                    // This has been cut from the product.
                    //
                    
                        // Show our property pages
                        //
                    case NativeMethods.OLEIVERB_PROPERTIES:
                        Debug.WriteLineIf(CompModSwitches.ActiveX.TraceVerbose, "DoVerb:Primary, Properties");
                        ShowProperties();
                        break;
                        
                    #endif

                        // All other verbs are notimpl.
                        //
                    default:
                        Debug.WriteLineIf(CompModSwitches.ActiveX.TraceVerbose, "DoVerb:Other");
                        ThrowHr(NativeMethods.E_NOTIMPL);
                        break;
                }
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ActiveXImpl.Draw"]/*' />
            /// <devdoc>
            ///      Implements IViewObject2::Draw.
            /// </devdoc>
            public void Draw(int dwDrawAspect, int lindex, IntPtr pvAspect, NativeMethods.tagDVTARGETDEVICE ptd,
                             IntPtr hdcTargetDev, IntPtr hdcDraw, NativeMethods.COMRECT prcBounds, NativeMethods.COMRECT lprcWBounds,
                             IntPtr pfnContinue, int dwContinue) {

                // support the aspects required for multi-pass drawing
                //
                switch (dwDrawAspect) {
                    case NativeMethods.DVASPECT_CONTENT:
                    case NativeMethods.DVASPECT_OPAQUE:
                    case NativeMethods.DVASPECT_TRANSPARENT:
                        break;
                    default:
                        ThrowHr(NativeMethods.DV_E_DVASPECT);
                        break;
                }

                // GDI+ does not support metafiles.  If someone passes us a metafile,
                // what do we do?  Today we throw VIEW_E_DRAW in the hope that
                // the caller figures it out and sends us a different DC.
                //
                int hdcType = UnsafeNativeMethods.GetObjectType(new HandleRef(null, hdcDraw));
                if (hdcType == NativeMethods.OBJ_METADC || hdcType == NativeMethods.OBJ_ENHMETADC) {
                    ThrowHr(NativeMethods.VIEW_E_DRAW);
                }

                NativeMethods.RECT rc;
                NativeMethods.POINT pVp = new NativeMethods.POINT();
                NativeMethods.POINT pW = new NativeMethods.POINT();
                NativeMethods.SIZE  sWindowExt = new NativeMethods.SIZE();
                NativeMethods.SIZE  sViewportExt = new NativeMethods.SIZE();
                int   iMode = NativeMethods.MM_TEXT;

                // if they didn't give us a rectangle, just copy over ours
                //
                if (prcBounds != null) {
                    rc = new NativeMethods.RECT(prcBounds.left, prcBounds.top, prcBounds.right, prcBounds.bottom);
                    
                    // To draw to a given rect, we scale the DC in such a way as to
                    // make the values it takes match our own happy MM_TEXT.  Then, 
                    // we back-convert prcBounds so that we convert it to this coordinate
                    // system.  This puts us in the most similar coordinates as we currently
                    // use.
                    //
                    SafeNativeMethods.LPtoDP(new HandleRef(null, hdcDraw), ref rc, 2);
                    
                    IntPtr hdc = UnsafeNativeMethods.GetDC(new HandleRef(control, control.Handle));
                    
                    int logXDraw = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(null, hdcDraw), NativeMethods.LOGPIXELSX);
                    int logYDraw = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(null, hdcDraw), NativeMethods.LOGPIXELSY);
                    
                    int logXScreen = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(null, hdc), NativeMethods.LOGPIXELSX);
                    int logYScreen = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(null, hdc), NativeMethods.LOGPIXELSY);
                    
                    UnsafeNativeMethods.ReleaseDC(new HandleRef(control, control.Handle), new HandleRef(null, hdc));
                    
                    iMode = SafeNativeMethods.SetMapMode(new HandleRef(null, hdcDraw), NativeMethods.MM_ANISOTROPIC);
                    SafeNativeMethods.SetWindowOrgEx(new HandleRef(null, hdcDraw), 0, 0, pW);
                    SafeNativeMethods.SetWindowExtEx(new HandleRef(null, hdcDraw), logXScreen, logYScreen, sWindowExt);
                    SafeNativeMethods.SetViewportOrgEx(new HandleRef(null, hdcDraw), rc.left, rc.top, pVp);
                    SafeNativeMethods.SetViewportExtEx(new HandleRef(null, hdcDraw), logXDraw, logYDraw, sViewportExt);
                    
                    // Now that we've done our conversion, convert rc to the new coordinate system.
                    //
                    SafeNativeMethods.DPtoLP(new HandleRef(null, hdcDraw), ref rc, 2);
                }
                else {
                    rc = new NativeMethods.RECT();
                    rc.left = control.Left;
                    rc.top = control.Top;
                    rc.right = control.Right;
                    rc.bottom = control.Bottom;
                }
    
                // Now do the actual drawing.  We must ask all of our children to draw as well.
                // Also, since we are simulating a paint via WM_PRINT, we have got to set our
                // size as well.  We only do it to this control, and not the children, because
                // the children are layed out according to their own rules.
                //
                Rectangle bounds = Rectangle.FromLTRB(rc.left, rc.top, rc.right, rc.bottom);
                Rectangle oldBounds = control.Bounds;
                bounds.X += oldBounds.X;
                bounds.Y += oldBounds.Y;
                control.Bounds = bounds;
                
                try {
                    control.SendMessage(NativeMethods.WM_PRINT, hdcDraw, 
                        (IntPtr)(NativeMethods.PRF_CHILDREN 
                                | NativeMethods.PRF_CLIENT 
                                | NativeMethods.PRF_ERASEBKGND 
                                | NativeMethods.PRF_NONCLIENT));
                                //| NativeMethods.PRF_CHECKVISIBLE 
                                //| NativeMethods.PRF_OWNED));
                }
                finally {
                    
                    control.Bounds = oldBounds;
                    
                    // And clean up the DC
                    //
                    if (prcBounds != null) {
                        SafeNativeMethods.SetWindowOrgEx(new HandleRef(null, hdcDraw), pW.x, pW.y, null);
                        SafeNativeMethods.SetWindowExtEx(new HandleRef(null, hdcDraw), sWindowExt.cx, sWindowExt.cy, null);
                        SafeNativeMethods.SetViewportOrgEx(new HandleRef(null, hdcDraw), pVp.x, pVp.y, null);
                        SafeNativeMethods.SetViewportExtEx(new HandleRef(null, hdcDraw), sViewportExt.cx, sViewportExt.cy, null);
                        SafeNativeMethods.SetMapMode(new HandleRef(null, hdcDraw), iMode);
                    }
                }
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ActiveXImpl.EnumVerbs"]/*' />
            /// <devdoc>
            ///     Returns a new verb enumerator.
            /// </devdoc>
            public static int EnumVerbs(out UnsafeNativeMethods.IEnumOLEVERB e) {
                if (axVerbs == null) {
                    NativeMethods.tagOLEVERB verbShow             = new NativeMethods.tagOLEVERB();
                    NativeMethods.tagOLEVERB verbInplaceActivate  = new NativeMethods.tagOLEVERB();
                    NativeMethods.tagOLEVERB verbUIActivate       = new NativeMethods.tagOLEVERB();
                    NativeMethods.tagOLEVERB verbHide             = new NativeMethods.tagOLEVERB();
                    NativeMethods.tagOLEVERB verbPrimary          = new NativeMethods.tagOLEVERB();
                    NativeMethods.tagOLEVERB verbProperties       = new NativeMethods.tagOLEVERB();

                    verbShow.lVerb = NativeMethods.OLEIVERB_SHOW;
                    verbInplaceActivate.lVerb = NativeMethods.OLEIVERB_INPLACEACTIVATE;
                    verbUIActivate.lVerb = NativeMethods.OLEIVERB_UIACTIVATE;
                    verbHide.lVerb = NativeMethods.OLEIVERB_HIDE;
                    verbPrimary.lVerb = NativeMethods.OLEIVERB_PRIMARY;
                    verbProperties.lVerb = NativeMethods.OLEIVERB_PROPERTIES;
                    verbProperties.lpszVerbName = SR.GetString(SR.AXProperties);
                    verbProperties.grfAttribs = NativeMethods.ActiveX.OLEVERBATTRIB_ONCONTAINERMENU;

                    axVerbs = new NativeMethods.tagOLEVERB[] {
                        verbShow,
                        verbInplaceActivate,
                        verbUIActivate,
                        verbHide,
                        verbPrimary,
                        verbProperties
                    };
                }


                e = new ActiveXVerbEnum(axVerbs);
                return NativeMethods.S_OK;
            }

            /// <devdoc>
            ///     Converts the given string to a byte array.
            /// </devdoc>
            static byte[] FromBase64WrappedString(string text) {

                if (text.IndexOfAny(new char[] {' ', '\r', '\n'}) != -1) {
                    StringBuilder sb = new StringBuilder(text.Length);
                    for (int i=0; i<text.Length; i++) {
                        switch (text[i]) {
                            case ' ':
                            case '\r':
                            case '\n':
                                break;
                            default:
                                sb.Append(text[i]);
                                break;
                        }
                    }
                    return Convert.FromBase64String(sb.ToString());
                }
                else {
                    return Convert.FromBase64String(text);
                }
            }

            /// <devdoc>
            ///      Implements IViewObject2::GetAdvise.
            /// </devdoc>
            public void GetAdvise(int[] paspects, int[] padvf, UnsafeNativeMethods.IAdviseSink[] pAdvSink) {

                // if they want it, give it to them
                //
                if (paspects != null) {
                    paspects[0] = NativeMethods.DVASPECT_CONTENT;
                }

                if (padvf != null) {
                    padvf[0] = 0;

                    if (activeXState[viewAdviseOnlyOnce]) padvf[0] |= NativeMethods.ADVF_ONLYONCE;
                    if (activeXState[viewAdvisePrimeFirst]) padvf[0] |= NativeMethods.ADVF_PRIMEFIRST;
                }

                if (pAdvSink != null) {
                    pAdvSink[0] = viewAdviseSink;
                }
            }

            /// <devdoc>
            ///      Helper function to retrieve an ambient property.  Returns false if the
            ///      property wasn't found.
            /// </devdoc>
            private bool GetAmbientProperty(int dispid, ref Object obj) {
                Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource:GetAmbientProperty");
                Debug.Indent();

                if (clientSite is UnsafeNativeMethods.IDispatch) {
                    Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "clientSite implements IDispatch");

                    UnsafeNativeMethods.IDispatch disp = (UnsafeNativeMethods.IDispatch)clientSite;
                    Object[] pvt = new Object[1];
                    Guid g = Guid.Empty;
                    int hr = NativeMethods.E_FAIL;

                    hr = disp.Invoke(dispid, ref g, NativeMethods.LOCALE_USER_DEFAULT,
                                     NativeMethods.DISPATCH_PROPERTYGET, new NativeMethods.tagDISPPARAMS(),
                                     pvt, null, null);

                    if (NativeMethods.Succeeded(hr)) {
                        Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "IDispatch::Invoke succeeded. VT=" + pvt[0].GetType().FullName);
                        obj = pvt[0];
                        Debug.Unindent();
                        return true;
                    }
                    else {
                        Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "IDispatch::Invoke failed. HR: 0x" + String.Format("{0:X}", hr));
                    }
                }

                Debug.Unindent();
                return false;
            }

            /// <devdoc>
            ///      Implements IOleObject::GetClientSite.
            /// </devdoc>
            public UnsafeNativeMethods.IOleClientSite GetClientSite() {
                return clientSite;
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ActiveXImpl.GetControlInfo"]/*' />
            /// <devdoc>
            /// </devdoc>
            /// <internalonly/>
            public int GetControlInfo(NativeMethods.tagCONTROLINFO pCI) {

                if (accelCount == -1) {
                    ArrayList mnemonicList = new ArrayList();
                    GetMnemonicList(control, mnemonicList);

                    accelCount = (short)mnemonicList.Count;

                    if (accelCount > 0) {
                        int accelSize = Marshal.SizeOf(typeof(NativeMethods.ACCEL));

                        // In the worst case we may have two accelerators per mnemonic:  one lower case and
                        // one upper case, hence the * 2 below.
                        //
                        IntPtr accelBlob = Marshal.AllocHGlobal(accelSize * accelCount * 2);

                        try {
                            NativeMethods.ACCEL accel = new NativeMethods.ACCEL();
                            accel.cmd = 0;

                            Debug.Indent();

                            accelCount = 0;

                            foreach(char ch in mnemonicList) {
                                IntPtr structAddr = (IntPtr)((long)accelBlob + accelCount * accelSize);

                                Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "Mnemonic: " + ch.ToString());

                                if (ch >= 'A' && ch <= 'Z') {

                                    // Lower case letter
                                    //
                                    accel.fVirt = NativeMethods.FALT | NativeMethods.FVIRTKEY;
                                    accel.key = (short)(UnsafeNativeMethods.VkKeyScan(ch) & 0x00FF);
                                    Marshal.StructureToPtr(accel, structAddr, false);

                                    // Upper case letter
                                    //
                                    accelCount++;
                                    structAddr = (IntPtr)((long)structAddr + accelSize);
                                    accel.fVirt = NativeMethods.FALT | NativeMethods.FVIRTKEY | NativeMethods.FSHIFT;
                                    Marshal.StructureToPtr(accel, structAddr, false);
                                }
                                else {
                                    // Some non-printable character.
                                    //
                                    accel.fVirt = NativeMethods.FALT | NativeMethods.FVIRTKEY;
                                    short scan = (short)(UnsafeNativeMethods.VkKeyScan(ch));
                                    if ((scan & 0x0100) != 0) {
                                        accel.fVirt |= NativeMethods.FSHIFT;
                                    }
                                    accel.key = (short)(scan & 0x00FF);
                                    Marshal.StructureToPtr(accel, structAddr, false);
                                }

                                accel.cmd++;
                                accelCount++;
                            }

                            Debug.Unindent();

                            // Now create an accelerator table and then free our memory.
                            //
                            accelTable = UnsafeNativeMethods.CreateAcceleratorTable(new HandleRef(null, accelBlob), accelCount);
                        }
                        finally {
                            if (accelBlob != IntPtr.Zero) {
                                Marshal.FreeHGlobal(accelBlob);
                            }
                        }
                    }
                }

                pCI.cAccel = accelCount;
                pCI.hAccel = accelTable;
                return NativeMethods.S_OK;
            }

            /// <devdoc>
            ///      Implements IOleObject::GetExtent.
            /// </devdoc>
            public void GetExtent(int dwDrawAspect, NativeMethods.tagSIZEL pSizel) {
                if ((dwDrawAspect & NativeMethods.DVASPECT_CONTENT) != 0) {
                    Size size = control.Size;

                    Point pt = PixelToHiMetric(size.Width, size.Height);
                    pSizel.cx = pt.X;
                    pSizel.cy = pt.Y;
                }
                else {
                    ThrowHr(NativeMethods.DV_E_DVASPECT);
                }
            }

            /// <devdoc>
            ///     Retrieves the mnemonic for the given text.  If the text
            ///     has no mnemonic, this will return -1
            /// </devdoc>
            private short GetMnemonic(string text) {
                int len = text.Length;
                short mnemonic = -1;

                for (int i = 0; i < len; i++) {
                    if (text[i] == '&' && i+1 < len && text[i+1] != '&') {
                        mnemonic = (short)Char.ToUpper(text[i+1], CultureInfo.CurrentCulture);
                        break;
                    }
                }

                return mnemonic;
            }

            /// <devdoc>
            ///     Searches the control hierarchy of the given control and adds
            ///     the mnemonics for each control to mnemonicList.  Each mnemonic
            ///     is added as a char to the list.
            /// </devdoc>        
            private void GetMnemonicList(Control control, ArrayList mnemonicList) {

                // Get the mnemonic for our control
                //
                short mnemonic = GetMnemonic(control.Text);
                if (mnemonic != -1) {
                    mnemonicList.Add((char)mnemonic);
                }

                // And recurse for our children.
                //
                foreach(Control c in control.Controls) {
                    if (c != null) GetMnemonicList(c, mnemonicList);
                }
            }

            /// <devdoc>
            ///      Implements IOleWindow::GetWindow
            /// </devdoc>
            public int GetWindow(out IntPtr hwnd) {
                if (!activeXState[inPlaceActive]) {
                    hwnd = IntPtr.Zero;
                    return NativeMethods.E_FAIL;
                }
                hwnd = control.Handle;
                return NativeMethods.S_OK;
            }

            /// <devdoc>
            ///      Converts coordinates in HiMetric to pixels.  Used for ActiveX sourcing.
            /// </devdoc>
            /// <internalonly/>
            private Point HiMetricToPixel(int x, int y) {
                Point pt = new Point();
                pt.X = (LogPixels.X * x + hiMetricPerInch / 2) / hiMetricPerInch;
                pt.Y = (LogPixels.Y * y + hiMetricPerInch / 2) / hiMetricPerInch;
                return pt;
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ActiveXImpl.InPlaceActivate"]/*' />
            /// <devdoc>
            ///      In place activates this Object.
            /// </devdoc>
            public void InPlaceActivate(int verb) {
                // If we don't have a client site, then there's not much to do.
                // We also punt if this isn't an in-place site, since we can't
                // go active then.
                //
                if (!(clientSite is UnsafeNativeMethods.IOleInPlaceSite)) {
                    return;
                }

                Debug.Assert(clientSite != null, "How can we inplaceactivate before we are sited??");
                UnsafeNativeMethods.IOleInPlaceSite inPlaceSite = (UnsafeNativeMethods.IOleInPlaceSite)clientSite;

                // If we're not already active, go and do it.
                //
                if (!activeXState[inPlaceActive]) {
                    Debug.WriteLineIf(CompModSwitches.ActiveX.TraceVerbose, "\tActiveXImpl:InPlaceActivate --> inplaceactive");

                    int hr = inPlaceSite.CanInPlaceActivate();

                    if (hr != NativeMethods.S_OK) {
                        if (NativeMethods.Succeeded(hr)) {
                            hr = NativeMethods.E_FAIL;
                        }
                        ThrowHr(hr);
                    }

                    inPlaceSite.OnInPlaceActivate();

                    activeXState[inPlaceActive] = true;
                }


                // And if we're not visible, do that too.
                //
                if (!activeXState[inPlaceVisible]) {
                    Debug.WriteLineIf(CompModSwitches.ActiveX.TraceVerbose, "\tActiveXImpl:InPlaceActivate --> inplacevisible");
                    NativeMethods.tagOIFI inPlaceFrameInfo = new NativeMethods.tagOIFI();
                    inPlaceFrameInfo.cb = Marshal.SizeOf(typeof(NativeMethods.tagOIFI));
                    IntPtr hwndParent = IntPtr.Zero;

                    // We are entering a secure context here.
                    //
                    hwndParent = inPlaceSite.GetWindow();

                    UnsafeNativeMethods.IOleInPlaceFrame pFrame;
                    UnsafeNativeMethods.IOleInPlaceUIWindow pWindow;
                    NativeMethods.COMRECT posRect = new NativeMethods.COMRECT();
                    NativeMethods.COMRECT clipRect = new NativeMethods.COMRECT();

                    if (inPlaceUiWindow != null && Marshal.IsComObject(inPlaceUiWindow)) {
                        Marshal.ReleaseComObject(inPlaceUiWindow);
                        inPlaceUiWindow = null;
                    }

                    if (inPlaceFrame != null && Marshal.IsComObject(inPlaceFrame)) {
                        Marshal.ReleaseComObject(inPlaceFrame);
                        inPlaceFrame = null;
                    }

                    inPlaceSite.GetWindowContext(out pFrame, out pWindow, posRect, clipRect, inPlaceFrameInfo);

                    SetObjectRects(posRect, clipRect);

                    inPlaceFrame = pFrame;
                    inPlaceUiWindow = pWindow;

                    // We are parenting ourselves
                    // directly to the host window.  The host must 
                    // implement the ambient property 
                    // DISPID_AMBIENT_MESSAGEREFLECT.
                    // If it doesn't, that means that the host
                    // won't reflect messages back to us.
                    //
                    this.hwndParent = hwndParent;
                    UnsafeNativeMethods.SetParent(new HandleRef(control, control.Handle), new HandleRef(null, hwndParent));

                    // Now create our handle if it hasn't already been done. Note that because
                    // this raises events to the user that it CANNOT be done with a security assertion
                    // in place!
                    //
                    control.CreateControl();

                    clientSite.ShowObject();

                    SetInPlaceVisible(true);
                    Debug.Assert(activeXState[inPlaceVisible], "Failed to set inplacevisible");
                }

                // if we weren't asked to UIActivate, then we're done.
                //
                if (verb != NativeMethods.OLEIVERB_PRIMARY && verb != NativeMethods.OLEIVERB_UIACTIVATE) {
                    Debug.WriteLineIf(CompModSwitches.ActiveX.TraceVerbose, "\tActiveXImpl:InPlaceActivate --> not becoming UIActive");
                    return;
                }

                // if we're not already UI active, do sow now.
                //                                
                if (!activeXState[uiActive]) {
                    Debug.WriteLineIf(CompModSwitches.ActiveX.TraceVerbose, "\tActiveXImpl:InPlaceActivate --> uiactive");
                    activeXState[uiActive] = true;

                    // inform the container of our intent
                    //
                    inPlaceSite.OnUIActivate();

                    // take the focus  [which is what UI Activation is all about !]
                    //
                    control.FocusInternal();

                    // set ourselves up in the host.
                    //
                    Debug.Assert(inPlaceFrame != null, "Setting us to visible should have created the in place frame");
                    inPlaceFrame.SetActiveObject(control, null);
                    if (inPlaceUiWindow != null) {
                        inPlaceUiWindow.SetActiveObject(control, null);
                    }

                    // we have to explicitly say we don't wany any border space.
                    //
                    int hr = inPlaceFrame.SetBorderSpace(null);
                    if (NativeMethods.Failed(hr) && hr != NativeMethods.INPLACE_E_NOTOOLSPACE && hr != NativeMethods.E_NOTIMPL) {
                        Marshal.ThrowExceptionForHR(hr);
                    }

                    if (inPlaceUiWindow != null) {
                        hr = inPlaceFrame.SetBorderSpace(null);
                        if (NativeMethods.Failed(hr) && hr != NativeMethods.INPLACE_E_NOTOOLSPACE && hr != NativeMethods.E_NOTIMPL) {
                            Marshal.ThrowExceptionForHR(hr);
                        }
                    }
                }
                else {
                    Debug.WriteLineIf(CompModSwitches.ActiveX.TraceVerbose, "\tActiveXImpl:InPlaceActivate --> already uiactive");
                }
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ActiveXImpl.InPlaceDeactivate"]/*' />
            /// <devdoc>
            ///      Implements IOleInPlaceObject::InPlaceDeactivate.
            /// </devdoc>
            public void InPlaceDeactivate() {

                // Only do this if we're already in place active.
                //
                if (!activeXState[inPlaceActive]) {
                    return;
                }

                // Deactivate us if we're UI active
                //
                if (activeXState[uiActive]) {
                    UIDeactivate();
                }

                // Some containers may call into us to save, and if we're still
                // active we will try to deactivate and recurse back into the container.
                // So, set the state bits here first.
                //
                activeXState[inPlaceActive] = false;
                activeXState[inPlaceVisible] = false;

                // Notify our site of our deactivation.
                //
                if (clientSite is UnsafeNativeMethods.IOleInPlaceSite) {
                    ((UnsafeNativeMethods.IOleInPlaceSite)clientSite).OnInPlaceDeactivate();
                }

                control.Visible = false;
                hwndParent = IntPtr.Zero;

                if (inPlaceUiWindow != null && Marshal.IsComObject(inPlaceUiWindow)) {
                    Marshal.ReleaseComObject(inPlaceUiWindow);
                    inPlaceUiWindow = null;
                }

                if (inPlaceFrame != null && Marshal.IsComObject(inPlaceFrame)) {
                    Marshal.ReleaseComObject(inPlaceFrame);
                    inPlaceFrame = null;
                }
            }

            /// <devdoc>
            ///      Implements IPersistStreamInit::IsDirty.
            /// </devdoc>
            public int IsDirty() {
                if (activeXState[isDirty]) {
                    return NativeMethods.S_OK;
                }
                else {
                    return NativeMethods.S_FALSE;
                }
            }

            /// <devdoc>
            ///      Looks at the property to see if it should be loaded / saved as a resource or
            ///      through a type converter.
            /// </devdoc>
            private bool IsResourceProp(PropertyDescriptor prop) {
                TypeConverter converter = prop.Converter;
                Type[] convertTypes = new Type[] {
                    typeof(string),
                    typeof(byte[])
                    };

                foreach (Type t in convertTypes) {
                    if (converter.CanConvertTo(t) && converter.CanConvertFrom(t)) {
                        return false;
                    }
                }

                // Finally, if the property can be serialized, it is a resource property.
                //
                return (prop.GetValue(control) is ISerializable);
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ActiveXImpl.Load"]/*' />
            /// <devdoc>
            ///      Implements IPersistStorage::Load
            /// </devdoc>
            public void Load(UnsafeNativeMethods.IStorage stg) {

                UnsafeNativeMethods.IStream stream = null;

                stream = stg.OpenStream(GetType().FullName, IntPtr.Zero, NativeMethods.STGM_READ | NativeMethods.STGM_SHARE_EXCLUSIVE, 0);

                Load(stream);
                stream = null;
                if (Marshal.IsComObject(stg)) {
                    Marshal.ReleaseComObject(stg);
                }
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ActiveXImpl.Load1"]/*' />
            /// <devdoc>
            ///      Implements IPersistStreamInit::Load
            /// </devdoc>
            public void Load(UnsafeNativeMethods.IStream stream) {

                // We do everything through property bags because we support full fidelity
                // in them.  So, load through that method.
                //
                PropertyBagStream bag = new PropertyBagStream();
                bag.Read(stream);
                Load(bag, null);

                if (Marshal.IsComObject(stream)) {
                    Marshal.ReleaseComObject(stream);
                }
            }

            /// <devdoc>
            ///      Implements IPersistPropertyBag::Load
            /// </devdoc>
            public void Load(UnsafeNativeMethods.IPropertyBag pPropBag, UnsafeNativeMethods.IErrorLog pErrorLog) {
                PropertyDescriptorCollection props = TypeDescriptor.GetProperties(control,
                    new Attribute[] {DesignerSerializationVisibilityAttribute.Visible});
                    
                for (int i = 0; i < props.Count; i++) {
                    Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "Loading property " + props[i].Name);

                    try {
                        object obj = null;
                        int hr = NativeMethods.E_FAIL;

                        hr = pPropBag.Read(props[i].Name, ref obj, pErrorLog);

                        if (NativeMethods.Succeeded(hr) && obj != null) {
                            Debug.Indent();
                            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "Property was in bag");

                            try {
                                if (obj.GetType() != typeof(string)) {
                                    Debug.Fail("Expected property " + props[i].Name + " to be stored in IPropertyBag as a string.  Attempting to coerce");
                                    obj = Convert.ToString(obj);
                                }

                                // Determine if this is a resource property or was persisted via a type converter.
                                //
                                if (IsResourceProp(props[i])) {
                                    Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "It's a resource property");

                                    // Resource property.  We encode these as base 64 strings.  To load them, we convert
                                    // to a binary blob and then de-serialize.
                                    //
                                    byte[] bytes = Convert.FromBase64String(obj.ToString());
                                    MemoryStream stream = new MemoryStream(bytes);
                                    BinaryFormatter formatter = new BinaryFormatter();
                                    props[i].SetValue(control, formatter.Deserialize(stream));
                                }
                                else {
                                    Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "It's a standard property");

                                    // Not a resource property.  Use TypeConverters to convert the string back to the data type.  We do
                                    // not check for CanConvertFrom here -- we the conversion fails the type converter will throw,
                                    // and we will log it into the COM error log.
                                    //
                                    TypeConverter converter = props[i].Converter;
                                    Debug.Assert(converter != null, "No type converter for property '" + props[i].Name + "' on class " + control.GetType().FullName);

                                    // Check to see if the type converter can convert from a string.  If it can,.
                                    // use that as it is the best format for IPropertyBag.  Otherwise, check to see
                                    // if it can convert from a byte array.  If it can, get the string, decode it
                                    // to a byte array, and then set the value.
                                    //
                                    object value = null;

                                    if (converter.CanConvertFrom(typeof(string))) {
                                        value = converter.ConvertFromInvariantString(obj.ToString());
                                    }
                                    else if (converter.CanConvertFrom(typeof(byte[]))) {
                                        string objString = obj.ToString();
                                        value = converter.ConvertFrom(null, CultureInfo.InvariantCulture, FromBase64WrappedString(objString));
                                    }
                                    Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "Converter returned " + value);
                                    props[i].SetValue(control, value);
                                }
                            }
                            catch (Exception e) {
                                Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "Exception converting property: " + e.ToString());
                                if (pErrorLog != null) {
                                    NativeMethods.tagEXCEPINFO err = new NativeMethods.tagEXCEPINFO();

                                    err.bstrSource = control.GetType().FullName;
                                    err.bstrDescription = e.ToString();
                                    if (e is ExternalException) {
                                        err.scode = ((ExternalException)e).ErrorCode;
                                    }
                                    else {
                                        err.scode = NativeMethods.E_FAIL;
                                    }

                                    pErrorLog.AddError(props[i].Name, err);
                                }
                            }
                            Debug.Unindent();
                        }
                    }
                    catch (Exception ex) {
                        Debug.Fail("Unexpected failure reading property", ex.ToString());
                    }
                }
                if (Marshal.IsComObject(pPropBag)) {
                    Marshal.ReleaseComObject(pPropBag);
                }
            }

            /// <devdoc>
            ///      Simple lookup to find the AmbientProperty corresponding to the given
            ///      dispid.
            /// </devdoc>
            private AmbientProperty LookupAmbient(int dispid) {
                for (int i = 0; i < ambientProperties.Length; i++) {
                    if (ambientProperties[i].DispID == dispid) {
                        return ambientProperties[i];
                    }
                }
                Debug.Fail("No ambient property for dispid " + dispid.ToString());
                return ambientProperties[0];
            }

            /// <devdoc>
            ///      Merges the input region with the current clipping region.
            ///      The output is always a region that can be fed directly
            ///      to SetWindowRgn.  The region does not have to be destroyed.
            ///      The original region is destroyed if a new region is returned.
            /// </devdoc>
            public IntPtr MergeRegion(IntPtr region) {
                if (clipRegion == IntPtr.Zero) {
                    return region;
                }

                if (region == IntPtr.Zero) {
                    return clipRegion;
                }

                try {
                    IntPtr newRegion = SafeNativeMethods.CreateRectRgn(0, 0, 0, 0);
                    try {
                        SafeNativeMethods.CombineRgn(new HandleRef(null, newRegion), new HandleRef(null, region), new HandleRef(this, clipRegion), NativeMethods.RGN_DIFF);
                        SafeNativeMethods.DeleteObject(new HandleRef(null, region));
                    }
                    catch {
                        SafeNativeMethods.DeleteObject(new HandleRef(null, newRegion));
                        throw;
                    }
                    return newRegion;
                }
                catch {
                    // If something goes wrong, use the original region.
                    return region;
                }
            }

            private void CallParentPropertyChanged(Control control, string propName) {
                switch (propName) {
                    case "BackColor" : 
                        control.OnParentBackColorChanged(EventArgs.Empty);
                        break;

                    case "BackgroundImage" : 
                        control.OnParentBackgroundImageChanged(EventArgs.Empty);
                        break;
                    
                    case "BindingContext" : 
                        control.OnParentBindingContextChanged(EventArgs.Empty);
                        break;

                    case "Enabled" : 
                        control.OnParentEnabledChanged(EventArgs.Empty);
                        break;

                    case "Font" : 
                        control.OnParentFontChanged(EventArgs.Empty);
                        break;

                    case "ForeColor" : 
                        control.OnParentForeColorChanged(EventArgs.Empty);
                        break;

                    case "RightToLeft" : 
                        control.OnParentRightToLeftChanged(EventArgs.Empty);
                        break;

                    case "Visible" : 
                        control.OnParentVisibleChanged(EventArgs.Empty);
                        break;

                    default:
                        Debug.Fail("There is no property change notification for: " + propName + " on Control.");
                        break;
                }
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ActiveXImpl.OnAmbientPropertyChange"]/*' />
            /// <devdoc>
            ///      Implements IOleControl::OnAmbientPropertyChanged
            /// </devdoc>
            public void OnAmbientPropertyChange(int dispID) {

                if (dispID != NativeMethods.ActiveX.DISPID_UNKNOWN) {

                    // Look for a specific property that has changed.
                    //
                    for (int i = 0; i < ambientProperties.Length; i++) {
                        if (ambientProperties[i].DispID == dispID) {
                            ambientProperties[i].ResetValue();
                            CallParentPropertyChanged(control, ambientProperties[i].Name);
                            return;
                        }
                    }

                    // Special properties that we care about
                    //
                    Object obj = new Object();

                    switch (dispID) {
                        case NativeMethods.ActiveX.DISPID_AMBIENT_UIDEAD:
                            if (GetAmbientProperty(NativeMethods.ActiveX.DISPID_AMBIENT_UIDEAD, ref obj)) {
                                activeXState[uiDead] = (bool)obj;
                            }
                            break;

                        case NativeMethods.ActiveX.DISPID_AMBIENT_DISPLAYASDEFAULT:
                            if (control is IButtonControl && GetAmbientProperty(NativeMethods.ActiveX.DISPID_AMBIENT_UIDEAD, ref obj)) {
                                ((IButtonControl)control).NotifyDefault((bool)obj);
                            }
                            break;
                    }
                }
                else {
                    // Invalidate all properties.  Ideally we should be checking each one, but
                    // that's pretty expensive too.
                    //
                    for (int i = 0; i < ambientProperties.Length; i++) {
                        ambientProperties[i].ResetValue();
                        CallParentPropertyChanged(control, ambientProperties[i].Name);
                    }
                }
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ActiveXImpl.OnDocWindowActivate"]/*' />
            /// <devdoc>
            ///      Implements IOleInPlaceActiveObject::OnDocWindowActivate.
            /// </devdoc>
            public void OnDocWindowActivate(int fActivate) {
                if (activeXState[uiActive] && fActivate != 0 && inPlaceFrame != null) {
                    // we have to explicitly say we don't wany any border space.
                    //
                    int hr = inPlaceFrame.SetBorderSpace(null);
                    if (NativeMethods.Failed(hr) && hr != NativeMethods.INPLACE_E_NOTOOLSPACE && hr != NativeMethods.E_NOTIMPL) {
                        Marshal.ThrowExceptionForHR(hr);
                    }
                }
            }

            /// <devdoc>
            ///     Called by Control when it gets the focus.
            /// </devdoc>
            public void OnFocus(bool focus) {
                Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AXSource: SetFocus:  " + focus.ToString());
                if (activeXState[inPlaceActive] && clientSite is UnsafeNativeMethods.IOleControlSite) {
                    ((UnsafeNativeMethods.IOleControlSite)clientSite).OnFocus(focus ? 1 : 0);
                }

                if (focus && activeXState[inPlaceActive] && !activeXState[uiActive]) {
                    InPlaceActivate(NativeMethods.OLEIVERB_UIACTIVATE);
                }
            }

            /// <devdoc>
            ///      Converts coordinates in pixels to HiMetric.
            /// </devdoc>
            /// <internalonly/>
            private Point PixelToHiMetric(int x, int y) {
                Point pt = new Point();
                pt.X = (hiMetricPerInch * x + (LogPixels.X >> 1)) / LogPixels.X;
                pt.Y = (hiMetricPerInch * y + (LogPixels.Y >> 1)) / LogPixels.Y;
                return pt;
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ActiveXImpl.QuickActivate"]/*' />
            /// <devdoc>
            ///     Our implementation of IQuickActivate::QuickActivate
            /// </devdoc>
            public void QuickActivate(UnsafeNativeMethods.tagQACONTAINER pQaContainer, UnsafeNativeMethods.tagQACONTROL pQaControl) {

                // Hookup our ambient colors
                //
                AmbientProperty prop = LookupAmbient(NativeMethods.ActiveX.DISPID_AMBIENT_BACKCOLOR);
                prop.Value = ColorTranslator.FromOle(unchecked((int)pQaContainer.colorBack));

                prop = LookupAmbient(NativeMethods.ActiveX.DISPID_AMBIENT_FORECOLOR);
                prop.Value = ColorTranslator.FromOle(unchecked((int)pQaContainer.colorFore));

                // And our ambient font
                //
                if (pQaContainer.pFont != null) {

                    prop = LookupAmbient(NativeMethods.ActiveX.DISPID_AMBIENT_FONT);

                    try {
                        IntPtr hfont = IntPtr.Zero;
                        object objfont = pQaContainer.pFont;
                        SafeNativeMethods.IFont ifont = (SafeNativeMethods.IFont)objfont;
                        hfont = ifont.GetHFont();
                        Font font = Font.FromHfont(hfont);
                        prop.Value = font;
                    }
                    catch {
                        // Do NULL, so we just defer to the default font
                        prop.Value = null;
                    }
                }

                // Now use the rest of the goo that we got passed in.
                //
                int status;

                pQaControl.cbSize = Marshal.SizeOf(typeof(UnsafeNativeMethods.tagQACONTROL));

                SetClientSite(pQaContainer.pClientSite);

                if (pQaContainer.pAdviseSink != null) {
                    SetAdvise(NativeMethods.DVASPECT_CONTENT, 0, (UnsafeNativeMethods.IAdviseSink)pQaContainer.pAdviseSink);
                }
                ((UnsafeNativeMethods.IOleObject)control).GetMiscStatus(NativeMethods.DVASPECT_CONTENT, out status);
                pQaControl.dwMiscStatus = status;
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ActiveXImpl.Save"]/*' />
            /// <devdoc>
            ///      Implements IPersistStorage::Save
            /// </devdoc>
            public void Save(UnsafeNativeMethods.IStorage stg, int fSameAsLoad) {
                UnsafeNativeMethods.IStream stream = null;

                stream = stg.CreateStream(GetType().FullName, NativeMethods.STGM_WRITE | NativeMethods.STGM_SHARE_EXCLUSIVE | NativeMethods.STGM_CREATE, 0, 0);

                Debug.Assert(stream != null, "Stream should be non-null, or an exception should have been thrown.");
                Save(stream, true);
                stream = null;
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ActiveXImpl.Save1"]/*' />
            /// <devdoc>
            ///      Implements IPersistStreamInit::Save
            /// </devdoc>
            public void Save(UnsafeNativeMethods.IStream stream, bool fClearDirty) {

                // We do everything through property bags because we support full fidelity
                // in them.  So, save through that method.
                //
                PropertyBagStream bag = new PropertyBagStream();
                Save(bag, fClearDirty, false);
                bag.Write(stream);
            }

            /// <devdoc>
            ///      Implements IPersistPropertyBag::Save
            /// </devdoc>
            public void Save(UnsafeNativeMethods.IPropertyBag pPropBag, bool fClearDirty, bool fSaveAllProperties) {
                PropertyDescriptorCollection props = TypeDescriptor.GetProperties(control,
                    new Attribute[] {DesignerSerializationVisibilityAttribute.Visible});
                    
                for (int i = 0; i < props.Count; i++) {
                    if (fSaveAllProperties || props[i].ShouldSerializeValue(control)) {
                        Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "Saving property " + props[i].Name);

                        object propValue;

                        if (IsResourceProp(props[i])) {

                            // Resource property.  Save this to the bag as a 64bit encoded string.
                            //
                            MemoryStream stream = new MemoryStream();
                            BinaryFormatter formatter = new BinaryFormatter();
                            formatter.Serialize(stream, props[i].GetValue(control));
                            byte[] bytes = new byte[(int)stream.Length];
                            stream.Position = 0;
                            stream.Read(bytes, 0, bytes.Length);
                            propValue = Convert.ToBase64String(bytes);
                            pPropBag.Write(props[i].Name, ref propValue);
                        }
                        else {

                            // Not a resource property.  Persist this using standard type converters.
                            //
                            TypeConverter converter = props[i].Converter;
                            Debug.Assert(converter != null, "No type converter for property '" + props[i].Name + "' on class " + control.GetType().FullName);

                            if (converter.CanConvertFrom(typeof(string))) {
                                propValue = converter.ConvertToInvariantString(props[i].GetValue(control));
                                pPropBag.Write(props[i].Name, ref propValue);
                            }
                            else if (converter.CanConvertFrom(typeof(byte[]))) {
                                byte[] data = (byte[])converter.ConvertTo(null, CultureInfo.InvariantCulture, props[i].GetValue(control), typeof(byte[]));
                                propValue = Convert.ToBase64String(data);
                                pPropBag.Write(props[i].Name, ref propValue);
                            }
                        }
                    }
                }

                if (fClearDirty) {
                    activeXState[isDirty] = false;
                }
            }

            /// <devdoc>
            ///      Fires the OnSave event to all of our IAdviseSink
            ///      listeners.  Used for ActiveXSourcing.
            /// </devdoc>
            /// <internalonly/>
            private void SendOnSave() {
                int cnt = adviseList.Count;
                for (int i = 0; i < cnt; i++) {
                    UnsafeNativeMethods.IAdviseSink s = (UnsafeNativeMethods.IAdviseSink)adviseList[i];
                    Debug.Assert(s != null, "NULL in our advise list");
                    s.OnSave();
                }
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ActiveXImpl.SetAdvise"]/*' />
            /// <devdoc>
            ///      Implements IViewObject2::SetAdvise.
            /// </devdoc>
            public void SetAdvise(int aspects, int advf, UnsafeNativeMethods.IAdviseSink pAdvSink) {
                // if it's not a content aspect, we don't support it.
                //
                if ((aspects & NativeMethods.DVASPECT_CONTENT) == 0) {
                    ThrowHr(NativeMethods.DV_E_DVASPECT);
                }

                // set up some flags  [we gotta stash for GetAdvise ...]
                //
                activeXState[viewAdvisePrimeFirst] = (advf & NativeMethods.ADVF_PRIMEFIRST) != 0 ? true : false;
                activeXState[viewAdviseOnlyOnce] = (advf & NativeMethods.ADVF_ONLYONCE) != 0 ? true : false;

                if (viewAdviseSink != null && Marshal.IsComObject(viewAdviseSink)) {
                    Marshal.ReleaseComObject(viewAdviseSink);
                }

                viewAdviseSink = pAdvSink;

                // prime them if they want it [we need to store this so they can get flags later]
                //
                if (activeXState[viewAdvisePrimeFirst]) {
                    ViewChanged();
                }
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ActiveXImpl.SetClientSite"]/*' />
            /// <devdoc>
            ///      Implements IOleObject::SetClientSite.
            /// </devdoc>
            public void SetClientSite(UnsafeNativeMethods.IOleClientSite value) {
                if (clientSite != null) {

                    if (value == null) {
                        globalActiveXCount--;

                        if (globalActiveXCount == 0 && IsIE) {

                            // This the last ActiveX control and we are
                            // being hosted in IE.  Use private reflection
                            // to ask SystemEvents to shutdown.  This is to 
                            // prevent a crash (ASURT 139932).
                            //
                            // Note: must assert full trust here because SystemEvents
                            // link demands full trust.
                            new NamedPermissionSet("FullTrust").Assert();
                            try {
                                MethodInfo method = typeof(SystemEvents).GetMethod("Shutdown", 
                                                                                  BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod,
                                                                                  null, new Type[0], new ParameterModifier[0]);
                                Debug.Assert(method != null, "No Shutdown method on SystemEvents");
                                if (method != null) {
                                    method.Invoke(null, null);
                                }
                            }
                            finally {
                                CodeAccessPermission.RevertAssert();
                            }

                            Application.DisposeParkingWindow(control);
                        }
                    }

                    if (Marshal.IsComObject(clientSite)) {
                        Marshal.ReleaseComObject(clientSite);
                    }
                }

                clientSite = value;

                // Get the ambient properties that effect us...
                //
                Object obj = new Object();
                if (GetAmbientProperty(NativeMethods.ActiveX.DISPID_AMBIENT_UIDEAD, ref obj)) {
                    activeXState[uiDead] = (bool)obj;
                }

                if (control is IButtonControl && GetAmbientProperty(NativeMethods.ActiveX.DISPID_AMBIENT_UIDEAD, ref obj)) {
                    ((IButtonControl)control).NotifyDefault((bool)obj);
                }

                if (clientSite == null) {
                    if (accelTable != IntPtr.Zero) {
                        UnsafeNativeMethods.DestroyAcceleratorTable(new HandleRef(this, accelTable));
                        accelTable = IntPtr.Zero;
                        accelCount = -1;
                    }

                    if (IsIE) {
                        this.control.Dispose();
                    }
                    GC.Collect();
                    GC.WaitForPendingFinalizers();
                }
                else {
                    globalActiveXCount++;

                    if (globalActiveXCount == 1 && IsIE) {

                        // This the first ActiveX control and we are
                        // being hosted in IE.  Use private reflection
                        // to ask SystemEvents to start.  Startup will only
                        // restart system events if we previously shut it down.
                        // This is to prevent a crash (ASURT 139932).
                        //
                        // Note: must assert full trust here because SystemEvents
                        // link demands full trust.
                        new NamedPermissionSet("FullTrust").Assert();
                        try {
                            MethodInfo method = typeof(SystemEvents).GetMethod("Startup", 
                                                                              BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod,
                                                                              null, new Type[0], new ParameterModifier[0]);
                            Debug.Assert(method != null, "No Startup method on SystemEvents");
                            if (method != null) {
                                method.Invoke(null, null);
                            }
                        }
                        finally {
                            CodeAccessPermission.RevertAssert();
                        }
                    }
                }
            }

            /// <devdoc>
            ///      Implements IOleObject::SetExtent
            /// </devdoc>
            public void SetExtent(int dwDrawAspect, NativeMethods.tagSIZEL pSizel) {
                if ((dwDrawAspect & NativeMethods.DVASPECT_CONTENT) != 0) {

                    if (activeXState[changingExtents]) {
                        return;
                    }

                    activeXState[changingExtents] = true;

                    try {
                        Size size = new Size(HiMetricToPixel(pSizel.cx, pSizel.cy));
                        Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "SetExtent : new size:" + size.ToString());

                        // If we're in place active, let the in place site set our bounds.
                        // Otherwise, just set it on our control directly.
                        //
                        if (activeXState[inPlaceActive]) {
                            if (clientSite is UnsafeNativeMethods.IOleInPlaceSite) {
                                Rectangle bounds = control.Bounds;
                                bounds.Location = new Point(bounds.X, bounds.Y);
                                Size adjusted = new Size(size.Width, size.Height);
                                bounds.Width = adjusted.Width;
                                bounds.Height = adjusted.Height;
                                Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "SetExtent : Announcing to in place site that our rect has changed.");
                                Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "            Announcing rect = " + bounds);
                                Debug.Assert(clientSite != null, "How can we setextent before we are sited??");

                                ((UnsafeNativeMethods.IOleInPlaceSite)clientSite).OnPosRectChange(NativeMethods.COMRECT.FromXYWH(bounds.X, bounds.Y, bounds.Width, bounds.Height));
                            }
                        }

                        control.Size = size;

                        // Check to see if the control overwrote our size with
                        // its own values.
                        //
                        if (!control.Size.Equals(size)) {
                            Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "SetExtent : Control has changed size.  Setting dirty bit");
                            activeXState[isDirty] = true;

                            // If we're not inplace active, then anounce that the view changed.
                            //
                            if (!activeXState[inPlaceActive]) {
                                ViewChanged();
                            }

                            // We need to call RequestNewObjectLayout
                            // here so we visually display our new extents.
                            //
                            if (!activeXState[inPlaceActive] && clientSite != null) {
                                Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "SetExtent : Requesting new Object layout.");

                                clientSite.RequestNewObjectLayout();
                            }
                        }
                    }
                    finally {
                        activeXState[changingExtents] = false;
                    }
                }
                else {
                    // We don't support any other aspects
                    //
                    ThrowHr(NativeMethods.DV_E_DVASPECT);
                }
            }

            /// <devdoc>
            ///      Marks our state as in place visible.
            /// </devdoc>
            private void SetInPlaceVisible(bool visible) {
                activeXState[inPlaceVisible] = visible;
                control.Visible = visible;
            }

            /// <devdoc>
            ///      Implements IOleInPlaceObject::SetObjectRects.
            /// </devdoc>
            public void SetObjectRects(NativeMethods.COMRECT lprcPosRect, NativeMethods.COMRECT lprcClipRect) {

#if DEBUG
                if (CompModSwitches.ActiveX.TraceInfo) {
                    Debug.WriteLine("SetObjectRects:");
                    Debug.Indent();

                    if (lprcPosRect != null) {
                        Debug.WriteLine("PosLeft:    " + lprcPosRect.left.ToString());
                        Debug.WriteLine("PosTop:     " + lprcPosRect.top.ToString());
                        Debug.WriteLine("PosRight:   " + lprcPosRect.right.ToString());
                        Debug.WriteLine("PosBottom:  " + lprcPosRect.bottom.ToString());
                    }

                    if (lprcClipRect != null) {
                        Debug.WriteLine("ClipLeft:   " + lprcClipRect.left.ToString());
                        Debug.WriteLine("ClipTop:    " + lprcClipRect.top.ToString());
                        Debug.WriteLine("ClipRight:  " + lprcClipRect.right.ToString());
                        Debug.WriteLine("ClipBottom: " + lprcClipRect.bottom.ToString());
                    }
                    Debug.Unindent();
                }
#endif

                Rectangle posRect = Rectangle.FromLTRB(lprcPosRect.left, lprcPosRect.top, lprcPosRect.right, lprcPosRect.bottom);
                
                Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "Set control bounds: " + posRect.ToString());

                // ActiveX expects to be notified when a control's bounds change, and also 
                // intends to notify us through SetObjectRects when we report that the
                // bounds are about to change.  We implement this all on a control's Bounds
                // property, which doesn't use this callback mechanism.  The adjustRect
                // member handles this. If it is non-null, then we are being called in
                // response to an OnPosRectChange call.  In this case we do not
                // set the control bounds but set the bounds on the adjustRect.  When
                // this returns from the container and comes back to our OnPosRectChange
                // implementation, these new bounds will be handed back to the control
                // for the actual window change.
                //
                Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "Old Control Bounds: " + control.Bounds);
                if (activeXState[adjustingRect]) {
                    adjustRect.left = posRect.X;
                    adjustRect.top = posRect.Y;
                    adjustRect.right = posRect.Width + posRect.X;
                    adjustRect.bottom = posRect.Height + posRect.Y;
                }
                else {
                    activeXState[adjustingRect] = true;
                    try {
                        control.Bounds = posRect;
                    }
                    finally {
                        activeXState[adjustingRect] = false;
                    }
                }
                
                bool setRegion = false;

                if (clipRegion != IntPtr.Zero) {
                    // Bad -- after calling SetWindowReg, windows owns the region.
                    //SafeNativeMethods.DeleteObject(clipRegion);
                    clipRegion = IntPtr.Zero;
                    setRegion = true;
                }

                if (lprcClipRect != null) {

                    // The container wants us to clip, so figure out if we really
                    // need to.
                    //
                    Rectangle clipRect = Rectangle.FromLTRB(lprcClipRect.left, lprcClipRect.top, lprcClipRect.right, lprcClipRect.bottom);

                    Rectangle intersect;

                    // Trident always sends an empty ClipRect... and so, we check for that and not do an 
                    // intersect in that case.
                    //
                    if (!clipRect.IsEmpty)
                        intersect = Rectangle.Intersect(posRect, clipRect);
                    else
                        intersect = posRect;

                    if (!intersect.Equals(posRect)) {

                        // Offset the rectangle back to client coordinates
                        //
                        NativeMethods.RECT rcIntersect = NativeMethods.RECT.FromXYWH(intersect.X, intersect.Y, intersect.Width, intersect.Height);
                        IntPtr hWndParent = UnsafeNativeMethods.GetParent(new HandleRef(control, control.Handle));

                        Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "Old Intersect: " + new Rectangle(rcIntersect.left, rcIntersect.top, rcIntersect.right-rcIntersect.left, rcIntersect.bottom-rcIntersect.top));
                        Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "New Control Bounds: " + posRect);

                        UnsafeNativeMethods.MapWindowPoints(new HandleRef(null, hWndParent), new HandleRef(control, control.Handle), ref rcIntersect, 2);
                        
                        Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "New Intersect: " + new Rectangle(rcIntersect.left, rcIntersect.top, rcIntersect.right-rcIntersect.left, rcIntersect.bottom-rcIntersect.top));
                        
                        // Create a Win32 region for it
                        //
                        clipRegion = SafeNativeMethods.CreateRectRgn(rcIntersect.left, rcIntersect.top,
                                                                 rcIntersect.right, rcIntersect.bottom);
                        setRegion = true;
                        Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "Created clipping region");
                    }
                }

                // If our region has changed, set the new value.  We only do this if
                // the handle has been created, since otherwise the control will
                // merge our region automatically.
                //
                if (setRegion && control.IsHandleCreated) {
                    IntPtr finalClipRegion = clipRegion;

                    Region controlRegion = control.Region;
                    if (controlRegion != null) {
                        IntPtr rgn = control.GetHRgn(controlRegion);
                        finalClipRegion = MergeRegion(rgn);
                    }

                    UnsafeNativeMethods.SetWindowRgn(new HandleRef(control, control.Handle), new HandleRef(this, finalClipRegion), SafeNativeMethods.IsWindowVisible(new HandleRef(control, control.Handle)));
                }
                
                // Yuck.  Forms^3 uses transparent overlay windows that appear to cause
                // painting artifacts.  Flicker like a banshee.
                //
                control.Invalidate();
            }

            #if ACTIVEX_SOURCING
            
            //
            // This has been cut from the product.
            //
            
            /// <devdoc>
            ///      Shows a property page dialog.
            /// </devdoc>
            private void ShowProperties() {
                if (propPage == null) {
                    propPage = new ActiveXPropPage(control);
                }

                if (inPlaceFrame != null) {
                    inPlaceFrame.EnableModeless(0);
                }
                try {
                    propPage.Edit(control);
                }
                finally {
                    if (inPlaceFrame != null) {
                        inPlaceFrame.EnableModeless(1);
                    }
                }
            }
            #endif

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ActiveXImpl.ThrowHr"]/*' />
            /// <devdoc>
            ///      Throws the given hresult.  This is used by ActiveX sourcing.
            /// </devdoc>
            public static void ThrowHr(int hr) {
                ExternalException e = new ExternalException("", hr);
                throw e;
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ActiveXImpl.TranslateAccelerator"]/*' />
            /// <devdoc>
            ///     Handles IOleControl::TranslateAccelerator
            /// </devdoc>
            public int TranslateAccelerator(ref NativeMethods.MSG lpmsg) {
                int hr = NativeMethods.S_FALSE;

#if DEBUG
                if (CompModSwitches.ActiveX.TraceInfo) {
                    if (!control.IsHandleCreated) {
                        Debug.WriteLine("AxSource: TranslateAccelerator before handle creation");
                    }
                    else {
                        Message m = Message.Create(lpmsg.hwnd, lpmsg.message, lpmsg.wParam, lpmsg.lParam);
                        Debug.WriteLine("AxSource: TranslateAccelerator : " + m.ToString());
                    }
                }
#endif // DEBUG

                bool needPreProcess = false;
                bool letSiteProcess = true;
                
                switch (lpmsg.message) {
                    case NativeMethods.WM_KEYDOWN:
                    case NativeMethods.WM_SYSKEYDOWN:
                    case NativeMethods.WM_CHAR:
                    case NativeMethods.WM_SYSCHAR:
                        needPreProcess = true;
                        break;
                }

                Message msg = Message.Create(lpmsg.hwnd, lpmsg.message, lpmsg.wParam, lpmsg.lParam);

                if (needPreProcess) {
                    Control target = Control.FromChildHandleInternal(lpmsg.hwnd);
                    if (target != null && (control == target || control.Contains(target))) {
                    
                        if (target.PreProcessMessage(ref msg)) {
                            lpmsg.message = msg.Msg;
                            lpmsg.wParam = msg.WParam;
                            lpmsg.lParam = msg.LParam;
                            hr = NativeMethods.S_OK;
                        }
                        else {
                        
                            // PreProcessMessage wasn't interested in the key.  However, we still need to see if 
                            // this is an input key or input char.  If it is, then we do not want to invoke
                            // the site's TranslateAccelerator or else it may eat the key.
                            //
                            if (msg.Msg == NativeMethods.WM_KEYDOWN || msg.Msg == NativeMethods.WM_SYSKEYDOWN) {
                                Keys keyData = (Keys)((int)msg.WParam | (int)ModifierKeys);
                                if (target.IsInputKey(keyData)) {
                                    letSiteProcess = false;
                                }
                            }
                            else if (msg.Msg == NativeMethods.WM_CHAR) {
                                if (target.IsInputChar((char)msg.WParam)) {
                                    letSiteProcess = false;
                                }
                            }
                        }
                    }
                }

                if (hr == NativeMethods.S_FALSE && letSiteProcess) {
                    Debug.WriteLineIf(CompModSwitches.ActiveX.TraceInfo, "AxSource: Control did not process accelerator, handing to site");

                    if (clientSite is UnsafeNativeMethods.IOleControlSite) {
                        int keyState = 0;

                        if (UnsafeNativeMethods.GetKeyState(NativeMethods.VK_SHIFT) < 0)     keyState |= 1;
                        if (UnsafeNativeMethods.GetKeyState(NativeMethods.VK_CONTROL) < 0)   keyState |= 2;
                        if (UnsafeNativeMethods.GetKeyState(NativeMethods.VK_MENU) < 0)      keyState |= 4;

                        hr = ((UnsafeNativeMethods.IOleControlSite)clientSite).TranslateAccelerator(ref lpmsg, keyState);
                    }
                }

                return hr;
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ActiveXImpl.UIDeactivate"]/*' />
            /// <devdoc>
            ///      Implements IOleInPlaceObject::UIDeactivate.
            /// </devdoc>
            public int UIDeactivate() {

                // Only do this if we're UI active
                //
                if (!activeXState[uiActive]) {
                    return NativeMethods.S_OK;
                }

                activeXState[uiActive] = false;

                // Notify frame windows, if appropriate, that we're no longer ui-active.
                //
                if (inPlaceUiWindow != null) {
                    inPlaceUiWindow.SetActiveObject(null, null);
                }

                Debug.Assert(inPlaceFrame != null, "No inplace frame -- how dod we go UI active?");
                inPlaceFrame.SetActiveObject(null, null);

                if (clientSite is UnsafeNativeMethods.IOleInPlaceSite) {
                    Debug.Assert(clientSite != null, "How can we uideactivate before we are sited??");
                    ((UnsafeNativeMethods.IOleInPlaceSite)clientSite).OnUIDeactivate(0);
                }

                return NativeMethods.S_OK;
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ActiveXImpl.Unadvise"]/*' />
            /// <devdoc>
            ///      Implements IOleObject::Unadvise
            /// </devdoc>
            public void Unadvise(int dwConnection) {
                if (dwConnection > adviseList.Count || adviseList[dwConnection - 1] == null) {
                    ThrowHr(NativeMethods.OLE_E_NOCONNECTION);
                }

                UnsafeNativeMethods.IAdviseSink sink = (UnsafeNativeMethods.IAdviseSink)adviseList[dwConnection - 1];
                adviseList.RemoveAt(dwConnection - 1);
                if (sink != null && Marshal.IsComObject(sink)) {
                    Marshal.ReleaseComObject(sink);
                }
            }

            /// <devdoc>
            ///     Notifies our site that we have changed our size and location.
            /// </devdoc>
            /// <internalonly/>
            public void UpdateBounds(ref int x, ref int y, ref int width, ref int height, int flags) {

                if (!activeXState[adjustingRect] && activeXState[inPlaceVisible] && clientSite is UnsafeNativeMethods.IOleInPlaceSite) {

                    NativeMethods.COMRECT rc = new NativeMethods.COMRECT();

                    if ((flags & NativeMethods.SWP_NOMOVE) != 0) {
                        rc.left = control.Left;
                        rc.top = control.Top;
                    }
                    else {
                        rc.left = x;
                        rc.top = y;
                    }

                    if ((flags & NativeMethods.SWP_NOSIZE) != 0) {
                        rc.right = rc.left + control.Width;
                        rc.bottom = rc.top + control.Height;
                    }
                    else {
                        rc.right = rc.left + width;
                        rc.bottom = rc.top + height;
                    }

                    // This member variable may be modified by SetObjectRects by the container.
                    adjustRect = rc;
                    activeXState[adjustingRect] = true;

                    try {
                        ((UnsafeNativeMethods.IOleInPlaceSite)clientSite).OnPosRectChange(rc);
                    }
                    finally {
                        adjustRect = null;
                        activeXState[adjustingRect] = false;
                    }

                    // On output, the new bounds will be reflected in  rc
                    if ((flags & NativeMethods.SWP_NOMOVE) == 0) {
                        x = rc.left;
                        y = rc.top;
                    }
                    if ((flags & NativeMethods.SWP_NOSIZE) == 0) {
                        width = rc.right - rc.left;
                        height = rc.bottom - rc.top;
                    }
                }
            }

            /// <devdoc>
            ///      Notifies our view advise sink (if it exists) that the view has
            ///      changed.
            /// </devdoc>
            /// <internalonly/>
            private void ViewChanged() {
                // send the view change notification to anybody listening.
                //
                // Note: Word2000 won't resize components correctly if an OnViewChange notification
                //       is sent while the component is persisting it's state.  The !m_fSaving check
                //       is to make sure we don't call OnViewChange in this case.
                //
                if (viewAdviseSink != null && !activeXState[saving]) {

                    viewAdviseSink.OnViewChange(NativeMethods.DVASPECT_CONTENT, -1);

                    if (activeXState[viewAdviseOnlyOnce]) {
                        if (Marshal.IsComObject(viewAdviseSink)) {
                            Marshal.ReleaseComObject(viewAdviseSink);
                        }
                        viewAdviseSink = null;
                    }
                }
            }

            /// <devdoc>
            ///      Called when the window handle of the control has changed.
            /// </devdoc>
            void IWindowTarget.OnHandleChange(IntPtr newHandle) {
                controlWindowTarget.OnHandleChange(newHandle);
            }

            /// <devdoc>
            ///      Called to do control-specific processing for this window.
            /// </devdoc>
            void IWindowTarget.OnMessage(ref Message m) {
                if (activeXState[uiDead]) {
                    if (m.Msg >= NativeMethods.WM_MOUSEFIRST && m.Msg <= NativeMethods.WM_MOUSELAST) {
                        return;
                    }
                    if (m.Msg >= NativeMethods.WM_NCLBUTTONDOWN && m.Msg <= NativeMethods.WM_NCMBUTTONDBLCLK) {
                        return;
                    }
                    if (m.Msg >= NativeMethods.WM_KEYFIRST && m.Msg <= NativeMethods.WM_KEYLAST) {
                        return;
                    }
                }

                controlWindowTarget.OnMessage(ref m);
            }

            /// <devdoc>
            ///      This is a property bag implementation that sits on a stream.  It can
            ///      read and write the bag to the stream.
            /// </devdoc>
            private class PropertyBagStream : UnsafeNativeMethods.IPropertyBag {
                private Hashtable bag = new Hashtable();

                internal void Read(UnsafeNativeMethods.IStream istream) {
                    // visual basic's memory streams don't support seeking, so we have to 
                    // work around this limitation here.  We do this by copying
                    // the contents of the stream into a MemoryStream object.
                    //
                    Stream stream = new DataStreamFromComStream(istream);
                    const int PAGE_SIZE = 0x1000; // one page (4096b)
                    byte[] streamData = new byte[PAGE_SIZE]; 
                    int offset = 0;

                    int count = stream.Read(streamData, offset, PAGE_SIZE);
                    int totalCount = count;

                    while (count == PAGE_SIZE) {
                        byte[] newChunk = new byte[streamData.Length + PAGE_SIZE];
                        Array.Copy(streamData, newChunk, streamData.Length);
                        streamData = newChunk;

                        offset += PAGE_SIZE;
                        count = stream.Read(streamData, offset, PAGE_SIZE);
                        totalCount += count;
                    }

                    stream = new MemoryStream(streamData);

                    BinaryFormatter formatter = new BinaryFormatter();
                    try {
                        bag = (Hashtable)formatter.Deserialize(stream);
                    }
                    catch {
                        // Error reading.  Just init an empty hashtable.
                        bag = new Hashtable();
                    }
                }

                int UnsafeNativeMethods.IPropertyBag.Read(string pszPropName, ref object pVar, UnsafeNativeMethods.IErrorLog pErrorLog) {
                    if (!bag.Contains(pszPropName))
                        return NativeMethods.E_INVALIDARG;
                    
                    pVar = bag[pszPropName];
                    return NativeMethods.S_OK;
                }

                int UnsafeNativeMethods.IPropertyBag.Write(string pszPropName, ref object pVar) {
                    bag[pszPropName] = pVar;
                    return NativeMethods.S_OK;
                }

                internal void Write(UnsafeNativeMethods.IStream istream) {
                    Stream stream = new DataStreamFromComStream(istream);
                    BinaryFormatter formatter = new BinaryFormatter();
                    formatter.Serialize(stream, bag);
                }
            }
        }

        /// <devdoc>
        ///     This is a marshaler object that knows how to marshal IFont to Font
        ///     and back.
        /// </devdoc>
        private class ActiveXFontMarshaler : ICustomMarshaler {

            private static ActiveXFontMarshaler instance;
            
            public void CleanUpManagedData(object obj) {
            }

            public void CleanUpNativeData(IntPtr pObj) {
                Marshal.Release(pObj);
            }

            public static ICustomMarshaler GetInstance(string cookie) {
                if (instance == null) {
                    instance = new ActiveXFontMarshaler();
                }
                return instance;
            }

            public int GetNativeDataSize() {
                return -1; // not a value type, so use -1
            }

            public IntPtr MarshalManagedToNative(object obj) {
                Font font = (Font)obj;
                NativeMethods.tagFONTDESC fontDesc = new NativeMethods.tagFONTDESC();
                NativeMethods.LOGFONT logFont = new NativeMethods.LOGFONT();

                IntSecurity.ObjectFromWin32Handle.Assert();
                try {
                    font.ToLogFont(logFont);
                }
                finally {
                    CodeAccessPermission.RevertAssert();
                }

                fontDesc.lpstrName = font.Name;
                fontDesc.cySize = (long)(font.SizeInPoints * 10000);
                fontDesc.sWeight = (short)logFont.lfWeight;
                fontDesc.sCharset = logFont.lfCharSet;
                fontDesc.fItalic = font.Italic;
                fontDesc.fUnderline = font.Underline;
                fontDesc.fStrikethrough = font.Strikeout;

                Guid iid = typeof(SafeNativeMethods.IFont).GUID;

                SafeNativeMethods.IFont oleFont = SafeNativeMethods.OleCreateFontIndirect(fontDesc, ref iid);
                IntPtr pFont = Marshal.GetIUnknownForObject(oleFont);
                IntPtr pIFont;

                int hr = Marshal.QueryInterface(pFont, ref iid, out pIFont);

                Marshal.Release(pFont);

                if (NativeMethods.Failed(hr)) {
                    Marshal.ThrowExceptionForHR(hr);
                }

                return pIFont;
            }

            public object MarshalNativeToManaged(IntPtr pObj) {
                SafeNativeMethods.IFont nativeFont = (SafeNativeMethods.IFont)Marshal.GetObjectForIUnknown(pObj);
                IntPtr hfont = IntPtr.Zero;

                hfont = nativeFont.GetHFont();

                Font font = null;

                try {
                    font = Font.FromHfont(hfont);
                }
                catch {
                    font = Control.DefaultFont;
                }

                return font;
            }
        }

        /// <devdoc>
        ///      Simple verb enumerator.
        /// </devdoc>
        private class ActiveXVerbEnum : UnsafeNativeMethods.IEnumOLEVERB {
            private NativeMethods.tagOLEVERB[] verbs;
            private int current;

            public ActiveXVerbEnum(NativeMethods.tagOLEVERB[] verbs) {
                this.verbs = verbs;
                current = 0;
            }

            public int Next(int celt, NativeMethods.tagOLEVERB rgelt, int[] pceltFetched) {
                int fetched = 0;

                if (celt != 1) {
                    Debug.Fail("Caller of IEnumOLEVERB requested celt > 1, but clr marshalling does not support this.");
                    celt = 1;
                }

                while (celt > 0 && current < verbs.Length) {
                    rgelt.lVerb = verbs[current].lVerb;
                    rgelt.lpszVerbName = verbs[current].lpszVerbName;
                    rgelt.fuFlags = verbs[current].fuFlags;
                    rgelt.grfAttribs = verbs[current].grfAttribs;
                    celt--;
                    current++;
                    fetched++;
                }

                if (pceltFetched != null) {
                    pceltFetched[0] = fetched;
                }

#if DEBUG
                if (CompModSwitches.ActiveX.TraceInfo) {
                    Debug.WriteLine("AxSource:IEnumOLEVERB::Next returning " + fetched.ToString() + " verbs:");
                    Debug.Indent();
                    for (int i = current - fetched; i < current; i++) {
                        Debug.WriteLine(i.ToString() + ": " + verbs[i].lVerb + " " + (verbs[i].lpszVerbName == null ? string.Empty : verbs[i].lpszVerbName));
                    }
                    Debug.Unindent();
                }
#endif
                return(celt == 0 ? NativeMethods.S_OK : NativeMethods.S_FALSE);
            }

            public int Skip(int celt) {
                if (current + celt < verbs.Length) {
                    current += celt;
                    return NativeMethods.S_OK;
                }
                else {
                    current = verbs.Length;
                    return NativeMethods.S_FALSE;
                }
            }

            public void Reset() {
                current = 0;
            }

            public void Clone(out UnsafeNativeMethods.IEnumOLEVERB ppenum) {
                ppenum = new ActiveXVerbEnum(verbs);
            }
        }

        #if ACTIVEX_SOURCING
        
        //
        // This has been cut from the product.
        //
        
        /// <devdoc>
        ///     The properties window we display.
        /// </devdoc>
        private class ActiveXPropPage {
            private Form form;
            private PropertyGrid grid;
            private ComponentEditor compEditor;

            public ActiveXPropPage(object component) {
                compEditor = (ComponentEditor)TypeDescriptor.GetEditor(component, typeof(ComponentEditor));

                if (compEditor == null) {
                    form = new Form();
                    grid = new PropertyGrid();

                    form.Text = SR.GetString(SR.AXProperties);
                    form.StartPosition = FormStartPosition.CenterParent;
                    form.Size = new Size(300, 350);
                    form.FormBorderStyle = FormBorderStyle.Sizable;
                    form.MinimizeBox = false;
                    form.MaximizeBox = false;
                    form.ControlBox = true;
                    form.SizeGripStyle = SizeGripStyle.Show;
                    form.DockPadding.Bottom = 16; // size grip size

                    Bitmap bitmap = new Bitmap(grid.GetType(), "PropertyGrid.bmp");
                    bitmap.MakeTransparent();
                    form.Icon = Icon.FromHandle(bitmap.GetHicon());

                    grid.Dock = DockStyle.Fill;

                    form.Controls.Add(grid);
                }
            }

            public void Edit(object editingObject) {
                if (compEditor != null) {
                    compEditor.EditComponent(null, editingObject);
                }
                else {
                    grid.SelectedObject = editingObject;
                    form.ShowDialog();
                }
            }
        }
        
        #endif

        /// <devdoc>
        ///      Contains a single ambient property, including DISPID, name and value.
        /// </devdoc>
        private class AmbientProperty {
            private string name;
            private int dispID;
            private Object value;
            private bool empty;

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.AmbientProperty.AmbientProperty"]/*' />
            /// <devdoc>
            ///      Creates a new, empty ambient property.
            /// </devdoc>
            public AmbientProperty(string name, int dispID) {
                this.name = name;
                this.dispID = dispID;
                this.value = null;
                this.empty = true;
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.AmbientProperty.Name"]/*' />
            /// <devdoc>
            ///      The windows forms property name.
            /// </devdoc>
            public string Name {
                get {
                    return name;
                }
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.AmbientProperty.DispID"]/*' />
            /// <devdoc>
            ///      The DispID for the property.
            /// </devdoc>
            public int DispID {
                get {
                    return dispID;
                }
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.AmbientProperty.Empty"]/*' />
            /// <devdoc>
            ///      Returns true if this property has not been set.
            /// </devdoc>
            public bool Empty {
                get {
                    return empty;
                }
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.AmbientProperty.Value"]/*' />
            /// <devdoc>
            ///      The current value of the property.
            /// </devdoc>
            public Object Value {
                get {
                    return value;
                }
                set {
                    this.value = value;
                    empty = false;
                }
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.AmbientProperty.ResetValue"]/*' />
            /// <devdoc>
            ///      Resets the property.
            /// </devdoc>
            public void ResetValue() {
                empty = true;
                value = null;
            }
        }

        /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ControlAccessibleObject"]/*' />
        /// <devdoc>
        ///      An implementation of AccessibleChild for use with Controls        
        /// </devdoc>
        [System.Runtime.InteropServices.ComVisible(true)]        
        public class ControlAccessibleObject : AccessibleObject {

            private static IntPtr oleAccAvailable = NativeMethods.InvalidIntPtr;

            // Member variables

            private IntPtr handle = IntPtr.Zero; // Associated window handle (if any)
            private Control ownerControl = null; // The associated Control for this AccessibleChild (if any)

            // constructors

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ControlAccessibleObject.ControlAccessibleObject"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public ControlAccessibleObject(Control ownerControl) {

                Debug.Assert(ownerControl != null, "Cannot construct a ControlAccessibleObject with a null ownerControl");
                if (ownerControl == null) {
                    throw new ArgumentNullException("ownerControl");
                }

                this.ownerControl = ownerControl;
                this.Handle = ownerControl.Handle;
            }
            
            /// <include file='doc\Control.uex' path='docs/doc[@for="ControlAccessibleObject.DefaultAction"]/*' />
            public override string DefaultAction {
                get {
                    string defaultAction = ownerControl.AccessibleDefaultActionDescription;
                    if (defaultAction != null) {
                        return defaultAction;
                    }
                    else {
                        return base.DefaultAction;
                    }
                }
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ControlAccessibleObject.Description"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override string Description {
                get {
                    string description = ownerControl.AccessibleDescription;
                    if (description != null) {
                        return description;
                    }
                    else {
                        return base.Description;
                    }
                }
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ControlAccessibleObject.Handle"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public IntPtr Handle {

                get {
                    return handle;
                }

                set {
                    if (handle != value) {
                        handle = value;

                        if (oleAccAvailable == IntPtr.Zero) {
                            return;
                        }

                        bool freeLib = false;

                        if (oleAccAvailable == NativeMethods.InvalidIntPtr) {
                            oleAccAvailable = UnsafeNativeMethods.LoadLibrary("oleacc.dll");
                            freeLib = (oleAccAvailable != IntPtr.Zero);
                        }

                        // Update systemIAccessible
                        // We need to store internally the system provided
                        // IAccessible, because some windows forms controls use it
                        // as the default IAccessible implementation.
                        if (handle != IntPtr.Zero && oleAccAvailable != IntPtr.Zero) {
                            UseStdAccessibleObjects(handle);
                        }

                        if (freeLib) {
                            UnsafeNativeMethods.FreeLibrary(new HandleRef(null, oleAccAvailable));
                        }

                    }
                } // end Handle.Set

            } // end Handle

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ControlAccessibleObject.Help"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override string Help {
                get {
                    QueryAccessibilityHelpEventHandler handler = (QueryAccessibilityHelpEventHandler)Owner.Events[EventQueryAccessibilityHelp];

                    if (handler != null) {
                        QueryAccessibilityHelpEventArgs args = new QueryAccessibilityHelpEventArgs();
                        handler(Owner, args);
                        return args.HelpString;
                    }
                    else {
                        return base.Help;
                    }
                }
            }     
            
            /// <include file='doc\Control.uex' path='docs/doc[@for="ControlAccessibleObject.KeyboardShortcut"]/*' />
            public override string KeyboardShortcut {
                get {
                    // Get this control's keyboard shortcut from the immediately preceeding label, if any
                    //
                    Label previousLabel = PreviousLabel;
                    if (previousLabel != null && previousLabel.Mnemonic != (char)0) {
                        return "Alt+" + previousLabel.Mnemonic;
                    }

                    string baseShortcut = base.KeyboardShortcut;
                    
                    if ((baseShortcut == null || baseShortcut.Length == 0) && this.Owner.Mnemonic != (char)0) {
                        return "Alt+" + this.Owner.Mnemonic;
                    }
                        
                    return baseShortcut;
                }
            } 

            internal override Control MarshalingControl {
                get {
                    return this.ownerControl;
                }
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ControlAccessibleObject.Name"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override string Name {
                get {
                    string name = ownerControl.AccessibleName;
                    if (name != null) {
                        return name;
                    }
                    
                    string baseName = base.Name;
                    
                    if (baseName == null || baseName.Length == 0) {
                        // Get this control's accessible name from the immediately preceeding label, if any
                        //
                        Label previousLabel = PreviousLabel;
                        if (previousLabel != null) {
                            return previousLabel.AccessibilityObject.Name;
                        }
                    }
                        
                    return baseName;
                }
                set {
                    ownerControl.AccessibleName = value;
                }
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ControlAccessibleObject.Owner"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public Control Owner {
                get {
                    return ownerControl;
                }
            }
            
            private Label PreviousLabel {
                get {
                    // Look for a label immediately preceeding this control in the tab order,
                    // and use its name for the accessible name.
                    //
                    if (Owner.Parent == null) {
                        return null;
                    }
                    ContainerControl c = Owner.Parent.GetContainerControlInternal() as ContainerControl;
                    if (c != null) {
                        Label previous = c.GetNextControl(Owner, false) as Label;
                        if (previous != null) {
                            return previous;
                        }
                    }
                    return null;
                }
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ControlAccessibleObject.Role"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override AccessibleRole Role {
                get {
                    AccessibleRole role = ownerControl.AccessibleRole;
                    if (role != AccessibleRole.Default) {
                        return role;
                    }
                    else {
                        return base.Role;
                    }

                }
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ControlAccessibleObject.GetHelpTopic"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override int GetHelpTopic(out string fileName) {
                int topic = 0;

                QueryAccessibilityHelpEventHandler handler = (QueryAccessibilityHelpEventHandler)Owner.Events[EventQueryAccessibilityHelp];                                     

                if (handler != null) {
                    QueryAccessibilityHelpEventArgs args = new QueryAccessibilityHelpEventArgs();
                    handler(Owner, args);

                    fileName = args.HelpNamespace;                             

                    try {
                        topic = Int32.Parse(args.HelpKeyword);
                    }
                    catch {
                    }

                    return topic;
                }
                else {
                    return base.GetHelpTopic(out fileName);
                }
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ControlAccessibleObject.NotifyClients"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public void NotifyClients(AccessibleEvents accEvent) {
                Debug.WriteLineIf(CompModSwitches.MSAA.TraceInfo, "Control.NotifyClients: this = " + 
                                  this.ToString() + ", accEvent = " + accEvent.ToString() + ", childID = self");
                                  
                UnsafeNativeMethods.NotifyWinEvent((int)accEvent, new HandleRef(this, Handle), NativeMethods.OBJID_CLIENT, 0);
            }
                 
            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ControlAccessibleObject.NotifyClients1"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public void NotifyClients(AccessibleEvents accEvent, int childID) {

                Debug.WriteLineIf(CompModSwitches.MSAA.TraceInfo, "Control.NotifyClients: this = " + 
                                  this.ToString() + ", accEvent = " + accEvent.ToString() + ", childID = " + childID.ToString());

                UnsafeNativeMethods.NotifyWinEvent((int)accEvent, new HandleRef(this, Handle), NativeMethods.OBJID_CLIENT, childID + 1);
            }
            
            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ControlAccessibleObject.ToString"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override string ToString() {
                if (Owner != null) {
                    return "ControlAccessibleObject: Owner = " + Owner.ToString();                    
                }
                else {
                    return "ControlAccessibleObject: Owner = null";
                }
            }
        }

        /// <devdoc>
        /// </devdoc>
        private class DropTarget : UnsafeNativeMethods.IOleDropTarget {
            private IDataObject lastDataObject = null;
            private DragDropEffects lastEffect = DragDropEffects.None;
            private Control owner;

            public DropTarget(Control owner) {
                Debug.WriteLineIf(CompModSwitches.DragDrop.TraceInfo, "DropTarget created");
                this.owner = owner;
            }

#if DEBUG
            ~DropTarget() {
                Debug.WriteLineIf(CompModSwitches.DragDrop.TraceInfo, "DropTarget destroyed");
            }
#endif

            private DragEventArgs CreateDragEventArgs(object pDataObj, int grfKeyState, NativeMethods.POINTL pt, int pdwEffect) {
            
                IDataObject data = null;

                if (pDataObj == null) {
                    data = lastDataObject;
                }
                else {
                    if (pDataObj is IDataObject) {
                        data = (IDataObject)pDataObj;
                    }
                    else if (pDataObj is UnsafeNativeMethods.IOleDataObject) {
                        data = new DataObject(pDataObj);
                    }
                    else {
                        return null; // Unknown data object interface; we can't work with this so return null
                    }
                }

                DragEventArgs drgevent = new DragEventArgs(data, grfKeyState, pt.x, pt.y, (DragDropEffects)pdwEffect, lastEffect);
                lastDataObject = data;
                return drgevent;
            }

            int UnsafeNativeMethods.IOleDropTarget.OleDragEnter(object pDataObj, int grfKeyState,
                                                          long pt,
                                                          ref int pdwEffect) {
                Debug.WriteLineIf(CompModSwitches.DragDrop.TraceInfo, "OleDragEnter recieved");
                NativeMethods.POINTL ptl = new NativeMethods.POINTL();
                ptl.x = GetX(pt);
                ptl.y = GetY(pt);
                Debug.WriteLineIf(CompModSwitches.DragDrop.TraceInfo, "\t" + (ptl.x) + "," + (ptl.y));
                Debug.Assert(pDataObj != null, "OleDragEnter didn't give us a valid data object.");
                DragEventArgs drgevent = CreateDragEventArgs(pDataObj, grfKeyState, ptl, pdwEffect);
                
                if (drgevent != null) {
                    owner.OnDragEnter(drgevent);
                    pdwEffect = (int)drgevent.Effect;
                    lastEffect = drgevent.Effect;
                }
                else {
                    pdwEffect = (int)DragDropEffects.None;
                }
                return NativeMethods.S_OK;
            }
            int UnsafeNativeMethods.IOleDropTarget.OleDragOver(int grfKeyState, long pt, ref int pdwEffect) {
                Debug.WriteLineIf(CompModSwitches.DragDrop.TraceInfo, "OleDragOver recieved");
                NativeMethods.POINTL ptl = new NativeMethods.POINTL();
                ptl.x = GetX(pt);
                ptl.y = GetY(pt);
                Debug.WriteLineIf(CompModSwitches.DragDrop.TraceInfo, "\t" + (ptl.x) + "," + (ptl.y));
                DragEventArgs drgevent = CreateDragEventArgs(null, grfKeyState, ptl, pdwEffect);
                owner.OnDragOver(drgevent);
                pdwEffect = (int)drgevent.Effect;
                lastEffect = drgevent.Effect;
                return NativeMethods.S_OK;
            }
            int UnsafeNativeMethods.IOleDropTarget.OleDragLeave() {
                Debug.WriteLineIf(CompModSwitches.DragDrop.TraceInfo, "OleDragLeave recieved");
                owner.OnDragLeave(EventArgs.Empty);
                return NativeMethods.S_OK;
            }
            int UnsafeNativeMethods.IOleDropTarget.OleDrop(object pDataObj, int grfKeyState, long pt, ref int pdwEffect) {
                Debug.WriteLineIf(CompModSwitches.DragDrop.TraceInfo, "OleDrop recieved");
                NativeMethods.POINTL ptl = new NativeMethods.POINTL();
                ptl.x = GetX(pt);
                ptl.y = GetY(pt);
                Debug.WriteLineIf(CompModSwitches.DragDrop.TraceInfo, "\t" + (ptl.x) + "," + (ptl.y));
                DragEventArgs drgevent = CreateDragEventArgs(pDataObj, grfKeyState, ptl, pdwEffect);
                
                if (drgevent != null) {
                    owner.OnDragDrop(drgevent);
                    pdwEffect = (int)drgevent.Effect;
                }
                else {
                    pdwEffect = (int)DragDropEffects.None;
                }
                
                lastEffect = DragDropEffects.None;
                lastDataObject = null;
                return NativeMethods.S_OK;
            }

            private int GetX(long pt) {
                return(int)(pt & 0xFFFFFFFF);

            }

            private int GetY(long pt) {
                return(int)((pt >> 32) & 0xFFFFFFFF);
            }
        }


        /// <devdoc>
        /// </devdoc>
        private class DropSource : UnsafeNativeMethods.IOleDropSource {
            private Control peer;

            public DropSource( Control peer ) {
                if (peer == null)
                    throw new ArgumentException("peer");
                this.peer = peer;
            }

            public int OleQueryContinueDrag(int fEscapePressed, int grfKeyState) {
                QueryContinueDragEventArgs qcdevent = null;
                bool escapePressed = (fEscapePressed != 0);
                DragAction action = DragAction.Continue;
                if (escapePressed) {
                    action = DragAction.Cancel;
                }
                else if ((grfKeyState & NativeMethods.MK_LBUTTON) == 0
                         && (grfKeyState & NativeMethods.MK_RBUTTON) == 0
                         && (grfKeyState & NativeMethods.MK_MBUTTON) == 0) {
                    action = DragAction.Drop;
                }

                qcdevent = new QueryContinueDragEventArgs(grfKeyState,escapePressed, action);
                peer.OnQueryContinueDrag(qcdevent);

                int hr = 0;

                switch (qcdevent.Action) {
                    case DragAction.Drop:
                        hr = DragDropSDrop;
                        break;
                    case DragAction.Cancel:
                        hr = DragDropSCancel;
                        break;
                }

                return hr;
            }

            public int OleGiveFeedback(int dwEffect) {
                GiveFeedbackEventArgs gfbevent = new GiveFeedbackEventArgs((DragDropEffects) dwEffect, true);
                peer.OnGiveFeedback(gfbevent);
                if (gfbevent.UseDefaultCursors) {
                    return DragDropSUseDefaultCursors;
                }
                return 0;
            }
        }

        // Fonts can be a pain to track, so we wrap Hfonts in this class to get a Finalize method.
        // CONSIDER: we could probably get deterministic lifetimes using reference counting.
        internal sealed class FontHandleWrapper : MarshalByRefObject {
#if DEBUG
            private string stackOnCreate = null;
            private string stackOnDispose = null;
#endif
            private IntPtr handle;

            internal FontHandleWrapper(Font font) {
#if DEBUG
                if (CompModSwitches.LifetimeTracing.Enabled) stackOnCreate = new System.Diagnostics.StackTrace().ToString();
#endif
                handle = font.ToHfont();
            }

            internal IntPtr Handle {
                get { 
                    Debug.Assert(handle != IntPtr.Zero, "FontHandleWrapper disposed, but still being accessed");
                    return handle;
                }
            }

            public void Dispose() {
                if (handle != IntPtr.Zero) {
#if DEBUG
                    if (CompModSwitches.LifetimeTracing.Enabled) stackOnDispose = new System.Diagnostics.StackTrace().ToString();
#endif
                    SafeNativeMethods.DeleteObject(new HandleRef(this, handle));
                    handle = IntPtr.Zero;
                }

            }

            ~FontHandleWrapper() {
                Dispose();
            }
        }

        private struct ImeModeConversion {
            public int setBits;
            public int clearBits;
        }

        /// <devdoc>
        ///     Used with BeginInvoke/EndInvoke
        /// </devdoc>
        private class ThreadMethodEntry : IAsyncResult {
            internal Control   caller;
            internal Delegate  method;
            internal Object[] args;
            internal Object    retVal;
            internal Exception exception;
            internal bool   synchronous;
            private bool isCompleted;
            private ManualResetEvent resetEvent;

            // Store the compressed stack associated with the caller thread, and
            // information about which thread actually got the stack applied to it.
            //
            internal CompressedStack compressedStack;

            public ThreadMethodEntry(Control caller, Delegate method, Object[] args, bool synchronous, CompressedStack compressedStack) {
                this.caller = caller;
                this.method = method;
                this.args = args;
                this.exception = null;
                this.retVal = null;
                this.synchronous = synchronous;
                this.isCompleted = false;
                this.resetEvent = null;
                this.compressedStack = compressedStack;
            }

            ~ThreadMethodEntry()
            {
                if (this.resetEvent != null)
                {
                    this.resetEvent.Close();
                }
            }

            public Object AsyncObject {
                get {
                    return this.caller;
                }
            }

            public  Object AsyncState {
                get {
                    return null;                    
                }                
            }

            public WaitHandle AsyncWaitHandle {
                get {
                    if (this.resetEvent == null)
                    {
                        this.resetEvent = new ManualResetEvent(false);
                        if (this.isCompleted)
                        {
                            this.resetEvent.Set();
                        }
                    }
                    return(WaitHandle)this.resetEvent;
                }
            }

            public bool CompletedSynchronously {
                get {
                    if (this.isCompleted && this.synchronous)
                        return true;

                    return false;
                }                        
            }

            public bool IsCompleted {
                get {   
                    return this.isCompleted;         
                }
            }

            internal void Complete() {
                this.isCompleted = true;
                if (this.resetEvent != null)
                {
                    this.resetEvent.Set();
                }
            }
        }


        /// <devdoc>
        ///     This class contains layout information for either anchor or dock properties.
        ///     These properties are mutually exclusive, so we share their data here.
        /// </devdoc>
        private class LayoutInfo {
            private byte mode;  // compact dock and anchor enum values into a byte
            public bool IsDock; // Should fold this into mode for a single DWORD.
            private int x1, x2, y1, y2;
            
            public LayoutInfo(DockStyle dock, int originalX, int originalY, int originalWidth, int originalHeight) {
                Debug.Assert(((DockStyle)((byte)dock)) == dock, "DockStyle has overflowed byte");
                mode = (byte)dock;
                IsDock = true;
                x1 = originalX;
                y1 = originalY;
                x2 = originalWidth;
                y2 = originalHeight;
            }
            
            public LayoutInfo(AnchorStyles anchor) {
                Debug.Assert(((AnchorStyles)((byte)anchor)) == anchor, "AnchorStyles has overflowed byte");
                mode = (byte)anchor;
                IsDock = false;
            }
            
            public AnchorStyles Anchor {
                get {
                    Debug.Assert(!IsDock, "Do not access Anchor property unless IsDock is false");
                    return (AnchorStyles)mode;
                }
            }
            
            public int Bottom {
                get {
                    Debug.Assert(!IsDock, "This property is only valid if IsDock is false.");
                    return y2;
                }
                set {
                    Debug.Assert(!IsDock, "This property is only valid if IsDock is false.");
                    y2 = value;
                }
            }
            
            public DockStyle Dock {
                get {
                    Debug.Assert(IsDock, "Do not access Dock property unless IsDock is true");
                    return (DockStyle)mode;
                }
                set {
                    Debug.Assert(IsDock, "Do not access Dock property unless IsDock is true");
                    mode = (byte)value;
                }
            }
            
            public int Left {
                get {
                    Debug.Assert(!IsDock, "This property is only valid if IsDock is false.");
                    return x1;
                }
                set {
                    Debug.Assert(!IsDock, "This property is only valid if IsDock is false.");
                    x1 = value;
                }
            }
            
            public int OriginalHeight {
                get {
                    Debug.Assert(IsDock, "This property is only valid if IsDock is true.");
                    return y2;
                }
                set {
                    Debug.Assert(IsDock, "This property is only valid if IsDock is true.");
                    y2 = value;
                }
            }
            
            public int OriginalWidth {
                get {
                    Debug.Assert(IsDock, "This property is only valid if IsDock is true.");
                    return x2;
                }
                set {
                    Debug.Assert(IsDock, "This property is only valid if IsDock is true.");
                    x2 = value;
                }
            }
            
            public int OriginalX {
                get {
                    Debug.Assert(IsDock, "This property is only valid if IsDock is true.");
                    return x1;
                }
                set {
                    Debug.Assert(IsDock, "This property is only valid if IsDock is true.");
                    x1 = value;
                }
            }
            
            public int OriginalY {
                get {
                    Debug.Assert(IsDock, "This property is only valid if IsDock is true.");
                    return y1;
                }
                set {
                    Debug.Assert(IsDock, "This property is only valid if IsDock is true.");
                    y1 = value;
                }
            }
            
            public int Right {
                get {
                    Debug.Assert(!IsDock, "This property is only valid if IsDock is false.");
                    return x2;
                }
                set {
                    Debug.Assert(!IsDock, "This property is only valid if IsDock is false.");
                    x2 = value;
                }
            }
            
            public int Top {
                get {
                    Debug.Assert(!IsDock, "This property is only valid if IsDock is false.");
                    return y1;
                }
                set {
                    Debug.Assert(!IsDock, "This property is only valid if IsDock is false.");
                    y1 = value;
                }
            }
        }
        
        //  A bunch of static methods dealing with anchoring and docking
        private class LayoutManager {
            // Layout for a single anchored control.  There's no order dependency when laying out anchored controls.
            private static void AnchorControl(Control ctl, Rectangle parentDisplayRectangle) {
                Rectangle displayRect = parentDisplayRectangle;
                Debug.WriteLineIf(CompModSwitches.RichLayout.TraceInfo, "\t\t'" + ctl.Text + "' is anchored at " + ctl.Bounds.ToString());

                LayoutInfo layout = (LayoutInfo)ctl.Properties.GetObject(PropLayoutInfo);

                int left = layout.Left + displayRect.X;
                int top = layout.Top + displayRect.Y;
                int right = layout.Right + displayRect.X;
                int bottom = layout.Bottom + displayRect.Y;

                Debug.WriteLineIf(CompModSwitches.RichLayout.TraceInfo, "\t\t...anchor dim (l,t,r,b) {"
                                  + (left)
                                  + ", " + (top)
                                  + ", " + (right)
                                  + ", " + (bottom)
                                  + "}");

                AnchorStyles mode = layout.Anchor;

                if ((mode & AnchorStyles.Right) == AnchorStyles.Right) {
                    Debug.WriteLineIf(CompModSwitches.RichLayout.TraceInfo, "\t\t...adjusting right");
                    right += displayRect.Width;

                    if ((mode & AnchorStyles.Left) != AnchorStyles.Left) {
                        Debug.WriteLineIf(CompModSwitches.RichLayout.TraceInfo, "\t\t...adjusting left");
                        left += displayRect.Width;
                    }
                }
                else if ((mode & AnchorStyles.Left) != AnchorStyles.Left) {
                    Debug.WriteLineIf(CompModSwitches.RichLayout.TraceInfo, "\t\t...adjusting left & right");
                    right += (displayRect.Width / 2);
                    left += (displayRect.Width / 2);
                }

                if ((mode & AnchorStyles.Bottom) == AnchorStyles.Bottom) {
                    Debug.WriteLineIf(CompModSwitches.RichLayout.TraceInfo, "\t\t...adjusting bottom");
                    bottom += displayRect.Height;

                    if ((mode & AnchorStyles.Top) != AnchorStyles.Top) {
                        Debug.WriteLineIf(CompModSwitches.RichLayout.TraceInfo, "\t\t...adjusting top");
                        top += displayRect.Height;
                    }
                }
                else if ((mode & AnchorStyles.Top) != AnchorStyles.Top) {
                    Debug.WriteLineIf(CompModSwitches.RichLayout.TraceInfo, "\t\t...adjusting top & bottom");
                    bottom += (displayRect.Height/2);
                    top += (displayRect.Height/2);
                }

                if (right < left) right = left;
                if (bottom < top) bottom = top;

                Debug.WriteLineIf(CompModSwitches.RichLayout.TraceInfo, "\t\t...new anchor dim (l,t,r,b) {"
                                                                          + (left)
                                                                          + ", " + (top)
                                                                          + ", " + (right)
                                                                          + ", " + (bottom)
                                                                          + "}");
                ctl.SetBoundsCore(left, top, right - left, bottom - top, BoundsSpecified.None);
            }

            private static void LayoutAnchoredControls(Control container, LayoutEventArgs levent) {
                Debug.WriteLineIf(CompModSwitches.RichLayout.TraceInfo, "\tAnchor Processing");
                Rectangle displayRect = container.DisplayRectangle;
                Debug.WriteLineIf(CompModSwitches.RichLayout.TraceInfo, "\t\tdisplayRect: " + displayRect.ToString());

                int count = container.Controls.Count;

                for (int i = 0; i < count; i++) {
                    Control ctl = (Control)container.Controls[i];
                    Debug.Assert(ctl != null, "Why is Control.Controls returning null elements?");
                    Debug.Assert(ctl.ParentInternal != null, "control.Controls[i].Parent == null?  If it doesn't have a parent, why is it in the Controls collection?");

                    LayoutInfo layout = (LayoutInfo)ctl.Properties.GetObject(PropLayoutInfo);

                    if (layout != null && !layout.IsDock) {
                        AnchorControl(ctl, displayRect);
                    }
                }
            }

            private static void LayoutDockedControls(Control container, LayoutEventArgs levent) {
                Debug.WriteLineIf(CompModSwitches.RichLayout.TraceInfo, "\tDock Processing");

                // Docking layout is order dependent.
                // After much debate, we decided to use z-order as the docking order.  (Introducing a DockOrder
                // property was a close second)
                // Array.Sort(ctls, 0, dockCount, LayoutComparer.INSTANCE); // array is already in z-order

                Rectangle displayRect = container.DisplayRectangle;

                // The "docking edges".  Starts off as the parent's edges,
                // and shrinks as controls are laid out.
                int left = displayRect.X;
                int top = displayRect.Y;
                int right = displayRect.X + displayRect.Width;
                int bottom = displayRect.Y + displayRect.Height;

                int count = container.Controls.Count;

                Control mdiClient = null;

                // Dock controls in reverse Z-order
                for (int i = count - 1; i >= 0; i--) {
                    Control ctl = (Control)container.Controls[i];
                    
                    LayoutInfo layout = (LayoutInfo)ctl.Properties.GetObject(PropLayoutInfo);
                    
                    if (layout != null && layout.IsDock && ctl.GetState(STATE_VISIBLE)) {
                        int width = ctl.Width;
                        int height = ctl.Height;
                        switch (layout.Dock) {
                            case DockStyle.Top:
                                ctl.SetBoundsCore(left, top, right - left, height, BoundsSpecified.None);
                                top += ctl.Bounds.Height;
                                break;
                            case DockStyle.Bottom:
                                bottom -= height;
                                ctl.SetBoundsCore(left, bottom, right - left, height, BoundsSpecified.None);
                                break;
                            case DockStyle.Left:
                                ctl.SetBoundsCore(left, top, width, bottom - top, BoundsSpecified.None);
                                left += ctl.Bounds.Width;
                                break;
                            case DockStyle.Right:
                                right -= width;
                                ctl.SetBoundsCore(right, top, width, bottom - top, BoundsSpecified.None);
                                break;
                            case DockStyle.Fill:
                                if (ctl is MdiClient) {
                                    mdiClient = ctl;
                                }
                                else {
                                    ctl.SetBoundsCore(left, top, right - left, bottom - top, BoundsSpecified.None);
                                }
                                break;
                            default:
                                Debug.Fail("Unexpected dock mode.");
                                break;
                        }
                    }
                }

                // Treat the MDI client specially, since it's supposed to blend in with the parent form
                if (mdiClient != null) {
                    mdiClient.SetBoundsCore(left, top, right - left, bottom - top, BoundsSpecified.None);
                }
            }

            // Core layout logic, called by Control.OnLayout.
            public static void OnLayout(Control container, LayoutEventArgs levent) {
                Debug.WriteLineIf(CompModSwitches.RichLayout.TraceInfo, 
                                  string.Format("{1}(hwnd=0x{0:X}).OnLayout", 
                                                (container.IsHandleCreated ? container.Handle : IntPtr.Zero), 
                                                container.GetType().FullName));

                bool dock = false;
                bool anchor = false;
                int count = 0;
                
                ControlCollection controls = (ControlCollection)container.Properties.GetObject(PropControlsCollection);
                if (controls != null) {
                    count = controls.Count;
                }
                
                for (int i = 0; i < count; i++) {
                    Control ctl = controls[i];
                    Control child = (Control)ctl;
                    
                    LayoutInfo layout = (LayoutInfo)child.Properties.GetObject(PropLayoutInfo);
                    
                    if (!dock && layout != null && layout.IsDock) dock = true;
                    if (!anchor && layout != null && !layout.IsDock) anchor = true;
                    if (anchor && dock) break;
                }

                Debug.WriteLineIf(CompModSwitches.RichLayout.TraceInfo, "\tanchor : " + anchor.ToString());
                Debug.WriteLineIf(CompModSwitches.RichLayout.TraceInfo, "\tdock :   " + dock.ToString());

                if (dock)   LayoutDockedControls(container, levent);
                if (anchor) LayoutAnchoredControls(container, levent);
            }

            /// <devdoc>
            ///     Updates the Anchor information based on the controls current bounds.
            ///     This should only be called when the parent control changes or the
            ///     anchor mode changes.
            /// </devdoc>
            public static void UpdateAnchorInfo(Control control) {

                LayoutInfo layout = (LayoutInfo)control.Properties.GetObject(PropLayoutInfo);
                Debug.WriteLineIf(CompModSwitches.RichLayout.TraceInfo, "Update anchor info");
                Debug.Indent();
                Debug.WriteLineIf(CompModSwitches.RichLayout.TraceInfo, control.ParentInternal == null ? "No parent" : "Parent");

                if (layout != null && !layout.IsDock && control.ParentInternal != null) {
                    
                    layout.Left = control.Left;
                    layout.Top = control.Top;
                    layout.Right = control.Left + control.Width;
                    layout.Bottom = control.Top + control.Height;

                    Rectangle parentDisplayRect = control.ParentInternal.DisplayRectangle;
                    Debug.WriteLineIf(CompModSwitches.RichLayout.TraceInfo, "Parent displayRectangle" + parentDisplayRect);
                    int parentWidth = parentDisplayRect.Width;
                    int parentHeight = parentDisplayRect.Height;

                    // VS#46140
                    // The anchor is relative to the parent DisplayRectangle, so offset the anchor
                    // by the DisplayRect origin
                    layout.Left -= parentDisplayRect.X;
                    layout.Top -= parentDisplayRect.Y;
                    layout.Right -= parentDisplayRect.X;
                    layout.Bottom -= parentDisplayRect.Y;

                    // V7#79 : ChrisAn, 7/13/1999 - When we are parented to a ScrollableControl
                    //       : we check to see if it has the AutoScrollMinSize. If it does, we
                    //       : treat that as the minimum size to be anchored to also.
                    //
                    if (control.ParentInternal is ScrollableControl) {
                        Size size = ((ScrollableControl)control.ParentInternal).AutoScrollMinSize;
                        if (size.Width != 0 && size.Height != 0) {
                            parentWidth = Math.Max(parentWidth, size.Width);
                            parentHeight = Math.Max(parentHeight, size.Height);
                        }
                    }

                    AnchorStyles mode = layout.Anchor;

                    if ((mode & AnchorStyles.Right) == AnchorStyles.Right) {
                        layout.Right -= parentWidth;

                        if ((mode & AnchorStyles.Left) != AnchorStyles.Left) {
                            layout.Left -= parentWidth;
                        }
                    }
                    else if ((mode & AnchorStyles.Left) != AnchorStyles.Left) {
                        layout.Right -= (parentWidth/2);
                        layout.Left -= (parentWidth/2);
                    }

                    if ((mode & AnchorStyles.Bottom) == AnchorStyles.Bottom) {
                        layout.Bottom -= parentHeight;

                        if ((mode & AnchorStyles.Top) != AnchorStyles.Top) {
                            layout.Top -= parentHeight;
                        }
                    }
                    else if ((mode & AnchorStyles.Top) != AnchorStyles.Top) {
                        layout.Bottom -= (parentHeight/2);
                        layout.Top -= (parentHeight/2);
                    }
                    Debug.WriteLineIf(CompModSwitches.RichLayout.TraceInfo, "anchor info (l,t,r,b): (" + layout.Left + ", " + layout.Top  + ", " + layout.Right  + ", " + layout.Bottom + ")");
                }
                Debug.Unindent();
            }
        }

        private class ControlVersionInfo {
            private string companyName = null;
            private string productName = null;
            private string productVersion = null;
            private FileVersionInfo versionInfo = null;
            private Control owner;

            public ControlVersionInfo(Control owner) {
                this.owner = owner;
            }

            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ControlVersionInfo.CompanyName"]/*' />
            /// <devdoc>
            ///     The company name associated with the component.
            /// </devdoc>
            public string CompanyName {
                get {
                    if (companyName == null) {
                        object[] attrs = owner.GetType().Module.Assembly.GetCustomAttributes(typeof(AssemblyCompanyAttribute), false);
                        if (attrs != null && attrs.Length > 0) {
                            companyName = ((AssemblyCompanyAttribute)attrs[0]).Company;
                        }

                        if (companyName == null || companyName.Length == 0) {
                            companyName = GetFileVersionInfo().CompanyName;
                            if (companyName != null) {
                                companyName = companyName.Trim();
                            }
                        }

                        if (companyName == null || companyName.Length == 0) {
                            string ns = owner.GetType().Namespace;
                            int firstDot = ns.IndexOf("/");
                            if (firstDot != -1) {
                                companyName = ns.Substring(0, firstDot);
                            }
                            else {
                                companyName = ns;
                            }
                        }
                    }
                    return companyName;
                }
            }


            /// <include file='doc\Control.uex' path='docs/doc[@for="Control.ControlVersionInfo.ProductName"]/*' />
            /// <devdoc>
            ///     The product name associated with this component.
            /// </devdoc>
            public string ProductName {
                get {
                    if (productName == null) {
                        object[] attrs = owner.GetType().Module.Assembly.GetCustomAttributes(typeof(AssemblyProductAttribute), false);
                        if (attrs != null && attrs.Length > 0) {
                            productName = ((AssemblyProductAttribute)attrs[0]).Product;
                        }

                        if (productName == null || productName.Length == 0) {
                            productName = GetFileVersionInfo().ProductName;
                            if (productName != null) {
                                productName = productName.Trim();
                            }
                        }

                        if (productName == null || productName.Length == 0) {
                            string ns = owner.GetType().Namespace;
                            int firstDot = ns.IndexOf(".");
                            if (firstDot != -1) {
                                productName = ns.Substring(firstDot+1);
                            }
                            else {
                                productName = ns;
                            }
                        }
                    }

                    return productName;
                }
            }


            /// <devdoc>
            ///     The product version associated with this component.
            /// </devdoc>
            public string ProductVersion {
                get {
                    if (productVersion == null) {
                        // custom attribute
                        //
                        object[] attrs = owner.GetType().Module.Assembly.GetCustomAttributes(typeof(AssemblyInformationalVersionAttribute), false);
                        if (attrs != null && attrs.Length > 0) {
                            productVersion = ((AssemblyInformationalVersionAttribute)attrs[0]).InformationalVersion;
                        }

                        // win32 version info
                        //
                        if (productVersion == null || productVersion.Length == 0) {
                            productVersion = GetFileVersionInfo().ProductVersion;
                            if (productVersion != null) {
                                productVersion = productVersion.Trim();
                            }
                        }

                        // fake it
                        //
                        if (productVersion.Length == 0) {
                            productVersion = "1.0.0.0";
                        }
                    }
                    return productVersion;
                }
            }


            /// <devdoc>
            ///     Retrieves the FileVersionInfo associated with the main module for
            ///     the component.
            /// </devdoc>
            private FileVersionInfo GetFileVersionInfo() {
                if (versionInfo == null) {
                    string path;
                    
                    FileIOPermission fiop = new FileIOPermission( PermissionState.None );
                    fiop.AllFiles = FileIOPermissionAccess.PathDiscovery;
                    fiop.Assert();
                    try {
                        path = owner.GetType().Module.FullyQualifiedName;
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                    
                    new FileIOPermission(FileIOPermissionAccess.Read, path).Assert();
                    try {
                        versionInfo = FileVersionInfo.GetVersionInfo(path);
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                }

                return versionInfo;

            }

        }

        private delegate void IPropertyNotifySinkEventHandler(int dispid);

    } // end class Control
    
} // end namespace System.Windows.Forms
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\day.cs ===
//------------------------------------------------------------------------------
// <copyright file="Day.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Drawing;
    using System.ComponentModel;
    using Microsoft.Win32;


    /// <include file='doc\Day.uex' path='docs/doc[@for="Day"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the day of the week.
    ///
    ///    </para>
    /// </devdoc>
    public enum Day {
        /// <include file='doc\Day.uex' path='docs/doc[@for="Day.Monday"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The day Monday.
        ///    </para>
        /// </devdoc>
        Monday = 0,
        /// <include file='doc\Day.uex' path='docs/doc[@for="Day.Tuesday"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The day Tuesday.
        ///    </para>
        /// </devdoc>
        Tuesday = 1,
        /// <include file='doc\Day.uex' path='docs/doc[@for="Day.Wednesday"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The day Wednesday.
        ///    </para>
        /// </devdoc>
        Wednesday = 2,
        /// <include file='doc\Day.uex' path='docs/doc[@for="Day.Thursday"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The day Thursday.
        ///    </para>
        /// </devdoc>
        Thursday = 3,
        /// <include file='doc\Day.uex' path='docs/doc[@for="Day.Friday"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The day Friday.
        ///    </para>
        /// </devdoc>
        Friday = 4,
        /// <include file='doc\Day.uex' path='docs/doc[@for="Day.Saturday"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The day Saturday.
        ///    </para>
        /// </devdoc>
        Saturday  = 5,
        /// <include file='doc\Day.uex' path='docs/doc[@for="Day.Sunday"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The day Sunday.
        ///    </para>
        /// </devdoc>
        Sunday = 6,
        /// <include file='doc\Day.uex' path='docs/doc[@for="Day.Default"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A default day of the week specified by the application.
        ///    </para>
        /// </devdoc>
        Default = 7,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\datetimepickerformats.cs ===
//------------------------------------------------------------------------------
// <copyright file="DateTimePickerFormats.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;

    /// <include file='doc\DateTimePickerFormats.uex' path='docs/doc[@for="DateTimePickerFormat"]/*' />
    /// <devdoc>
    ///      Constants that specify how the date and time picker control displays
    ///      date and time information.
    /// </devdoc>
    public enum DateTimePickerFormat {

        /// <include file='doc\DateTimePickerFormats.uex' path='docs/doc[@for="DateTimePickerFormat.Long"]/*' />
        /// <devdoc>
        ///     Long format - produces output in the form "Wednesday, April 7, 1999"
        /// </devdoc>
        Long    = 0x0001,

        /// <include file='doc\DateTimePickerFormats.uex' path='docs/doc[@for="DateTimePickerFormat.Short"]/*' />
        /// <devdoc>
        ///     Short format - produces output in the form "4/7/99"
        /// </devdoc>
        Short   = 0x0002,

        /// <include file='doc\DateTimePickerFormats.uex' path='docs/doc[@for="DateTimePickerFormat.Time"]/*' />
        /// <devdoc>
        ///     Time format - produces output in time format
        /// </devdoc>
        Time    = 0x0004,

        /// <include file='doc\DateTimePickerFormats.uex' path='docs/doc[@for="DateTimePickerFormat.Custom"]/*' />
        /// <devdoc>
        ///     Custom format - produces output in custom format.
        /// </devdoc>
        Custom  = 0x0008,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\datetimepicker.cs ===
//------------------------------------------------------------------------------
// <copyright file="DateTimePicker.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;

    using System.Diagnostics;

    using System;
    using System.Security.Permissions;
    
    using System.Drawing;
    using System.Windows.Forms;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    
    using Microsoft.Win32;

    /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker"]/*' />
    /// <devdoc>
    ///     Date/DateTime picker control
    /// </devdoc>
    [
    DefaultProperty("Value"),
    DefaultEvent("ValueChanged"),
    Designer("System.Windows.Forms.Design.DateTimePickerDesigner, " + AssemblyRef.SystemDesign)
    ]
    public class DateTimePicker : Control {
        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.DefaultTitleBackColor"]/*' />
        /// <devdoc>
        ///    <para>Specifies the default title back color. This field is read-only.</para>
        /// </devdoc>
        protected static readonly Color DefaultTitleBackColor = SystemColors.ActiveCaption;
        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.DefaultTitleForeColor"]/*' />
        /// <devdoc>
        ///    <para>Specifies the default foreground color. This field is read-only.</para>
        /// </devdoc>
        protected static readonly Color DefaultTitleForeColor = SystemColors.ActiveCaptionText;
        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.DefaultMonthBackColor"]/*' />
        /// <devdoc>
        ///    <para>Specifies the default month background color. This field is read-only.</para>
        /// </devdoc>
        protected static readonly Color DefaultMonthBackColor = SystemColors.Window;
        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.DefaultTrailingForeColor"]/*' />
        /// <devdoc>
        ///    <para>Specifies the default trailing forground color. This field is read-only.</para>
        /// </devdoc>
        protected static readonly Color DefaultTrailingForeColor = SystemColors.GrayText;

        private static readonly object EVENT_FORMATCHANGED = new object();                                     
                                     
        private const int TIMEFORMAT_NOUPDOWN = NativeMethods.DTS_TIMEFORMAT & (~NativeMethods.DTS_UPDOWN);
        private EventHandler                    onCloseUp;
        private EventHandler                    onDropDown;
        private EventHandler                    onValueChanged;
        
        // We need to restrict the available dates because of limitations in the comctl
        // DateTime and MonthCalendar controls
        //
        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.MinDateTime"]/*' />
        /// <devdoc>
        ///    <para>Specifies the mimimum date value. This field is read-only.</para>
        /// </devdoc>
        public static readonly DateTime MinDateTime = new DateTime(1753, 1, 1);
        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.MaxDateTime"]/*' />
        /// <devdoc>
        ///    <para>Specifies the maximum date value. This field is read-only.</para>
        /// </devdoc>
        public static readonly DateTime MaxDateTime = new DateTime(9998, 12, 31);

        private int                             style;
        private short                           prefHeightCache = -1;

        /// <devdoc>
        ///     validTime determines whether the CheckBox in the DTP is checked.  The CheckBox is only
        ///     displayed when ShowCheckBox is true.
        /// </devdoc>
        /// <internalonly/>
        private bool                            validTime = true;

        // DateTime changeover: DateTime is a value class, not an object, so we need to keep track
        // of whether or not its values have been initialised in a separate boolean.
        private bool                            userHasSetValue = false;
        private DateTime                        value = DateTime.Now;
        private DateTime                        max = MaxDateTime;
        private DateTime                        min = MinDateTime;
        private Color                           calendarForeColor = DefaultForeColor;
        private Color                           calendarTitleBackColor = DefaultTitleBackColor;
        private Color                           calendarTitleForeColor = DefaultTitleForeColor;
        private Color                           calendarMonthBackground = DefaultMonthBackColor;
        private Color                           calendarTrailingText = DefaultTrailingForeColor;
        private Font                            calendarFont = null;
        private FontHandleWrapper               calendarFontHandleWrapper = null;

        // Since there is no way to get the customFormat from the DTP, we need to
        // cache it. Also we have to track if the user wanted customFormat or
        // shortDate format (shortDate is the lack of being in Long or DateTime format
        // without a customFormat). What fun!
        //
        private string                          customFormat;
        
        private DateTimePickerFormat           format;

        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.DateTimePicker"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Windows.Forms.DateTimePicker'/> class.</para>
        /// </devdoc>
        public DateTimePicker()
        : base() {
            SetStyle(ControlStyles.FixedHeight, true);
            
            // Since DateTimePicker does its own mouse capturing, we do not want
            // to receive standard click events, or we end up with mismatched mouse
            // button up and button down messages.
            //
            SetStyle(ControlStyles.UserPaint |
                     ControlStyles.StandardClick, false);

            // Set default flags here...
            //
            format = DateTimePickerFormat.Long;
            
            SystemEvents.UserPreferenceChanged += new UserPreferenceChangedEventHandler(this.UserPreferenceChanged);
        }

        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.BackColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Color BackColor {
            get {
                if (ShouldSerializeBackColor()) {
                    return base.BackColor;
                }
                else {
                    return SystemColors.Window;
                }
            }
            set {
                base.BackColor = value;
            }
        }

        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.BackColorChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler BackColorChanged {
            add {
                base.BackColorChanged += value;
            }
            remove {
                base.BackColorChanged -= value;
            }
        }

        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.BackgroundImage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Image BackgroundImage {
            get {
                return base.BackgroundImage;
            }
            set {
                base.BackgroundImage = value;
            }
        }

        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.BackgroundImageChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler BackgroundImageChanged {
            add {
                base.BackgroundImageChanged += value;
            }
            remove {
                base.BackgroundImageChanged -= value;
            }
        }

        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.CalendarForeColor"]/*' />
        /// <devdoc>
        ///     The current value of the CalendarForeColor property.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        SRDescription(SR.DateTimePickerCalendarForeColorDescr)
        ]
        public Color CalendarForeColor {
            get {
                return calendarForeColor;
            }

            set {
                if (value.IsEmpty) {
                    throw new ArgumentException(SR.GetString(SR.InvalidNullArgument,
                                                              "value"));
                }
                if (!value.Equals(calendarForeColor)) {
                    calendarForeColor = value;
                    SetControlColor(NativeMethods.MCSC_TEXT, value);
                }
            }
        }

        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.CalendarFont"]/*' />
        /// <devdoc>
        ///     The current value of the CalendarFont property.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        Localizable(true),
        AmbientValue(null),
        SRDescription(SR.DateTimePickerCalendarFontDescr)
        ]
        public Font CalendarFont {
            get {
                if (calendarFont == null) {
                    return Font;
                }
                return calendarFont;
            }

            set {
                if ((value == null && calendarFont != null) || (value != null && !value.Equals(calendarFont))) {
                    calendarFont = value;
                    calendarFontHandleWrapper = null;
                    SetControlCalendarFont();
                }
            }
        }

        private IntPtr CalendarFontHandle {
            get {
                if (calendarFont == null) {
                    Debug.Assert(calendarFontHandleWrapper == null, "font handle out of sync with Font");
                    return FontHandle;
                }

                if (calendarFontHandleWrapper == null) {
                    calendarFontHandleWrapper = new FontHandleWrapper(CalendarFont);
                }

                return calendarFontHandleWrapper.Handle;
            }
        }

        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.CalendarTitleBackColor"]/*' />
        /// <devdoc>
        ///     The current value of the CalendarTitleBackColor property.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        SRDescription(SR.DateTimePickerCalendarTitleBackColorDescr)
        ]
        public Color CalendarTitleBackColor {
            get {
                return calendarTitleBackColor;
            }

            set {
                if (value.IsEmpty) {
                    throw new ArgumentException(SR.GetString(SR.InvalidNullArgument,
                                                              "value"));
                }
                if (!value.Equals(calendarTitleBackColor)) {
                    calendarTitleBackColor = value;
                    SetControlColor(NativeMethods.MCSC_TITLEBK, value);
                }
            }
        }

        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.CalendarTitleForeColor"]/*' />
        /// <devdoc>
        ///     The current value of the CalendarTitleForeColor property.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        SRDescription(SR.DateTimePickerCalendarTitleForeColorDescr)
        ]
        public Color CalendarTitleForeColor {
            get {
                return calendarTitleForeColor;
            }

            set {
                if (value.IsEmpty) {
                    throw new ArgumentException(SR.GetString(SR.InvalidNullArgument,
                                                              "value"));
                }
                if (!value.Equals(calendarTitleForeColor)) {
                    calendarTitleForeColor = value;
                    SetControlColor(NativeMethods.MCSC_TITLETEXT, value);
                }
            }
        }

        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.CalendarTrailingForeColor"]/*' />
        /// <devdoc>
        ///     The current value of the CalendarTrailingForeColor property.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        SRDescription(SR.DateTimePickerCalendarTrailingForeColorDescr)
        ]
        public Color CalendarTrailingForeColor {
            get {
                return calendarTrailingText;
            }

            set {
                if (value.IsEmpty) {
                    throw new ArgumentException(SR.GetString(SR.InvalidNullArgument,
                                                              "value"));
                }
                if (!value.Equals(calendarTrailingText)) {
                    calendarTrailingText = value;
                    SetControlColor(NativeMethods.MCSC_TRAILINGTEXT, value);
                }
            }
        }

        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.CalendarMonthBackground"]/*' />
        /// <devdoc>
        ///     The current value of the CalendarMonthBackground property.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        SRDescription(SR.DateTimePickerCalendarMonthBackgroundDescr)
        ]
        public Color CalendarMonthBackground {
            get {
                return calendarMonthBackground;
            }

            set {
                if (value.IsEmpty) {
                    throw new ArgumentException(SR.GetString(SR.InvalidNullArgument,
                                                              "value"));
                }
                if (!value.Equals(calendarMonthBackground)) {
                    calendarMonthBackground = value;
                    SetControlColor(NativeMethods.MCSC_MONTHBK, value);
                }
            }
        }

        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.Checked"]/*' />
        /// <devdoc>
        /// <para>Indicates whether the <see cref='System.Windows.Forms.DateTimePicker.Value'/> property has been set.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(true),
        Bindable(true),
        SRDescription(SR.DateTimePickerCheckedDescr)
        ]
        public bool Checked {
            get {
                return validTime;
            }
            set {
                if (validTime != value) {
                    validTime = value;

                    if (validTime) {
                        int gdt = NativeMethods.GDT_VALID;
                        NativeMethods.SYSTEMTIME sys = DateTimePicker.DateTimeToSysTime(Value);
                        UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.DTM_SETSYSTEMTIME, gdt, sys);
                    }
                    else {
                        int gdt = NativeMethods.GDT_NONE;
                        NativeMethods.SYSTEMTIME sys = null;
                        UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.DTM_SETSYSTEMTIME, gdt, sys);
                    }
                }
            }
        }
        
        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.CreateParams"]/*' />
        /// <devdoc>
        ///     Returns the CreateParams used to create this window.
        /// </devdoc>
        protected override CreateParams CreateParams {
            [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
            get {
                CreateParams cp = base.CreateParams;
                cp.ClassName = NativeMethods.WC_DATETIMEPICK;
                
                cp.Style |= style; 
                 
                switch (format) {                            
                    case DateTimePickerFormat.Long:
                        cp.Style |= NativeMethods.DTS_LONGDATEFORMAT;
                        break;
                    case DateTimePickerFormat.Short:
                        break;
                    case DateTimePickerFormat.Time:
                        cp.Style |= TIMEFORMAT_NOUPDOWN;
                        break;
                    case DateTimePickerFormat.Custom:
                        break;
                }
                
                cp.ExStyle |= NativeMethods.WS_EX_CLIENTEDGE;
                return cp;
            }
        }

        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.CustomFormat"]/*' />
        /// <devdoc>
        ///     Returns the custom format.
        /// </devdoc>
        [
        DefaultValue(null),
        SRCategory(SR.CatBehavior),
        RefreshProperties(RefreshProperties.Repaint),
        SRDescription(SR.DateTimePickerCustomFormatDescr)
        ]
        public string CustomFormat {
            get { 
                return customFormat;
            }

            set {
                if ((value != null && !value.Equals(customFormat)) ||
                    (value == null && customFormat != null)) {
                    
                    customFormat = value;
                    
                    if (IsHandleCreated) {
                        if (format == DateTimePickerFormat.Custom)
                            SendMessage(NativeMethods.DTM_SETFORMAT, 0, customFormat);
                    }
                }
            }
        }

        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.DefaultSize"]/*' />
        /// <devdoc>
        ///     Deriving classes can override this to configure a default size for their control.
        ///     This is more efficient than setting the size in the control's constructor.
        /// </devdoc>
        protected override Size DefaultSize {
            get {
                return new Size(200, PreferredHeight);
            }
        }

        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.DropDownAlign"]/*' />
        /// <devdoc>
        ///     The current value of the dropDownAlign property.  The calendar
        ///     dropDown can be aligned to the left or right of the control.
        /// </devdoc>
        [
        DefaultValue(LeftRightAlignment.Left),
        SRCategory(SR.CatAppearance),
        Localizable(true),
        SRDescription(SR.DateTimePickerDropDownAlignDescr)
        ]
        public LeftRightAlignment DropDownAlign {
            get {
                return((style & NativeMethods.DTS_RIGHTALIGN) != 0)
                ? LeftRightAlignment.Right
                : LeftRightAlignment.Left;
            }

            set {
                if (!Enum.IsDefined(typeof(LeftRightAlignment), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(LeftRightAlignment));
                }

                SetStyleBit((value == LeftRightAlignment.Right), NativeMethods.DTS_RIGHTALIGN);
            }
        }

        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.ForeColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Color ForeColor {
            get {
                if (ShouldSerializeForeColor()) {
                    return base.ForeColor;
                }
                else {
                    return SystemColors.WindowText;
                }
            }
            set {
                base.ForeColor = value;
            }
        }

        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.ForeColorChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler ForeColorChanged {
            add {
                base.ForeColorChanged += value;
            }
            remove {
                base.ForeColorChanged -= value;
            }
        }

        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.Format"]/*' />
        /// <devdoc>
        ///     Returns the current value of the format property. This determines the
        ///     style of format the date is displayed in.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        RefreshProperties(RefreshProperties.Repaint),
        SRDescription(SR.DateTimePickerFormatDescr)
        ]
        public DateTimePickerFormat Format {
            get {
                return format;
            }

            set {
                if (!Enum.IsDefined(typeof(DateTimePickerFormat), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(DateTimePickerFormat));
                }
                                                        
                if (format != value) {
                
                    format = value;
                    RecreateHandle();
                    
                    OnFormatChanged(EventArgs.Empty);
                }
            }
        }
        
        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.FormatChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.DateTimePickerOnFormatChangedDescr)]
        public event EventHandler FormatChanged {
            add {
                Events.AddHandler(EVENT_FORMATCHANGED, value);
            }
            remove {
                Events.RemoveHandler(EVENT_FORMATCHANGED, value);
            }
        }

        /// <include file='doc\DateTimepicker.uex' path='docs/doc[@for="DateTimepicker.OnPaint"]/*' />
        /// <devdoc>
        ///     DateTimePicker Onpaint.
        /// </devdoc>
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event PaintEventHandler Paint {
            add {
                base.Paint += value;
            }
            remove {
                base.Paint -= value;
            }
        }

        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.MaxDate"]/*' />
        /// <devdoc>
        ///    <para> Indicates the maximum date and time
        ///       selectable in the control.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        SRDescription(SR.DateTimePickerMaxDateDescr)
        ]
        public DateTime MaxDate {
            get {
                return max;
            }
            set {
                if (DateTime.Compare(value, max) != 0) {
                    if (DateTime.Compare(value, min) == -1) {
                        throw new ArgumentException(SR.GetString(SR.InvalidLowBoundArgumentEx, "MaxDate", FormatDateTime(value), "MinDate"));
                    }

                    // If trying to set the maximum greater than MaxDateTime, set
                    // it to MaxDateTime.
                    if (DateTime.Compare(value, MaxDateTime) == 1) {
                        throw new ArgumentException(SR.GetString(SR.DateTimePickerMaxDate, FormatDateTime(DateTimePicker.MaxDateTime)), "value");
                    }

                    max = value;
                    SetRange();

                    //If Value (which was once valid) is suddenly greater than the max (since we just set it)
                    //then adjust this...
                    if (DateTime.Compare(max, Value) == -1) {
                        Value = max;
                    }
                }
            }
        }

        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.MinDate"]/*' />
        /// <devdoc>
        ///    <para> Indicates the minimum date and time
        ///       selectable in the control.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        SRDescription(SR.DateTimePickerMinDateDescr)
        ]
        public DateTime MinDate {
            get {
                return min;
            }
            set {
                if (DateTime.Compare(value, min) != 0) {
                    if (DateTime.Compare(value, max) != -1) {
                        throw new ArgumentException(SR.GetString(SR.InvalidHighBoundArgument, "MinDate", FormatDateTime(value), "MaxDate"));
                    }

                    // If trying to set the minimum less than MinDateTime, set
                    // it to MinDateTime.
                    if (DateTime.Compare(value, MinDateTime) == -1) {
                        throw new ArgumentException(SR.GetString(SR.DateTimePickerMinDate, FormatDateTime(DateTimePicker.MinDateTime)), "value");
                    }

                    min = value;
                    SetRange();

                    //If Value (which was once valid) is suddenly less than the min (since we just set it)
                    //then adjust this...
                    if (DateTime.Compare(min, Value) == 1) {
                        Value = min;
                    }

                }
            }
        }
        
        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.PreferredHeight"]/*' />
        /// <devdoc>
        ///    <para>Indicates the preferred height of the DateTimePicker control. This property is read-only.</para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public int PreferredHeight {
            get {
                if (prefHeightCache > -1)
                    return(int)prefHeightCache;

                // Base the preferred height on the current font
                int height = FontHeight;

                // Adjust for the border
                height += SystemInformation.BorderSize.Height * 4 + 3;
                prefHeightCache = (short)height;

                return height;
            }
        }
        
        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.ShowCheckBox"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Indicates whether a check box is displayed to toggle the NoValueSelected property
        ///       value.</para>
        /// </devdoc>
        [
        DefaultValue(false),
        SRCategory(SR.CatAppearance),
        SRDescription(SR.DateTimePickerShowNoneDescr)
        ]
        public bool ShowCheckBox {
            get {
                return(style & NativeMethods.DTS_SHOWNONE) != 0;
            }
            set {
                SetStyleBit(value, NativeMethods.DTS_SHOWNONE);
            }
        }

        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.ShowUpDown"]/*' />
        /// <devdoc>
        ///    <para> Indicates
        ///       whether an up-down control is used to adjust the time values.</para>
        /// </devdoc>
        [
        DefaultValue(false),
        SRCategory(SR.CatAppearance),
        SRDescription(SR.DateTimePickerShowUpDownDescr)
        ]
        public bool ShowUpDown {
            get {
                return(style & NativeMethods.DTS_UPDOWN) != 0;
            }
            set {
                if (ShowUpDown != value) {
                    SetStyleBit(value, NativeMethods.DTS_UPDOWN);
                }
            }
        }

        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.Text"]/*' />
        /// <devdoc>
        ///     Overrides Text to allow for setting of the value via a string.  Also, returns
        ///     a formatted Value when getting the text.  The DateTime class will throw
        ///     an exception if the string (value) being passed in is invalid.
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public override string Text {
            get {
                return base.Text;
            }
            set {
                // Clause to check length
                //
                if (value == null || value.Length == 0) {
                    ResetValue();
                }
                else {
                    Value = DateTime.Parse(value);
                }
            }
        }

        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.TextChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced)]
        new public event EventHandler TextChanged {
            add {
                base.TextChanged += value;
            }
            remove {
                base.TextChanged -= value;
            }
        }
        
        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.Value"]/*' />
        /// <devdoc>
        ///    <para>Indicates the DateTime value assigned to the control.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        Bindable(true),
        RefreshProperties(RefreshProperties.All),
        SRDescription(SR.DateTimePickerValueDescr)
        ]
        public DateTime Value {
            get {
                //checkbox clicked, no value set - no value set state should never occur, but just in case
                if (!userHasSetValue && validTime)
                    return DateTime.Now;
                else
                    return value;
            }
            set {
                bool valueChanged = !DateTime.Equals(this.Value, value);
                // Check for value set here; if we've not set the value yet, it'll be Now, so the second
                // part of the test will fail.
                // So, if userHasSetValue isn't set, we don't care if the value is still the same - and we'll
                // update anyway.
                if (!userHasSetValue || valueChanged) {
                    if ((value < min) || (value > max)) {
                        throw new ArgumentException(SR.GetString(SR.InvalidBoundArgument,
                                                                  "Value", FormatDateTime(value),
                                                                  "'MinDate'", "'MaxDate'"));
                    }
                    
                    string oldText = this.Text;
                    
                    this.value = value;
                    userHasSetValue = true;

                    if (IsHandleCreated) {
                        /*
                        * Make sure any changes to this code
                        * get propagated to createHandle
                        */
                        int gdt = NativeMethods.GDT_VALID;
                        NativeMethods.SYSTEMTIME sys = DateTimePicker.DateTimeToSysTime(value);
                        UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.DTM_SETSYSTEMTIME, gdt, sys);
                    }
                    
                    if (valueChanged) {
                        OnValueChanged(EventArgs.Empty);
                    }
                    
                    if (!oldText.Equals(this.Text)) {
                        OnTextChanged(EventArgs.Empty);
                    }
                }
            }
        }
        
        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.CloseUp"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the dropdown calendar is dismissed and disappears.</para>
        /// </devdoc>
        [SRCategory(SR.CatAction), SRDescription(SR.DateTimePickerOnCloseUpDescr)]
        public event EventHandler CloseUp {
            add {
                onCloseUp += value;
            }
            remove {
                onCloseUp -= value;
            }
        }


        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.ValueChanged"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the value for the control changes.</para>
        /// </devdoc>
        [SRCategory(SR.CatAction), SRDescription(SR.valueChangedEventDescr)]
        public event EventHandler ValueChanged {
            add {
                onValueChanged += value;
            }
            remove {
                onValueChanged -= value;
            }
        }
        

        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.DropDown"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the drop down calendar is shown.</para>
        /// </devdoc>
        [SRCategory(SR.CatAction), SRDescription(SR.DateTimePickerOnDropDownDescr)]
        public event EventHandler DropDown {
            add {
                onDropDown += value;
            }
            remove {
                onDropDown -= value;
            }
        }
        
        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.Dispose"]/*' />
        protected override void Dispose(bool disposing) 
        {
            if (disposing) 
            {
                SystemEvents.UserPreferenceChanged -= new UserPreferenceChangedEventHandler(this.UserPreferenceChanged);
            }
            base.Dispose(disposing);
        }
		
        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.CreateAccessibilityInstance"]/*' />
        /// <internalonly/>
        /// <summary>
        /// <para>
        /// Constructs the new instance of the accessibility object for this control. Subclasses
        /// should not call base.CreateAccessibilityObject.
        /// </para>
        /// </summary>
        protected override AccessibleObject CreateAccessibilityInstance() {
            return new DateTimePickerAccessibleObject(this);
        }
        
        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.CreateHandle"]/*' />
        /// <devdoc>
        ///     Creates the physical window handle.
        /// </devdoc>
        protected override void CreateHandle() {
            if (!RecreatingHandle) {
                NativeMethods.INITCOMMONCONTROLSEX icc = new NativeMethods.INITCOMMONCONTROLSEX();
                icc.dwICC = NativeMethods.ICC_DATE_CLASSES;
                SafeNativeMethods.InitCommonControlsEx(icc);
            }

            base.CreateHandle();

            if (userHasSetValue && validTime) {
                /*
                * Make sure any changes to this code
                * get propagated to setValue
                */
                int gdt = NativeMethods.GDT_VALID;
                NativeMethods.SYSTEMTIME sys = DateTimePicker.DateTimeToSysTime(Value);
                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.DTM_SETSYSTEMTIME, gdt, sys);
            }
            else if (!validTime) {
                int gdt = NativeMethods.GDT_NONE;
                NativeMethods.SYSTEMTIME sys = null;
                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.DTM_SETSYSTEMTIME, gdt, sys);
            }
            
            if (format == DateTimePickerFormat.Custom) {                                                                     
                SendMessage(NativeMethods.DTM_SETFORMAT, 0, customFormat);
            }

            UpdateUpDown();
            SetAllControlColors();
            SetControlCalendarFont();
            SetRange();
        }

        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.DestroyHandle"]/*' />
        /// <devdoc>
        ///     Destroys the physical window handle.
        /// </devdoc>
        [UIPermission(SecurityAction.LinkDemand, Window=UIPermissionWindow.AllWindows)]
        protected override void DestroyHandle() {
            value = Value;
            base.DestroyHandle();
        }
        
        // Return a localized string representation of the given DateTime value.
        // Used for throwing exceptions, etc.
        //                       
        private static string FormatDateTime(DateTime value) {
            return value.ToString("G");
        }

        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.IsInputKey"]/*' />
        /// <devdoc>
        ///      Handling special input keys, such as pgup, pgdown, home, end, etc...
        /// </devdoc>
        protected override bool IsInputKey(Keys keyData) {
            if ((keyData & Keys.Alt) == Keys.Alt) return false;
            switch (keyData & Keys.KeyCode) {
                case Keys.PageUp:
                case Keys.PageDown:
                case Keys.Home:
                case Keys.End:
                    return true;
            }
            return base.IsInputKey(keyData);
        }
  
        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.OnCloseUp"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.DateTimePicker.CloseUp'/> 
        /// event.</para>
        /// </devdoc>
        protected virtual void OnCloseUp(EventArgs eventargs) {
            if (onCloseUp != null) onCloseUp.Invoke(this, eventargs);
        }

        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.OnDropDown"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.DateTimePicker.DropDown'/> event.</para>
        /// </devdoc>
        protected virtual void OnDropDown(EventArgs eventargs) {
            if (onDropDown != null) {
                onDropDown.Invoke(this, eventargs);
            }
        }

        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.OnFormatChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnFormatChanged(EventArgs e) {
            EventHandler eh = Events[EVENT_FORMATCHANGED] as EventHandler;
            if (eh != null) {
                 eh(this, e);
            }
        }
        
        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.OnValueChanged"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.DateTimePicker.ValueChanged'/> event.</para>
        /// </devdoc>
        protected virtual void OnValueChanged(EventArgs eventargs) {
            if (onValueChanged != null) {
                onValueChanged.Invoke(this, eventargs);
            }
        }

        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.OnFontChanged"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Occurs when a property for the control changes.
        /// </devdoc>
        protected override void OnFontChanged(EventArgs e) {
            base.OnFontChanged(e);

            //clear the pref height cache
            prefHeightCache = -1;
            
            Height = PreferredHeight;
        
            if (calendarFont == null) {
                calendarFontHandleWrapper = null;
                SetControlCalendarFont();
            }
        }
        
        /// <devdoc>
        /// <para>Resets the <see cref='System.Windows.Forms.DateTimePicker.Format'/> property to its default 
        ///    value.</para>
        /// </devdoc>
        private void ResetFormat() {
            Format = DateTimePickerFormat.Long;
        }

        /// <devdoc>
        /// <para>Resets the <see cref='System.Windows.Forms.DateTimePicker.MaxDate'/> property to its default value. </para>
        /// </devdoc>
        private void ResetMaxDate() {
            MaxDate = MaxDateTime;
        }

        /// <devdoc>
        /// <para>Resets the <see cref='System.Windows.Forms.DateTimePicker.MinDate'/> property to its default value. </para>
        /// </devdoc>
        private void ResetMinDate() {
            MinDate = MinDateTime;
        }
        
        /// <devdoc>
        /// <para> Resets the <see cref='System.Windows.Forms.DateTimePicker.Value'/> property to its default value.</para>
        /// </devdoc>
        private void ResetValue() {

            // always update on reset with ShowNone = false -- as it'll take the current time.
            this.value = DateTime.Now;

            // If ShowCheckBox = true, then userHasSetValue can be false (null value).
            // otherwise, userHasSetValue is valid...
            // userHasSetValue = !ShowCheckBox;

            // After ResetValue() the flag indicating whether the user
            // has set the value should be false.
            userHasSetValue = false;

            // Update the text displayed in the DateTimePicker
            if (IsHandleCreated) {
                int gdt = NativeMethods.GDT_VALID;
                NativeMethods.SYSTEMTIME sys = DateTimePicker.DateTimeToSysTime(value);
                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.DTM_SETSYSTEMTIME, gdt, sys);
            }

            // Updating Checked to false will set the control to "no date",
            // and clear its checkbox.
            Checked = false;

            OnValueChanged(EventArgs.Empty);
            OnTextChanged(EventArgs.Empty);
        }
        
        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.SetBoundsCore"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Restricts the vertical size of the control
        ///    </para>
        /// </devdoc>
        protected override void SetBoundsCore(int x, int y, int width, int height, BoundsSpecified specified) {
            base.SetBoundsCore(x, y, width, PreferredHeight, specified);
        }

        /// <devdoc>
        ///     If the handle has been created, this applies the color to the control
        /// </devdoc>
        /// <internalonly/>
        private void SetControlColor(int colorIndex, Color value) {
            if (IsHandleCreated) {
                SendMessage(NativeMethods.DTM_SETMCCOLOR, colorIndex, ColorTranslator.ToWin32(value));
            }
        }

        /// <devdoc>
        ///     If the handle has been created, this applies the font to the control.
        /// </devdoc>
        /// <internalonly/>
        private void SetControlCalendarFont() {
            if (IsHandleCreated) {
                SendMessage(NativeMethods.DTM_SETMCFONT, CalendarFontHandle, NativeMethods.InvalidIntPtr);
            }
        }

        /// <devdoc>
        ///     Applies all the colors to the control.
        /// </devdoc>
        /// <internalonly/>
        private void SetAllControlColors() {
            SetControlColor(NativeMethods.MCSC_MONTHBK, calendarMonthBackground);
            SetControlColor(NativeMethods.MCSC_TEXT, calendarForeColor);
            SetControlColor(NativeMethods.MCSC_TITLEBK, calendarTitleBackColor);
            SetControlColor(NativeMethods.MCSC_TITLETEXT, calendarTitleForeColor);
            SetControlColor(NativeMethods.MCSC_TRAILINGTEXT, calendarTrailingText);
        }

        /// <devdoc>
        ///     Updates the window handle with the min/max ranges if it has been
        ///     created.
        /// </devdoc>
        /// <internalonly/>
        private void SetRange() {
            if (IsHandleCreated) {
                int flags = 0;

                NativeMethods.SYSTEMTIMEARRAY sa = new NativeMethods.SYSTEMTIMEARRAY();

                flags |= NativeMethods.GDTR_MIN | NativeMethods.GDTR_MAX;
                NativeMethods.SYSTEMTIME sys = DateTimePicker.DateTimeToSysTime(min);
                sa.wYear1 = sys.wYear;
                sa.wMonth1 = sys.wMonth;
                sa.wDayOfWeek1 = sys.wDayOfWeek;
                sa.wDay1 = sys.wDay;
                sa.wHour1 = sys.wHour;
                sa.wMinute1 = sys.wMinute;
                sa.wSecond1 = sys.wSecond;
                sa.wMilliseconds1 = sys.wMilliseconds;
                sys = DateTimePicker.DateTimeToSysTime(max);
                sa.wYear2 = sys.wYear;
                sa.wMonth2 = sys.wMonth;
                sa.wDayOfWeek2 = sys.wDayOfWeek;
                sa.wDay2 = sys.wDay;
                sa.wHour2 = sys.wHour;
                sa.wMinute2 = sys.wMinute;
                sa.wSecond2 = sys.wSecond;
                sa.wMilliseconds2 = sys.wMilliseconds;
                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.DTM_SETRANGE, flags, sa);
            }
        }

        /// <devdoc>
        ///     Turns on or off a given style bit
        /// </devdoc>
        /// <internalonly/>
        private void SetStyleBit(bool flag, int bit) {
            if (((style & bit) != 0) == flag) return;

            if (flag) {
                style |= bit;
            }
            else {
                style &= ~bit;
            }

            if (IsHandleCreated) {
                RecreateHandle();
                Invalidate();
                Update();
            }
        }
        
        /// <devdoc>
        /// <para> Determines if the <see cref='System.Windows.Forms.DateTimePicker.CalendarForeColor'/> property needs to be 
        ///    persisted.</para>
        /// </devdoc>
        private bool ShouldSerializeCalendarForeColor() {
            return !CalendarForeColor.Equals(DefaultForeColor);
        }

        /// <devdoc>
        /// <para>Determines if the <see cref='System.Windows.Forms.DateTimePicker.CalendarFont'/> property needs to be persisted.</para>
        /// </devdoc>
        private bool ShouldSerializeCalendarFont() {
            return calendarFont != null;
        }

        /// <devdoc>
        /// <para>Determines if the <see cref='System.Windows.Forms.DateTimePicker.CalendarTitleBackColor'/> property needs to be persisted.</para>
        /// </devdoc>
        private bool ShouldSerializeCalendarTitleBackColor() {
            return !calendarTitleBackColor.Equals(DefaultTitleBackColor);
        }

        /// <devdoc>
        /// <para>Determines if the <see cref='System.Windows.Forms.DateTimePicker.CalendarTitleForeColor'/> property needs to be persisted.</para>
        /// </devdoc>
        private bool ShouldSerializeCalendarTitleForeColor() {
            return !calendarTitleForeColor.Equals(DefaultTitleForeColor);
        }

        /// <devdoc>
        /// <para>Determines if the <see cref='System.Windows.Forms.DateTimePicker.CalendarTrailingForeColor'/> property needs to be persisted.</para>
        /// </devdoc>
        private bool ShouldSerializeCalendarTrailingForeColor() {
            return !calendarTrailingText.Equals(DefaultTrailingForeColor);
        }

        /// <devdoc>
        /// <para>Determines if the <see cref='System.Windows.Forms.DateTimePicker.CalendarMonthBackground'/> property needs to be persisted.</para>
        /// </devdoc>
        private bool ShouldSerializeCalendarMonthBackground() {
            return !calendarMonthBackground.Equals(DefaultMonthBackColor);
        }
        
        /// <devdoc>
        /// <para>Determines if the <see cref='System.Windows.Forms.DateTimePicker.MaxDate'/> property needs to be persisted.</para>
        /// </devdoc>
        private bool ShouldSerializeMaxDate() {
            return !max.Equals(MaxDateTime);
        }

        /// <devdoc>
        /// <para>Determines if the <see cref='System.Windows.Forms.DateTimePicker.MinDate'/> property needs to be persisted.</para>
        /// </devdoc>
        private bool ShouldSerializeMinDate() {
            return !min.Equals(MinDateTime);
        }

        /// <devdoc>
        /// <para>Determines if the <see cref='System.Windows.Forms.DateTimePicker.Value'/> property needs to be persisted.</para>
        /// </devdoc>
        private bool ShouldSerializeValue() {
            return userHasSetValue;
        }

        /// <devdoc>
        /// <para>Determines if the <see cref='System.Windows.Forms.DateTimePicker.Format'/> property needs to be persisted.</para>
        /// </devdoc>
        private bool ShouldSerializeFormat() {
            return(Format != DateTimePickerFormat.Long);
        }

        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.ToString"]/*' />
        /// <devdoc>
        ///     Returns the control as a string
        /// </devdoc>
        /// <internalonly/>
        public override string ToString() {

            string s = base.ToString();
            return s + ", Value: " + FormatDateTime(Value);
        }

        /// <devdoc>
        ///     Forces a repaint of the updown control if it is displayed.
        /// </devdoc>
        /// <internalonly/>
        private void UpdateUpDown() {
            // The upDown control doesn't repaint correctly.
            //
            if (ShowUpDown) {
                EnumChildren c = new EnumChildren();
                NativeMethods.EnumChildrenCallback cb = new NativeMethods.EnumChildrenCallback(c.enumChildren);
                UnsafeNativeMethods.EnumChildWindows(new HandleRef(this, Handle), cb, NativeMethods.NullHandleRef);
                if (c.hwndFound != IntPtr.Zero) {
                    SafeNativeMethods.InvalidateRect(new HandleRef(c, c.hwndFound), null, true);
                    SafeNativeMethods.UpdateWindow(new HandleRef(c, c.hwndFound));
                }
            }
        }
        
        private void UserPreferenceChanged(object sender, UserPreferenceChangedEventArgs pref) {
            if (pref.Category == UserPreferenceCategory.Locale) {
                // We need to recreate the monthcalendar handle when the locale changes, because
                // the day names etc. are only updated on a handle recreate (comctl32 limitation).
                //
                RecreateHandle();                
            }
        }

        /// <devdoc>
        ///     Handles the DTN_CLOSEUP notification
        /// </devdoc>
        /// <internalonly/>
        private void WmCloseUp(ref Message m) {
            OnCloseUp(EventArgs.Empty);
        }

        /// <devdoc>
        ///     Handles the DTN_DATETIMECHANGE notification
        /// </devdoc>
        /// <internalonly/>
        private void WmDateTimeChange(ref Message m) {
            NativeMethods.NMDATETIMECHANGE nmdtc = (NativeMethods.NMDATETIMECHANGE)m.GetLParam(typeof(NativeMethods.NMDATETIMECHANGE));
            DateTime temp = value;
            bool oldvalid = validTime;
            if (nmdtc.dwFlags != NativeMethods.GDT_NONE) {
                validTime = true;
                value = DateTimePicker.SysTimeToDateTime(nmdtc.st);
                userHasSetValue = true;
            }
            else {
                validTime = false;
            }
            if (value!=temp || oldvalid != validTime) {
                OnValueChanged(EventArgs.Empty);
                OnTextChanged(EventArgs.Empty);
            }
        }

        /// <devdoc>
        ///     Handles the DTN_DROPDOWN notification
        /// </devdoc>
        /// <internalonly/>
        private void WmDropDown(ref Message m) {
            OnDropDown(EventArgs.Empty);
        }
        
        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.OnSystemColorsChanged"]/*' />
        /// <devdoc>
        ///     Handles system color changes
        /// </devdoc>
        /// <internalonly/>
        protected override void OnSystemColorsChanged(EventArgs e) {
            SetAllControlColors();
            base.OnSystemColorsChanged(e);
        }
        
        /// <devdoc>
        ///     Handles the WM_COMMAND messages reflected from the parent control.
        /// </devdoc>
        /// <internalonly/>
        private void WmReflectCommand(ref Message m) {
            if (m.HWnd == Handle) {

                NativeMethods.NMHDR nmhdr = (NativeMethods.NMHDR)m.GetLParam(typeof(NativeMethods.NMHDR));
                switch (nmhdr.code) {
                    case NativeMethods.DTN_CLOSEUP:
                        WmCloseUp(ref m);
                        break;
                    case NativeMethods.DTN_DATETIMECHANGE:
                        WmDateTimeChange(ref m);
                        break;
                    case NativeMethods.DTN_DROPDOWN:
                        WmDropDown(ref m);
                        break;                    
                }
            }
        }

        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePicker.WndProc"]/*' />
        /// <devdoc>
        ///     Overrided wndProc
        /// </devdoc>
        /// <internalonly/>
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        protected override void WndProc(ref Message m) {
            switch (m.Msg) {
                case NativeMethods.WM_LBUTTONDOWN:
                    FocusInternal();
                    if (!ValidationCancelled) {
                        base.WndProc(ref m);
                    }
                    break;
                case NativeMethods.WM_REFLECT + NativeMethods.WM_NOTIFY:
                    WmReflectCommand(ref m);
                    base.WndProc(ref m);
                    break;
                case NativeMethods.WM_WINDOWPOSCHANGED:
                    base.WndProc(ref m);
                    UpdateUpDown();
                    break;
                default:
                    base.WndProc(ref m);
                    break;
            }
        }

        /// <devdoc>
        ///     Takes a DateTime value and returns a SYSTEMTIME struct
        ///     Note: 1 second granularity
        /// </devdoc>
        internal static NativeMethods.SYSTEMTIME DateTimeToSysTime(DateTime time) {
            NativeMethods.SYSTEMTIME sys = new NativeMethods.SYSTEMTIME();
            sys.wYear = (short)time.Year;
            sys.wMonth = (short)time.Month;
            sys.wDayOfWeek = (short)time.DayOfWeek;
            sys.wDay = (short)time.Day;
            sys.wHour = (short)time.Hour;
            sys.wMinute = (short)time.Minute;
            sys.wSecond = (short)time.Second;
            sys.wMilliseconds = 0;
            return sys;
        }
        
        /// <devdoc>
        ///     Takes a SYSTEMTIME struct and returns a DateTime value
        ///     Note: 1 second granularity.
        /// </devdoc>
        internal static DateTime SysTimeToDateTime(NativeMethods.SYSTEMTIME s) {
            return new DateTime(s.wYear, s.wMonth, s.wDay, s.wHour, s.wMinute, s.wSecond);
        }
        
        /// <devdoc>
        /// </devdoc>
        private sealed class EnumChildren {
            public IntPtr hwndFound = IntPtr.Zero;

            public bool enumChildren(IntPtr hwnd, IntPtr lparam) {
                hwndFound = hwnd;
                return true;
            }
        }
        
        /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePickerAccessibleObject"]/*' />
        /// <internalonly/>
        /// <summary>
        /// </summary>
        [ComVisible(true)]
        public class DateTimePickerAccessibleObject : ControlAccessibleObject {

            /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePickerAccessibleObject.DateTimePickerAccessibleObject"]/*' />
            public DateTimePickerAccessibleObject(DateTimePicker owner) : base(owner) {
            }

            /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePickerAccessibleObject.Value"]/*' />
            public override string Value {
                get {
                    string baseValue = base.Value;
                    if (baseValue == null || baseValue.Length == 0) {
                        return Owner.Text;
                    }                    
                    return baseValue;
                }
            }
            
            /// <include file='doc\DateTimePicker.uex' path='docs/doc[@for="DateTimePickerAccessibleObject.State"]/*' />
            public override AccessibleStates State {
                get {
                    AccessibleStates state = base.State;
                    
                    if(((DateTimePicker)Owner).ShowCheckBox &&
                       ((DateTimePicker)Owner).Checked) {
                       state |= AccessibleStates.Checked;
                    }
                    
                    return state;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\dialogresult.cs ===
//------------------------------------------------------------------------------
// <copyright file="DialogResult.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Drawing;
    using System.ComponentModel;
    using Microsoft.Win32;



    /// <include file='doc\DialogResult.uex' path='docs/doc[@for="DialogResult"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies identifiers to
    ///       indicate the return value of a dialog box.
    ///    </para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public enum DialogResult{

        /// <include file='doc\DialogResult.uex' path='docs/doc[@for="DialogResult.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       
        ///       Nothing is returned from the dialog box. This
        ///       means that the modal dialog continues running.
        ///       
        ///    </para>
        /// </devdoc>
        None = 0,

        /// <include file='doc\DialogResult.uex' path='docs/doc[@for="DialogResult.OK"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The
        ///       dialog box return value is
        ///       OK (usually sent from a button labeled OK).
        ///       
        ///    </para>
        /// </devdoc>
        OK = 1,

        /// <include file='doc\DialogResult.uex' path='docs/doc[@for="DialogResult.Cancel"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The
        ///       dialog box return value is Cancel (usually sent
        ///       from a button labeled Cancel).
        ///       
        ///    </para>
        /// </devdoc>
        Cancel = 2,

        /// <include file='doc\DialogResult.uex' path='docs/doc[@for="DialogResult.Abort"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The dialog box return value is
        ///       Abort (usually sent from a button labeled Abort).
        ///       
        ///    </para>
        /// </devdoc>
        Abort = 3,

        /// <include file='doc\DialogResult.uex' path='docs/doc[@for="DialogResult.Retry"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The dialog box return value is
        ///       Retry (usually sent from a button labeled Retry).
        ///       
        ///    </para>
        /// </devdoc>
        Retry = 4,

        /// <include file='doc\DialogResult.uex' path='docs/doc[@for="DialogResult.Ignore"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The
        ///       dialog box return value is Ignore (usually sent
        ///       from a button labeled Ignore).
        ///       
        ///    </para>
        /// </devdoc>
        Ignore = 5,

        /// <include file='doc\DialogResult.uex' path='docs/doc[@for="DialogResult.Yes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The dialog box return value is
        ///       Yes (usually sent from a button labeled Yes).
        ///       
        ///    </para>
        /// </devdoc>
        Yes = 6,

        /// <include file='doc\DialogResult.uex' path='docs/doc[@for="DialogResult.No"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The dialog box return value is
        ///       No (usually sent from a button labeled No).
        ///       
        ///    </para>
        /// </devdoc>
        No = 7,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\dataobject.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataObject.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Runtime.Serialization.Formatters.Binary;
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Serialization;
    using System.Text;
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.ComponentModel;
    using System.IO;
    using System.Drawing;
    using System.Windows.Forms;
    using System.Security;
    using System.Security.Permissions;
    using System.Reflection;

    /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject"]/*' />
    /// <devdoc>
    ///    <para>Implements a basic data transfer mechanism.</para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.None)
    ]
    public class DataObject : IDataObject, UnsafeNativeMethods.IOleDataObject {

        private static Exception CreateHRException(int hr) {
            ExternalException e = new ExternalException("", hr);
            return e;
        }

        private static readonly string CF_DEPRECATED_FILENAME = "FileName";
        private static readonly string CF_DEPRECATED_FILENAMEW = "FileNameW";

        private const int HR_S_FALSE = 1;
        private const int HR_S_OK = 0;
        private static readonly Exception S_FALSE = CreateHRException(HR_S_FALSE);

        private const int DV_E_FORMATETC     = unchecked((int)0x80040064);
        private const int DV_E_LINDEX        = unchecked((int)0x80040068);
        private const int DV_E_TYMED         = unchecked((int)0x80040069);
        private const int DV_E_DVASPECT      = unchecked((int)0x8004006B);
        private const int OLE_E_NOTRUNNING   = unchecked((int)0x80040005);
        private const int OLE_E_ADVISENOTSUPPORTED = unchecked((int)0x80040003);
        private const int DATA_S_SAMEFORMATETC = 0x00040130;

        private const int DVASPECT_CONTENT   = 1;
        private const int DVASPECT_THUMBNAIL = 2;
        private const int DVASPECT_ICON      = 4;
        private const int DVASPECT_DOCPRINT  = 8;

        private const int TYMED_HGLOBAL      = 1;
        private const int TYMED_FILE         = 2;
        private const int TYMED_ISTREAM      = 4;
        private const int TYMED_ISTORAGE     = 8;
        private const int TYMED_GDI          = 16;
        private const int TYMED_MFPICT       = 32;
        private const int TYMED_ENHMF        = 64;
        private const int TYMED_NULL         = 0;

        private const int DATADIR_GET        = 1;
        private const int DATADIR_SET        = 2;

        private static readonly int[] ALLOWED_TYMEDS =
        new int [] { TYMED_HGLOBAL,
            TYMED_ISTREAM,
            TYMED_ENHMF,
            TYMED_MFPICT,
            TYMED_GDI};

        private IDataObject     innerData = null;
        
        // We use this to identify that a stream is actually a serialized object.  On read,
        // we don't know if the contents of a stream were saved "raw" or if the stream is really
        // pointing to a serialized object.  If we saved an object, we prefix it with this
        // guid.
        //
        private static readonly byte[] serializedObjectID = new Guid("FD9EA796-3B13-4370-A679-56106BB288FB").ToByteArray();

        /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.DataObject"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Windows.Forms.DataObject'/> class, with the specified <see cref='System.Windows.Forms.IDataObject'/>.</para>
        /// </devdoc>
        internal DataObject(IDataObject data) {
            Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "Constructed DataObject based on IDataObject");
            innerData = data;
            Debug.Assert(innerData != null, "You must have an innerData on all DataObjects");
        }

        /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.DataObject1"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Windows.Forms.DataObject'/> class, with the specified <see langword='NativeMethods.IOleDataObject'/>.</para>
        /// </devdoc>
        internal DataObject(UnsafeNativeMethods.IOleDataObject data) {
            Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "Constructed DataObject based on IOleDataObject");
            innerData = new OleConverter(data);
            Debug.Assert(innerData != null, "You must have an innerData on all DataObjects");
        }

        /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.DataObject2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.DataObject'/>
        ///       class, which can store arbitrary data.
        ///    </para>
        /// </devdoc>
        public DataObject() {
            Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "Constructed DataObject standalone");
            innerData = new DataStore();
            Debug.Assert(innerData != null, "You must have an innerData on all DataObjects");
        }

        /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.DataObject3"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Windows.Forms.DataObject'/> class, containing the specified data.</para>
        /// </devdoc>
        public DataObject(object data) {
            Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "Constructed DataObject base on Object: " + data.ToString());
            if (data is IDataObject && !Marshal.IsComObject(data)) {
                innerData = (IDataObject)data;
            }
            else if (data is UnsafeNativeMethods.IOleDataObject) {
                innerData = new OleConverter((UnsafeNativeMethods.IOleDataObject)data);
            }
            else {
                innerData = new DataStore();
                SetData(data);
            }
            Debug.Assert(innerData != null, "You must have an innerData on all DataObjects");
        }

        /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.DataObject4"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Windows.Forms.DataObject'/> class, containing the specified data and its 
        ///    associated format.</para>
        /// </devdoc>
        public DataObject(string format, object data) : this() {
            SetData(format, data);
            Debug.Assert(innerData != null, "You must have an innerData on all DataObjects");
        }
        
        private IntPtr GetCompatibleBitmap(Bitmap bm) {
            // GDI+ returns a DIBSECTION based HBITMAP. The clipboard deals well
            // only with bitmaps created using CreateCompatibleBitmap(). So, we 
            // convert the DIBSECTION into a compatible bitmap.
            //
            IntPtr hBitmap = bm.GetHbitmap();
    
            // Get the screen DC.
            //
            IntPtr hDC = UnsafeNativeMethods.GetDC(NativeMethods.NullHandleRef);

            // Create a compatible DC to render the source bitmap.
            //
            IntPtr dcSrc = UnsafeNativeMethods.CreateCompatibleDC(new HandleRef(null, hDC));
            IntPtr srcOld = SafeNativeMethods.SelectObject(new HandleRef(null, dcSrc), new HandleRef(bm, hBitmap));

            // Create a compatible DC and a new compatible bitmap. 
            //
            IntPtr dcDest = UnsafeNativeMethods.CreateCompatibleDC(new HandleRef(null, hDC));
            IntPtr hBitmapNew = SafeNativeMethods.CreateCompatibleBitmap(new HandleRef(null, hDC), bm.Size.Width, bm.Size.Height);

            // Select the new bitmap into a compatible DC and render the blt the original bitmap.
            //
            IntPtr destOld = SafeNativeMethods.SelectObject(new HandleRef(null, dcDest), new HandleRef(null, hBitmapNew));
            SafeNativeMethods.BitBlt(new HandleRef(null, dcDest), 0, 0, bm.Size.Width, bm.Size.Height, new HandleRef(null, dcSrc), 0, 0, 0x00CC0020);

            // Clear the source and destination compatible DCs.
            //
            SafeNativeMethods.SelectObject(new HandleRef(null, dcSrc), new HandleRef(null, srcOld));
            SafeNativeMethods.SelectObject(new HandleRef(null, dcDest), new HandleRef(null, destOld));

            UnsafeNativeMethods.DeleteDC(new HandleRef(null, dcSrc));
            UnsafeNativeMethods.DeleteDC(new HandleRef(null, dcDest));
            UnsafeNativeMethods.ReleaseDC(NativeMethods.NullHandleRef, new HandleRef(null, hDC));

            SafeNativeMethods.DeleteObject(new HandleRef(bm, hBitmap));

            return hBitmapNew;
        }

        /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.GetData"]/*' />
        /// <devdoc>
        ///    <para>Retrieves the data associated with the specified data 
        ///       format, using an automated conversion parameter to determine whether to convert
        ///       the data to the format.</para>
        /// </devdoc>
        public virtual object GetData(string format, bool autoConvert) {
            Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "Request data: " + format + ", " + autoConvert.ToString());
            Debug.Assert(innerData != null, "You must have an innerData on all DataObjects");
            return innerData.GetData(format, autoConvert);
        }

        /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.GetData1"]/*' />
        /// <devdoc>
        ///    <para>Retrieves the data associated with the specified data 
        ///       format.</para>
        /// </devdoc>
        public virtual object GetData(string format) {
            Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "Request data: " + format);
            return GetData(format, true);
        }

        /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.GetData2"]/*' />
        /// <devdoc>
        ///    <para>Retrieves the data associated with the specified class 
        ///       type format.</para>
        /// </devdoc>
        public virtual object GetData(Type format) {
            Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "Request data: " + format.FullName);
            Debug.Assert(format != null, "Must specify a format type");
            if (format == null) {
                return null;
            }
            return GetData(format.FullName);
        }

        /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.GetDataPresent"]/*' />
        /// <devdoc>
        ///    <para>Determines whether data stored in this instance is 
        ///       associated with, or can be converted to, the specified
        ///       format.</para>
        /// </devdoc>
        public virtual bool GetDataPresent(Type format) {
            Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "Check data: " + format.FullName);
            Debug.Assert(format != null, "Must specify a format type");
            if (format == null) {
                return false;
            }
            bool b = GetDataPresent(format.FullName);
            Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "  ret: " + b.ToString());
            return b;
        }

        /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.GetDataPresent1"]/*' />
        /// <devdoc>
        ///    <para>Determines whether data stored in this instance is 
        ///       associated with the specified format, using an automatic conversion
        ///       parameter to determine whether to convert the data to the format.</para>
        /// </devdoc>
        public virtual bool GetDataPresent(string format, bool autoConvert) {
            Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "Check data: " + format + ", " + autoConvert.ToString());
            Debug.Assert(innerData != null, "You must have an innerData on all DataObjects");
            bool b = innerData.GetDataPresent(format, autoConvert);
            Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "  ret: " + b.ToString());
            return b;
        }

        /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.GetDataPresent2"]/*' />
        /// <devdoc>
        ///    <para>Determines whether data stored in this instance is 
        ///       associated with, or can be converted to, the specified
        ///       format.</para>
        /// </devdoc>
        public virtual bool GetDataPresent(string format) {
            Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "Check data: " + format);
            bool b = GetDataPresent(format, true);
            Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "  ret: " + b.ToString());
            return b;
        }


        /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.GetFormats"]/*' />
        /// <devdoc>
        ///    <para>Gets a list of all formats that data stored in this 
        ///       instance is associated with or can be converted to, using an automatic
        ///       conversion parameter<paramref name=" "/>to
        ///       determine whether to retrieve all formats that the data can be converted to or
        ///       only native data formats.</para>
        /// </devdoc>
        public virtual string[] GetFormats(bool autoConvert) {
            Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "Check formats: " + autoConvert.ToString());
            Debug.Assert(innerData != null, "You must have an innerData on all DataObjects");
            return innerData.GetFormats(autoConvert);
        }

        /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.GetFormats1"]/*' />
        /// <devdoc>
        ///    <para>Gets a list of all formats that data stored in this instance is associated
        ///       with or can be converted to.</para>
        /// </devdoc>
        public virtual string[] GetFormats() {
            Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "Check formats:");
            return GetFormats(true);
        }

        /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.GetDistinctStrings"]/*' />
        /// <devdoc>
        ///     Retrieves a list of distinct strings from the array.
        /// </devdoc>
        private static string[] GetDistinctStrings(string[] formats) {
            ArrayList distinct = new ArrayList();
            for (int i=0; i<formats.Length; i++) {
                string s = formats[i];
                if (!distinct.Contains(s)) {
                    distinct.Add(s);
                }
            }

            string[] temp = new string[distinct.Count];
            distinct.CopyTo(temp, 0);
            return temp;
        }

        /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.GetMappedFormats"]/*' />
        /// <devdoc>
        ///     Returns all the "synonyms" for the specified format.
        /// </devdoc>
        private static string[] GetMappedFormats(string format) {
            if (format == null) {
                return null;
            }

            if (format.Equals(DataFormats.Text)
                || format.Equals(DataFormats.UnicodeText)
                || format.Equals(DataFormats.StringFormat)) {

                return new string[] {
                    DataFormats.StringFormat,
                    DataFormats.UnicodeText,
                    DataFormats.Text,
                };
            }

            if (format.Equals(DataFormats.FileDrop)
                || format.Equals(CF_DEPRECATED_FILENAME)
                || format.Equals(CF_DEPRECATED_FILENAMEW)) {

                return new string[] {
                    DataFormats.FileDrop,
                    CF_DEPRECATED_FILENAMEW,
                    CF_DEPRECATED_FILENAME,
                };
            }

            if (format.Equals(DataFormats.Bitmap)
                || format.Equals((typeof(Bitmap)).FullName)) {

                return new string[] {
                    (typeof(Bitmap)).FullName,
                    DataFormats.Bitmap,
                };
            }

/*gpr
            if (format.Equals(DataFormats.EnhancedMetafile)
                || format.Equals((typeof(Metafile)).FullName)) {

                return new string[] {DataFormats.EnhancedMetafile,
                    (typeof(Metafile)).FullName};
            }
*/
            return new String[] {format};
        }

        /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.GetMappedFormats1"]/*' />
        /// <devdoc>
        ///     Returns all distinct "synonyms" for the each of the formats.
        /// </devdoc>
        private static string[] GetMappedFormats(string[] formats) {
            ArrayList allChoices = new ArrayList();

            for (int i=0; i<formats.Length; i++) {
                allChoices.Add(formats[i]);
            }

            if (formats != null) {
                for (int i=0; i<formats.Length; i++) {
                    string[] r = GetMappedFormats(formats[i]);
                    if (r != null) {
                        for (int j=0; j<r.Length; j++) {
                            allChoices.Add(r[j]);
                        }
                    }
                }
            }

            string[] temp = new string[allChoices.Count];
            allChoices.CopyTo(temp, 0);
            return GetDistinctStrings(temp);
        }

        /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.GetTymedUseable"]/*' />
        /// <devdoc>
        ///     Returns true if the tymed is useable.
        /// </devdoc>
        /// <internalonly/>
        private bool GetTymedUseable(int tymed) {
            for (int i=0; i<ALLOWED_TYMEDS.Length; i++) {
                if ((tymed & ALLOWED_TYMEDS[i]) != 0) {
                    return true;
                }
            }
            return false;
        }

        /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.GetDataIntoOleStructs"]/*' />
        /// <devdoc>
        ///     Populates Ole datastructes from a WinForms dataObject. This is the core
        ///     of WinForms to OLE conversion.
        /// </devdoc>
        /// <internalonly/>
        private int GetDataIntoOleStructs(NativeMethods.FORMATETC formatetc,
                                           NativeMethods.STGMEDIUM medium) {

            if (GetTymedUseable(formatetc.tymed) && GetTymedUseable(medium.tymed)) {
                string format = DataFormats.GetFormat(formatetc.cfFormat).Name;

                if (GetDataPresent(format)) {


                    Object data = GetData(format);                    

                    if ((formatetc.tymed & TYMED_HGLOBAL) != 0) {
                        return SaveDataToHandle(data, format, medium);
                    }
                    else if ((formatetc.tymed & TYMED_GDI) != 0) {
                        if (format.Equals(DataFormats.Bitmap) && data is Bitmap) {
                            // save bitmap
                            //
                            Bitmap bm = (Bitmap)data;
                            if (bm != null) {
                                medium.unionmember = GetCompatibleBitmap(bm); // gpr: Does this get properly disposed?
                            }
                        }
                    }
/* gpr
                    else if ((formatetc.tymed & TYMED_ENHMF) != 0) {
                        if (format.Equals(DataFormats.EnhancedMetafile)
                            && data is Metafile) {
                            // save metafile

                            Metafile mf = (Metafile)data;
                            if (mf != null) {
                                medium.unionmember = mf.Handle;
                            }
                        }
                    } 
                    */
                    else {
                        return (DV_E_TYMED);
                    }
                }
                else {
                    return (DV_E_FORMATETC);
                }
            }
            else {
                return (DV_E_TYMED);
            }
            return NativeMethods.S_OK;
        }

        // <devdoc>
        //     Part of IOleDataObject, used to interop with OLE.
        // </devdoc>
        // <internalonly/>
        int UnsafeNativeMethods.IOleDataObject.OleDAdvise(NativeMethods.FORMATETC pFormatetc, int advf, Object pAdvSink, int[] pdwConnection) {
            Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "OleDAdvise");
            if (innerData is OleConverter) {
                return ((OleConverter)innerData).OleDataObject.OleDAdvise(pFormatetc, advf, pAdvSink, pdwConnection);
            }
            return (NativeMethods.E_NOTIMPL);
        }

        // <devdoc>
        //     Part of IOleDataObject, used to interop with OLE.
        // </devdoc>
        // <internalonly/>
        int UnsafeNativeMethods.IOleDataObject.OleDUnadvise(int dwConnection) {
            Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "OleDUnadvise");
            if (innerData is OleConverter) {
                return ((OleConverter)innerData).OleDataObject.OleDUnadvise(dwConnection);
            }
            return (NativeMethods.E_NOTIMPL);
        }

        // <devdoc>
        //     Part of IOleDataObject, used to interop with OLE.
        // </devdoc>
        // <internalonly/>
        int UnsafeNativeMethods.IOleDataObject.OleEnumDAdvise(object[] ppenumAdvise) {
            Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "OleEnumDAdvise");
            if (innerData is OleConverter) {
                return ((OleConverter)innerData).OleDataObject.OleEnumDAdvise(ppenumAdvise);
            }
            return (OLE_E_ADVISENOTSUPPORTED);
        }

        // <devdoc>
        //     Part of IOleDataObject, used to interop with OLE.
        // </devdoc>
        // <internalonly/>
        UnsafeNativeMethods.IEnumFORMATETC UnsafeNativeMethods.IOleDataObject.OleEnumFormatEtc(int dwDirection) {
            Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "OleEnumFormatEtc: " + dwDirection.ToString());
            if (innerData is OleConverter) {
                return ((OleConverter)innerData).OleDataObject.OleEnumFormatEtc(dwDirection);
            }
            if (dwDirection == DATADIR_GET) {
                return new FormatEnumerator(this);
            }
            else {
                throw new ExternalException("", NativeMethods.E_NOTIMPL);
            }
        }

        // <devdoc>
        //     Part of IOleDataObject, used to interop with OLE.
        // </devdoc>
        // <internalonly/>
        int UnsafeNativeMethods.IOleDataObject.OleGetCanonicalFormatEtc(NativeMethods.FORMATETC pformatetcIn, NativeMethods.FORMATETC pformatetcOut) {
            Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "OleGetCanonicalFormatEtc");
            if (innerData is OleConverter) {
                return ((OleConverter)innerData).OleDataObject.OleGetCanonicalFormatEtc(pformatetcIn, pformatetcOut);
            }
            return (DATA_S_SAMEFORMATETC);
        }

        // <devdoc>
        //     Part of IOleDataObject, used to interop with OLE.
        // </devdoc>
        // <internalonly/>
        int UnsafeNativeMethods.IOleDataObject.OleGetData(NativeMethods.FORMATETC formatetc, NativeMethods.STGMEDIUM medium) {
            Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "OleGetData");
            if (innerData is OleConverter) {
                return ((OleConverter)innerData).OleDataObject.OleGetData(formatetc, medium);
            }
            if (GetTymedUseable(formatetc.tymed)) {
                if ((formatetc.tymed & TYMED_HGLOBAL) != 0) {

                    medium.tymed = TYMED_HGLOBAL;
                    medium.unionmember = UnsafeNativeMethods.GlobalAlloc(NativeMethods.GMEM_MOVEABLE
                                                             | NativeMethods.GMEM_DDESHARE
                                                             | NativeMethods.GMEM_ZEROINIT,
                                                             1);
                    if (medium.unionmember == IntPtr.Zero) {
                        return (NativeMethods.E_OUTOFMEMORY);
                    }
                    int hr = ((UnsafeNativeMethods.IOleDataObject)this).OleGetDataHere(formatetc, medium);

                    // make sure we zero out that pointer if we don't support the format.
                    //
                    if (NativeMethods.Failed(hr)) {
                        UnsafeNativeMethods.GlobalFree(new HandleRef(medium, medium.unionmember));
                        medium.unionmember = IntPtr.Zero;
                    }
                    return hr;
                }
                else {

                    medium.tymed  = formatetc.tymed;
                    return ((UnsafeNativeMethods.IOleDataObject)this).OleGetDataHere(formatetc, medium);
                }
            }
            else {
                return (DV_E_TYMED);
            }
        }

        // <devdoc>
        //     Part of IOleDataObject, used to interop with OLE.
        // </devdoc>
        // <internalonly/>
        int UnsafeNativeMethods.IOleDataObject.OleGetDataHere(NativeMethods.FORMATETC formatetc, NativeMethods.STGMEDIUM medium) {
            Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "OleGetDataHere");
            if (innerData is OleConverter) {
                return ((OleConverter)innerData).OleDataObject.OleGetDataHere(formatetc, medium);
            }
            return GetDataIntoOleStructs(formatetc, medium);
        }

        // <devdoc>
        //     Part of IOleDataObject, used to interop with OLE.
        // </devdoc>
        // <internalonly/>
        int UnsafeNativeMethods.IOleDataObject.OleQueryGetData(NativeMethods.FORMATETC formatetc) {
            Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "OleQueryGetData");
            if (innerData is OleConverter) {
                return ((OleConverter)innerData).OleDataObject.OleQueryGetData(formatetc);
            }
            if (formatetc.dwAspect == DVASPECT_CONTENT) {
                if (GetTymedUseable(formatetc.tymed)) {

                    if (formatetc.cfFormat == 0) {
                        Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "OleQueryGetData::returning S_FALSE because cfFormat == 0");
                        return NativeMethods.S_FALSE;
                    }
                    else {
                        if (!GetDataPresent(DataFormats.GetFormat(formatetc.cfFormat).Name)) {
                            return (DV_E_FORMATETC);
                        }
                    }
                }
                else {
                    return (DV_E_TYMED);
                }
            }
            else {
                return (DV_E_DVASPECT);
            }
            #if DEBUG
            int format = formatetc.cfFormat;
            Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "OleQueryGetData::cfFormat " + format.ToString() + " found");
            #endif
            return NativeMethods.S_OK;
        }

        // <devdoc>
        //     Part of IOleDataObject, used to interop with OLE.
        // </devdoc>
        // <internalonly/>
        int UnsafeNativeMethods.IOleDataObject.OleSetData(NativeMethods.FORMATETC pFormatetcIn, NativeMethods.STGMEDIUM pmedium, int fRelease) {
            Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "OleSetData");
            if (innerData is OleConverter) {
                return ((OleConverter)innerData).OleDataObject.OleSetData(pFormatetcIn, pmedium, fRelease);
            }
            // CONSIDER : ChrisAn, 11/13/1997 - Do we need to support this?
            //
            return (NativeMethods.E_NOTIMPL);
        }

        private int SaveDataToHandle(object data, string format, NativeMethods.STGMEDIUM medium) {
            int hr = NativeMethods.E_FAIL;
            if (data is Stream) {
                hr = SaveStreamToHandle(ref medium.unionmember, (Stream)data);
            }
            else if (format.Equals(DataFormats.Text)
                     || format.Equals(DataFormats.Rtf)
                     || format.Equals(DataFormats.Html)
                     || format.Equals(DataFormats.OemText)) {
                hr = SaveStringToHandle(medium.unionmember, data.ToString(), false);
            }
            else if (format.Equals(DataFormats.UnicodeText)) {
                hr = SaveStringToHandle(medium.unionmember, data.ToString(), true);
            }
            else if (format.Equals(DataFormats.FileDrop)) {
                hr = SaveFileListToHandle(medium.unionmember, (string[])data);
            }
            else if (format.Equals(CF_DEPRECATED_FILENAME)) {
                string[] filelist = (string[])data;
                hr = SaveStringToHandle(medium.unionmember, filelist[0], false);
            }
            else if (format.Equals(CF_DEPRECATED_FILENAMEW)) {
                string[] filelist = (string[])data;
                hr = SaveStringToHandle(medium.unionmember, filelist[0], true);
            }
            else if (format.Equals(DataFormats.Dib)
                     && data is Image) {
                // GDI+ does not properly handle saving to DIB images.  Since the 
                // clipboard will take an HBITMAP and publish a Dib, we don't need
                // to support this.
                //
                hr = DV_E_TYMED; // SaveImageToHandle(ref medium.unionmember, (Image)data);
            }
            else if (format.Equals(DataFormats.Serializable)
                     || data is ISerializable 
                     || (data != null && data.GetType().IsSerializable)) {
                hr = SaveObjectToHandle(ref medium.unionmember, data);
            }
            return hr;
        }
        
        private int SaveImageToHandle(ref IntPtr handle, Image data) {
            MemoryStream stream = new MemoryStream();
            data.Save(stream, System.Drawing.Imaging.ImageFormat.Bmp);
            return SaveStreamToHandle(ref handle, stream);
        }

        private int SaveObjectToHandle(ref IntPtr handle, Object data) {
            Stream stream = new MemoryStream();
            BinaryWriter bw = new BinaryWriter(stream);
            bw.Write(serializedObjectID);
            BinaryFormatter formatter = new BinaryFormatter();
            formatter.Serialize(stream, data);
            return SaveStreamToHandle(ref handle, stream);
        }

        /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.SaveStreamToHandle"]/*' />
        /// <devdoc>
        ///     Saves stream out to handle.
        /// </devdoc>
        /// <internalonly/>
        private int SaveStreamToHandle(ref IntPtr handle, Stream stream) {
            int size = (int)stream.Length;
            handle = UnsafeNativeMethods.GlobalAlloc(NativeMethods.GMEM_MOVEABLE | NativeMethods.GMEM_DDESHARE, size);
            if (handle == IntPtr.Zero) {
                return (NativeMethods.E_OUTOFMEMORY);
            }
            IntPtr ptr = UnsafeNativeMethods.GlobalLock(new HandleRef(null, handle));
            if (ptr == IntPtr.Zero) {
                return (NativeMethods.E_OUTOFMEMORY);
            }
            try {
                byte[] bytes = new byte[size];
                stream.Position = 0;
                stream.Read(bytes, 0, size);
                Marshal.Copy(bytes, 0, ptr, size);
            }
            finally {
                UnsafeNativeMethods.GlobalUnlock(new HandleRef(null, handle));
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.SaveFileListToHandle"]/*' />
        /// <devdoc>
        ///     Saves a list of files out to the handle in HDROP format.
        /// </devdoc>
        /// <internalonly/>
        private int SaveFileListToHandle(IntPtr handle, string[] files) {
            if (files == null) {
                return NativeMethods.S_OK;
            }
            else if (files.Length < 1) {
                return NativeMethods.S_OK;
            }
            if (handle == IntPtr.Zero) {
                return (NativeMethods.E_INVALIDARG);
            }


            bool unicode = (Marshal.SystemDefaultCharSize != 1);

            IntPtr currentPtr = IntPtr.Zero;
            int baseStructSize =  4 + 8 + 4 + 4;
            int sizeInBytes = baseStructSize;

            // First determine the size of the array
            //
            if (unicode) {
                for (int i=0; i<files.Length; i++) {
                    sizeInBytes += (files[i].Length + 1) * 2;
                }
                sizeInBytes += 2;
            }
            else {
                for (int i=0; i<files.Length; i++) {
                    sizeInBytes += NativeMethods.Util.GetPInvokeStringLength(files[i]) + 1;
                }
                sizeInBytes ++;
            }

            // Alloc the Win32 memory
            //
            IntPtr newHandle = UnsafeNativeMethods.GlobalReAlloc(new HandleRef(null, handle),
                                                  sizeInBytes,
                                                  NativeMethods.GMEM_MOVEABLE | NativeMethods.GMEM_DDESHARE);
            if (newHandle == IntPtr.Zero) {
                return (NativeMethods.E_OUTOFMEMORY);
            }
            IntPtr basePtr = UnsafeNativeMethods.GlobalLock(new HandleRef(null, newHandle));
            if (basePtr == IntPtr.Zero) {
                return (NativeMethods.E_OUTOFMEMORY);
            }
            currentPtr = basePtr;

            // Write out the struct...
            //
            int[] structData = new int[] {baseStructSize, 0, 0, 0, 0};

            if (unicode) {
                structData[4] = unchecked((int)0xFFFFFFFF);
            }
            Marshal.Copy(structData, 0, currentPtr, structData.Length);
            currentPtr = (IntPtr)((long)currentPtr + baseStructSize);

            // Write out the strings...
            //
            for (int i=0; i<files.Length; i++) {
                if (unicode) {

                    // NOTE: DllLib.copy(char[]...) converts to ANSI on Windows 95...
                    UnsafeNativeMethods.CopyMemoryW(currentPtr, files[i], files[i].Length*2);
                    currentPtr = (IntPtr)((long)currentPtr + (files[i].Length * 2));
                    Marshal.Copy(new byte[]{0,0}, 0, currentPtr, 2);
                    currentPtr = (IntPtr)((long)currentPtr + 2);
                }
                else {
                    int pinvokeLen = NativeMethods.Util.GetPInvokeStringLength(files[i]);
                    UnsafeNativeMethods.CopyMemoryA(currentPtr, files[i], pinvokeLen);
                    currentPtr = (IntPtr)((long)currentPtr + pinvokeLen);
                    Marshal.Copy(new byte[]{0}, 0, currentPtr, 1);
                    currentPtr = (IntPtr)((long)currentPtr + 1);
                }
            }

            if (unicode) {
                Marshal.Copy(new char[]{'\0'}, 0, currentPtr, 1);
                currentPtr = (IntPtr)((long)currentPtr + 2);
            }
            else {
                Marshal.Copy(new byte[]{0}, 0, currentPtr, 1);
                currentPtr = (IntPtr)((long)currentPtr + 1);
            }

            UnsafeNativeMethods.GlobalUnlock(new HandleRef(null, newHandle));
            return NativeMethods.S_OK;
        }

        /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.SaveStringToHandle"]/*' />
        /// <devdoc>
        ///     Save string to handle. If unicode is set to true
        ///     then the string is saved as Unicode, else it is saves as DBCS.
        /// </devdoc>
        /// <internalonly/>
        private int SaveStringToHandle(IntPtr handle, string str, bool unicode) {
            if (handle == IntPtr.Zero) {
                return (NativeMethods.E_INVALIDARG);
            }
            IntPtr newHandle = IntPtr.Zero;
            if (unicode) {
                int byteSize = (str.Length*2 + 2);
                newHandle = UnsafeNativeMethods.GlobalReAlloc(new HandleRef(null, handle),
                                                  byteSize,
                                                  NativeMethods.GMEM_MOVEABLE
                                                  | NativeMethods.GMEM_DDESHARE
                                                  | NativeMethods.GMEM_ZEROINIT);
                if (newHandle == IntPtr.Zero) {
                    return (NativeMethods.E_OUTOFMEMORY);
                }
                IntPtr ptr = UnsafeNativeMethods.GlobalLock(new HandleRef(null, newHandle));
                if (ptr == IntPtr.Zero) {
                    return (NativeMethods.E_OUTOFMEMORY);
                }
                // NOTE: DllLib.copy(char[]...) converts to ANSI on Windows 95...
                char[] chars = str.ToCharArray(0, str.Length);
                UnsafeNativeMethods.CopyMemoryW(ptr, chars, chars.Length*2);
                //NativeMethods.CopyMemoryW(ptr, string, string.Length()*2);

            }
            else {


                int pinvokeSize = UnsafeNativeMethods.WideCharToMultiByte(0 /*CP_ACP*/, 0, str, str.Length, null, 0, IntPtr.Zero, IntPtr.Zero);

                byte[] strBytes = new byte[pinvokeSize];
                UnsafeNativeMethods.WideCharToMultiByte(0 /*CP_ACP*/, 0, str, str.Length, strBytes, strBytes.Length, IntPtr.Zero, IntPtr.Zero);

                newHandle = UnsafeNativeMethods.GlobalReAlloc(new HandleRef(null, handle),
                                                  pinvokeSize + 1,
                                                  NativeMethods.GMEM_MOVEABLE
                                                  | NativeMethods.GMEM_DDESHARE
                                                  | NativeMethods.GMEM_ZEROINIT);
                if (newHandle == IntPtr.Zero) {
                    return (NativeMethods.E_OUTOFMEMORY);
                }
                IntPtr ptr = UnsafeNativeMethods.GlobalLock(new HandleRef(null, newHandle));
                if (ptr == IntPtr.Zero) {
                    return (NativeMethods.E_OUTOFMEMORY);
                }
                UnsafeNativeMethods.CopyMemory(ptr, strBytes, pinvokeSize);
                Marshal.Copy(new byte[] {0}, 0, (IntPtr)((long)ptr+pinvokeSize), 1);
            }

            if (newHandle != IntPtr.Zero) {
                UnsafeNativeMethods.GlobalUnlock(new HandleRef(null, newHandle));
            }
            return NativeMethods.S_OK;
        }


        /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.SetData"]/*' />
        /// <devdoc>
        ///    <para>Stores the specified data and its associated format in 
        ///       this instance, using the automatic conversion parameter
        ///       to specify whether the
        ///       data can be converted to another format.</para>
        /// </devdoc>
        public virtual void SetData(string format, bool autoConvert, Object data) {
            Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "Set data: " + format + ", " + autoConvert.ToString() + ", " + data.ToString());
            Debug.Assert(innerData != null, "You must have an innerData on all DataObjects");
            innerData.SetData(format, autoConvert, data);
        }

        /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.SetData1"]/*' />
        /// <devdoc>
        ///    <para>Stores the specified data and its associated format in this
        ///       instance.</para>
        /// </devdoc>
        public virtual void SetData(string format, object data) {
            Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "Set data: " + format + ", " + data.ToString());
            Debug.Assert(innerData != null, "You must have an innerData on all DataObjects");
            innerData.SetData(format, data);
        }

        /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.SetData2"]/*' />
        /// <devdoc>
        ///    <para>Stores the specified data and
        ///       its
        ///       associated class type in this instance.</para>
        /// </devdoc>
        public virtual void SetData(Type format, object data) {
            Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "Set data: " + format.FullName + ", " + data.ToString());
            Debug.Assert(innerData != null, "You must have an innerData on all DataObjects");
            innerData.SetData(format, data);
        }

        /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.SetData3"]/*' />
        /// <devdoc>
        ///    <para>Stores the specified data in
        ///       this instance, using the class of the data for the format.</para>
        /// </devdoc>
        public virtual void SetData(object data) {
            Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "Set data: " + data.ToString());
            Debug.Assert(innerData != null, "You must have an innerData on all DataObjects");
            innerData.SetData(data);
        }

        /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.FormatEnumerator"]/*' />
        /// <devdoc>
        ///     Part of IOleDataObject, used to interop with OLE.
        /// </devdoc>
        /// <internalonly/>
        private class FormatEnumerator : UnsafeNativeMethods.IEnumFORMATETC {

            internal IDataObject parent = null;
            internal ArrayList formats = new ArrayList();
            internal int current = 0;

            public FormatEnumerator(IDataObject parent) : this(parent, parent.GetFormats()) {
                Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "FormatEnumerator: Constructed: " + parent.ToString());
            }

            public FormatEnumerator(IDataObject parent, NativeMethods.FORMATETC[] formats) {
                Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "FormatEnumerator: Constructed: " + parent.ToString() + ", FORMATETC[]" + formats.Length.ToString());
                NativeMethods.FORMATETC temp = null;
                this.formats.Clear();

                this.parent = parent;
                current = 0;

                if (formats != null) {
                    NativeMethods.FORMATETC currentFormat = null;

                    for (int i=0; i<formats.Length; i++) {
                        currentFormat = formats[i];

                        temp = new NativeMethods.FORMATETC();
                        temp.cfFormat = currentFormat.cfFormat;
                        temp.dwAspect = currentFormat.dwAspect;
                        temp.ptd = currentFormat.ptd;
                        temp.lindex = currentFormat.lindex;
                        temp.tymed = currentFormat.tymed;
                        this.formats.Add(temp);
                    }
                }
            }

            public FormatEnumerator(IDataObject parent, string[] formats) {
                Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "FormatEnumerator: Constructed: " + parent.ToString() + ", string[]" + formats.Length.ToString());
                NativeMethods.FORMATETC temp = null;

                this.parent = parent;
                this.formats.Clear();

                string bitmap = DataFormats.Bitmap;
                string emf = DataFormats.EnhancedMetafile;
                string text = DataFormats.Text;
                string unicode = DataFormats.UnicodeText;
                string standard = DataFormats.StringFormat;
                string str = DataFormats.StringFormat;

                if (formats != null) {
                    for (int i=0; i<formats.Length; i++) {
                        string format = formats[i];
                        temp = new NativeMethods.FORMATETC();
                        temp.cfFormat = (short)DataFormats.GetFormat(format).Id;
                        temp.dwAspect = DVASPECT_CONTENT;
                        temp.ptd = IntPtr.Zero;
                        temp.lindex = -1;

                        if (format.Equals(bitmap)) {
                            temp.tymed = TYMED_GDI;
                        }
                        else if (format.Equals(emf)) {
                            temp.tymed = TYMED_ENHMF;
                        }
                        else if (format.Equals(text)
                                 || format.Equals(unicode)
                                 || format.Equals(standard)
                                 || format.Equals(str)
                                 || format.Equals(DataFormats.Rtf)
                                 || format.Equals(DataFormats.CommaSeparatedValue)
                                 || format.Equals(DataFormats.FileDrop)
                                 || format.Equals(CF_DEPRECATED_FILENAME)
                                 || format.Equals(CF_DEPRECATED_FILENAMEW)) {

                            temp.tymed = TYMED_HGLOBAL;
                        }
                        else {
                            temp.tymed = TYMED_HGLOBAL;
                        }

                        if (temp.tymed != 0) {
                            this.formats.Add(temp);
                        }
                    }
                }
            }

            public virtual int Next(int celt, NativeMethods.FORMATETC rgelt, int[] pceltFetched) {
                Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "FormatEnumerator: Next");
                if (this.current < formats.Count) {

                    NativeMethods.FORMATETC current = (NativeMethods.FORMATETC)formats[this.current];
                    rgelt.cfFormat = current.cfFormat;
                    rgelt.tymed = current.tymed;
                    rgelt.dwAspect = DVASPECT_CONTENT;
                    rgelt.ptd = IntPtr.Zero;
                    rgelt.lindex = -1;

                    if (pceltFetched != null) {
                        pceltFetched[0] = 1;
                    }
                    this.current++;
                }
                else {
                    if (pceltFetched != null) {
                        pceltFetched[0] = 0;
                    }
                    return NativeMethods.S_FALSE;
                }
                return NativeMethods.S_OK;
            }

            public virtual int Skip(int celt) {
                Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "FormatEnumerator: Skip");
                current += celt;
                return NativeMethods.S_OK;
            }

            public virtual int Reset() {
                Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "FormatEnumerator: Reset");
                current = 0;
                return NativeMethods.S_OK;
            }

            public virtual int Clone(UnsafeNativeMethods.IEnumFORMATETC[] ppenum) {
                Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "FormatEnumerator: Clone");
                NativeMethods.FORMATETC[] temp = new NativeMethods.FORMATETC[formats.Count];
                formats.CopyTo(temp, 0);
                ppenum[0] = new FormatEnumerator(parent, temp);
                return NativeMethods.S_OK;
            }
        }

        /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.OleConverter"]/*' />
        /// <devdoc>
        ///     OLE Converter.  This class embodies the nastiness required to convert from our
        ///     managed types to standard OLE clipboard formats.
        /// </devdoc>
        private class OleConverter : IDataObject {
            internal UnsafeNativeMethods.IOleDataObject innerData;

            public OleConverter(UnsafeNativeMethods.IOleDataObject data) {
                Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "OleConverter: Constructed OleConverter");
                innerData = data;
            }

            /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.OleConverter.OleDataObject"]/*' />
            /// <devdoc>
            ///     Returns the data Object we are wrapping
            /// </devdoc>
            /// <internalonly/>
            public UnsafeNativeMethods.IOleDataObject OleDataObject {
                get {
                    return innerData;
                }
            }

            /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.OleConverter.GetTymedUseable"]/*' />
            /// <devdoc>
            ///     Returns true if the tymed is useable.
            /// </devdoc>
            /// <internalonly/>
            private bool GetTymedUseable(int tymed) {
                for (int i=0; i<ALLOWED_TYMEDS.Length; i++) {
                    if ((tymed & ALLOWED_TYMEDS[i]) != 0) {
                        return true;
                    }
                }
                return false;
            }

            /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.OleConverter.GetDataFromOleIStream"]/*' />
            /// <devdoc>
            ///     Uses IStream and retrieves the specified format from the bound IOleDataObject.
            /// </devdoc>
            /// <internalonly/>
            private Object GetDataFromOleIStream(string format) {

                NativeMethods.FORMATETC formatetc = new NativeMethods.FORMATETC();
                NativeMethods.STGMEDIUM medium = new NativeMethods.STGMEDIUM();

                formatetc.cfFormat = (short)DataFormats.GetFormat(format).Id;
                formatetc.dwAspect = DVASPECT_CONTENT;
                formatetc.lindex = -1;
                formatetc.tymed = TYMED_ISTREAM;

                medium.tymed = TYMED_ISTREAM;

                if (NativeMethods.S_OK != innerData.OleGetData(formatetc, medium)){
                    return null;
                }

                if (medium.unionmember != IntPtr.Zero) {
                    UnsafeNativeMethods.IStream pStream = (UnsafeNativeMethods.IStream)Marshal.GetObjectForIUnknown(medium.unionmember);
                    Marshal.Release(medium.unionmember);
                    NativeMethods.STATSTG sstg = new NativeMethods.STATSTG();
                    pStream.Stat(sstg, NativeMethods.STATFLAG_DEFAULT );
                    int size = (int)sstg.cbSize;

                    IntPtr hglobal = UnsafeNativeMethods.GlobalAlloc(NativeMethods.GMEM_MOVEABLE
                                                      | NativeMethods.GMEM_DDESHARE
                                                      | NativeMethods.GMEM_ZEROINIT,
                                                      size);
                    IntPtr ptr = UnsafeNativeMethods.GlobalLock(new HandleRef(innerData, hglobal));
                    pStream.Read(ptr, size);
                    UnsafeNativeMethods.GlobalUnlock(new HandleRef(innerData, hglobal));

                    return GetDataFromHGLOBLAL(format, hglobal);
                }

                return null;
            }


            /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.OleConverter.GetDataFromHGLOBLAL"]/*' />
            /// <devdoc>
            ///     Retrieves the specified form from the specified hglobal.
            /// </devdoc>
            /// <internalonly/>
            private Object GetDataFromHGLOBLAL(string format, IntPtr hglobal) {
                Object data = null;

                if (hglobal != IntPtr.Zero) {
                    //=----------------------------------------------------------------=
                    // Convert from OLE to IW objects
                    //=----------------------------------------------------------------=
                    // Add any new formats here...

                    if (format.Equals(DataFormats.Text)
                        || format.Equals(DataFormats.Rtf)
                        || format.Equals(DataFormats.Html)
                        || format.Equals(DataFormats.OemText)) {
                        data = ReadStringFromHandle(hglobal, false);
                    }
                    else if (format.Equals(DataFormats.UnicodeText)) {
                        data = ReadStringFromHandle(hglobal, true);
                    }
                    else if (format.Equals(DataFormats.FileDrop)) {
                        data = (Object)ReadFileListFromHandle(hglobal);
                    }
                    else if (format.Equals(CF_DEPRECATED_FILENAME)) {
                        data = new string[] {ReadStringFromHandle(hglobal, false)};
                    }
                    else if (format.Equals(CF_DEPRECATED_FILENAMEW)) {
                        data = new string[] {ReadStringFromHandle(hglobal, true)};
                    }
                    else {
                        data = ReadObjectFromHandle(hglobal);
                        /*
                        spb - 93835 dib support is a mess
                        if (format.Equals(DataFormats.Dib)
                            && data is Stream) {
                            data = new Bitmap((Stream)data);
                        }
                        */
                    }

                    UnsafeNativeMethods.GlobalFree(new HandleRef(null, hglobal));
                }

                return data;
            }

            /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.OleConverter.GetDataFromOleHGLOBAL"]/*' />
            /// <devdoc>
            ///     Uses HGLOBALs and retrieves the specified format from the bound IOleDataObject.
            /// </devdoc>
            /// <internalonly/>
            private Object GetDataFromOleHGLOBAL(string format) {
                Debug.Assert(innerData != null, "You must have an innerData on all DataObjects");

                NativeMethods.FORMATETC formatetc = new NativeMethods.FORMATETC();
                NativeMethods.STGMEDIUM medium = new NativeMethods.STGMEDIUM();

                formatetc.cfFormat = (short)DataFormats.GetFormat(format).Id;
                formatetc.dwAspect = DVASPECT_CONTENT;
                formatetc.lindex = -1;
                formatetc.tymed = TYMED_HGLOBAL;

                medium.tymed = TYMED_HGLOBAL;

                object data = null;
                innerData.OleGetData(formatetc, medium);

                if (medium.unionmember != IntPtr.Zero) {
                    data = GetDataFromHGLOBLAL(format, medium.unionmember);
                }

                return data;

            }

            /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.OleConverter.GetDataFromOleOther"]/*' />
            /// <devdoc>
            ///     Retrieves the specified format data from the bound IOleDataObject, from
            ///     other sources that IStream and HGLOBAL... this is really just a place
            ///     to put the "special" formats like BITMAP, ENHMF, etc.
            /// </devdoc>
            /// <internalonly/>
            private Object GetDataFromOleOther(string format) {
                Debug.Assert(innerData != null, "You must have an innerData on all DataObjects");

                NativeMethods.FORMATETC formatetc = new NativeMethods.FORMATETC();
                NativeMethods.STGMEDIUM medium = new NativeMethods.STGMEDIUM();

                int tymed = 0;

                if (format.Equals(DataFormats.Bitmap)) {
                    tymed = TYMED_GDI;
                }
                else if (format.Equals(DataFormats.EnhancedMetafile)) {
                    tymed = TYMED_ENHMF;
                }

                if (tymed == 0) {
                    return null;
                }

                formatetc.cfFormat = (short)DataFormats.GetFormat(format).Id;
                formatetc.dwAspect = DVASPECT_CONTENT;
                formatetc.lindex = -1;
                formatetc.tymed = tymed;
                medium.tymed = tymed;

                Object data = null;
                try {
                    innerData.OleGetData(formatetc, medium);
                }
                catch (Exception) {
                }

                if (medium.unionmember != IntPtr.Zero) {

                    if (format.Equals(DataFormats.Bitmap)
                        //||format.Equals(DataFormats.Dib))
                    ) { 
                        // as/urt 140870 -- GDI+ doesn't own this HBITMAP, but we can't
                        // delete it while the object is still around.  So we have to do the really crappy
                        // thing of cloning the image so we can release the HBITMAP.
                        //
                        Image clipboardImage = Image.FromHbitmap(medium.unionmember);
                        if (clipboardImage != null) {
                            Image firstImage = clipboardImage;
                            clipboardImage = (Image)clipboardImage.Clone();
                            SafeNativeMethods.DeleteObject(new HandleRef(null, medium.unionmember));
                            firstImage.Dispose();
                        }
                        data = clipboardImage;
                    }
/* gpr:
                    else if (format.Equals(DataFormats.EnhancedMetafile)) {
                        data = new Metafile(medium.unionmember);
                    }
*/
                }

                return data;
            }

            /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.OleConverter.GetDataFromBoundOleDataObject"]/*' />
            /// <devdoc>
            ///     Extracts a managed Object from the innerData of the specified
            ///     format. This is the base of the OLE to managed conversion.
            /// </devdoc>
            /// <internalonly/>
            private Object GetDataFromBoundOleDataObject(string format) {

                Object data = null;
                try {
                    data = GetDataFromOleOther(format);
                    if (data == null) {
                        data = GetDataFromOleHGLOBAL(format);
                    }
                    if (data == null) {
                        data = GetDataFromOleIStream(format);
                    }
                }
                catch (Exception e) {
                    Debug.Fail(e.ToString());
                }
                return data;
            }

            /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.OleConverter.ReadByteStreamFromHandle"]/*' />
            /// <devdoc>
            ///     Creates an Stream from the data stored in handle.
            /// </devdoc>
            /// <internalonly/>
            private Stream ReadByteStreamFromHandle(IntPtr handle, out bool isSerializedObject) {
                IntPtr ptr = UnsafeNativeMethods.GlobalLock(new HandleRef(null, handle));
                if (ptr == IntPtr.Zero){
                    throw new ExternalException("", NativeMethods.E_OUTOFMEMORY);
                }
                try {
                    int size = UnsafeNativeMethods.GlobalSize(new HandleRef(null, handle));
                    byte[] bytes = new byte[size];
                    Marshal.Copy(ptr, bytes, 0, size);
                    int index = 0; 
                    
                    // The object here can either be a stream or a serialized
                    // object.  We identify a serialized object by writing the
                    // bytes for the guid serializedObjectID at the front
                    // of the stream.  Check for that here.
                    //
                    if (size > serializedObjectID.Length) {
                        isSerializedObject = true;
                        for(int i = 0; i < serializedObjectID.Length; i++) {
                            if (serializedObjectID[i] != bytes[i]) {
                                isSerializedObject = false;
                                break;
                            }
                        }
                        
                        // Advance the byte pointer.
                        //
                        if (isSerializedObject) {
                            index = serializedObjectID.Length;
                        }
                    }
                    else {
                        isSerializedObject = false;
                    }
                    
                    return new MemoryStream(bytes, index, bytes.Length - index);
                }
                finally {
                    UnsafeNativeMethods.GlobalUnlock(new HandleRef(null, handle));
                }
            }

            /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.OleConverter.ReadObjectFromHandle"]/*' />
            /// <devdoc>
            ///     Creates a new instance of the Object that has been persisted into the
            ///     handle.
            /// </devdoc>
            /// <internalonly/>
            private Object ReadObjectFromHandle(IntPtr handle) {
                object value = null;
                
                bool isSerializedObject;
                Stream stream = ReadByteStreamFromHandle(handle, out isSerializedObject);
                
                if (isSerializedObject) {
                    BinaryFormatter formatter = new BinaryFormatter();
                    formatter.AssemblyFormat = FormatterAssemblyStyle.Simple;
                    value = formatter.Deserialize(stream);
                }
                else {
                    value = stream;
                }

                return value;
            }


            /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.OleConverter.ReadFileListFromHandle"]/*' />
            /// <devdoc>
            ///     Parses the HDROP format and returns a list of strings using
            ///     the DragQueryFile function.
            /// </devdoc>
            /// <internalonly/>
            private string[] ReadFileListFromHandle(IntPtr hdrop) {

                string[] files = null;
                StringBuilder sb = new StringBuilder(NativeMethods.MAX_PATH);

                int count = UnsafeNativeMethods.DragQueryFile(new HandleRef(null, hdrop), unchecked((int)0xFFFFFFFF), null, 0);
                if (count > 0) {
                    files = new string[count];


                    for (int i=0; i<count; i++) {
                        int charlen = UnsafeNativeMethods.DragQueryFile(new HandleRef(null, hdrop), i, sb, sb.Capacity);
                        string s = sb.ToString();
                        if (s.Length > charlen) {
                            s = s.Substring(0, charlen);
                        }

                        // SECREVIEW : do we really need to do this?
                        //
                        Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "FileIO(" + s + ") Demanded");
                        new FileIOPermission(FileIOPermissionAccess.AllAccess, s).Demand();
                        files[i] = s;
                    }
                }

                return files;
            }

            /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.OleConverter.ReadStringFromHandle"]/*' />
            /// <devdoc>
            ///     Creates a string from the data stored in handle. If
            ///     unicode is set to true, then the string is assume to be Unicode,
            ///     else DBCS (ASCI) is assumed.
            /// </devdoc>
            /// <internalonly/>
            private unsafe string ReadStringFromHandle(IntPtr handle, bool unicode) {
                string stringData = null;
                
                IntPtr ptr = UnsafeNativeMethods.GlobalLock(new HandleRef(null, handle));
                try {
                    if (unicode) {
                        stringData = new string((char*)ptr);
                    }
                    else {
                        stringData = new string((sbyte*)ptr);
                    }
                }
                finally {
                    UnsafeNativeMethods.GlobalUnlock(new HandleRef(null, handle));
                }

                return stringData;
            }            

            //=------------------------------------------------------------------------=
            // IDataObject
            //=------------------------------------------------------------------------=
            public virtual Object GetData(string format, bool autoConvert) {
                Object baseVar = GetDataFromBoundOleDataObject(format);
                Object original = baseVar;

                if (autoConvert && (baseVar == null || baseVar is MemoryStream)) {
                    string[] mappedFormats = GetMappedFormats(format);
                    if (mappedFormats != null) {
                        for (int i=0; i<mappedFormats.Length; i++) {
                            if (!format.Equals(mappedFormats[i])) {
                                baseVar = GetDataFromBoundOleDataObject(mappedFormats[i]);
                                if (baseVar != null && !(baseVar is MemoryStream)) {
                                    original = null;
                                    break;
                                }
                            }
                        }
                    }
                }

                if (original != null) {
                    return original;
                }
                else {
                    return baseVar;
                }
            }

            public virtual Object GetData(string format) {
                return GetData(format, true);
            }

            public virtual Object GetData(Type format) {
                return GetData(format.FullName);
            }

            public virtual void SetData(string format, bool autoConvert, Object data) {
                // CONSIDER : ChrisAn, 11/13/1997 - If we want to support setting
                //          : Data onto an OLE data Object, that code goes here...
                //
            }
            public virtual void SetData(string format, Object data) {
                SetData(format, true, data);
            }

            public virtual void SetData(Type format, Object data) {
                SetData(format.FullName, data);
            }

            public virtual void SetData(Object data) {
                if (data is ISerializable) {
                    SetData(DataFormats.Serializable, data);
                }
                else {
                    SetData(data.GetType(), data);
                }
            }

            public virtual bool GetDataPresent(Type format) {
                return GetDataPresent(format.FullName);
            }

            private bool GetDataPresentInner(string format) {
                Debug.Assert(innerData != null, "You must have an innerData on all DataObjects");
                NativeMethods.FORMATETC formatetc = new NativeMethods.FORMATETC();
                formatetc.cfFormat = (short)DataFormats.GetFormat(format).Id;
                formatetc.dwAspect = DVASPECT_CONTENT;
                formatetc.lindex = -1;

                for (int i=0; i<ALLOWED_TYMEDS.Length; i++) {
                    formatetc.tymed |= ALLOWED_TYMEDS[i];
                }

                int hr = innerData.OleQueryGetData(formatetc);
                return (hr == NativeMethods.S_OK);
            }

            public virtual bool GetDataPresent(string format, bool autoConvert) {
                bool baseVar = GetDataPresentInner(format);

                if (!baseVar && autoConvert) {
                    string[] mappedFormats = GetMappedFormats(format);
                    if (mappedFormats != null) {
                        for (int i=0; i<mappedFormats.Length; i++) {
                            if (!format.Equals(mappedFormats[i])) {
                                baseVar = GetDataPresentInner(mappedFormats[i]);
                                if (baseVar) {
                                    break;
                                }
                            }
                        }
                    }
                }
                return baseVar;
            }

            public virtual bool GetDataPresent(string format) {
                return GetDataPresent(format, true);
            }

            public virtual string[] GetFormats(bool autoConvert) {
                Debug.Assert(innerData != null, "You must have an innerData on all DataObjects");

                UnsafeNativeMethods.IEnumFORMATETC enumFORMATETC = null;
                ArrayList formats = new ArrayList();
                try {
                    enumFORMATETC = innerData.OleEnumFormatEtc(DATADIR_GET);
                }
                catch (Exception) {
                }

                if (enumFORMATETC != null) {
                    enumFORMATETC.Reset();

                    NativeMethods.FORMATETC formatetc = new NativeMethods.FORMATETC();
                    int[] retrieved = new int[] {1};

                    while (retrieved[0] > 0) {
                        retrieved[0] = 0;
                        try {
                            enumFORMATETC.Next(1, formatetc, retrieved);
                        }
                        catch (Exception) {
                        }


                        if (retrieved[0] > 0) {
                            string name = DataFormats.GetFormat(formatetc.cfFormat).Name;
                            if (autoConvert) {
                                string[] mappedFormats = GetMappedFormats(name);
                                for (int i=0; i<mappedFormats.Length; i++) {
                                    formats.Add(mappedFormats[i]);
                                }
                            }
                            else {
                                formats.Add(name);
                            }
                        }
                    }
                }

                string[] temp = new string[formats.Count];
                formats.CopyTo(temp, 0);
                return GetDistinctStrings(temp);
            }

            public virtual string[] GetFormats() {
                return GetFormats(true);
            }
        }

        //--------------------------------------------------------------------------
        // Data Store
        //--------------------------------------------------------------------------

        /// <include file='doc\DataObject.uex' path='docs/doc[@for="DataObject.DataStore"]/*' />
        /// <devdoc>
        /// </devdoc>
        private class DataStore : IDataObject {
            private class DataStoreEntry {
                public Object data;
                public bool autoConvert;

                public DataStoreEntry(Object data, bool autoConvert) {
                    this.data = data;
                    this.autoConvert = autoConvert;
                }
            }

            private Hashtable data = new Hashtable();

            public DataStore() {
                Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "DataStore: Constructed DataStore");
            }

            public virtual Object GetData(string format, bool autoConvert) {
                Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "DataStore: GetData: " + format + ", " + autoConvert.ToString());
                DataStoreEntry dse = (DataStoreEntry)data[format];
                Object baseVar = null;
                if (dse != null) {
                    baseVar = dse.data;
                }
                Object original = baseVar;

                if (autoConvert
                    && (dse == null || dse.autoConvert)
                    && (baseVar == null || baseVar is MemoryStream)) {

                    string[] mappedFormats = GetMappedFormats(format);
                    if (mappedFormats != null) {
                        for (int i=0; i<mappedFormats.Length; i++) {
                            if (!format.Equals(mappedFormats[i])) {
                                DataStoreEntry found = (DataStoreEntry)data[mappedFormats[i]];
                                if (found != null) {
                                    baseVar = found.data;
                                }
                                if (baseVar != null && !(baseVar is MemoryStream)) {
                                    original = null;
                                    break;
                                }
                            }
                        }
                    }
                }

                if (original != null) {
                    return original;
                }
                else {
                    return baseVar;
                }
            }

            public virtual Object GetData(string format) {
                Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "DataStore: GetData: " + format);
                return GetData(format, true);
            }

            public virtual Object GetData(Type format) {
                Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "DataStore: GetData: " + format.FullName);
                return GetData(format.FullName);
            }            

            public virtual void SetData(string format, bool autoConvert, Object data) {
                Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "DataStore: SetData: " + format + ", " + autoConvert.ToString() + ", " + data.ToString());

                // We do not have proper support for Dibs, so if the user explicitly asked
                // for Dib and provided a Bitmap object we can't convert.  Instead, publish as an HBITMAP
                // and let the system provide the conversion for us.
                //
                if (data is Bitmap && format.Equals(DataFormats.Dib)) {
                    if (autoConvert) {
                        format = DataFormats.Bitmap;
                    }
                    else {
                        throw new NotSupportedException(SR.GetString(SR.DataObjectDibNotSupported));
                    }
                }

                this.data[format] = new DataStoreEntry(data, autoConvert);
            }
            public virtual void SetData(string format, Object data) {
                Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "DataStore: SetData: " + format + ", " + data.ToString());
                SetData(format, true, data);
            }

            public virtual void SetData(Type format, Object data) {
                Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "DataStore: SetData: " + format.FullName + ", " + data.ToString());
                SetData(format.FullName, data);
            }

            public virtual void SetData(Object data) {
                Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "DataStore: SetData: " + data.ToString());
                if (data is ISerializable
                    && !this.data.ContainsKey(DataFormats.Serializable)) {

                    SetData(DataFormats.Serializable, data);
                }

                SetData(data.GetType(), data);
            }

            public virtual bool GetDataPresent(Type format) {
                Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "DataStore: GetDataPresent: " + format.FullName);
                return GetDataPresent(format.FullName);
            }

            public virtual bool GetDataPresent(string format, bool autoConvert) {
                Debug.Assert(format != null, "Null format passed in");
                Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "DataStore: GetDataPresent: " + format + ", " + autoConvert.ToString());

                if (!autoConvert) {
                    Debug.Assert(data != null, "data must be non-null");
                    return data.ContainsKey(format);
                }
                else {
                    string[] formats = GetFormats(autoConvert);
                    Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "DataStore:  got " + formats.Length.ToString() + " formats from get formats");
                    Debug.Assert(formats != null, "Null returned from GetFormats");
                    for (int i=0; i<formats.Length; i++) {
                        Debug.Assert(formats[i] != null, "Null format inside of formats at index " + i.ToString());
                        if (format.Equals(formats[i])) {
                            Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "DataStore: GetDataPresent: returning true");
                            return true;
                        }
                    }
                    Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "DataStore: GetDataPresent: returning false");
                    return false;
                }
            }

            public virtual bool GetDataPresent(string format) {
                Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "DataStore: GetDataPresent: " + format);
                return GetDataPresent(format, true);
            }

            public virtual string[] GetFormats(bool autoConvert) {
                Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "DataStore: GetFormats: " + autoConvert.ToString());
                Debug.Assert(data != null, "data collection can't be null");
                Debug.Assert(data.Keys != null, "data Keys collection can't be null");

                string [] baseVar = new string[data.Keys.Count];
                data.Keys.CopyTo(baseVar, 0);
                Debug.Assert(baseVar != null, "Collections should never return NULL arrays!!!");
                if (autoConvert) {
                    Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "DataStore: applying autoConvert");

                    ArrayList formats = new ArrayList();
                    for (int i=0; i<baseVar.Length; i++) {
                        Debug.Assert(data[baseVar[i]] != null, "Null item in data collection with key '" + baseVar[i] + "'");
                        if (((DataStoreEntry)data[baseVar[i]]).autoConvert) {

                            string[] cur = GetMappedFormats(baseVar[i]);
                            Debug.Assert(cur != null, "GetMappedFormats returned null for '" + baseVar[i] + "'");
                            for (int j=0; j<cur.Length; j++) {
                                formats.Add(cur[j]);
                            }
                        }
                        else {
                            formats.Add(baseVar[i]);
                        }
                    }

                    string[] temp = new string[formats.Count];
                    formats.CopyTo(temp, 0);
                    baseVar = GetDistinctStrings(temp);
                }
                Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "DataStore: returing " + baseVar.Length.ToString() + " formats from GetFormats");
                return baseVar;
            }
            public virtual string[] GetFormats() {
                Debug.WriteLineIf(CompModSwitches.DataObject.TraceVerbose, "DataStore: GetFormats");
                return GetFormats(true);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\dockstyle.cs ===
//------------------------------------------------------------------------------
// <copyright file="DockStyle.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Drawing.Design;
    using Microsoft.Win32;


    /*
     * Copyright (c) 1997, Microsoft Corporation. All Rights Reserved.
     * Information Contained Herein is Proprietary and Confidential.
     */



    /// <include file='doc\DockStyle.uex' path='docs/doc[@for="DockStyle"]/*' />
    /// <devdoc>
    ///     Control Dock values.
    ///
    ///     When a control is docked to an edge of it's container it will
    ///     always be positioned flush against that edge while the container
    ///     resizes. If more than one control is docked to an edge, the controls
    ///     will not be placed on top of each other.
    /// </devdoc>
    [
    Editor("System.Windows.Forms.Design.DockEditor, " + AssemblyRef.SystemDesign, typeof(UITypeEditor))
    ]
    public enum DockStyle {
        /// <include file='doc\DockStyle.uex' path='docs/doc[@for="DockStyle.None"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        None   = 0,
        /// <include file='doc\DockStyle.uex' path='docs/doc[@for="DockStyle.Top"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Top    = 1,
        /// <include file='doc\DockStyle.uex' path='docs/doc[@for="DockStyle.Bottom"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Bottom = 2,
        /// <include file='doc\DockStyle.uex' path='docs/doc[@for="DockStyle.Left"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Left   = 3,
        /// <include file='doc\DockStyle.uex' path='docs/doc[@for="DockStyle.Right"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Right  = 4,
        /// <include file='doc\DockStyle.uex' path='docs/doc[@for="DockStyle.Fill"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Fill   = 5,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\dragaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="DragAction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Drawing;
    using System.ComponentModel;
    using Microsoft.Win32;


    /// <include file='doc\DragAction.uex' path='docs/doc[@for="DragAction"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies how and if a drag-and-drop operation should continue.
    ///    </para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public enum DragAction {
        /// <include file='doc\DragAction.uex' path='docs/doc[@for="DragAction.Continue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The operation will continue.
        ///    </para>
        /// </devdoc>
        Continue = 0,
        /// <include file='doc\DragAction.uex' path='docs/doc[@for="DragAction.Drop"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The operation will stop with a drop.
        ///    </para>
        /// </devdoc>
        Drop = 1,
        /// <include file='doc\DragAction.uex' path='docs/doc[@for="DragAction.Cancel"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The operation is canceled with no
        ///       drop message.
        ///       
        ///    </para>
        /// </devdoc>
        Cancel = 2,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\dragdropeffects.cs ===
//------------------------------------------------------------------------------
// <copyright file="DragDropEffects.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Drawing;
    using System.ComponentModel;
    using Microsoft.Win32;


    /// <include file='doc\DragDropEffects.uex' path='docs/doc[@for="DragDropEffects"]/*' />
    /// <devdoc>
    ///    <para>Specifies the effects of a drag-and-drop
    ///       operation.</para>
    /// </devdoc>
    [Flags]
    public enum DragDropEffects {

        /// <include file='doc\DragDropEffects.uex' path='docs/doc[@for="DragDropEffects.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The
        ///       drop target does not accept the data.
        ///       
        ///    </para>
        /// </devdoc>
        None = 0x00000000,
        /// <include file='doc\DragDropEffects.uex' path='docs/doc[@for="DragDropEffects.Copy"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The data is copied to the drop
        ///       target.
        ///       
        ///    </para>
        /// </devdoc>
        Copy = 0x00000001,
        /// <include file='doc\DragDropEffects.uex' path='docs/doc[@for="DragDropEffects.Move"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The data from the drag source is moved to the drop
        ///       target.
        ///    </para>
        /// </devdoc>
        Move = 0x00000002,
        /// <include file='doc\DragDropEffects.uex' path='docs/doc[@for="DragDropEffects.Link"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The data fromt the drag source is
        ///       linked to the drop target.
        ///    </para>
        /// </devdoc>
        Link = 0x00000004,
        /// <include file='doc\DragDropEffects.uex' path='docs/doc[@for="DragDropEffects.Scroll"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Scrolling is about to start or is currently occurring in the drop target.
        ///    </para>
        /// </devdoc>
        Scroll = unchecked(unchecked((int)0x80000000)),
        /// <include file='doc\DragDropEffects.uex' path='docs/doc[@for="DragDropEffects.All"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The data is copied,
        ///       removed from the drag source, and scrolled in the drop target.
        ///    </para>
        /// </devdoc>
        All = Copy | Move | Scroll,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\debughandletracker.cs ===
//------------------------------------------------------------------------------
// <copyright file="DebugHandleTracker.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using Microsoft.Win32;
    using System;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Runtime.InteropServices;

    using Hashtable = System.Collections.Hashtable;

    /// <include file='doc\DebugHandleTracker.uex' path='docs/doc[@for="DebugHandleTracker"]/*' />
    /// <devdoc>
    ///     The job of this class is to collect and track handle usage in
    ///     windows forms.  Ideally, a developer should never have to call dispose() on
    ///     any windows forms object.  The problem in making this happen is in objects that
    ///     are very small to the VM garbage collector, but take up huge amounts
    ///     of resources to the system.  A good example of this is a Win32 region
    ///     handle.  To the VM, a Region object is a small six ubyte object, so there
    ///     isn't much need to garbage collect it anytime soon.  To Win32, however,
    ///     a region handle consumes expensive USER and GDI resources.  Ideally we
    ///     would like to be able to mark an object as "expensive" so it uses a different
    ///     garbage collection algorithm.  In absence of that, we use the HandleCollector class, which
    ///     runs a daemon thread to garbage collect when handle usage goes up.
    /// </devdoc>
    /// <internalonly/>
    internal class DebugHandleTracker {
    #if DEBUG

        private static Hashtable           handleTypes = new Hashtable();
        //not used... private static int                 handleTypeCount;
        private static DebugHandleTracker  tracker;

        static DebugHandleTracker() {
            tracker = new DebugHandleTracker();

            if (CompModSwitches.HandleLeak.Level > TraceLevel.Off || CompModSwitches.TraceCollect.Enabled) {
                HandleCollector.HandleAdded += new HandleChangeEventHandler(tracker.OnHandleAdd);
                HandleCollector.HandleRemoved += new HandleChangeEventHandler(tracker.OnHandleRemove);
            }
        }
    #endif

        private DebugHandleTracker() {
        }

    #if DEBUG
        /// <include file='doc\DebugHandleTracker.uex' path='docs/doc[@for="DebugHandleTracker.CheckLeaks"]/*' />
        /// <devdoc>
        ///     Called at shutdown to check for handles that are currently allocated.
        ///     Normally, there should be none.  This will print a list of all
        ///     handle leaks.
        /// </devdoc>
        /** @conditional(DEBUG) */
        public static void CheckLeaks() {
            lock(typeof(DebugHandleTracker)) {
                if (CompModSwitches.HandleLeak.Level >= TraceLevel.Warning) {
                    GC.Collect();
                    HandleType[] types = new HandleType[handleTypes.Values.Count];
                    handleTypes.Values.CopyTo(types, 0);

                    for (int i = 0; i < types.Length; i++) {
                        if (types[i] != null) {
                            types[i].CheckLeaks();
                        }
                    }
                }
            }
        }

        /// <include file='doc\DebugHandleTracker.uex' path='docs/doc[@for="DebugHandleTracker.Initialize"]/*' />
        /// <devdoc>
        ///     Ensures leak detection has been initialized.
        /// </devdoc>
        /** @conditional(DEBUG) */
        public static void Initialize() {
            // Calling this method forces the class to be loaded, thus running the
            // static constructor which does all the work.
        }

        /// <include file='doc\DebugHandleTracker.uex' path='docs/doc[@for="DebugHandleTracker.OnHandleAdd"]/*' />
        /// <devdoc>
        ///     Called by the Win32 handle collector when a new handle is created.
        /// </devdoc>
        /** @conditional(DEBUG) */
        private void OnHandleAdd(string handleName, IntPtr handle, int handleCount) {
            HandleType type = (HandleType)handleTypes[handleName];
            if (type == null) {
                type = new HandleType(handleName);
                handleTypes[handleName] = type;
            }
            type.Add(handle);
        }

        /// <include file='doc\DebugHandleTracker.uex' path='docs/doc[@for="DebugHandleTracker.OnHandleRemove"]/*' />
        /// <devdoc>
        ///     Called by the Win32 handle collector when a new handle is created.
        /// </devdoc>
        /** @conditional(DEBUG) */
        private void OnHandleRemove(string handleName, IntPtr handle, int HandleCount) {
            HandleType type = (HandleType)handleTypes[handleName];
            if (type != null) {
                bool removed = type.Remove(handle);
                // It seems to me we shouldn't call HandleCollector.Remove more than once
                // for a given handle, but we do just that for HWND's (NativeWindow.DestroyWindow
                // and Control.WmNCDestroy).
                // Debug.Assert(removed, "Couldn't find handle " + Convert.ToString(handle, 16) + " of type "
                //              + handleName + " when asked to remove it");
            }
        }

        /// <include file='doc\DebugHandleTracker.uex' path='docs/doc[@for="DebugHandleTracker.HandleType"]/*' />
        /// <devdoc>
        ///     Represents a specific type of handle.
        /// </devdoc>
        private class HandleType {
            public readonly string name;

            private int handleCount;
            private HandleEntry[] buckets;

            private const int BUCKETS = 10;

            /// <include file='doc\DebugHandleTracker.uex' path='docs/doc[@for="DebugHandleTracker.HandleType.HandleType"]/*' />
            /// <devdoc>
            ///     Creates a new handle type.
            /// </devdoc>
            public HandleType(string name) {
                this.name = name;
                this.handleCount = 0;
                this.buckets = new HandleEntry[BUCKETS];
            }

            /// <include file='doc\DebugHandleTracker.uex' path='docs/doc[@for="DebugHandleTracker.HandleType.Add"]/*' />
            /// <devdoc>
            ///     Adds a handle to this handle type for monitoring.
            /// </devdoc>
            public void Add(IntPtr handle) {
                lock(this) {
                    int hash = ComputeHash(handle);
                    if (CompModSwitches.HandleLeak.Level >= TraceLevel.Info) {
                        Debug.WriteLine("-------------------------------------------------");
                        Debug.WriteLine("Handle Allocating: " + Convert.ToString((int)handle, 16));
                        Debug.WriteLine("Handle Type      : " + name);
                        if (CompModSwitches.HandleLeak.Level >= TraceLevel.Verbose)
                            Debug.WriteLine(Environment.StackTrace);
                    }

                    HandleEntry entry = buckets[hash];
                    while (entry != null) {
                        Debug.Assert(entry.handle != handle, "Duplicate handle of type " + name);
                        entry = entry.next;
                    }

                    buckets[hash] = new HandleEntry(buckets[hash], handle);
                    handleCount++;
                }
            }

            /// <include file='doc\DebugHandleTracker.uex' path='docs/doc[@for="DebugHandleTracker.HandleType.CheckLeaks"]/*' />
            /// <devdoc>
            ///     Checks and reports leaks for handle monitoring.
            /// </devdoc>
            public void CheckLeaks() {
                lock(this) {
                    if (handleCount > 0) {
                        Debug.WriteLine("\r\nHandle leaks detected for handles of type " + name + ":");
                        for (int i = 0; i < BUCKETS; i++) {
                            HandleEntry e = buckets[i];
                            while (e != null) {
                                Debug.WriteLine(e.ToString(this));
                                e = e.next;
                            }
                        }
                    }
                }
            }

            /// <include file='doc\DebugHandleTracker.uex' path='docs/doc[@for="DebugHandleTracker.HandleType.ComputeHash"]/*' />
            /// <devdoc>
            ///     Computes the hash bucket for this handle.
            /// </devdoc>
            private int ComputeHash(IntPtr handle) {
                return((int)handle & 0xFFFF) % BUCKETS;
            }

            /// <include file='doc\DebugHandleTracker.uex' path='docs/doc[@for="DebugHandleTracker.HandleType.Remove"]/*' />
            /// <devdoc>
            ///     Removes the given handle from our monitor list.
            /// </devdoc>
            public bool Remove(IntPtr handle) {
                lock(this) {
                    int hash = ComputeHash(handle);
                    if (CompModSwitches.HandleLeak.Level >= TraceLevel.Info) {
                        Debug.WriteLine("-------------------------------------------------");
                        Debug.WriteLine("Handle Releaseing: " + Convert.ToString((int)handle, 16));
                        Debug.WriteLine("Handle Type      : " + name);
                        if (CompModSwitches.HandleLeak.Level >= TraceLevel.Verbose)
                            Debug.WriteLine(Environment.StackTrace);
                    }
                    HandleEntry e = buckets[hash];
                    HandleEntry last = null;
                    while (e != null && e.handle != handle) {
                        last = e;
                        e = e.next;
                    }
                    if (e != null) {
                        if (last == null) {
                            buckets[hash] = e.next;
                        }
                        else {
                            last.next = e.next;
                        }
                        handleCount--;
                        return true;
                    }
                    return false;
                }
            }

            /// <include file='doc\DebugHandleTracker.uex' path='docs/doc[@for="DebugHandleTracker.HandleType.HandleEntry"]/*' />
            /// <devdoc>
            ///     Denotes a single entry in our handle list.
            /// </devdoc>
            private class HandleEntry {
                public readonly IntPtr handle;
                public HandleEntry next;

                #if DEBUG
                public readonly string callStack;
                #endif // DEBUG

                /// <include file='doc\DebugHandleTracker.uex' path='docs/doc[@for="DebugHandleTracker.HandleType.HandleEntry.HandleEntry"]/*' />
                /// <devdoc>
                ///     Creates a new handle entry
                /// </devdoc>
                public HandleEntry(HandleEntry next, IntPtr handle) {
                    this.handle = handle;
                    this.next = next;

                    #if DEBUG
                    if (CompModSwitches.HandleLeak.Level > TraceLevel.Off) {
                        this.callStack = Environment.StackTrace;
                    }
                    else {
                        this.callStack = null;
                    }
                    #endif // DEBUG
                }

                /// <include file='doc\DebugHandleTracker.uex' path='docs/doc[@for="DebugHandleTracker.HandleType.HandleEntry.ToString"]/*' />
                /// <devdoc>
                ///     Converts this handle to a printable string.  the string consists
                ///     of the handle value along with the callstack for it's
                ///     allocation.
                /// </devdoc>
                public string ToString(HandleType type) {
                    StackParser sp = new StackParser(callStack);

                    // Discard all of the stack up to and including the "Handle.create" call
                    //
                    sp.DiscardTo("HandleCollector.Add");

                    // Skip the next call as it is always a debug wrapper
                    //
                    sp.DiscardNext();

                    // Now recreate the leak list with ten stack entries maximum, and
                    // put it all on one line.
                    //
                    sp.Truncate(10);

                    string description = "";
                    if (type.name.Equals("GDI") || type.name.Equals("HDC")) {
                        int objectType = UnsafeNativeMethods.GetObjectType(new HandleRef(null, handle));
                        switch (objectType) {
                            case NativeMethods.OBJ_DC: description = "normal DC"; break;
                            case NativeMethods.OBJ_MEMDC: description = "memory DC"; break;
                            case NativeMethods.OBJ_METADC: description = "metafile DC"; break;
                            case NativeMethods.OBJ_ENHMETADC: description = "enhanced metafile DC"; break;

                            case NativeMethods.OBJ_PEN: description = "Pen"; break;
                            case NativeMethods.OBJ_BRUSH: description = "Brush"; break;
                            case NativeMethods.OBJ_PAL: description = "Palette"; break;
                            case NativeMethods.OBJ_FONT: description = "Font"; break;
                            case NativeMethods.OBJ_BITMAP: description = "Bitmap"; break;
                            case NativeMethods.OBJ_REGION: description = "Region"; break;
                            case NativeMethods.OBJ_METAFILE: description = "Metafile"; break;
                            case NativeMethods.OBJ_EXTPEN: description = "Extpen"; break;
                            default: description = "?"; break;
                        }
                        description = " (" + description + ")";
                    }

                    return Convert.ToString((int)handle, 16) + description + ": " + sp.ToString();
                }

                /// <include file='doc\DebugHandleTracker.uex' path='docs/doc[@for="DebugHandleTracker.HandleType.HandleEntry.StackParser"]/*' />
                /// <devdoc>
                ///     Simple stack parsing class to manipulate our callstack.
                /// </devdoc>
                private class StackParser {
                    internal string releventStack;
                    internal int startIndex;
                    internal int endIndex;
                    internal int length;

                    /// <include file='doc\DebugHandleTracker.uex' path='docs/doc[@for="DebugHandleTracker.HandleType.HandleEntry.StackParser.StackParser"]/*' />
                    /// <devdoc>
                    ///     Creates a new stackparser with the given callstack
                    /// </devdoc>
                    public StackParser(string callStack) {
                        releventStack = callStack;
                        startIndex = 0;
                        endIndex = 0;
                        length = releventStack.Length;
                    }

                    /// <include file='doc\DebugHandleTracker.uex' path='docs/doc[@for="DebugHandleTracker.HandleType.HandleEntry.StackParser.ContainsString"]/*' />
                    /// <devdoc>
                    ///     Determines if the given string contains token.  This is a case
                    ///     sensitive match.
                    /// </devdoc>
                    private static bool ContainsString(string str, string token) {
                        int stringLength = str.Length;
                        int tokenLength = token.Length;

                        for (int s = 0; s < stringLength; s++) {
                            int t = 0;
                            while (t < tokenLength && str[s + t] == token[t]) {
                                t++;
                            }
                            if (t == tokenLength) {
                                return true;
                            }
                        }
                        return false;
                    }

                    /// <include file='doc\DebugHandleTracker.uex' path='docs/doc[@for="DebugHandleTracker.HandleType.HandleEntry.StackParser.DiscardNext"]/*' />
                    /// <devdoc>
                    ///     Discards the next line of the stack trace.
                    /// </devdoc>
                    public void DiscardNext() {
                        GetLine();
                    }

                    /// <include file='doc\DebugHandleTracker.uex' path='docs/doc[@for="DebugHandleTracker.HandleType.HandleEntry.StackParser.DiscardTo"]/*' />
                    /// <devdoc>
                    ///     Discards all lines up to and including the line that contains
                    ///     discardText.
                    /// </devdoc>
                    public void DiscardTo(string discardText) {
                        while (startIndex < length) {
                            string line = GetLine();
                            if (line == null || ContainsString(line, discardText)) {
                                break;
                            }
                        }
                    }

                    /// <include file='doc\DebugHandleTracker.uex' path='docs/doc[@for="DebugHandleTracker.HandleType.HandleEntry.StackParser.GetLine"]/*' />
                    /// <devdoc>
                    ///     Retrieves the next line of the stack.
                    /// </devdoc>
                    private string GetLine() {
                        endIndex = releventStack.IndexOf('\r', startIndex);
                        if (endIndex < 0) {
                            endIndex = length - 1;
                        }

                        string line = releventStack.Substring(startIndex, endIndex - startIndex);
                        char ch;

                        while (endIndex < length && ((ch = releventStack[endIndex]) == '\r' || ch == '\n')) {
                            endIndex++;
                        }
                        if (startIndex == endIndex) return null;
                        startIndex = endIndex;
                        line = line.Replace('\t', ' ');
                        return line;
                    }

                    /// <include file='doc\DebugHandleTracker.uex' path='docs/doc[@for="DebugHandleTracker.HandleType.HandleEntry.StackParser.ToString"]/*' />
                    /// <devdoc>
                    ///     Rereives the string of the parsed stack trace
                    /// </devdoc>
                    public override string ToString() {
                        return releventStack.Substring(startIndex);
                    }

                    /// <include file='doc\DebugHandleTracker.uex' path='docs/doc[@for="DebugHandleTracker.HandleType.HandleEntry.StackParser.Truncate"]/*' />
                    /// <devdoc>
                    ///     Truncates the stack trace, saving the given # of lines.
                    /// </devdoc>
                    public void Truncate(int lines) {
                        string truncatedStack = "";

                        while (lines-- > 0 && startIndex < length) {
                            if (truncatedStack == null) {
                                truncatedStack = GetLine();
                            }
                            else {
                                truncatedStack += ": " + GetLine();
                            }
                        }

                        releventStack = truncatedStack;
                        startIndex = 0;
                        endIndex = 0;
                        length = releventStack.Length;
                    }
                }
            }
        }

    #endif // DEBUG
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\dragevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="DragEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Drawing;
    using System.Windows.Forms;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\DragEvent.uex' path='docs/doc[@for="DragEventArgs"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides data for the <see cref='System.Windows.Forms.Control.DragDrop'/>, <see cref='System.Windows.Forms.Control.DragEnter'/>, or <see cref='System.Windows.Forms.Control.DragOver'/> event.
    ///    </para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public class DragEventArgs : EventArgs {
        /// <include file='doc\DragEvent.uex' path='docs/doc[@for="DragEventArgs.data"]/*' />
        /// <devdoc>
        ///     The data associated with this event.
        /// </devdoc>
        private readonly IDataObject data;
        /// <include file='doc\DragEvent.uex' path='docs/doc[@for="DragEventArgs.keyState"]/*' />
        /// <devdoc>
        ///     The current state of the shift, ctrl, and alt keys.
        /// </devdoc>
        private readonly int keyState;
        /// <include file='doc\DragEvent.uex' path='docs/doc[@for="DragEventArgs.x"]/*' />
        /// <devdoc>
        ///     The mouse x location.
        /// </devdoc>
        private readonly int x;
        /// <include file='doc\DragEvent.uex' path='docs/doc[@for="DragEventArgs.y"]/*' />
        /// <devdoc>
        ///     The mouse y location.
        /// </devdoc>
        private readonly int y;
        /// <include file='doc\DragEvent.uex' path='docs/doc[@for="DragEventArgs.allowedEffect"]/*' />
        /// <devdoc>
        ///     The effect that should be applied to the mouse cursor.
        /// </devdoc>
        private readonly DragDropEffects allowedEffect;
        /// <include file='doc\DragEvent.uex' path='docs/doc[@for="DragEventArgs.effect"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.DragEventArgs'/>
        ///       class.
        ///
        ///    </para>
        /// </devdoc>
        private DragDropEffects effect;

        /// <include file='doc\DragEvent.uex' path='docs/doc[@for="DragEventArgs.DragEventArgs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.DragEventArgs'/> class.
        ///    </para>
        /// </devdoc>
        public DragEventArgs(IDataObject data, int keyState, int x, int y, DragDropEffects allowedEffect, DragDropEffects effect) {
            this.data = data;
            this.keyState = keyState;
            this.x = x;
            this.y = y;
            this.allowedEffect = allowedEffect;
            this.effect = effect;
        }

        /// <include file='doc\DragEvent.uex' path='docs/doc[@for="DragEventArgs.Data"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The <see cref='System.Windows.Forms.IDataObject'/>
        ///       that contains the data associated with this event.
        ///    </para>
        /// </devdoc>
        public IDataObject Data {
            get {
                return data;
            }
        }
        /// <include file='doc\DragEvent.uex' path='docs/doc[@for="DragEventArgs.KeyState"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       the current state of the SHIFT, CTRL, and ALT keys.
        ///
        ///    </para>
        /// </devdoc>
        public int KeyState {
            get {
                return keyState;
            }
        }
        /// <include file='doc\DragEvent.uex' path='docs/doc[@for="DragEventArgs.X"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the
        ///       x-coordinate
        ///       of the mouse pointer.
        ///    </para>
        /// </devdoc>
        public int X {
            get {
                return x;
            }
        }
        /// <include file='doc\DragEvent.uex' path='docs/doc[@for="DragEventArgs.Y"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       the y-coordinate
        ///       of the mouse pointer.
        ///    </para>
        /// </devdoc>
        public int Y {
            get {
                return y;
            }
        }
        /// <include file='doc\DragEvent.uex' path='docs/doc[@for="DragEventArgs.AllowedEffect"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets which drag-and-drop operations are allowed by the
        ///       originator (or source) of the drag event.
        ///    </para>
        /// </devdoc>
        public DragDropEffects AllowedEffect {
            get {
                return allowedEffect;
            }
        }
        /// <include file='doc\DragEvent.uex' path='docs/doc[@for="DragEventArgs.Effect"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets which drag-and-drop operations are allowed by the target of the drag event.
        ///    </para>
        /// </devdoc>
        public DragDropEffects Effect {
            get {
                return effect;
            }
            set {
                effect = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\domainupdown.cs ===
//------------------------------------------------------------------------------
// <copyright file="DomainUpDown.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Security.Permissions;
    
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Drawing;
    using System.Drawing.Design;
    using System.Globalization;
    using System.Windows.Forms;
    using System.Collections;
    using Microsoft.Win32;

    /// <include file='doc\DomainUpDown.uex' path='docs/doc[@for="DomainUpDown"]/*' />
    /// <devdoc>
    ///    <para>Represents a Windows up-down control that displays string values.</para>
    /// </devdoc>
    [
    DefaultProperty("Items"),
    DefaultEvent("SelectedItemChanged")
    ]
    public class DomainUpDown : UpDownBase {

        private readonly static string     DefaultValue = "";
        private readonly static bool       DefaultWrap = false;

        //////////////////////////////////////////////////////////////
        // Member variables
        //
        //////////////////////////////////////////////////////////////

        /// <include file='doc\DomainUpDown.uex' path='docs/doc[@for="DomainUpDown.domainItems"]/*' />
        /// <devdoc>
        ///     Allowable strings for the domain updown.
        /// </devdoc>

        private DomainUpDownItemCollection domainItems = null;

        private string stringValue = DefaultValue;      // Current string value
        private int domainIndex = -1;                    // Index in the domain list
        private bool sorted = false;                 // Sort the domain values

        private bool wrap = DefaultWrap;             // Wrap around domain items

        private EventHandler onSelectedItemChanged = null;

        private bool inSort = false;

        /// <include file='doc\DomainUpDown.uex' path='docs/doc[@for="DomainUpDown.DomainUpDown"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.DomainUpDown'/> class.
        ///    </para>
        /// </devdoc>
        public DomainUpDown() : base() {            
            Text = "";
        }                
                
        // Properties

        /// <include file='doc\DomainUpDown.uex' path='docs/doc[@for="DomainUpDown.Items"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the collection of objects assigned to the
        ///       up-down control.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatData),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        SRDescription(SR.DomainUpDownItemsDescr),
        Localizable(true),
        Editor("System.Windows.Forms.Design.StringCollectionEditor, " + AssemblyRef.SystemDesign, typeof(UITypeEditor))
        ]
        public DomainUpDownItemCollection Items {

            get {
                if (domainItems == null) {
                    domainItems = new DomainUpDownItemCollection(this);
                }
                return domainItems;
            }
        }

        /// <include file='doc\DomainUpDown.uex' path='docs/doc[@for="DomainUpDown.SelectedIndex"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the index value of the selected item.
        ///    </para>
        /// </devdoc>
        [
        Browsable(false),
        DefaultValue(-1),
        SRCategory(SR.CatAppearance),
        SRDescription(SR.DomainUpDownSelectedIndexDescr)
        ]
        public int SelectedIndex {

            get {
                if (UserEdit) {
                    return -1;
                }
                else {
                    return domainIndex;
                }
            }

            set {
                if (value < -1 || value >= Items.Count) {
                    throw new ArgumentException(SR.GetString(SR.InvalidArgument, "Value", (value).ToString()));
                }
                
                if (value != SelectedIndex) {    
                    SelectIndex(value);
                }
            }
        }

        /// <include file='doc\DomainUpDown.uex' path='docs/doc[@for="DomainUpDown.SelectedItem"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the selected item based on the index value
        ///       of the selected item in the
        ///       collection.
        ///    </para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.DomainUpDownSelectedItemDescr)
        ]
        public object SelectedItem {
            get {
                int index = SelectedIndex;
                return(index == -1) ? null : Items[index];
            }
            set {

                // Treat null as selecting no item
                //
                if (value == null) {
                    SelectedIndex = -1;
                }
                else {
                    // Attempt to find the given item in the list of items
                    //
                    for (int i = 0; i < Items.Count; i++) {
                        if (value != null && value.Equals(Items[i])) {
                            SelectedIndex = i;
                            break;
                        }
                    }
                }
            }
        }

        /// <include file='doc\DomainUpDown.uex' path='docs/doc[@for="DomainUpDown.Sorted"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the item collection is sorted.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(false),
        SRDescription(SR.DomainUpDownSortedDescr)
        ]
        public bool Sorted {

            get {
                return sorted;
            }

            set {
                sorted = value;
                if (sorted) {
                    SortDomainItems();
                }
            }
        }

        /// <include file='doc\DomainUpDown.uex' path='docs/doc[@for="DomainUpDown.Wrap"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the collection of items continues to
        ///       the first or last item if the user continues past the end of the list.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        Localizable(true),
        DefaultValue(false),
        SRDescription(SR.DomainUpDownWrapDescr)
        ]
        public bool Wrap {

            get {
                return wrap;
            }

            set {
                wrap = value;
            }
        }

        //////////////////////////////////////////////////////////////
        // Methods
        //
        //////////////////////////////////////////////////////////////

        /// <include file='doc\DomainUpDown.uex' path='docs/doc[@for="DomainUpDown.SelectedItemChanged"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs when the <see cref='System.Windows.Forms.DomainUpDown.SelectedItem'/> property has
        ///       been changed.
        ///    </para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.DomainUpDownOnSelectedItemChangedDescr)]
        public event EventHandler SelectedItemChanged {
            add {
                onSelectedItemChanged += value;
            }
            remove {
                onSelectedItemChanged -= value;
            }
        }
        
        /// <include file='doc\DomainUpDown.uex' path='docs/doc[@for="DomainUpDown.CreateAccessibilityInstance"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Constructs the new instance of the accessibility object for this control. Subclasses
        ///    should not call base.CreateAccessibilityObject.
        /// </devdoc>
        protected override AccessibleObject CreateAccessibilityInstance() {
            return new DomainUpDownAccessibleObject(this);
        }
        
        /// <include file='doc\DomainUpDown.uex' path='docs/doc[@for="DomainUpDown.DownButton"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Displays the next item in the object collection.
        ///    </para>
        /// </devdoc>
        public override void DownButton() {

            // Make sure domain values exist, and there are >0 items
            //
            if (domainItems == null) {
                return;
            }
            if (domainItems.Count <= 0) {
                return;
            }

            // If the user has entered text, attempt to match it to the domain list
            //            
            int matchIndex = -1;
            if (UserEdit) {
                matchIndex = MatchIndex(Text, false, domainIndex);
            }
            if (matchIndex != -1) {

                // Found a match, so select this value
                //
                SelectIndex(matchIndex);
            }

            // Otherwise, get the next string in the domain list
            //
            else {
                if (domainIndex < domainItems.Count - 1) {
                    SelectIndex(domainIndex + 1);
                }
                else if (Wrap) {
                    SelectIndex(0);
                }
            }            
        }

        /// <include file='doc\DomainUpDown.uex' path='docs/doc[@for="DomainUpDown.MatchIndex"]/*' />
        /// <devdoc>
        ///     Tries to find a match of the supplied text in the domain list.
        ///     If complete is true, a complete match is required for success
        ///     (i.e. the supplied text is the same length as the matched domain value)
        ///     Returns the index in the domain list if the match is successful,
        ///     returns -1 otherwise.
        /// </devdoc>

        internal int MatchIndex(string text, bool complete) {
            return MatchIndex(text, complete, domainIndex);
        }
        internal int MatchIndex(string text, bool complete, int startPosition) {

            // Make sure domain values exist
            if (domainItems == null) {
                return -1;
            }

            // Sanity check of parameters
            if (text.Length < 1) {
                return -1;
            }
            if (domainItems.Count <= 0) {
                return -1;
            }
            if (startPosition < 0) {
                startPosition = domainItems.Count - 1;
            }
            if (startPosition >= domainItems.Count) {
                startPosition = 0;
            }

            // Attempt to match the supplied string text with
            // the domain list. Returns the index in the list if successful,
            // otherwise returns -1.
            int index = startPosition;
            int matchIndex = -1;
            bool found = false;

            if (!complete) {
                text = text.ToUpper(CultureInfo.InvariantCulture);
            }

            // Attempt to match the string with Items[index]
            do {
                if (complete)
                    found = Items[index].ToString().Equals(text);
                else
                    found = Items[index].ToString().ToUpper(CultureInfo.InvariantCulture).StartsWith(text);

                if (found) {
                    matchIndex = index;
                }

                // Calculate the next index to attempt to match
                index++;
                if (index >= domainItems.Count) {
                    index = 0;
                }

            } while (!found && index != startPosition);

            return matchIndex;
        }

        /// <include file='doc\DomainUpDown.uex' path='docs/doc[@for="DomainUpDown.OnChanged"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       In the case of a DomainUpDown, the handler for changing
        ///       values is called OnSelectedItemChanged - so just forward it to that
        ///       function.
        ///    </para>
        /// </devdoc>
        protected override void OnChanged(object source, EventArgs e) {
            OnSelectedItemChanged(source, e);
        }

        /// <include file='doc\DomainUpDown.uex' path='docs/doc[@for="DomainUpDown.OnTextBoxKeyDown"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void OnTextBoxKeyDown(object source, KeyEventArgs e) {

            if (ReadOnly) {

                // Make sure a legal character was pressed
                char[] character = new char[] { (char)(int)e.KeyCode};

                UnicodeCategory uc = Char.GetUnicodeCategory(character[0]);

                if (uc == UnicodeCategory.LetterNumber
                    || uc == UnicodeCategory.LowercaseLetter
                    || uc == UnicodeCategory.DecimalDigitNumber
                    || uc == UnicodeCategory.MathSymbol
                    || uc == UnicodeCategory.OtherLetter
                    || uc == UnicodeCategory.OtherNumber
                    || uc == UnicodeCategory.UppercaseLetter) {

                    // Attempt to match the character to a domain item
                    int matchIndex = MatchIndex(new string(character), false, domainIndex + 1);
                    if (matchIndex != -1) {

                        // Select the matching domain item
                        SelectIndex(matchIndex);
                    }
                    e.Handled = true;
                }
            }
            base.OnTextBoxKeyDown(source, e);
        }

        /// <include file='doc\DomainUpDown.uex' path='docs/doc[@for="DomainUpDown.OnSelectedItemChanged"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.DomainUpDown.SelectedItemChanged'/> event.
        ///    </para>
        /// </devdoc>
        protected void OnSelectedItemChanged(object source, EventArgs e) {

            // Call the event handler
            if (onSelectedItemChanged != null) {
                onSelectedItemChanged(this, e);
            }
        }

        /// <include file='doc\DomainUpDown.uex' path='docs/doc[@for="DomainUpDown.SelectIndex"]/*' />
        /// <devdoc>
        ///     Selects the item in the domain list at the given index
        /// </devdoc>
        private void SelectIndex(int index) {

            // Sanity check index

            Debug.Assert(domainItems != null, "Domain values array is null");
            Debug.Assert(index < domainItems.Count && index >= -1, "SelectValue: index out of range");
            if (domainItems == null || index < -1 || index >= domainItems.Count) {
                // Defensive programming
                index = -1;
                return;
            }
            
            // If the selected index has changed, update the text
            //
            domainIndex = index;
            if (domainIndex >= 0) {
                stringValue = domainItems[domainIndex].ToString();
                UserEdit = false;
                UpdateEditText();
            }
            else {
                UserEdit = true;
            }
            
            Debug.Assert(domainIndex >=0 || UserEdit == true, "UserEdit should be true when domainIndex < 0 " + UserEdit);
        }

        /// <include file='doc\DomainUpDown.uex' path='docs/doc[@for="DomainUpDown.SortDomainItems"]/*' />
        /// <devdoc>
        ///     Sorts the domain values
        /// </devdoc>
        private void SortDomainItems() {
            if (inSort)
                return;
            
            inSort = true;
            try {
                // Sanity check
                Debug.Assert(sorted == true, "Sorted == false");
                if (!sorted) {
                    return;
                }

                if (domainItems != null) {

                    // Sort the domain values
                    ArrayList.Adapter(domainItems).Sort(new DomainUpDownItemCompare());

                    // Update the domain index
                    if (!UserEdit) {
                        int newIndex = MatchIndex(stringValue, true);
                        if (newIndex != -1) {
                            SelectIndex(newIndex);
                        }
                    }
                }
            }
            finally {
                inSort = false;
            }
        }

        /// <include file='doc\DomainUpDown.uex' path='docs/doc[@for="DomainUpDown.ToString"]/*' />
        /// <devdoc>
        ///     Provides some interesting info about this control in String form.
        /// </devdoc>
        /// <internalonly/>
        public override string ToString() {

            string s = base.ToString();

            if (Items != null) {
                s += ", Items.Count: " + Items.Count.ToString();
                s += ", SelectedIndex: " + SelectedIndex.ToString();
            }
            return s;
        }

        /// <include file='doc\DomainUpDown.uex' path='docs/doc[@for="DomainUpDown.UpButton"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Displays the previous item in the collection.
        ///    </para>
        /// </devdoc>
        public override void UpButton() {

            // Make sure domain values exist, and there are >0 items
            if (domainItems == null) {
                return;
            }
            if (domainItems.Count <= 0) {
                return;
            }
            if (domainIndex == -1) {
                return;
            }

            // If the user has entered text, attempt to match it to the domain list
            int matchIndex = -1;
            if (UserEdit) {
                matchIndex = MatchIndex(Text, false, domainIndex);
            }
            if (matchIndex != -1) {

                // Found a match, so set the domain index accordingly
                SelectIndex(matchIndex);
            }

            // Otherwise, get the previous string in the domain list
            else {
                if (domainIndex > 0) {
                    SelectIndex(domainIndex - 1);
                }
                else if (Wrap) {
                    SelectIndex(domainItems.Count - 1);
                }
            }
        }
       
        /// <include file='doc\DomainUpDown.uex' path='docs/doc[@for="DomainUpDown.UpdateEditText"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Updates the text in the up-down control to display the selected item.
        ///    </para>
        /// </devdoc>
        protected override void UpdateEditText() {

            Debug.Assert(!UserEdit, "UserEdit should be false");
            // Defensive programming
            UserEdit = false;

            ChangingText = true;
            Text = stringValue;
        }


        // DomainUpDown collection class

        /// <include file='doc\DomainUpDown.uex' path='docs/doc[@for="DomainUpDown.DomainUpDownItemCollection"]/*' />
        /// <devdoc>
        /// <para>Encapsulates a collection of objects for use by the <see cref='System.Windows.Forms.DomainUpDown'/>
        /// class.</para>
        /// </devdoc>
        public class DomainUpDownItemCollection : ArrayList {
            DomainUpDown owner;

            internal DomainUpDownItemCollection(DomainUpDown owner)
            : base() {
                this.owner = owner;
            }

            /// <include file='doc\DomainUpDown.uex' path='docs/doc[@for="DomainUpDown.DomainUpDownItemCollection.this"]/*' />
            /// <devdoc>
            /// </devdoc>
            [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
            public override object this[int index] {
                get {
                    return base[index];
                }

                set {
                    base[index] = value;

                    if (owner.SelectedIndex == index) {
                        owner.SelectIndex(index);
                    }

                    if (owner.Sorted) {
                        owner.SortDomainItems();
                    }
                }
            }

            /// <include file='doc\DomainUpDown.uex' path='docs/doc[@for="DomainUpDown.DomainUpDownItemCollection.Add"]/*' />
            /// <devdoc>
            /// </devdoc>
            public override int Add(object item) {
                // Overridden to perform sorting after adding an item

                int ret = base.Add(item);
                if (owner.Sorted) {
                    owner.SortDomainItems();
                }
                return ret;
            }

            /// <include file='doc\DomainUpDown.uex' path='docs/doc[@for="DomainUpDown.DomainUpDownItemCollection.Remove"]/*' />
            /// <devdoc>
            /// </devdoc>
            public override void Remove(object item) {
                int index = IndexOf(item);
                
                if (index == -1) {
                    throw new ArgumentException(SR.GetString(SR.InvalidArgument, "item", item.ToString()));
                }
                else {
                    RemoveAt(index);    
                }
            }
            
            /// <include file='doc\DomainUpDown.uex' path='docs/doc[@for="DomainUpDown.DomainUpDownItemCollection.RemoveAt"]/*' />
            /// <devdoc>
            /// </devdoc>
            public override void RemoveAt(int item) {
                // Overridden to update the domain index if neccessary
                base.RemoveAt(item);

                if (item < owner.domainIndex) {
                    // The item removed was before the currently selected item
                    owner.SelectIndex(owner.domainIndex - 1);
                }
                else if (item == owner.domainIndex) {
                    // The currently selected item was removed
                    //
                    owner.SelectIndex(-1);
                }
            }

            /// <include file='doc\DomainUpDown.uex' path='docs/doc[@for="DomainUpDown.DomainUpDownItemCollection.Insert"]/*' />
            /// <devdoc>
            /// </devdoc>
            public override void Insert(int index, object item) {
                base.Insert(index, item);
                if (owner.Sorted) {
                    owner.SortDomainItems();
                }
            }
        } // end class DomainUpDownItemCollection

        /// <include file='doc\DomainUpDown.uex' path='docs/doc[@for="DomainUpDown.DomainUpDownItemCompare"]/*' />
        /// <devdoc>
        /// </devdoc>
        private sealed class DomainUpDownItemCompare : IComparer {

            public int Compare(object p, object q) {
                if (p == q) return 0;
                if (p == null || q == null) {
                    return 0;
                }

                return String.Compare(p.ToString(), q.ToString(), false, CultureInfo.CurrentCulture);
            }
        }

        /// <include file='doc\DomainUpDown.uex' path='docs/doc[@for="DomainUpDown.DomainUpDownAccessibleObject"]/*' />
        /// <internalonly/>        
        /// <devdoc>
        /// </devdoc>
        [System.Runtime.InteropServices.ComVisible(true)]        
        public class DomainUpDownAccessibleObject : ControlAccessibleObject {

            private DomainItemListAccessibleObject itemList;
            
            /// <include file='doc\DomainUpDown.uex' path='docs/doc[@for="DomainUpDown.DomainUpDownAccessibleObject.DomainUpDownAccessibleObject"]/*' />
            /// <devdoc>
            /// </devdoc>
            public DomainUpDownAccessibleObject(Control owner) : base(owner) {
            }
            
            private DomainItemListAccessibleObject ItemList {
                get {
                    if (itemList == null) {
                        itemList = new DomainItemListAccessibleObject(this);
                    }
                    return itemList;
                }
            }
            
            /// <include file='doc\DomainUpDown.uex' path='docs/doc[@for="DomainUpDown.DomainUpDownAccessibleObject.Role"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override AccessibleRole Role {
                get {
                    return AccessibleRole.ComboBox;
                }
            }
            
            /// <include file='doc\DomainUpDown.uex' path='docs/doc[@for="DomainUpDown.DomainUpDownAccessibleObject.GetChild"]/*' />
            /// <devdoc>
            /// </devdoc>
            public override AccessibleObject GetChild(int index) {
                switch(index) {
                    // TextBox child
                    //
                    case 0:
                        return ((UpDownBase)Owner).TextBox.AccessibilityObject.Parent;
                    
                    // Up/down buttons
                    //
                    case 1:
                        return ((UpDownBase)Owner).UpDownButtonsInternal.AccessibilityObject.Parent;
            
                    case 2:                           
                        return ItemList;
                }
                
                return null;
            }

            /// <include file='doc\DomainUpDown.uex' path='docs/doc[@for="DomainUpDown.DomainUpDownAccessibleObject.GetChildCount"]/*' />
            /// <devdoc>
            /// </devdoc>
            public override int GetChildCount() {
                return 3;
            }
        }
        
        internal class DomainItemListAccessibleObject : AccessibleObject {
        
            private DomainUpDownAccessibleObject parent;
        
            public DomainItemListAccessibleObject(DomainUpDownAccessibleObject parent) : base() {
                this.parent = parent;
            }
            
            public override string Name {
                get {
                    string baseName = base.Name;
                    if (baseName == null || baseName.Length == 0) {
                        return "Items";
                    }
                    return baseName;
                }
                set {
                    base.Name = value;
                }
            }
            
            public override AccessibleObject Parent {
                get {
                    return parent;
                }
            }

            public override AccessibleRole Role {
                get {
                    return AccessibleRole.List;
                }
            }

            public override AccessibleStates State {
                get {
                    return AccessibleStates.Invisible | AccessibleStates.Offscreen;
                }
            }
            
            public override AccessibleObject GetChild(int index) {
                
                if (index >=0 && index < GetChildCount()) {
                    return new DomainItemAccessibleObject(((DomainUpDown)parent.Owner).Items[index].ToString(), this);
                }
                
                return null;
            }

            public override int GetChildCount() {
                return ((DomainUpDown)parent.Owner).Items.Count;
            }

        }

        /// <include file='doc\DomainUpDown.uex' path='docs/doc[@for="DomainUpDown.DomainItemAccessibleObject"]/*' />
        /// <internalonly/>        
        /// <devdoc>
        /// </devdoc>
        [System.Runtime.InteropServices.ComVisible(true)]        
        public class DomainItemAccessibleObject : AccessibleObject {

            private string name;
            private DomainItemListAccessibleObject parent;

            /// <include file='doc\DomainUpDown.uex' path='docs/doc[@for="DomainUpDown.DomainItemAccessibleObject.DomainItemAccessibleObject"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public DomainItemAccessibleObject(string name, AccessibleObject parent) : base() {
                this.name = name;
                this.parent = (DomainItemListAccessibleObject)parent;
            }

            /// <include file='doc\DomainUpDown.uex' path='docs/doc[@for="DomainUpDown.DomainItemAccessibleObject.Name"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override string Name {
                get {
                    return name;
                }
                set {
                    name = value;
                }
            }

            /// <include file='doc\DomainUpDown.uex' path='docs/doc[@for="DomainUpDown.DomainItemAccessibleObject.Parent"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override AccessibleObject Parent {
                get {
                    return parent;
                }
            }

            /// <include file='doc\DomainUpDown.uex' path='docs/doc[@for="DomainUpDown.DomainItemAccessibleObject.Role"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override AccessibleRole Role {
                get {
                    return AccessibleRole.ListItem;
                }
            }

            /// <include file='doc\DomainUpDown.uex' path='docs/doc[@for="DomainUpDown.DomainItemAccessibleObject.State"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override AccessibleStates State {
                get {
                    return AccessibleStates.Selectable;
                }
            }

            /// <include file='doc\DomainUpDown.uex' path='docs/doc[@for="DomainUpDown.DomainItemAccessibleObject.Value"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override string Value {
                get {
                    return name;
                }
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\drageventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="DragEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Drawing;

    /// <include file='doc\DragEventHandler.uex' path='docs/doc[@for="DragEventHandler"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the method that will handle
    ///       the <see cref='System.Windows.Forms.Control.DragDrop'/>,
    ///    <see cref='System.Windows.Forms.Control.DragEnter'/>, or <see cref='System.Windows.Forms.Control.DragOver'/> event of a <see cref='System.Windows.Forms.Control'/>.
    ///    </para>
    /// </devdoc>
    public delegate void DragEventHandler(object sender, DragEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\drawitemevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="DrawItemEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;

    /// <include file='doc\DrawItemEvent.uex' path='docs/doc[@for="DrawItemEventArgs"]/*' />
    /// <devdoc>
    ///     This event is fired by owner draw Controls, such as ListBoxes and
    ///     ComboBoxes. It contains all the information needed for the user to
    ///     paint the given item, including the item index, the Rectangle in which
    ///     the drawing should be done, and the Graphics object with which the drawing
    ///     should be done.
    /// </devdoc>
    public class DrawItemEventArgs : EventArgs {

        /// <include file='doc\DrawItemEvent.uex' path='docs/doc[@for="DrawItemEventArgs.backColor"]/*' />
        /// <devdoc>
        ///     The backColor to paint each menu item with.
        /// </devdoc>
        private Color backColor;

        /// <include file='doc\DrawItemEvent.uex' path='docs/doc[@for="DrawItemEventArgs.foreColor"]/*' />
        /// <devdoc>
        ///     The foreColor to paint each menu item with.
        /// </devdoc>
        private Color foreColor;

        /// <include file='doc\DrawItemEvent.uex' path='docs/doc[@for="DrawItemEventArgs.font"]/*' />
        /// <devdoc>
        ///     The font used to draw the item's string.
        /// </devdoc>
        private Font font;
        
        /// <include file='doc\DrawItemEvent.uex' path='docs/doc[@for="DrawItemEventArgs.graphics"]/*' />
        /// <devdoc>
        ///     The graphics object with which the drawing should be done.
        /// </devdoc>
        private readonly System.Drawing.Graphics graphics;

        /// <include file='doc\DrawItemEvent.uex' path='docs/doc[@for="DrawItemEventArgs.index"]/*' />
        /// <devdoc>
        ///     The index of the item that should be painted.
        /// </devdoc>
        private readonly int index;

        /// <include file='doc\DrawItemEvent.uex' path='docs/doc[@for="DrawItemEventArgs.rect"]/*' />
        /// <devdoc>
        ///     The rectangle outlining the area in which the painting should be
        ///     done.
        /// </devdoc>
        private readonly Rectangle rect;

        /// <include file='doc\DrawItemEvent.uex' path='docs/doc[@for="DrawItemEventArgs.state"]/*' />
        /// <devdoc>
        ///     Miscellaneous state information, such as whether the item is
        ///     "selected", "focused", or some other such information.  ComboBoxes
        ///     have one special piece of information which indicates if the item
        ///     being painted is the editable portion of the ComboBox.
        /// </devdoc>
        private readonly DrawItemState state;

        /// <include file='doc\DrawItemEvent.uex' path='docs/doc[@for="DrawItemEventArgs.DrawItemEventArgs"]/*' />
        /// <devdoc>
        ///     Creates a new DrawItemEventArgs with the given parameters.
        /// </devdoc>
        public DrawItemEventArgs(Graphics graphics, Font font, Rectangle rect,
                             int index, DrawItemState state) {
            this.graphics = graphics;
            this.font = font;
            this.rect = rect;
            this.index = index;
            this.state = state;
            this.foreColor = SystemColors.WindowText;
            this.backColor = SystemColors.Window;
        }
        
        /// <include file='doc\DrawItemEvent.uex' path='docs/doc[@for="DrawItemEventArgs.DrawItemEventArgs2"]/*' />
        /// <devdoc>
        ///     Creates a new DrawItemEventArgs with the given parameters, including the foreColor and backColor of the control.
        /// </devdoc>
        public DrawItemEventArgs(Graphics graphics, Font font, Rectangle rect,
                             int index, DrawItemState state, Color foreColor, Color backColor) {
            this.graphics = graphics;
            this.font = font;
            this.rect = rect;
            this.index = index;
            this.state = state;
            this.foreColor = foreColor;
            this.backColor = backColor;
        }

        /// <include file='doc\DrawItemEvent.uex' path='docs/doc[@for="DrawItemEventArgs.BackColor"]/*' />
        public Color BackColor {
            get {
                if ((state & DrawItemState.Selected) == DrawItemState.Selected) {
                    return SystemColors.Highlight;
                }
                return backColor;
            }
        }
        
        

        /// <include file='doc\DrawItemEvent.uex' path='docs/doc[@for="DrawItemEventArgs.Bounds"]/*' />
        /// <devdoc>
        ///     The rectangle outlining the area in which the painting should be
        ///     done.
        /// </devdoc>
        public Rectangle Bounds {
            get {
                return rect;
            }
        }

        /// <include file='doc\DrawItemEvent.uex' path='docs/doc[@for="DrawItemEventArgs.Font"]/*' />
        /// <devdoc>
        ///     A suggested font, usually the parent control's Font property.
        /// </devdoc>
        public Font Font {
            get {
                return font;
            }
        }

        /// <include file='doc\DrawItemEvent.uex' path='docs/doc[@for="DrawItemEventArgs.ForeColor"]/*' />
        /// <devdoc>
        ///     A suggested color drawing: either SystemColors.WindowText or SystemColors.HighlightText,
        ///     depending on whether this item is selected.
        /// </devdoc>
        public Color ForeColor {
            get {
                if ((state & DrawItemState.Selected) == DrawItemState.Selected) {
                    return SystemColors.HighlightText;
                }
                return foreColor;
            }
        }              

        /// <include file='doc\DrawItemEvent.uex' path='docs/doc[@for="DrawItemEventArgs.Graphics"]/*' />
        /// <devdoc>
        ///     Graphics object with which painting should be done.
        /// </devdoc>
        public Graphics Graphics {
            get {
                return graphics;
            }
        }

        /// <include file='doc\DrawItemEvent.uex' path='docs/doc[@for="DrawItemEventArgs.Index"]/*' />
        /// <devdoc>
        ///     The index of the item that should be painted.
        /// </devdoc>
        public int Index {
            get {
                return index;
            }
        }

        /// <include file='doc\DrawItemEvent.uex' path='docs/doc[@for="DrawItemEventArgs.State"]/*' />
        /// <devdoc>
        ///     Miscellaneous state information, such as whether the item is
        ///     "selected", "focused", or some other such information.  ComboBoxes
        ///     have one special piece of information which indicates if the item
        ///     being painted is the editable portion of the ComboBox.
        /// </devdoc>
        public DrawItemState State {
            get {
                return state;
            }
        }

        internal void Dispose() {
            graphics.Dispose();
        }

        /// <include file='doc\DrawItemEvent.uex' path='docs/doc[@for="DrawItemEventArgs.DrawBackground"]/*' />
        /// <devdoc>
        ///     Draws the background of the given rectangle with the color returned from the BackColor property.
        /// </devdoc>
        public virtual void DrawBackground() {
            Brush backBrush = new SolidBrush(BackColor);
            Graphics.FillRectangle(backBrush, rect);
            backBrush.Dispose();
        }

        /// <include file='doc\DrawItemEvent.uex' path='docs/doc[@for="DrawItemEventArgs.DrawFocusRectangle"]/*' />
        /// <devdoc>
        ///     Draws a handy focus rect in the given rectangle.
        /// </devdoc>
        public virtual void DrawFocusRectangle() {
            if ((state & DrawItemState.Focus) == DrawItemState.Focus
                && (state & DrawItemState.NoFocusRect) != DrawItemState.NoFocusRect)
                ControlPaint.DrawFocusRectangle(Graphics, rect, ForeColor, BackColor);
        }                
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\drawitemstate.cs ===
//------------------------------------------------------------------------------
// <copyright file="DrawItemState.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;


    /// <include file='doc\DrawItemState.uex' path='docs/doc[@for="DrawItemState"]/*' />
    /// <devdoc>
    ///    <para>
    ///
    ///       Specifies
    ///       the state of an item that is being drawn.
    ///    </para>
    /// </devdoc>
    [Flags]
    public enum DrawItemState {
        /// <include file='doc\DrawItemState.uex' path='docs/doc[@for="DrawItemState.Checked"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The item is checked. Only menu controls use this value.
        ///
        ///    </para>
        /// </devdoc>
        Checked = NativeMethods.ODS_CHECKED,
        /// <include file='doc\DrawItemState.uex' path='docs/doc[@for="DrawItemState.ComboBoxEdit"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The item is the editing portion of a <see cref='System.Windows.Forms.ComboBox'/> .
        ///    </para>
        /// </devdoc>
        ComboBoxEdit = NativeMethods.ODS_COMBOBOXEDIT,
        /// <include file='doc\DrawItemState.uex' path='docs/doc[@for="DrawItemState.Default"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The item is the default item of the control.
        ///    </para>
        /// </devdoc>
        Default     = NativeMethods.ODS_DEFAULT,
        /// <include file='doc\DrawItemState.uex' path='docs/doc[@for="DrawItemState.Disabled"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The item is disabled.
        ///    </para>
        /// </devdoc>
        Disabled     = NativeMethods.ODS_DISABLED,
        /// <include file='doc\DrawItemState.uex' path='docs/doc[@for="DrawItemState.Focus"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The item has focus.
        ///    </para>
        /// </devdoc>
        Focus        = NativeMethods.ODS_FOCUS,
        /// <include file='doc\DrawItemState.uex' path='docs/doc[@for="DrawItemState.Grayed"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The item
        ///       is grayed. Only menu controls use this value.
        ///
        ///    </para>
        /// </devdoc>
        Grayed        = NativeMethods.ODS_GRAYED,
        /// <include file='doc\DrawItemState.uex' path='docs/doc[@for="DrawItemState.HotLight"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The item is being hot-tracked.
        ///    </para>
        /// </devdoc>
        HotLight        = NativeMethods.ODS_HOTLIGHT,
        /// <include file='doc\DrawItemState.uex' path='docs/doc[@for="DrawItemState.Inactive"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The item is inactive.
        ///    </para>
        /// </devdoc>
        Inactive        = NativeMethods.ODS_INACTIVE,
        /// <include file='doc\DrawItemState.uex' path='docs/doc[@for="DrawItemState.NoAccelerator"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The item displays without a keyboard accelarator.
        ///    </para>
        /// </devdoc>
        NoAccelerator        = NativeMethods.ODS_NOACCEL,
        /// <include file='doc\DrawItemState.uex' path='docs/doc[@for="DrawItemState.NoFocusRect"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The item displays without the visual cue that indicates it has the focus.
        ///    </para>
        /// </devdoc>
        NoFocusRect        = NativeMethods.ODS_NOFOCUSRECT,
        /// <include file='doc\DrawItemState.uex' path='docs/doc[@for="DrawItemState.Selected"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The item is selected.
        ///    </para>
        /// </devdoc>
        Selected     = NativeMethods.ODS_SELECTED,
        /// <include file='doc\DrawItemState.uex' path='docs/doc[@for="DrawItemState.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The item is in its default visual state.
        ///    </para>
        /// </devdoc>
        None         = 0,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\drawitemeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="DrawItemEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;


    /// <include file='doc\DrawItemEventHandler.uex' path='docs/doc[@for="DrawItemEventHandler"]/*' />
    /// <devdoc>
    /// </devdoc>
    public delegate void DrawItemEventHandler(object sender, DrawItemEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\drawmode.cs ===
//------------------------------------------------------------------------------
// <copyright file="DrawMode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;


    /// <include file='doc\DrawMode.uex' path='docs/doc[@for="DrawMode"]/*' />
    /// <devdoc>
    ///    <para>
    ///
    ///       Specifies responsibility for drawing a control or portion of a control.
    ///
    ///    </para>
    /// </devdoc>
    public enum DrawMode {
        /// <include file='doc\DrawMode.uex' path='docs/doc[@for="DrawMode.Normal"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The
        ///       operating system paints the items in the control, and the items are each the
        ///       same height.
        ///
        ///    </para>
        /// </devdoc>
        Normal = 0,

        /// <include file='doc\DrawMode.uex' path='docs/doc[@for="DrawMode.OwnerDrawFixed"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The
        ///       programmer explicitly paints the items in the control, and the items are
        ///       each the same height.
        ///
        ///    </para>
        /// </devdoc>
        OwnerDrawFixed = 1,

        /// <include file='doc\DrawMode.uex' path='docs/doc[@for="DrawMode.OwnerDrawVariable"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The programmer explicitly paints the items in the control manually, and they
        ///       may be different heights.
        ///    </para>
        /// </devdoc>
        OwnerDrawVariable = 2,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\errorblinkstyle.cs ===
//------------------------------------------------------------------------------
// <copyright file="ErrorBlinkStyle.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;
    /// <include file='doc\ErrorBlinkStyle.uex' path='docs/doc[@for="ErrorBlinkStyle"]/*' />
    /// <devdoc>
    ///     Describes the times that the error icon supplied by an ErrorProvider
    ///     should blink to alert the user that an error has occurred.
    /// </devdoc>
    public enum ErrorBlinkStyle {
        /// <include file='doc\ErrorBlinkStyle.uex' path='docs/doc[@for="ErrorBlinkStyle.BlinkIfDifferentError"]/*' />
        /// <devdoc>
        ///     Blink only if the error icon is already displayed, but a new
        ///     error string is set for the control.  If the icon did not blink 
        ///     in this case, the user might not know that there is a new error.
        /// </devdoc>
        BlinkIfDifferentError,
        
        /// <include file='doc\ErrorBlinkStyle.uex' path='docs/doc[@for="ErrorBlinkStyle.AlwaysBlink"]/*' />
        /// <devdoc>
        ///     Blink the error icon when the error is first displayed, or when 
        ///     a new error description string is set for the control and the
        ///     error icon is already displayed.
        /// </devdoc>
        AlwaysBlink,
        
        /// <include file='doc\ErrorBlinkStyle.uex' path='docs/doc[@for="ErrorBlinkStyle.NeverBlink"]/*' />
        /// <devdoc>
        ///     Never blink the error icon.
        /// </devdoc>
        NeverBlink
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\erroriconalignment.cs ===
//------------------------------------------------------------------------------
// <copyright file="ErrorIconAlignment.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;
    
    /// <include file='doc\ErrorIconAlignment.uex' path='docs/doc[@for="ErrorIconAlignment"]/*' />
    /// <devdoc>
    ///     Describes the set of locations that an error icon can appear in
    ///     relation to the control with the error.
    /// </devdoc>
    public enum ErrorIconAlignment {
    
        /// <include file='doc\ErrorIconAlignment.uex' path='docs/doc[@for="ErrorIconAlignment.TopLeft"]/*' />
        /// <devdoc>
        ///     The icon appears aligned with the top of the control, and to
        ///     the left of the control.
        /// </devdoc>
        TopLeft,
        
        /// <include file='doc\ErrorIconAlignment.uex' path='docs/doc[@for="ErrorIconAlignment.TopRight"]/*' />
        /// <devdoc>
        ///     The icon appears aligned with the top of the control, and to
        ///     the right of the control.
        /// </devdoc>
        TopRight,
        
        /// <include file='doc\ErrorIconAlignment.uex' path='docs/doc[@for="ErrorIconAlignment.MiddleLeft"]/*' />
        /// <devdoc>
        ///     The icon appears aligned with the middle of the control, and
        ///     the left of the control.
        /// </devdoc>
        MiddleLeft,
        
        /// <include file='doc\ErrorIconAlignment.uex' path='docs/doc[@for="ErrorIconAlignment.MiddleRight"]/*' />
        /// <devdoc>
        ///     The icon appears aligned with the middle of the control, and
        ///     the right of the control.
        /// </devdoc>
        MiddleRight,
        
        /// <include file='doc\ErrorIconAlignment.uex' path='docs/doc[@for="ErrorIconAlignment.BottomLeft"]/*' />
        /// <devdoc>
        ///     The icon appears aligned with the bottom of the control, and
        ///     the left of the control.
        /// </devdoc>
        BottomLeft,
        
        /// <include file='doc\ErrorIconAlignment.uex' path='docs/doc[@for="ErrorIconAlignment.BottomRight"]/*' />
        /// <devdoc>
        ///     The icon appears aligned with the bottom of the control, and
        ///     the right of the control.
        /// </devdoc>
        BottomRight
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\errorprovider.cs ===
//------------------------------------------------------------------------------
// <copyright file="ErrorProvider.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    using System.Threading;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System;
    using System.Collections;    
    using System.Globalization;    
    using System.Drawing;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    using System.Security.Permissions;

    /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider"]/*' />
    /// <devdoc>
    ///     ErrorProvider presents a simple user interface for indicating to the
    ///     user that a control on a form has an error associated with it.  If a
    ///     error description string is specified for the control, then an icon
    ///     will appear next to the control, and when the mouse hovers over the
    ///     icon, a tooltip will appear showing the error description string.
    /// </devdoc>
    [
    ProvideProperty("IconPadding", typeof(Control)),
    ProvideProperty("IconAlignment", typeof(Control)),
    ProvideProperty("Error", typeof(Control)),
    ToolboxItemFilter("System.Windows.Forms")
    ]
    public class ErrorProvider : Component, IExtenderProvider {

        //
        // FIELDS
        //

        Hashtable items = new Hashtable();
        Hashtable windows = new Hashtable();
        Icon icon;
        IconRegion region;
        int itemIdCounter;
        int blinkRate;
        ErrorBlinkStyle blinkStyle;
        bool showIcon = true;                       // used for blinking
        private bool inSetErrorManager = false;
        static Icon defaultIcon = null;
        const int defaultBlinkRate = 250;
        const ErrorBlinkStyle defaultBlinkStyle = ErrorBlinkStyle.BlinkIfDifferentError;
        const ErrorIconAlignment defaultIconAlignment = ErrorIconAlignment.MiddleRight;

        // data binding
        private ContainerControl parentControl;
        private object dataSource = null;
        private string dataMember = null;
        private CurrencyManager errorManager;
        private EventHandler currentChanged;

        // listen to the OnPropertyChanged event in the ContainerControl
        private EventHandler propChangedEvent;

        //
        // CONSTRUCTOR
        //

        /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.ErrorProvider"]/*' />
        /// <devdoc>
        ///     Default constructor.
        /// </devdoc>
        public ErrorProvider() {
            icon = DefaultIcon;
            blinkRate = defaultBlinkRate;
            blinkStyle = defaultBlinkStyle;
            currentChanged = new EventHandler(ErrorManager_CurrentChanged);
        }

        /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.ErrorProvider1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ErrorProvider(ContainerControl parentControl) : this() {
            this.parentControl = parentControl;
            propChangedEvent = new EventHandler(ParentControl_BindingContextChanged);
            parentControl.BindingContextChanged += propChangedEvent;
        }

        //
        // PROPERTIES
        //

        /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.Site"]/*' />
        public override ISite Site {
            set {
                base.Site = value;
                if (value == null)
                    return;
                    
                IDesignerHost host = value.GetService(typeof(IDesignerHost)) as IDesignerHost;
                if (host != null) {
                    IComponent baseComp = host.RootComponent;
    
                    if (baseComp is ContainerControl) {
                        this.ContainerControl = (ContainerControl) baseComp;
                    }
                }
            }
        }

        /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.BlinkStyle"]/*' />
        /// <devdoc>
        ///     Returns or sets when the error icon flashes.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(defaultBlinkStyle),
        SRDescription(SR.ErrorProviderBlinkStyleDescr)
        ]
        public ErrorBlinkStyle BlinkStyle {
            get {
                if (blinkRate == 0) {
                    return ErrorBlinkStyle.NeverBlink;
                }
                return blinkStyle;
            }
            set {
                if (!Enum.IsDefined(typeof(ErrorBlinkStyle), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(ErrorBlinkStyle));
                }

                // If the blinkRate == 0, then set blinkStyle = neverBlink
                //
                if (blinkRate == 0)
                    value = ErrorBlinkStyle.NeverBlink;

                if (blinkStyle == value)
                    return;

                if (value == ErrorBlinkStyle.AlwaysBlink) {
                    // we need to startBlinking on all the controlItems
                    // in our items hashTable.
                    this.showIcon = false;
                    foreach (ErrorWindow w in windows.Values)
                        w.StartBlinking();
                } else if (blinkStyle == ErrorBlinkStyle.AlwaysBlink) {
                    this.showIcon = true;
                    // we need to stop blinking...
                    foreach (ErrorWindow w in windows.Values)
                        w.StopBlinking();
                }

                blinkStyle = value;
            }
        }

        /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.ContainerControl"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        DefaultValue(null),
        SRCategory(SR.CatData),
        SRDescription(SR.ErrorProviderContainerControlDescr)
        ]
        public ContainerControl ContainerControl {
            [UIPermission(SecurityAction.LinkDemand, Window=UIPermissionWindow.AllWindows)]
            get {
                return parentControl;
            }
            set {
                if (parentControl != value) {
                    if (parentControl != null)
                        parentControl.BindingContextChanged -= propChangedEvent;

                    parentControl = value;

                    if (parentControl != null)
                        parentControl.BindingContextChanged += propChangedEvent;

                    Set_ErrorManager(this.DataSource, this.DataMember, true);
                }
            }
        }

        private void Set_ErrorManager(object newDataSource, string newDataMember, bool force) {
            if (inSetErrorManager)
                return;
            inSetErrorManager = true;
            bool dataSourceChanged = this.DataSource != newDataSource;
            bool dataMemberChanged = this.DataMember != newDataMember;

            //if nothing changed, then do not do any work
            //
            if (!dataSourceChanged && !dataMemberChanged && !force)
                return;

            // set the dataSource and the dataMember
            //
            this.dataSource = newDataSource;
            this.dataMember = newDataMember;

            try {
                // unwire the errorManager:
                //
                if (errorManager != null)
                    UnwireEvents(errorManager);

                // get the new errorManager
                //
                if (parentControl != null && this.dataSource != null && parentControl.BindingContext != null)
                    errorManager = (CurrencyManager) parentControl.BindingContext[this.dataSource, this.dataMember];
                else
                    errorManager = null;

                // wire the events
                //
                if (errorManager != null)
                    WireEvents(errorManager);

                // see if there are errors at the current 
                // item in the list, w/o waiting for the position to change
                if (errorManager != null)
                    UpdateBinding();
            } finally {
                inSetErrorManager = false;
            }
        }

        /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.DataSource"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        DefaultValue(null),
        SRCategory(SR.CatData),
        TypeConverterAttribute("System.Windows.Forms.Design.DataSourceConverter, " + AssemblyRef.SystemDesign),
        SRDescription(SR.ErrorProviderDataSourceDescr) 
        ]
        public object DataSource {
            get {
                return dataSource;
            }
            set {
                Set_ErrorManager(value, this.DataMember, false);
            }
        }

        /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.ShouldSerializeDataSource"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        private bool ShouldSerializeDataSource() {
            return (dataSource != null);
        }

        /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.DataMember"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        DefaultValue(null),
        SRCategory(SR.CatData),
        Editor("System.Windows.Forms.Design.DataMemberListEditor, " + AssemblyRef.SystemDesign, typeof(System.Drawing.Design.UITypeEditor)),
        SRDescription(SR.ErrorProviderDataMemberDescr) 
        ]
        public string DataMember {
            get {
                return dataMember;
            }
            set {
                if (value == null) value = "";
                Set_ErrorManager(this.DataSource, value, false);
            }
        }

        /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.ShouldSerializeDataMember"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        private bool ShouldSerializeDataMember() {
            return (!"".Equals(dataMember));
        }

        /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.BindToDataAndErrors"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void BindToDataAndErrors(object newDataSource, string newDataMember) {
            Set_ErrorManager(newDataSource, newDataMember, false);
        }

        private void WireEvents(CurrencyManager listManager) {
            listManager.CurrentChanged += currentChanged;
            listManager.ItemChanged += new ItemChangedEventHandler(this.ErrorManager_ItemChanged);
            listManager.Bindings.CollectionChanged += new CollectionChangeEventHandler(this.ErrorManager_BindingsChanged);
        }

        private void UnwireEvents(CurrencyManager listManager) {
            listManager.CurrentChanged -= currentChanged;
            listManager.ItemChanged -= new ItemChangedEventHandler(this.ErrorManager_ItemChanged);
            listManager.Bindings.CollectionChanged -= new CollectionChangeEventHandler(this.ErrorManager_BindingsChanged);
        }

        private void ErrorManager_BindingsChanged(object sender, CollectionChangeEventArgs e) {
            ErrorManager_CurrentChanged(errorManager, e);
        }

        private void ParentControl_BindingContextChanged(object sender, EventArgs e) {
            Set_ErrorManager(this.DataSource, this.DataMember, true);
        }

        // Work around... we should figure out if errors changed automatically.
        /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.UpdateBinding"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void UpdateBinding() {
            ErrorManager_CurrentChanged(errorManager, EventArgs.Empty);
        }

        private void ErrorManager_ItemChanged(object sender, ItemChangedEventArgs e) {
            BindingsCollection errBindings = errorManager.Bindings;
            int bindingsCount = errBindings.Count;

            // If the list became empty then reset the errors
            if (e.Index == -1 && errorManager.Count == 0)
                for (int j = 0; j < bindingsCount; j++)
                    SetError(errBindings[j].Control, "");
            else
                ErrorManager_CurrentChanged(sender, e);
        }

        private void ErrorManager_CurrentChanged(object sender, EventArgs e) {
            Debug.Assert(sender == errorManager, "who else can send us messages?");

            // flush the old list
            //
            // items.Clear();

            if (errorManager.Count == 0) {
                return;
            }

            object value = errorManager.Current;
            if ( !(value is IDataErrorInfo))
                return;

            BindingsCollection errBindings = errorManager.Bindings;
            int bindingsCount = errBindings.Count;

            // we need to delete the blinkPhases from each controlItem (suppose
            // that the error that we get is the same error. then we want to
            // show the error and not blink )
            //
            foreach (ControlItem ctl in items.Values)
                ctl.BlinkPhase = 0;

            // We can only show one error per control, so we will build up a string...
            // 
            Hashtable controlError = new Hashtable(bindingsCount);

            for (int j = 0; j < bindingsCount; j++) {
                BindToObject dataBinding = errBindings[j].BindToObject;
                string error = ((IDataErrorInfo) value)[dataBinding.BindingMemberInfo.BindingField];

                if (error == null) {
                    error = "";
                }

                string newError = error.Equals(String.Empty) ?
                                        "" : SR.GetString(SR.ErrorProviderErrorTemplate, dataBinding.BindingMemberInfo.BindingField, error);

                string outputError = "";

                if (controlError.Contains(errBindings[j].Control))
                    outputError = (string) controlError[errBindings[j].Control];

                if (outputError.Equals(String.Empty)) {
                    outputError = newError;
                } else {
                    outputError = string.Concat(outputError, "\r\n", newError);
                }

                controlError[errBindings[j].Control] = outputError;
            }

            IEnumerator enumerator = controlError.GetEnumerator();
            while (enumerator.MoveNext()) {
                DictionaryEntry entry = (DictionaryEntry) enumerator.Current;
                SetError((Control) entry.Key, (string) entry.Value);
            }
        }

        /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.BlinkRate"]/*' />
        /// <devdoc>
        ///     Returns or set the rate in milliseconds at which the error icon flashes.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(defaultBlinkRate),
        SRDescription(SR.ErrorProviderBlinkRateDescr),
        RefreshProperties(RefreshProperties.Repaint)
        ]
        public int BlinkRate {
            get {
                return blinkRate;
            }
            set {
                if (value < 0) {
                    throw new ArgumentOutOfRangeException("value", value, SR.GetString(SR.BlinkRateMustBeZeroOrMore));
                }
                blinkRate = value;
                // If we set the blinkRate = 0 then set BlinkStyle = NeverBlink
                if (blinkRate == 0)
                    BlinkStyle = ErrorBlinkStyle.NeverBlink;
            }
        }

        /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.DefaultIcon"]/*' />
        /// <devdoc>
        ///     Demand load and cache the default icon.
        /// </devdoc>
        /// <internalonly/>
        static Icon DefaultIcon {
            get {
                if (defaultIcon == null) {
                    lock (typeof(ErrorProvider)) {
                        if (defaultIcon == null) {
                            defaultIcon = new Icon(typeof(ErrorProvider), "Error.ico");
                        }
                    }
                }
                return defaultIcon;
            }
        }

        /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.Icon"]/*' />
        /// <devdoc>
        ///     Returns or sets the Icon that displayed next to a control when an error
        ///     description string has been set for the control.  For best results, an
        ///     icon containing a 16 by 16 icon should be used.
        /// </devdoc>
        [
        Localizable(true),
        SRCategory(SR.CatAppearance),
        SRDescription(SR.ErrorProviderIconDescr)
        ]
        public Icon Icon {
            get {
                return icon;
            }
            set {
                if (value == null)
                    throw new ArgumentNullException("value");
                icon = value;
                DisposeRegion();
                ErrorWindow[] array = new ErrorWindow[windows.Values.Count];
                windows.Values.CopyTo(array, 0);
                for (int i = 0; i < array.Length; i++)
                    array[i].Update();
            }
        }

        /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.Region"]/*' />
        /// <devdoc>
        ///     Create the icon region on demand.
        /// </devdoc>
        /// <internalonly/>
        internal IconRegion Region {
            get {
                if (region == null)
                    region = new IconRegion(Icon);
                return region;
            }
        }

        //
        // METHODS
        //

        /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.CanExtend"]/*' />
        /// <devdoc>
        ///     Returns whether a control can be extended.
        /// </devdoc>
        public bool CanExtend(object extendee) {
            return extendee is Control && !(extendee is Form) && !(extendee is ToolBar);
        }

        /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.Dispose"]/*' />
        /// <devdoc>
        ///     Release any resources that this component is using.  After calling Dispose,
        ///     the component should no longer be used.
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                ErrorWindow[] w = new ErrorWindow[windows.Values.Count];
                windows.Values.CopyTo(w, 0);
                for (int i = 0; i < w.Length; i++) w[i].Dispose();
                windows.Clear();
                items.Clear();
                DisposeRegion();
            }
            base.Dispose(disposing);
        }

        /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.DisposeRegion"]/*' />
        /// <devdoc>
        ///     Helper to dispose the cached icon region.
        /// </devdoc>
        /// <internalonly/>
        void DisposeRegion() {
            if (region != null) {
                region.Dispose();
                region = null;
            }
        }

        /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.EnsureControlItem"]/*' />
        /// <devdoc>
        ///     Helper to make sure we have allocated a control item for this control.
        /// </devdoc>
        /// <internalonly/>
        private ControlItem EnsureControlItem(Control control) {
            if (control == null)
                throw new ArgumentNullException("control");
            ControlItem item = (ControlItem)items[control];
            if (item == null) {
                item = new ControlItem(this, control, (IntPtr)(++itemIdCounter));
                items[control] = item;
            }
            return item;
        }

        /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.EnsureErrorWindow"]/*' />
        /// <devdoc>
        ///     Helper to make sure we have allocated an error window for this control.
        /// </devdoc>
        /// <internalonly/>
        internal ErrorWindow EnsureErrorWindow(Control parent) {
            ErrorWindow window = (ErrorWindow)windows[parent];
            if (window == null) {
                window = new ErrorWindow(this, parent);
                windows[parent] = window;
            }
            return window;
        }

        /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.GetError"]/*' />
        /// <devdoc>
        ///     Returns the current error description string for the specified control.
        /// </devdoc>
        [
        DefaultValue(""),
        Localizable(true),
        SRCategory(SR.CatAppearance),
        SRDescription(SR.ErrorProviderErrorDescr)
        ]
        public string GetError(Control control) {
            return EnsureControlItem(control).Error;
        }

        /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.GetIconAlignment"]/*' />
        /// <devdoc>
        ///     Returns where the error icon should be placed relative to the control.
        /// </devdoc>
        [
        DefaultValue(defaultIconAlignment),
        Localizable(true),
        SRCategory(SR.CatAppearance),
        SRDescription(SR.ErrorProviderIconAlignmentDescr)
        ]
        public ErrorIconAlignment GetIconAlignment(Control control) {
            return EnsureControlItem(control).IconAlignment;
        }

        /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.GetIconPadding"]/*' />
        /// <devdoc>
        ///     Returns the amount of extra space to leave next to the error icon.
        /// </devdoc>
        [
        DefaultValue(0),
        Localizable(true),
        SRCategory(SR.CatAppearance),
        SRDescription(SR.ErrorProviderIconPaddingDescr)
        ]
        public int GetIconPadding(Control control) {
            return EnsureControlItem(control).IconPadding;
        }

        /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.SetError"]/*' />
        /// <devdoc>
        ///     Sets the error description string for the specified control.
        /// </devdoc>
        public void SetError(Control control, string value) {
            EnsureControlItem(control).Error = value;
        }

        /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.SetIconAlignment"]/*' />
        /// <devdoc>
        ///     Sets where the error icon should be placed relative to the control.
        /// </devdoc>
        public void SetIconAlignment(Control control, ErrorIconAlignment value) {
            EnsureControlItem(control).IconAlignment = value;
        }

        /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.SetIconPadding"]/*' />
        /// <devdoc>
        ///     Sets the amount of extra space to leave next to the error icon.
        /// </devdoc>
        public void SetIconPadding(Control control, int padding) {
            EnsureControlItem(control).IconPadding = padding;
        }

        private bool ShouldSerializeIcon() {
            return Icon != DefaultIcon;
        }

        /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.ErrorWindow"]/*' />
        /// <devdoc>
        ///     There is one ErrorWindow for each control parent.  It is parented to the
        ///     control parent.  The window's region is made up of the regions from icons
        ///     of all child icons.  The window's size is the enclosing rectangle for all
        ///     the regions.  A tooltip window is created as a child of this window.  The
        ///     rectangle associated with each error icon being displayed is added as a
        ///     tool to the tooltip window.
        /// </devdoc>
        /// <internalonly/>
        internal class ErrorWindow : NativeWindow {

            //
            // FIELDS
            //

            ArrayList items = new ArrayList();
            Control parent;
            ErrorProvider provider;
            Rectangle windowBounds = Rectangle.Empty;
            System.Windows.Forms.Timer timer;
            NativeWindow tipWindow;

            //
            // CONSTRUCTORS
            //

            /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.ErrorWindow.ErrorWindow"]/*' />
            /// <devdoc>
            ///     Construct an error window for this provider and control parent.
            /// </devdoc>
            public ErrorWindow(ErrorProvider provider, Control parent) {
                this.provider = provider;
                this.parent = parent;
            }

            //
            // METHODS
            //

            /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.ErrorWindow.Add"]/*' />
            /// <devdoc>
            ///     This is called when a control would like to show an error icon.
            /// </devdoc>
            public void Add(ControlItem item) {
                items.Add(item);
                EnsureCreated();

                NativeMethods.TOOLINFO_T toolInfo = new NativeMethods.TOOLINFO_T();
                toolInfo.cbSize = Marshal.SizeOf(toolInfo);
                toolInfo.hwnd = Handle;
                toolInfo.uId = item.Id;
                toolInfo.lpszText = item.Error;
                toolInfo.uFlags = NativeMethods.TTF_SUBCLASS;
                UnsafeNativeMethods.SendMessage(new HandleRef(tipWindow, tipWindow.Handle), NativeMethods.TTM_ADDTOOL, 0, toolInfo);

                Update();
            }

            /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.ErrorWindow.Dispose"]/*' />
            /// <devdoc>
            ///     Called to get rid of any resources the Object may have.
            /// </devdoc>
            public void Dispose() {
                EnsureDestroyed();
            }

            /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.ErrorWindow.EnsureCreated"]/*' />
            /// <devdoc>
            ///     Make sure the error window is created, and the tooltip window is created.
            /// </devdoc>
            void EnsureCreated() {
                if (Handle == IntPtr.Zero) {
                    CreateParams cparams = new CreateParams();
                    cparams.Caption = "";
                    cparams.Style = NativeMethods.WS_VISIBLE | NativeMethods.WS_CHILD;
                    cparams.ClassStyle = NativeMethods.CS_DBLCLKS;
                    cparams.X = 0;
                    cparams.Y = 0;
                    cparams.Width = 0;
                    cparams.Height = 0;
                    cparams.Parent = parent.Handle;
                    CreateHandle(cparams);

                    NativeMethods.INITCOMMONCONTROLSEX icc = new NativeMethods.INITCOMMONCONTROLSEX();
                    icc.dwICC = NativeMethods.ICC_TAB_CLASSES;
                    icc.dwSize = Marshal.SizeOf(icc);
                    SafeNativeMethods.InitCommonControlsEx(icc);
                    cparams = new CreateParams();
                    cparams.Parent = Handle;
                    cparams.ClassName = NativeMethods.TOOLTIPS_CLASS;
                    cparams.Style = NativeMethods.TTS_ALWAYSTIP;
                    tipWindow = new NativeWindow();
                    tipWindow.CreateHandle(cparams);

                    UnsafeNativeMethods.SendMessage(new HandleRef(tipWindow, tipWindow.Handle), NativeMethods.TTM_SETMAXTIPWIDTH, 0, SystemInformation.MaxWindowTrackSize.Width);
                    SafeNativeMethods.SetWindowPos(new HandleRef(tipWindow, tipWindow.Handle), NativeMethods.HWND_TOPMOST, 0, 0, 0, 0, NativeMethods.SWP_NOSIZE | NativeMethods.SWP_NOMOVE | NativeMethods.SWP_NOACTIVATE);
                    UnsafeNativeMethods.SendMessage(new HandleRef(tipWindow, tipWindow.Handle), NativeMethods.TTM_SETDELAYTIME, NativeMethods.TTDT_INITIAL, 0);
                }
            }

            /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.ErrorWindow.EnsureDestroyed"]/*' />
            /// <devdoc>
            ///     Destroy the timer, toolwindow, and the error window itself.
            /// </devdoc>
            void EnsureDestroyed() {
                if (timer != null) {
                    timer.Dispose();
                    timer = null;
                }
                if (tipWindow != null) {
                    tipWindow.DestroyHandle();
                    tipWindow = null;
                }

                // Hide the window and invalidate the parent to ensure
                // that we leave no visual artifacts... given that we
                // have a bizare region window, this is needed.
                //
                SafeNativeMethods.SetWindowPos(new HandleRef(this, Handle), 
                                               NativeMethods.HWND_TOP, 
                                               windowBounds.X, 
                                               windowBounds.Y,
                                               windowBounds.Width, 
                                               windowBounds.Height, 
                                               NativeMethods.SWP_HIDEWINDOW 
                                               | NativeMethods.SWP_NOSIZE  
                                               | NativeMethods.SWP_NOMOVE);
                if (parent != null) {
                    parent.Invalidate(true);
                }
                DestroyHandle();
            }

            /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.ErrorWindow.OnPaint"]/*' />
            /// <devdoc>
            ///     This is called when the error window needs to paint.  We paint each icon at it's
            ///     correct location.
            /// </devdoc>
            void OnPaint(ref Message m) {
                NativeMethods.PAINTSTRUCT ps = new NativeMethods.PAINTSTRUCT();
                IntPtr hdc = UnsafeNativeMethods.BeginPaint(new HandleRef(this, Handle), ref ps);
                for (int i = 0; i < items.Count; i++) {
                    ControlItem item = (ControlItem)items[i];
                    Rectangle bounds = item.GetIconBounds(provider.Region.Size);
                    SafeNativeMethods.DrawIconEx(new HandleRef(this, hdc), bounds.X - windowBounds.X, bounds.Y - windowBounds.Y, new HandleRef(provider.Region, provider.Region.IconHandle), bounds.Width, bounds.Height, 0, NativeMethods.NullHandleRef, NativeMethods.DI_NORMAL);
                }
                UnsafeNativeMethods.EndPaint(new HandleRef(this, Handle), ref ps);
            }

            protected override void OnThreadException(Exception e) {
                Application.OnThreadException(e);
            }

            /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.ErrorWindow.OnTimer"]/*' />
            /// <devdoc>
            ///     This is called when an error icon is flashing, and the view needs to be updatd.
            /// </devdoc>
            void OnTimer(Object sender, EventArgs e) {
                int blinkPhase = 0;
                for (int i = 0; i < items.Count; i++)
                    blinkPhase += ((ControlItem)items[i]).BlinkPhase;
                if (blinkPhase == 0 && provider.BlinkStyle != ErrorBlinkStyle.AlwaysBlink) timer.Stop();
                Update();
            }

            /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.ErrorWindow.Remove"]/*' />
            /// <devdoc>
            ///     This is called when a control no longer needs to display an error icon.
            /// </devdoc>
            public void Remove(ControlItem item) {
                items.Remove(item);

                if (tipWindow != null) {
                    NativeMethods.TOOLINFO_T toolInfo = new NativeMethods.TOOLINFO_T();
                    toolInfo.cbSize = Marshal.SizeOf(toolInfo);
                    toolInfo.hwnd = Handle;
                    toolInfo.uId = item.Id;
                    UnsafeNativeMethods.SendMessage(new HandleRef(tipWindow, tipWindow.Handle), NativeMethods.TTM_DELTOOL, 0, toolInfo);
                }

                if (items.Count == 0) {
                    EnsureDestroyed();
                }
                else {
                    Update();
                }
            }

            /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.ErrorWindow.StartBlinking"]/*' />
            /// <devdoc>
            ///     Start the blinking process.  The timer will fire until there are no more
            ///     icons that need to blink.
            /// </devdoc>
            internal void StartBlinking() {
                if (timer == null) {
                    timer = new System.Windows.Forms.Timer();
                    timer.Start();
                    timer.Tick += new EventHandler(OnTimer);
                }
                timer.Interval = provider.BlinkRate;
                timer.Start();
                Update();
            }

            internal void StopBlinking() {
                timer.Stop();
                Update();
            }

            /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.ErrorWindow.Update"]/*' />
            /// <devdoc>
            ///     Move and size the error window, compute and set the window region,
            ///     set the tooltip rectangles and descriptions.  This basically brings
            ///     the error window up to date with the internal data structures.
            /// </devdoc>
            public void Update() {
                IconRegion iconRegion = provider.Region;
                Size size = iconRegion.Size;
                windowBounds = Rectangle.Empty;
                for (int i = 0; i < items.Count; i++) {
                    ControlItem item = (ControlItem)items[i];
                    Rectangle iconBounds = item.GetIconBounds(size);
                    if (windowBounds.IsEmpty)
                        windowBounds = iconBounds;
                    else
                        windowBounds = Rectangle.Union(windowBounds, iconBounds);
                }

                Region windowRegion =  new Region(new Rectangle(0, 0, 0, 0));
                IntPtr windowRegionHandle = IntPtr.Zero;
                try {
                    for (int i = 0; i < items.Count; i++) {
                        ControlItem item = (ControlItem)items[i];
                        Rectangle iconBounds = item.GetIconBounds(size);
                        iconBounds.X -= windowBounds.X;
                        iconBounds.Y -= windowBounds.Y;

                        if ((item.BlinkPhase & 1) == 0 && provider.showIcon) {
                            iconRegion.Region.Translate(iconBounds.X, iconBounds.Y);
                            windowRegion.Union(iconRegion.Region);
                            iconRegion.Region.Translate(-iconBounds.X, -iconBounds.Y);
                        }

                        if (tipWindow != null) {
                            NativeMethods.TOOLINFO_T toolInfo = new NativeMethods.TOOLINFO_T();
                            toolInfo.cbSize = Marshal.SizeOf(toolInfo);
                            toolInfo.hwnd = Handle;
                            toolInfo.uId = item.Id;
                            if (item.BlinkPhase > 0)
                                // do not show anything while the icon is blinking.
                                toolInfo.lpszText = "";
                            else
                                toolInfo.lpszText = item.Error;
                            toolInfo.rect = NativeMethods.RECT.FromXYWH(iconBounds.X, iconBounds.Y, iconBounds.Width, iconBounds.Height);
                            toolInfo.uFlags = NativeMethods.TTF_SUBCLASS;
                            UnsafeNativeMethods.SendMessage(new HandleRef(tipWindow, tipWindow.Handle), NativeMethods.TTM_SETTOOLINFO, 0, toolInfo);
                        }

                        if (item.BlinkPhase > 0) item.BlinkPhase--;

                        if (provider.BlinkStyle == ErrorBlinkStyle.AlwaysBlink)
                            provider.showIcon = !provider.showIcon;
                    }

                    IntPtr dc = UnsafeNativeMethods.GetDC(NativeMethods.NullHandleRef);
                    Graphics graphics = Graphics.FromHdcInternal(dc);
                    try {
                        windowRegionHandle = windowRegion.GetHrgn(graphics);
                    }
                    finally {
                        graphics.Dispose();
                    }
                    UnsafeNativeMethods.ReleaseDC(NativeMethods.NullHandleRef, new HandleRef(null, dc));

                    UnsafeNativeMethods.SetWindowRgn(new HandleRef(this, Handle), new HandleRef(windowRegion, windowRegionHandle), true);
                }
                finally {
                    windowRegion.Dispose();
                    if (windowRegionHandle == IntPtr.Zero)
                        SafeNativeMethods.DeleteObject(new HandleRef(null, windowRegionHandle));
                }

                SafeNativeMethods.SetWindowPos(new HandleRef(this, Handle), NativeMethods.HWND_TOP, windowBounds.X, windowBounds.Y,
                                     windowBounds.Width, windowBounds.Height, NativeMethods.SWP_NOACTIVATE);
                SafeNativeMethods.InvalidateRect(new HandleRef(this, Handle), null, false);
            }

            /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.ErrorWindow.WndProc"]/*' />
            /// <devdoc>
            ///     Called when the error window gets a windows message.
            /// </devdoc>
            protected override void WndProc(ref Message m) {
                switch (m.Msg) {
                    case NativeMethods.WM_ERASEBKGND:
                        break;
                    case NativeMethods.WM_PAINT:
                        OnPaint(ref m);
                        break;
                    default:
                        base.WndProc(ref m);
                        break;
                }
            }
        }

        /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.ControlItem"]/*' />
        /// <devdoc>
        ///     There is one ControlItem for each control that the ErrorProvider is
        ///     is tracking state for.  It contains the values of all the extender
        ///     properties.
        /// </devdoc>
        internal class ControlItem {

            //
            // FIELDS
            //

            string error;
            Control control;
            ErrorWindow window;
            ErrorProvider provider;
            int blinkPhase;
            IntPtr id;
            int iconPadding;
            ErrorIconAlignment iconAlignment;
            const int startingBlinkPhase = 10;          // cause we want to blink 5 times

            //
            // CONSTRUCTORS
            //

            /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.ControlItem.ControlItem"]/*' />
            /// <devdoc>
            ///     Construct the item with it's associated control, provider, and
            ///     a unique ID.  The ID is used for the tooltip ID.
            /// </devdoc>
            public ControlItem(ErrorProvider provider, Control control, IntPtr id) {
                this.iconAlignment = defaultIconAlignment;
                this.error = String.Empty;
                this.id = id;
                this.control = control;
                this.provider = provider;
                this.control.HandleCreated += new EventHandler(OnCreateHandle);
                this.control.HandleDestroyed += new EventHandler(OnDestroyHandle);
                this.control.LocationChanged += new EventHandler(OnBoundsChanged);
                this.control.SizeChanged += new EventHandler(OnBoundsChanged);
                this.control.VisibleChanged += new EventHandler(OnParentVisibleChanged);
                this.control.ParentChanged += new EventHandler(OnParentVisibleChanged);
            }

            //
            // PROPERTIES
            //

            /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.ControlItem.Control"]/*' />
            /// <devdoc>
            ///     Return the control being extended.
            /// </devdoc>
            public Control Control {
                get {
                    return control;
                }
            }

            /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.ControlItem.Id"]/*' />
            /// <devdoc>
            ///     Returns the unique ID for this control.  The ID used as the tooltip ID.
            /// </devdoc>
            public IntPtr Id {
                get {
                    return id;
                }
            }

            /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.ControlItem.BlinkPhase"]/*' />
            /// <devdoc>
            ///     Returns or set the phase of blinking that this control is currently
            ///     in.   If zero, the control is not blinking.  If odd, then the control
            ///     is blinking, but invisible.  If even, the control is blinking and
            ///     currently visible.  Each time the blink timer fires, this value is
            ///     reduced by one (until zero), thus causing the error icon to appear
            ///     or disappear.
            /// </devdoc>
            public int BlinkPhase {
                get {
                    return blinkPhase;
                }
                set {
                    blinkPhase = value;
                }
            }

            /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.ControlItem.IconPadding"]/*' />
            /// <devdoc>
            ///     Returns or sets the icon padding for the control.
            /// </devdoc>
            public int IconPadding {
                get {
                    return iconPadding;
                }
                set {
                    if (iconPadding != value) {
                        iconPadding = value;
                        UpdateWindow();
                    }
                }
            }

            /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.ControlItem.Error"]/*' />
            /// <devdoc>
            ///     Returns or sets the error description string for the control.
            /// </devdoc>
            public string Error {
                get {
                    return error;
                }
                set {
                    if (value == null) value = "";

                    // if the error is the same and the blinkStyle is not AlwaysBlink, then
                    // we should not add the error and not start blinking.
                    if (error.Equals(value) && provider.BlinkStyle != ErrorBlinkStyle.AlwaysBlink) return;
                    bool adding = error.Length == 0;
                    error = value;
                    if (value.Length == 0) {
                        RemoveFromWindow();
                    }
                    else {
                        if (adding) {
                            AddToWindow();
                            // When we get a new error, if the style is set to BlinkIfDifferrentError
                            // then start blinking;
                            if (provider.BlinkStyle == ErrorBlinkStyle.AlwaysBlink || provider.BlinkStyle == ErrorBlinkStyle.BlinkIfDifferentError)
                                StartBlinking();
                        }
                        else {
                            if (provider.BlinkStyle != ErrorBlinkStyle.NeverBlink)
                                StartBlinking();
                            else
                                UpdateWindow();
                        }
                    }
                }
            }

            /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.ControlItem.IconAlignment"]/*' />
            /// <devdoc>
            ///     Returns or sets the location of the error icon for the control.
            /// </devdoc>
            public ErrorIconAlignment IconAlignment {
                get {
                    return iconAlignment;
                }
                set {
                    if (iconAlignment != value) {
                        if (!Enum.IsDefined(typeof(ErrorIconAlignment), value)) {
                            throw new InvalidEnumArgumentException("value", (int)value, typeof(ErrorIconAlignment));
                        }
                        iconAlignment = value;
                        UpdateWindow();
                    }
                }
            }

            /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.ControlItem.GetIconBounds"]/*' />
            /// <devdoc>
            ///     Returns the location of the icon in the same coordinate system as
            ///     the control being extended.  The size passed in is the size of
            ///     the icon.
            /// </devdoc>
            internal Rectangle GetIconBounds(Size size) {
                int x = 0;
                int y = 0;

                switch (IconAlignment) {
                    case ErrorIconAlignment.TopLeft:
                    case ErrorIconAlignment.MiddleLeft:
                    case ErrorIconAlignment.BottomLeft:
                        x = control.Left - size.Width - iconPadding;
                        break;
                    case ErrorIconAlignment.TopRight:
                    case ErrorIconAlignment.MiddleRight:
                    case ErrorIconAlignment.BottomRight:
                        x = control.Right + iconPadding;
                        break;
                }

                switch (IconAlignment) {
                    case ErrorIconAlignment.TopLeft:
                    case ErrorIconAlignment.TopRight:
                        y = control.Top;
                        break;
                    case ErrorIconAlignment.MiddleLeft:
                    case ErrorIconAlignment.MiddleRight:
                        y = control.Top + (control.Height - size.Height) / 2;
                        break;
                    case ErrorIconAlignment.BottomLeft:
                    case ErrorIconAlignment.BottomRight:
                        y = control.Bottom - size.Height;
                        break;
                }

                return new Rectangle(x, y, size.Width, size.Height);
            }

            /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.ControlItem.UpdateWindow"]/*' />
            /// <devdoc>
            ///     If this control's error icon has been added to the error
            ///     window, then update the window state because some property
            ///     has changed.
            /// </devdoc>
            void UpdateWindow() {
                if (window != null) window.Update();
            }

            /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.ControlItem.StartBlinking"]/*' />
            /// <devdoc>
            ///     If this control's error icon has been added to the error
            ///     window, then start blinking the error window.  The blink
            ///     count
            /// </devdoc>
            void StartBlinking() {
                if (window != null) {
                    BlinkPhase = startingBlinkPhase;
                    window.StartBlinking();
                }
            }

            /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.ControlItem.AddToWindow"]/*' />
            /// <devdoc>
            ///     Add this control's error icon to the error window.
            /// </devdoc>
            void AddToWindow() {
                // if we are recreating the control, then add the control.
                if (window == null && (control.Created || control.RecreatingHandle) && control.Visible && control.ParentInternal != null && error.Length > 0) {
                    window = provider.EnsureErrorWindow(control.ParentInternal);
                    window.Add(this);
                }
            }

            /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.ControlItem.RemoveFromWindow"]/*' />
            /// <devdoc>
            ///     Remove this control's error icon from the error window.
            /// </devdoc>
            void RemoveFromWindow() {
                if (window != null) {
                    window.Remove(this);
                    window = null;
                }
            }

            /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.ControlItem.OnBoundsChanged"]/*' />
            /// <devdoc>
            ///     This is called when a property on the control is changed.
            /// </devdoc>
            void OnBoundsChanged(Object sender, EventArgs e) {
                UpdateWindow();
            }
                
            void OnParentVisibleChanged(Object sender, EventArgs e) {
                this.BlinkPhase = 0;
                RemoveFromWindow();
                AddToWindow();
            }

            /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.ControlItem.OnCreateHandle"]/*' />
            /// <devdoc>
            ///     This is called when the control's handle is created.
            /// </devdoc>
            void OnCreateHandle(Object sender, EventArgs e) {
                AddToWindow();
            }

            /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.ControlItem.OnDestroyHandle"]/*' />
            /// <devdoc>
            ///     This is called when the control's handle is destroyed.
            /// </devdoc>
            void OnDestroyHandle(Object sender, EventArgs e) {
                RemoveFromWindow();
            }
        }

        /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.IconRegion"]/*' />
        /// <devdoc>
        ///     This represents the HRGN of icon.  The region is calculate from the icon's mask.
        /// </devdoc>
        internal class IconRegion {

            //
            // FIELDS
            //

            Region region;
            Icon icon;

            //
            // CONSTRUCTORS
            //

            /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.IconRegion.IconRegion"]/*' />
            /// <devdoc>
            ///     Constructor that takes an Icon and extracts it's 16x16 version.
            /// </devdoc>
            public IconRegion(Icon icon) {
                this.icon = new Icon(icon, 16, 16);
            }

            //
            // PROPERTIES
            //

            /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.IconRegion.IconHandle"]/*' />
            /// <devdoc>
            ///     Returns the handle of the icon.
            /// </devdoc>
            public IntPtr IconHandle {
                get {
                    return icon.Handle;
                }
            }

            /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.IconRegion.Region"]/*' />
            /// <devdoc>
            ///     Returns the handle of the region.
            /// </devdoc>
            public Region Region {
                get {
                    if (region == null) {
                        region = new Region(new Rectangle(0,0,0,0));

                        IntPtr mask = IntPtr.Zero;
                        try {
                            Size size = icon.Size;
                            Bitmap bitmap = icon.ToBitmap();
                            bitmap.MakeTransparent();
                            mask = ControlPaint.CreateHBitmapTransparencyMask(bitmap);
                            bitmap.Dispose();

                            int widthInBytes = size.Width / 8;
                            byte[] bits = new byte[widthInBytes * size.Height];
                            SafeNativeMethods.GetBitmapBits(new HandleRef(null, mask), bits.Length, bits);

                            ArrayList rectList = new ArrayList();
                            for (int y = 0; y < size.Height; y++) {
                                for (int x = 0; x < size.Width; x++) {
                                    // see if bit is set in mask.  bits in byte are reversed. 0 is black (set).
                                    if ((bits[y * widthInBytes + x / 8] & (1 << (7 - (x % 8)))) == 0) {
                                        region.Union(new Rectangle(x, y, 1, 1));
                                    }
                                }
                            }
                            region.Intersect(new Rectangle(0, 0, size.Width, size.Height));
                        }
                        finally {
                            if (mask != IntPtr.Zero)
                                SafeNativeMethods.DeleteObject(new HandleRef(null, mask));
                        }
                    }

                    return region;
                }
            }

            /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.IconRegion.Size"]/*' />
            /// <devdoc>
            ///     Return the size of the icon.
            /// </devdoc>
            public Size Size {
                get {
                    return icon.Size;
                }
            }

            //
            // METHODS
            //

            /// <include file='doc\ErrorProvider.uex' path='docs/doc[@for="ErrorProvider.IconRegion.Dispose"]/*' />
            /// <devdoc>
            ///     Release any resources held by this Object.
            /// </devdoc>
            public void Dispose() {
                if (region != null) {
                    region.Dispose();
                    region = null;
                }
                icon.Dispose();
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\fontdialog.cs ===
//------------------------------------------------------------------------------
// <copyright file="FontDialog.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Drawing;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Windows.Forms;
    using System.Security;
    using System.Security.Permissions;

    using Microsoft.Win32;

    /// <include file='doc\FontDialog.uex' path='docs/doc[@for="FontDialog"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents
    ///       a common dialog box that displays a list of fonts that are currently installed
    ///       on
    ///       the system.
    ///    </para>
    /// </devdoc>
    [
    DefaultEvent("Apply"),
    DefaultProperty("Font")
    ]
    public class FontDialog : CommonDialog {
        /// <include file='doc\FontDialog.uex' path='docs/doc[@for="FontDialog.EventApply"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected static readonly object EventApply = new object();

        private const int defaultMinSize = 0;
        private const int defaultMaxSize = 0;

        private int options;
        private Font font;
        private Color color;
        private int minSize = defaultMinSize;
        private int maxSize = defaultMaxSize;
        private bool showColor = false;

        /// <include file='doc\FontDialog.uex' path='docs/doc[@for="FontDialog.FontDialog"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.FontDialog'/>
        ///       class.
        ///    </para>
        /// </devdoc>
        public FontDialog() {
            Reset();
        }

        /// <include file='doc\FontDialog.uex' path='docs/doc[@for="FontDialog.AllowSimulations"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the dialog box allows graphics device interface
        ///       (GDI) font simulations.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(true),
        SRDescription(SR.FnDallowSimulationsDescr)
        ]
        public bool AllowSimulations {
            get {
                return !GetOption(NativeMethods.CF_NOSIMULATIONS);
            }

            set {
                SetOption(NativeMethods.CF_NOSIMULATIONS, !value);
            }
        }

        /// <include file='doc\FontDialog.uex' path='docs/doc[@for="FontDialog.AllowVectorFonts"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the dialog box allows vector font selections.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(true),
        SRDescription(SR.FnDallowVectorFontsDescr)
        ]
        public bool AllowVectorFonts {
            get {
                return !GetOption(NativeMethods.CF_NOVECTORFONTS);
            }

            set {
                SetOption(NativeMethods.CF_NOVECTORFONTS, !value);
            }
        }

        /// <include file='doc\FontDialog.uex' path='docs/doc[@for="FontDialog.AllowVerticalFonts"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether
        ///       the dialog box displays both vertical and horizontal fonts or only
        ///       horizontal fonts.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(true),
        SRDescription(SR.FnDallowVerticalFontsDescr)
        ]
        public bool AllowVerticalFonts {
            get {
                return !GetOption(NativeMethods.CF_NOVERTFONTS);
            }

            set {
                SetOption(NativeMethods.CF_NOVERTFONTS, !value);
            }
        }

        /// <include file='doc\FontDialog.uex' path='docs/doc[@for="FontDialog.AllowScriptChange"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       or sets a value indicating whether the user can change the character set specified
        ///       in the Script combo box to display a character set other than the one
        ///       currently displayed.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(true),
        SRDescription(SR.FnDallowScriptChangeDescr)
        ]
        public bool AllowScriptChange {
            get {
                return !GetOption(NativeMethods.CF_SELECTSCRIPT);
            }

            set {
                SetOption(NativeMethods.CF_SELECTSCRIPT, !value);
            }
        }

        /// <include file='doc\FontDialog.uex' path='docs/doc[@for="FontDialog.Color"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating the selected font color.
        ///    </para>
        /// </devdoc>
        [
        SRDescription(SR.FnDcolorDescr)
        ]
        public Color Color {
            get {
                return color;
            }
            set {
                if (!value.IsEmpty) {
                    color = value;
                }
                else {
                    color = Color.Black;
                }
            }
        }

        /// <include file='doc\FontDialog.uex' path='docs/doc[@for="FontDialog.FixedPitchOnly"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       a value indicating whether the dialog box allows only the selection of fixed-pitch fonts.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(false),
        SRDescription(SR.FnDfixedPitchOnlyDescr)
        ]
        public bool FixedPitchOnly {
            get {
                return GetOption(NativeMethods.CF_FIXEDPITCHONLY);
            }

            set {
                SetOption(NativeMethods.CF_FIXEDPITCHONLY, value);
            }
        }

        /// <include file='doc\FontDialog.uex' path='docs/doc[@for="FontDialog.Font"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating the selected font.
        ///    </para>
        /// </devdoc>
        [
        SRDescription(SR.FnDfontDescr)
        ]
        public Font Font {
            get {
                Font result = font;
                if (result == null)
                    result = Control.DefaultFont;

                float actualSize =  result.SizeInPoints;
                if (minSize != defaultMinSize && actualSize < MinSize)
                    result = new Font(result.FontFamily, MinSize, result.Style, GraphicsUnit.Point);
                if (maxSize != defaultMaxSize && actualSize > MaxSize)
                    result = new Font(result.FontFamily, MaxSize, result.Style, GraphicsUnit.Point);

                return result;
            }
            set {
                font = value;
            }
        }

        /// <include file='doc\FontDialog.uex' path='docs/doc[@for="FontDialog.FontMustExist"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the dialog box specifies an error condition if the
        ///       user attempts to select a font or style that does not exist.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(false),
        SRDescription(SR.FnDfontMustExistDescr)
        ]
        public bool FontMustExist {
            get {
                return GetOption(NativeMethods.CF_FORCEFONTEXIST);
            }

            set {
                SetOption(NativeMethods.CF_FORCEFONTEXIST, value);
            }
        }

        /// <include file='doc\FontDialog.uex' path='docs/doc[@for="FontDialog.MaxSize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the maximum
        ///       point size a user can select.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(defaultMaxSize),
        SRDescription(SR.FnDmaxSizeDescr)
        ]
        public int MaxSize {
            get {
                return maxSize;
            }
            set {
                if (value < 0) {
                    value = 0;
                }
                maxSize = value;

                if (maxSize > 0 && maxSize < minSize) {
                    minSize = maxSize;
                }
            }
        }

        /// <include file='doc\FontDialog.uex' path='docs/doc[@for="FontDialog.MinSize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating the minimum point size a user can select.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(defaultMinSize),
        SRDescription(SR.FnDminSizeDescr)
        ]
        public int MinSize {
            get {
                return minSize;
            }
            set {
                if (value < 0) {
                    value = 0;
                }
                minSize = value;

                if (maxSize > 0 && maxSize < minSize) {
                    maxSize = minSize;
                }
            }
        }

        /// <include file='doc\FontDialog.uex' path='docs/doc[@for="FontDialog.Options"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Gets the value passed to CHOOSEFONT.Flags.
        ///    </para>
        /// </devdoc>
        protected int Options {
            get {
                return options;
            }
        }

        /// <include file='doc\FontDialog.uex' path='docs/doc[@for="FontDialog.ScriptsOnly"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a
        ///       value indicating whether the dialog box allows selection of fonts for all non-OEM and Symbol character
        ///       sets, as well as the American National Standards Institute (ANSI) character set.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(false),
        SRDescription(SR.FnDscriptsOnlyDescr)
        ]
        public bool ScriptsOnly {
            get {
                return GetOption(NativeMethods.CF_SCRIPTSONLY);
            }
            set {
                SetOption(NativeMethods.CF_SCRIPTSONLY, value);
            }
        }

        /// <include file='doc\FontDialog.uex' path='docs/doc[@for="FontDialog.ShowApply"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the dialog box contains an Apply button.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(false),
        SRDescription(SR.FnDshowApplyDescr)
        ]
        public bool ShowApply {
            get {
                return GetOption(NativeMethods.CF_APPLY);
            }
            set {
                SetOption(NativeMethods.CF_APPLY, value);
            }
        }

        /// <include file='doc\FontDialog.uex' path='docs/doc[@for="FontDialog.ShowColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the dialog box displays the color choice.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(false),
        SRDescription(SR.FnDshowColorDescr)
        ]
        public bool ShowColor {
            get {
                return showColor;
            }
            set {
                this.showColor = value;
            }
        }

        /// <include file='doc\FontDialog.uex' path='docs/doc[@for="FontDialog.ShowEffects"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the dialog box contains controls that allow the
        ///       user to specify strikethrough, underline, and text color options.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(true),
        SRDescription(SR.FnDshowEffectsDescr)
        ]
        public bool ShowEffects {
            get {
                return GetOption(NativeMethods.CF_EFFECTS);
            }
            set {
                SetOption(NativeMethods.CF_EFFECTS, value);
            }
        }

        /// <include file='doc\FontDialog.uex' path='docs/doc[@for="FontDialog.ShowHelp"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the dialog box displays a Help button.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(false),
        SRDescription(SR.FnDshowHelpDescr)
        ]
        public bool ShowHelp {
            get {
                return GetOption(NativeMethods.CF_SHOWHELP);
            }
            set {
                SetOption(NativeMethods.CF_SHOWHELP, value);
            }
        }

        /// <include file='doc\FontDialog.uex' path='docs/doc[@for="FontDialog.Apply"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs when the user clicks the Apply button in the font
        ///       dialog box.
        ///    </para>
        /// </devdoc>
        [SRDescription(SR.FnDapplyDescr)]
        public event EventHandler Apply {
            add {
                Events.AddHandler(EventApply, value);
            }
            remove {
                Events.RemoveHandler(EventApply, value);
            }
        }

        /// <include file='doc\FontDialog.uex' path='docs/doc[@for="FontDialog.GetOption"]/*' />
        /// <devdoc>
        ///     Returns the state of the given option flag.
        /// </devdoc>
        /// <internalonly/>
        internal bool GetOption(int option) {
            return(options & option) != 0;
        }

        /// <include file='doc\FontDialog.uex' path='docs/doc[@for="FontDialog.HookProc"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies the common dialog box hook procedure that is overridden to add
        ///       specific functionality to a common dialog box.
        ///    </para>
        /// </devdoc>
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)] 
        protected override IntPtr HookProc(IntPtr hWnd, int msg, IntPtr wparam, IntPtr lparam) {
            
            switch (msg) {
                case NativeMethods.WM_COMMAND:
                    if ((int)wparam == 0x402) {
                        NativeMethods.LOGFONT lf = new NativeMethods.LOGFONT();
                        UnsafeNativeMethods.SendMessage(new HandleRef(null, hWnd), NativeMethods.WM_CHOOSEFONT_GETLOGFONT, 0, lf);
                        UpdateFont(lf);
                        int index = (int)UnsafeNativeMethods.SendDlgItemMessage(new HandleRef(null, hWnd), 0x473, NativeMethods.CB_GETCURSEL, IntPtr.Zero, IntPtr.Zero);
                        if (index != NativeMethods.CB_ERR) {
                            UpdateColor((int)UnsafeNativeMethods.SendDlgItemMessage(new HandleRef(null, hWnd), 0x473,
                                                                         NativeMethods.CB_GETITEMDATA, (IntPtr) index, IntPtr.Zero));
                        }
                        try {
                            OnApply(EventArgs.Empty);
                        }
                        catch (Exception e) {
                            Application.OnThreadException(e);
                        }
                    }
                    break;
                case NativeMethods.WM_INITDIALOG:
                    if (!showColor) {
                        IntPtr hWndCtl = UnsafeNativeMethods.GetDlgItem(new HandleRef(null, hWnd), NativeMethods.cmb4);
                        SafeNativeMethods.ShowWindow(new HandleRef(null, hWndCtl), NativeMethods.SW_HIDE);
                        hWndCtl = UnsafeNativeMethods.GetDlgItem(new HandleRef(null, hWnd), NativeMethods.stc4);
                        SafeNativeMethods.ShowWindow(new HandleRef(null, hWndCtl), NativeMethods.SW_HIDE);
                    }
                    break;
            }
            
            return base.HookProc(hWnd, msg, wparam, lparam);
        }

        /// <include file='doc\FontDialog.uex' path='docs/doc[@for="FontDialog.OnApply"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.FontDialog.Apply'/> event.
        ///    </para>
        /// </devdoc>
        protected virtual void OnApply(EventArgs e) {
            EventHandler handler = (EventHandler)Events[EventApply];
            if (handler != null) handler(this, e);
        }

        /// <include file='doc\FontDialog.uex' path='docs/doc[@for="FontDialog.Reset"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Resets all dialog box options to their default values.
        ///    </para>
        /// </devdoc>
        public override void Reset() {
            options = NativeMethods.CF_SCREENFONTS | NativeMethods.CF_EFFECTS;
            font = null;
            color = Color.Black;
            showColor = false;
            minSize = defaultMinSize;
            maxSize = defaultMaxSize;
            SetOption(NativeMethods.CF_TTONLY, true);
        }

        /// <include file='doc\FontDialog.uex' path='docs/doc[@for="FontDialog.RunDialog"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       The actual implementation of running the dialog. Inheriting classes
        ///       should override this if they want to add more functionality, and call
        ///       base.runDialog() if necessary
        ///       
        ///    </para>
        /// </devdoc>
        protected override bool RunDialog(IntPtr hWndOwner) {
            NativeMethods.WndProc hookProcPtr = new NativeMethods.WndProc(this.HookProc);
            NativeMethods.CHOOSEFONT cf = new NativeMethods.CHOOSEFONT();
            IntPtr screenDC = UnsafeNativeMethods.GetDC(NativeMethods.NullHandleRef);
            NativeMethods.LOGFONT lf = new NativeMethods.LOGFONT();

            Graphics graphics = Graphics.FromHdcInternal(screenDC);
            IntSecurity.ObjectFromWin32Handle.Assert();
            try {
                Font.ToLogFont(lf, graphics);
            }
            finally {
                graphics.Dispose();
                CodeAccessPermission.RevertAssert();
            }
            UnsafeNativeMethods.ReleaseDC(NativeMethods.NullHandleRef, new HandleRef(null, screenDC));

            IntPtr logFontPtr = IntPtr.Zero;
            try {
                logFontPtr = Marshal.AllocCoTaskMem(Marshal.SizeOf(typeof(NativeMethods.LOGFONT)));
                Marshal.StructureToPtr(lf, logFontPtr, false);

                cf.lStructSize = Marshal.SizeOf(typeof(NativeMethods.CHOOSEFONT));
                cf.hwndOwner = hWndOwner;
                cf.hDC = IntPtr.Zero;
                cf.lpLogFont = logFontPtr;
                cf.Flags = Options | NativeMethods.CF_INITTOLOGFONTSTRUCT | NativeMethods.CF_ENABLEHOOK;
                if (minSize > 0 || maxSize > 0) {
                    cf.Flags |= NativeMethods.CF_LIMITSIZE;
                }

                //if ShowColor=true then try to draw the sample text in color,
                //if ShowEffects=false then we will draw the sample text in black regardless.
                //(limitation of windows control)
                //
                if (ShowColor || ShowEffects) {
                    cf.rgbColors = ColorTranslator.ToWin32(color);
                }
                else {
                    cf.rgbColors = ColorTranslator.ToWin32(Color.Black);
                }

                cf.lpfnHook = hookProcPtr;
                cf.hInstance = UnsafeNativeMethods.GetModuleHandle(null);
                cf.nSizeMin = minSize;
                if (maxSize == 0) {
                    cf.nSizeMax = Int32.MaxValue;
                }
                else {
                    cf.nSizeMax = maxSize;
                }
                Debug.Assert(cf.nSizeMin <= cf.nSizeMax, "min and max font sizes are the wrong way around");
                if (!SafeNativeMethods.ChooseFont(cf)) return false;


                NativeMethods.LOGFONT lfReturned = null;
                lfReturned = (NativeMethods.LOGFONT)UnsafeNativeMethods.PtrToStructure(logFontPtr, typeof(NativeMethods.LOGFONT));

                if (lfReturned.lfFaceName != null && lfReturned.lfFaceName.Length > 0) {
                    lf = lfReturned;
                    UpdateFont(lf);
                    UpdateColor(cf.rgbColors);
                }

                return true;
            }
            finally {
                if (logFontPtr != IntPtr.Zero)
                    Marshal.FreeCoTaskMem(logFontPtr);
            }
        }

        /// <include file='doc\FontDialog.uex' path='docs/doc[@for="FontDialog.SetOption"]/*' />
        /// <devdoc>
        ///     Sets the given option to the given boolean value.
        /// </devdoc>
        /// <internalonly/>
        internal void SetOption(int option, bool value) {
            if (value) {
                options |= option;
            }
            else {
                options &= ~option;
            }
        }

        /// <include file='doc\FontDialog.uex' path='docs/doc[@for="FontDialog.ShouldSerializeColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates whether the <see cref='System.Windows.Forms.FontDialog.Color'/> property should be persisted.
        ///    </para>
        /// </devdoc>
        private bool ShouldSerializeColor() {
            return !Color.Equals(Color.Black);
        }

        /// <include file='doc\FontDialog.uex' path='docs/doc[@for="FontDialog.ShouldSerializeFont"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates whether the <see cref='System.Windows.Forms.FontDialog.Font'/> property should be
        ///       persisted.
        ///    </para>
        /// </devdoc>
        private bool ShouldSerializeFont() {
            return !Font.Equals(Control.DefaultFont);
        }

        /// <include file='doc\FontDialog.uex' path='docs/doc[@for="FontDialog.ToString"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Retrieves a string that includes the name of the current font selected in
        ///       the dialog box.
        ///       
        ///    </para>
        /// </devdoc>
        public override string ToString() {
            string s = base.ToString();
            return s + ",  Font: " + Font.ToString();
        }

        /// <include file='doc\FontDialog.uex' path='docs/doc[@for="FontDialog.UpdateColor"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private void UpdateColor(int rgb) {
            if (ColorTranslator.ToWin32(color) != rgb) {
                color = ColorTranslator.FromOle(rgb);
            }
        }

        /// <include file='doc\FontDialog.uex' path='docs/doc[@for="FontDialog.UpdateFont"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private void UpdateFont(NativeMethods.LOGFONT lf) {
            IntPtr screenDC = UnsafeNativeMethods.GetDC(NativeMethods.NullHandleRef);
            try {
                Font fontInWorldUnits = null;
                try {
                    IntSecurity.UnmanagedCode.Assert();
                    try {
                        fontInWorldUnits = Font.FromLogFont(lf, screenDC);
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }

                    // The dialog claims its working in points (a device-independent unit),
                    // but actually gives us something in world units (device-dependent).
                    font = ControlPaint.FontInPoints(fontInWorldUnits);
                }
                finally {
                    if (fontInWorldUnits != null) {
                        fontInWorldUnits.Dispose();
                    }
                }
            }
            finally {
                UnsafeNativeMethods.ReleaseDC(NativeMethods.NullHandleRef, new HandleRef(null, screenDC));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\flatstyle.cs ===
//------------------------------------------------------------------------------
// <copyright file="FlatStyle.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;
    /// <include file='doc\FlatStyle.uex' path='docs/doc[@for="FlatStyle"]/*' />
    /// <devdoc>
    ///    <para>Specifies the style of control to display.</para>
    /// </devdoc>
    public enum FlatStyle {
        /// <include file='doc\FlatStyle.uex' path='docs/doc[@for="FlatStyle.Flat"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The control appears flat.
        ///    </para>
        /// </devdoc>
        Flat,
        /// <include file='doc\FlatStyle.uex' path='docs/doc[@for="FlatStyle.Popup"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A control appears flat until the mouse pointer
        ///       moves over
        ///       it, at which point it appears three-dimensional.
        ///    </para>
        /// </devdoc>
        Popup,
        /// <include file='doc\FlatStyle.uex' path='docs/doc[@for="FlatStyle.Standard"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The control appears three-dimensional.
        ///    </para>
        /// </devdoc>
        Standard,
        /// <include file='doc\FlatStyle.uex' path='docs/doc[@for="FlatStyle.System"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The control appears three-dimensional.
        ///    </para>
        /// </devdoc>
        System,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\featuresupport.cs ===
//------------------------------------------------------------------------------
// <copyright file="FeatureSupport.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    using System.Configuration.Assemblies;

    using System.Diagnostics;

    using System;
    using System.Reflection;

    /// <include file='doc\FeatureSupport.uex' path='docs/doc[@for="FeatureSupport"]/*' />
    /// <devdoc>
    /// <para>Provides <see langword='static'/> methods for retrieving feature information from the
    ///    current system.</para>
    /// </devdoc>
    public abstract class FeatureSupport : IFeatureSupport {

        /// <include file='doc\FeatureSupport.uex' path='docs/doc[@for="FeatureSupport.IsPresent"]/*' />
        /// <devdoc>
        ///    <para>Determines whether any version of the specified feature
        ///       is installed in the system. This method is <see langword='static'/>.</para>
        /// </devdoc>
        public static bool IsPresent(string featureClassName, string featureConstName) {
            return IsPresent(featureClassName, featureConstName, new Version(0, 0, 0, 0));
        }

        /// <include file='doc\FeatureSupport.uex' path='docs/doc[@for="FeatureSupport.IsPresent1"]/*' />
        /// <devdoc>
        ///    <para>Determines whether the specified or newer version of the specified feature is
        ///       installed in the system. This method is <see langword='static'/>.</para>
        /// </devdoc>
        public static bool IsPresent(string featureClassName, string featureConstName, Version minimumVersion) {
            object featureId = null;
            IFeatureSupport featureSupport = null;

            Type c = Type.GetType(featureClassName);
            if (c != null) {
                FieldInfo fi = c.GetField(featureConstName);

                if (fi != null) {
                    featureId = fi.GetValue(null);
                }
            }

            if (featureId != null) {
                featureSupport = (IFeatureSupport)Activator.CreateInstance(c);

                if (featureSupport != null) {
                    return featureSupport.IsPresent(featureId, minimumVersion);
                }
            }
            return false;
        }

        /// <include file='doc\FeatureSupport.uex' path='docs/doc[@for="FeatureSupport.GetVersionPresent"]/*' />
        /// <devdoc>
        ///    <para>Gets the version of the specified feature that is available on the system.</para>
        /// </devdoc>
        public static Version GetVersionPresent(string featureClassName, string featureConstName) {
            object featureId = null;
            IFeatureSupport featureSupport = null;

            Type c = Type.GetType(featureClassName);
            if (c != null) {
                FieldInfo fi = c.GetField(featureConstName);

                if (fi != null) {
                    featureId = fi.GetValue(null);
                }
            }

            if (featureId != null) {
                featureSupport = (IFeatureSupport)Activator.CreateInstance(c);

                if (featureSupport != null) {
                    return featureSupport.GetVersionPresent(featureId);
                }
            }
            return null;
        }

        /// <include file='doc\FeatureSupport.uex' path='docs/doc[@for="FeatureSupport.IsPresent2"]/*' />
        /// <devdoc>
        ///    <para>Determines whether any version of the specified feature
        ///       is installed in the system.</para>
        /// </devdoc>
        public virtual bool IsPresent(object feature) {
            return IsPresent(feature, new Version(0, 0, 0, 0));
        }

        /// <include file='doc\FeatureSupport.uex' path='docs/doc[@for="FeatureSupport.IsPresent3"]/*' />
        /// <devdoc>
        ///    <para>Determines whether the specified or newer version of the
        ///       specified feature is installed in the system.</para>
        /// </devdoc>
        public virtual bool IsPresent(object feature, Version minimumVersion) {
            Version ver = GetVersionPresent(feature);

            if (ver != null) {
                return ver.CompareTo(minimumVersion) >= 0;
            }
            return false;
        }

        /// <include file='doc\FeatureSupport.uex' path='docs/doc[@for="FeatureSupport.GetVersionPresent1"]/*' />
        /// <devdoc>
        ///    <para>When overridden in a derived class, gets the version of the specified
        ///       feature that is available on the system.</para>
        /// </devdoc>
        public abstract Version GetVersionPresent(object feature);
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\filedialog.cs ===
//------------------------------------------------------------------------------
// <copyright file="FileDialog.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    using System.Text;
    using System.Threading;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;

    using System.Diagnostics;

    using System;
    using System.Security.Permissions;
    using System.Drawing;
    using System.ComponentModel;
    using System.Windows.Forms;
    using System.IO;
    using ArrayList = System.Collections.ArrayList;

    using Encoding = System.Text.Encoding;
    using Microsoft.Win32;
    using System.Security;
    using CharBuffer = System.Windows.Forms.NativeMethods.CharBuffer;

    /// <include file='doc\FileDialog.uex' path='docs/doc[@for="FileDialog"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Displays a dialog window from which the user can select a file.
    ///    </para>
    /// </devdoc>
    [
    DefaultEvent("FileOk"),
    DefaultProperty("FileName")
    ]
    public abstract class FileDialog : CommonDialog {

        private const int FILEBUFSIZE = 8192;

        /// <include file='doc\FileDialog.uex' path='docs/doc[@for="FileDialog.EventFileOk"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        /// <internalonly/>
        protected static readonly object EventFileOk = new object();

        internal const int OPTION_ADDEXTENSION = unchecked(unchecked((int)0x80000000));

        internal int options;

        private string title;
        private string initialDir;
        private string defaultExt;
        private string[] fileNames;
        private string filter;
        private int filterIndex;
        private CharBuffer charBuffer;
        private IntPtr dialogHWnd;

        /// <include file='doc\FileDialog.uex' path='docs/doc[@for="FileDialog.FileDialog"]/*' />
        /// <devdoc>
        ///    <para>
        ///       In an inherited class,
        ///       initializes a new instance of the <see cref='System.Windows.Forms.FileDialog'/>
        ///       class.
        ///    </para>
        /// </devdoc>
        internal FileDialog() {
            Reset();
        }

        /// <include file='doc\FileDialog.uex' path='docs/doc[@for="FileDialog.AddExtension"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the
        ///       dialog box automatically adds an extension to a
        ///       file name if the user omits the extension.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(true),
        SRDescription(SR.FDaddExtensionDescr)
        ]
        public bool AddExtension {
            get {
                return GetOption(OPTION_ADDEXTENSION);
            }

            set {
                Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "FileDialogCustomization Demanded");
                IntSecurity.FileDialogCustomization.Demand();
                SetOption(OPTION_ADDEXTENSION, value);
            }
        }

        /// <include file='doc\FileDialog.uex' path='docs/doc[@for="FileDialog.CheckFileExists"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value indicating whether
        ///       the dialog box displays a warning if the user specifies a file name that does not exist.</para>
        /// </devdoc>
        [
        DefaultValue(false),
        SRDescription(SR.FDcheckFileExistsDescr)
        ]
        public virtual bool CheckFileExists {
            get {
                return GetOption(NativeMethods.OFN_FILEMUSTEXIST);
            }

            set {
                Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "FileDialogCustomization Demanded");
                IntSecurity.FileDialogCustomization.Demand();
                SetOption(NativeMethods.OFN_FILEMUSTEXIST, value);
            }
        }

        /// <include file='doc\FileDialog.uex' path='docs/doc[@for="FileDialog.CheckPathExists"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the
        ///       dialog box displays a warning if the user specifies a path that does not exist.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(true),
        SRDescription(SR.FDcheckPathExistsDescr)
        ]
        public bool CheckPathExists {
            get {
                return GetOption(NativeMethods.OFN_PATHMUSTEXIST);
            }

            set {
                Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "FileDialogCustomization Demanded");
                IntSecurity.FileDialogCustomization.Demand();
                SetOption(NativeMethods.OFN_PATHMUSTEXIST, value);
            }
        }

        /// <include file='doc\FileDialog.uex' path='docs/doc[@for="FileDialog.DefaultExt"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the default file extension.
        ///       
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(""),
        SRDescription(SR.FDdefaultExtDescr)
        ]
        public string DefaultExt {
            get {
                return defaultExt == null? "": defaultExt;
            }

            set {
                if (value != null) {
                    if (value.StartsWith("."))
                        value = value.Substring(1);
                    else if (value.Length == 0)
                        value = null;
                }
                defaultExt = value;
            }
        }

        /// <include file='doc\FileDialog.uex' path='docs/doc[@for="FileDialog.DereferenceLinks"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value
        ///       indicating whether the dialog box returns the location of the file referenced by the shortcut or
        ///       whether it returns the location of the shortcut (.lnk).
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(true),
        SRDescription(SR.FDdereferenceLinksDescr)
        ]
        public bool DereferenceLinks {
            get { 
                return !GetOption(NativeMethods.OFN_NODEREFERENCELINKS);
            }
            set { 
                Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "FileDialogCustomization Demanded");
                IntSecurity.FileDialogCustomization.Demand();
                SetOption(NativeMethods.OFN_NODEREFERENCELINKS, !value);
            }
        }

        internal string DialogCaption {
            get {
                int textLen = SafeNativeMethods.GetWindowTextLength(new HandleRef(this, dialogHWnd));
                StringBuilder sb = new StringBuilder(textLen+1);
                UnsafeNativeMethods.GetWindowText(new HandleRef(this, dialogHWnd), sb, sb.Capacity);
                return sb.ToString();
            }
        }

        /// <include file='doc\FileDialog.uex' path='docs/doc[@for="FileDialog.FileName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       or sets a string containing
        ///       the file name selected in the file dialog box.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(""),
        SRDescription(SR.FDfileNameDescr)
        ]
        public string FileName {
            get {
                if (fileNames == null) {
                    return "";
                }
                else {
                    if (fileNames[0].Length > 0) {
                        Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "FileIO(" + fileNames[0] + ") Demanded");
                        IntSecurity.DemandFileIO(FileIOPermissionAccess.AllAccess, fileNames[0]);

                        return fileNames[0];
                    }
                    else {
                        return "";
                    }
                }
            }
            set {
                Debug.WriteLineI